****************************************************************************

Copyright (c) 2002 Microsoft Corporation

Module Name:
    safelib.cpp

Abstract:
    Implements LoadLibraryFromSystemDir function

******************************************************************************/

#include "stdafx.h"


// **************************************************************************
static 
BOOL UseFullPath(void)
{
    static BOOL s_fUseFullPath = TRUE;
    static BOOL s_fInit        = FALSE;

    OSVERSIONINFO   osvi;

    if (s_fInit)
        return s_fUseFullPath;

    ZeroMemory(&osvi, sizeof(osvi));
    osvi.dwOSVersionInfoSize = sizeof(osvi);

    if (GetVersionEx(&osvi))
    {
        if (osvi.dwPlatformId == VER_PLATFORM_WIN32_NT &&
            (osvi.dwMajorVersion > 5 ||
             (osvi.dwMajorVersion == 5 && osvi.dwMinorVersion >= 1)))
        {
            s_fUseFullPath = FALSE;
        }

        s_fInit = TRUE;
    }

    return s_fUseFullPath;
}

// **************************************************************************
HMODULE WINAPI LoadLibraryFromSystemDir(LPCTSTR szModule)
{
    HRESULT hr = NOERROR;
    HMODULE hmod = NULL;
    TCHAR   szModulePath[MAX_PATH + 1];

    if (szModule == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto done;
    }

    if (UseFullPath())
    {
        DWORD cch;

        // if the function call fails, make the buffer an empty string, so 
        //  we will just use the dll name in the append below.
        cch = GetSystemDirectory(szModulePath, ARRAYSIZE(szModulePath));
        if (cch == 0 || cch >= ARRAYSIZE(szModulePath))
            szModulePath[0] = _T('\0');
    }
    else
    {
        szModulePath[0] = _T('\0');
    }

    hr = PathCchAppend(szModulePath, ARRAYSIZE(szModulePath), szModule);
    if (FAILED(hr))
    {
        SetLastError(HRESULT_CODE(hr));
        goto done;
    }

    hmod = LoadLibraryEx(szModulePath, NULL, 0);
    if (hmod == NULL)
        goto done;

done:
    return hmod;    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\lib\util\stringutil.cpp ===
//=======================================================================
//
//  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:   StringUtil.CPP
//
//  Description:
//
//      IU string utility library
//
//=======================================================================

#include <windows.h>
#include <tchar.h>
#include <stringutil.h>
#include <memutil.h>
#include <shlwapi.h>
#include<iucommon.h>
#include<MISTSAFE.h>


#define	IfNullReturnNull(ptr)		if (NULL == ptr) return NULL;

// ----------------------------------------------------------------------
//
// Public function StrChr() - same as shlwapi StrChr()
//		Searches a string for the first occurrence of a character that
//		matches the specified character. The comparison is case sensitive.
//
//	Input: 
//		lpStart - Address of the string to be searched
//		wMatch - Character to be used for comparison
//
//	Return:
//		Returns the address of the first occurrence of the character in 
//		the string if successful, or NULL otherwise.
//
// ----------------------------------------------------------------------
LPCTSTR MyStrChr(LPCTSTR lpStart, const TCHAR wMatch)
{
	LPCTSTR lpPtr = lpStart;

	IfNullReturnNull(lpStart);
	
	while (_T('\0') != *lpPtr && wMatch != *lpPtr)
	{
		lpPtr = CharNext(lpPtr);
	}

	return (_T('\0') != *lpPtr) ? lpPtr : NULL;
}

// ----------------------------------------------------------------------
//
// Public function StrRChr() - same as shlwapi StrRChr()
//		Searches a string for the last occurrence of a character that
//		matches the specified character. The comparison is case sensitive.
//
//	Input: 
//		lpStart - Address of the string to be searched
//      lpEnd - Address of the end of the string (NOT included in the search)
//		wMatch - Character to be used for comparison
//
//	Return:
//		Returns the address of the last occurrence of the character in 
//		the string if successful, or NULL otherwise.
//
// ----------------------------------------------------------------------
LPCTSTR MyStrRChr(LPCTSTR lpStart, LPCTSTR lpEnd, const TCHAR wMatch)
{
    LPCTSTR lpFound = NULL;

    IfNullReturnNull(lpStart);

    if (NULL == lpEnd)
        lpEnd = lpStart + lstrlen(lpStart);

    LPCTSTR lpPtr = lpEnd;
    while (lpPtr > lpStart)
    {
        if (*lpPtr == wMatch)
            break;

        lpPtr = CharPrev(lpStart, lpPtr);
    }
	if (lpStart == lpPtr)
	{
		return (*lpStart == wMatch) ? lpStart : NULL;
	}
	else
	{
		return (lpPtr > lpStart) ? lpPtr : NULL;
	}
}


// ----------------------------------------------------------------------
//
// Public function StrChrI() - same as shlwapi StrChrI()
//		Searches a string for the first occurrence of a character that
//		matches the specified character. The comparison is case INsensitive.
//
//	Input: 
//		lpStart - Address of the string to be searched
//		wMatch - Character to be used for comparison
//
//	Return:
//		Returns the address of the first occurrence of the character in 
//		the string if successful, or NULL otherwise.
//
// ----------------------------------------------------------------------
LPCTSTR MyStrChrI(LPCTSTR lpStart, const TCHAR wMatch)
{
	LPCTSTR	lpPtr;
	LPTSTR	lpBuffer;
	DWORD	dwLength;
	HANDLE	hHeap;

	IfNullReturnNull(lpStart);

	//
	// get buffer to store search string
	//
	hHeap = GetProcessHeap();
	dwLength = lstrlen(lpStart);
	lpBuffer = (LPTSTR) HeapAlloc(
								  GetProcessHeap(), 
								  0, 
								  (dwLength + 1) * sizeof(TCHAR)
								 );

	IfNullReturnNull(lpBuffer);

	//
	// copy the search string to buffer
	//
	

	//The buffer allocated is sufficient to hold the lpStart string. 
	StringCchCopyEx(lpBuffer,dwLength + 1,lpStart,NULL,NULL,MISTSAFE_STRING_FLAGS);



	//
	// based on the case of wMatch, determine how to convert
	// the search string
	//
	if (IsCharUpper(wMatch))
	{
		CharUpperBuff(lpBuffer, dwLength);
	}
	else
	{
		CharLowerBuff(lpBuffer, dwLength);
	}

	//
	// search the char in in new string
	//
	lpPtr = lpBuffer;
	while (_T('\0') != *lpPtr && wMatch != *lpPtr)
	{
		lpPtr = CharNext(lpPtr);
	}

	//
	// map the position to original string, if found.
	//
	lpPtr = (_T('\0') != *lpPtr) ? lpStart + (lpPtr - lpBuffer) : NULL;

	HeapFree(hHeap, 0, lpBuffer); 

	return lpPtr;
}



// ----------------------------------------------------------------------
//
//	Convert a long number content in bstr into long
//	if error, 0 returned.
//
// ----------------------------------------------------------------------
LONG MyBSTR2L(BSTR bstrLongNumber)
{
	USES_IU_CONVERSION;

	LPTSTR lpszNumber = OLE2T(bstrLongNumber);
	
	return StrToInt(lpszNumber);
}



// ----------------------------------------------------------------------
//
//	Convert a a long number into bstr
//
// ----------------------------------------------------------------------
BSTR MyL2BSTR(LONG lNumber)
{
	USES_IU_CONVERSION;
	WCHAR sNumber[32];
	
	
	StringCchPrintfExW(sNumber,ARRAYSIZE(sNumber),NULL,NULL,MISTSAFE_STRING_FLAGS,L"%ld", lNumber);

	return SysAllocString(sNumber);
}


BSTR MyUL2BSTR(ULONG ulNumber)
{
	USES_IU_CONVERSION;
	WCHAR sNumber[32];

	
	StringCchPrintfExW(sNumber,ARRAYSIZE(sNumber),NULL,NULL,MISTSAFE_STRING_FLAGS,L"%lu", ulNumber);
	return SysAllocString(sNumber);
}






// ----------------------------------------------------------------------
//
// Compare a binary buffer with a string, where data in the string
// has format:
//
//		<String>	::= <Number> [<Space><String>]
//		<Space>		::= TCHAR(' ')
//		<Number>	::= 0x<HexValue>|x<HexValue>|<Decimal>
//		<Decimal>	::= +<DecimalValue>|-<DecimalValue>
//		<DecimalValue> ::= <DecimalDigit>|<DecimalDigit><DecimalValue>
//		<DecimalDegit> ::= 0|1|2|3|4|5|6|7|8|9
//		<HexValue>	::= <HexDigit>|<HexDigit><HexDigit>
//		<HexDigit>	::= <DecimalDigit>|A|B|C|D|E|F
//
//	example of strings that this function recognize:
//		"12 0 45 0x1F"
//
//	Return: similar to lstrcmp() API, each byte is compared
//			as unsigned short
//			if binary > string, +1
//			if binary = string, 0
//			if binary < string, -1
//
//  Note:
//		If the string is shorter than binary buffer, i.e., string contains
//		less byte data than the binary buffer contain, we only compare till
//		the number of bytes provided by the string offered. 
//		This request is based on the fact that many v3 data has reg value
//		as DWORD but the update created the value with type binary. so for 
//		string data, e.g., it's "1", for binary data, it's "01 00 00 00" for
//		4 bytes, this function will return 0 meaning equality, per request
//		from aavon for bug 364085 in Whistler RAID.
//
// ----------------------------------------------------------------------
int CmpBinaryToString(
		LPBYTE pBinaryBuffer,		// buffer to contain binary data
		UINT nBinarySize,			// number of bytes this binary has data
		LPCTSTR pstrValue			// string contains data to compare
)
{
	int rc = 0;
	int iNumber;
	UINT nCharCount = nBinarySize;
	LPCTSTR lpNumber = pstrValue;

	if (NULL == pBinaryBuffer)
	{
		if (NULL == pstrValue)
		{
			return 0;	// both NULL
		}
		nBinarySize = 0; // make sure
	}

	if (NULL == pstrValue || _T('\0') == *pstrValue)
	{
		//
		// this is the case that binary not null,
		// but string null.
		// as of lstrcmp(), string 1 > string 2
		//
		return +1;		
	}

	while (nBinarySize > 0)
	{
		if (NULL == lpNumber || _T('\0') == *lpNumber)
		{
			//
			// when binary not done, string done, we don't care the left binary
			// 
			return 0;
		}


		if (!StrToIntEx(lpNumber, STIF_SUPPORT_HEX, &iNumber) ||
			iNumber < 0 || 
			iNumber > 255)
		{
			//
			// found un-convertable number in the 
			// string. or the number if out of range
			// of a byte, treat it invalid, so the
			// binary win
			//
			iNumber = 0x0;
		}

		if ((unsigned short)pBinaryBuffer[nCharCount - nBinarySize]  > (unsigned short) iNumber)
		{
			return +1;

		}
		else if ((unsigned short)pBinaryBuffer[nCharCount - nBinarySize]  < (unsigned short) iNumber)
		{
			//
			// binary is smaller
			//
			return -1;
		}

		//
		// if equal, continue to compare next byte
		//
		nBinarySize--;

		//
		// skip the white spaces before this number
		//
		while (_T('\0') != *lpNumber && 
			   (_T(' ') == *lpNumber ||
			   _T('\t') == *lpNumber ||
			   _T('\r') == *lpNumber ||
			   _T('\n') == *lpNumber)) lpNumber++;
		//
		// try to find the beginning of the next number
		//
		lpNumber = StrChr(lpNumber, _T(' '));
	}

	//
	// these two parameters point to data having same meaning
	//
	return 0;
}


/*
 * FUNCTION:		int atoh(char *ptr)
 * 
 * PURPOSE:			This function converts an hexadecimal string into it's decimal value.
 * 
 * PARAMETERS:
 *
 *		char *ptr:	pointer to string to be converted
 * 
 * RETURNS:			The converted value.
 * 
 * COMMENTS:		Like atoi this function ends the conversion on the first innvalid
 *					hex digit.
 * 
 */
int atoh(LPCSTR ptr)
{
	int		i = 0;
	char	ch;

	//skip 0x if present
	if (NULL == ptr) return 0;
	if ( ptr[0] == '0') ptr++;
	if ( ptr[0] == 'x' || ptr[0] == 'X') ptr++;

	while( 1 )
	{
		ch = (char)toupper(*ptr);
		if ( (ch >= '0' && ch <= '9') || (ch >= 'A' && ch <= 'F') )
		{
			ch -= '0';
			if ( ch > 10 )
				ch -= 7;
			i *= 16;
			i += (int)ch;
			ptr++;
			continue;
		}
		break;
	}
	return i;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\lib\wusafefn\safereg.cpp ===
//
// SafeReg.cpp
//
//		Functions to ensure strings read from the registry are null-terminated.
//
// History:
//
//		2002-03-20  KenSh     Created
//
// Copyright (c) 2002 Microsoft Corporation
//

#include "stdafx.h"
#include "SafeReg.h"


// SafeRegQueryValueCchHelper [private]
//
//		Implementation of both "safe" kinds of string registry reads.
//
static HRESULT SafeRegQueryValueCchHelper
	(
		IN DWORD dwExpectedType,
		IN HKEY hkey,
		IN LPCTSTR pszValueName,
		OUT LPTSTR pszBuf,
		IN int cchBuf,
		OUT OPTIONAL int* pcchValueSize,
		OUT OPTIONAL BOOL* pfExpandSz
	)
{
	HRESULT hr = S_OK;
	int cchValueSize = 0;
	BOOL fExpandSz = FALSE;

	// BLOCK
	{
		if ((!pszBuf && cchBuf != 0) || cchBuf < 0) // note: pszValueName can be null
		{
			hr = E_INVALIDARG;
			goto done;
		}

		DWORD dwType;
		DWORD cbData = cchBuf * sizeof(TCHAR);
		DWORD dwResult = RegQueryValueEx(
							hkey, pszValueName, NULL, &dwType, (LPBYTE)pszBuf, &cbData);
		if (dwResult != ERROR_SUCCESS)
		{
			hr = HRESULT_FROM_WIN32(dwResult);
		}
		else if (!pszBuf && cbData > 0)
		{
			hr = HRESULT_FROM_WIN32(ERROR_MORE_DATA);
		}

		if (SUCCEEDED(hr))
		{
			fExpandSz = (dwType == REG_EXPAND_SZ);

			if ((dwType != dwExpectedType) &&
			    !(dwExpectedType == REG_SZ && dwType == REG_EXPAND_SZ))
			{
				hr = HRESULT_FROM_WIN32(ERROR_DATATYPE_MISMATCH);
			}
		}

		if (hr == HRESULT_FROM_WIN32(ERROR_MORE_DATA))
		{
			// Add 1-2 extra chars in case the registry data is not big enough.
			cchValueSize = cbData / sizeof(TCHAR);
			cchValueSize += (dwExpectedType == REG_MULTI_SZ) ? 2 : 1;
		}
		else if (SUCCEEDED(hr))
		{
			cchValueSize = cbData / sizeof(TCHAR);

			// check for lack of null-termination
			if (cchValueSize == 0 || pszBuf[cchValueSize-1] != _T('\0'))
				cchValueSize++;

			// check for lack of double null-termination (multi-sz only)
			if (dwExpectedType == REG_MULTI_SZ && (cchValueSize < 2 || pszBuf[cchValueSize-2] != _T('\0')))
				cchValueSize++;

			// check for overflow
			if (cchValueSize > cchBuf)
			{
				hr = HRESULT_FROM_WIN32(ERROR_MORE_DATA);
			}
			else
			{
				cchValueSize--;  // when successful, count doesn't include trailing null
				pszBuf[cchValueSize] = _T('\0');

				if (dwExpectedType == REG_MULTI_SZ)
					pszBuf[cchValueSize-1] = _T('\0');
			}
		}
	} // end BLOCK

done:
	if (FAILED(hr) && pszBuf && cchBuf > 0)
		pszBuf[0] = _T('\0');
	if (pcchValueSize)
		*pcchValueSize = cchValueSize;
	if (pfExpandSz)
		*pfExpandSz = fExpandSz;

	return hr;
}


// SafeRegQueryValueCchAllocHelper [private]
//
//		Implementation of the 2 "alloc" versions of the safe reg string functions.
//
HRESULT WINAPI SafeRegQueryValueCchAllocHelper
	(
		IN DWORD dwExpectedType,
		IN HKEY hkey,
		IN LPCTSTR pszValueName,
		OUT LPTSTR* ppszBuf,
		OUT OPTIONAL int* pcchValueSize,
		OUT OPTIONAL BOOL* pfExpandSz
	)
{
	LPTSTR pszResult = NULL;
	int cchValueSize = 0;
	BOOL fExpandSz = FALSE;
	HRESULT hr = E_INVALIDARG;

	// BLOCK
	{
		if (!ppszBuf)
		{
			goto done;  // hr is already E_INVALIDARG
		}

		DWORD cbNeeded = 0;
		DWORD dwErr = RegQueryValueEx(hkey, pszValueName, NULL, NULL, NULL, &cbNeeded);
		if (dwErr != 0 && dwErr != ERROR_MORE_DATA)
		{
			hr = HRESULT_FROM_WIN32(dwErr);
			goto done;
		}

		int cchBuf = (cbNeeded / sizeof(TCHAR)) + 2;
		pszResult = (LPTSTR)SafeRegMalloc(sizeof(TCHAR) * cchBuf);
		if (!pszResult)
		{
			hr = E_OUTOFMEMORY;
			goto done;
		}

		hr = SafeRegQueryValueCchHelper(dwExpectedType, hkey, pszValueName, pszResult, cchBuf, &cchValueSize, &fExpandSz);
	}

done:
	if (FAILED(hr))
	{
		SafeRegFree(pszResult);
		pszResult = NULL;
	}

	if (ppszBuf)
		*ppszBuf = pszResult;
	if (pcchValueSize)
		*pcchValueSize = cchValueSize;
	if (pfExpandSz)
		*pfExpandSz = fExpandSz;

	return hr;
}


// SafeRegQueryStringValueCch [public]
//
//		Reads a string out of the registry and ensures the result is null-
//		terminated. Optionally returns the number of characters retrieved,
//		excluding the trailing null.
//
//		If the buffer is not big enough, the function returns REG_E_MORE_DATA
//		and stores the required size, in characters, in the pcchValueSize
//		parameter (including room for the trailing null). Note that the size
//		returned may be bigger than the actual size of the data in the registry.
//
HRESULT WINAPI SafeRegQueryStringValueCch
	(
		IN HKEY hkey,
		IN LPCTSTR pszValueName,
		OUT LPTSTR pszBuf,
		IN int cchBuf,
		OUT OPTIONAL int* pcchValueSize, // S_OK: chars written, excluding trailing null
		                                 // REG_E_MORE_DATA: required size, including null
		OUT OPTIONAL BOOL* pfExpandSz    // TRUE if reg string is actually REG_EXPAND_SZ
	)
{
	return SafeRegQueryValueCchHelper(REG_SZ, hkey, pszValueName, pszBuf, cchBuf, pcchValueSize, pfExpandSz);
}

HRESULT WINAPI SafeRegQueryStringValueCb
	(
		IN HKEY hkey,
		IN LPCTSTR pszValueName,
		OUT LPTSTR pszBuf,
		IN int cbBuf,
		OUT OPTIONAL int* pcbValueSize, // S_OK: bytes written, excluding trailing null
		                                // REG_E_MORE_DATA: required size, including null
		OUT OPTIONAL BOOL* pfExpandSz   // TRUE if reg string is actually REG_EXPAND_SZ
	)
{
	int cchBuf = cbBuf / sizeof(TCHAR); // note: odd #'s for cbBuf are rounded down
	HRESULT hr = SafeRegQueryValueCchHelper(REG_SZ, hkey, pszValueName, pszBuf, cchBuf, pcbValueSize, pfExpandSz);
	if (pcbValueSize)
		*pcbValueSize *= sizeof(TCHAR);
	return hr;
}


// SafeRegQueryMultiStringValueCch [public]
//
//		Reads a multi-string out of the registry and ensures the result is double
//		null-terminated. Optionally returns the number of characters retrieved,
//		excluding the second trailing NULL.
//
//		If the buffer is not big enough, the function returns REG_E_MORE_DATA
//		and stores the required size, in characters, in the pcchValueSize
//		parameter (including room for the trailing nulls). Note that the size
//		returned may be bigger than the actual size of the data in the registry.
//
HRESULT WINAPI SafeRegQueryMultiStringValueCch
	(
		IN HKEY hkey,
		IN LPCTSTR pszValueName,
		OUT LPTSTR pszBuf,
		IN int cchBuf,
		OUT OPTIONAL int* pcchValueSize // S_OK: chars written, excluding final trailing null
		                                // REG_E_MORE_DATA: required size, including nulls
	)
{
	return SafeRegQueryValueCchHelper(REG_MULTI_SZ, hkey, pszValueName, pszBuf, cchBuf, pcchValueSize, NULL);
}

HRESULT WINAPI SafeRegQueryMultiStringValueCb
	(
		IN HKEY hkey,
		IN LPCTSTR pszValueName,
		OUT LPTSTR pszBuf,
		IN int cbBuf,
		OUT OPTIONAL int* pcbValueSize // S_OK: bytes written, excluding final trailing null
		                               // REG_E_MORE_DATA: required size, including nulls
	)
{
	int cchBuf = cbBuf / sizeof(TCHAR); // note: odd #'s for cbBuf are rounded down
	HRESULT hr = SafeRegQueryValueCchHelper(REG_MULTI_SZ, hkey, pszValueName, pszBuf, cchBuf, pcbValueSize, NULL);
	if (pcbValueSize)
		*pcbValueSize *= sizeof(TCHAR);
	return hr;
}

// SafeRegQueryStringValueCchAlloc [public]
//
//		Allocates room for the registry string via SafeRegMalloc, and returns
//		the resulting string. Caller should free via SafeRegFree.
//
HRESULT WINAPI SafeRegQueryStringValueCchAlloc
	(
		IN HKEY hkey,
		IN LPCTSTR pszValueName,
		OUT LPTSTR* ppszBuf,
		OUT OPTIONAL int* pcchValueSize, // chars written, excluding trailing null
		OUT OPTIONAL BOOL* pfExpandSz    // TRUE if reg string is actually REG_EXPAND_SZ
	)
{
	return SafeRegQueryValueCchAllocHelper(REG_SZ, hkey, pszValueName, ppszBuf, pcchValueSize, pfExpandSz);
}

HRESULT WINAPI SafeRegQueryStringValueCbAlloc
	(
		IN HKEY hkey,
		IN LPCTSTR pszValueName,
		OUT LPTSTR* ppszBuf,
		OUT OPTIONAL int* pcbValueSize, // bytes written, excluding trailing null
		OUT OPTIONAL BOOL* pfExpandSz   // TRUE if reg string is actually REG_EXPAND_SZ
	)
{
	HRESULT hr = SafeRegQueryValueCchAllocHelper(REG_SZ, hkey, pszValueName, ppszBuf, pcbValueSize, pfExpandSz);
	if (pcbValueSize)
		*pcbValueSize *= sizeof(TCHAR);
	return hr;
}

// SafeRegQueryMultiStringValueCchAlloc [public]
//
//		Allocates room for the registry string via SafeRegMalloc, and returns
//		the resulting string. Caller should free via SafeRegFree.
//
HRESULT WINAPI SafeRegQueryMultiStringValueCchAlloc
	(
		IN HKEY hkey,
		IN LPCTSTR pszValueName,
		OUT LPTSTR* ppszBuf,
		OUT OPTIONAL int* pcchValueSize // chars written, excluding final trailing null
	)
{
	return SafeRegQueryValueCchAllocHelper(REG_MULTI_SZ, hkey, pszValueName, ppszBuf, pcchValueSize, NULL);
}

HRESULT WINAPI SafeRegQueryMultiStringValueCbAlloc
	(
		IN HKEY hkey,
		IN LPCTSTR pszValueName,
		OUT LPTSTR* ppszBuf,
		OUT OPTIONAL int* pcbValueSize // bytes written, excluding final trailing null
	)
{
	HRESULT hr = SafeRegQueryValueCchAllocHelper(REG_MULTI_SZ, hkey, pszValueName, ppszBuf, pcbValueSize, NULL);
	if (pcbValueSize)
		*pcbValueSize *= sizeof(TCHAR);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\lib\wusafefn\safepath.cpp ===
/******************************************************************************

Copyright (c) 2002 Microsoft Corporation

Module Name:
    safepath.cpp

Abstract:
    Implements safe path function

******************************************************************************/

#include "stdafx.h"
#include <shlwapi.h>

// We use a little C++ precompiler trick to be able to code both ANSI & Unicode
//  versions of the below functions in the same file with only one copy of the 
//  source code.  This is what all the 'X' suffixes below are doing.  
// During the first pass through the source file, we build ANSI source code. 
//  When we reach the bottom, we define a symbol & #include this source file,
//  causing it to be compiled again.  However, in this second pass, the symbol
//  we defined causes it to be compiled as Unicode.

#undef XCHAR
#undef _X
#undef LPXSTR
#undef LPCXSTR
#undef StringCchCatExX
#undef StringCchCopyExX
#undef StringCchCopyNExX
#undef PathCchAppendX
#undef PathCchCombineX
#undef PathCchAddBackslashX
#undef PathCchAddExtensionX
#undef PathCchRenameExtensionX
#undef PathCchCanonicalizeX
#undef lstrlenX
#undef PathIsRelativeX
#undef PathIsRootX
#undef PathIsUNCX
#undef PathStripToRootX
#undef PathFindExtensionX
#undef StrChrX
#undef StrRChrX
#undef c_szDotExeX
#undef WUGetPCEndX
#undef WUGetPCStartX
#undef WUNearRootFixupsX

#if defined(SAFEPATH_UNICODEPASS)

static const WCHAR c_szDotExeW[] = L".exe";

// define Unicode versions
#define XCHAR                   WCHAR
#define _X(ch)                  L ## ch
#define LPXSTR                  LPWSTR
#define LPCXSTR                 LPCWSTR
#define StringCchCatExX         StringCchCatExW
#define StringCchCopyExX        StringCchCopyExW
#define StringCchCopyNExX       StringCchCopyNExW
#define PathCchAppendX          PathCchAppendW
#define PathCchCombineX         PathCchCombineW
#define PathCchAddBackslashX    PathCchAddBackslashW
#define PathCchAddExtensionX    PathCchAddExtensionW
#define PathCchRenameExtensionX PathCchRenameExtensionW
#define PathCchCanonicalizeX    PathCchCanonicalizeW
#define PathIsRelativeX         PathIsRelativeW
#define PathIsRootX             PathIsRootW
#define PathIsUNCX              PathIsUNCW
#define PathStripToRootX        PathStripToRootW
#define PathFindExtensionX      PathFindExtensionW
#define StrChrX                 StrChrW
#define StrRChrX                StrRChrW
#define lstrlenX                lstrlenW
#define c_szDotExeX             c_szDotExeW
#define WUGetPCEndX             WUGetPCEndW
#define WUGetPCStartX           WUGetPCStartW
#define WUNearRootFixupsX       WUNearRootFixupsW

#else

static const CHAR  c_szDotExeA[] = ".exe";

// define ANSI versions
#define XCHAR                   char
#define _X(ch)                  ch
#define LPXSTR                  LPSTR
#define LPCXSTR                 LPCSTR
#define StringCchCatExX         StringCchCatExA
#define StringCchCopyExX        StringCchCopyExA
#define StringCchCopyNExX       StringCchCopyNExA
#define PathCchAppendX          PathCchAppendA
#define PathCchCombineX         PathCchCombineA
#define PathCchAddBackslashX    PathCchAddBackslashA
#define PathCchAddExtensionX    PathCchAddExtensionA
#define PathCchRenameExtensionX PathCchRenameExtensionA
#define PathCchCanonicalizeX    PathCchCanonicalizeA
#define PathIsRelativeX         PathIsRelativeA
#define PathIsRootX             PathIsRootA
#define PathIsUNCX              PathIsUNCA
#define PathStripToRootX        PathStripToRootA
#define PathFindExtensionX      PathFindExtensionA
#define StrChrX                 StrChrA
#define StrRChrX                StrRChrA
#define lstrlenX                lstrlenA
#define c_szDotExeX             c_szDotExeA
#define WUGetPCEndX             WUGetPCEndA
#define WUGetPCStartX           WUGetPCStartA
#define WUNearRootFixupsX       WUNearRootFixupsA

#endif


#define SAFEPATH_STRING_FLAGS (MISTSAFE_STRING_FLAGS | STRSAFE_NO_TRUNCATION)
#define CH_WHACK _X('\\')

//////////////////////////////////////////////////////////////////////////////
// Utility functions

// **************************************************************************
// Return a pointer to the end of the next path componenent in the string.
//  ie return a pointer to the next backslash or terminating NULL.
static inline
LPCXSTR WUGetPCEndX(LPCXSTR pszStart)
{
    LPCXSTR pszEnd;
    pszEnd = StrChrX(pszStart, CH_WHACK);
    if (pszEnd == NULL)
        pszEnd = pszStart + lstrlenX(pszStart);
    return pszEnd;
}

// **************************************************************************
// Given a pointer to the end of a path component, return a pointer to
//  its begining.
//  ie return a pointer to the previous backslash (or start of the string).
static inline
LPXSTR WUGetPCStartX(LPXSTR pszStart, LPCXSTR pszCurrent)
{
    LPXSTR pszBegin;
    pszBegin = StrRChrX(pszStart, pszCurrent, CH_WHACK);
    if (pszBegin == NULL)
        pszBegin = pszStart;
    return pszBegin;
}

// **************************************************************************
// Fix up a few special cases so that things roughly make sense.
static inline
void WUNearRootFixupsX(LPXSTR pszPath, DWORD cchPath, BOOL fUNC)
{
    // Empty path?
    if (cchPath > 1 && pszPath[0] == _X('\0'))
    {
        pszPath[0] = CH_WHACK;
        pszPath[1] = _X('\0');
    }
    
    // Missing slash?  (In the case of ANSI, be sure to check if the first 
    //  character is a lead byte
    else if (cchPath > 3 && 
#if !defined(SAFEPATH_UNICODEPASS)
             IsDBCSLeadByte(pszPath[0]) == FALSE && 
#endif
             pszPath[1] == _X(':') && pszPath[2] == _X('\0'))
    {
        pszPath[2] = _X('\\');
        pszPath[3] = _X('\0');
    }
    
    // UNC root?
    else if (cchPath > 2 && 
             fUNC && 
             pszPath[0] == _X('\\') && pszPath[1] == _X('\0'))
    {
        pszPath[1] = _X('\\');
        pszPath[2] = _X('\0');
    }
}

// **************************************************************************
static inline
LPXSTR AllocNewDest(LPXSTR pszDest, DWORD cchDest, LPXSTR *ppchDest, LPXSTR *ppszMax)
{
    HRESULT hr;
    LPXSTR  pszNewDest = NULL;
    DWORD   cchToCopy;

    pszNewDest = (LPXSTR)HeapAlloc(GetProcessHeap(), 0, cchDest * sizeof(XCHAR));
    if (pszNewDest == NULL)
    {
        SetLastError(ERROR_OUTOFMEMORY);
        goto done;
    }

    cchToCopy = (DWORD)(DWORD_PTR)(*ppchDest - pszDest);

    hr = StringCchCopyNExX(pszNewDest, cchDest, pszDest, cchToCopy,
                           NULL, NULL, SAFEPATH_STRING_FLAGS);
    if (FAILED(hr))
    {
        HeapFree(GetProcessHeap(), 0, pszNewDest);
        SetLastError(HRESULT_CODE(hr));
        pszNewDest = NULL;
        goto done;
    }

    *ppchDest = pszNewDest + cchToCopy;
    *ppszMax  = pszNewDest + cchDest - 1;

done:
    return pszNewDest;
}

//////////////////////////////////////////////////////////////////////////////
// Exported functions

// **************************************************************************
HRESULT PathCchCanonicalizeX(LPXSTR pszDest, DWORD cchDest, LPCXSTR pszSrc)
{
    HRESULT hr = NOERROR;
    LPCXSTR pchSrc, pchPCEnd;
    LPXSTR  pszMax = pszDest + cchDest - 1;
    LPXSTR  pchDest;
    LPXSTR  pszDestReal = pszDest;
    DWORD   cchPC;
    BOOL    fUNC, fRoot;

    if (pszDest == NULL || cchDest == 0 || pszSrc == NULL)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
        goto done;
    }

    pchSrc  = pszSrc;
    pchDest = pszDestReal;
    
    // Need to keep track of whether we have a UNC path so we can potentially
    //  fix it up below
    fUNC = PathIsUNCX(pszSrc);

    while (*pchSrc != _T('\0'))
    {
        pchPCEnd = WUGetPCEndX(pchSrc);
        cchPC    = (DWORD)(DWORD_PTR)(pchPCEnd - pchSrc) + 1;

        // is it a backslash?
        if (cchPC == 1 && *pchSrc == CH_WHACK)
        {
            if (pchDest + 1 > pszMax)            
            {
                // source string too big for the buffer.  Put a NULL at the end
                //  to ensure that it is NULL terminated.
                pszDestReal[cchDest - 1] = 0;
                hr = STRSAFE_E_INSUFFICIENT_BUFFER;
                goto done;
            }

            // Just copy it.
            *pchDest++ = CH_WHACK;
            pchSrc++;
        }

        // ok, how about a dot?
        else if (cchPC == 2 && *pchSrc == _X('.'))
        {
            if (pszDest == pszSrc && pszDestReal == pszDest)
            {
                pszDestReal = AllocNewDest(pszDest, cchDest, &pchDest, &pszMax);
                if (pszDestReal == NULL)
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                    goto done;
                }
            }
            
            // Are we at the end?
            if (*(pchSrc + 1) == 0)
            {
                pchSrc++;

                // remove the last slash we copied (if we've copied one), but 
                //  don't make a malformed root
                if (pchDest > pszDestReal && PathIsRootX(pszDestReal) == FALSE)
                    pchDest--;
            }
            else
            {
                pchSrc += 2;
            }
        }

        // any double dots? 
        else if (cchPC == 3 && *pchSrc == _X('.') && *(pchSrc + 1) == _X('.'))
        {
            if (pszDest == pszSrc && pszDestReal == pszDest)
            {
                pszDestReal = AllocNewDest(pszDest, cchDest, &pchDest, &pszMax);
                if (pszDestReal == NULL)
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                    goto done;
                }
            }
            
            // make sure we aren't already at the root.  If not, just remove 
            //  the previous path component
            if (PathIsRootX(pszDestReal) == FALSE)
            {
                pchDest = WUGetPCStartX(pszDestReal, pchDest - 1);
            }

            // we are at the root- however, we must make sure to skip the 
            //  backslash at the end of the ..\ so we don't copy another
            //  one (otherwise, C:\..\FOO would become C:\\FOO)
            else
            {
                if (*(pchSrc + 2) == CH_WHACK)
                    pchSrc++;
            }

            // skip ".."
            pchSrc += 2;       
        }

        // just choose 'none of the above'...
        else
        {
            if (pchDest != pchSrc)
            {
                DWORD cchAvail;
                
                cchAvail = cchDest - (DWORD)(DWORD_PTR)(pchDest - pszDestReal);

                hr = StringCchCopyNExX(pchDest, cchAvail, pchSrc, cchPC,
                                       NULL, NULL, SAFEPATH_STRING_FLAGS);
                if (FAILED(hr))
                    goto done;
            }
            
            pchDest += (cchPC - 1);
            pchSrc  += (cchPC - 1);
        }

        // make sure we always have a NULL terminated string
        if (pszDestReal != pszSrc) 
            *pchDest = _X('\0');
    }

    // Check for weirdo root directory stuff.
    WUNearRootFixupsX(pszDestReal, cchDest, fUNC);

    if (pszDest != pszDestReal)
    {
        hr = StringCchCopyExX(pszDest, cchDest, pszDestReal, 
                              NULL, NULL, SAFEPATH_STRING_FLAGS);
    }

done:
    if (pszDest != pszDestReal && pszDestReal != NULL)
        HeapFree(GetProcessHeap(), 0, pszDestReal);
    
    return hr;
}

// **************************************************************************
HRESULT PathCchRenameExtensionX(LPXSTR pszPath, DWORD cchPath, LPCXSTR pszExt)
{
    HRESULT hr = NOERROR;
    LPXSTR  pszOldExt;
    DWORD   cchPathWithoutExt;

    if (pszPath == NULL || pszExt == NULL)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
        goto done;
    }

    // This function returns a pointer to the end of the string if there 
    //  is no extension.  This is exactly what we want cuz we will want
    //  to add an extension to the end of the string if none exists.
    pszOldExt = PathFindExtensionX(pszPath);
    cchPathWithoutExt = (DWORD)(DWORD_PTR)(pszOldExt - pszPath);

    hr = StringCchCopyExX(pszOldExt, cchPath - cchPathWithoutExt, pszExt,
                          NULL, NULL, SAFEPATH_STRING_FLAGS);
done:
    return hr;
}


// **************************************************************************
HRESULT PathCchAddExtensionX(LPXSTR pszPath, DWORD cchPath, LPCXSTR pszExt)
{
    HRESULT hr = NOERROR;
    LPXSTR  pszOldExt;
    
    if (pszPath == NULL)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
        goto done;
    }

    // since we're *adding* an extension here, don't want to do anything if
    //  one already exists
    pszOldExt  = PathFindExtensionX(pszPath);
    if (*pszOldExt == _T('\0'))
    {
        if (pszExt == NULL)
            pszExt = c_szDotExeX;

        hr = StringCchCatExX(pszPath, cchPath, pszExt, 
                             NULL, NULL, SAFEPATH_STRING_FLAGS);
    }

done:
    return hr;
}

// **************************************************************************
HRESULT PathCchAddBackslashX(LPXSTR pszPath, DWORD cchPathBuff)
{
    HRESULT hr = NOERROR;
    LPCXSTR psz;
    DWORD   cch;

    if (pszPath == NULL)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
        goto done;
    }

    cch = lstrlenX(pszPath);

    if (cch == 0)
        goto done;

#if defined(SAFEPATH_UNICODEPASS)
    psz = &pszPath[cch - 1];
#else
    psz = CharPrevA(pszPath, &pszPath[cch]);
#endif

    // if the end of the base string does not have a backslash, then add one
    if (*psz != CH_WHACK)
    {
        // make sure we have enough space for the backslash in the buffer
        if (cch + 1 >= cchPathBuff)
        {
            hr = STRSAFE_E_INSUFFICIENT_BUFFER;
            goto done;
        }
        
        pszPath[cch++] = CH_WHACK;
        pszPath[cch]   = _X('\0');
    }

done:
    return hr;
}




// **************************************************************************
HRESULT PathCchCombineX(LPXSTR pszPath, DWORD cchPathBuff, LPCXSTR pszPrefix, 
                       LPCXSTR pszSuffix)
{
    HRESULT hr = NOERROR;

    if (pszPath == NULL || cchPathBuff == 0)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
        goto done;
    }


    // if both fields are NULL, just bail now.
    if (pszPrefix == NULL && pszSuffix == NULL)
    {
        pszPath[0] = L'\0';
        goto done;
    }

    if ((pszPrefix == NULL || *pszPrefix == _X('\0')) &&
        (pszSuffix == NULL || *pszSuffix == _X('\0')))
    {
        if (cchPathBuff > 1)
        {
            pszPath[0] = _X('\\');
            pszPath[1] = _X('\0');
        }
        else
        {
            hr = STRSAFE_E_INSUFFICIENT_BUFFER;
        }

        goto done;
    }

    // if all we have is the suffix, just copy it
    if (pszPrefix == NULL || *pszPrefix == _X('\0'))
    {
        hr = StringCchCopyExX(pszPath, cchPathBuff, pszSuffix, 
                              NULL, NULL, SAFEPATH_STRING_FLAGS);
        if (FAILED(hr))
            goto done;
    }
    else
    {
        // if all we have is the prefix, just copy it
        if (pszSuffix == NULL || *pszSuffix == _X('\0'))
        {
            hr = StringCchCopyExX(pszPath, cchPathBuff, pszPrefix,
                                  NULL, NULL, SAFEPATH_STRING_FLAGS);
            if (FAILED(hr))
                goto done;
        }

        // if we have a relative path for the suffix, then we just combine 
        //  the two and insert a backslash between them if necessary
        else if (PathIsRelativeX(pszSuffix))
        {
            hr = StringCchCopyExX(pszPath, cchPathBuff, pszPrefix,
                                  NULL, NULL, SAFEPATH_STRING_FLAGS);
            if (FAILED(hr))
                goto done;

            hr = PathCchAddBackslashX(pszPath, cchPathBuff);
            if (FAILED(hr))
                goto done;

            hr = StringCchCatExX(pszPath, cchPathBuff, pszSuffix,
                                 NULL, NULL, SAFEPATH_STRING_FLAGS);
            if (FAILED(hr))
                goto done;
        }

        // if the suffix starts with a backslash then just strip off
        //  everything except for the root of the prefix and append the
        //  suffix
        else if (*pszSuffix == CH_WHACK && PathIsUNCX(pszSuffix) == FALSE)
        {
            hr = StringCchCopyExX(pszPath, cchPathBuff, pszPrefix,
                                  NULL, NULL, SAFEPATH_STRING_FLAGS);
            if (FAILED(hr))
                goto done;

            // this is safe to call as it will only reduce the size of the
            //  string
            PathStripToRootX(pszPath);

            hr = PathCchAddBackslashX(pszPath, cchPathBuff);
            if (FAILED(hr))
                goto done;

            // make sure to skip the backslash while appending
            hr = StringCchCatExX(pszPath, cchPathBuff, pszSuffix + 1,
                                 NULL, NULL, SAFEPATH_STRING_FLAGS);
            if (FAILED(hr))
                goto done;
        }

        // we'll, likely the suffix is a full path (local or UNC), so
        //  ignore the prefix
        else
        {
            hr = StringCchCopyExX(pszPath, cchPathBuff, pszSuffix, 
                                  NULL, NULL, SAFEPATH_STRING_FLAGS);
            if (FAILED(hr))
                goto done;
        }
    }

    hr = PathCchCanonicalizeX(pszPath, cchPathBuff, pszPath);

done:
    return hr;
}



// **************************************************************************
HRESULT PathCchAppendX(LPXSTR pszPath, DWORD cchPathBuff, LPCXSTR pszNew)
{
    HRESULT hr = NOERROR;
    DWORD   dwOffset = 0;
    DWORD   cch, cchNew;

    if (pszPath == NULL)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
        goto done;
    }

    if (pszNew != NULL)
    {
        // skip all initial backslashes in pszNew
        while (*pszNew == CH_WHACK)
        {
            pszNew++;
        }

        hr = PathCchCombineX(pszPath, cchPathBuff, pszPath, pszNew);

    }
    else
    {
        hr = E_FAIL;
    }
    
done:
    return hr;
}




// make the unicode pass through the file
#if !defined(SAFEPATH_UNICODEPASS)
#define SAFEPATH_UNICODEPASS
#include "safepath.cpp"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\lib\wusafefn\sources.inc ===
MAJORCOMP=windows.com
MINORCOMP=lib.wusafefn

TARGETNAME=wusafefn
TARGETPATH=$(_OBJ_DIR)
TARGETTYPE=LIBRARY
UMTYPE=windows

PRECOMPILED_INCLUDE=..\StdAfx.h
PRECOMPILED_CXX=1

CHICAGO_PRODUCT=1

!IF "$(NTDEBUG)" != "ntsdnodbg"
DEBUG_CRTS=1
C_DEFINES = $(C_DEFINES) -D_DEBUG
MSC_OPTIMIZATION=/Od
!ENDIF

INCLUDES= \
        $(INCLUDES); \
        ..; \
        ..\..\..\inc; \

SOURCES= \
        ..\safecs.cpp \
        ..\safefile.cpp \
        ..\safelib.cpp \
        ..\safepath.cpp \
        ..\safereg.cpp \
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\lib\wusafefn\stdafx.h ===
/******************************************************************************

Copyright (c) 2002 Microsoft Corporation

Module Name:
    StdAfx.h
	
Abstract:
    precompiled header

******************************************************************************/

#pragma once

#define _WIN32_WINNT 0x0500  // some functionality is Win2000+ only

#include <windows.h>
#include <tchar.h>
#include <wusafefn.h>
#include <iucommon.h>
#include <mistsafe.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\winupd\include\sysinfo.h ===
//=======================================================================
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999  All Rights Reserved.
//
//  File:   SysInfo.h 
//
//	Description:
//			Gathers system information necessary to do redirect to windows update site.
//
//=======================================================================
const TCHAR REGPATH_WINUPD[]     = _T("Software\\Policies\\Microsoft\\WindowsUpdate");
const TCHAR REGPATH_EXPLORER[]   = _T("Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer");
const TCHAR REGKEY_WINUPD_DISABLED[] = _T("NoWindowsUpdate");

// Internet Connection Wizard settings
const TCHAR REGPATH_CONNECTION_WIZARD[] = _T("SOFTWARE\\Microsoft\\INTERNET CONNECTION WIZARD");
const TCHAR REGKEY_CONNECTION_WIZARD[] = _T("Completed");
#define LANGID_LEN 20

const LPTSTR WINDOWS_UPDATE_URL = _T("http://windowsupdate.microsoft.com");

bool FWinUpdDisabled(void);

void VoidGetConnectionStatus(bool *pfConnected);

const TCHAR WEB_DIR[] = _T("web\\");

/////////////////////////////////////////////////////////////////////////////
// vLaunchIE
//   Launch IE on the given URL.
//
// Parameters:
//
// Comments :
/////////////////////////////////////////////////////////////////////////////
HRESULT vLaunchIE(LPTSTR tszURL);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\winupd\lib\sysinfo.cpp ===
//=======================================================================
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999  All Rights Reserved.
//
//  File:   SysInfo.cpp 
//
// Description:
//   Gathers system information necessary to do redirect to windows update site.
//
//=======================================================================

#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include <windows.h>
#include <shellapi.h>
#include <wininet.h>
#include <ras.h>
#include <ole2.h>
#include <atlbase.h>
#include <exdisp.h>
#include <sysinfo.h>
#define SafeFree(x){if(NULL != x){free(x); x = NULL;}}

const DWORD dwWin98MinMinorVer = 1;

const TCHAR REGPATH_POLICY_USERACCESS_DISABLED[] = _T("Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\WindowsUpdate");
const TCHAR REGKEY_WU_USERACCESS_DISABLED[] = _T("DisableWindowsUpdateAccess");

/////////////////////////////////////////////////////////////////////////////
// FWinUpdDisabled
//   Determine if corporate administrator has turned off Windows Update via
//   policy settings.
//
// Parameters:
//
// Comments :
/////////////////////////////////////////////////////////////////////////////

bool FWinUpdDisabled(void)
{
    bool fDisabled = false;
    HKEY hKey = NULL;
    DWORD dwDisabled = 0;
    DWORD dwSize = sizeof(dwDisabled);
    DWORD dwType = 0;


    // check the original Group policy key to see if WU is disabled
    if ( RegOpenKeyEx(  HKEY_CURRENT_USER,
                        REGPATH_EXPLORER,
                        NULL,
                        KEY_QUERY_VALUE,
                        &hKey) == ERROR_SUCCESS )
    {
        if ( RegQueryValueEx(hKey,
                            REGKEY_WINUPD_DISABLED,
                            NULL,
                            &dwType,
                            (LPBYTE)&dwDisabled,
                            &dwSize) == ERROR_SUCCESS )
        {
            if ( (dwType == REG_DWORD) && (dwDisabled != 0) )
            {
                fDisabled = true;
            }
        }
    
        RegCloseKey(hKey);
    }

     if(false == fDisabled) // if we didn't find a disabled flag there...
    {
        // Check the new DisableWindowsUpdateAccess group policy (backported from XP)
        if ( RegOpenKeyEx(  HKEY_CURRENT_USER,
                            REGPATH_POLICY_USERACCESS_DISABLED,
                            NULL,
                            KEY_QUERY_VALUE,
                            &hKey) == ERROR_SUCCESS )
        {
            if ( RegQueryValueEx(hKey,
                                REGKEY_WU_USERACCESS_DISABLED,
                                NULL,
                                &dwType,
                                (LPBYTE)&dwDisabled,
                                &dwSize) == ERROR_SUCCESS )
            {
                if ( (dwType == REG_DWORD) && (dwDisabled == 0) )
                {
                    fDisabled = false;
                }
                else
                {
                    fDisabled = true;
                }
            }

            RegCloseKey(hKey);
        }
    }

    return fDisabled;
}

//
// FRASConnectoidExists
// Checks to see whether there is a default RAS connectoid.  
// If so, we know we're configured to connect to the Internet
//
bool FRASConnectoidExists()
{
    DWORD cb = 0;
    DWORD cEntries = 0;
    DWORD dwRet = 0;
    bool  fRet = false;

    // We have to have a valid structure with the dwSize initialized, but we pass 0 as the size
    // This will return us the correct count of entries (which is all we care about)
    LPRASENTRYNAME lpRasEntryName = (LPRASENTRYNAME) malloc( sizeof(RASENTRYNAME) );
    if(NULL == lpRasEntryName)
    {
            return fRet;
    }

    lpRasEntryName->dwSize = sizeof(RASENTRYNAME);

    dwRet = RasEnumEntries( NULL, NULL, lpRasEntryName, &cb, &cEntries );

     // Otherwise, Check to make sure there's at least one RAS entry
    if(cEntries > 0)
    {
        fRet = true;
    }

    SafeFree(lpRasEntryName );
    return fRet;
}

//
// FICWConnection Exists
// Checks to see whether the "Completed" flag has been set for the ICW.
// as of XP build 2472, this also applies to the Network Connection Wizard
//
bool FICWConnectionExists()
{
    HKEY    hKey = NULL;
    DWORD   dwCompleted = 0;
    DWORD   dwSize = sizeof(dwCompleted);
    DWORD   dwType = 0;
    bool    fRet = false;

    if ( RegOpenKeyEx(  HKEY_CURRENT_USER,
                        REGPATH_CONNECTION_WIZARD,
                        NULL,
                        KEY_QUERY_VALUE,
                        &hKey) == ERROR_SUCCESS )
    {
        if ( RegQueryValueEx(hKey,
                            REGKEY_CONNECTION_WIZARD,
                            NULL,
                            &dwType,
                            (BYTE *)&dwCompleted,
                            &dwSize) == ERROR_SUCCESS )
        {
            if ( ((dwType != REG_DWORD) && (dwType != REG_BINARY)) || 
                 dwCompleted )
            {
                fRet = true;
            }
        }
    
        RegCloseKey(hKey);
    }

    return fRet;
}

bool FIsLanConnection()
{
    DWORD dwConnTypes = 0;

    // We don't care about the return value - we just care whether we get the LAN flag
    (void)InternetGetConnectedState( &dwConnTypes, 0 );

    return (dwConnTypes & INTERNET_CONNECTION_LAN) ? true : false;
}

/////////////////////////////////////////////////////////////////////////////
// VoidGetConnectionStatus
//   Determine whether the Internet Connection Wizard has run.
//
// Parameters:
//
// Comments :
/////////////////////////////////////////////////////////////////////////////


void VoidGetConnectionStatus(bool *pfConnected)
{
    // Check to see if there is a default entry in the RAS phone book.  
    // If so, we know this computer has configured a connection to the Internet.
    // We can't tell whether the connection is live, but we can let IE handle prompting to connect.
    *pfConnected = FRASConnectoidExists() ||

    // If there's no default RAS entry, check to see if the user has run the ICW
    // As of build 2472, the Network Connection Wizard sets this same key for both RAS and persistent network connections
    FICWConnectionExists() ||

    // if the user has a LAN connection, we will trust IE's ability to get through
    FIsLanConnection();

    // if *pfConnected is still false at this point, there is no preconfigured Internet connection
}

/////////////////////////////////////////////////////////////////////////////
// vLaunchIE
//   Launch IE on URL.
//
// Parameters:
//
// Comments :
/////////////////////////////////////////////////////////////////////////////

HRESULT vLaunchIE(LPTSTR tszURL)
{
    
    if( NULL == tszURL || _T('\0') == tszURL[0] )
    {
        // if string is null throw error
        return E_INVALIDARG;
    }
    
    IWebBrowser2 *pwb2;

    HRESULT hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);

    if ( SUCCEEDED(hr) )
    {   
        hr = CoCreateInstance(CLSID_InternetExplorer, NULL,
                              CLSCTX_LOCAL_SERVER, IID_IWebBrowser2, (LPVOID*)&pwb2);

        if ( SUCCEEDED(hr) )
        {
            USES_CONVERSION;
            BSTR bstrURL = SysAllocString(T2W(tszURL));
            
            if( NULL == bstrURL )
            {
                  hr = E_OUTOFMEMORY;
                  goto Cleanup;
            }
            
            VARIANT varURL;            
            VariantInit(&varURL);
            varURL.vt = VT_BSTR;
            varURL.bstrVal = bstrURL;            

            VARIANT varFlags;
            VariantInit(&varFlags);
            varFlags.vt = VT_I4;
            varFlags.lVal = 0;

            VARIANT varEmpty;
            VariantInit(&varEmpty);

            hr = pwb2->Navigate2(&varURL, &varFlags, &varEmpty, &varEmpty, &varEmpty);
        
            if ( SUCCEEDED(hr) )
            {
                LONG_PTR lhwnd = NULL;
                if ( SUCCEEDED(pwb2->get_HWND((LONG_PTR*)&lhwnd)) )
                {
                    SetForegroundWindow((HWND)lhwnd);
                }
                hr = pwb2->put_Visible(TRUE);
            }
            pwb2->Release();                        
            VariantClear(&varFlags);
            VariantClear(&varURL);
        }        
        Cleanup:
        CoUninitialize();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\winupd\wupdmgr\resource.h ===
//=======================================================================
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999  All Rights Reserved.
//
//  File:   resource.h
//
//=======================================================================
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by InfoStub.rc
//
#define IDS_FILENOTFOUND                1
#define IDS_CANTACCESS                  2
#define IDS_UNKNOWN                     3
#define IDS_NOEXECUTABLE                4
#define IDS_DESCRIPTION                 5
#define IDS_MEMORY                      6
#define IDS_UNEXPECTED                  7
#define IDS_NOMSCFILE                   8

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\inc\aucompat.h ===
/****************************************************************************
Copyright (c) 2001 Microsoft Corporation

Module Name:
    aucompat.h

Revision History:
    DerekM      created     10/28/01

****************************************************************************/

#ifndef AUTSUTIL_H
#define AUTSUTIL_H

BOOL    AUIsTSRunning(void);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\inc\aucatitem.h ===
//=======================================================================
//
//  Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:    AUCatItem.h
//
//  Creator: PeterWi
//
//  Purpose: AU Catalog Item
//
//=======================================================================

#pragma once

#include "AUBaseCatalog.h"

//const DWORD AUCATITEM_UNSELECTED = 0;
//const DWORD AUCATITEM_SELECTED	 = 1;
//const DWORD AUCATITEM_HIDDEN	 = 2;

struct CatalogItem
{	
	void init(PUID puid, DWORD index, DWORD dwStatus = AUCATITEM_SELECTED)
	{
	    m_puid = puid;
	    m_dwStatus = dwStatus;
	    m_index = index;
    }
	void SetStatus(DWORD dwStatus) { m_dwStatus = dwStatus; }
    void SetStatusHidden(void) { m_dwStatus = AUCATITEM_HIDDEN; }

	DWORD GetStatus(void) { return m_dwStatus; }
	BOOL Selected(void)	{ return (AUCATITEM_SELECTED == m_dwStatus); }
	BOOL Unselected(void) { return (AUCATITEM_UNSELECTED == m_dwStatus); }
	BOOL Hidden(void) { return (AUCATITEM_HIDDEN == m_dwStatus); }

	PUID m_puid;
	BOOL m_dwStatus;
	DWORD m_index;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\inc\aubasecatalog.h ===
//=======================================================================
//
//  Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:    AUCatalog.h
//
//  Creator: PeterWi
//
//  Purpose: AU Catalog Definitions
//
//=======================================================================

#pragma once
#include <stdio.h>
#include <msxml.h>
#include <windows.h>
#include <safefunc.h>
#include "Loadengine.h"
#include "iu.h" //for IU engine exported functions' prototype
#include "iuctl.h" //for definition of UPDATE_COMMAND_CANCEL
#include "mistsafe.h"

class AUCatalogItem;

const WCHAR AUCLIENTINFO[] = L"<clientInfo xmlns=\"x-schema:http://schemas.windowsupdate.com/iu/clientInfo.xml\" clientName=\"au\" />";
const WCHAR AUDRIVERCLIENTINFO[] = L"<clientInfo xmlns=\"x-schema:http://schemas.windowsupdate.com/iu/clientInfo.xml\" clientName=\"audriver\" />";

const DWORD AUCATITEM_UNSELECTED = 0;
const DWORD AUCATITEM_SELECTED	 = 1;
const DWORD AUCATITEM_HIDDEN	 = 2;

//global object should not use CAU_BSTR because its constructor and destructor will
//make API calls which might cause dll loader deadlock
class CAU_BSTR
{
public:
    CAU_BSTR() : m_bstr(NULL){};
    ~CAU_BSTR() {SafeFreeBSTR(m_bstr); } 
	
    operator BSTR()	{ return m_bstr; }
	
    BOOL append(LPCWSTR wszToAppend)
		{
		if (NULL == wszToAppend)
			{
			return FALSE;
			}
		if (NULL == m_bstr)
			{
			m_bstr = SysAllocString(wszToAppend);
			return m_bstr != NULL;
			}
		int ilen = SysStringLen(m_bstr) + lstrlenW(wszToAppend) + 1;
		LPWSTR wszTmp = (LPWSTR) malloc(ilen * sizeof(WCHAR));
		if (NULL == wszTmp)
			{
			return FALSE;
			}
		BOOL fRet =
			SUCCEEDED(StringCchCopyExW(wszTmp, ilen, m_bstr, NULL, NULL, MISTSAFE_STRING_FLAGS)) &&
			SUCCEEDED(StringCchCatExW(wszTmp, ilen, wszToAppend, NULL, NULL, MISTSAFE_STRING_FLAGS)) &&
			SysReAllocString(&m_bstr, wszTmp);
		free(wszTmp);
		return fRet;
		}

private:
    BSTR m_bstr;
};

class AU_VARIANT : public ::tagVARIANT
{
public:
    AU_VARIANT()
    {
        vt = VT_EMPTY;
    }

    AU_VARIANT(LPCWSTR wsz)
    {
        vt = VT_BSTR;
        if ( NULL == (bstrVal = SysAllocString(wsz)) )
        {
            vt = VT_EMPTY;
        }
    }

    AU_VARIANT(long newlVal)
    {
        vt = VT_I4;
        lVal = newlVal;
    }

    AU_VARIANT(GUID & guid)
    {
        WCHAR wszGUID[40]; // 725e35a2-ee11-4b34-834f-6eaf4bade994

        vt = VT_BSTR;
        if ( (0 == StringFromGUID2(guid, wszGUID, ARRAYSIZE(wszGUID))) ||
             (NULL == (bstrVal = SysAllocString(wszGUID))) )
        {
            DEBUGMSG("variant with guid failed");
            vt = VT_EMPTY;
        }
    }

    ~AU_VARIANT() { VariantClear(this); }

    BOOL IsEmpty(void) { return VT_EMPTY == vt; }
};


class AUCatalogItemList
{
public:
	AUCatalogItemList()
		:pList(NULL), uNum(0) {}
	~AUCatalogItemList() { Clear();	}
	UINT Count(void) { return uNum; }

	AUCatalogItem & operator[] (UINT uIndex) const
	{
	    return *pList[uIndex];
	}
	void Clear(void);
	HRESULT Allocate(DWORD cItems);
	HRESULT Allocate(VARIANT & var);
	BOOL Add(AUCatalogItem *pitem);
	void Remove(BSTR bstrItemID);
	INT Contains(BSTR bstrItemID);
	HRESULT Copy( AUCatalogItemList &itemlist2);
	HRESULT BuildIndirectDependency();

       UINT GetNum(DWORD dwSelectionStatus);
       UINT GetNumSelected(void) { return GetNum(AUCATITEM_SELECTED); }
       UINT GetNumUnselected(void) { return GetNum(AUCATITEM_UNSELECTED); }
       UINT GetNumHidden(void) { return GetNum(AUCATITEM_HIDDEN);}

       BOOL ItemIsRelevant(UINT index) ;
   
       void DbgDump(void);
    
private:
	UINT uNum;
	AUCatalogItem **pList;
};

class AUCatalogItem
{
public:
    AUCatalogItem()
        : m_dwStatus(AUCATITEM_SELECTED),
          m_bstrID(NULL),
          m_bstrProviderName(NULL),
          m_bstrTitle(NULL),
          m_bstrDescription(NULL),
          m_bstrRTFPath(NULL),
          m_bstrEULAPath(NULL)
    {}

    AUCatalogItem(AUCatalogItem & item2)
    {
    	m_bstrID = SysAllocString(item2.bstrID());
		m_bstrProviderName = SysAllocString(item2.bstrProviderName());
		m_bstrTitle = SysAllocString(item2.bstrTitle());
		m_bstrDescription = SysAllocString(item2.bstrDescription());
		m_bstrRTFPath = SysAllocString(item2.bstrRTFPath());
		m_bstrEULAPath = SysAllocString(item2.bstrEULAPath());
		m_dwStatus = item2.dwStatus();
    }

	void Clear()
	{
		SafeFreeBSTRNULL(m_bstrID);
        SafeFreeBSTRNULL(m_bstrTitle);
        SafeFreeBSTRNULL(m_bstrProviderName);
        SafeFreeBSTRNULL(m_bstrDescription);
        SafeFreeBSTRNULL(m_bstrRTFPath);
        SafeFreeBSTRNULL(m_bstrEULAPath);
	}
	
    ~AUCatalogItem()
    {
    	Clear();
    }

    BOOL fEqual(AUCatalogItem & item2)
		{
			BOOL fRet = FALSE;
			BSTR  myValues[] = {m_bstrID,
								m_bstrProviderName, 
								m_bstrTitle, 
								m_bstrDescription, 
								m_bstrRTFPath, 
								m_bstrEULAPath }; 
			BSTR theirValues[] = {item2.bstrID(),
								item2.bstrProviderName(),
								item2.bstrTitle(),
								item2.bstrDescription(),
								item2.bstrRTFPath(),
								item2.bstrEULAPath()};
			if (item2.dwStatus() != m_dwStatus)
			{
				goto done;
			}
			for ( UINT i= 0; i < ARRAYSIZE(myValues); i++ )
			{
				if (NULL != myValues[i] && NULL == theirValues[i]
					|| NULL == myValues[i] && NULL != theirValues[i])
				{
					goto done;
				}
				else if (NULL != myValues[i] && NULL != theirValues[i])
				{
					if (0 != lstrcmpW(myValues[i], theirValues[i]))
					{
						goto done;
					}
				}
			}
			fRet = TRUE;
done:
			return fRet;
    }
  	

    void SetField(LPCSTR szFieldName, BSTR bstrVal)
	{
		BSTR * grValues[] = {	&m_bstrID,
								&m_bstrProviderName, 
								&m_bstrTitle, 
								&m_bstrDescription, 
								&m_bstrRTFPath, 
								&m_bstrEULAPath }; 

		for ( int index = 0; index < ARRAYSIZE(grValues); index++ )
		{
			if ( 0 == _stricmp(szFieldName, m_pFieldNames[index]))
			{
				*grValues[index] = bstrVal;
				return;
			}
		}
	}

    void dump() //for debug
	{
		DEBUGMSG("dumping item content");
		DEBUGMSG("Item ID= %S", m_bstrID);
		DEBUGMSG("Provider Name= %S", m_bstrProviderName);
		DEBUGMSG("Title= %S", m_bstrTitle);
		DEBUGMSG("Desc= %S", m_bstrDescription);
		DEBUGMSG("RTF Path= %S", m_bstrRTFPath);
		DEBUGMSG("Eula Path= %S", m_bstrEULAPath);
		DEBUGMSG("status = %d", m_dwStatus);
		if (m_DependingItems.Count() == 0)
			{
			DEBUGMSG("		has no depending items");
			}
		else
			{
			DEBUGMSG("		has total %d depending items", m_DependingItems.Count());
			for (UINT i = 0; i < m_DependingItems.Count();  i++)
				{
				DEBUGMSG("		: %S", m_DependingItems[i].bstrID()); //only cares about itemID
				}
			}	
		DEBUGMSG("dumping item done");
	}

    static char * m_pFieldNames[] ;

    DWORD dwStatus(void) { return m_dwStatus; }
    BSTR bstrID(void) { return (m_bstrID); }
    BSTR bstrProviderName(void) { return (m_bstrProviderName); }
    BSTR bstrTitle(void) { return (m_bstrTitle); }
    BSTR bstrDescription(void) { return (m_bstrDescription); }
    BSTR bstrRTFPath(void) { return (m_bstrRTFPath); }
    BSTR bstrEULAPath(void) { return (m_bstrEULAPath); }

    void SetStatus(DWORD dwStatus) { m_dwStatus = dwStatus; }
    void SetStatusHidden(void) { m_dwStatus = AUCATITEM_HIDDEN; }
    void SetStatusSelected(void)	{m_dwStatus = AUCATITEM_SELECTED;}

    BOOL fSelected(void) { return (AUCATITEM_SELECTED == m_dwStatus); }
    BOOL fUnselected(void) { return (AUCATITEM_UNSELECTED == m_dwStatus); }
    BOOL fHidden(void) { return (AUCATITEM_HIDDEN == m_dwStatus); }
	
   AUCatalogItemList	m_DependingItems; //all items that depends on this item, directly and indirectly
private:
    DWORD m_dwStatus;

    BSTR m_bstrID; 
    BSTR m_bstrProviderName;
    BSTR m_bstrTitle;
    BSTR m_bstrDescription;
    BSTR m_bstrRTFPath;
    BSTR m_bstrEULAPath;


    friend HRESULT TransformSafeArrayToItemList(VARIANT & var, AUCatalogItemList & ItemList);
    friend class AUCatalog;
};



//wrapper class for AU to do detection using IU
class AUBaseCatalog
{
public: 
    AUBaseCatalog()
    	{
			Reset();
		}
    ~AUBaseCatalog();
    HRESULT PrepareIU(BOOL fOnline = TRUE);
    void FreeIU();
    HRESULT CancelNQuit(void);
protected:
    HMODULE				m_hIUCtl;
    HMODULE				m_hIUEng;					
    PFN_LoadIUEngine		m_pfnCtlLoadIUEngine;
    PFN_UnLoadIUEngine		m_pfnCtlUnLoadIUEngine;
    PFN_GetSystemSpec		m_pfnGetSystemSpec;
    PFN_GetManifest			m_pfnGetManifest;
    PFN_Detect				m_pfnDetect;
    PFN_Install		        m_pfnInstall;
    PFN_SetOperationMode	m_pfnSetOperationMode;
    PFN_CtlCancelEngineLoad m_pfnCtlCancelEngineLoad;
	PFN_CreateEngUpdateInstance		m_pfnCreateEngUpdateInstance;
	PFN_DeleteEngUpdateInstance		m_pfnDeleteEngUpdateInstance;
    BOOL 					m_fEngineLoaded;
	HIUENGINE				m_hIUEngineInst;
private:
	void Reset()
	{
		m_hIUCtl = NULL;
	    m_hIUEng = NULL;
	    m_pfnCtlLoadIUEngine = NULL;
	    m_pfnCtlUnLoadIUEngine = NULL;
	    m_pfnGetSystemSpec = NULL;
	    m_pfnGetManifest = NULL;
	    m_pfnDetect = NULL;
	    m_pfnInstall = NULL;
	    m_pfnSetOperationMode = NULL;
	    m_pfnCtlCancelEngineLoad = NULL;
		m_pfnCreateEngUpdateInstance = NULL;
		m_pfnDeleteEngUpdateInstance = NULL;
		m_hIUEngineInst = NULL;
		m_fEngineLoaded = FALSE;
	}
};


extern HANDLE ghMutex; //mutex used to prevent catalog from being destructed while canceling it
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\winupd\wupdmgr\wupdmgr.cpp ===
//=======================================================================
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999  All Rights Reserved.
//
//  File:   	WUpdMgr.cpp
//
//  Description:
//		Executable launched from the Windows Update shortcut.
//
//=======================================================================

#include <stdio.h>
#include <tchar.h>

#include <windows.h>
#include <wininet.h> //INTERNET_MAX_URL_LENGTH
#include <shellapi.h>
#include <objbase.h>
#include <shlobj.h>

#include "sysinfo.h"
#include "msg.h"
#include <atlbase.h>
#include <atlconv.cpp>

const TCHAR HELPCENTER_WINUPD_URL[] = _T("hcp://system/updatectr/updatecenter.htm");
 
/////////////////////////////////////////////////////////////////////////////
// vShowMessageBox
//   Display an error in a message box.
//
// Parameters:
//
// Comments :
/////////////////////////////////////////////////////////////////////////////

void vShowMessageBox(DWORD dwMessageId)
{
	LPTSTR tszMsg = _T("");
	
	DWORD dwResult = 
		FormatMessage(	FORMAT_MESSAGE_ALLOCATE_BUFFER |
						FORMAT_MESSAGE_FROM_HMODULE,
						NULL,
						dwMessageId,
						0,
						(LPTSTR)&tszMsg,
						0,
						NULL);

	// if we can't get the message, we don't do anything.
	if ( dwResult != 0 )
	{
		MessageBox(NULL,
				   tszMsg,
				   NULL,
				   MB_OK | MB_ICONEXCLAMATION);

		LocalFree(tszMsg);
	}
}


/////////////////////////////////////////////////////////////////////////////
// main
//   Entry point.
//
// Parameters:
//
// Comments :
/////////////////////////////////////////////////////////////////////////////

int __cdecl main(int argc, char **argv)
{
	int nReturn = 0;

	if ( FWinUpdDisabled() )
	{
		vShowMessageBox(WU_E_DISABLED);

		nReturn = 1;
	}
	else
	{
		bool fConnected;

		// Determine if the internet connection wizard has run and we are
		// connected to the Internet
		VoidGetConnectionStatus(&fConnected);

		if ( fConnected )
		{	// The user has an internet connection.
			// Launch IE to go to the site
			vLaunchIE(WINDOWS_UPDATE_URL);
		}
		else
		{
			//launch helpcenter version of WU
			ShellExecute(NULL, NULL, HELPCENTER_WINUPD_URL, NULL, NULL, SW_SHOWNORMAL);
		}
	}
	return nReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\inc\audirectory.h ===
#pragma once
extern const TCHAR C_DOWNLD_DIR[];
extern TCHAR g_szWUDir[MAX_PATH+1];        //Path to windows update directory

/////////////////////////////////////////////////////////////////////
// audirectory.cpp
/////////////////////////////////////////////////////////////////////
int DelDir(LPCTSTR lpszDir);
int RegExpDelFile(LPCTSTR tszFilePath, LPCTSTR tszFilePattern);

BOOL AUDelFileOrDir(LPCTSTR szFileOrDir);
BOOL CreateWUDirectory(BOOL fGetPathOnly = FALSE);
HRESULT GetDownloadPath(LPTSTR lpszDir, DWORD dwCchSize);
HRESULT MakeTempDownloadDir(LPTSTR  pstrTarget, DWORD dwCchSize);
HRESULT GetRTFDownloadPath(LPTSTR lpszDir, DWORD dwCchSize);
HRESULT GetRTFDownloadPath(LPTSTR lpszDir, DWORD dwCchSize, LANGID langid);
HRESULT GetRTFLocalFileName(BSTR bstrRTFUrl, LPTSTR lpszFileName, DWORD dwCchSize, LANGID langid);
HRESULT GetCabsDownloadPath(LPTSTR lpszDir, DWORD dwCchSize );
BOOL 	EnsureDirExists(LPCTSTR lpDir);
HRESULT	LOGXMLFILE(LPCTSTR szFileName, BSTR bstrMessage);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\inc\aucomres.h ===
//=======================================================================
//
//  Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:    comres.h
//
//  Creator: Weiw
//
//  Purpose: common utility header for auto update
//
//=======================================================================
#pragma once
#include <windows.h>
#include <TCHAR.h>

#define IDC_OPTION1       1000
#define IDC_OPTION2       1001
#define IDC_OPTION3       1002
#define IDC_RESTOREHIDDEN		     1003
#define IDC_CHK_KEEPUPTODATE		1008
#define IDC_CMB_DAYS			1009
#define IDC_CMB_HOURS			1010

#ifdef DBG
const TCHAR DOWNLOAD_FILE[] = _T("downloadresult.xml");
const TCHAR INSTALLRESULTS_FILE[] = _T("InstallResults.xml");
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\inc\aumsgs.h ===
#pragma once

// fixcode separate and rename
// engine messages
const UINT AUMSG_INIT				= WM_APP;
const UINT AUMSG_DETECT                 = WM_APP+1;
const UINT AUMSG_DOWNLOAD               = WM_APP +  2;
const UINT AUMSG_DOWNLOAD_COMPLETE      = WM_APP +  3;
const UINT AUMSG_PRE_INSTALL            = WM_APP +  4;
const UINT AUMSG_POST_INSTALL           = WM_APP +  5;
const UINT AUMSG_VALIDATE_CATALOG       = WM_APP + 17;
const UINT AUMSG_EULA_ACCEPTED          = WM_APP + 23;
const UINT AUMSG_LOG_EVENT				= WM_APP + 24;


// client messages
const UINT AUMSG_INSTALL_COMPLETE       = WM_APP +  6;
const UINT AUMSG_REBOOT_REQUIRED        = WM_APP +  7;
const UINT AUMSG_SHOW_WELCOME           = WM_APP +  8;
const UINT AUMSG_SHOW_DOWNLOAD          = WM_APP +  9;
const UINT AUMSG_SHOW_INSTALL           = WM_APP + 10;
const UINT AUMSG_TRAYCALLBACK           = WM_APP + 11;
const UINT AUMSG_INSTALL_PROGRESS       = WM_APP + 12;
const UINT AUMSG_SELECTION_CHANGED      = WM_APP + 13;
const UINT AUMSG_SET_INSTALL_ITEMSNUM = WM_APP+14;
const UINT AUMSG_SHOW_RTF               = WM_APP + 15;
const UINT AUMSG_SHOW_INSTALLWARNING = WM_APP + 18;


const UINT AUMSG_ENG_END				= AUMSG_LOG_EVENT;
const UINT AUMSG_ENG_START              = AUMSG_INIT;

inline BOOL IsValidAUMsg(UINT uMsg) 
{
	return uMsg >= AUMSG_ENG_START && uMsg <= AUMSG_ENG_END;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\inc\auregkeys.h ===
#pragma once

#define AUTOUPDATEKEY       TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate\\Auto Update")
#define TIMEOUTVALUE        TEXT("Timeout")
//#define TIMESTAMPVALUE      TEXT("Timestamp")
#define TIMEOUTSTATE        TEXT("TimeoutState")
//#define INDEXVALUE          TEXT("TimeoutIndex")
//#define DOWNLOADSTOPPED     TEXT("DownloadStopped")
#define LASTWAITTIMEOUT		TEXT("LastWaitTimeout")
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\inc\ausvc.h ===
#pragma once

typedef DWORD (WINAPI *AUSERVICEHANDLER)(DWORD fdwControl,
                                                DWORD dwEventType,
                                                LPVOID pEventData,
                                                LPVOID lpContext);


const DWORD AUSRV_VERSION = 1;
typedef struct _AUENGINEINFO_VER_1
{
    SERVICE_STATUS          serviceStatus;
    SERVICE_STATUS_HANDLE   hServiceStatus;
} AUENGINEINFO_VER_1;

typedef BOOL (WINAPI *AUREGSERVICEVER) (DWORD dwServiceVersion, DWORD *pdwEngineVersion);
typedef BOOL (WINAPI *AUGETENGSTATUS)(void *pEngineInfo);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\inc\auwait.h ===
#pragma once

#define AU_TEN_SECONDS (10)
#define AU_ONE_MIN     (60)
#define AU_THREE_MINS (3 * AU_ONE_MIN)
#define AU_FIVE_MINS   (5  * AU_ONE_MIN)
#define AU_TEN_MINS	   (10 * AU_ONE_MIN)
#define AU_ONE_HOUR    (60 * AU_ONE_MIN)
#define AU_FOUR_HOURS  (4  * AU_ONE_HOUR)
#define AU_FIVE_HOURS  (5  * AU_ONE_HOUR)
#define AU_TWELVE_HOURS (12* AU_ONE_HOUR)
#define AU_TWENTY_TWO_HOURS (22 * AU_ONE_HOUR)
#define AU_ONE_DAY     (24 * AU_ONE_HOUR)
#define AU_TWO_DAYS    ( 2 * AU_ONE_DAY)
#define AU_ONE_WEEK    ( 7 * AU_ONE_DAY)

#define AU_MIN_SECS    (1)
#define AU_MIN_MS      (AU_MIN_SECS * 1000)

#define AUFT_INVALID_VALUE ((ULONGLONG) 0)

#define AU_RANDOMIZATION_WINDOW	20 //percent

// easy to do calculations with without casting.
typedef union
{
    FILETIME ft;
    ULONGLONG ull;
} AUFILETIME;

DWORD dwTimeToWait(DWORD dwTimeInSecs, DWORD dwMinSecs = AU_MIN_SECS);

inline DWORD dwSecsToWait(DWORD dwTime)
{
    return (dwTimeToWait(dwTime) / 1000);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\inc\wuaustate.h ===
#pragma once

//States
#define AUSTATE_OUTOFBOX			0
#define AUSTATE_NOT_CONFIGURED	1
#define AUSTATE_DETECT_PENDING		2
#define AUSTATE_DETECT_COMPLETE		3
#define AUSTATE_DOWNLOAD_PENDING	4
#define AUSTATE_DOWNLOAD_COMPLETE	5
#define AUSTATE_INSTALL_PENDING		6
#define AUSTATE_DISABLED			7
#define AUSTATE_WAITING_FOR_REBOOT	8
#define AUSTATE_MIN	AUSTATE_OUTOFBOX
#define AUSTATE_MAX	AUSTATE_WAITING_FOR_REBOOT
//AUSTATE 

//Directives
const DWORD AUCLT_ACTION_NONE = 0;
//const DWORD AUCLT_ACTION_SHOWINSTALLWARNINGONLY = 1;
const DWORD AUCLT_ACTION_AUTOINSTALL = 1;
const DWORD AUCLT_ACTION_SHOWREBOOTWARNING = 2;

typedef struct _AUSTATE
{
	DWORD dwState;
	BOOL  fDisconnected;
	DWORD dwCltAction;
} AUSTATE;

typedef struct _AUOPTION
{
	DWORD dwOption;
	DWORD dwSchedInstallDay;
	DWORD dwSchedInstallTime;
	BOOL    fDomainPolicy; //option comes from domain
} AUOPTION;


typedef struct _AUEVTHANDLES
{
#ifdef _WIN64
	//LONG64	ulEngineState;
	LONG64	ulNotifyClient;
#else	
	//LONG	ulEngineState;
	LONG	ulNotifyClient;
#endif

} AUEVTHANDLES;


typedef enum tagClientNotifyCode {
	NOTIFY_STOP_CLIENT = 1,
	NOTIFY_ADD_TRAYICON,
	NOTIFY_REMOVE_TRAYICON,
	NOTIFY_STATE_CHANGE,
	NOTIFY_SHOW_INSTALLWARNING,
	NOTIFY_RESET,
	NOTIFY_RELAUNCH_CLIENT
} CLIENT_NOTIFY_CODE;

typedef struct tagCLIENT_NOTIFY_DATA{
	CLIENT_NOTIFY_CODE actionCode;
} CLIENT_NOTIFY_DATA;

///////////////////////////////////////////////
//
//  Status Pinging Related Definition
//
///////////////////////////////////////////////
typedef long PUID;

const UINT	PING_STATUS_ERRMSG_MAX_LENGTH = 200;

typedef enum tagPingStatusCode
{
	PING_STATUS_CODE_SELFUPDATE_PENDING = 0,
	PING_STATUS_CODE_SELFUPDATE_COMPLETE ,
	PING_STATUS_CODE_SELFUPDATE_FAIL,
	PING_STATUS_CODE_DETECT_FAIL,
	PING_STATUS_CODE_DOWNLOAD_SUCCESS,
	PING_STATUS_CODE_DOWNLOAD_FAIL,
	PING_STATUS_CODE_INSTALL_SUCCESS,
	PING_STATUS_CODE_INSTALL_REBOOT,
	PING_STATUS_CODE_INSTALL_FAIL
} PingStatusCode;

#define  PING_STATUS_CODE_MIN  PING_STATUS_CODE_SELFUPDATE_PENDING
#define  PING_STATUS_CODE_MAX PING_STATUS_CODE_INSTALL_FAIL

#if 0
// Ping status information entry
// fUsePuid		: switch to decide if to use puid or not
//					if TURE, puid is used 
//					if FALSE, puid is not applicable 
// puid			: if applicable, puid of the item we send information about
// enStatusCode	: status code for type of information AU sends.
// guid			: unique identifier for each AU cycle
// tszErr		: addtional message about general errors. Maximum length is PING_STATUS_ERRMSG_MAX_LENGTH. 
//				: Messages longer than PING_STATUS_ERRMSG_MAX_LENGTH will be truncated.
//			:	 if NULL, "none" will be the default error message
typedef struct tagStatusEntry  
{
	BOOL fUsePuid;   //if TRUE, puid is used. otherwise puid is not used
	PUID puid;
	GUID guid;
	PingStatusCode enStatusCode;
	TCHAR tszErr[PING_STATUS_ERRMSG_MAX_LENGTH];
} StatusEntry;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\irnotif\makefile.inc ===
!INCLUDE $(NTMAKEENV)\makefile.plt

#
# Common MIDL related define
#

CPP_CMD = -cpp_cmd "$(MIDL_CPP)"
CPP_OPT = $(MIDL_FLAGS)
MIDL_INC = -I$(COM_INC_PATH) -I$(SDK_INC_PATH) -I$(CRT_INC_PATH)
COMMON_FLAGS= -Oicf -error all -robust -c_ext -ms_ext -oldnames -char unsigned $(CPP_CMD) $(CPP_OPT) $(MIDL_INC)

#
# Common variables
#

TOKEN =usertok

#
# Info about currently logged-in user (Private)
#
token: $(O)\$(TOKEN).h $(O)\$(TOKEN)_c.c

$(O)\$(TOKEN).h $(O)\$(TOKEN)_c.c: $(TOKEN).idl $(TOKEN).acf
        midl $(COMMON_FLAGS) -server none -out $(O) $(TOKEN).idl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\irnotif\token.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       token.cxx
//
//  Note:		Copied from //depot/LAB04_N/com/mobile/sens/conn/notify/token.cxx#2
//				Should only be used for OSes earlier than .NET Server
//--------------------------------------------------------------------------

#include <windows.h>
#include <usertok.h>
#include <malloc.h>

extern "C"
{
HANDLE
GetCurrentUserToken_for_Win2KW(
                      WCHAR Winsta[],
                      DWORD DesiredAccess
                      );
}

HANDLE
GetCurrentUserToken_for_Win2KW(
                      WCHAR Winsta[],
                      DWORD DesiredAccess
                      )
{
    unsigned long handle = 0;
    error_status_t status;
    handle_t binding;

    //
    // Use a dynamic binding - it will pick up the endpoint from the interfaace.
    //
    status = RpcBindingFromStringBinding(L"ncacn_np:", &binding);
    if (status)
        {
        SetLastError(status);
        return 0;
        }

    RPC_SECURITY_QOS Qos;

    Qos.Version = 1;
    Qos.Capabilities = RPC_C_QOS_CAPABILITIES_DEFAULT;
    Qos.IdentityTracking = RPC_C_QOS_IDENTITY_DYNAMIC;
    Qos.ImpersonationType = RPC_C_IMP_LEVEL_IMPERSONATE;

    status = RpcBindingSetAuthInfoEx( binding,
                                      NULL,
                                      RPC_C_AUTHN_LEVEL_PKT_INTEGRITY,
                                      RPC_C_AUTHN_WINNT,
                                      NULL,                           // default credentials
                                      RPC_C_AUTHZ_NONE,
                                      &Qos
                                      );
    if (status)
        {
        RpcBindingFree( &binding );
        SetLastError(status);
        return 0;
        }

    status = SecpGetCurrentUserToken( binding, Winsta, GetCurrentProcessId(), &handle, DesiredAccess);
    if (status)
        {
        RpcBindingFree( &binding );
        if (status == RPC_S_UNKNOWN_AUTHN_SERVICE ||
            status == RPC_S_SERVER_UNAVAILABLE    ||
            status == RPC_S_CALL_FAILED )
            {
            status = ERROR_NOT_LOGGED_ON;
            }

        SetLastError(status);
        return 0;
        }

    RpcBindingFree( &binding );

    return ULongToPtr(handle);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\inc\link.h ===
//=======================================================================
//
//  Copyright (c) 1998-1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:   Link.h
//
//  Owner:  a-josem
//
//  Description:
//
//      Static control subclassing Class used to display links.
//
//
//=======================================================================


#pragma once
#include <stdlib.h>
#include <malloc.h>

#include "windowsx.h"
#include "tchar.h"
#include "htmlhelp.h"
#include <shellapi.h>
#include <safefunc.h>
#include "mistsafe.h"

const TCHAR strObjPtr[]  = TEXT("strSysLinkObjPtr");

const struct
{
	enum { cxWidth = 32, cyHeight = 32 };
	int xHotSpot;
	int yHotSpot;
	unsigned char arrANDPlane[cxWidth * cyHeight / 8];
	unsigned char arrXORPlane[cxWidth * cyHeight / 8];
} _Link_CursorData = 
{
	5, 0, 
	{
		0xF9, 0xFF, 0xFF, 0xFF, 0xF0, 0xFF, 0xFF, 0xFF, 0xF0, 0xFF, 0xFF, 0xFF, 0xF0, 0xFF, 0xFF, 0xFF, 
		0xF0, 0xFF, 0xFF, 0xFF, 0xF0, 0x3F, 0xFF, 0xFF, 0xF0, 0x07, 0xFF, 0xFF, 0xF0, 0x01, 0xFF, 0xFF, 
		0xF0, 0x00, 0xFF, 0xFF, 0x10, 0x00, 0x7F, 0xFF, 0x00, 0x00, 0x7F, 0xFF, 0x00, 0x00, 0x7F, 0xFF, 
		0x80, 0x00, 0x7F, 0xFF, 0xC0, 0x00, 0x7F, 0xFF, 0xC0, 0x00, 0x7F, 0xFF, 0xE0, 0x00, 0x7F, 0xFF, 
		0xE0, 0x00, 0xFF, 0xFF, 0xF0, 0x00, 0xFF, 0xFF, 0xF0, 0x00, 0xFF, 0xFF, 0xF8, 0x01, 0xFF, 0xFF, 
		0xF8, 0x01, 0xFF, 0xFF, 0xF8, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
	},
	{
		0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 
		0x06, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x06, 0xC0, 0x00, 0x00, 0x06, 0xD8, 0x00, 0x00, 
		0x06, 0xDA, 0x00, 0x00, 0x06, 0xDB, 0x00, 0x00, 0x67, 0xFB, 0x00, 0x00, 0x77, 0xFF, 0x00, 0x00, 
		0x37, 0xFF, 0x00, 0x00, 0x17, 0xFF, 0x00, 0x00, 0x1F, 0xFF, 0x00, 0x00, 0x0F, 0xFF, 0x00, 0x00, 
		0x0F, 0xFE, 0x00, 0x00, 0x07, 0xFE, 0x00, 0x00, 0x07, 0xFE, 0x00, 0x00, 0x03, 0xFC, 0x00, 0x00, 
		0x03, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	}
};

class CSysLink
{
public:
	CSysLink(BOOL fIsHtmlHelp= TRUE):/*bInit(FALSE),*/m_OrigWndProc(NULL),m_lpstrLabel(NULL), m_lpstrHyperLink(NULL),m_hWnd(NULL),
			m_hCursor(NULL), m_hFont(NULL), /* m_bPaintLabel(true),*/ m_clrLink(RGB(0, 0, 255)), m_PaintedFocusRect(false), m_IsHtmlHelp(fIsHtmlHelp)
	{
		SetRectEmpty(&m_rcLink);
	}

	~CSysLink()
	{
#if 0		
		free(m_lpstrLabel);
		free(m_lpstrHyperLink);
		if(m_hFont != NULL)
			::DeleteObject(m_hFont);
		if(m_hCursor != NULL)
			::DestroyCursor(m_hCursor);
#endif		
	}

	void Uninit()
	{
		SafeFreeNULL(m_lpstrLabel);
		SafeFreeNULL(m_lpstrHyperLink);
		if(m_hFont != NULL)
		{
			::DeleteObject(m_hFont);
			m_hFont = NULL;
		}
		if(m_hCursor != NULL)
		{
			::DestroyCursor(m_hCursor);
			m_hCursor = NULL;
		}
	}

	void Init()
	{	
		LONG ctrlstyle = GetWindowLong(m_hWnd,GWL_STYLE);
		ctrlstyle |= SS_NOTIFY;
		SetWindowLongPtr(m_hWnd,GWL_STYLE,ctrlstyle);

		HWND wnd = GetParent(m_hWnd);
		HFONT hFont = (HFONT)SendMessage(wnd,WM_GETFONT,0,0);
/*		if(m_bPaintLabel) */
		{
			if(hFont != NULL)
			{
				LOGFONT lf;
				GetObject(hFont, sizeof(LOGFONT), &lf);
				lf.lfUnderline = TRUE;
				m_hFont = CreateFontIndirect(&lf);
			}
		}

		// set label (defaults to window text)
		if(m_lpstrLabel == NULL)
		{
			int nLen = GetWindowTextLength(m_hWnd);
			if(nLen > 0)
			{
				LPTSTR lpszText = (LPTSTR)malloc((nLen+1)*sizeof(TCHAR));
				if(NULL != lpszText && GetWindowText(m_hWnd,lpszText, nLen+1))
					SetLabel(lpszText);
				SafeFree(lpszText);
			}
		}

		// set hyperlink (defaults to label)
		if(m_lpstrHyperLink == NULL && m_lpstrLabel != NULL)
			SetHyperLink(m_lpstrLabel);

		CalcLabelRect();
	}

	void SubClassWindow(HWND hWnd)
	{
		if (SetProp(hWnd, strObjPtr, (HANDLE)this))
		{
//			bInit = TRUE;
			m_hWnd = hWnd;
			m_OrigWndProc = (WNDPROC) SetWindowLongPtr(hWnd,GWLP_WNDPROC,(LONG_PTR)CSysLink::_SysLinkWndProc);
		}
		Init();
	}

	static INT_PTR CALLBACK _SysLinkWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
	{
		CSysLink *pThis = (CSysLink *)GetProp(hwnd, strObjPtr);

//		if (NULL != pThis)
//		{
			switch(uMsg)
			{
				HANDLE_MSG(hwnd, WM_ERASEBKGND,	pThis->_OnEraseBkgnd);
				HANDLE_MSG(hwnd, WM_PAINT, pThis->_OnPaint);
				HANDLE_MSG(hwnd, WM_SETFOCUS, pThis->_OnFocus);
				HANDLE_MSG(hwnd, WM_KILLFOCUS, pThis->_OnFocus);
				HANDLE_MSG(hwnd, WM_MOUSEMOVE, pThis->_OnMouseMove);
				HANDLE_MSG(hwnd, WM_LBUTTONDOWN, pThis->_OnLButtonDown);
				HANDLE_MSG(hwnd, WM_LBUTTONUP, pThis->_OnLButtonUp);
				HANDLE_MSG(hwnd, WM_CHAR, pThis->_OnChar);
				HANDLE_MSG(hwnd, WM_GETDLGCODE,  pThis->_OnGetDlgCode);
				HANDLE_MSG(hwnd, WM_SETCURSOR,  pThis->_OnSetCursor);
			}
//		}
		return CallWindowProc(pThis->m_OrigWndProc, hwnd,uMsg,wParam,lParam);
	}

	BOOL Invalidate(BOOL bErase = TRUE)
	{
		return InvalidateRect(m_hWnd, NULL, bErase);
	}

	BOOL Navigate()
	{
		if (m_IsHtmlHelp == TRUE)
			HtmlHelp(NULL,m_lpstrHyperLink,HH_DISPLAY_TOPIC,NULL);
		else
		{
			ShellExecute(0, _T("open"), m_lpstrHyperLink, 0, 0, SW_SHOWNORMAL);
		}
		return TRUE;
	}

	void SetSysLinkInstanceHandle(HINSTANCE hInstance)
	{
		m_hInstance = hInstance;
		m_hCursor = ::CreateCursor(hInstance, _Link_CursorData.xHotSpot, _Link_CursorData.yHotSpot, _Link_CursorData.cxWidth, _Link_CursorData.cyHeight, _Link_CursorData.arrANDPlane, _Link_CursorData.arrXORPlane);
	}

public: //Message Handlers
	BOOL _OnSetCursor(HWND hwnd, HWND hwndCursor, UINT codeHitTest, UINT msg)
	{
		POINT pt;
		GetCursorPos(&pt);
		ScreenToClient(m_hWnd,&pt);
		if(m_lpstrHyperLink != NULL && ::PtInRect(&m_rcLink, pt))
		{
			return TRUE;
		}
		return (BOOL)CallWindowProc(m_OrigWndProc, hwnd,WM_SETCURSOR,(WPARAM)hwndCursor,MAKELPARAM(codeHitTest,msg));
	}

	UINT _OnGetDlgCode(HWND hwnd, LPMSG lpmsg)
	{
		return DLGC_WANTCHARS;
	}

	void _OnMouseMove(HWND hwnd, int x, int y, UINT keyFlags)
	{
		POINT pt = { x, y};
		if(m_lpstrHyperLink != NULL && PtInRect(&m_rcLink, pt))
			SetCursor(m_hCursor);
	}

	void _OnFocus(HWND hwnd, HWND hwndOldFocus)
	{
		Invalidate();
	}

	void _OnLButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags)
	{
		POINT pt = { x, y };
		if(PtInRect(&m_rcLink, pt))
		{
			SetFocus(m_hWnd);
			SetCapture(m_hWnd);
		}
	}

	void _OnPaint(HWND hwnd)
	{
		PAINTSTRUCT ps;
		HDC hDC = BeginPaint(hwnd, &ps);
		m_hWnd = hwnd;
		DoPaint(hDC);
		EndPaint(hwnd, &ps);
	}

	void _OnChar(HWND hwnd, TCHAR ch, int cRepeat)
	{
		if(ch == VK_RETURN || ch == VK_SPACE)
			Navigate();
	}

	BOOL _OnEraseBkgnd(HWND hwnd, HDC hdc)
	{
/*		if(m_bPaintLabel)*/
		{
			HBRUSH hBrush = (HBRUSH)::SendMessage(GetParent(hwnd), WM_CTLCOLORSTATIC, (WPARAM)hdc, (LPARAM)m_hWnd);
			if(hBrush != NULL)
			{
				RECT rect;
				GetClientRect(m_hWnd, &rect);
				FillRect(hdc, &rect, hBrush);
			}
		}
		return 1;
	}

	void _OnLButtonUp(HWND hwnd, int x, int y, UINT keyFlags)
	{
		if(GetCapture() == m_hWnd)
		{
			ReleaseCapture();
			POINT pt = { x, y };
			if(PtInRect(&m_rcLink, pt))
				Navigate();
		}
	}

	void DoPaint(HDC hDC)
	{
		if (m_PaintedFocusRect)
		{
			m_PaintedFocusRect = false;
			DrawFocusRect(hDC, &m_rcLink);
		}

		SetBkMode(hDC, TRANSPARENT);
		SetTextColor(hDC, m_clrLink);
		if(m_hFont != NULL)
			SelectFont(hDC, m_hFont);

		LPTSTR lpstrText = (m_lpstrLabel != NULL) ? m_lpstrLabel : m_lpstrHyperLink;

		LONG_PTR dwStyle = GetWindowLongPtr(m_hWnd,GWL_STYLE);

		int nDrawStyle = DT_LEFT;
		if (dwStyle & SS_CENTER)
			nDrawStyle = DT_CENTER;
		else if (dwStyle & SS_RIGHT)
			nDrawStyle = DT_RIGHT;

		DrawText(hDC, lpstrText, -1, &m_rcLink, nDrawStyle | DT_WORDBREAK);

		if((GetFocus() == m_hWnd)&&(!m_PaintedFocusRect))
		{
			m_PaintedFocusRect = true;
			DrawFocusRect(hDC, &m_rcLink);
		}
	}

	bool CalcLabelRect()
	{
		if(m_lpstrLabel == NULL && m_lpstrHyperLink == NULL)
			return false;

		HDC hDC = GetDC(m_hWnd);

		RECT rect;
		GetClientRect(m_hWnd, &rect);
		m_rcLink = rect;

		HFONT hOldFont = NULL;
		if(m_hFont != NULL)
			hOldFont = SelectFont(hDC, m_hFont);
		LPTSTR lpstrText = (m_lpstrLabel != NULL) ? m_lpstrLabel : m_lpstrHyperLink;

		DWORD dwStyle = (DWORD)GetWindowLongPtr(m_hWnd,GWL_STYLE);
		int nDrawStyle = DT_LEFT;
		if (dwStyle & SS_CENTER)
			nDrawStyle = DT_CENTER;
		else if (dwStyle & SS_RIGHT)
			nDrawStyle = DT_RIGHT;
		DrawText(hDC, lpstrText, -1, &m_rcLink, nDrawStyle | DT_WORDBREAK | DT_CALCRECT);
		if(m_hFont != NULL)
			SelectFont(hDC, hOldFont);
		return true;
	}

	bool SetLabel(LPCTSTR lpstrLabel)
	{
		free(m_lpstrLabel);
		m_lpstrLabel = NULL;
		int ilen = lstrlen(lpstrLabel) + 1;
		m_lpstrLabel = (LPTSTR)malloc(ilen * sizeof(TCHAR));
		if(m_lpstrLabel == NULL)
			return false;
		//lstrcpy(m_lpstrLabel, lpstrLabel);
		if (FAILED(StringCchCopyEx(m_lpstrLabel, ilen, lpstrLabel, NULL, NULL, MISTSAFE_STRING_FLAGS)))
		{
			free(m_lpstrLabel);
			m_lpstrLabel = NULL;
			return false;
		}
		CalcLabelRect();
		return true;
	}

#if 0
	bool GetLabel(LPTSTR lpstrBuffer, int nLength)
	{
		if (NULL != m_lpstrLabel &&
			nLength > lstrlen(m_lpstrLabel) &&
			SUCCEEDED(StringCchCopyEx(lpstrBuffer, nLength, m_lpstrLabel, NULL, NULL, MISTSAFE_STRING_FLAGS)))
		{
			return true;
		}
		return false;
	}
#endif

	bool SetHyperLink(LPCTSTR lpstrLink)
	{
		free(m_lpstrHyperLink);
		m_lpstrHyperLink = NULL;
		int ilen = lstrlen(lpstrLink) + 1;
		m_lpstrHyperLink = (LPTSTR)malloc(ilen * sizeof(TCHAR));
		if(m_lpstrHyperLink == NULL)
			return false;
		if (FAILED(StringCchCopyEx(m_lpstrHyperLink, ilen, lpstrLink, NULL, NULL, MISTSAFE_STRING_FLAGS)))
		{
			free(m_lpstrHyperLink);
			m_lpstrHyperLink = NULL;
			return false;
		}
		if(m_lpstrLabel == NULL)
			CalcLabelRect();
		return true;
	}

#if 0
	bool GetHyperLink(LPTSTR lpstrBuffer, int nLength)
	{
		if (NULL != m_lpstrHyperLink &&
			nLength > lstrlen(m_lpstrHyperLink) &&
			SUCCEEDED(StringCchCopyEx(lpstrBuffer, nLength, m_lpstrHyperLink, NULL, NULL, MISTSAFE_STRING_FLAGS)))
		{
			return true;
		}
		return false;
	}
#endif

private:
//	BOOL bInit;
	BOOL m_IsHtmlHelp;
	HWND m_hWnd;
	WNDPROC m_OrigWndProc;

	LPTSTR m_lpstrLabel;
	LPTSTR m_lpstrHyperLink;
	HCURSOR m_hCursor;
//	bool m_bPaintLabel;
	HFONT m_hFont;
	RECT m_rcLink;

	bool m_PaintedFocusRect;
	COLORREF m_clrLink; //set once

	HINSTANCE m_hInstance;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\testiu\audownload.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       catalog.cpp
//
//--------------------------------------------------------------------------

#include "audownload.h"
#pragma hdrstop

const WCHAR AUJOBNAME[] = L"TestIU";


CAUDownloader::~CAUDownloader()
{
       IBackgroundCopyJob  * pjob;
       HRESULT hr ;
	// fixcode optimization check if m_refs != 0
	DEBUGMSG("CAUDownloader::~CAUDownloader() starts");
	
	if ( SUCCEEDED(FindDownloadJob(&pjob)))
	{
		DEBUGMSG("Found bits notify interface to release");
		if (FAILED(hr = pjob->SetNotifyInterface(NULL)))
		{
			DEBUGMSG(" failed to delete job notification interface %#lx", hr);
		}
		pjob->Release();
	}

	if ( FAILED(hr = CoDisconnectObject((IUnknown *)this, 0)) )
	{
		DEBUGMSG("CoDisconnectObject() failed %#lx", hr);
	}

	DEBUGMSG("WUAUENG: CAUDownloader destructed with m_refs = %d", m_refs);
}	

///////////////////////////////////////////////////////////////////////////////////
// when service starts up, find last download job if there is one and reconnect AU to drizzle 
//////////////////////////////////////////////////////////////////////////////////
HRESULT CAUDownloader::ContinueLastDownloadJob(const GUID & downloadid)
{	
    HRESULT hr = S_OK;
    IBackgroundCopyJob * pjob = NULL;
    DEBUGMSG("CAUDownloader::ContinueLastDownloadJob() starts");
       if (GUID_NULL != downloadid)
        {
            m_DownloadId = downloadid;
            if (SUCCEEDED(hr = FindDownloadJob(&pjob)) && SUCCEEDED(hr = ReconnectDownloadJob()))
                {
                //fixcode: print out job id
                DEBUGMSG("found and connected to previous download job ");
                goto done;
                }
            else
                {
                DEBUGMSG("fail to find or connect to previous download job");
                m_DownloadId = GUID_NULL;
                }
       }
done:           
       SafeRelease(pjob);
       DEBUGMSG("CAUDownloader::ContinueLastDownloadJob() ends");
	return hr;
}


HRESULT CAUDownloader::CreateDownloadJob(IBackgroundCopyJob **ppjob)
{
    IBackgroundCopyManager * pmanager = NULL;
    HRESULT hr;

    if (FAILED(hr = CoCreateInstance(__uuidof(BackgroundCopyManager),
                                     NULL,
                                     CLSCTX_ALL,
                                     __uuidof(IBackgroundCopyManager),
                                     (void **)&pmanager )))
     {
       DEBUGMSG("CreateDownloadJob : create manager failed %x ", hr);
       goto done;
     }

    if (FAILED(hr=pmanager->CreateJob( AUJOBNAME ,
                                      BG_JOB_TYPE_DOWNLOAD,
                                      &m_DownloadId,
                                      ppjob )))
      {
        DEBUGMSG("CreateDownloadJob : create job failed %x ", hr);
        goto done;
      }

#ifdef DBG 
	WCHAR szGUID[MAX_PATH+1];
	int iret;
	
	iret = StringFromGUID2(m_DownloadId, //GUID to be converted  
						szGUID,  //Pointer to resulting string
						MAX_PATH);//Size of array at lpsz
	if (0 != iret)
	{
		DEBUGMSG("WUAUENG m_DownloadId = %S, charret = %d", szGUID, iret);
	}
#endif

	if (FAILED(hr = SetDrizzleNotifyInterface()))
        {
        DEBUGMSG("CreateDownloadJob : set notification interface failed %x", hr);
    	}
done:
       SafeRelease(pmanager);
	if (FAILED(hr))
	{
        m_DownloadId = GUID_NULL;
        Reset();
        SafeRelease(*ppjob);
        }
        return hr;
}


HRESULT CAUDownloader::FindDownloadJob(IBackgroundCopyJob ** ppjob)
{
    IBackgroundCopyManager * pmanager = NULL;
    HRESULT hr;

    if (FAILED(hr = CoCreateInstance(__uuidof(BackgroundCopyManager),
                                     NULL,
                                     CLSCTX_ALL,
                                     __uuidof(IBackgroundCopyManager),
                                     (void **)&pmanager )))
        {
        DEBUGMSG("FindDownloadJob : create manager failed %x ", hr);
        goto done;
        }

    if (FAILED(hr=pmanager->GetJob(m_DownloadId, ppjob )))
        {
        //            DEBUGMSG("FindDownloadJob : get job failed %x ", hr); //might be expected
        }
done:
    SafeRelease(pmanager);
    return hr;
}



///////////////////////////////////////////////////////////////////////////////////
// Get the puid causing downloading problem and error message
// pCat:   IN  pointer to the catalog 
// pBGErr: IN  pointer to background error 
// puid:   OUT stores the puid of the errornous file
// pwszErrDesc: OUT stores the error description from drizzle
///////////////////////////////////////////////////////////////////////////////////
/*
BOOL GetDownloadErr(Catalog *pCat,  IBackgroundCopyError *pBGErr, PUID &puid, LPTSTR tszErrDesc, UINT uErrDescSize)
{
	IBackgroundCopyFile *pBGFile = NULL;
	HRESULT hr;
	BOOL fRet = TRUE;
	LPWSTR wszErrFile = NULL;
	
	USES_CONVERSION;

	//DEBUGMSG("GetDownloadErr() starts");

	if (FAILED(hr = pBGErr->GetFile(&pBGFile)))
	{
		fRet = FALSE;
		goto done;
	}
	pBGFile->GetRemoteName(&wszErrFile);
	pCat->Filename2Puid(W2T(wszErrFile), puid);
	if (NULL != wszErrFile)
	{
		CoTaskMemFree(wszErrFile);
	}
	BG_ERROR_CONTEXT bgErrContext = BG_ERROR_CONTEXT_NONE;
	HRESULT hrErr = E_FAIL;
	pBGErr->GetError(&bgErrContext, &hrErr);
	_sntprintf(tszErrDesc, uErrDescSize * sizeof(tszErrDesc[0]), _T("code:%#lxContext:%d"), hrErr, bgErrContext);

done:
	SafeRelease(pBGFile);
	//DEBUGMSG("GetDownloadErr() ends");
	return fRet;

}


BOOL PingDownloadStatusData::Init(BOOL fDownloadOk, Catalog *pCat, IBackgroundCopyError *pBGErr)
{
	LONG lPuidNum = 0;
    PUID *pPUIDs = NULL;

	//DEBUGMSG("DownloadStatusData::Init() starts");
	if (NULL == pCat)
	    {
	    DEBUGMSG("PingDownloadStatusData::Init() got invalid parameter");
	    return FALSE;
	    }
	m_fDownloadOk = fDownloadOk;
	if (m_fDownloadOk)
	{
		m_uPuidNum = 0;
		m_pPuids = NULL;
	}
	else
	{
		m_errPuid = 0;
		ZeroMemory(&m_tszErrDesc, DOWNLOAD_ERR_DESC_SIZE * sizeof(TCHAR));
	}
	if (fDownloadOk)
	{
		if (FAILED(pCat->GetFinalPuidList(&lPuidNum, &pPUIDs)))
		{
			DEBUGMSG("DownloadStatusData::Init failed on call to GetFinalPuidList()");
			return FALSE;
		}		
		m_uPuidNum = lPuidNum;
		m_pPuids = pPUIDs;
	}
	else
	{
		//get problematic file and its puid
		GetDownloadErr(pCat, pBGErr, m_errPuid , m_tszErrDesc, DOWNLOAD_ERR_DESC_SIZE);
	}
	//DEBUGMSG("DownloadStatusData::Init() ends");
	return TRUE;
}
*/



STDMETHODIMP
CAUDownloader::JobTransferred(
    IBackgroundCopyJob * pjob
    )
{
    HRESULT hr;

#if DBG
    //
    // Make sure the right job is finished.
    //
    {
    GUID jobId;

    if (FAILED( hr= pjob->GetId( &jobId )))
        {
        return hr;
        }

    if ( jobId != m_DownloadId )
        {
        DEBUGMSG("notified of completion of a download job that I don't own");
        }
    }
#endif

    //
    // Transfer file ownership from downloader to catalogue.
    //
    if (FAILED(hr= pjob->Complete()))
        {
        return hr;
        }

//    PingDownloadStatusData tDownloadStatusData;
//    tDownloadStatusData.Init(TRUE, catalog);
    m_DoDownloadStatus(CATMSG_DOWNLOAD_COMPLETE, NULL);

    return S_OK;
}

STDMETHODIMP
CAUDownloader::JobError(
    IBackgroundCopyJob * pjob,
    IBackgroundCopyError * perror
    )
{
	BG_ERROR_CONTEXT bgEContext;
	HRESULT hr;

        // download encounter error
//	PingDownloadStatusData tDownloadStatusData;
//	tDownloadStatusData.Init(FALSE, catalog, perror);
	m_DoDownloadStatus(CATMSG_DOWNLOAD_ERROR, NULL);

	if (SUCCEEDED(perror->GetError(&bgEContext, &hr)))
	{
		DEBUGMSG("WUAUNEG JobError callback Context = %d, hr = 0x%x",bgEContext, hr);
	}

       Reset();
       return S_OK;
}

STDMETHODIMP
CAUDownloader::JobModification(
    IBackgroundCopyJob * pjob,
    DWORD  /*dwReserved*/
    )
{
	BG_JOB_STATE state;
	HRESULT hr;
    if (FAILED(hr= pjob->GetState(&state)))
        {
        return hr;
        }

	if (m_dwJobState == state)
	{
		goto Done;
	}
	DEBUGMSG("WUAUENG JobModification callback");
	switch (state)
	{
	case BG_JOB_STATE_QUEUED: 	
		DEBUGMSG("WUAUENG JobModification: Drizzle notified BG_JOB_STATE_QUEUED");
		break;
	case BG_JOB_STATE_TRANSFERRING:
		DEBUGMSG("WUAUENG JobModification: Drizzle notified BG_JOB_STATE_TRANSFERRING");
		m_DoDownloadStatus(CATMSG_DOWNLOAD_IN_PROGRESS); 	
		break;
	case BG_JOB_STATE_TRANSIENT_ERROR:
		{
			DEBUGMSG("WUAUENG JobModification: Drizzle notified BG_JOB_STATE_TRANSIENT_ERROR");
			m_DoDownloadStatus(CATMSG_TRANSIENT_ERROR);			
			break;
		}		
	case BG_JOB_STATE_CANCELLED:
		{
			DEBUGMSG("WUAUENG JobModification: Drizzle notified BG_JOB_STATE_CANCELLED");
			m_DoDownloadStatus(CATMSG_DOWNLOAD_CANCELED);
			break;
		}
	case BG_JOB_STATE_SUSPENDED:
	case BG_JOB_STATE_ERROR:			//What about BG_JOB_STATE_ERROR ?
	case BG_JOB_STATE_TRANSFERRED:
	case BG_JOB_STATE_ACKNOWLEDGED:	
    case BG_JOB_STATE_CONNECTING:
		{
			DEBUGMSG("WUAUENG JobModification: Drizzle notified BG_JOB_STATE = %d", state);
			break;
		}
	default:
		{
		DEBUGMSG("WUAUENG Drizzle notified unexpected BG_JOB_STATE %d",state);
		}
	}
	m_dwJobState = state;
Done:
	return S_OK;
}

HRESULT CAUDownloader::SetDrizzleNotifyInterface()
{
	HRESULT hr ;
       IBackgroundCopyJob * pjob = NULL;
       
       if (FAILED(hr = FindDownloadJob(&pjob)))
        {
            DEBUGMSG("CAUDownloader::SetDrizzleNotifyInterface() got no download job with error %#lx", hr);
            goto done;
        }
	if (FAILED(hr = pjob->SetNotifyFlags(DRIZZLE_NOTIFY_FLAGS)))
	{
		DEBUGMSG("WUAUENG SetDrizzleNotifyInterface: set notification flags failed %#lx", hr);
	}
	else if (FAILED(hr = pjob->SetNotifyInterface(this)))
	{
		DEBUGMSG("WUAUENG SetDrizzleNotifyInterface: set notification interface failed %#lx", hr);
	}
	
done:
       SafeRelease(pjob);
	return hr;
}

///////////////////////////////////////////////////////////////////////////////////////
// helper function to connect AU to the job got using its GUID
//////////////////////////////////////////////////////////////////////////////////////
HRESULT CAUDownloader::ReconnectDownloadJob()
{
	BG_JOB_STATE state;		
	HRESULT hr = E_FAIL;
       IBackgroundCopyJob * pjob = NULL;
       
	DEBUGMSG("ReconnectDownloadJob() starts");
	if ( (FAILED(hr = FindDownloadJob(&pjob)))
	   || FAILED(hr = pjob->GetState(&state)))
	{  
	    DEBUGMSG("get no download job or fail to get job state");
           goto Done;
	}	
	switch (state)
	{
	case BG_JOB_STATE_QUEUED: 
	case BG_JOB_STATE_TRANSFERRING:
	case BG_JOB_STATE_CONNECTING:
	case BG_JOB_STATE_TRANSIENT_ERROR:
	case BG_JOB_STATE_SUSPENDED:		
	case BG_JOB_STATE_ERROR:
		{
			DEBUGMSG("WUAUENG Trying to connect to drizzle again");
			if (FAILED(hr = SetDrizzleNotifyInterface()))
			{
				goto Done;				
			}			
			//fixcode: why need resume if error?
			if (BG_JOB_STATE_ERROR == state)
			{
				pjob->Resume();		//REVIEW, Is this really what we want to do?
			}
			break;
		}				
	case BG_JOB_STATE_TRANSFERRED:
		{
			DEBUGMSG("WUAUENG  Got BG_JOB_STATE_TRANSFERRED should work ok");
			if (FAILED(hr = pjob->Complete()))
			{
				goto Done;
			}
//			PingDownloadStatusData tDownloadStatusData;
	//		tDownloadStatusData.Init(TRUE, catalog);
			m_DoDownloadStatus(CATMSG_DOWNLOAD_COMPLETE, NULL );
			break;
		}
	case BG_JOB_STATE_ACKNOWLEDGED:
		{
			//If the job was already acknowledged, we are assuming that the engine can continue
			DEBUGMSG("WUAUENG : Got BG_JOB_STATE_ACKNOWLEDGED should work ok");
			break;
		}
	case BG_JOB_STATE_CANCELLED:
		{
			DEBUGMSG("WUAUENG : Got BG_JOB_STATE_CANCELLED, should start again");
			goto Done;			
		}
	default:
		{
		DEBUGMSG("WUAUENG Drizzle notified unexpected BG_JOB_STATE");		
		}
	}
	hr = S_OK;
	m_dwJobState = state;	
Done:
       if (FAILED(hr))
        {
           Reset();
        }
       SafeRelease(pjob);
     	DEBUGMSG("ReconnectDownloadJob() ends");
	return hr;
}



/*****
CAUDownloader::QueueDownloadFile() adds a file to download to drizzle's 

RETURNS:
    S_OK:    
*****/
HRESULT CAUDownloader::QueueDownloadFile(LPCTSTR pszServerUrl,				// full http url
			LPCTSTR pszLocalFile				// local file name
			)
{
    HRESULT hr = S_OK;

    DEBUGMSG("CAUDownloader::DownloadFile() starts");
    
    IBackgroundCopyJob * pjob = NULL;
    if (FAILED(hr = FindDownloadJob(&pjob)))
    {
         DEBUGMSG("no existing download job, create one ");
         if (FAILED(hr = CreateDownloadJob(&pjob)))
            {
            DEBUGMSG("fail to create a new download job");
            goto done;
            }
     }

    //fixcode: do we need to pause job first before adding files
    
    //
    // Add the file to the download job.
    //
   hr = pjob->AddFile( pszServerUrl, pszLocalFile);
    if (FAILED(hr))
    {
        DEBUGMSG(" adding file failed with %#lx", hr);
        goto done;
    }

done:
	if ( FAILED(hr) )
	{
		Reset();
	}
      SafeRelease(pjob);
      return hr;
}


HRESULT CAUDownloader::StartDownload()
{
    HRESULT hr = E_FAIL;
    IBackgroundCopyJob * pjob = NULL;

    if (FAILED(hr = FindDownloadJob(&pjob)))
        {
        DEBUGMSG(" fail to get download job with error %#lx", hr);
        goto done;
        }
    if (FAILED(hr = pjob->Resume()))
    {
        DEBUGMSG("  failed to start the download job");
    }
done:
    SafeRelease(pjob);
    return hr;
}

//////////////////////////////////////////////////////////////////////////////////
// cancel the job and reset CAUDownloader's state 
/////////////////////////////////////////////////////////////////////////////////
void CAUDownloader::Reset()
{
    IBackgroundCopyJob * pjob = NULL;
    
    if (SUCCEEDED(FindDownloadJob(&pjob)))
        {
            pjob->Cancel();
            pjob->Release();
        }
    m_dwJobState = NO_BG_JOBSTATE;	
    m_DownloadId = GUID_NULL;
}

HRESULT CAUDownloader::DrizzleOperation(DRIZZLEOPS dop)
{
    HRESULT hrRet;
    IBackgroundCopyJob * pjob = NULL;
    if (FAILED(hrRet = FindDownloadJob(&pjob)))
    {
        DEBUGMSG("CAUDownloader::DrizzleOperation() on an invalid job");
        goto done;
    }
    switch (dop)
    	{
	case  DRIZZLEOPS_CANCEL: 
		DEBUGMSG("Catalog: Canceling Drizzle Job");
		hrRet =pjob->Cancel();
		break;
	case DRIZZLEOPS_PAUSE:
		DEBUGMSG("Catalog: Pausing Drizzle Job");
		hrRet = pjob->Suspend();		
		break;
	case DRIZZLEOPS_RESUME:
		DEBUGMSG("Catalog: Resuming Drizzle Job");
		hrRet = pjob->Resume();		
		break;
    	}
done:
    SafeRelease(pjob);
    return hrRet;
}

/// pdwstatus actually contains the jobstate
HRESULT CAUDownloader::getStatus(DWORD *pdwPercent, DWORD *pdwstatus)
{
    BG_JOB_PROGRESS progress;
    BG_JOB_STATE state;
    HRESULT hr = S_OK;
    IBackgroundCopyJob * pjob = NULL;

    if (FAILED(hr = FindDownloadJob(&pjob)))
        {
        DEBUGMSG(" getStatus : no download job with error %#lx", hr);
        goto done;
        }

    if (FAILED(hr = pjob->GetState( &state )))
        {
	    DEBUGMSG("WUAUENG: job->GetState failed");
           state = BG_JOB_STATE_QUEUED;
           goto done;
        }

    if (FAILED(hr = pjob->GetProgress( &progress )))
        {
	    DEBUGMSG("WUAUENG: job->GetProgress failed");
	    goto done;
        }
    
    if (progress.BytesTotal != BG_SIZE_UNKNOWN )
       {
           *pdwPercent = DWORD( 100 * float(progress.BytesTransferred) / float(progress.BytesTotal) );
           DEBUGMSG("getStatus is %d percent", *pdwPercent);
       }
     else
        {
            DEBUGMSG("getStatus, progress.BytesTotal= BG_SIZE_UNKNOWN, BytesTransfered = %d",progress.BytesTransferred);
           *pdwPercent = 0;       
        }

	*pdwstatus =  state;

done:
    SafeRelease(pjob);
    return hr;
}


HRESULT STDMETHODCALLTYPE
CAUDownloader::QueryInterface(
    REFIID riid,
    void __RPC_FAR *__RPC_FAR *ppvObject
    )
{
    HRESULT hr = S_OK;
    *ppvObject = NULL;

    if (riid == __uuidof(IUnknown) ||
        riid == __uuidof(IBackgroundCopyCallback) )
        {
        *ppvObject = (IBackgroundCopyCallback *)this;
        ((IUnknown *)(*ppvObject))->AddRef();
        }
    else
        {
        hr = E_NOINTERFACE;
        }

    return hr;
}

ULONG STDMETHODCALLTYPE
CAUDownloader::AddRef()
{
    long cRef = InterlockedIncrement(&m_refs);
	DEBUGMSG("CAUDownloader AddRef = %d", cRef);
	return cRef;
}

ULONG STDMETHODCALLTYPE
CAUDownloader::Release()
{
    long cRef = InterlockedDecrement(&m_refs);
	DEBUGMSG("CAUDownloader Release = %d", cRef);
	return cRef;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\testiu\audownload.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:     audownload.h
//
//--------------------------------------------------------------------------

#pragma once
#include <windows.h>
//#include "aucatitem.h"
//#include "aucatalog.h"
//#include "catalog.h"
#include <initguid.h>
#include <bits.h>
#include <cguid.h>
#include <testiu.h>

//class Catalog;

#define NO_BG_JOBSTATE				-1
#define CATMSG_DOWNLOAD_COMPLETE	1
#define CATMSG_TRANSIENT_ERROR		2	//This comes from drizzle, for example if internet connection is lost
#define CATMSG_DOWNLOAD_IN_PROGRESS 3
#define CATMSG_DOWNLOAD_CANCELED	4
#define CATMSG_DOWNLOAD_ERROR		5

#define DRIZZLE_NOTIFY_FLAGS	BG_NOTIFY_JOB_TRANSFERRED | BG_NOTIFY_JOB_ERROR | BG_NOTIFY_JOB_MODIFICATION

/*
typedef struct tagPingDownloadStatusData {
	static const UINT DOWNLOAD_ERR_DESC_SIZE = 50;
	BOOL m_fDownloadOk;
	union {
		struct {
			UINT  m_uPuidNum;
			PUID* m_pPuids;
		};
		struct {
			PUID  m_errPuid;
			TCHAR m_tszErrDesc[DOWNLOAD_ERR_DESC_SIZE]; 
		};
	};

	BOOL Init(BOOL fDownloadOk, Catalog *pCat, IBackgroundCopyError *pBGErr=NULL);
} PingDownloadStatusData;


typedef struct tagQueryFilesForPuidCallbackData{
	BOOL fFound;
	LPCTSTR ptszRemoteFile;
} QueryFilesForPuidCallbackData;

typedef void (*DWNLDCALLBACK)(DWORD dwCallbackMsg, PingDownloadStatusData * ptDownloadStatusData = NULL);
*/
typedef void (*DWNLDCALLBACK)(DWORD dwCallbackMsg, PVOID ptDownloadStatusData = NULL);


typedef enum tagDRIZZLEOPS {
	DRIZZLEOPS_CANCEL = 1,
	DRIZZLEOPS_PAUSE ,
	DRIZZLEOPS_RESUME
} DRIZZLEOPS;



///////////////////////////////////////////////////////////////////////////
// Wrapper class for drizzle download operation
// also implements drizzle notification callbacks
//////////////////////////////////////////////////////////////////////////
class CAUDownloader : public IBackgroundCopyCallback
{
public:
    // IUnknown methods
    HRESULT STDMETHODCALLTYPE QueryInterface(
        /* [in] */ REFIID riid,
        /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

    ULONG STDMETHODCALLTYPE AddRef( void);

    ULONG STDMETHODCALLTYPE Release( void);

    // IBackgroundCopyCallback methods

    HRESULT STDMETHODCALLTYPE JobTransferred(
        /* [in] */ IBackgroundCopyJob *pJob);

    HRESULT STDMETHODCALLTYPE JobError(
        /* [in] */ IBackgroundCopyJob *pJob,
        /* [in] */ IBackgroundCopyError *pError);

    HRESULT STDMETHODCALLTYPE JobModification(
        /* [in] */ IBackgroundCopyJob*,
        /* [in] */ DWORD );


	CAUDownloader(DWNLDCALLBACK pfnCallback):
			m_DownloadId(GUID_NULL),
			m_dwJobState(NO_BG_JOBSTATE),
			m_DoDownloadStatus(pfnCallback),
			m_refs(0)
			{};
	~CAUDownloader();

	HRESULT ContinueLastDownloadJob(const GUID & guidDownloadId);
	//the following two could be combined into DownloadFiles() in V4
	HRESULT QueueDownloadFile(LPCTSTR pszServerUrl,				// full http url
			LPCTSTR pszLocalFile				// local file name
			);
	HRESULT StartDownload();
	HRESULT DrizzleOperation(DRIZZLEOPS);
	HRESULT getStatus(DWORD *percent, DWORD *pdwstatus);
	GUID 	getID() 
		{
			return m_DownloadId;
		}
private:
	HRESULT SetDrizzleNotifyInterface();
	HRESULT InitDownloadJob(const GUID & guidDownloadId);	
	HRESULT ReconnectDownloadJob();
	HRESULT CreateDownloadJob(IBackgroundCopyJob ** ppjob);
	HRESULT FindDownloadJob(IBackgroundCopyJob ** ppjob);
	void 	Reset();

	long m_refs;
	GUID m_DownloadId;                  // id what m_pjob points to. 
	DWORD m_dwJobState;			//Job State from drizzle, used in JobModification callback
	DWNLDCALLBACK	m_DoDownloadStatus; //callback function to notify user of download state change

// Friend functions (callbacks)
//	friend void QueryFilesExistCallback(void*, long, LPCTSTR, LPCTSTR);
	
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\testiu\auxml.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       auxml.h
//
//  About:  header file for AU related XML and schema data structure and functions
//--------------------------------------------------------------------------

#pragma once
#include <windows.h>
#include <ole2.h>
#include <msxml2.h>
#include "testiu.h"


class CItemDetails {
	public:
		CItemDetails() : m_pxml(NULL) {};
		~CItemDetails() {};
		BOOL Init(BSTR bsxml);
		void Uninit();
		IXMLDOMNode * CloneIdentityNode(BSTR bsItemId);
		IXMLDOMNode * CloneDescriptionNode(BSTR bsItemId);
		IXMLDOMNode * ClonePlatformNode(BSTR bsItemId);
		BSTR GetItemDownloadPath(BSTR bstrItemId);
		HRESULT FindNextItemId(BSTR bsPrevItemId, BSTR * pbsNextItemId);
		HRESULT GetTitle(BSTR bsItemId, BSTR * pbsTitle);
		HRESULT GetDescription(BSTR bsItemId, BSTR *pbsDescription);
		HRESULT GetCompanyName(BSTR bsItemId, BSTR *pbsCompanyName);
		HRESULT GetRTFUrl(BSTR bsItemId, BSTR *pbsRTFUrl);
		HRESULT GetEulaUrl(BSTR bsItemId, BSTR *pbsEulaUrl);
		HRESULT GetCabNames(BSTR bsItemId, BSTR ** ppCabNames, UINT *pCabsNum);
	private:
		IXMLDOMDocument2 * m_pxml;
		IXMLDOMNode * getIdentityNode(BSTR bsItemId);
		IXMLDOMNode * getItemNode(BSTR bsItemId);

};

CItemList * ExtractNormalItemInfo(BSTR bsDetails);
CItemList* ExtractDriverItemInfo(BSTR bsDetails) ;
BSTR BuildDownloadResult(BSTR bsItemDetails, CItemList *pItemList);
BSTR DBGReadXMLFromFile(LPCWSTR wszFile);
void DBGDumpXMLDocProperties(IXMLDOMDocument2 *pDoc);
void DBGShowNodeName(IXMLDOMNode *pNode);
void DBGDumpXMLNode(IXMLDOMNode *pNode);
HRESULT MergeCatalogs(BSTR bsCatalog1, BSTR bsCatalog2, BSTR *pDesCat );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\testiu\auxml.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       auxml.cpp
//
//  About:  source file for AU related XML and schema data structure and functions
//--------------------------------------------------------------------------
#include "auxml.h"

const LPCWSTR DEFAULT_COMPANY_NAME = L"Microsoft";

HRESULT GetCabsDownloadPath(LPTSTR lpszDir, UINT uDirSize);

void DBGDumpXMLNode(IXMLDOMNode *pNode)
{
    BSTR bsNodeName;
    pNode->get_nodeName(&bsNodeName);
    BSTR bsNodeXML;
    pNode->get_xml(&bsNodeXML);
    DEBUGMSG("XML for %S is %S", bsNodeName, bsNodeXML);
    SafeFreeBSTR(bsNodeName);
    SafeFreeBSTR(bsNodeXML);
}

void DBGShowNodeName(IXMLDOMNode *pNode)
{
    BSTR bsNodeName;
    if (SUCCEEDED(pNode->get_nodeName(&bsNodeName)))
        {
        DEBUGMSG("node name is %S", bsNodeName);
        }
    else
        {
        DEBUGMSG("FAIL to get node name");
        }
}

void DBGDumpXMLDocProperties(IXMLDOMDocument2 *pDoc)
{
    BSTR bsSelectionLanguage, bsSelectionNamespaces, bsServerHTTPRequest;
    VARIANT vVal;
    VariantInit(&vVal);
    pDoc->getProperty(L"SelectionLanguage", &vVal);
    DEBUGMSG("XMLDoc selection language is %S", vVal.bstrVal);
    VariantClear(&vVal);
    pDoc->getProperty(L"SelectionNamespaces", &vVal);
    DEBUGMSG("XMLDoc selection namespaces is %S", vVal.bstrVal);
    VariantClear(&vVal);
    pDoc->getProperty(L"ServerHTTPRequest", &vVal);
    DEBUGMSG("XMLDoc ServerHTTPRequest is %s", vVal.boolVal ? "True" : "False");
    VariantClear(&vVal);
}

BSTR DBGReadXMLFromFile(LPCWSTR wszFile)
{
              BSTR bsResult = NULL;
		IXMLDOMDocument2 *pSourceXML;
		if (FAILED(CoCreateInstance(__uuidof( DOMDocument30), NULL, CLSCTX_INPROC_SERVER, __uuidof(IXMLDOMDocument2), (void**)&pSourceXML)))
		{
			DEBUGMSG("DBGReadXMLFromFile() Fail to create source XML ");
		}
		else
		{
			pSourceXML->put_async(VARIANT_FALSE);
			pSourceXML->put_resolveExternals(VARIANT_TRUE);

        		VARIANT vSource;
        		vSource.vt = VT_BSTR;
                     vSource.bstrVal = SysAllocString(wszFile);
                     if (NULL == vSource.bstrVal)
                        {
                        DEBUGMSG("DBGReadXMLFromFile() fail to allocate string");
                        }
                     else
                        {
                            VARIANT_BOOL fSuccess;
                		if (S_OK != pSourceXML->load(vSource, &fSuccess))
                		{
                			DEBUGMSG("DBGReadXMLFromFile() fail to load XML source file");
                		}
                		else
                		{
                			pSourceXML->get_xml(&bsResult);
                		}
                		VariantClear(&vSource);
                        }
			pSourceXML->Release();	
		}
		return bsResult;
}



BOOL CItemDetails::Init(BSTR bsItemDetails)
    {
    BOOL fRet = TRUE;
     if (FAILED(CoCreateInstance(__uuidof(DOMDocument30), NULL, CLSCTX_INPROC_SERVER, __uuidof( IXMLDOMDocument2), (void**)&m_pxml)))
	{
		DEBUGMSG("CItemDetails::Init() fail to create XML document");
		fRet = FALSE;
		goto end;
	}
    	m_pxml->put_async(VARIANT_FALSE);
	m_pxml->put_resolveExternals(VARIANT_TRUE);
	m_pxml->put_validateOnParse(VARIANT_TRUE);
	VARIANT_BOOL fOk;
	if (S_OK != m_pxml->loadXML(bsItemDetails, &fOk))
        {
          DEBUGMSG("CItemDetails::Init() fail to load XML");
          fRet = FALSE;
        }
    end:
        if (!fRet)
            {
            SafeReleaseNULL(m_pxml);
            }
        return fRet;
}


void CItemDetails::Uninit()
{
    SafeRelease(m_pxml);
}

IXMLDOMNode * CItemDetails::getIdentityNode(BSTR bsItemId)
{
    IXMLDOMNode * pIdentityNode = NULL ;
    CAU_BSTR aubsPattern(L"//identity[@itemID=\"");
    HRESULT hr ;
//    DEBUGMSG("CItemDetails::getIdentityNode() starts");

    if (aubsPattern.IsNULL())
        {
        DEBUGMSG("failed to create pattern string");
        goto done;
        }
    if (!aubsPattern.append(bsItemId))
        {
        DEBUGMSG("failed to append string");
        goto done;
        }
    if (!aubsPattern.append(L"\"]"))
        {
        DEBUGMSG("failed to append string");
        goto done;
        }
    if (FAILED(hr = m_pxml->selectSingleNode(aubsPattern, &pIdentityNode)) ||
            NULL == pIdentityNode)
        {
        DEBUGMSG(" failed to find identityNode %#lx", hr);
        }
done:
    //DEBUGMSG("CItemDetails::getIdentityNode() done");
    return pIdentityNode;
}

IXMLDOMNode * CItemDetails::getItemNode(BSTR bsItemId)
{
    IXMLDOMNode * pIdentityNode = getIdentityNode(bsItemId);
    IXMLDOMNode * pItemNode = NULL;
    HRESULT hr;

//    DEBUGMSG("CItemDetails::getItemNode() starts");
    if (NULL == pIdentityNode)
        {
        goto done;
        }
  if (FAILED(hr = pIdentityNode->get_parentNode(&pItemNode)) || NULL == pItemNode)
        {
        DEBUGMSG(" fail to get item node %#lx", hr);
        goto done;
        }

done:
    SafeRelease(pIdentityNode);
    //DEBUGMSG("CItemDetails::getItemNode() ends");
    return pItemNode;
}

    

IXMLDOMNode * CItemDetails::CloneIdentityNode(BSTR bsItemId)
{
    IXMLDOMNode * pIdentityNode ;
    IXMLDOMNode * pCloneIdentityNode = NULL;
    HRESULT hr;

    //DEBUGMSG("CItemDetails::CloneIdentityNode() starts");
    if (NULL == (pIdentityNode = getIdentityNode(bsItemId)))
        {
        goto done;
        }
   if (FAILED(hr = pIdentityNode->cloneNode(VARIANT_TRUE, &pCloneIdentityNode)) ||
          NULL == pCloneIdentityNode)
        {
        DEBUGMSG("CItemDetails::CloneIdentityNode() failed to clone identityNode %#lx", hr);
        }
done:
    SafeRelease(pIdentityNode);
//    DEBUGMSG("CItemDetails::CloneIdentityNode() ends");
    return pCloneIdentityNode;
}

IXMLDOMNode * CItemDetails::CloneDescriptionNode(BSTR bsItemId)
{
    IXMLDOMNode * pItemNode = getItemNode(bsItemId);
    IXMLDOMNode * pDescriptionNode = NULL;
    IXMLDOMNode * pCloneDescriptionNode = NULL;
    CAU_BSTR aubsDescription(L"description");
    HRESULT hr;
     if (NULL == pItemNode)
        {
        goto done;
       }
    if (aubsDescription.IsNULL())
        {
        DEBUGMSG("CItemDetails::CloneDescriptionNode() fail to create description string");
        goto done;
        }
   if (!FindNode(pItemNode, aubsDescription, &pDescriptionNode))
    {
        DEBUGMSG("CItemDetails::CloneDescriptionNode() fail to get description node");
        goto done;
    }
   if (FAILED(hr = pDescriptionNode->cloneNode(VARIANT_TRUE, &pCloneDescriptionNode)) ||
          NULL == pCloneDescriptionNode)
    {
        DEBUGMSG("CItemDetails::CloneDescriptionNode() fail to clone node %#lx", hr);
    }
done:
    SafeRelease(pItemNode);
    SafeRelease(pDescriptionNode);
    return pCloneDescriptionNode;
}


IXMLDOMNode * CItemDetails::ClonePlatformNode(BSTR bsItemId)
{
    IXMLDOMNode * pItemNode = getItemNode(bsItemId);
    IXMLDOMNode * pPlatformNode = NULL;
    IXMLDOMNode * pClonePlatformNode = NULL;
    CAU_BSTR aubsPlatform(L"platform");
    HRESULT hr ;
    if (NULL == pItemNode)
        {
        goto done;
        }
    if (aubsPlatform.IsNULL())
        {
        DEBUGMSG("CItemDetails::ClonePlatformNode() fail to create platform string");
        goto done;
        }
   if (!FindNode(pItemNode, aubsPlatform, &pPlatformNode))
    {
        DEBUGMSG("CItemDetails::ClonePlatformNode() fail to get platform node");
        goto done;
    }
   if (FAILED(hr = pPlatformNode->cloneNode(VARIANT_TRUE, &pClonePlatformNode)))
    {

        DEBUGMSG("CItemDetails::ClonePlatformNode() fail to clone node %#lx", hr);
    }
done:
    SafeRelease(pItemNode);
    SafeRelease(pPlatformNode);
    return pClonePlatformNode;
}

/////////////////////////////////////////////////////////////////////////////////////////
// retrieve cab names associated with an item identified by bsitemid
// called should free ppCabNames allocated in the function
// *pCabsNum contains number of cab names returned
////////////////////////////////////////////////////////////////////////////////////////
HRESULT CItemDetails::GetCabNames(BSTR bsItemId, BSTR ** ppCabNames, UINT *pCabsNum)
{
    IXMLDOMNode * pItemNode = getItemNode(bsItemId);
    IXMLDOMNodeList *pCodeBaseNodes = NULL;
    BSTR * pCabNames = NULL;
    UINT uCabsNum;
    CAU_BSTR aubsCodeBase (L"installation/codeBase");
    CAU_BSTR aubsHREF(L"href");
    HRESULT hr = E_FAIL;
    //DEBUGMSG("CItemDetails::GetCabNames() starts");
    if (aubsCodeBase.IsNULL() || aubsHREF.IsNULL())
        {
        DEBUGMSG("fail to create aubs");
        goto done;
        }
    if (NULL == pItemNode)
        {
        goto done;
        }
    if (FAILED(hr = pItemNode->selectNodes(aubsCodeBase, &pCodeBaseNodes)) || NULL == pCodeBaseNodes)
        {
        DEBUGMSG("Fail to find codebase section");
        goto done;
        }
    pCodeBaseNodes->get_length((long *) &uCabsNum);
    pCabNames = (BSTR*) malloc(uCabsNum * sizeof(BSTR));
    ZeroMemory((PVOID)pCabNames, uCabsNum * sizeof(BSTR));
    if (NULL == pCabNames)
        {
          hr = E_OUTOFMEMORY;
          goto done;
        }
    for (UINT i = 0; i < uCabsNum ; i++)
        {
          IXMLDOMNode *pCodeBaseNode;
          if (FAILED(hr = pCodeBaseNodes->get_item(i, &pCodeBaseNode)))
            {
            DEBUGMSG("Fail to get codebase %d", i);
            goto done;
            }
          if (FAILED(hr = GetAttribute(pCodeBaseNode, aubsHREF, &(pCabNames[i]))))
            {
                DEBUGMSG("Fail to get attribute href");
                pCodeBaseNode->Release();
                goto done;
            }
          pCodeBaseNode->Release();
        }
    *ppCabNames = pCabNames;
    *pCabsNum = uCabsNum;
    done:
        SafeRelease(pCodeBaseNodes);
        SafeRelease(pItemNode);
        if (FAILED(hr))
            {
                if (NULL != pCabNames)
                {
                    for (UINT j = 0; j < uCabsNum; j++)
                        {
                        SafeFreeBSTR(pCabNames[j]);
                        }
                    free(pCabNames);
                }
            }
       // DEBUGMSG("CItemDetails::GetCabNames() ends");
        return hr;
    
}

BSTR CItemDetails::GetItemDownloadPath(BSTR bstrItemId)
{
//    USES_CONVERSION; only needed for ansi version
    BSTR bstrdownloadPath;
    BSTR bstrRet = NULL;
    IXMLDOMNode * pIdentityNode ;

    DEBUGMSG("CItemDetails::GetItemDownloadPath starts");
    if (NULL == (pIdentityNode = getIdentityNode(bstrItemId)))
        {
            goto done;
        }

   if (FAILED(UtilGetUniqIdentityStr(pIdentityNode, &bstrdownloadPath, 0)))
    {
        DEBUGMSG("GetItemDownloadPath() fail to get unique identity string");
        goto done;
    }
    TCHAR tszPath[MAX_PATH];
    GetCabsDownloadPath(tszPath, MAX_PATH);
    lstrcat(tszPath, _T("\\"));
    lstrcat(tszPath, W2T(bstrdownloadPath));
    bstrRet = SysAllocString(T2W(tszPath));
    SysFreeString(bstrdownloadPath);
done:
    SafeRelease(pIdentityNode);
    DEBUGMSG("CItemDetails::GetItemDownloadPath() got %S", bstrRet);
    if (NULL != bstrRet && !EnsureDirExists(W2T(bstrRet)))
        {
        DEBUGMSG("CItemDetails::GetItemDownloadPath() fail to create directory %S", bstrRet);
        SysFreeString(bstrRet);
        bstrRet = NULL;
        }
    return bstrRet;
}


HRESULT CItemDetails::FindNextItemId(BSTR bsPrevItemId, BSTR * pbsNextItemId)
{
   return E_NOTIMPL;
}
    	    
HRESULT CItemDetails::GetTitle(BSTR bsItemId, BSTR * pbsTitle)
{
    return E_NOTIMPL;
}

HRESULT CItemDetails::GetDescription(BSTR bsItemId, BSTR *pbsDescription)
{
    return E_NOTIMPL;
}

HRESULT CItemDetails::GetCompanyName(BSTR bsItemId, BSTR *pbsCompanyName)
{
    return E_NOTIMPL;
}

HRESULT CItemDetails::GetRTFUrl(BSTR bsItemId, BSTR *pbsRTFUrl)
{
    return E_NOTIMPL;
}

HRESULT CItemDetails::GetEulaUrl(BSTR bsItemId, BSTR *pbsEulaUrl)
{
    return E_NOTIMPL;
}
    	    

CItemList* ExtractDriverItemInfo(BSTR bsDetails) 
{
    DEBUGMSG("Extracting driver item information starts");
    return ExtractNormalItemInfo(bsDetails);
    DEBUGMSG("Extracting driver item information done");
}

CItemList* ExtractNormalItemInfo(BSTR bsDetails) 
{
	USES_CONVERSION;
	IXMLDOMDocument2 *pItemDetailsXML;
       IXMLDOMNodeList *pItemNodeList = NULL;
	CItemList *pRet = NULL;
	int i;
	HRESULT hr ;
	CAU_BSTR bsItemPattern(L"catalog/provider/item"); //case sensitive
	CAU_BSTR bsItemIDPattern(L"identity/@itemID");
	CAU_BSTR bsTitlePattern(L"description/descriptionText/title");
	CAU_BSTR bsDescPattern(L"description/descriptionText/text()");
	CAU_BSTR bsRTFUrlPattern(L"description/descriptionText/details/@href");
	CAU_BSTR bsEulaUrlPattern(L"description/descriptionText/eula/@href");
	BSTR pPatterns[] = {
		bsItemIDPattern, bsTitlePattern, bsDescPattern,
		bsRTFUrlPattern, bsEulaUrlPattern };
	CAU_BSTR bsCompanyNamePattern(L"description/descriptionText/title");

       DEBUGMSG("ExtractNormalItemInfo() starts");
//       DEBUGMSG("input string is %S", bsDetails);
	if (bsCompanyNamePattern.IsNULL() || bsItemPattern.IsNULL())
	{
		goto done;
	}

	for (i = 0; i < ARRAYSIZE(pPatterns); i++)
	{
		if (NULL == pPatterns[i])
		{
			goto done;
		}
	}

	if (FAILED(CoCreateInstance(__uuidof(DOMDocument30), NULL, CLSCTX_INPROC_SERVER, __uuidof(   IXMLDOMDocument2), (void**)&pItemDetailsXML)))
	{
		DEBUGMSG("Fail to create XML document for Item Details");
		goto done;
	}
	hr = pItemDetailsXML->put_async(VARIANT_FALSE);

	VARIANT_BOOL fOk;
	hr = pItemDetailsXML->loadXML(bsDetails, &fOk);
	if (S_OK != hr)
	    {
	    DEBUGMSG("ExtractNormalItemInfo(): fail to extract information");
	    goto done;
	    }
	
	hr = pItemDetailsXML->selectNodes(bsItemPattern, &pItemNodeList);
	if (FAILED(hr) || NULL == pItemNodeList)
	{
		DEBUGMSG("ExtractNormalItemInfo() : no item found");
		goto done;
	}
	pRet = new CItemList();
	long lNodeNum;
	pItemNodeList->get_length(&lNodeNum);
	for (i = 0; i < lNodeNum; i++)
	{
		   IXMLDOMNode *pnextItem;
		hr = pItemNodeList->nextNode(&pnextItem);
		if (NULL == pnextItem)
		{
			continue;
		}
		
		//BSTR bsRegIDPattern = L""; //publishername.name to stick into registry when hidden
		
		const char * pFields[] = {
			"ItemID", "Title", "Description", "RTFUrl", "EulaUrl"};
		
		   IXMLDOMNode *pNode;
		CItem *pitem = new CItem();
		for (int j = 0; j < ARRAYSIZE(pPatterns); j++)
		{
			hr = pnextItem->selectSingleNode(pPatterns[j], &pNode);
			if (NULL != pNode)
			{
				BSTR bsItemInfo;
				pNode->get_text(&bsItemInfo);
				pitem->SetField(pFields[j], bsItemInfo);
				pNode->Release();
			}
		}
		
		   IXMLDOMNode *pProvider = NULL;
		pnextItem->get_parentNode(&pProvider);
		if (NULL == pProvider)
		{
			DEBUGMSG("ExtractNormalItemInfo() fail to get provider node");
		}
		else
		{
        		BSTR bsCompanyName = NULL;
			pProvider->selectSingleNode(bsCompanyNamePattern, &pNode);
			if (NULL == pNode)
			{
				DEBUGMSG("ExtractNormalItemInfo() couldn't find company name, default to MS");
				bsCompanyName = SysAllocString(DEFAULT_COMPANY_NAME);
			}
			else
			{
	        		pNode->get_text(&bsCompanyName);
				pNode->Release();
			}
			if (NULL != bsCompanyName) 
			    {
	        		  pitem->SetField("CompanyName", bsCompanyName);
        	                SysFreeString(bsCompanyName);
			    }
			pRet->Add(pitem);
			pProvider->Release();
		}
		pnextItem->Release();
	}
	pItemDetailsXML->Release();
done:
       DEBUGMSG("ExtractNormalItemInfo() ends");
	return pRet;
}

///////////////////////////////////////////////////////////////////
// merge catalog 1 and catalog2 and make it destination catalog *pDesCatalog
///////////////////////////////////////////////////////////////////
HRESULT MergeCatalogs(BSTR bsCatalog1, BSTR bsCatalog2, BSTR *pbsDesCatalog )
{
    IXMLDOMDocument * pCat1 = NULL;
    IXMLDOMDocument * pCat2 = NULL;
    IXMLDOMNodeList *pProviderNodeList = NULL;
    IXMLDOMNode *pCatalogNode = NULL;
    CAU_BSTR aubscatalog(L"catalog");
    CAU_BSTR aubsprovider(L"catalog/provider");
    HRESULT hr = E_FAIL;

    DEBUGMSG("MergeCatalogs() starts");
    if (aubsprovider.IsNULL() ||
aubscatalog.IsNULL() ||
        FAILED(hr = LoadXMLDoc(bsCatalog1, &pCat1)) ||

         FAILED(hr = LoadXMLDoc(bsCatalog2,&pCat2)))
        {
        DEBUGMSG("MergeCatalogs() fail to load xml or fail or allocate string (with error %#lx)", hr);
        goto done;
        }
    if (FAILED(hr = FindSingleDOMNode(pCat1, aubscatalog, &pCatalogNode)))
        {
        DEBUGMSG("Fail to find provider in catalog 1");
        goto done;
        }
    if (NULL == (pProviderNodeList = FindDOMNodeList(pCat2, aubsprovider)))
        {
        DEBUGMSG("Fail to find provider in catalog 2 with error %#lx", hr);
        goto done;
        }
    long lNum;
    pProviderNodeList->get_length(&lNum);
    for (int i = 0; i < lNum; i++)
        {
        IXMLDOMNode * pProviderNode;
        if (FAILED(hr = pProviderNodeList->get_item(i, &pProviderNode)))
            {
            DEBUGMSG("Fail to get item in Provider List with error %#lx", hr);
            goto done;
            }
        if (FAILED(hr = InsertNode(pCatalogNode, pProviderNode)))
            {
            DEBUGMSG("Fail to append provider node from catalog 2 to catalog 1 with error %#lx", hr);
            pProviderNode->Release();
            goto done;
            }
        pProviderNode->Release();
        }
    if (FAILED(hr = pCat1->get_xml(pbsDesCatalog)))
        {
            DEBUGMSG("Fail to get result xml for catalog 1 with error %#lx", hr);
            goto done;
        }
    LOGFILE(MERGED_CATALOG_FILE, *pbsDesCatalog);
done:
    SafeRelease(pCat1);
    SafeRelease(pCat2);
    SafeRelease(pProviderNodeList);
    SafeRelease(pCatalogNode);
    DEBUGMSG("MergeCatalogs() ends");
    return hr;
}
    
IXMLDOMNode * createDownloadItemStatusNode(IXMLDOMDocument * pxml, CItem * pItem, BSTR bsInstallation)
{
    CAU_BSTR aubs_itemStatus(L"itemStatus");
    CAU_BSTR aubs_downloadPath(L"downloadPath");
    CAU_BSTR aubs_downloadStatus(L"downloadStatus");
    CAU_BSTR aubs_downloadStatusValue(L"value");
    IXMLDOMElement * pitemStatus = NULL;
    BOOL fError = FALSE; //no error occurs
    IXMLDOMNode * pIdentity = NULL;
    IXMLDOMNode * pdescription = NULL;
    IXMLDOMNode * pPlatform = NULL;
    IXMLDOMElement *pdownloadStatus = NULL;
    IXMLDOMElement *pdownloadPath = NULL;
    CItemDetails itemDetails;
    BSTR bsItemId = NULL, bsdownloadPath=NULL;
    VARIANT vComplete;
    IXMLDOMNode * pNewNode;
    IXMLDOMNode ** ItemStatusChildren[] = {&pIdentity, &pdescription, &pPlatform};

    DEBUGMSG("CAUCatalog::createDownloadItemStatusNode()  starts");
    if (!itemDetails.Init(bsInstallation))
        {
        DEBUGMSG("fail to init itemdetails");
        fError = TRUE;
        goto done;
        }

    if (aubs_itemStatus.IsNULL() || aubs_downloadPath.IsNULL() ||
         aubs_downloadStatus.IsNULL() || aubs_downloadStatusValue.IsNULL())
        {
            DEBUGMSG("fail to create string");
            fError = TRUE;
            goto done;
        }
        
    bsItemId = pItem->GetField("ItemId");
    DEBUGMSG("creating node for %S", bsItemId);
    if (NULL == bsItemId)
        {
        DEBUGMSG("fails to get item id");
        fError = TRUE;
        goto done;
        }
    if (FAILED(pxml->createElement(aubs_itemStatus, &pitemStatus)) || NULL == pitemStatus)
        {
        DEBUGMSG("fail to create item status node");
        fError = TRUE;
        goto done;
        }

    pIdentity =  itemDetails.CloneIdentityNode(bsItemId);
    pdescription = itemDetails.CloneDescriptionNode(bsItemId);
    pPlatform = itemDetails.ClonePlatformNode(bsItemId);
    if (NULL == pIdentity || NULL == pdescription || NULL == pPlatform)
        {
        fError = TRUE;
        goto done;
        }

  for (int i = 0; i < ARRAYSIZE(ItemStatusChildren); i++)
    {
      if (FAILED(pitemStatus->appendChild(*(ItemStatusChildren[i]), &pNewNode)))
        {
        DEBUGMSG("fail to append identy node");
        fError = TRUE;
        goto done;
        }
    }

     if (FAILED(pxml->createElement(aubs_downloadPath, &pdownloadPath)) || NULL == pdownloadPath)
        {
        DEBUGMSG("fail to create download path node");
        fError = TRUE;
        goto done;
        }

    bsdownloadPath = itemDetails.GetItemDownloadPath(bsItemId);
    if (NULL == bsdownloadPath)
        {
            fError = TRUE;
            goto done;
        }
    
    if (FAILED(pdownloadPath->put_text(bsdownloadPath)))
        {
        DEBUGMSG("fail to set download path text to %S", bsdownloadPath);
        fError = TRUE;
        goto done;
        }
    
    if (FAILED(pitemStatus->appendChild(pdownloadPath, &pNewNode)))
        {
        DEBUGMSG("fail to append download path");
        fError = TRUE;
        goto done;
        }
    
    if (FAILED(pxml->createElement(aubs_downloadStatus, &pdownloadStatus)) || NULL == pdownloadStatus)
        {
        DEBUGMSG("fail to create download status node");
        fError = TRUE;
        goto done;
        }

    vComplete.vt = VT_BSTR;
    vComplete.bstrVal = L"COMPLETE";
    if (FAILED(SetAttribute(pdownloadStatus, aubs_downloadStatusValue, vComplete)))
        {
        DEBUGMSG("fail to set download status attribute");
        fError = TRUE;
        goto done;
        }

    if (FAILED(pitemStatus->appendChild(pdownloadStatus, &pNewNode)))
        {
        DEBUGMSG("fail to append download status node");
        fError = TRUE;
        goto done;
        }

    
done:
    itemDetails.Uninit();
    SafeFreeBSTR(bsItemId);
    SafeFreeBSTR(bsdownloadPath);
    if (fError)
        {
            SafeRelease(pitemStatus);
            pitemStatus = NULL;
        }
    SafeRelease(pIdentity);
    SafeRelease(pPlatform);
    SafeRelease(pdescription);
    SafeRelease(pdownloadPath);
    SafeRelease(pdownloadStatus);
    DEBUGMSG("CAUCatalog::createDownloadItemStatusNode() ends");
    return pitemStatus;
}

IXMLDOMDocument2 * CreateXMLDoc()
{
	IXMLDOMDocument2 *pxml;
	if (FAILED(CoCreateInstance(__uuidof(DOMDocument30), NULL, CLSCTX_INPROC_SERVER, __uuidof(IXMLDOMDocument2), (void**) &pxml)))
	{
		printf("fail to create xml document");
		return NULL;
	}
	pxml->put_async(VARIANT_FALSE);
	pxml->put_resolveExternals(VARIANT_FALSE);
	pxml->put_validateOnParse(VARIANT_FALSE);
	return pxml;
}


BSTR BuildDownloadResult(BSTR bsItemDetails, CItemList *pItemList)
{
  BSTR bsRet = NULL;
  IXMLDOMNode * pItems = NULL;
  CAU_BSTR aubsItems(L"items");
  HRESULT hr ;
  IXMLDOMDocument *pxml;
  CAU_BSTR aubsResultTemplate (L"<?xml version=\"1.0\"?><items xmlns=\"x-schema:http://schemas.windowsupdate.com/iu/resultschema.xml\"></items>");

    if (aubsResultTemplate.IsNULL() || aubsItems.IsNULL())
        {

        DEBUGMSG("CAUCatalog::buildDownloadResult() fail to create result template string");
        goto done;
        }
    if (FAILED(LoadXMLDoc(aubsResultTemplate, &pxml)))
        {
        DEBUGMSG("CAUCatalog::buildDownloadResult() fail to load download result template");
        goto done;
        }

     if (FAILED(hr = FindSingleDOMNode(pxml, aubsItems, &pItems)) || NULL == pItems)
        {
         DEBUGMSG("CAUCatalog::buildDownloadResult() fail to get items with error %#lx", hr);
         goto done;
        }

    UINT uItemCount= pItemList->Count();
    DEBUGMSG("need to insert %d items in download result", uItemCount);
    for (UINT i = 0; i < uItemCount; i++)
        {
            CItem *pItem = (*pItemList)[i];
            if (pItem->IsSelected())
                {
                    IXMLDOMNode * pItemStatus = createDownloadItemStatusNode(pxml, pItem, bsItemDetails);
                    if (NULL != pItemStatus)
                        {
                        IXMLDOMNode * pNewNode;
                        if (FAILED(pItems->appendChild(pItemStatus, &pNewNode)) || NULL == pNewNode)
                            {
                                DEBUGMSG("fail to insert item %d", i);
                            }
                        else
                            {
                                  DEBUGMSG("item %d inserted", i);
                            }
                        pItemStatus->Release();
                        }
                }
        }
   if (FAILED( hr = pxml->get_xml(&bsRet)))
       {
        DEBUGMSG("CAUCatalog::buildDownloadResult() fail to get xml for the result %#lx", hr);
        }
done:
   SafeRelease(pItems);
   SafeRelease(pxml);
   return bsRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\testiu\testiu.h ===
#pragma once
#include <stdio.h>
#include <atlbase.h>
#include <atlconv.h>
#include <Loadengine.h>
#include <iu.h>
#include <iuctl.h>
#include <msxml2.h>
#include <windows.h>
#include <shlwapi.h>
#include <shlobj.h>
#include <schemamisc.h>
#include "safefunc.h"

#define ARRAYSIZE(x) sizeof(x)/sizeof(x[0])

void DEBUGMSG(LPSTR pszFormat, ...);

typedef enum tagDETECTLEVEL
{
	MIN_LEVEL = 0,
	PROVIDER_LEVEL = MIN_LEVEL,
	PRODUCT_LEVEL ,
	ITEM_LEVEL,
	DETAILS_LEVEL,
	MAX_LEVEL = DETAILS_LEVEL,
	DRIVERS_LEVEL
} DETECTLEVEL;


extern HANDLE ghInstallDone;
extern HANDLE ghDownloadDone;

class InstallProgListener : public IProgressListener {
	long m_refs;
public: 
		// IUnknown
	   STDMETHOD(QueryInterface)(REFIID riid, void **ppvObject)
	   {
		   if(riid == IID_IUnknown ||
			   riid == IID_IProgressListener)
			{
				*ppvObject = this;
				AddRef();
			}
			else
			{
				*ppvObject = NULL;
				return E_NOINTERFACE;
			}
			return S_OK;
	   }
       STDMETHOD_(ULONG, AddRef)(void)
	   {
		   return InterlockedIncrement(&m_refs);;
	   }
       STDMETHOD_(ULONG, Release)(void)
	   {
		   return InterlockedDecrement(&m_refs);
	   }
	
	   // IProgressListener
	   HRESULT STDMETHODCALLTYPE OnItemStart( 
            /* [in] */ BSTR bsUuidOperation,
            /* [in] */ BSTR bsXmlItem,
            /* [out] */ LONG *plCommandRequest)
		{
		   DEBUGMSG("InstallProgressListener::OnItemStart() for %S", bsUuidOperation);
			return S_OK;
		}
        HRESULT STDMETHODCALLTYPE OnProgress( 
            /* [in] */ BSTR bsUuidOperation,
            /* [in] */ VARIANT_BOOL fItemCompleted,
            /* [in] */ BSTR bsProgress,
            /* [out] */ LONG *plCommandRequest)
		{
			DEBUGMSG("InstallProgressListener::OnProgress() ");
			DEBUGMSG("			for %S", bsUuidOperation);
			DEBUGMSG("			with progress %S",bsProgress);
			DEBUGMSG("			and item is %s", (VARIANT_TRUE == fItemCompleted) ? "completed" : "ongoing");
			*plCommandRequest = 0;		//request nothing
			return S_OK;
		}
        HRESULT STDMETHODCALLTYPE OnOperationComplete( 
            /* [in] */ BSTR bsUuidOperation,
            /* [in] */ BSTR bsXmlItems)
		{
			DEBUGMSG("InstallProgressListener::OnOperationComplete() for %S", bsUuidOperation);
			SetEvent(ghInstallDone);
			return S_OK;
		}
};

class CAU_BSTR {
	BSTR bsData;
public:
	CAU_BSTR(LPCWSTR wszData)
	{
		bsData = SysAllocString(wszData);
	}
	~CAU_BSTR()
	{
		SafeFreeBSTR(bsData);
	}
	operator BSTR ()
	{
		return bsData;
	}

	BOOL append(LPCWSTR wszToAppend)
		{
		if (NULL == wszToAppend)
			{
			return FALSE;
			}
		if (NULL == bsData)
			{
			bsData = SysAllocString(wszToAppend);
			return bsData != NULL;
			}
		LPWSTR wszTmp;
		wszTmp = (LPWSTR) malloc(SysStringByteLen(bsData) + wcslen(wszToAppend)*2 + 2);
		if (NULL == wszTmp)
			{
			return FALSE;
			}
		wcscpy(wszTmp, bsData);
		wcscat(wszTmp, wszToAppend);
		BOOL fRet =  SysReAllocString(&bsData, wszTmp);
		free(wszTmp);
		return fRet;
		}
	
	BOOL IsNULL()
	{
		return NULL == bsData;
	}
};

/*typedef enum tagITEMSTATUS {
	AUCATITEM_UNSPECIFIED = -1,
	AUCATITEM_UNSELECTED = 0,
	AUCATITEM_SELECTED,
	AUCATITEM_HIDDEN
} ITEMSTATUS;
*/
#define AUCATITEM_SELECTED_FLAG 	0x00000001
#define AUCATITEM_HIDDEN_FLAG		0x00000002


//prototyping for item data structure
class CItem {
	static const char * fieldNames[];
	BSTR fields[9]; 
			// field 0 ItemID
			// field 1 Title
			// field 2 Description
			// field 3 CompanyName
			// field 4 RegistryID
			// field 5 RTFUrl
			// field 6 EulaUrl
			// field 7 RTFLocal
			// field 8 EulaLocal
	UINT  status;
	DWORD dwIndex; //legacy
public:
	CItem(): status(0), dwIndex(-1)
	{
		for (int i = 0; i< ARRAYSIZE(fields); i++)
		{
			fields[i] = NULL;
		}
	};
	CItem(CItem & item2)
		{
		for (int i = 0; i< ARRAYSIZE(fields); i++)
			{
			fields[i] = SysAllocString(item2.GetField(fieldNames[i]));
			}
		status = item2.GetStatus();
		dwIndex = item2.GetIndex();
		}
	~CItem()
	{
		for (int i = 0; i< ARRAYSIZE(fields); i++)
		{
			SafeFreeBSTR(fields[i]);
		}
	}
	void SetField(LPCSTR szFieldName, BSTR bsVal)
	{
		for (int i = 0; i < ARRAYSIZE(fields); i++)
		{
			if (0 == _stricmp(szFieldName, fieldNames[i]))
			{
				fields[i] = SysAllocString(bsVal);
				break;
			}
		}
	}

	BSTR GetField(LPCSTR szFieldName)
		{
		for (int i = 0; i < ARRAYSIZE(fields); i++)
			{
			if (0 == _stricmp(szFieldName, fieldNames[i]))
				{
				return SysAllocString(fields[i]);
				}
			}
		return NULL;
		}

	UINT GetStatus()
		{
		return status;
		}
	void MarkHidden()
	{
	status |= AUCATITEM_HIDDEN_FLAG;
	}

	void MarkSelected()
		{
		status |= AUCATITEM_SELECTED_FLAG;
		}
	void SetIndex(DWORD dwnewIndex)
	{
		dwIndex = dwnewIndex;
	}
	DWORD GetIndex()
	{
		return dwIndex;
	}
	
	BOOL IsSelected()
		{
		return AUCATITEM_SELECTED_FLAG & status;
		}
	BOOL IsHidden()
		{
		return AUCATITEM_HIDDEN_FLAG & status;
		}
	void dump() //for debug
	{
		DEBUGMSG("dumping item content");
		DEBUGMSG("ItemID= %S", fields[0]);
		DEBUGMSG("Title= %S", fields[1]);
		DEBUGMSG("Desc= %S", fields[2]);
		DEBUGMSG("CompanyName= %S", fields[3]);
		DEBUGMSG("RegID= %S", fields[4]);
		DEBUGMSG("RTFUrl= %S", fields[5]);
		DEBUGMSG("EulaUrl= %S", fields[6]);
		DEBUGMSG("RTFLocal= %S", fields[7]);
		DEBUGMSG("bsEulaLocal= %S", fields[8]);
		DEBUGMSG("status = %d", status);
		DEBUGMSG("dwIndex = %d", dwIndex);
		DEBUGMSG("dumping item done");
	}
};

class CItemList {
	UINT uNum;
	CItem **pList;
public:
	CItemList():pList(NULL), uNum(0)
			{};
	~CItemList()
	{
		if (NULL != pList)
		{
			for (UINT i = 0; i< uNum; i++)
			{
				free(pList[i]);	
			}
			free(pList);
		}
	}
	//fixcode: need to return error when realloc fails
	BOOL Add(CItem *pitem)
	{
		CItem ** pTmp = (CItem**) realloc(pList, (uNum+1)*sizeof(CItem *));
		if (NULL == pTmp)
			{
			return FALSE;
			}
		pList = pTmp;
		pList[uNum] = pitem;
		uNum++;
		return TRUE;
	}

	UINT Count()
		{
		return uNum;
		}

	CItem * operator[] (UINT i)
		{
		if ( i > uNum-1)
			{
			return NULL;
			}
		return (pList[i]);
		}
		
	void Iterate() //for debug
	{
		DEBUGMSG("Iterating %d items in the list....", uNum);
		for (UINT i = 0; i < uNum; i++)
		{
			pList[i]->dump();
		}
		DEBUGMSG("Iterating item list done");
	}
};

//wrapper class for AU to do detection using IU
class CAUCatalog {
public: 
    HRESULT Init();
    void Uninit();
    HRESULT DetectItems();
    HRESULT ValidateItems(BOOL fOnline, BOOL *pfValid);
    HRESULT DownloadItems(BSTR bsDestDir);
    HRESULT InstallItems();
    
private:
    HRESULT PrepareIU();
    void FreeIU();
    HRESULT GetManifest(DETECTLEVEL enLevel, BSTR bsDetectResult, BSTR * pbsManifest);
    HRESULT GetSystemSpec();
    HRESULT DoDetection(DETECTLEVEL enLevel, BSTR bsCatalog, BSTR * pbsResult);
    HRESULT DetectNonDriverItems(OUT BSTR *pbsInstall, OUT CItemList **pItemList);
    HRESULT DetectDriverItems(OUT BSTR *pbsInstall, OUT CItemList **pItemList);
    HRESULT MergeDetectionResult(BSTR bsDriverInstall, BSTR bsNonDriverInstall, CItemList & driverlist, CItemList & nondriverList);
    HRESULT DownloadRTFsnEULAs();
    void Clear();
    BSTR GetQuery(DETECTLEVEL enLevel, BSTR bsDetectResult);
    char* GetLogFile(DETECTLEVEL enLevel);
    char * GetLevelStr(DETECTLEVEL enLevel);
public: //revert to private once done testing
    BSTR buildDownloadResult();
private:
    IXMLDOMNode * createDownloadItemStatusNode(IXMLDOMDocument2 * pxml, CItem * pItem);

    HMODULE				m_hIUCtl;
    HMODULE				m_hIUEng;					
    PFN_LoadIUEngine		m_pfnCtlLoadIUEngine;
    PFN_UnLoadIUEngine		m_pfnCtlUnLoadIUEngine;
    PFN_GetSystemSpec		m_pfnGetSystemSpec;
    PFN_GetManifest			m_pfnGetManifest;
    PFN_Detect				m_pfnDetect;
    PFN_Download			m_pfnDownload;
    PFN_InstallAsync		m_pfnInstallAsync;
    PFN_SetOperationMode	m_pfnSetOperationMode;
    PFN_GetOperationMode	m_pfnGetOperationMode;

	BSTR	m_bsClientInfo;
	InstallProgListener * m_pInstallListener;
	IXMLDOMDocument2 * m_pQueryXML;
	IXMLDOMDocument2 *m_pResultXML;


	BSTR	m_bsSystemSpec;
	BSTR 	m_bsDownloadResult;
	BSTR 	m_bsInstallation; //a.k.a item details
	CItemList * m_pItemList;
};


void LOGFILE(const char *szFileName, BSTR bsMessage);
BOOL EnsureDirExists(LPCTSTR lpDir);

extern const char MERGED_CATALOG_FILE[];
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\wuauclt\aucltcatalog.cpp ===
//=======================================================================
//
//  Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:    AUClientCatalog.cpp
//
//  Creator: PeterWi
//
//  Purpose: Client AU Catalog Functions
//
//=======================================================================

#include "pch.h"

//=======================================================================
//
//  AUClientCatalog::Init
//
//  Initialize client catalog data.
//
//=======================================================================
HRESULT AUClientCatalog::Init(void)
{
    HRESULT hr = S_OK;

    if (FAILED(hr = m_WrkThread.m_Init()))
        {
        DEBUGMSG("AUCatalog::Init() Work Thread fail to init with error %#lx", hr);
        goto end;
        }
        
    m_fReboot = FALSE;

	if (NULL == m_pInstallCallback)
	{
		m_pInstallCallback = new CInstallCallback();
		if (NULL == m_pInstallCallback)
		{
			DEBUGMSG("AUCatalog::Init() fail to create install progress listener");
			hr = E_OUTOFMEMORY;
			goto end;
		}
	}

	if (NULL == m_bstrClientInfo)
	{
		m_bstrClientInfo = SysAllocString(AUCLIENTINFO);
		if (NULL == m_bstrClientInfo)
		{
			DEBUGMSG("AUCatalog::Init() fail to alloc string for client info");
			hr = E_OUTOFMEMORY;
			goto end;
		}
	}

end:
	return hr;
}


AUClientCatalog::~AUClientCatalog(void)
{
//	m_WrkThread.m_Terminate();
       SafeFreeBSTR(m_bstrClientInfo);
	SafeDelete(m_pInstallCallback);
}


DWORD GetItemNum(BSTR bstrCatalog) 
{
	IXMLDOMDocument *pxml = NULL;
	CAU_BSTR aubsItemIdsPattern;
	IXMLDOMNodeList *pItemIdsNodeList = NULL;
	HRESULT hr;
	long lRet = 0;

	if (FAILED(hr =LoadXMLDoc(bstrCatalog, &pxml)))
	{
		DEBUGMSG("GetItemNum fails to load xml with error %#lx", hr);
		goto done;
	}
	
	if (!aubsItemIdsPattern.append(L"catalog/provider/item/identity/@itemID")) //case sensitive
	{
	    DEBUGMSG("WUAUCLT OUT OF MEMORY. Fail to create item id pattern");
            goto done;
	}
 	
	if (FAILED(hr = pxml->selectNodes(aubsItemIdsPattern, &pItemIdsNodeList)))
	{
		DEBUGMSG(" fail to find item id with error %#lx", hr);
		goto done;
	}

	pItemIdsNodeList->get_length(&lRet);

done:
	SafeRelease(pItemIdsNodeList);
	SafeRelease(pxml);
//	DEBUGMSG("GetItemNum return %ld", lRet);
	return lRet;
}
	
//=======================================================================
//
//  AUClientCatalog::InstallItems
//
//  Install selected items.
//
//=======================================================================
HRESULT AUClientCatalog::InstallItems(BOOL fAutoInstall)
{
    DEBUGMSG("AUClientCatalog::InstallItems");
    HRESULT hr;
    IUpdates * pUpdates = NULL;
    BSTR bstrCatalogXML = NULL;
    BSTR bstrDownloadXML = NULL;
    BSTR bstrUuidOperation = NULL;

    if ( FAILED(hr = PrepareIU(FALSE)) )
    {
        DEBUGMSG("AUCatalog::InstallItems() fail to prepare IU %#lx", hr);
        goto end;
    }

    if ( FAILED(hr = CoCreateInstance(__uuidof(Updates),
    	    NULL,
    		CLSCTX_LOCAL_SERVER,
    		IID_IUpdates,
    		(LPVOID*)&pUpdates)) )
    {
        DEBUGMSG("AUClientCatalog::InstallItems() fail to create Updates object");
        goto end;
    }		

    if (!fAutoInstall)
    {
            if ( FAILED(hr = gInternals->m_saveSelectionsToServer(pUpdates)) )
            {
        		DEBUGMSG("AUClientCatalog::InstallItems() call to m_saveSelectionsToServer failed, hr = %#lx", hr);
                goto end;
            }
    }

    if ( FAILED(hr = pUpdates->GetInstallXML(&bstrCatalogXML, &bstrDownloadXML)) )
    {
		DEBUGMSG("AUClientCatalog::InstallItems() call to GetInstallXML failed, hr = %#lx", hr);
        goto end;
    }

    if (S_FALSE == hr)
    {
        DEBUGMSG("Nothing to install");
        goto end;
    }

	SendMessage(ghCurrentDialog, AUMSG_SET_INSTALL_ITEMSNUM, 0, GetItemNum(bstrCatalogXML));


#if DBG
	LOGXMLFILE(DOWNLOAD_FILE, bstrDownloadXML);
#endif

    //fixcode: when install fail, should NOT show the installation complete UI
    DEBUGMSG("WUAUCLT calling IU to do install........");
     m_pfnInstall(m_hIUEngineInst, m_bstrClientInfo,
                      bstrCatalogXML, 
					  bstrDownloadXML,
					  UPDATE_NOTIFICATION_ANYPROGRESS |UPDATE_OFFLINE_MODE , 
					  m_pInstallCallback, 
					  0, // hWnd
					  &bstrUuidOperation);
    DEBUGMSG("WUAUCLT IU done installation");
    
    Sleep(750);

    if ( gpClientCatalog->m_fReboot )
    {
        DEBUGMSG("Reboot required, setting regkey");
        fSetRebootFlag();
        if (NULL != ghCurrentDialog)
            {
            SendMessage(ghCurrentDialog, AUMSG_REBOOT_REQUIRED, 0, 0);
            }
    }
    else
    {
        if (NULL != ghCurrentDialog)
            {
            SendMessage(ghCurrentDialog, AUMSG_INSTALL_COMPLETE, 0, 0);
            }
    }

end:
    SafeFreeBSTR(bstrUuidOperation);	
    SafeFreeBSTR(bstrCatalogXML);	
    SafeFreeBSTR(bstrDownloadXML);	

    FreeIU();
    SafeRelease(pUpdates);
    DEBUGMSG("AUCatalog done items installation");

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\testiu\testiu.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       testIU.cpp
//
//  Purpose:	to exercise iu usage for AU
//
//--------------------------------------------------------------------------
#include "testiu.h"
#include "auxml.h"
#include <download.h>
#include "audownload.h"

LPCTSTR C_DOWNLD_DIR= _T("wuaudnld.tmp");
LPCTSTR CABS_DIR=  _T("cabs");
LPCTSTR RTF_DIR = _T("RTF");
LPCTSTR EULA_DIR = _T("EULA");
LPCTSTR DETAILS_DIR = _T("Details");


const char * CItem::fieldNames[] = { "ItemID", "Title", "Description", "CompanyName","RegistryID", "RTFUrl", "EulaUrl", "RTFLocal", "EulaLocal"};

const char SYSSPEC_FILE[] = "sys.xml";
const char PROVIDER_FILE[] = "provider.xml";
const char PRODUCT_FILE[] = "product.xml";
const char ITEM_FILE[] = "item.xml";
const char DRIVERS_FILE[] = "drivers.xml";
const char DETAILS_FILE[] = "details.xml";
const char DETECT1_FILE[] = "detect1.xml";
const char DETECT2_FILE[] = "detect2.xml";
const char DETECT3_FILE[] = "detect3.xml";
const char DETECT4_FILE[] = "detect4.xml";
const char DOWNLOAD_FILE[] = "download.xml";
const char MERGED_CATALOG_FILE[] = "MergedCat.xml";

WCHAR AUCLIENTINFO[] = L"<clientInfo xmlns=\"x-schema:http://schemas.windowsupdate.com/iu/clientInfo.xml\" clientName=\"au\" />";

CAU_BSTR AUPROVIDERQUERY(L"<query href=\"http://iupreprodweb1/autoupdate/getmanifest.asp\"><dObjQueryV1 procedure=\"providers\" /></query>");
CAU_BSTR AUPRODUCTQUERY(L"<query href=\"http://iupreprodweb1/autoupdate/getmanifest.asp\"><dObjQueryV1 procedure=\"products\"><parentItems></parentItems></dObjQueryV1></query>");
CAU_BSTR AUITEMQUERY(L"<query href=\"http://iupreprodweb1/autoupdate/getmanifest.asp\"><dObjQueryV1 procedure=\"items\"><parentItems></parentItems></dObjQueryV1></query>");
CAU_BSTR AUDETAILSQUERY(L"<query href=\"http://iupreprodweb1/autoupdate/getmanifest.asp\"><dObjQueryV1 procedure=\"itemdetails\"><parentItems></parentItems></dObjQueryV1></query>");
CAU_BSTR AUDRIVERSQUERY(L"<query href=\"http://iupreprodweb1/autoupdatedrivers/getmanifest.asp\"><dObjQueryV1 procedure=\"driverupdates\"/></query>");
CAU_BSTR PRODUCT_PRUNE_PATTERN(L"//itemStatus[detectResult/@installed=\"1\"]"); //case SENSITIVE
BSTR ITEM_PRUNE_PATTERN = PRODUCT_PRUNE_PATTERN;
CAU_BSTR DETAILS_PRUNE_PATTERN(L"//itemStatus[not (detectResult/@excluded=\"1\") and (detectResult/@force=\"1\" or not (detectResult/@installed=\"1\") or detectResult/@upToDate = \"0\")]");


BOOL	gfCoInited = FALSE;
CAU_BSTR	gbsSelectionLanguage(L"SelectionLanguage");
CAU_BSTR	gbsXPath(L"XPath");

HANDLE ghInstallDone;
HANDLE ghDownloadDone;
BOOL    gfDownloadOk;


void DoDownloadStatus(DWORD dwCallbackMsg, PVOID ptDownloadStatusData = NULL)
{
    DEBUGMSG("DoDownloadStatus() got callback msg %d", dwCallbackMsg);
}

void DEBUGMSG(LPSTR pszFormat, ...)
{
	SYSTEMTIME st;
	GetSystemTime(&st);
	char szBuf[2048];
	sprintf(szBuf, "%d:%d:%d  ", st.wHour, st.wMinute, st.wSecond);
	OutputDebugStringA(szBuf);

	va_list ArgList;
	va_start(ArgList, pszFormat);
    _vsnprintf(szBuf, sizeof(szBuf), pszFormat, ArgList);
	va_end(ArgList);

	OutputDebugStringA(szBuf);
	OutputDebugStringA("\n");
	printf(szBuf);
	printf("\n");
}

void LOGFILE(const char *szFileName, BSTR bsMessage)
{
	HANDLE hFile = CreateFileA(szFileName, GENERIC_WRITE, NULL, NULL, CREATE_ALWAYS, NULL, NULL);
	if (INVALID_HANDLE_VALUE == hFile)
	{
		DEBUGMSG("Fail to create file %s", szFileName);
		return;
	}
		
	DWORD dwBytesWritten;
	if (!WriteFile(hFile, bsMessage, SysStringByteLen(bsMessage), &dwBytesWritten, NULL))
	{
		DEBUGMSG("Fail to write to file %s with error %d", szFileName, GetLastError());
	}
	CloseHandle(hFile);
	return;
}

inline BOOL fFileExists(LPCTSTR lpFileName)
{
	return (-1 != GetFileAttributes(lpFileName));
}

inline BOOL EnsureDirExists(LPCTSTR lpDir)
{
    if (!fFileExists(lpDir))
        {
            INT iRet = SHCreateDirectoryEx(NULL, lpDir, NULL);
            DEBUGMSG(" Create directory %S %s (with error %d)", lpDir, (ERROR_SUCCESS != iRet) ? "failed" : "succeeded", iRet);
            return ERROR_SUCCESS == iRet;
        }
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
//
// Function GetDownloadPath()
//			Gets the download directory path
//
// Input:   a buffer to store the directory created
//          an unsigned intetger to specify the size of buffer
// Output:  None
// Return:  HRESULT to tell the result
//
/////////////////////////////////////////////////////////////////////////////
HRESULT GetDownloadPath(LPTSTR lpszDir, UINT uDirSize)
{
    UINT	nSize;
    TCHAR	szDir[MAX_PATH];
    const TCHAR EOS = _T('\0');


    if (lpszDir == NULL || uDirSize == 0)
    {
        return (E_INVALIDARG);
    }

    if(FAILED(SHGetFolderPath(NULL, CSIDL_PROGRAM_FILES, NULL, 0,szDir)) )
    {
        DEBUGMSG("fail to get program files folder");
        return E_FAIL;
    }

   PathAppend(szDir, TEXT("WindowsUpdate"));
    nSize = lstrlen(szDir);
    if (szDir[nSize-1] != '\\')
    {
        szDir[nSize++] = '\\';
        szDir[nSize] = EOS;
    }
    nSize += lstrlen(C_DOWNLD_DIR) + 1;
    if (uDirSize < nSize)
    {
        DEBUGMSG("GetDownloadPath() found input buffer buffer (%d) too small (%d).", uDirSize, nSize);
        return (E_INVALIDARG);
    }
    lstrcat(szDir, C_DOWNLD_DIR);
    lstrcpy(lpszDir, szDir);
    DEBUGMSG("DownloadPath() is %S", szDir);
    EnsureDirExists(szDir);
    return S_OK;
}

///////////////////////////////////////////////////////////////
// get the path to download software update bits
// lpszDir  : IN buffer to store the path
// uDirSize: IN size of the buffer in characters. 
// return : S_OK if success
//           : E_INVALIDARG if buffer too small
//           : E_FAIL if other error
//////////////////////////////////////////////////////////////
HRESULT GetCabsDownloadPath(LPTSTR lpszDir, UINT uDirSize)
{
    HRESULT hr;
    if (FAILED(hr = GetDownloadPath(lpszDir, uDirSize)))
        {
        DEBUGMSG("GetCabsDownloadPath() fail to get download path");
        return hr;
        }
    UINT uSizeNeeded = (lstrlen(lpszDir) + lstrlen(CABS_DIR)  + 2) ;
    if (uSizeNeeded > uDirSize)
        {
        DEBUGMSG("GetCabsDownloadPath() got too small buffer");
        return E_INVALIDARG;
        }
    lstrcat(lpszDir, _T("\\"));
    lstrcat(lpszDir, CABS_DIR);
    EnsureDirExists(lpszDir);
    return S_OK;
}

HRESULT GetUISpecificDownloadPath(LPTSTR lpszDir, UINT uDirSize, LANGID langid, LPCTSTR tszSubDir)
{
    HRESULT hr ;
    if (FAILED(hr = GetDownloadPath(lpszDir, uDirSize)))
        {
        DEBUGMSG("GetUISpecificDownloadPath() fail to get download path");
        return hr;
        }
    TCHAR tszLangId[10];
    wsprintf(tszLangId, L"%04x", langid);
    UINT uSizeNeeded = (lstrlen(lpszDir) + lstrlen(tszSubDir) + lstrlen(tszLangId) + 3); //two \ s and one NULL
    if (uSizeNeeded > uDirSize)
        {
        DEBUGMSG("GetUISpecificDownloadPath() got too small buffer");
        return E_INVALIDARG;
        }
    lstrcat(lpszDir, _T("\\"));
    lstrcat(lpszDir, tszSubDir);
    lstrcat(lpszDir, _T("\\"));
    lstrcat(lpszDir, tszLangId);
    DEBUGMSG("GetUISpecificDownloadPath() return %S", lpszDir);
    EnsureDirExists(lpszDir);
    return S_OK;
}

///////////////////////////////////////////////////////////////
// get the rtf download path for a language
// lpszDir : IN buffer to store the path
// uDirSize:IN size of the buffer in charaters
// return: S_OK if success
//           : E_INVALIDARG if buffer too small
//           : E_FAIL if other error
//////////////////////////////////////////////////////////////
HRESULT GetRTFDownloadPath(LPTSTR lpszDir, UINT uDirSize, LANGID langid)
{
  return GetUISpecificDownloadPath(lpszDir, uDirSize, langid, RTF_DIR);
}
    
///////////////////////////////////////////////////////////////
// get the local details xml path to download to for a language
// lpszDir : IN buffer to store the path
// uDirSize:IN size of the buffer in charaters
// return: S_OK if success
//           : E_INVALIDARG if buffer too small
//           : E_FAIL if other error
//////////////////////////////////////////////////////////////
HRESULT GetDetailsDownloadPath(LPTSTR lpszDir, UINT uDirSize, LANGID langid)
{
    return GetUISpecificDownloadPath(lpszDir, uDirSize, langid, DETAILS_DIR);
}

///////////////////////////////////////////////////////////////
// get the local EULA xml path to download to for a language
// lpszDir : IN buffer to store the path
// uDirSize:IN size of the buffer in charaters
// return: S_OK if success
//           : E_INVALIDARG if buffer too small
//           : E_FAIL if other error
//////////////////////////////////////////////////////////////
HRESULT GetEulaDownloadPath(LPTSTR lpszDir, UINT uDirSize, LANGID langid)
{
    return GetUISpecificDownloadPath(lpszDir, uDirSize, langid, EULA_DIR);
}

//////////////////////////////////////////////////////////////
// delete every files in download path and its  every subdirectories
//////////////////////////////////////////////////////////////
HRESULT CleanFilesOnDisk()
{
    // to be implemented
    return S_OK;
}

HRESULT PrepareTest()
{
	HRESULT hr =  CoInitialize(NULL);
	if (!(gfCoInited = SUCCEEDED(hr)))
	    {
	    DEBUGMSG("Fail to initialize COM");
	    goto done;
	    }
	ghInstallDone = CreateEvent(NULL, FALSE, FALSE, NULL) ; //auto unnamed event
	ghDownloadDone = CreateEvent(NULL, FALSE, FALSE, NULL) ;
	if (NULL == ghInstallDone || NULL == ghDownloadDone)
	    {
	    DEBUGMSG("Fail to create install done or download done event");
	    hr = E_FAIL;
	    }
done:
    return hr;
}

void PostTest()
{
        if (NULL != ghInstallDone)
            {
            CloseHandle(ghInstallDone);
            }
        if (NULL != ghDownloadDone)
            {
            CloseHandle(ghDownloadDone);
            }
	if (gfCoInited)
	{
		CoUninitialize();
	}
}


//always called before any other method on CAUCatalog is used.
HRESULT CAUCatalog::Init()
{
        HRESULT hr = S_OK;
        m_pQueryXML = NULL;
        m_pResultXML = NULL;
        m_pItemList = NULL;
	 m_bsInstallation = NULL;
	 m_bsDownloadResult = NULL;
	 m_bsSystemSpec = NULL;
       if (FAILED(hr = CoCreateInstance(__uuidof(DOMDocument30), NULL, CLSCTX_INPROC_SERVER, __uuidof( IXMLDOMDocument2), (void**)&m_pQueryXML)))
	{
		DEBUGMSG("CAUCatalog::Init() fail to create XML document");
		goto end;
	}
	if (FAILED(hr = CoCreateInstance(__uuidof(DOMDocument30), NULL, CLSCTX_INPROC_SERVER, __uuidof( IXMLDOMDocument2), (void**)&m_pResultXML)))
	{
		DEBUGMSG("CAUCatalog::Init() fail to create XML document for Detect result");
		goto end;
	}
	m_bsClientInfo = SysAllocString(AUCLIENTINFO);
	if (NULL == m_bsClientInfo)
	{
	    DEBUGMSG("CAUCatalog::Init() fail to alloc string for client info");
		hr = E_FAIL;
		goto end;
	}
	m_pInstallListener = new InstallProgListener();
	if (NULL == m_pInstallListener)
	{
	    DEBUGMSG("CAUCatalog::Init() fail to create install progress listener");
		hr = E_FAIL;
		goto end;
	}
	//make sure all query and prune pattern strings are not NULL
	if (AUPROVIDERQUERY.IsNULL() || AUPRODUCTQUERY.IsNULL()
		|| AUITEMQUERY.IsNULL() || AUDETAILSQUERY.IsNULL()
		|| PRODUCT_PRUNE_PATTERN.IsNULL()
		|| NULL == ITEM_PRUNE_PATTERN
		|| DETAILS_PRUNE_PATTERN.IsNULL())
	{
	    DEBUGMSG("CAUCatalog::Init() fail to initialize some query strings");
	    hr = E_FAIL;
           goto end;
	}
	if (FAILED(PrepareIU()))
	    {
	    DEBUGMSG("CAUCatalog::Init() fail to prepare IU");
	    hr = E_FAIL;
	    }
end:
	return hr;
}

void CAUCatalog::Uninit()
{
       FreeIU();
	SafeFreeBSTR(m_bsClientInfo);
	SafeFreeBSTR(m_bsSystemSpec);
	SafeDelete(m_pInstallListener);
	SafeRelease(m_pResultXML);
	SafeRelease(m_pQueryXML);
	SafeDelete(m_pItemList);
	SafeFreeBSTR(m_bsInstallation);
	SafeFreeBSTR(m_bsDownloadResult);
}

//////////////////////////////////////////////////////////////////////
// clear out more dynamic internal data
/////////////////////////////////////////////////////////////////////
void CAUCatalog::Clear()
{
       SafeDeleteNULL(m_pItemList);
	SafeFreeBSTR(m_bsInstallation);
	SafeFreeBSTR(m_bsDownloadResult);
       SafeFreeBSTR(m_bsSystemSpec);
       m_bsInstallation = NULL;
       m_bsDownloadResult = NULL;
       m_bsSystemSpec = NULL;
}


HRESULT CAUCatalog::PrepareIU()
{
    HRESULT hr = S_OK;
   m_hIUCtl = NULL;
    m_hIUEng = NULL;
    m_pfnCtlLoadIUEngine = NULL;
    m_pfnCtlUnLoadIUEngine = NULL;
    m_pfnGetSystemSpec = NULL;
    m_pfnGetManifest = NULL;
    m_pfnDetect = NULL;
    m_pfnDownload = NULL;
    m_pfnInstallAsync = NULL;
    m_pfnSetOperationMode = NULL;
    m_pfnGetOperationMode = NULL;
    	// all IU function pointers are initialized
       m_hIUCtl = LoadLibrary(_T("iuctl.dll"));	
	if (NULL == m_hIUCtl)
	{
		hr = E_FAIL;
		DEBUGMSG("CAUCatalog::PrepareIU() Fail to load iuctl.dll");
		goto end;
	}
	if (NULL == (m_pfnCtlLoadIUEngine = (PFN_LoadIUEngine) GetProcAddress(m_hIUCtl, "LoadIUEngine")))
	{
		hr = E_FAIL;
		DEBUGMSG("CAUCatalog::PrepareIU() Fail to GetProcAddress for LoadIUEngine");
		goto end;
	}

	if (NULL == (m_pfnCtlUnLoadIUEngine = (PFN_UnLoadIUEngine) GetProcAddress(m_hIUCtl, "UnLoadIUEngine")))
	{
		hr = E_FAIL;
		DEBUGMSG("CAUCatalog::PrepareIU() Fail to getprocaddress for UnloadIUEngine");
		goto end;
	}
	if (NULL == (m_hIUEng = m_pfnCtlLoadIUEngine(TRUE, FALSE))) //synchronous and online mode, selfupdate IU engine if required
	{
		hr = E_FAIL;
		DEBUGMSG("CAUCatalog::PrepareIU() Fail to LoadIUEngine");
		goto end;
	}
	if (NULL == (m_pfnGetSystemSpec = (PFN_GetSystemSpec) GetProcAddress(m_hIUEng, "GetSystemSpec")))
	{
		hr = E_FAIL;
		DEBUGMSG("CAUCatalog::PrepareIU() Fail to getprocaddress for GetSystemSpec");
		goto end;
	}
	if (NULL == (m_pfnGetManifest = (PFN_GetManifest) GetProcAddress(m_hIUEng, "GetManifest")))
	{
		hr = E_FAIL;
		DEBUGMSG("CAUCatalog::PrepareIU() Fail to getprocaddress for GetManifest");
		goto end;
	}

	if (NULL == (m_pfnDetect = (PFN_Detect)GetProcAddress(m_hIUEng, "Detect")))
	{
		hr = E_FAIL;
		DEBUGMSG("CAUCatalog::PrepareIU() Fail to getprocaddress for Detect");
		goto end;
	}
	if (NULL == (m_pfnDownload = (PFN_Download)GetProcAddress(m_hIUEng, "Download")))
	{
		hr = E_FAIL;
		DEBUGMSG("CAUCatalog::PrepareIU() Fail to getprocaddress for Download");
		goto end;
	}
	if (NULL == (m_pfnInstallAsync = (PFN_InstallAsync)GetProcAddress(m_hIUEng, "InstallAsync")))
	{
		hr = E_FAIL;
		DEBUGMSG("CAUCatalog::PrepareIU() Fail to getprocaddress for InstallAsync");
		goto end;
	}
	if (NULL == (m_pfnSetOperationMode = (PFN_SetOperationMode)GetProcAddress(m_hIUEng, "SetOperationMode")))
	{
		hr = E_FAIL;
		DEBUGMSG("CAUCatalog::PrepareIU() Fail to getprocaddress for SetOperationMode");
		goto end;
	}
	if (NULL == (m_pfnGetOperationMode = (PFN_GetOperationMode)GetProcAddress(m_hIUEng, "GetOperationMode")))
	{
		hr = E_FAIL;
		DEBUGMSG("CAUCatalog::PrepareIU() Fail to getprocaddress for GetOperationMode");
		goto end;
	}
end:
        if (FAILED(hr))
            {
                FreeIU();
            }
        return hr;
}

void CAUCatalog::FreeIU()
{
	if (NULL != m_hIUEng && NULL != m_pfnCtlUnLoadIUEngine)
	{
		m_pfnCtlUnLoadIUEngine(m_hIUEng);
	}
	if (NULL != m_hIUCtl)
        {
	   FreeLibrary(m_hIUCtl);
	 }
	 m_hIUCtl = NULL;
        m_hIUEng = NULL;
//        m_pfnCtlLoadIUEngine = NULL;
        m_pfnCtlUnLoadIUEngine = NULL;
//        m_pfnGetSystemSpec = NULL;
   //     m_pfnGetManifest = NULL;
    //    m_pfnDetect = NULL;
      //  m_pfnDownload = NULL;
      //  m_pfnInstallAsync = NULL;
      //  m_pfnSetOperationMode = NULL;
      //  m_pfnGetOperationMode = NULL;
}


HRESULT CAUCatalog::DownloadRTFsnEULAs()
{
    BSTR bsSrcUrl;
    TCHAR tszLocalRTFDir[MAX_PATH];
    TCHAR tszLocalEULADir[MAX_PATH];
    HRESULT hr;
    LANGID langid = MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US);

    if (FAILED(hr = GetRTFDownloadPath(tszLocalRTFDir, MAX_PATH, langid)))
        {
        DEBUGMSG("Fail to get RTF download path %#lx", hr);
        goto done;
        }
    DEBUGMSG("Got RTF path %S", tszLocalRTFDir);
    if (FAILED(hr = GetEulaDownloadPath(tszLocalEULADir, MAX_PATH, langid)))
        {

        DEBUGMSG("Fail to get eula download path %#lx", hr);
        goto done;
        }
    DEBUGMSG("Got EULA path %S", tszLocalEULADir);
    UINT uItemCount = m_pItemList->Count();
    DEBUGMSG("Downloading %d RTFs", uItemCount);
    for (UINT i = 0; i<uItemCount; i++)
        {
        CItem *pItem = (*(m_pItemList))[i];
        if (NULL == pItem)
            {

            DEBUGMSG("fail to get item %d from item list", i);
            continue;
            }
        LPCSTR szFields[2] = {"RTF", "EULA"};
        LPCSTR szFieldNames[2] = {"RTFUrl", "EULAUrl"};
        LPTSTR pszDirs[2] = {tszLocalRTFDir, tszLocalEULADir};
        for (UINT j = 0; j < ARRAYSIZE(szFieldNames); j++)
            {
                bsSrcUrl = pItem->GetField(szFieldNames[j]);
                hr = DownloadFile(
        			bsSrcUrl,					// full http url
        			pszDirs[j],			// local directory to download file to
        			NULL,					// optional local file name to rename the downloaded file to if pszLocalPath does not contain file name
                            NULL,					// bytes downloaded for this file
                            NULL,       //    // optional events causing this function to abort
                            0, //    // number of quit events, must be 0 if array is NULL
        			NULL,	// optional call back function
        			NULL);					// parameter for call back function to use
        	DEBUGMSG("download %s from %S to %S %s", szFields[j], bsSrcUrl, pszDirs[j], FAILED(hr)? "failed" : "succeeded");
        	DEBUGMSG("  with error %#lx", hr);
        	SafeFreeBSTR(bsSrcUrl);
            }
     }
done:
        return hr;
}



HRESULT CAUCatalog::GetSystemSpec()
{
	CAU_BSTR AUSYSCLASS(L"<classes><computerSystem/><platform/><devices/><locale/></classes>");
	HRESULT hr = E_FAIL;
	if (AUSYSCLASS.IsNULL())
	{
		goto done;
	}
	hr = m_pfnGetSystemSpec(AUSYSCLASS, 0, &m_bsSystemSpec); //online mode
	if (SUCCEEDED(hr))
	{
		LOGFILE(SYSSPEC_FILE, m_bsSystemSpec);
	}
done:
	return hr;
}

////////////////////////////////////////////////////////////////////////////////
// compose query based on a format and items picked out from detection result
//
BSTR CAUCatalog::GetQuery(DETECTLEVEL enLevel, BSTR bsDetectResult)
{
	BSTR bsPrunePattern;
	BSTR bsQuery = NULL;
	VARIANT_BOOL fOk;
       HRESULT hr;


	//DEBUGMSG("GetQuery(): string in is %S", bsDetectResult);

	switch (enLevel)
	{
	case PROVIDER_LEVEL:
			bsQuery = AUPROVIDERQUERY;
			break;
	case DRIVERS_LEVEL:
	              bsQuery = AUDRIVERSQUERY;
	              break;
	case PRODUCT_LEVEL:
			bsQuery = AUPRODUCTQUERY;
			bsPrunePattern = PRODUCT_PRUNE_PATTERN;
			break;
	case ITEM_LEVEL:
			bsQuery = AUITEMQUERY;
			bsPrunePattern = ITEM_PRUNE_PATTERN;
			break;
	case DETAILS_LEVEL:
			bsQuery = AUDETAILSQUERY;
			bsPrunePattern = DETAILS_PRUNE_PATTERN;
			break;
	}
	
	m_pQueryXML->put_async(VARIANT_FALSE);
	m_pQueryXML->put_resolveExternals(VARIANT_TRUE);
	m_pQueryXML->put_validateOnParse(VARIANT_TRUE);
	hr = m_pQueryXML->loadXML(bsQuery, &fOk);
       if (S_OK != hr)
        {
          DEBUGMSG("GetQuery() fail to load query XML");
          goto done;
        }

	if (enLevel != PROVIDER_LEVEL && enLevel != DRIVERS_LEVEL)
	{
		m_pResultXML->put_async(VARIANT_FALSE);
		m_pResultXML->put_resolveExternals(VARIANT_TRUE);
		m_pResultXML->put_validateOnParse(VARIANT_TRUE);
		hr = m_pResultXML->loadXML(bsDetectResult, &fOk);

		if (S_OK != hr)
		    {
		    DEBUGMSG("GetQuery() fail to load XML for detect result");
		    goto done;
		    }
		
		VARIANT vStr;
		vStr.vt = VT_BSTR;
		vStr.bstrVal = gbsXPath;
		if (FAILED(m_pResultXML->setProperty(gbsSelectionLanguage, vStr)))
		{
			DEBUGMSG("GetQuery() fail to set resultXML selection language");
			goto done;
		}
		//fixcode: Is xpath really needed?
		if (FAILED(m_pQueryXML->setProperty(gbsSelectionLanguage, vStr)))
		{
			DEBUGMSG("GetQuery() fail to set queryXML selection language");
			goto done;
		}
		
		IXMLDOMNodeList *pItems;

		if (FAILED(m_pResultXML->selectNodes(bsPrunePattern, &pItems)) || NULL == pItems)
		{
			DEBUGMSG("GetQuery() fail to select node or nothing to select");
			goto done;
		}

		long lLen;
		pItems->get_length(&lLen);
		DEBUGMSG("GetQuery(): pruning result %d items", lLen);
		IXMLDOMNode *pParentItems;
		HRESULT hr;
		if (FAILED(hr = m_pQueryXML->selectSingleNode(L"//parentItems", &pParentItems)) || NULL == pParentItems)
		{
			DEBUGMSG("GetQuery() fail to select single node %#lx or nothing to select", hr);
		}
		else
		{
				for (int i = 0; i < lLen; i++)
				{
					   IXMLDOMElement *pItem;
					   IXMLDOMNode *pIdentity1;
					   IXMLDOMNode *pItemStatus;
					   IXMLDOMText *pItemIdText;
					HRESULT hr;
					m_pQueryXML->createElement(L"item", &pItem);
					if (NULL == pItem)
					{
						DEBUGMSG("GetQuery() fail to create element");
					}
					else
					{
						pItems->get_item(i, &pItemStatus);
						pItemStatus->selectSingleNode(L"./identity/@itemID", &pIdentity1);
						if (NULL == pIdentity1)
						{
							DEBUGMSG("GetQuery() fail to select itemID");
						}
						else
						{
							BSTR bsItemId;
							pIdentity1->get_text(&bsItemId);
							hr = m_pQueryXML->createTextNode(bsItemId, &pItemIdText);
							hr = pItem->appendChild(pItemIdText, (   IXMLDOMNode**) &pItemIdText);
							hr = pParentItems->appendChild(pItem, (   IXMLDOMNode**)&pItem);
							pItemIdText->Release();
							pIdentity1->Release();
						}
						pItemStatus->Release();
						pItem->Release();
					}
				}
				pParentItems->Release();
		}
		pItems->Release();
	}
	m_pQueryXML->get_xml(&bsQuery);
done:
//	DEBUGMSG("GetQuery(): Query string is %S", bsQuery);
	return bsQuery;
}


HRESULT CAUCatalog::DoDetection(DETECTLEVEL enLevel, BSTR bsCatalog, BSTR *pbsResult)
{
	HRESULT hr = m_pfnDetect(bsCatalog, 0, pbsResult); //online mode
	if (SUCCEEDED(hr))
	{
		switch (enLevel)
		{
		case PROVIDER_LEVEL:
			LOGFILE(DETECT1_FILE, *pbsResult);
			break;
		case PRODUCT_LEVEL:
			LOGFILE(DETECT2_FILE, *pbsResult);
			break;
		case ITEM_LEVEL:
			LOGFILE(DETECT3_FILE, *pbsResult);
			break;
		case DETAILS_LEVEL:
			LOGFILE(DETECT4_FILE, *pbsResult);
			break;
		}
	}
	return hr;
}

char* CAUCatalog::GetLogFile(DETECTLEVEL enLevel)
{
	switch (enLevel)
	{
	case PROVIDER_LEVEL:
		return (char*)PROVIDER_FILE;
	case PRODUCT_LEVEL:
		return (char*)PRODUCT_FILE;
	case ITEM_LEVEL:
		return (char*)ITEM_FILE;
	case DETAILS_LEVEL:
		return (char*)DETAILS_FILE;
	case DRIVERS_LEVEL:
	        return (char*)DRIVERS_FILE;
	default:
		return NULL;
	}
}

HRESULT CAUCatalog::GetManifest(DETECTLEVEL enLevel, BSTR bsDetectResult, BSTR *pbsManifest)
{
	BSTR bsQuery = GetQuery(enLevel, bsDetectResult);
	
	HRESULT hr = m_pfnGetManifest(m_bsClientInfo, m_bsSystemSpec, bsQuery, 1, pbsManifest); // compression
	if (SUCCEEDED(hr))
	{
		LOGFILE(GetLogFile(enLevel), *pbsManifest);
	}
	SafeFreeBSTR(bsQuery);
	return hr;
}

void  DownloadCallback(DWORD dwCallbackMsg, PVOID ptDownloadStatusData = NULL)
{
    DEBUGMSG("In downloadcallback message %d got ", dwCallbackMsg);
    if (CATMSG_DOWNLOAD_COMPLETE == dwCallbackMsg)
        {
        gfDownloadOk = TRUE;
        SetEvent(ghDownloadDone);
        }
    if (CATMSG_DOWNLOAD_ERROR == dwCallbackMsg)
        {
        gfDownloadOk = FALSE;
        SetEvent(ghDownloadDone);
        }
}
    

HRESULT CAUCatalog::DownloadItems(BSTR bsDestDir)
{
       HRESULT hr;
       UINT uItemCount;
     	CItemDetails itemdetails;
     	CAUDownloader audownloader(DownloadCallback);
	DEBUGMSG("CAUCatalog downloading items...");
	if (NULL == m_bsInstallation)
	    {
	    DEBUGMSG("CAUCatalog::DownloadItems() can't get installation xml");
	    hr = E_FAIL;
	    goto end;
	    }

       if (!itemdetails.Init(m_bsInstallation))
        {
            hr = E_FAIL;
            DEBUGMSG("fail to init itemdetails");
            goto end;
        }

       uItemCount= m_pItemList->Count();
       DEBUGMSG("Need to download %d items", uItemCount);
       for (UINT i = 0; i < uItemCount; i++)
        {
            CItem *pItem = (*m_pItemList)[i];
            pItem->MarkSelected(); //testing only, remove before copy this code into wuau
            if (pItem->IsSelected())
                {
                    BSTR bsItemId;
                    bsItemId = pItem->GetField("ItemId");
                    BSTR * pCabNames;
                    UINT uCabsNum;
                    if (FAILED(itemdetails.GetCabNames(bsItemId, &pCabNames, &uCabsNum)))
                        {
                         DEBUGMSG("fail to get cab names for %S", bsItemId);
                         goto end;
                        }
                    DEBUGMSG("Need to download following files for %S", bsItemId);
                   
                    for (UINT j  = 0; j < uCabsNum; j++)
                        {
                            TCHAR szFullFileName[MAX_PATH];
                            BSTR bstrItemDownloadPath = itemdetails.GetItemDownloadPath(bsItemId);
                            if (NULL == bstrItemDownloadPath)
                                {
                                    DEBUGMSG("fail to build item downloadPath");
                                    hr = E_FAIL;
                                    goto end;
                                }
                            lstrcpy(szFullFileName, W2T(bstrItemDownloadPath));
                            PathAppend(szFullFileName, PathFindFileName(W2T(pCabNames[j])));
                            audownloader.QueueDownloadFile(W2T(pCabNames[j]), szFullFileName);
                            DEBUGMSG("       from %S  to %S", pCabNames[j], szFullFileName);
                           SysFreeString(pCabNames[j]);
                           SysFreeString(bstrItemDownloadPath); 
                          }
                    free(pCabNames);
                }
        }
                        
	audownloader.StartDownload();
	/*
	hr = m_pfnDownload(m_bsClientInfo,
							m_bsInstallation,
							bsDestDir,
							 0,		//lMode
							 NULL,	//punkProgressListener
							 NULL,	//hWnd
							 &m_bsDownloadResult);
	LOGFILE(DOWNLOAD_FILE, m_bsDownloadResult);
	*/

       DEBUGMSG("Wait for downloading to be done........");
	while (1)
	    {
        	DWORD dwRet = WaitForSingleObject(ghDownloadDone, 1000);
        	if (WAIT_OBJECT_0 == dwRet)
        	    {
        	        break;
        	    }
        	DWORD dwPercent, dwStatus;
        	audownloader.getStatus(&dwPercent, &dwStatus);
        	DEBUGMSG("%d percent done, status is %d", dwPercent, dwStatus);
	    }

        hr = gfDownloadOk ? S_OK : E_FAIL;

end:
       itemdetails.Uninit();
     	DEBUGMSG("CAUCatalog downloading items %s", gfDownloadOk ? "ok" : "failed");
     	if (SUCCEEDED(hr))
     	    {
              m_bsDownloadResult = buildDownloadResult();
         	LOGFILE(DOWNLOAD_FILE, m_bsDownloadResult);

     	    }
	return hr;
}


/*
void TestBuildDownloadResult()
{
    CAUCatalog catalog;
    if (FAILED(PrepareTest()))
        {
        goto done;
        }
    if (FAILED(catalog.Init()))
        {
            goto done;
        }
    catalog.m_bsInstallation = DBGReadXMLFromFile(L"details.xml");
    catalog.m_pItemList = ExtractNormalItemInfo(catalog.m_bsInstallation);
    UINT uItemCount = catalog.m_pItemList->Count();
    for (UINT i = 0; i<uItemCount; i++)
        {
        CItem *pItem = (*(catalog.m_pItemList))[i];
        if (NULL == pItem)
            {

            DEBUGMSG("fail to get item from item list");
            }
        else
            {
            pItem->MarkSelected();
            }
        }
    catalog.buildDownloadResult();
    catalog.Uninit();
done:
    PostTest();
   return;
}
*/

BSTR CAUCatalog::buildDownloadResult()
{
    BSTR bsRet = NULL;
    HRESULT hr ;
    DEBUGMSG("CAUCatalog::buildDownloadResult() starts");

    if (NULL == m_bsInstallation)
        {
        DEBUGMSG("CAUCatalog::buildDownloadResult() got NULL item details");
        goto done;
        }
    bsRet = BuildDownloadResult(m_bsInstallation, m_pItemList);
done:
//    DEBUGMSG("CAUCatalog::buildDownloadResult() got download result : %S", bsRet);
    LOGFILE("downloadresult.xml",bsRet);
    return bsRet;
}
        
HRESULT CAUCatalog::InstallItems()
{
    HRESULT hr;
	DEBUGMSG("CAUCatalog installing items...");
	if (NULL == m_bsInstallation || NULL == m_bsDownloadResult)
	    {
	    DEBUGMSG("CAUCatalog::InstallItems() can't get installation xml or download result xml");
	    hr = E_FAIL;
	    goto end;
	    }
	BSTR bsUuidOperation;

//BSTR bsDownloadResult = DBGReadXMLFromFile(A2W(DOWNLOAD_FILE));
//testing only
    UINT uItemCount = m_pItemList->Count();
    for (UINT i = 0; i<uItemCount; i++)
        {
        CItem *pItem = (*(m_pItemList))[i];
        if (NULL == pItem)
            {

            DEBUGMSG("fail to get item from item list");
            }
        else
            {
            pItem->MarkSelected();
            }
        }
//testing end
	
	hr = m_pfnInstallAsync(m_bsClientInfo,
							m_bsInstallation,
							m_bsDownloadResult,
							UPDATE_NOTIFICATION_ANYPROGRESS, //online mode
							m_pInstallListener, //progress listener
							0,	//hWnd
							NULL,
							&bsUuidOperation);
	DEBUGMSG("CAUCatalog::InstallItems() operation uuid is %S", bsUuidOperation);
	DEBUGMSG("CAUCatalog::InstallItems() now wait for installation to finish");
	WaitForSingleObject(ghInstallDone, INFINITE);
	SafeFreeBSTR(bsUuidOperation);	
end:
	DEBUGMSG("CAUCatalog done items installation");
	return hr;
}

char * CAUCatalog::GetLevelStr(DETECTLEVEL enLevel)
{
	switch (enLevel)
	{
	case PROVIDER_LEVEL: return "Provider";
	case PRODUCT_LEVEL: return "Product";
	case ITEM_LEVEL: return "Item";
	case DETAILS_LEVEL: return "ItemDetails";
	default: return NULL;
	}
}

HRESULT CAUCatalog::ValidateItems(BOOL fOnline, BOOL *pfValid)
{
    DEBUGMSG("CAUCatalog validating items...");
    DEBUGMSG("CAUCatalog done validating items");
    *pfValid = TRUE;
    return S_OK;
}

HRESULT CAUCatalog::DetectItems()
{
    HRESULT hr;
    BSTR bsNonDriverInstall = NULL, bsDriverInstall = NULL;
    CItemList  *pNonDriverList = NULL, *pDriverList = NULL;

    DEBUGMSG("CAUCatalog::DetectItems() starts");
    if (FAILED(hr = GetSystemSpec()))
	{
	DEBUGMSG("  Fail to Getsystem spec %#lx", hr);
	goto done;
	}
    DEBUGMSG("System spec got ");

    if (FAILED(hr = DetectNonDriverItems(&bsNonDriverInstall, &pNonDriverList)))
        {

        DEBUGMSG(" fail to detect non driver updates %#lx", hr);
        goto done;
        }
    DEBUGMSG("Non driver items got");
    if (FAILED(hr = DetectDriverItems(&bsDriverInstall, &pDriverList)))
        {
        DEBUGMSG("fail to detect driver updates %#lx", hr);
        goto done;
        }
    DEBUGMSG("Driver items got");
    if (FAILED(hr = MergeDetectionResult(bsDriverInstall, bsNonDriverInstall, *pDriverList, *pNonDriverList)))
        {
        DEBUGMSG("fail to merge detection result for drivers and nondrivers");
        }
    DEBUGMSG("Driver items and non driver items merged");
    //testing only
    m_pItemList->Iterate();
    //testing end
    if (FAILED( hr =DownloadRTFsnEULAs()))
        {
        DEBUGMSG("downloading RTF and EULAs %s", FAILED(hr)? "failed" : "succeeded");
        }

  done:
        SafeFreeBSTR(bsNonDriverInstall);
        SafeFreeBSTR(bsDriverInstall);
        SafeDelete(pDriverList);
        SafeDelete(pNonDriverList);
        if (FAILED(hr))
            {
                Clear();
            }
        DEBUGMSG("CAUCatalog::DetectItems() ends");
        return hr;
}

HRESULT CAUCatalog::MergeDetectionResult(BSTR bsDriverInstall, BSTR bsNonDriverInstall, CItemList & driverlist, CItemList & nondriverlist)
{
    HRESULT hr= S_OK;
    UINT uDriverNum = driverlist.Count();
    UINT uNonDriverNum = nondriverlist.Count();

    m_pItemList = new CItemList();
    if (NULL == m_pItemList)
        {
        hr = E_FAIL;
        goto done;
        }
    UINT nums[2] = {uDriverNum, uNonDriverNum};
    CItemList * pitemlists[2] = {&driverlist, &nondriverlist};
    for (UINT j = 0; j < 2 ; j++)
        {
        for (UINT i = 0; i < nums[j]; i++)
            {
            CItem * pItem = new CItem(*((*pitemlists[j])[i]));
            if (NULL == pItem)
                {
                DEBUGMSG("Fail to create item");
                hr = E_FAIL;
                goto done;
                }
            m_pItemList->Add(pItem);
            }
        }        
    hr = MergeCatalogs(bsDriverInstall, bsNonDriverInstall, &m_bsInstallation);
done:
    if (FAILED(hr))
        {
        SafeDeleteNULL(m_pItemList);
        }
    return hr;
}

// go through 1 cycle to detect driver items 
HRESULT CAUCatalog::DetectDriverItems(OUT BSTR *pbsInstall, OUT CItemList **pItemList)
{
    HRESULT hr;

    DEBUGMSG("CAUCatalog detecting driver items...");
    *pItemList = NULL;
    if (FAILED(hr = GetManifest(DRIVERS_LEVEL, NULL, pbsInstall)))
    	{
        DEBUGMSG(" Fail to get drivers manifest %#lx", hr);
        goto end;
    	}

    *pItemList = ExtractDriverItemInfo(*pbsInstall);

  if (NULL != *pItemList)
    {
#ifdef DBG
        (*pItemList)->Iterate();
#endif
    }
  else
    {
        hr = E_FAIL;
        SysFreeString(*pbsInstall);
        DEBUGMSG(" fail to extract item information");
    }

end: 
    if (FAILED(hr))
        {
        SafeDelete(*pItemList);
        }
    DEBUGMSG("CAUCatalog detecting driver items done");
    return hr;
}


          

// go through 4 cycles to detect software items 
// get down manifest 
HRESULT CAUCatalog::DetectNonDriverItems(BSTR *pbsInstall, CItemList **pItemList)
{
    HRESULT hr;
    BSTR bsManifest = NULL;
    BSTR bsResult=NULL;

    DEBUGMSG("CAUCatalog detecting non driver items...");
    *pItemList = NULL;
    for (int enLevel = MIN_LEVEL; enLevel <= MAX_LEVEL; enLevel++)
    {
    	DEBUGMSG("#%d pass", enLevel+1);
    	hr = GetManifest((DETECTLEVEL)enLevel, bsResult, &bsManifest);
    	SafeFreeBSTR(bsResult);
    	if (FAILED(hr))
    	{
    		DEBUGMSG(" Fail to get %s %#lx", GetLevelStr((DETECTLEVEL)enLevel), hr);
    		goto end;
    	}
    	DEBUGMSG("%s got", GetLevelStr((DETECTLEVEL)enLevel));
    	if (DETAILS_LEVEL != enLevel)
    	{
    		hr = DoDetection((DETECTLEVEL)enLevel, bsManifest, &bsResult);
    		SafeFreeBSTR(bsManifest);
    		if (FAILED(hr))
    		{
    			DEBUGMSG("Fail to do detection %#lx", hr);
    			goto end;
    		}
    	}
    }

    *pbsInstall = bsManifest;
    *pItemList = ExtractNormalItemInfo(bsManifest);

      if (NULL != *pItemList)
        {
#ifdef DBG
            (*pItemList)->Iterate();
#endif
        }
      else
        {
        DEBUGMSG(" fail to extract item information");
        }

    end: 
        if (FAILED(hr))
            {
            SafeDelete(*pItemList);
            }
        DEBUGMSG("CAUCatalog detecting non driver items done");
        return hr;
}


void __cdecl main()
{

	DEBUGMSG("Testing starts");
	CAU_BSTR bsDestDir(L"c:\\tmp");
	CAUCatalog catalog;
	HRESULT hr ;
	if (FAILED(hr = PrepareTest()))
	{
		DEBUGMSG("Fail to init test %#lx", hr);
		goto end;
	}

	DEBUGMSG("Test inited");
	
	if (FAILED(hr = catalog.Init()))
	{
		DEBUGMSG("Fail to init AU catalog %#lx", hr);
		goto end;
	}
	DEBUGMSG("AU Catalog Initialized");

       if (FAILED(hr = catalog.DetectItems()))
        {
            DEBUGMSG("Fail to build AU catalog %#lx", hr);
            goto end;
        }
       DEBUGMSG("AU catalog built");

        BOOL fValid;
       if (FAILED(hr = catalog.ValidateItems(TRUE, &fValid)))
        {
            DEBUGMSG("Fail to validate AU catalog %#lx", hr);
            goto end;
        }
       DEBUGMSG("AU catalog is %s", fValid ? "valid" : "invalid");
       
	BSTR bsDownloadResult;
	if (FAILED(hr = catalog.DownloadItems(bsDestDir)))
	{
		DEBUGMSG("Fail to download AU catalog items %#lx", hr);
		goto end;
	}
	DEBUGMSG("AU catalog items downloaded");

	if (FAILED(hr = catalog.InstallItems()))
	{
		DEBUGMSG("Fail to install AU catalog items %#lx", hr);
		goto end;
	}

end:
	catalog.Uninit();
	PostTest();
	DEBUGMSG("Testing done");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\wuauclt\aucltcatalog.h ===
//=======================================================================
//
//  Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:    AUCltCatalog.h
//
//  Creator: PeterWi
//
//  Purpose: Client AU Catalog Definitions
//
//=======================================================================

#pragma once
#include "AUBaseCatalog.h"
#include "WrkThread.h"
//#include <iuprogress.h>

class CInstallCallback : public IProgressListener
{
public: 
		// IUnknown
	   STDMETHOD(QueryInterface)(REFIID riid, void **ppvObject);
       STDMETHOD_(ULONG, AddRef)(void);
       STDMETHOD_(ULONG, Release)(void);
	
	   // IProgressListener
	   HRESULT STDMETHODCALLTYPE OnItemStart( 
            /* [in] */ BSTR bstrUuidOperation,
            /* [in] */ BSTR bstrXmlItem,
            /* [out] */ LONG *plCommandRequest);

        HRESULT STDMETHODCALLTYPE OnProgress( 
            /* [in] */ BSTR bstrUuidOperation,
            /* [in] */ VARIANT_BOOL fItemCompleted,
            /* [in] */ BSTR bstrProgress,
            /* [out] */ LONG *plCommandRequest);

        HRESULT STDMETHODCALLTYPE OnOperationComplete( 
            /* [in] */ BSTR bstrUuidOperation,
            /* [in] */ BSTR bstrXmlItems);

private:
    long m_refs;
};

//wrapper class for AU to do detection using IU
class AUClientCatalog : public AUBaseCatalog
{
public:
	AUClientCatalog(): m_bstrClientInfo(NULL), m_pInstallCallback(NULL) {}
    ~AUClientCatalog();
    HRESULT InstallItems(BOOL fAutoInstall);
    HRESULT Init();
//    void Uninit();

	IProgressListener * m_pInstallCallback;
	BSTR	m_bstrClientInfo;
	BOOL m_fReboot;
    	CClientWrkThread m_WrkThread;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\wuauclt\auinternals.h ===
//=======================================================================
//
//  Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:    AUInternals.h
//
//  Creator: PeterWi
//
//  Purpose: Client AU Internal Definitions
//
//=======================================================================

#pragma once
#include "aubasecatalog.h"

extern AUClientCatalog *gpClientCatalog;

struct AUDownloadStatus
{
	DWORD m_percentageComplete;
	BOOL  m_bSuspended;
};

class CAUInternals
{
public:
	CAUInternals():m_pUpdates(NULL)
		{}
	~CAUInternals();

	HRESULT	m_Init()
	{
		return CoCreateInstance(__uuidof(Updates),
					NULL,
					 CLSCTX_LOCAL_SERVER,
					 IID_IUpdates,
					 (LPVOID*)&m_pUpdates);
	}
	HRESULT	m_setReminderTimeout(UINT iTimeout);
	HRESULT	m_setReminderState(DWORD);	
	HRESULT	m_getServiceState(AUSTATE *pAuState);
	HRESULT	m_getServiceOption(AUOPTION *pauopt)
	{
#ifdef TESTUI
		return S_OK;
#else
		HRESULT hr = m_pUpdates->get_Option(pauopt);
		return hr;
#endif
	}

	HRESULT	m_setServiceOption(AUOPTION auopt)
	{
#ifdef TESTUI
		return S_OK;
#else
		return m_pUpdates->put_Option(auopt);
#endif
	}

	HRESULT m_getServiceUpdatesList(void);
	HRESULT m_saveSelectionsToServer(IUpdates *pUpdates);
	HRESULT m_startDownload(void);
	HRESULT m_getDownloadStatus(UINT *, DWORD *);
	HRESULT m_setDownloadPaused(BOOL);
	HRESULT m_startInstall(BOOL fAutoInstall = FALSE);
	HRESULT m_configureAU();
	HRESULT m_AvailableSessions(LPUINT pcSess);
	HRESULT m_getEvtHandles(DWORD dwProcId, AUEVTHANDLES *pAuEvtHandles);

	IUpdates* m_pUpdates;
	AUCatalogItemList m_ItemList;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\wuauclt\cltdebug.h ===
#pragma once

#ifdef DBG

void DebugCheckForAutoPilot(HWND hwnd);
void DebugUninstallDemoPackages(void);

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\wuauclt\customlbacc.cpp ===
//=======================================================================
//
//  Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:    customlbacc.cpp
//
//  Creator: weiw
//
//  Purpose: custom list box accessibility file
//
//=======================================================================
#include <pch.h>
#pragma hdrstop

BSTR GetMYLBItemTitle(DWORD idChild)
{
	//DEBUGMSG("GetMYLBItemTitle() called");
	static LPCTSTR tszDefItemTitle = _T("");
	LRESULT lr =  SendMessage(ghWndList, LB_GETITEMDATA, idChild, 0);
	if (LB_ERR == lr)
	{
		return SysAllocString(tszDefItemTitle);
	}
	LBITEM *pItem = (LBITEM*) lr;
	return SysAllocString(pItem->szTitle);
}

BSTR GetMYLBItemDesc(DWORD idChild)
{
	//DEBUGMSG("GetMYLBItemDesc() called");
	static LPCTSTR tszDefItemDesc = _T("");
	_bstr_t bstrItemDesc;
	BSTR   bsRet = NULL;
	LRESULT lr = SendMessage(ghWndList, LB_GETITEMDATA, idChild, 0);
	try 
	{
		if (LB_ERR == lr)
		{
			bstrItemDesc = _bstr_t(tszDefItemDesc);
		}
		else
		{
			LBITEM *pItem = (LBITEM*) lr;
			bstrItemDesc = _bstr_t(pItem->pszDescription);
			if (pItem->bRTF)
			{
				DEBUGMSG("GetMYLBItemDesc() Item got RTF, adding %S", gtszRTFShortcut);
				bstrItemDesc += _bstr_t(gtszRTFShortcut);
			}
		}
		bsRet = bstrItemDesc.copy();
	}
	catch (...)
	{
		DEBUGMSG("GetMYLBItemDesc() got _bstr_t exception");
	}
	return bsRet;
}

DWORD GetMYLBItemState(DWORD idChild)
{
	//DEBUGMSG("GetMYLBItemState() called");
	DWORD dwState = STATE_SYSTEM_FOCUSABLE|STATE_SYSTEM_SELECTABLE;
	LRESULT lr = SendMessage(ghWndList, LB_GETITEMDATA, idChild, 0);
	if (LB_ERR == lr)
	{
		goto done;
	}
	LBITEM *pItem = (LBITEM*) lr;
	if (pItem->bSelect)
	{
		dwState |= STATE_SYSTEM_CHECKED;
	}
	if (idChild == gFocusItemId)
	{
		dwState |= STATE_SYSTEM_FOCUSED|STATE_SYSTEM_SELECTED;
	}
done:
	return dwState;
}

HRESULT STDMETHODCALLTYPE MYLBAccPropServer::GetPropValue ( 
        const BYTE *    pIDString,
        DWORD           dwIDStringLen,
        MSAAPROPID      idProp,
        VARIANT *       pvarValue,
        BOOL *          pfGotProp )
{
	HRESULT hr = S_OK;
	BOOL fHoldMYLB = FALSE;

	//DEBUGMSG("MYLBAccPropServer::GetPropValue() starts");
	if (NULL == pvarValue || NULL == pfGotProp)
	{
		hr = E_INVALIDARG;
		goto done;
	}

	pvarValue->vt = VT_EMPTY;
	*pfGotProp = FALSE;

	if (!(fHoldMYLB = TryEnterCriticalSection(&gcsClient))|| 
		! IsWindow( ghWndList ) ||
		GetProp( ghWndList, MYLBALIVEPROP) != (HANDLE)TRUE )
	{
		DEBUGMSG("GetPropValue() MYLB is not alive any more");
		hr = RPC_E_DISCONNECTED;
		goto done;
	}

    HWND  hwnd;
    DWORD idObject;
    DWORD idChild;

    if( S_OK != m_pAccPropSvc->DecomposeHwndIdentityString( pIDString, dwIDStringLen,
                & hwnd, & idObject, & idChild ) )
    {
        // problem decomposing identity string - return early...
        goto done;
    }

    if( idChild != CHILDID_SELF )
    {
        DEBUGMSG("MYLBAccPropServer::GetPropValue() for child Id %lu", idChild);
        if  (PROPID_ACC_NAME == idProp)
        {
            pvarValue->bstrVal = GetMYLBItemTitle(idChild-1);
			if (NULL == pvarValue->bstrVal)
			{
				goto done;
			}
			pvarValue->vt = VT_BSTR;
            *pfGotProp = TRUE;
		}
		else if (PROPID_ACC_STATE == idProp)
		{
			pvarValue->vt = VT_I4;
			pvarValue->lVal = GetMYLBItemState(idChild-1);
			*pfGotProp = TRUE;
		}
		else if (PROPID_ACC_ROLE == idProp)
		{
			pvarValue->vt = VT_I4;
            pvarValue->lVal = ROLE_SYSTEM_CHECKBUTTON;
            *pfGotProp = TRUE;
		}
		else if (PROPID_ACC_DESCRIPTION == idProp)
		{
			pvarValue->bstrVal = GetMYLBItemDesc(idChild-1);
			if (NULL == pvarValue->bstrVal)
			{
				goto done;
			}
			pvarValue->vt = VT_BSTR;
			*pfGotProp = TRUE;
		}
    }

done:
	if (fHoldMYLB)
	{
		LeaveCriticalSection(&gcsClient);
	}

	//DEBUGMSG("MYLBAccPropServer::GetPropValue() ends");
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\wuauclt\auinternals.cpp ===
#include "pch.h"
#pragma hdrstop

#include "wuauengi_i.c"

CAUInternals::~CAUInternals()
{
	if (m_pUpdates != NULL)
	{
		m_pUpdates->Release();
	}
}

HRESULT CAUInternals::m_setReminderState(DWORD dwState)
{
	HRESULT hr = S_OK;

	// save selections so we have them after the reminder
	if ( AUSTATE_NOT_CONFIGURED == dwState || (SUCCEEDED(hr = m_saveSelectionsToServer(m_pUpdates))))
	{
		hr = SetRegDWordValue(TIMEOUTSTATE, dwState);
	}
	return hr;
}

/*****
 Takes the number of seconds we want to wait before reminding the user
 and records it in the current user's registry along with a timestamp.
*****/
HRESULT CAUInternals::m_setReminderTimeout(UINT iTimeout)
{
	//const int NanoSec100PerSec = 10000000;
	DEBUGMSG("WUAUCLT Setting timeout = %lu", ReminderTimes[iTimeout].timeout);

	DWORD timeout;

	if ( TIMEOUT_INX_TOMORROW == iTimeout )
	{
		// time to wait is midnight - current time.
		SYSTEMTIME tmCurrent;
		SYSTEMTIME tmMidnight;
		FILETIME ftCurrent;
		FILETIME ftMidnight;

		GetLocalTime(&tmCurrent);
		tmMidnight = tmCurrent;
		tmMidnight.wHour = 23;
		tmMidnight.wMinute = 59;
		tmMidnight.wSecond = 59;
		tmMidnight.wMilliseconds  = 999;

		SystemTimeToFileTime(&tmCurrent,  &ftCurrent);
		SystemTimeToFileTime(&tmMidnight, &ftMidnight);
		ULONGLONG diff = *((ULONGLONG *)&ftMidnight) - *((ULONGLONG *)&ftCurrent);
		timeout = DWORD(diff / NanoSec100PerSec);
		DEBUGMSG("WUAUCLT: tomorrow is %lu secs away", timeout);
	}
	else
	{
		timeout = ReminderTimes[iTimeout].timeout;
	}

	return setAddedTimeout(timeout, TIMEOUTVALUE);
}

HRESULT CAUInternals::m_getServiceState(AUSTATE *pAuState)
{
#ifdef TESTUI
		return S_OK;
#else
	if (NULL == m_pUpdates)
	{
		return E_FAIL;
	}
	HRESULT hr = m_pUpdates->get_State(pAuState);
	if (FAILED(hr))
	{
		DEBUGMSG("WUAUCLT m_getServiceState failed, hr=%#lx", hr);		
	}
	return hr;
#endif
}


HRESULT TransformSafeArrayToItemList(VARIANT & var, AUCatalogItemList & ItemList)
{
	HRESULT hr; //= S_OK;


	// determine how many elements there are.
	if (FAILED(hr = ItemList.Allocate(var)))
	{
	    DEBUGMSG("WUAUCLT fail to allocate item list with error %#lx", hr);
	    goto done;
	}
    DEBUGMSG("ItemList had %d elements", ItemList.Count());
#if 0
	if ( !m_bValid )
	{
		DEBUGMSG("Catalog::getUpdateList fails because catalog is not valid");
		goto done;
	}
#endif
	for ( UINT index = 0; index < ItemList.Count(); index++ )
	{
		VARIANT varg;
		VariantInit(&varg);

		struct
		{
			VARTYPE vt;
			void * pv;
		} grMembers[] = { { VT_I4,		&ItemList[index].m_dwStatus }, 
						  { VT_BSTR,	&ItemList[index].m_bstrID },
						  { VT_BSTR,	&ItemList[index].m_bstrProviderName },
						  { VT_BSTR,	&ItemList[index].m_bstrTitle },
						  { VT_BSTR,	&ItemList[index].m_bstrDescription },
						  { VT_BSTR,	&ItemList[index].m_bstrRTFPath },
						  { VT_BSTR,	&ItemList[index].m_bstrEULAPath } };

		for ( int index2 = 0; index2 < ARRAYSIZE(grMembers); index2++ )
		{
    		long dex = (index * 7) + index2;

			if ( FAILED(hr = SafeArrayGetElement(var.parray, &dex, &varg)) )
			{
                DEBUGMSG("Failed to get element %ld", dex);
				goto done;
			}

			switch (grMembers[index2].vt)
			{
			case VT_I4:
				*((long *)grMembers[index2].pv) = varg.lVal;
				break;
			
			case VT_BSTR:
				*((BSTR *)grMembers[index2].pv) = varg.bstrVal;
				break;
			}
		}
	}

done:
	return hr; 
}


HRESULT CAUInternals::m_getServiceUpdatesList(void)
{
#ifdef TESTUI
    return S_OK;
#else
    VARIANT var;
    HRESULT hr;
    
    if ( SUCCEEDED(hr = m_pUpdates->GetUpdatesList(&var)) &&
         SUCCEEDED(hr = TransformSafeArrayToItemList(var, m_ItemList)) )
    {
//        gItemList.DbgDump();
    }
    else
    {	
        DEBUGMSG("WUAUCLT m_getUpdatesList failed, hr=%#lx", hr);
    }

    VariantClear(&var);

    return hr;
#endif
}


HRESULT CAUInternals::m_saveSelectionsToServer(IUpdates *pUpdates)
{
    HRESULT hr = E_FAIL;
	SAFEARRAYBOUND bound[1] = { m_ItemList.Count() * 2, 0};

	if ( 0 == m_ItemList.Count() )
	{
		DEBUGMSG("Catalog::m_saveSelectionsToServer fails because getNumItems is 0");
		hr = E_UNEXPECTED;
		goto Done;
	}

	VARIANT varSelections;
    varSelections.vt = VT_ARRAY | VT_VARIANT;

	if (NULL == (varSelections.parray = SafeArrayCreate(VT_VARIANT, 1, bound)))
    {
		hr = E_OUTOFMEMORY;
		goto Done;
    }

	VARIANT *grVariant = NULL;
	if (FAILED(hr = SafeArrayAccessData(varSelections.parray, (void **)&grVariant)))
	{
		goto CleanUp;
	}

	for ( UINT n = 0; n < m_ItemList.Count(); n++ )
	{
		if (NULL == (grVariant[n*2+0].bstrVal = SysAllocString(m_ItemList[n].bstrID())))
		{
			hr = E_OUTOFMEMORY;
			break;
		}
		grVariant[n*2+0].vt = VT_BSTR;
		grVariant[n*2+1].vt = VT_I4;
		grVariant[n*2+1].lVal = m_ItemList[n].dwStatus();
	}
	HRESULT hr2 = SafeArrayUnaccessData(varSelections.parray);
	if (SUCCEEDED(hr) && FAILED(hr2))
	{
		hr = hr2;
		goto CleanUp;
	}

	if (SUCCEEDED(hr))
	{
		hr = pUpdates->SaveSelections(varSelections);
	}

CleanUp:
    VariantClear(&varSelections);

Done:
	return hr; 
}

HRESULT CAUInternals::m_startDownload(void)
{
	//fixcode this call is probably unneccesary
	HRESULT hr = m_saveSelectionsToServer(m_pUpdates);
       DEBUGMSG("WUAUCLT %s download", FAILED(hr) ? "skip" : "start");
	if ( SUCCEEDED(hr) )
	{
		hr = m_pUpdates->StartDownload();

		if (FAILED(hr))
		{
			DEBUGMSG("WUAUCLT m_startDownload failed, hr=%#lx", hr);
		}
	}

	return hr;
}

HRESULT CAUInternals::m_getDownloadStatus(UINT *percent, DWORD *status)
{
	HRESULT hr = m_pUpdates->GetDownloadStatus(percent, status);
	if (FAILED(hr))
	{
		DEBUGMSG("WUAUCLT m_getDownloadStatus failed, hr=%#lx", hr);
	}
	return hr;
}

HRESULT CAUInternals::m_setDownloadPaused(BOOL bPaused)
{
	HRESULT hr = m_pUpdates->SetDownloadPaused(bPaused);
	if (FAILED(hr))
	{
		DEBUGMSG("WUAUCLT m_setDownloadPaused failed, hr=%#lx", hr);
	}
	return hr;
}

//fAutoInstall  TRUE if client doing install via local system
// FALSE if installing via local admin
HRESULT CAUInternals::m_startInstall(BOOL fAutoInstall)
{
	HRESULT hr = m_pUpdates->ClientMessage(AUMSG_PRE_INSTALL);

	if (FAILED(hr))
	{
		DEBUGMSG("WUAUCLT m_startInstall failed, hr=%#lx", hr);
	}
	else
	{
	    gpClientCatalog->m_WrkThread.m_DoDirective(fAutoInstall ? enWrkThreadAutoInstall :  enWrkThreadInstall);
	}
	return hr;
}

//fixcode: should change name to complete wizard
HRESULT CAUInternals::m_configureAU()
{
	HRESULT hr = m_pUpdates->ConfigureAU();
	if (FAILED(hr))
	{
		DEBUGMSG("WUAUCLT m_ConfigureAU failed, hr=%#lx", hr);
	}
	return hr;
}

#if 0
long CAUInternals::m_getNum(DWORD dwSelectionStatus)
{
	long total = 0;
	
    
    for (UINT index = 0; index < gItemList.Count(); index++ )
	{
		if ( dwSelectionStatus == gItemList[index].dwStatus() )
		{
			total++;
		}
	}

    return total;
}
#endif

HRESULT CAUInternals::m_AvailableSessions(LPUINT pcSess)
{
	if (NULL == pcSess)
	{
		return E_INVALIDARG;
	}
	return m_pUpdates->AvailableSessions(pcSess);
}

HRESULT CAUInternals::m_getEvtHandles(DWORD dwProcId, AUEVTHANDLES *pAuEvtHandles)
{
	HRESULT	hr = m_pUpdates->get_EvtHandles(dwProcId, pAuEvtHandles);
	if (FAILED(hr))
	{
		DEBUGMSG("WUAUCLT get_EvtHandles failed hr=%#lx", hr);
	}
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\wuauclt\cltdebug.cpp ===
#include "pch.h"
#pragma hdrstop

#ifdef DBG
//=======================================================================
//
//  Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:    cltdebug.cpp
//
//  Creator: PeterWi
//
//  Purpose: wuauclt debug functions.
//
//=======================================================================
const UINT_PTR AU_AUTOPILOT_TIMER_ID = 555;
const DWORD AU_AUTOPILOT_TIMEOUT = 2000;

//=======================================================================
//
//  DebugAutoPilotTimerProc
//
//  Called after timeout to dismiss dialog.
//
//=======================================================================

VOID CALLBACK DebugAutoPilotTimerProc( HWND hWnd,         // handle to window
								  UINT /*uMsg*/,         // WM_TIMER message
								  UINT_PTR /*idEvent*/,  // timer identifier
								  DWORD /*dwTime*/)      // current system time
{
	if ( hWnd == ghMainWindow )
	{
		PostMessage(hWnd, AUMSG_TRAYCALLBACK, 0, WM_LBUTTONDOWN);
	}
	else
	{
		PostMessage(hWnd, WM_COMMAND, IDC_OK, 0);
	}

	KillTimer(hWnd, AU_AUTOPILOT_TIMER_ID);
}

//=======================================================================
//
//  DebugCheckForAutoPilot
//
//  Check to see if we want AU to run by itself.
//
//=======================================================================
void DebugCheckForAutoPilot(HWND hWnd)
{
	DWORD dwAutoPilot;

	if ( SUCCEEDED(GetRegDWordValue(TEXT("AutoPilot"), &dwAutoPilot)) &&
		 (0 != dwAutoPilot) )
	{
		SetTimer(hWnd, AU_AUTOPILOT_TIMER_ID, AU_AUTOPILOT_TIMEOUT, DebugAutoPilotTimerProc);
	}
}

//=======================================================================
//
//  DebugUninstallDemoPackages
//
//  Uninstall demo packages and increase iteration count.
//
//=======================================================================
void DebugUninstallDemoPackages(void)
{
	DWORD dwAutoPilot;

	if ( SUCCEEDED(GetRegDWordValue(TEXT("AutoPilot"), &dwAutoPilot)) &&
		 (0 != dwAutoPilot) )
	{
		if ( FAILED(GetRegDWordValue(TEXT("AutoPilotIteration"), &dwAutoPilot)) )
		{
			dwAutoPilot = 0;
		}

		DEBUGMSG("AUTOPILOT: Finished iteration %d", ++dwAutoPilot);
		SetRegDWordValue(TEXT("AutoPilotIteration"), dwAutoPilot);

		fRegKeyDelete(TEXT("SOFTWARE\\Microsoft\\Active Setup\\Installed Components\\{0A1F2CEC-8688-4d1b-A266-051415FBEE91}"));
		fRegKeyDelete(TEXT("SOFTWARE\\Microsoft\\Active Setup\\Installed Components\\{09AC50A5-0354-479b-8961-EDA2CE7AC002}"));
		fRegKeyDelete(TEXT("SOFTWARE\\Microsoft\\Active Setup\\Installed Components\\{0101E65E-8C15-4551-8455-D2CC10FBEA01}"));
	}
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\wuauclt\customlbacc.h ===
//=======================================================================
//
//  Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:    customlbacc.h
//
//  Creator: weiw
//
//  Purpose: custom list box accessibility header file
//
//=======================================================================

#pragma once
#include <pch.h>


class MYLBAccPropServer : public IAccPropServer {

    LONG               m_Ref;
    IAccPropServices *  m_pAccPropSvc;

public:

    MYLBAccPropServer(IAccPropServices * pAccPropSvc )
        : m_Ref( 1 ),
          m_pAccPropSvc( pAccPropSvc )
    {
        m_pAccPropSvc->AddRef();
    }

    ~MYLBAccPropServer()
    {
        m_pAccPropSvc->Release();
    }
	
// IUnknown
	STDMETHOD(QueryInterface)(REFIID riid, void **ppvObject)
	{
		HRESULT hr = S_OK;
		*ppvObject = NULL;

		if (__uuidof(IUnknown)  == riid ||
			__uuidof(IAccPropServer) == riid)
        {
			*ppvObject = (void *)this;
			AddRef();
        }
		else
        {
			DEBUGMSG("MYLBAccPropServer QueryInterface(): interface not supported");
			hr = E_NOINTERFACE;
        }

		return hr;
	}

	STDMETHOD_(ULONG, AddRef)(void)
	{
		 long cRef = InterlockedIncrement(&m_Ref);
		 //DEBUGMSG("MYLBAccPropServer AddRef = %d", cRef);
		 return cRef;
	}
	
	STDMETHOD_(ULONG, Release)(void)
	{
		long cRef = InterlockedDecrement(&m_Ref);
		//DEBUGMSG("MYLBAccPropServer Release = %d", cRef);
		if (0 == cRef)
		{
			delete this;
		}
		return cRef;
	}

// IAccPropServer
	HRESULT STDMETHODCALLTYPE GetPropValue ( 
            const BYTE *    pIDString,
            DWORD           dwIDStringLen,
            MSAAPROPID      idProp,
            VARIANT *       pvarValue,
            BOOL *          pfGotProp );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\wuauclt\customlb.cpp ===
#include "pch.h"
#pragma hdrstop


void SetMYLBAcc(HWND hListWin);
void DrawMYLBFocus(HWND hListWin, LPDRAWITEMSTRUCT lpdis, MYLBFOCUS enCurFocus, INT nCurFocusId);
void DrawItem(LPDRAWITEMSTRUCT lpdis, BOOL fSelectionDisabled);
void DrawTitle(HDC hDC, LBITEM * plbi, RECT rc);
void DrawRTF(HDC hDC, LBITEM * plbi, const RECT & rc /*, BOOL bHit*/);
void DrawDescription(HDC hDC, LBITEM * plbi, RECT & rc);
void DrawBitmap(HDC hDC, LBITEM * plbi, const RECT & rc, BOOL fSel, BOOL fSelectionDisabled);
void CalcTitleFocusRect(const RECT &rcIn, RECT & rcOut);
void CalcRTFFocusRect(const RECT &rcIn, RECT & rcOut);
int  CalcDescHeight(HDC hDC, LPTSTR ptszDescription, int cx);
int  CalcRTFHeight(HDC hDC, LPTSTR ptszRTF);
int  CalcRTFWidth(HDC hDC, LPTSTR ptszRTF);
int  CalcTitleHeight(HDC hDC, LPTSTR ptszTitle, int cx);
int  CalcItemHeight(HDC hDC, LPTSTR ptszTitle, LPTSTR ptszDescription, LPTSTR ptszRTF, int cx);
void CalcItemLocation(HDC hDC, LBITEM * plbi, const RECT & rc);
void ToggleSelection(HWND hDlg, HWND hListWin, LBITEM *pItem);
void AddItem(LPTSTR tszTitle, LPTSTR tszDesc, LPTSTR tszRTF, int index, BOOL fSelected, BOOL fRTF);
BOOL CurItemHasRTF(HWND hListWin);
void RedrawMYLB(HWND hwndLB);
void LaunchRTF(HWND hListWin);


HBITMAP ghBmpGrayOut; //=NULL;
HBITMAP ghBmpCheck; // = NULL;
HBITMAP ghBmpClear; // = NULL;
HFONT   ghFontUnderline; // = NULL;
HFONT   ghFontBold; // = NULL;
HFONT   ghFontNormal; // = NULL;
HWND   ghWndList; //=NULL;

MYLBFOCUS gFocus;
INT	  gFocusItemId;
TCHAR gtszRTFShortcut[MAX_RTFSHORTCUTDESC_LENGTH];


void LaunchRTF(HWND hListWin)
{
	HWND hDlg = GetParent(hListWin);
	int i = (LONG)SendMessage(ghWndList, LB_GETCURSEL, 0, 0);
	if(i != LB_ERR)
	{
		LBITEM* pItem = (LBITEM*)SendMessage(hListWin, LB_GETITEMDATA, i, 0);
		if (pItem && pItem->bRTF)
		{
			DEBUGMSG("MYLB show RTF for item %S", pItem->szTitle);
			PostMessage(GetParent(hDlg), AUMSG_SHOW_RTF, LOWORD(pItem->m_index), 0);
		}
	}  
}

////////////////////////////////////////////////////////////////////////////////
// Overwrite hListWin's accessibility behavior using dynamic annotation server
////////////////////////////////////////////////////////////////////////////////
void SetMYLBAcc(HWND hListWin)
{
    IAccPropServices * pAccPropSvc = NULL;
    HRESULT hr = CoCreateInstance(CLSID_AccPropServices, 
				NULL,
				CLSCTX_INPROC_SERVER,
				IID_IAccPropServices,
				(void **) &pAccPropSvc);
    if( hr == S_OK && pAccPropSvc )
    {
        MYLBAccPropServer* pMYLBPropSrv = new MYLBAccPropServer( pAccPropSvc );
        if( pMYLBPropSrv )
        {
            
            MSAAPROPID propids[4];
            propids[0] = PROPID_ACC_NAME;
			propids[1] = PROPID_ACC_STATE;
			propids[2] = PROPID_ACC_ROLE;
			propids[3] = PROPID_ACC_DESCRIPTION;

			pAccPropSvc->SetHwndPropServer( hListWin, OBJID_CLIENT, 0, propids, 4, pMYLBPropSrv, ANNO_CONTAINER);
		
            pMYLBPropSrv->Release();
        }
		pAccPropSvc->Release();
    }
    else
    {
    	DEBUGMSG("WANRING: WUAUCLT   Fail to create object AccPropServices with error %#lx", hr);
    }
	// Mark the listbox so that the server can tell if it alive
	SetProp(hListWin, MYLBALIVEPROP, (HANDLE)TRUE);

}

/*void DumpRect(LPCTSTR tszName, RECT rc)
{
	DEBUGMSG("DumpRect %S at (%d, %d, %d, %d)", tszName, rc.left, rc.top, rc.right, rc.bottom);
}
*/

void DrawItem(LPDRAWITEMSTRUCT lpdis, BOOL fSelectionDisabled)
{
	LRESULT lResult = SendMessage(lpdis->hwndItem, LB_GETITEMDATA, lpdis->itemID, 0); 
	
	if (LB_ERR == lResult)
	{
		return;
	}
	LBITEM * plbi = (LBITEM*) lResult;
	CalcItemLocation(lpdis->hDC, plbi, lpdis->rcItem);
	// Draw the title of the item
	DrawTitle(lpdis->hDC, plbi, plbi->rcTitle);
	// Draw the text of the item
	DrawDescription(lpdis->hDC, plbi, plbi->rcText);
	// Draw the bitmap
	DrawBitmap(lpdis->hDC, plbi, plbi->rcBitmap, plbi->bSelect, fSelectionDisabled);
	// draw the Read this First 
	DrawRTF(lpdis->hDC, plbi, plbi->rcRTF);
}

BOOL CurItemHasRTF(HWND hListWin)
{
	int i = (LONG)SendMessage(hListWin, LB_GETCURSEL, 0, 0);
	if (LB_ERR == i)
	{
		return FALSE;
	}
	LBITEM *pItem = (LBITEM*)SendMessage(hListWin, LB_GETITEMDATA, (WPARAM)i, 0);
	return pItem->bRTF;
}

BOOL fDisableSelection(void)
{
     AUOPTION auopt;
    if (SUCCEEDED(gInternals->m_getServiceOption(&auopt))
         && auopt.fDomainPolicy && AUOPTION_SCHEDULED == auopt.dwOption)
        {
            return TRUE;
        }
    return FALSE;
}

void ToggleSelection(HWND hDlg, HWND hListWin, LBITEM *pItem)
{
	//DEBUGMSG("ToggleSelection()");
	if (NULL == hDlg || NULL == hListWin || NULL == pItem || pItem->m_index >= gInternals->m_ItemList.Count())
	{
		AUASSERT(FALSE); //should never reach here.
		return;
	}
    HDC hDC = GetDC(hListWin);

	if (NULL == hDC)
	{
		return;
	}
	pItem->bSelect = !pItem->bSelect;
    DrawBitmap(hDC, pItem, pItem->rcBitmap, pItem->bSelect, FALSE); //obviously selection is allowed

#ifndef TESTUI
    gInternals->m_ItemList[pItem->m_index].SetStatus(pItem->bSelect ? AUCATITEM_SELECTED : AUCATITEM_UNSELECTED);
#endif
    PostMessage(GetParent(hDlg), AUMSG_SELECTION_CHANGED, 0, 0);
    ReleaseDC(hListWin, hDC);
}


void RedrawMYLB(HWND hwndLB)
{
	//DEBUGMSG("REDRAW MYLB ");
	InvalidateRect(ghWndList, NULL, TRUE);
	UpdateWindow(ghWndList);
}

void CalcTitleFocusRect(const RECT &rcIn, RECT & rcOut)
{
	rcOut = rcIn;
	rcOut.right -= TITLE_MARGIN * 2/3;
	rcOut.top += SECTION_SPACING * 2/3;
	rcOut.bottom -= SECTION_SPACING*2/3 ;
}

void CalcRTFFocusRect(const RECT &rcIn, RECT & rcOut)
{
	rcOut = rcIn;
	rcOut.left -=3;
	rcOut.right +=3;
	rcOut.top -= 2;
	rcOut.bottom += 2;
}

void DrawMYLBFocus(HWND hListWin, LPDRAWITEMSTRUCT lpdis, MYLBFOCUS enCurFocus, INT nCurFocusId)
{
	LBITEM * pItem;
	LRESULT lResult;
	
	//DEBUGMSG("DrawMYLBFocus for current focus %d with Item %d", enCurFocus, nCurFocusId);

	RECT rcNew;

	if (nCurFocusId != lpdis->itemID)
	{
		return;
	}

	if (GetFocus() != ghWndList )
	{
//		DEBUGMSG("CustomLB doesn't have focus");
		return;
	}

	lResult = SendMessage(hListWin, LB_GETITEMDATA, lpdis->itemID, 0);
	if (LB_ERR == lResult)
	{
		DEBUGMSG("DrawMYLBFocus() fail to get item data");
		goto done;
	}
	pItem = (LBITEM*) lResult;
	if (!EqualRect(&lpdis->rcItem, &pItem->rcItem))
    {
        CalcItemLocation(lpdis->hDC, pItem, lpdis->rcItem);
    }
                   
	if (enCurFocus == MYLB_FOCUS_RTF)
	{
		CalcRTFFocusRect(pItem->rcRTF, rcNew);
	}
	if (enCurFocus == MYLB_FOCUS_TITLE)
	{
		CalcTitleFocusRect(pItem->rcTitle, rcNew);
	}
	DrawFocusRect(lpdis->hDC, &rcNew); //set new focus rect
done:
	return;
}
	
LRESULT CallDefLBWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	static WNDPROC s_defLBWndProc = NULL;

	if (NULL == s_defLBWndProc)
	{
		s_defLBWndProc = (WNDPROC) GetWindowLongPtr(hWnd, GWLP_USERDATA);
	}
	
	return CallWindowProc(s_defLBWndProc, hWnd, message, wParam, lParam);
}


LRESULT CALLBACK newLBWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	switch (message)
	{
		case WM_GETDLGCODE:
			return DLGC_WANTALLKEYS;
		case WM_KEYDOWN:
			switch(wParam)
			{
			case VK_RIGHT:
			case VK_LEFT:
				if (MYLB_FOCUS_RTF == gFocus)
				{
					DEBUGMSG("LB change focus to Title");
					gFocus = MYLB_FOCUS_TITLE;
					RedrawMYLB(ghWndList);
				}
				else if (MYLB_FOCUS_TITLE == gFocus && CurItemHasRTF(hWnd))
				{
					DEBUGMSG("LB change focus to RTF");
					gFocus = MYLB_FOCUS_RTF;
					RedrawMYLB(ghWndList);
				}
				break;
			case VK_F1:
				if (GetKeyState(VK_SHIFT)<0) 
				{//SHIFT down
					LaunchRTF(hWnd);
					return 0;
				}
				break;
			case VK_RETURN:
				if (MYLB_FOCUS_RTF == gFocus)
				{
					DEBUGMSG("MYLB show RTF ");
					LaunchRTF(hWnd);
				}
				break;
			case VK_TAB:
				PostMessage(GetParent(hWnd), WM_NEXTDLGCTL, 0, 0L);
				break;
			default:
				return CallDefLBWndProc(hWnd, message, wParam, lParam);
			}
			return 0;
		case WM_KEYUP:

			switch(wParam)
			{
			case VK_RIGHT:
			case VK_LEFT:
				break;
			case VK_RETURN:
				break;
			default:
				return CallDefLBWndProc(hWnd, message, wParam, lParam);
			}
			return 0;
		default:
			break;
	}
	return CallDefLBWndProc(hWnd, message, wParam, lParam);
}


// Message handler for Custom List box.
LRESULT CALLBACK CustomLBWndProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    static int lenx;
    int clb;
    LBITEM *item;
    static BOOL s_fSelectionDisabled;
    
    switch (message)
    {
        case WM_CREATE:
            {
                RECT rcLst, rcDlg;
                LOGFONT lf;
				HFONT parentFont;
				TCHAR tszRTF[MAX_RTF_LENGTH] = _T("");

                GetClientRect(hDlg, &rcDlg);
                rcDlg.top += 2;
                rcDlg.bottom -= 3;
                rcDlg.left += 2;
                rcDlg.right -= 2;

                s_fSelectionDisabled = fDisableSelection();
                
                ghWndList = CreateWindow(_T("listbox"), NULL, 
                    WS_CHILD | WS_VISIBLE | LBS_NOTIFY | LBS_OWNERDRAWVARIABLE |
                    LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_WANTKEYBOARDINPUT | 
					WS_VSCROLL | WS_HSCROLL | WS_TABSTOP,
                    rcDlg.left, rcDlg.top, rcDlg.right - rcDlg.left, rcDlg.bottom - rcDlg.top,
                    hDlg, NULL, ghInstance, NULL);

                if (NULL == ghWndList)
                {
                    return -1;
                }
				WNDPROC defLBWndProc = (WNDPROC) GetWindowLongPtr(ghWndList, GWLP_WNDPROC);
				SetWindowLongPtr(ghWndList, GWLP_USERDATA, (LONG_PTR) defLBWndProc);
				SetWindowLongPtr(ghWndList, GWLP_WNDPROC, (LONG_PTR) newLBWndProc);
                    
                HDC hDC = GetDC(ghWndList);

                GetWindowRect(hDlg, &rcDlg);        
                GetClientRect(ghWndList, &rcLst);
                
                lenx = rcLst.right - rcLst.left;

                // Load read this first text from resource file
                LoadString(ghInstance, IDS_READTHISFIRST, tszRTF, MAX_RTF_LENGTH);
     
				// load keyboard shortcut description for Read this First
				LoadString(ghInstance, IDS_RTFSHORTCUT, gtszRTFShortcut, MAX_RTFSHORTCUTDESC_LENGTH);

                // Load the bitmaps
                ghBmpClear = (HBITMAP)LoadImage(ghInstance, MAKEINTRESOURCE(IDB_CLEAR), IMAGE_BITMAP, 0, 0, LR_LOADMAP3DCOLORS | LR_CREATEDIBSECTION);
                ghBmpCheck = (HBITMAP)LoadImage(ghInstance, MAKEINTRESOURCE(IDB_CHECK), IMAGE_BITMAP, 0, 0, LR_LOADMAP3DCOLORS | LR_CREATEDIBSECTION);
                ghBmpGrayOut = (HBITMAP)LoadImage(ghInstance, MAKEINTRESOURCE(IDB_GRAYOUT), IMAGE_BITMAP, 0, 0, LR_LOADMAP3DCOLORS | LR_CREATEDIBSECTION); 


                // Create BOLD and Italic fonts
                ZeroMemory(&lf, sizeof(lf));

				//fixcode: check return value of GetCurrentObject()
                GetObject(GetCurrentObject(hDC, OBJ_FONT), sizeof(lf), &lf);

				//fixcode: check return value of GetParent()
				parentFont = (HFONT)SendMessage(GetParent(hDlg), WM_GETFONT, 0, 0);
				SendMessage(hDlg, WM_SETFONT, (WPARAM)parentFont, FALSE);
				SelectObject(hDC, parentFont);

				//fixcode: check return value of GetCurrentObject()
                GetObject(GetCurrentObject(hDC, OBJ_FONT), sizeof(lf), &lf);

                lf.lfUnderline = TRUE;
                lf.lfWeight = FW_NORMAL;
				//fixcode: check return value of CreateFontIndirect()
                ghFontUnderline = CreateFontIndirect(&lf); 

                lf.lfUnderline = FALSE;
                lf.lfWeight = FW_NORMAL;
				//fixcode: check return value of CreateFontIndirect()
                ghFontNormal = CreateFontIndirect(&lf); 

                lf.lfUnderline = FALSE; 
                lf.lfWeight = FW_HEAVY; 
				//fixcode: check return value of CreateFontIndirect()
                ghFontBold = CreateFontIndirect(&lf); 
                ReleaseDC(ghWndList, hDC);

#ifdef TESTUI
                {
                    AddItem(_T("Test 1 Very long title Test 1 Very long title Test 1 Very long title Test 1 Very long title "),
							_T("Description"), tszRTF, 0, TRUE, TRUE);
                    AddItem(_T("Test 2"), _T("Another description. No RTF"), tszRTF,0, TRUE, FALSE);
                }
#else
 #if 0
				DEBUGMSG("WM_CREATE: before add item rcLst=(%d, %d)-(%d, %d)", rcLst.left, rcLst.top, rcLst.right, rcLst.bottom);
 #endif
                {
                    for (UINT i = 0; i < gInternals->m_ItemList.Count(); i++)
                    {
						DEBUGMSG("selected[%d] = %lu", i, gInternals->m_ItemList[i].dwStatus());
						if ( !gInternals->m_ItemList[i].fHidden() )
						{
							AddItem(gInternals->m_ItemList[i].bstrTitle(),
									gInternals->m_ItemList[i].bstrDescription(),
									tszRTF,
									i,
									gInternals->m_ItemList[i].fSelected(),
									IsRTFDownloaded(gInternals->m_ItemList[i].bstrRTFPath(), GetSystemDefaultLangID()));
						}
                    }
                }
				GetClientRect(ghWndList, &rcLst);
 #if 0
				DEBUGMSG("WM_CREATE: after add item rcLst=(%d, %d)-(%d, %d)", rcLst.left, rcLst.top, rcLst.right, rcLst.bottom);
 #endif
				if (rcLst.right - rcLst.left != lenx)
				{
					lenx = rcLst.right - rcLst.left;
					hDC = GetDC(ghWndList);
					int nListIndex = 0;
                    for (UINT i = 0; i < gInternals->m_ItemList.Count(); i++)
                    {
						DEBUGMSG("selected[%d] = %lu", i, gInternals->m_ItemList[i].dwStatus());
						if ( !gInternals->m_ItemList[i].fHidden() )
						{
							if (LB_ERR == SendMessage(
											ghWndList,
											LB_SETITEMHEIGHT,
											nListIndex,
											CalcItemHeight(
												hDC,
												gInternals->m_ItemList[i].bstrTitle(),
												gInternals->m_ItemList[i].bstrDescription(),
												tszRTF,
												lenx)))
							{
								DEBUGMSG("failed to recalc height of item %u", i);
								break;
							}
							nListIndex++;
						}
                    }
	                ReleaseDC(ghWndList, hDC);
				}
#endif
                SendMessage(ghWndList, LB_SETCURSEL, 0, 0); 
                gFocus = MYLB_FOCUS_TITLE;
                gFocusItemId = 0;

                SetMYLBAcc(ghWndList);

			
                return 0;
            }

		case WM_MOVE:
            {
                RECT rcList;
                
                GetWindowRect(ghWndList, &rcList);   // need this to force LB to realize it got moved
                return(TRUE);
            }
            
        case WM_SETCURSOR:
			{
				if (ghWndList == (HWND)wParam && LOWORD(lParam) == HTCLIENT && HIWORD(lParam) == WM_MOUSEMOVE)
				{
					POINT pt;
					RECT rc;
					GetCursorPos(&pt);
					if (0 == MapWindowPoints(NULL, ghWndList, &pt, 1))
					{
						DEBUGMSG("MYLBWndProc MapWindowPoints failed");
						return FALSE;
					}
                
					DWORD dwPos;
					dwPos = MAKELONG( pt.x, pt.y);
                
					DWORD dwItem = (LONG)SendMessage(ghWndList, LB_ITEMFROMPOINT, 0, dwPos);
                
					if (LOWORD(dwItem) == -1)
						return(FALSE);
                
					item = (LBITEM*)SendMessage(ghWndList, LB_GETITEMDATA, LOWORD(dwItem), 0);
					SendMessage(ghWndList, LB_GETITEMRECT, LOWORD(dwItem), (LPARAM)&rc);
                
					if (!EqualRect(&rc, &item->rcItem))
					{
						HDC hDC = GetDC(ghWndList);
						CalcItemLocation(hDC, item, rc);
						ReleaseDC(ghWndList, hDC);
					}
                                
					if (item->bRTF && PtInRect(&item->rcRTF, pt))
					{
					//	DEBUGMSG("Change Cursor to hand in MOUSEMOVE");
						SetCursor(ghCursorHand);
						return TRUE;
					}
                
					return FALSE;
				}
				else
				if (ghWndList == (HWND)wParam && LOWORD(lParam) == HTCLIENT && HIWORD(lParam) == WM_LBUTTONDOWN)
				{
					POINT pt;
					RECT rc;
					GetCursorPos(&pt);
					if (0 == MapWindowPoints(NULL, ghWndList, &pt, 1))
					{
						DEBUGMSG("MYLBWndProc MapWindowPoints failed");
						return FALSE;
					}

					DWORD dwPos;
					dwPos = MAKELONG( pt.x, pt.y);
					DWORD dwItem = (LONG)SendMessage(ghWndList, LB_ITEMFROMPOINT, 0, dwPos);
                
					if (LOWORD(dwItem) == -1)
						return(FALSE);
                
					item = (LBITEM*)SendMessage(ghWndList, LB_GETITEMDATA, LOWORD(dwItem), 0);
					SendMessage(ghWndList, LB_GETITEMRECT, LOWORD(dwItem), (LPARAM)&rc);

					if (!EqualRect(&rc, &item->rcItem))
					{
						HDC hDC = GetDC(ghWndList);
						CalcItemLocation(hDC, item, rc);
						ReleaseDC(ghWndList, hDC);
					}
                
					// Are we clicking on the Title?
					if (PtInRect(&item->rcBitmap, pt))
					{
						if (!s_fSelectionDisabled)
						    {
						        ToggleSelection(hDlg, ghWndList, item);
						    }
					//	DEBUGMSG("WM_SETCURSOR change gFocus to TITLE");
						gFocus = MYLB_FOCUS_TITLE;
						gFocusItemId = dwItem;
						RedrawMYLB(ghWndList);

						return TRUE;
					}
                
					// or are we clicking on the RTF?
					if (item->bRTF && PtInRect(&item->rcRTF, pt))
					{
						PostMessage(GetParent(hDlg), AUMSG_SHOW_RTF, LOWORD(item->m_index), 0);
						SetCursor(ghCursorHand);
						//DEBUGMSG("WM_SETCURSOR change gFocus to RTF");
						gFocus = MYLB_FOCUS_RTF;
						gFocusItemId = dwItem;
						RedrawMYLB(ghWndList);
						return TRUE;
					}
                
					return FALSE;
				}

				return FALSE;
			}
            
        case WM_MEASUREITEM: 
            {
                LPMEASUREITEMSTRUCT lpmis = (LPMEASUREITEMSTRUCT) lParam ; 
#if 0
				DEBUGMSG("WM_MEASUREITEM: ctlId=%u, itemId=%u, itemWidth=%u, itemHeight=%u", lpmis->CtlID, lpmis->itemID, lpmis->itemWidth, lpmis->itemHeight);
#endif
                HDC hdc = GetDC(ghWndList);
                LBITEM * plbi = (LBITEM*)lpmis->itemData;
				lpmis->itemHeight = CalcItemHeight(hdc, plbi->szTitle, plbi->pszDescription, plbi->szRTF, lenx);
                ReleaseDC(ghWndList, hdc);
                return TRUE; 

            }
        case WM_PAINT:
            PAINTSTRUCT ps;
			RECT borderRect;
            BeginPaint(hDlg, &ps);
			GetClientRect(hDlg, &borderRect);
			DrawEdge(ps.hdc, &borderRect, EDGE_ETCHED, BF_RECT);
            EndPaint(hDlg, &ps);
            break;
            
		case WM_NEXTDLGCTL:
			PostMessage(GetParent(hDlg), WM_NEXTDLGCTL, 0, 0L);
			return 0;
		case WM_KEYUP:
			//DEBUGMSG("MYLB got KEYUP key %d", wParam);
			switch(wParam)
            {
				case VK_TAB:
				case VK_DOWN:
				case VK_UP:
						SetFocus(ghWndList);
						return 0;
				default: 
					break;
			}
			break;
				
		case WM_VKEYTOITEM:
			{
				//DEBUGMSG("WM_VKEYTOITEM got char %d", LOWORD(wParam));
				if (LOWORD(wParam) != VK_SPACE)
				{
					return -1;
				}
				if (MYLB_FOCUS_TITLE == gFocus)
				{
					int i = (LONG)SendMessage(ghWndList, LB_GETCURSEL, 0, 0);
					if (LB_ERR == i)
					{
						return -2;
					}
					item = (LBITEM*)SendMessage(ghWndList, LB_GETITEMDATA, i, 0);

        				if (!s_fSelectionDisabled)
        				    {
	        				ToggleSelection(hDlg, ghWndList, item);
        				    }
					return -2;
				}
				if (MYLB_FOCUS_RTF == gFocus)
				{
					LaunchRTF(ghWndList);
				}
				return -2;
			}
			
	     case WM_DRAWITEM: 
	     		{
		            LPDRAWITEMSTRUCT lpdis = (LPDRAWITEMSTRUCT) lParam; 
#if 0
					DEBUGMSG("WM_DRAWITEM: ctlId=%u, itemId=%u, rcItem=(%d, %d)-(%d, %d)", lpdis->CtlID, lpdis->itemID, lpdis->rcItem.left, lpdis->rcItem.top, lpdis->rcItem.right, lpdis->rcItem.bottom);
#endif

		            // If there are no list box items, skip this message. 
		 
		            if (lpdis->itemID == -1) 
		            { 
		                break; 
		            } 
		 
		            // Draw the bitmap and text for the list box item. Draw a 
		            // rectangle around the bitmap if it is selected. 
		 
		            switch (lpdis->itemAction) 
		            { 
		                case ODA_SELECT: 
		                case ODA_DRAWENTIRE: 
							//DEBUGMSG("MYLB WM_DRAWITEM ODA_DRAWENTIRE for %d", lpdis->itemID);
							DrawItem(lpdis, s_fSelectionDisabled);
							DrawMYLBFocus(ghWndList, lpdis, gFocus, gFocusItemId);
		                    break; 
		                case ODA_FOCUS: 
							if (lpdis->itemID != gFocusItemId)
							{
								gFocusItemId = lpdis->itemID;
								gFocus = MYLB_FOCUS_TITLE;
							}
							//DEBUGMSG("MYLB ODA_FOCUS change focus to %d", gFocusItemId);
							DrawItem(lpdis, s_fSelectionDisabled);
							DrawMYLBFocus(ghWndList, lpdis, gFocus, gFocusItemId);
		                    break; 
		            } 
		            return TRUE; 
	     		}

        case WM_DESTROY:
            // need to cleanup the fonts
            if (ghFontBold)         
                DeleteObject(ghFontBold);
            if (ghFontUnderline)
                DeleteObject(ghFontUnderline);
            if (ghFontNormal)
                DeleteObject(ghFontNormal);
		if (ghBmpCheck)
                DeleteObject(ghBmpCheck);
		if (ghBmpGrayOut)
		   DeleteObject(ghBmpGrayOut);
            if (ghBmpClear)
                DeleteObject(ghBmpClear);

                
            ghFontNormal = NULL;
            ghFontBold = NULL;
            ghFontUnderline = NULL;
		ghBmpCheck = NULL;
		ghBmpGrayOut = NULL;
		ghBmpClear = NULL;

		EnterCriticalSection(&gcsClient);
		RemoveProp( ghWndList, MYLBALIVEPROP );
            clb = (LONG)SendMessage(ghWndList, LB_GETCOUNT, 0, 0);
            for(int i = 0; i < clb; i++)
            {
                item = (LBITEM*)SendMessage(ghWndList, LB_GETITEMDATA, i, 0);
                delete(item);
            }
		LeaveCriticalSection(&gcsClient);
			
            return 0;
    }
    return DefWindowProc(hDlg, message, wParam, lParam);
}

void DrawTitle(HDC hDC, LBITEM * plbi, RECT rc)
{
    // we want the bitmap to be on the same background as the title, let's do this here since we 
    // already have all the measures.
    RECT rcTop = rc;
    rcTop.left = 0;

    // draw menu background rectangle for the title and bitmap
    HBRUSH hBrush;
    if (! (hBrush = CreateSolidBrush(GetSysColor(COLOR_MENU))))
	{
		DEBUGMSG("WUAUCLT CreateSolidBrush failure in DrawTitle, GetLastError=%lu", GetLastError());
		return;
	}
    FillRect(hDC, (LPRECT)&rcTop, hBrush);
    if (NULL != hBrush)
	{
		DeleteObject(hBrush);
	}

    // draw 3d look
    DrawEdge(hDC, &rcTop, EDGE_ETCHED, BF_RECT);

    // change text and back ground color of list box's selection
    DWORD dwOldTextColor = SetTextColor(hDC, GetSysColor(COLOR_MENUTEXT)); // black text color
    DWORD dwOldBkColor = SetBkColor(hDC, GetSysColor(COLOR_MENU)); // text cell light gray background
    HFONT hFontPrev = (HFONT)SelectObject(hDC, ghFontBold);

	rc.left += TITLE_MARGIN;
    rc.top += SECTION_SPACING;
    rc.right -= TITLE_MARGIN;
    rc.bottom -= SECTION_SPACING;
	DrawText(hDC, (LPTSTR)plbi->szTitle, -1,
            &rc, DT_WORDBREAK | DT_NOPREFIX);
    
    // restore text and back ground color of list box's selection
    SetTextColor(hDC, dwOldTextColor);
    SetBkColor(hDC, dwOldBkColor);
    SelectObject(hDC, hFontPrev);

    return;
}

void DrawRTF(HDC hDC, LBITEM * plbi, const RECT & rc /*,BOOL fHit*/)
{
  if (!plbi->bRTF)
		return;

	//draw RTF background 
   RECT rcBackGround;
   CalcRTFFocusRect(rc, rcBackGround);
   HBRUSH hBrush;
    if (!(hBrush = CreateSolidBrush(GetSysColor(COLOR_WINDOW))))
	{
		DEBUGMSG("WUAUCLT CreateSolidBrush failure in DrawRTF, GetLastError=%lu", GetLastError());
		return;
	}
    if (!FillRect(hDC, (LPRECT)&rcBackGround, hBrush))
	{
		DEBUGMSG("Fail to erase RTF background");
	}
    if (NULL != hBrush)
	{
		DeleteObject(hBrush);
	}

	
    HFONT hFontPrev = (HFONT) SelectObject(hDC, ghFontUnderline);

    DWORD dwOldTextColor = SetTextColor(hDC, GetSysColor(ATTENTION_COLOR));

	SetBkMode(hDC, TRANSPARENT);
	// add the read this first 
    TextOut(hDC, (int)(rc.left), (int)(rc.top),
          (LPTSTR)plbi->szRTF, lstrlen(plbi->szRTF));
    
    // restore text and back ground color of list box's selection
    SetTextColor(hDC, dwOldTextColor);
	SelectObject(hDC, hFontPrev);

    return;
}

void DrawDescription(HDC hDC, LBITEM * plbi, RECT & rc)
{
#if 0
	DEBUGMSG("draw \"%S\" (%d, %d) - (%d, %d)", (LPTSTR)plbi->pszDescription, rc.left, rc.top, rc.right, rc.bottom);
#endif
	HFONT hFontPrev = (HFONT)SelectObject(hDC, ghFontNormal);
    DrawText(hDC, (LPTSTR)plbi->pszDescription, -1,
            &rc, DT_BOTTOM | DT_EXPANDTABS | DT_WORDBREAK | DT_EDITCONTROL | DT_NOPREFIX);
            
    SelectObject(hDC, hFontPrev);

    return;
}

void DrawBitmap(HDC hDC, LBITEM * plbi, const RECT & rc, BOOL fSel, BOOL fSelectionDisabled)
{
    HDC hdcMem;

    plbi->bSelect = fSel;

    if (hdcMem = CreateCompatibleDC(hDC))
	{
	    HGDIOBJ hBmp;
	    if (fSelectionDisabled)
	        {
	            hBmp = ghBmpGrayOut;
//	            DEBUGMSG("Set bitmap to grayout");
	        }
	    else
	        {
//	            DEBUGMSG("Set bitmap to selectable");
	            hBmp = (plbi->bSelect ? ghBmpCheck : ghBmpClear);
	        }
		HBITMAP hbmpOld = (HBITMAP)SelectObject(hdcMem, hBmp); 

		BitBlt(hDC, 
			rc.left + 3, rc.top + SECTION_SPACING, 
			rc.right - rc.left, 
			rc.bottom - rc.top, 
			hdcMem, 0, 0, SRCCOPY);

		SelectObject(hdcMem, hbmpOld); 
		DeleteDC(hdcMem);
	}
}

BOOL GetBmpSize(HANDLE hBmp, SIZE *psz)
{
	if (NULL == hBmp || NULL == psz)
	{
		DEBUGMSG("Error: GetBmpSize() invalid parameter");
		return FALSE;
	}
	BITMAP bm;
	ZeroMemory(&bm, sizeof(bm));
	if (0 == GetObject(hBmp, sizeof(bm), &bm))
	{
		return FALSE;
	}
	psz->cx = bm.bmWidth;
	psz->cy = bm.bmHeight;
	return TRUE;
}

//fixcode: should return error code
void AddItem(LPTSTR tszTitle, LPTSTR tszDesc, LPTSTR tszRTF, int index, BOOL fSelected, BOOL fRTF)
{
    LBITEM *newItem = new(LBITEM);
	if (! newItem)
	{
		DEBUGMSG("WUAUCLT new() failed in AddItem, GetLastError=%lu", GetLastError());
		goto Failed;
	}
	DWORD dwDescLen = max(lstrlen(tszDesc), MAX_DESC_LENGTH);
	newItem->pszDescription = (LPTSTR) malloc((dwDescLen+1) * sizeof(TCHAR));
	if (NULL == newItem->pszDescription)
	{
		DEBUGMSG("AddItem() fail to alloc memory for description");
		goto Failed;
	}
    (void)StringCchCopyEx(newItem->szTitle, ARRAYSIZE(newItem->szTitle), tszTitle, NULL, NULL, MISTSAFE_STRING_FLAGS);
	(void)StringCchCopyEx(newItem->pszDescription, dwDescLen+1, tszDesc, NULL, NULL, MISTSAFE_STRING_FLAGS);
	(void)StringCchCopyEx(newItem->szRTF, ARRAYSIZE(newItem->szRTF), tszRTF, NULL, NULL, MISTSAFE_STRING_FLAGS);
    newItem->m_index = index;
	newItem->bSelect = fSelected;
    newItem->bRTF = fRTF;

    LRESULT i = SendMessage(ghWndList, LB_GETCOUNT, 0, 0);
	if (LB_ERR == i ||
		LB_ERR == (i = SendMessage(ghWndList, LB_INSERTSTRING, (WPARAM) i, (LPARAM) newItem->szTitle)) ||
		LB_ERRSPACE == i ||
		LB_ERR == SendMessage(ghWndList, LB_SETITEMDATA, (WPARAM) i, (LPARAM) newItem))
	{
		DEBUGMSG("WUAUCLT AddItem() fail to add item to listbox");
		goto Failed;
	}

	return;

Failed:
	SafeDelete(newItem);
	QuitNRemind(TIMEOUT_INX_TOMORROW);
}

////////////////////////////////////////////////////
// utility function
// calculate the height of a paragraph in current 
// device context
////////////////////////////////////////////////////
UINT GetParagraphHeight(HDC hDC, LPTSTR tszPara, int nLineWidth, UINT uExtraFormat = 0)
{
	UINT y = 0;

	if (0 == nLineWidth)
	{
		return 0;
	}

	RECT rc;
	ZeroMemory(&rc, sizeof(rc));
	rc.right = nLineWidth;

	if (0 == DrawText(hDC, tszPara, -1, &rc, DT_WORDBREAK | DT_NOPREFIX | DT_NOCLIP | DT_CALCRECT | uExtraFormat))
	{
		DEBUGMSG("failed to calc paragraph height w/ error %ld", GetLastError());
		return 0;
	}
#if 0
	else
	{
		DEBUGMSG("para \"%S\" line-width=%lu (%d, %d) - (%d, %d)", tszPara, nLineWidth, rc.left, rc.top, rc.right, rc.bottom);
	}
#endif

	return rc.bottom - rc.top + 1;
}

int CalcDescHeight(HDC hDC, LPTSTR ptszDescription, int cx)
{
    int y = 0;
	HFONT hPrevFont = NULL;
    
	hPrevFont = (HFONT) SelectObject(hDC, ghFontNormal);
	y = GetParagraphHeight(hDC, ptszDescription, cx, DT_BOTTOM | DT_EXPANDTABS | DT_EDITCONTROL);
	SelectObject(hDC, hPrevFont);

    return y;
}    


int CalcRTFHeight(HDC hDC, LPTSTR ptszRTF)
{
    SIZE sz ;

	ZeroMemory(&sz, sizeof(sz));
	HFONT hPrevFont = (HFONT) SelectObject(hDC, ghFontUnderline);
	//fixcode: check return value of GetTextExtentPoint32()
	GetTextExtentPoint32(hDC, ptszRTF, lstrlen(ptszRTF), &sz);
	SelectObject(hDC, hPrevFont);

	return sz.cy;
}

int CalcRTFWidth(HDC hDC, LPTSTR ptszRTF)
{
	SIZE sz;
	HFONT hPrevFont = (HFONT) SelectObject(hDC, ghFontUnderline);
	//fixcode: check return value of GetTextExtentPoint32()
	GetTextExtentPoint32(hDC, ptszRTF, lstrlen(ptszRTF), &sz);
	SelectObject(hDC, hPrevFont);

	return sz.cx;
}

int CalcTitleHeight(HDC hDC, LPTSTR ptszTitle, int cx)
{    
	INT y = 0;
	INT iBmpHeight = 0;

	HFONT hPrevFont = (HFONT) SelectObject(hDC, ghFontBold);
	y = GetParagraphHeight(hDC, ptszTitle, cx);
	SelectObject(hDC, hPrevFont);

	// get checkbox size
	if (NULL != ghBmpCheck && NULL != ghBmpClear && NULL != ghBmpGrayOut)
	{
		SIZE sz1 ;
		SIZE sz2 ;
		SIZE sz3 ;
		sz1.cy = sz2.cy = sz3.cy = DEF_CHECK_HEIGHT;
		GetBmpSize(ghBmpCheck, &sz1);
		GetBmpSize(ghBmpClear, &sz2);
		GetBmpSize(ghBmpGrayOut, &sz3);
		iBmpHeight = max(sz1.cy, sz2.cy);
		iBmpHeight = max(iBmpHeight, sz3.cy);
	}
	return max(y, iBmpHeight); //make title height a little bigger for clearer focus rect
}


int CalcItemHeight(HDC hdc, LPTSTR ptszTitle, LPTSTR ptszDescription, LPTSTR ptszRTF, int cx)
{
	return CalcTitleHeight(hdc, ptszTitle, cx -  XBITMAP - 2* TITLE_MARGIN) 
			+ CalcDescHeight(hdc, ptszDescription, cx - XBITMAP )
			+ CalcRTFHeight(hdc, ptszRTF) + 4 * SECTION_SPACING;
}


////////////////////////////////////////////////////////////
/// Layout of listbox item:
///		spacing
///		bitmap margin TITLE margin
///		spacing
///			   DESCRIPTION 
///		spacing
///						RTF rtf_margin
///		spacing
///////////////////////////////////////////////////////////
void CalcItemLocation(HDC hDC, LBITEM * plbi, const RECT & rc)
{
    // Calculate the positon of each element
    plbi->rcItem = rc;
    
    plbi->rcTitle = rc;
	plbi->rcTitle.left += XBITMAP ;
    plbi->rcTitle.bottom = plbi->rcTitle.top + CalcTitleHeight(hDC, plbi->szTitle, plbi->rcTitle.right -  plbi->rcTitle.left - 2* TITLE_MARGIN) 
							+ 2 * SECTION_SPACING; 

    plbi->rcText = rc;
    plbi->rcText.left = plbi->rcTitle.left;
	plbi->rcText.right = plbi->rcTitle.right;
    plbi->rcText.top = plbi->rcTitle.bottom;
	int nRtfHeight = CalcRTFHeight(hDC, plbi->szRTF);
    plbi->rcText.bottom -= nRtfHeight + SECTION_SPACING;  //

	
	plbi->rcRTF = plbi->rcText;
    plbi->rcRTF.top = plbi->rcText.bottom;
    plbi->rcRTF.bottom = plbi->rcRTF.top + nRtfHeight;
	plbi->rcRTF.right = plbi->rcText.right - RTF_MARGIN;
	plbi->rcRTF.left = plbi->rcRTF.right - CalcRTFWidth(hDC, plbi->szRTF);

    plbi->rcBitmap = rc;
    plbi->rcBitmap.bottom = plbi->rcTitle.bottom;
       
    
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\wuauclt\customlb.h ===
//=======================================================================
//
//  Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:    customlb.h
//
//  Creator: weiw
//
//  Purpose: custom list box header file
//
//=======================================================================

#pragma once

#define XBITMAP 20

// ATTENTION_COLOR: color for link when mouse is over 
// NOATTENTION_COLOR: otherwise
//#define NOATTENTION_COLOR	COLOR_GRAYTEXT
#define ATTENTION_COLOR		COLOR_HOTLIGHT

// Foward declarations of functions included in this code module:

#define MAX_RTF_LENGTH			80 //in charaters
#define MAX_TITLE_LENGTH		300
#define MAX_DESC_LENGTH			3000 // 750 in the spec, leave room to adapt 
#define DEF_CHECK_HEIGHT		13
#define SECTION_SPACING			6 //spacing between title, description and RTF
#define TITLE_MARGIN			6 //margin at the left and right for title
#define RTF_MARGIN				20 //margin at the right of rtf
#define MAX_RTFSHORTCUTDESC_LENGTH	140


class LBITEM
{
public:
    TCHAR szTitle[MAX_TITLE_LENGTH]; 
    LPTSTR pszDescription;
	TCHAR szRTF[MAX_RTF_LENGTH];
	UINT	  m_index; // index of item in gvList
    BOOL  bSelect;
    BOOL  bRTF;
    RECT rcTitle;
    RECT rcText;
    RECT rcBitmap; // weiwfixcode: missleading name. the same as rcTitle
    RECT rcRTF;
    RECT rcItem;
    //int  xTitle; // extra len for the title hit point
public:
	LBITEM()
	{
		ZeroMemory(szTitle, sizeof(szTitle));
		ZeroMemory(szRTF, sizeof(szRTF));
		ZeroMemory(&rcTitle, sizeof(rcTitle));
		ZeroMemory(&rcText, sizeof(rcText));
		ZeroMemory(&rcBitmap, sizeof(rcBitmap));
		ZeroMemory(&rcRTF, sizeof(rcRTF));
		ZeroMemory(&rcItem, sizeof(rcItem));
		bSelect = FALSE;
		bRTF = FALSE;
		pszDescription = NULL;
	}

	~LBITEM()
	{
		if (NULL != pszDescription)
		{
			free(pszDescription);
		}
	}
};

typedef enum tagMYLBFOCUS {
	MYLB_FOCUS_TITLE =1,
	MYLB_FOCUS_RTF
} MYLBFOCUS;


const TCHAR MYLBALIVEPROP[] = TEXT("MYLBAlive");

extern HWND ghWndList;
extern INT  gFocusItemId;
extern TCHAR gtszRTFShortcut[MAX_RTFSHORTCUTDESC_LENGTH];
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\wuauclt\pch.h ===
//#pragma warning( push, 3 )
#include <windows.h>
#include <tchar.h>
#include "criticalfixreg.h"
#include "aumsgs.h"
#include "wuauengi.h"
#include "wuaustate.h"
#include "wuaulib.h"
#include "aucltcatalog.h"
#include "auinternals.h"
#include "wuauclt.h"
#include "resource.h"
#include <Mshtmhst.h>
#include <Wtsapi32.h>
#include "auregkeys.h"
#include "auwait.h"
#include <richedit.h>
#include <commdlg.h>
#include "safefunc.h"
#include "CltDebug.h"
#include <shellapi.h>
#include <comdef.h>
#include <initguid.h> 
#include <oleacc.h>
#include <advpub.h>
#include "customlb.h"
#include "customlbacc.h"
#include "schemamisc.h"
#include "aucomres.h"
#include "audirectory.h"
#include "PromptUserDlg.h"
#include "aucompat.h"
#include "memutil.h"
#include "WUTestKeys.h"
#include "wusafefn.h"
#include "MISTSafe.h"
//#pragma warning( pop )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\wuauclt\installcallback.cpp ===
//=======================================================================
//
//  Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:    AUCltCatalog.cpp
//
//  Creator: PeterWi
//
//  Purpose: Client AU Catalog Functions
//
//=======================================================================

#include "pch.h"
#include "iuprogress.h"

#include "AUEventMsgs.h"

//=======================================================================
//
// CInstallCallback::QueryInterface
//
//=======================================================================
STDMETHODIMP CInstallCallback::QueryInterface(REFIID riid, void **ppvObject)
{
   if ( (riid == __uuidof(IUnknown)) || (riid == IID_IProgressListener) )
	{
		*ppvObject = this;
		AddRef();
	}
	else
	{
		*ppvObject = NULL;
		return E_NOINTERFACE;
	}
	return S_OK;
}

//=======================================================================
//
// CInstallCallback::AddRef
//
//=======================================================================
STDMETHODIMP_(ULONG) CInstallCallback::AddRef(void)
{
    return InterlockedIncrement(&m_refs);;
}

//=======================================================================
//
// CInstallCallback::Release
//
//=======================================================================
STDMETHODIMP_(ULONG) CInstallCallback::Release(void)
{
   return InterlockedDecrement(&m_refs);
}
	
//=======================================================================
//
// CInstallCallback::OnItemStart
//
//=======================================================================
STDMETHODIMP CInstallCallback::OnItemStart( 
            IN BSTR /*bstrUuidOperation*/,
            IN BSTR bstrXmlItem,
            OUT LONG *plCommandRequest)
{
    DEBUGMSG("InstallProgressListener::OnItemStart(%S)", bstrXmlItem);
	*plCommandRequest = 0;			
    return S_OK;
}

//=======================================================================
//
// CInstallCallback::OnProgress
//
//=======================================================================
STDMETHODIMP CInstallCallback::OnProgress( 
            IN  BSTR /*bstrUuidOperation*/,
            IN  VARIANT_BOOL fItemCompleted,
            IN  BSTR bstrProgress,
            OUT LONG *plCommandRequest)
{
	DEBUGMSG("InstallProgressListener::OnProgress(%S), %s", 
             bstrProgress, (VARIANT_TRUE == fItemCompleted) ? "completed" : "ongoing");
	
    *plCommandRequest = 0;			

    if ( fItemCompleted )
    {
    	SendMessage(ghCurrentDialog, AUMSG_INSTALL_PROGRESS, 0, 0);
    }

	return S_OK;
}

//=======================================================================
//
// CInstallCallback::OnOperationComplete
//
//=======================================================================

HRESULT LogEventToServer(
			IUpdates *pUpdates,
			WORD wType,
			WORD wCategory,
			DWORD dwEventID,
			DWORD dwItemCount,
			BSTR *pbstrItems);

STDMETHODIMP CInstallCallback::OnOperationComplete( 
            /* [in] */ BSTR bstrUuidOperation,
            /* [in] */ BSTR bstrXmlItems)
{
	DEBUGMSG("InstallProgressListener::OnOperationComplete() for %S", bstrUuidOperation);
    HRESULT hr;

#ifdef DBG
    LOGXMLFILE(INSTALLRESULTS_FILE, bstrXmlItems);
#endif

    // determine if reboot needed
    IXMLDOMDocument *pxmlInstallResult = NULL;
    IXMLDOMNodeList *pItemStatuses = NULL;
	BSTR *pbstrItemsSucceeded = NULL;
	BSTR *pbstrItemsFailed = NULL;
	BSTR *pbstrItemsNeedReboot = NULL;
	IXMLDOMNode *pItemStatus = NULL;
	IXMLDOMNode *pChild = NULL;
	BSTR bstrTitle = NULL;
	BSTR bstrStatus = NULL;
	DWORD dwNumOfItemsSucceeded = 0;
	DWORD dwNumOfItemsFailed = 0;
	DWORD dwNumOfItemsNeedReboot = 0;
	IUpdates *pUpdates = NULL;
	BOOL fCoInit = FALSE;
	BSTR bstrItemStatusXPath 		= SysAllocString(L"items/itemStatus");
	BSTR bstrTitleXPath 			= SysAllocString(L"description/descriptionText/title");
	BSTR bstrItemStatusNode 		= SysAllocString(L"installStatus");
	BSTR bstrValueAttribute 		= SysAllocString(L"value");
	BSTR bstrNeedsRebootAttribute 	= SysAllocString(L"needsReboot");

	if (NULL == bstrItemStatusXPath || NULL == bstrTitleXPath || NULL == bstrItemStatusNode || NULL == bstrValueAttribute || NULL == bstrNeedsRebootAttribute)
	{
		hr = E_OUTOFMEMORY;
		goto CleanUp;	
	}

	if (FAILED(hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED)))
	{
		DEBUGMSG("InstallProgressListener::OnOperationComplete() CoInitialize failed (%#lx)", hr);
		goto CleanUp;
	}
	fCoInit = TRUE;

    if ( FAILED(hr = LoadXMLDoc(bstrXmlItems, &pxmlInstallResult)) )
    {
		DEBUGMSG("InstallProgressListener::OnOperationComplete() call to LoadXMLDoc() failed (%#lx)", hr);
		pxmlInstallResult = NULL;
        goto CleanUp;
    }

	if (FAILED(hr = pxmlInstallResult->selectNodes(bstrItemStatusXPath, &pItemStatuses)) )
	{
		DEBUGMSG("InstallProgressListener::OnOperationComplete() fail to select node");
		pItemStatuses = NULL;
		goto CleanUp;
	}

    long lLen;
	if (FAILED(hr = pItemStatuses->get_length(&lLen)))
	{
		DEBUGMSG("InstallProgressListener::OnOperationComplete() fail to get count of item statuses");
		goto CleanUp;
	}

	if (0 >= lLen)
	{
		DEBUGMSG("InstallProgressListener::OnOperationComplete() no item statuses found");
		hr = E_INVALIDARG;
		goto CleanUp;
	}

	if (NULL == (pbstrItemsSucceeded = (BSTR *) malloc(sizeof(BSTR) * lLen)) ||
		NULL == (pbstrItemsFailed = (BSTR *) malloc(sizeof(BSTR) * lLen)) ||
		NULL == (pbstrItemsNeedReboot = (BSTR *) malloc(sizeof(BSTR) * lLen)))
	{
		DEBUGMSG("InstallProgressListener::OnOperationComplete() failed to alloc memory for BSTR *'s");
		hr = E_OUTOFMEMORY;
		goto CleanUp;
	}

	for (long index = 0; index < lLen; index++)
    {
		if (S_OK != (hr = pItemStatuses->get_item(index, &pItemStatus)))
		{
			DEBUGMSG("InstallProgressListener::OnOperationComplete() call to get_item() failed (%#lx)", hr);
			pItemStatus = NULL;
			if (S_FALSE == hr)
			{
				hr = E_FAIL;
			}
			goto CleanUp;
		}

		if (S_OK != (hr = pItemStatus->selectSingleNode(bstrTitleXPath, &pChild)))
		{
			DEBUGMSG("InstallProgressListener::OnOperationComplete() call to selectSingleNode() failed (%#lx)", hr);
			pChild = NULL;
			if (S_FALSE == hr)
			{
				hr = E_INVALIDARG;
			}
			goto CleanUp;
		}

		if (S_OK != (hr = GetText(pChild, &bstrTitle)))
		{
			DEBUGMSG("InstallProgressListener::OnOperationComplete() call to GetText() failed (%#lx)", hr);
			bstrTitle = NULL;
			if (S_FALSE == hr)
			{
				hr = E_INVALIDARG;
			}
			goto CleanUp;
		}

		pChild->Release();
		pChild = NULL;

		if (S_OK != (hr = pItemStatus->selectSingleNode(bstrItemStatusNode, &pChild)))
		{
			DEBUGMSG("InstallProgressListener::OnOperationComplete() call to selectSingleNode() failed (%#lx)", hr);
			pChild = NULL;
			if (S_FALSE == hr)
			{
				hr = E_INVALIDARG;
			}
			goto CleanUp;
		}

		if (S_OK != (hr = GetAttribute(pChild, bstrValueAttribute, &bstrStatus)))
		{
			DEBUGMSG("InstallProgressListener::OnOperationComplete() call to GetAttribute(..., \"value\", ...) failed (%#lx)", hr);
			bstrStatus = NULL;
			if (S_FALSE == hr)
			{
				hr = E_INVALIDARG;
			}
			goto CleanUp;
		}

		if (CSTR_EQUAL == WUCompareStringI(bstrStatus, L"COMPLETE"))
		{
			BOOL fReboot;

			if (S_OK != (hr = GetAttribute(pChild, bstrNeedsRebootAttribute, &fReboot)))
			{
				DEBUGMSG("InstallProgressListener::OnOperationComplete() call to GetAttribute(..., \"needsReboot\", ...) failed (%#lx)", hr);
				if (S_FALSE == hr)
				{
					hr = E_INVALIDARG;
				}
				goto CleanUp;
			}
			if (fReboot)
			{
				pbstrItemsNeedReboot[dwNumOfItemsNeedReboot++] = bstrTitle;
				gpClientCatalog->m_fReboot = TRUE;
			}
			pbstrItemsSucceeded[dwNumOfItemsSucceeded++] = bstrTitle;
			// Now pbstrItemsSucceeded is responsible to free the BSTR.
		}
		else if (CSTR_EQUAL == WUCompareStringI(bstrStatus, L"FAILED"))
		{
			pbstrItemsFailed[dwNumOfItemsFailed++] = bstrTitle;
			// Now pbstrItemsFailed is responsible to free the BSTR.
		}
		SysFreeString(bstrStatus);
		bstrStatus = NULL;

		pChild->Release();
		pChild = NULL;

		bstrTitle = NULL;
    }

	if (FAILED(hr = CoCreateInstance(__uuidof(Updates),
						 NULL,
						 CLSCTX_LOCAL_SERVER,
						 IID_IUpdates,
						 (LPVOID*)&pUpdates)))
	{
		DEBUGMSG("LogEventToServer failed to get Updates object (%#lx)", hr);
		goto CleanUp;
	}

	if (0 < dwNumOfItemsSucceeded)
	{
		DEBUGMSG("InstallProgressListener::OnOperationComplete() %lu items was successfully installed", dwNumOfItemsSucceeded);
		LogEventToServer(
			pUpdates,
			EVENTLOG_INFORMATION_TYPE,
			IDS_MSG_Installation,
			IDS_MSG_InstallationSuccessful,
			dwNumOfItemsSucceeded,
			pbstrItemsSucceeded);
	}
	if (0 < dwNumOfItemsFailed)
	{
		DEBUGMSG("InstallProgressListener::OnOperationComplete() %lu items failed to install", dwNumOfItemsFailed);
		LogEventToServer(
			pUpdates,
			EVENTLOG_ERROR_TYPE,
			IDS_MSG_Installation,
			IDS_MSG_InstallationFailure,
			dwNumOfItemsFailed,
			pbstrItemsFailed);
	}
	if (0 < dwNumOfItemsNeedReboot)
	{
		DEBUGMSG("InstallProgressListener::OnOperationComplete() %lu items was installed and require reboot", dwNumOfItemsNeedReboot);

		AUOPTION auopt;
		DWORD dwNoAutoReboot = 0;
		(void)GetRegDWordValue(REG_AUNOAUTOREBOOTWITHLOGGEDONUSERS, &dwNoAutoReboot, AUREGKEY_HKLM_DOMAIN_POLICY);
              DEBUGMSG("WUAUCLT NoAutoReboot key is %d", dwNoAutoReboot);
		if (SUCCEEDED(hr = pUpdates->get_Option(&auopt)) &&
			(AUOPTION_SCHEDULED == auopt.dwOption) && 
			(0 == dwNoAutoReboot))
		{
			LogEventToServer(
				pUpdates,
				EVENTLOG_INFORMATION_TYPE,
				IDS_MSG_Installation,
				IDS_MSG_RestartNeeded_Scheduled,
				dwNumOfItemsNeedReboot,
				pbstrItemsNeedReboot);
		}
		else
		{
			LogEventToServer(
				pUpdates,
				EVENTLOG_INFORMATION_TYPE,
				IDS_MSG_Installation,
				IDS_MSG_RestartNeeded_Unscheduled,
				dwNumOfItemsNeedReboot,
				pbstrItemsNeedReboot);
		}
	}

CleanUp:
	SafeFreeBSTR(bstrItemStatusXPath);
	SafeFreeBSTR(bstrTitleXPath);
	SafeFreeBSTR(bstrItemStatusNode);
	SafeFreeBSTR(bstrValueAttribute);
	SafeFreeBSTR(bstrNeedsRebootAttribute);
	SafeRelease(pUpdates);
	SysFreeString(bstrStatus);
	SysFreeString(bstrTitle);
	SafeRelease(pChild);
	SafeRelease(pItemStatus);
	SafeFree(pbstrItemsNeedReboot);
	if (NULL != pbstrItemsFailed)
	{
		while(dwNumOfItemsFailed > 0)
		{
			SysFreeString(pbstrItemsFailed[--dwNumOfItemsFailed]);
		}
		free(pbstrItemsFailed);
	}
	if (NULL != pbstrItemsSucceeded)
	{
		while(dwNumOfItemsSucceeded > 0)
		{
			SysFreeString(pbstrItemsSucceeded[--dwNumOfItemsSucceeded]);
		}
		free(pbstrItemsSucceeded);
	}
    SafeRelease(pItemStatuses);
    SafeRelease(pxmlInstallResult);
	if (fCoInit)
	{
		CoUninitialize();
	}

	DEBUGMSG("InstallProgressListener::OnOperationComplete() ends");
	return hr;
}

HRESULT LogEventToServer(
			IUpdates *pUpdates,
			WORD wType,
			WORD wCategory,
			DWORD dwEventID,
			DWORD dwItemCount,
			BSTR *pbstrItems)
{
	DEBUGMSG("LogEventToServer");

    HRESULT hr;
	SAFEARRAY *psa;

	SAFEARRAYBOUND bound[1] = { dwItemCount, 0};

	if (NULL == (psa = SafeArrayCreate(VT_BSTR, 1, bound)))
	{
		DEBUGMSG("LogEventToServer failed to create safearray");
		hr = E_OUTOFMEMORY;
		goto CleanUp;
	}

	BSTR *pbstrElements;

	if (S_OK != (hr = SafeArrayAccessData(psa, (void **)&pbstrElements)))
    {
		DEBUGMSG("LogEventToServer failed to access savearray date (%#lx)", hr);
		goto CleanUp;
    }

	for ( DWORD i = 0; i < dwItemCount; i++ )
	{
		if (NULL == (pbstrElements[i] = SysAllocString(pbstrItems[i])))
		{
			DEBUGMSG("LogEventToServer failed to allocate BSTR memory");
			hr = E_OUTOFMEMORY;
			break;
		}
	}

	if (S_OK != (hr = SafeArrayUnaccessData(psa)))
	{
		DEBUGMSG("LogEventToServer failed to unaccess safearray data (%#lx)", hr);
	}

	if (FAILED(hr))
	{
		goto CleanUp;
	}

	VARIANT varItems;
    varItems.vt = VT_ARRAY | VT_BSTR;
	varItems.parray = psa;

    hr = pUpdates->LogEvent(wType, wCategory, dwEventID, varItems);
	if (FAILED(hr))
	{
		DEBUGMSG("LogEventToServer failed to call pUpdates->LogEvent (%#lx)", hr);
	}

CleanUp:
	if (NULL != psa)
	{
		(void) SafeArrayDestroy(psa);
	}
	return hr; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\wuauclt\dialogs.cpp ===
#include "pch.h"
#include "htmlhelp.h"
#include "link.h"
#pragma hdrstop
	
HINSTANCE mshtml = NULL;
HACCEL ghCurrentAccel = NULL;
HHOOK ghHook = NULL;
AUOPTION gWelcomeOption;

extern UINT		gNextDialogMsg;

#ifdef TESTUI
DWORD gdwScheduledInstallDay = -1;
DWORD gdwScheduledInstallTime = -1;
#endif

CSysLink g_AutoUpdatelink;
CSysLink g_ScheduledInstalllink;
CSysLink g_PrivacyStatementLink;
CSysLink g_EULA_Link(FALSE); //non html help

SHOWHTMLDIALOGFN  *pfnShowHTMLDialog;

const UINT CTRLIDSTRIDMAP[][2] = {
	{IDC_WELCOME_NOTE, IDS_NOTE},
	{IDC_WELCOME_CONTINUE, IDS_WELCOME_CONTINUE},
	{IDC_SUMMARY_NOTE, IDS_NOTE},
	{IDC_WELCOME_EULA, IDS_EULA},
	{IDC_LEARNMORE,IDS_LEARNMORE},
	{IDC_STAT_LEARNAUTOUPDATE,IDS_LEARNMOREAUTO}
};

// A Wrapper function to first check the item handle returned from GetDlgItem for the item iIDDlgItem and then to enable or disable it depending on the flag passed
inline void GetItemAndEnableIt(HWND hWnd, int iIDDlgItem, BOOL bEnable)
{
	HWND hItem = GetDlgItem(hWnd, iIDDlgItem);
	if (NULL != hItem)
	{
		EnableWindow(hItem, bEnable);
	}	
}

void SetButtonText(HWND button, UINT resId)
{
    TCHAR text[50];
    LoadString(ghInstance, resId, text, 50);
    SendMessage(button, WM_SETTEXT, 0, (LPARAM)text);
}

void ShowRTF(HWND hWnd, WPARAM wParam)
{
    UINT uIndex = (UINT)wParam;
	IMoniker *pIMon = NULL;
       WCHAR wszArg[200];
	RECT rc;

   	if (NULL == pfnShowHTMLDialog || uIndex >= gInternals->m_ItemList.Count()) 
   		{
   		return;
   		}
	HRESULT hr;
	if (FAILED(hr = CreateURLMoniker(NULL, L"res://wuauclt.exe/RTFWRAPPER.HTM", &pIMon)))
	{
		DEBUGMSG("WUAUCLT: ShowRTF failed to CreateURLMoniker() with error %#lx", hr);
		goto done;
	}

	//fixcode: check return value of GetWindowRect()
	GetWindowRect(hWnd, &rc);
	if (FAILED(StringCchPrintfExW(wszArg, ARRAYSIZE(wszArg), NULL, NULL, MISTSAFE_STRING_FLAGS,
					L"dialogHeight:%dpx;dialogWidth:%dpx;dialogTop:%d;dialogLeft:%d;help:no;resizable:yes",
					rc.bottom-rc.top, rc.right-rc.left, rc.top + 25, rc.left + 25)))
	{
		DEBUGMSG("WUAUCLT: ShowRTF insufficient buffer for HTML dialog argument");
		goto done;
	}

	TCHAR tszRTFLocalFile[MAX_PATH];
	if (FAILED(GetRTFLocalFileName(gInternals->m_ItemList[uIndex].bstrRTFPath(), tszRTFLocalFile, ARRAYSIZE(tszRTFLocalFile), GetSystemDefaultLangID())))
	{
		goto done;
	}
	DEBUGMSG("Launching RTF page from %S", T2W(tszRTFLocalFile));
	VARIANT varg;
	varg.vt = VT_BSTR;
	if (NULL == (varg.bstrVal = SysAllocString(T2W(tszRTFLocalFile))))
	{
		DEBUGMSG("WUAUCLT: ShowRTF failed to allocate memory for HTML dialog argument");
		goto done;
	}
       pfnShowHTMLDialog(hWnd, pIMon, &varg, wszArg, NULL);
       VariantClear(&varg);
done:
	SafeRelease(pIMon);
	return;
}


UINT ControlId2StringId(UINT uCtrlId)
{
	for (int i = 0 ; i< ARRAYSIZE(CTRLIDSTRIDMAP); i++)
	{
		if (CTRLIDSTRIDMAP[i][0] == uCtrlId)
		{
			return CTRLIDSTRIDMAP[i][1];
		}
	}
	return -1;
}

//////////////////////////////////////////////////////////////////
// Adjust (Stretch or squeeze) the bitmap IDB_SIDEBAR to
//  make it fit into the control IDC_SIDEBAR
// to fit in the dialog
// hDlg		: handle to the dialog
///////////////////////////////////////////////////////////////////
void AdjustSideBar(HWND hDlg)
{
	HBITMAP hBmp;
	BITMAP  bmp;
	HDC		hDC;
	HDC		hMemDC;
	RECT	rc ;
	RECT	rcWhiteRect, rcBottomLine;

	GetWindowRect(GetDlgItem(hDlg, IDC_BOTTOMLINE), &rcBottomLine);
	GetWindowRect(GetDlgItem(hDlg, IDC_WHITERECT), &rcWhiteRect);
	MapWindowPoints(NULL, hDlg, (LPPOINT)&rcBottomLine, 2);
	MapWindowPoints(NULL, hDlg, (LPPOINT)&rcWhiteRect, 2);
	rc.right = rcWhiteRect.left;
	rc.bottom = rcBottomLine.top -1;
	hDC = GetDC(hDlg);
	hMemDC = CreateCompatibleDC(hDC);
	hBmp = (HBITMAP) LoadImage(ghInstance, MAKEINTRESOURCE(IDB_SIDEBAR), IMAGE_BITMAP,
		0, 0, LR_DEFAULTSIZE | LR_CREATEDIBSECTION);
	GetObject(hBmp, sizeof(bmp), &bmp);	
	SelectObject(hMemDC, hBmp);
	SetStretchBltMode( hDC, COLORONCOLOR );
	StretchBlt(hDC, 0, 0, rc.right, rc.bottom, hMemDC, 0, 0, bmp.bmWidth, bmp.bmHeight, MERGECOPY);
	DeleteObject(hBmp);
	DeleteDC(hMemDC);
	ReleaseDC(hDlg, hDC);
}


void SetAUDialogIcon(HWND hDlg, HANDLE hIcon, HANDLE hSmIcon)
{
	SendMessage(hDlg, WM_SETICON, ICON_BIG, (LPARAM)hIcon);
	SendMessage(hDlg, WM_SETICON, ICON_SMALL, (LPARAM)hSmIcon);
}

int DisplayWizardCancelWarning(HWND hWnd)
{
	TCHAR title[80], text[300];
	
	LoadString(ghInstance, IDS_CLOSEWARNINGTITLE, title, ARRAYSIZE(title));
	LoadString(ghInstance, IDS_CLOSEWARNINGTEXT, text, ARRAYSIZE(text));

	return MessageBox(hWnd, text, title, MB_YESNO | MB_ICONQUESTION);
}

void LaunchHelp(
	HWND hwnd,
	LPCTSTR szURL
)
{
	HtmlHelp(NULL,szURL,HH_DISPLAY_TOPIC,NULL);
}

LONG SetColors(HDC hdc, HWND control)
{
	int id = GetDlgCtrlID(control);

	switch (id)
	{
		case IDC_WHITERECT:
			{
				SetBkMode(hdc, OPAQUE);
				SetBkColor(hdc, GetSysColor(COLOR_WINDOW));
				return PtrToLong(GetSysColorBrush(COLOR_WINDOW));
			}
			
		case IDC_CHK_KEEPUPTODATE:
			{
				//DEBUGMSG("IDC_LEARNMORE Setcolors");
/*				
				SetBkMode(hdc, TRANSPARENT);
				return PtrToLong(GetSysColorBrush(COLOR_BTNFACE));
*/	
				return FALSE;
			}

		case IDC_OPTION1:
		case IDC_OPTION2:
		case IDC_OPTION3:
			{ 
				return FALSE;
			}

		case IDC_GRPBOX:
			return FALSE;

		default:
			{ 
				SetTextColor(hdc, GetSysColor(COLOR_WINDOWTEXT));
				SetBkMode(hdc, TRANSPARENT);
				return PtrToLong(GetStockObject(HOLLOW_BRUSH));
			}
	}
}


LRESULT CALLBACK AUTranslatorProc(int code, WPARAM wParam, LPARAM lParam)
{
	if(code != MSGF_DIALOGBOX
	   || ghCurrentAccel == NULL 
	   || !TranslateAccelerator(ghCurrentDialog, ghCurrentAccel, (MSG*)lParam))
	{
		return CallNextHookEx(ghHook, code, wParam, lParam);
	}
	else
	{
		return 1;
	}
}


INT_PTR CALLBACK WizardFrameProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{  
    switch(message)
    {
        case WM_INITDIALOG:
            ghCurrentMainDlg = hWnd;
            CreateDialog(ghInstance, MAKEINTRESOURCE(IDD_WELCOME), 
                hWnd, WelcomeDlgProc);
            SetActiveWindow(ghCurrentMainDlg);
            SetForegroundWindow(ghCurrentMainDlg);
            SetAUDialogIcon(hWnd, ghAppIcon, ghAppSmIcon); //set icon for all AU dialogs
			gWelcomeOption.dwOption = -1;
            gWelcomeOption.dwSchedInstallDay = -1;
            gWelcomeOption.dwSchedInstallTime = -1;
            return TRUE;

		case WM_COMMAND:
			if(ghCurrentDialog != NULL)
			{
				PostMessage(ghCurrentDialog, WM_COMMAND, wParam, lParam);
			}
			return 0;

        case WM_DESTROY:
            ghCurrentMainDlg = NULL;
			return 0;

        case WM_HELP:
        	LaunchHelp(hWnd, gtszAUOverviewUrl);
        	return TRUE;
	    default:
            return FALSE;
    }
}


void LaunchEula()
{
	TCHAR szCmd[MAX_PATH+1];																
	STARTUPINFO StartupInfo;								
	PROCESS_INFORMATION ProcessInfo;
	TCHAR szEULA_TXT[] = _T(" eula.txt"); // command line string
	UINT ulen =GetSystemDirectory(szCmd, ARRAYSIZE(szCmd)); 
    if ( 0 == ulen ||
    	ulen >= ARRAYSIZE(szCmd) ||
		FAILED(StringCchCatEx(szCmd, ARRAYSIZE(szCmd), _T("\\notepad.exe"), NULL, NULL, MISTSAFE_STRING_FLAGS)))
    {
		return;
    }

	ZeroMemory(&ProcessInfo, sizeof(ProcessInfo));
	ZeroMemory(&StartupInfo, sizeof(StartupInfo));
	
	StartupInfo.cb = sizeof(StartupInfo);
	StartupInfo.wShowWindow = SW_SHOW;
	
	CreateProcess(
			szCmd,					// name of executable module
			szEULA_TXT,			    // command line string
			NULL,					// SD
			NULL,					// SD
			FALSE,					// handle inheritance option
			DETACHED_PROCESS,		// creation flags
			NULL,					// new environment block
			NULL,					// current directory name
			&StartupInfo,			// startup information
			&ProcessInfo			// process information
			);	
	SafeCloseHandleNULL(ProcessInfo.hThread);
	SafeCloseHandleNULL(ProcessInfo.hProcess);
}


void LaunchLinkAction(HWND hwnd, UINT uCtrlId)
{

//#ifdef _CWU
#if 0
	OSVERSIONINFO OsVer;
	OsVer.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	GetVersionEx( &OsVer );
#endif	
//#endif

	switch (uCtrlId)
	{
		case IDC_WELCOME_EULA:
			LaunchEula();
			break;
//		case IDC_WELCOME_PRIVACY:
/*#ifndef _CWU
			ShellExecute(NULL, NULL, gtszPrivacyUrl, NULL, NULL, SW_SHOWNORMAL);
#else
*/
//			{
//				LaunchHelp(hwnd, (LPTSTR)gtszW2KPrivacyUrl);

/*				if( (OsVer.dwMajorVersion == 5) && (OsVer.dwMinorVersion == 0))
				{
					// NT5
					LaunchHelp(hwnd, (LPTSTR)gtszW2KPrivacyUrl);
				}
				else if( (OsVer.dwMajorVersion == 5) && (OsVer.dwMinorVersion == 1))
				{
					// Whistler
					ShellExecute(NULL, NULL, gtszPrivacyUrl, NULL, NULL, SW_SHOWNORMAL);
				}
*/
//			}
//#endif
			break;
		case IDC_LEARNMORE:
/*#ifndef _CWU
			ShellExecute(NULL, NULL, gtszLearnMoreUrl, NULL, NULL, SW_SHOWNORMAL);
#else
*/
			{
				LaunchHelp(hwnd, gtszAUSchedInstallUrl);

/*				if( (OsVer.dwMajorVersion == 5) && (OsVer.dwMinorVersion == 0))
				{
					// NT5
					LaunchHelp(hwnd, (LPTSTR)gtszAUW2kSchedInstallUrl);
				}
				else if( (OsVer.dwMajorVersion == 5) && (OsVer.dwMinorVersion == 1))
				{
					// Whistler
        				LaunchHelp(hwnd, (LPTSTR)gtszAUXPSchedInstallUrl);
				}
*/				
			}
			break;
//#endif

//#ifdef _CWU
		case IDC_STAT_LEARNAUTOUPDATE:
			{
				LaunchHelp(hwnd, gtszAUOverviewUrl);
/*
				if( (OsVer.dwMajorVersion == 5) && (OsVer.dwMinorVersion == 0))
				{
					// NT5
					LaunchHelp(hwnd, (LPTSTR)gtszAUOverviewUrl);
				}
				else if( (OsVer.dwMajorVersion == 5) && (OsVer.dwMinorVersion == 1))
				{
					// Whistler
					ShellExecute(NULL, NULL, gtszLearnMoreUrl, NULL, NULL, SW_SHOWNORMAL);
				}
*/
			}
			break;
//#endif
	}
	return;
}


void SetDefaultCF(HWND hWndMYRE, CHARFORMAT2 *pcfDefault)
{
	pcfDefault->cbSize  = sizeof(*pcfDefault);
	SendMessage(hWndMYRE, EM_GETCHARFORMAT, 0, (LPARAM)pcfDefault);
	pcfDefault->dwMask |= CFM_BOLD | CFM_HIDDEN | CFM_ITALIC | CFM_LINK 
							| CFM_UNDERLINE | CFM_SIZE | CFM_WEIGHT | CFM_COLOR;
	pcfDefault->dwEffects &= ~(CFE_BOLD | CFE_ITALIC |CFE_LINK | CFE_UNDERLINE | CFE_HIDDEN);

	SendMessage(hWndMYRE, EM_SETCHARFORMAT, 0, (LPARAM)pcfDefault);
}

/*
void DbgDumpEffects(CHARFORMAT2 cf)
{
	UINT   effects[] = {
			CFE_BOLD,
			CFE_ITALIC,
			CFE_LINK, 
			CFE_UNDERLINE
	};
	LPTSTR msgs[]= {
		_T("BOLD"),
		_T("ITALIC"),
		_T("LINK"),
		_T("UNDERLINE")
	};
	const UINT NUM_EFFECTS = 4;
	for (int i = 0; i < NUM_EFFECTS; i++)
	{
		if (cf.dwEffects & effects[i] )
		{
			DEBUGMSG("cf is %S", msgs[i]);
		}
		else
		{
			DEBUGMSG("cf is NOT %S", msgs[i]);
		}
	}
}
*/

/////////////////////////////////////////////////////////////
// Format specified text in a rich edit control
// e.g. make it bold, italic, link etc
// hWndMYRE		: Rich edit window handle
// uStrId		: string id for the text to format
// puEffects	: points to the flag specifying designed effects. e.g.
//				: CFE_BOLD
//				: CFE_ITALIC
//				: CFE_UNDERLINE
//				: if NULL, effects not changed
void FormatMYREText(HWND hWndMYRE, UINT uStrId, UINT* puEffects)
{
	FINDTEXTEXW ft;
	CHARRANGE cr;
	CHARFORMAT2 cf;
	INT nFTflags ;
	ZeroMemory(&ft, sizeof(ft));
	ZeroMemory(&cr, sizeof(cr));
	ZeroMemory(&cf, sizeof(cf));
	
//	DEBUGMSG("FormatMYREText() effects = 0x%x color = 0x%x", puEffects, ptxtColor);

	cf.cbSize = sizeof(cf);
	ft.chrg.cpMin = 0;
	ft.chrg.cpMax = -1;
	ft.lpstrText = ResStrFromId(uStrId);

	nFTflags = FR_MATCHCASE|FR_WHOLEWORD|FR_DOWN;
	cr.cpMin = (LONG)SendMessage(hWndMYRE, EM_FINDTEXTEXW, nFTflags, (LPARAM) &ft);
	if (-1 == cr.cpMin )
	{
		DEBUGMSG("Format Text %S not found %lu", ft.lpstrText, GetLastError()); 
		return;
	}
	cr = ft.chrgText;
	SendMessage(hWndMYRE, EM_EXSETSEL, 0, (LPARAM)&cr);
	SendMessage(hWndMYRE, EM_GETCHARFORMAT, 1, (LPARAM)&cf);
	if (0 != puEffects)
	{
		cf.dwEffects |= *puEffects;
	}
	SendMessage(hWndMYRE, EM_SETCHARFORMAT, SCF_SELECTION, (LPARAM)&cf);
}

/////////////////////////////////////////////////////////////////
// Subclass rich edit control and format its text
// hDlg : the dialog the rich edit control is in
// uId  : id of the rich edit control
// hFont: font to set richedit control 
/////////////////////////////////////////////////////////////////
void MYREInit(HWND hDlg, UINT uId, HFONT hFont)
{
	CHARFORMAT2 cfDefault;
	HWND	hWndMYRE = GetDlgItem(hDlg, uId);
	UINT uStrId  = 0;
       UINT uEffects = 0;

      	SetDefaultCF(hWndMYRE, &cfDefault);
      //DEBUGMSG("MYREInit() retrieving and removing text");
       UINT uTextLen =  (LONG)SendMessage(hWndMYRE, WM_GETTEXTLENGTH, 0, 0);
       TCHAR *pText = (TCHAR*)malloc((uTextLen + 1)* sizeof(TCHAR));
       if (NULL != pText)
       {
               /* need to blank out text and reset text for new font to go into effect*/
               SendMessage(hWndMYRE, WM_GETTEXT, (WPARAM)(uTextLen+1), (LPARAM)pText);
               //DEBUGMSG("MYREInit() get text %S", pText);
               SendMessage(hWndMYRE, WM_SETTEXT, 0, (LPARAM)L"");
               //DEBUGMSG("MYREInit() removed text");
               LRESULT lres = SendMessage(hWndMYRE, EM_GETLANGOPTIONS, 0, 0);
               lres &= ~IMF_AUTOFONT;        // turn off autofont
               SendMessage(hWndMYRE, EM_SETLANGOPTIONS, 0, (LPARAM)lres);
               //DEBUGMSG("MYREInit() turn off auto font");
               SendMessage(hWndMYRE, WM_SETFONT, (WPARAM)hFont, TRUE);
               //DEBUGMSG("MYREInit() setting font to %#lx", hFont);
               SendMessage(hWndMYRE, WM_SETTEXT, 0, (LPARAM)pText);
               //DEBUGMSG("MYREInit() reset text");
               free(pText);
        }
	switch (uId)
	{
		case IDC_WELCOME_NOTE:
		case IDC_SUMMARY_NOTE:
		case IDC_WELCOME_CONTINUE:
			{
				uStrId = ControlId2StringId(uId);
				uEffects = CFE_BOLD;
				break;
			}
//#ifdef _CWU
		case IDC_WELCOME_EULA:
	    case IDC_WELCOME_PRIVACY:
		case IDC_LEARNMORE:
		case IDC_STAT_LEARNAUTOUPDATE:
			uStrId = ControlId2StringId(uId);
			uEffects = CFE_LINK;

			SendMessage(hWndMYRE, EM_SETEVENTMASK, 0, ENM_LINK);
			break;

	
//#endif
				
	}
	if (0 != uStrId)
	{
		FormatMYREText(hWndMYRE, uStrId, &uEffects);
	}

	return;
}					

void CancelWizard(HWND hWnd)
{
	static BOOL s_fCancelWarningShown = FALSE;

	if (!s_fCancelWarningShown)
	{
		s_fCancelWarningShown = TRUE;
		if (IDYES == DisplayWizardCancelWarning(hWnd))				
		{
#if 0
#ifndef TESTUI
			SetTomorrowReminder(AUSTATE_NOT_CONFIGURED);
#endif
#endif
			CreateDialog(ghInstance, MAKEINTRESOURCE(IDD_SETUPCANCEL), 
				GetParent(hWnd), SetupCancelDlgProc);     
			DestroyWindow(hWnd);
		}
		s_fCancelWarningShown = FALSE;
	}
}

INT_PTR CALLBACK WelcomeDlgProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{  
	static BOOL s_fHasFocusLastTime ; 

    switch(message)
    {   
        case WM_INITDIALOG:
            {
				HWND hHeader = GetDlgItem(hWnd, IDC_HEADER);

                ghCurrentDialog = hWnd;				
   				s_fHasFocusLastTime = FALSE; 
			
                SendMessage(hHeader, WM_SETFONT, (WPARAM)ghHeaderFont, 0);

                SetWindowPos(hWnd, HWND_TOP, 0, 0, 0, 0, SWP_SHOWWINDOW | SWP_NOSIZE);

				GetItemAndEnableIt(hWnd, IDC_BACK, FALSE);

				SetFocus(GetDlgItem(hWnd, IDC_NEXT));	

                HFONT hFont = (HFONT) SendMessage(hWnd , WM_GETFONT, 0, 0);
				MYREInit(hWnd, IDC_WELCOME_NOTE, hFont);
				MYREInit(hWnd, IDC_WELCOME_CONTINUE, hFont);
//#ifdef _CWU
//				MYREInit(hWnd, IDC_WELCOME_EULA, hFont);
//				MYREInit(hWnd, IDC_WELCOME_PRIVACY, hFont);
//#endif
				g_PrivacyStatementLink.SetSysLinkInstanceHandle(ghInstance);
				g_PrivacyStatementLink.SubClassWindow(GetDlgItem(hWnd,IDC_WELCOME_PRIVACY));
				g_PrivacyStatementLink.SetHyperLink(gtszAUPrivacyUrl);
				g_PrivacyStatementLink.Invalidate();

				g_EULA_Link.SetSysLinkInstanceHandle(ghInstance);
				g_EULA_Link.SubClassWindow(GetDlgItem(hWnd,IDC_WELCOME_EULA));
				g_EULA_Link.SetHyperLink(_T("eula.txt"));
				g_EULA_Link.Invalidate();

				return TRUE;
            }

        case WM_COMMAND:
            switch(LOWORD(wParam))
            {
				case IDOK:
                case IDC_NEXT:
                    CreateDialog(ghInstance, MAKEINTRESOURCE(IDD_NOTOPTIONS), 
                        GetParent(hWnd), NotificationOptionsDlgProc);
                    DestroyWindow(hWnd);
                    return 0;

				case IDCANCEL:														
				case IDC_CANCEL:					
						CancelWizard(hWnd);
						return 0;

				default:
						return 0;
            }

        case WM_CTLCOLORSTATIC:
			return SetColors((HDC)wParam, (HWND)lParam);

		case WM_SETCURSOR:
			{	
				if (LOWORD(lParam) == HTCLIENT && HIWORD(lParam) == WM_MOUSEMOVE)
				{
					SetCursor(ghCursorNormal);
				}
				return TRUE;
			}

		case WM_DRAWITEM:
			{
				AdjustSideBar(hWnd);
				return TRUE;	
			}
		case WM_NOTIFY:
			{
				UINT  uId = (UINT) LOWORD(wParam);
/*#ifndef _CWU
				LPNMHDR pNMHdr = (LPNMHDR) lParam;
				switch (uId)
				{
					case IDC_WELCOME_PRIVACY:
					case IDC_WELCOME_EULA:
							switch (pNMHdr->code)
							{
							 case NM_RETURN:
							 case NM_CLICK:
								{
									LaunchLinkAction(uId);							
								}
								break;
							 default:
								 break;
							}			

					default:
							  break;
				}
#else
*/
				switch (uId)
				{
//					case IDC_WELCOME_PRIVACY:
					case IDC_WELCOME_EULA:
						if (((NMHDR FAR *) lParam)->code == EN_LINK) 
						{
							if (((ENLINK FAR *) lParam)->msg == WM_LBUTTONDOWN)  
							{
								LaunchLinkAction(hWnd, uId);
							}
						}
						break;
					default:
							  break;
				}
//#endif
				return 0;
			}
		case WM_DESTROY:
		    g_EULA_Link.Uninit();
		    g_PrivacyStatementLink.Uninit();
		    return 0;
		default:
			{
				return FALSE;
			}
				
    }
}

WNDPROC editProc;

#ifdef TESTUI
const TCHAR REG_AUOPTIONS[] = _T("AUOptions"); //REG_DWORD
const TCHAR REG_AUSCHEDINSTALLDAY[] = _T("ScheduledInstallDay"); // REG_DWORD
const TCHAR REG_AUSCHEDINSTALLTIME[] = _T("ScheduledInstallTime"); // REG_DWORD

void GetServiceOption(
	LPDWORD lpdwOption,
	LPDWORD lpdwDay,
	LPDWORD lpdwTime
)
{
	DWORD dwResult = AUOPTION_INSTALLONLY_NOTIFY;
	GetRegDWordValue(REG_AUOPTIONS, &dwResult);
	if ((dwResult < AUOPTION_ADMIN_MIN) || (dwResult > AUOPTION_MAX))
	{
		DEBUGMSG("WUAUENG Invalid option in registry, returning installonly");
		dwResult = AUOPTION_INSTALLONLY_NOTIFY;
	}
	*lpdwOption = dwResult;

	dwResult = 0;
	GetRegDWordValue(REG_AUSCHEDINSTALLDAY, &dwResult);
	if( (dwResult <= 0) || (dwResult > 7))
	{
		dwResult = 0;
	}
	*lpdwDay = dwResult;
	gdwScheduledInstallDay = dwResult;

	dwResult = 0;
	GetRegDWordValue(REG_AUSCHEDINSTALLTIME, &dwResult);
	if( (dwResult <= 0) || (dwResult > 23))
	{
		dwResult = 3;
	}
	*lpdwTime = dwResult;
	gdwScheduledInstallTime = dwResult;
}


void SetServiceOption(
	DWORD dwOption,
	DWORD dwDay,
	DWORD dwTime
)
{
	SetRegDWordValue( REG_AUOPTIONS, dwOption);
	SetRegDWordValue( REG_AUSCHEDINSTALLDAY, dwDay);
	SetRegDWordValue( REG_AUSCHEDINSTALLTIME, dwTime);
}
#endif 

BOOL EnableCombo(HWND hwnd, BOOL bState)
{
	GetItemAndEnableIt(hwnd,IDC_CMB_DAYS,bState);
	GetItemAndEnableIt(hwnd,IDC_CMB_HOURS,bState);
//	GetItemAndEnableIt(hwnd,IDC_LEARNMORE,bState); //Enable/disable the learn about schedule install 
														//link along with the combo boxes.	
	return TRUE;
}

BOOL EnableOptions(HWND hwnd, BOOL bState)
{
	GetItemAndEnableIt(hwnd,IDC_OPTION1,bState);
	GetItemAndEnableIt(hwnd,IDC_OPTION2,bState);
	GetItemAndEnableIt(hwnd,IDC_OPTION3,bState);

	if (BST_CHECKED == SendMessage(GetDlgItem(hwnd,IDC_OPTION3),BM_GETCHECK,0,0))
	{
		EnableCombo(hwnd, bState);
	}
	return TRUE;
}


void OnKeepUptoDate(HWND hwnd)
{
	LRESULT lResult = SendMessage(GetDlgItem(hwnd,IDC_CHK_KEEPUPTODATE),BM_GETCHECK,0,0);
	
	if (lResult == BST_CHECKED)
	{
		EnableOptions(hwnd, TRUE);
	}
	else if (lResult == BST_UNCHECKED)
	{
		EnableOptions(hwnd, FALSE);
		EnableCombo(hwnd, FALSE);
	}
}


void GetDayAndTimeFromUI( 
	HWND hWnd,
	LPDWORD lpdwDay,
	LPDWORD lpdwTime
)
{
	HWND hComboDays = GetDlgItem(hWnd,IDC_CMB_DAYS);
	HWND hComboHrs = GetDlgItem(hWnd,IDC_CMB_HOURS);
	LRESULT nDayIndex = SendMessage(hComboDays,CB_GETCURSEL,0,(LPARAM)0);
	LRESULT nTimeIndex = SendMessage(hComboHrs,CB_GETCURSEL,0,(LPARAM)0);

	*lpdwDay = (DWORD)SendMessage(hComboDays,CB_GETITEMDATA, nDayIndex, (LPARAM)0);
	*lpdwTime = (DWORD)SendMessage(hComboHrs,CB_GETITEMDATA, nTimeIndex, (LPARAM)0);
}

INT_PTR CALLBACK NotificationOptionsDlgProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{  

    switch(message)
    {   
        case WM_INITDIALOG:
            {
                ghCurrentDialog = hWnd;
  				EnableCombo(hWnd, FALSE); //Initially disabled
                HWND hHeader = GetDlgItem(hWnd, IDC_HEADER);
				SendMessage(hHeader, WM_SETFONT, (WPARAM)ghHeaderFont, 0);
				
				if(-1 == gWelcomeOption.dwOption)
				{
#ifndef TESTUI
					gInternals->m_getServiceOption(&gWelcomeOption);
#else
					GetServiceOption(&(gWelcomeOption.dwOption), &(gWelcomeOption.dwSchedInstallDay), &(gWelcomeOption.dwSchedInstallTime));
#endif
				}

				g_AutoUpdatelink.SetSysLinkInstanceHandle(ghInstance);
				g_AutoUpdatelink.SubClassWindow(GetDlgItem(hWnd,IDC_STAT_LEARNAUTOUPDATE));
				g_AutoUpdatelink.SetHyperLink(gtszAUOverviewUrl);
				g_AutoUpdatelink.Invalidate();

				g_ScheduledInstalllink.SetSysLinkInstanceHandle(ghInstance);
				g_ScheduledInstalllink.SubClassWindow(GetDlgItem(hWnd,IDC_LEARNMORE));
				g_ScheduledInstalllink.SetHyperLink(gtszAUSchedInstallUrl);
				g_ScheduledInstalllink.Invalidate();

				switch(gWelcomeOption.dwOption)
				{
					case AUOPTION_AUTOUPDATE_DISABLE:
						CheckDlgButton( hWnd, IDC_CHK_KEEPUPTODATE, BST_UNCHECKED);
						CheckRadioButton(hWnd, IDC_OPTION1, IDC_OPTION3, IDC_OPTION2);
						EnableOptions( hWnd, FALSE );
						break;

					case AUOPTION_PREDOWNLOAD_NOTIFY:
						CheckDlgButton( hWnd, IDC_CHK_KEEPUPTODATE, BST_CHECKED);
						CheckRadioButton(hWnd, IDC_OPTION1, IDC_OPTION3, IDC_OPTION1);
						EnableOptions( hWnd, TRUE );
						break;

					case AUOPTION_INSTALLONLY_NOTIFY:
						CheckDlgButton( hWnd, IDC_CHK_KEEPUPTODATE, BST_CHECKED);
						CheckRadioButton(hWnd, IDC_OPTION1, IDC_OPTION3, IDC_OPTION2);
						EnableOptions( hWnd, TRUE );
						break;

					case AUOPTION_SCHEDULED:
						CheckDlgButton( hWnd, IDC_CHK_KEEPUPTODATE, BST_CHECKED);
						CheckRadioButton(hWnd, IDC_OPTION1, IDC_OPTION3, IDC_OPTION3);
						EnableOptions( hWnd, TRUE );
						break;
				}

				SetFocus(GetDlgItem(hWnd, IDC_NEXT));
                SetWindowPos(hWnd, HWND_TOP, 0, 0, 0, 0, SWP_SHOWWINDOW | SWP_NOSIZE);

				HFONT hFont = (HFONT) SendMessage(hWnd , WM_GETFONT, 0, 0);
				MYREInit(hWnd, IDC_STAT_LEARNAUTOUPDATE, hFont);
				MYREInit(hWnd, IDC_LEARNMORE, hFont);
				FillDaysCombo(ghInstance, hWnd, gWelcomeOption.dwSchedInstallDay, IDS_STR_EVERYDAY, IDS_STR_SATURDAY );
				FillHrsCombo( hWnd, gWelcomeOption.dwSchedInstallTime );

                if (gWelcomeOption.fDomainPolicy)
                {
                    DisableUserInput(hWnd); 
                }
                return TRUE;
            }

		case WM_COMMAND:
			switch(LOWORD(wParam))
			{
				case IDOK:
				case IDC_NEXT:
//#ifndef _CWU
#if 0
					if(IsDlgButtonChecked(hWnd, IDC_OPTION1) == BST_CHECKED)
					{
						gdwWelcomeOption = AUOPTION_INSTALLONLY_NOTIFY;
					}
					else if(IsDlgButtonChecked(hWnd, IDC_OPTION2) == BST_CHECKED)
					{
						gdwWelcomeOption = AUOPTION_PREDOWNLOAD_NOTIFY;
					}
					else if(IsDlgButtonChecked(hWnd, IDC_OPTION3) == BST_CHECKED)
					{
						gdwWelcomeOption = AUOPTION_AUTOUPDATE_DISABLE;
					}
#endif					
//#else
					if(IsDlgButtonChecked(hWnd, IDC_CHK_KEEPUPTODATE) == BST_UNCHECKED)
					{
						gWelcomeOption.dwOption = AUOPTION_AUTOUPDATE_DISABLE;
					}
					else if(IsDlgButtonChecked(hWnd, IDC_OPTION1) == BST_CHECKED)
					{
						gWelcomeOption.dwOption = AUOPTION_PREDOWNLOAD_NOTIFY;
					}
					else if(IsDlgButtonChecked(hWnd, IDC_OPTION2) == BST_CHECKED)
					{
						gWelcomeOption.dwOption = AUOPTION_INSTALLONLY_NOTIFY;
					}
					else if(IsDlgButtonChecked(hWnd, IDC_OPTION3) == BST_CHECKED)
					{
						gWelcomeOption.dwOption = AUOPTION_SCHEDULED;
						EnableCombo( hWnd, TRUE );
						GetDayAndTimeFromUI( hWnd, &(gWelcomeOption.dwSchedInstallDay), &(gWelcomeOption.dwSchedInstallTime));
					}					
//#endif
					CreateDialog(ghInstance, MAKEINTRESOURCE(IDD_SETUPCOMPLETE), 
					        GetParent(hWnd), SetupCompleteDlgProc);
					DestroyWindow(hWnd);
					return 0;

                case IDC_BACK:
                    CreateDialog(ghInstance, MAKEINTRESOURCE(IDD_WELCOME), 
                    GetParent(hWnd), WelcomeDlgProc);
                    DestroyWindow(hWnd);
                    return 0;

		case IDCANCEL:
		case IDC_CANCEL:
			CancelWizard(hWnd);	
			return 0;
//#ifndef _CWU
#if 0
				case IDC_OPTION1:
					gdwWelcomeOption = AUOPTION_INSTALLONLY_NOTIFY;
					CheckRadioButton(hWnd, IDC_OPTION1, IDC_OPTION3, IDC_OPTION1);
					return 0;
				case IDC_OPTION2:
					gdwWelcomeOption = AUOPTION_PREDOWNLOAD_NOTIFY;
					CheckRadioButton(hWnd, IDC_OPTION1, IDC_OPTION3, IDC_OPTION2);
					return 0;
				case IDC_OPTION3:
					gdwWelcomeOption = AUOPTION_AUTOUPDATE_DISABLE;
					CheckRadioButton(hWnd, IDC_OPTION1, IDC_OPTION3, IDC_OPTION3);
					return 0;
#endif					
//#else
				case IDC_OPTION1:
					gWelcomeOption.dwOption = AUOPTION_PREDOWNLOAD_NOTIFY;
					EnableCombo( hWnd, FALSE );
					CheckRadioButton(hWnd, IDC_OPTION1, IDC_OPTION3, IDC_OPTION1);
					return 0;
				case IDC_OPTION2:
					gWelcomeOption.dwOption = AUOPTION_INSTALLONLY_NOTIFY;
					EnableCombo( hWnd, FALSE );
					CheckRadioButton(hWnd, IDC_OPTION1, IDC_OPTION3, IDC_OPTION2);
					return 0;
				case IDC_OPTION3:
					gWelcomeOption.dwOption = AUOPTION_SCHEDULED;
					EnableCombo( hWnd, TRUE );
					//GetDayAndTimeFromUI( hWnd, &(gWelcomeOption.dwSchedInstallDay), &(gWelcomeOption.dwSchedInstallTime));
					CheckRadioButton(hWnd, IDC_OPTION1, IDC_OPTION3, IDC_OPTION3);
					return 0;
				case IDC_CHK_KEEPUPTODATE:
					if( BN_CLICKED == HIWORD(wParam) )
					{
						OnKeepUptoDate( hWnd );
					}
					return 0;
//#endif
				default:
					return 0;
			}
		case WM_NOTIFY:
//#ifndef _CWU
#if 0
			{
				UINT  uId = (UINT) wParam;
				LPNMHDR pNMHdr = (LPNMHDR) lParam;
				if (IDC_LEARNMORE == uId && (NM_RETURN == pNMHdr->code || NM_CLICK == pNMHdr->code))
				{
					LaunchLinkAction(hWnd, uId);							
				}
				return 0;
			}
#endif
//#else
			{
					UINT  uId = (UINT) LOWORD(wParam);
					switch (uId)
					{
						case IDC_LEARNMORE:
						case IDC_STAT_LEARNAUTOUPDATE:
							if (((NMHDR FAR *) lParam)->code == EN_LINK) 
							{
								if (((ENLINK FAR *) lParam)->msg == WM_LBUTTONDOWN)  
								{
									LaunchLinkAction(hWnd, uId);							
								}
							}
							break;
						default:
								  break;
					}
			}
			return 0;
//#endif
		case WM_SETCURSOR:
			{			
				if (LOWORD(lParam) == HTCLIENT && HIWORD(lParam) == WM_MOUSEMOVE)
				{
					SetCursor(ghCursorNormal);
				}
				return TRUE;
			}

	    case WM_CTLCOLORSTATIC:
		{
			return SetColors((HDC)wParam, (HWND)lParam);
		}	
	    case WM_DESTROY:
	        g_ScheduledInstalllink.Uninit();
	        g_AutoUpdatelink.Uninit();
	        return 0;
        default:
            return FALSE;
    }
}

INT_PTR CALLBACK SetupCompleteDlgProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{  
    switch(message)
    {   
        case WM_INITDIALOG:
            {
                ghCurrentDialog = hWnd;
                HWND hHeader = GetDlgItem(hWnd, IDC_HEADER);
                SendMessage(hHeader, WM_SETFONT, (WPARAM)ghHeaderFont, 0);

                SetWindowPos(hWnd, HWND_TOP, 0, 0, 0, 0, SWP_SHOWWINDOW | SWP_NOSIZE);
								
				GetItemAndEnableIt(hWnd, IDC_BACK, TRUE);								
				GetItemAndEnableIt(hWnd, IDC_CANCEL, TRUE);

                SetFocus(GetDlgItem(hWnd, IDC_FINISH));

                return TRUE;
            }

        case WM_COMMAND:
            switch(LOWORD(wParam))
            {
				case IDC_BACK:
              		      CreateDialog(ghInstance, MAKEINTRESOURCE(IDD_NOTOPTIONS), 
						GetParent(hWnd), NotificationOptionsDlgProc);
		                    DestroyWindow(hWnd);
					return 0;
				case IDCANCEL:
				case IDC_CANCEL:
					CancelWizard(hWnd);
					return 0;
				case IDOK:
				case IDC_FINISH:									
					EndDialog(GetParent(hWnd), S_OK);
					DestroyWindow(hWnd);
#ifdef TESTUI
					SetServiceOption(gWelcomeOption.dwOption, gWelcomeOption.dwSchedInstallDay, gWelcomeOption.dwSchedInstallTime);
					PostMessage(ghMainWindow, AUMSG_SHOW_DOWNLOAD, 0, 0);
#else
					gInternals->m_setServiceOption(gWelcomeOption);
					gInternals->m_configureAU();
					QUITAUClient();
#endif
					return 0;
	       	         default:
       	       	      return 0;
            }

			case WM_CTLCOLORSTATIC:
				return SetColors((HDC)wParam, (HWND)lParam);

			case WM_DRAWITEM:
				AdjustSideBar(hWnd);
				return TRUE;

        default:
            return FALSE;
    }
}

void SetRemindMeLaterState(HWND hWnd)
{
#ifndef TESTUI
    AUOPTION auopt;
    if (SUCCEEDED(gInternals->m_getServiceOption(&auopt)))
    {
        GetItemAndEnableIt(hWnd, IDC_REMINDLATER,AUOPTION_SCHEDULED != auopt.dwOption); 
    }
#endif    
}

INT_PTR CALLBACK DownloadDlgProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{ 
    switch(message)
    {
        case WM_INITDIALOG:
            {
                ghCurrentMainDlg = hWnd;
  	 	  ghCurrentDialog = hWnd;

		  SetAUDialogIcon(hWnd, ghAppIcon, ghAppSmIcon);
                HWND hHeader = GetDlgItem(hWnd, IDC_HEADER);
		  SendMessage(hHeader, WM_SETFONT, (WPARAM)ghHeaderFont, 0);
#ifndef TESTUI
                if ( gInternals->m_ItemList.GetNumSelected() == 0)
                {
                    SetButtonText(GetDlgItem(hWnd, IDC_OK), IDS_CLOSEBUTTONTXT);
                }
#endif
                SetRemindMeLaterState(hWnd);

                SetActiveWindow(ghCurrentMainDlg);
                SetForegroundWindow(ghCurrentMainDlg);
                
                if(mshtml == NULL) 
                {
			// fixcode: we already have a static ref to mshtml.
                    mshtml = LoadLibraryFromSystemDir(_T("MSHTML.DLL"));
                    pfnShowHTMLDialog = (SHOWHTMLDIALOGFN*)GetProcAddress(mshtml, "ShowHTMLDialog");
                }
                
                SetFocus(GetDlgItem(hWnd, IDC_UPDATELIST));
#ifdef DBG
				DebugCheckForAutoPilot(hWnd);
#endif // DBG
                return TRUE;
            }

        case WM_COMMAND:
            switch(LOWORD(wParam))
            {
                case IDC_OK:
                        {
#ifdef TESTUI
					PostMessage(ghMainWindow, AUMSG_SHOW_INSTALL, 0, 0);
#else
                                   long lSelected = gInternals->m_ItemList.GetNumSelected();
					if (FAILED(gInternals->m_startDownload()) || 0 == lSelected)
						{
						QUITAUClient();
						}
					else
					{
					    RemoveTrayIcon();
					}
#endif
			
			EndDialog(hWnd, S_OK);
                    return 0;
                    }

                case IDC_REMINDLATER:
                    if(DialogBox(ghInstance, MAKEINTRESOURCE(IDD_REMIND),
                        hWnd, ReminderDlgProc) == S_OK)
                    {
#ifndef TESTUI
				gInternals->m_setReminderState(AUSTATE_DETECT_COMPLETE);
       	              EndDialog(hWnd, S_FALSE);
#endif
                    }
                    return 0;

                case IDC_SETTINGS:
                    {
                        ShowSettingsDlg(hWnd);
                        SetRemindMeLaterState(hWnd);
                        return 0;
                    }

                case IDCANCEL:					
                	//CancelDialog(hWnd, AUSTATE_DETECT_COMPLETE, TRUE);
                	EndDialog(hWnd, S_OK);
                	gNextDialogMsg = AUMSG_SHOW_DOWNLOAD;
                	return 0;

                default:
                    return 0;
            }
            
        case WM_CTLCOLORSTATIC:
			return SetColors((HDC)wParam, (HWND)lParam);

        case AUMSG_SELECTION_CHANGED:
#ifndef TESTUI
            if ( gInternals->m_ItemList.GetNumSelected() == 0)
            {
                SetButtonText(GetDlgItem(hWnd, IDC_OK), IDS_CLOSEBUTTONTXT);
            }
            else
            {
                SetButtonText(GetDlgItem(hWnd, IDC_OK), IDS_DOWNLOADBUTTONTXT);
            }
#endif
            return TRUE;

        case AUMSG_SHOW_RTF:
            {
#ifdef TESTUI
				TCHAR tszMsg[100];
				(void)StringCchPrintfEx(tszMsg, ARRAYSIZE(tszMsg), NULL, NULL, MISTSAFE_STRING_FLAGS, _T("SHOW RTF for item %d"), (UINT)wParam);
				MessageBox(0, tszMsg, _T("Show RTF"), 0);
#else
                
				ShowRTF(hWnd, wParam);
				
#endif
                return TRUE;
            }            
            break;
            
        case WM_DESTROY:
            ghCurrentMainDlg = NULL;
            return FALSE;
            
        case WM_MOVE:
            return (LONG)SendMessage(GetDlgItem(hWnd, IDC_UPDATELIST), message, wParam, lParam);

        case WM_HELP:
    		LaunchHelp(hWnd, gtszAUOverviewUrl);
    		return TRUE;

            
        default:
            return FALSE;

    }
}

INT_PTR CALLBACK InstallDlgProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{  
    switch(message)
    {
        case WM_INITDIALOG:
			SetAUDialogIcon(hWnd, ghAppIcon, ghAppSmIcon);
            ghCurrentMainDlg = hWnd;
#ifdef TESTUI
           ghCurrentDialog = CreateDialog(ghInstance, MAKEINTRESOURCE(IDD_SUMMARY), 
                    hWnd, SummaryDlgProc);
#else
            if ( 0 == gInternals->m_ItemList.GetNumUnselected())
			{
				ghCurrentDialog = CreateDialog(ghInstance, MAKEINTRESOURCE(IDD_SUMMARY), 
                    hWnd, SummaryDlgProc);
			}
			else
			{
				ghCurrentDialog = CreateDialog(ghInstance, MAKEINTRESOURCE(IDD_DETAILS), 
                    hWnd, DetailsDlgProc);
			}
#endif
            ShowWindow(hWnd, SW_HIDE);
            SetActiveWindow(ghCurrentMainDlg);
            SetForegroundWindow(ghCurrentMainDlg);
			SetFocus(ghCurrentDialog);
            return FALSE;

        case WM_MOVE:
            return (LONG)SendMessage(ghCurrentDialog, message, wParam, lParam);
            break;

		case WM_COMMAND:
			if(ghCurrentDialog != NULL)
			{
				PostMessage(ghCurrentDialog, WM_COMMAND, wParam, lParam);
			}
			return 0;
			break;

        case WM_HELP:
        		LaunchHelp(hWnd, gtszAUOverviewUrl);
        		return TRUE;

        case WM_DESTROY:
            	ghCurrentMainDlg = NULL;
            	ghCurrentDialog = NULL;
//		QUITAUClient(); // if we are getting destroyed, install is over //QUITAUClient() where we know we need to quit
	     	break;
        default:
            break;
    }
    return FALSE;
}

INT_PTR CALLBACK SummaryDlgProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    static HANDLE hIcon = NULL;
    switch(message)
    {
        case WM_INITDIALOG:
            {
		//DEBUGMSG("SummaryDlg Get Initialized");
                ghCurrentDialog = hWnd;
                HWND hHeader = GetDlgItem(hWnd, IDC_HEADER);
                SendMessage(hHeader, WM_SETFONT, (WPARAM)ghHeaderFont, 0);
                SetWindowPos(hWnd, HWND_TOP, 0, 0, 0, 0, SWP_SHOWWINDOW | SWP_NOSIZE);
                if (NULL == hIcon)
                {
                	hIcon = LoadImage(ghInstance, MAKEINTRESOURCE(IDI_INFOICON), IMAGE_ICON, 16, 16, LR_LOADTRANSPARENT | LR_CREATEDIBSECTION);
                }
                HWND hInfoIcon = GetDlgItem(hWnd, IDC_INFOICON);
                SendMessage( hInfoIcon, STM_SETIMAGE, IMAGE_ICON, (LPARAM)hIcon);
                HFONT hFont = (HFONT) SendMessage(hWnd , WM_GETFONT, 0, 0);
                MYREInit(hWnd, IDC_SUMMARY_NOTE, hFont);
                SetRemindMeLaterState(hWnd);
                SetFocus(GetDlgItem(hWnd, IDC_OK));
		
#ifdef DBG
				DebugCheckForAutoPilot(hWnd);
#endif // DBG
                return TRUE;
            }

		case WM_COMMAND:
            switch(LOWORD(wParam))
            {
		  case IDOK:
                case IDC_OK:
					{
					RemoveTrayIcon();
#ifdef TESTUI
					CreateDialogParam(ghInstance, MAKEINTRESOURCE(IDD_PROGRESS), 
							GetParent(hWnd), ProgressDlgProc, 2);
					DestroyWindow(hWnd);
#else
					int num;
					if ( 0 != (num = gInternals->m_ItemList.GetNumSelected() ))
					{
//						CreateDialogParam(ghInstance, MAKEINTRESOURCE(IDD_PROGRESS), 
//							GetParent(hWnd), ProgressDlgProc, gInternals->m_ItemList.GetNumSelected());
						CreateDialog(ghInstance, MAKEINTRESOURCE(IDD_PROGRESS),GetParent(hWnd), ProgressDlgProc);
					}
                                   HRESULT hr;
					if (FAILED(hr = gInternals->m_startInstall()) || 0 == num)
					{
						EndDialog(GetParent(hWnd), S_OK);
					}
					else
					    {
                                          DestroyWindow(hWnd);
					    }
					if (FAILED(hr))
					    {
    						QUITAUClient();
					    }
#endif
                    return 0;
					}

               
				case IDC_DETAILS:
                    CreateDialog(ghInstance, MAKEINTRESOURCE(IDD_DETAILS), 
                    GetParent(hWnd), DetailsDlgProc);
                    DestroyWindow(hWnd);
                    return 0;
				

                case IDC_REMINDLATER:
                    if(DialogBox(ghInstance, MAKEINTRESOURCE(IDD_REMIND),
                        hWnd, ReminderDlgProc) == S_OK)
                    {
#ifdef TESTUI
#else
						gInternals->m_setReminderState(AUSTATE_DOWNLOAD_COMPLETE);
                        EndDialog(GetParent(hWnd), S_FALSE);
//                        QUITAUClient();
#endif
                    }
                    return 0;

		case IDCANCEL:					
					//CancelDialog(hWnd, AUSTATE_DOWNLOAD_COMPLETE);
					EndDialog(GetParent(hWnd), S_OK);
					gNextDialogMsg = AUMSG_SHOW_INSTALL;
					return 0;

                default:
                    return 0;
            }

        case WM_CTLCOLORSTATIC:
			return SetColors((HDC)wParam, (HWND)lParam);
            
	case WM_DRAWITEM:
				AdjustSideBar(hWnd);
				return TRUE;

        default:
            return FALSE;
    }
}

// peterwi can this and Summary dialog proc essentially be combined?
INT_PTR CALLBACK DetailsDlgProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch(message)
    {
        case WM_INITDIALOG:
            {
                ghCurrentDialog = hWnd;
            
                HWND hHeader = GetDlgItem(hWnd, IDC_HEADER);
				SendMessage(hHeader, WM_SETFONT, (WPARAM)ghHeaderFont, 0);

#ifndef TESTUI
                if ( gInternals->m_ItemList.GetNumSelected() == 0 )
                {
                    SetButtonText(GetDlgItem(hWnd, IDC_OK), IDS_CLOSEBUTTONTXT);
                }
#endif
                SetRemindMeLaterState(hWnd);
                SetWindowPos(hWnd, HWND_TOP, 0, 0, 0, 0, SWP_SHOWWINDOW | SWP_NOSIZE);
                
                if(mshtml == NULL) 
                {
                    mshtml = LoadLibraryFromSystemDir(_T("MSHTML.DLL"));
                    pfnShowHTMLDialog = (SHOWHTMLDIALOGFN*)GetProcAddress(mshtml, "ShowHTMLDialog");
                }
                
                SetFocus(GetDlgItem(hWnd, IDC_OK));
                                
                return TRUE;
            }
	
		
        case WM_COMMAND:
            switch(LOWORD(wParam))
            {
                case IDC_OK:
					{

#ifdef TESTUI
					CreateDialogParam(ghInstance, MAKEINTRESOURCE(IDD_PROGRESS), 
                                    GetParent(hWnd), ProgressDlgProc, 2);
					DestroyWindow(hWnd);
#else
					RemoveTrayIcon();
					//(void)gpClientCatalog->PruneInstallListAccordingToSelections();
					int num;
					if ( 0 != (num = gInternals->m_ItemList.GetNumSelected()) )
					{
						DEBUGMSG("WUAUCLT details dialog had %d items selected", num);
//						CreateDialogParam(ghInstance, MAKEINTRESOURCE(IDD_PROGRESS), 
//							              GetParent(hWnd), ProgressDlgProc, gInternals->m_ItemList.GetNumSelected());
						CreateDialog(ghInstance, MAKEINTRESOURCE(IDD_PROGRESS),GetParent(hWnd), ProgressDlgProc);
					}

					HRESULT hr ;
					if (FAILED(hr = gInternals->m_startInstall()) || 0 == num)
					{
						EndDialog(GetParent(hWnd), S_OK);
					}
					else
					{
						DestroyWindow(hWnd);
					}
					if (FAILED(hr))
					{
						QUITAUClient();
					}
#endif
                    return 0;
					}

                case IDC_REMINDLATER:
                    if(DialogBox(ghInstance, MAKEINTRESOURCE(IDD_REMIND),
                        hWnd, ReminderDlgProc) == S_OK)
                    {
#ifndef TESTUI
                        gInternals->m_setReminderState(AUSTATE_DOWNLOAD_COMPLETE);
                        EndDialog(GetParent(hWnd), S_FALSE);
                        //QUITAUClient();
#endif
                    }
                    return 0;

                case IDC_SETTINGS:
                    ShowSettingsDlg(hWnd);
                    SetRemindMeLaterState(hWnd);
                    return 0;

                case IDCANCEL:					
					//CancelDialog(hWnd, AUSTATE_DETECT_COMPLETE);
					EndDialog(GetParent(hWnd), S_OK);
					gNextDialogMsg = AUMSG_SHOW_INSTALL;
					return 0;

                default:
                    return 0;
            }

        case AUMSG_SELECTION_CHANGED:
        	UINT uBtnTxt;
            if ( gInternals->m_ItemList.GetNumSelected() == 0 )
            {
                uBtnTxt = IDS_CLOSEBUTTONTXT;
            }
            else
            {
                uBtnTxt = IDS_INSTALLBUTTONTXT;
            }
            SetButtonText(GetDlgItem(hWnd, IDC_OK), uBtnTxt);
            return TRUE;
            
        case AUMSG_SHOW_RTF:
            {
#ifdef TESTUI
				TCHAR tszMsg[100];
				(void)StringCchPrintfEx(tszMsg, ARRAYSIZE(tszMsg), NULL, NULL, MISTSAFE_STRING_FLAGS, _T("SHOW RTF for item %d"), (UINT)wParam);
				MessageBox(0, tszMsg, _T("Show RTF"), 0);
#else
                ShowRTF(hWnd, wParam);
#endif
                return TRUE;
            }            
            break;
            
        case WM_CTLCOLORSTATIC:
			return SetColors((HDC)wParam, (HWND)lParam);

        case WM_MOVE:
            return (LONG)SendMessage(GetDlgItem(hWnd, IDC_UPDATELIST), message, wParam, lParam);

        default:
            return FALSE;
    }
}

INT_PTR CALLBACK ProgressDlgProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
#ifdef TESTUI
	static DWORD dwProgress = 0;
#endif
    switch(message)
    {
        case WM_INITDIALOG:
        {
            ghCurrentDialog = hWnd;
            HWND hHeader = GetDlgItem(hWnd, IDC_HEADER);
			SendMessage(hHeader, WM_SETFONT, (WPARAM)ghHeaderFont, 0);

#ifdef TESTUI
			HWND hProgress = GetDlgItem(hWnd, IDC_PROGRESS);
			dwProgress = 0;
			SendMessage(hProgress, PBM_SETRANGE, 0, MAKELPARAM(0,  3));
			SendMessage(hProgress, PBM_SETSTEP, (WPARAM) 1, 0); 
			SetTimer(hWnd, 1, 1000, NULL);
#else
//		    HWND hProgress = GetDlgItem(hWnd, IDC_PROGRESS);
//			DEBUGMSG("WUAUCLT ProgressDlg total %d items to be installed ", lParam);
//            SendMessage(hProgress, PBM_SETRANGE, 0, MAKELPARAM(0,  lParam));
//			SendMessage(hProgress, PBM_SETSTEP, (WPARAM) 1, 0); 
#endif
		
            SetWindowPos(hWnd, HWND_TOP, 0, 0, 0, 0, SWP_SHOWWINDOW | SWP_NOSIZE);
            EnableMenuItem (GetSystemMenu(GetParent(hWnd), FALSE), SC_CLOSE, MF_GRAYED);
            return TRUE;
        }
		case WM_CTLCOLORSTATIC:
			return SetColors((HDC)wParam, (HWND)lParam);

        case AUMSG_INSTALL_COMPLETE:
			DEBUGMSG("WUAUCLT ProgDlg gets AUMSG_INSTALL_COMPLETE");
            CreateDialog(ghInstance, MAKEINTRESOURCE(IDD_COMPLETE), 
                GetParent(hWnd), InstallCompleteDlgProc);
            DestroyWindow(hWnd);
            return TRUE;

        case AUMSG_REBOOT_REQUIRED:
			DEBUGMSG("WUAUCLT ProgDlg gets AUMSG_REBOOT_REQUIRED");
            CreateDialog(ghInstance, MAKEINTRESOURCE(IDD_RESTART),
                GetParent(hWnd), RestartDlgProc);
		DestroyWindow(hWnd);
		return TRUE;

        case AUMSG_INSTALL_PROGRESS:
			{
				HWND hProgress = GetDlgItem(hWnd, IDC_PROGRESS);
				SendMessage(hProgress, PBM_STEPIT, 0, 0);
		            return TRUE;
			}

	case AUMSG_SET_INSTALL_ITEMSNUM:
		{
			HWND hProgress = GetDlgItem(hWnd, IDC_PROGRESS);
			DEBUGMSG("WUAUCLT ProgressDlg total %d items to be installed ", lParam);
			SendMessage(hProgress, PBM_SETRANGE, 0, MAKELPARAM(0,  lParam));
			SendMessage(hProgress, PBM_SETSTEP, (WPARAM) 1, 0); 
	}
#ifdef TESTUI
		case WM_TIMER:
		{
			dwProgress ++;
			PostMessage(hWnd, AUMSG_INSTALL_PROGRESS, 0, 0);
			if (dwProgress  >= 3) 
			{
				KillTimer(hWnd, 1);
				if(fCheckRebootFlag())
				{
					PostMessage(hWnd, AUMSG_REBOOT_REQUIRED, 0, 0);
				}
				else
				{
					PostMessage(hWnd, AUMSG_INSTALL_COMPLETE, 0, 0);
				}
			}
			return 0;
		}
#endif  
        default:
            return FALSE;
    }
}

INT_PTR CALLBACK InstallCompleteDlgProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch(message)
    {
        case WM_INITDIALOG:
        {
			ghCurrentDialog = hWnd;
            HWND hHeader = GetDlgItem(hWnd, IDC_HEADER);
            SendMessage(hHeader, WM_SETFONT, (WPARAM)ghHeaderFont, 0);
            SetWindowPos(hWnd, HWND_TOP, 0, 0, 0, 0, SWP_SHOWWINDOW | SWP_NOSIZE);
#ifdef DBG
			DebugCheckForAutoPilot(hWnd);
			DebugUninstallDemoPackages();
#endif // DBG
            EnableMenuItem (GetSystemMenu(GetParent(hWnd), FALSE), SC_CLOSE, MF_ENABLED); //reset system menu
            return TRUE;
        }

        case WM_CTLCOLORSTATIC:
			return SetColors((HDC)wParam, (HWND)lParam);

        case WM_COMMAND:
            switch(LOWORD(wParam))
            {
				case IDOK:
                case IDC_OK:
				case IDCANCEL:
                    EndDialog(GetParent(hWnd), S_OK);
					QUITAUClient();
                    return 0;				

                default:
                    return 0;
            }

		case WM_DESTROY:
//            ghCurrentMainDlg = NULL;
			return FALSE;

		case WM_DRAWITEM:
			AdjustSideBar(hWnd);
			return TRUE;

        default:
            return FALSE;
    }
}

INT_PTR CALLBACK RestartDlgProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch(message)
    {
        case WM_INITDIALOG:
        {
            ghCurrentDialog = hWnd;
            HWND hHeader = GetDlgItem(hWnd, IDC_HEADER);
            SendMessage(hHeader, WM_SETFONT, (WPARAM)ghHeaderFont, 0);
            SetWindowPos(hWnd, HWND_TOP, 0, 0, 0, 0, SWP_SHOWWINDOW | SWP_NOSIZE);
            SetFocus(GetDlgItem(hWnd, IDC_RESTARTNOW));
            EnableMenuItem (GetSystemMenu(GetParent(hWnd), FALSE), SC_CLOSE, MF_ENABLED); //reset system menu
            return TRUE;
        }

        case WM_CTLCOLORSTATIC:
			return SetColors((HDC)wParam, (HWND)lParam);

        case WM_COMMAND:
            switch(LOWORD(wParam))
            {
		case IDOK:
        case IDC_RESTARTNOW:
			SetClientExitCode(CDWWUAUCLT_REBOOTNOW);
                    EndDialog(GetParent(hWnd),S_OK);
                    QUITAUClient();
                    return 0;
		case IDCANCEL:
		case IDC_RESTARTLATER:
				//DestroyWindow(hWnd);
				EndDialog(GetParent(hWnd), S_OK);
				SetClientExitCode(CDWWUAUCLT_REBOOTLATER);
				QUITAUClient();
			return 0;
              default:
                    return 0;
            }

		case WM_DRAWITEM:
			AdjustSideBar(hWnd);
			return TRUE;

        default:
            return FALSE;
    }
}


INT_PTR CALLBACK SetupCancelDlgProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{  
    switch(message)
    {   
        case WM_INITDIALOG:
            {
                ghCurrentDialog = hWnd;

                HWND hHeader = GetDlgItem(hWnd, IDC_HEADER);
                SendMessage(hHeader, WM_SETFONT, (WPARAM)ghHeaderFont, 0);

                SetWindowPos(hWnd, HWND_TOP, 0, 0, 0, 0, SWP_SHOWWINDOW | SWP_NOSIZE);
				
				GetItemAndEnableIt(hWnd, IDC_BACK, FALSE);
				GetItemAndEnableIt(hWnd, IDC_CANCEL, FALSE);

				SetFocus(GetDlgItem(hWnd, IDC_FINISH));		

                return TRUE;
            }

        case WM_COMMAND:
            switch(LOWORD(wParam))
            {
				case IDOK:				
				case IDCANCEL:					
				case IDC_FINISH:	
					{
						// bug 493734
						// Remove the dialog (frame) but keep the icon.
                		EndDialog(GetParent(hWnd), S_OK);
                		gNextDialogMsg = AUMSG_SHOW_WELCOME;
//						QUITAUClient();		
//						RemoveTrayIcon();
						return 0;
					}				
                default:
                    return 0;
            }

        case WM_CTLCOLORSTATIC:
			return SetColors((HDC)wParam, (HWND)lParam);

	case WM_DRAWITEM:
			AdjustSideBar(hWnd);
			return TRUE;

        default:
            return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\wuauclt\reminder.cpp ===
#include "pch.h"
#pragma hdrstop

#define STRING_BUFFER_SIZE 80

void InitReminderComboBox(HWND hDlg, HWND combo)
{
	for(int i = 0; i < TIMEOUT_INX_COUNT; i++)
	{
		TCHAR buffer[STRING_BUFFER_SIZE];
		if (0 == LoadString(ghInstance, ReminderTimes[i].stringResId, buffer, STRING_BUFFER_SIZE))
		{
			DEBUGMSG("WUAUCLT String resource %d not found", ReminderTimes[i].stringResId);
			QUITAUClient();
			return;
		}
		LRESULT lr = SendMessage(combo, CB_INSERTSTRING, i, (LPARAM)buffer);
		if (CB_ERR == lr)
		{
			DEBUGMSG("REMINDER: fail to insert string to combobox %S", buffer);
		}
	}
	SendMessage(combo, CB_SETCURSEL, 0, 0); 
}



INT_PTR CALLBACK ReminderDlgProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM /*lParam*/)
{
	//fixcode: no need static
	static HWND combo;
	static HWND oldCurrentDlg;

	switch(message)
	{
		case WM_INITDIALOG:
			oldCurrentDlg = ghCurrentDialog;
			ghCurrentDialog = hWnd;
			gTopWins.Add(hWnd);
			combo = GetDlgItem(hWnd, IDC_REMINDTIME);
			InitReminderComboBox(hWnd, combo);
			SetFocus(combo);
			return TRUE;

		case WM_COMMAND:
			switch(LOWORD(wParam))
			{
				case IDC_OK:
					{
#ifdef TESTUI
						EndDialog(hWnd, S_OK);
						return 0;
#else
						UINT index = (LONG)SendMessage(combo, CB_GETCURSEL, 0, 0);
						gInternals->m_setReminderTimeout(index);
						EndDialog(hWnd, S_OK);						
						QUITAUClient();	//Stop the client's execution when user sets remind me later
						return 0;
#endif
					}
				case IDCANCEL:
				case IDC_CANCEL:
					{
						EndDialog(hWnd, S_FALSE);
						return 0;
					}

				default:
					break;
			}
			break;
/*
		case WM_CLOSE:
			{
				UINT index = SendMessage(combo, CB_GETCURSEL, 0, 0);

				setReminderTime(index);
				EndDialog(hWnd, S_FALSE);
				return TRUE;
			}
			*/

		case WM_DESTROY:
			ghCurrentDialog = oldCurrentDlg;
			gTopWins.Remove(hWnd);
			return 0;

		default:
			break;
	}
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\wuauclt\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by contents.rc
//
#include "aucomres.h"

#define IDS_WELCOMECAPTION              100
#define IDS_DOWNLOADTITLE               101
#define IDS_DOWNLOADCAPTION             102
#define IDS_INSTALLTITLE                103
#define IDS_INSTALLCAPTION              104
#define IDS_DOWNLOADBUTTONTXT	        107
#define IDS_INSTALLBUTTONTXT	        108
#define IDS_CLOSEBUTTONTXT	            109
#define IDS_PAUSEMENUITEM	            111
#define IDS_RESUMEMENUITEM	            112
#define IDS_DOWNLOADINGFORMAT	        113
#define IDS_SUSPENDEDFORMAT	            114
#define IDS_HEADERFONT		            117
#define IDS_INSTALLTEXT                 118
#define IDS_THIRTY_MINUTES              125
#define IDS_ONE_HOUR                    126
#define IDS_TWO_HOURS                   127
#define IDS_FOUR_HOURS                  128
#define IDS_TOMORROW                    129
#define IDS_READTHISFIRST               130
#define IDS_WELCOMETITLE                131
#define IDS_CLOSEWARNINGTITLE       	132
#define IDS_CLOSEWARNINGTEXT	        133
#define IDS_RESTORE_POINT_DESC          136
#define IDS_THREE_DAYS					154
#define IDS_NOTE				157
#define IDS_WELCOME_CONTINUE			158
#define IDS_RTFSHORTCUT					159
//#ifdef _CWU
#define IDS_EULA						160
#define IDS_PRIVACY						161
#define IDS_LEARNMORE					162
#define IDS_LEARNMOREAUTO				163
#define IDS_STR_EVERYDAY				164
#define IDS_STR_SUNDAY					165
#define IDS_STR_MONDAY					166
#define IDS_STR_TUESDAY					167
#define IDS_STR_WEDNESDAY				168
#define IDS_STR_THURSDAY				169
#define IDS_STR_FRIDAY					170
#define IDS_STR_SATURDAY				171
#define IDS_START_INSTALL				174
#define IDS_PROMPT_RESTART				175
#define IDS_COUNTDOWN_FORMAT			176
//#endif



//////////////////////////////////////////////////
// ICON identifiers
//////////////////////////////////////////////////
#define IDI_AUICON 		301
#define IDI_INFOICON					304


//////////////////////////////////////////////////
// BITMAP identifiers
//////////////////////////////////////////////////
#define IDB_SIDEBAR                     401
#define IDB_HEADERICON                  402
#define IDB_CHECK                       403
#define IDB_CLEAR                       404
#define IDB_GRAYOUT			    405


/////////////////////////////////////////////////
// DIALOG identifiers
/////////////////////////////////////////////////
#define IDD_WELCOME                     501
#define IDD_DETAILS                     502
#define IDD_DOWNLOAD                    503
#define IDD_SUMMARY                     504
#define IDD_PROGRESS                    505
#define IDD_COMPLETE                    506
#define IDD_RESTART                     507
#define IDD_REMIND			            509
#define IDD_UPDATEFRAME                 510
#define IDD_INSTALLFRAME                511
#define IDD_SETTINGS                    512
#define IDD_DISABLE                     513
#define IDD_SETUPCOMPLETE				514
#define IDD_NOTOPTIONS					515
#define IDD_SETUPCANCEL					516
//#ifdef _CWU
#define IDD_RESTOREUPDATE				517
#define IDD_START_INSTALL               518
#define IDD_PROMPT_RESTART              519
//#endif

/////////////////////////////////////////////////
// ACCELARATOR identifiers
/////////////////////////////////////////////////
#define IDA_BASE						610

/////////////////////////////////////////////////
// CONTROL identifiers
/////////////////////////////////////////////////
#define IDC_SETTINGS                    701
#define IDC_OK                          702
#define IDC_REMINDLATER                 703
#define IDC_UPDATELIST                  704
#define IDC_DETAILS                     705
#define IDC_PROGRESS                    706
#define IDC_HEADER                      707
#define IDC_CANCEL                      708
#define IDC_REMINDTIME                  709
#define IDC_TEXT                        710
//#define IDC_OPTION1                     711
//#define IDC_OPTION2                     712
//#define IDC_OPTION3                     713
//#define IDC_RESTOREHIDDEN               714
#define IDC_NEXT						715
#define IDC_BACK						716
#define IDC_FINISH						717
#define IDC_ACCEPT						718
#define IDC_PAUSE                       720
#define IDC_RESUME                      721
#define IDC_INFOICON					723
#define IDC_WHITERECT                   725
#define IDC_TEXT_HIDDEN1				726
#define IDC_TEXT_HIDDEN2				727
#define IDC_LEARNMORE					729
#define IDC_RESTARTNOW					730
#define IDC_RESTARTLATER				731
#define IDC_WELCOME_CONTINUE			732
#define IDC_WELCOME_NOTE				733
#define IDC_WELCOME_EULA				734
#define IDC_WELCOME_PRIVACY				735
#define IDC_SUMMARY_NOTE				736
#define IDC_SIDEBAR						737
#define IDC_BOTTOMLINE					738
#define IDC_GRPBOX						739

#define IDI_AUSYSTRAYICON				740	

//#ifdef _CWU
//#define IDC_CMB_DAYS                    1000
//#define IDC_CMB_HOURS                   1001
//#define IDC_CHK_KEEPUPTODATE			1002
#define IDC_STAT_LEARNAUTOUPDATE		2003
#define IDC_AT							2004
#define IDC_STAT_COUNTER                2005
#define IDC_PROG_TIME                   2006
//#endif
/////////////////////////////////////////////////
// Other Resource identifiers
/////////////////////////////////////////////////

/*
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        120
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1026
#define _APS_NEXT_SYMED_VALUE           126
#endif
#endif
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\wuauclt\settingsdlg.cpp ===
#include "pch.h"
#include "link.h"

#pragma hdrstop

#define	AU_ITEMS			TEXT("AutoUpdateItems")

void EnableRestoreControls(HWND hWnd, BOOL fEnable)
{
	EnableWindow(GetDlgItem(hWnd, IDC_RESTOREHIDDEN), fEnable);
	EnableWindow(GetDlgItem(hWnd, IDC_TEXT_HIDDEN1), fEnable);				
	EnableWindow(GetDlgItem(hWnd, IDC_TEXT_HIDDEN2), fEnable);				
}
					
CSysLink g_SettingsAutoUpdatelink;
CSysLink g_SettingsScheduledInstalllink;

BOOL EnableCombo(HWND hwnd, BOOL bState);
BOOL EnableOptions(HWND hwnd, BOOL bState);
//BOOL FillDaysCombo(HWND hwnd, DWORD dwSchedInstallDay);
//BOOL FillHrsCombo(HWND hwnd, DWORD dwSchedInstallTime);
void OnKeepUptoDate(HWND hwnd);
void MYREInit(HWND hDlg, UINT uId, HFONT hFont);
void LaunchLinkAction(HWND hwnd, UINT uCtrlId);
#ifdef TESTUI
#if 0
void SetServiceOption(
	DWORD dwOption,
	DWORD dwDay,
	DWORD dwTime
);
void GetServiceOption(
	LPDWORD lpdwOption,
	LPDWORD lpdwDay,
	LPDWORD lpdwTime
);
#endif
#endif

void GetDayAndTimeFromUI( 
	HWND hWnd,
	LPDWORD lpdwDay,
	LPDWORD lpdwTime
);

INT_PTR CALLBACK _DlgRestoreProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	switch(message)
	{
		case WM_INITDIALOG:
			{
				HWND hwndOwner; 
				RECT rc, rcDlg, rcOwner; 
				// Get the owner window and dialog box rectangles. 
 
				if ((hwndOwner = GetParent(hwnd)) == NULL) 
				{
					hwndOwner = GetDesktopWindow(); 
				}

				GetWindowRect(hwndOwner, &rcOwner); 
				GetWindowRect(hwnd, &rcDlg); 
				CopyRect(&rc, &rcOwner); 

				 // Offset the owner and dialog box rectangles so that 
				 // right and bottom values represent the width and 
				 // height, and then offset the owner again to discard 
				 // space taken up by the dialog box. 
				OffsetRect(&rcDlg, -rcDlg.left, -rcDlg.top); 
				OffsetRect(&rc, -rc.left, -rc.top); 
				OffsetRect(&rc, -rcDlg.right, -rcDlg.bottom); 

				 // The new position is the sum of half the remaining 
				 // space and the owner's original position. 
				SetWindowPos(hwnd, 
					HWND_TOP, 
					rcOwner.left + (rc.right / 2), 
					rcOwner.top + (rc.bottom / 2), 
					0, 0,          // ignores size arguments 
					SWP_NOSIZE); 
			}
			return TRUE;

		case WM_COMMAND:	
			switch(LOWORD(wParam))
			{
			case IDOK:
				EndDialog(hwnd, TRUE);
				return TRUE;

			case IDCANCEL:
				EndDialog(hwnd, FALSE);
				return TRUE;
			}
	}
	return FALSE;
}

LONG SetSettingsColors(HDC hdc, HWND control)
{
	SetBkMode(hdc, TRANSPARENT);
	return PtrToLong(GetStockObject( HOLLOW_BRUSH ));
}

INT_PTR CALLBACK SettingsDlgProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	static HWND oldCurrentDialog;
//	DWORD dwOption = AUOPTION_INSTALLONLY_NOTIFY;
//	DWORD dwScheduledInstallDay = -1;
//	DWORD dwScheduledInstallTime = -1;
	AUOPTION auopt;
	auopt.dwOption = AUOPTION_INSTALLONLY_NOTIFY;
	auopt.dwSchedInstallDay = -1;
	auopt.dwSchedInstallTime = -1;

	switch(message)
	{
		case WM_INITDIALOG:
			{
			oldCurrentDialog = ghCurrentDialog;
			ghCurrentDialog = hWnd;
			gTopWins.Add(hWnd);
  			EnableCombo(hWnd, FALSE); //Initially disabled
#ifndef TESTUI
			if (FAILED(gInternals->m_getServiceOption(&auopt)))
				{
				QUITAUClient();
				return TRUE;
				}
#else
#endif

			g_SettingsAutoUpdatelink.SetSysLinkInstanceHandle(ghInstance);
			g_SettingsAutoUpdatelink.SubClassWindow(GetDlgItem(hWnd,IDC_STAT_LEARNAUTOUPDATE));
			g_SettingsAutoUpdatelink.SetHyperLink(gtszAUOverviewUrl);
			g_SettingsAutoUpdatelink.Invalidate();

			g_SettingsScheduledInstalllink.SetSysLinkInstanceHandle(ghInstance);
			g_SettingsScheduledInstalllink.SubClassWindow(GetDlgItem(hWnd,IDC_LEARNMORE));
			g_SettingsScheduledInstalllink.SetHyperLink(gtszAUSchedInstallUrl);
			g_SettingsScheduledInstalllink.Invalidate();

			switch(auopt.dwOption)
			{
				case AUOPTION_AUTOUPDATE_DISABLE:
					CheckDlgButton( hWnd, IDC_CHK_KEEPUPTODATE, BST_UNCHECKED);
					CheckRadioButton(hWnd, IDC_OPTION1, IDC_OPTION3, IDC_OPTION2);
					EnableOptions( hWnd, FALSE );
					break;

				case AUOPTION_PREDOWNLOAD_NOTIFY:
					CheckDlgButton( hWnd, IDC_CHK_KEEPUPTODATE, BST_CHECKED);
					CheckRadioButton(hWnd, IDC_OPTION1, IDC_OPTION3, IDC_OPTION1);
					EnableOptions( hWnd, TRUE );
					break;

				case AUOPTION_INSTALLONLY_NOTIFY:
					CheckDlgButton( hWnd, IDC_CHK_KEEPUPTODATE, BST_CHECKED);
					CheckRadioButton(hWnd, IDC_OPTION1, IDC_OPTION3, IDC_OPTION2);
					EnableOptions( hWnd, TRUE );
					break;

				case AUOPTION_SCHEDULED:
					CheckDlgButton( hWnd, IDC_CHK_KEEPUPTODATE, BST_CHECKED);
					CheckRadioButton(hWnd, IDC_OPTION1, IDC_OPTION3, IDC_OPTION3);
					EnableOptions( hWnd, TRUE );
					break;
			}

//			HFONT hFont = (HFONT) SendMessage(hWnd , WM_GETFONT, 0, 0);
//			MYREInit(hWnd, IDC_STAT_LEARNAUTOUPDATE, hFont);
//			MYREInit(hWnd, IDC_LEARNMORE, hFont);
			FillDaysCombo(ghInstance, hWnd, auopt.dwSchedInstallDay, IDS_STR_EVERYDAY, IDS_STR_SATURDAY );
			FillHrsCombo( hWnd, auopt.dwSchedInstallTime );
				
#ifndef TESTUI
			EnableRestoreControls(hWnd, FHiddenItemsExist());
			if (auopt.fDomainPolicy)
			{
				DisableUserInput(hWnd);
			}
#else
			EnableRestoreControls(hWnd, TRUE);
#endif
			SetFocus(GetDlgItem(hWnd,IDC_OK));
			return TRUE;
			}

		case WM_COMMAND:	
			switch(LOWORD(wParam))
			{
				case IDC_OK:
					if(IsDlgButtonChecked(hWnd, IDC_CHK_KEEPUPTODATE) == BST_UNCHECKED)
					{
                                          auopt.dwOption = AUOPTION_AUTOUPDATE_DISABLE;
						QUITAUClient();
						EndDialog(GetParent(hWnd), S_OK);
					}
					else if(IsDlgButtonChecked(hWnd, IDC_OPTION1) == BST_CHECKED)
					{
                                          auopt.dwOption = AUOPTION_PREDOWNLOAD_NOTIFY;
					}
					else if(IsDlgButtonChecked(hWnd, IDC_OPTION2) == BST_CHECKED)
					{
                                          auopt.dwOption = AUOPTION_INSTALLONLY_NOTIFY;
					}
					else //if(IsDlgButtonChecked(hWnd, IDC_OPTION3) == BST_CHECKED)
					{
						GetDayAndTimeFromUI( hWnd, &(auopt.dwSchedInstallDay), &(auopt.dwSchedInstallTime));
						auopt.dwOption = AUOPTION_SCHEDULED;
						EnableCombo( hWnd, TRUE );
					}
#ifndef TESTUI					
        				gInternals->m_setServiceOption(auopt);
#else
//					SetServiceOption(auopt.dwOption, auopt.dwScheduledInstallDay, auopt.dwScheduledInstallTime);
#endif
					EndDialog(hWnd, S_OK);
					return 0;

				case IDC_OPTION1:
					EnableCombo( hWnd, FALSE );
					CheckRadioButton(hWnd, IDC_OPTION1, IDC_OPTION3, IDC_OPTION1);
					return 0;
				case IDC_OPTION2:
					EnableCombo( hWnd, FALSE );
					CheckRadioButton(hWnd, IDC_OPTION1, IDC_OPTION3, IDC_OPTION2);
					return 0;
				case IDC_OPTION3:
					EnableCombo( hWnd, TRUE );
					CheckRadioButton(hWnd, IDC_OPTION1, IDC_OPTION3, IDC_OPTION3);
					return 0;
				case IDC_CHK_KEEPUPTODATE:
					if( BN_CLICKED == HIWORD(wParam) )
					{
						OnKeepUptoDate( hWnd );
					}
					return 0;

				case IDC_RESTOREHIDDEN:
					{
						extern HINSTANCE ghInstance;
						INT Result = (INT)DialogBoxParam(ghInstance, 
								MAKEINTRESOURCE(IDD_RESTOREUPDATE), 
								hWnd, 
								_DlgRestoreProc, 
							(LPARAM)NULL);
						if (Result == TRUE)
						{
#ifndef TESTUI
							if (RemoveHiddenItems())
							{
								EnableRestoreControls(hWnd, FALSE);
							}	
#else
							MessageBoxW(NULL,L"Said Yes",NULL,MB_OK);
							EnableRestoreControls(hWnd, FALSE);
#endif
						}
					}
					return 0;
				case IDCANCEL:
				case IDC_CANCEL:
					EndDialog(hWnd, S_OK);
					return 0;

				default:
					return FALSE;
			}
		case WM_CLOSE:
			EndDialog(hWnd, S_OK);
			return FALSE;

		case WM_DESTROY:
		       g_SettingsAutoUpdatelink.Uninit();
		       g_SettingsScheduledInstalllink.Uninit();
			ghCurrentDialog = oldCurrentDialog;
			gTopWins.Remove(hWnd);
			return 0;
		
		case WM_CTLCOLORSTATIC:
			{
				if (((HWND)lParam == GetDlgItem(hWnd, IDC_STAT_LEARNAUTOUPDATE)) || ((HWND)lParam == GetDlgItem(hWnd, IDC_LEARNMORE)))
					return SetSettingsColors((HDC)wParam, (HWND)lParam);
			}
/*
		case WM_NOTIFY:
			{
					UINT  uId = (UINT) LOWORD(wParam);
					switch (uId)
					{
						case IDC_LEARNMORE:
						case IDC_STAT_LEARNAUTOUPDATE:
							if (((NMHDR FAR *) lParam)->code == EN_LINK) 
							{
								if (((ENLINK FAR *) lParam)->msg == WM_LBUTTONDOWN)  
								{
									LaunchLinkAction(hWnd, uId);							
								}
							}
							break;
						default:
								  break;
					}
			}
			return 0;*/
		default:
			return FALSE;

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\wuauclt\promptuserdlg.cpp ===
// PromptUserDlg.cpp: implementation of the CPromptUserDlg class.
//
//////////////////////////////////////////////////////////////////////

#include "pch.h"
#include "PromptUserDlg.h"
#include "Resource.h"
#include "windowsx.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////
HINSTANCE CPromptUserDlg::m_hInstance = NULL;

#define TIMER_INTERVAL 5  //5 sec interval

const TCHAR g_szDialogPtr[]       = TEXT("PromptUser_DialogPtr");

void CPromptUserDlg::SetInstanceHandle(HINSTANCE hInstance)
{
	m_hInstance = hInstance;
}

CPromptUserDlg::CPromptUserDlg(WORD wDlgResourceId, BOOL fEnableYes, BOOL fEnableNo, BOOL fManualReboot, DWORD dwElapsedTime )
{
      DEBUGMSG("PromptUserDlg %d created with fEnableYes = %d, fEnableNo = %d, fManualReboot = %d, dwElapsedTime = %d", wDlgResourceId, fEnableYes, fEnableNo, fManualReboot, dwElapsedTime);
	m_nIDTimer = 0;
	m_wDlgResourceId = wDlgResourceId;
	m_fEnableYes = fEnableYes;
	m_fEnableNo = fEnableNo;
	m_fManualReboot = fManualReboot;
        AUASSERT(dwElapsedTime <= AUPROMPTDLG_TOTAL_TIME_ELAPSE);
        if (dwElapsedTime > AUPROMPTDLG_TOTAL_TIME_ELAPSE)
        {
            dwElapsedTime = AUPROMPTDLG_TOTAL_TIME_ELAPSE;
        }
        m_ElapsedTime = (dwElapsedTime) / TIMER_INTERVAL * TIMER_INTERVAL; //round off 
}

CPromptUserDlg::~CPromptUserDlg()
{

}

INT CPromptUserDlg::DoModal(HWND hWndParent = NULL)
{
	return (INT)DialogBoxParam(m_hInstance, 
                                 MAKEINTRESOURCE(m_wDlgResourceId), 
                                 hWndParent, 
                                 CPromptUserDlg::_DlgProc, 
                                 (LPARAM)this);
}

INT_PTR CALLBACK 
CPromptUserDlg::_DlgProc(   // [static]
    HWND hwnd,
    UINT uMsg, 
    WPARAM wParam, 
    LPARAM lParam
    )
{
	CPromptUserDlg *pThis = NULL;
    if (WM_INITDIALOG == uMsg)
    {
        pThis = (CPromptUserDlg *)lParam;
        if (!SetProp(hwnd, g_szDialogPtr, (HANDLE)pThis))
        {
            pThis = NULL;
        }
    }
    else
    {
        pThis = (CPromptUserDlg *)GetProp(hwnd, g_szDialogPtr);
    }

    if (NULL != pThis)
    {
        switch(uMsg)
        {
            HANDLE_MSG(hwnd, WM_INITDIALOG,  pThis->_OnInitDialog);
            HANDLE_MSG(hwnd, WM_COMMAND,     pThis->_OnCommand);
            HANDLE_MSG(hwnd, WM_DESTROY, pThis->_OnDestroy);
	     HANDLE_MSG(hwnd, WM_TIMER,     pThis->_OnTimer);
		 HANDLE_MSG(hwnd, WM_ENDSESSION, pThis->_OnEndSession);
            default:
                break;
        }
    }
    return (FALSE);
}

extern HWND ghCurrentMainDlg;
extern HWND ghCurrentDialog;

BOOL CPromptUserDlg::_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
// set icons
	HICON hIcon = (HICON)::LoadImage(m_hInstance, MAKEINTRESOURCE(IDI_AUICON), 
	IMAGE_ICON, ::GetSystemMetrics(SM_CXICON), ::GetSystemMetrics(SM_CYICON), LR_DEFAULTCOLOR);
	::SendMessage(hwnd, WM_SETICON, ICON_BIG, (LPARAM)hIcon);

	HICON hIconSmall = (HICON)::LoadImage(m_hInstance, MAKEINTRESOURCE(IDI_AUICON), 
		IMAGE_ICON, ::GetSystemMetrics(SM_CXSMICON), ::GetSystemMetrics(SM_CYSMICON), LR_DEFAULTCOLOR);
	::SendMessage(hwnd, WM_SETICON, ICON_SMALL, (LPARAM)hIconSmall);

	EnableWindow(GetDlgItem(hwnd, IDYES), m_fEnableYes);
	EnableWindow(GetDlgItem(hwnd, IDNO), m_fEnableNo);
	ghCurrentMainDlg = hwnd;
  	ghCurrentDialog = hwnd;
	m_ProgressBar = GetDlgItem(hwnd,IDC_PROG_TIME);
	if (m_fManualReboot)
	{
	    ShowWindow(m_ProgressBar, SW_HIDE);
	    ShowWindow(GetDlgItem(hwnd, IDC_STAT_COUNTER), SW_HIDE);

	}
	else
	{
	    SendMessage(m_ProgressBar,PBM_SETRANGE, 0, MAKELPARAM(0,AUPROMPTDLG_TOTAL_TIME_ELAPSE / TIMER_INTERVAL));
           SendMessage(m_ProgressBar,PBM_SETSTEP,(WPARAM)1,(LPARAM)0);
	    SendMessage(m_ProgressBar,PBM_SETPOS, m_ElapsedTime / TIMER_INTERVAL, 0);
           SendMessage(hwnd, WM_SETICON, ICON_BIG,(LPARAM)hIcon);
           m_nIDTimer = SetTimer(hwnd,m_nIDTimer,TIMER_INTERVAL* 1000,(TIMERPROC)NULL);
	}

	EnableMenuItem(GetSystemMenu(hwnd, FALSE), SC_CLOSE, MF_GRAYED);

	UpdateStatus(hwnd);
//       SetActiveWindow(ghCurrentMainDlg); 
       SetForegroundWindow(ghCurrentMainDlg);

	return TRUE;
}

void CPromptUserDlg::_OnDestroy (HWND hwnd) {
        ghCurrentMainDlg = NULL;
}



BOOL CPromptUserDlg::_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    switch(id)
    {
        case IDNO:
        case IDYES:
            if(BN_CLICKED == codeNotify)
            {
		  if (0 != m_nIDTimer) 
		    {
		        KillTimer(hwnd,m_nIDTimer);
		  }
                EndDialog(hwnd,id);
            }
	        break;
	}
	return TRUE;
}

void CPromptUserDlg::_OnTimer(HWND hwnd, UINT id)
{
	m_ElapsedTime += TIMER_INTERVAL;

	if (m_ElapsedTime <= AUPROMPTDLG_TOTAL_TIME_ELAPSE)
	{
		//Update Progress bar
		SendMessage(m_ProgressBar,PBM_STEPIT,0,0);
		UpdateStatus(hwnd);
	}
	if (m_ElapsedTime == AUPROMPTDLG_TOTAL_TIME_ELAPSE)
	{
		KillTimer(hwnd,m_nIDTimer);
		//On end of AUPROMPTDLG_TOTAL_TIME_ELAPSE send message timeout to the dialog.
		EndDialog(hwnd,AU_IDTIMEOUT);
	}
}

void CPromptUserDlg::UpdateStatus(HWND hwnd)
{
	TCHAR tszCountdownFormat[81];//see 
	TCHAR tszCountdown[160];
	TCHAR strFormat[200];
	TCHAR strUpdate[200];
	DWORD dwResId = 0;
	SYSTEMTIME st;

	ZeroMemory(&st, sizeof(st));
	st.wMinute = (AUPROMPTDLG_TOTAL_TIME_ELAPSE - m_ElapsedTime) / 60;
	st.wSecond = (AUPROMPTDLG_TOTAL_TIME_ELAPSE - m_ElapsedTime) % 60;

	switch(m_wDlgResourceId) {
	case IDD_START_INSTALL:
		dwResId = IDS_START_INSTALL;
		break;

	case IDD_PROMPT_RESTART:
		dwResId = IDS_PROMPT_RESTART;
		break;
	}

	if (LoadString(m_hInstance, IDS_COUNTDOWN_FORMAT, tszCountdownFormat, ARRAYSIZE(tszCountdownFormat)) &&
		LoadString(m_hInstance, dwResId, strFormat, ARRAYSIZE(strFormat)) &&
		GetTimeFormat(LOCALE_SYSTEM_DEFAULT, 0, &st, tszCountdownFormat, tszCountdown, ARRAYSIZE(tszCountdown)))
	{
		(void)StringCchPrintfEx(strUpdate, ARRAYSIZE(strUpdate), NULL, NULL, MISTSAFE_STRING_FLAGS, strFormat, tszCountdown);
		//fixcode: check return value of GetDlgItem()
		SetWindowText(GetDlgItem(hwnd,IDC_STAT_COUNTER),strUpdate);
	}
}


void CPromptUserDlg::_OnEndSession(HWND hwnd, BOOL fEnding)
{
	DEBUGMSG("OnEndSession: ending = %s", fEnding ? "TRUE" : "FALSE");
	KillTimer(hwnd,m_nIDTimer);
	//On end of AUPROMPTDLG_TOTAL_TIME_ELAPSE send message timeout to the dialog.
	EnableMenuItem(GetSystemMenu(hwnd, FALSE), SC_CLOSE, MF_ENABLED);
	EndDialog(hwnd,AU_IDTIMEOUT);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\wuauclt\promptuserdlg.h ===
// PromptUserDlg.h: interface for the CPromptUserDlg class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_PROMPTUSERDLG_H__BFA609BD_8021_4CE2_AEF8_1D0D96F87402__INCLUDED_)
#define AFX_PROMPTUSERDLG_H__BFA609BD_8021_4CE2_AEF8_1D0D96F87402__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define AU_IDTIMEOUT 	1000

class CPromptUserDlg  
{
public:
	CPromptUserDlg(WORD wDlgResourceId, BOOL fEnableYes= TRUE, BOOL fEnableNo = TRUE, BOOL fManualReboot = FALSE, DWORD dwElapsedTime = 0);
	virtual int DoModal(HWND hWndParent);
	virtual ~CPromptUserDlg();

	//Message Handlers
	BOOL _OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam);
    BOOL _OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
	void _OnTimer(HWND hwnd, UINT id);
	void _OnDestroy(HWND hwnd);
	void _OnEndSession(HWND hwnd, BOOL fEnding);

	static void SetInstanceHandle(HINSTANCE hInstance);
	static INT_PTR CALLBACK _DlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

	//Helper function
	void UpdateStatus(HWND hwnd);
private:
	static HINSTANCE m_hInstance;

private:
	WORD m_wDlgResourceId;
	HWND m_ProgressBar;

	UINT_PTR m_nIDTimer;
	UINT m_ElapsedTime;
	
	BOOL m_fEnableYes;
	BOOL m_fEnableNo;
	BOOL m_fManualReboot;
};

#endif // !defined(AFX_PROMPTUSERDLG_H__BFA609BD_8021_4CE2_AEF8_1D0D96F87402__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\wuauclt\trayicon.cpp ===
#include "pch.h"
#pragma hdrstop


BOOL fTrayIconShowing;
TCHAR downloadFormatString[64];
TCHAR pauseString[64];


BOOL MyShell_NotifyIcon(DWORD dwMessage, PNOTIFYICONDATA pnid)
{

//       DEBUGMSG("MyShell_NotifyIcon() called with msg %d", dwMessage);
	BOOL fRet;

	if (NIM_SETVERSION == dwMessage)
		{
		return Shell_NotifyIcon(dwMessage, pnid);
		}
	UINT uRetry = 0;
	//retry 3 times due to the way Shell_NotifyIcon is implemented
	while ( !(fRet = Shell_NotifyIcon(dwMessage, pnid)) && uRetry++ < 3)
		{
		   if (WAIT_TIMEOUT != MsgWaitForMultipleObjectsEx(0,NULL, 2000, QS_POSTMESSAGE, MWMO_INPUTAVAILABLE))
		   	{
		   	break;
		   	}
		   	
		}
	return fRet;
}
   
void InitTrayIcon()
{
	fTrayIconShowing = FALSE;

	TCHAR PauseMenuString[30];
	TCHAR ResumeMenuString[30];

	LoadString(ghInstance, IDS_PAUSEMENUITEM, PauseMenuString, ARRAYSIZE(PauseMenuString));
	LoadString(ghInstance, IDS_RESUMEMENUITEM, ResumeMenuString, ARRAYSIZE(ResumeMenuString));
	
	ghPauseMenu = CreatePopupMenu();
	AppendMenu(ghPauseMenu, MF_STRING, IDC_PAUSE, PauseMenuString);	
	ghResumeMenu = CreatePopupMenu();
	AppendMenu(ghResumeMenu, MF_STRING, IDC_RESUME, ResumeMenuString);	

	LoadString(ghInstance, IDS_DOWNLOADINGFORMAT, downloadFormatString, ARRAYSIZE(downloadFormatString));
	LoadString(ghInstance, IDS_SUSPENDEDFORMAT, pauseString, ARRAYSIZE(pauseString));
}

void UninitPopupMenus()
{
	if (NULL != ghPauseMenu)
	{
		DestroyMenu(ghPauseMenu);
	}
	if (NULL != ghResumeMenu)
	{
		DestroyMenu(ghResumeMenu);
	}
}

BOOL ShowTrayIcon()
{
    DEBUGMSG("ShowTrayIcon() called");

	if ( fTrayIconShowing) 
	{
		return TRUE;
	}

	NOTIFYICONDATA nid;
	memset(&nid, 0, sizeof(nid));
	nid.cbSize = sizeof(nid);
	nid.hWnd = ghMainWindow;
	nid.uID = (UINT) IDI_AUICON;
	nid.uFlags = NIF_ICON | NIF_MESSAGE;
	nid.uCallbackMessage = AUMSG_TRAYCALLBACK;
	nid.hIcon = ghTrayIcon;
	BOOL fRet = MyShell_NotifyIcon(NIM_ADD, &nid);

	if(!fRet)
	{
		// If for any reason, we are not able to use the tray icon, something is wrong
		// ask WUAUSERV wait for sometime before relaunch WUAUCLT. 
		DEBUGMSG("WUAUCLT quit because fail to add tray icon");
		SetClientExitCode(CDWWUAUCLT_RELAUNCHLATER);
		QUITAUClient();
	}
	else
	{
		fTrayIconShowing = TRUE;
	}
	return fRet;
}

void ShowTrayBalloon(WORD title, WORD caption, WORD tip )
{
       DEBUGMSG("ShowTrayBalloon() called");

	static NOTIFYICONDATA nid;
    
	memset(&nid, 0, sizeof(nid));
	nid.uTimeout = 15000;

    LoadString(ghInstance, title, nid.szInfoTitle, ARRAYSIZE(nid.szInfoTitle));
	LoadString(ghInstance, caption, nid.szInfo, ARRAYSIZE(nid.szInfo));
	LoadString(ghInstance, tip, nid.szTip, ARRAYSIZE(nid.szTip));
	nid.uFlags = NIF_INFO | NIF_TIP;
	nid.cbSize = sizeof(nid);
	nid.hWnd = ghMainWindow;
	nid.uID = (UINT) IDI_AUICON;
    nid.dwInfoFlags = NIIF_INFO;

	BOOL fRet = MyShell_NotifyIcon(NIM_MODIFY, &nid);
    if (!fRet)
    {
        DEBUGMSG("WUAUCLT Creation of tray balloon failed");
    }

#ifdef DBG
	DebugCheckForAutoPilot(ghMainWindow);
#endif
}


/*
void AddTrayToolTip(WORD tip)
{
	static NOTIFYICONDATA nid;
    
	memset(&nid, 0, sizeof(nid));
	LoadString(ghInstance, tip, nid.szTip, ARRAYSIZE(nid.szTip));
	nid.uFlags = NIF_TIP;
	nid.cbSize = sizeof(nid);
	nid.hWnd = ghMainWindow;
	nid.uID = (UINT) IDI_AUICON;
	MyShell_NotifyIcon(NIM_MODIFY, &nid);
}
*/

void RemoveTrayIcon()
{
	DEBUGMSG("RemoveTrayIcon() called");
	if (fTrayIconShowing)
	{
		NOTIFYICONDATA nid;
		memset(&nid, 0, sizeof(nid));
		nid.cbSize = sizeof(nid);
		nid.hWnd = ghMainWindow;
		nid.uID = (UINT) IDI_AUICON;
		MyShell_NotifyIcon(NIM_DELETE, &nid);

		// Don't leave any popup menu around when removing tray icon.
		if (SendMessage(ghMainWindow, WM_CANCELMODE, 0, 0))
		{
			DEBUGMSG("WUAUCLT WM_CANCELMODE was not handled");
		}

		fTrayIconShowing = FALSE;
	}
}

//fixcode: when download complete, should call ShowProgress() to update trayicon info
void ShowProgress()
{
	NOTIFYICONDATA nid;
	UINT percentComplete;
	DWORD status;

    //DEBUGMSG("ShowProgress() called");
    memset(&nid, 0, sizeof(nid));

	if (FAILED(gInternals->m_getDownloadStatus(&percentComplete, &status)))
	{
		QUITAUClient();
		return;
	}
	nid.cbSize = sizeof(nid);
	nid.hWnd = ghMainWindow;
	nid.uID = (UINT) IDI_AUICON;
	nid.uFlags = NIF_TIP;
	
	if(status == DWNLDSTATUS_DOWNLOADING) 
	{
		(void)StringCchPrintfEx(nid.szTip, ARRAYSIZE(nid.szTip), NULL, NULL, MISTSAFE_STRING_FLAGS, downloadFormatString, percentComplete);
	}
	else if(status == DWNLDSTATUS_PAUSED)
	{
		(void)StringCchCopyEx(nid.szTip, ARRAYSIZE(nid.szTip), pauseString, NULL, NULL, MISTSAFE_STRING_FLAGS);
	}
	else
	{
	    (void)StringCchCopyEx(nid.szTip, ARRAYSIZE(nid.szTip), _T(""), NULL, NULL, MISTSAFE_STRING_FLAGS);
	}
	MyShell_NotifyIcon(NIM_MODIFY, &nid);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\wuauclt\wrkthread.h ===
//=======================================================================
//
//  Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:    WrkThread.h
//
//  Creator: PeterWi
//
//  Purpose: Worker thread declarations.
//
//=======================================================================
#pragma once

#include "wuauengi.h"

typedef enum
{
	enWrkThreadInstall,
	enWrkThreadAutoInstall,	
	enWrkThreadTerminate
} enumWrkThreadDirective;

//start another thread in client to install
class CClientWrkThread
{
public:
	CClientWrkThread()
		: m_hEvtDirectiveStart(NULL),
		  m_hEvtDirectiveDone(NULL),
		  m_hWrkThread(NULL)
	{ 
	}
	
	~CClientWrkThread();
	HRESULT m_Init(void);
	void  m_Terminate(void);
	static DWORD WINAPI m_WorkerThread(void * lpParameter);
	static void PingStatus(PUID puid, PingStatusCode enStatusCode, HRESULT hrErr = 0);
	void m_DoDirective(enumWrkThreadDirective enDirective);
	void WaitUntilDone();

private:
	HRESULT m_WaitForDirective(void);
	HANDLE m_hEvtDirectiveStart;
	HANDLE m_hEvtDirectiveDone;
	HANDLE m_hWrkThread;	
	static HANDLE m_hEvtInstallDone;
	enumWrkThreadDirective m_enDirective;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\wuaucpl\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	wuaucpl.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\wuaucpl\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by wuaucpl.rc
//
#include "aucomres.h"
#define IDS_STR_NAME                    100
#define IDD_AUTOUPDATE                  101
#define IDC_GRP_OPTIONS                 101
#define IDS_STR_DESC                    101
#define IDC_AUTOUPDATE_OPTION1          102
#define IDI_ICONWU                      102
#define IDS_STR_EVERYDAY                102
#define IDC_AUTOUPDATE_OPTION2          103
#define IDS_STR_SUNDAY                  103
#define IDC_AUTOUPDATE_OPTION3          104
#define IDS_STR_MONDAY                  104
#define IDD_RESTOREUPDATE               104
#define IDC_TXT_HEADER                  105
#define IDS_STR_TUESDAY                 105
#define IDS_STR_WEDNESDAY               106
#define IDS_STR_THURSDAY                107
#define IDS_STR_FRIDAY                  108
#define IDI_AUTOUPDATE                  109
#define IDS_STR_SATURDAY                109

#define IDS_HEADER_CONNECTING			112
#define IDS_HEADER_UNAVAILABLE			113
#define IDS_HEADER_CONNECTED			114

#define IDC_STAT_LEARNAUTOUPDATE        203
#define IDC_AUTOUPDATELINK				204
#define IDC_STATICAT					205
#define IDC_SCHINSTALLINK				206

#define IDS_STR_AUTOUPDATE				207
#define IDS_STR_SCHEDULEINSTAL			208

#define IDC_STA_SCHEDULEDINSTAL         1002
#define IDC_STA_SCHEDULEDINSTALL        1002
#define IDC_BTN_APPLY                   1003
#define IDC_BTN_RESTORE                 1004

#define IDC_HANDCUR						1005	
	
// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        105
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1005
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\wuauclt\wrkthread.cpp ===
//=======================================================================
//
//  Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:	 wrkthread.cpp
//
//  Creator: PeterWi
//
//  Purpose: Worker thread.
//
//=======================================================================

#include "pch.h"
#pragma hdrstop

const CLSID CLSID_CV3 = {0xCEBC955E,0x58AF,0x11D2,{0xA3,0x0A,0x00,0xA0,0xC9,0x03,0x49,0x2B}};

HANDLE CClientWrkThread::m_hEvtInstallDone = NULL;

//=======================================================================
//
// CClientWrkThread::~CClientWrkThread
//
// Destructor
//
//=======================================================================

CClientWrkThread::~CClientWrkThread()
{
	SafeCloseHandleNULL(m_hEvtDirectiveStart);
	SafeCloseHandleNULL(m_hEvtDirectiveDone);
	SafeCloseHandleNULL(m_hEvtInstallDone);
	SafeCloseHandleNULL(m_hWrkThread);
}

void CClientWrkThread::m_Terminate()
{
	if (NULL != m_hWrkThread)
	{
		m_DoDirective(enWrkThreadTerminate);
		WaitForSingleObject(m_hWrkThread, INFINITE);
	}
}

//=======================================================================
//
// CClientWrkThread::m_WorkerThread
//
// Client worker thread that does long duration activities.
//
//=======================================================================

DWORD WINAPI CClientWrkThread::m_WorkerThread(void * lpParameter)
{
//	HRESULT hr;
	CClientWrkThread * pWrkThread = (CClientWrkThread *)lpParameter;
	DWORD dwRet = 0;

	DEBUGMSG("WUAUCLT: Installation worker thread starting");

	if ( FAILED(CoInitializeEx(NULL, COINIT_APARTMENTTHREADED)) )
	{
	       DEBUGMSG("m_WorkerThread() fails to initialize COM");
		return 1;
	}

	SetEvent(pWrkThread->m_hEvtDirectiveDone);

	DEBUGMSG("WUAUCLT: Installation worker thread waiting for directive");

	// wait for directive or termination of client.
	do
	{
		if ( SUCCEEDED(pWrkThread->m_WaitForDirective()) )
		{
			switch ( pWrkThread->m_enDirective )
			{
			case enWrkThreadInstall:
			case enWrkThreadAutoInstall:
			        {
        			      DEBUGMSG("m_WorkerThread() doing install");
			            HRESULT hr = gpClientCatalog->InstallItems(enWrkThreadAutoInstall == pWrkThread->m_enDirective);
			            SetEvent(m_hEvtInstallDone);
			            if (S_OK != hr)
			                {
			                    //install failed or nothing to install
			                    QUITAUClient();
			                    goto done;
			                }
        				break;
        			    }

			case enWrkThreadTerminate:
			       DEBUGMSG("m_WorkerThread() terminating");
				goto done;
				break;

			default:
				DEBUGMSG("ClientWrkThread: bad directive %d", pWrkThread->m_enDirective);
				break;
			}
		}
		else
		{
			dwRet = 1; // FAIL //fixcode: nobody look at this
			QUITAUClient();
			goto done;
		}
	} while (1);

done:
	DEBUGMSG("WUAUCLT CClientWrkThread::m_WorkerThread releasing");

	CoUninitialize();

	DEBUGMSG("WUAUCLT: Worker thread ended, ret = %lu", dwRet);

	return dwRet;
}

//=======================================================================
//
// CClientWrkThread::m_Init
//
// Init routine to do things that can fail.
//
//=======================================================================

HRESULT CClientWrkThread::m_Init(void)
{
	DWORD dwID;

	if ( (NULL == (m_hEvtDirectiveStart = CreateEvent(NULL,	FALSE, FALSE, NULL)))
	  || (NULL == (m_hEvtDirectiveDone = CreateEvent(NULL,	FALSE, FALSE, NULL)))
	  || (NULL == (m_hEvtInstallDone = CreateEvent(NULL,  FALSE, FALSE, NULL)))
	  || (NULL == (m_hWrkThread = CreateThread(NULL,
												 0,
												 (LPTHREAD_START_ROUTINE)CClientWrkThread::m_WorkerThread,
												 (LPVOID)this /*m_pCatalog*/,
												 0,
												 &dwID))))
	{
		return HRESULT_FROM_WIN32(GetLastError());
	}

	CONST HANDLE grHandles[] = { m_hEvtDirectiveDone, m_hWrkThread };
	DWORD dwRet = WaitForMultipleObjects(ARRAYSIZE(grHandles), grHandles, FALSE, INFINITE);

	// thread only returns on failure
	if ( (WAIT_OBJECT_0 + 1) == dwRet )
	{
		return E_FAIL;
	}
	else if (WAIT_FAILED == dwRet)
	{
		return HRESULT_FROM_WIN32(GetLastError());
	}

	return S_OK;
}

//=======================================================================
//
// ClientWrkThread::m_WaitForDirective
//
// Routine that worker thread waits with for a new directive.
//
//=======================================================================

HRESULT CClientWrkThread::m_WaitForDirective(void)
{
	DWORD dwRet = WaitForSingleObject(m_hEvtDirectiveStart, INFINITE);

	return (WAIT_OBJECT_0 == dwRet) ? S_OK : E_FAIL;
}

//=======================================================================
//
// ClientWrkThread::m_DoDirective
//
// Method to tell thread to start doing directive.
//
//=======================================================================

void CClientWrkThread::m_DoDirective(enumWrkThreadDirective enDirective)
{
	m_enDirective = enDirective;
	SetEvent(m_hEvtDirectiveStart);
}


/////////////////////////////////////////////////////////////////////////////////////////////
// wait until installation is done
////////////////////////////////////////////////////////////////////////////////////////////
void CClientWrkThread::WaitUntilDone()
{
    WaitForSingleObject(m_hEvtInstallDone, INFINITE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\wuauclt\wuauclt.h ===
#pragma once

#include "auinternals.h"
#include "resource.h"

class AUCLTTopWindows 
{
 public:
        AUCLTTopWindows(): m_uNum(0)
            {
                ZeroMemory(m_hwnds, sizeof(m_hwnds));
             }
        void Add(HWND hwnd) { 
                if (NULL != hwnd)
                    {
                       m_hwnds[m_uNum++] = hwnd;
                    }
            }
        BOOL Remove(HWND hwnd){
            if (NULL == hwnd)
                {
                    return FALSE;
                }
            for (UINT u = 0 ; u < m_uNum; u++)
                {
                    if (hwnd == m_hwnds[u]) 
                        {
                            m_hwnds[u] = m_hwnds[m_uNum-1];
                            m_hwnds[m_uNum-1] = NULL;
                            m_uNum--;
                            return TRUE;
                        }
                }
            return FALSE;
            }
        void Dismiss(void)
            {
	         DEBUGMSG("WUAUCLT dismiss %d dialogs", m_uNum);     
	         UINT uNum = m_uNum; //extra variable needed because m_uNum will change once a dialog is dismissed
	         HWND hwnds[ARRAYSIZE(m_hwnds)];
	         
                for (UINT u = 0; u < uNum; u++)
                    {
                    		hwnds[u] = m_hwnds[u];
                	}
                for (UINT u = 0; u < uNum; u++)
                	{
#ifdef DBG
//			   TCHAR buf[100];
//			   GetWindowText(hwnds[u], buf, 100);
//                    	   DEBUGMSG("Dismiss dialog %S", buf);
#endif                    	   
                        EndDialog(hwnds[u], S_OK);
                    }
                m_uNum = 0;
                ZeroMemory(m_hwnds, sizeof(m_hwnds));
            }
private:
        UINT m_uNum; //number of top wuauclt windows
        HWND m_hwnds[2]; //maximum 2 top windows at the same time
};



#define QUITAUClient() { PostMessage(ghMainWindow, WM_CLOSE, 0, 0); }

// Global Data Items
extern CAUInternals*	gInternals;	
extern UINT guExitProcess;
extern CRITICAL_SECTION gcsClient; 
extern LPCTSTR gtszAUSchedInstallUrl;
extern LPCTSTR gtszAUPrivacyUrl;


// Global UI Items
extern HINSTANCE	ghInstance;
extern HFONT		ghHeaderFont;
extern HWND			ghMainWindow;
extern HWND			ghCurrentDialog;
extern HWND			ghCurrentMainDlg;
extern AUCLTTopWindows	gTopWins;
extern HMENU		ghCurrentMenu;
extern HMENU		ghPauseMenu;
extern HMENU		ghResumeMenu;
extern HICON		ghAppIcon;
extern HICON		ghAppSmIcon;
extern HICON		ghTrayIcon;
extern HHOOK		ghHook;
extern HACCEL		ghCurrentAccel;
extern HCURSOR ghCursorHand;
extern HCURSOR ghCursorNormal;
//extern AUCatalogItemList gItemList;



struct ReminderItem
{
	DWORD timeout;
	WORD stringResId;
};

//IMPORTANT: Change constants below if you change ReminderItems constant
extern const ReminderItem ReminderTimes[];

typedef enum tagTIMEOUTINDEX
{
	TIMEOUT_INX_MIN			= 0,
	TIMEOUT_INX_THIRTY_MINS = 0,
	TIMEOUT_INX_ONE_HOUR	= 1,
	TIMEOUT_INX_TWO_HOURS	= 2,
	TIMEOUT_INX_FOUR_HOURS	= 3,
	TIMEOUT_INX_TOMORROW	= 4,
	TIMEOUT_INX_THREE_DAYS	= 5,
	TIMEOUT_INX_COUNT		= 6
} TIMEOUTINDEX;

extern LRESULT CALLBACK MainWndProc(HWND, UINT, WPARAM, LPARAM);	
extern void InitTrayIcon();
extern void UninitPopupMenus();
extern BOOL ShowTrayIcon();
extern void ShowTrayBalloon(WORD, WORD, WORD );
//extern void AddTrayToolTip(WORD tip);
extern void RemoveTrayIcon();
extern void ShowProgress();
extern void QuitNRemind(TIMEOUTINDEX enTimeoutIndex);
extern LPTSTR ResStrFromId(UINT uStrId);
extern UINT ControlId2StringId(UINT uCtrlId);

extern LRESULT CALLBACK AUTranslatorProc(int code, WPARAM wParam, LPARAM lParam);
extern INT_PTR CALLBACK InstallDlgProc(HWND, UINT, WPARAM, LPARAM);
extern INT_PTR CALLBACK SummaryDlgProc(HWND, UINT, WPARAM, LPARAM);
extern INT_PTR CALLBACK DetailsDlgProc(HWND, UINT, WPARAM, LPARAM);
extern INT_PTR CALLBACK ProgressDlgProc(HWND, UINT, WPARAM, LPARAM);
extern INT_PTR CALLBACK SettingsDlgProc(HWND, UINT, WPARAM, LPARAM);
extern INT_PTR CALLBACK InstallCompleteDlgProc(HWND, UINT, WPARAM, LPARAM);
extern INT_PTR CALLBACK RestartDlgProc(HWND, UINT, WPARAM, LPARAM);
extern INT_PTR CALLBACK WizardFrameProc(HWND, UINT, WPARAM, LPARAM);
extern INT_PTR CALLBACK WelcomeDlgProc(HWND, UINT, WPARAM, LPARAM);
extern INT_PTR CALLBACK NotificationOptionsDlgProc(HWND, UINT, WPARAM, LPARAM);
extern INT_PTR CALLBACK SetupCompleteDlgProc(HWND, UINT, WPARAM, LPARAM);
extern INT_PTR CALLBACK DownloadDlgProc(HWND, UINT, WPARAM, LPARAM);
extern INT_PTR CALLBACK ReminderDlgProc(HWND, UINT, WPARAM, LPARAM);
extern INT_PTR CALLBACK SetupCancelDlgProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
inline void ShowSettingsDlg(HWND hWndOwner)
{
	DialogBoxParam(ghInstance, MAKEINTRESOURCE(IDD_SETTINGS), hWndOwner, SettingsDlgProc, (LPARAM)ghInstance);
}

void	SetClientExitCode(UINT uExitCode);
inline UINT   GetClientExitCode()
{
	return guExitProcess;
}

extern LRESULT CALLBACK CustomLBWndProc(HWND, UINT, WPARAM, LPARAM);
extern BOOL fDisableSelection(void);
//extern void SaveSelection();

//Index for the events in main loop
const ISTATE_CHANGE		= 0;
const IMESSAGE			= 1;
const CNUM_EVENTS		= 1;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\wuaucpl\main.cpp ===
#include "stdafx.h"
#include "wuaucpl.h"
#include "resource.h"

BOOL APIENTRY DllMain( HINSTANCE hInstance, DWORD  ul_reason_for_call,LPVOID lpReserved);
LONG CALLBACK CPlApplet(HWND hWnd, UINT uMsg, LONG lParam1, LONG lParam2);

CWUAUCpl g_wuaucpl(IDI_ICONWU, IDS_STR_NAME, IDS_STR_DESC);

BOOL APIENTRY DllMain( HINSTANCE hInstance, 
                       DWORD  ul_reason_for_call, 
                       LPVOID lpReserved
					 )
{
	if (ul_reason_for_call == DLL_PROCESS_ATTACH)
	{
		CWUAUCpl::SetInstanceHandle(hInstance);
	}
	return TRUE;
}

LONG CALLBACK CPlApplet( HWND hWnd, UINT uMsg, LONG lParam1, LONG lParam2 )
{
   LONG result = 0;

   switch( uMsg )
   {
      case CPL_INIT :                  // Applet initialisation 
         result = g_wuaucpl.Init();
      break;

      case CPL_GETCOUNT :              // How many applets in the DLL?
         result = g_wuaucpl.GetCount();
      break;

	  case CPL_INQUIRE:				      //  Tell Control Panel about this applet
         result = g_wuaucpl.Inquire(lParam1, (LPCPLINFO)((LONG_PTR)lParam2));
      break;

      case CPL_DBLCLK :                //  If applet icon is selected...
         result = g_wuaucpl.DoubleClick(hWnd, lParam1, lParam2);
	  break;

      case CPL_STOP :                  // Applet shutdown
         result = g_wuaucpl.Stop(lParam1, lParam2);
      break;

      case CPL_EXIT :                  // DLL shutdown
         result = g_wuaucpl.Exit();
      break;

	  default:
	  break;
	}

   return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\wuaucpl\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__8CBA5209_964A_468F_BF0D_E3470D69C834__INCLUDED_)
#define AFX_STDAFX_H__8CBA5209_964A_468F_BF0D_E3470D69C834__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <windows.h>
#include <tchar.h>

#define _RICHEDIT_VER 0x0200

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__8CBA5209_964A_468F_BF0D_E3470D69C834__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\wuauclt\wuauclt.cpp ===
#include "pch.h"
#pragma hdrstop

#define MAINWINDOW_CURSOR   IDC_ARROW
#define RESOURCE_STRING_MAX_LENGTH      100

TCHAR AU_WINDOW_CLASS_NAME[] =  _T("Auto Update Client Window");
const TCHAR gtszAUW2KPrivacyUrl[]= _T("..\\help\\wuauhelp.chm::/w2k_autoupdate_privacy.htm");
const TCHAR gtszAUXPPrivacyUrl[]= _T("..\\help\\wuauhelp.chm::/autoupdate_privacy.htm");

const ReminderItem ReminderTimes[TIMEOUT_INX_COUNT] = 
{ 
    { 1800, IDS_THIRTY_MINUTES },
    { 3600, IDS_ONE_HOUR },
    { 7200, IDS_TWO_HOURS },
    { 14400, IDS_FOUR_HOURS },
    { 86400, IDS_TOMORROW },
    { 259200, IDS_THREE_DAYS }
};

const UINT RESOURCESTRINGINDEX[] = {
    IDS_NOTE,
    IDS_WELCOME_CONTINUE,
    IDS_EULA,
    IDS_PRIVACY,
    IDS_LEARNMORE,
    IDS_LEARNMOREAUTO
};


// Global Data Items
CAUInternals*   gInternals; 
AUClientCatalog *gpClientCatalog ; //= NULL
TCHAR gResStrings[ARRAYSIZE(RESOURCESTRINGINDEX)][RESOURCE_STRING_MAX_LENGTH]; 
// Global UI Items
CRITICAL_SECTION gcsClient; // guard guard user's tray interaction (showing, not showing) and guard customlb data
HINSTANCE   ghInstance;
HFONT       ghHeaderFont;
HCURSOR     ghCursorHand;
HCURSOR     ghCursorNormal; // cursor of main window

HMODULE     ghRichEd20;
HANDLE      ghEngineState;
HWND        ghMainWindow;
HWND        ghCurrentDialog;
HWND        ghCurrentMainDlg;
AUCLTTopWindows gTopWins;
UINT        gNextDialogMsg;
BOOL        gbOnlySession; // = FALSE;
BOOL             gfShowingInstallWarning; // = FALSE;

HMENU       ghPauseMenu;
HMENU       ghResumeMenu;
HMENU       ghCurrentMenu;
HICON       ghAppIcon;
HICON       ghAppSmIcon;
HICON       ghTrayIcon;
UINT        guExitProcess=CDWWUAUCLT_UNSPECIFY;

LPCTSTR      gtszAUSchedInstallUrl;
LPCTSTR      gtszAUPrivacyUrl;

AU_ENV_VARS gAUEnvVars;


// No critical section used to access the following variables.
// Should them only in WinMain/MainWndProc thread.
HANDLE g_hClientNotifyEvt = NULL; //the event Engine use to notify client
HANDLE g_hRegisterWait = NULL;
BOOL g_fCoInit = FALSE;
BOOL g_fcsInit = FALSE;
BOOL g_fAlreadyUninit = FALSE;


/****
Helper function to simplify window class registration.
*****/
ATOM AURegisterWindowClass(WNDPROC lpWndProc, LPTSTR lpClassName)
{
    WNDCLASSEX wcex;

    ZeroMemory(&wcex, sizeof(wcex));
    
    wcex.cbSize = sizeof(WNDCLASSEX); 
    wcex.style          = CS_HREDRAW | CS_VREDRAW;
    wcex.lpfnWndProc    = lpWndProc;
//    wcex.cbClsExtra     = 0;
//    wcex.cbWndExtra     = 0;
//    wcex.lpszMenuName   = NULL;
//    wcex.hIcon          = NULL; 
//    wcex.hIconSm        = NULL; 
    wcex.hInstance      = ghInstance;
    wcex.hCursor        = LoadCursor(NULL, MAINWINDOW_CURSOR);
    wcex.hbrBackground  = (HBRUSH)(COLOR_WINDOW+1);
    wcex.lpszClassName  = lpClassName;

    return RegisterClassEx(&wcex);
}


///////////////////////////////////////////////////////////////////
// map string id to its storage in the gResStrings
///////////////////////////////////////////////////////////////////
LPTSTR ResStrFromId(UINT uStrId)
{
    for (int i = 0; i < ARRAYSIZE(RESOURCESTRINGINDEX); i++)
    {
        if (RESOURCESTRINGINDEX[i] == uStrId)
        {
            return gResStrings[i];
        }
    }
    return NULL;
}

////////////////////////////////////////////////////////
//  Set reminder timeout and state and quit
////////////////////////////////////////////////////////
void QuitNRemind(TIMEOUTINDEX enTimeoutIndex)
{
    AUSTATE     auState;
    if (FAILED(gInternals->m_getServiceState(&auState)))
    {
        goto done;
    }
    if (FAILED(gInternals->m_setReminderTimeout(enTimeoutIndex)))
    {
        goto done;
    }
    gInternals->m_setReminderState(auState.dwState);
done:
    QUITAUClient();
}



////////////////////////////////////////////////////////////////////////////
//
// Helper Function  HrQuerySessionConnectState(int iAdminSession, int *piConState)
//          helper function to get the Session Connection State
//
// Input:   int iAdminSession   Session Admin ID
// Output:  int *piConState     Conection state
// Return:  HRESULT value. If Failed, *piConState is unspecified
////////////////////////////////////////////////////////////////////////////
HRESULT HrQuerySessionConnectState(int iAdminSession, int *piConState)
{
    LPTSTR  pBuffer = NULL;             
    HRESULT hr = NO_ERROR;
    DWORD dwBytes;

    if (AUIsTSRunning())
    {
        
        if (WTSQuerySessionInformation(WTS_CURRENT_SERVER_HANDLE, iAdminSession, WTSConnectState, 
            &pBuffer, &dwBytes))
        {
            *piConState = (int) *pBuffer;   //Because we are asking for WTSConnectState, pBuffer points to an int
            WTSFreeMemory(pBuffer);
            hr = NO_ERROR;
        }
        else
        {
            DEBUGMSG("WUAUCLT: WTSQuerySessionInformation failed: %lu", GetLastError());
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }
    else 
    {
        DWORD dwSession = iAdminSession;
        
        if (dwSession == WTS_CURRENT_SESSION)
            ProcessIdToSessionId(GetCurrentProcessId(), &dwSession);
        
        // if we're launched & TS is not up, we've gotta be an active session.
        if (dwSession == 0)
        {
            DEBUGMSG("WUAUCLT: TS is not running or not installed.  Assuming session 0 is active.");
            gbOnlySession = TRUE;
            *piConState = WTSActive;
        }
        else
        {
            DEBUGMSG("WUAUCLT: TS is not running or not installed, but a non 0 session was asked for (session %d).  Failing call.", iAdminSession);
            hr = E_FAIL;
        }
    }
    
    return hr;
}
BOOL FCurrentSessionInActive()
{
    BOOL fRet = FALSE;
    HRESULT hr;
    int iConState;

    if (gbOnlySession)
    {
           DEBUGMSG("FCurrentSessionInActive() Only one session");
        goto Done;
    }
        
    //Check if the Current Session is Inactive
    hr = HrQuerySessionConnectState(WTS_CURRENT_SESSION, &iConState);

    if (SUCCEEDED(hr))
    {
        fRet = (WTSDisconnected == iConState);
    }
    else
    {
        if (RPC_S_INVALID_BINDING == GetLastError()) //Terminal Services are disabled, this is session 0
        {
            DEBUGMSG("FCurrentSessionInActive() TS disabled");
            gbOnlySession = TRUE;
        }
        else
        {       
            DEBUGMSG("FCurrentSessionInActive() HrQuerySessionConnectState failed %#lx =",hr);
        }
    }
Done:
//       DEBUGMSG("FCurrentSessionInActive() return %s", fRet ? "TRUE" : "FALSE");
    return fRet;
}


//////////////////////////////////////////////////////////////////////////////
// BuildClientCatalog
//
// Do online detection of the catalog and build up the wuv3is.dll detection state
// inside this process.  Validation is done during this process with the catalog file
// previously written by the engine.
//
//////////////////////////////////////////////////////////////////////////////
HRESULT BuildClientCatalog(void)
{
    HRESULT hr = S_OK;

    DEBUGMSG("BuildClientCatalog() starts");
    if ( NULL == gpClientCatalog )
    {
        gpClientCatalog = new AUClientCatalog();
        if ( NULL != gpClientCatalog )
        {
            if ( FAILED(hr = gpClientCatalog->Init()) )
            {
                goto done;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }

    // change to: hr = gpClientCatalog->LoadInstallXML();

done:
       DEBUGMSG("BuildClientCatalog() ends");
    return hr;
}

void DismissUIIfAny()
{
    gTopWins.Add(ghCurrentMainDlg);
    gTopWins.Dismiss();

	// Don't leave any popup menu around when dismissing dialogs.
	if (SendMessage(ghMainWindow, WM_CANCELMODE, 0, 0))
	{
		DEBUGMSG("WUAUCLT WM_CANCELMODE was not handled");
	}
}


void ResetAUClient(void)
{
    DismissUIIfAny();
    RemoveTrayIcon();
    gfShowingInstallWarning = FALSE;
    gNextDialogMsg = NULL;
    ghCurrentMenu = NULL;
}


void ShowInstallWarning()
{ //dismiss current dialog if any
    DEBUGMSG("ShowInstallWarning() starts");
    gfShowingInstallWarning = TRUE;
    gNextDialogMsg = NULL;
    ghCurrentMenu = NULL;
    CPromptUserDlg PromptUserDlg(IDD_START_INSTALL);
	PromptUserDlg.SetInstanceHandle(ghInstance);
    INT iRet = PromptUserDlg.DoModal(NULL);
    DEBUGMSG("WUAUCLT ShowInstallWarning dlg return code is %d", iRet);
    if (IDYES == iRet || AU_IDTIMEOUT == iRet)
    {
        SetClientExitCode(CDWWUAUCLT_INSTALLNOW);
        QUITAUClient();
    }
    else //if (retVal == IDNO)
    {
            gNextDialogMsg = AUMSG_SHOW_INSTALL;
    }
    gfShowingInstallWarning = FALSE;
    DEBUGMSG("ShowInstallWarning() ends");
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
// fEnableYes: IN whether yes button should be enabled
// fEnableNo: IN whether no button should be enabled
// fManualReboot: IN show countdown progress bar if NOT manual
// dwElapsedTime: IN how many secs passed since count down starts, only used when fManualReboot is set false
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
void ShowRebootWarning(BOOL fEnableYes, BOOL fEnableNo, BOOL fManualReboot, DWORD dwElapsedTime)
{
    DEBUGMSG("ShowRebootWarning() starts");
	INT iRet;
    CPromptUserDlg PromptUserDlg(IDD_PROMPT_RESTART, fEnableYes, fEnableNo, fManualReboot, dwElapsedTime);

	PromptUserDlg.SetInstanceHandle(ghInstance);
	iRet = PromptUserDlg.DoModal(NULL);
    if (IDYES == iRet)
    {
        SetClientExitCode(CDWWUAUCLT_REBOOTNOW);
    }
	else if (IDNO == iRet)
	{
        SetClientExitCode(CDWWUAUCLT_REBOOTLATER);
    }
	else  //if (IDTIMEOUT == iRet)
	{
		SetClientExitCode(CDWWUAUCLT_REBOOTTIMEOUT);
	}
	
    QUITAUClient();
    DEBUGMSG("ShowRebootWarning() ends with return code %d", iRet);
    DEBUGMSG("ShowRebootWarning() set client exit code to be %d", GetClientExitCode());
}

VOID CALLBACK WaitCallback(PVOID lpParameter,  BOOLEAN /*fTimerOrWaitFired*/ )
{
    // fTimerOrWaitFired is always false - We can't time out with INFINATE wait

	BOOL fRebootWarningMode = (BOOL) PtrToInt(lpParameter);
	if (fRebootWarningMode)
	{
		DEBUGMSG("WUAUCLT got exit signal from engine");
		QUITAUClient();
		return ;
	}
    
    // ClientNotify event was fired
    CLIENT_NOTIFY_DATA notifyData;
    BOOL fCoInit = SUCCEEDED(CoInitializeEx(NULL, COINIT_APARTMENTTHREADED));
    
    if ( !fCoInit )
    {
        DEBUGMSG("WUAUCLT WaitCallback CoInitialize failed");
        goto Done;
    }

    IUpdates * pUpdates = NULL;
    HRESULT hr = CoCreateInstance(__uuidof(Updates),
                     NULL,
                     CLSCTX_LOCAL_SERVER,
                     IID_IUpdates,
                     (LPVOID*)&pUpdates);
    if (FAILED(hr))
    {
        DEBUGMSG("WaitCallback failed to get Updates object");
        goto Done;
    }
    if (FAILED(hr = pUpdates->GetNotifyData(&notifyData)))
    {
        DEBUGMSG("WaitCallback fail to get NotifyData %#lx", hr);
        goto Done;
    }
    switch (notifyData.actionCode)
    {
    case NOTIFY_STOP_CLIENT:
    case NOTIFY_RELAUNCH_CLIENT:
        if (NOTIFY_RELAUNCH_CLIENT == notifyData.actionCode)
        {
            DEBUGMSG("WaitCallback() notify client to relaunch");
            SetClientExitCode(CDWWUAUCLT_RELAUNCHNOW);
        }
        else
        {
            DEBUGMSG("WaitCallback() notify client to stop");
            SetClientExitCode(CDWWUAUCLT_OK);
        }
        if (NULL != ghMutex)
        {
            WaitForSingleObject(ghMutex, INFINITE);
            if (NULL != gpClientCatalog)
            {
                gpClientCatalog->CancelNQuit();
            }
            else
            {
                DEBUGMSG("No need to cancel catalag");
            }
            ReleaseMutex(ghMutex);
        }
        QUITAUClient(); 
        break;
    case NOTIFY_RESET: //reprocess state and option and show UI accordingly
        ResetAUClient();
        SetEvent(ghEngineState);
        break;
    case NOTIFY_ADD_TRAYICON:
        DEBUGMSG("WaitCallback()  notify client to show tray icon");
        ShowTrayIcon();
        ghCurrentMenu = ghPauseMenu; //the job is now downloading
        break;
    case NOTIFY_REMOVE_TRAYICON:
        DEBUGMSG("WaitCallback() notify client to remove tray icon");
        RemoveTrayIcon();
        break;
    case NOTIFY_STATE_CHANGE:
        DEBUGMSG("WaitCallback() notify client of state change");
        SetEvent(ghEngineState);
        break;
    case NOTIFY_SHOW_INSTALLWARNING:
        DEBUGMSG("WaitCallback() notify client to show install warning");
        if (!gfShowingInstallWarning)
        { //install warning dialog is not up, prevent install warning dialog torn down before it expires when secsinaday low
            DismissUIIfAny();
            PostMessage(ghMainWindow, AUMSG_SHOW_INSTALLWARNING, 0, 0);
        }
        break;
    }
Done:
    SafeRelease(pUpdates);
    if (fCoInit)
    {
        CoUninitialize();
    }
}

BOOL ProcessEngineState()
{
    AUSTATE AuState;
    BOOL fResult = TRUE;

    DEBUGMSG("WUAUCLT starts ProcessEngineState()");
    ghCurrentMenu = NULL;

    if (FAILED(gInternals->m_getServiceState(&AuState)))
    {
        DEBUGMSG("WUAUCLT : quit because m_getServiceState failed");       
        SetClientExitCode(CDWWUAUCLT_FATAL_ERROR);
        fResult = FALSE;
        goto Done;
    }
    
    DEBUGMSG("WUAUCLT process Engine state %lu",AuState.dwState);
    switch(AuState.dwState)
    {
        case AUSTATE_NOT_CONFIGURED:
            if(gNextDialogMsg != AUMSG_SHOW_WELCOME && ghCurrentMainDlg == NULL )
            {
                if (ShowTrayIcon())
                {
                    ShowTrayBalloon(IDS_WELCOMETITLE, IDS_WELCOMECAPTION, IDS_WELCOMETITLE);
                    gNextDialogMsg = AUMSG_SHOW_WELCOME;
                }
            }
            break;
        case AUSTATE_DETECT_COMPLETE:
            if ( FAILED(gInternals->m_getServiceUpdatesList()) )
            {
                DEBUGMSG("WUAUCLT : quit because m_getServiceUpdatesList failed");
                SetClientExitCode(CDWWUAUCLT_FATAL_ERROR);
                fResult = FALSE;
                break;
            }

           {
                AUOPTION auopt;

                if (SUCCEEDED(gInternals->m_getServiceOption(&auopt)) && 
                    (AUOPTION_INSTALLONLY_NOTIFY == auopt.dwOption || AUOPTION_SCHEDULED == auopt.dwOption))
                {
                    // user option is auto download, start download
                    //ShowTrayIcon();    
                    
                    // do download right away without dialogs if user options set to notify for just install
                    if (FAILED(gInternals->m_startDownload()))
                    {
                        QUITAUClient();
                    }
                    else
                    {
//                            ghCurrentMenu = ghPauseMenu;
                    }
                    break;
                }
                
                if(gNextDialogMsg != AUMSG_SHOW_DOWNLOAD && ghCurrentMainDlg == NULL)
                {
                    if (ShowTrayIcon())
                    {
                        ShowTrayBalloon(IDS_DOWNLOADTITLE, IDS_DOWNLOADCAPTION, IDS_DOWNLOADTITLE);
                                        gNextDialogMsg = AUMSG_SHOW_DOWNLOAD;
                    }
                }   
                break;                  
            }
            
        case AUSTATE_DOWNLOAD_COMPLETE:
            if (AUCLT_ACTION_AUTOINSTALL == AuState.dwCltAction)
            { // engine initiated install: auto install
                HRESULT hr;
                DEBUGMSG("Auto install ...");
                if ( S_OK !=(hr = BuildClientCatalog()))
                {
                    DEBUGMSG("WUAUCLT fail to build client catalog with error %#lx, exiting, hr");
                    SetClientExitCode(CDWWUAUCLT_FATAL_ERROR);
                    fResult = FALSE;
                    break;
                }
                if (FAILED(hr = gInternals->m_startInstall(TRUE)))
                {
                    DEBUGMSG("Fail to post install message with error %#lx", hr);
                    fResult = FALSE;
                    break;
                }
                gpClientCatalog->m_WrkThread.WaitUntilDone();
                if (gpClientCatalog->m_fReboot)
                {
                    SetClientExitCode(CDWWUAUCLT_REBOOTNEEDED);
                }
                else
                {
                    SetClientExitCode(CDWWUAUCLT_OK);
                }
                QUITAUClient();
                break;
            }
            else
            { //show preinstall dialog and let user initiate install
                HRESULT hr;
                DEBUGMSG("Prompt for manual install");
                if ( FAILED(gInternals->m_getServiceUpdatesList()))
                {
                    DEBUGMSG("WUAUCLT : quit because m_getServiceUpdatesList failed");
                    SetClientExitCode(CDWWUAUCLT_FATAL_ERROR);
                    fResult = FALSE;
                    break;
                }

           
                if ( S_OK !=(hr = BuildClientCatalog()) )
                {
                    DEBUGMSG("WUAUCLT fail to build client catalog with error %#lx, exiting", hr);
                    SetClientExitCode(CDWWUAUCLT_FATAL_ERROR);
                    fResult = FALSE;
                }
                else if(gNextDialogMsg != AUMSG_SHOW_INSTALL && ghCurrentMainDlg == NULL)
                {
                    if (ShowTrayIcon())
                    {
                        ShowTrayBalloon(IDS_INSTALLTITLE, IDS_INSTALLCAPTION, IDS_INSTALLTITLE);
                        gNextDialogMsg = AUMSG_SHOW_INSTALL;
                    }
                }
                break;
            }   
            
        case AUSTATE_DOWNLOAD_PENDING:                  
            {                                       
                UINT nPercentComplete = 0;
                DWORD dwStatus;
                
                //if drizzle got transient error, quit client
                //fixcode: why quit if transient error?
                if (AuState.fDisconnected)
                {
                    DEBUGMSG("WUAUCLT : quit because of lost of connection, fDisconnected = %d",AuState.fDisconnected);
                    fResult = FALSE;        
                    break;
                }
                if (FAILED(gInternals->m_getDownloadStatus(&nPercentComplete, &dwStatus)))
                {
                    DEBUGMSG("WUAUCLT : quit because m_getDownloadStatus failed");
                    fResult = FALSE;
                    break;
                }

                if (DWNLDSTATUS_CHECKING_CONNECTION == dwStatus) 
                {
                    //hide tray icon 
                    DEBUGMSG("WUAUCLT Waiting for engine to find connection first");
//                    RemoveTrayIcon();
//                    ghCurrentMenu = NULL;
                }
                else if(dwStatus == DWNLDSTATUS_DOWNLOADING) 
                {
					ghCurrentMenu = ghPauseMenu;
                    DEBUGMSG("WUAUCLT in active downloading state");
                    ShowTrayIcon();                         
                }
                else if(dwStatus == DWNLDSTATUS_PAUSED)
                {
                    ghCurrentMenu = ghResumeMenu;
                    DEBUGMSG("WUAUCLT in download paused state");
                    if (fDisableSelection() &&
						FAILED(gInternals->m_setDownloadPaused(FALSE)))
                    {
//                        QUITAUClient(); //let wuaueng to figure out problem and recover
                    }
                    ShowTrayIcon();
                }
                else //not downloading
                {
                    DEBUGMSG("WUAUCLT WARNING: not downloading while in download pending state");
                }              
            }
            break;                  
            
        case AUSTATE_DETECT_PENDING:
            //Quit only if the Install UI has been accepted or there is no InstallUI
            if (NULL == ghCurrentMainDlg)
            {                       
                QUITAUClient();
            }
            break;
            
        case AUSTATE_DISABLED:
            QUITAUClient();
            break;

        case AUSTATE_INSTALL_PENDING:
        default:
            // outofbox and waiting_for_reboot are here. WUAUCLT should not be launched in these states
            DEBUGMSG("WUAUCLT AUSTATE = %lu", AuState.dwState);
            break;
    }
Done:
    DEBUGMSG("WUAUCLT exits ProcessEngineState()");
    return fResult; 
}

BOOL InitUIComponents(HINSTANCE hInstance)
{
    INITCOMMONCONTROLSEX icex;
    icex.dwSize = sizeof(INITCOMMONCONTROLSEX);
    icex.dwICC = 0;     //We dont need to register any control classes
	if (!InitCommonControlsEx(&icex))  //needed for theming
    {
        DEBUGMSG("InitUIComponents :InitCommonControlsEx failed");
        return FALSE;
    }

	//we need to load riched20.dll to register the class
	ghRichEd20  = LoadLibraryFromSystemDir(_T("RICHED20.dll"));
	if (NULL == ghRichEd20)
	{
	    return FALSE;
	}

	ghCursorHand = LoadCursor(NULL, IDC_HAND);
	ghCursorNormal = LoadCursor(NULL, MAINWINDOW_CURSOR); //change if main window's cursor does
	if (NULL == ghCursorHand)
	{
	  DEBUGMSG("WUAUCLT fail to load hand cursor");
	  ghCursorHand = ghCursorNormal;
	}

	ghAppIcon = (HICON) LoadImage(hInstance, MAKEINTRESOURCE(IDI_AUICON), IMAGE_ICON, NULL, NULL, LR_DEFAULTSIZE | LR_CREATEDIBSECTION);
	ghAppSmIcon = (HICON) LoadImage(hInstance, MAKEINTRESOURCE(IDI_AUICON), IMAGE_ICON, GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON), LR_CREATEDIBSECTION);

	if (IsWin2K())
	{
		//Win2k
		ghTrayIcon = (HICON) LoadImage(hInstance, MAKEINTRESOURCE(IDI_AUSYSTRAYICON), IMAGE_ICON, 16, 16, 0);
	}
	else
	{
		//WindowsXP
		ghTrayIcon = (HICON) LoadImage(hInstance, MAKEINTRESOURCE(IDI_AUICON), IMAGE_ICON, 16, 16, LR_CREATEDIBSECTION);
	}
		
	for (int i = 0; i < ARRAYSIZE(RESOURCESTRINGINDEX); i++)
	{
	    LoadString(hInstance, RESOURCESTRINGINDEX[i], ResStrFromId(RESOURCESTRINGINDEX[i]), RESOURCE_STRING_MAX_LENGTH);    
	}

	ghCurrentAccel = LoadAccelerators(ghInstance, MAKEINTRESOURCE(IDA_BASE));
	gtszAUSchedInstallUrl = IsWin2K() ? gtszAUW2kSchedInstallUrl : gtszAUXPSchedInstallUrl;
	gtszAUPrivacyUrl = IsWin2K() ? gtszAUW2KPrivacyUrl : gtszAUXPPrivacyUrl;

	return TRUE;
}


BOOL InitializeAUClientForRebootWarning(HINSTANCE hInstance, 
	OUT HANDLE *phRegisterWait, 
	OUT HANDLE *phClientNotifyEvt,
	OUT BOOL *pfCoInit)
{
	TCHAR buf[100];

    SetClientExitCode(CDWWUAUCLT_UNSPECIFY);
	*phRegisterWait = NULL;
	*pfCoInit = FALSE;
	*phClientNotifyEvt = OpenEvent(SYNCHRONIZE, FALSE, gAUEnvVars.m_szClientExitEvtName);
	if (NULL == *phClientNotifyEvt)
	{
		DEBUGMSG("WUAUCLT fail to open client exit event %S with error %d", gAUEnvVars.m_szClientExitEvtName, GetLastError());
		return FALSE;
	}


	INITCOMMONCONTROLSEX icex;
    icex.dwSize = sizeof(INITCOMMONCONTROLSEX);
    icex.dwICC = 0;     //We dont need to register any control classes
	if (!InitCommonControlsEx(&icex))  //needed for theming
    {
        DEBUGMSG("InitCommonControlsEx failed");
        return FALSE;
    }

	if (!RegisterWaitForSingleObject(phRegisterWait,               // wait handle
        *phClientNotifyEvt, // handle to object
        WaitCallback,                   // timer callback function
        (PVOID)1,                           // callback function parameter
        INFINITE,                       // time-out interval
        WT_EXECUTEONLYONCE               // options
        ))
	{
	    DEBUGMSG("WUAUCLT RegisterWaitForSingleObject failed %lu",GetLastError());
	    *phRegisterWait = NULL;
	    return FALSE;
	}
    ghInstance = hInstance;

	return TRUE;
}

BOOL InitializeAUClient(HINSTANCE hInstance,
     OUT  HANDLE * phRegisterWait,
     OUT  HANDLE * phClientNotifyEvt,
     OUT  BOOL *pfCoInit,
     OUT  BOOL *pfcsInit)
{   
        HRESULT hr;
    *pfcsInit = FALSE;
    *phClientNotifyEvt = NULL;
    *phRegisterWait = NULL;
    SetClientExitCode(CDWWUAUCLT_UNSPECIFY);
    *pfCoInit = SUCCEEDED(CoInitializeEx(NULL, COINIT_APARTMENTTHREADED));
    
    if ( !*pfCoInit )
    {
        DEBUGMSG("WUAUCLT WinMain CoInitialize failed");
        return FALSE;
    }

    if (!InitUIComponents(hInstance))
    {
    	DEBUGMSG("WUAUCLT fail to initialize UI components");
    	return FALSE;
    }

    if (NULL == (ghMutex = CreateMutex(NULL, FALSE, NULL)))
    {
        DEBUGMSG("WUAUCLT fail to create global mutex");
        return FALSE;
    }

    
    gInternals = NULL;
    
    if ( (NULL == (ghEngineState = CreateEvent(NULL, FALSE, FALSE, NULL))) )
    {
    	DEBUGMSG("WUAUCLT fails to create event");
        return FALSE;
    }

    ghInstance = hInstance;

    if (!(*pfcsInit = SafeInitializeCriticalSection(&gcsClient)))
    {
    	DEBUGMSG("WUAUCLT fails to initialize critical section");
        return FALSE;
    }

#ifndef TESTUI

    if (! (gInternals = new CAUInternals()))
    {
    	DEBUGMSG("WUAUCLT fails to create auinternals object");
        return FALSE;
    }

    if (FAILED(hr = gInternals->m_Init()))
    {
        DEBUGMSG("WUAUCLT failed in CoCreateInstance of service with error %#lx, exiting", hr);
        return FALSE;
    }           

    AUEVTHANDLES AuEvtHandles;
    ZeroMemory(&AuEvtHandles, sizeof(AuEvtHandles));
    if (FAILED(hr = gInternals->m_getEvtHandles(GetCurrentProcessId(), &AuEvtHandles)))
    {
        DEBUGMSG("WUAUCLT failed in m_getEvtHandles with error %#lx, exiting", hr);
        return FALSE;
    }
	*phClientNotifyEvt = (HANDLE)AuEvtHandles.ulNotifyClient;

    if (!RegisterWaitForSingleObject( phRegisterWait,               // wait handle
        *phClientNotifyEvt, // handle to object
        WaitCallback,                   // timer callback function
        0,                           // callback function parameter
        INFINITE,                       // time-out interval
        WT_EXECUTEDEFAULT               // options
        ))
    {
        DEBUGMSG("WUAUCLT RegisterWaitForSingleObject failed %lu",GetLastError());
        *phRegisterWait = NULL;
        return FALSE;
    }
        
#endif

    return TRUE;
}


void UninitializeAUClient(HANDLE hRegisterWait, HANDLE hClientNotifyEvt, BOOL fCoInit, BOOL fcsInit)
{

	if (g_fAlreadyUninit)
	{
		return;
	}
	g_fAlreadyUninit = TRUE;


    RemoveTrayIcon();
    if (NULL != hRegisterWait)
    {
        if ( !UnregisterWaitEx(hRegisterWait, INVALID_HANDLE_VALUE) )
        {
            DEBUGMSG("WUAUCLT: UnregisterWaitEx() failed, dw = %lu", GetLastError());
        }
    }
    if (NULL != ghRichEd20)
    {
        FreeLibrary(ghRichEd20);
		ghRichEd20 = NULL;
    }
	SafeCloseHandleNULL(hClientNotifyEvt);
	
	if (!gAUEnvVars.m_fRebootWarningMode)
	{
		//fixcode: is ghMainWindow a valid window here?
	    KillTimer(ghMainWindow, 1);
	    if (fcsInit)
	    {
	        DeleteCriticalSection(&gcsClient);
	    }
	    SafeDeleteNULL(gInternals);
	    SafeDeleteNULL(gpClientCatalog);   
	    SafeCloseHandleNULL(ghEngineState);
	    SafeCloseHandleNULL(ghMutex);
	}

    if ( fCoInit)
    {
        CoUninitialize();
    }
}
      	

int APIENTRY WinMain(HINSTANCE hInstance,
                     HINSTANCE /*hPrevInstance*/,
                     LPSTR     /*lpCmdLine*/,
                     int       /*nCmdShow*/)
{
    HANDLE rhEvents[CNUM_EVENTS];

    //Initialize the global pointing to WU Directory. (the directory should already exist)
    if(!CreateWUDirectory(TRUE))
    {
        //If we can not create WU directory, no point in continuing
        DEBUGMSG("WUAUCLT Fail to create WU directory");
        SetClientExitCode(CDWWUAUCLT_FATAL_ERROR);
        goto exit;
    }

	if (!gAUEnvVars.ReadIn())
	{
		DEBUGMSG("WUAUCLT fails to read in environment variables");
		SetClientExitCode(CDWWUAUCLT_FATAL_ERROR);
		goto exit;
	}
	
	if (gAUEnvVars.m_fRebootWarningMode)
	{
		DEBUGMSG("WUAUCLT starts in reboot warning mode");
		if (!InitializeAUClientForRebootWarning(hInstance, &g_hRegisterWait, &g_hClientNotifyEvt, &g_fCoInit))
		{
			SetClientExitCode(CDWWUAUCLT_FATAL_ERROR);
			goto exit;
		}
	}
	else
	{
		DEBUGMSG("WUAUCLT starts in regular mode");
	    if (!InitializeAUClient(hInstance, &g_hRegisterWait, &g_hClientNotifyEvt, &g_fCoInit, &g_fcsInit))
	    {
	        SetClientExitCode(CDWWUAUCLT_FATAL_ERROR);
	        goto exit;
	    }
	}

    DEBUGMSG("WUAUCLT initialization done");
    // Create the main window hidden
    if (!AURegisterWindowClass(MainWndProc, AU_WINDOW_CLASS_NAME))
    {
        goto exit;
    }
    if (!AURegisterWindowClass(CustomLBWndProc, _T("MYLB")))
    {
        goto exit;
    }
    if (!CreateWindow(AU_WINDOW_CLASS_NAME, AU_WINDOW_CLASS_NAME, WS_CAPTION,
        0, 0, 0, 0, NULL, NULL, hInstance, NULL))
    {
        goto exit;
    }

    ShowWindow(ghMainWindow, SW_HIDE);
    
#ifdef TESTUI
    {
        MSG msg;
        while(PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
        {
            if (WM_QUIT == msg.message )
            {
                // Set this event so the service does what every appropriate
                // If we don't do this, we might leave the service waiting for this event for 
                // some cases - for example, when the session in which the client leaves is deactivated or
                // when there is a log off
                //SetEvent(ghEngineState);                  
                goto exit;
            }
            TranslateMessage(&msg);
            DispatchMessage(&msg);          
        }
    }
#else
    {
    	// Run the main message loop
	    MSG msg;

    	if (gAUEnvVars.m_fRebootWarningMode)
    	{
              DWORD dwElapsedTime = (GetTickCount() - gAUEnvVars.m_dwStartTickCount) / 1000;
    		ShowRebootWarning(gAUEnvVars.m_fEnableYes, gAUEnvVars.m_fEnableNo, gAUEnvVars.m_fManualReboot, dwElapsedTime);
    	}
    	else
    	{
	        SetTimer(ghMainWindow, 1, dwTimeToWait(ReminderTimes[TIMEOUT_INX_FOUR_HOURS].timeout), NULL); //every 4 hours

	        DEBUGMSG("WUAUCLT Processing messages and being alert for Engine state change event");

	        rhEvents[ISTATE_CHANGE] = ghEngineState;
	        
	        while (1)
	        {
	            DWORD dwRet = MsgWaitForMultipleObjectsEx(CNUM_EVENTS, rhEvents, INFINITE, QS_ALLINPUT, MWMO_INPUTAVAILABLE);
	            
	            if (WAIT_OBJECT_0 + ISTATE_CHANGE == dwRet)                 //ghEngineState (ISTATE_CHANGE)
	            {
	                DEBUGMSG("WUAUCLT Engine changed state");
	                if (!ProcessEngineState())
	                {
	                    QUITAUClient();
	                }           
	            }
	            else if (WAIT_OBJECT_0 + IMESSAGE == dwRet)     // There is a message to process
	            {
	                while(PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
	                {
	                    if (g_fAlreadyUninit || WM_QUIT == msg.message)
	                    {         
	                        goto exit;
	                    }
	                    TranslateMessage(&msg);
	                    DispatchMessage(&msg);
	                }
					if (g_fAlreadyUninit)
					{
						goto exit;
					}
	            }   
	            else 
	            {
	                if (WAIT_ABANDONED_0 == dwRet)      //ghEngineState abandoned       
	                {
	                    DEBUGMSG("WUAUCLT quitting because engine state event was abandoned");          
	                }
	                else if (WAIT_FAILED == dwRet)               //MsgWaitForMultipleObjectsEx failed
	                {                   
	                    DEBUGMSG("WUAUCLT quitting because MsgWaitForMultipleObjectsEx() failed with last error = %lu", GetLastError());
	                }               
	                QUITAUClient();
	            }
	        }
    	}
    }
#endif

exit:
    DEBUGMSG("WUAUCLT Exiting");

    //if installation thread is live, wait until it finishes
    if (NULL != gpClientCatalog)
    {
    	gpClientCatalog->m_WrkThread.m_Terminate();
    }
    UninitializeAUClient(g_hRegisterWait, g_hClientNotifyEvt, g_fCoInit, g_fcsInit);

    if (CDWWUAUCLT_UNSPECIFY == GetClientExitCode())
    {
		SetClientExitCode(CDWWUAUCLT_OK);
    }
    DEBUGMSG("WUAUCLT exit code %d", GetClientExitCode());
    ExitProcess(GetClientExitCode());

    return 0;
}

LRESULT CALLBACK MainWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    AUSTATE AuState;

    switch(message)
    {
        case WM_CREATE:
        {
            LOGFONT     lFont;

            // initialize global ui variables
            ghMainWindow = hWnd;
            ghCurrentMainDlg = NULL;
            gNextDialogMsg = NULL;
            ghHeaderFont    = NULL;

            InitTrayIcon();

            HFONT hDefUIFont = (HFONT)GetStockObject(DEFAULT_GUI_FONT);
            //create header font
            ZeroMemory(&lFont, sizeof(lFont));
            lFont.lfWeight = FW_BOLD;
            lFont.lfCharSet = DEFAULT_CHARSET;
            lFont.lfOutPrecision = OUT_DEFAULT_PRECIS;
            lFont.lfClipPrecision = CLIP_DEFAULT_PRECIS;
            lFont.lfQuality = DEFAULT_QUALITY;
            lFont.lfPitchAndFamily = DEFAULT_PITCH | FF_DONTCARE;
            LoadString(ghInstance, IDS_HEADERFONT, lFont.lfFaceName, ARRAYSIZE(lFont.lfFaceName));
            ghHeaderFont = CreateFontIndirect(&lFont);
            if(ghHeaderFont == NULL) {
                DEBUGMSG("WUAUCLT fail to create Header Font, use default GUI font instead");
                ghHeaderFont = hDefUIFont;
            }
            //create underline font
            ZeroMemory(&lFont, sizeof(lFont));              
            GetObject(hDefUIFont, sizeof(lFont), &lFont);
            lFont.lfUnderline = TRUE;

            ghHook = SetWindowsHookEx(WH_MSGFILTER, AUTranslatorProc, ghInstance, GetCurrentThreadId());            
#ifdef TESTUI
            PostMessage(ghMainWindow, AUMSG_SHOW_WELCOME, 0, 0);
#else
#endif
            return 0;                   
        }

        case AUMSG_SHOW_WELCOME:
            DEBUGMSG("WUAUCLT Displaying Welcome");
            DialogBox(ghInstance, MAKEINTRESOURCE(IDD_UPDATEFRAME), 
                    NULL, WizardFrameProc);                        
            return 0;

        case AUMSG_SHOW_DOWNLOAD:                   
#ifdef TESTUI
        {
            DEBUGMSG("WUAUCLT Displaying Predownload");
            DialogBox(ghInstance, MAKEINTRESOURCE(IDD_DOWNLOAD), 
                    NULL, DownloadDlgProc);    
            return 0;
        }
#else
        {               
            DEBUGMSG("WUAUCLT Displaying Predownload");
            DialogBox(ghInstance, MAKEINTRESOURCE(IDD_DOWNLOAD), 
                NULL, DownloadDlgProc);                
            return 0;
        }
#endif

        case AUMSG_SHOW_INSTALL:
            DEBUGMSG("WUAUCLT Displaying Install");
            DismissUIIfAny();
            DialogBox(ghInstance, MAKEINTRESOURCE(IDD_INSTALLFRAME), 
                NULL, InstallDlgProc);
            return 0;

        case AUMSG_SHOW_INSTALLWARNING: 
            DEBUGMSG("WUAUCLT Displaying install warning dialog");
            ShowInstallWarning();
            return 0;

        case WM_CLOSE:          
            DestroyWindow(ghMainWindow);            
            return 0;

		case WM_ENDSESSION:
			DEBUGMSG("WUAUCLT received WM_ENDSESSION (wParam = %#x)", wParam);
			if (wParam)
			{
				//if installation thread is live, wait until it finishes
				if (NULL != gpClientCatalog)
				{
    				gpClientCatalog->m_WrkThread.m_Terminate();
				}
				DismissUIIfAny();
				UninitPopupMenus();
				if (NULL != ghHeaderFont)
				{
					DeleteObject(ghHeaderFont);
				}
				UninitializeAUClient(g_hRegisterWait, g_hClientNotifyEvt, g_fCoInit, g_fcsInit);

				// Even we try to set the client exit code here, but there are cases
				// based on observation (e.g. logging off during reboot warning) that
				// we don't get back to WinMain for clean up after so the exit code gets
				// ignored.
				if (CDWWUAUCLT_UNSPECIFY == GetClientExitCode())
				{
					SetClientExitCode(CDWWUAUCLT_ENDSESSION);
				}
				DEBUGMSG("WUAUCLT exit code %d", GetClientExitCode());
			}
			return 0;

        case WM_DESTROY:            
            if (NULL != ghHeaderFont)
            {
                DeleteObject(ghHeaderFont);
            }
            if(ghCurrentMainDlg != NULL) 
            {
                DestroyWindow(ghCurrentMainDlg);
            }
			UninitPopupMenus();
            PostQuitMessage(0); 
            return 0;

        case WM_TIMER:
#ifdef TESTUI
            return 0;
#else
            {
                UINT nPercentComplete = 0;
                DWORD dwStatus;

                if (FAILED(gInternals->m_getServiceState(&AuState)))
                {
                    DEBUGMSG("WUAUCLT m_getServiceState failed when WM_TIMER or AuState.fDisconnected, quitting");
                    QUITAUClient();
                }
                else
                {
					if (AUSTATE_DETECT_COMPLETE != AuState.dwState 
						&& AUSTATE_DOWNLOAD_PENDING != AuState.dwState
						&& AUSTATE_DOWNLOAD_COMPLETE != AuState.dwState
						&& AUSTATE_NOT_CONFIGURED != AuState.dwState)
					{
						return 0;
					}
                    if (AUSTATE_DOWNLOAD_PENDING != AuState.dwState ||
                        SUCCEEDED(gInternals->m_getDownloadStatus(&nPercentComplete, &dwStatus)) && (DWNLDSTATUS_PAUSED == dwStatus))
                    {
			    UINT cSess;

                        if ((SUCCEEDED(gInternals->m_AvailableSessions(&cSess)) && cSess > 1) || FCurrentSessionInActive())
                        {
                            DEBUGMSG("WUAUCLT : After 4 hours, exit client and relaunch it in next available admin session");
                            SetClientExitCode(CDWWUAUCLT_RELAUNCHNOW);
                            QUITAUClient();
                        }
                    }
                }
            return 0;
            }
#endif      
        case AUMSG_TRAYCALLBACK:
#ifdef TESTUI
            return 0;
#else
            switch(lParam)
            {
                case WM_LBUTTONDOWN:
                case WM_RBUTTONDOWN:
                case WM_LBUTTONDBLCLK:
                case WM_CONTEXTMENU:
                case NIN_BALLOONUSERCLICK:
                    DEBUGMSG("TrayIcon Message got %d", lParam);
                    if (ghCurrentMenu != NULL)
                    {
						// bug 499697
						// Don't show Pause/Resume menu for download if domain policy specifies schedule install
						if (//SUCCEEDED(gInternals->m_getServiceState(&AuState)) &&
							//AUSTATE_DOWNLOAD_PENDING == AuState.dwState &&
							fDisableSelection())
						{
							break;
						}

						POINT mousePos;
						GetCursorPos(&mousePos);
						SetForegroundWindow(ghMainWindow);
						/*BOOL result =*/ TrackPopupMenu(ghCurrentMenu, 0, mousePos.x, mousePos.y, 0, ghMainWindow, NULL);
						PostMessage(ghMainWindow, WM_NULL, 0, 0);
                    }
                    else
                    {
                        EnterCriticalSection(&gcsClient); 

                        if(gNextDialogMsg != 0)
                        {
                            PostMessage(hWnd, gNextDialogMsg, 0, 0);
                            gNextDialogMsg = 0;
                            // we need to make use of the permission to set foregroundwindow ASAP because 
                            // SetForegroundWindow() will fail if called later
                            if (!SetForegroundWindow(ghMainWindow))
                            {
                                DEBUGMSG("WUAUCLT: Set main window to foreground FAILED");
                            }
                        }
                        else
                        {
                            SetActiveWindow(ghCurrentMainDlg);
                            SetForegroundWindow(ghCurrentMainDlg);
                            if(ghCurrentDialog != NULL) SetFocus(ghCurrentDialog);
                        }
                        LeaveCriticalSection(&gcsClient);
                    }
                    break;

                case WM_MOUSEMOVE:
                    if (FAILED(gInternals->m_getServiceState(&AuState)))
                    {
                        //fixcode: shall we quit AU here?
                        RemoveTrayIcon();
                        break;
                    }
                    if (AUSTATE_DOWNLOAD_PENDING == AuState.dwState) 
                    {
                        ShowProgress();
                    }
                    break;

                default:
                    break;
            }
            return 0;
#endif

        case WM_COMMAND:
            
#ifdef TESTUI
            return 0;
#else
			// bug 499697
			// Don't process Pause/Resume menu commands
			// if domain policy specifies scheduled install
			// in case the message was generated before
			// current domain policy kicked in.
			if (fDisableSelection())
			{
				return 0;
			}
            switch(LOWORD(wParam))
            {
                case IDC_PAUSE:
                    DEBUGMSG("WUAUCLT User pausing download");
                    if (FAILED(gInternals->m_setDownloadPaused(TRUE)))
                    {
//                        QUITAUClient(); //let wuaueng to figure out problem and recover
                    }
                    else
                    {
                        ghCurrentMenu = ghResumeMenu;
                        DEBUGMSG("current menu = resume");
                    }
                    break;

                case IDC_RESUME:
                    DEBUGMSG("WUAUCLT User resuming download");
                    if (FAILED(gInternals->m_setDownloadPaused(FALSE)))
                    {
//                        QUITAUClient();
                    }
                    else
                    {
                        ghCurrentMenu = ghPauseMenu;
                        DEBUGMSG("current menu = pause");
                    }
                    break;

                default:
                    break;
            }
            return 0;
#endif  
        default:
            return DefWindowProc(hWnd, message, wParam, lParam);

    }
    return 0;
}

//client exit code should only be set once with a meaningful value
void SetClientExitCode(UINT uExitCode)
{
    if (guExitProcess != CDWWUAUCLT_UNSPECIFY)
    {
        DEBUGMSG("ERROR: WUAUCLT Client exit code should only be set once");
    }
    else
    {
        guExitProcess = uExitCode;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\wuaucpl\wuaucpl.cpp ===
// WUAUCpl.cpp: implementation of the CWUAUCpl class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "Resource.h"
#include "WUAUCpl.h"
#include "windowsx.h"
#include "shellapi.h"
#include "tchar.h"
#include "atlbase.h"
#include "criticalfixreg.h"
#include "wuaulib.h"
#include "wuauengi_i.c"

#include "htmlhelp.h"
#include "link.h"
#pragma hdrstop

HINSTANCE CWUAUCpl::m_hInstance = NULL;

#define IDH_LETWINDOWS					3000
#define IDH_AUTOUPDATE_OPTION1			3001
#define IDH_AUTOUPDATE_OPTION2			3002
#define IDH_AUTOUPDATE_OPTION3			3003
#define IDH_DAYDROPDOWN					3004
#define IDH_TIMEDROPDOWN				3005
#define IDH_AUTOUPDATE_RESTOREHIDDEN	3006
#define IDH_BTN_APPLY					3007
#define IDH_NOHELP						-1

LPTSTR ResStrFromId(UINT uStrId);

HANDLE g_RegUpdateEvent = NULL;

const DWORD CWUAUCpl::s_rgHelpIDs[] = {
	IDC_CHK_KEEPUPTODATE,         DWORD(IDH_LETWINDOWS),
    IDC_AUTOUPDATE_OPTION1,       DWORD(IDH_AUTOUPDATE_OPTION1),
    IDC_AUTOUPDATE_OPTION2,       DWORD(IDH_AUTOUPDATE_OPTION2),
    IDC_AUTOUPDATE_OPTION3,       DWORD(IDH_AUTOUPDATE_OPTION3),
	IDC_CMB_DAYS,				  DWORD(IDH_DAYDROPDOWN),
	IDC_CMB_HOURS,				  DWORD(IDH_TIMEDROPDOWN),
	IDC_BTN_RESTORE,			  DWORD(IDH_AUTOUPDATE_RESTOREHIDDEN),
	IDC_BTN_APPLY,				  DWORD(IDH_BTN_APPLY),
    0, 0
    };

LRESULT CALLBACK StatLinkWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
WNDPROC g_OrigStatWndProc = NULL;
HCURSOR g_HandCursor = NULL; 

void CWUAUCpl::SetInstanceHandle(HINSTANCE hInstance)
{
	m_hInstance = hInstance;
	g_HandCursor = LoadCursor(hInstance,MAKEINTRESOURCE(IDC_HANDCUR));
}

CWUAUCpl::CWUAUCpl(int nIconID,int nNameID,int nDescID)
{
	m_nIconID = nIconID;
	m_nNameID = nNameID;
	m_nDescID = nDescID;
	m_hFont = NULL;

	m_colorVisited = RGB(0,0,225);
	m_colorUnvisited = RGB(128,0,128);

	m_bVisitedLinkLearnAutoUpdate = FALSE;
	m_bVisitedLinkScheduleInstall = FALSE;

	m_hThreadUpdatesObject = NULL;
	m_idUpdatesObjectThread = 0;
}

LONG CWUAUCpl::Init()
{
	return TRUE;
}

LONG CWUAUCpl::GetCount()
{
	return 1;
}

LONG CWUAUCpl::Inquire(LONG appletIndex, LPCPLINFO lpCPlInfo)
{
	lpCPlInfo->lData = 0;
	lpCPlInfo->idIcon = m_nIconID;
	lpCPlInfo->idName = m_nNameID;
	lpCPlInfo->idInfo = m_nDescID;
	return TRUE;
}

LONG CWUAUCpl::DoubleClick(HWND hWnd, LONG lParam1, LONG lParam2)
{

	INT Result = (INT)DialogBoxParam(m_hInstance, 
                                 MAKEINTRESOURCE(IDD_AUTOUPDATE), 
                                 hWnd, 
                                 CWUAUCpl::_DlgProc, 
                                 (LPARAM)this);
	return TRUE;
}

INT_PTR CALLBACK 
CWUAUCpl::_DlgProc(   // [static]
    HWND hwnd,
    UINT uMsg, 
    WPARAM wParam, 
    LPARAM lParam
    )
{
	CWUAUCpl *pThis = NULL;
    if (WM_INITDIALOG == uMsg)
    {
        pThis = (CWUAUCpl*)lParam;
        if (!SetProp(hwnd, g_szPropDialogPtr, (HANDLE)pThis))
        {
            pThis = NULL;
        }
    }
    else
    {
        pThis = (CWUAUCpl *)GetProp(hwnd, g_szPropDialogPtr);
    }

	if (NULL != pThis)
    {
        switch(uMsg)
        {
            HANDLE_MSG(hwnd, WM_INITDIALOG,  pThis->_OnInitDialog);
            HANDLE_MSG(hwnd, WM_COMMAND,     pThis->_OnCommand);
            HANDLE_MSG(hwnd, WM_CONTEXTMENU, pThis->_OnContextMenu);
            HANDLE_MSG(hwnd, WM_HELP,        pThis->_OnHelp);
	        HANDLE_MSG(hwnd, WM_CTLCOLORSTATIC, pThis->_OnCtlColorStatic);
			HANDLE_MSG(hwnd, WM_DESTROY, pThis->_OnDestroy);
			HANDLE_MSG(hwnd, PWM_INITUPDATESOBJECT, pThis->_OnInitUpdatesObject);
            default:
                break;
        }
    }
    return (FALSE);
}

INT_PTR CALLBACK CWUAUCpl::_DlgRestoreProc(
    HWND hwnd,
    UINT uMsg, 
    WPARAM wParam, 
    LPARAM lParam
    )
{
	if (uMsg == WM_INITDIALOG)
	{
		HWND hwndOwner; 
		RECT rc, rcDlg, rcOwner; 
        // Get the owner window and dialog box rectangles. 
 
		if ((hwndOwner = GetParent(hwnd)) == NULL) 
		{
			hwndOwner = GetDesktopWindow(); 
		}

		GetWindowRect(hwndOwner, &rcOwner); 
		GetWindowRect(hwnd, &rcDlg); 
		CopyRect(&rc, &rcOwner); 

		 // Offset the owner and dialog box rectangles so that 
		 // right and bottom values represent the width and 
		 // height, and then offset the owner again to discard 
		 // space taken up by the dialog box. 
		OffsetRect(&rcDlg, -rcDlg.left, -rcDlg.top); 
		OffsetRect(&rc, -rc.left, -rc.top); 
		OffsetRect(&rc, -rcDlg.right, -rcDlg.bottom); 

		 // The new position is the sum of half the remaining 
		 // space and the owner's original position. 
		SetWindowPos(hwnd, 
			HWND_TOP, 
			rcOwner.left + (rc.right / 2), 
			rcOwner.top + (rc.bottom / 2), 
			0, 0,          // ignores size arguments 
			SWP_NOSIZE); 
	}

	if (uMsg == WM_COMMAND)
	{
		switch (LOWORD(wParam))
		{
		case IDOK:
			EndDialog(hwnd, TRUE);
			return TRUE;

		case IDCANCEL:
			EndDialog(hwnd, FALSE);
			return TRUE;
		}
	}
	return FALSE;
}

LONG CWUAUCpl::Stop(LPARAM lParam1, LPARAM lParam2)
{
	return TRUE;
}

LONG CWUAUCpl::Exit()
{
	return TRUE;
}

void CWUAUCpl::_OnDestroy(HWND hwnd)
{
       m_AutoUpdatelink.Uninit();
       m_ScheduledInstalllink.Uninit();
	if (m_hFont)
		DeleteObject(m_hFont); 
}

HBRUSH CWUAUCpl::_OnCtlColorStatic(HWND hwnd, HDC hDC, HWND hwndCtl, int type)
{
	HBRUSH hBr = NULL;
	if ((hwndCtl == m_hWndLinkLearnAutoUpdate) || (hwndCtl == m_hWndLinkScheduleInstall))
	{

/*		LONG ctrlstyle = GetWindowLong(hwndCtl,GWL_STYLE);
		if( (ctrlstyle & 0xff) <= SS_RIGHT )
		{
			// it's a text control: set up font and colors
			if( !m_hFont )
			{
				LOGFONT lf;
				GetObject((VOID*)SendMessage(hwnd,WM_GETFONT,0,0), sizeof(lf), &lf );
				lf.lfUnderline = TRUE;
				m_hFont = CreateFontIndirect( &lf );
			}
			SelectObject( hDC, m_hFont );

			if (hwndCtl == m_hWndLinkLearnAutoUpdate)
				SetTextColor( hDC, m_bVisitedLinkLearnAutoUpdate ? m_colorUnvisited : m_colorVisited );

			if (hwndCtl == m_hWndLinkScheduleInstall)
				SetTextColor( hDC, m_bVisitedLinkScheduleInstall ? m_colorUnvisited : m_colorVisited );*/

			SetBkMode( hDC, TRANSPARENT );
			hBr = (HBRUSH)GetStockObject( HOLLOW_BRUSH );
//		}
	}
	return hBr;
}

BOOL CWUAUCpl::_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
	_SetHeaderText(hwnd, IDS_HEADER_CONNECTING);
	EnableWindow(GetDlgItem(hwnd, IDC_BTN_APPLY), FALSE); //Disable Apply button

	_SetDefault(hwnd);
	_SetStaticCtlNotifyStyle(hwnd);

	_EnableControls(hwnd,FALSE);
    //
    // Create the thread on which the Updates object lives.
    // Communication between the thread and the property page is
    // through the messages PWM_INITUPDATESOBJECT and UOTM_SETDATA.
    //
    m_hThreadUpdatesObject = CreateThread(NULL,
                                          0,
                                          _UpdatesObjectThreadProc,
                                          (LPVOID)hwnd,
                                          0,
                                          &m_idUpdatesObjectThread);

	return TRUE;
}

//
// This thread is where the Updates object lives.  This allows us to 
// CoCreate the object without blocking the UI.  If the Windows Update
// service is not running, CoCreate can take several seconds.  Without
// placing this on another thread, this can make the UI appear to be
// hung.
//
// *pvParam is the HWND of the property page window.  
//
DWORD WINAPI
CWUAUCpl::_UpdatesObjectThreadProc(   // [static]
    LPVOID pvParam
    )
{
    HWND hwndClient = (HWND)pvParam;
    HRESULT hr = CoInitialize(NULL);

	if (SUCCEEDED(hr))
    {
        IUpdates *pUpdates;
        hr = CoCreateInstance(__uuidof(Updates),
                              NULL, 
                              CLSCTX_LOCAL_SERVER,
                              IID_IUpdates,
                              (void **)&pUpdates);
        if (SUCCEEDED(hr))
        {
            //
            // Query the object for it's current data and send it
            // to the property page.
            //
            UPDATESOBJ_DATA data;
            data.fMask    = UODI_ALL;

            HRESULT hrQuery = _QueryUpdatesObjectData(hwndClient, pUpdates, &data);
            SendMessage(hwndClient, PWM_INITUPDATESOBJECT, (WPARAM)SUCCEEDED(hrQuery), (LPARAM)&data);
            //
            // Now sit waiting for thread messages from the UI.  We receive
            // either messages to configure Windows Update or a 
            // WM_QUIT indicating it's time to go.
            // 
            bool bDone = false;
            MSG msg;
            while(!bDone)
            {
                if (0 == GetMessage(&msg, NULL, 0, 0))
                {
                    bDone = true;
                }
                else switch(msg.message)
                {
                    case UOTM_SETDATA:
                        if (NULL != msg.lParam)
                        {
                            UPDATESOBJ_DATA *pData = (UPDATESOBJ_DATA *)msg.lParam;
                            _SetUpdatesObjectData(hwndClient, pUpdates, pData);
                            LocalFree(pData);
							if (g_RegUpdateEvent)
							{
								SetEvent(g_RegUpdateEvent);
							}
                        }
                        break;
        
                    default:
                        TranslateMessage(&msg);
                        DispatchMessage(&msg);
                        break;
                }
            }
            pUpdates->Release();
        }
        CoUninitialize();
    }
    if (FAILED(hr))
    {
        //
        // Something failed.  Notify the property page.
        // Most likely, the Windows Update service is not available.
        // That's the principal case this separate thread is addressing.
        //
        SendMessage(hwndClient, PWM_INITUPDATESOBJECT, FALSE, (LPARAM)NULL);
    }
    return 0;
}

HRESULT
CWUAUCpl::_QueryUpdatesObjectData(  // [static]
    HWND /*hwnd*/,
    IUpdates *pUpdates,
    UPDATESOBJ_DATA *pData
    )
{
    HRESULT hr = S_OK;
    if (UODI_OPTION & pData->fMask)
    {
        AUOPTION auopt;
        hr = pUpdates->get_Option(&auopt);
        pData->Option = auopt;
        if (FAILED(hr))
        {
            //
            // ISSUE-2000/10/18-BrianAu  Display error UI?
            //
        }
    }
    return hr;
}

HRESULT
CWUAUCpl::_SetUpdatesObjectData(  // [static]
    HWND /*hwnd*/,
    IUpdates *pUpdates,
    UPDATESOBJ_DATA *pData
    )
{
    HRESULT hr = S_OK;
    if (UODI_OPTION & pData->fMask)
    {
        hr = pUpdates->put_Option(pData->Option);
    }
    return hr;
}


BOOL CWUAUCpl::_OnInitUpdatesObject(HWND hwnd, BOOL bObjectInitSuccessful, UPDATESOBJ_DATA *pData)
{
    if (bObjectInitSuccessful &&  fAccessibleToAU())
    {
        //
        // Updates object was created and initialized.  The 
        // pData pointer refers to the initial state information retrieved 
        // from the object.  Initialize the property page.
        //
        _SetHeaderText(hwnd, IDS_HEADER_CONNECTED);
        _EnableControls(hwnd, TRUE);
		EnableWindow(GetDlgItem(hwnd,IDC_BTN_APPLY),FALSE);
		EnableRestoreDeclinedItems( hwnd, FHiddenItemsExist()); 

        switch(pData->Option.dwOption)
        {
            case AUOPTION_AUTOUPDATE_DISABLE:
				CheckRadioButton(hwnd, IDC_AUTOUPDATE_OPTION1, IDC_AUTOUPDATE_OPTION3, IDC_AUTOUPDATE_OPTION1);
				_EnableOptions(hwnd, FALSE);
				_EnableCombo(hwnd, FALSE);
				SendMessage(GetDlgItem(hwnd,IDC_CHK_KEEPUPTODATE),BM_SETCHECK,BST_UNCHECKED,0);
                break;

            case AUOPTION_PREDOWNLOAD_NOTIFY:
                CheckRadioButton(hwnd, IDC_AUTOUPDATE_OPTION1, IDC_AUTOUPDATE_OPTION3, IDC_AUTOUPDATE_OPTION1);
				_EnableCombo(hwnd, FALSE);
				SendMessage(GetDlgItem(hwnd,IDC_CHK_KEEPUPTODATE),BM_SETCHECK,BST_CHECKED,0);
                break;

            case AUOPTION_INSTALLONLY_NOTIFY:
				CheckRadioButton(hwnd, IDC_AUTOUPDATE_OPTION1, IDC_AUTOUPDATE_OPTION3, IDC_AUTOUPDATE_OPTION2);
				_EnableCombo(hwnd, FALSE);
				SendMessage(GetDlgItem(hwnd,IDC_CHK_KEEPUPTODATE),BM_SETCHECK,BST_CHECKED,0);
                break;

			case AUOPTION_SCHEDULED:
                CheckRadioButton(hwnd, IDC_AUTOUPDATE_OPTION1, IDC_AUTOUPDATE_OPTION3, IDC_AUTOUPDATE_OPTION3);
				_EnableCombo(hwnd, TRUE);
				SendMessage(GetDlgItem(hwnd,IDC_CHK_KEEPUPTODATE),BM_SETCHECK,BST_CHECKED,0);
                break;

            default:
				_SetDefault(hwnd);
                break;
        }

		_FillDaysCombo(hwnd, pData->Option.dwSchedInstallDay);
        FillHrsCombo(hwnd, pData->Option.dwSchedInstallTime);

        if (pData->Option.fDomainPolicy)
        {
			_EnableControls(hwnd, FALSE);
			SetFocus(GetDlgItem(hwnd,IDCANCEL));
        }
		else
			SetFocus(GetDlgItem(hwnd,IDC_CHK_KEEPUPTODATE));

		m_AutoUpdatelink.Invalidate();
		m_ScheduledInstalllink.Invalidate();
    }
    else
    {
        //
        // Something failed when creating the Updates object.
        // Most likely, the Windows Update service is not running.
        //
        _SetHeaderText(hwnd, IDS_HEADER_UNAVAILABLE);
    }
        
    return FALSE;   
}

BOOL CWUAUCpl::_SetStaticCtlNotifyStyle(HWND hwnd)
{
	m_hWndLinkLearnAutoUpdate = GetDlgItem(hwnd,IDC_STAT_LEARNAUTOUPDATE);
	m_hWndLinkScheduleInstall = GetDlgItem(hwnd,IDC_STA_SCHEDULEDINSTALL);
/*
	LONG ctrlstyle = GetWindowLong(m_hWndLinkLearnAutoUpdate,GWL_STYLE);
	ctrlstyle |= SS_NOTIFY;
	SetWindowLongPtr(GetDlgItem(hwnd,IDC_STAT_LEARNAUTOUPDATE),GWL_STYLE,ctrlstyle);

	g_OrigStatWndProc = (WNDPROC) SetWindowLongPtr(GetDlgItem(hwnd,IDC_STAT_LEARNAUTOUPDATE),GWLP_WNDPROC,(LONG_PTR)StatLinkWndProc);
*/	
	m_AutoUpdatelink.SetSysLinkInstanceHandle(m_hInstance);
	m_AutoUpdatelink.SubClassWindow(GetDlgItem(hwnd,IDC_STAT_LEARNAUTOUPDATE));
	m_AutoUpdatelink.SetHyperLink(gtszAUOverviewUrl);

/*	ctrlstyle = GetWindowLong(m_hWndLinkScheduleInstall,GWL_STYLE);
	ctrlstyle |= SS_NOTIFY;
	SetWindowLongPtr(GetDlgItem(hwnd,IDC_STA_SCHEDULEDINSTALL),GWL_STYLE,ctrlstyle);
	g_OrigStatWndProc = (WNDPROC)SetWindowLongPtr(GetDlgItem(hwnd,IDC_STA_SCHEDULEDINSTALL),GWLP_WNDPROC,(LONG_PTR)StatLinkWndProc);
*/
	m_ScheduledInstalllink.SetSysLinkInstanceHandle(m_hInstance);
	m_ScheduledInstalllink.SubClassWindow(GetDlgItem(hwnd,IDC_STA_SCHEDULEDINSTALL));
	m_ScheduledInstalllink.SetHyperLink(gtszAUW2kSchedInstallUrl);
	return TRUE;
}


BOOL CWUAUCpl::_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    switch(id)
    {
        case IDOK:
			_OnApply(hwnd);
        case IDCANCEL:
            if(BN_CLICKED == codeNotify)
            {
				EndDialog(hwnd,TRUE);
            }
	        break;

        case IDC_BTN_APPLY:
            if(BN_CLICKED == codeNotify)
            {
				EnableWindow(hwndCtl,FALSE);
				_OnApply(hwnd);
			}
			break;

		case IDC_CHK_KEEPUPTODATE:
			if (BN_CLICKED == codeNotify)
			{
				_OnKeepUptoDate(hwnd);
			}
			break;

/*		case IDC_STAT_LEARNAUTOUPDATE:
		case IDC_STA_SCHEDULEDINSTALL:
			if( STN_CLICKED == codeNotify || STN_DBLCLK == codeNotify)
			{
				LaunchLinkAction(hwndCtl);
			}
			break;
*/
        case IDC_AUTOUPDATE_OPTION1:
        case IDC_AUTOUPDATE_OPTION2:
        case IDC_AUTOUPDATE_OPTION3:
            if(BN_CLICKED == codeNotify)
            {
                _OnOptionSelected(hwnd, id);
            }
            break;

		case IDC_CMB_DAYS:
		case IDC_CMB_HOURS:
			if(CBN_SELCHANGE == codeNotify)
			{
				EnableWindow(GetDlgItem(hwnd, IDC_BTN_APPLY), TRUE); //Enable Apply button				
			}
			break;

		case IDC_BTN_RESTORE:
			if(BN_CLICKED == codeNotify)
			{
				INT Result = (INT)DialogBoxParam(m_hInstance, 
                     MAKEINTRESOURCE(IDD_RESTOREUPDATE), 
                     hwnd, 
                     CWUAUCpl::_DlgRestoreProc, 
                     (LPARAM)NULL);
				if (Result == TRUE)
				{	
					if (SUCCEEDED (_OnRestoreHiddenItems()))			
					{		
						EnableRestoreDeclinedItems( hwnd, FALSE);
					}	
				}
			}
			break;
	}
	return TRUE;
}

BOOL CWUAUCpl::_OnContextMenu(HWND hwnd, HWND hwndContext, UINT xPos, UINT yPos)
{
	if ((hwndContext == GetDlgItem(hwnd,IDC_CHK_KEEPUPTODATE))||
		(hwndContext == GetDlgItem(hwnd,IDC_AUTOUPDATE_OPTION1))||
		(hwndContext == GetDlgItem(hwnd,IDC_AUTOUPDATE_OPTION2))||
		(hwndContext == GetDlgItem(hwnd,IDC_AUTOUPDATE_OPTION3))||
		(hwndContext == GetDlgItem(hwnd,IDC_CMB_DAYS))||
		(hwndContext == GetDlgItem(hwnd,IDC_CMB_HOURS))||
		(hwndContext == GetDlgItem(hwnd,IDC_BTN_RESTORE))||
		(hwndContext == GetDlgItem(hwnd,IDC_BTN_APPLY))
		)
	{
		HtmlHelp(hwndContext,g_szHelpFile,HH_TP_HELP_CONTEXTMENU,(DWORD_PTR)((LPTSTR)s_rgHelpIDs));
	}
	return TRUE;
}

BOOL CWUAUCpl::_OnHelp(HWND hwnd, HELPINFO *pHelpInfo)
{
	if (HELPINFO_WINDOW == pHelpInfo->iContextType)
    {
		if ((pHelpInfo->hItemHandle == GetDlgItem(hwnd,IDC_CHK_KEEPUPTODATE))||
			(pHelpInfo->hItemHandle == GetDlgItem(hwnd,IDC_AUTOUPDATE_OPTION1))||
			(pHelpInfo->hItemHandle == GetDlgItem(hwnd,IDC_AUTOUPDATE_OPTION2))||
			(pHelpInfo->hItemHandle == GetDlgItem(hwnd,IDC_AUTOUPDATE_OPTION3))||
			(pHelpInfo->hItemHandle == GetDlgItem(hwnd,IDC_CMB_DAYS))||
			(pHelpInfo->hItemHandle == GetDlgItem(hwnd,IDC_CMB_HOURS))||
			(pHelpInfo->hItemHandle == GetDlgItem(hwnd,IDC_BTN_RESTORE))||
			(pHelpInfo->hItemHandle == GetDlgItem(hwnd,IDCANCEL))||
			(pHelpInfo->hItemHandle == GetDlgItem(hwnd,IDOK))||
			(pHelpInfo->hItemHandle == GetDlgItem(hwnd,IDC_BTN_APPLY))
			)
		{
			HtmlHelp((HWND)pHelpInfo->hItemHandle,
					 g_szHelpFile,
					 HH_TP_HELP_WM_HELP,
					 (DWORD_PTR)((LPTSTR)s_rgHelpIDs));
		}
    }
	return TRUE;
}

void CWUAUCpl::_GetDayAndTimeFromUI( 
	HWND hWnd,
	LPDWORD lpdwSchedInstallDay,
	LPDWORD lpdwSchedInstallTime
)
{
	HWND hComboDays = GetDlgItem(hWnd,IDC_CMB_DAYS);
	HWND hComboHrs = GetDlgItem(hWnd,IDC_CMB_HOURS);
	LRESULT nDayIndex = SendMessage(hComboDays,CB_GETCURSEL,0,(LPARAM)0);
	LRESULT nTimeIndex = SendMessage(hComboHrs,CB_GETCURSEL,0,(LPARAM)0);

	*lpdwSchedInstallDay = (DWORD)SendMessage(hComboDays,CB_GETITEMDATA, nDayIndex, (LPARAM)0);
	*lpdwSchedInstallTime = (DWORD)SendMessage(hComboHrs,CB_GETITEMDATA, nTimeIndex, (LPARAM)0);
}


BOOL CWUAUCpl::_FillDaysCombo(HWND hwnd, DWORD dwSchedInstallDay)
{
    return FillDaysCombo(m_hInstance, hwnd, dwSchedInstallDay, IDS_STR_EVERYDAY, IDS_STR_SATURDAY);
#if 0    
       DWORD dwCurrentIndex = 0;
	HWND hComboDays = GetDlgItem(hwnd,IDC_CMB_DAYS);
	for (int i = IDS_STR_EVERYDAY, j = 0; i <= IDS_STR_SATURDAY; i ++, j++)
	{
		TCHAR szDay[MAX_PATH];
		LoadString(m_hInstance,i,szDay,ARRAYSIZE(szDay));

		LRESULT nIndex = SendMessage(hComboDays,CB_ADDSTRING,0,(LPARAM)szDay);
		SendMessage(hComboDays,CB_SETITEMDATA,nIndex,j);
		if( dwSchedInstallDay == j )
		{
			dwCurrentIndex = (DWORD)nIndex;
		}
	}
	SendMessage(hComboDays,CB_SETCURSEL,dwCurrentIndex,(LPARAM)0);
	return TRUE;
#endif	
}

BOOL CWUAUCpl::_OnKeepUptoDate(HWND hwnd)
{
	LRESULT lResult = SendMessage(GetDlgItem(hwnd,IDC_CHK_KEEPUPTODATE),BM_GETCHECK,0,0);

	EnableWindow(GetDlgItem(hwnd, IDC_BTN_APPLY), TRUE); //Enable Apply button

	if (lResult == BST_CHECKED)
	{
		_EnableOptions(hwnd, TRUE);
		return TRUE;
	}
	else if (lResult == BST_UNCHECKED)
	{
		_EnableOptions(hwnd, FALSE);
		return TRUE;	
	}
	else
	{
		return FALSE;
	}
}

BOOL CWUAUCpl::_OnOptionSelected(HWND hwnd,INT idOption)
{
    const UINT idFirst = IDC_AUTOUPDATE_OPTION1;
    const UINT idLast  = IDC_AUTOUPDATE_OPTION3;
    CheckRadioButton(hwnd, idFirst, idLast, idOption);

	if (idOption == IDC_AUTOUPDATE_OPTION3)
		_EnableCombo(hwnd, TRUE);
	else
		_EnableCombo(hwnd, FALSE);

	EnableWindow(GetDlgItem(hwnd, IDC_BTN_APPLY), TRUE); //Enable Apply button
	return TRUE;
}

BOOL CWUAUCpl::_EnableOptions(HWND hwnd, BOOL bState)
{
	EnableWindow(GetDlgItem(hwnd,IDC_AUTOUPDATE_OPTION1),bState);
	EnableWindow(GetDlgItem(hwnd,IDC_AUTOUPDATE_OPTION2),bState);
	EnableWindow(GetDlgItem(hwnd,IDC_AUTOUPDATE_OPTION3),bState);

	if (BST_CHECKED == SendMessage(GetDlgItem(hwnd,IDC_AUTOUPDATE_OPTION3),BM_GETCHECK,0,0))
	{
		_EnableCombo(hwnd, bState);
	}
	return TRUE;
}

BOOL CWUAUCpl::_EnableCombo(HWND hwnd, BOOL bState)
{
	EnableWindow(GetDlgItem(hwnd,IDC_CMB_DAYS),bState);
	EnableWindow(GetDlgItem(hwnd,IDC_CMB_HOURS),bState);
	return TRUE;
}

BOOL CWUAUCpl::_SetDefault(HWND hwnd)
{
	LRESULT lResult = SendMessage(GetDlgItem(hwnd,IDC_CHK_KEEPUPTODATE),BM_SETCHECK,1,0);
	lResult = SendMessage(GetDlgItem(hwnd,IDC_AUTOUPDATE_OPTION2),BM_SETCHECK,1,0);
	return TRUE;
}

void CWUAUCpl::LaunchLinkAction(HWND hwnd)
{
	if ( m_hWndLinkLearnAutoUpdate == hwnd)
	{
		LaunchHelp(hwnd, gtszAUOverviewUrl);
		m_bVisitedLinkLearnAutoUpdate = TRUE;
		InvalidateRect(hwnd,NULL,TRUE);
	}
	else if	(m_hWndLinkScheduleInstall == hwnd)
	{
		LaunchHelp(hwnd, gtszAUW2kSchedInstallUrl);
		m_bVisitedLinkScheduleInstall = TRUE;
		InvalidateRect(hwnd,NULL,TRUE);
	}
	return;
}

//
// Set the text to the right of the icon.
//
HRESULT 
CWUAUCpl::_SetHeaderText(
    HWND hwnd, 
    UINT idsText
    )
{
    HRESULT hr;
    TCHAR szText[MAX_PATH] ;

    if (0 < LoadString(m_hInstance, idsText, szText, ARRAYSIZE(szText)))
    {
        SetWindowText(GetDlgItem(hwnd, IDC_TXT_HEADER), szText);
        hr = S_OK;
    }
    else
    {
        const DWORD dwErr = GetLastError();
        hr = HRESULT_FROM_WIN32(dwErr);
    }
    return hr;
}

//
// Enable or disable all controls on the property page.
// All but the header text control.
//
HRESULT
CWUAUCpl::_EnableControls(
    HWND hwnd,
    BOOL bEnable
    )
{
    static const UINT rgidCtls[] = {
		IDC_CHK_KEEPUPTODATE,
		IDC_AUTOUPDATELINK,
        IDC_AUTOUPDATE_OPTION1,
        IDC_AUTOUPDATE_OPTION2,
        IDC_AUTOUPDATE_OPTION3,
        IDC_BTN_RESTORE,
        IDC_GRP_OPTIONS,
		IDC_CMB_DAYS,
		IDC_STATICAT,
		IDC_CMB_HOURS,
		IDOK
		};

    for (int i = 0; i < ARRAYSIZE(rgidCtls); i++)
    {
        EnableWindow(GetDlgItem(hwnd, rgidCtls[i]), bEnable);
    }
    return S_OK;
}

void CWUAUCpl::EnableRestoreDeclinedItems(HWND hWnd, BOOL fEnable)
{
	EnableWindow(GetDlgItem(hWnd, IDC_BTN_RESTORE), fEnable);
}

//
// Called when the user presses the "Apply" button or the "OK"
// button when the page has been changed.
//
BOOL
CWUAUCpl::_OnApply(
    HWND hwnd
    )
{
    HRESULT hr = E_FAIL;
    //
    // Create a structure that can be passed to the Updates Object thread
    // by way of the UOTM_SETDATA thread message.  The thread will free
    // the buffer when it's finished with it.
    //
    UPDATESOBJ_DATA *pData = (UPDATESOBJ_DATA *)LocalAlloc(LPTR, sizeof(*pData));
    if (NULL == pData)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        pData->Option.dwOption = AUOPTION_AUTOUPDATE_DISABLE;
        pData->fMask    = UODI_ALL;

        static const struct
        {
            UINT idCtl;
            DWORD dwOption;

        } rgMap[] = {
            { IDC_AUTOUPDATE_OPTION1,  AUOPTION_PREDOWNLOAD_NOTIFY },
            { IDC_AUTOUPDATE_OPTION2,  AUOPTION_INSTALLONLY_NOTIFY },
            { IDC_AUTOUPDATE_OPTION3,  AUOPTION_SCHEDULED }
		};

		if 	(IsDlgButtonChecked(hwnd, IDC_CHK_KEEPUPTODATE) == BST_CHECKED)
		{
			//
			// Determine the WAU option based on the radio button configuration.
			//
			for (int i = 0; i < ARRAYSIZE(rgMap); i++)
			{
				if (IsDlgButtonChecked(hwnd, rgMap[i].idCtl) == BST_CHECKED)
				{
					pData->Option.dwOption = rgMap[i].dwOption;
					break;
				}
			}
		}
		else
			pData->Option.dwOption = AUOPTION_AUTOUPDATE_DISABLE;

	    if (AUOPTION_SCHEDULED == pData->Option.dwOption)
        {
            _GetDayAndTimeFromUI(hwnd, &(pData->Option.dwSchedInstallDay), &(pData->Option.dwSchedInstallTime));
        }

        if (0 != m_idUpdatesObjectThread)
        {
			//Create event
			g_RegUpdateEvent = CreateEvent(NULL,FALSE,FALSE,NULL);

            if (0 != PostThreadMessage(m_idUpdatesObjectThread,
                                       UOTM_SETDATA,
                                       0,
                                       (LPARAM)pData))
            {
                hr    = S_OK;
                pData = NULL;
            }
			WaitForSingleObject(g_RegUpdateEvent,10000);

			CloseHandle(g_RegUpdateEvent);
			g_RegUpdateEvent = NULL;
        }
        if (NULL != pData)
        {
            LocalFree(pData);
            pData = NULL;
        }
    }
    return FALSE;
}

void 
CWUAUCpl::LaunchHelp(HWND hwnd,
	LPCTSTR szURL
)
{
	HtmlHelp(NULL,szURL,HH_DISPLAY_TOPIC,NULL);
}


HRESULT
CWUAUCpl::_OnRestoreHiddenItems()
{
    return RemoveHiddenItems() ? S_OK : E_FAIL;
}


LRESULT CALLBACK StatLinkWndProc(
  HWND hwnd,      // handle to window
  UINT uMsg,      // message identifier
  WPARAM wParam,  // first message parameter
  LPARAM lParam   // second message parameter
)
{
	switch (uMsg)
	{
	case WM_SETCURSOR:
		{
			POINT pt;
			GetCursorPos(&pt);
			ScreenToClient(hwnd, &pt);

			RECT rect;
			GetClientRect(hwnd, &rect);

			if (::PtInRect(&rect, pt))
			{
				return TRUE;
			}
			break;
		}

//	case WM_GETDLGCODE:
//		return DLGC_WANTCHARS;

	case WM_MOUSEMOVE:
		{
			POINT pt = { GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam) };
			RECT rect;
			GetClientRect(hwnd, &rect);
			if(::PtInRect(&rect, pt))
				SetCursor(g_HandCursor);
			return TRUE;
		}
		break;

/*	case WM_SETFOCUS:
	case WM_KILLFOCUS:
		{
			RECT rect;
			GetClientRect(hwnd, &rect);
			InvalidateRect(hwnd, &rect, TRUE);
			return FALSE;
		}
		break;

	case WM_LBUTTONDOWN:
		{
			POINT pt = { GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam) };
			RECT rect;
			GetClientRect(hwnd, &rect);
			if(::PtInRect(&rect, pt))
			{
				SetFocus(hwnd);
				SetCapture(hwnd);
				return 0;
			}
		}
		break;

	case WM_LBUTTONUP:
		if(GetCapture() == hwnd)
		{
			ReleaseCapture();
			POINT pt = { GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam) };
			RECT rect;
			GetClientRect(hwnd, &rect);
//			if(::PtInRect(&rect, pt))
//				Navigate();
		}
		return 0;
	case WM_PAINT:
		{
			
		}

	case WM_CHAR:
		if(wParam == VK_RETURN || wParam == VK_SPACE)
//			Navigate();
		return 0;*/
	}
	return CallWindowProc(g_OrigStatWndProc, hwnd,uMsg,wParam,lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\wuaueng\aucpl.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       aucpl.cpp
//
//--------------------------------------------------------------------------
#include "pch.h"
#pragma hdrstop

HINSTANCE  g_hInstance = NULL;
LONG       g_cRefDll    = 0;

// {5F327514-6C5E-4d60-8F16-D07FA08A78ED}
//DEFINE_GUID(CLSID_AutoUpdatePropSheet,
//0x5f327514, 0x6c5e, 0x4d60, 0x8f, 0x16, 0xd0, 0x7f, 0xa0, 0x8a, 0x78, 0xed);

class __declspec(uuid("5f327514-6c5e-4d60-8f16-d07fa08a78ed")) CAutoUpdatePropSheet;
                        
//-----------------------------------------------------------------------------
// COM server class factory.
//-----------------------------------------------------------------------------
class CAutoUpdateClassFactory : IClassFactory
{
    public:
        ~CAutoUpdateClassFactory(void);
        //
        // IUnknown methods
        //
        STDMETHOD(QueryInterface)(REFIID riid, void **ppvOut);
        STDMETHOD_(ULONG, AddRef)(void);
        STDMETHOD_(ULONG, Release)(void);
        //
        // IClassFactory methods
        //
        STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter, REFIID riid, void **ppvOut);
        STDMETHOD(LockServer)(BOOL);
        //
        // Instance generator.
        //
        static HRESULT CreateInstance(REFIID riid, void **ppvOut);

    private:
        LONG m_cRef;
        //
        // Force use of instance generator.
        //
        CAutoUpdateClassFactory(void);
        //
        // Prevent copy.
        //
        CAutoUpdateClassFactory(const CAutoUpdateClassFactory& rhs);              // not implemented.
        CAutoUpdateClassFactory& operator = (const CAutoUpdateClassFactory& rhs); // not implemented.
};


//
// Instance generator.
//
HRESULT
CAutoUpdateClassFactory::CreateInstance(  // [static]
    REFIID riid,
    void **ppvOut
    )
{
    HRESULT hr = E_OUTOFMEMORY;
    CAutoUpdateClassFactory *pFactory = new CAutoUpdateClassFactory();
    if (NULL != pFactory)
    {
        hr = pFactory->QueryInterface(riid, ppvOut);
        pFactory->Release();
    }
    return hr;
}



CAutoUpdateClassFactory::CAutoUpdateClassFactory(void)
    : m_cRef(1)
{
    DllAddRef();
}



CAutoUpdateClassFactory::~CAutoUpdateClassFactory(void)
{
    DllRelease();
}



STDMETHODIMP
CAutoUpdateClassFactory::QueryInterface(
    REFIID riid,
    void **ppvOut
    )
{
    HRESULT hr = E_NOINTERFACE;

    if (NULL == ppvOut)
        return E_INVALIDARG;

    *ppvOut = NULL;
    if (IID_IClassFactory == riid || IID_IUnknown == riid)
    {
        *ppvOut = static_cast<IClassFactory *>(this);
    }
    if (NULL != *ppvOut)
    {
        ((LPUNKNOWN)*ppvOut)->AddRef();
        hr = NOERROR;
    }
    return hr;
}



STDMETHODIMP_(ULONG) CAutoUpdateClassFactory::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
}



STDMETHODIMP_(ULONG) CAutoUpdateClassFactory::Release(void)
{
    if (InterlockedDecrement(&m_cRef))
        return m_cRef;

    delete this;
    return 0;
}



STDMETHODIMP
CAutoUpdateClassFactory::CreateInstance(
    IUnknown *pUnkOuter,
    REFIID riid,
    void **ppvOut
    )
{
    HRESULT hr = CLASS_E_NOAGGREGATION;

	if (NULL == ppvOut)
	{
		return E_INVALIDARG;
	}
    *ppvOut = NULL;

    if (NULL == pUnkOuter)
    {
        if (IID_IShellExtInit == riid ||
            IID_IShellPropSheetExt == riid ||
            IID_IUnknown == riid)
        {
            hr = CAutoUpdatePropSheet_CreateInstance(g_hInstance, riid, ppvOut);
        }
        else
        {
            hr = E_NOINTERFACE;
        }
    }
    return hr;
}



STDMETHODIMP
CAutoUpdateClassFactory::LockServer(
    BOOL fLock
    )
{
    if (fLock)
        DllAddRef();
    else
        DllRelease();

    return S_OK;
}


//-----------------------------------------------------------------------------
// Standard COM server exports.
//-----------------------------------------------------------------------------

STDAPI
DllGetClassObject(
    REFCLSID rclsid,
    REFIID riid,
    void **ppvOut
    )
{
    HRESULT hr = CLASS_E_CLASSNOTAVAILABLE;

	if (NULL == ppvOut)
	{
		return E_INVALIDARG;
	}
    *ppvOut = NULL;

    if (__uuidof(CAutoUpdatePropSheet) == rclsid)
    {
        hr = CAutoUpdateClassFactory::CreateInstance(riid, ppvOut);
    }
    return hr;
}



STDAPI DllCanUnloadNow(void)
{
    HRESULT hr = (0 == g_cRefDll ? S_OK : S_FALSE);
    return hr;
}



STDAPI_(void) DllAddRef(void)
{
    InterlockedIncrement(&g_cRefDll);
}



STDAPI_(void) DllRelease(void)
{
    InterlockedDecrement(&g_cRefDll);
}



BOOL APIENTRY 
DllMain( 
    HANDLE hModule, 
    DWORD  dwReason, 
    LPVOID /*lpReserved*/
    )
{
    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
            g_hInstance = (HINSTANCE)hModule;
            DisableThreadLibraryCalls(g_hInstance);
            break;

        case DLL_THREAD_ATTACH:
        case DLL_THREAD_DETACH:
        case DLL_PROCESS_DETACH:
	    break;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\wuaueng\aucpl.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       aucpl.h
//
//--------------------------------------------------------------------------

#pragma once

STDAPI_(void) DllAddRef(void);
STDAPI_(void) DllRelease(void);

extern HINSTANCE  g_hInstance;

class AUSetup {
public:
	HRESULT m_SetupNewAU(void);
private:
	static const LPCTSTR mc_WUFilesToDelete[] ;
	static const LPCTSTR mc_WUDirsToDelete[];
	void mi_CleanUpWUDir();
	HRESULT mi_CreateAUService(BOOL fStandalone);
//    BOOL m_IsWin2K(); 
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\wuaueng\audownload.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       catalog.cpp
//
//--------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop


extern CLIENT_HANDLES  ghClientHandles;
extern ENGINE_EVENTS EngineEvents;

const WCHAR AUJOBNAME[] = L"Windows Update";


void DoDownloadStatus(
					DWORD dwDownloadMsg,
					IBackgroundCopyJob *pBGJob,
					IBackgroundCopyError *pBGErr)
{
	DEBUGMSG("WUAUENG DoDownloadStatus!");

    switch(dwDownloadMsg)
    {
		case CATMSG_TRANSIENT_ERROR:
			{
#ifdef DBG
				if (NULL == pBGErr &&
					S_OK != pBGJob->GetError(&pBGErr))
				{
//					break;
				}
				else
				{
        				HRESULT hrErr;
        				BG_ERROR_CONTEXT bgErrContext;

        				// Formulate error message
        				(void) pBGErr->GetError(&bgErrContext, &hrErr);
        				DEBUGMSG("WUAUENG DoDownloadStatus - TRANSIENT_ERROR %#lx (context=%d)", hrErr, bgErrContext);
        				pBGErr->Release();
				}
#endif
				EngineEvents.SetEvent(IDOWNLOAD_TRANSIENT_ERROR_EVT); 				
			}
			break;
		case CATMSG_DOWNLOAD_IN_PROGRESS:
			{
				DEBUGMSG("WUAUENG DoDownloadStatus - DOWNLOAD_IN_PROGRESS");
				EngineEvents.SetEvent(IDOWNLOAD_DOWNLOAD_IN_PROGRESS);
			}
			break;
        case CATMSG_DOWNLOAD_COMPLETE:            // Ping required
			{
				// Send ping for each successfully downloaded item.
				DEBUGMSG("WUAUENG DoDownloadStatus - file download done");
				EngineEvents.SetEvent(IDOWNLOAD_COMPLETE_EVT);
			}
			break;
		case CATMSG_DOWNLOAD_ERROR:
            {
				DEBUGMSG("WUAUENG DoDownloadStatus - DOWNLOAD_ERROR");
				//DEBUGMSG("WUAUENG DoDownloadStatus() ping error puid %d and error description %S", ptDownloadStatusData->m_errPuid, ptDownloadStatusData->m_tszErrDesc);

				IBackgroundCopyFile *pBGFile = NULL;

				// Found out which item caused the download error
				if (SUCCEEDED(pBGErr->GetFile(&pBGFile)))
				{
					BSTR bstrErrorItemId;	// only used if dwDownloadMsg == CATMSG_DOWNLOAD_ERROR
					LPWSTR pwszLocalFileName = NULL;

					(void) pBGFile->GetLocalName(&pwszLocalFileName);

					// Ping for download failure
					if (NULL != (bstrErrorItemId = gpAUcatalog->FindItemIdByLocalFileName(pwszLocalFileName)))
					{
						HRESULT hrErr;
						BG_ERROR_CONTEXT bgErrContext;
						TCHAR tszMessage[30];

						// Formulate error message
						(void) pBGErr->GetError(&bgErrContext, &hrErr);
                        (void)StringCchPrintfEx(tszMessage, ARRAYSIZE(tszMessage), NULL, NULL, MISTSAFE_STRING_FLAGS, _T("ctx=%d"), bgErrContext);
						gPingStatus.PingDownload(
							FALSE,
							URLLOGSTATUS_Failed,
							hrErr,
							W2T(bstrErrorItemId),
							NULL,
							tszMessage);
					}
					CoTaskMemFree(pwszLocalFileName);

					pBGFile->Release();
				}
#ifdef DBG
				else
				{
					DEBUGMSG("WUAUENG DoDownloadStatus failed to get IBackgroundCopyFile object");
				}
#endif
			}
			break;
        default:
            DEBUGMSG("WUAUENG DoDownloadStatus - invalid message");
            break;
    }
}


CAUDownloader::~CAUDownloader()
{
       IBackgroundCopyJob  * pjob;
       HRESULT hr ;
	// fixcode optimization check if m_refs != 0
	DEBUGMSG("CAUDownloader::~CAUDownloader() starts");
	
	if ( SUCCEEDED(FindDownloadJob(&pjob)))
	{
		DEBUGMSG("Found bits notify interface to release");
		if (FAILED(hr = pjob->SetNotifyInterface(NULL)))
		{
			DEBUGMSG(" failed to delete job notification interface %#lx", hr);
		}
		pjob->Release();
	}

	if ( FAILED(hr = CoDisconnectObject((IUnknown *)this, 0)) )
	{
		DEBUGMSG("CoDisconnectObject() failed %#lx", hr);
	}

	DEBUGMSG("WUAUENG: CAUDownloader destructed with m_refs = %d", m_refs);
}	

///////////////////////////////////////////////////////////////////////////////////
// when service starts up, find last download job if there is one and reconnect AU to drizzle 
//////////////////////////////////////////////////////////////////////////////////
HRESULT CAUDownloader::ContinueLastDownloadJob(/*const GUID & downloadid*/)
{	
    HRESULT hr = E_FAIL;
    IBackgroundCopyJob * pjob = NULL;
    DEBUGMSG("CAUDownloader::ContinueLastDownloadJob() starts");
       if (GUID_NULL != m_DownloadId)
        {
            if (SUCCEEDED(hr = FindDownloadJob(&pjob)) && SUCCEEDED(hr = ReconnectDownloadJob()))
                {
                DEBUGMSG("found and connected to previous download job ");
                goto done;
                }
            else
                {
                DEBUGMSG("fail to find or connect to previous download job");
                m_DownloadId = GUID_NULL;
                }
       }
done:           
       SafeRelease(pjob);
       DEBUGMSG("CAUDownloader::ContinueLastDownloadJob() ends");
	return hr;
}


HRESULT CAUDownloader::CreateDownloadJob(IBackgroundCopyJob **ppjob)
{
    IBackgroundCopyManager * pmanager = NULL;
    HRESULT hr;

    *ppjob = NULL;
     m_DownloadId = GUID_NULL;
    if (FAILED(hr = CoCreateInstance(__uuidof(BackgroundCopyManager),
                                     NULL,
                                     CLSCTX_LOCAL_SERVER,
                                     __uuidof(IBackgroundCopyManager),
                                     (void **)&pmanager )))
     {
       DEBUGMSG("CreateDownloadJob : create manager failed %x ", hr);
       goto done;
     }

    if (FAILED(hr=pmanager->CreateJob( AUJOBNAME ,
                                      BG_JOB_TYPE_DOWNLOAD,
                                      &m_DownloadId,
                                      ppjob )))
      {
        DEBUGMSG("CreateDownloadJob : create job failed %x ", hr);
        goto done;
      }

    {
    DWORD fFullBandwidth = 0;;

    // change job priority to full bandwidth if appropriate reg key set.
	if ( SUCCEEDED(GetRegDWordValue(L"FullBandwidth", &fFullBandwidth)) && fFullBandwidth )
    {
        HRESULT hr1 = (*ppjob)->SetPriority(BG_JOB_PRIORITY_FOREGROUND);
        DEBUGMSG("CAUDownloader::CreateDownloadJob -- FULL BANDWIDTH, hr = %#lx", hr1);
    }
    }

#ifdef DBG
	WCHAR szGUID[50]; //really need 39 bytes
	int iret;
	
	iret = StringFromGUID2(m_DownloadId, //GUID to be converted  
						szGUID,  //Pointer to resulting string
						ARRAYSIZE(szGUID));//Size of array at lpsz
	if (0 != iret)
	{
		DEBUGMSG("WUAUENG m_DownloadId = %S", szGUID);
	}
#endif

	if (FAILED(hr = SetDrizzleNotifyInterface()))
        {
        DEBUGMSG("CreateDownloadJob : set notification interface failed %x", hr);
    	}
done:
       SafeRelease(pmanager);
	if (FAILED(hr))
	{
        Reset();
        SafeReleaseNULL(*ppjob);
        }
        return hr;
}


HRESULT CAUDownloader::FindDownloadJob(IBackgroundCopyJob ** ppjob)
{
    IBackgroundCopyManager * pmanager = NULL;
    HRESULT hr;

    if (FAILED(hr = CoCreateInstance(__uuidof(BackgroundCopyManager),
                                     NULL,
                                     CLSCTX_LOCAL_SERVER,
                                     __uuidof(IBackgroundCopyManager),
                                     (void **)&pmanager )))
        {
        DEBUGMSG("FindDownloadJob : create manager failed %x ", hr);
        goto done;
        }

    if (FAILED(hr=pmanager->GetJob(m_DownloadId, ppjob )))
        {
        //            DEBUGMSG("FindDownloadJob : get job failed %x ", hr); //might be expected
        }
done:
    SafeRelease(pmanager);
    return hr;
}



STDMETHODIMP
CAUDownloader::JobTransferred(
    IBackgroundCopyJob * pjob
    )
{
    HRESULT hr;

#if DBG
    //
    // Make sure the right job is finished.
    //
    {
    GUID jobId;

    if (FAILED( hr= pjob->GetId( &jobId )))
        {
        return hr;
        }

    if ( jobId != m_DownloadId )
        {
        DEBUGMSG("notified of completion of a download job that I don't own");
        }
    }
#endif

    //
    // Transfer file ownership from downloader to catalogue.
    //
    if (FAILED(hr= pjob->Complete()))
        {
        return hr;
        }

    m_DoDownloadStatus(CATMSG_DOWNLOAD_COMPLETE, pjob, NULL);

    m_dwJobState = NO_BG_JOBSTATE;	
    m_DownloadId = GUID_NULL;
    return S_OK;
}

STDMETHODIMP
CAUDownloader::JobError(
    IBackgroundCopyJob * pjob,
    IBackgroundCopyError * perror
    )
{
    // download encounter error
	m_DoDownloadStatus(CATMSG_DOWNLOAD_ERROR, pjob, perror);

	HRESULT hr;
	BG_ERROR_CONTEXT bgEContext;
	if (SUCCEEDED(perror->GetError(&bgEContext, &hr)))
	{
		DEBUGMSG("WUAUNEG JobError callback Context = %d, hr = 0x%x",bgEContext, hr);
	}

       Reset();
       m_FinishReason = JOB_ERROR;
       return S_OK;
}

STDMETHODIMP
CAUDownloader::JobModification(
    IBackgroundCopyJob * pjob,
    DWORD  /*dwReserved*/
    )
{
    BG_JOB_STATE state;
	HRESULT hr;
    if (FAILED(hr= pjob->GetState(&state)))
        {
        return hr;
        }

	if (m_dwJobState == state)
	{
		goto Done;
	}
	DEBUGMSG("WUAUENG JobModification callback");
	switch (state)
	{
	case BG_JOB_STATE_QUEUED: 	
		DEBUGMSG("WUAUENG JobModification: Drizzle notified BG_JOB_STATE_QUEUED");
		ghClientHandles.ClientRemoveTrayIcon();
		break;
	case BG_JOB_STATE_TRANSFERRING:
		DEBUGMSG("WUAUENG JobModification: Drizzle notified BG_JOB_STATE_TRANSFERRING");
		m_DoDownloadStatus(CATMSG_DOWNLOAD_IN_PROGRESS, pjob, NULL);
		ghClientHandles.ClientAddTrayIcon();
		break;
	case BG_JOB_STATE_TRANSIENT_ERROR:
		{
			DEBUGMSG("WUAUENG JobModification: Drizzle notified BG_JOB_STATE_TRANSIENT_ERROR");
			m_DoDownloadStatus(CATMSG_TRANSIENT_ERROR, pjob, NULL);
			break;
		}		
	case BG_JOB_STATE_SUSPENDED:
	case BG_JOB_STATE_ERROR:			//What about BG_JOB_STATE_ERROR ?
	case BG_JOB_STATE_TRANSFERRED:
	case BG_JOB_STATE_ACKNOWLEDGED:	
    case BG_JOB_STATE_CONNECTING:
		{
			DEBUGMSG("WUAUENG JobModification: Drizzle notified BG_JOB_STATE = %d", state);
			break;
		}
	default:
		{
		DEBUGMSG("WUAUENG Drizzle notified unexpected BG_JOB_STATE %d",state);
		}
	}
	m_dwJobState = state;
Done:
	return S_OK;
}

HRESULT CAUDownloader::SetDrizzleNotifyInterface()
{
	HRESULT hr ;
       IBackgroundCopyJob * pjob = NULL;
       
       if (FAILED(hr = FindDownloadJob(&pjob)))
        {
            DEBUGMSG("CAUDownloader::SetDrizzleNotifyInterface() got no download job with error %#lx", hr);
            goto done;
        }
	if (FAILED(hr = pjob->SetNotifyFlags(DRIZZLE_NOTIFY_FLAGS)))
	{
		DEBUGMSG("WUAUENG SetDrizzleNotifyInterface: set notification flags failed %#lx", hr);
	}
	else if (FAILED(hr = pjob->SetNotifyInterface(this)))
	{
		DEBUGMSG("WUAUENG SetDrizzleNotifyInterface: set notification interface failed %#lx", hr);
	}
	
done:
       SafeRelease(pjob);
	return hr;
}

///////////////////////////////////////////////////////////////////////////////////////
// helper function to connect AU to the job got using its GUID
//////////////////////////////////////////////////////////////////////////////////////
HRESULT CAUDownloader::ReconnectDownloadJob()
{
	BG_JOB_STATE state;		
	HRESULT hr = E_FAIL;
       IBackgroundCopyJob * pjob = NULL;
       
	DEBUGMSG("ReconnectDownloadJob() starts");
	if ( (FAILED(hr = FindDownloadJob(&pjob)))
	   || FAILED(hr = pjob->GetState(&state)))
	{  
	    DEBUGMSG("get no download job or fail to get job state");
           goto Done;
	}	
	switch (state)
	{
	case BG_JOB_STATE_QUEUED: 
	case BG_JOB_STATE_TRANSFERRING:
	case BG_JOB_STATE_CONNECTING:
	case BG_JOB_STATE_TRANSIENT_ERROR:
	case BG_JOB_STATE_SUSPENDED:		
	case BG_JOB_STATE_ERROR:
		{
			DEBUGMSG("WUAUENG Trying to connect to drizzle again");
			if (FAILED(hr = SetDrizzleNotifyInterface()))
			{
				goto Done;				
			}			
			//fixcode: why need resume if error?
			if (BG_JOB_STATE_ERROR == state)
			{
				pjob->Resume();		//REVIEW, Is this really what we want to do?
			}
			break;
		}				
	case BG_JOB_STATE_TRANSFERRED:
		{
			DEBUGMSG("WUAUENG  Got BG_JOB_STATE_TRANSFERRED should work ok");
			if (FAILED(hr = pjob->Complete()))
			{
				goto Done;
			}
			m_DoDownloadStatus(CATMSG_DOWNLOAD_COMPLETE, pjob, NULL);

			break;
		}
	case BG_JOB_STATE_ACKNOWLEDGED:
		{
			//If the job was already acknowledged, we are assuming that the engine can continue
			DEBUGMSG("WUAUENG : Got BG_JOB_STATE_ACKNOWLEDGED should work ok");
			break;
		}
	case BG_JOB_STATE_CANCELLED:
		{
			DEBUGMSG("WUAUENG : Got BG_JOB_STATE_CANCELLED, should start again");
			goto Done;			
		}
	default:
		{
		DEBUGMSG("WUAUENG Drizzle notified unexpected BG_JOB_STATE");		
		}
	}
	hr = S_OK;
	m_dwJobState = state;	
Done:
       SafeRelease(pjob);
       if (FAILED(hr))
        {
           Reset();
        }
     	DEBUGMSG("ReconnectDownloadJob() ends with result %#lx", hr);
	return hr;
}



/*****
CAUDownloader::QueueDownloadFile() adds a file to download to drizzle's 

RETURNS:
    S_OK:    
*****/
HRESULT CAUDownloader::QueueDownloadFile(LPCTSTR pszServerUrl,				// full http url
			LPCTSTR pszLocalFile				// local file name
			)
{
    HRESULT hr = S_OK;

    DEBUGMSG("CAUDownloader::DownloadFile() starts");
    
    IBackgroundCopyJob * pjob = NULL;
    if (FAILED(hr = FindDownloadJob(&pjob)))
    {
         DEBUGMSG("no existing download job, create one ");
         if (FAILED(hr = CreateDownloadJob(&pjob)))
            {
            DEBUGMSG("fail to create a new download job");
            goto done;
            }
     }

    //fixcode: do we need to pause job first before adding files
    
    //
    // Add the file to the download job.
    //
   hr = pjob->AddFile( pszServerUrl, pszLocalFile);
    if (FAILED(hr))
    {
        DEBUGMSG(" adding file failed with %#lx", hr);
        goto done;
    }

done:
       SafeRelease(pjob);
	if ( FAILED(hr) )
	{
		Reset();
	}
      return hr;
}


HRESULT CAUDownloader::StartDownload()
{
    HRESULT hr = E_FAIL;
    IBackgroundCopyJob * pjob = NULL;

    if (FAILED(hr = FindDownloadJob(&pjob)))
        {
        DEBUGMSG(" fail to get download job with error %#lx", hr);
        goto done;
        }
    if (FAILED(hr = pjob->Resume()))
    {
        DEBUGMSG("  failed to start the download job");
    }
done:
    SafeRelease(pjob);
    if (FAILED(hr))
        {
           Reset();
        }
    return hr;
}

//////////////////////////////////////////////////////////////////////////////////
// cancel the job and reset CAUDownloader's state 
/////////////////////////////////////////////////////////////////////////////////
void CAUDownloader::Reset()
{
    IBackgroundCopyJob * pjob = NULL;

    if (SUCCEEDED(FindDownloadJob(&pjob)))
        {
            pjob->Cancel();
            pjob->Release();
            EngineEvents.SetEvent(IDOWNLOAD_DOWNLOAD_CANCELED);				
            DEBUGMSG("Reset() job cancelled and released");
        }
    m_DownloadId = GUID_NULL;
}

HRESULT CAUDownloader::DrizzleOperation(DRIZZLEOPS dop)
{
    HRESULT hrRet;
    IBackgroundCopyJob * pjob = NULL;
    if (FAILED(hrRet = FindDownloadJob(&pjob)))
    {
        DEBUGMSG("CAUDownloader::DrizzleOperation() on an invalid job");
        goto done;
    }
    switch (dop)
    	{
	case  DRIZZLEOPS_CANCEL: 
		DEBUGMSG("Catalog: Canceling Drizzle Job");
		hrRet =pjob->Cancel();
		EngineEvents.SetEvent(IDOWNLOAD_DOWNLOAD_CANCELED);				
		break;
	case DRIZZLEOPS_PAUSE:
		DEBUGMSG("Catalog: Pausing Drizzle Job");
		hrRet = pjob->Suspend();		
		break;
	case DRIZZLEOPS_RESUME:
		DEBUGMSG("Catalog: Resuming Drizzle Job");
		hrRet = pjob->Resume();		
		break;
    	}
done:
    SafeRelease(pjob);
    return hrRet;
}

/// pdwstatus actually contains the jobstate
HRESULT CAUDownloader::getStatus(DWORD *pdwPercent, DWORD *pdwstatus)
{
    BG_JOB_PROGRESS progress;
    BG_JOB_STATE state;
    HRESULT hr = S_OK;
    IBackgroundCopyJob * pjob = NULL;

    if (FAILED(hr = FindDownloadJob(&pjob)))
        {
        DEBUGMSG(" getStatus : no download job with error %#lx", hr);
        goto done;
        }

    if (FAILED(hr = pjob->GetState( &state )))
        {
	    DEBUGMSG("WUAUENG: job->GetState failed");
           state = BG_JOB_STATE_QUEUED;
           goto done;
        }

    if (FAILED(hr = pjob->GetProgress( &progress )))
        {
	    DEBUGMSG("WUAUENG: job->GetProgress failed");
	    goto done;
        }
    
    if (progress.BytesTotal != BG_SIZE_UNKNOWN )
       {
           *pdwPercent = DWORD( 100 * float(progress.BytesTransferred) / float(progress.BytesTotal) );
           DEBUGMSG("getStatus is %d percent", *pdwPercent);
       }
     else
        {
            DEBUGMSG("getStatus, progress.BytesTotal= BG_SIZE_UNKNOWN, BytesTransfered = %d",progress.BytesTransferred);
           *pdwPercent = 0;       
        }

	*pdwstatus =  state;

done:
    SafeRelease(pjob);
    return hr;
}


HRESULT STDMETHODCALLTYPE
CAUDownloader::QueryInterface(
    REFIID riid,
    void __RPC_FAR *__RPC_FAR *ppvObject
    )
{
    HRESULT hr = S_OK;
    *ppvObject = NULL;

    if (riid == __uuidof(IUnknown) ||
        riid == __uuidof(IBackgroundCopyCallback) )
        {
        *ppvObject = (IBackgroundCopyCallback *)this;
        ((IUnknown *)(*ppvObject))->AddRef();
        }
    else
        {
        hr = E_NOINTERFACE;
        }

    return hr;
}

ULONG STDMETHODCALLTYPE
CAUDownloader::AddRef()
{
    long cRef = InterlockedIncrement(&m_refs);
	DEBUGMSG("CAUDownloader AddRef = %d", cRef);
	return cRef;
}

ULONG STDMETHODCALLTYPE
CAUDownloader::Release()
{
    long cRef = InterlockedDecrement(&m_refs);
	DEBUGMSG("CAUDownloader Release = %d", cRef);
	return cRef;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\wuaueng\aucatalog.cpp ===
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       aucatalog.cpp
//
//  Purpose:	AU catalog file using IU 
//
//  Creator:	WeiW
//
//  History:	08-15-01 	first created
//
//--------------------------------------------------------------------------
#include "pch.h"
#pragma hdrstop


const LPTSTR ITEM_FILE = _T("item.xml");
const LPTSTR DRIVERS_FILE = _T("drivers.xml");
const LPTSTR CATALOG_FILE = _T("catalog.xml");
const LPTSTR DETAILS_FILE = _T("details.xml");


//following files are write once and never be read. 
#ifdef DBG
const LPTSTR DRIVER_SYSSPEC_FILE = _T("driversys.xml");
const LPTSTR NONDRIVER_SYSSPEC_FILE = _T("nondriversys.xml");
const LPTSTR PROVIDER_FILE = _T("provider.xml");
const LPTSTR PRODUCT_FILE = _T("product.xml");
const LPTSTR DETECT1_FILE = _T("detect1.xml");
const LPTSTR DETECT2_FILE = _T("detect2.xml");
const LPTSTR DETECT3_FILE = _T("detect3.xml");
const LPTSTR INSTALL_FILE = _T("install.xml");
#endif

#ifdef DBG
const TCHAR REG_AUCATLIFESPAN[] = _T("CatLifeSpan"); //REG_DWORD
const TCHAR REG_AUCATOFFLINELIFESPAN[] = _T("CatOfflineLifeSpan"); //REG_DWORD
#endif


BSTR AUCatalog::AUPROVIDERQUERY;
BSTR AUCatalog::AUPRODUCTQUERY;
BSTR AUCatalog::AUITEMQUERY;
BSTR AUCatalog::AUDETAILSQUERY;
BSTR AUCatalog::AUDRIVERSQUERY;
BSTR AUCatalog::PRODUCT_PRUNE_PATTERN; 
BSTR AUCatalog::DETAILS_PRUNE_PATTERN;
BSTR AUCatalog::AUDRIVERSYSCLASS;
BSTR AUCatalog::AUNONDRIVERSYSCLASS;
BSTR AUCatalog::bstrParentItems;
BSTR AUCatalog::bstrItemID;
BSTR AUCatalog::bstrTagAUCATALOG;
BSTR AUCatalog::bstrAttrVERSION;
BSTR AUCatalog::bstrAttrDOWNLOADID;
BSTR AUCatalog::bstrAttrITEMCOUNT;
BSTR AUCatalog::bstrAttrUpdateDriver;
BSTR AUCatalog::bstrAttrSTATUS;
BSTR AUCatalog::bstrHiddenItems;
BSTR AUCatalog::bstrTagITEM;
BSTR AUCatalog::bstrAttrID;
BSTR AUCatalog::bstrProviderNamePattern;
BSTR AUCatalog::bstrItemIDPattern;
BSTR AUCatalog::bstrTitlePattern;
BSTR AUCatalog::bstrDescPattern;
BSTR AUCatalog::bstrRTFUrlPattern;
BSTR AUCatalog::bstrEulaUrlPattern;
BSTR AUCatalog::bstrExclusiveItemPattern;
BSTR AUCatalog::bstrItemIdsPattern;
BSTR AUCatalog::bstrTemplate;
BSTR AUCatalog::bstrResultTemplate;
BSTR AUCatalog::bstrCatalog;


inline BOOL FServiceShuttingDown()
{
    return WaitForSingleObject(ghServiceFinished, 0) == WAIT_OBJECT_0;
}

#ifdef DBG
inline BOOL fDBGUseLocalFile()
{
    DWORD dwLevel;
    if (FAILED(GetRegDWordValue(TEXT("UseLocalFile"), &dwLevel)) || 1 != dwLevel)
        {
            return FALSE;
        }
    
    return TRUE;
}
#endif

AUCatalog::~AUCatalog(void)
{
    Clear();
    SafeFreeBSTR(m_bstrClientInfo);
    SafeFreeBSTR(m_bstrDriverClientInfo);
}

//always called before any other method on AUCatalog is used.
HRESULT AUCatalog::Init()
{
    HRESULT hr = S_OK;
    m_fNeedToContinueJob = FALSE;
    m_bstrInstallation = NULL;
    m_fUpdateDriver = !gpState->fWin2K();
    m_dwCatLifeSpan = CATALOG_LIFESPAN;
    m_dwOfflineCatLifeSpan = CATALOG_OFFLINE_LIFESPAN;

    ZeroMemory(&m_stExpireTime, sizeof(m_stExpireTime)) ;
    ZeroMemory(&m_stOfflineExpireTime, sizeof(m_stOfflineExpireTime));

	m_bstrClientInfo = SysAllocString(AUCLIENTINFO);
	m_bstrDriverClientInfo = SysAllocString(AUDRIVERCLIENTINFO);
	if (NULL == m_bstrClientInfo || NULL == m_bstrDriverClientInfo)
	{
	    DEBUGMSG("AUCatalog::Init() fail to alloc string for client info");
		hr = E_FAIL;
		goto end;
	}

#ifdef DBG
	if (FAILED(GetRegDWordValue(REG_AUCATLIFESPAN, &m_dwCatLifeSpan)))
	{
		m_dwCatLifeSpan = CATALOG_LIFESPAN;
	}

	 if (FAILED(GetRegDWordValue(REG_AUCATOFFLINELIFESPAN, &m_dwOfflineCatLifeSpan)))
	{
		m_dwOfflineCatLifeSpan = CATALOG_OFFLINE_LIFESPAN;
	}
#endif

end:
	return hr;
}


//////////////////////////////////////////////////////////////////////
// clear out more dynamic internal data
/////////////////////////////////////////////////////////////////////
void AUCatalog::Clear()
{
       m_ItemList.Clear();
	SafeFreeBSTRNULL(m_bstrInstallation);
       ZeroMemory(&m_stExpireTime, sizeof(m_stExpireTime));
       ZeroMemory(&m_stOfflineExpireTime, sizeof(m_stOfflineExpireTime));
}


HRESULT AUCatalog::GetSystemSpec(DETECTLEVEL enLevel, BSTR * pbstrSysSpec)
{
	HRESULT hr = E_FAIL;
	if (FServiceShuttingDown())
        {
            DEBUGMSG("Skip AUCatalog::GetSystemSpec() because service is shutting down");
            hr = E_ABORT;
            goto done;
        }


	BSTR bstrSysClass = (DRIVERS_LEVEL == enLevel) ? AUDRIVERSYSCLASS : AUNONDRIVERSYSCLASS;
	hr = m_pfnGetSystemSpec(m_hIUEngineInst, bstrSysClass, 0, pbstrSysSpec); //online mode

#ifdef DBG	   
	if (SUCCEEDED(hr))
	{
		LOGXMLFILE((DRIVERS_LEVEL == enLevel) ? DRIVER_SYSSPEC_FILE : NONDRIVER_SYSSPEC_FILE, *pbstrSysSpec);
	}
#endif	
done:
	return hr;
}


////////////////////////////////////////////////////////////////////////////////
// compose query based on a format and items picked out from detection result
//
HRESULT AUCatalog::GetQuery(IN DETECTLEVEL enLevel, IN BSTR bstrDetectResult, OUT BSTR *pbstrQuery)
{
	BSTR bstrPrunePattern;
	BSTR bstrQuery = NULL;
    HRESULT hr = S_OK;
	IXMLDOMNodeList *pItems = NULL;
    IXMLDOMNode *pParentItems = NULL; 
  	IXMLDOMDocument *pQueryXML= NULL;
	IXMLDOMDocument *pResultXML= NULL;


	DEBUGMSG("GetQuery() starts");
	AUASSERT(NULL != pbstrQuery);
    *pbstrQuery = NULL;
	switch (enLevel)
	{
	case PROVIDER_LEVEL:
			bstrQuery = AUPROVIDERQUERY;
			break;
	case DRIVERS_LEVEL:
	              bstrQuery = AUDRIVERSQUERY;
	              break;
	case PRODUCT_LEVEL:
			bstrQuery = AUPRODUCTQUERY;
			bstrPrunePattern = PRODUCT_PRUNE_PATTERN;
			break;
	case ITEM_LEVEL:
			bstrQuery = AUITEMQUERY;
			bstrPrunePattern = PRODUCT_PRUNE_PATTERN; //the same as product pruning logic
			break;
	case DETAILS_LEVEL:
			bstrQuery = AUDETAILSQUERY;
			bstrPrunePattern = DETAILS_PRUNE_PATTERN;
			break;
	default:
			AUASSERT(FALSE); //should never be here
			return E_INVALIDARG;
	}


	if (FAILED(hr = LoadXMLDoc(bstrQuery, &pQueryXML, TRUE)))
        {
          DEBUGMSG("GetQuery() fail to load query XML with error %#lx", hr);
           goto done;
        }

	if (enLevel != PROVIDER_LEVEL && DRIVERS_LEVEL != enLevel)
	{
		if (FAILED(hr = LoadXMLDoc(bstrDetectResult, &pResultXML, TRUE)))
		    {
		    DEBUGMSG("GetQuery() fail to load XML for detect result with error %#lx", hr);
		    goto done;
		    }

		if (FAILED(hr = pResultXML->selectNodes(bstrPrunePattern, &pItems)))
		{
			DEBUGMSG("GetQuery() fail to select node or nothing to select with error %#lx", hr);
			goto done;
		}

		long lLen = 0;
		if (FAILED(hr = pItems->get_length(&lLen)))
		{
			DEBUGMSG("GetQuery() fail to get item number with error %#lx", hr);
			goto done;
		}
		DEBUGMSG("GetQuery(): pruning result %d items", lLen);
		if (0 == lLen)
		    {
		      DEBUGMSG("No updates applicable");
		      hr = S_FALSE;
                    goto done;
		    }
		if (S_OK != (hr = pQueryXML->selectSingleNode(bstrParentItems, &pParentItems)))
		{
			DEBUGMSG("GetQuery() fail to select single node %#lx or nothing to select", hr);
			hr = E_FAIL;
			goto done;
		}
		for (int i = 0; i < lLen; i++)
		{
                     IXMLDOMNode *pIdentity1 = NULL;
  		       IXMLDOMNode *pItemStatus;
			if (S_OK != (hr = pItems->get_item(i, &pItemStatus)))
			    {
                    hr = FAILED(hr) ? hr : E_FAIL;			    	
			        goto done;
			    }
			hr = pItemStatus->selectSingleNode(bstrItemID, &pIdentity1);
			pItemStatus->Release();
			if (FAILED(hr) || NULL == pIdentity1)
			{
				DEBUGMSG("GetQuery() fail to select itemID with error %#lx", hr);
				hr = FAILED(hr) ? hr : E_FAIL;
				goto done;
			}
			if (NULL == pIdentity1)
			{
				DEBUGMSG("GetQuery() fail to select itemID");
				hr = E_FAIL;
				goto done;
			}
       		    {
       			BSTR bstrItemId = NULL;
       			IXMLDOMElement *pItem= NULL;
         		       IXMLDOMText *pItemIdText = NULL;

         		       if (S_OK != (hr = pIdentity1->get_text(&bstrItemId)))
         		        {
         		            DEBUGMSG("Fail to get text for item");
                            hr = FAILED(hr) ? hr : E_FAIL;
         		        }
         		       else if (FAILED(hr = pQueryXML->createTextNode(bstrItemId, &pItemIdText)))
         		        {
         		            DEBUGMSG("Fail to create text node");
         		        }
         		       else if (FAILED (hr = pQueryXML->createElement(KEY_ITEM, &pItem)))
         		        {
         		            DEBUGMSG("GetQuery() fail to create element");
           			}
         		       else if (FAILED(hr = pItem->appendChild(pItemIdText, NULL)))
         		        {
         		            DEBUGMSG("Fail to append child");
         		        }
         		       else if (FAILED(hr = pParentItems->appendChild(pItem, NULL)))
         		        {
         		            DEBUGMSG("Fail to append child with error %#lx", hr);
         		        }

       			SafeRelease(pItem);
       			SafeRelease(pItemIdText);
       			SafeFreeBSTR(bstrItemId);
       			pIdentity1->Release();
       			if (FAILED(hr))
       			    {
       			    goto done;
       			    }
       		    }
		}
	}
	if (FAILED(hr = pQueryXML->get_xml(pbstrQuery)))
	{
		DEBUGMSG("Fail to get query xml with error %#lx", hr);
		goto done;
	}
done:
//	DEBUGMSG("GetQuery(): Query string is %S", *pbstrQuery);
	SafeRelease(pItems);
	SafeRelease(pParentItems);
	SafeRelease(pQueryXML);
	SafeRelease(pResultXML);
	if (FAILED(hr))
	{
		SafeFreeBSTRNULL(*pbstrQuery);
	}
	return hr;
}


HRESULT AUCatalog::DoDetection(IN  DETECTLEVEL enLevel, IN BSTR bstrCatalog, OUT BSTR *pbstrResult, IN BOOL fOnline)
{
       HRESULT hr = E_FAIL;
#ifdef DBG
       DWORD dwStart = GetTickCount();
#endif
	AUASSERT(m_pfnDetect != NULL);
	AUASSERT(bstrCatalog != NULL);
	AUASSERT(m_hIUEngineInst != NULL);
	AUASSERT(NULL != pbstrResult);
	*pbstrResult = NULL;
	if (FServiceShuttingDown())
        {
        DEBUGMSG("Skip AUCatalog::DoDetection() because service is shutting down");
        hr = E_ABORT;
        goto done;
        }
	hr = m_pfnDetect(m_hIUEngineInst, bstrCatalog, fOnline ? 0 : FLAG_OFFLINE_MODE, pbstrResult); 
#ifdef DBG
	if (SUCCEEDED(hr))
	{
		switch (enLevel)
		{
		case PROVIDER_LEVEL:
			LOGXMLFILE(DETECT1_FILE, *pbstrResult);
			break;
		case PRODUCT_LEVEL:
			LOGXMLFILE(DETECT2_FILE, *pbstrResult);
			break;
		case ITEM_LEVEL:
			LOGXMLFILE(DETECT3_FILE, *pbstrResult);
			break;
		default:
			AUASSERT(FALSE);
			hr = E_INVALIDARG;
			break;
		}
	}
#endif
done:
#ifdef DBG
    DEBUGMSG("DoDetection() take %d msecs", GetTickCount() - dwStart);
#endif
	if (FAILED(hr))
	{
		SafeFreeBSTRNULL(*pbstrResult);
	}
    return hr;
}

LPCTSTR AUCatalog::GetLogFile(IN DETECTLEVEL enLevel)
{
	switch (enLevel)
	{
#ifdef DBG	
	case PROVIDER_LEVEL:
		return PROVIDER_FILE;
	case PRODUCT_LEVEL:
		return PRODUCT_FILE;
#endif		
	case ITEM_LEVEL:
		return ITEM_FILE;
	case DETAILS_LEVEL:
		return DETAILS_FILE;
	case DRIVERS_LEVEL:
	        return DRIVERS_FILE;
	default:
		return NULL;
	}
}

HRESULT AUCatalog::GetManifest(IN DETECTLEVEL enLevel, IN BSTR bstrDetectResult, OUT BSTR *pbstrManifest)
{
       HRESULT hr = E_FAIL;
       BSTR bstrQuery = NULL;
       
#ifdef DBG
        DWORD dwStart= GetTickCount();
#endif
		AUASSERT(NULL != m_pfnGetManifest);
        *pbstrManifest = NULL;
	if (FServiceShuttingDown())
        {
        DEBUGMSG("Skip AUCatalog::GetManifest() because service is shutting down");
        hr = E_ABORT;
        goto done;
        }
       if (S_OK != (hr = GetQuery(enLevel, bstrDetectResult, &bstrQuery)))
        {
            goto done;
        }

       BSTR bstrSysSpec = NULL;            
       if (FAILED(hr = GetSystemSpec(enLevel, &bstrSysSpec)))
        {
           goto done;
        } 

	DEBUGMSG("WUAUENG: Calling IU getmanifest()....");
	hr = m_pfnGetManifest(m_hIUEngineInst, (DRIVERS_LEVEL == enLevel) ? m_bstrDriverClientInfo :m_bstrClientInfo,
	            bstrSysSpec, bstrQuery, FLAG_USE_COMPRESSION, pbstrManifest); //compression on
	DEBUGMSG("WUAUENG: IU getmanifest() done");	            
	SysFreeString(bstrSysSpec);
	if (FAILED(hr))
	{
		goto done;
	}

	LPCTSTR ptszLogFile = GetLogFile(enLevel);
	if (NULL != ptszLogFile)
	{
		if (FAILED(hr = LOGXMLFILE(ptszLogFile, *pbstrManifest)))
		{
			goto done;
		}
	}
	
done:
    SafeFreeBSTR(bstrQuery);
#ifdef DBG
        DEBUGMSG("GetManifest() take %d msecs", GetTickCount() - dwStart);
#endif
	if (FAILED(hr))
	{
		SafeFreeBSTRNULL(*pbstrManifest);
	}
    return hr;
}


HRESULT AUCatalog::DownloadItems()
{
//	USES_CONVERSION;
	HRESULT hr = S_OK;
	CItemDetails itemdetails;
	UINT uItemCount;
    
	DEBUGMSG("AUCatalog downloading items...");

	PersistHiddenItems(m_ItemList, URLLOGACTIVITY_Download);

       if (m_fNeedToContinueJob)
	{
        	m_fNeedToContinueJob = FALSE;
		if (SUCCEEDED(m_audownloader.ContinueLastDownloadJob()))
		{
			DEBUGMSG("found previous download job, reconnecting succeed");
			goto end;
		}
	}
#ifdef DBG
	else
	{
		DEBUGMSG("no previous download job found");
	}
#endif

	DWORD dwNumSelected = m_ItemList.GetNumSelected();
	if (0 == dwNumSelected)
	{
		hr = S_FALSE;
		DEBUGMSG("Nothing to download, bail out");
		goto end;
	}

	if (NULL == m_bstrInstallation)
	{
		DEBUGMSG("AUCatalog::DownloadItems() can't get installation xml");
		hr = E_FAIL;
		goto end;
	}

	if (!itemdetails.Init(m_bstrInstallation))
	{
		hr = E_FAIL;
		DEBUGMSG("fail to init itemdetails");
		goto end;
	}

	for (UINT i = 0; i < m_ItemList.Count(); i++)
	{
		AUCatalogItem &item = m_ItemList[i];
		if (item.fSelected() || m_ItemList.ItemIsRelevant(i))
		{
			BSTR * pCRCCabNames, *pRealCabNames, *pCabChecksums;
			UINT uCabsNum;
			BSTR bstrItemId = item.bstrID();
			BSTR bstrItemDownloadPath = itemdetails.GetItemDownloadPath(bstrItemId);
			if (NULL == bstrItemDownloadPath)
			{
				DEBUGMSG("fail to build item downloadPath");
				hr = E_FAIL;
				goto end;
			}

			if (SUCCEEDED(hr = itemdetails.GetCabNames(bstrItemId, &pCRCCabNames, &pRealCabNames, &pCabChecksums, &uCabsNum)))
			{
				DEBUGMSG("Need to download following files for %S", bstrItemId);
				for (UINT j  = 0; j < uCabsNum; j++)
				{
					TCHAR szFullFileName[MAX_PATH];
					if (SUCCEEDED(hr) &&
						SUCCEEDED(hr = StringCchCopyEx(szFullFileName, ARRAYSIZE(szFullFileName), W2T(bstrItemDownloadPath), NULL, NULL, MISTSAFE_STRING_FLAGS)))
					{
						if (SUCCEEDED(hr = PathCchAppend(szFullFileName, ARRAYSIZE(szFullFileName), W2T(pRealCabNames[j]))))
						{
							hr = m_audownloader.QueueDownloadFile(W2T(pCRCCabNames[j]), szFullFileName);
						}						
					}
					DEBUGMSG("       from %S  to %S", pCRCCabNames[j], szFullFileName);

					SafeFreeBSTR(pCRCCabNames[j]);
					SafeFreeBSTR(pRealCabNames[j]);
                    SafeFreeBSTR(pCabChecksums[j]);
                }
				free(pCRCCabNames);
				free(pRealCabNames);
                free(pCabChecksums);
			}
#ifdef DBG
			else
			{
				DEBUGMSG("fail to get cab names for %S", bstrItemId);
			}
#endif

			SysFreeString(bstrItemDownloadPath);
			if (FAILED(hr))
			{
				goto end;
			}
		}
	}
	if (SUCCEEDED(hr = m_audownloader.StartDownload()))
	{
		Serialize(); //serialize download id
	}
end: 
	itemdetails.Uninit();
	if (FAILED(hr))
	{
		m_audownloader.Reset();
	}
	DEBUGMSG("AUCatalog downloading items done");
	return hr;
}

char * AUCatalog::GetLevelStr(DETECTLEVEL enLevel)
{
	switch (enLevel)
	{
	case PROVIDER_LEVEL: return "Provider";
	case PRODUCT_LEVEL: return "Product";
	case ITEM_LEVEL: return "Item";
	case DETAILS_LEVEL: return "ItemDetails";
	default: return NULL;
	}
}

BOOL AUCatalog::hasExpired(BOOL fOffline)
{
	SYSTEMTIME	stTmp ;
	SYSTEMTIME stExpire;

	ZeroMemory(&stTmp, sizeof(stTmp));
    stExpire = fOffline ? m_stOfflineExpireTime : m_stExpireTime;
    GetSystemTime(&stTmp);
#ifdef DBG      	
	TCHAR szExpireTime[80], szCurrentTime[80];
       if (SUCCEEDED(SystemTime2String(stExpire, szExpireTime, ARRAYSIZE(szExpireTime))) 
       	  && SUCCEEDED(SystemTime2String(stTmp, szCurrentTime, ARRAYSIZE(szCurrentTime))))
       {
	     	DEBUGMSG("AUCatalog::hasExpired() expire time is %S current time is %S", szExpireTime, szCurrentTime);
       }
#endif     	
	return TimeDiff(stExpire, stTmp) >= 0;
}

HRESULT AUCatalog::setExpireTime(BOOL fOffline)
{
	SYSTEMTIME stCurrent;
	HRESULT hr = E_FAIL;
	GetSystemTime(&stCurrent);
	if (FAILED(hr = TimeAddSeconds(stCurrent, dwSecsToWait(m_dwOfflineCatLifeSpan), &m_stOfflineExpireTime)))
	{
		DEBUGMSG("Fail to calculate m_stOfflineExpireTime with error %#lx", hr);
		goto done;
	}
	if (!fOffline)
	{
	    if (FAILED(hr = TimeAddSeconds(stCurrent, dwSecsToWait(m_dwCatLifeSpan), &m_stExpireTime)))
	    {
	    	DEBUGMSG("Fail to calculate m_stExpireTime with error %#lx", hr);
	    	goto done;
	    }
	}
#ifdef DBG       
	TCHAR szCurrentTime[80], szExpireTime[80];
       if (SUCCEEDED(SystemTime2String(stCurrent, szCurrentTime, ARRAYSIZE(szCurrentTime)))
       	&& SUCCEEDED(SystemTime2String(m_stOfflineExpireTime, szExpireTime, ARRAYSIZE(szExpireTime))))
       {
	       DEBUGMSG("AUCatalog::setExpireTime with current time %S and expire time %S", szCurrentTime, szExpireTime);
       }
#endif       
	hr = S_OK;
done:
	if (FAILED(hr))
	{
		ZeroMemory(&m_stOfflineExpireTime, sizeof(m_stOfflineExpireTime));
		ZeroMemory(&m_stExpireTime, sizeof(m_stOfflineExpireTime));
	}
	return hr;
}

//when m_fUpdateDriver is FALSE, bstrDrivers are not looked at
HRESULT AUCatalog::ValidateOffline(BSTR bstrItems, BSTR bstrDrivers)
{
    HRESULT hr= E_FAIL;
    BSTR bstrResult = NULL;
    BSTR bstrQuery = NULL;
    IXMLDOMDocument *pQueryXml = NULL;
    IXMLDOMDocument *pDriversXml = NULL;

//	DEBUGMSG("ValidateOffline starts");
		if (0 == m_ItemList.Count())
		{
			hr = S_FALSE;
			goto done; //no need to validate
		}

         if (FAILED(hr = PrepareIU(FALSE)))
            {
                DEBUGMSG(" fail to prepare IU offline with error %#lx", hr);
                goto done;
            }

         if (FAILED(hr = DoDetection(ITEM_LEVEL, bstrItems, &bstrResult, FALSE)))
                {
                DEBUGMSG("Fail to detect items with error %#lx", hr);
                goto done;
                }
            if (S_OK != (hr = GetQuery(DETAILS_LEVEL, bstrResult, &bstrQuery)))
                {
                    goto done;
                }
//            DEBUGMSG("Query Result is %S", bstrQuery);
            if (FAILED(hr = LoadXMLDoc(bstrQuery, &pQueryXml, TRUE)) ||
                  (m_fUpdateDriver && FAILED(hr = LoadXMLDoc(bstrDrivers, &pDriversXml, TRUE)))) //offline
                {
                DEBUGMSG("Fail to load xml with error %#lx", hr);
                goto done;
                }

            for (UINT u = 0; u < m_ItemList.Count(); u++)
                {
                    IXMLDOMNode *pItemIdentityNode1 = NULL;
                    IXMLDOMNode *pItemNode2 = NULL;
                    CAU_BSTR aubsItemPattern;
                    CAU_BSTR aubsDriverItemIdentityPattern;
                    if (!aubsDriverItemIdentityPattern.append(L"/catalog/provider/item/identity[@itemID=\"") || !aubsDriverItemIdentityPattern.append(m_ItemList[u].bstrID()) || !aubsDriverItemIdentityPattern.append(L"\"]"))
                        {
                        DEBUGMSG("failed to create driver pattern string");
                        hr = E_OUTOFMEMORY;
                        goto done;
                        }

                    if (!aubsItemPattern.append(L"/query/dObjQueryV1/parentItems/item[.=\"") || !aubsItemPattern.append(m_ItemList[u].bstrID()) || !aubsItemPattern.append(L"\"]"))
                        {
                        DEBUGMSG("OUT OF MEMORY and failed to create pattern string");
                        hr = E_OUTOFMEMORY;
                        goto done;
                        }

                    if ((m_fUpdateDriver && HRESULT_FROM_WIN32(ERROR_NOT_FOUND) == FindSingleDOMNode(pDriversXml, aubsDriverItemIdentityPattern, &pItemIdentityNode1)
                        && HRESULT_FROM_WIN32(ERROR_NOT_FOUND) == FindSingleDOMNode(pQueryXml, aubsItemPattern, &pItemNode2)) ||
                          (!m_fUpdateDriver && HRESULT_FROM_WIN32(ERROR_NOT_FOUND) == FindSingleDOMNode(pQueryXml, aubsItemPattern, &pItemNode2)))
                    {
                        DEBUGMSG("item %S installed off band, remove it from AU's list", m_ItemList[u].bstrID());
                        m_ItemList.Remove(m_ItemList[u].bstrID());
                    }
                    SafeRelease(pItemIdentityNode1);
                    SafeRelease(pItemNode2);
                }
done:
           		FreeIU();
                SafeFreeBSTR(bstrQuery);
                SafeFreeBSTR(bstrResult);
                SafeRelease(pQueryXml);
                SafeRelease(pDriversXml);
    //           	DEBUGMSG("ValidateOffline ends");
                return hr;
}

///////////////////////////////////////////////////////////////////////////////////////
//update internal list to reflect latest applicable items
// return S_FALSE if nothing is appliable anymore
//////////////////////////////////////////////////////////////////////////////////////
HRESULT AUCatalog::ValidateItems(BOOL fOnline )
{
    HRESULT hr = S_OK;
    BSTR bstrNonDrivers = NULL, bstrDrivers = NULL;

    DEBUGMSG("AUCatalog validating items...");

    if (fOnline && !hasExpired())
	{
		DEBUGMSG("Catalog was valid and hasn't expired online. Do offline validation only");
		fOnline = FALSE;
	}
    if (!fOnline && !hasExpired(TRUE))
    {
        DEBUGMSG("Catalog was valid and hasn't expired offline. No validation needed");
        goto done;
    }

    if (fOnline)
        {
        //do online detection
         DEBUGMSG("Doing online validating");
        AUCatalogItemList olditemlist;
        if (FAILED(hr = olditemlist.Copy(m_ItemList)))
        {
        	goto done;
        }
        if (S_OK != (hr = DetectItems(TRUE))) //update instead of building from scratch
            {
                //fail to detect or no items applicable
                goto done;
            }

        BOOL fItemPulled;
        do
            {
                fItemPulled = FALSE;
                UINT uOldListLen = olditemlist.Count();
                for (UINT u=0; u < uOldListLen; u++)
                    {
                        if (m_ItemList.Contains(olditemlist[u].bstrID()) < 0)
                            {
                                DEBUGMSG("item %S is pulled from site", olditemlist[u].bstrID());
                                olditemlist.Remove(olditemlist[u].bstrID());
                                fItemPulled = TRUE;
                                break;
                            }
                    }
            }
        while (fItemPulled);
        if (FAILED(hr = m_ItemList.Copy(olditemlist))) //update item list
        {
        	goto done;
        }
      }

      if (NULL == (bstrNonDrivers =ReadXMLFromFile(ITEM_FILE))  ||
          (m_fUpdateDriver && (NULL == (bstrDrivers = ReadXMLFromFile(DRIVERS_FILE)))))
            {
              DEBUGMSG("Fail to read item or drivers xml file ");
              hr = E_FAIL;
              goto done;
            }

    if (!fOnline)
    {
        //do offline validation for non drivers
            DEBUGMSG("Doing offline validating");
            if (FAILED(hr = ValidateOffline(bstrNonDrivers, bstrDrivers)))
                {
                    DEBUGMSG("Fail to validate offline with error %#lx", hr);
                    goto done;
                }
    }
    if (m_ItemList.GetNumHidden() == m_ItemList.Count())
        {
            DEBUGMSG("No applicable items left");
            hr = S_FALSE;
            goto done;
        }


    if (FAILED(hr = BuildDependencyList(m_ItemList, bstrDrivers, bstrNonDrivers)))
        {
            DEBUGMSG("Fail to build dependency list with error %#lx", hr);
            goto done;
        }
    setExpireTime(fOnline);
    
     Serialize();
done:
    if (S_OK != hr)
        {
            Clear(); //need to redetect anyway
            DelCatFiles();
        }
    SafeFreeBSTR(bstrNonDrivers);
    SafeFreeBSTR(bstrDrivers);
    DEBUGMSG("AUCatalog done validating items");
    return hr;
}

HRESULT AUCatalog::getUpdatesList(VARIANT OUT *pvarList)
{
    SAFEARRAYBOUND bound[1] = { m_ItemList.Count() * 7, 0};
	SAFEARRAY * psa = SafeArrayCreate(VT_VARIANT, 1, bound);
	VARIANT * grVariant;
	BOOL fRet = FALSE;

	AUASSERT(NULL != pvarList);
    DEBUGMSG("AUCatalog::getUpdateList() starts");
	VariantInit(pvarList);
	if ( 0 == m_ItemList.Count() )
	{
		DEBUGMSG("AUCatalog::getUpdateList fails because getNumItems is 0");
		goto done;
	}

	if (NULL == psa || S_OK != SafeArrayAccessData(psa, (void **)&grVariant))
		goto done;	

	BOOL fError = FALSE;
	for ( UINT n = 0; n < m_ItemList.Count(); n++ )
	{
		grVariant[n*7+0].vt = VT_I4;
		grVariant[n*7+0].lVal = m_ItemList[n].dwStatus();
		grVariant[n*7+1].vt = VT_BSTR;
		grVariant[n*7+1].bstrVal = SysAllocString(m_ItemList[n].bstrID()); 
		grVariant[n*7+2].vt = VT_BSTR;
		grVariant[n*7+2].bstrVal = SysAllocString(m_ItemList[n].bstrProviderName()); 
		grVariant[n*7+3].vt = VT_BSTR;
		grVariant[n*7+3].bstrVal = SysAllocString(m_ItemList[n].bstrTitle()); 
		grVariant[n*7+4].vt = VT_BSTR;
		grVariant[n*7+4].bstrVal = SysAllocString(m_ItemList[n].bstrDescription()); 
		grVariant[n*7+5].vt = VT_BSTR;
		grVariant[n*7+5].bstrVal = SysAllocString(m_ItemList[n].bstrRTFPath()); 
		grVariant[n*7+6].vt = VT_BSTR;
		grVariant[n*7+6].bstrVal = SysAllocString(m_ItemList[n].bstrEULAPath()); 
		if ((NULL != m_ItemList[n].bstrID() && NULL == grVariant[n*7+1].bstrVal)
			|| (NULL != m_ItemList[n].bstrProviderName() && NULL == grVariant[n*7+2].bstrVal)
			|| (NULL != m_ItemList[n].bstrTitle() && NULL == grVariant[n*7+3].bstrVal)
			|| (NULL != m_ItemList[n].bstrDescription() && NULL == grVariant[n*7+4].bstrVal)
			|| (NULL != m_ItemList[n].bstrRTFPath() && NULL == grVariant[n*7+5].bstrVal)
			|| (NULL != m_ItemList[n].bstrEULAPath() && NULL == grVariant[n*7+6].bstrVal))
		{
			DEBUGMSG("OUT OF MEMORY, Fail to allocate string");
			fError = TRUE;
			break;
		}
	}
	if (FAILED(SafeArrayUnaccessData(psa)))
	{
		goto done;
		
	}
	if (!fError)
	{
		fRet = TRUE;
		pvarList->vt = VT_ARRAY | VT_VARIANT;
		pvarList->parray = psa;
	}
done:
    DEBUGMSG("AUCatalog::getUpdateList() ends");
	if (!fRet && NULL != psa)
	{
		SafeArrayDestroy(psa);
	}
	return (fRet ? S_OK : E_FAIL); 
}

//if udpate, meaning get updated information about existing items. Used in online validation. Treat exclusive and non exclusive the same
//if not update, meaning building a fresh new item list 
//return S_FALSE if nothing applicable
HRESULT AUCatalog::DetectItems(BOOL fUpdate )
{
    HRESULT hr;
    BSTR bstrNonDriverInstall = NULL, bstrDriverInstall = NULL;
    AUCatalogItemList  nonDriverList, driverList;
    BOOL fExclusiveItemFound = FALSE;
    BOOL fExclusiveDriverFound = FALSE;

    DEBUGMSG("CAUCatalog::DetectItems() starts");
    //clean up memory and local disk
    Clear();
    DelCatFiles(fUpdate);
    if (FAILED(hr = PrepareIU()))
        {
            DEBUGMSG("AUCatalog::DetectItems() fail to prepare IU %#lx", hr);
            goto done;
        }

    if (FAILED(hr = DetectNonDriverItems(&bstrNonDriverInstall, nonDriverList,  &fExclusiveItemFound)))
        {

        if (E_ABORT != hr)
            {
            DEBUGMSG(" fail to detect non driver updates %#lx", hr);
            }
        goto done;
        }
    DEBUGMSG("Non driver items got");

    if (m_fUpdateDriver)
     {
        if (FAILED(hr = DetectDriverItems(&bstrDriverInstall, driverList,  &fExclusiveDriverFound)))
            {
            if (E_ABORT != hr)
                {
                DEBUGMSG("fail to detect driver updates %#lx", hr);
                DEBUGMSG("consider driver update not essential, continue even if it fails");
                //consider driver update not essential, continue even if it fails
                m_fUpdateDriver = FALSE;  //from now on in this cycle do not care about driver any more
                }
            else
                {
                    goto done; //bail out if service shutdown
                }
            }
         DEBUGMSG("Driver items got");
        }
    else
        {
            DEBUGMSG("Driver updates not supported");
        }

    if (fExclusiveItemFound)
        {
        AUCatalogItemList dummydriverList;
        hr = MergeDetectionResult(NULL, dummydriverList, FALSE, bstrNonDriverInstall, nonDriverList, fExclusiveItemFound);
        DEBUGMSG("Exclusive item found");
        }
    else if (fExclusiveDriverFound)
        {
        AUCatalogItemList dummynonDriverList;
        hr = MergeDetectionResult(bstrDriverInstall, driverList, fExclusiveDriverFound, NULL, dummynonDriverList, FALSE);
        DEBUGMSG("Exclusive driver found");
        }
    else
        {
        hr = MergeDetectionResult(bstrDriverInstall, driverList, fExclusiveDriverFound, bstrNonDriverInstall, nonDriverList, fExclusiveItemFound);
        DEBUGMSG("Merge detection result for non driver and driver");
        }
            
    if (FAILED(hr))
    {
        DEBUGMSG("MergeDetectionResult fail with error %#lx", hr);
        goto done;
    }

    if (m_ItemList.Count() == m_ItemList.GetNumHidden())
        { //nothing to show to the user
            hr = S_FALSE;
            goto done;
        }
   
#ifdef DBG
//   m_ItemList.DbgDump();
#endif

    if (!fUpdate) 
        { 
            BSTR bstrNonDrivers;
            if (NULL == (bstrNonDrivers =ReadXMLFromFile(ITEM_FILE)))
            {
            DEBUGMSG("Fail to read item file ");
            goto done;
            }
            hr = BuildDependencyList(m_ItemList, bstrDriverInstall, bstrNonDrivers);
            SysFreeString(bstrNonDrivers);
            if (FAILED(hr))
            {
                DEBUGMSG("fail to build dependency list with error %#lx", hr);
                goto done;
            }
            hr = DownloadRTFsnEULAs(GetSystemDefaultLangID());
            DEBUGMSG("downloading RTF and EULAs %s", FAILED(hr)? "failed" : "succeeded");
            setExpireTime();
            Serialize();
        }
  done:
        FreeIU();
        SafeFreeBSTR(bstrNonDriverInstall);
        SafeFreeBSTR(bstrDriverInstall);
        if (FAILED(hr))
            {
                Clear();
            }
        DEBUGMSG("CAUCatalog::DetectItems() ends");
        return hr;
}

HRESULT AUCatalog::MergeDetectionResult(BSTR bstrDriverInstall, AUCatalogItemList & driverlist, BOOL fExclusiveDriverFound, BSTR bstrNonDriverInstall,  AUCatalogItemList & nondriverlist, BOOL fExclusiveItemFound)
{
    HRESULT hr= S_OK;
    UINT uDriverNum = driverlist.Count();
    UINT uNonDriverNum = nondriverlist.Count();

    UINT nums[2] = {uDriverNum, uNonDriverNum};
    AUCatalogItemList * pitemlists[2] = {&driverlist, &nondriverlist};

    if (fExclusiveDriverFound || fExclusiveItemFound)
        { //no merge needed
            DEBUGMSG("Exclusive driver or non driver found, no need to merge");
            AUCatalogItemList *pItemList = fExclusiveDriverFound ? &driverlist : & nondriverlist;
            BSTR bstrInstall = fExclusiveDriverFound? bstrDriverInstall : bstrNonDriverInstall;
            if (FAILED(hr = m_ItemList.Copy(*pItemList)))
                {
                goto done;
                }
            if (NULL == (m_bstrInstallation = SysAllocString(bstrInstall)))
                {
                    hr = E_OUTOFMEMORY;
                    DEBUGMSG("OUT of memory: fail to alloc string");
                    goto done;
                }
        }
    else
        {
            for (UINT j = 0; j < ARRAYSIZE(nums) ; j++)
                {
                for (UINT i = 0; i < nums[j]; i++)
                    {
                    AUCatalogItem * pItem = new AUCatalogItem((*pitemlists[j])[i]);
                    if (NULL == pItem)
                        {
                        DEBUGMSG("Fail to create item");
                        hr = E_FAIL;
                        goto done;
                        }
                    if (!pItem->fEqual((*pitemlists[j])[i]))
                    {
                    	DEBUGMSG("Fail to create item");
                    	hr = E_OUTOFMEMORY;
                    	delete pItem;
                    	goto done;
                    }
                    if (!m_ItemList.Add(pItem))
                    {
                    	hr = E_OUTOFMEMORY;
                    	delete pItem;
                    	goto done;
                    }
                    }
                }        
          hr = MergeCatalogs(bstrDriverInstall, bstrNonDriverInstall, &m_bstrInstallation);
        }

done:
    if (FAILED(hr))
        {
            Clear();
        }
    return hr;
}

// go through 1 cycle to detect driver items 
HRESULT AUCatalog::DetectDriverItems(OUT BSTR *pbstrInstall, OUT AUCatalogItemList &itemList,  BOOL *pfFoundExclusiveItem)
{
    HRESULT hr = S_OK;
    BSTR bstrManifest;

	if (NULL == pbstrInstall || NULL == pfFoundExclusiveItem)
	{
		return E_INVALIDARG;
	}
    DEBUGMSG("CAUCatalog detecting driver items...");
    *pbstrInstall = NULL;
    *pfFoundExclusiveItem = FALSE;
    itemList.Clear();
#ifdef DBG
     if (fDBGUseLocalFile())
        {
            DEBUGMSG("Use local file instead of going on line");
            if (NULL == (bstrManifest = ReadXMLFromFile(DRIVERS_FILE)))
                {
                DEBUGMSG("fail to get drivers from file %s", DRIVERS_FILE);
                hr = E_FAIL;
                goto end;
                }
        }
    else
#endif
		{
			if (FAILED(hr = GetManifest(DRIVERS_LEVEL, NULL, &bstrManifest)))
				{
			    DEBUGMSG(" Fail to get drivers manifest %#lx", hr);
			    goto end;
				}
			if (S_FALSE == hr)
			    { //no updates applicable

			    goto end;
			    }
		}

    *pbstrInstall = bstrManifest;
    if (!fExtractItemInfo(*pbstrInstall, itemList, pfFoundExclusiveItem))
        {
            DEBUGMSG("fail to extract information for driver items");
            hr = E_FAIL;
            goto end;
        }

#ifdef DBG
//        itemList.DbgDump();
#endif

end: 
    DEBUGMSG("CAUCatalog detecting driver items done");
    if (FAILED(hr))
    {
    	SafeFreeBSTRNULL(*pbstrInstall);
    	*pfFoundExclusiveItem = FALSE;
    	itemList.Clear();
    }
    return hr;
}


          

// go through 4 cycles to detect software items 
// get down manifest 
HRESULT AUCatalog::DetectNonDriverItems(OUT BSTR *pbstrInstall, OUT AUCatalogItemList &itemList, OUT BOOL *pfFoundExclusiveItem)
{
    HRESULT hr = S_OK;
    BSTR bstrManifest = NULL;
    BSTR bstrResult=NULL;

	if (NULL == pbstrInstall || NULL == pfFoundExclusiveItem)
	{
		return E_INVALIDARG;
	}
    DEBUGMSG("CAUCatalog detecting non driver items...");
    *pbstrInstall = NULL;
    *pfFoundExclusiveItem = FALSE;
    itemList.Clear();
#ifdef DBG
    if (fDBGUseLocalFile())
        {
            DEBUGMSG("Use local file instead of going on line");
            if (NULL == (bstrManifest = ReadXMLFromFile(DETAILS_FILE)))
                {
                hr = E_FAIL;
                DEBUGMSG("Fail to get item details from file %s", DETAILS_FILE);
                goto end;
                }
        }
    else
 #endif
        {
            for (int enLevel = MIN_LEVEL; enLevel <= MAX_LEVEL; enLevel++)
            {
            	DEBUGMSG("#%d pass", enLevel+1);
            	hr = GetManifest((DETECTLEVEL)enLevel, bstrResult, &bstrManifest);
            	SafeFreeBSTR(bstrResult);
            	if (FAILED(hr))
            	{
            		DEBUGMSG(" Fail to get %s %#lx", GetLevelStr((DETECTLEVEL)enLevel), hr);
            		goto end;
            	}
            	if (S_FALSE == hr)
            	    {
            	        goto end;
            	    }
            	DEBUGMSG("%s got", GetLevelStr((DETECTLEVEL)enLevel));
            	if (DETAILS_LEVEL != enLevel)
            	{
            	       DEBUGMSG("Doing detection........");
            		hr = DoDetection((DETECTLEVEL)enLevel, bstrManifest, &bstrResult);
            		SafeFreeBSTR(bstrManifest);
            		if (FAILED(hr))
            		{
            			DEBUGMSG("Fail to do detection %#lx", hr);
            			goto end;
            		}
            	}
            }
        }

     *pbstrInstall = bstrManifest;

    if (!fExtractItemInfo(bstrManifest, itemList, pfFoundExclusiveItem))
        {
            DEBUGMSG("Fail to extract item information for non drivers");
            hr = E_FAIL;
            goto end;
        }

#ifdef DBG
//            itemList.DbgDump();
#endif

   end: 
        DEBUGMSG("CAUCatalog detecting non driver items done");
        if (FAILED(hr))
        {
        	SafeFreeBSTRNULL(*pbstrInstall);
        	*pfFoundExclusiveItem = FALSE;
		    itemList.Clear();
		}
		if (gpState->fInCorpWU())
		{
			if (SUCCEEDED(hr))
			{
				gPingStatus.PingDetectionSuccess(TRUE, itemList.Count());
			}
			else
			{
				gPingStatus.PingDetectionFailure(TRUE, hr);
			}
		}
        return hr;
}


//////////////////////////////////////////////////////////////////////////////////////////////
// delete all local cat log files we might use to do offline operation, including item.xml details.xml, 
// mergedcatalog.xml, drivers.xml and catalog.xml. If not fUpdate (i.e., will build everything from scratch), also clean up RTFs and Cabs
/////////////////////////////////////////////////////////////////////////////////////////////
void AUCatalog::DelCatFiles(BOOL fUpdate)
{
    TCHAR tszPath[MAX_PATH];
    TCHAR tszFullFileName[MAX_PATH];

    DEBUGMSG("DelCatFiles()");
#ifdef DBG
    if (fDBGUseLocalFile())
        {
            DEBUGMSG("When use local file in debugging mode, do not delete local catalog files");
            return;
        }
    else
#endif
    {
        AUASSERT(_T('\0') != g_szWUDir[0]);
   		if (FAILED(StringCchCopyEx(tszPath, ARRAYSIZE(tszPath) , g_szWUDir, NULL, NULL, MISTSAFE_STRING_FLAGS)))
   		 {
  	      return;
  		 }

   		LPCTSTR FILES_TO_DELETE[] = {ITEM_FILE, DRIVERS_FILE, DETAILS_FILE, 
#ifdef DBG
        DETECT1_FILE, DETECT2_FILE, DETECT3_FILE, DRIVER_SYSSPEC_FILE, NONDRIVER_SYSSPEC_FILE,
		PROVIDER_FILE, PRODUCT_FILE, INSTALL_FILE,
#endif
            CATALOG_FILE };
    	for (int i = 0;  i< ARRAYSIZE(FILES_TO_DELETE); i++)
        {
            if (SUCCEEDED(StringCchCopyEx(tszFullFileName, ARRAYSIZE(tszFullFileName) , tszPath, NULL, NULL, MISTSAFE_STRING_FLAGS)) &&
				SUCCEEDED(StringCchCatEx(tszFullFileName, ARRAYSIZE(tszFullFileName), FILES_TO_DELETE[i], NULL, NULL, MISTSAFE_STRING_FLAGS)))
			{
				AUDelFileOrDir(tszFullFileName);
			}
        }
            
    	if (!fUpdate)
        {
             TCHAR tszDownloadTmpDir[MAX_PATH];

            if (SUCCEEDED(GetDownloadPath(tszDownloadTmpDir, ARRAYSIZE(tszDownloadTmpDir))))
            {
	            DelDir(tszDownloadTmpDir);
	            RemoveDirectory(tszDownloadTmpDir);
            }
        }
	}
}


////////////////////////////////////////////
// caller needs to free the returned BSTR
////////////////////////////////////////////
BSTR GetCatalogFile(void)
{
    TCHAR szFile[MAX_PATH];
    AUASSERT(_T('\0') != g_szWUDir[0]);
    if (FAILED(StringCchCopyEx(szFile, ARRAYSIZE(szFile), g_szWUDir, NULL, NULL, MISTSAFE_STRING_FLAGS))||
		FAILED(StringCchCatEx(szFile, ARRAYSIZE(szFile), CATALOG_FILE, NULL, NULL, MISTSAFE_STRING_FLAGS)))
        {
            return NULL;
        }
    return SysAllocString(T2W(szFile));
}

    
//=======================================================================
//
//  AUCatalog::Serialize
//
//=======================================================================
HRESULT AUCatalog::Serialize(void)
{
    HRESULT hr = S_OK;
	DEBUGMSG("WUAUENG: serializing");
	BSTR bstrCatFile = NULL ;
    IXMLDOMDocument *pxmlCatalog = NULL;
    IXMLDOMElement *pelemAUCATALOG = NULL;
  
    AU_VARIANT  varValueVERSION(CATALOG_XML_VERSION);
    AU_VARIANT  varValueDOWNLOADID(m_audownloader.getID());
    AU_VARIANT  varValueITEMCOUNT(m_ItemList.Count());
    AU_VARIANT  varValueUpdateDriver(m_fUpdateDriver);


    if (NULL == (bstrCatFile = GetCatalogFile()))
    {
    	DEBUGMSG("Fail to get catalog file with error %#lx", hr);
    	goto done;
    }

    AUDelFileOrDir(W2T(bstrCatFile)); //delete old catalog file


	if ( FAILED(hr = CoCreateInstance(__uuidof(DOMDocument), NULL, CLSCTX_INPROC_SERVER,
                                      __uuidof(IXMLDOMDocument), (void**)&pxmlCatalog)) ||
         FAILED(hr = pxmlCatalog->createElement(bstrTagAUCATALOG, &pelemAUCATALOG)) ||
         FAILED(hr = pelemAUCATALOG->setAttribute(bstrAttrVERSION, varValueVERSION)) ||
         FAILED(hr = pelemAUCATALOG->setAttribute(bstrAttrDOWNLOADID, varValueDOWNLOADID)) ||
         FAILED(hr = pelemAUCATALOG->setAttribute(bstrAttrITEMCOUNT, varValueITEMCOUNT)) ||
         FAILED(hr = pelemAUCATALOG->setAttribute(bstrAttrUpdateDriver, varValueUpdateDriver)) ||
         FAILED(hr = pxmlCatalog->appendChild(pelemAUCATALOG, NULL)) )
	{
		DEBUGMSG("Fail to create Catalog.xml");
		goto done;
	}

        VARIANT varValueID;
        VARIANT varValueSTATUS;
        varValueID.vt = VT_BSTR;
        varValueSTATUS.vt = VT_I4;

    // write out item information
	for ( DWORD index = 0; index < m_ItemList.Count(); index++ )
	{
        IXMLDOMElement *pelemITEM = NULL;
        varValueID.bstrVal = m_ItemList[index].bstrID();
        varValueSTATUS.lVal = m_ItemList[index].dwStatus();
//        DEBUGMSG("Status is %d for item %S", varValueSTATUS.lVal, m_ItemList[index].bstrID());

        if ( FAILED(hr = pxmlCatalog->createElement(bstrTagITEM, &pelemITEM)) ||
             FAILED(hr = pelemITEM->setAttribute(bstrAttrID, varValueID)) ||
             FAILED(hr = pelemITEM->setAttribute(bstrAttrSTATUS, varValueSTATUS)) ||
             FAILED(hr = pelemAUCATALOG->appendChild(pelemITEM, NULL)) )
        {
            SafeRelease(pelemITEM);
            goto done;
        }
        SafeRelease(pelemITEM);
	}

     if ( FAILED(hr = SaveDocument(pxmlCatalog, bstrCatFile)))
    {
        DEBUGMSG("saving of %S failed, hr = %#lx", bstrCatFile, hr);
        if ( SUCCEEDED(hr) )
        {
            hr = E_FAIL;
        }
        goto done;
    }

done:
	if (FAILED(hr) && NULL != bstrCatFile)
   	{
   		AUDelFileOrDir(bstrCatFile);
   	}	
    SafeFreeBSTR(bstrCatFile);
	SafeRelease(pelemAUCATALOG);
   	SafeRelease(pxmlCatalog);
	return hr;
}

//=======================================================================
//
// AUCatalog::Unserialize
//
//=======================================================================
HRESULT AUCatalog::Unserialize()
{
//    USES_CONVERSION;
    DEBUGMSG("WUAUENG: unserializing");

    HRESULT hr = S_OK;
    IXMLDOMDocument *pxmlCatalog = NULL;
    IXMLDOMNodeList *pitemnodes = NULL;
    IXMLDOMNode *pcatalog = NULL;
    BSTR bstrCatFile = NULL;
    long lVersion;
    long lItemCount;
    BSTR bstrDownloadId = NULL;
    GUID downloadId;

    if (NULL == (bstrCatFile = GetCatalogFile()))
    {
    	DEBUGMSG("Fail to get catalog file with error %#lx", hr);
    	goto done;
    }
    if ( FAILED(hr = LoadDocument(bstrCatFile, &pxmlCatalog, TRUE)))
    {
        DEBUGMSG("Could not Load catalog file with error %#lx",  hr);
        goto done;
    }

    //get catalog node (root)
    if (!FindNode(pxmlCatalog, bstrTagAUCATALOG, &pcatalog))
        {
        hr = E_FAIL;
        DEBUGMSG("fail to find catalog node ");
        goto done;
        }
    
    // get version
    if ( FAILED(hr = GetAttribute(pcatalog, bstrAttrVERSION, &lVersion)))
    {
        DEBUGMSG("Fail to get version with error %#lx", hr);
        goto done;
    }

    DEBUGMSG("Catalog Version Number is %d", lVersion);

    if ( CATALOG_XML_VERSION !=  lVersion )
    {
        DEBUGMSG("invalid XML version");
        hr = E_FAIL;
        goto done;
    }

    // get DOWNLOADID
    if ( FAILED(hr = GetAttribute(pcatalog, bstrAttrDOWNLOADID, &bstrDownloadId)) ||
         FAILED(hr = CLSIDFromString(bstrDownloadId, &downloadId)))
    {
        DEBUGMSG("failed to get download id with error %#lx", hr);
        goto done;
    }

    if (GUID_NULL != downloadId)
    {
        m_audownloader.setID(downloadId);
        m_fNeedToContinueJob = TRUE;
    }
    // get ITEMCOUNT
    if ( FAILED(hr = GetAttribute(pcatalog, bstrAttrITEMCOUNT, &lItemCount)))
    {
        DEBUGMSG("failed to get item count with error %#lx", hr);
        goto done;
    }

	if (m_fUpdateDriver)
	{
	    if (FAILED(hr = GetAttribute(pcatalog, bstrAttrUpdateDriver, &m_fUpdateDriver)))
	    {
	    	DEBUGMSG("failed to get fUpdateDriver with error %#lx", hr);
	    	goto done;
	    }
	}

    DEBUGMSG("Catalog item count is %d", lItemCount);

    if (FAILED(hr = m_ItemList.Allocate(lItemCount)))
        {
          DEBUGMSG("Out of memory, fail to allocate item list");
          goto done;
        }

    if ( NULL == (pitemnodes = FindDOMNodeList(pcatalog, bstrTagITEM)))
    {
        hr = E_FAIL;
        DEBUGMSG("Fail to find items in the catalog ");
        goto done;
    }

    // read in item list
    for ( DWORD index = 0; index < m_ItemList.Count(); index++ )
    {
        IXMLDOMNode *pitemnode = NULL;
        if ( S_OK != (hr = pitemnodes->get_item(index, &pitemnode)) )
        {
            DEBUGMSG("failed to get item node %d", index);
            hr = FAILED(hr) ? hr : E_FAIL;
            goto done;
        }

        // get ID
        if ( FAILED(hr = GetAttribute(pitemnode, bstrAttrID, &(m_ItemList[index].m_bstrID))))
        {
            DEBUGMSG("Fail to find ID for item %d", index);
            SafeRelease(pitemnode);
            goto done;
        }

       
        // get STATUS
        if ( FAILED(hr = GetAttribute(pitemnode, bstrAttrSTATUS, (long*)(&(m_ItemList[index].m_dwStatus)))))
        {
            DEBUGMSG("Fail to find status for item %d with error %#lx", index, hr);
            SafeRelease(pitemnode);
            goto done;
        }
//        DEBUGMSG("item %S status is %d", m_ItemList[index].m_bstrID, m_ItemList[index].m_dwStatus);

        pitemnode->Release();
    }

    //populate m_ItemList with other information than itemID and status
     hr = GetDetailedItemInfoFromDisk(m_ItemList, &m_bstrInstallation, m_fUpdateDriver);
done:
    SafeFreeBSTR(bstrDownloadId);
    SafeFreeBSTR(bstrCatFile);
    SafeRelease(pcatalog);
    SafeRelease(pitemnodes);
    SafeRelease(pxmlCatalog);
    if (FAILED(hr))
	{
	     DelCatFiles();
         Clear();
	}
    DEBUGMSG("WUAUENG unserializing done with result %#lx", hr);
    return hr;
}

//only download RTFs for now
HRESULT AUCatalog::DownloadRTFsnEULAs(LANGID langid)
{
    BSTR bstrRTFUrl, bstrEULAUrl;
    TCHAR tszLocalRTFDir[MAX_PATH];
    HRESULT hr;

    if (FAILED(hr = GetRTFDownloadPath(tszLocalRTFDir, ARRAYSIZE(tszLocalRTFDir), langid)))
        {
        DEBUGMSG("Fail to get RTF download path %#lx", hr);
        goto done;
        }
    DEBUGMSG("Got RTF path %S", tszLocalRTFDir);
    UINT uItemCount = m_ItemList.Count();
//    DEBUGMSG("Downloading %d RTFs", uItemCount);
    for (UINT i = 0; i<uItemCount; i++)
    {
        AUCatalogItem & item = (m_ItemList)[i];
        if (item.fSelected())
        {
            bstrRTFUrl = item.bstrRTFPath();
            if (NULL != bstrRTFUrl)
            {
                HRESULT hr1 =DownloadFile(bstrRTFUrl, tszLocalRTFDir,NULL, NULL, &ghServiceFinished, 1, NULL,NULL, WUDF_SKIPCABVALIDATION);                
                DEBUGMSG("download RTF file from %S to %S %s (with error %#lx)", bstrRTFUrl, tszLocalRTFDir, FAILED(hr1)? "failed" : "succeeded", hr1);
                if(SUCCEEDED(hr1))
                {
                    ValidateDownloadedRTF(bstrRTFUrl, m_ItemList[i].bstrID());
                }
            }
        }
    }
done:
        return hr;
}

DWORD AUCatalog::GetNumSelected(void)
{
    UINT uItemNum = m_ItemList.Count();
    DWORD dwSelectedNum = 0;
    for (UINT i = 0; i < uItemNum; i++)
        {
        AUCatalogItem &item = m_ItemList[i];
        if (item.fSelected())
            {
            dwSelectedNum++;
            }
        }
    return dwSelectedNum;
}

//=======================================================================
//
//  AUCatalog::GetInstallXML
//
//=======================================================================
HRESULT AUCatalog::GetInstallXML(BSTR *pbstrCatalogXML, BSTR *pbstrDownloadXML)
{
	DEBUGMSG("AUCatalog::GetInstallXML");
    HRESULT hr = S_OK;


    PersistHiddenItems(m_ItemList, URLLOGACTIVITY_Installation);
    if (m_ItemList.GetNumSelected() == 0)
        {
            DEBUGMSG("Nothing to install");
            hr = S_FALSE;
            goto end;
        }
                
    if (S_OK != (hr = ValidateItems(FALSE/*, TRUE*/)))
        {
            DEBUGMSG("Invalid catalog with error %#lx or no items", hr);
            hr = E_FAIL;
            goto end;
        }

    if (NULL == m_bstrInstallation )
	{
	    DEBUGMSG(" can't get installation xml or download result xml");
	    hr = E_FAIL;
	    goto end;
	}

    hr = PrepareInstallXML(m_bstrInstallation, m_ItemList, pbstrDownloadXML, pbstrCatalogXML);
#ifdef DBG
    if (SUCCEEDED(hr))
        {
        LOGXMLFILE(INSTALL_FILE, *pbstrCatalogXML); //download xml is logged by client
        }
#endif
end:
	return hr;
}

//=======================================================================
//
//  AUCatalog::FindItemIdByLocalFileName
//  return value should not be freed
//=======================================================================
BSTR AUCatalog::FindItemIdByLocalFileName(LPCWSTR pwszLocalFileName)
{
	CItemDetails itemdetails;

	if (NULL == pwszLocalFileName ||
		0 == m_ItemList.GetNumSelected() ||
		NULL == m_bstrInstallation ||
		!itemdetails.Init(m_bstrInstallation))
	{
		DEBUGMSG("AUCatalog::FindItemIdByLocalFileName bad params or failed to init CItemDetails");
		return NULL;
	}

	UINT uItemCount = m_ItemList.Count();
	BSTR bstrResult = NULL;
	BOOL fDone = FALSE;

	for (UINT i = 0; i < uItemCount && !fDone; i++)
	{
		AUCatalogItem &item = m_ItemList[i];

		if (item.fSelected() || m_ItemList.ItemIsRelevant(i))
		{
			BSTR bstrItemId = item.bstrID();
			BSTR bstrItemDownloadPath = itemdetails.GetItemDownloadPath(bstrItemId);

			if (NULL == bstrItemDownloadPath)
			{
				DEBUGMSG("AUCatalog::FindItemIdByLocalFileName fail to build item downloadPath for %S", bstrItemId);
				fDone = TRUE;
			}
			else
			{
				BSTR *pCRCCabNames  = NULL;
				BSTR *pRealCabNames = NULL;
                BSTR *pCabChecksums = NULL;
				UINT uCabsNum;

				if (FAILED(itemdetails.GetCabNames(bstrItemId, &pCRCCabNames, &pRealCabNames, &pCabChecksums, &uCabsNum)))
				{
					DEBUGMSG("AUCatalog::FindItemIdByLocalFileName fail to get cab names for %S", bstrItemId);
					fDone = TRUE;
				}
				else
				{
					for (UINT j = 0; j < uCabsNum; j++)
					{
						WCHAR wszFullFileName[MAX_PATH];

						if (!fDone &&
							SUCCEEDED(PathCchCombineW(
										wszFullFileName,
                                        ARRAYSIZE(wszFullFileName),
										bstrItemDownloadPath,
										pRealCabNames[j])) &&
							0 == StrCmpIW(wszFullFileName, pwszLocalFileName))
						{
							DEBUGMSG("AUCatalog::FindItemIdByLocalFileName found item");
							bstrResult = bstrItemId;
							fDone = TRUE;
						}

						SafeFreeBSTR(pCRCCabNames[j]);
						SafeFreeBSTR(pRealCabNames[j]);
                        SafeFreeBSTR(pCabChecksums[j]);
					}

					SafeFree(pCRCCabNames);
					SafeFree(pRealCabNames);
                    SafeFree(pCabChecksums);
				}

				SysFreeString(bstrItemDownloadPath);
			}
		}
    }

	itemdetails.Uninit();
	return bstrResult;
}


//=======================================================================
////  AUCatalog::ValidateDownloadedCabs
//    The OUT parameter (itemid) will be NULL if no error or if the error 
//    is other than ERROR_CRC
//=======================================================================
HRESULT AUCatalog::ValidateDownloadedCabs(BSTR *pbstrErrorItemId)
{
    HRESULT hr = E_FAIL;
	CItemDetails itemdetails;

    AUASSERT(NULL != m_bstrInstallation);
    if(NULL == pbstrErrorItemId)
    {
        return E_INVALIDARG;
    }
    *pbstrErrorItemId = NULL;

    //if no items selected or if failed to load install xml
    if (0 == m_ItemList.GetNumSelected() || 
        !itemdetails.Init(m_bstrInstallation))
	{
		return hr;
	}

	UINT uItemCount = m_ItemList.Count();
    BOOL fError = FALSE;

    BSTR *pCRCCabNames = NULL;
	BSTR *pRealCabNames = NULL;
    BSTR *pCabChecksums = NULL;
	UINT uCabsNum = 0;

	for (UINT i = 0; i < uItemCount && !fError; i++)
	{
        if (!m_ItemList[i].fSelected() && !m_ItemList.ItemIsRelevant(i))
		{
            continue;
        }
		BSTR bstrItemId = m_ItemList[i].bstrID();
		BSTR bstrItemDownloadPath = itemdetails.GetItemDownloadPath(bstrItemId);
        if( NULL == bstrItemDownloadPath)
        {
            hr = E_OUTOFMEMORY;
            break;
        }

		if (FAILED(hr = itemdetails.GetCabNames(bstrItemId, &pCRCCabNames, &pRealCabNames, &pCabChecksums, &uCabsNum)))
		{
            SysFreeString(bstrItemDownloadPath);
            break;
		}

        //Iterate through all the cabs in an item
		for (UINT j = 0; j < uCabsNum; j++)
		{
            //If no error and CRC exists
            if(!fError && NULL != pCabChecksums[j])
            {
			    WCHAR wszFullFileName[MAX_PATH+1];
			    if (SUCCEEDED(hr = PathCchCombineW(wszFullFileName, ARRAYSIZE(wszFullFileName), bstrItemDownloadPath, pRealCabNames[j])))
                {
                    if(FAILED(hr = VerifyFileCRC(wszFullFileName, pCabChecksums[j])))
                    {
                        fError = TRUE;
                        if(hr == HRESULT_FROM_WIN32(ERROR_CRC))
                        {
                            *pbstrErrorItemId = bstrItemId;
                        }
                        DEBUGMSG("Checksum Failed for file %S", wszFullFileName);
                    }
                }
                else
                {
                    fError = TRUE;
                }
            }
            //Free up memory
            SafeFreeBSTR(pCRCCabNames[j]);
            SafeFreeBSTR(pRealCabNames[j]);
            SafeFreeBSTR(pCabChecksums[j]);
        }
        
        SafeFreeNULL(pCRCCabNames);
        SafeFreeNULL(pRealCabNames);
        SafeFreeNULL(pCabChecksums);

        SysFreeString(bstrItemDownloadPath);
    }
    itemdetails.Uninit();
	return hr;
}

void AUCatalog::ValidateDownloadedRTF(BSTR bstrRTFUrl, BSTR bstrItemId)
{
    CItemDetails itemdetails;
    BSTR bstrCRC = NULL;
    TCHAR szRTFName[MAX_PATH+1];

    AUASSERT(NULL != bstrItemId && NULL != bstrRTFUrl && NULL != m_bstrInstallation);

    //if failed to load install xml
    if (itemdetails.Init(m_bstrInstallation) &&
        SUCCEEDED(itemdetails.GetRTFCRC(bstrItemId, &bstrCRC)) &&
        SUCCEEDED(GetRTFLocalFileName(bstrRTFUrl, szRTFName, ARRAYSIZE(szRTFName), GetSystemDefaultLangID())) &&
        HRESULT_FROM_WIN32(ERROR_CRC) == VerifyFileCRC(szRTFName, bstrCRC))
    {
        DEBUGMSG("Checksum Failed for RTF %S, deleting it.", szRTFName);
        DeleteFile(szRTFName);
    }

    SafeFreeBSTR(bstrCRC);
    itemdetails.Uninit();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\wuaucpl\wuaucpl.h ===
// WUAUCpl.h: interface for the CWUAUCpl class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_WUAUCPL_H__7F649158_0715_4CAA_B7CF_9AACC1DD0612__INCLUDED_)
#define AFX_WUAUCPL_H__7F649158_0715_4CAA_B7CF_9AACC1DD0612__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "cpl.h"
#include "wuauengi.h"
#include "link.h"

//
// Create a structure for Updates Object data.  This structure
// is used to pass data between the property page and the
// Updates Object thread.  Today all we use is the "option" value 
// but there may be more later.
//
enum UPDATESOBJ_DATA_ITEMS
{
    UODI_OPTION = 0x00000001,
    UODI_ALL    = 0xFFFFFFFF
};

struct UPDATESOBJ_DATA
{
    DWORD fMask;     // UPDATESOBJ_DATA_ITEMS mask
    AUOPTION Option;  // Updates option setting.
};

//
// Private window message sent from the Updates Object thread proc
// to the property page telling the page that the object has been
// initialized.  
//
//      lParam - points to a UPATESOBJ_DATA structure containing 
//               the initial configuration of the update's object with
//               which to initialize the UI.  If wParam is 0, this 
//               may be NULL.
//
//      wParam - BOOL (0/1) indicating if object intialization was 
//               successful or not.  If wParam is 0, lParam may be NULL.
// 
const UINT PWM_INITUPDATESOBJECT = WM_USER + 1;
//
// Message sent from the property page to the Updates Object thread
// to tell it to configure the Auto Updates service.  
//
//      lParam - points to a UPDATESOBJ_DATA structure containing the 
//               data to set.
//
//      wParam - Unused.  Set to 0.
//
const UINT UOTM_SETDATA = WM_USER + 2;

//
// Message cracker for WM_HELP.  Not sure why windowsx.h doesn't have one.
//
// void Cls_OnHelp(HWND hwnd, HELPINFO *pHelpInfo)
//
#define HANDLE_WM_HELP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HELPINFO *)(lParam)))
#define FORWARD_WM_HELP(hwnd, pHelpInfo, fn) \
    (void)(fn)((hwnd), WM_HELP, (WPARAM)0, (LPARAM)pHelpInfo)
//
// Message cracker for PWM_INITUPDATESOBJECT.
//
// void Cls_OnInitUpdatesObject(HWND hwnd, BOOL bInitSuccessful, UPDATESOBJ_DATA *pData)
//
#define HANDLE_PWM_INITUPDATESOBJECT(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (BOOL)(wParam), (UPDATESOBJ_DATA *)(lParam)))

class CWUAUCpl  
{
public:
	CWUAUCpl(int nIconID,int nNameID,int nDescID);
	void _OnDestroy(HWND hwnd);
	BOOL _OnSetCursor(HWND hwnd, HWND hwndCursor, UINT codeHitTest, UINT msg);
	HBRUSH _OnCtlColorStatic(HWND hwnd, HDC hDC, HWND hwndCtl, int type); 
	BOOL _OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam);
    BOOL _OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
    BOOL _OnContextMenu(HWND hwnd, HWND hwndContext, UINT xPos, UINT yPos);
    BOOL _OnHelp(HWND hwnd, HELPINFO *pHelpInfo);
	BOOL _OnKeepUptoDate(HWND hwnd);
	BOOL _SetDefault(HWND hwnd);
	void _GetDayAndTimeFromUI( HWND hWnd,	LPDWORD lpdwSchedInstallDay,LPDWORD lpdwSchedInstallTime);
	BOOL _OnOptionSelected(HWND hwnd,int idOption);
	BOOL _EnableOptions(HWND hwnd, BOOL bState);
	BOOL _FillDaysCombo(HWND hwnd, DWORD dwSchedInstallDay);
	BOOL _EnableCombo(HWND hwnd, BOOL bState);
	BOOL _SetStaticCtlNotifyStyle(HWND hwnd);
	BOOL _OnApply(HWND hwnd);

	HRESULT _SetHeaderText(HWND hwnd, UINT idsText);
	HRESULT _EnableControls(HWND hwnd, BOOL bEnable);
	BOOL _OnInitUpdatesObject(HWND hwnd, BOOL bObjectInitSuccessful, UPDATESOBJ_DATA *pData);

	HRESULT _OnRestoreHiddenItems();
	void EnableRestoreDeclinedItems(HWND hWnd, BOOL fEnable);

	static HRESULT _QueryUpdatesObjectData(HWND hwnd, IUpdates *pUpdates, UPDATESOBJ_DATA *pData);
	static HRESULT _SetUpdatesObjectData(HWND hwnd, IUpdates *pUpdates, UPDATESOBJ_DATA *pData);

	void LaunchLinkAction(HWND hwnd);
	static const DWORD s_rgHelpIDs[];

	void LaunchHelp(HWND hwnd, LPCTSTR szURL);

private:
	static HINSTANCE m_hInstance;

public:
	static void SetInstanceHandle(HINSTANCE hInstance);
	static INT_PTR CALLBACK _DlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
	static INT_PTR CALLBACK _DlgRestoreProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static DWORD WINAPI _UpdatesObjectThreadProc(LPVOID pvParam);

	LONG Init();
	LONG GetCount();
	LONG Inquire(LONG appletIndex, LPCPLINFO lpCPlInfo);
	LONG DoubleClick(HWND hWnd, LONG lParam1, LONG lParam2);
	LONG StartWithParams(HWND hWnd, LONG lParam1, LPSTR lParam2);
	LONG Stop(LPARAM lParam1, LPARAM lParam2);
	LONG Exit();

private:
	// Applet data
	int m_nIconID;
	int m_nNameID;
	int m_nDescID;

	HFONT m_hFont;
	COLORREF m_colorVisited;
	COLORREF m_colorUnvisited;

	HWND m_hWndLinkLearnAutoUpdate;
	BOOL m_bVisitedLinkLearnAutoUpdate;
	HWND m_hWndLinkScheduleInstall;
	BOOL m_bVisitedLinkScheduleInstall;

	DWORD   m_idUpdatesObjectThread;
	HANDLE	m_hThreadUpdatesObject;

	HCURSOR m_HandCursor;

	CSysLink m_AutoUpdatelink;
	CSysLink m_ScheduledInstalllink;
};


#endif // !defined(AFX_WUAUCPL_H__7F649158_0715_4CAA_B7CF_9AACC1DD0612__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\wuaueng\audownload.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:     audownload.h
//
//--------------------------------------------------------------------------

#pragma once

#include "aucatitem.h"
#include "aucatalog.h"
#include <bits.h>
#include <initguid.h>

class Catalog;

#define NO_BG_JOBSTATE				-1
#define CATMSG_DOWNLOAD_COMPLETE	1
#define CATMSG_TRANSIENT_ERROR		2	//This comes from drizzle, for example if internet connection is lost
#define CATMSG_DOWNLOAD_IN_PROGRESS 3
#define CATMSG_DOWNLOAD_CANCELED	4
#define CATMSG_DOWNLOAD_ERROR		5

#define DRIZZLE_NOTIFY_FLAGS	BG_NOTIFY_JOB_TRANSFERRED | BG_NOTIFY_JOB_ERROR | BG_NOTIFY_JOB_MODIFICATION

typedef void (*DWNLDCALLBACK)(DWORD dwCallbackMsg, IBackgroundCopyJob *pBGJob, IBackgroundCopyError *pBGErr /*= NULL*/);


typedef enum tagDRIZZLEOPS {
	DRIZZLEOPS_CANCEL = 1,
	DRIZZLEOPS_PAUSE ,
	DRIZZLEOPS_RESUME
} DRIZZLEOPS;

typedef enum tagJOBFINISHREASON {
	JOB_UNSPECIFIED_REASON = -1,
	JOB_ERROR = 0
} JOBFINISHREASON;

	


///////////////////////////////////////////////////////////////////////////
// Wrapper class for drizzle download operation
// also implements drizzle notification callbacks
//////////////////////////////////////////////////////////////////////////
class CAUDownloader : public IBackgroundCopyCallback
{
public:
    // IUnknown methods
    HRESULT STDMETHODCALLTYPE QueryInterface(
        /* [in] */ REFIID riid,
        /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

    ULONG STDMETHODCALLTYPE AddRef( void);

    ULONG STDMETHODCALLTYPE Release( void);

    // IBackgroundCopyCallback methods

    HRESULT STDMETHODCALLTYPE JobTransferred(
        /* [in] */ IBackgroundCopyJob *pJob);

    HRESULT STDMETHODCALLTYPE JobError(
        /* [in] */ IBackgroundCopyJob *pJob,
        /* [in] */ IBackgroundCopyError *pError);

    HRESULT STDMETHODCALLTYPE JobModification(
        /* [in] */ IBackgroundCopyJob*,
        /* [in] */ DWORD );


	CAUDownloader(DWNLDCALLBACK pfnCallback):
			m_DownloadId(GUID_NULL),
			m_dwJobState(NO_BG_JOBSTATE),
			m_DoDownloadStatus(pfnCallback),
			m_refs(0),
			m_FinishReason(JOB_UNSPECIFIED_REASON)
			{};
	~CAUDownloader();

	HRESULT ContinueLastDownloadJob();
	//the following two could be combined into DownloadFiles() in V4
	HRESULT QueueDownloadFile(LPCTSTR pszServerUrl,				// full http url
			LPCTSTR pszLocalFile				// local file name
			);
	HRESULT StartDownload();
	HRESULT DrizzleOperation(DRIZZLEOPS);
	HRESULT getStatus(DWORD *percent, DWORD *pdwstatus);
	GUID 	getID() 
		{
			return m_DownloadId;
		}
	void  setID(const GUID & guid )
		{
			m_DownloadId = guid;
		}
	void 	Reset();
	JOBFINISHREASON m_FinishReason;
private:
	HRESULT SetDrizzleNotifyInterface();
	HRESULT InitDownloadJob(const GUID & guidDownloadId);	
	HRESULT ReconnectDownloadJob();
	HRESULT CreateDownloadJob(IBackgroundCopyJob ** ppjob);
	HRESULT FindDownloadJob(IBackgroundCopyJob ** ppjob);

	long m_refs;
	GUID m_DownloadId;                  // id what m_pjob points to. 
	DWORD m_dwJobState;			//Job State from drizzle, used in JobModification callback
	DWNLDCALLBACK	m_DoDownloadStatus; //callback function to notify user of download state change

// Friend functions (callbacks)
	friend void QueryFilesExistCallback(void*, long, LPCTSTR, LPCTSTR);
	
};


void DoDownloadStatus(DWORD dwDownloadMsg, IBackgroundCopyJob *pBGJob, IBackgroundCopyError *pBGErr);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\wuaueng\aucatalog.h ===
//=======================================================================
//
//  Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:    AUCatalog.h
//
//  Creator: PeterWi
//
//  Purpose: AU Catalog Definitions
//
//=======================================================================

#pragma once
#include <windows.h>
#include "safefunc.h"
#include "audownload.h"
#include "auwait.h"
#include "AUBaseCatalog.h"

class AUCatalogItemList;

const DWORD CATALOG_XML_VERSION = 2;

typedef enum tagDETECTLEVEL
{
	MIN_LEVEL = 0,
	PROVIDER_LEVEL = MIN_LEVEL,
	PRODUCT_LEVEL ,
	ITEM_LEVEL,
	DETAILS_LEVEL,
	MAX_LEVEL = DETAILS_LEVEL,
	DRIVERS_LEVEL
} DETECTLEVEL;


//wrapper class for AU to do detection using IU
class AUCatalog : public AUBaseCatalog
{
public: 
   AUCatalog(): m_audownloader(DoDownloadStatus)
   	{
   	}
   ~AUCatalog();
	static BOOL InitStaticVars(void)
    {
    	AUPROVIDERQUERY = SysAllocString(L"<query><dObjQueryV1 procedure=\"providers\" /></query>"); //case SENSITIVE
		AUPRODUCTQUERY= SysAllocString(L"<query><dObjQueryV1 procedure=\"products\"><parentItems></parentItems></dObjQueryV1></query>");
		AUITEMQUERY = SysAllocString(L"<query><dObjQueryV1 procedure=\"items\"><parentItems></parentItems></dObjQueryV1></query>");
		AUDETAILSQUERY = SysAllocString(L"<query><dObjQueryV1 procedure=\"itemdetails\"><parentItems></parentItems></dObjQueryV1></query>");
		PRODUCT_PRUNE_PATTERN = SysAllocString(L"/items/itemStatus[detectResult/@installed=\"1\"]"); 
		DETAILS_PRUNE_PATTERN = SysAllocString(L"/items/itemStatus[(not (detectResult/@excluded) or (detectResult/@excluded=\"0\")) and (detectResult/@force=\"1\" or not (detectResult/@installed=\"1\") or detectResult/@upToDate = \"0\")]");
		AUDRIVERSQUERY = SysAllocString(L"<query><dObjQueryV1 procedure=\"driverupdates\"/></query>");
		AUDRIVERSYSCLASS = SysAllocString(L"<classes><computerSystem/><platform/><devices/><locale /></classes>");
		AUNONDRIVERSYSCLASS = SysAllocString(L"<classes><computerSystem/><platform/><locale /></classes>");
		bstrParentItems = SysAllocString(L"/query/dObjQueryV1/parentItems");
		bstrItemID = SysAllocString(L"./identity/@itemID");
	
		bstrTagAUCATALOG=SysAllocString(L"AUCATALOG");
		bstrAttrVERSION=SysAllocString(L"VERSION");
		bstrAttrDOWNLOADID=SysAllocString(L"DOWNLOADID");
		bstrAttrITEMCOUNT=SysAllocString(L"ITEMCOUNT");
		bstrAttrUpdateDriver = SysAllocString(L"UPDATEDRIVER");
		bstrAttrSTATUS=SysAllocString(L"STATUS");
		bstrHiddenItems=SysAllocString(L"hiddenitems");
		bstrTagITEM=SysAllocString(L"ITEM");
		bstrAttrID=SysAllocString(L"ID");
		bstrProviderNamePattern=SysAllocString(L"description/descriptionText/title"); 
        bstrItemIDPattern=SysAllocString(L"identity/@itemID"); 
        bstrTitlePattern=SysAllocString(L"description/descriptionText/title"); 
        bstrDescPattern=SysAllocString(L"description/descriptionText/text()");
        bstrRTFUrlPattern=SysAllocString(L"description/descriptionText/details/@href");
        bstrEulaUrlPattern=SysAllocString(L"description/descriptionText/eula/@href");
        bstrExclusiveItemPattern=SysAllocString(L"catalog/provider/item[installation/@exclusive=\"1\"]");
        bstrItemIdsPattern=SysAllocString(L"catalog/provider/item/identity/@itemID"); 
        bstrTemplate=SysAllocString(L"<hiddenitems version = \"1\"></hiddenitems>");
        bstrResultTemplate=SysAllocString(L"<?xml version=\"1.0\"?><items xmlns=\"x-schema:http://schemas.windowsupdate.com/iu/resultschema.xml\"></items>");
       	bstrCatalog=SysAllocString(L"catalog");


		//make sure all query and prune pattern strings are not NULL
		if (NULL == AUPROVIDERQUERY 
			|| NULL == AUPRODUCTQUERY
			|| NULL == AUITEMQUERY 
			|| NULL == AUDETAILSQUERY
			|| NULL == PRODUCT_PRUNE_PATTERN 
			|| NULL == DETAILS_PRUNE_PATTERN
			|| NULL == AUDRIVERSQUERY
			|| NULL == AUDRIVERSYSCLASS
			|| NULL == AUNONDRIVERSYSCLASS
			|| NULL == bstrParentItems
			|| NULL == bstrItemID
			|| NULL == bstrTagAUCATALOG
			|| NULL == bstrAttrVERSION
			|| NULL == bstrAttrDOWNLOADID
			|| NULL == bstrAttrITEMCOUNT
			|| NULL == bstrAttrUpdateDriver
			|| NULL == bstrTagITEM 
			|| NULL == bstrAttrID
			|| NULL == bstrAttrSTATUS 
			|| NULL == bstrHiddenItems
			|| NULL == bstrProviderNamePattern
			|| NULL == bstrItemIDPattern
			|| NULL == bstrTitlePattern
			|| NULL == bstrDescPattern
			|| NULL == bstrRTFUrlPattern
			|| NULL == bstrEulaUrlPattern
			|| NULL == bstrExclusiveItemPattern
			|| NULL == bstrItemIdsPattern
			|| NULL == bstrTemplate
			|| NULL == bstrResultTemplate
			|| NULL == bstrCatalog)
		{
		    DEBUGMSG("AUCatalog::Init() fail to initialize some query strings");
			return FALSE;
		}
		return TRUE;
    }

	static void UninitStaticVars(void)
	{
		SafeFreeBSTR(AUPROVIDERQUERY);
		SafeFreeBSTR(AUPRODUCTQUERY);
		SafeFreeBSTR(AUITEMQUERY);
		SafeFreeBSTR(AUDETAILSQUERY);
		SafeFreeBSTR(PRODUCT_PRUNE_PATTERN);
		SafeFreeBSTR(DETAILS_PRUNE_PATTERN);
		SafeFreeBSTR(AUDRIVERSQUERY);
		SafeFreeBSTR(AUDRIVERSYSCLASS);
		SafeFreeBSTR(AUNONDRIVERSYSCLASS);
		SafeFreeBSTR(bstrParentItems);
		SafeFreeBSTR(bstrItemID);
		SafeFreeBSTR(bstrTagAUCATALOG);
		SafeFreeBSTR(bstrAttrVERSION);
		SafeFreeBSTR(bstrAttrDOWNLOADID);
		SafeFreeBSTR(bstrAttrITEMCOUNT);
		SafeFreeBSTR(bstrAttrUpdateDriver);
		SafeFreeBSTR(bstrTagITEM);
		SafeFreeBSTR(bstrAttrID);
		SafeFreeBSTR(bstrAttrSTATUS);
		SafeFreeBSTR(bstrHiddenItems);
		SafeFreeBSTR(bstrProviderNamePattern);
		SafeFreeBSTR(bstrItemIDPattern);
		SafeFreeBSTR(bstrTitlePattern);
		SafeFreeBSTR(bstrDescPattern);
		SafeFreeBSTR(bstrRTFUrlPattern);
		SafeFreeBSTR(bstrEulaUrlPattern);
		SafeFreeBSTR(bstrExclusiveItemPattern);
		SafeFreeBSTR(bstrItemIdsPattern);
		SafeFreeBSTR(bstrTemplate);
		SafeFreeBSTR(bstrResultTemplate);
		SafeFreeBSTR(bstrCatalog);
	}
	
    HRESULT Init(void);
    HRESULT DetectItems(BOOL fUpdate = FALSE);
    HRESULT ValidateItems(BOOL fOnline);
    HRESULT ValidateDownloadedCabs(BSTR *pbstrErrorItemId);
    HRESULT DownloadItems(void);
    HRESULT GetInstallXML(BSTR *pbstrCatalogXML, BSTR *pbstrDownloadXML);
    HRESULT Serialize(void);
    HRESULT Unserialize(void);
    void DelCatFiles(BOOL fUpdate = FALSE);
    HRESULT getUpdatesList(VARIANT *plist);
	BSTR FindItemIdByLocalFileName(LPCWSTR pwszLocalFileName);

#if DBG
	void DbgDump(void) { m_ItemList.DbgDump(); }
#endif

public: 
	AUCatalogItemList m_ItemList;
    CAUDownloader m_audownloader;
    BOOL  m_fUpdateDriver;
    static 	BSTR bstrTagAUCATALOG;
	static 	BSTR bstrAttrVERSION;
	static 	BSTR bstrAttrDOWNLOADID;
	static	BSTR bstrAttrITEMCOUNT;
	static 	BSTR bstrAttrUpdateDriver;
	static	BSTR bstrTagITEM;
	static 	BSTR bstrAttrID;
	static	BSTR bstrAttrSTATUS;
	static 	BSTR bstrHiddenItems;
	static  BSTR bstrProviderNamePattern; //context node is provider
 	static  BSTR bstrItemIDPattern; //from here below, context node is item
    static  BSTR bstrTitlePattern; 
    static  BSTR bstrDescPattern;
    static  BSTR bstrRTFUrlPattern;
    static  BSTR bstrEulaUrlPattern;
    static 	BSTR bstrExclusiveItemPattern;
    static  BSTR bstrItemIdsPattern;
    static	BSTR bstrTemplate;
    static 	BSTR bstrResultTemplate;
    static	BSTR bstrCatalog;    	
    DWORD m_dwCatLifeSpan;
    DWORD m_dwOfflineCatLifeSpan;
    
private:
    HRESULT GetManifest(DETECTLEVEL enLevel, BSTR bstrDetectResult, BSTR * pbstrManifest);
    HRESULT GetSystemSpec(DETECTLEVEL enLevel, BSTR *pbstrSysSpec);
    HRESULT DoDetection(DETECTLEVEL enLevel, BSTR bstrCatalog, BSTR * pbstrResult, BOOL fOnline = TRUE);
    HRESULT DetectNonDriverItems(OUT BSTR *pbsInstall, OUT AUCatalogItemList &pItemList,  BOOL *pfExclusiveItemFound);
    HRESULT DetectDriverItems(OUT BSTR *pbsInstall, OUT AUCatalogItemList &pItemList,  BOOL *pfExclusiveItemFound);
    HRESULT AUCatalog::MergeDetectionResult(BSTR bstrDriverInstall, AUCatalogItemList & driverlist, BOOL fExclusiveDriverFound, BSTR bstrNonDriverInstall,  AUCatalogItemList & nondriverlist, BOOL fExclusiveItemFound);
    HRESULT DownloadRTFsnEULAs(LANGID langid);
    void ValidateDownloadedRTF(BSTR bstrRTFUrl, BSTR bstrItemId);
    HRESULT ValidateOffline(BSTR bstrNonDrivers, BSTR bstrDrivers);
    HRESULT GetQuery(DETECTLEVEL enLevel, BSTR bstrDetectResult, BSTR *pbstrQuery);
    LPCTSTR GetLogFile(DETECTLEVEL enLevel);
    char * GetLevelStr(DETECTLEVEL enLevel);
    BOOL 	hasExpired(BOOL fOffline = FALSE);
    HRESULT setExpireTime(BOOL fOffline = FALSE);
    DWORD  GetNumSelected(void);		
    void Clear(void);
    
	BSTR	m_bstrClientInfo; //assigned once and never change
	BSTR 	m_bstrDriverClientInfo; //assigned once and never change
	BSTR m_bstrInstallation; //a.k.a item details
	SYSTEMTIME m_stExpireTime; //online
	SYSTEMTIME m_stOfflineExpireTime;
	BOOL m_fNeedToContinueJob; 

static	BSTR AUPROVIDERQUERY;
static	BSTR AUPRODUCTQUERY;
static	BSTR AUITEMQUERY;
static	BSTR AUDETAILSQUERY;
static	BSTR AUDRIVERSQUERY;
static	BSTR PRODUCT_PRUNE_PATTERN; 
static	BSTR DETAILS_PRUNE_PATTERN;
static 	BSTR AUDRIVERSYSCLASS;
static	BSTR AUNONDRIVERSYSCLASS;
static 	BSTR bstrParentItems;
static 	BSTR bstrItemID;

	
};

const DWORD CATALOG_LIFESPAN	=	AU_TWELVE_HOURS; //in secs
const DWORD CATALOG_OFFLINE_LIFESPAN = AU_ONE_HOUR; 

//following files persisted across cycles. Under %program files%\windowsupdate
extern const LPTSTR ITEM_FILE; 
extern const LPTSTR DRIVERS_FILE;
extern const LPTSTR CATALOG_FILE;
extern const LPTSTR DETAILS_FILE; 


//following files are write once and never be read. 
#ifdef DBG
extern const LPTSTR DRIVER_SYSSPEC_FILE; 
extern const LPTSTR NONDRIVER_SYSSPEC_FILE; 
extern const LPTSTR PROVIDER_FILE; 
extern const LPTSTR PRODUCT_FILE ; 
extern const LPTSTR DETECT1_FILE ; 
extern const LPTSTR DETECT2_FILE; 
extern const LPTSTR DETECT3_FILE; 
extern const LPTSTR INSTALL_FILE; 
#endif
extern AUCatalog * gpAUcatalog;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\wuaueng\aueventlog.cpp ===
//=======================================================================
//
//  Copyright (c) 2001-2002 Microsoft Corporation.  All Rights Reserved.
//
//  File:    AUEventLog.cpp
//
//  Creator: DChow
//
//  Purpose: Event Logging class
//
//=======================================================================

#include "pch.h"

extern HINSTANCE g_hInstance;
extern AUCatalog *gpAUcatalog;

const TCHAR c_tszSourceKey[] = _T("SYSTEM\\CurrentControlSet\\Services\\Eventlog\\System\\Automatic Updates");

CAUEventLog::CAUEventLog(HINSTANCE hInstance)
: m_hEventLog(NULL), m_ptszListItemFormat(NULL)
{
	const DWORD c_dwLen = 64;
	LPTSTR ptszToken = NULL;

	if (NULL != (m_ptszListItemFormat = (LPTSTR) malloc(sizeof(TCHAR) * c_dwLen)) &&
		0 != LoadString(
					hInstance,
					IDS_EVT_LISTITEMFORMAT,
					m_ptszListItemFormat,
					c_dwLen) &&
		NULL != (ptszToken = StrStr(m_ptszListItemFormat, _T("%lS"))) &&
		EnsureValidSource() &&
		NULL != (m_hEventLog = RegisterEventSource(NULL, _T("Automatic Updates"))))
	{
		// bug 492897: WUAU: W2K: Event log error for installation failure
		// does not show the package that failed.  CombineItems() calls
		// StringCchPrintfEx() which in turn calls _sntprintf().  _sntprintf
		// calls wvsprintf().  Compiled with USE_VCRT=1, the %lS placeholder
		// in the format string will be replaced under Win2K by only the first
		// character of the intended string, contrary to MSDN.  It doesn't
		// happen if the placeholder is %ls, %ws or %wS, or if the running
		// platform is WinXP or .Net Server.  To get around the problem
		// without using an unsafe function, we choose to replace %lS in the
		// format string from resource with %ls.
		// We should move the fix to the resource string when we can.
		ptszToken[2] = _T('s');	// Convert %lS into %ls
	}
	else
	{
		AUASSERT(FALSE);

		SafeFreeNULL(m_ptszListItemFormat);
	}
}


CAUEventLog::~CAUEventLog()
{
	if (NULL != m_hEventLog)
	{
		DeregisterEventSource(m_hEventLog);
	}
	SafeFree(m_ptszListItemFormat);
}


// Assume no NULL in the pbstrItems and pptszMsgParams arrays.
BOOL CAUEventLog::LogEvent(
					WORD wType,
					WORD wCategory,
					DWORD dwEventID,
					UINT nNumOfItems,
					BSTR *pbstrItems,
					WORD wNumOfMsgParams,
					LPTSTR *pptszMsgParams) const
{
	if (NULL == m_hEventLog || NULL == m_ptszListItemFormat)
	{
		return FALSE;
	}

	BOOL fRet = FALSE;

	LPTSTR ptszItemList = NULL;
	LPTSTR *pptszAllMsgParams = pptszMsgParams;
	WORD wNumOfAllMsgParams = wNumOfMsgParams;

	if (0 < nNumOfItems)
	{
		wNumOfAllMsgParams++;

		if (NULL == (ptszItemList = CombineItems(nNumOfItems, pbstrItems)))
		{
			goto CleanUp;
		}

		if (0 < wNumOfMsgParams)
		{
			if (NULL == (pptszAllMsgParams = (LPTSTR *) malloc(sizeof(LPTSTR) * wNumOfAllMsgParams)))
			{
				goto CleanUp;
			}

			for (INT i=0; i<wNumOfMsgParams; i++)
			{
				pptszAllMsgParams[i] = pptszMsgParams[i];
			}
			pptszAllMsgParams[i] = ptszItemList;
		}
		else
		{
			pptszAllMsgParams = &ptszItemList;
		}
	}

	fRet = ReportEvent(
				m_hEventLog,
				wType,
				wCategory,
				dwEventID,
				NULL,
				wNumOfAllMsgParams,
				0,
				(LPCTSTR *) pptszAllMsgParams,
				NULL);

CleanUp:
	if (0 < nNumOfItems)
	{
		if (0 < wNumOfMsgParams)
		{
			SafeFree(pptszAllMsgParams);
		}
		SafeFree(ptszItemList);
	}
	return fRet;
}


BOOL CAUEventLog::LogEvent(
					WORD wType,
					WORD wCategory,
					DWORD dwEventID,
					SAFEARRAY *psa) const
{
    DEBUGMSG("CAUEvetLog::LogEvent(VARIANT version)");

	long lItemCount, i = 0;
	HRESULT hr;

// similar check should have been done in Update::LogEvent()
/*	if (NULL == psa)
	{
		hr = E_INVALIDARG;
		goto CleanUp;
	}

	VARTYPE vt;

	if (FAILED(hr = SafeArrayGetVartype(psa, &vt)))
	{
		DEBUGMSG("CAUEvetLog::LogEvent(VARIANT version) failed to get safearray type (%#lx)", hr);
		goto CleanUp;
	}

	if (VT_BSTR != vt)
	{
		DEBUGMSG("CAUEvetLog::LogEvent(VARIANT version) invalid element type of safearray (%#lx)", vt);
		goto CleanUp;
	}
*/
	if (FAILED(hr = SafeArrayGetUBound(psa, 1, &lItemCount)))
	{
		DEBUGMSG("CAUEventLog::LogEvent(VARIANT version) failed to get upper bound (%#lx)", hr);
		goto CleanUp;
	}

	lItemCount++;

	BSTR *pbstrItems = NULL;
	if (NULL == (pbstrItems = (BSTR *) malloc(sizeof(BSTR) * lItemCount)))
	{
		DEBUGMSG("CAUEventLog::LogEvent(VARIANT version) out of memory");
		goto CleanUp;
	}

	BOOL fRet = FALSE;
    while (i < lItemCount)
	{
		long dex = i;

        if (FAILED(hr = SafeArrayGetElement(psa, &dex, &pbstrItems[i])))
        {
            DEBUGMSG("CAUEventLog::LogEvent(VARIANT version) SafeArrayGetElement failed (%#lx)", hr);
            goto CleanUp;
        }
		i++;
	}

	fRet = LogEvent(
				wType,
				wCategory,
				dwEventID,
				lItemCount,
				pbstrItems);

CleanUp:
	if (NULL != pbstrItems)
	{
		while(i > 0)
		{
			SysFreeString(pbstrItems[--i]);
		}
		free(pbstrItems);
	}

	DEBUGMSG("CAUEventLog::LogEvent(VARIANT version) ends");

	return fRet;
}

// The caller is responsible for freeing the return value if this function succeeds.
LPTSTR CAUEventLog::CombineItems(UINT nNumOfItems, BSTR *pbstrItems) const
{
	DEBUGMSG("CombineItems");

	if (NULL != m_ptszListItemFormat && NULL != pbstrItems && 0 < nNumOfItems)
	{
		// Estimate buffer size
		size_t cchBufferLen = 1;	// 1 for the terminating NULL
		size_t cchListItemFormatLen = lstrlen(m_ptszListItemFormat);

		for (UINT i=0; i<nNumOfItems; i++)
		{
			if (0 < i)
			{
				cchBufferLen += 2;	// for line feed and carriage return (i.e. _T('\n'))
			}
			cchBufferLen += cchListItemFormatLen + SysStringLen(pbstrItems[i]);
		}

		LPTSTR ptszBuffer;

		cchBufferLen = min(cchBufferLen, 0x8000);	// String limit for ReportEvent
		if (NULL != (ptszBuffer = (LPTSTR) malloc(sizeof(TCHAR) * cchBufferLen)))
		{
			LPTSTR ptszDest = ptszBuffer;

			for (i = 0;;)
			{
				if (FAILED(StringCchPrintfEx(
								ptszDest,
								cchBufferLen,
								&ptszDest,
								&cchBufferLen,
								MISTSAFE_STRING_FLAGS,
								m_ptszListItemFormat,	// uses %ls; so okay w/ BSTR (UNICODE)
								pbstrItems[i++])))
				{
					DEBUGMSG("CAUEventLog::CombineItems() call to StringCchPrintfEx() failed");
					return ptszBuffer;
				}
				if (i == nNumOfItems)
				{
					return ptszBuffer;
				}
				if (cchBufferLen <= 1)
				{
					DEBUGMSG("CAUEventLog::CombineItems() insufficient buffer for newline");
					return ptszBuffer;
				}
				*ptszDest++ = _T('\n');
				*ptszDest = _T('\0');
				cchBufferLen--;
			}
		}
	}
	return NULL;
}


BOOL CAUEventLog::EnsureValidSource()
{
	HKEY hKey;
	DWORD dwDisposition;

	if (ERROR_SUCCESS != RegCreateKeyEx(
							HKEY_LOCAL_MACHINE,					// root key
							c_tszSourceKey,						// subkey
							0,									// reserved
							NULL,								// class name
							REG_OPTION_NON_VOLATILE,			// option
							KEY_QUERY_VALUE | KEY_SET_VALUE,	// security 
							NULL,								// security attribute
							&hKey,
							&dwDisposition))
	{
		return FALSE;
	}

	BOOL fRet = TRUE;

	if (REG_OPENED_EXISTING_KEY == dwDisposition)
	{
		(void) RegCloseKey(hKey);
	}
	else
	{
		DWORD dwCategoryCount = 2;	//fixcode: should it be hardcoded?
//		DWORD dwDisplayNameID = IDS_SERVICENAME;
		DWORD dwTypesSupported =
					EVENTLOG_ERROR_TYPE |
					EVENTLOG_WARNING_TYPE |
					EVENTLOG_INFORMATION_TYPE;
		const TCHAR c_tszWUAUENG_DLL[] = _T("%SystemRoot%\\System32\\wuaueng.dll");

		if (ERROR_SUCCESS != RegSetValueEx(
								hKey,
								_T("CategoryCount"),		// value name
								0,							// reserved
								REG_DWORD,					// type
								(BYTE*) &dwCategoryCount,	// data
								sizeof(dwCategoryCount)) ||	// size
			ERROR_SUCCESS != RegSetValueEx(
								hKey,
								_T("CategoryMessageFile"),
								0,
								REG_EXPAND_SZ,
								(BYTE*) c_tszWUAUENG_DLL,
								sizeof(c_tszWUAUENG_DLL)) ||	// not ARRAYSIZE
//			ERROR_SUCCESS != RegSetValueEx(
//								hKey,
//								_T("DisplayNameFile"),
//								0,
//								REG_EXPAND_SZ,
//								(BYTE*) c_tszWUAUENG_DLL,
//								sizeof(c_tszWUAUENG_DLL)) ||	// not ARRAYSIZE
//			ERROR_SUCCESS != RegSetValueEx(
//								hKey,
//								_T("DisplayNameID"),
//								0,
//								REG_DWORD,
//								(BYTE*) &dwDisplayNameID,
//								sizeof(dwDisplayNameID)) ||
			ERROR_SUCCESS != RegSetValueEx(
								hKey,
								_T("EventMessageFile"),
								0,
								REG_EXPAND_SZ,
								(BYTE*) c_tszWUAUENG_DLL,
								sizeof(c_tszWUAUENG_DLL)) ||	// not ARRAYSIZE
			ERROR_SUCCESS != RegSetValueEx(
								hKey,
								_T("TypesSupported"),
								0,
								REG_DWORD,
								(BYTE*) &dwTypesSupported,
								sizeof(dwTypesSupported)))
		{
			fRet = FALSE;
		}

		if (ERROR_SUCCESS != RegCloseKey(hKey))
		{
			fRet = FALSE;
		}
	}

	return fRet;
}


void LogEvent_ItemList(
		WORD wType,
		WORD wCategory,
		DWORD dwEventID,
		WORD wNumOfMsgParams,
		LPTSTR *pptszMsgParams)
{
	AUCatalogItemList &itemList = gpAUcatalog->m_ItemList;
	UINT nNumOfItems = itemList.GetNumSelected();

	if (0 < nNumOfItems)
	{
		BSTR *pbstrItems = (BSTR *) malloc(sizeof(BSTR) * nNumOfItems);

		if (NULL != pbstrItems)
		{
			CAUEventLog aueventlog(g_hInstance);
			UINT j = 0;

			for (UINT i=0; i<itemList.Count(); i++)
			{
				AUCatalogItem &item = itemList[i];
				if (item.fSelected())
				{
					pbstrItems[j++] = item.bstrTitle();
				}
			}

			aueventlog.LogEvent(
				wType,
				wCategory,
				dwEventID,
				nNumOfItems,
				pbstrItems,
				wNumOfMsgParams,
				pptszMsgParams);

			free(pbstrItems);
		}
		else
		{
			DEBUGMSG("LogEvent_ItemList() failed to allocate memory for pbstrItems");
		}
	}
	else
	{
		DEBUGMSG("LogEvent_ItemList() no item in gpAUcatalog is selected!");
	}
}


void LogEvent_ScheduledInstall(void)
{
	TCHAR tszScheduledDate[64];
	TCHAR tszScheduledTime[40];
	AUFILETIME auftSchedInstallDate;
	SYSTEMTIME stScheduled;

	DEBUGMSG("LogEvent_ScheduledInstall");

	gpState->GetSchedInstallDate(auftSchedInstallDate);

	//fixcode: any need to use DATE_LTRREADING or DATE_RTLREADING?
	if (FileTimeToSystemTime(&auftSchedInstallDate.ft, &stScheduled))
	{
		if (0 != GetDateFormat(
					LOCALE_SYSTEM_DEFAULT,
					LOCALE_NOUSEROVERRIDE | DATE_LONGDATE,
					&stScheduled,
					NULL,
					tszScheduledDate,
					ARRAYSIZE(tszScheduledDate)))
		{
			if (Hours2LocalizedString(
					&stScheduled,
					tszScheduledTime,
					ARRAYSIZE(tszScheduledTime)))
			{
				LPTSTR pptszMsgParams[2];

				pptszMsgParams[0] = tszScheduledDate;
				pptszMsgParams[1] = tszScheduledTime;

				LogEvent_ItemList(
					EVENTLOG_INFORMATION_TYPE,
					IDS_MSG_Installation,
					IDS_MSG_InstallReady_Scheduled,
					2,
					pptszMsgParams);
			}
		#ifdef DBG
			else
			{
				DEBUGMSG("LogEvent_ScheduledInstall() call to Hours2LocalizedString() failed");
			}
		#endif
		}
	#ifdef DBG
		else
		{
			DEBUGMSG("LogEvent_ScheduledInstall() call to GetDateFormatW() failed (%#lx)", GetLastError());
		}
	#endif
	}
#ifdef DBG
	else
	{
		DEBUGMSG("LogEvent_ScheduledInstall() call to FileTimeToSystemTime() failed (%#lx)", GetLastError());
	}
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\wuaueng\auservinternals.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       auservinternals.h
//
//--------------------------------------------------------------------------

#pragma once

HRESULT	removeTimeOutKeys(BOOL fLastWaitReminderKeys);
HRESULT	getReminderTimeout(DWORD *, UINT *);
HRESULT getReminderState(DWORD *);
HRESULT	removeReminderKeys(void);	
HRESULT getLastWaitTimeout(DWORD * pdwLastWaitTimeout);
HRESULT setLastWaitTimeout(DWORD pdwLastWaitTimeout);
HRESULT removeLastWaitKey(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\wuaueng\aueventlog.h ===
//=======================================================================
//
//  Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:    AUEventLog.h
//
//  Creator: DChow
//
//  Purpose: Event Logging class
//
//=======================================================================

#pragma once

#include <windows.h>

class CAUEventLog
{
public:
	CAUEventLog(HINSTANCE hInstance);
	~CAUEventLog();

	BOOL LogEvent(
			WORD wType,
			WORD wCatagory,
			DWORD dwEventID,
			UINT nNumOfItems = 0,
			BSTR *pbstrItems = NULL,
			WORD wNumOfMsgParams = 0,
			LPTSTR *pptszMsgParams = NULL) const;
	BOOL LogEvent(
			WORD wType,
			WORD wCatagory,
			DWORD dwEventID,
			SAFEARRAY *psa) const;
	LPTSTR CombineItems(
			UINT nNumOfItems,
			BSTR *pbstItems) const;

private:
	HANDLE m_hEventLog;
	LPTSTR m_ptszListItemFormat;

	BOOL EnsureValidSource();
};


void LogEvent_ItemList(
		WORD wType,
		WORD wCategory,
		DWORD dwEventID,
		WORD wNumOfMsgParams = 0,
		LPTSTR *pptszMsgParams = NULL);

void LogEvent_ScheduledInstall(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\wuaueng\auservinternals.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       auservinternals.cpp
//
//--------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop


/*****
 Looks for reminder timestamp in users registry. If not found, returns
 failure. If found, passes the remaining timeout in seconds remaining
 before we should remind the user
*****/ 
HRESULT getReminderTimeout(DWORD *pdwTimeDiff, UINT * /*pIndex*/)
{
	return getAddedTimeout(pdwTimeDiff, TIMEOUTVALUE);
}


HRESULT getReminderState(DWORD *pdwState)
{
	HKEY	hAUKey;
	LONG	lRet;
	DWORD	dwType = REG_DWORD, dwSize = sizeof(DWORD);
	return GetRegDWordValue(TIMEOUTSTATE,pdwState);
}


HRESULT	removeTimeOutKeys(BOOL fLastWaitReminderKeys)
{
	if (fLastWaitReminderKeys)
	{
		return DeleteRegValue(LASTWAITTIMEOUT);
	}
	else
	{
		HRESULT hr1 = DeleteRegValue(TIMEOUTVALUE);
		HRESULT hr2 = DeleteRegValue( TIMEOUTSTATE);
		if (FAILED(hr1) || FAILED(hr2))
		{
			return FAILED(hr1)? hr1 : hr2;
		}
		else
		{
			return S_OK;
		}	
	}
}
HRESULT	removeReminderKeys()
{
	return removeTimeOutKeys(FALSE);
}
HRESULT	setLastWaitTimeout(DWORD pdwLastWaitTimeout)
{
	return setAddedTimeout(pdwLastWaitTimeout, LASTWAITTIMEOUT);
}
HRESULT	getLastWaitTimeout(DWORD * pdwLastWaitTimeout)
{
	return getAddedTimeout(pdwLastWaitTimeout, LASTWAITTIMEOUT);
}
HRESULT	removeLastWaitKey(void)
{
	return removeTimeOutKeys(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\wuaueng\ausessions.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       ausessions.h
//  		     Definition of the Updates class
//
//--------------------------------------------------------------------------

#pragma once

#define MAX_WTS 256 // replace 256 by whatever the limit of TS Client is
#define CDWNO_SESSION -2

#define CMIN_SESSIONS 4

//fixcode: why a structure with only one member
//fixcode: misleading name. fSource will be better
typedef struct _Session_State
{
	BOOL fFoundEnumerating;
} SESSION_STATE;

typedef struct _Session_State_Info
{
	DWORD dwSessionId;
	SESSION_STATE SessionState;
} SESSION_STATE_INFO;

class SESSION_STATUS
{
public:
    SESSION_STATUS();
    ~SESSION_STATUS();

	BOOL Initialize(BOOL fUseCriticalSection, BOOL fAllActiveUsers);
	void Clear(void);
	BOOL m_FAddSession(DWORD dwSessionId, SESSION_STATE *pSesState);
	BOOL m_FGetSessionState(DWORD dwSessionId, SESSION_STATE **pSesState ); //check if dwSessionId is in cache	
	BOOL m_FDeleteSession(DWORD dwSessionId);
	int  CSessions(void)
	{
		return m_iLastSession + 1;
	}
	BOOL m_FGetNextSession(DWORD *pdwSessionId);
	BOOL m_FGetCurrentSession(DWORD *pdwSessionId);
    int  m_iGetSessionIdAtIndex(int iIndex);
	int  m_iFindSession(DWORD dwSessionId); //get cache index for dwSessionId

    void m_DumpSessions();   // for debug purposes
    void m_EraseAll();

    BOOL CacheSessionIfAUEnabledAdmin(DWORD dwSessionId, BOOL fFoundEnumerating);
    VOID CacheExistingSessions();
    void ValidateCachedSessions();
    void RebuildSessionCache();
private:
	BOOL m_FChangeBufSession(int cSessions);

	SESSION_STATE_INFO *m_pSessionStateInfo;
	int m_iLastSession;
	int m_cAllocBufSessions;
	int m_iCurSession;	

    CRITICAL_SECTION m_csWrite;
    BOOL m_fAllLoggedOnUsers; //Active Admin only otherwise
	BOOL m_fInitCS;	// whether critical section has been initialized
};

//#define ALL_SESSIONS -2
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\wuaueng\ausens.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  sens.cpp
//
//  Modele that implements a COM+ subscriber for use with SENS notifications. 
//
//  10/9/2001   annah   Created
//                      Ported code from BITS sources. Removed SEH code, 
//                      changed methods that threw exceptions to return
//                      error codes.
//
//----------------------------------------------------------------------------


#include "pch.h"
#include "ausens.h"
#include "tscompat.h"
#include "service.h"

static CLogonNotification  *g_SensLogonNotification = NULL;


HRESULT ActivateSensLogonNotification()
{
    HRESULT hr = S_OK;

    // only activate once
    if ( g_SensLogonNotification )
    {
        DEBUGMSG("AUSENS Logon object was already created; reusing object.");
        return S_OK;
    }

    g_SensLogonNotification = new CLogonNotification();
    if (!g_SensLogonNotification)
    {
        DEBUGMSG("AUSENS Failed to alocate memory for CLogonNotification object.");
        return E_OUTOFMEMORY;
    }

    hr = g_SensLogonNotification->Initialize();
    if (FAILED(hr))
    {
        DEBUGMSG( "AUSENS notification activation failed." );
    }
    else
    {
        DEBUGMSG( "AUSENS notification activated" );
    }

    return hr;
}

HRESULT DeactivateSensLogonNotification()
{
    if (!g_SensLogonNotification)
    {
        DEBUGMSG("AUSENS Logon object is not activated; ignoring call.");
        return S_OK;
    }

	HRESULT hr = S_OK;
	if (FAILED(hr = CoDisconnectObject(g_SensLogonNotification, 0)))
	{
		DEBUGMSG("AUSENS fail to disconnect objet with error %#lx", hr);
	}
    delete g_SensLogonNotification;
    g_SensLogonNotification = NULL;

    DEBUGMSG( "AUSENS notification deactivated" );
    return S_OK;
}

//----------------------------------------------------------------------------
// BSTR manipulation
//----------------------------------------------------------------------------

 HRESULT AppendBSTR(BSTR *bstrDest, BSTR bstrAppend)
 {
     HRESULT hr      = S_OK;
     BSTR    bstrNew = NULL;

     if (bstrDest == NULL || *bstrDest == NULL)
         return E_INVALIDARG;

     if (bstrAppend == NULL)
         return S_OK;

     hr = VarBstrCat(*bstrDest, bstrAppend, &bstrNew);
     if (SUCCEEDED(hr))
     {
         SysFreeString(*bstrDest);
         *bstrDest = bstrNew;
     }

     return hr;
 }

 // Caller is responsible for freeing bstrOut
 HRESULT BSTRFromIID(IN REFIID riid, OUT BSTR *bstrOut)
 {
     HRESULT   hr       = S_OK;
     LPOLESTR  lpszGUID = NULL;

     if (bstrOut == NULL)
     {
         hr = E_INVALIDARG;
         goto done;
     }

     hr = StringFromIID(riid, &lpszGUID);
     if (FAILED(hr))
     {
         DEBUGMSG("AUSENS Failed to extract GUID from string");
         goto done;
     }

     *bstrOut = SysAllocString(lpszGUID);
     if (*bstrOut == NULL)
     {
         hr = E_OUTOFMEMORY;
         goto done;
     }

 done:
     if (lpszGUID)
     {
         CoTaskMemFree(lpszGUID);
     }

     return hr;
 }

 HRESULT CBstrTable::Initialize()
 {
     HRESULT hr = S_OK;

     hr = BSTRFromIID(g_oLogonSubscription.SubscriptionGuid, &m_bstrLogonSubscriptionGuid);
     if (FAILED(hr))
     {
         goto done;
     }

     m_bstrSubscriptionName = SysAllocString(SUBSCRIPTION_NAME_TEXT);
     if (m_bstrSubscriptionName == NULL)
     {
         hr = E_OUTOFMEMORY;
         goto done;
     }    

     m_bstrSubscriptionDescription = SysAllocString(SUBSCRIPTION_DESCRIPTION_TEXT);
     if (m_bstrSubscriptionDescription == NULL)
     {
         hr = E_OUTOFMEMORY;
         goto done;
     }    

     hr = BSTRFromIID(_uuidof(ISensLogon), &m_bstrSensLogonGuid);
     if (FAILED(hr))
     {
         goto done;
     }

     hr = BSTRFromIID(SENSGUID_EVENTCLASS_LOGON, &m_bstrSensEventClassGuid);
     if (FAILED(hr))
     {
         goto done;
     }

 done:
     return hr;
 }


//----------------------------------------------------------------------------
// Implementation for CLogonNotification methods
//----------------------------------------------------------------------------

HRESULT CLogonNotification::Initialize()
{
   HRESULT  hr = S_OK;
   SIZE_T   cSubscriptions = 0;

   // 
   // Create auxiliary object with BSTR names used for several actions
   //
   m_oBstrTable = new CBstrTable();
   if (!m_oBstrTable)
   {
       return E_OUTOFMEMORY;
   }

   hr = m_oBstrTable->Initialize();
   if (FAILED(hr))
   {
       DEBUGMSG("AUSENS Could not create auxiliary structure BstrTable");
       return hr;
   }

   //
   // Load the type library from SENS
   //
   hr = LoadTypeLibEx(L"SENS.DLL", REGKIND_NONE, &m_TypeLib);
   if (FAILED(hr))
   {
       DEBUGMSG("AUSENS Could not load type library from SENS DLL");
       goto done;
   }

   //
   // Get TypeInfo for ISensLogon from SENS typelib -- this will
   // simplify thing for us when implementing IDispatch methods
   //
   hr = m_TypeLib->GetTypeInfoOfGuid(__uuidof( ISensLogon ), &m_TypeInfo);
   if (FAILED(hr))
   {
       DEBUGMSG("AUSENS Could not get type info for ISensLogon.");
       goto done;
   }

   //
   // Grab an interface pointer of the EventSystem object
   //
   hr = CoCreateInstance(CLSID_CEventSystem, NULL, CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER, IID_IEventSystem, (void**)&m_EventSystem );
   if (FAILED(hr))
   {
       DEBUGMSG("AUSENS Failed to create EventSytem instance for Sens subscription. Error is %x.", hr);
       goto done;
   }

   //
   // Subscribe for the Logon notifications
   //
   DEBUGMSG("AUSENS Subscribing ALL methods with SENS");
   hr = SubscribeMethod(m_oBstrTable->m_bstrLogonSubscriptionGuid);
   if (FAILED(hr))
   {
       DEBUGMSG("AUSENS Subscription for method failed.");
       goto done;
   }
   m_fSubscribed = TRUE;

done:

   return hr;
}

HRESULT CLogonNotification::UnsubscribeAllMethods()
{
    HRESULT   hr                      = S_OK;
    BSTR      bstrQuery               = NULL;
    BSTR      bstrAux                 = NULL;
    int       ErrorIndex;

    DEBUGMSG("AUSENS Unsubscribing all methods");
    //
    // The query should be a string in the following format:
    // EventClassID == {D5978630-5B9F-11D1-8DD2-00AA004ABD5E} and SubscriptioniD == {XXXXXXX-5B9F-11D1-8DD2-00AA004ABD5E}
    //

    bstrQuery = SysAllocString(L"EventClassID == ");
    if (bstrQuery == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }
    
    bstrAux = SysAllocString(L" and SubscriptionID == ");
    if (bstrAux == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = AppendBSTR(&bstrQuery, m_oBstrTable->m_bstrSensLogonGuid);
    if (FAILED(hr))
    {
        DEBUGMSG("AUSENS Failed to append BSTR string");
        goto done;
    }

    hr = AppendBSTR(&bstrQuery, bstrAux);
    if (FAILED(hr))
    {
        DEBUGMSG("AUSENS Failed to append BSTR string");
        goto done;
    }

    hr = AppendBSTR(&bstrQuery, m_oBstrTable->m_bstrLogonSubscriptionGuid);
    if (FAILED(hr))
    {
        DEBUGMSG("AUSENS Failed to append BSTR string");
        goto done;
    }

	if (bstrQuery != NULL)
    {    
	    // Remove subscription for all ISensLogon subscription that were added for this WU component
        DEBUGMSG("AUSENS remove subscription query: %S", bstrQuery);
	    hr = m_EventSystem->Remove( PROGID_EventSubscription, bstrQuery, &ErrorIndex );
	    if (FAILED(hr))
	    {
            DEBUGMSG("AUSENS Failed to remove AU Subscription from COM Event System");
            goto done;
	    }
        m_fSubscribed = FALSE;
	}
    else
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

done:

    SafeFreeBSTR(bstrQuery);
    SafeFreeBSTR(bstrAux);

    return hr;
}

HRESULT CLogonNotification::SubscribeMethod(const BSTR bstrSubscriptionGuid)
{
    HRESULT              hr = S_OK;
    IEventSubscription  *pEventSubscription  = NULL;

    //
    // Create an instance of EventSubscription
    //
    hr = CoCreateInstance(CLSID_CEventSubscription, NULL, CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER, IID_IEventSubscription, (void**)&pEventSubscription); 
    if (FAILED(hr))
    {
        DEBUGMSG("AUSENS Failed to instanciate EventSubscription object");
        goto done;
    }

    //
    // Subscribe the method
    //
    hr = pEventSubscription->put_EventClassID(m_oBstrTable->m_bstrSensEventClassGuid);
    if (FAILED(hr))
    {
        DEBUGMSG("AUSENS Failed to set EventClassID during method subscription");
        goto done;
    }

    hr = pEventSubscription->put_SubscriberInterface(this);
    if (FAILED(hr))
    {
        DEBUGMSG("AUSENS Failed to set EventClassID during method subscription");
        goto done;
    }

    hr = pEventSubscription->put_SubscriptionName(m_oBstrTable->m_bstrSubscriptionName);
    if (FAILED(hr))
    {
        DEBUGMSG("AUSENS Failed to set EventClassID during method subscription");
        goto done;
    }

    hr = pEventSubscription->put_Description(m_oBstrTable->m_bstrSubscriptionDescription);
    if (FAILED(hr))
    {
        DEBUGMSG("AUSENS Failed to set subscription method during method subscription");
        goto done;
    }

    hr = pEventSubscription->put_Enabled(TRUE);
    if (FAILED(hr))
    {
        DEBUGMSG("AUSENS Failed to set enabled flag during method subscription");
        goto done;
    }

    hr = pEventSubscription->put_MethodName(NULL); //subscribe to all events about ISensLogon
    if (FAILED(hr))
    {
        DEBUGMSG("AUSENS Failed to set MethodName during method subscription");
        goto done;
    }

    hr = pEventSubscription->put_SubscriptionID(bstrSubscriptionGuid);
    if (FAILED(hr))
    {
        DEBUGMSG("AUSENS Failed to set SubscriptionID during method subscription");
        goto done;
    }

    hr = m_EventSystem->Store(PROGID_EventSubscription, pEventSubscription);
    if (FAILED(hr))
    {
        DEBUGMSG("AUSENS Failed to store Event Subscription in the Event System");
        goto done;
    }

done:
    SafeRelease(pEventSubscription);

    return hr;
}

void CLogonNotification::Cleanup()
{
    __try
    {
        if (m_EventSystem)
        {
            if (m_fSubscribed)
            {
                UnsubscribeAllMethods();
            }
            SafeRelease(m_EventSystem);
        }

        SafeRelease(m_TypeInfo);
        SafeRelease(m_TypeLib);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        DEBUGMSG("AUSENS Cleanup raised and execution exception that was trapped.");
    }

    if (m_oBstrTable)
    {
        delete m_oBstrTable;
        m_oBstrTable = NULL;
    }
}

HRESULT CLogonNotification::CheckLocalSystem()
{
    HRESULT                     hr             = E_FAIL;
    PSID                        pLocalSid      = NULL;
    HANDLE                      hToken         = NULL;
    SID_IDENTIFIER_AUTHORITY    IDAuthorityNT  = SECURITY_NT_AUTHORITY;
    BOOL                        fRet           = FALSE;
    BOOL                        fIsLocalSystem = FALSE;

    fRet = AllocateAndInitializeSid(
                &IDAuthorityNT,
                1,
                SECURITY_LOCAL_SYSTEM_RID,
                0,0,0,0,0,0,0,
                &pLocalSid );

    if (fRet == FALSE) 
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        DEBUGMSG("AUSENS AllocateAndInitializeSid failed with error %x", hr);
        goto done;
    }

    if (FAILED(hr = CoImpersonateClient()))
	{
        DEBUGMSG("AUSENS Failed to impersonate client", hr);
        hr = E_ACCESSDENIED;
        goto done;
	}
    
    fRet = OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &hToken);
    if (fRet == FALSE)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        DEBUGMSG("AUSENS Failed to OpenProcessToken");
        goto done;
    }

    if (FAILED(CoRevertToSelf()))
    {
    	AUASSERT(FALSE); //should never be there
    	hr = E_ACCESSDENIED;
    	goto done;
    }

    fRet = CheckTokenMembership(hToken, pLocalSid, &fIsLocalSystem);
    if (fRet == FALSE)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        DEBUGMSG("AUSENS fail to Check token membership with error %x", hr);
        goto done;
    }

    if (fIsLocalSystem)
    {
        hr = S_OK;
    }
    else
    {
        hr = E_ACCESSDENIED;
        DEBUGMSG("AUSENS SECURITY CHECK Current thread is not running as LocalSystem!!");
    }

done:

    if (hToken != NULL)
        CloseHandle(hToken);
    if (pLocalSid != NULL)
        FreeSid(pLocalSid);

    return hr;
}

STDMETHODIMP CLogonNotification::Logon( BSTR UserName )
{
    DEBUGMSG("AUSENS logon notification for %S", (WCHAR*)UserName );
    DEBUGMSG("AUSENS Forcing the rebuilt of the cachesessions array");

    // 
    // fix for security bug 563054 -- annah
    //
    // The Logon() method is called by the COM+ Event System to notify us of a logon event
    // We expose the ISensLogon interface but don't want anybody calling us
    // that is not the COM+ Event System.
    //
    // The COM+ Event System service runs as Local System in the netsvcs svchost group.
    // We will check if the caller is really the Event System by checking for
    // the Local System account.
    //
    HRESULT hr = CheckLocalSystem();
    if (FAILED(hr))
    {
        DEBUGMSG("AUSENS CheckLocalSystem failed with error %x. Will not trigger logon notification", hr);
        goto done;
    }


    //
    // One big problem of the code below is that although we're validating that
    // there are admins on the machine who are valid users for AU, it could be the 
    // same that was already there, because we don't have a reliable way of receiving
    // logoff notifications. So we will raise the NEW_ADMIN event here, and
    // we will block the cretiion of a new client if we detect that there's a
    // a client still running.
    // 
    gAdminSessions.RebuildSessionCache();
    if (gAdminSessions.CSessions() > 0 || gpState->fRebootWarningMode())
	{
        DEBUGMSG("AU SENS Logon: There are admins in the admin cache, raising NEW_ADMIN event (it could be a false alarm)");
        SetClientSessionEvent();
    }

#if DBG
    gAdminSessions.m_DumpSessions();
#endif

done:

    return S_OK;
}

STDMETHODIMP CLogonNotification::Logoff( BSTR UserName )
{
    DEBUGMSG( "AUSENS logoff notification for %S", (WCHAR*)UserName );

    if (gpState->fRebootWarningMode())
    {
        SetClientSessionEvent(); 
    }

#if DBG
    gAdminSessions.m_DumpSessions();
#endif

    return S_OK;
}

STDMETHODIMP CLogonNotification::QueryInterface(REFIID iid, void** ppvObject)
{
    HRESULT hr = S_OK;
    *ppvObject = NULL;

    if ((iid == IID_IUnknown) || (iid == _uuidof(IDispatch)) || (iid == _uuidof(ISensLogon)))
    {
        *ppvObject = static_cast<ISensLogon *> (this);
        (static_cast<IUnknown *>(*ppvObject))->AddRef();
    }
    else
    {
        hr = E_NOINTERFACE;
    }

    return hr;
}

STDMETHODIMP CLogonNotification::GetIDsOfNames(REFIID, OLECHAR ** rgszNames, unsigned int cNames, LCID, DISPID *rgDispId )
{
    return m_TypeInfo->GetIDsOfNames(rgszNames, cNames, rgDispId);
}

    
STDMETHODIMP CLogonNotification::GetTypeInfo(unsigned int iTInfo, LCID, ITypeInfo **ppTInfo )
{
    if ( iTInfo != 0 )
        return DISP_E_BADINDEX;

    *ppTInfo = m_TypeInfo;
    m_TypeInfo->AddRef();

    return S_OK;
}

STDMETHODIMP CLogonNotification::GetTypeInfoCount(unsigned int *pctinfo)
{
    *pctinfo = 1;
    return S_OK;
}

STDMETHODIMP CLogonNotification::Invoke( 
    DISPID dispID, 
    REFIID riid, 
    LCID, 
    WORD wFlags, 
    DISPPARAMS *pDispParams, 
    VARIANT *pvarResult, 
    EXCEPINFO *pExcepInfo, 
    unsigned int *puArgErr )
{

    if (riid != IID_NULL)
    {
        return DISP_E_UNKNOWNINTERFACE;
    }

    return m_TypeInfo->Invoke(
        (IDispatch*) this,
        dispID,
        wFlags,
        pDispParams,
        pvarResult,
        pExcepInfo,
        puArgErr
        );
}

STDMETHODIMP CLogonNotification::DisplayLock( BSTR UserName )
{
    return S_OK;
}

STDMETHODIMP CLogonNotification::DisplayUnlock( BSTR UserName )
{
    return S_OK;
}

STDMETHODIMP CLogonNotification::StartScreenSaver( BSTR UserName )
{
    return S_OK;
}

STDMETHODIMP CLogonNotification::StopScreenSaver( BSTR UserName )
{
    return S_OK;
}

STDMETHODIMP CLogonNotification::StartShell( BSTR UserName )
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\wuaueng\ausens.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  sens.h
//
//  Definition of classes needed for to handle SENS notifications.
//
//  10/9/2001   annah   Created
//
//----------------------------------------------------------------------------

#pragma once

#include <coguid.h>
#include <sens.h>
#include <sensevts.h>
#include <eventsys.h>

//----------------------------------------------------------------------------
// Information used to create the AU subscriptions with ISensLogon
//----------------------------------------------------------------------------

static struct { GUID SubscriptionGuid;} g_oLogonSubscription = {
    // Declares the guid and name for our Logon method. 
    // L"{2f519218-754d-4cfe-8daa-5215cd0de0eb}", 
    { 0x2f519218, 0x754d, 0x4cfe, {0x8d, 0xaa, 0x52, 0x15, 0xcd, 0x0d, 0xe0, 0xeb} }
};
#define SUBSCRIPTION_NAME_TEXT          L"WU Autoupdate"
#define SUBSCRIPTION_DESCRIPTION_TEXT   L"WU Autoupdate Notification subscription"

class CBstrTable {
    void Cleanup()
    {
        SafeFreeBSTR(m_bstrLogonSubscriptionGuid);
        SafeFreeBSTR(m_bstrSubscriptionName);
        SafeFreeBSTR(m_bstrSubscriptionDescription);
        SafeFreeBSTR(m_bstrSensEventClassGuid);
        SafeFreeBSTR(m_bstrSensLogonGuid);
    }

public:
    BSTR m_bstrLogonSubscriptionGuid;
    BSTR m_bstrSubscriptionName;
    BSTR m_bstrSubscriptionDescription;

    BSTR m_bstrSensEventClassGuid;
    BSTR m_bstrSensLogonGuid;

    CBstrTable() :
        m_bstrLogonSubscriptionGuid(NULL),
        m_bstrSubscriptionName(NULL),
        m_bstrSubscriptionDescription(NULL),
        m_bstrSensEventClassGuid(NULL),
        m_bstrSensLogonGuid(NULL) { }

    ~CBstrTable() { Cleanup(); }

    HRESULT Initialize();
};

//----------------------------------------------------------------------------
// Prototypes for functions used externally
//----------------------------------------------------------------------------

HRESULT ActivateSensLogonNotification();
HRESULT DeactivateSensLogonNotification();

//----------------------------------------------------------------------------
// CSimpleIUnknown
// 
// Light-weight class that implements the basic COM methods.
//----------------------------------------------------------------------------

template<class T> class CSimpleIUnknown : public T
{
public:
    // IUnknown Methods
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObject);
    ULONG _stdcall AddRef(void);
    ULONG _stdcall Release(void);

protected:
    CSimpleIUnknown() : m_refs(1) {}; // always start with one ref count!
    LONG    m_refs;
};

template<class T> STDMETHODIMP CSimpleIUnknown<T>::QueryInterface(REFIID iid, void** ppvObject)
{
    HRESULT hr = S_OK;
    *ppvObject = NULL;

    if ((iid == IID_IUnknown) || (iid == _uuidof(T)))
    {
        *ppvObject = static_cast<T *> (this);
        (static_cast<IUnknown *>(*ppvObject))->AddRef();
    }
    else
    {
        hr = E_NOINTERFACE;
    }

    return hr;
}

template<class T> ULONG CSimpleIUnknown<T>::AddRef()
{
    ULONG newrefs = InterlockedIncrement(&m_refs);

    return newrefs;
}

template<class T> ULONG CSimpleIUnknown<T>::Release()
{
    ULONG newrefs = InterlockedDecrement(&m_refs);

    if (newrefs == 0)
    {
        DEBUGMSG("Deleting object due to ref count hitting 0");

        delete this;
        return 0;
    }

    return m_refs;
}


//----------------------------------------------------------------------------
// CLogonNotification
//
// This is the class that will be used to subscribe to SENS. As such,
// it needs to implement the IDispatch interface and the ISensLogon methods.
// 
// ISensLogon already inherits from IUnknown and IDispatch, so there's no
// need to make CLogonNotification to do this also.
//
//----------------------------------------------------------------------------

class CLogonNotification : public CSimpleIUnknown<ISensLogon>
{
public:
    CLogonNotification() :
      m_EventSystem( NULL ),
      m_TypeLib( NULL ),
      m_TypeInfo( NULL ),
      m_fSubscribed( FALSE ),
      m_oBstrTable(NULL) {}

    ~CLogonNotification() { Cleanup(); }

    HRESULT Initialize();

private:

    IEventSystem *m_EventSystem;
    ITypeLib     *m_TypeLib;
    ITypeInfo    *m_TypeInfo;

    CBstrTable *m_oBstrTable;
    BOOL        m_fSubscribed;

    void    Cleanup();
    HRESULT SubscribeMethod( const BSTR bstrSubscriptionGuid);
    HRESULT UnsubscribeAllMethods();
    HRESULT CheckLocalSystem();

public:
    // Other IUnknown methods come from CSimpleIUnknown
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);

    // IDispatch methods (needed for SENS subscription)
    HRESULT STDMETHODCALLTYPE GetTypeInfoCount(unsigned int FAR* pctinfo);
    HRESULT STDMETHODCALLTYPE GetTypeInfo(unsigned int iTInfo, LCID lcid, ITypeInfo FAR* FAR* ppTInfo); 
    HRESULT STDMETHODCALLTYPE GetIDsOfNames(REFIID riid, OLECHAR FAR* FAR* rgszNames, unsigned int cNames, LCID lcid, DISPID FAR* rgDispId);
    HRESULT STDMETHODCALLTYPE Invoke(DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS FAR* pDispParams, VARIANT FAR* pVarResult, EXCEPINFO FAR* pExcepInfo, unsigned int FAR* puArgErr);

    // ISensLogon methods -- we will be using only Logon & Logoff
    HRESULT STDMETHODCALLTYPE DisplayLock( BSTR UserName );
    HRESULT STDMETHODCALLTYPE DisplayUnlock( BSTR UserName );
    HRESULT STDMETHODCALLTYPE StartScreenSaver( BSTR UserName );
    HRESULT STDMETHODCALLTYPE StopScreenSaver( BSTR UserName );
    HRESULT STDMETHODCALLTYPE Logon( BSTR UserName );
    HRESULT STDMETHODCALLTYPE Logoff( BSTR UserName );
    HRESULT STDMETHODCALLTYPE StartShell( BSTR UserName );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\wuaueng\ausessions.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       ausessions.cpp
// 
//  History:    10/19/2001  annah
//                          transformed struct in class, added constructors
//                          destructors, and also proctected write operations
//                          with a critical session (on win2k the code can
//                          have race conditions). Also moved some functions
//                          from service.cpp to the class.
//
//--------------------------------------------------------------------------
#include "pch.h"
#include "tscompat.h" 
#include "service.h"

#pragma hdrstop

//SESSION_STATUS Functions
SESSION_STATUS::SESSION_STATUS (void)
{
	m_fInitCS = FALSE;
}

SESSION_STATUS::~SESSION_STATUS()
{
	if (m_fInitCS)
	{
		DeleteCriticalSection(&m_csWrite);
	}
}

BOOL SESSION_STATUS::Initialize(BOOL fUseCriticalSection, BOOL fAllLoggedOnUsers)
{
    m_fAllLoggedOnUsers = fAllLoggedOnUsers;
	m_pSessionStateInfo =  NULL;		
	m_iLastSession = -1;
	m_cAllocBufSessions = 0;
	m_iCurSession = CDWNO_SESSION;		
    //
    // The code will only execute concurrent paths on win2K
    // It won't be expensive to use th critical session
    //  for all platforms, however
    //
	if (fUseCriticalSection)
	{
		if (!m_fInitCS)
		{
			m_fInitCS = SafeInitializeCriticalSection(&m_csWrite);
		}
	}
	else
	{
		AUASSERT(!m_fInitCS);
	}
	return (m_fInitCS == fUseCriticalSection);
}

void SESSION_STATUS::Clear(void)
{
	if (NULL != m_pSessionStateInfo)
	{
		free(m_pSessionStateInfo);
	}	
}


// Method used when we want to rebuild the array from scratch
void SESSION_STATUS::m_EraseAll()
{
	if (m_fInitCS)
	{
		EnterCriticalSection(&m_csWrite);
	}

    Clear();
    BOOL fRet = Initialize(m_fInitCS, m_fAllLoggedOnUsers);
	AUASSERT(fRet);

	if (m_fInitCS)
	{
		LeaveCriticalSection(&m_csWrite);
	}
}

void SESSION_STATUS::RebuildSessionCache()
{
	if (m_fInitCS)
	{
		EnterCriticalSection(&m_csWrite);
	}

	m_EraseAll();
    CacheExistingSessions();

	if (m_fInitCS)
	{
		LeaveCriticalSection(&m_csWrite);
	}
}

BOOL SESSION_STATUS::m_FAddSession(DWORD dwSessionId, SESSION_STATE *pSesState)
{	
	BOOL fRet = TRUE;

	if (m_fInitCS)
	{
		EnterCriticalSection(&m_csWrite);
	}

    //
    // Fix for bug 498256 -- annah
    // It can happen that a user logs in right when the service is starting, so
    // we would add the session though the TS enumeration code AND
    // then possibly again through the code that receives SCM logon notifications.
    // The fix will be to test if the session is already stored, and skip
    // adding entries that for session ids that are already there.
    //
    if (m_iFindSession(dwSessionId) != CDWNO_SESSION)
    {
        // do nothing -- don't add duplicate entries if the session id 
        // is already there.
        fRet = FALSE;
        goto Done;
    }
	
	if (NULL == m_pSessionStateInfo || m_iLastSession >= m_cAllocBufSessions - 1)
	{
		int cSessions;

		if (m_cAllocBufSessions == 0)
		{
			cSessions = CMIN_SESSIONS;
			m_iCurSession = 0;
		}
		else
		{
			cSessions = m_cAllocBufSessions * 2;
		}
		if (!m_FChangeBufSession(cSessions))
		{
			fRet = FALSE;
			goto Done;
		}
	}
	m_iLastSession++;

	m_pSessionStateInfo[m_iLastSession].dwSessionId = dwSessionId;
	m_pSessionStateInfo[m_iLastSession].SessionState = *pSesState;

Done:
	if (m_fInitCS)
	{
		LeaveCriticalSection(&m_csWrite);
	}
#ifdef DBG
    DEBUGMSG("After AddSession");
    m_DumpSessions();
#endif    
	return fRet;
}

//determine whether or not session dwSessionId is a cached AU session
BOOL SESSION_STATUS::m_FGetSessionState(DWORD dwSessionId, SESSION_STATE **pSesState )
{	
	int iSession = m_iFindSession(dwSessionId);

	BOOL fRet = (CDWNO_SESSION != iSession);
	
	if (fRet && (NULL != pSesState))
	{
		*pSesState = &m_pSessionStateInfo[iSession].SessionState;
	}
	return fRet;
}

BOOL SESSION_STATUS::m_FDeleteSession(DWORD dwSessionId)
{
	BOOL fRet= FALSE;

	if (m_fInitCS)
	{
		EnterCriticalSection(&m_csWrite);
	}
	
	int iSession = m_iFindSession(dwSessionId);
	if (CDWNO_SESSION == iSession)
	{
		goto Done;
	}
	if (iSession != m_iLastSession)
	{
		memmove(m_pSessionStateInfo + iSession, 
			m_pSessionStateInfo + iSession + 1, 
			sizeof(SESSION_STATE_INFO) * (m_iLastSession - iSession));
	}
	if (m_iCurSession > iSession)
	{
		m_iCurSession--;
	}
	//fixcode m_iCurSession should point to the previous session
	if (m_iCurSession == m_iLastSession)
	{
		m_iCurSession = 0;
	}
	m_iLastSession--;
	fRet = TRUE;

Done:
	if (m_fInitCS)
	{
		LeaveCriticalSection(&m_csWrite);
	}
#ifdef DBG
    DEBUGMSG("After DeleteSession");
    m_DumpSessions();
#endif    
	return fRet;
}

BOOL SESSION_STATUS::m_FGetCurrentSession(DWORD *pdwSessionId)
{
	if (0 == CSessions())
	{
		return FALSE;
	}	
	
	*pdwSessionId = m_pSessionStateInfo[m_iCurSession].dwSessionId;	
	
	return TRUE;
}

BOOL SESSION_STATUS::m_FGetNextSession(DWORD *pdwSessionId)
{
	if (0 == CSessions())
	{
		return FALSE;
	}
	m_iCurSession = (m_iCurSession + 1 ) % CSessions();
	*pdwSessionId = m_pSessionStateInfo[m_iCurSession].dwSessionId;		
	return TRUE;
}
int SESSION_STATUS::m_iFindSession(DWORD dwSessionId)
{	

	for (int iSession = 0; iSession < CSessions(); iSession++)
	{		
		if (dwSessionId == m_pSessionStateInfo[iSession].dwSessionId)
		{	
			return iSession;		
		}		
	}
	return CDWNO_SESSION;
}

// this functions lets someone traverse the content of
// the array sequencially.
int SESSION_STATUS::m_iGetSessionIdAtIndex(int iIndex)
{
    if (iIndex < 0 || iIndex >= CSessions())
    {
        // Out of bound!!
        return -1;
    }

    return m_pSessionStateInfo[iIndex].dwSessionId;
}

BOOL SESSION_STATUS::m_FChangeBufSession(int cSessions)
{
	BOOL fRet = FALSE;
	SESSION_STATE_INFO *pSessionStateInfo = (SESSION_STATE_INFO *)realloc(m_pSessionStateInfo, sizeof(SESSION_STATE_INFO) * cSessions);
	if (NULL != pSessionStateInfo)
    {
       	m_pSessionStateInfo = pSessionStateInfo;
    }
    else
	{
		goto Done;
	}
	m_cAllocBufSessions = cSessions;
	fRet = TRUE;
Done:
	return fRet;
}	

// Function for debugging
VOID SESSION_STATUS::m_DumpSessions()
{	
    DEBUGMSG(">>>>>>> DUMPING cached sessions content ");

	for (int iSession = 0; iSession < CSessions(); iSession++)
	{		
		DEBUGMSG(">>> position %d: %lu", iSession, m_pSessionStateInfo[iSession].dwSessionId);
	}

    DEBUGMSG(">>>>>>> END DUMPING cached sessions content ");
}

BOOL fLoggedOnSession(DWORD dwSessionId)
{
	HANDLE hImpersonationToken;
	if (AUGetUserToken(dwSessionId, &hImpersonationToken))
	{
		CloseHandle(hImpersonationToken);
		return TRUE;
	}
	return FALSE;
}


/**
CacheExistingSessions() 
Enumerates existent sessions and persists the admin sessions for future reference
**/
VOID SESSION_STATUS::CacheExistingSessions()
{	
	PWTS_SESSION_INFO pSessionInfo = NULL;	
	DWORD             dwCount = 0;

    // 
    // Check if TS is enabled and try to enumerate existing
    // sessions. If TS is not running, query only session 0.
    //
	if (_IsTerminalServiceRunning())
    {
        if (WTSEnumerateSessions(WTS_CURRENT_SERVER_HANDLE, 0, 1, &pSessionInfo, &dwCount))
        {
            DEBUGMSG("WUAUENG WTSEnumerateSessions dwCount= %lu",dwCount);

            for (DWORD dwSession = 0; dwSession < dwCount; dwSession++)
            {	
                WTS_SESSION_INFO SessionInfo = pSessionInfo[dwSession];

                DEBUGMSG("WUAUENG CacheExistingSessions, enumerating SessionId =%lu, State =%d",SessionInfo.SessionId, SessionInfo.State);

				if (m_fAllLoggedOnUsers)
				{
					if (fLoggedOnSession(SessionInfo.SessionId))
					{
						SESSION_STATE SessionState;
						SessionState.fFoundEnumerating = TRUE;
						m_FAddSession(SessionInfo.SessionId, &SessionState);
					}
				}
				else
				{
        	                if ((WTSActive != SessionInfo.State) && ( WTSConnected != SessionInfo.State) ||
        	                    (m_iFindSession(SessionInfo.SessionId) != CDWNO_SESSION))
        	                {
        	                    //We only care about Active and Connected sessions that existed before 
        	                    //the service was registered, this means that if fAdminSessionLoggedOn is turned on
        	                    //the logon notification was received already and we must no check anything
        	                    continue;
        	                }
        	                if (CacheSessionIfAUEnabledAdmin(SessionInfo.SessionId, TRUE))
        	                {
        	                    DEBUGMSG("WUAUENG Existent Admin Session = %lu",SessionInfo.SessionId);
        	                }
				}
            }		

            WTSFreeMemory(pSessionInfo);
        }
        else
        {
            DWORD dwRet = GetLastError();
            DEBUGMSG("WUAUENG WTSEnumerateSessions failed dwRet = %lu", dwRet);
        }
    }
    else
    {
		if (m_fAllLoggedOnUsers)
		{
			if (fLoggedOnSession(0))
			{
				SESSION_STATE SessionState;
				SessionState.fFoundEnumerating = TRUE;
				m_FAddSession(0, &SessionState);
			}
		}
		else
		{
	        if (CacheSessionIfAUEnabledAdmin(0, TRUE))	//Check Session 0 because Terminal Services are disabled
	        {
	            DEBUGMSG("WUAUENG Existent Admin Session = %d",0);
	        }
		}
    }
#ifdef DBG
    DEBUGMSG("After CacheExistingSessions");
    m_DumpSessions();
#endif    
}

/**
CacheSessionIfAUEnabledAdmin
	Cache session in internal data structure if session has administrator logged on and
	has AU group policy allowing update
	Also store this admin session's origin (logon  notification or via Enumeration)
**/
BOOL SESSION_STATUS::CacheSessionIfAUEnabledAdmin(DWORD dwSessionId, BOOL fFoundEnumerating)
{
	BOOL fRet = TRUE;
	
	if (IsUserAUEnabledAdmin(dwSessionId))
	{
		SESSION_STATE SessionState;		
		SessionState.fFoundEnumerating = fFoundEnumerating;	
		fRet = m_FAddSession(dwSessionId, &SessionState);		
	}
	else
	{
		fRet = FALSE;
	}

       if (fRet)
       {
            DEBUGMSG("WUAUENG an Admin Session %d added", dwSessionId);
       }
	return fRet;	
}

void SESSION_STATUS::ValidateCachedSessions()
{
    DWORD *rgMarkedForDelete = NULL;
    int   cSession           = 0;
    int   cMarkedForDelete   = 0;

    //m_DumpSessions();

    cSession = CSessions();

    rgMarkedForDelete = new DWORD[cSession];
    if (!rgMarkedForDelete)
    {
        goto cleanup;
    }

	if (m_fInitCS)
	{
		EnterCriticalSection(&m_csWrite);
	}
	for (int i = 0; i < cSession; i++)
	{
        DWORD dwAdminSession = m_iGetSessionIdAtIndex(i);
        if (!IsAUValidSession(dwAdminSession))
        {
            // store the sessions id to be deleted and deleted after we exit the loop
            rgMarkedForDelete[cMarkedForDelete] = dwAdminSession;
            cMarkedForDelete++;
        }
    }

    // delete the pending sessions that are now invalid
    for (int i=0; i < cMarkedForDelete; i++)
    {
        DEBUGMSG("WUAUENG Found cached admin session that is not valid anymore. Deleting entry for session %lu", rgMarkedForDelete[i]);
        m_FDeleteSession(rgMarkedForDelete[i]);
    }
	if (m_fInitCS)
	{
		LeaveCriticalSection(&m_csWrite);
	}

    //m_DumpSessions();

cleanup:

    if (rgMarkedForDelete)
    {
        delete [] rgMarkedForDelete;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\wuaueng\auxml.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       auxml.cpp
//
//  About:  source file for AU related XML and schema data structure and functions
//--------------------------------------------------------------------------
#include "pch.h"

//when changed, search for all occurrance of m_pFieldNames for needed modifications
//fixcode: get rid of EULA stuff.
LPSTR  AUCatalogItem::m_pFieldNames[] = {"ItemID", "ProviderName", "Title", "Description", "RTFPath" , "EulaPath"};

#ifdef DBG
void DBGShowNodeName(IXMLDOMNode *pNode)
{
    BSTR bsNodeName;
    if (SUCCEEDED(pNode->get_nodeName(&bsNodeName)))
        {
        DEBUGMSG("node name is %S", bsNodeName);
        }
    else
        {
        DEBUGMSG("FAIL to get node name");
        }
}

void DBGDumpXMLNode(IXMLDOMNode *pNode)
{
    BSTR bsNodeName = NULL;
    BSTR bsNodeXML = NULL;
    if (SUCCEEDED(pNode->get_nodeName(&bsNodeName)) &&
		(SUCCEEDED(pNode->get_xml(&bsNodeXML))))
    {
	    DEBUGMSG("XML for %S is %S", bsNodeName, bsNodeXML);
    }
    SafeFreeBSTR(bsNodeName);
    SafeFreeBSTR(bsNodeXML);
}
#endif

#if 0
void DBGDumpXMLDocProperties(IXMLDOMDocument2 *pDoc)
{
    BSTR bsSelectionLanguage, bsSelectionNamespaces, bsServerHTTPRequest;
    VARIANT vVal;
    VariantInit(&vVal);
    pDoc->getProperty(L"SelectionLanguage", &vVal);
    DEBUGMSG("XMLDoc selection language is %S", vVal.bstrVal);
    VariantClear(&vVal);
    pDoc->getProperty(L"SelectionNamespaces", &vVal);
    DEBUGMSG("XMLDoc selection namespaces is %S", vVal.bstrVal);
    VariantClear(&vVal);
    pDoc->getProperty(L"ServerHTTPRequest", &vVal);
    DEBUGMSG("XMLDoc ServerHTTPRequest is %s", vVal.boolVal ? "True" : "False");
    VariantClear(&vVal);
}
#endif


BSTR ReadXMLFromFile(IN LPCTSTR szFileName)
{
    TCHAR tszFullFileName[MAX_PATH];
    IXMLDOMDocument *pxml = NULL;
    BSTR bstrXml  = NULL;
//    USES_CONVERSION;
//    DEBUGMSG("ReadXMLFromFile() starts");
    AUASSERT(_T('\0') != g_szWUDir[0]);
    if(FAILED(StringCchCopyEx(tszFullFileName, ARRAYSIZE(tszFullFileName), g_szWUDir, NULL, NULL, MISTSAFE_STRING_FLAGS)) ||
       FAILED(StringCchCatEx(tszFullFileName, ARRAYSIZE(tszFullFileName), szFileName, NULL, NULL, MISTSAFE_STRING_FLAGS)))
    {
        DEBUGMSG("file name or path too long");
        goto done;
    }

    if (!fFileExists(tszFullFileName))
    {
        DEBUGMSG("%S doesn't exists on disk", tszFullFileName);
    }
    else
    {
        CAU_BSTR aubsFullFileName;
        HRESULT hr;
        if (!aubsFullFileName.append(T2W(tszFullFileName)))
            {
            DEBUGMSG("Out of memory, fail to create string");
            goto done;
            }
        if (FAILED(hr = LoadDocument(aubsFullFileName, &pxml, TRUE))) //offline
            {
            DEBUGMSG("Fail to load xml document %S with error %#lx", tszFullFileName, hr);
            goto done;
            }
        if (FAILED(hr = pxml->get_xml(&bstrXml)))
        {
        	DEBUGMSG("Fail to get xml string from document with error %#lx", hr);
        	goto done;
        }
    }
done:
    SafeRelease(pxml);
   // DEBUGMSG("ReadXMLFromFile() ends");
    return bstrXml;
}


HRESULT MungleIdentity(IN IXMLDOMNode *pIdentity, IN DWORD dwSuffix)
{
	BSTR bstrItemName = NULL;
	CAU_BSTR aubsTmp;
	WCHAR wcsBuf[12]; //will accomodate the maxium dword
	HRESULT hr = S_OK;

	if (0 == dwSuffix)
	{
		goto done;
	}
	if (NULL == pIdentity) 
	{
		hr = E_INVALIDARG;
		goto done;
	}
	if (FAILED(hr = GetAttribute(pIdentity, KEY_NAME, &bstrItemName)))
	{		DEBUGMSG("Fail to get name from identity with error %#lx", hr);
		goto done;
	}

	if (FAILED(StringCchPrintfExW(wcsBuf, ARRAYSIZE(wcsBuf), NULL, NULL, MISTSAFE_STRING_FLAGS, L"%lu", dwSuffix)) ||
		!aubsTmp.append(bstrItemName) ||
		!aubsTmp.append(L"_") ||
		!aubsTmp.append(wcsBuf))
	{
		DEBUGMSG("OUT OF MEMORY");
		hr = E_OUTOFMEMORY;
		goto done;
	}

	if (FAILED(hr = SetAttribute(pIdentity, KEY_NAME, aubsTmp)))
	{
		DEBUGMSG("Fail to set attribute with error %#lx", hr);
		goto done;
	}

done:
	SafeFreeBSTR(bstrItemName);
	return hr;
}

            
BSTR GetPattern(IN LPCSTR szFieldName)
{
       if (0 == _stricmp(szFieldName, AUCatalogItem::m_pFieldNames[0]))
       	{
       	return AUCatalog::bstrItemIDPattern;
       	}
       else
   	 if (0 == _stricmp(szFieldName, AUCatalogItem::m_pFieldNames[1]))
   	{
   	return AUCatalog::bstrProviderNamePattern;
   	}
       else
       if (0 == _stricmp(szFieldName, AUCatalogItem::m_pFieldNames[2]))
       	{
       	return AUCatalog::bstrTitlePattern;
       	}
       else
       if (0 == _stricmp(szFieldName, AUCatalogItem::m_pFieldNames[3]))
       	{
       	return AUCatalog::bstrDescPattern;
       	}
       else
       if (0 == _stricmp(szFieldName, AUCatalogItem::m_pFieldNames[4]))
       	{
       	return AUCatalog::bstrRTFUrlPattern;
       	}
       else
       if (0 == _stricmp(szFieldName, AUCatalogItem::m_pFieldNames[5]))
       	{
       	return AUCatalog::bstrEulaUrlPattern;
       	}
       else
       	{
       	return NULL;
       	}
}

BOOL IsPersistedHiddenItem(IN BSTR bstrItemID, IN AUCatalogItemList & hiddenItemList)
{
    BOOL fRet = (hiddenItemList.Contains(bstrItemID) >=0);
    DEBUGMSG("%S is %s hidden item ", bstrItemID,  fRet? "" : "NOT");
    return fRet;
}


BOOL CItemDetails::Init(IN BSTR bsItemDetails)
{
    BOOL fRet = TRUE;
    if (FAILED(CoCreateInstance(__uuidof(DOMDocument), NULL, CLSCTX_INPROC_SERVER, __uuidof( IXMLDOMDocument), (void**)&m_pxml)))
	{
		DEBUGMSG("CItemDetails::Init() fail to create XML document");
		fRet = FALSE;
		goto end;
	}
    if (FAILED(m_pxml->put_async(VARIANT_FALSE)) 
    	||FAILED(m_pxml->put_resolveExternals(VARIANT_FALSE))
    	|| FAILED(m_pxml->put_validateOnParse(VARIANT_FALSE)))
    {
    	fRet = FALSE;
    	goto end;
    }
	VARIANT_BOOL fOk;
	if (S_OK != m_pxml->loadXML(bsItemDetails, &fOk))
        {
          DEBUGMSG("CItemDetails::Init() fail to load XML");
          fRet = FALSE;
        }
    end:
        if (!fRet)
            {
            SafeReleaseNULL(m_pxml);
            }
        return fRet;
}

//should be callable event without Init() called first
void CItemDetails::Uninit()
{
    SafeRelease(m_pxml);
}	

HRESULT CItemDetails::GetItemIdentities(IN BSTR bstrItemId, OUT IXMLDOMNodeList ** ppIdentityNodeList)
{
    CAU_BSTR aubsPattern;
    HRESULT hr = S_OK ;

//    DEBUGMSG("CItemDetails::getIdentityNode() starts");
	*ppIdentityNodeList = NULL;
    if (!aubsPattern.append(L"/catalog/provider/item/identity[@itemID=\"") || !aubsPattern.append(bstrItemId) || !aubsPattern.append(L"\"]"))
        {
        DEBUGMSG("failed to create pattern string");
        hr = E_OUTOFMEMORY;
        goto done;
        }
    if (FAILED(hr = m_pxml->selectNodes(aubsPattern, ppIdentityNodeList))) 
        {
        DEBUGMSG(" failed to find identityNode %#lx", hr);
        goto done;
        }   

done:
//    DEBUGMSG("CItemDetails::getIdentityNode() done");
    return hr;
}	

////////////////////////////////////////////////////////////////////////////
// delete all items with ITEMID=bstrItemId
///////////////////////////////////////////////////////////////////////////
HRESULT CItemDetails::DeleteItem(IN BSTR bstrItemId)
{
    HRESULT hr = E_FAIL;
  IXMLDOMNode *pItemNode = NULL;
  IXMLDOMNode *pProviderNode = NULL;
  IXMLDOMNode *pCatalogNode = NULL;

  while (NULL != ( pItemNode = getItemNode(bstrItemId)))
  {
	  if (FAILED(hr = pItemNode->get_parentNode(&pProviderNode)) || NULL == pProviderNode)
	        {
	        DEBUGMSG(" fail to get provider node %#lx", hr);
	        goto done;
	        }        
	  if (FAILED(hr = pProviderNode->removeChild(pItemNode, NULL)))
	    {
	        DEBUGMSG(" fail to remove item node with error %#lx", hr);
	        goto done;
	    }
	//  DEBUGMSG("one item removed");
	  pItemNode ->Release();
	  pItemNode = NULL;
	  if (S_FALSE == (hr =pProviderNode->selectSingleNode(KEY_ITEM, &pItemNode)))
	    {
	        //provider had no children
	      if (FAILED(hr = pProviderNode->get_parentNode(&pCatalogNode)) || NULL == pCatalogNode)
	        {
	        DEBUGMSG(" fail to get catalog node %#lx", hr);
	        goto done;
	        }        
	      if (FAILED(hr = pCatalogNode->removeChild(pProviderNode, NULL)))
	        {
	            DEBUGMSG(" fail to remove provider node with error %#lx", hr);
	            goto done;
	        }
	    //  DEBUGMSG("one provider removed");
	    }
	SafeReleaseNULL(pItemNode);
	SafeReleaseNULL(pProviderNode);
	SafeReleaseNULL(pCatalogNode);
  }
      
  done:
    SafeRelease(pItemNode);
    SafeRelease(pProviderNode);
    SafeRelease(pCatalogNode);
    return hr;
}

HRESULT CItemDetails::GetXML(BSTR *pbstrxml)
{
    return m_pxml->get_xml(pbstrxml);
}

IXMLDOMNode * CItemDetails::getIdentityNode(IN BSTR bstrItemId)
{
    IXMLDOMNode * pIdentityNode = NULL ;
    CAU_BSTR aubsPattern;
    HRESULT hr ;

//    DEBUGMSG("CItemDetails::getIdentityNode() starts");
    if (!aubsPattern.append(L"/catalog/provider/item/identity[@itemID=\"") || !aubsPattern.append(bstrItemId) || !aubsPattern.append(L"\"]"))
        {
        DEBUGMSG("failed to create pattern string");
        goto done;
        }
    if (FAILED(hr = m_pxml->selectSingleNode(aubsPattern, &pIdentityNode))) 
        {
        DEBUGMSG(" failed to find identityNode %#lx", hr);
        goto done;
        }   
    if (NULL == pIdentityNode)
    {
    	goto done;
    }
done:
//    DEBUGMSG("CItemDetails::getIdentityNode() done");
    return pIdentityNode;
}

/////////////////////////////////////////////////////////
// caller should make sure item bstrItemId exists in itemdetails
////////////////////////////////////////////////////////
BOOL CItemDetails::IsVisible(IN BSTR bstrItemId)
{
    IXMLDOMNode * pItemNode = getItemNode(bstrItemId);
    IXMLDOMNode *pDescriptionNode = NULL;
    LONG  lRet = 0;
    HRESULT hr ;
//    DEBUGMSG("IsVisible() starts");
	//fixcode: really should return error instead of bogus TRUE
    if (NULL == pItemNode ) 
    {
        DEBUGMSG("fail to find node or fail to create string");
       goto done;
    }
   if (FAILED(hr = pItemNode->selectSingleNode(KEY_DESCRIPTION, &pDescriptionNode)) || NULL == pDescriptionNode)
    {
        DEBUGMSG("Fail to select node %S with error %#lx", KEY_DESCRIPTION, hr);
        goto done;
    }
   if (FAILED(hr = GetAttribute(pDescriptionNode, KEY_HIDDEN, &lRet)))
    {
        DEBUGMSG("Fail to get attribute %S with error %#lx", KEY_HIDDEN, hr);
        goto done;
    }
//   DEBUGMSG("Hidden attribute is %d for item %S", lRet, bstrItemId);
done:
   SafeRelease(pDescriptionNode);
   SafeRelease(pItemNode);
//   DEBUGMSG("IsVisible() return %s for %S", (0 == lRet) ? "true" : "false", bstrItemId);
   return 0 == lRet;
}
    
        
    

IXMLDOMNode * CItemDetails::getItemNode(IN BSTR bsItemId)
{
    IXMLDOMNode * pIdentityNode = getIdentityNode(bsItemId);
    IXMLDOMNode * pItemNode = NULL;
    HRESULT hr;

   //DEBUGMSG("CItemDetails::getItemNode() starts");
    if (NULL == pIdentityNode)
        {
        goto done;
        }
  if (FAILED(hr = pIdentityNode->get_parentNode(&pItemNode)) || NULL == pItemNode)
        {
        DEBUGMSG(" fail to get item node %#lx", hr);
        goto done;
        }
done:
    SafeRelease(pIdentityNode);
    //DEBUGMSG("CItemDetails::getItemNode() ends");
    return pItemNode;
}	


HRESULT CItemDetails::CloneIdentityNode(IN BSTR bsItemId, IN IXMLDOMDocument *pDesXml, OUT IXMLDOMNode ** ppDesNode)
{
    IXMLDOMNode * pIdentityNode ;
    HRESULT hr = E_FAIL;

   // DEBUGMSG("CItemDetails::CloneIdentityNode() starts");
   *ppDesNode = NULL;
    if (NULL == (pIdentityNode = getIdentityNode(bsItemId)))
        {
        goto done;
        }
    	
    if (FAILED(hr = CopyNode(pIdentityNode, pDesXml, ppDesNode)))
        {
        DEBUGMSG("CItemDetails::CloneIdentityNode() failed to clone identityNode %#lx", hr);
        }
done:
    SafeRelease(pIdentityNode);
   // DEBUGMSG("CItemDetails::CloneIdentityNode() ends");
    return hr;
}

HRESULT CItemDetails::CloneDescriptionNode(IN BSTR bsItemId, IN IXMLDOMDocument *pDesXml, OUT IXMLDOMNode **ppDesNode)
{
    IXMLDOMNode * pItemNode = getItemNode(bsItemId);
    IXMLDOMNode * pDescriptionNode = NULL;
    HRESULT hr = E_FAIL;

    *ppDesNode = NULL;
    if (NULL == pItemNode)
        {
        goto done;
        }
   if (!FindNode(pItemNode, KEY_DESCRIPTION, &pDescriptionNode))
    {
        DEBUGMSG("CItemDetails::CloneDescriptionNode() fail to get description node");
        goto done;
    }
     if (FAILED(hr = CopyNode(pDescriptionNode, pDesXml, ppDesNode)))
    {
        DEBUGMSG("CItemDetails::CloneDescriptionNode() fail to clone node %#lx", hr);
    }
done:
    SafeRelease(pItemNode);
    SafeRelease(pDescriptionNode);
    return hr;
}


HRESULT CItemDetails::ClonePlatformNode(IN BSTR bsItemId,  IN IXMLDOMDocument *pDesXml, OUT IXMLDOMNode **ppDesNode)
{
    IXMLDOMNode * pItemNode = getItemNode(bsItemId);
    IXMLDOMNode * pPlatformNode = NULL;
    HRESULT hr  = E_FAIL;

    *ppDesNode = NULL;
    if (NULL == pItemNode)
        {
        goto done;
        }
   if (!FindNode(pItemNode, KEY_PLATFORM, &pPlatformNode))
    {
        DEBUGMSG("CItemDetails::ClonePlatformNode() fail to get platform node");
        goto done;
    }
    if (FAILED(hr = CopyNode(pPlatformNode, pDesXml, ppDesNode)))
    {
        DEBUGMSG("CItemDetails::ClonePlatformNode() fail to clone node %#lx", hr);
    }
done:
    SafeRelease(pItemNode);
    SafeRelease(pPlatformNode);
    return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////
// retrieve cab names associated with an item identified by bsitemid
// called should free ppCabNames allocated in the function
// *pCabsNum contains number of cab names returned
////////////////////////////////////////////////////////////////////////////////////////
HRESULT CItemDetails::GetCabNames(IN BSTR bsItemId, OUT  BSTR ** ppCRCCabNames,  OUT BSTR **ppRealCabNames, OUT BSTR **ppCabChecksums, OUT UINT *pCabsNum)
{
    IXMLDOMNode * pItemNode = getItemNode(bsItemId);
    IXMLDOMNodeList *pCodeBaseNodes = NULL;
    BSTR * pCRCCabNames = NULL;
    BSTR * pRealCabNames = NULL;
    BSTR * pCabChecksums = NULL;
    UINT uCabsNum = 0;
    CAU_BSTR aubsCodeBase;
    HRESULT hr = E_FAIL;

    //DEBUGMSG("CItemDetails::GetCabNames() starts");
    *ppRealCabNames = *ppCRCCabNames = *ppCabChecksums = NULL;
    *pCabsNum = 0;
    if (!aubsCodeBase.append(L"installation/codeBase"))
        {
        DEBUGMSG("fail to create aubs");
        goto done;
        }
    if (NULL == pItemNode)
        {
        goto done;
        }
    if (FAILED(hr = pItemNode->selectNodes(aubsCodeBase, &pCodeBaseNodes)) || NULL == pCodeBaseNodes)
        {
        DEBUGMSG("Fail to find codebase section");
        goto done;
        }
    if (FAILED(hr = pCodeBaseNodes->get_length((long *) &uCabsNum)))
    {
    	DEBUGMSG("Fail to get number of code base nodes with error %#lx", hr);
    	goto done;
    }
    pCRCCabNames  = (BSTR*) malloc(uCabsNum * sizeof(*pCRCCabNames));
    pRealCabNames = (BSTR*) malloc(uCabsNum * sizeof(*pRealCabNames));
    pCabChecksums = (BSTR*) malloc(uCabsNum * sizeof(*pCabChecksums));
    if (NULL != pCRCCabNames)
    {
	   	ZeroMemory((PVOID)pCRCCabNames, uCabsNum * sizeof(*pCRCCabNames));
    }
    if (NULL != pRealCabNames)
    {
	   	ZeroMemory((PVOID)pRealCabNames, uCabsNum * sizeof(*pRealCabNames));
    }
    if (NULL != pCabChecksums)
    {
	   	ZeroMemory((PVOID)pCabChecksums, uCabsNum * sizeof(*pCabChecksums));
    }
    if (NULL == pCRCCabNames || NULL == pRealCabNames || NULL == pCabChecksums)
    {
        DEBUGMSG("Fail to alloc memory for CRCCabsNames or RealCabNames");
        hr = E_OUTOFMEMORY;
        goto done;
    }
    for (UINT i = 0; i < uCabsNum ; i++)
    {
        IXMLDOMNode *pCodeBaseNode;
        if (S_OK != (hr = pCodeBaseNodes->get_item(i, &pCodeBaseNode)))
        {
            DEBUGMSG("Fail to get codebase %d", i);
            hr = FAILED(hr) ? hr : E_FAIL;
            goto done;
        }
        if (FAILED(hr = GetAttribute(pCodeBaseNode, KEY_HREF, &(pCRCCabNames[i]))))
        {
            DEBUGMSG("Fail to get attribute %S", KEY_HREF);
            pCodeBaseNode->Release();
            goto done;
        }
        if (FAILED(hr = GetAttribute(pCodeBaseNode, KEY_NAME, &(pRealCabNames[i]))))
        {
            DEBUGMSG("Fail to get attribute %S", KEY_NAME);
            pCodeBaseNode->Release();
            goto done;
        }        
        //Since CRC is optional, it might not exist for this cab
        GetAttribute(pCodeBaseNode, KEY_CRC, &(pCabChecksums[i]));
  
        pCodeBaseNode->Release();
    }

    *ppCRCCabNames = pCRCCabNames;
    *ppRealCabNames = pRealCabNames;
    *ppCabChecksums = pCabChecksums;
    *pCabsNum = uCabsNum;

done:
    SafeRelease(pCodeBaseNodes);
    SafeRelease(pItemNode);
    if (FAILED(hr))
    {
        if (NULL != pCRCCabNames)
        {
            for (UINT j = 0; j < uCabsNum; j++)
            {
                SafeFreeBSTR(pCRCCabNames[j]);
            }
            free(pCRCCabNames);
        }
        if (NULL != pRealCabNames)
        {
            for (UINT j = 0; j < uCabsNum; j++)
            {
                SafeFreeBSTR(pRealCabNames[j]);
            }
            free(pRealCabNames);
        }
        if (NULL != pCabChecksums)
        {
            for (UINT j = 0; j < uCabsNum; j++)
            {
                SafeFreeBSTR(pCabChecksums[j]);
            }
            free(pCabChecksums);
        }
    }
    //DEBUGMSG("CItemDetails::GetCabNames() ends");
    return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////
// retrieve the CRC for the rtf file for the specified item
// caller should free pRTFCRC allocated in the function
////////////////////////////////////////////////////////////////////////////////////////
HRESULT CItemDetails::GetRTFCRC(BSTR bstrItemId, BSTR *pRTFCRC)
{
    IXMLDOMNode * pItemNode   = getItemNode(bstrItemId);
    IXMLDOMNode *pDetailsNode = NULL;
    CAU_BSTR aubsDetails;
    HRESULT hr = E_FAIL;

    AUASSERT(NULL != pRTFCRC);
    *pRTFCRC = NULL;

    if( NULL == pItemNode ||
        !aubsDetails.append(L"description/descriptionText/details"))       
    {
        goto done;
    }
    if (FAILED(hr = pItemNode->selectSingleNode(aubsDetails, &pDetailsNode)) ||
        NULL == pDetailsNode)
    {
        DEBUGMSG("Fail to find details section");
        goto done;
    }
    if (FAILED(hr = GetAttribute(pDetailsNode, KEY_CRC, pRTFCRC)) ||
        hr == S_FALSE)      //GetAttribute returns S_FALSE if the attribute does not exist for the node
    {
        DEBUGMSG("Fail to get attribute RTF crc, hr is %x", hr);
        hr = (hr == S_FALSE) ? E_FAIL : hr;
    }

done:    
    if(FAILED(hr))
    {
        SafeFreeBSTRNULL(*pRTFCRC);
    }
    SafeRelease(pItemNode);
    SafeRelease(pDetailsNode);
    return hr;    
}

BSTR CItemDetails::GetItemDownloadPath(IN BSTR bstrItemId)
{
//    USES_CONVERSION; only needed for ansi version
    BSTR bstrRet = NULL;
    IXMLDOMNode * pIdentityNode= NULL;

//    DEBUGMSG("CItemDetails::GetItemDownloadPath starts");

    if (NULL == (pIdentityNode = getIdentityNode(bstrItemId)))
        {
            goto done;
        }
    BSTR bstrdownloadPath;
   if (FAILED(UtilGetUniqIdentityStr(pIdentityNode, &bstrdownloadPath, 0)))
    {
        DEBUGMSG("GetItemDownloadPath() fail to get unique identity string");
        goto done;
    }
    TCHAR tszPath[MAX_PATH];
    if (SUCCEEDED(GetCabsDownloadPath(tszPath, ARRAYSIZE(tszPath))) &&
		SUCCEEDED(StringCchCatEx(tszPath, ARRAYSIZE(tszPath), _T("\\"), NULL, NULL, MISTSAFE_STRING_FLAGS)) &&
		SUCCEEDED(StringCchCatEx(tszPath, ARRAYSIZE(tszPath), W2T(bstrdownloadPath), NULL, NULL, MISTSAFE_STRING_FLAGS)))
	{
		bstrRet = SysAllocString(T2W(tszPath));
	}
    SysFreeString(bstrdownloadPath);
done:
    SafeRelease(pIdentityNode);
   /// DEBUGMSG("CItemDetails::GetItemDownloadPath() got %S", bstrRet);
    if (NULL != bstrRet && !EnsureDirExists(W2T(bstrRet)))
        {
        DEBUGMSG("CItemDetails::GetItemDownloadPath() fail to create directory %S", bstrRet);
        SysFreeString(bstrRet);
        bstrRet = NULL;
        }
    return bstrRet;
}

HRESULT CItemDetails::GetItemIds(OUT long *plItemNum, OUT BSTR ** ppbstrItemIds)
{
     IXMLDOMNodeList *pItemIdsNodeList = NULL;
     HRESULT hr = E_FAIL;

//     DEBUGMSG("CItemDetails::GetItemIds() starts");
       *ppbstrItemIds = NULL;
       *plItemNum = 0;
 	
	if (FAILED(hr = m_pxml->selectNodes(AUCatalog::bstrItemIdsPattern, &pItemIdsNodeList)))
	{
		DEBUGMSG(" fail to find item id with error %#lx", hr);
		goto done;
	}

	if (FAILED(hr = pItemIdsNodeList->get_length(plItemNum)))
	{
		DEBUGMSG("Fail to get itemids number with error %#lx", hr);
		goto done;
	}
	*ppbstrItemIds = (BSTR *) malloc((*plItemNum) * sizeof(**ppbstrItemIds));
	if (NULL == *ppbstrItemIds)
	    {
	    DEBUGMSG("Fail to allocate memory for item ids");
	    hr = E_OUTOFMEMORY;
	    goto done;
	    }
	ZeroMemory(*ppbstrItemIds, (*plItemNum) * sizeof(**ppbstrItemIds));
	for (int i = 0; i < *plItemNum; i++)
	    {
	        IXMLDOMNode *pItemIdNode = NULL;
	        if (FAILED(hr = pItemIdsNodeList->get_item(i, &pItemIdNode)) || NULL == pItemIdNode)
	            {
	                DEBUGMSG("Fail to get item id node with error %#lx", hr);
	                hr = FAILED(hr) ? hr : E_FAIL;
	                goto done;
	            }
	        if (FAILED(hr = pItemIdNode->get_text(&((*ppbstrItemIds)[i]))) || NULL == (*ppbstrItemIds)[i])
	            {
	                DEBUGMSG("Fail to get item id no. %d with error %#lx", i+1, hr);
	                pItemIdNode->Release();
	                hr = FAILED(hr) ? hr : E_FAIL;
	                goto done;
	            }
               pItemIdNode->Release();
//	        DEBUGMSG(" got #%d item id %S", i+1, (*ppbstrItemIds)[i]);
	    }
	        
done:
    SafeRelease(pItemIdsNodeList);
    if (FAILED(hr))
        {
          if (NULL != *ppbstrItemIds)
        	{
 
	          for (int j = 0; j < *plItemNum; j++)
	            {
	                SafeFreeBSTR((*ppbstrItemIds)[j]);
	            }
	            SafeFree(*ppbstrItemIds);
	        }
          *plItemNum = 0;         
          *ppbstrItemIds = NULL;
        }
    else
        {
        DEBUGMSG(" got %d item ids", *plItemNum);
        }
//    DEBUGMSG("CItemDetails::GetItemIds() ends");
   return hr;
}
    	    
HRESULT CItemDetails::GetItemInfo(IN LPCSTR szFieldName, IN const BSTR bstrItemId, OUT BSTR * pbstrItemInfo)
{
   HRESULT hr = E_FAIL;
   IXMLDOMNode * pItemNode = getItemNode(bstrItemId);
   IXMLDOMNode * pProviderNode = NULL;
   IXMLDOMNode * pParentNode;
   IXMLDOMNode  *pItemInfoNode = NULL;

//    DEBUGMSG("GetItemInfo() for %s starts", szFieldName);

   *pbstrItemInfo = NULL;
   if (NULL == pItemNode)
    {
    DEBUGMSG("Fail to get item node for %S", bstrItemId);
    goto done;
    }
   //special case provider name
   if (0 == _strcmpi(szFieldName, AUCatalogItem::m_pFieldNames[1]))
    {
        if (FAILED(hr = pItemNode->get_parentNode(&pProviderNode)) || NULL == pProviderNode)
            {
                DEBUGMSG("Fail to get provider node");
                hr = E_FAIL;
                goto done;
            }
        pParentNode = pProviderNode;
    }
   else
    {
       pParentNode = pItemNode;
    }
   if (FAILED(hr = FindSingleDOMNode(pParentNode, GetPattern(szFieldName), &pItemInfoNode)))
    {
    DEBUGMSG("Fail to get field %s for item %S", szFieldName, bstrItemId);
    goto done;
    }
   if (FAILED(hr = pItemInfoNode->get_text(pbstrItemInfo))) //NULL content is fine
    { 
    DEBUGMSG("Fail to get value from title node with error %#lx", hr);
    goto done;
    }

//   DEBUGMSG(" item info %s is %S", szFieldName, *pbstrItemInfo);

done:
    SafeRelease(pItemNode);
    SafeRelease(pItemInfoNode);
    SafeRelease(pProviderNode);
    if (FAILED(hr))
    {
    	SafeFreeBSTRNULL(*pbstrItemInfo);
    }
//    DEBUGMSG("GetItemInfo() for %s ends", szFieldName);    
    return hr;
}

//////////////////////////////////////////////////////////////////////////////////
//find first exclusive item that is NOT hidden and visible
//return S_OK if found one
//return S_FALSE if found none
//return E_FAIL if error occurs
HRESULT CItemDetails::FindFirstExclusiveItem(OUT BSTR *pbstrItemId, IN  AUCatalogItemList & hiddenItemList)
{
    IXMLDOMNodeList *pExclusiveItemNodes = NULL;
    HRESULT hr = E_FAIL;
    BOOL fFound = FALSE;

    DEBUGMSG("CItemDetails::FindFirstExclusiveItem() starts");
    *pbstrItemId = NULL;
    pExclusiveItemNodes = FindDOMNodeList(m_pxml, AUCatalog::bstrExclusiveItemPattern);
    if (NULL  == pExclusiveItemNodes)
        {   
            DEBUGMSG("No exclusive item found");
            hr = S_FALSE;
            goto done;
        }
    long lNum;
    if (FAILED(hr = pExclusiveItemNodes->get_length(&lNum)))
    {
    	DEBUGMSG("Fail to get exclusive item nodes number with error %#lx", hr);
    	goto done;
    }
    for (long l = 0; l < lNum; l++)
        {
            IXMLDOMNode *pExclusiveItemNode = NULL;
            if (S_OK != (hr = pExclusiveItemNodes->get_item(l, &pExclusiveItemNode)))
                {
                    DEBUGMSG("Fail to get item with error %#lx", hr);
                    hr = FAILED(hr) ? hr : E_FAIL;
                    goto done;
                }
            if (!FindNodeValue(pExclusiveItemNode, GetPattern(AUCatalogItem::m_pFieldNames[0]), pbstrItemId))
            {
                hr = E_FAIL;
            }
            pExclusiveItemNode->Release();
            if (FAILED(hr))
                {
                    DEBUGMSG("Fail to get item id text with error %#lx", hr);
                    goto done;
                }
            if (!IsPersistedHiddenItem(*pbstrItemId, hiddenItemList) && IsVisible(*pbstrItemId))
                {
                    fFound = TRUE;
                    break;
                }
            SysFreeString(*pbstrItemId);
            *pbstrItemId = NULL;
        }

    if (fFound)
        {
            DEBUGMSG("Find first exclusive item %S", *pbstrItemId);
            hr = S_OK;
        }
    else
        {
            DEBUGMSG("No unhidden and visible exclusive item found");
            hr = S_FALSE;
        }

done:
    SafeRelease(pExclusiveItemNodes);
    if (S_OK != hr)
    {
    	SafeFreeBSTRNULL(*pbstrItemId);
    }
    DEBUGMSG("CItemDetails::FindFirstExclusiveItem() ends");
    return hr;
}

//////////////////////////////////////////////////////////////////////////////
// populate m_DependentItems of each item in the lsit with direct dependency
// Also check the self containment of depending items with in the list, i.e. all the depending items should
// also be in the list. If not, the dependency will not be recorded.
// return S_OK : if item found and dependency built if any
//          E_XXXX: if error
//////////////////////////////////////////////////////////////////////////////
HRESULT CItemDetails::BuildDirectDependency(IN OUT AUCatalogItemList  &itemlist)
{
    HRESULT hr = S_OK;
    CAU_BSTR aubsDependentItemID;

//    DEBUGMSG("CItemDetails::BuildDirectDependency starts");
    if (!aubsDependentItemID.append(L"dependencies/identity/@itemID"))
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    for (UINT i = 0; i < itemlist.Count(); i++)
        {
        IXMLDOMNodeList *pItemIDNodes = NULL;
        IXMLDOMNode *pItemNode = NULL; 
 
        if (NULL == (pItemNode = getItemNode(itemlist[i].bstrID())))
            {
//                DEBUGMSG("Warning: item %S not found in the list", itemlist[i].bstrID()); //legitimate error
                continue;
            }
        if (NULL == (pItemIDNodes  = FindDOMNodeList(pItemNode, aubsDependentItemID)))
            {
//                DEBUGMSG ("No dependency found for item %S", itemlist[i].bstrID());
                pItemNode->Release();
                continue;
            }
        long lNumOfDependency;
        if (FAILED(hr = pItemIDNodes->get_length(&lNumOfDependency)))
        {
        	DEBUGMSG("Fail to get item id node number with error %#lx", hr);
        	pItemNode->Release();
        	pItemIDNodes->Release();
        	continue;
        }
        for (long l = 0; l < lNumOfDependency; l++)
            {
                IXMLDOMNode * pItemIDNode  = NULL;
                if (S_OK == pItemIDNodes->get_item(l, &pItemIDNode))
                    {
                        BSTR bstrItemId = NULL;
                        if (FAILED(hr = pItemIDNode->get_text(&bstrItemId)) || NULL == bstrItemId)
                        {
                        	DEBUGMSG("Fail to get text for item id with error %#lx", hr);
                        	hr = FAILED(hr) ? hr : E_FAIL;
                        	pItemIDNode->Release();
                        	break;
                        }
                        pItemIDNode->Release(); 
                        AUCatalogItem *pdependingItem  = new AUCatalogItem;
                        if (NULL == pdependingItem)
                            {
                            DEBUGMSG("Out of Memory. Fail to create new item");
                            hr = E_OUTOFMEMORY;
                            SafeFreeBSTR(bstrItemId);
                            break;
                            }
                        if (NULL == bstrItemId)
                            {//although schema does not require itemid, we do
                              DEBUGMSG("Fail to find item id");
                              hr = E_FAIL;
                              delete pdependingItem;
                              break;
                            }
                        INT index = itemlist.Contains(bstrItemId);
                        if (index >= 0)
                            {
                            	BSTR bstrTmp = SysAllocString(itemlist[i].bstrID());
                            	if (NULL == bstrTmp)
                            	{
                            		DEBUGMSG("Fail to allocate memory");
                            		SysFreeString(bstrItemId);
                            		delete pdependingItem;
                            		hr = E_OUTOFMEMORY;
                            		break;
                            	}
	                            pdependingItem->SetField(AUCatalogItem::m_pFieldNames[0], bstrTmp);
	                            if (!itemlist[index].m_DependingItems.Add(pdependingItem))
	                            {
	                            	DEBUGMSG("fail to add depending item");
	                            	SysFreeString(bstrItemId);
	                            	delete pdependingItem;
	                            	hr = E_OUTOFMEMORY;
	                            	break;
	                            }
	                            else
	                            {
		                            DEBUGMSG("item %S depending on item %S. Dependency recorded", pdependingItem->bstrID(), itemlist[index].bstrID());
	                            }
                            }
                        else
                            {
                            DEBUGMSG("Warning: item %S depends on an item not in the list", itemlist[i].bstrID());
                            delete pdependingItem;
                            }
                        SysFreeString(bstrItemId);
                    }
                else
                    {
                        DEBUGMSG("Error: fail to get item id node");
                        hr = E_FAIL;
                        break;
                    }
            }
       pItemNode->Release();
       pItemIDNodes->Release();
    }
done:
//    DEBUGMSG("CItemDetails::BuildDirectDependency ends");
	if (FAILED(hr))
	{
		for (UINT i = 0; i < itemlist.Count(); i++)
		{
			itemlist[i].m_DependingItems.Clear();
		}
	}
    return hr;
}

////////////////////////////////////////////////////////////////////////////
// format of hidde.xml is
// <hiddenitems version = #> 
//      <item id = "...........">
//      ..............
//      <item id = "...........">
// </hiddenitems>
// return S_FALSE when no hidden items left in the xml file. The file will be deleted
///////////////////////////////////////////////////////////////////////////
// TO be finished
HRESULT PersistHiddenItems(IN AUCatalogItemList &itemlist, IN URLLOGACTIVITY activity)
{
//    USES_CONVERSION;
    IXMLDOMDocument *pHiddenXml = NULL;
    IXMLDOMNode *pHiddenItemsNode = NULL;
    IXMLDOMElement *pelemITEM = NULL;
     TCHAR tszFullFileName[MAX_PATH];
    CAU_BSTR aubsFullFileName;
    CAU_BSTR aubsItemPattern;
    UINT uItemAdded = 0;
    HRESULT hr = S_OK;

    DEBUGMSG("PersistHiddenItems() starts");
    if (itemlist.GetNumUnselected() == 0)
        {
            DEBUGMSG("No hidden items to persist");
            goto done;
        }
    AUASSERT(_T('\0') != g_szWUDir[0]);
    if (FAILED(StringCchCopyEx(tszFullFileName, ARRAYSIZE(tszFullFileName), g_szWUDir, NULL, NULL, MISTSAFE_STRING_FLAGS)) ||
		FAILED(StringCchCatEx(tszFullFileName, ARRAYSIZE(tszFullFileName), HIDDEN_ITEMS_FILE, NULL, NULL, MISTSAFE_STRING_FLAGS)) ||
		!aubsFullFileName.append(T2W(tszFullFileName)) ||
        !aubsItemPattern.append(AUCatalog::bstrHiddenItems) ||
        !aubsItemPattern.append(L"/") ||!aubsItemPattern.append(AUCatalog::bstrTagITEM))
    {
    DEBUGMSG("Fail to create string ");
    hr = E_OUTOFMEMORY;
    goto done;
    }

    if (fFileExists(tszFullFileName))
        {
            DEBUGMSG("file %S exists. Add hidden items to it", tszFullFileName);
            if (FAILED(hr = LoadDocument(aubsFullFileName, &pHiddenXml, TRUE))) //offline
                {
                    DEBUGMSG(" %S fail to load with error %#lx, delete it", aubsFullFileName, hr);
                    AUDelFileOrDir(tszFullFileName);
                }
        }
    if (NULL == pHiddenXml)
        {
            if (FAILED(hr = LoadXMLDoc(AUCatalog::bstrTemplate, &pHiddenXml, TRUE))) //offline
                {
                  DEBUGMSG("Fail to load template xml with error %#lx", hr);
                  goto done;
                }
        }

    if (!FindNode(pHiddenXml, AUCatalog::bstrHiddenItems, &pHiddenItemsNode))
        {
            hr = E_FAIL;
            DEBUGMSG("Fail to find node %S", AUCatalog::bstrHiddenItems);
            goto done;
        }

       VARIANT varValueID;
       varValueID.vt = VT_BSTR;
    // write out item information
	for ( DWORD index = 0; index < itemlist.Count(); index++ )
	{
        if (itemlist[index].fUnselected())
            { //hide unselected items
                varValueID.bstrVal = itemlist[index].bstrID();
                if ( FAILED(hr = pHiddenXml->createElement(AUCatalog::bstrTagITEM, &pelemITEM)) ||
                      FAILED(hr = pelemITEM->setAttribute(AUCatalog::bstrAttrID, varValueID)) ||
                      FAILED(hr = pHiddenItemsNode->appendChild(pelemITEM, NULL)) )
                {
                    DEBUGMSG("XML operation failure with error %#lx", hr);
                }
                else
                    {
    //                DEBUGMSG("item %S persisted", itemlist[index].bstrID());
                    uItemAdded++;
					gPingStatus.PingDeclinedItem(FALSE, activity, W2T(varValueID.bstrVal));
                    }
                SafeReleaseNULL(pelemITEM);
//                DEBUGMSG("Item %S now hidden", itemlist[index].bstrID());
                itemlist[index].SetStatusHidden();
            }
       }

      if (0 == uItemAdded)
        {
            DEBUGMSG("no new hidden items need to be persisted");
            hr = S_OK;
        }
      else
	if (FAILED(hr= SaveDocument(pHiddenXml, aubsFullFileName)))
	    {
	    DEBUGMSG("Fail to save hidden xml %S with error %#lx", T2W(tszFullFileName), hr);
           AUDelFileOrDir(tszFullFileName);
           goto done;
	    }
done:
   SafeRelease(pelemITEM);
   SafeRelease(pHiddenItemsNode);
   SafeRelease(pHiddenXml);
   DEBUGMSG("PersistHiddenItems() ends with %d items added", uItemAdded);
   return hr;
}

//////////////////////////////////////////////////////////////////////
// read hidden xml file if there is one
// and populate the hidden item list passed in
// return S_FALSE if there is no hidden items found
/////////////////////////////////////////////////////////////////////
HRESULT GetPersistedHiddenItems(AUCatalogItemList OUT & hiddenItemList)
{
    HRESULT hr ;
    IXMLDOMNodeList *pItemNodes = NULL;
    IXMLDOMDocument *pHiddenXml = NULL;
    CAU_BSTR aubsItemPattern;

    DEBUGMSG("GetPersistedHiddenItems() starts");
    TCHAR tszFullFileName[MAX_PATH];
    CAU_BSTR aubsFullFileName;

    AUASSERT(_T('\0') != g_szWUDir[0]);
    if (FAILED(StringCchCopyEx(tszFullFileName, ARRAYSIZE(tszFullFileName), g_szWUDir, NULL, NULL, MISTSAFE_STRING_FLAGS)) ||
		FAILED(StringCchCatEx(tszFullFileName, ARRAYSIZE(tszFullFileName), HIDDEN_ITEMS_FILE, NULL, NULL, MISTSAFE_STRING_FLAGS)) ||
		!aubsItemPattern.append(AUCatalog::bstrHiddenItems) ||
         !aubsItemPattern.append(L"/") ||
         !aubsItemPattern.append(AUCatalog::bstrTagITEM) ||
         !aubsFullFileName.append(T2W(tszFullFileName)))
        {
            DEBUGMSG("fail to create string");
            hr = E_OUTOFMEMORY;
            goto done;
        }

    if (!fFileExists(W2T(aubsFullFileName)))
        {
            DEBUGMSG("No persisted item found");
            hr = S_FALSE;
            goto done;
        }
    if (FAILED(hr = LoadDocument(aubsFullFileName, &pHiddenXml, TRUE))) //offline
    {
        DEBUGMSG(" %S fail to load with error %#lx", aubsFullFileName, hr); //might be expected if file is not there
        goto done;
    }
    pItemNodes = FindDOMNodeList(pHiddenXml, aubsItemPattern);
    if (NULL == pItemNodes)
        {
        	hr = S_FALSE;
            DEBUGMSG("no persisted hidden items found using pattern %S", aubsItemPattern);
            goto done;
        }
    long lItemNum;
    if (FAILED(hr = pItemNodes->get_length(&lItemNum)))
    {
    	DEBUGMSG("fail to get number of item nodes with error %#lx", hr);
    	goto done;
    }
    for (int i = 0; i < lItemNum; i++)
        {
            IXMLDOMNode *pItemNode = NULL;
            BSTR bstrItemID = NULL;
            if (S_OK != (hr = pItemNodes->get_item(i, &pItemNode)))
            {
            	DEBUGMSG("Fail to get item %d", i);
            	hr = FAILED(hr) ? hr : E_FAIL;
            	goto done;
            }
            hr = GetAttribute(pItemNode, AUCatalog::bstrAttrID, &bstrItemID);
            SafeRelease(pItemNode);
            if (FAILED(hr))
            {
            	goto done;
            }
            if (NULL != bstrItemID)
                {
                    AUCatalogItem *pItem = new AUCatalogItem();
                    if (NULL == pItem)
                        {
                            DEBUGMSG("Fail to create new item");
                            SysFreeString(bstrItemID);
                            hr = E_OUTOFMEMORY;
                            goto done;
                        }
                    else
                        {
                        pItem->SetField(AUCatalogItem::m_pFieldNames[0], bstrItemID);
                        DEBUGMSG("Find one hidden item %S", bstrItemID);
                        if (!hiddenItemList.Add(pItem))
                        {
                        	DEBUGMSG("OUT OF MEMORY: fail to add item");
                        	hr = E_OUTOFMEMORY;
                        	delete pItem;
                        	goto done;
                        }
                        }
                }
        }
    done:
        SafeRelease(pItemNodes);
        SafeRelease(pHiddenXml);
        if (hr != S_OK)
            {
            hiddenItemList.Clear();
            }
        DEBUGMSG("GetPersistedHiddenItems() ends");
        return hr;
}
                    
                
//////////////////////////////////////////////////////////////////////////////////////////////////////
// given a details xml, extract all the items in it
// and populate the AU catalog item list passed in
// all the persisted hidden items will be excluded
// bstrDetails: IN details xml
// itemlist :   IN/OUT receives items information
// fDriver:  IN whether bstrDetails is for driver or non driver
// pfFoundExclusive: OUT TRUE if found exclusive item. In that case, only exclusive item will be returned
// return : TRUE if items got from the xml
//              FALSE otherwise
/////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL fExtractItemInfo(IN const BSTR bstrDetails, OUT AUCatalogItemList & itemList, OUT BOOL *pfFoundExclusive) 
{
	long lNumItems = 0;
	BSTR *pbstrItemIds = NULL;
	BOOL fRet = FALSE;
	CItemDetails itemdetails;
	BSTR bstrExclusiveItemId; 
       AUCatalogItemList hiddenItemList;
       BOOL fHiddenItemsFound;
       BOOL fItemIdsAllocated = FALSE;
	HRESULT hr;

       DEBUGMSG("fExtractItemInfo() starts");
		*pfFoundExclusive = FALSE;
		itemList.Clear();
       if (!itemdetails.Init(bstrDetails))
        {
            DEBUGMSG("Fail to init itemdetails");
            goto done;
        }
       if (FAILED(hr = GetPersistedHiddenItems(hiddenItemList)))
       {
           DEBUGMSG("no persisted hidden items loaded with error %#lx", hr);
       }
       if (*pfFoundExclusive = (S_OK == itemdetails.FindFirstExclusiveItem(&bstrExclusiveItemId, hiddenItemList)))
        {
                DEBUGMSG("Found exclusive item, add it");
                lNumItems = 1;
                pbstrItemIds = &bstrExclusiveItemId;
        }
       else
        {
           if (FAILED(hr = itemdetails.GetItemIds(&lNumItems, &pbstrItemIds)))
            {
                DEBUGMSG("Fail to get item ids with error %#lx", hr);
                goto done;
            }
           else
            {
                fItemIdsAllocated = TRUE;
            }
        }

   
	for (long i = 0; i < lNumItems; i++)
	{
		if (itemList.Contains(pbstrItemIds[i]) >=0)
		{ //duplicate item id found
			continue;
		}
		AUCatalogItem *pitem = new AUCatalogItem();
		if (NULL == pitem)
		    {
		        DEBUGMSG("Out of memory and fail to create new item.");
		        goto done;
		    }
		BSTR bstrTmp = SysAllocString(pbstrItemIds[i]);
		if (NULL == bstrTmp)
		{
			DEBUGMSG("Out of memory ");
			delete pitem;
			goto done;
		}
		pitem->SetField(AUCatalogItem::m_pFieldNames[0], bstrTmp);
		 //even if one or more following item information is missing, add item anyway
		 for (int j = 1; j < ARRAYSIZE(AUCatalogItem::m_pFieldNames); j++)
		    {
	    		BSTR bstrItemInfo = NULL;
		       if (FAILED(itemdetails.GetItemInfo(AUCatalogItem::m_pFieldNames[j], pbstrItemIds[i], &bstrItemInfo)))
		        {
		            continue;
		        }
             	pitem->SetField(AUCatalogItem::m_pFieldNames[j], bstrItemInfo);
		    }
		  if ( IsPersistedHiddenItem(pbstrItemIds[i], hiddenItemList) ||
		        !itemdetails.IsVisible(pbstrItemIds[i]))
	            { //don't show non visible and hidden items
        	        pitem->SetStatusHidden(); 
	            }
	     	if (!itemList.Add(pitem))
	     	{
	     		DEBUGMSG("OUT OF MEMORY: fail to add new item");
	     		delete pitem;
	     		goto done;
	     	}
	}
    fRet = TRUE;
done:
        itemdetails.Uninit();
        if (!fRet)
            {
            itemList.Clear();
            }
        for (int k = 0; k < lNumItems; k++)
            {
                SafeFreeBSTR(pbstrItemIds[k]);
            }
        if (fItemIdsAllocated)
            {
                SafeFree(pbstrItemIds);
            }
        DEBUGMSG("fExtractItemInfo() ends");
        return fRet;
}


IXMLDOMNode * createDownloadItemStatusNode(IN IXMLDOMDocument * pxml, IN AUCatalogItem  &Item, IN const BSTR bsInstallation, OUT IXMLDOMNode **ppIdentity)
{
    IXMLDOMElement * pitemStatus = NULL;
    BOOL fError = FALSE; //no error occurs
    IXMLDOMNode * pdescription = NULL;
    IXMLDOMNode * pPlatform = NULL;
    IXMLDOMElement *pdownloadStatus = NULL;
    IXMLDOMElement *pdownloadPath = NULL;
    CItemDetails itemDetails;
    BSTR bsItemId, bsdownloadPath = NULL;
    VARIANT vComplete;
    IXMLDOMNode ** ItemStatusChildren[] = {ppIdentity, &pdescription, &pPlatform};

    DEBUGMSG("CAUCatalog::createDownloadItemStatusNode()  starts");
    *ppIdentity = NULL;
    if (!itemDetails.Init(bsInstallation))
        {
        DEBUGMSG("fail to init itemdetails");
        fError = TRUE;
        goto done;
        }

        
    bsItemId = Item.bstrID();
    DEBUGMSG("creating node for %S", bsItemId);
    if (NULL == bsItemId)
        {
        DEBUGMSG("fails to get item id");
        fError = TRUE;
        goto done;
        }
    if (FAILED(pxml->createElement(KEY_ITEMSTATUS, &pitemStatus)) || NULL == pitemStatus)
        {
        DEBUGMSG("fail to create item status node");
        fError = TRUE;
        goto done;
        }

    itemDetails.CloneIdentityNode(bsItemId, pxml, ppIdentity);
    itemDetails.CloneDescriptionNode(bsItemId, pxml, &pdescription);
    itemDetails.ClonePlatformNode(bsItemId, pxml, &pPlatform);
    if (NULL == *ppIdentity || NULL == pdescription || NULL == pPlatform)
        {
        fError = TRUE;
        goto done;
        }

  for (int i = 0; i < ARRAYSIZE(ItemStatusChildren); i++)
    {
      if (FAILED(pitemStatus->appendChild(*(ItemStatusChildren[i]), NULL)))
        {
        DEBUGMSG("fail to append identy node");
        fError = TRUE;
        goto done;
        }
    }

     if (FAILED(pxml->createElement(KEY_DOWNLOADPATH, &pdownloadPath)) || NULL == pdownloadPath)
        {
        DEBUGMSG("fail to create download path node");
        fError = TRUE;
        goto done;
        }

    bsdownloadPath = itemDetails.GetItemDownloadPath(bsItemId);
    if (NULL == bsdownloadPath)
        {
            fError = TRUE;
            goto done;
        }
    
    if (FAILED(pdownloadPath->put_text(bsdownloadPath)))
        {
        DEBUGMSG("fail to set download path text to %S", bsdownloadPath);
        fError = TRUE;
        goto done;
        }
    
    if (FAILED(pitemStatus->appendChild(pdownloadPath, NULL)))
        {
        DEBUGMSG("fail to append download path");
        fError = TRUE;
        goto done;
        }
    
    if (FAILED(pxml->createElement(KEY_DOWNLOADSTATUS, &pdownloadStatus)) || NULL == pdownloadStatus)
        {
        DEBUGMSG("fail to create download status node");
        fError = TRUE;
        goto done;
        }

    vComplete.vt = VT_BSTR;
    vComplete.bstrVal = SysAllocString(L"COMPLETE");
    if (NULL == vComplete.bstrVal)
    {
    	DEBUGMSG("Out of memory, fail to create string complete");
    	fError = TRUE;
    	goto done;
    }
    HRESULT hr = SetAttribute(pdownloadStatus, KEY_DOWNLOADSTATUS, vComplete);
    VariantClear(&vComplete);
    if (FAILED(hr))
        {
        DEBUGMSG("fail to set download status attribute");
        fError = TRUE;
        goto done;
        }

    if (FAILED(pitemStatus->appendChild(pdownloadStatus, NULL)))
        {
        DEBUGMSG("fail to append download status node");
        fError = TRUE;
        goto done;
        }

    
done:
    itemDetails.Uninit();
    SafeFreeBSTR(bsdownloadPath);
    if (fError)
        {
            SafeRelease(*ppIdentity);
            SafeRelease(pitemStatus);
            *ppIdentity = NULL;
            pitemStatus = NULL;
        }
    SafeRelease(pPlatform);
    SafeRelease(pdescription);
    SafeRelease(pdownloadPath);
    SafeRelease(pdownloadStatus);
    DEBUGMSG("CAUCatalog::createDownloadItemStatusNode() ends");
    return pitemStatus;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////
// *pbstrInstallation contains a subset of bsItemDetails (only items needs to be installed)
///////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT PrepareInstallXML(
            IN  BSTR bsItemDetails, //a superset of items in the itemlist
            IN  AUCatalogItemList &itemList, 
            OUT BSTR * pbstrDownloadResult,
            OUT BSTR *pbstrInstallation)
{
  DEBUGMSG("::PrepareInstallXML");
  HRESULT hr = E_FAIL;
  BSTR bsRet = NULL;
  IXMLDOMNode * pItems = NULL;
  IXMLDOMDocument *pxml = NULL;
  CItemDetails  itemdetails;
  LONG lNumItems = 0;
  BSTR * pbstrItemIds = NULL;

   *pbstrDownloadResult = NULL;
   *pbstrInstallation = NULL;

    if (! itemdetails.Init(bsItemDetails))
        {
            DEBUGMSG("Fail to init item details ");
            goto done;
        }
    if (FAILED(hr = LoadXMLDoc(AUCatalog::bstrResultTemplate, &pxml)))
        {
        DEBUGMSG("::PrepareInstallXML() fail to load download result template with error %#lx", hr);
        goto done;
        }

     if (FAILED(hr = FindSingleDOMNode(pxml, KEY_ITEMS, &pItems)) || NULL == pItems)
        {
         DEBUGMSG("::PrepareInstallXML() fail to get items with error %#lx", hr);
         goto done;
        }

//    DEBUGMSG("need to insert %d items in download result", itemList.GetNumSelected());
     if (FAILED(hr = itemdetails.GetItemIds(&lNumItems, &pbstrItemIds)))
            {
                DEBUGMSG("Fail to get item ids with error %#lx", hr);
                goto done;
            }

    for (LONG l = 0; l < lNumItems; l++)
        {
            if (itemList.Contains(pbstrItemIds[l]) < 0)
                {
                    itemdetails.DeleteItem(pbstrItemIds[l]); //delete items not in the itemlist
                }
        }
    for (UINT i = 0; i < itemList.Count(); i++)
        {
            AUCatalogItem & item = itemList[i];
            if (item.fSelected() || itemList.ItemIsRelevant(i))
                {
                	long lItemNum = 0;
                	IXMLDOMNodeList *pIdentityNodeList = NULL;
                	if (FAILED(itemdetails.GetItemIdentities(item.bstrID(), &pIdentityNodeList)))
                	{
                		DEBUGMSG("Fail to get item identities for item %S", item.bstrID());
                		continue;
                	}
                	if (FAILED(pIdentityNodeList->get_length(&lItemNum)))
                	{

                		DEBUGMSG("Fail to get number of identity nodes"); //fixcode: bail out here
                		pIdentityNodeList->Release();
                		continue;
                	}
                	for (long lIndex = 0; lIndex < lItemNum; lIndex++)
                	{
                		DEBUGMSG("Create download status node %d for item %S", lIndex, item.bstrID());
                		IXMLDOMNode * pDetailsIdentity = NULL;
                        	IXMLDOMNode *pDownloadResultIdentity = NULL;
                		if (S_OK != pIdentityNodeList->get_item(lIndex, &pDetailsIdentity))
                		{
                			DEBUGMSG("Fail to get item %d", lIndex); //fixcode: bail out here
                			continue;
                		}
                		MungleIdentity(pDetailsIdentity, lIndex);
	                    IXMLDOMNode * pItemStatus = createDownloadItemStatusNode(pxml, item, bsItemDetails, &pDownloadResultIdentity);
	                    if (NULL != pItemStatus)
	                        {
					MungleIdentity(pDownloadResultIdentity, lIndex);
					if (FAILED(hr = pItems->appendChild(pItemStatus,NULL)))
					    {
					        DEBUGMSG("fail to insert item %d", i);
					    }
					else
					    {
					          DEBUGMSG("item %d inserted", i);
					    }
					pItemStatus->Release();
	                        }
	                    SafeRelease(pDetailsIdentity);
	                    SafeRelease(pDownloadResultIdentity);
                	}
                	pIdentityNodeList->Release();
                }
            else
                {
                    itemdetails.DeleteItem(item.bstrID());
                }
        }
   if ( FAILED(hr = pxml->get_xml(pbstrDownloadResult)) )
       {
        DEBUGMSG("::PrepareInstallXML() fail to get xml for the result %#lx", hr);
        goto done;
        }

   if (FAILED(hr = itemdetails.GetXML(pbstrInstallation)))
    {
        DEBUGMSG(" fail to get xml for installation with error %#lx", hr);
        goto done;
    }
   

done:
   itemdetails.Uninit();
   SafeRelease(pItems);
   SafeRelease(pxml);
   for (int k = 0; k < lNumItems; k++)
       {
           SafeFreeBSTR(pbstrItemIds[k]);
       }
   if (lNumItems > 0)
       {
           SafeFree(pbstrItemIds);
       }
   if (FAILED(hr))
    {
        SafeFreeBSTR(*pbstrDownloadResult);
        *pbstrDownloadResult = NULL;
        SafeFreeBSTR(*pbstrInstallation);
        *pbstrInstallation = NULL;
    }
   return hr;
}

///////////////////////////////////////////////////////////////////
// merge catalog 1 and catalog2 and make it destination catalog *pDesCatalog
// if either of bsCatalog1 and bsCatalog2 is NULL, return duplicate of the non NULL 
//  catalog 
// if both bsCatalog1 and bsCatalog2 are NULL, return NULL and S_FALSE
// 
///////////////////////////////////////////////////////////////////
HRESULT MergeCatalogs(IN const BSTR bsCatalog1, IN const BSTR bsCatalog2, OUT BSTR *pbsDesCatalog )
{
    IXMLDOMDocument * pCat1 = NULL;
    IXMLDOMDocument * pCat2 = NULL;
    IXMLDOMNodeList *pProviderNodeList = NULL;
    IXMLDOMNode *pCatalogNode = NULL;
    HRESULT hr = E_FAIL;

    DEBUGMSG("MergeCatalogs() starts");
    *pbsDesCatalog = NULL;
    if (NULL == bsCatalog1 && NULL == bsCatalog2)
    {
    	return S_FALSE;
    }
    if (NULL == bsCatalog1 || NULL == bsCatalog2)
        {
        *pbsDesCatalog = SysAllocString((NULL == bsCatalog1) ? bsCatalog2 : bsCatalog1);
        if (NULL == *pbsDesCatalog)
        {
        	DEBUGMSG("Out of memory");
        	hr = E_OUTOFMEMORY;
        	goto done;
        }
        hr = S_OK;
        goto done;
        }
    if ( FAILED(hr = LoadXMLDoc(bsCatalog1, &pCat1)) ||
         FAILED(hr = LoadXMLDoc(bsCatalog2,&pCat2)))
        {
        DEBUGMSG("MergeCatalogs() fail to load xml or fail or allocate string (with error %#lx)", hr);
        goto done;
        }
    if (FAILED(hr = FindSingleDOMNode(pCat1, AUCatalog::bstrCatalog, &pCatalogNode)))
        {
        DEBUGMSG("Fail to find provider in catalog 1");
        goto done;
        }
    if (NULL == (pProviderNodeList = FindDOMNodeList(pCat2, KEY_CATALOG_PROVIDER)))
        {
        DEBUGMSG("Fail to find provider in catalog 2 with error %#lx", hr);
        goto done;
        }
    long lNum;
    if (FAILED(hr = pProviderNodeList->get_length(&lNum)))
    {
    	DEBUGMSG("Fail to get nubmer of providers");
    	goto done;
    }
    for (int i = 0; i < lNum; i++)
        {
        IXMLDOMNode * pProviderNode = NULL;
        if (S_OK != (hr = pProviderNodeList->get_item(i, &pProviderNode)))
            {
            DEBUGMSG("Fail to get item in Provider List with error %#lx", hr);
            hr = FAILED(hr) ? hr : E_FAIL;
            goto done;
            }
        if (FAILED(hr = InsertNode(pCatalogNode, pProviderNode)))
            {
            DEBUGMSG("Fail to append provider node from catalog 2 to catalog 1 with error %#lx", hr);
            pProviderNode->Release();
            goto done;
            }
        pProviderNode->Release();
        }
    if (FAILED(hr = pCat1->get_xml(pbsDesCatalog)))
        {
            DEBUGMSG("Fail to get result xml for catalog 1 with error %#lx", hr);
            goto done;
        }
done:
    SafeRelease(pCat1);
    SafeRelease(pCat2);
    SafeRelease(pProviderNodeList);
    SafeRelease(pCatalogNode);
    if (FAILED(hr))
    {
    	SafeFreeBSTRNULL(*pbsDesCatalog);
    }
    DEBUGMSG("MergeCatalogs() ends");
    return hr;
}

////////////////////////////////////////////////////////////////////////////////////
// populate itemlist for all items in the list with detailed information from local merged catalog xml file
// also return the merged catalog xml in pbstrInstallation
// if fDrvierNeeded, care to extract driver information. Otherwise, no driver info extracted
/////////////////////////////////////////////////////////////////////////////////////
HRESULT GetDetailedItemInfoFromDisk(IN OUT AUCatalogItemList  &ItemList, OUT BSTR *pbstrInstallation,  IN BOOL fDriverNeeded)
{
    HRESULT hr = S_OK;
    CItemDetails driverDetails, nonDriverDetails;
    BSTR bstrDriver = NULL;
    BSTR bstrNonDriver = NULL;

    *pbstrInstallation = NULL;

    if (NULL == (bstrNonDriver = ReadXMLFromFile(DETAILS_FILE)) ||
        (fDriverNeeded && (NULL == (bstrDriver = ReadXMLFromFile(DRIVERS_FILE)))))
        {
            DEBUGMSG("Fail to load driver or nondriver details xml file");
            hr = E_FAIL;
            goto done;
        }
    if (!nonDriverDetails.Init(bstrNonDriver) ||
          (fDriverNeeded && !driverDetails.Init(bstrDriver)))
        {
        DEBUGMSG("Fail to initialize item or driver details ");
        hr = E_FAIL;
        goto done;
        }
    if (FAILED(hr = MergeCatalogs(bstrDriver, bstrNonDriver, pbstrInstallation)))
        {
            DEBUGMSG("Fail to merge catalog with error %#lx", hr);
            goto done;
        }
    for (UINT u = 0; u < ItemList.Count(); u++)
        {
            for (int i = 1; i < ARRAYSIZE(AUCatalogItem::m_pFieldNames); i++)
                {
                    BSTR bstrItemInfo = NULL;
                    if (SUCCEEDED(nonDriverDetails.GetItemInfo(AUCatalogItem::m_pFieldNames[i], ItemList[u].bstrID(), &bstrItemInfo)) ||
                        (fDriverNeeded && SUCCEEDED(driverDetails.GetItemInfo(AUCatalogItem::m_pFieldNames[i], ItemList[u].bstrID(), &bstrItemInfo))))
                        {
                            ItemList[u].SetField(AUCatalogItem::m_pFieldNames[i], bstrItemInfo);
                        }
                    else  
                        {
                        DEBUGMSG("Warning: not getting information about %S for item %S", AUCatalogItem::m_pFieldNames[i], ItemList[u].bstrID());
                        }
                }
        }
    done:
        driverDetails.Uninit();
        nonDriverDetails.Uninit();
        if (FAILED(hr))
        {
	        SafeFreeBSTR(*pbstrInstallation);
	        *pbstrInstallation = NULL;
        }
        SafeFreeBSTR(bstrDriver);
	    SafeFreeBSTR(bstrNonDriver);
        return hr;
}



///////////////////////////////////////////////////////////////////////////////////////
// walk through the whole list of items, hidden or non hidden, build dependency list m_DependentItems
// for each item from scratch. The orginal m_DependentItems for each item is discarded
// bstrDriver could be NULL
/////////////////////////////////////////////////////////////////////////////////////////
HRESULT BuildDependencyList(
            AUCatalogItemList IN OUT &itemlist, 
            BSTR IN bstrDriver,
            BSTR IN bstrNonDriver)
{
    CItemDetails driverInfo;
    CItemDetails nondriverInfo;
    HRESULT hr = E_FAIL ;
    BOOL fHasDriverUpdate = TRUE;

    if (!nondriverInfo.Init(bstrNonDriver))
        {
            DEBUGMSG("Fail to initialize item details");
            goto done;
        }

    if (NULL != bstrDriver)
        {
            if (!driverInfo.Init(bstrDriver) )
                {
                    DEBUGMSG("Fail to initialize driver details");
                    goto done;
                }
        }
    else
        {
            fHasDriverUpdate = FALSE;
        }
    DEBUGMSG("Building direct dependency for non drivers");
    if (FAILED(hr = nondriverInfo.BuildDirectDependency(itemlist)))
            { //itemlist is a non driver and dependency built if any
            DEBUGMSG("Fail to build dependency for non drivers with error %#lx", hr);
            goto done;
            }
    if (fHasDriverUpdate)
        {
             DEBUGMSG("Building direct dependency for drivers");
             if (FAILED(hr = driverInfo.BuildDirectDependency(itemlist)))
                 { //itemlist is a driver and dependency built if any
                    DEBUGMSG("Fail to build dependency for drivers with error %#lx", hr);
                    goto done;
                 }
        }
     DEBUGMSG("Building indirect dependency");
    if (FAILED(hr = itemlist.BuildIndirectDependency()))
        {
            DEBUGMSG("Fail to build indirect dependency for itemlist with error %#lx", hr);
            goto done;
        }
    done:
        if (fHasDriverUpdate)
            {
                driverInfo.Uninit();
            }
        nondriverInfo.Uninit();
        DEBUGMSG("BuildDependencyList done");
#ifdef DBG
//        itemlist.DbgDump();
#endif
        return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\wuaueng\auxml.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       auxml.h
//
//  About:  header file for AU related XML and schema data structure and functions
//--------------------------------------------------------------------------

#pragma once
#include <windows.h>
#include <ole2.h>
#include <msxml.h>
#include <URLLogging.h>
#include "AUBaseCatalog.h"

class CItemDetails
{
	public:
		CItemDetails() : m_pxml(NULL) {};
		~CItemDetails() {};
		BOOL Init(BSTR bsxml);
		void Uninit(); 
		HRESULT CloneIdentityNode(BSTR bstrItemId, IXMLDOMDocument *pDesXml, IXMLDOMNode ** ppDesNode);
		HRESULT CloneDescriptionNode(BSTR bstrItemId,IXMLDOMDocument *pDesXml, IXMLDOMNode ** ppDesNode);
		HRESULT ClonePlatformNode(BSTR bstrItemId,IXMLDOMDocument *pDesXml, IXMLDOMNode ** ppDesNode);
		HRESULT GetItemIds(long *puItemNum, BSTR ** ppbstrItemIds);
		HRESULT GetItemInfo(LPCSTR szFieldName, BSTR bstrItemId, BSTR * pbstrItemInfo);
		HRESULT GetCabNames(BSTR bstrItemId, BSTR ** ppCabNames, BSTR **ppRealCabNames, BSTR **ppCabChecksums, UINT *pCabsNum);
        HRESULT GetRTFCRC(BSTR bstrItemId, BSTR * pRTFCRC);
		HRESULT FindFirstExclusiveItem(BSTR *pbstrItemId, AUCatalogItemList & hiddenItemList);
		HRESULT DeleteItem(BSTR bstrItemId);
		HRESULT GetXML(BSTR *pbstrxml);
		HRESULT BuildDirectDependency(AUCatalogItemList IN OUT &item);
		BSTR GetItemDownloadPath(BSTR bstrItemId);
		BOOL IsVisible(BSTR bstrItemId);
		HRESULT  GetItemIdentities(BSTR bstrItemId, IXMLDOMNodeList ** ppIdentityNodeList);

	private:
		IXMLDOMDocument * m_pxml;
		IXMLDOMNode * getIdentityNode(BSTR bstrItemId);
		IXMLDOMNode * getItemNode(BSTR bstrItemId);

};

BOOL fExtractItemInfo(BSTR bstrDetails, AUCatalogItemList & itemList, /*BOOL fDriver,*/ BOOL *pfFoundExclusiveItem/*, BOOL fIgnoreExclusiveNhidden*/);
BSTR ReadXMLFromFile(LPCTSTR szFile);
HRESULT PrepareInstallXML(BSTR bstrItemDetails, AUCatalogItemList &itemList, BSTR * pbstrDownloadResult, BSTR *pbstrInstallation);
HRESULT MergeCatalogs(BSTR bsCatalog1, BSTR bsCatalog2, BSTR *pbsDesCatalog );
HRESULT PersistHiddenItems(AUCatalogItemList &itemlist, URLLOGACTIVITY activity);
HRESULT GetDetailedItemInfoFromDisk(AUCatalogItemList OUT &ItemList, BSTR OUT *pbstrInstallation, BOOL fUpdateDriver);
HRESULT BuildDependencyList(AUCatalogItemList IN OUT &itemlist, BSTR IN bstrDriverDetail, BSTR IN bstrNonDriverDetail);
HRESULT MungleIdentity(IXMLDOMNode *pIdentity, DWORD dwSuffix);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\wuaueng\caustate.cpp ===
//=======================================================================
//
//  Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:    state.cpp
//
//  Creator: PeterWi
//
//  Purpose: State management functions.
//
//=======================================================================

#include "pch.h"
#pragma hdrstop

// global state object pointer
CAUState *gpState;
BOOL  gfDownloadStarted; //to be used to distinguish connection detection and actually downloading mode

#ifdef DBG
const TCHAR REG_AUCONNECTWAIT[] = _T("ConnectWait"); 
const TCHAR REG_SELFUPDATE_URL[] = _T("SelfUpdateURL");
#endif

const TCHAR REG_WUSERVER_URL[] = _T("WUServer");
const TCHAR REG_WUSTATUSSERVER_URL[] = _T("WUStatusServer");
const TCHAR REG_IDENT_URL[] = _T("IdentServer");
const TCHAR WU_LIVE_URL[] = _T("http://windowsupdate.microsoft.com/v4");


//AU configurable registry settings
const TCHAR REG_AUOPTIONS[] = _T("AUOptions"); //REG_DWORD
const TCHAR REG_AUSTATE[] = _T("AUState"); //REG_DWORD
const TCHAR REG_AUDETECTIONSTARTTIME[] = _T("DetectionStartTime"); //REG_SZ
const TCHAR REG_AUSCHEDINSTALLDAY[] = _T("ScheduledInstallDay"); //REG_DWORD
const TCHAR REG_AUSCHEDINSTALLTIME[] = _T("ScheduledInstallTime"); //REG_DWORD
const TCHAR REG_AURESCHEDWAITTIME[] = _T("RescheduleWaitTime"); //REG_DWORD
const TCHAR REG_AUSCHEDINSTALLDATE[] = _T("ScheduledInstallDate"); //REG_SZ
const TCHAR REG_AURESCHED[] = _T("Rescheduled"); //REG_DWORD

const TCHAR REG_AUNOAUTOUPDATE[] = _T("NoAutoUpdate"); // REG_DWORD 1 means AU be disabled

#define MIN_RESCHEDULE_WAIT_TIME 1
#define MAX_RESCHEDULE_WAIT_TIME 60

//=======================================================================
//  CAUState::HrCreateState
//
//  Static function to create the global state object in memory.
//=======================================================================
/*static*/ HRESULT CAUState::HrCreateState(void)
{
    HRESULT hr;

    if ( NULL == (gpState = new CAUState()) )
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

	if (NULL == (gpState->m_hMutex = CreateMutex(NULL, FALSE, NULL)))
    {				
        DEBUGMSG("CAUState::HrCreateState() fail to CreateMutex with error %d",GetLastError());
        hr = E_FAIL;
        goto done;
    }
    hr = gpState->HrInit(TRUE);	
done:
    return hr;
}

AUFILETIME GetCurrentAUTime(void)
{
	AUFILETIME auftNow;
	SYSTEMTIME stNow;
	GetLocalTime(&stNow);
	if (!SystemTimeToFileTime(&stNow, &auftNow.ft))
	{
		auftNow.ull = AUFT_INVALID_VALUE;
		AUASSERT(FALSE); //should never be here
	}
	return auftNow;
}

CAUState::CAUState()
{ //only initialize members that destructor cares and member that will be inited once and never change
   m_auftServiceStartupTime = GetCurrentAUTime();
   m_fReschedPrivileged = TRUE;
    m_hMutex = NULL;
#ifdef DBG
    m_pszTestSelfUpdateURL = NULL;
#endif
    m_pszTestIdentServerURL = NULL;
}

void CAUState::m_Reset(void)
{
    m_PolicySettings.Reset();
    m_dwState = AUSTATE_OUTOFBOX;
#ifdef DBG    
    SafeFreeNULL(m_pszTestSelfUpdateURL);
#endif
    SafeFreeNULL(m_pszTestIdentServerURL);
    m_fWin2K = FALSE;
    m_auftSchedInstallDate.ull = AUFT_INVALID_VALUE;
    m_auftDetectionStartTime.ull = AUFT_INVALID_VALUE;
    m_dwCltAction = AUCLT_ACTION_NONE;
    m_fDisconnected = FALSE;
    m_fNoAutoRebootWithLoggedOnUsers(TRUE); //clear cache
}
	

//=======================================================================
//  CAUState::HrInit
//
//  Initialize state.
//=======================================================================
HRESULT CAUState::HrInit(BOOL fInit)
{
        HRESULT hr = S_OK;

	    if (!m_lock())
	    {
	    	return HRESULT_FROM_WIN32(GetLastError());
	    }
        m_dwCltAction = AUCLT_ACTION_NONE;
        m_fDisconnected = FALSE;
        m_PolicySettings.m_fRegAUOptionsSpecified = TRUE;
	m_Reset();
    	m_ReadRegistrySettings(fInit);

        // read policy information.  If any domain policy setting is
        // invalid, we revert to admin policy settings.
        if ( FAILED(hr = m_ReadPolicy(fInit)) )	// called after getting m_dwState due to dependency
        { // only case this function fails is when out of memory
            goto done;
        }

        if (!gPingStatus.SetCorpServerUrl(m_PolicySettings.m_pszWUStatusServerURL))
		{
			hr = E_FAIL;
			goto done;
		}

        if ( FAILED(hr = m_ReadTestOverrides()))
	    {//only case this function fails is when out of memory
	        goto done;
	    }

		if (!m_PolicySettings.m_fRegAUOptionsSpecified)
		{
		    if (m_dwState >= AUSTATE_DETECT_PENDING)
		    {  //invalid option needs user attention via wizard
		  	m_dwState = AUSTATE_OUTOFBOX;
		    }
		}
		else if (!fOptionEnabled())
	    {
	        SetState(AUSTATE_DISABLED);
	    }
	    else if (m_dwState < AUSTATE_DETECT_PENDING)
	    {   // if domain policy set or auoption already configured, we skip the wizard state.
	        SetState(AUSTATE_DETECT_PENDING);
	    }
		
	    m_fWin2K = IsWin2K();
		gfDownloadStarted = FALSE;

done:
#ifdef DBG
    if ( SUCCEEDED(hr) )
    {
        m_DbgDumpState();
    }
#endif
    m_unlock();
	return hr;
}

BOOL fURLChanged(LPCTSTR url1, LPCTSTR url2)
{
    if (url1 == NULL && url2 == NULL)
        {
            return FALSE;
        }
    if ((url1 == NULL &&  url2 != NULL )
        || (url1 != NULL && url2 == NULL))
        {
            return TRUE;
        }
    return 0 != StrCmpI(url1, url2);
}

//read Policy info again and refresh state object (only care about possible admin policy change now)
//return S_FALSE if nothing changed
//return S_OK if policy changed and state successfully updated
//          *pActCode will indicate what to do
HRESULT CAUState::Refresh(enumAUPOLICYCHANGEACTION OUT *pActCode)
{
    AUPolicySettings  newsettings;
    HRESULT hr;

    if (!m_lock())
    {
    	return HRESULT_FROM_WIN32(GetLastError());
    }
    *pActCode = AUPOLICYCHANGE_NOOP;
    hr = newsettings.m_ReadIn();
    if (FAILED(hr))
        {
            goto done;
        }
    if (newsettings == m_PolicySettings)
        {
            hr = S_FALSE;
            goto done;
        }

    if (fURLChanged(newsettings.m_pszWUStatusServerURL, m_PolicySettings.m_pszWUStatusServerURL))
	{
		(void) gPingStatus.SetCorpServerUrl(newsettings.m_pszWUStatusServerURL);
	}

	if (!newsettings.m_fRegAUOptionsSpecified)
	{
		*pActCode = AUPOLICYCHANGE_NOOP;
	}
	else if ((fURLChanged(newsettings.m_pszWUServerURL, m_PolicySettings.m_pszWUServerURL) && AUSTATE_DISABLED != m_dwState)
            || (AUOPTION_AUTOUPDATE_DISABLE == m_PolicySettings.m_dwOption && newsettings.m_dwOption > m_PolicySettings.m_dwOption)
            || m_dwState < AUSTATE_DETECT_PENDING)
        { //stop client, cancel download if any, reset state to detect pending. do detect
            *pActCode = AUPOLICYCHANGE_RESETENGINE;
        }
    else if (AUOPTION_AUTOUPDATE_DISABLE == newsettings.m_dwOption && m_PolicySettings.m_dwOption != newsettings.m_dwOption)
        { //stop client, cancel download if any, set state to be disabled
            *pActCode = AUPOLICYCHANGE_DISABLE;
        }
    else if (AUSTATE_INSTALL_PENDING != m_dwState &&
            (newsettings.m_enPolicyType != m_PolicySettings.m_enPolicyType 
            ||newsettings.m_dwOption != m_PolicySettings.m_dwOption 
            ||newsettings.m_dwSchedInstallDay != m_PolicySettings.m_dwSchedInstallDay
            ||newsettings.m_dwSchedInstallTime != m_PolicySettings.m_dwSchedInstallTime))
        {
            *pActCode = AUPOLICYCHANGE_RESETCLIENT;
        }
    else
        {
            *pActCode = AUPOLICYCHANGE_NOOP;
        }
     m_PolicySettings.Copy(newsettings);
done:
#ifdef DBG
    m_DbgDumpState();
#endif
	m_unlock();
	DEBUGMSG("CAUState::Refresh() return %#lx with action code %d", hr, *pActCode);
    return hr;
}
    
            
void CAUState::m_ReadRegistrySettings(BOOL fInit)
{
        if ( FAILED(GetRegDWordValue(REG_AUSTATE, &m_dwState, enAU_AdminPolicy)) 
//        	||m_dwState < AUSTATE_MIN  //always false
        	|| m_dwState > AUSTATE_MAX)
        {
            m_dwState = AUSTATE_OUTOFBOX;
        }


        TCHAR tszDetectionStartTime[20];

        if ( fInit ||
        	 FAILED(GetRegStringValue(REG_AUDETECTIONSTARTTIME, tszDetectionStartTime,
                                      ARRAYSIZE(tszDetectionStartTime), enAU_AdminPolicy)) ||
             FAILED(String2FileTime(tszDetectionStartTime, &m_auftDetectionStartTime.ft)) )
        {
            m_auftDetectionStartTime.ull = AUFT_INVALID_VALUE;
        }

        if (!fInit)
        {
        	ResetScheduleInstallDate();
        }
        else if (AUSTATE_DOWNLOAD_COMPLETE == m_dwState)
        {
        	TCHAR szSchedInstallDate[20];

        	if ( FAILED(GetRegStringValue(REG_AUSCHEDINSTALLDATE, szSchedInstallDate,
        								  ARRAYSIZE(szSchedInstallDate), enAU_AdminPolicy)) ||
        		 FAILED(String2FileTime(szSchedInstallDate, &m_auftSchedInstallDate.ft)) )
        	{
        		ResetScheduleInstallDate();
        	}        		
        }
        else
        {//service starts and state not for install
        		ResetScheduleInstallDate();
        }
        	
    
        return;
}


void CAUState::ResetScheduleInstallDate(void)
{
//	m_lock(); //uncomment if code below needs protection against simultaneous access
	DeleteRegValue(REG_AUSCHEDINSTALLDATE);
	DeleteRegValue(REG_AURESCHED);
	m_auftSchedInstallDate.ull = AUFT_INVALID_VALUE;
//	m_unlock();
}


//=======================================================================
//  CAUState::m_fNeedReschedule 
//  decide whether need to reschedule for scheduled install. If so, how many seconds to wait from now and the new scheduleinstalldate
//  when this function is called, the assumption is that we already made sure AU is in scheduled install mode
//  if rescheuled is available, auftSchedInstallDate is the rescheduled install date and  might be in the past, now or in the future
//  pdwSleepTime stores the number of seconds to wait before the rescheduled install date
//=======================================================================
BOOL CAUState::m_fNeedReschedule(AUFILETIME &auftSchedInstallDate, DWORD *pdwSleepTime)
{
	static BOOL fLastResult = TRUE;
	static AUFILETIME auftRescheduleInstallDate = {AUFT_INVALID_VALUE};
	AUFILETIME auftNow = GetCurrentAUTime();

	auftSchedInstallDate.ull = AUFT_INVALID_VALUE;
	*pdwSleepTime = 0;
	if (AUFT_INVALID_VALUE == auftNow.ull)
	{
		fLastResult = FALSE;
		goto done;
	}
	if (!fLastResult) 
	{
		goto done; //once false, always false.
	}
	if (AUFT_INVALID_VALUE != auftRescheduleInstallDate.ull) //once evaluated to be true, always true
	{ // we already calculated before, no need to caculate again
		goto done;
	}


#ifdef DBG
	TCHAR szTime[20];
        if ( FAILED(FileTime2String(m_auftSchedInstallDate.ft, szTime, ARRAYSIZE(szTime))) )
        {
            (void)StringCchCopyEx(szTime, ARRAYSIZE(szTime), _T("invalid"), NULL, NULL, MISTSAFE_STRING_FLAGS);
        }
	DEBUGMSG("Last schedule install date: %S", szTime);
	 if ( FAILED(FileTime2String(m_auftServiceStartupTime.ft, szTime, ARRAYSIZE(szTime))) )
        {
            (void)StringCchCopyEx(szTime, ARRAYSIZE(szTime), _T("invalid"), NULL, NULL, MISTSAFE_STRING_FLAGS);
        }
	DEBUGMSG("ServiceStartupTime: %S", szTime);
	DEBUGMSG("RescheduleWaitTime: %d", m_PolicySettings.m_dwRescheduleWaitTime);
#endif

	if ( AUFT_INVALID_VALUE == m_auftServiceStartupTime.ull
		|| AUFT_INVALID_VALUE == m_auftSchedInstallDate.ull
		|| -1 == m_PolicySettings.m_dwRescheduleWaitTime)
	{
		fLastResult = FALSE;
		goto done;
	}

	DWORD dwResched = 0;
	if ( FAILED(GetRegDWordValue(REG_AURESCHED, &dwResched, enAU_AdminPolicy))
			|| 1 != dwResched )
	{
		if ( m_auftSchedInstallDate.ull >= m_auftServiceStartupTime.ull)
		{
			fLastResult = FALSE;
			goto done;
		}
	}
	
	auftRescheduleInstallDate.ull = m_auftServiceStartupTime.ull + (ULONGLONG) m_PolicySettings.m_dwRescheduleWaitTime * AU_ONE_MIN * NanoSec100PerSec; //changes to RescheduleWaitTime won't be respected
done:
	if (fLastResult)
	{
	 	auftSchedInstallDate = auftRescheduleInstallDate;
		if (auftNow.ull <= auftRescheduleInstallDate.ull)
		{
			*pdwSleepTime = (DWORD) ((auftRescheduleInstallDate.ull - auftNow.ull)  / NanoSec100PerSec) ;
		}
	}

	return fLastResult;
}
	

//=======================================================================
// this NoAutoRebootWithLoggedOnUsers reg value will be read only once in a cycle
// if fReset is TRUE, cached value will be cleared and registry will be read again next time this function is called
//=======================================================================
BOOL CAUState::m_fNoAutoRebootWithLoggedOnUsers(BOOL fReset)
{
        static DWORD dwNoAutoReboot = 0;
        static BOOL fInited = FALSE;
        if (fReset) 
        {
            fInited = FALSE;
            return FALSE;
        }
        if (!fInited)
        {
            fInited = TRUE;
            (void)GetRegDWordValue(REG_AUNOAUTOREBOOTWITHLOGGEDONUSERS, &dwNoAutoReboot, enAU_DomainPolicy);
        }
	return 1 == dwNoAutoReboot;
}


//=======================================================================
//  CAUState::m_ReadPolicy
//  read in registry settings
//=======================================================================
HRESULT CAUState::m_ReadPolicy(BOOL fInit)
{
    return  m_PolicySettings.m_ReadIn();
}

HRESULT  AUPolicySettings::m_ReadIn()
{
    HRESULT hr = m_ReadWUServerURL();

	if (SUCCEEDED(hr))
	{
		m_enPolicyType = enAU_DomainPolicy;
	 	for (int i = 0; i < 2; i++)
		{
			if ( FAILED(hr = m_ReadOptionPolicy()) ||
				 FAILED(hr = m_ReadScheduledInstallPolicy()) )
			{
				 m_enPolicyType = enAU_AdminPolicy;
				 continue;
			}
			break;
		}
	}

    DEBUGMSG("ReadPolicy: %d, hr = %#lx", m_enPolicyType, hr);
    return hr;
}

//=======================================================================
//  CAUState::m_ReadOptionPolicy
//  return S_FALSE if default option is returned 
//=======================================================================
HRESULT AUPolicySettings::m_ReadOptionPolicy(void)
{
    HRESULT hr = E_INVALIDARG;

	//  reading admin policy will always return success
    if ( enAU_DomainPolicy == m_enPolicyType )
    {
        // check if disabled by the NoAutoUpdate key
        if ( SUCCEEDED(CAUState::GetRegDWordValue(REG_AUNOAUTOUPDATE, &(m_dwOption), m_enPolicyType)) &&
             (AUOPTION_AUTOUPDATE_DISABLE == m_dwOption) )
        {
            hr = S_OK;
        }

        if (FAILED(CAUState::GetRegDWordValue(REG_AURESCHEDWAITTIME, &m_dwRescheduleWaitTime, m_enPolicyType)) 
	        	|| m_dwRescheduleWaitTime < MIN_RESCHEDULE_WAIT_TIME
	        	|| m_dwRescheduleWaitTime > MAX_RESCHEDULE_WAIT_TIME)
        {
        	m_dwRescheduleWaitTime  = -1;
        }

    }

    if ( FAILED(hr) &&
            (FAILED(hr = CAUState::GetRegDWordValue(REG_AUOPTIONS, &(m_dwOption), m_enPolicyType)) ||
            (m_dwOption > AUOPTION_MAX) ||
            ((enAU_AdminPolicy == m_enPolicyType) && (m_dwOption < AUOPTION_ADMIN_MIN)) ||
            ((enAU_DomainPolicy == m_enPolicyType) && (m_dwOption < AUOPTION_DOMAIN_MIN))) )
    {
        if ( enAU_AdminPolicy == m_enPolicyType )
        {
           DEBUGMSG("bad admin option policy, defaulting to AUOPTION_INSTALLONLY_NOTIFY");
           m_fRegAUOptionsSpecified = (AUOPTION_UNSPECIFIED != m_dwOption);
           m_dwOption = AUOPTION_INSTALLONLY_NOTIFY;
           hr = S_FALSE; 
        }
        else
        {
           DEBUGMSG("invalid domain option policy");
           hr = E_INVALIDARG;
        }
    }

    DEBUGMSG("ReadOptionPolicy: type = %d, hr = %#lx", m_enPolicyType, hr);

    return hr;
}


//=======================================================================
//  CAUState::m_ReadScheduledInstallPolicy
//=======================================================================
HRESULT AUPolicySettings::m_ReadScheduledInstallPolicy()
{
    const DWORD DEFAULT_SCHED_INSTALL_DAY = 0;
    const DWORD DEFAULT_SCHED_INSTALL_TIME = 3;

    HRESULT hr = S_OK;

    if ( AUOPTION_SCHEDULED != m_dwOption )
    {
        m_dwSchedInstallDay = DEFAULT_SCHED_INSTALL_DAY;
        m_dwSchedInstallTime = DEFAULT_SCHED_INSTALL_TIME;
    }
    else
    {
        if ( FAILED(CAUState::GetRegDWordValue(REG_AUSCHEDINSTALLDAY, &m_dwSchedInstallDay, m_enPolicyType)) ||
             (m_dwSchedInstallDay > AUSCHEDINSTALLDAY_MAX) )
        {
            DEBUGMSG("invalid SchedInstallDay policy");
            if ( enAU_DomainPolicy == m_enPolicyType )
            {
                hr = E_INVALIDARG;
                goto done;
            }
            m_dwSchedInstallDay = DEFAULT_SCHED_INSTALL_DAY;
        }
        
        if ( FAILED(CAUState::GetRegDWordValue(REG_AUSCHEDINSTALLTIME, &m_dwSchedInstallTime, m_enPolicyType)) ||
             (m_dwSchedInstallTime > AUSCHEDINSTALLTIME_MAX) )
        {
            DEBUGMSG("invalid SchedInstallTime policy");
            if ( enAU_DomainPolicy == m_enPolicyType )
            {
                hr = E_INVALIDARG;
                goto done;
            }
            m_dwSchedInstallTime = DEFAULT_SCHED_INSTALL_TIME;
        }

    }
done:
    return hr;
}

//=======================================================================
//  CAUState::m_ReadWUServerURL
//  only error returned is E_OUTOFMEMORY
//=======================================================================
HRESULT AUPolicySettings::m_ReadWUServerURL(void)
{
    HRESULT hr = S_OK;
    
    LPTSTR *purls[2] = { &m_pszWUServerURL, &m_pszWUStatusServerURL};
    LPCTSTR RegStrs[2] = {REG_WUSERVER_URL, REG_WUSTATUSSERVER_URL};
    
    for (int i = 0 ; i < ARRAYSIZE(purls); i++)
    {
        DWORD dwBytes = INTERNET_MAX_URL_LENGTH * sizeof((*purls[i])[0]);

        if ( (NULL == *purls[i]) &&
             (NULL == (*purls[i] = (LPTSTR)malloc(dwBytes))) )
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }

        hr = CAUState::GetRegStringValue(RegStrs[i], *purls[i],
                               dwBytes/sizeof((*purls[i])[0]), enAU_WindowsUpdatePolicy);

        if ( FAILED(hr) )
        {
            DEBUGMSG("invalid key %S; resetting both corp WU server URLs", RegStrs[i]);
            goto done;
        }
    }

done:
    if (FAILED(hr))
    {
        SafeFreeNULL(m_pszWUServerURL);
        SafeFreeNULL(m_pszWUStatusServerURL);

		if (E_OUTOFMEMORY != hr)
		{
			hr = S_OK;
		}
    }
        
    return hr;
}

HRESULT AUPolicySettings::m_SetInstallSchedule(DWORD dwSchedInstallDay, DWORD dwSchedInstallTime)
{
    HRESULT hr;
    if (enAU_DomainPolicy == m_enPolicyType)
        {
            return E_ACCESSDENIED; //if domain policy in force, option can not be changed
        }
    if (/*dwSchedInstallDay < AUSCHEDINSTALLDAY_MIN ||*/ dwSchedInstallDay > AUSCHEDINSTALLDAY_MAX 
        /*|| dwSchedInstallTime < AUSCHEDINSTALLTIME_MIN*/ || dwSchedInstallTime > AUSCHEDINSTALLTIME_MAX)
        {
        return E_INVALIDARG;
        }

    if (SUCCEEDED(hr = CAUState::SetRegDWordValue(REG_AUSCHEDINSTALLDAY, dwSchedInstallDay))
         && SUCCEEDED(hr = CAUState::SetRegDWordValue(REG_AUSCHEDINSTALLTIME, dwSchedInstallTime)))
        {
          m_dwSchedInstallDay = dwSchedInstallDay;
          m_dwSchedInstallTime = dwSchedInstallTime;
        }
    else
        { //roll back
        CAUState::SetRegDWordValue(REG_AUSCHEDINSTALLDAY, m_dwSchedInstallDay);
        CAUState::SetRegDWordValue(REG_AUSCHEDINSTALLTIME,m_dwSchedInstallTime);
        }
    return hr;
}

HRESULT AUPolicySettings::m_SetOption(AUOPTION & Option)
{
    HRESULT hr;
    if ( (Option.dwOption < AUOPTION_ADMIN_MIN) || (Option.dwOption > AUOPTION_MAX) )
    {
        return E_INVALIDARG;
    }

    if (enAU_DomainPolicy == m_enPolicyType)
    {
        return E_ACCESSDENIED; //if domain policy in force, option can not be changed
    }

    if (SUCCEEDED(hr = CAUState::SetRegDWordValue(REG_AUOPTIONS, Option.dwOption)))
    {
        m_dwOption = Option.dwOption;
    }
    else 
    {
	goto done;
    }

    if (AUOPTION_SCHEDULED == Option.dwOption)
        {
            hr = m_SetInstallSchedule(Option.dwSchedInstallDay, Option.dwSchedInstallTime);
        }

done:
    return hr;
}


//=======================================================================
//  CAUState::m_ReadTestOverrides
//=======================================================================
HRESULT CAUState::m_ReadTestOverrides(void)
{
    HRESULT hr = S_OK;
    DWORD dwBytes = 0;

#ifdef DBG
    dwBytes = INTERNET_MAX_URL_LENGTH * sizeof(m_pszTestSelfUpdateURL[0]);
    if ( (NULL == m_pszTestSelfUpdateURL) &&
         (NULL == (m_pszTestSelfUpdateURL = (LPTSTR)malloc(dwBytes))) )
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    if ( FAILED(GetRegStringValue(REG_SELFUPDATE_URL, m_pszTestSelfUpdateURL,
                                   dwBytes/sizeof(m_pszTestSelfUpdateURL[0]), enAU_AdminPolicy)) )
    {
        SafeFreeNULL(m_pszTestSelfUpdateURL);
    }
#endif

    dwBytes = INTERNET_MAX_URL_LENGTH * sizeof(m_pszTestIdentServerURL[0]);

    if ( (NULL == m_pszTestIdentServerURL) &&
         (NULL == (m_pszTestIdentServerURL = (LPTSTR)malloc(dwBytes))) )
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    if ( FAILED(GetRegStringValue(REG_IDENT_URL, m_pszTestIdentServerURL,
                                   dwBytes/sizeof(m_pszTestIdentServerURL[0]), enAU_IUControlPolicy)) )
    {
        SafeFreeNULL(m_pszTestIdentServerURL);
    }

done:
    return hr;
}


//=======================================================================
//  CAUState::m_SetScheduledInstallDate
//   returns
//    S_OK - there was no need to change the scheduled install date
//    other - error code
//=======================================================================
HRESULT CAUState::m_SetScheduledInstallDate(BOOL fReschedule)
{
    // fixcode need to put new scheduled time in event log
    HRESULT hr = S_OK;	// assume scheduled install date unchanged
    TCHAR szSchedInstallDate[20];

	if (SUCCEEDED(hr = FileTime2String(m_auftSchedInstallDate.ft, szSchedInstallDate, ARRAYSIZE(szSchedInstallDate))))
	{
//		DEBUGMSG("New scheduled install date: %S", szSchedInstallDate);
		if (FAILED(hr = SetRegStringValue(REG_AUSCHEDINSTALLDATE, szSchedInstallDate, enAU_AdminPolicy)))
		{
			goto done;
		}
	}
	else
	{
		DEBUGMSG("failed m_SetScheduledInstallDate() == %#lx", hr);
		goto done;
	}
	if (fReschedule)
	{
		if (FAILED(hr = SetRegDWordValue(REG_AURESCHED, 1, enAU_AdminPolicy)))
		{
			goto done;
		}
	}
	else
	{
		DeleteRegValue(REG_AURESCHED);
	}
		
done:
	return hr;
}


AUOPTION CAUState::GetOption(void)
{
    AUOPTION opt;
    BOOL fLocked = m_lock();
    opt.dwOption = m_PolicySettings.m_dwOption;
    opt.dwSchedInstallDay = m_PolicySettings.m_dwSchedInstallDay;
    opt.dwSchedInstallTime = m_PolicySettings.m_dwSchedInstallTime;
    opt.fDomainPolicy = (enAU_DomainPolicy == m_PolicySettings.m_enPolicyType);
    if (fLocked) 
    	m_unlock();
    return opt;
}

//=======================================================================
//  CAUState::SetOption
// option.fDomainPolicy is irrelevant. Not settable
//=======================================================================
HRESULT CAUState::SetOption(AUOPTION & Option)
{
    HRESULT hr;
    
    if (!m_lock())
    {
    	return HRESULT_FROM_WIN32(GetLastError());
    }
    hr = m_PolicySettings.m_SetOption(Option);
    m_unlock();
    return hr;
}

HRESULT CAUState::SetInstallSchedule(DWORD dwSchedInstallDay, DWORD dwSchedInstallTime)
{
    HRESULT hr;

    if (!m_lock())
    {
    	return HRESULT_FROM_WIN32(GetLastError());
    }
    hr = m_PolicySettings.m_SetInstallSchedule(dwSchedInstallDay, dwSchedInstallTime);
    m_unlock();
    return hr;
}




//=======================================================================
// CAUState::SetState
// it could also be called to kick state event in both engine and client
// even if no state change is involved
//=======================================================================
void CAUState::SetState(DWORD dwState)
{
    if (!m_lock())
    {
    	return ;
    }

    if ( m_dwState != dwState )
    {
	    m_dwState = dwState;		
	    SetRegDWordValue(REG_AUSTATE, dwState);
		DEBUGMSG("WUAUENG SetState Event, state = %d", dwState);
    }
    else
    {
        DEBUGMSG("kick state event in client and engine with state %d", dwState);
    }

    if (AUSTATE_WAITING_FOR_REBOOT == dwState)
    {
        	gpState->LeaveRebootWarningMode();
    }
    SetEvent(ghEngineState);
    ghClientHandles.ClientStateChange();
    m_unlock();
}    

void CAUState::GetInstallSchedule(DWORD *pdwSchedInstallDay, DWORD *pdwSchedInstallTime)
{
	BOOL fLocked = m_lock();
    *pdwSchedInstallDay = m_PolicySettings.m_dwSchedInstallDay;
    *pdwSchedInstallTime = m_PolicySettings.m_dwSchedInstallTime;
    if (fLocked)
    	m_unlock();
}


//=======================================================================
// CAUState::fWasSystemRestored
//
// Determine if system was restored.
//=======================================================================
BOOL CAUState::fWasSystemRestored(void)
{
	if ( fIsPersonalOrProfessional() &&
		 fRegKeyExists(AUREGKEY_HKLM_SYSTEM_WAS_RESTORED) )
	{
    	fRegKeyDelete(AUREGKEY_HKLM_SYSTEM_WAS_RESTORED);
		return TRUE;
	}

	return FALSE;
}

void CAUState::SetDisconnected(BOOL fDisconnected)
{
	if (!m_lock())
    {
    	return ;
    }
	m_fDisconnected = fDisconnected;		
	m_unlock();
}

//=======================================================================
// CAUState::GetRegDWordValue
//=======================================================================
HRESULT CAUState::GetRegDWordValue(LPCTSTR lpszValueName, LPDWORD pdwValue, enumAUPolicyType enPolicyType)
{
    if (lpszValueName == NULL)
    {
        return E_INVALIDARG;
    }

  	return ::GetRegDWordValue(lpszValueName, pdwValue, 
		                    (enAU_DomainPolicy == enPolicyType) ? AUREGKEY_HKLM_DOMAIN_POLICY : AUREGKEY_HKLM_ADMIN_POLICY);
}


//=======================================================================
// CAUState::SetRegDWordValue
//=======================================================================
HRESULT CAUState::SetRegDWordValue(LPCTSTR lpszValueName, DWORD dwValue, enumAUPolicyType enPolicyType, DWORD options)
{
    if (lpszValueName == NULL)
    {
        return E_INVALIDARG;
    }

   return ::SetRegDWordValue(lpszValueName, dwValue, options, 
    	(enAU_DomainPolicy == enPolicyType) ? AUREGKEY_HKLM_DOMAIN_POLICY : AUREGKEY_HKLM_ADMIN_POLICY);
}

//=======================================================================
// CAUState::GetRegStringValue
//=======================================================================
HRESULT CAUState::GetRegStringValue(LPCTSTR lpszValueName, LPTSTR lpszBuffer, int nCharCount, enumAUPolicyType enPolicyType)
{
    LPCTSTR  pszSubKey; 


    if (lpszValueName == NULL || lpszBuffer == NULL)
    {
        return E_INVALIDARG;
    }

    switch (enPolicyType)
    {
    case enAU_DomainPolicy:          pszSubKey = AUREGKEY_HKLM_DOMAIN_POLICY; break;
    case enAU_AdminPolicy:           pszSubKey = AUREGKEY_HKLM_ADMIN_POLICY; break;
    case enAU_WindowsUpdatePolicy:   pszSubKey = AUREGKEY_HKLM_WINDOWSUPDATE_POLICY; break;
    case enAU_IUControlPolicy:       pszSubKey = AUREGKEY_HKLM_IUCONTROL_POLICY; break;
    default:                         return E_INVALIDARG;
    }

   return ::GetRegStringValue(lpszValueName, lpszBuffer, nCharCount, pszSubKey);
}


//=======================================================================
// CAUState::SetRegStringValue
//=======================================================================
HRESULT CAUState::SetRegStringValue(LPCTSTR lpszValueName, LPCTSTR lpszNewValue, enumAUPolicyType enPolicyType)
{
    HKEY        hKey;
    HRESULT     hRet = E_FAIL;
    DWORD       dwResult;
    
    if (lpszValueName == NULL || lpszNewValue == NULL)
    {
        return E_INVALIDARG;
    }

   
	return ::SetRegStringValue(lpszValueName, lpszNewValue, 
		(enAU_DomainPolicy == enPolicyType) ? AUREGKEY_HKLM_DOMAIN_POLICY : AUREGKEY_HKLM_ADMIN_POLICY);
}

//=======================================================================
//  Calculate Scheduled Date
//=======================================================================
HRESULT CAUState::m_CalculateScheduledInstallDate(AUFILETIME & auftSchedInstallDate,
                                             DWORD *pdwSleepTime)
{
    auftSchedInstallDate.ull = AUFT_INVALID_VALUE;
    *pdwSleepTime = 0;
    
    if ( (-1 == m_PolicySettings.m_dwSchedInstallDay) || (-1 == m_PolicySettings.m_dwSchedInstallTime) )
    {
        return E_INVALIDARG;
    }

    //DEBUGMSG("Schedule day: %d, time: %d", m_dwSchedInstallDay, m_dwSchedInstallTime);

    AUFILETIME auftNow;
    SYSTEMTIME stNow;
    GetLocalTime(&stNow);

    if ( !SystemTimeToFileTime(&stNow, &auftNow.ft) )
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    SYSTEMTIME stScheduled = stNow;
    stScheduled.wHour = (WORD)m_PolicySettings.m_dwSchedInstallTime;
    stScheduled.wMinute = stScheduled.wSecond = stScheduled.wMilliseconds = 0;

    DWORD dwSchedInstallDayOfWeek = (0 == m_PolicySettings.m_dwSchedInstallDay) ? stNow.wDayOfWeek : (m_PolicySettings.m_dwSchedInstallDay - 1);
    DWORD dwDaysToAdd = (7 + dwSchedInstallDayOfWeek - stNow.wDayOfWeek) % 7;

    //DEBUGMSG("daystoadd %d", dwDaysToAdd);

    AUFILETIME auftScheduled;

    if ( !SystemTimeToFileTime(&stScheduled, &auftScheduled.ft) )
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    auftScheduled.ull += (ULONGLONG)dwDaysToAdd * AU_ONE_DAY * NanoSec100PerSec;

    if ( auftScheduled.ull < auftNow.ull )
    {
        // we missed the time today, go to next scheduled day
        auftScheduled.ull += (ULONGLONG)((0 == m_PolicySettings.m_dwSchedInstallDay) ? AU_ONE_DAY : AU_ONE_WEEK) * NanoSec100PerSec;
    }

    auftSchedInstallDate = auftScheduled;

    *pdwSleepTime = (DWORD)((auftScheduled.ull - auftNow.ull) / NanoSec100PerSec);

    return S_OK;
}


//=======================================================================
//  CAUState::CalculateScheduledInstallSleepTime
//=======================================================================
HRESULT CAUState::CalculateScheduledInstallSleepTime(DWORD *pdwSleepTime)
{
    HRESULT hr = S_OK;
    DWORD dwReschedSleepTime = 0;
    DWORD dwSchedSleepTime = 0;

    *pdwSleepTime = 0;

   if (!m_lock())
   {
   	return HRESULT_FROM_WIN32(GetLastError());
   }

    AUFILETIME auftSchedInstallDate;
    AUFILETIME auftReschedInstallDate;
   if (m_fNeedReschedule(auftReschedInstallDate, &dwReschedSleepTime))
   {
   	DEBUGMSG("Reschedule available");
   }
   else
   {
   	m_fReschedPrivileged = FALSE;
   	DEBUGMSG("Reschedule not available");
   }
  if (FAILED(hr = m_CalculateScheduledInstallDate(auftSchedInstallDate, &dwSchedSleepTime)))
  {
  	DEBUGMSG("Fail to calculate schedule install date with error %#lx", hr);
  }

   AUFILETIME auftNewSchedInstallDate;
   if (!m_fReschedPrivileged)
   {
   	auftNewSchedInstallDate.ull = auftSchedInstallDate.ull;
   	*pdwSleepTime = dwSchedSleepTime;
   }
   else 
   {
      	auftNewSchedInstallDate=auftReschedInstallDate.ull < auftSchedInstallDate.ull ? auftReschedInstallDate : auftSchedInstallDate;
   	*pdwSleepTime = auftReschedInstallDate.ull < auftSchedInstallDate.ull ? dwReschedSleepTime : dwSchedSleepTime;
   }
   
   
   if (m_auftSchedInstallDate.ull != auftNewSchedInstallDate.ull)
   {     //persist new schedule install date if anything changes
#ifdef DBG
	   TCHAR szTime[20];
	  if ( FAILED(FileTime2String(auftReschedInstallDate.ft, szTime, ARRAYSIZE(szTime))) )
	       {
	           (void)StringCchCopyEx(szTime, ARRAYSIZE(szTime), _T("invalid"), NULL, NULL, MISTSAFE_STRING_FLAGS);
	       }
	   DEBUGMSG("Reschedule install date: %S", szTime);
	   if ( FAILED(FileTime2String(auftSchedInstallDate.ft, szTime, ARRAYSIZE(szTime))) )
	       {
	           (void)StringCchCopyEx(szTime, ARRAYSIZE(szTime), _T("invalid"), NULL, NULL, MISTSAFE_STRING_FLAGS);
	       }
	   DEBUGMSG("Schedule install date: %S", szTime);

	    if ( FAILED(FileTime2String(m_auftSchedInstallDate.ft, szTime, ARRAYSIZE(szTime))) )
	       {
	           (void)StringCchCopyEx(szTime, ARRAYSIZE(szTime), _T("invalid"), NULL, NULL, MISTSAFE_STRING_FLAGS);
	       }
	   DEBUGMSG("previous install date: %S", szTime);
	    if ( FAILED(FileTime2String(auftNewSchedInstallDate.ft, szTime, ARRAYSIZE(szTime))) )
	       {
	           (void)StringCchCopyEx(szTime, ARRAYSIZE(szTime), _T("invalid"), NULL, NULL, MISTSAFE_STRING_FLAGS);
	       }
	   DEBUGMSG("Updated install date: %S", szTime);
#endif		
   
   	m_auftSchedInstallDate = auftNewSchedInstallDate;
   	m_SetScheduledInstallDate(auftNewSchedInstallDate.ull != auftSchedInstallDate.ull);
	hr = S_FALSE;
   }

//    DEBUGMSG("CalculateScheduleInstallSleepTime return %d sleeping secs with result %#lx", *pdwSleepTime, hr);
	m_unlock();
    return hr;
}

//=======================================================================
//  CAUState::SetDetectionStartTime
//=======================================================================
void CAUState::SetDetectionStartTime(BOOL fOverwrite)
{
	if (!m_lock())
    {
    	return ;
    }

	if (fOverwrite || AUFT_INVALID_VALUE == m_auftDetectionStartTime.ull)
	{
		AUFILETIME auftNow = GetCurrentAUTime();
    
		if (AUFT_INVALID_VALUE != auftNow.ull)
		{
			HRESULT hr;
			TCHAR tszDetectionStartTime[20];

			if (SUCCEEDED(hr = FileTime2String(auftNow.ft, tszDetectionStartTime, ARRAYSIZE(tszDetectionStartTime))))
			{
				m_auftDetectionStartTime = auftNow;
				DEBUGMSG("New last connection check time: %S", tszDetectionStartTime);
				SetRegStringValue(REG_AUDETECTIONSTARTTIME, tszDetectionStartTime, enAU_AdminPolicy);
			}
			else
			{
				DEBUGMSG("failed m_SetScheduledInstallDate() == %#lx", hr);
			}
		}
	}
	else
	{
		DEBUGMSG("CAUState::SetDetectionStartTime() fOverwrite==FALSE, time(%#lx%8lx) != AUFT_INVALID_VALUE.", m_auftDetectionStartTime.ft.dwHighDateTime, m_auftDetectionStartTime.ft.dwLowDateTime);
	}
	m_unlock();
}

//=======================================================================
//  CAUState::IsUnableToConnect
//=======================================================================
BOOL CAUState::IsUnableToConnect(void)
{
	AUFILETIME auftNow = GetCurrentAUTime();

	if (AUFT_INVALID_VALUE == auftNow.ull)
	{
		return FALSE;	//REVIEW: or return TRUE?
	}

	if (!m_lock())
    {
    	return FALSE;
    }

	BOOL fRet = FALSE;
	if (AUFT_INVALID_VALUE != m_auftDetectionStartTime.ull &&
		(auftNow.ull - m_auftDetectionStartTime.ull) / NanoSec100PerSec >= dwSecsToWait(AU_TWO_DAYS))
	{
		fRet = TRUE;
	}
	m_unlock();
	return fRet;
}

//=======================================================================
//  CAUState::RemoveDetectionStartTime
//=======================================================================
void CAUState::RemoveDetectionStartTime(void)
{
	if (!m_lock())
    {
    	return ;
    }
	DeleteRegValue(REG_AUDETECTIONSTARTTIME);
	m_auftDetectionStartTime.ull = AUFT_INVALID_VALUE;
	m_unlock();
}

#ifdef DBG
//=======================================================================
//  CAUState::m_DbgDumpState
//=======================================================================
void CAUState::m_DbgDumpState(void)
{
    DEBUGMSG("======= Initial State Dump =========");
    m_PolicySettings.m_DbgDump();
    DEBUGMSG("State: %d", m_dwState);

    TCHAR szSchedInstallDate[20];

    if ( 0 == m_auftSchedInstallDate.ull )
    {
        (void)StringCchCopyEx(szSchedInstallDate, ARRAYSIZE(szSchedInstallDate), _T("none"), NULL, NULL, MISTSAFE_STRING_FLAGS);
    }
    else
    {
        if ( FAILED(FileTime2String(m_auftSchedInstallDate.ft, szSchedInstallDate, ARRAYSIZE(szSchedInstallDate))) )
        {
            (void)StringCchCopyEx(szSchedInstallDate, ARRAYSIZE(szSchedInstallDate), _T("invalid"), NULL, NULL, MISTSAFE_STRING_FLAGS);
        }
    }
    DEBUGMSG("ScheduledInstallDate: %S", szSchedInstallDate);
    //DEBUGMSG("WUServer Value: %S", gpState->GetWUServerURL());
    DEBUGMSG("Ident Server: %S", gpState->GetIdentServerURL());
    DEBUGMSG("Self Update Server URL Override: %S", (NULL != gpState->GetSelfUpdateServerURLOverride()) ? gpState->GetSelfUpdateServerURLOverride() : _T("none"));

    DEBUGMSG("=====================================");
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\wuaueng\cauwait.h ===
//=======================================================================
//
//  Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:    CAUWait.h
//
//  Creator: PeterWi
//
//  Purpose: Event waiting management.
//
//=======================================================================

#pragma once
#include "pch.h"

//handle event number should be consecutive and 
// range from AU_HANDLE_EVENT_MIN to AU_HANDLE_EVENT_MAX
typedef enum tagAUEVENT {
	AU_HANDLE_EVENT_MIN = 0,
	AUEVENT_STATE_CHANGED     = AU_HANDLE_EVENT_MIN,
	AUEVENT_SERVICE_FINISHED,
	AUEVENT_NEW_CLIENT_SESSION   ,
	AUEVENT_WUAUCLT_FINISHED    ,
	AUEVENT_POLICY_CHANGE,
	AUEVENT_SETTINGS_CHANGE,
	AUEVENT_CATALOG_VALIDATED,
	AU_HANDLE_EVENT_MAX = AUEVENT_CATALOG_VALIDATED,
	AUEVENT_DUMMY,
	AUEVENT_REMINDER_TIMEOUT    ,
	AUEVENT_DO_DIRECTIVE,  		//skip wait once
	AUEVENT_RELAUNCH_TIMEOUT    ,
	AUEVENT_SCHEDULED_INSTALL,
	AUEVENT_REBOOTWARNING_TIMEOUT
} AUEVENT;
extern HANDLE ghClientSession;
extern HANDLE ghPolicyChanged;
extern HANDLE ghSettingsChanged;

//=======================================================================
// CAUState
//=======================================================================
class CAUWait
{
public:
    CAUWait() :m_pfSecondaryCltsIsInteresting(NULL), m_phSecondaryClts(NULL){ Reset(); }
    ~CAUWait() 
    {
    	Reset();
    }

    void Reset(void)
    {
//    	DEBUGMSG("CAUWait Reset() called");
		m_fFirstClientIsInteresting = TRUE;
        m_dwSecondaryClts= 0;
        m_timeoutID = AUEVENT_DUMMY;
        m_fProrateTimeout = TRUE;
        m_fSkipWaitOnce = FALSE;
        SafeFreeNULL(m_pfSecondaryCltsIsInteresting);
        SafeFreeNULL(m_phSecondaryClts);
        ZeroMemory(&m_hEventHandles, sizeof(m_hEventHandles));
        ZeroMemory(&m_stTimeout, sizeof(m_stTimeout));
        m_Add(AUEVENT_STATE_CHANGED);
        m_Add(AUEVENT_SERVICE_FINISHED);
        m_Add(AUEVENT_POLICY_CHANGE);
        m_Add(AUEVENT_SETTINGS_CHANGE);
    }

    BOOL  Add(AUEVENT eventID, HANDLE hEvent = NULL, BOOL fCltIsInteresting = FALSE)
    {
		if (AUEVENT_DO_DIRECTIVE == eventID)
		{
			m_fSkipWaitOnce = TRUE;
			return TRUE;
		}
       	return m_Add(eventID, hEvent, fCltIsInteresting);
    }

    void Timeout(AUEVENT eventID, DWORD dwTimeout, BOOL fProrate = TRUE)
    {
        m_timeoutID = eventID;
        GetSystemTime(&m_stTimeout);
        TimeAddSeconds(m_stTimeout, dwTimeout, &m_stTimeout);
        m_fProrateTimeout = fProrate;
#if 0        
#ifdef DBG
		TCHAR szTime[50];
		if (SUCCEEDED(SystemTime2String(m_stTimeout, szTime, ARRAYSIZE(szTime))))
		{
			DEBUGMSG("next time out time is %S", szTime);
		}
#endif
#endif
    }

   AUEVENT GetTimeoutEvent(void) 
   	{
   	return m_timeoutID;
   	}

   DWORD GetTimeoutValue(void)
   {
   	SYSTEMTIME stCur;
   	GetSystemTime(&stCur);
	return max(TimeDiff(stCur, m_stTimeout), 0);
   }

   BOOL fWaitOnEvent(AUEVENT event)
   {
   	if (event <= AU_HANDLE_EVENT_MAX && event >= AU_HANDLE_EVENT_MIN)
   	{
   		return m_hEventHandles[event] != NULL;
   	}
   	//only TIMEOUT event is possible here
   	return m_timeoutID == event;
   }
   
    BOOL Wait(HANDLE *pHandle, BOOL *pfInterestingClt, AUEVENT *pfEventId)
    {
    	DWORD dwTimeout;
    	BOOL fRet = TRUE;
    	AUASSERT(pHandle != NULL);
    	AUASSERT(pfInterestingClt != NULL);
    	AUASSERT(NULL != pfEventId);
    	*pHandle = NULL;
    	*pfInterestingClt = FALSE;
    	*pfEventId = AUEVENT_DUMMY;
    	if (m_fSkipWaitOnce)
    	{
    		m_fSkipWaitOnce = FALSE;
    		*pfEventId = AUEVENT_DO_DIRECTIVE;
    		return TRUE;
    	}
		if (AUEVENT_DUMMY == m_timeoutID)
		{
			dwTimeout = INFINITE;
		}
		else
		{
			SYSTEMTIME stCur;
			GetSystemTime(&stCur);
			dwTimeout = max(TimeDiff(stCur, m_stTimeout), 0);
			dwTimeout = m_fProrateTimeout ? dwTimeToWait(dwTimeout): dwTimeout * 1000;
//			DEBUGMSG("Wait() timeout value is %d msecs", dwTimeout);
		}

		HANDLE *phandles = NULL;
		DWORD dwCount = 0;
		HandleList(FALSE, &phandles, &dwCount); //get handle list
		AUASSERT(dwCount > 0);	
		AUASSERT(NULL != phandles);
		AUEVENT eventid = AUEVENT_DUMMY;
        DWORD dwRet = WaitForMultipleObjects(dwCount, phandles, FALSE, dwTimeout);
        if ( (WAIT_OBJECT_0 + dwCount - 1) >= dwRet )
        {
            *pHandle = phandles[dwRet - WAIT_OBJECT_0];
            eventid = GetEventID(*pHandle);
            if (AUEVENT_WUAUCLT_FINISHED == eventid)
            {
            	*pfInterestingClt = fIsCltInteresting(*pHandle);
            	DEBUGMSG("%s wuauclt exited", *pfInterestingClt? "Interesting" : "Boring");
            }
			RemoveHandle(eventid, *pHandle);
        }
        else if ( WAIT_TIMEOUT == dwRet )
        {
            eventid = m_timeoutID;
	        m_timeoutID = AUEVENT_DUMMY;
        }
        else
        {
        	fRet = FALSE;
        }
   		HandleList(TRUE, &phandles); //free handle list if allocated
        	
#ifdef DBG
	char buf[100];
	    switch (eventid)
	        {
	        case AUEVENT_STATE_CHANGED: StringCchCopyExA(buf, ARRAYSIZE(buf), "state change", NULL, NULL, MISTSAFE_STRING_FLAGS); break;
	        case AUEVENT_POLICY_CHANGE: StringCchCopyExA(buf, ARRAYSIZE(buf), "policy change", NULL, NULL, MISTSAFE_STRING_FLAGS); break;
	        case AUEVENT_RELAUNCH_TIMEOUT: StringCchCopyExA(buf, ARRAYSIZE(buf), "relaunch timeout", NULL, NULL, MISTSAFE_STRING_FLAGS); break;
	        case AUEVENT_REMINDER_TIMEOUT: StringCchCopyExA(buf, ARRAYSIZE(buf), "reminder timeout", NULL, NULL, MISTSAFE_STRING_FLAGS); break;
	        case AUEVENT_SCHEDULED_INSTALL: StringCchCopyExA(buf, ARRAYSIZE(buf), "schedule install", NULL, NULL, MISTSAFE_STRING_FLAGS); break;
	        case AUEVENT_WUAUCLT_FINISHED: StringCchCopyExA(buf, ARRAYSIZE(buf), "wuauclt finished", NULL, NULL, MISTSAFE_STRING_FLAGS); break;
	        case AUEVENT_SERVICE_FINISHED: StringCchCopyExA(buf, ARRAYSIZE(buf), "service finished", NULL, NULL, MISTSAFE_STRING_FLAGS);break;
	        case AUEVENT_NEW_CLIENT_SESSION: StringCchCopyExA(buf, ARRAYSIZE(buf), "new client session", NULL, NULL, MISTSAFE_STRING_FLAGS); break;
	        case AUEVENT_SETTINGS_CHANGE: StringCchCopyExA(buf, ARRAYSIZE(buf), "settings changed", NULL, NULL, MISTSAFE_STRING_FLAGS); break;
	        case AUEVENT_DO_DIRECTIVE: StringCchCopyExA(buf, ARRAYSIZE(buf), "doing directive, skip wait once", NULL, NULL, MISTSAFE_STRING_FLAGS); break;
	        case AUEVENT_CATALOG_VALIDATED: StringCchCopyExA(buf, ARRAYSIZE(buf), "catalog validation done", NULL, NULL, MISTSAFE_STRING_FLAGS); break;
	        case AUEVENT_REBOOTWARNING_TIMEOUT: StringCchCopyExA(buf, ARRAYSIZE(buf), "reboot warning engine timeout", NULL, NULL, MISTSAFE_STRING_FLAGS);break;
	        default: StringCchCopyExA(buf, ARRAYSIZE(buf), "error", NULL, NULL, MISTSAFE_STRING_FLAGS);
	        }
	    DEBUGMSG("Wait object wake up for %s with handle %lx", buf, *pHandle);
#endif
		*pfEventId = eventid;
        return fRet;
    }

private:
	//assumption: handle is unique in the list
    BOOL m_Add(AUEVENT eventID, HANDLE hEvent = NULL, BOOL fCltIsInteresting = FALSE)
    {
    	if (eventID >= ARRAYSIZE(m_hEventHandles))
    	{
    		AUASSERT(FALSE); //should never be
    		return FALSE;
    	}
        if ( NULL != hEvent )
        {
        	if (AUEVENT_WUAUCLT_FINISHED != eventID)
        	{
        		m_hEventHandles[eventID] = hEvent;
        	}
        	else
        	{
        		if (NULL == m_hEventHandles[eventID])
        		{
        			m_hEventHandles[eventID] = hEvent;
        			m_fFirstClientIsInteresting = fCltIsInteresting;
        		}
        		else
        		{ //more than one client
					HANDLE *pTmp = (HANDLE *)malloc((m_dwSecondaryClts+1)*sizeof(*pTmp));
					if (NULL == pTmp)
					{
						return FALSE;
					}
					BOOL *pTmp2 = (BOOL *) malloc((m_dwSecondaryClts + 1) * sizeof(*pTmp2));
					if (NULL == pTmp2)
					{
						free(pTmp);
						return FALSE;
					}
					for (UINT i = 0; i < m_dwSecondaryClts; i++)
					{
						pTmp[i] = m_phSecondaryClts[i];
						pTmp2[i] = m_pfSecondaryCltsIsInteresting[i];
					}
					m_dwSecondaryClts++;
					pTmp[m_dwSecondaryClts-1] = hEvent;
					pTmp2[m_dwSecondaryClts-1] = fCltIsInteresting;
					SafeFree(m_phSecondaryClts);
					SafeFree(m_pfSecondaryCltsIsInteresting);
					m_phSecondaryClts = pTmp;
					m_pfSecondaryCltsIsInteresting = pTmp2;
        		}
        	}

            return TRUE;
        }
        else
        {
            switch (eventID)
            {
            case AUEVENT_STATE_CHANGED:
                return m_Add(eventID, ghEngineState);

            case AUEVENT_SERVICE_FINISHED:
                return m_Add(eventID, ghServiceFinished);

            case AUEVENT_NEW_CLIENT_SESSION:
                return m_Add(eventID, ghClientSession);

            case AUEVENT_POLICY_CHANGE:
                return m_Add(eventID, ghPolicyChanged);

            case AUEVENT_SETTINGS_CHANGE:
				return m_Add(eventID, ghSettingsChanged);

            case AUEVENT_CATALOG_VALIDATED:
            	return m_Add(eventID, ghValidateCatalog);
                
            default:
                DEBUGMSG("Unknown event id %d", eventID);
                AUASSERT(FALSE); //should never be here
                return FALSE;
            }
        }
    }

private:
    HANDLE  m_hEventHandles[AU_HANDLE_EVENT_MAX - AU_HANDLE_EVENT_MIN + 1];
    BOOL    m_fFirstClientIsInteresting; // for the first clt
    HANDLE  *m_phSecondaryClts;
    BOOL 	*m_pfSecondaryCltsIsInteresting;
    DWORD   m_dwSecondaryClts;
	SYSTEMTIME m_stTimeout; //when timeout should happen
    AUEVENT   m_timeoutID;
    BOOL 	m_fProrateTimeout;//whether to prorate Timeout when do actual wait
    BOOL 	m_fSkipWaitOnce;

    BOOL fIsEventInherent(DWORD dwEventId)
    {
    	if (AUEVENT_STATE_CHANGED == dwEventId ||
        	AUEVENT_SERVICE_FINISHED==dwEventId ||
        	AUEVENT_POLICY_CHANGE == dwEventId ||
        	AUEVENT_SETTINGS_CHANGE == dwEventId)
    	{
    		return TRUE;
    	}
    	else
    	{
    		return FALSE;
    	}
    }

	//get or free handle list
	//IN fFreeList: if TRUE, free *pHandles list got
	//			if FALSE, get the handle list
    void HandleList(BOOL fFreeList, HANDLE **pHandles, DWORD *pdwCount = NULL) const
    {
	    static HANDLE handles[ARRAYSIZE(m_hEventHandles)];
		DWORD dwCount = 0;

		if (NULL== pHandles )
		{
			return ;
		}
		if (fFreeList)
		{
			if (*pHandles != handles)
			{
				free(*pHandles);
			}
			return;
		}
		if  (NULL == pdwCount)
		{
			return;
		}

		*pHandles = NULL;
	    *pdwCount =0;
       	ZeroMemory(&handles, sizeof(handles));
	    for (UINT i = 0; i < ARRAYSIZE(m_hEventHandles); i++)
		{
			if (NULL != m_hEventHandles[i])
			{
				handles[dwCount++] = m_hEventHandles[i];
			}
		}
		*pHandles = handles;
		if (0 != m_dwSecondaryClts)
		{ //need to wait for more than one client
			AUASSERT(m_phSecondaryClts != NULL);
			if (NULL != (*pHandles = (HANDLE *) malloc((dwCount + m_dwSecondaryClts) * sizeof(**pHandles))))
			{
				for (UINT j = 0 ; j < dwCount; j++)
				{
					(*pHandles)[j] = handles[j];
				}
				for (j = 0; j< m_dwSecondaryClts; j++)
				{
					(*pHandles)[dwCount+j] = m_phSecondaryClts[j];
				}
				dwCount += m_dwSecondaryClts;
			}
			else
			{
				*pHandles = handles;
			}
		}
		*pdwCount = dwCount;
    }

	//return TRUE if handle removed from internal wait list or handle does not need to be removed
	//return FALSE if handle not found
	BOOL RemoveHandle(IN AUEVENT eventid , IN HANDLE & handle)
	{
		AUASSERT(NULL != handle);
		if (fIsEventInherent(eventid))
	   {
	   	return TRUE;
	   }
	   //remove non inhereant events once signalled
		for (UINT i = 0; i < ARRAYSIZE(m_hEventHandles); i++)
		{
			if (handle == m_hEventHandles[i])
			{
				m_hEventHandles[i] = NULL;
				return TRUE;
			}
		}
		for (i = 0; i < m_dwSecondaryClts; i++)
		{
			if (handle == m_phSecondaryClts[i])
			{
				m_phSecondaryClts[i] = m_phSecondaryClts[m_dwSecondaryClts-1];
				m_pfSecondaryCltsIsInteresting[i] = m_pfSecondaryCltsIsInteresting[m_dwSecondaryClts - 1];
				m_phSecondaryClts[m_dwSecondaryClts-1] = NULL;
				m_pfSecondaryCltsIsInteresting[m_dwSecondaryClts - 1] = FALSE;
				m_dwSecondaryClts--;
				if (0 == m_dwSecondaryClts)
				{
					SafeFreeNULL(m_phSecondaryClts);
					SafeFreeNULL(m_pfSecondaryCltsIsInteresting);
				}
				return TRUE;
			}
		}
		AUASSERT(FALSE); //should never be here
		return FALSE;
	}

	BOOL fIsCltInteresting(HANDLE & handle) const
	{
		AUASSERT(NULL != handle);
		if (handle == m_hEventHandles[AUEVENT_WUAUCLT_FINISHED])
		{
			return m_fFirstClientIsInteresting;
		}
		for (UINT i = 0; i < m_dwSecondaryClts; i++)
		{
			if (handle == m_phSecondaryClts[i])
			{
				return m_pfSecondaryCltsIsInteresting[i];
			}
		}
		AUASSERT(FALSE); //should never be here
		return FALSE;
	}

	AUEVENT GetEventID(HANDLE &handle) const
	{
		AUASSERT(NULL!= handle);
		for (UINT i = 0; i < ARRAYSIZE(m_hEventHandles); i++)
		{
			if (handle == m_hEventHandles[i])
			{
				return (AUEVENT)i;
			}
		}
		for (i = 0; i< m_dwSecondaryClts; i++)
		{
			if (handle == m_phSecondaryClts[i])
			{
				return AUEVENT_WUAUCLT_FINISHED;
			}
		}
		AUASSERT(FALSE); //should never be here
		return AUEVENT_DUMMY;
	}	
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\wuaueng\muiutil.h ===
/******************************************************************************

Copyright (c) 2002 Microsoft Corporation

Module Name:
    muisu.h

Abstract:
    Implements helper functions for self-updating MUI stuff

******************************************************************************/

#pragma once

#ifndef MUIUTIL_H
#define MUIUTIL_H

const TCHAR MUI_SUBDIR[]     = _T("mui\\fallback\\");
const TCHAR MUI_HELPSUBDIR[] = _T("help\\mui\\");
const TCHAR MUI_EXT[]        = _T(".mui");
const TCHAR MUI_WEBSUBPATH[] = _T("/mui");

// selfupdate architecture flags
const TCHAR IDENT_ARCH[] = _T("ARCH");
const TCHAR IDENT_OS[] = _T("OS");
const TCHAR IDENT_LANG[] = _T("LANG");

// IU selfupdate arch keys
const TCHAR IDENT_X86[] = _T("x86");
const TCHAR IDENT_IA64[] = _T("ia64");


typedef struct tagAU_LANG
{
    LPTSTR szMuiName;
    LPTSTR szAUName;
} AU_LANG;

typedef struct tagAU_LANGLIST
{
    AU_LANG **rgpaulLangs;
    LPCTSTR pszIdentFile;
    DWORD   cSlots;
    DWORD   cLangs;
} AU_LANGLIST;

HRESULT GetMuiLangList(AU_LANGLIST *paull, 
                         LPTSTR pszMuiDir, DWORD *pcchMuiDir,
                         LPTSTR pszHelpMuiDir, DWORD *pcchHelpMuiDir);
HRESULT CleanupMuiLangList(AU_LANGLIST *paull);
BOOL MapLangIdToStringName(LANGID langid, LPCTSTR pszIdentFile, 
                           LPTSTR pszLangString, DWORD cchLangString);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\wuaueng\pch.h ===
//#pragma warning( push, 3 )
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdio.h>
#include <windows.h>
#include <comdef.h>
#include "iucommon.h"
#include "criticalfixreg.h"
#include "audirectory.h"
#include "wuaulib.h"
#include "caustate.h"
#include "wuaueng.h"
#include "AUSessions.h"
#include "aucatalog.h"
#include "wuaustate.h"
#include "aucpl.h"
#include "prsheet.h"
#include "resource.h"
#include "wuverp.h"
#include "auservinternals.h"
#include <shlobj.h>
#include <advpub.h>
#include <sfcapip.h>
#include <shlwapi.h>
#include <tchar.h>
#include "download.h"
#include "wuauengi.h"
#include <initguid.h>
#include <Wtsapi32.h>
#include "Updates.h"
extern "C"
{
#include <winsta.h>
#include <syslib.h>
}
#include "ausvc.h"
#include <winsock2.h>
#include <aumsgs.h>
#include <auregkeys.h>
#include <auwait.h>
#include <safefunc.h>
#include <RedirectUtil.h>
#include <windowsx.h>
#include "AUEventLog.h"
#include "schemamisc.h"
#include "auxml.h"
#include "audownload.h"
#include "logging.h"
#include "aucomres.h"
#include "schemakeys.h"
#include "CAUWait.h"
#include "ausens.h"
#include "tscompat.h"
#include "service.h"
#include <userenv.h>
#include "AUEventMsgs.h"
#include "memutil.h"
#include <msiquery.h>
#include <msi.h>
#include <sddl.h>
#include "fileutil.h"
#include "WUTestKeys.h"
#include "wusafefn.h"
#include "MISTSafe.h"

//#pragma warning( pop )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\wuaueng\caustate.h ===
//=======================================================================
//
//  Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:    CAUState.h
//
//  Creator: PeterWi
//
//  Purpose: AU state functions.
//
//=======================================================================
#include "safefunc.h"
#include "wuaulib.h"
#include "wuaustate.h"
#include "auwait.h"


#pragma once

extern BOOL  gfDownloadStarted; //to be used to distinguish connection detection and actually downloading mode

typedef enum
{
    enAU_DomainPolicy,
    enAU_AdminPolicy,
    enAU_WindowsUpdatePolicy,
    enAU_IUControlPolicy
} enumAUPolicyType;

typedef enum
{
	AUPOLICYCHANGE_NOOP,
	AUPOLICYCHANGE_RESETENGINE,
	AUPOLICYCHANGE_RESETCLIENT,
	AUPOLICYCHANGE_DISABLE
}enumAUPOLICYCHANGEACTION;

//AU configurable registry settings
#ifdef DBG
extern const TCHAR REG_AUCONNECTWAIT[] ;//= _T("ConnectWait"); //REG_DWORD
extern const TCHAR REG_SELFUPDATE_URL[]; // = _T("SelfUpdateURL");
#endif

extern const TCHAR REG_WUSERVER_URL[]; // = _T("WUServer");
extern const TCHAR REG_WUSTATUSSERVER_URL[]; // = _T("WUStatusServer");
extern const TCHAR REG_IDENT_URL[]; // = _T("IdentServer");
extern const TCHAR WU_LIVE_URL[]; // = _T("http://windowsupdate.microsoft.com/v4");


BOOL fURLChanged(LPCTSTR url1, LPCTSTR url2);

//read only settings
class AUPolicySettings {
public:
	AUPolicySettings() :m_enPolicyType(enAU_DomainPolicy), m_dwOption(AUOPTION_UNSPECIFIED),
					m_dwSchedInstallDay(0), m_dwSchedInstallTime(0), m_dwRescheduleWaitTime(-1),
				 	m_pszWUServerURL(NULL), m_pszWUStatusServerURL(NULL), m_fRegAUOptionsSpecified(TRUE)
		{};
	~AUPolicySettings() {
	        SafeFree(m_pszWUServerURL);
	        SafeFree(m_pszWUStatusServerURL);
		}
	enumAUPolicyType m_enPolicyType;
	BOOL 	   m_fRegAUOptionsSpecified;
	DWORD m_dwOption;
	DWORD m_dwSchedInstallDay;
	DWORD m_dwSchedInstallTime;
	DWORD m_dwRescheduleWaitTime;
	LPTSTR  m_pszWUServerURL;
	LPTSTR  m_pszWUStatusServerURL;

	void Reset(void) {
		m_enPolicyType = enAU_DomainPolicy;
		m_dwOption = AUOPTION_UNSPECIFIED;
		m_dwSchedInstallDay = 0;
		m_dwSchedInstallTime = 0;
		m_dwRescheduleWaitTime = -1;
		m_fRegAUOptionsSpecified = TRUE;
		SafeFreeNULL(m_pszWUServerURL);
		SafeFreeNULL(m_pszWUStatusServerURL);
	}
		
	HRESULT  m_ReadIn();
	HRESULT m_SetOption(AUOPTION & Option);
	HRESULT m_SetInstallSchedule(DWORD dwSchedInstallDay, DWORD dwSchedInstallTime);

	BOOL	operator == (AUPolicySettings & setting2)
		{ 
			return m_enPolicyType == setting2.m_enPolicyType 
					&& m_dwOption == setting2.m_dwOption
					&& m_dwSchedInstallDay == setting2.m_dwSchedInstallDay
					&& m_dwSchedInstallTime == setting2.m_dwSchedInstallTime
					&& m_dwRescheduleWaitTime == setting2.m_dwRescheduleWaitTime
					&& !fURLChanged(m_pszWUServerURL, setting2.m_pszWUServerURL)
					&& !fURLChanged(m_pszWUStatusServerURL, setting2.m_pszWUStatusServerURL);
		}

	HRESULT  Copy (AUPolicySettings & setting2)
		{
			HRESULT hr = E_FAIL;
			AUASSERT(this != &setting2);
			if (this == &setting2)
			{
				return E_INVALIDARG;
			}
			Reset();
			m_enPolicyType = setting2.m_enPolicyType;
			m_dwOption = setting2.m_dwOption;
			m_dwSchedInstallDay = setting2.m_dwSchedInstallDay;
			m_dwSchedInstallTime = setting2.m_dwSchedInstallTime;
			m_dwRescheduleWaitTime = setting2.m_dwRescheduleWaitTime;
			m_fRegAUOptionsSpecified = setting2.m_fRegAUOptionsSpecified;
			if (NULL != setting2.m_pszWUServerURL)
			{
				size_t cchWUServerURL = lstrlen(setting2.m_pszWUServerURL) + 1;
				m_pszWUServerURL = (LPTSTR) malloc(cchWUServerURL * sizeof(TCHAR));
				if (NULL == m_pszWUServerURL)
				{
					hr = E_OUTOFMEMORY;
					goto done;
				}
                if (FAILED(hr = StringCchCopyEx(m_pszWUServerURL, cchWUServerURL, setting2.m_pszWUServerURL, NULL, NULL, MISTSAFE_STRING_FLAGS)))
                {
                	goto done;
                }
			}
			if (NULL != setting2.m_pszWUStatusServerURL)
			{
				size_t cchWUStatusServerURL = lstrlen(setting2.m_pszWUStatusServerURL) + 1;
                m_pszWUStatusServerURL =(LPTSTR) malloc(cchWUStatusServerURL * sizeof(TCHAR));
				if (NULL == m_pszWUStatusServerURL)
				{
					hr = E_OUTOFMEMORY;
					goto done;
				}
                if (FAILED(hr = StringCchCopyEx(m_pszWUStatusServerURL, cchWUStatusServerURL, setting2.m_pszWUStatusServerURL, NULL, NULL, MISTSAFE_STRING_FLAGS)))
                {
                	goto done;
                }
			}
			hr = S_OK;
			
done:
			//in case of failure, keep the most accurate information we could have
			if (FAILED(hr))
			{
				SafeFreeNULL(m_pszWUServerURL);
				SafeFreeNULL(m_pszWUStatusServerURL);
			}
			return hr;
		}				



#ifdef DBG
	void m_DbgDump(void)
	{
		    DEBUGMSG("Policy location: %s", (enAU_DomainPolicy == m_enPolicyType) ? "domain" : "admin");
		    DEBUGMSG("Option: %d", m_dwOption);
		    DEBUGMSG("ScheduledInstallDay: %d", m_dwSchedInstallDay);
		    DEBUGMSG("ScheduledInstallTime: %d", m_dwSchedInstallTime);
    		    DEBUGMSG("RescheduleWaitTime: %d", m_dwRescheduleWaitTime);
		    DEBUGMSG("WUServerURL string is: %S", m_pszWUServerURL);
		    DEBUGMSG("WUStatusServerURL string is: %S", m_pszWUStatusServerURL);
	}
#endif

private:
	HRESULT m_ReadOptionPolicy(void);
	HRESULT m_ReadScheduledInstallPolicy(void);
	HRESULT m_ReadWUServerURL(void);
};
	

class CAUState
{
public:
    static HRESULT HrCreateState(void);
    CAUState();
    ~CAUState()
    {
    	SafeCloseHandleNULL(m_hMutex);
        SafeFree(m_pszTestIdentServerURL);
#ifdef DBG        
        SafeFree(m_pszTestSelfUpdateURL);
#endif
    }

    // Option methods
    AUOPTION GetOption(void) ;
    HRESULT SetOption(AUOPTION & Option);
    HRESULT SetInstallSchedule(DWORD dwSchedInstallDay, DWORD dwSchedInstallTime);
    void GetInstallSchedule(DWORD *pdwSchedInstallDay, DWORD *pdwSchedInstallTime);
    BOOL fOptionAutoDownload(void)
    {
        return ((AUOPTION_INSTALLONLY_NOTIFY == m_PolicySettings.m_dwOption) ||
                (AUOPTION_SCHEDULED == m_PolicySettings.m_dwOption));
    }

    BOOL fOptionSchedInstall(void)
    	{
    		return AUOPTION_SCHEDULED == m_PolicySettings.m_dwOption;
    	}
    BOOL fOptionEnabled(void)
    	{
    		return AUOPTION_AUTOUPDATE_DISABLE != m_PolicySettings.m_dwOption;
    	}
    BOOL fShouldScheduledInstall(void)
    	{  //in which case launch AU client via local system
    	return (AUOPTION_SCHEDULED == m_PolicySettings.m_dwOption) 
    		&& (AUSTATE_DOWNLOAD_COMPLETE == m_dwState);
    	}

    BOOL fValidationNeededState(void)
    {
    	return AUSTATE_DETECT_COMPLETE == m_dwState || AUSTATE_DOWNLOAD_COMPLETE == m_dwState;
    }

    void EnterRebootWarningMode(void)
    	{
    	m_fRebootWarningMode = TRUE;
    	}

    void LeaveRebootWarningMode(void)
    	{
    	m_fRebootWarningMode = FALSE;
    	}

    BOOL fRebootWarningMode(void)
    	{
    	return AUSTATE_INSTALL_PENDING == m_dwState &&  m_fRebootWarningMode;
    	}
    
    // State methods
    DWORD GetState(void) { return m_dwState; }
    void SetState(DWORD dwState);
    DWORD GetCltAction(void) { return m_dwCltAction;}
    void SetCltAction(DWORD dwCltAction) { m_dwCltAction = dwCltAction;}

    // Helper functions
    HRESULT HrInit(BOOL fInit = FALSE);
    HRESULT Refresh(enumAUPOLICYCHANGEACTION *pactcode);
    BOOL fWasSystemRestored(void);
    BOOL fDisconnected(void) { return m_fDisconnected; }
    void SetDisconnected(BOOL fDisconnected);
    void DepriveReschedPrivilege(void) { m_fReschedPrivileged = FALSE; }

    static HRESULT GetRegDWordValue(LPCTSTR lpszValueName, LPDWORD pdwValue, enumAUPolicyType enPolicyType = enAU_AdminPolicy);
	static HRESULT SetRegDWordValue(LPCTSTR lpszValueName, DWORD dwValue, enumAUPolicyType enPolicyType = enAU_AdminPolicy, DWORD options = REG_OPTION_NON_VOLATILE);
	static HRESULT GetRegStringValue(LPCTSTR lpszValueName, LPTSTR lpszBuffer, int nCharCount, enumAUPolicyType enPolicyType);
	static HRESULT SetRegStringValue(LPCTSTR lpszValueName, LPCTSTR lpszNewValue, enumAUPolicyType enPolicyType);

    HRESULT CalculateScheduledInstallSleepTime(DWORD *pdwSleepTime );
	void GetSchedInstallDate(AUFILETIME & auftSchedInstallDate) { auftSchedInstallDate = m_auftSchedInstallDate; }

	void SetDetectionStartTime(BOOL fOverwrite);
	BOOL IsUnableToConnect(void);
	void RemoveDetectionStartTime(void);

	void ResetScheduleInstallDate(void);
	BOOL m_fNoAutoRebootWithLoggedOnUsers(BOOL fReset = FALSE);

    LPCTSTR GetIdentServerURL(void)
    {
        LPCTSTR pszRet = WU_LIVE_URL;

        if ( NULL != m_pszTestIdentServerURL )
        {
            pszRet = m_pszTestIdentServerURL;
        }
        else if ( NULL != m_PolicySettings.m_pszWUServerURL )
        {
            pszRet = m_PolicySettings.m_pszWUServerURL;
        }

        return pszRet;
    }

    LPTSTR GetSelfUpdateServerURLOverride(void)
    {
        LPTSTR pszRet = NULL;

#ifdef DBG
        if ( NULL != m_pszTestSelfUpdateURL )
        {
            return m_pszTestSelfUpdateURL;
        }
#endif        
		if ( NULL != m_PolicySettings.m_pszWUServerURL )
        {
            pszRet = m_PolicySettings.m_pszWUServerURL;
        }

        return pszRet;
    }

	BOOL fInCorpWU(void)
	{
		return (NULL != m_PolicySettings.m_pszWUStatusServerURL);
	}

    BOOL fWin2K(void) { return m_fWin2K; }
    BOOL fShouldAutoDownload(BOOL fUserAvailable)
    {
        return !fUserAvailable && (AUSTATE_DETECT_COMPLETE == m_dwState) && fOptionAutoDownload();
    }
public:
	HANDLE m_hMutex; //protect against simultaneous writing
private:
   BOOL m_fNeedReschedule(AUFILETIME & auftSchedInstallDate, DWORD *pdwSleepTime);
    HRESULT m_ReadPolicy(BOOL fInit);
    void m_ReadRegistrySettings(BOOL fInit);
    HRESULT m_ReadTestOverrides(void);
    HRESULT m_SetScheduledInstallDate(BOOL fReschedule = FALSE);
    HRESULT m_CalculateScheduledInstallDate(AUFILETIME & auftSchedInstallDate, DWORD *pdwSleepTime);
    void m_Reset(void);
    BOOL m_lock(void)
    {
    	AUASSERT(NULL != m_hMutex);
    	if (WAIT_FAILED == WaitForSingleObject(m_hMutex, INFINITE))
    	{
    		AUASSERT(FALSE); //should never be here
    		return FALSE;
    	}
    	return TRUE;
    }
	void m_unlock(void)
	{
		ReleaseMutex(m_hMutex);
	}

#ifdef DBG
    void m_DbgDumpState(void);
#endif

    AUPolicySettings 	m_PolicySettings;
    DWORD    m_dwState;
    AUFILETIME m_auftSchedInstallDate;
    AUFILETIME m_auftDetectionStartTime;
    DWORD    m_dwCltAction;
    BOOL     m_fDisconnected;
    BOOL     m_fWin2K;
    BOOL 	   m_fRebootWarningMode;
    AUFILETIME m_auftServiceStartupTime;
    BOOL m_fReschedPrivileged;  //whether resched and normal sched or wins
    LPTSTR   m_pszTestIdentServerURL;
#ifdef DBG
    LPTSTR   m_pszTestSelfUpdateURL;
#endif

};

// global state object pointer
extern CAUState *gpState;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\wuaueng\muiutil.cpp ===
/******************************************************************************

Copyright (c) 2002 Microsoft Corporation

Module Name:
    muiutil.cpp

Abstract:
    Implements helper functions for self-updating MUI stuff

******************************************************************************/

#include "pch.h"
#include "muiutil.h"
#include "osdet.h"

typedef struct tagSLangIDStringMap
{
    LANGID langid;
    LPTSTR szISOName;
} SLangIDStringMap;

/*

// this is a combination of the languages used by WU and the languages used
//  by MUI
// Mappings determined from the following sources
// For langid to full language name : MSDN
// full language name to 2 char name: http://www.oasis-open.org/cover/iso639a.html
// country name to 2 character name : http://www.din.de/gremien/nas/nabd/iso3166ma

This table is no longer used, but is kept as a reference for langid -> string
mappings

const SLangIDStringMap g_rgLangMap[] = 
{
	{ 0x0401, _T("ar") },
	{ 0x0402, _T("bg") },
	{ 0x0403, _T("ca") },
	{ 0x0404, _T("zhTW") },
	{ 0x0405, _T("cs") },
	{ 0x0406, _T("da") },
	{ 0x0407, _T("de") },
	{ 0x0408, _T("el") },
	{ 0x0409, _T("en") },
	{ 0x040b, _T("fi") },
	{ 0x040c, _T("fr") },
	{ 0x040d, _T("he") },
	{ 0x040e, _T("hu") },
	{ 0x0410, _T("it") },
	{ 0x0411, _T("ja") },
	{ 0x0412, _T("ko") },
	{ 0x0413, _T("nl") },
	{ 0x0414, _T("no") },
	{ 0x0415, _T("pl") },
	{ 0x0416, _T("ptBR") },
	{ 0x0418, _T("ro") },
	{ 0x0419, _T("ru") },
	{ 0x041a, _T("hr") },
	{ 0x041b, _T("sk") },
	{ 0x041d, _T("sv") },
	{ 0x041e, _T("en") },
	{ 0x041f, _T("tr") },
	{ 0x0424, _T("sl") },
	{ 0x0425, _T("et") },
	{ 0x0426, _T("lv") },
	{ 0x0427, _T("lt") },
	{ 0x042d, _T("eu") },
	{ 0x0804, _T("zhCN") },
	{ 0x080a, _T("es") },
	{ 0x0816, _T("pt") },
	{ 0x0c0a, _T("es") }
};
*/


// ******************************************************************************
BOOL MapLangIdToStringName(LANGID langid, LPCTSTR pszIdentFile, 
                           LPTSTR pszLangString, DWORD cchLangString)
{
	LOG_Block("MapLangIdToStringName");

    TCHAR   szLang[32];
    DWORD   cch;
    LCID    lcid;
    BOOL    fRet = FALSE;

    lcid = MAKELCID(langid, SORT_DEFAULT);

    fRet = LookupLocaleStringFromLCID(lcid, szLang, ARRAYSIZE(szLang));
    if (fRet == FALSE)
    {
        LOG_ErrorMsg(GetLastError());
        goto done;
    }

    // first try the whole string ("<lang>-<country>")
    cch = GetPrivateProfileString(IDENT_LANG, szLang, 
                                  _T(""),
                                  pszLangString, cchLangString, 
                                  pszIdentFile);
    if (cch == cchLangString - 1)
    {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        LOG_ErrorMsg(ERROR_INSUFFICIENT_BUFFER);
        goto done;
    }

    // if that fails, strip off the country code & just try the language
    else if (cch == 0)
    {
        LPTSTR pszDash;

        pszDash = StrChr(szLang, _T('-'));
        if (pszDash != NULL)
        {
            *pszDash = _T('\0');
            cch = GetPrivateProfileString(IDENT_LANG, szLang, 
                                          _T(""),
                                          pszLangString, cchLangString, 
                                          pszIdentFile);
            if (cch == cchLangString - 1)
            {
                SetLastError(ERROR_INSUFFICIENT_BUFFER);
                LOG_ErrorMsg(ERROR_INSUFFICIENT_BUFFER);
                goto done;
            }
        }
    }

    if (cch > 0 && pszLangString[0] == _T('/'))
    {
        // want to use the full cch (& not cch - 1) because we want to copy the
        //  NULL terminator also...
        MoveMemory(&pszLangString[0], &pszLangString[1], cch * sizeof(TCHAR));
    }

    fRet = TRUE;

done:
    return fRet;    
}

// ******************************************************************************
BOOL CALLBACK EnumUILangProc(LPTSTR szUILang, LONG_PTR lParam)
{
	LOG_Block("EnumUILangProc");

    AU_LANGLIST *paull = (AU_LANGLIST *)lParam;
    AU_LANG     *paulNew = NULL;
    HRESULT     hr;
    LANGID      langid;
    LPTSTR      pszStop;
    TCHAR       szAUName[32];
    DWORD       cchMuiName, cchAUName, cbNeed, cchAvail, dwLangID;
    BOOL        fRet = FALSE, fMap;

    if (szUILang == NULL || lParam == NULL)
        goto done;

    langid = (LANGID)_tcstoul(szUILang, &pszStop, 16);

    // if we don't have a mapping for a langid, then just skip the language
    //  and return success
    szAUName[0] = _T('\0');
    fMap = MapLangIdToStringName(langid, paull->pszIdentFile,
                                 szAUName, ARRAYSIZE(szAUName));
    if (fMap == FALSE || szAUName[0] == _T('\0'))
    {
        fRet = TRUE;
        goto done;
    }

    if (paull->cLangs >= paull->cSlots)
    {
        AU_LANG **rgpaulNew = NULL;
        DWORD   cNewSlots = paull->cSlots * 2;

        if (cNewSlots == 0)
            cNewSlots = 32;

        if (paull->rgpaulLangs != NULL)
        {
            rgpaulNew = (AU_LANG **)HeapReAlloc(GetProcessHeap(), 
                                                HEAP_ZERO_MEMORY,
                                                paull->rgpaulLangs,
                                                cNewSlots * sizeof(AU_LANG *));
        }
        else
        {
            rgpaulNew = (AU_LANG **)HeapAlloc(GetProcessHeap(),
                                              HEAP_ZERO_MEMORY,
                                              cNewSlots * sizeof(AU_LANG *));
        }
        if (rgpaulNew == NULL)
            goto done;

        paull->rgpaulLangs = rgpaulNew;
        paull->cSlots      = cNewSlots;
    }

    // we will be adding an '_' to the beginning of the AUName, so make sure
    //  the size we compute here reflects that.
    cchAUName  = lstrlen(szAUName) + 1;
    cchMuiName = lstrlen(szUILang);

    // alloc a buffer to hold the AU_LANG struct plus the two strings (and 
    //  don't forget the NULL terminators!).
    // The layout of the buffer is as follows:
    //  <AU_LANG>
    //  <szMuiName>
    //  _<szAUName>
    // NOTE: if this buffer format ever change, gotta make sure that the 
    //  contents are aligned properly (otherwise, we'll fault on ia64)
    cbNeed =  sizeof(AU_LANG);
    cbNeed += ((cchMuiName + cchAUName + 2) * sizeof(TCHAR));
    paulNew = (AU_LANG *)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, cbNeed);
    if (paulNew == NULL)
        goto done;

    paulNew->szMuiName = (LPTSTR)((PBYTE)paulNew + sizeof(AU_LANG)); 
    paulNew->szAUName  = paulNew->szMuiName + cchMuiName + 1;

    // this should never truncate the buffers cuz we calc'ed the size above and
    //  allocated a buffer exactly long enuf to hold all of this
    cchAvail = (cbNeed - sizeof(AU_LANG)) / sizeof(TCHAR);
    hr = StringCchCopyEx(paulNew->szMuiName, cchAvail, szUILang, 
                         NULL, NULL, MISTSAFE_STRING_FLAGS);
    if (FAILED(hr))
        goto done;

    cchAvail -= (cchMuiName + 1);

    // need to put an '_' in front of the AU name, so add it to the buffer and
    //  reduce the available size by one.  Also make sure to start copying the
    //  AUName *after* the '_' character.
    paulNew->szAUName[0] = _T('_');
    cchAvail--;
    
    hr = StringCchCopyEx(&paulNew->szAUName[1], cchAvail, szAUName, 
                         NULL, NULL, MISTSAFE_STRING_FLAGS);
    if (FAILED(hr))
        goto done;
    
    paull->rgpaulLangs[paull->cLangs++] = paulNew;
    paulNew = NULL;

    fRet = TRUE;

done:
    if (paulNew != NULL)
        HeapFree(GetProcessHeap(), 0, paulNew);
    
    return fRet;
}

// ******************************************************************************
HRESULT GetMuiLangList(AU_LANGLIST *paull, 
                       LPTSTR pszMuiDir, DWORD *pcchMuiDir,
                       LPTSTR pszHelpMuiDir, DWORD *pcchHelpMuiDir)
{
	LOG_Block("GetMuiLangList");

    HRESULT hr = NOERROR;
    DWORD   cMuiLangs;
    int     iLang;

    paull->cLangs      = 0;
    paull->cSlots      = 0;
    paull->rgpaulLangs = NULL;
    
    if (EnumUILanguages(EnumUILangProc, 0, (LONG_PTR)paull) == FALSE)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto done;
    }

    // We need to deal with MUI stuff only if we've have more than 0 languages
    //  to worry about
    if (paull->cLangs > 0)
    {
        LPTSTR  pszHelp = NULL, pszMui = NULL;
        size_t  cchAvail, cchAvailHelp;
        TCHAR   szPath[MAX_PATH + 1];
        DWORD   dwAttrib;
        DWORD   cch, cLangs = (int)paull->cLangs;
        BOOL    fDeleteLang;
        
        // need to get the directory we'll stuff MUI updates into
        cch = GetSystemWindowsDirectory(pszMuiDir, *pcchMuiDir);

        // note 2nd compare takes into account the addition of an extra '\\' after
        //  the system windows dir
        if (cch == 0 || cch >= *pcchMuiDir)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto done;
        }

        // tack on an extra '\\' if necessary
        if (pszMuiDir[cch - 1] != _T('\\'))
        {
            pszMuiDir[cch++] = _T('\\');
            pszMuiDir[cch] = _T('\0');
        }

        hr = StringCchCopyEx(pszHelpMuiDir, *pcchHelpMuiDir, pszMuiDir,
                             NULL, NULL, MISTSAFE_STRING_FLAGS);
        if (FAILED(hr))
            goto done;

        hr = StringCchCatEx(pszHelpMuiDir, *pcchHelpMuiDir, MUI_HELPSUBDIR,
                            &pszHelp, &cchAvailHelp, MISTSAFE_STRING_FLAGS);
        if (FAILED(hr))
            goto done;
        
        hr = StringCchCatEx(pszMuiDir, *pcchMuiDir, MUI_SUBDIR, 
                            &pszMui, &cchAvail, MISTSAFE_STRING_FLAGS);
        if (FAILED(hr))
            goto done;
        
        *pcchMuiDir     -= cchAvail;
        *pcchHelpMuiDir -= cchAvailHelp;

        // check and make sure that the MUI directories exist- remove all those that 
        //  do not.  This section also checks to make sure that the buffer passed in 
        //  is large enuf to hold the language
        for(iLang = (int)(cLangs - 1); iLang >= 0; iLang--)
        {   
            fDeleteLang = FALSE;

            hr = StringCchCopyEx(pszMui, cchAvail,
                                 paull->rgpaulLangs[iLang]->szMuiName, 
                                 NULL, NULL, MISTSAFE_STRING_FLAGS);
            if (FAILED(hr))
                goto done;
            
            dwAttrib = GetFileAttributes(pszMuiDir);
            if (dwAttrib == INVALID_FILE_ATTRIBUTES || 
                (dwAttrib & FILE_ATTRIBUTE_DIRECTORY) == 0)
            {
                fDeleteLang = TRUE;
            }
            else
            {
                hr = StringCchCopyEx(pszHelp, cchAvailHelp,
                                     paull->rgpaulLangs[iLang]->szMuiName, 
                                     NULL, NULL, MISTSAFE_STRING_FLAGS);
                if (FAILED(hr))
                    goto done;
                
                dwAttrib = GetFileAttributes(pszHelpMuiDir);
                if (dwAttrib == INVALID_FILE_ATTRIBUTES || 
                    (dwAttrib & FILE_ATTRIBUTE_DIRECTORY) == 0)
                {
                    fDeleteLang = TRUE;
                }
            }

            if (fDeleteLang)
            {
                HeapFree(GetProcessHeap(), 0, paull->rgpaulLangs[iLang]);
                if (iLang != paull->cLangs - 1)
                {
                    MoveMemory(&paull->rgpaulLangs[iLang], 
                               &paull->rgpaulLangs[iLang + 1],
                               (paull->cLangs - iLang - 1) * sizeof(AU_LANG *));
                }
                paull->rgpaulLangs[--paull->cLangs] = NULL;
            }
        }

        pszMuiDir[*pcchMuiDir] = _T('\0');
        pszHelpMuiDir[*pcchHelpMuiDir] = _T('\0');
        
    }

done:
    if (FAILED(hr))
        CleanupMuiLangList(paull);

    return hr;
}

// ******************************************************************************
HRESULT CleanupMuiLangList(AU_LANGLIST *paull)
{
	LOG_Block("CleanupMuiLangList");

    HRESULT hr = S_OK;
    DWORD   i;

    // if it's NULL, just return success
    if (paull == NULL)
        return hr;

    if (paull->rgpaulLangs == NULL)
        goto done;

    for (i = 0; i < paull->cLangs; i++)
    {
        if (paull->rgpaulLangs[i] != NULL)
            HeapFree(GetProcessHeap(), 0, paull->rgpaulLangs[i]);
    }

    HeapFree(GetProcessHeap(), 0, paull->rgpaulLangs);

done:
    ZeroMemory(paull, sizeof(AU_LANGLIST));
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\wuaueng\prsheet.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       prsheet.h
//
//--------------------------------------------------------------------------
#pragma once

HRESULT
CAutoUpdatePropSheet_CreateInstance(
    HINSTANCE hInstance,
    REFIID riid,
    void **ppv);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\wuaueng\prsheet.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       prsheet.cpp
//
//--------------------------------------------------------------------------
#include "pch.h"
#include "shellapi.h"
#include "htmlhelp.h"
#pragma hdrstop

#define IDH_LETWINDOWS					3000
#define IDH_AUTOUPDATE_OPTION1			3001
#define IDH_AUTOUPDATE_OPTION2			3002
#define IDH_AUTOUPDATE_OPTION3			3003
#define IDH_DAYDROPDOWN					3004
#define IDH_TIMEDROPDOWN				3005
#define IDH_AUTOUPDATE_RESTOREHIDDEN	3006
#define IDH_NOHELP						-1

const TCHAR g_szAutoUpdateItems[]     = TEXT("AutoUpdateItems");

//
// Create a structure for Updates Object data.  This structure
// is used to pass data between the property page and the
// Updates Object thread.  Today all we use is the "option" value 
// but there may be more later.
//
enum UPDATESOBJ_DATA_ITEMS
{
    UODI_OPTION = 0x00000001,
    UODI_ALL    = 0xFFFFFFFF
};

struct UPDATESOBJ_DATA
{
    DWORD fMask;     // UPDATESOBJ_DATA_ITEMS mask
    AUOPTION Option;  // Updates option setting.
};


//
// Private window message sent from the Updates Object thread proc
// to the property page telling the page that the object has been
// initialized.  
//
//      lParam - points to a UPATESOBJ_DATA structure containing 
//               the initial configuration of the update's object with
//               which to initialize the UI.  If wParam is 0, this 
//               may be NULL.
//
//      wParam - BOOL (0/1) indicating if object intialization was 
//               successful or not.  If wParam is 0, lParam may be NULL.
// 
const UINT PWM_INITUPDATESOBJECT = WM_USER + 1;
//
// Message sent from the property page to the Updates Object thread
// to tell it to configure the Auto Updates service.  
//
//      lParam - points to a UPDATESOBJ_DATA structure containing the 
//               data to set.
//
//      wParam - Unused.  Set to 0.
//
const UINT UOTM_SETDATA = WM_USER + 2;


//
// Message cracker for WM_HELP.  Not sure why windowsx.h doesn't have one.
//
// void Cls_OnHelp(HWND hwnd, HELPINFO *pHelpInfo)
//
#define HANDLE_WM_HELP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HELPINFO *)(lParam)))
#define FORWARD_WM_HELP(hwnd, pHelpInfo, fn) \
    (void)(fn)((hwnd), WM_HELP, (WPARAM)0, (LPARAM)pHelpInfo)

//
// Message cracker for PWM_INITUPDATESOBJECT.
//
#define HANDLE_PWM_INITUPDATESOBJECT(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (BOOL)(wParam), (UPDATESOBJ_DATA *)(lParam)))


class CAutoUpdatePropSheet : public IShellExtInit, 
                             public IShellPropSheetExt
{
    public:
        ~CAutoUpdatePropSheet(void);
        //
        // IUnknown
        //
        STDMETHOD(QueryInterface)(REFIID riid, void **ppv);
        STDMETHOD_(ULONG, AddRef)(void);
        STDMETHOD_(ULONG, Release)(void);
        //
        // IShellExtInit
        //
        STDMETHOD(Initialize)(LPCITEMIDLIST pidl, LPDATAOBJECT pdtobj, HKEY hkey);
        //
        // IShellPropSheetExt
        //
        STDMETHOD(AddPages)(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam);
        STDMETHOD(ReplacePage)(UINT uPageID, LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam);
        //
        // Instance generator.
        //
        static HRESULT CreateInstance(HINSTANCE hInstance, REFIID riid, void **ppv);

    private:
        LONG      m_cRef;
        HINSTANCE m_hInstance;
        DWORD     m_idUpdatesObjectThread;
        HANDLE    m_hThreadUpdatesObject;
        
        static const DWORD s_rgHelpIDs[];

        BOOL _OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam);
        BOOL _OnNotify(HWND hwnd, UINT idFrom, LPNMHDR pnmhdr);
        BOOL _OnPSN_Apply(HWND hwnd);
        BOOL _OnDestroy(HWND hwnd);
        BOOL _OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
        BOOL _OnContextMenu(HWND hwnd, HWND hwndContext, UINT xPos, UINT yPos);
        BOOL _OnHelp(HWND hwnd, HELPINFO *pHelpInfo);
        BOOL _OkToDisplayPage(void);
        BOOL _OnInitUpdatesObject(HWND hwnd, BOOL bObjectInit, UPDATESOBJ_DATA *pData);

		//newly added methods : a-josem
		BOOL _EnableOptions(HWND hwnd, BOOL bState);
		BOOL _EnableCombo(HWND hwnd, BOOL bState);
		BOOL _SetDefault(HWND hwnd);
		void _GetDayAndTimeFromUI( HWND hWnd,	LPDWORD lpdwSchedInstallDay,LPDWORD lpdwSchedInstallTime);
		BOOL _FillDaysCombo(HWND hwnd, DWORD dwSchedInstallDay);
		void _OnKeepUptoDate(HWND hwnd);
		static INT_PTR CALLBACK _DlgRestoreProc(HWND hwnd,UINT uMsg,WPARAM wParam,LPARAM lParam);
		void LaunchLinkAction(HWND hwnd, UINT uCtrlId);
		void LaunchHelp(LPCTSTR szURL);
		//end of newly added methods,

        HRESULT _OnOptionSelected(HWND hwnd, int idOption);
        HRESULT _OnRestoreHiddenItems(void);
        HRESULT _EnableControls(HWND hwnd, BOOL bEnable);
        HRESULT _SetHeaderText(HWND hwnd, UINT idsText);
        HRESULT _AddPage(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam);

        static DWORD WINAPI _UpdatesObjectThreadProc(LPVOID pvParam);
        static HRESULT _QueryUpdatesObjectData(HWND hwnd, IUpdates *pUpdates, UPDATESOBJ_DATA *pData);
        static HRESULT _SetUpdatesObjectData(HWND hwnd, IUpdates *pUpdates, UPDATESOBJ_DATA *pData);
        static UINT CALLBACK _PageCallback(HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp);
        static INT_PTR CALLBACK _DlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
       
        //
        // Allow public creation through instance generator only.
        //
        CAutoUpdatePropSheet(HINSTANCE hInstance);
        //
        // Prevent copy.
        //
        CAutoUpdatePropSheet(const CAutoUpdatePropSheet& rhs);              // not implemented.
        CAutoUpdatePropSheet& operator = (const CAutoUpdatePropSheet& rhs); // not implemented.
};



CAutoUpdatePropSheet::CAutoUpdatePropSheet(
    HINSTANCE hInstance
    ) : m_cRef(1),
        m_hInstance(hInstance),
        m_idUpdatesObjectThread(0),
        m_hThreadUpdatesObject(NULL)
{
    DllAddRef();
}



CAutoUpdatePropSheet::~CAutoUpdatePropSheet(
    void
    )
{
    if (NULL != m_hThreadUpdatesObject)
    {
        CloseHandle(m_hThreadUpdatesObject);
    }
    DllRelease();
}



HRESULT
CAutoUpdatePropSheet::CreateInstance(
    HINSTANCE hInstance,
    REFIID riid,
    void **ppvOut
    )
{
    HRESULT hr = E_OUTOFMEMORY;
    if (NULL == ppvOut)
    {
    	return E_INVALIDARG;
    }
    	
    *ppvOut = NULL;

    CAutoUpdatePropSheet *pSheet = new CAutoUpdatePropSheet(hInstance);
    if (NULL != pSheet)
    {
        hr = pSheet->QueryInterface(riid, ppvOut);
        pSheet->Release();
    }
    return hr;
}



STDMETHODIMP
CAutoUpdatePropSheet::QueryInterface(
    REFIID riid,
    void **ppvOut
    )
{
    HRESULT hr = E_NOINTERFACE;

    if (NULL == ppvOut)
        return E_INVALIDARG;

    *ppvOut = NULL;
    if (IID_IUnknown == riid ||
        IID_IShellExtInit == riid)
    {
        *ppvOut = static_cast<IShellExtInit *>(this);
    }
    else if (IID_IShellPropSheetExt == riid)
    {
        *ppvOut = static_cast<IShellPropSheetExt *>(this);
    }
    if (NULL != *ppvOut)
    {
        ((LPUNKNOWN)*ppvOut)->AddRef();
        hr = NOERROR;
    }
    return hr;
}



STDMETHODIMP_(ULONG)
CAutoUpdatePropSheet::AddRef(
    void
    )
{
    return InterlockedIncrement(&m_cRef);
}



STDMETHODIMP_(ULONG)
CAutoUpdatePropSheet::Release(
    void
    )
{
    if (InterlockedDecrement(&m_cRef))
        return m_cRef;

    delete this;
    return 0;
}


//
// IShellExtInit::Initialize impl.
//
STDMETHODIMP
CAutoUpdatePropSheet::Initialize(
    LPCITEMIDLIST /*pidlFolder*/, 
    LPDATAOBJECT /*pdtobj*/,
    HKEY /*hkeyProgID*/
    )
{
    return NOERROR;
}



//
// IShellPropSheetExt::AddPages impl.
//
STDMETHODIMP
CAutoUpdatePropSheet::AddPages(
    LPFNADDPROPSHEETPAGE lpfnAddPage, 
    LPARAM lParam
    )
{
    HRESULT hr = E_FAIL; // Assume failure.

    if (_OkToDisplayPage())
    {
        hr = _AddPage(lpfnAddPage, lParam);
    }
    return hr;
}



//
// IShellPropSheetExt::ReplacePage impl.
//
STDMETHODIMP
CAutoUpdatePropSheet::ReplacePage(
    UINT /*uPageID*/, 
    LPFNADDPROPSHEETPAGE /*lpfnAddPage*/, 
    LPARAM /*lParam*/
    )
{
    return E_NOTIMPL;
}



//
// Determines if it's OK to display the auto-update prop page.
// Reasons for NOT displaying:
//
//  1. User is not an administrator.
//  2. The "NoAutoUpdate" policy restriction is in place.
//
//
BOOL
CAutoUpdatePropSheet::_OkToDisplayPage(
    void
    )
{
    BOOL bOkToDisplay = TRUE;

    if (!IsNTAdmin(0,0))
    {
        bOkToDisplay = FALSE;
    }
    else
    {
        bOkToDisplay = fAccessibleToAU();
    }
    return bOkToDisplay;
}


//
// Add our page to the property sheet.
//
HRESULT
CAutoUpdatePropSheet::_AddPage(
    LPFNADDPROPSHEETPAGE lpfnAddPage, 
    LPARAM lParam
    )
{
    HRESULT hr = E_FAIL;

    PROPSHEETPAGE psp;
    ZeroMemory(&psp, sizeof(psp));

    psp.dwSize      = sizeof(PROPSHEETPAGE);
    psp.dwFlags     = PSP_USECALLBACK;
    psp.hInstance   = m_hInstance;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_AUTOUPDATE);
    psp.pszTitle    = NULL;
    psp.pfnDlgProc  = CAutoUpdatePropSheet::_DlgProc;
    psp.pfnCallback = CAutoUpdatePropSheet::_PageCallback;
    psp.lParam      = (LPARAM)this;

    HPROPSHEETPAGE hPage = CreatePropertySheetPage(&psp);
    if (NULL != hPage)
    {
        if (lpfnAddPage(hPage, lParam))
        {
            hr = S_OK;
        }
        else
        {
            DestroyPropertySheetPage(hPage);
        }
    }
    return hr;
}



//
// We implement the page callback to manage the lifetime of the
// C++ object attached to the property page.
// We also use the callback to defer creation of the IUpdates object.
//
UINT CALLBACK
CAutoUpdatePropSheet::_PageCallback(  // [static]
    HWND /*hwnd*/,
    UINT uMsg,
    LPPROPSHEETPAGE ppsp
    )
{
    UINT uReturn = 1;
    if (NULL == ppsp)
    {
    	return uReturn;
    }
    CAutoUpdatePropSheet *pThis = (CAutoUpdatePropSheet *)ppsp->lParam;

    switch(uMsg)
    {
        case PSPCB_ADDREF:
            pThis->AddRef();
            break;

        case PSPCB_RELEASE:
            pThis->Release();
            break;
    }
    return uReturn;
}



//
// ISSUE-2000/10/12-BrianAu  Need help IDs.
//
const DWORD CAutoUpdatePropSheet::s_rgHelpIDs[] = {
	IDC_CHK_KEEPUPTODATE,         DWORD(IDH_LETWINDOWS),
    IDC_OPTION1,       DWORD(IDH_AUTOUPDATE_OPTION1),
    IDC_OPTION2,       DWORD(IDH_AUTOUPDATE_OPTION2),
    IDC_OPTION3,       DWORD(IDH_AUTOUPDATE_OPTION3),
	IDC_CMB_DAYS,				  DWORD(IDH_DAYDROPDOWN),
	IDC_CMB_HOURS,				  DWORD(IDH_TIMEDROPDOWN),
	IDC_RESTOREHIDDEN,			  DWORD(IDH_AUTOUPDATE_RESTOREHIDDEN),
	IDC_GRP_OPTIONS,			  DWORD(IDH_NOHELP),
	IDI_AUTOUPDATE,				  DWORD(IDH_NOHELP),
    0, 0
    };




INT_PTR CALLBACK 
CAutoUpdatePropSheet::_DlgProc(   // [static]
    HWND hwnd,
    UINT uMsg, 
    WPARAM wParam, 
    LPARAM lParam
    )
{
    CAutoUpdatePropSheet *pThis = NULL;
    if (WM_INITDIALOG == uMsg)
    {
        PROPSHEETPAGE *psp = (PROPSHEETPAGE *)lParam;
        pThis = (CAutoUpdatePropSheet *)psp->lParam;
        if (!SetProp(hwnd, g_szPropDialogPtr, (HANDLE)pThis))
        {
            pThis = NULL;
        }
    }
    else
    {
        pThis = (CAutoUpdatePropSheet *)GetProp(hwnd, g_szPropDialogPtr);
    }

    if (NULL != pThis)
    {
        switch(uMsg)
        {
            HANDLE_MSG(hwnd, WM_INITDIALOG,  pThis->_OnInitDialog);
            HANDLE_MSG(hwnd, WM_COMMAND,     pThis->_OnCommand);
            HANDLE_MSG(hwnd, WM_DESTROY,     pThis->_OnDestroy);
            HANDLE_MSG(hwnd, WM_NOTIFY,      pThis->_OnNotify);
            HANDLE_MSG(hwnd, WM_CONTEXTMENU, pThis->_OnContextMenu);
            HANDLE_MSG(hwnd, WM_HELP,        pThis->_OnHelp);
            HANDLE_MSG(hwnd, PWM_INITUPDATESOBJECT, pThis->_OnInitUpdatesObject);
            default:
                break;
        }
    }
    return FALSE;
}


void EnableRestoreDeclinedItems(HWND hWnd, BOOL fEnable)
{
	EnableWindow(GetDlgItem(hWnd, IDC_RESTOREHIDDEN), fEnable);
}

//
// PWM_INITUPDATESOBJECT handler.
// This is called when the Updates Object thread has either successfully
// CoCreated the Updates object or CoCreation has failed.
// It's possible that the Windows Update Service is not running.
// This is how we handle that condition.
//
BOOL
CAutoUpdatePropSheet::_OnInitUpdatesObject(
    HWND hwnd,
    BOOL bObjectInitSuccessful,
    UPDATESOBJ_DATA *pData
    )
{
    if (bObjectInitSuccessful)
    {
    	if (NULL == pData)
    	{
    		return FALSE;
    	}
        //
        // Updates object was created and initialized.  The 
        // pData pointer refers to the initial state information retrieved 
        // from the object.  Initialize the property page.
        //
        _SetHeaderText(hwnd, IDS_HEADER_CONNECTED);
        _EnableControls(hwnd, TRUE);

		EnableRestoreDeclinedItems( hwnd, FHiddenItemsExist());

        switch(pData->Option.dwOption)
        {
            case AUOPTION_AUTOUPDATE_DISABLE:
				CheckRadioButton(hwnd, IDC_OPTION1, IDC_OPTION3, IDC_OPTION1);
				_EnableOptions(hwnd, FALSE);
				_EnableCombo(hwnd, FALSE);
				SendMessage(GetDlgItem(hwnd,IDC_CHK_KEEPUPTODATE),BM_SETCHECK,BST_UNCHECKED,0);
                break;

            case AUOPTION_PREDOWNLOAD_NOTIFY:
                            CheckRadioButton(hwnd, IDC_OPTION1, IDC_OPTION3, IDC_OPTION1);
				_EnableCombo(hwnd, FALSE);
				SendMessage(GetDlgItem(hwnd,IDC_CHK_KEEPUPTODATE),BM_SETCHECK,BST_CHECKED,0);
                break;

             case AUOPTION_INSTALLONLY_NOTIFY:
                            CheckRadioButton(hwnd, IDC_OPTION1, IDC_OPTION3, IDC_OPTION2);
				_EnableCombo(hwnd, FALSE);
				SendMessage(GetDlgItem(hwnd,IDC_CHK_KEEPUPTODATE),BM_SETCHECK,BST_CHECKED,0);
                break;

		case AUOPTION_SCHEDULED:
                            CheckRadioButton(hwnd, IDC_OPTION1, IDC_OPTION3, IDC_OPTION3);
				_EnableCombo(hwnd, TRUE);
				SendMessage(GetDlgItem(hwnd,IDC_CHK_KEEPUPTODATE),BM_SETCHECK,BST_CHECKED,0);
                break;

            default:
				_SetDefault(hwnd);
                break;
        }
       _FillDaysCombo(hwnd, pData->Option.dwSchedInstallDay);
       FillHrsCombo(hwnd, pData->Option.dwSchedInstallTime);

        if (pData->Option.fDomainPolicy)
            {
                DisableUserInput(hwnd);
            }
    }
    else
    {
        //
        // Something failed when creating the Updates object.
        // Most likely, the Windows Update service is not running.
        //
        _SetHeaderText(hwnd, IDS_HEADER_UNAVAILABLE);
    }
        
    return FALSE;   
}




//
// WM_INITDIALOG handler.
//
BOOL
CAutoUpdatePropSheet::_OnInitDialog(
    HWND hwnd,
    HWND /*hwndFocus*/,
    LPARAM /*lParam*/
    )
{
    //
    // If the thread is created, the threadproc will call 
    // DllRelease();
    //
    DllAddRef();
    //
    // Disable all page controls and display a message in the 
    // header indicating that we're trying to connect to the
    // Windows Update service.
    //
    _SetHeaderText(hwnd, IDS_HEADER_CONNECTING);
    _EnableControls(hwnd, FALSE);
    //
    // Create the thread on which the Updates object lives.
    // Communication between the thread and the property page is
    // through the messages PWM_INITUPDATESOBJECT and UOTM_SETDATA.
    //
    m_hThreadUpdatesObject = CreateThread(NULL,
                                          0,
                                          _UpdatesObjectThreadProc,
                                          (LPVOID)hwnd,
                                          0,
                                          &m_idUpdatesObjectThread);
    if (NULL == m_hThreadUpdatesObject)
    {
        DllRelease();
    }
    return TRUE;
}



//
// WM_DESTROY handler.
//
BOOL 
CAutoUpdatePropSheet::_OnDestroy(
    HWND hwnd
    )
{
    RemoveProp(hwnd, g_szPropDialogPtr);
    if (0 != m_idUpdatesObjectThread)
    {
        //
        // Terminate the Update Objects thread.
        //
        if (0 != PostThreadMessage(m_idUpdatesObjectThread, WM_QUIT, 0, 0))
        {
            //
            // Wait for normal thread termination.
            //
            WaitForSingleObject(m_hThreadUpdatesObject, 5000);
        }
    }
    return FALSE;
}



//
// WM_COMMAND handler.
//
BOOL
CAutoUpdatePropSheet::_OnCommand(
    HWND hwnd,
    int id,
    HWND /*hwndCtl*/,
    UINT codeNotify
    )
{
	INT Result;
    switch(id)
    {
		case IDC_CHK_KEEPUPTODATE:
			if (BN_CLICKED == codeNotify)
			{
				_OnKeepUptoDate(hwnd);
			}
			break;

        case IDC_OPTION1:
        case IDC_OPTION2:
        case IDC_OPTION3:
            if(BN_CLICKED == codeNotify)
            {
                _OnOptionSelected(hwnd, id);
            }
            break;

		case IDC_CMB_DAYS:
		case IDC_CMB_HOURS:
			if(CBN_SELCHANGE == codeNotify)
			{
				//
				// Enable the "Apply" button.
				//
				SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM)hwnd, 0);

			}
			break;

        case IDC_RESTOREHIDDEN:
				 Result = (INT)DialogBoxParam(m_hInstance, 
                 MAKEINTRESOURCE(IDD_RESTOREUPDATE), 
                 hwnd, 
                 CAutoUpdatePropSheet::_DlgRestoreProc, 
                 (LPARAM)NULL);
			if (Result == TRUE)
			{	
				if (SUCCEEDED (_OnRestoreHiddenItems()))			
				{		
					EnableRestoreDeclinedItems( hwnd, FALSE);
				}	
			}
            break;

        default:
            return FALSE;
    }
    return TRUE;
}

INT_PTR CALLBACK CAutoUpdatePropSheet::_DlgRestoreProc(
    HWND hwnd,
    UINT uMsg, 
    WPARAM wParam, 
    LPARAM lParam
    )
{
	if (uMsg == WM_INITDIALOG)
	{
		HWND hwndOwner; 
		RECT rc, rcDlg, rcOwner; 
        // Get the owner window and dialog box rectangles. 
 
		if ((hwndOwner = GetParent(hwnd)) == NULL) 
		{
			hwndOwner = GetDesktopWindow(); 
		}

		GetWindowRect(hwndOwner, &rcOwner); 
		GetWindowRect(hwnd, &rcDlg); 
		CopyRect(&rc, &rcOwner); 

		 // Offset the owner and dialog box rectangles so that 
		 // right and bottom values represent the width and 
		 // height, and then offset the owner again to discard 
		 // space taken up by the dialog box. 
		OffsetRect(&rcDlg, -rcDlg.left, -rcDlg.top); 
		OffsetRect(&rc, -rc.left, -rc.top); 
		OffsetRect(&rc, -rcDlg.right, -rcDlg.bottom); 

		 // The new position is the sum of half the remaining 
		 // space and the owner's original position. 
		SetWindowPos(hwnd, 
			HWND_TOP, 
			rcOwner.left + (rc.right / 2), 
			rcOwner.top + (rc.bottom / 2), 
			0, 0,          // ignores size arguments 
			SWP_NOSIZE); 
	}

	if (uMsg == WM_COMMAND)
	{
		switch (LOWORD(wParam))
		{
		case IDOK:
			EndDialog(hwnd, TRUE);
			return TRUE;

		case IDCANCEL:
			EndDialog(hwnd, FALSE);
			return TRUE;
		}
	}
	return FALSE;
}


//
// WM_NOTIFY handler.
//
BOOL
CAutoUpdatePropSheet::_OnNotify(
    HWND hwnd,
    UINT idFrom,
    LPNMHDR pnmhdr
    )
{
    switch(pnmhdr->code)
    {
        case PSN_APPLY:
            _OnPSN_Apply(hwnd);
            break;

		case NM_RETURN:
		case NM_CLICK:
			if (idFrom == IDC_AUTOUPDATELINK || idFrom == IDC_SCHINSTALLINK)
				LaunchLinkAction(hwnd, idFrom);
			break;

        default:
            break;
    }
    return FALSE;
}

void CAutoUpdatePropSheet::LaunchLinkAction(HWND hwnd, UINT uCtrlId)
{
	switch (uCtrlId)
	{
		case IDC_AUTOUPDATELINK:
			LaunchHelp(gtszAUOverviewUrl);
			break;
		case IDC_SCHINSTALLINK:
			LaunchHelp(gtszAUXPSchedInstallUrl);
			break;
	}
	return;
}


//
// Called when the user presses the "Apply" button or the "OK"
// button when the page has been changed.
//
BOOL
CAutoUpdatePropSheet::_OnPSN_Apply(
    HWND hwnd
    )
{
    HRESULT hr = E_FAIL;
    //
    // Create a structure that can be passed to the Updates Object thread
    // by way of the UOTM_SETDATA thread message.  The thread will free
    // the buffer when it's finished with it.
    //
    UPDATESOBJ_DATA *pData = (UPDATESOBJ_DATA *)LocalAlloc(LPTR, sizeof(*pData));
    if (NULL == pData)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        pData->Option.dwSchedInstallDay = -1;
        pData->Option.dwSchedInstallTime = -1;
        pData->fMask    = UODI_ALL;

        static const struct
        {
            UINT idCtl;
            DWORD dwOption;

        } rgMap[] = {
            { IDC_OPTION1,  AUOPTION_PREDOWNLOAD_NOTIFY },
            { IDC_OPTION2,  AUOPTION_INSTALLONLY_NOTIFY },
            { IDC_OPTION3,  AUOPTION_SCHEDULED }
		};

		if 	(IsDlgButtonChecked(hwnd, IDC_CHK_KEEPUPTODATE) == BST_CHECKED)
		{
			//
			// Determine the WAU option based on the radio button configuration.
			//
			for (int i = 0; i < ARRAYSIZE(rgMap); i++)
			{
				if (IsDlgButtonChecked(hwnd, rgMap[i].idCtl) == BST_CHECKED)
				{
					pData->Option.dwOption = rgMap[i].dwOption;
					break;
				}
			}
		}
		else
			pData->Option.dwOption = AUOPTION_AUTOUPDATE_DISABLE;

        if (AUOPTION_SCHEDULED == pData->Option.dwOption)
            {
                _GetDayAndTimeFromUI(hwnd, &(pData->Option.dwSchedInstallDay), &(pData->Option.dwSchedInstallTime));
            }

        if (0 != m_idUpdatesObjectThread)
        {
            if (0 != PostThreadMessage(m_idUpdatesObjectThread,
                                       UOTM_SETDATA,
                                       0,
                                       (LPARAM)pData))
            {
                hr    = S_OK;
                pData = NULL;
            }
        }
        if (NULL != pData)
        {
            LocalFree(pData);
            pData = NULL;
        }
    }
    if (SUCCEEDED(hr))
    {
        //
        // Inform the property sheet the update was successful and
        // disable the "Apply" button.
        //
        SetWindowLongPtr(hwnd, DWLP_MSGRESULT, PSNRET_NOERROR);
        SendMessage(GetParent(hwnd), PSM_UNCHANGED, (WPARAM)hwnd, 0);
    }
    return FALSE;
}



//
// WM_CONTEXTMENU handler.
//
BOOL 
CAutoUpdatePropSheet::_OnContextMenu(
    HWND hwnd, 
    HWND hwndContext, 
    UINT /*xPos*/, 
    UINT /*yPos*/
    )
{
	if ((hwndContext == GetDlgItem(hwnd,IDC_CHK_KEEPUPTODATE))||
	(hwndContext == GetDlgItem(hwnd,IDC_OPTION1))||
	(hwndContext == GetDlgItem(hwnd,IDC_OPTION2))||
	(hwndContext == GetDlgItem(hwnd,IDC_OPTION3))||
	(hwndContext == GetDlgItem(hwnd,IDC_CMB_DAYS))||
	(hwndContext == GetDlgItem(hwnd,IDC_CMB_HOURS))||
	(hwndContext == GetDlgItem(hwnd,IDC_RESTOREHIDDEN)))
	{
		HtmlHelp(hwndContext,g_szHelpFile,HH_TP_HELP_CONTEXTMENU,(DWORD_PTR)((LPTSTR)s_rgHelpIDs));
	}
    return FALSE;
}


//
// WM_HELP handler.
//
BOOL 
CAutoUpdatePropSheet::_OnHelp(
    HWND hwnd, 
    HELPINFO *pHelpInfo
    )
{
	if (NULL == pHelpInfo)
	{
		return TRUE;
	}
	if (HELPINFO_WINDOW == pHelpInfo->iContextType)
    {
		if ((pHelpInfo->hItemHandle == GetDlgItem(hwnd,IDC_CHK_KEEPUPTODATE))||
			(pHelpInfo->hItemHandle == GetDlgItem(hwnd,IDC_OPTION1))||
			(pHelpInfo->hItemHandle == GetDlgItem(hwnd,IDC_OPTION2))||
			(pHelpInfo->hItemHandle == GetDlgItem(hwnd,IDC_OPTION3))||
			(pHelpInfo->hItemHandle == GetDlgItem(hwnd,IDC_CMB_DAYS))||
			(pHelpInfo->hItemHandle == GetDlgItem(hwnd,IDC_CMB_HOURS))||
			(pHelpInfo->hItemHandle == GetDlgItem(hwnd,IDC_RESTOREHIDDEN))
			)
        HtmlHelp((HWND)pHelpInfo->hItemHandle,
                 g_szHelpFile,
                 HH_TP_HELP_WM_HELP,
                 (DWORD_PTR)((LPTSTR)s_rgHelpIDs));
    }
    return TRUE;
}


//
// Called when user selects one of the 3 options radio buttons.
//
HRESULT
CAutoUpdatePropSheet::_OnOptionSelected(
    HWND hwnd,
    int idOption
    )
{
    const UINT idFirst = IDC_OPTION1;
    const UINT idLast  = IDC_OPTION3;
    CheckRadioButton(hwnd, idFirst, idLast, idOption);

	if (idOption == IDC_OPTION3)
		_EnableCombo(hwnd, TRUE);
	else
		_EnableCombo(hwnd, FALSE);

    //
    // Enable the "Apply" button.
    //
    SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM)hwnd, 0);

    return S_OK;
}



//
// Called when the user presses the "Restore Hidden Items" button
//
HRESULT
CAutoUpdatePropSheet::_OnRestoreHiddenItems(
    void
    )
{
    return RemoveHiddenItems() ? S_OK : E_FAIL;
}


//
// Enable or disable all controls on the property page.
// All but the header text control.
//
HRESULT
CAutoUpdatePropSheet::_EnableControls(
    HWND hwnd,
    BOOL bEnable
    )
{
    static const UINT rgidCtls[] = {
		IDC_CHK_KEEPUPTODATE,
        IDC_OPTION1,
        IDC_OPTION2,
        IDC_OPTION3,
        IDC_RESTOREHIDDEN,
        IDC_GRP_OPTIONS,
		IDC_CMB_DAYS,
		IDC_STATICAT,
		IDC_CMB_HOURS,
		IDC_SCHINSTALLINK,
		IDC_AUTOUPDATELINK
        };

    for (int i = 0; i < ARRAYSIZE(rgidCtls); i++)
    {
        EnableWindow(GetDlgItem(hwnd, rgidCtls[i]), bEnable);
    }
    return S_OK;
}


//
// Set the text to the right of the icon.
//
HRESULT 
CAutoUpdatePropSheet::_SetHeaderText(
    HWND hwnd, 
    UINT idsText
    )
{
    HRESULT hr;
    TCHAR szText[300] ;

	//ZeroMemory(szText, sizeof(szText));
    if (0 < LoadString(m_hInstance, idsText, szText, ARRAYSIZE(szText)))
    {
        SetWindowText(GetDlgItem(hwnd, IDC_TXT_HEADER), szText);
        hr = S_OK;
    }
    else
    {
        const DWORD dwErr = GetLastError();
        hr = HRESULT_FROM_WIN32(dwErr);
    }
    return hr;
}

        

//
// This thread is where the Updates object lives.  This allows us to 
// CoCreate the object without blocking the UI.  If the Windows Update
// service is not running, CoCreate can take several seconds.  Without
// placing this on another thread, this can make the UI appear to be
// hung.
//
// *pvParam is the HWND of the property page window.  
//
DWORD WINAPI
CAutoUpdatePropSheet::_UpdatesObjectThreadProc(   // [static]
    LPVOID pvParam
    )
{
    HWND hwndClient = (HWND)pvParam;
    HRESULT hr = CoInitialize(NULL);
    if (SUCCEEDED(hr))
    {
        IUpdates *pUpdates;
        hr = CoCreateInstance(__uuidof(Updates),
                              NULL, 
                              CLSCTX_LOCAL_SERVER,
                              IID_IUpdates,
                              (void **)&pUpdates);
        if (SUCCEEDED(hr))
        {
            //
            // Query the object for it's current data and send it
            // to the property page.
            //
            UPDATESOBJ_DATA data;
            data.fMask    = UODI_ALL;

            HRESULT hrQuery = _QueryUpdatesObjectData(hwndClient, pUpdates, &data);
            SendMessage(hwndClient, PWM_INITUPDATESOBJECT, (WPARAM)SUCCEEDED(hrQuery), (LPARAM)&data);
            //
            // Now sit waiting for thread messages from the UI.  We receive
            // either messages to configure Windows Update or a 
            // WM_QUIT indicating it's time to go.
            // 
            bool bDone = false;
            MSG msg;
            while(!bDone)
            {
                if (0 == GetMessage(&msg, NULL, 0, 0))
                {
                    bDone = true;
                }
                else switch(msg.message)
                {
                    case UOTM_SETDATA:
                        if (NULL != msg.lParam)
                        {
                            UPDATESOBJ_DATA *pData = (UPDATESOBJ_DATA *)msg.lParam;
                            _SetUpdatesObjectData(hwndClient, pUpdates, pData);
                            LocalFree(pData);
                        }
                        break;
        
                    default:
                        TranslateMessage(&msg);
                        DispatchMessage(&msg);
                        break;
                }
            }
            pUpdates->Release();
        }
        CoUninitialize();
    }
    if (FAILED(hr))
    {
        //
        // Something failed.  Notify the property page.
        // Most likely, the Windows Update service is not available.
        // That's the principal case this separate thread is addressing.
        //
        DEBUGMSG("AU cpl fails to create IUpdates object with error %#lx", hr);
        SendMessage(hwndClient, PWM_INITUPDATESOBJECT, FALSE, (LPARAM)NULL);
    }
    //
    // DllAddRef() was called before CreateThread in _OnInitDialog.
    //
    DllRelease();
    return 0;
}



HRESULT
CAutoUpdatePropSheet::_QueryUpdatesObjectData(  // [static]
    HWND /*hwnd*/,
    IUpdates *pUpdates,
    UPDATESOBJ_DATA *pData
    )
{
    HRESULT hr = S_OK;
    if (NULL == pData)
    {
    	return E_INVALIDARG;

    }
    if (UODI_OPTION & pData->fMask)
    {
        hr = pUpdates->get_Option(&(pData->Option));
        if (FAILED(hr))
        {
        	DEBUGMSG("AU cpl fail to get option with error %#lx", hr);
            //
            // ISSUE-2000/10/18-BrianAu  Display error UI?
            //
        }
    }
    return hr;
}


HRESULT
CAutoUpdatePropSheet::_SetUpdatesObjectData(  // [static]
    HWND /*hwnd*/,
    IUpdates *pUpdates,
    UPDATESOBJ_DATA *pData
    )
{
    HRESULT hr = S_OK;
    if (NULL == pData)
    {
    	return E_INVALIDARG;
    }
    if (UODI_OPTION & pData->fMask)
    {
        hr = pUpdates->put_Option(pData->Option);
    }
    return hr;
}

//
// Exported instance generator.  External coupling is reduced
// to this single function.
//
HRESULT
CAutoUpdatePropSheet_CreateInstance(
    HINSTANCE hInstance,
    REFIID riid,
    void **ppv
    )
{
    return CAutoUpdatePropSheet::CreateInstance(hInstance, riid, ppv);
}


void CAutoUpdatePropSheet::_GetDayAndTimeFromUI( 
	HWND hWnd,
	LPDWORD lpdwSchedInstallDay,
	LPDWORD lpdwSchedInstallTime
)
{
	HWND hComboDays = GetDlgItem(hWnd,IDC_CMB_DAYS);
	HWND hComboHrs = GetDlgItem(hWnd,IDC_CMB_HOURS);
	LRESULT nDayIndex = SendMessage(hComboDays,CB_GETCURSEL,0,(LPARAM)0);
	LRESULT nTimeIndex = SendMessage(hComboHrs,CB_GETCURSEL,0,(LPARAM)0);

	*lpdwSchedInstallDay = (DWORD)SendMessage(hComboDays,CB_GETITEMDATA, nDayIndex, (LPARAM)0);
	*lpdwSchedInstallTime = (DWORD)SendMessage(hComboHrs,CB_GETITEMDATA, nTimeIndex, (LPARAM)0);
}


BOOL CAutoUpdatePropSheet::_FillDaysCombo(HWND hwnd, DWORD dwSchedInstallDay)
{
    return FillDaysCombo(m_hInstance, hwnd, dwSchedInstallDay, IDS_STR_EVERYDAY, IDS_STR_SATURDAY);
}

void CAutoUpdatePropSheet::_OnKeepUptoDate(HWND hwnd)
{
	LRESULT lResult = SendMessage(GetDlgItem(hwnd,IDC_CHK_KEEPUPTODATE),BM_GETCHECK,0,0);
	
	//
    // Enable the "Apply" button.
    //
    SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM)hwnd, 0);

	if (lResult == BST_CHECKED)
	{
		_EnableOptions(hwnd, TRUE);
	}
	else if (lResult == BST_UNCHECKED)
	{
		_EnableOptions(hwnd, FALSE);
	}
	/*  //check box is either checked or not
	else
	{
		return FALSE;
	}
	*/
}

BOOL CAutoUpdatePropSheet::_EnableOptions(HWND hwnd, BOOL bState)
{
	EnableWindow(GetDlgItem(hwnd,IDC_OPTION1),bState);
	EnableWindow(GetDlgItem(hwnd,IDC_OPTION2),bState);
	EnableWindow(GetDlgItem(hwnd,IDC_OPTION3),bState);

	if (BST_CHECKED == SendMessage(GetDlgItem(hwnd,IDC_OPTION3),BM_GETCHECK,0,0))
	{
		_EnableCombo(hwnd, bState);
	}

	return TRUE;
}

BOOL CAutoUpdatePropSheet::_SetDefault(HWND hwnd)
{
	LRESULT lResult = SendMessage(GetDlgItem(hwnd,IDC_CHK_KEEPUPTODATE),BM_SETCHECK,BST_CHECKED,0);
	CheckRadioButton(hwnd, IDC_OPTION1, IDC_OPTION3, IDC_OPTION2);
	return TRUE;
}

BOOL CAutoUpdatePropSheet::_EnableCombo(HWND hwnd, BOOL bState)
{
	EnableWindow(GetDlgItem(hwnd,IDC_CMB_DAYS),bState);
	EnableWindow(GetDlgItem(hwnd,IDC_STATICAT),bState);		
	EnableWindow(GetDlgItem(hwnd,IDC_CMB_HOURS),bState);
	return TRUE;
}

void 
CAutoUpdatePropSheet::LaunchHelp(LPCTSTR szURL)
{
	HtmlHelp(NULL,szURL,HH_DISPLAY_TOPIC,NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\wuaueng\register.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       register.cpp
//
//--------------------------------------------------------------------------


#include "pch.h"
#include "service.h"

#pragma hdrstop

const TCHAR AU_SERVICE_NAME[]   = _T("wuauserv");
const TCHAR PING_STATUS_FILE[]  = _T("pingstatus.dat");

const TCHAR SVCHOST_CMDLINE_NETSVCS[]      = _T("%systemroot%\\system32\\svchost.exe -k netsvcs");
const TCHAR SVCHOST_CMDLINE_STANDALONE[]   = _T("%systemroot%\\system32\\svchost.exe -k wugroup");


//=======================================================================
//  CallRegInstall
//=======================================================================
inline HRESULT CallRegInstall(HMODULE hModule, LPCSTR pszSection)
{
    HRESULT hr = RegInstall(hModule, pszSection, NULL);
	if (FAILED(hr))
	{
		DEBUGMSG("CallRegInstall() call RegInstall failed %#lx", hr);
	}
    return hr;
}


//caller is responsible for closing hSCM
//Stopping service not needed during setup cuz service won't start in GUI setup mode
//Needed for command line dll registering
void  StopNDeleteAUService(SC_HANDLE hSCM)
{
		SC_HANDLE hService = OpenService(hSCM, AU_SERVICE_NAME, SERVICE_ALL_ACCESS);
		if(hService != NULL)
		{
			SERVICE_STATUS wuauservStatus;
			DEBUGMSG("Old wuauserv service found, deleting");
			
			if (0 == ControlService(hService, SERVICE_CONTROL_STOP, &wuauservStatus))
			{
				DEBUGMSG("StopNDeleteAUService() fails to stop wuauserv with error %d", GetLastError());
			}
			else
			{
				DEBUGMSG("wuauserv successfully stopped");
			}
			
			if (0 == DeleteService(hService))
			{
				DEBUGMSG("StopNDeleteAUService() could not delete wuauserv with error %d", GetLastError());
			}
			else
			{
				DEBUGMSG("wuauserv service successfully deleted");
			}
			CloseServiceHandle(hService);
		}
		else
		{
			DEBUGMSG("No old wuauserv service found");
		}
}


/////////////////////////////////////////////////////////////////////////
// Setup utility function for debugging only
// uncomment for testing
/////////////////////////////////////////////////////////////////////////
/*
void AUSetup::mi_DumpWUDir()
{
	WIN32_FIND_DATA fd;
	HANDLE hFindFile;
	BOOL fMoreFiles = FALSE;
	TCHAR tszFileName[MAX_PATH+1];
	TCHAR tszWUDirPath[MAX_PATH+1];

	if (!GetWUDirectory(tszWUDirPath) ||
		FAILED(StringCchCopyEx(tszFileName, ARRAYSIZE(tszFileName), tszWUDirPath, NULL, NULL, MISTSAFE_STRING_FLAGS)) ||
		FAILED(StringCchCatEx(tszFileName, ARRAYSIZE(tszFileName), _T("*.*"), NULL, NULL, MISTSAFE_STRING_FLAGS))
		INVALID_HANDLE_VALUE == (hFindFile = FindFirstFile(tszFileName, &fd)))
	{
		DEBUGMSG("AUSetup::m_CleanUp() no more files found");
		goto done;
	}
	
	FindNextFile(hFindFile, &fd);				
	//"." and ".." skipped
	while (fMoreFiles = FindNextFile(hFindFile, &fd))
	{
		if (SUCCEEDED(StringCchCopyEx(tszFileName, ARRAYSIZE(tszFileName), tszWUDirPath, NULL, NULL, MISTSAFE_STRING_FLAGS)) &&
			SUCCEEDED(StringCchCatEx(tszFileName, ARRAYSIZE(tszFileName), fd.cFileName, NULL, NULL, MISTSAFE_STRING_FLAGS)))
		{
			DEBUGMSG("DumpWUDir() %S", tszFileName);
		}
	}
done:
	if (INVALID_HANDLE_VALUE != hFindFile)
	{
		FindClose(hFindFile);
	}
	return;

}
*/

const LPCTSTR AUSetup::mc_WUFilesToDelete[] =
{
	_T("*.des"),
	_T("*.inv"),
	_T("*.bkf"),
	_T("*.as"),
	_T("*.plt"),
	_T("*.bm"),
	_T("*.bin"),
	_T("*.cdm"),
	_T("*.ini"),
	_T("*.dll"),
	_T("*.gng"),
	_T("*.png"),
	_T("*.cab"),
	_T("*.jpg"),
	_T("*.gif"),
	_T("*.cif"),
	_T("*.bak"),
	_T("inventory.cat"),
	_T("catalog4.dat"),
	PING_STATUS_FILE,
	_T("ident.*"),
	_T("osdet.*"),
	_T("austate.cfg"),
	_T("inseng.w98"),
	_T("temp.inf"),
      ITEM_FILE,
      DETAILS_FILE,
#ifdef DBG      
      DETECT1_FILE,
      DETECT2_FILE,
      DETECT3_FILE ,
      INSTALLRESULTS_FILE,
      INSTALL_FILE,
      DOWNLOAD_FILE,
      DRIVER_SYSSPEC_FILE,
      NONDRIVER_SYSSPEC_FILE,
      PROVIDER_FILE,
      PRODUCT_FILE,
#endif     
     DRIVERS_FILE,
    CATALOG_FILE,
    HIDDEN_ITEMS_FILE
};

const LPCTSTR AUSetup::mc_WUDirsToDelete[] =
{
	_T("Cabs"),
	_T("RTF"),
	_T("wupd"),
    C_DOWNLD_DIR
};

void AUSetup::mi_CleanUpWUDir()
{
	TCHAR tszWUDirPath[MAX_PATH+1];

	if (!CreateWUDirectory() || FAILED(StringCchCopyEx(tszWUDirPath, ARRAYSIZE(tszWUDirPath), g_szWUDir, NULL, NULL, MISTSAFE_STRING_FLAGS)))
	{
		return;
	}

		
	DEBUGMSG("mi_CleanUpWUDir() Windows update directory is %S ", tszWUDirPath);

	// clean all known V3 files
	for (int i=0; i < ARRAYSIZE(mc_WUFilesToDelete); i++)
	{
		TCHAR tszFileName[MAX_PATH+1];
		if (SUCCEEDED(StringCchCopyEx(tszFileName, ARRAYSIZE(tszFileName), tszWUDirPath, NULL, NULL, MISTSAFE_STRING_FLAGS)) &&
			SUCCEEDED(StringCchCatEx(tszFileName, ARRAYSIZE(tszFileName), mc_WUFilesToDelete[i], NULL, NULL, MISTSAFE_STRING_FLAGS)))
		{
			//DEBUGMSG("AUSetup::mi_CleanUpWUDir() deleting file %S", tszFileName);
			RegExpDelFile(tszWUDirPath, mc_WUFilesToDelete[i]);
		}
		else
		{
			DEBUGMSG("AUSetup::mi_CleanUpWUDir() failed in name construction for file %d", i);
		}
	}

 	// clean all known V3 subdirectories
	for (int i =0; i< ARRAYSIZE(mc_WUDirsToDelete); i++)
	{
		TCHAR tszDirName[MAX_PATH+1];
		if (SUCCEEDED(StringCchCopyEx(tszDirName, ARRAYSIZE(tszDirName), tszWUDirPath, NULL, NULL, MISTSAFE_STRING_FLAGS)) &&
			SUCCEEDED(StringCchCatEx(tszDirName, ARRAYSIZE(tszDirName), mc_WUDirsToDelete[i], NULL, NULL, MISTSAFE_STRING_FLAGS)))
		{
			DelDir(tszDirName);
			RemoveDirectory(tszDirName);
		}
		else
		{
			DEBUGMSG("AUSetup::mi_CleanUpWUDir() failed in name construction for dir %d", i);
		}
	}	
 
	return;
}

HRESULT  AUSetup::mi_CreateAUService(BOOL fStandalone)
{
	TCHAR tServiceName[50] = _T("Automatic Updates");	
	HRESULT		hr = E_FAIL;
	const ULONG CREATESERVICE_RETRY_TIMES = 5;

	LoadString(g_hInstance, IDS_SERVICENAME, tServiceName, ARRAYSIZE(tServiceName));

    // First install the service
    SC_HANDLE hSCM = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
	
	if(hSCM == NULL)
	{
		DEBUGMSG("Could not open SCManager, no service installed");
		goto done;
	}

	DEBUGMSG("Opened SCManager, removing any existing wuauserv service");

	StopNDeleteAUService(hSCM);
		
	DEBUGMSG("Installing new wuauserv service");

	for (int i = 0; i < CREATESERVICE_RETRY_TIMES;  i++) //retry for at most a number of times
	{
		SC_HANDLE hService = CreateService(hSCM,
			AU_SERVICE_NAME,
			tServiceName,		   
			SERVICE_ALL_ACCESS,
			SERVICE_WIN32_SHARE_PROCESS,
			SERVICE_AUTO_START,
			SERVICE_ERROR_NORMAL,
            fStandalone? SVCHOST_CMDLINE_STANDALONE : SVCHOST_CMDLINE_NETSVCS,
			NULL,
			NULL,
			NULL,
			NULL,
			NULL);

		if(hService != NULL)
		{
			DEBUGMSG("Service installed, setting description");

			TCHAR serviceDescription[512];
			if(LoadString(g_hInstance, IDS_SERVICE_DESC, serviceDescription, ARRAYSIZE(serviceDescription)) > 0)
			{
				SERVICE_DESCRIPTION descriptionStruct;
				descriptionStruct.lpDescription = serviceDescription; //only member
				BOOL fRet = ChangeServiceConfig2(hService, SERVICE_CONFIG_DESCRIPTION, &descriptionStruct);
				DEBUGMSG("Setting service description %s", fRet? "Succeeded" : "Failed");
			}
			else
			{
				DEBUGMSG("Error loading description resource, no description set");
			}
			hr = S_OK;
			CloseServiceHandle(hService);
			break;
		}
		else
		{
			DWORD dwErr = GetLastError();
			// this error code is not documented in MSDN for CreateService()
			if (ERROR_SERVICE_MARKED_FOR_DELETE != dwErr)
			{
				DEBUGMSG("Error creating service with error code %d, no service installed", dwErr);
				goto done;
			}
			else
			{
				DEBUGMSG("ERROR_SERVICE_MARKED_FOR_DELETE got. Retry within 2 secs");
				Sleep(2000); //sleep 2 secs and retry
			}
		}
	} // for
	
done:
	if (NULL != hSCM) 
	{
		CloseServiceHandle(hSCM);
	}
	return hr;

}

HRESULT AUSetup::m_SetupNewAU()
{
	HRESULT hr                 = S_OK;
    BOOL    fWorkStation       = fIsPersonalOrProfessional();     // will be true for Workstation as well
    BOOL    fIsWin2K           = IsWin2K();
    BOOL    fStandaloneService = fIsWin2K;                        // if it is win2k we need to install standalone

	mi_CleanUpWUDir();
    if (FAILED(mi_CreateAUService(fStandaloneService)))
    {
        return E_FAIL;
    }

    //
    // Depending on which OS we are, choose different setup entry points.
    // For Win2K, wuauserv will be installed as a separate svchost group, wugroup.
    //
    if (fIsWin2K)
    {
        if (fWorkStation)
        {
            DEBUGMSG("m_SetupNewAU() setup win2k workstation");
            hr =  CallRegInstall(g_hInstance, "Win2KWorkStationDefaultInstall");
        }
        else
        {
            DEBUGMSG("m_SetupNewAU() setup win2k server");
            hr =  CallRegInstall(g_hInstance, "Win2KServerDefaultInstall");
        }
    }
    else
    {
        if (fWorkStation)
        {
            DEBUGMSG("m_SetupNewAU() setup workstation");
            hr =  CallRegInstall(g_hInstance, "WorkStationDefaultInstall");
        }
        else
        {
            DEBUGMSG("m_SetupNewAU() setup server");
            hr =  CallRegInstall(g_hInstance, "ServerDefaultInstall");
        }
    }

	return hr;
}

//=======================================================================
//  DllRegisterServer
//=======================================================================
STDAPI DllRegisterServer(void)
{
	AUSetup ausetup;

	return  ausetup.m_SetupNewAU();
}

//=======================================================================
//  DllUnregisterServer
//=======================================================================
STDAPI DllUnregisterServer(void)
{
	SC_HANDLE hSCM = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
	
	if (NULL == hSCM)
	{
		DEBUGMSG("DllUnregisterServer() fail to open service manager: error %d", GetLastError());
		return E_FAIL;
	}
	StopNDeleteAUService(hSCM);
	return CallRegInstall(g_hInstance, "DefaultUninstall");
}

//=======================================================================
//  MSIUninstallOfCUN
//=======================================================================
void MSIUninstallOfCUN(void)
{
    DEBUGMSG("MSIUninstallOfCUN");

    typedef UINT (WINAPI * PFNMsiConfigureProduct)(LPCWSTR szProduct, int iInstallLevel, INSTALLSTATE eInstallState);
    typedef INSTALLUILEVEL (WINAPI *PFNMsiSetInternalUI)(INSTALLUILEVEL dwUILevel, HWND  *phWnd);
    typedef UINT (WINAPI *PFNMsiEnumClients)(LPCWSTR szComponent, DWORD iProductIndex, LPWSTR lpProductBuf);
    typedef UINT (WINAPI *PFNMsiGetProductInfo)(LPCWSTR szProduct, LPCWSTR szAttribute, LPWSTR lpValueBuf, DWORD *pcchValueBuf);
    
    PFNMsiConfigureProduct pfnMsiConfigureProduct;
    PFNMsiSetInternalUI    pfnMsiSetInternalUI;
    PFNMsiEnumClients      pfnMsiEnumClients;
    PFNMsiGetProductInfo   pfnMsiGetProductInfo;

    // component code for wuslflib.dll is constant across all localized versions of CUN
    // and can be used to determine which product version is on the machine.
    const TCHAR CUN_COMPONENT_CODE[] = _T("{2B313391-563D-46FC-876C-B95201166D11}");
    // name of product is not localized between versions (because the UI is always english)
    // and can thus be used as a safety check.
    const TCHAR CUN_PRODUCT_NAME[] = _T("Microsoft Windows Critical Update Notification");
    WCHAR szProductCode[39];
 
    
    HMODULE hMSI = LoadLibraryFromSystemDir(_T("msi.dll"));	
	
    if ( (NULL == hMSI) ||
         (NULL == (pfnMsiConfigureProduct = (PFNMsiConfigureProduct)GetProcAddress(hMSI, "MsiConfigureProductW"))) ||
         (NULL == (pfnMsiSetInternalUI =    (PFNMsiSetInternalUI)   GetProcAddress(hMSI, "MsiSetInternalUI"))) ||
         (NULL == (pfnMsiEnumClients =      (PFNMsiEnumClients)     GetProcAddress(hMSI, "MsiEnumClientsW"))) ||
         (NULL == (pfnMsiGetProductInfo =   (PFNMsiGetProductInfo)  GetProcAddress(hMSI, "MsiGetProductInfoW"))) )
	{
		DEBUGMSG("LoadLibraryFromSystemDir(msi.dll) or GetProc failed");
		goto done;
	}

    // highly unlikely that multiple clients will be installed, but just in case, enumerate
    // all MSI clients of wuslflib.dll.
    for ( int iProductIndex = 0;
          ERROR_SUCCESS == pfnMsiEnumClients(CUN_COMPONENT_CODE, iProductIndex, szProductCode);
          iProductIndex++ )
    {
        DEBUGMSG("szProductCode = %S", szProductCode);

        // verify that this product is the Windows CUN by double checking the Product Name. 
        // This string is not localized for localized versions of CUN.
        TCHAR szCurrentProductName[50];
        DWORD cchCurrentProductName = ARRAYSIZE(szCurrentProductName);

        // retrieve the product name. If the name is too long to fit in the buffer, this is obviously not CUN.
        // on error, do not attempt to uninstall the product.
        if ( (ERROR_SUCCESS == pfnMsiGetProductInfo(szProductCode, INSTALLPROPERTY_INSTALLEDPRODUCTNAME, szCurrentProductName, &cchCurrentProductName)) &&
             (0 == StrCmp(CUN_PRODUCT_NAME, szCurrentProductName)) )
        {
            // set completely silent install
            pfnMsiSetInternalUI(INSTALLUILEVEL_NONE, NULL);

            DEBUGMSG("uninstall CUN");
            // uninstall the product.
            UINT uiResult = pfnMsiConfigureProduct(szProductCode, INSTALLLEVEL_DEFAULT, INSTALLSTATE_ABSENT);
            DEBUGMSG("MsiConfigureProduct = %d", uiResult);
            break;
        }
    }
done:
    if ( NULL != hMSI )
    {
        FreeLibrary(hMSI);
    }

    return;
}

inline void SafeCloseServiceHandle(SC_HANDLE h) { if ( NULL != h) { CloseServiceHandle(h); } }
inline void SafeFreeLibrary(HMODULE h) { if ( NULL != h) { FreeLibrary(h); } }

//=======================================================================
//  StartWUAUSERVService
//=======================================================================
HRESULT StartWUAUSERVService(void)
{
    DEBUGMSG("StartWUAUSERVService");
    HRESULT hr = E_FAIL;
    SC_HANDLE hService = NULL;
    SC_HANDLE hSCM = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);

    if( hSCM == NULL )
    {
        DEBUGMSG("OpenSCManager failed");
        goto done;
    }

    if ( NULL == (hService = OpenService(hSCM, AU_SERVICE_NAME, SERVICE_ALL_ACCESS)) )
    {
        DEBUGMSG("OpenService failed");
        goto done;
    }

    if ( !StartService(hService, 0, NULL) )
    {
        DWORD dwRet = GetLastError();
        if ( ERROR_SERVICE_ALREADY_RUNNING != dwRet )
        {
            hr = HRESULT_FROM_WIN32(dwRet);
            DEBUGMSG("StartService failed, hr = %#lx", hr);
        }
        else
        {
            DEBUGMSG("StartService -- service already running");
        }
        goto done;
    }

    hr = S_OK;

done:
    SafeCloseServiceHandle(hService);
    SafeCloseServiceHandle(hSCM);

    return hr;
}

//=======================================================================
//  CRunSetupCommand
//=======================================================================
class CRunSetupCommand
{
public:
    CRunSetupCommand()
        : m_hAdvPack(NULL)
    {}
    ~CRunSetupCommand()
    {
        SafeFreeLibrary(m_hAdvPack);
    }
    
    HRESULT m_Init(void)
    {
        HRESULT hr = S_OK;
        
        if ( (NULL == (m_hAdvPack = LoadLibraryFromSystemDir(_T("advpack.dll")))) ||
		     (NULL == (m_pfnRunSetupCommand = (RUNSETUPCOMMAND)GetProcAddress(m_hAdvPack,
                                                                              achRUNSETUPCOMMANDFUNCTION))) )
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
        else
        {
            CHAR szWinDir[MAX_PATH+1];
            if ( !GetWindowsDirectoryA(szWinDir, ARRAYSIZE(szWinDir)))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
            }
            else if (SUCCEEDED(hr = PathCchCombineA(m_szInfDir, ARRAYSIZE(m_szInfDir), szWinDir, "inf")))
            {
                DEBUGMSG("inf dir is %s", m_szInfDir);
			}
        }
	
    	return hr;
    }

    HRESULT m_Run(LPCSTR pszInfFile, LPCSTR pszInfSection)
	{
        DEBUGMSG("run %s\\%s[%s]", m_szInfDir, pszInfFile, pszInfSection);

		HRESULT hr = m_pfnRunSetupCommand(NULL, 
                                          pszInfFile,
                                          pszInfSection,
                                          m_szInfDir,
                                          NULL,
                                          NULL,
                                          RSC_FLAG_INF | RSC_FLAG_NGCONV | RSC_FLAG_QUIET,
                                          NULL);
        DEBUGMSG("RunSetupCommand = %#lx", hr);
        return hr;
	}

private:
	HMODULE m_hAdvPack;
    RUNSETUPCOMMAND m_pfnRunSetupCommand;
    CHAR m_szInfDir[MAX_PATH+1];
};
	

//=======================================================================
//  DllInstall
//=======================================================================
STDAPI DllInstall(BOOL fInstall, LPCWSTR pszCmdLine)
{
    DEBUGMSG("fInstall = %s, pszCmdLine = %S", fInstall ? "TRUE" : "FALSE", (pszCmdLine == NULL) ? L"NULL" : /*const_cast<LPWSTR>*/(pszCmdLine));

    HRESULT hr = DllRegisterServer();
    DEBUGMSG("DllRegisterServer(), hr = %#lx", hr);

    if ( SUCCEEDED(hr) )
    {
        CRunSetupCommand cmd;

        //TerminateCUN();

        if ( SUCCEEDED(hr = cmd.m_Init()) &&
             //SUCCEEDED(hr = cmd.m_Run("AUBITS12.inf", "DefaultInstall")) &&
             SUCCEEDED(hr = StartWUAUSERVService()) )
        {
            MSIUninstallOfCUN();
            cmd.m_Run("AUCUN.inf", "DefaultUninstall");
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\wuaueng\service.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  xx
//
//  Prototypes of functions defined on service.cpp and used externally. 
//
//  10/19/2001   annah   Created
//
//----------------------------------------------------------------------------

#pragma once

#include "pch.h"

extern SESSION_STATUS gAdminSessions;
extern const TCHAR AU_SERVICE_NAME[];

BOOL AUGetUserToken(ULONG LogonId, PHANDLE pImpersonationToken);
BOOL IsUserAUEnabledAdmin(DWORD dwSessionId);
BOOL IsSession0Active();
BOOL FSessionActive(DWORD dwAdminSession, WTS_CONNECTSTATE_CLASS *pWTSState = NULL);
BOOL IsAUValidSession(DWORD dwSessionId);
BOOL IsWin2K();
void SetClientSessionEvent();
void ResetEngine(void);
void DisableAU(void);
void ServiceFinishNotify(void);

//Current AU Engine version
const DWORD AUENGINE_VERSION = 1;

//Supported Service versions
const DWORD AUSRV_VERSION_1 = 1;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\wuaueng\service.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       service.cpp
//
//--------------------------------------------------------------------------

#include "pch.h"

#pragma hdrstop

SERVICE_STATUS          gMyServiceStatus; 
SERVICE_STATUS_HANDLE   ghMyServiceStatus;
HANDLE			hWorkerThread;
HANDLE			ghServiceFinished ; //= NULL;
HANDLE          ghPolicyChanged; //= NULL;
HANDLE          ghSettingsChanged;  //= NULL;
HANDLE			ghClientSession ; //= NULL;
HANDLE			ghEngineState ; //= NULL;
HANDLE			ghServiceDisabled ; //= NULL;
HANDLE			ghNotifyClient ; //= NULL;
HANDLE			ghValidateCatalog ; //= NULL;
HANDLE 			ghWorkerThreadMsgQueueCreation; //= NULL
DWORD			gdwWorkerThreadId = -1;
CLIENT_HANDLES  ghClientHandles;
CLIENT_NOTIFY_DATA	gClientNotifyData;
DWORD gdwServiceVersion = -1;


SESSION_STATUS gAdminSessions;

BOOL FEnsureValidEvent(HANDLE & hEvent, BOOL fManualState, BOOL fInitialState)
{
	hEvent = CreateEvent(NULL,					// for enable/disable
						  fManualState,		// manual reset
						  fInitialState,	// initial state
						  NULL);	// event name
	return (NULL != hEvent);	
}

void ServiceFinishNotify(void)
{
    DEBUGMSG("ServiceFinishNotify() starts");    
    if (NULL != ghMutex)
    {
        WaitForSingleObject(ghMutex, INFINITE);
        if (NULL != gpAUcatalog)
        {
            gpAUcatalog->CancelNQuit();
        }
        else
        {
            DEBUGMSG("No need to cancel catalag");
        }
        ReleaseMutex(ghMutex);
    }
    //Moving SetEvent to the end of the function since we could potentially have a deadlock if ServiceMain frees the resources (i.e. ghMutex is null) as soon as we call SetEvent
    SetEvent(ghServiceFinished);
    DEBUGMSG("ServiceFinishNotify() ends");
}

//** Returns true if the service was finished otherwise, waits dwSleepTime milliseconds
//** This function assumes that the handle hServiceFinished is actually a handle to
//** AUSERVICE_FINISHED_EVENT
BOOL FServiceFinishedOrWait(HANDLE hServiceFinished, DWORD dwSleepTime)
{
	DEBUGMSG("Entering FServiceFinishedOrWait dwSleepTime=%lu", dwSleepTime);
	DWORD dwRet = WaitForSingleObject(hServiceFinished, dwSleepTime);
	DEBUGMSG("Exiting FServiceFinishedOrWait");
	return (WAIT_OBJECT_0 == dwRet);
}



//utility function
BOOL _IsTokenAdmin(HANDLE hToken)
{
    static SID_IDENTIFIER_AUTHORITY sSystemSidAuthority = SECURITY_NT_AUTHORITY;

    BOOL    fResult = FALSE;
    PSID    pSIDLocalGroup;

    if (AllocateAndInitializeSid(&sSystemSidAuthority,
                                2,
                                SECURITY_BUILTIN_DOMAIN_RID,
                                DOMAIN_ALIAS_RID_ADMINS, // Local Admins
                                0, 0, 0, 0, 0, 0,
                                &pSIDLocalGroup) != FALSE)
    {
        if (!CheckTokenMembership(hToken, pSIDLocalGroup, &fResult))
        {
        	DEBUGMSG("Fail to check token membership with error %d", GetLastError());
            fResult = FALSE;
        }

        FreeSid(pSIDLocalGroup);		
    }
    else
    {    
    	DEBUGMSG("_IsTokenAdmin fail to get AllocateAndInitializeSid with error %d", GetLastError());
    }

    return fResult;
}

//return TRUE if the token has reboot privilege, no matter it is admin or not
//return FALSE otherwise
BOOL fHasRebootPrivilege(HANDLE hToken)
{
    BOOL fResult = FALSE;
    LUID shutdownLuid = {0};
    TOKEN_PRIVILEGES *pTokenPri = NULL;

   if (!LookupPrivilegeValue(NULL, SE_SHUTDOWN_NAME, &shutdownLuid))
   {
        DEBUGMSG("LookupPrivilegeValue() failed with error %lu", GetLastError());
        goto done;
    }

    DWORD dwLen = 0;
    //always fail. try to get buf size
    GetTokenInformation(hToken, TokenPrivileges, NULL , 0, &dwLen);
    if (NULL == (pTokenPri = (TOKEN_PRIVILEGES *) malloc(dwLen * sizeof(BYTE))))
    {
        DEBUGMSG("Fail to alloc memory");
        goto done;
    }

    if (!GetTokenInformation(hToken, TokenPrivileges, pTokenPri, dwLen, &dwLen))
    {
        DEBUGMSG("Fail to get token info with error %d", GetLastError());
        goto done;
    }

    for (DWORD  i = 0; i < pTokenPri->PrivilegeCount; i++)
    {
//        DEBUGMSG("Privilege %d luid = %d Attributes = %d", i, pTokenPri->Privileges[i].Luid, pTokenPri->Privileges[i].Attributes);
        if (shutdownLuid.LowPart == pTokenPri->Privileges[i].Luid.LowPart 
            && shutdownLuid.HighPart == pTokenPri->Privileges[i].Luid.HighPart)
        {
            fResult = TRUE;
            goto done;
        }
    }
   
done:
//    DEBUGMSG("fHasRebootPrivilege return %s", fResult ? "true" : "false");
    SafeFreeNULL(pTokenPri);
    return fResult;
        
}



//fixcode: return primary token instead
BOOL AUGetUserToken(ULONG LogonId, PHANDLE pImpersonationToken)
{
	BOOL fRet;
	HANDLE hUserToken;

    // _WTSQueryUserToken is defined on tscompat.cpp
	if (fRet = _WTSQueryUserToken(LogonId, &hUserToken))
	{
//		DEBUGMSG("WUAUENG AUGetUserToken() succeeded WTSQueryUserToken");
		if (!(fRet =DuplicateTokenEx(hUserToken, TOKEN_QUERY|TOKEN_DUPLICATE|TOKEN_IMPERSONATE , NULL, SecurityImpersonation, TokenImpersonation, pImpersonationToken)))
		{
			DEBUGMSG("WUAUENG AUGetUserToken() DuplicateTokenEx failed");
		}
		CloseHandle(hUserToken);
	}
#ifdef DBG
	else // all failure 
	{	
		DEBUGMSG("WUAUENG AUGetUserToken() failed WTSQueryUserToken with session= %d, error=%d", LogonId, GetLastError());
	}
#endif

	return fRet;
}

BOOL IsUserAUEnabledAdmin(DWORD dwSessionId)
{
    HANDLE hImpersonationToken;
	BOOL   fDisableWindowsUpdateAccess = TRUE;

	if (AUGetUserToken(dwSessionId, &hImpersonationToken))
	{		
		// If user is an admin, impersonate them and steal their current user reg settings
		if( _IsTokenAdmin(hImpersonationToken) )
		{
			HKEY hCurrentUserKey;

			//Bother to check for the policy only if it is an Admin session
			if (!ImpersonateLoggedOnUser(hImpersonationToken))
			{
				DEBUGMSG("WUAUENG fail to ImpersonateLoggedOnUser() with error %d", GetLastError());
				CloseHandle(hImpersonationToken);
				goto done;
			}

			if(RegOpenCurrentUser(KEY_READ, &hCurrentUserKey) == ERROR_SUCCESS)
			{
                        HKEY   hkeyPolicy;	

                        if (ERROR_SUCCESS != RegOpenKeyEx(
                        					hCurrentUserKey,
                        					AUREGKEY_HKCU_USER_POLICY,
                        					0,
                        					KEY_READ,
                        					&hkeyPolicy))
                        {
                            fDisableWindowsUpdateAccess = FALSE;
                        }
                        else
                        {						
                            DWORD dwData;
                            DWORD dwType = REG_DWORD;
                            DWORD dwSize = sizeof(dwData);
                        	if ((ERROR_SUCCESS != RegQueryValueEx(
                        		hkeyPolicy,
                        		AUREGVALUE_DISABLE_WINDOWS_UPDATE_ACCESS,
                        		NULL,
                        		&dwType,
                        		(LPBYTE)&dwData,
                        		&dwSize)) ||
                        		(REG_DWORD != dwType) ||
                        		(1 != dwData) )
                        	{																
                        		fDisableWindowsUpdateAccess = FALSE;											
                        	}
                        	RegCloseKey(hkeyPolicy);
                        }
                        RegCloseKey(hCurrentUserKey);
			}
			RevertToSelf();
		}

		CloseHandle(hImpersonationToken);
	}	
	else
	{
		DEBUGMSG("WUAUENG AUGetUserToken in AUServiceHandler failed for session= %d, error=%d", dwSessionId, GetLastError());	
	}		
	
done:
	return (!fDisableWindowsUpdateAccess);	
}

BOOL IsSession0Active()
{
	BOOL fRet = FALSE;

        //DEBUGMSG("In IsSession0Active()");
	
	HWINSTA hwinsta = OpenWindowStation(_T("WinSta0"), FALSE, WINSTA_READATTRIBUTES);
	
	if (NULL == hwinsta)
	{		
		DEBUGMSG("WUAUENG OpenWindowStation failed");
		goto Done;
	}

	DWORD dwLength;
	USEROBJECTFLAGS stFlags;
	if (GetUserObjectInformation(hwinsta, UOI_FLAGS, (void *)&stFlags, sizeof(stFlags), &dwLength)
		&& (stFlags.dwFlags & WSF_VISIBLE))
	{
		// If there is no user associeted dwLenght is 0
		DWORD dwBuff;
		if (GetUserObjectInformation(hwinsta, UOI_USER_SID, (PVOID) &dwBuff, sizeof(DWORD), &dwLength))
		{
			fRet = dwLength > 0;
		}
		else
		{
			fRet = (ERROR_INSUFFICIENT_BUFFER == GetLastError()); 
		}
	}	
	else
	{
		DEBUGMSG("WUAUENG GetUserObjectInformation failed = %d", GetLastError());
	}
Done:
    if(NULL != hwinsta)
    {
        CloseWindowStation(hwinsta);
    }
	return fRet;
}


inline BOOL FOnlySession0WasLoggedOnBeforeServiceStarted()
{				
	/*We check for only one Sesion logged on because:
	1) When Terminal Services are enabled, Session State can be WTSConnected and the session is actually 
	   logged on (active), but since Terminal Services hadn't been started before the user logged on, they
	   didn't know and could not set the session to WTS Active and left it in WTSConnected. If there is more 
	   than one session, we don't know for sure if Session0's state is WTSConnected but really active or not,
	   we don't want to run the risk of launching the client in an inactive session	   
	*/	
	SESSION_STATE *pSessionState;

	return (gAdminSessions.m_FGetSessionState(0, &pSessionState) && pSessionState->fFoundEnumerating && 1 == gAdminSessions.CSessions());
}

BOOL FSessionActive(DWORD dwAdminSession, WTS_CONNECTSTATE_CLASS *pWTSState)
{
	LPTSTR  pBuffer;			
	DWORD dwBytes;
	WTS_CONNECTSTATE_CLASS wtsState = WTSDown;
	BOOL fRet = FALSE;

    // we might not be able to getthe TS status for the session,
    // so initialize WTSStatus with an invalid value (WTS Status is an enum of positive integers)
    if (_IsTerminalServiceRunning())
    {
             if (WTSQuerySessionInformation(WTS_CURRENT_SERVER_HANDLE, dwAdminSession, WTSConnectState, 
                &pBuffer, &dwBytes))		
            {
               	wtsState = *((WTS_CONNECTSTATE_CLASS *)pBuffer);

                WTSFreeMemory(pBuffer);

             //DEBUGMSG("FSessionActive() get session state = %d for session %d", wtsState, dwAdminSession);

             if (WTSActive == (wtsState) || ((0 == dwAdminSession) && FOnlySession0WasLoggedOnBeforeServiceStarted()))
                {
     //			DEBUGMSG("WUAUENG Active Admin Session =%d", dwAdminSession);
                          fRet = TRUE;
        			goto done;
                }		
            }	
            else
            {
 	        DEBUGMSG("FSessionActive() fail to call WTSQuerySessionInformation");
            }
    }
    else
	{	
		if ((dwAdminSession == 0) && IsSession0Active())
 		{
 			//DEBUGMSG("WUAUENG Active Admin Session = 0");
			wtsState = WTSActive;
			fRet = TRUE;
			goto done;
		}
	}


done:
	if (fRet && NULL != pWTSState)
	{
		*pWTSState = wtsState;
	}
	return fRet;
}

  

// This function is only called on Win2K code, and as such contains specific logic that relates to
// how login/logoff are handled on win2k.
BOOL IsAUValidSession(DWORD dwSessionId)
{
    WTS_CONNECTSTATE_CLASS SessionState;

    // using this function only the retreive the current session status
    FSessionActive(dwSessionId, &SessionState);

    if ((SessionState == WTSActive || SessionState == WTSConnected || SessionState == WTSDisconnected) &&
        IsUserAUEnabledAdmin(dwSessionId))
    {
        DEBUGMSG("WUAUENG ValidateSession succeeded for session %d", dwSessionId);
        return TRUE;
    }
    else
    {
        DEBUGMSG("WUAUENG ValidateSession failed for session %d", dwSessionId);
        return FALSE;
    }
}

//** returns the first Active Admin Sesion ID available 
//** returns -1 if there is no Active Admin session at all
//** dwIgnoreSession is the SessionID that will not be considered as a candidate
//** for available admin sessions 
DWORD GetAllowedAdminSessionId(BOOL fGetSessionForRemindMe)
{
	DWORD dwAdminSession;	

//	DEBUGMSG("GetAllowedAdminSessionId() starts");
//Sleep 15 seconds before we check Session Status so that we can get accurate information if there 
//is an Admin Logging Off or any other Session Change notification. This is because it takes a while before 
//the session information shows right info	
    if (FServiceFinishedOrWait(ghServiceFinished, 15000))
    {
 	return DWNO_ACTIVE_ADMIN_SESSION_SERVICE_FINISHED;
    }
    
    if (IsWin2K())
    {
        DEBUGMSG("WUAUENG Forcing the session cache to be rebuilt (needed on win2k as we don't track logoffs).");
        gAdminSessions.ValidateCachedSessions();
    }

	//if for remind later timeout, try to use the same session as last time
	if (fGetSessionForRemindMe && gAdminSessions.m_FGetCurrentSession(&dwAdminSession) && FSessionActive(dwAdminSession))
	{
        return dwAdminSession;
	}

	for (int nSession = 0; nSession < gAdminSessions.CSessions(); nSession++)
	{ // get next available active session
		if (gAdminSessions.m_FGetNextSession(&dwAdminSession) && FSessionActive(dwAdminSession))			
                {
                	DEBUGMSG(" found available admin %d", dwAdminSession);
                    goto Done;
                }
    }

    dwAdminSession = DWNO_ACTIVE_ADMIN_SESSION_FOUND;

Done:
//	DEBUGMSG("GetAllowedAdminSessionId() ends");
	return dwAdminSession;	
}

//return TRUE if AU client stopped.
//return FALSE otherwise
void AUStopClients(BOOL fWaitTillCltDone = FALSE, BOOL fRelaunch = FALSE)
{
    if ( ghClientHandles.fClient() )
    {
		ghClientHandles.StopClients(fRelaunch);
		if (fWaitTillCltDone)
		{
		    ghClientHandles.WaitForClientExits();
		}
    }
}

////////////////////////////////////////////////////////////////////////////////////////
// notify workerclient thread when session info changed and when we need to do sth accordingly either by launching more client or reboot
////////////////////////////////////////////////////////////////////////////////////////
void SetClientSessionEvent()
{
	if (NULL != ghClientSession)	
	{	
		DEBUGMSG("WUAUENG AUACTIVE_ADMIN_SESSION_EVENT triggered ");		
		SetEvent(ghClientSession);
	}
	else
	{
	    AUASSERT(FALSE);
            DEBUGMSG("WUAUENG No  AUACTIVE_ADMIN_SESSION_EVENT handle settup propperly");
	}
}

BOOL FDownloadIsPaused()
{
	DWORD dwStatus;
	UINT upercentage;

	return ((AUSTATE_DOWNLOAD_PENDING == gpState->GetState()) &&
		(SUCCEEDED(GetDownloadStatus(&upercentage, &dwStatus, FALSE))) && 
		(DWNLDSTATUS_PAUSED == dwStatus));
}


BOOL fJustUpgraded()
{
	DWORD dwResetAU = 0;
	if (FAILED(GetRegDWordValue(_T("ResetAU"), &dwResetAU)))
	{
		dwResetAU = 0;
	}	
	return  (1 == dwResetAU);
}
		

///////////////////////////////////////////////////////////////////////////////////
// return nothing
//////////////////////////////////////////////////////////////////////////////////
void ProcessInitialState(WORKER_THREAD_INIT_DATA * pinitData, BOOL fUpgraded)
{
     DWORD AuState;

       pinitData->uFirstMsg = -1;
       pinitData->fWaitB4Detect = FALSE;
       pinitData->dwWaitB4Detect = 0;

	// check if the system was just restored.
	if ( gpState->fWasSystemRestored() )
	{
		DEBUGMSG("The system was restored, going to state AUSTATE_DETECT_PENDING");
		AuState = AUSTATE_DETECT_PENDING;
		gpState->SetState(AuState);
	}
	else
	{
		AuState = gpState->GetState();
	}
	
	DEBUGMSG("WUAUENG Starting update cycle in state %d", gpState->GetState());
	// all states after Detect Pending require catalog validation

	switch(AuState)
	{
		case AUSTATE_OUTOFBOX:	
        		{
        		    pinitData->uFirstMsg = AUMSG_INIT;
        		    break;
			}		
		case AUSTATE_NOT_CONFIGURED:
        		    break;
		case AUSTATE_DISABLED:
                        if (gpState->fOptionEnabled())
                        {
                           	gpState->SetState(AUSTATE_DETECT_PENDING);
        			pinitData->uFirstMsg = AUMSG_DETECT;
                        }
                        break;
		
		case AUSTATE_DETECT_PENDING:
			pinitData->uFirstMsg = AUMSG_DETECT;
			break;

		case AUSTATE_DETECT_COMPLETE:
    		case AUSTATE_DOWNLOAD_COMPLETE:		
			if (FAILED(gpAUcatalog->Unserialize()))
			{
				DEBUGMSG("WUAUENG catalog unserializing failed. State -> Detect Pending");
				gpState->SetState(AUSTATE_DETECT_PENDING);
        			pinitData->uFirstMsg = AUMSG_DETECT;
				break;
			}
                    break;
		
		case AUSTATE_DOWNLOAD_PENDING:
		      {
                      if (FAILED(gpAUcatalog->Unserialize()))
                      {
                          	DEBUGMSG("WUAUENG catalog unserializing failed. State -> Detect Pending");
                          	gpState->SetState(AUSTATE_DETECT_PENDING);
        			pinitData->uFirstMsg = AUMSG_DETECT;
                          	break;
                      }
                      ResumeDownloadIfNeccesary();
      			pinitData->uFirstMsg = AUMSG_DOWNLOAD;
  			break;
                    }
	
		case AUSTATE_INSTALL_PENDING:
			// enter this code path when restore system restore point and after reboot completed
			DEBUGMSG("WUAUENG in INSTALL_PENDING state, State->Detect Pending");
			gpState->SetState(AUSTATE_DETECT_PENDING);
			pinitData->uFirstMsg = AUMSG_DETECT;
			break;
		case AUSTATE_WAITING_FOR_REBOOT:
			{
				if (!fCheckRebootFlag())
				{	
					//if there is no Reboot flag and the state was WAINTING_FOR_REBOOT means there was a 
					//a reboot and now it is time to set to DETECT_PENDING but wait for random hours
					gpState->SetState(AUSTATE_DETECT_PENDING);
                                   pinitData->fWaitB4Detect = TRUE;
                                   pinitData->dwWaitB4Detect = RandomWaitTimeBeforeDetect();
                                   pinitData->uFirstMsg = AUMSG_DETECT;
				}
				break;
			}
		default:
			{
			DEBUGMSG("WUAUENG ERROR Startup state = %d", AuState);
#ifdef DBG
			(void)ServiceFinishNotify();				
#endif
			break;
			}
	}


	if( fUpgraded )
	{
		DEBUGMSG("AU got upgraded, resetting state to detect_pending");
		DWORD dwNewState = gpState->GetState();
		if( dwNewState > AUSTATE_DETECT_PENDING )
		{ //reset au engine after sp upgrade
       		if (AUSTATE_DISABLED != dwNewState && AUSTATE_WAITING_FOR_REBOOT != dwNewState)
       		{
	       		CancelDownload();
       			gpState->SetState(AUSTATE_DETECT_PENDING);
	       		pinitData->fWaitB4Detect = FALSE; //start detection right away
				pinitData->dwWaitB4Detect = 0;
				pinitData->uFirstMsg = AUMSG_DETECT;
       		}
		}
		DeleteRegValue(_T("ResetAU"));
	}

	SetEvent(ghEngineState); //jump start workerclient
	return ;
}



DWORD WINAPI ServiceHandler(DWORD fdwControl, DWORD dwEventType, LPVOID pEventData, LPVOID /*lpContext*/)
{
	switch(fdwControl)
	{
		case SERVICE_CONTROL_STOP:
		case SERVICE_CONTROL_SHUTDOWN:
			gMyServiceStatus.dwCurrentState	= SERVICE_STOP_PENDING;
			if (SERVICE_CONTROL_SHUTDOWN == fdwControl)
				{
				DEBUGMSG("WUAUENG AUServiceHandler received SERVICE_CONTROL_SHUTDOWN");
				}
			else if (SERVICE_CONTROL_STOP == fdwControl)
				{
				DEBUGMSG("WUAUENG AUServiceHandler received SERVICE_CONTROL_STOP");			
				}
			SetServiceStatus(ghMyServiceStatus, &gMyServiceStatus);
			(void)ServiceFinishNotify();			
			break;

		case SERVICE_CONTROL_INTERROGATE:
			SetServiceStatus(ghMyServiceStatus, &gMyServiceStatus);
			break;

        //
        // ATT: On Win2K this case will never be called. To replace this code, we will be 
        // subscribing to SENS (see ausens.cpp) and subscribing to logon/logoff notifications.
        // The SENS callbacks will call the same code it is called here for non-Win2K systems:
        // OnUserLogon and OnUserLogoff.
        // Note however that SENS will not raise notifications for CONNECT/DISCONNECTS, so
        // there's a change of functionality implied by this different code path.
        //
		case SERVICE_CONTROL_SESSIONCHANGE:
			{
				if (pEventData && !IsWin2K())
				{
					WTSSESSION_NOTIFICATION* pswtsi = (WTSSESSION_NOTIFICATION*)pEventData;
					DWORD dwSessionId = pswtsi->dwSessionId;

					switch (dwEventType)
					{
                                        case WTS_CONSOLE_CONNECT:
                                        case WTS_REMOTE_CONNECT:    
							{								
								DEBUGMSG("WUAUENG session %d connected via %s", dwSessionId, 
								        WTS_CONSOLE_CONNECT==dwEventType ? "console" : "remote");
								//check if session is cached
								if (gAdminSessions.m_FGetSessionState(dwSessionId, NULL))
								{
									SetClientSessionEvent();
								}
								else
								{
									if (gAdminSessions.CacheSessionIfAUEnabledAdmin(dwSessionId, FALSE))
									{ //only add it if it is not cached and is AU enabled Admin
										SetClientSessionEvent();
									}
								}
								break;
							}							
                                        case WTS_CONSOLE_DISCONNECT:
                                        case WTS_REMOTE_DISCONNECT:	
							{					
								DEBUGMSG("WUAUENG session %d disconnected via %s", dwSessionId,
								        WTS_CONSOLE_DISCONNECT==dwEventType ? "console" : "remote");
								if (!gpState->fRebootWarningMode() && ghClientHandles.fClient())
								{
									DWORD dwCurAdminSessionId;
									if (gAdminSessions.m_FGetCurrentSession(&dwCurAdminSessionId) &&
									    dwSessionId == dwCurAdminSessionId && 
										!FDownloadIsPaused())
									{
										DEBUGMSG("WUAUENG stopping client");									
                                                                      AUStopClients(FALSE, TRUE); //non blocking
									}
								}			
								break;
							}				        
                                        case WTS_SESSION_LOGON:
							{											
								DEBUGMSG("WUAUENG session %d logged ON ", dwSessionId);
                                            		if ((gpState->fRebootWarningMode())
								    ||gAdminSessions.CacheSessionIfAUEnabledAdmin(dwSessionId, FALSE))
                                                        {
                                                            SetClientSessionEvent();									
                                                        }
								break;
							}						
						case WTS_SESSION_LOGOFF:
							{
        							DEBUGMSG("WUAUENG session %d logged OFF", dwSessionId);
                                                        gAdminSessions.m_FDeleteSession(dwSessionId);
                                                        if (gpState->fRebootWarningMode())
                                                        {
                                                            SetClientSessionEvent();
                                                        }
								break;
							}
						default:  /* WTS_SESSION_LOCK, WTS_SESSION_UNLOCK,WTS_SESSION_REMOTE_CONTROL*/
							break;
					}
				}					
				break;
			}
		default:
			return ERROR_CALL_NOT_IMPLEMENTED;
	}	

	return NO_ERROR ;		
}


BOOL WaitForShell(void)
{
    HANDLE hShellReadyEvent;
    UINT uCount = 0;
    BOOL fRet = FALSE;

    if (IsWin2K())
    {
        DEBUGMSG("WUAUENG WUAUSERV Ignoring WaitForShell on Win2K");
        fRet =  FALSE;   // we're not leaving because the service has finished.
        goto done;
    }

    while ((hShellReadyEvent = OpenEvent(SYNCHRONIZE, FALSE, TEXT("ShellReadyEvent"))) == NULL) {
        if ( FServiceFinishedOrWait(ghServiceFinished, dwTimeToWait(AU_TEN_SECONDS) ))
        {
            fRet =  TRUE;
            goto done;
        }
        if (uCount++ > 6) 
        {
            DEBUGMSG("ShellReadyEvent not set after one min");
            goto done;
        }
   }
 
  HANDLE hEvents[2] = {hShellReadyEvent, ghServiceFinished};
  DWORD dwRet  = WaitForMultipleObjects(2, hEvents, FALSE, INFINITE);
  if (WAIT_OBJECT_0 + 1 == dwRet)
  {
     fRet = TRUE;
  }
  else
  {
    DEBUGMSG("WUAUENG: ShellReadyEvent kicked");
  }
  CloseHandle(hShellReadyEvent);
 done:
    return fRet;
}


//=======================================================================
//  Calculate Reminder Time
//=======================================================================
inline HRESULT CalculateReminderTime(DWORD *pdwSleepTime /*in secs, no prorate*/)
{
    DWORD dwTimeOut;
    UINT index;
	
    *pdwSleepTime = 0;
    HRESULT hr = getReminderTimeout(&dwTimeOut, &index);

	if ( SUCCEEDED(hr) )
	{		
		DWORD dwReminderState = AUSTATE_DETECT_COMPLETE;
		AUOPTION auopt = gpState->GetOption();
		DWORD dwCurrentState = gpState->GetState();

		getReminderState(&dwReminderState);
		if (dwCurrentState != dwReminderState)
		{
			// Invalidate reminder timeout
			hr = E_FAIL;
		}
		// bug 502380
		// Wake up immediately if AUOptions was changed
		// from 2->3 during AUSTATE_DETECT_COMPLETE,
		// or from 2/3->4, has AU been running or not.
		else if (AUOPTION_SCHEDULED == auopt.dwOption ||
				 (AUOPTION_INSTALLONLY_NOTIFY == auopt.dwOption &&
				  AUSTATE_DETECT_COMPLETE == dwCurrentState))
		{
			DEBUGMSG("WUAUENG reminder no longer applies");
		}
		else
		{
			*pdwSleepTime = dwTimeOut;
		}
		if (0 == *pdwSleepTime)
		{
		    // reminder time is up
			removeReminderKeys();
		}
	}

    return hr;
}

void RebootNow()
{
	// Set AUState to "waiting for reboot" just in case anything fails in this function
	DEBUGMSG("WUAUENG in AUSTATE_WAITING_FOR_REBOOT state");
	gpState->SetState(AUSTATE_WAITING_FOR_REBOOT);

	DEBUGMSG("WUAUENG initiating shutdown sequence...");

	HANDLE currentToken;
	if(OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &currentToken))
	{
		LUID shutdownluid;
		if(LookupPrivilegeValue(NULL, SE_SHUTDOWN_NAME, &shutdownluid) != 0)
		{
			BYTE OldPrivBuf[30]; //should be big enough to host one privilege entry
			TOKEN_PRIVILEGES privileges;
			ULONG cbNeeded = 0;
			privileges.PrivilegeCount = 1;
			privileges.Privileges[0].Luid = shutdownluid; 
			privileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
			ZeroMemory(OldPrivBuf, sizeof(OldPrivBuf));
			if (AdjustTokenPrivileges(currentToken, FALSE, &privileges, sizeof(OldPrivBuf), (PTOKEN_PRIVILEGES)OldPrivBuf, &cbNeeded))
			{
                            if (InitiateSystemShutdown(NULL, NULL, 0, TRUE, TRUE))
                            {
                            	DEBUGMSG("WUAUENG first reboot successfully issued");
                            }
                            else
                            {
                            	DEBUGMSG("Warning: Wuaueng fail to issue first reboot with error %lu", GetLastError());
                            }

				const DWORD c_dwRetryWaitTimeInMS = 10000;
				DWORD dwRetryCountDown = 30;

				DEBUGMSG("WUAUENG keep on forcing restart until service finish");
				while ((0 < --dwRetryCountDown) &&
					   (WAIT_TIMEOUT == WaitForSingleObject(ghServiceFinished, c_dwRetryWaitTimeInMS)))
				{
					if (ExitWindowsEx(EWX_REBOOT | EWX_FORCE, 0))
					{
						DEBUGMSG("WUAUENG forceful reboot successfully issued");
					}
					else
					{
						DEBUGMSG("Warning: Wuaueng fail to reboot with error %lu; retry in %d secs", GetLastError(), c_dwRetryWaitTimeInMS / 1000);
					}
				}

				if (((PTOKEN_PRIVILEGES)OldPrivBuf)->PrivilegeCount > 0)
				{
					AdjustTokenPrivileges(currentToken, FALSE, (PTOKEN_PRIVILEGES)OldPrivBuf, 0, NULL, NULL); //restore privious privileges
				}
			}
			else
			{
				DEBUGMSG("Warning: wuaueng fail to adjust token previlege with error %d", GetLastError());
			}
		}
		else
		{
			DEBUGMSG("Warning: wuaueng fail to look up privilege value with error %lu", GetLastError());
		}
		CloseHandle(currentToken);
	}
	else
	{
		DEBUGMSG("Warning: Wuaueng fail to get process token to enable reboot with error %lu", GetLastError());
	}
}


//=======================================================================
//  ProcessClientFinished()
//=======================================================================
void ProcessClientFinished(CAUWait & wait, HANDLE hClientProcess, BOOL fInterestingClt)
{
    DEBUGMSG("ProcessClientFinished");

	// if client returns from installing, change state.
	//if the client exited because there was a timeout (due to no user interaction),
	//make sure that the session in which it (client) was launched will not be selected again										
	DWORD dwExitProc;	
	BOOL fRet = GetExitCodeProcess(hClientProcess, &dwExitProc);
	BOOL fRebootWarningMode = gpState->fRebootWarningMode();
	ghClientHandles.RemoveHandle(hClientProcess);																

	if (AUSTATE_DOWNLOAD_PENDING == gpState->GetState())							
	{// resume job if needed after user logs off or au client torn down
	    ResumeDownloadIfNeccesary();
	}

	if (!fRet)
	{
		DEBUGMSG("WUAUENG GetExitCodeProcess failed, last Error= %lu", GetLastError());
		wait.Reset();
	}		
       else
	{
		DEBUGMSG("WUAUENG GetExitCodeProcess succeeded, sessionId is = %d, dwExitProc is = %lu", 0 , dwExitProc);
		if (!fInterestingClt)
		{ // for non admin without capability to reboot, don't look at its return code
			DEBUGMSG("WUAUENG notice wuauclt returned with no need to look at return code");
			return; 
		}
		if (CDWWUAUCLT_REBOOTTIMEOUT == dwExitProc || 
			(((STATUS_SUCCESS == dwExitProc) ||
			  (DBG_TERMINATE_PROCESS == dwExitProc) ||
			  (CDWWUAUCLT_ENDSESSION == dwExitProc))
			&& fRebootWarningMode))
		{
			DEBUGMSG("WUAUENG reboot warning client log off or time out ");
                    return;
		}
		//no need to wait for other clients
		wait.Reset();
              switch(dwExitProc)
			{													
				case CDWWUAUCLT_OK:
				{
					if ( AUSTATE_INSTALL_PENDING == gpState->GetState() )
					{
						DEBUGMSG("WUAUENG Install done, State->Detect Pending");
						gpState->SetState(AUSTATE_DETECT_PENDING);
						PostThreadMessage(gdwWorkerThreadId, AUMSG_POST_INSTALL, 0, 0);
					}
					break;
				}
				case CDWWUAUCLT_RELAUNCHNOW:
				{
                                    wait.Timeout(AUEVENT_RELAUNCH_TIMEOUT, 0);
					break;
				}
				case CDWWUAUCLT_RELAUNCHLATER:			// sleep a while before relaunching client if asked by client
				{
                                    //
                                    // Fix for bug 493026
                                    // Annah: Relaunching the client was taken too long because time of wait need to be specified in seconds
                                    // (AU constants are already defined in seconds and dwWait should be in seconds).
                                    //									 
					DEBUGMSG("WUAUENG wait for 3 min before relaunching WUAUCLT");													
			              wait.Timeout(AUEVENT_RELAUNCH_TIMEOUT, AU_THREE_MINS);
					break;
				}
                            // STATUS_SUCCESS is the exit code for wuauclt.exe on Win2k and also for some cases of NtTerminateProcess (like pskill.exe)
                            case STATUS_SUCCESS:      
				case DBG_TERMINATE_PROCESS:
				case CDWWUAUCLT_ENDSESSION:	// user logs off or system shuts down
				{
					//This is the only time that the service will Set the Engine State change event.
					//The client was terminated by the debugger and it didn't have the chance to set the event
					//and it is necessesary so that this loop (fServiceFinished) doesn't get stuck
					//this exit code is also returned when user logs off the session
                                    if (fCheckRebootFlag())
					{ //AU client killed while showing waiting for reboot
						DEBUGMSG("WUAUENG in AUSTATE_WAITING_FOR_REBOOT state");
					    gpState->SetState(AUSTATE_WAITING_FOR_REBOOT);
					}
					else if (AUSTATE_INSTALL_PENDING == gpState->GetState())
                                    { //AU client killed while installing 
                                        /*
                                         if (S_OK != (gpAUcatalog->ValidateItems(FALSE)))
                                        { //no items to install anymore
                                              ResetEngine(); 
                                        }
                                         else */
                                         { //show uninstall items again.
                                            gpState->SetState(AUSTATE_DOWNLOAD_COMPLETE);
                                         }
                                    }
                                    else
                                    {
                                        wait.Timeout(AUEVENT_RELAUNCH_TIMEOUT, 0);
                                    }
					break;
				}	
				case CDWWUAUCLT_INSTALLNOW:
				    {
				        //user say yes to install warning dialog
				        //launch client install via local system right away
				        gpState->SetCltAction(AUCLT_ACTION_AUTOINSTALL);
      					wait.Add(AUEVENT_DO_DIRECTIVE); //reenter workclient loop right away
				        break;
				    }
				case CDWWUAUCLT_REBOOTNOW:
				    { //now in install_pending state
				            DEBUGMSG("WUAUENG rebooting machine");
				            AUStopClients(TRUE); //stop all clients
                                        RebootNow();
					        break;
				    }
				case CDWWUAUCLT_REBOOTLATER:
				    {
			                DEBUGMSG("WUAUENG change to AUSTATE_WAITING_FOR_REBOOT state");
			                AUStopClients(TRUE); //stop all clients
				            gpState->SetState(AUSTATE_WAITING_FOR_REBOOT);
				            break;
				    }
				case CDWWUAUCLT_REBOOTNEEDED:
				        { //now in install_pending state
				            DEBUGMSG("WUAUENG need to prompt user for reboot choice");
				            gpState->SetCltAction(AUCLT_ACTION_SHOWREBOOTWARNING);
                                        wait.Add(AUEVENT_DO_DIRECTIVE); //reenter workclient loop right away
				            break;
				    }

                            case CDWWUAUCLT_FATAL_ERROR:
				default:
				{			
       				(void)ServiceFinishNotify();
					break;
				}
			}
        }
}

#if 0
inline BOOL fUserAvailable()
{
    return (DWNO_ACTIVE_ADMIN_SESSION_FOUND != gdwAdminSessionId);
}
#endif


//////////////////////////////////////////////////////////////////////////////////////////////
// launch reboot warning UI (auto or manual) for logged on users who haven't got the UI yet
// if there is no logged on user anymore, reboot
// reboot warning UI will show the time left for the count down in case of auto reboot
// wait : IN wait object to add client handles to 
// fFirstRunPerCycle: IN if TRUE, reset the internal reboot warning startup time clock to current time and set wait timeout
//////////////////////////////////////////////////////////////////////////////////////////////
void ProcessRebootWarning(CAUWait & wait, BOOL fFirstRunPerCycle = FALSE)
{
	PROCESS_INFORMATION ProcessInfo;	
	SESSION_STATUS LoggedOnSessions;
	HANDLE hCltExitEvt;
	TCHAR szCmd[MAX_PATH+1];	
	LPTSTR lpszEnvBuf = NULL;
        BOOL fManualReboot = gpState->m_fNoAutoRebootWithLoggedOnUsers();
        static DWORD dwStartTickCount = 0;

        DEBUGMSG("ProcessRebootWarning() starts with FirstRun = %d and Manual = %d", fFirstRunPerCycle, fManualReboot);
      	LoggedOnSessions.Initialize(FALSE, TRUE);
        if (fFirstRunPerCycle)
        {
            dwStartTickCount = GetTickCount();
            gpState->EnterRebootWarningMode();
        }

        //wait for log on or log off to settle down before create the client if not first run
       if (!fFirstRunPerCycle && FServiceFinishedOrWait(ghServiceFinished, 15000))
	{
		goto done;
	}

       LoggedOnSessions.CacheExistingSessions();

        if (0 == LoggedOnSessions.CSessions())
        {
                 RebootNow();
                 goto done;
        }

	memset(&ProcessInfo, 0, sizeof(ProcessInfo));

	UINT ulen = GetSystemDirectory(szCmd, ARRAYSIZE(szCmd));
	if (0 == ulen || ulen >= ARRAYSIZE(szCmd))
	{
		DEBUGMSG("WUAUENG Could not get system directory");
		goto done;
	}

	const TCHAR szAUCLT[] = _T("wuauclt.exe");
	if (FAILED(PathCchAppend(szCmd, ARRAYSIZE(szCmd), szAUCLT)))
	{
		DEBUGMSG("WUAUENG Could not form full path to wuauclt.exe");
		goto done;
	}

	const size_t c_cchEnvBuf = AU_ENV_VARS::s_AUENVVARCOUNT * (2 * AU_ENV_VARS::s_AUENVVARBUFSIZE + 2) + 1;
	if (NULL == (lpszEnvBuf = (LPTSTR) malloc(c_cchEnvBuf * sizeof(TCHAR))))
	{
		DEBUGMSG("Fail to allocate memory for string for environment variables");
		goto done;
	}

	for (int nSession = 0; nSession < LoggedOnSessions.CSessions(); nSession++)
	{ 
        	DWORD dwLoggedOnSession = -1;
        	if (LoggedOnSessions.m_FGetNextSession(&dwLoggedOnSession) && !ghClientHandles.fClient(dwLoggedOnSession))
                {  //find a session which doesn't have reboot warning UI yet
                    AU_ENV_VARS auEnvVars;
                    HANDLE hImpersonationToken = NULL;																	
                    HANDLE hUserToken = NULL;
                    TCHAR szClientExitEvtName[100];

                    DEBUGMSG("WUAUENG launch client in session %d", dwLoggedOnSession);
                    szClientExitEvtName[0] = TCHAR('\0');
                    if (!ghClientHandles.CreateClientExitEvt(szClientExitEvtName, ARRAYSIZE(szClientExitEvtName)))
                    {
                        DEBUGMSG("Fail to create client exit event with error %d", GetLastError());
                        continue;
                    }

                    if (!AUGetUserToken(dwLoggedOnSession, &hImpersonationToken))
			{								
				DEBUGMSG("WUAUENG WARNING: fails AUGetUserToken");
				continue;
			}

                    BOOL fRebootEnabled = fHasRebootPrivilege(hImpersonationToken);
			  
			if (!DuplicateTokenEx(hImpersonationToken, TOKEN_QUERY|TOKEN_DUPLICATE|TOKEN_ASSIGN_PRIMARY , NULL,
				SecurityImpersonation, TokenPrimary, &hUserToken))								
			{
				DEBUGMSG("WUAUENG WARNING: Could not DuplicateTokenEx, dw=%d", GetLastError());								
				CloseHandle(hImpersonationToken);
				continue;
			}

		  	CloseHandle(hImpersonationToken);
		  	BOOL fAUAdmin = IsUserAUEnabledAdmin(dwLoggedOnSession);
		  	BOOL fEnableYes = (1 == LoggedOnSessions.CSessions()) && fRebootEnabled; //only if the logged on user has reboot privilege and there is only one user
		  	BOOL fEnableNo = fAUAdmin;
			if (!auEnvVars.WriteOut(lpszEnvBuf, c_cchEnvBuf, fEnableYes, fEnableNo, fManualReboot, dwStartTickCount, szClientExitEvtName))
			{
				DEBUGMSG("WUAUENG Could not write out environment variables");
				CloseHandle(hUserToken);
				continue;
			}
			LPVOID envBlock;
			if (!CreateEnvironmentBlock(&envBlock, hUserToken, FALSE))
			{
				DEBUGMSG("WUAUENG fail to get environment block for user");
				CloseHandle(hUserToken);
				continue;
			}

			STARTUPINFO StartupInfo;								
			memset(&StartupInfo, 0, sizeof(StartupInfo));
			StartupInfo.cb = sizeof(StartupInfo);
			StartupInfo.lpDesktop = _T("WinSta0\\Default");																	

			if (!CreateProcessAsUser(hUserToken, szCmd, lpszEnvBuf, NULL, NULL, FALSE /*Inherit Handles*/ , 
					DETACHED_PROCESS|CREATE_UNICODE_ENVIRONMENT, envBlock, NULL, &StartupInfo, &ProcessInfo))
			{
				DEBUGMSG("WUAUENG Could not CreateProcessAsUser (WUAUCLT), dwRet = %d", GetLastError());
			    DestroyEnvironmentBlock(envBlock);
			    CloseHandle(hUserToken);
			    continue;
			}	
			DestroyEnvironmentBlock(envBlock);
			CloseHandle(hUserToken);
		   	DEBUGMSG("WUAUENG Created the client service (WUAUCLT)");
			ghClientHandles.AddHandle(ProcessInfo, dwLoggedOnSession);
		       wait.Add(AUEVENT_WUAUCLT_FINISHED, ProcessInfo.hProcess, fAUAdmin || fEnableYes);
		}
	}
done:
        ResetEvent(ghClientSession); //start listening to client session events from now on
       wait.Add(AUEVENT_NEW_CLIENT_SESSION);
       if (fFirstRunPerCycle && !fManualReboot) 
    	{
    	        wait.Timeout(AUEVENT_REBOOTWARNING_TIMEOUT,  AUPROMPTDLG_TOTAL_TIME_ELAPSE + 10, FALSE); //10 secs to make sure all clients time out
    	}
	SafeFree(lpszEnvBuf);
	LoggedOnSessions.Clear();
       DEBUGMSG("ProcessRebootWarning()  ends");
	return;
}

//=======================================================================
//  LaunchClient()
// if no admin logged on, launch client via local system
// update ghClientHandles
// return S_OK if client launched
//		S_FALSE if no session available or service finished, *pdwSessionId indicates the reason
//		E_XXX for all other failures
//=======================================================================
HRESULT  LaunchClient(IN CAUWait & wait, IN BOOL fAsLocalSystem, OUT DWORD *pdwSessionId, IN BOOL fGetSessionForRemindMe = FALSE )
{
//    DEBUGMSG("LaunchClient");
    HANDLE hImpersonationToken = NULL;																	
    HANDLE hUserToken = NULL;	
	DWORD    dwAdminSessionId = DWNO_ACTIVE_ADMIN_SESSION_FOUND ;
	HRESULT hr = E_FAIL;

	wait.Reset();
	AUASSERT(NULL != pdwSessionId);
	*pdwSessionId = DWNO_ACTIVE_ADMIN_SESSION_FOUND;
       if (!fAsLocalSystem)
        { //launch client in user context
             dwAdminSessionId = GetAllowedAdminSessionId(fGetSessionForRemindMe);
             if (DWNO_ACTIVE_ADMIN_SESSION_FOUND == dwAdminSessionId ||
             	DWNO_ACTIVE_ADMIN_SESSION_SERVICE_FINISHED == dwAdminSessionId)
            {
                DEBUGMSG("WUAUENG find no admin or service finished before launching client");
                hr = S_FALSE;
                goto done;
            }
            DEBUGMSG("WUAUENG launch client in session %d", dwAdminSessionId);
        	if (!AUGetUserToken(dwAdminSessionId, &hImpersonationToken))
        	{								
        		DEBUGMSG("WUAUENG fails AUGetUserToken");
        		hr = HRESULT_FROM_WIN32(GetLastError());
        		goto done;
        	}
        	  
        	if (!DuplicateTokenEx(hImpersonationToken, TOKEN_QUERY|TOKEN_DUPLICATE|TOKEN_ASSIGN_PRIMARY , NULL,
        		SecurityImpersonation, TokenPrimary, &hUserToken))								
        	{
        		DEBUGMSG("WUAUENG Could not DuplicateTokenEx, dw=%d", GetLastError());								
        		hr = HRESULT_FROM_WIN32(GetLastError());
        		goto done;
        	}

        	if ( WaitForShell() )
        	{
                // service finished
                dwAdminSessionId = DWNO_ACTIVE_ADMIN_SESSION_SERVICE_FINISHED ;
                hr = S_FALSE;
        		goto done;
        	}
        }
       else
       {
       	dwAdminSessionId = DWSYSTEM_ACCOUNT;
       }

	STARTUPINFO StartupInfo;								
	PROCESS_INFORMATION ProcessInfo;								
	TCHAR szCmd[MAX_PATH+1];																

	memset(&ProcessInfo, 0, sizeof(ProcessInfo));
	memset(&StartupInfo, 0, sizeof(StartupInfo));

	StartupInfo.cb = sizeof(StartupInfo);

	UINT ulen = GetSystemDirectory(szCmd, ARRAYSIZE(szCmd));
	if (0 == ulen)
	{
		DEBUGMSG("WUAUENG Could not get system directory");
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto done;
	}
	if (ulen >= ARRAYSIZE(szCmd))
	{
		hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
		goto done;
	}

	const TCHAR szAUCLT[] = _T("wuauclt.exe");
	if (FAILED(hr =PathCchAppend(szCmd, ARRAYSIZE(szCmd), szAUCLT)))
	{
		DEBUGMSG("WUAUENG Could not form full path to wuauclt.exe");
		goto done;
	}
	ghClientHandles.ClientStateChange(); //let AU client process initial state
	WaitForSingleObject(ghMutex, INFINITE);
	StartupInfo.lpDesktop = _T("WinSta0\\Default");	
	if (fAsLocalSystem)
	    { //launch client via local system
	        DEBUGMSG("Launch client via local system"); //inherit local system's desktop
	        if (!CreateProcess(szCmd, NULL, NULL, NULL, FALSE, DETACHED_PROCESS, NULL, NULL, &StartupInfo, &ProcessInfo))
	        {
    		       DEBUGMSG("WUAUENG Could not CreateProcess (WUAUCLT), dwRet = %d", GetLastError());     
    		       ReleaseMutex(ghMutex);
    		       hr = HRESULT_FROM_WIN32(GetLastError());
    		       goto done;
    		 }
    }
	else
    {
		LPVOID envBlock = NULL;
		BOOL fResult = FALSE;		
		CreateEnvironmentBlock(&envBlock, hUserToken, FALSE); //if fail, use NULL
    	fResult = CreateProcessAsUser(hUserToken, szCmd, NULL, NULL, NULL, FALSE /*Inherit Handles*/ , 
    			DETACHED_PROCESS|CREATE_UNICODE_ENVIRONMENT, envBlock, NULL, &StartupInfo, &ProcessInfo);
    	DWORD dwLastErr = GetLastError();
		if (NULL != envBlock)
		{
			DestroyEnvironmentBlock(envBlock);
		}
		if (!fResult)
		{
			DEBUGMSG("WUAUENG Could not CreateProcessAsUser (WUAUCLT), dwRet = %d", GetLastError());
            ReleaseMutex(ghMutex);
			hr = HRESULT_FROM_WIN32(dwLastErr);
            goto done;		
    	}		
    }
	DEBUGMSG("WUAUENG Created the client service (WUAUCLT)");
	ghClientHandles.SetHandle(ProcessInfo, fAsLocalSystem);
	ReleaseMutex(ghMutex);
    wait.Add(AUEVENT_WUAUCLT_FINISHED, ProcessInfo.hProcess, TRUE);
    hr = S_OK;
done:
    SafeCloseHandleNULL(hImpersonationToken);                            
    SafeCloseHandleNULL(hUserToken);	
   	*pdwSessionId = dwAdminSessionId;
    return hr;
}

void CalculateSleepTime(CAUWait & wait)
{
    DWORD dwReminderSleepTime = -1; //DWORD -1 is 0xFFFFFFFF
    DWORD dwSchedSleepTime = -1;
    DWORD dwSleepTimes[4] = { -1, -1, -1, -1};
    AUEVENT EventIds[4] = {AUEVENT_SCHEDULED_INSTALL, AUEVENT_REMINDER_TIMEOUT, AUEVENT_RELAUNCH_TIMEOUT, AUEVENT_REBOOTWARNING_TIMEOUT};
#ifdef DBG    
    LPSTR   szEventNames[4] = {"Schedule Install", "Reminder timeout", "Relaunch timeout", "RebootWarning timeout"};
#endif

//    DEBUGMSG("CalculateSleepTime starts");
    if ( FAILED(CalculateReminderTime((DWORD*) &dwReminderSleepTime)) )
    {
        dwReminderSleepTime = -1;
    }

    if (gpState->fShouldScheduledInstall())
    {
        if (!wait.fWaitOnEvent(AUEVENT_CATALOG_VALIDATED))
        {//calculate and potentially wait for scheduled time only when not validating catalog
		HRESULT hr;
		if (SUCCEEDED(hr = gpState->CalculateScheduledInstallSleepTime(&dwSchedSleepTime)) )
                {
                    if (S_FALSE == hr)	// the scheduled install date has been changed
                    {
                	    PostThreadMessage(gdwWorkerThreadId, AUMSG_LOG_EVENT, 0, 0);
                    }
                }
        }
    }

    dwSleepTimes[0] = dwSchedSleepTime;
    dwSleepTimes[1] = dwReminderSleepTime;
    dwSleepTimes[2] = (AUEVENT_RELAUNCH_TIMEOUT == wait.GetTimeoutEvent()) ? wait.GetTimeoutValue(): -1;
    dwSleepTimes[3] = (AUEVENT_REBOOTWARNING_TIMEOUT == wait.GetTimeoutEvent())? wait.GetTimeoutValue(): -1;

    DWORD dwLeastTimeIndex = 0;
    for (int i = 0; i < ARRAYSIZE(dwSleepTimes); i++)
    {
        if (dwSleepTimes[i] < dwSleepTimes[dwLeastTimeIndex])
        {
            dwLeastTimeIndex = i;
        }
    }
    if (-1 == dwSleepTimes[dwLeastTimeIndex])
    {
        wait.Timeout(AUEVENT_DUMMY, INFINITE);
    }
    else
    {
    	BOOL fProrate = (AUEVENT_REBOOTWARNING_TIMEOUT != EventIds[dwLeastTimeIndex]);
        wait.Timeout(EventIds[dwLeastTimeIndex], dwSleepTimes[dwLeastTimeIndex], fProrate);
#ifdef DBG        
        DEBUGMSG("CalculateSleepTime: next time wake up in %d secs for %s", dwSleepTimes[dwLeastTimeIndex], szEventNames[dwLeastTimeIndex]);
#endif
        if ( AUEVENT_REMINDER_TIMEOUT != EventIds[dwLeastTimeIndex]
         && -1 != dwSleepTimes[1])
        {
                removeReminderKeys();
        }
    }

//        DEBUGMSG("CalculateSleepTime ends");
        return;
}

void ResetEngine(void)
{
    if ( fCheckRebootFlag() )
    {
    	DEBUGMSG("WUAUENG in AUSTATE_WAITING_FOR_REBOOT state");
    	gpState->SetState(AUSTATE_WAITING_FOR_REBOOT);
    }
    else
    {
        ResetEvent(ghServiceDisabled);
        CancelDownload();
        gpState->SetState(AUSTATE_DETECT_PENDING);
        PostThreadMessage(gdwWorkerThreadId, AUMSG_DETECT, 0, 0);
        AUStopClients(); 
    }
}

void DisableAU(void)
{
    gpState->SetState(AUSTATE_DISABLED);		
    SetEvent(ghServiceDisabled); //intrinsticly cancel download
    AUStopClients();
}

//=======================================================================
//  WorkerClient
//=======================================================================
void WorkerClient(void)
{
	AUEVENT eventid;	
	DWORD dwLastState;
	CAUWait wait;
        
	 DEBUGMSG("WUAUENG Entering Worker Client");
	while ( TRUE )
	{	
		HANDLE hSignaledEvent;
		BOOL 	fInterestingClt = TRUE;
            CalculateSleepTime(wait);

            DEBUGMSG("WUAUENG before waiting for next worker client event");
            dwLastState = gpState->GetState();

		if (!wait.Wait(&hSignaledEvent, &fInterestingClt, &eventid))
		{
			DEBUGMSG("WUAUENG wait.wait() failed.");
			(void)ServiceFinishNotify();				
            goto done;
		}
        if ( AUEVENT_SERVICE_FINISHED == eventid )
        {
            AUStopClients(TRUE);
            if ( fCheckRebootFlag() )
            {
            	DEBUGMSG("WUAUENG in AUSTATE_WAITING_FOR_REBOOT state");
            	gpState->SetState(AUSTATE_WAITING_FOR_REBOOT);
            }
            goto done;
        }

        if (AUEVENT_POLICY_CHANGE == eventid)
        {
                //find out what changed
                //if nothing changed, go back to the beginning of the loop
                //otherwise, take different actions
                enumAUPOLICYCHANGEACTION actcode;
                if (S_OK == gpState->Refresh(&actcode))
                    {
                        switch (actcode)
                            {
                                case AUPOLICYCHANGE_NOOP: break;
                                case AUPOLICYCHANGE_RESETENGINE: 
                                                    ResetEngine();
                                                    break;
                                case AUPOLICYCHANGE_RESETCLIENT:
                                                    ghClientHandles.ResetClient();
                                                    break;
                                case AUPOLICYCHANGE_DISABLE:
                                                    DisableAU();
                                                    break;
                            }
                        if (AUPOLICYCHANGE_NOOP != actcode)
                        {
             	          	gpState->DepriveReschedPrivilege();
                        }
                    }
                continue;
        }

        if (AUEVENT_SETTINGS_CHANGE == eventid)
        {
            //go back to begining of loop and recalculate sleep time according to the new settings
            gpState->DepriveReschedPrivilege();
            continue;
        }

        if (AUEVENT_REBOOTWARNING_TIMEOUT == eventid)
        {
	        AUStopClients(); //stop all clients, non blocking
             	RebootNow();
        	wait.Reset();
        	continue;
        }
        
        DWORD dwState = gpState->GetState();

        if ( (eventid == AUEVENT_STATE_CHANGED) && (dwState == dwLastState) )
        {
            DWORD dwTimeOut;
            DWORD dwTimeOutState;
            UINT index;
            if ( SUCCEEDED(getReminderTimeout(&dwTimeOut, &index))
            		&& SUCCEEDED(getReminderState(&dwTimeOutState)))
            {
            	 if (dwTimeOutState == dwState)
            	 {
	                continue;
            	 }
            }
        }

        switch (dwState)
        	{
        		case AUSTATE_OUTOFBOX:				
        		case AUSTATE_WAITING_FOR_REBOOT:
        		    continue;
        		case AUSTATE_DISABLED: 
                          CancelDownload(); //then process auclt finish event
        		case AUSTATE_DETECT_PENDING:									
        		{		
        		     if ( AUEVENT_WUAUCLT_FINISHED == eventid )
                                {
                                    ProcessClientFinished(wait, hSignaledEvent, TRUE);
                                }
                               continue;
        		}
        		case AUSTATE_DOWNLOAD_COMPLETE:	
                     case AUSTATE_NOT_CONFIGURED:
        		case AUSTATE_DETECT_COMPLETE:
        		case AUSTATE_DOWNLOAD_PENDING:
        		case AUSTATE_INSTALL_PENDING: 
        		{			
                        if ( AUEVENT_WUAUCLT_FINISHED == eventid )
                        {
                            ProcessClientFinished(wait, hSignaledEvent, fInterestingClt);
                            continue;
                        }
                        
                        BOOL fGetSessionForRemindMe = FALSE;

                        if ( AUEVENT_REMINDER_TIMEOUT == eventid )
                        {
                            // Reminder time is up 														
                            removeReminderKeys();	
                            fGetSessionForRemindMe = TRUE;
                        }                             

                      if (AUEVENT_DO_DIRECTIVE == eventid)
                      {
                                wait.Reset(); //timeout is infinite now
                                DWORD dwCltAction = gpState->GetCltAction();
                                switch (dwCltAction)
                                    {
                                    case AUCLT_ACTION_AUTOINSTALL:
                                    	{
                                  			DWORD dwAdminSessionId;
                                                if (FAILED(LaunchClient(wait, TRUE, &dwAdminSessionId)))
                                                {
                                                	ServiceFinishNotify();
                                                }
                                                break;
                                    	}
                                    case AUCLT_ACTION_SHOWREBOOTWARNING:
                                    	{
                                                 gpState->SetCltAction(AUCLT_ACTION_NONE); //reset
                                                 ProcessRebootWarning(wait, TRUE); 
                                                 break;
                                    }
                                   default: 
#ifdef DBG                                
                                                DEBUGMSG("ERROR: should not be here");
                                                ServiceFinishNotify();                                                    
#endif                                    
                                                break;
                                    }                                        
                                continue;
                    }
                    if ( AUEVENT_SCHEDULED_INSTALL == eventid )
                    {
			gpState->DepriveReschedPrivilege();
                        if ( ghClientHandles.fClient())
                        {
                            ghClientHandles.ClientShowInstallWarning();
                        }
                        else
                        { 
                            gpState->SetCltAction(AUCLT_ACTION_AUTOINSTALL);
                            wait.Add(AUEVENT_DO_DIRECTIVE); //reenter workclient loop right away
                        }
                        continue;
                    }

                // eventid is one of these: AUEVENT_STATE_CHANGED, AUEVENT_NEW_CLIENT_SESSION, AUEVENT_REMINDER_TIMEOUT
#ifdef DBG                                        
                        AUASSERT(AUEVENT_STATE_CHANGED == eventid 
                        	||AUEVENT_NEW_CLIENT_SESSION == eventid
                        	||AUEVENT_REMINDER_TIMEOUT == eventid
                        	||AUEVENT_RELAUNCH_TIMEOUT == eventid
                        	||AUEVENT_CATALOG_VALIDATED == eventid);
#endif                           

  
                        if (AUEVENT_RELAUNCH_TIMEOUT == eventid)
                        {
                            wait.Reset();//reset time out
                        }
                        if (gpState->fRebootWarningMode())
                        {
                            if (AUEVENT_NEW_CLIENT_SESSION == eventid)
                            {
                                ProcessRebootWarning(wait);
                                continue;
                            }
                        }

                            
                        if ( !ghClientHandles.fClient() )
                        {//no client process running
                            DEBUGMSG( "WUAUENG Service detected that the client is not running.");

                            if (AvailableSessions() == 0)
                            {		
                                if (gpState->fShouldAutoDownload(FALSE))
                                { //do autodownload if appropriate
                                    StartDownload();
                                    continue;
                                }
                                DEBUGMSG("WUAUENG There is no Administrator Account, waiting for AUACTIVE_ADMIN_SESSION_EVENT to be triggered");					
                                wait.Reset();
                                wait.Add(AUEVENT_NEW_CLIENT_SESSION);
                                continue;
                            }
                            if (AUEVENT_CATALOG_VALIDATED != eventid && gpState->fValidationNeededState())
                            {
                                PostThreadMessage(gdwWorkerThreadId, AUMSG_VALIDATE_CATALOG, 0, 0);
                                wait.Reset();
                                wait.Add(AUEVENT_CATALOG_VALIDATED);
                                DEBUGMSG("WUAUENG needs to validate catalog before launching client");
                                continue;
                            }
                            DEBUGMSG("Trying to launch client");
                            DWORD dwCltSession;
                            HRESULT hr = LaunchClient(wait, FALSE, &dwCltSession, fGetSessionForRemindMe);
                            if (S_FALSE == hr && DWNO_ACTIVE_ADMIN_SESSION_FOUND == dwCltSession)
                            {
                                DEBUGMSG("WUAUENG There is no Administrator Account, waiting for AUACTIVE_ADMIN_SESSION_EVENT to be triggered");					
                                wait.Reset();
                                wait.Add(AUEVENT_NEW_CLIENT_SESSION);
                                continue;
                            }
                            if (FAILED(hr))
                            {
        				ServiceFinishNotify();
        				continue;
                            }
                        }
                    break;
                	}
        default:
                //What about the other states, will the service get them?
                DEBUGMSG("WARNING: WUAUENG default dwState=%d", dwState);
                break;				
        }	
    }
done:
   	DEBUGMSG("WUAUENG Exiting Worker Client");	
}


DWORD WINAPI WorkerThread(void * pdata)
{
	CoInitialize(NULL);
	
       WORKER_THREAD_INIT_DATA *pInitData = (WORKER_THREAD_INIT_DATA*) pdata;
	DWORD dwRet = UpdateProc(*pInitData);

	if(FAILED(dwRet))
	{
		DEBUGMSG("WUAUENG pUpdates->m_pUpdateFunc() failed, exiting service");
		(void)ServiceFinishNotify();		
	}
	else if(dwRet == S_OK)
	{	
		DEBUGMSG("WUAUENG Update() finished succesfully");		
	}
	else if(dwRet == S_FALSE)
	{
		DEBUGMSG("WUAUENG Updates() indicated selfupdate");
		(void)ServiceFinishNotify(); //service will reload new wuaueng.dll instead of exiting
	}
	CoUninitialize();

	DEBUGMSG("WUAUENG Exiting WorkerThread");
    return dwRet;
}

#if 0
#ifdef DBG
void DbgDumpSessions(void)
{
	const LPSTR TSStates[] = {
		"Active", "Connected", "ConnectQuery", "Shadow",
		"Disconnected", "Idle", "Listen", "Reset", "Down", "Init"};
			
     PWTS_SESSION_INFO pSessionInfo = NULL;	
     DWORD dwCount;

     DEBUGMSG("DumpSessions starts....");
     if (WTSEnumerateSessions(WTS_CURRENT_SERVER_HANDLE, 0, 1, &pSessionInfo, &dwCount))
        {
            DEBUGMSG("Sessions Count= %d",dwCount);

            for (DWORD dwSession = 0; dwSession < dwCount; dwSession++)
            {	
                WTS_SESSION_INFO SessionInfo = pSessionInfo[dwSession];

                DEBUGMSG("  SessionId =%d, State Id =%d, State = %s",SessionInfo.SessionId, SessionInfo.State, TSStates[SessionInfo.State]);
            }
     }
     DEBUGMSG("DumpSessions end");
}



DWORD WINAPI DbgThread(void * pdata)
{
	DEBUGMSG("WUAUENG Starting Debug thread");
	CoInitialize(NULL);
	while (true)
	{
		DbgDumpSessions();
		if (FServiceFinishedOrWait(ghServiceFinished, 5000))
		{
			DEBUGMSG("DbgThread noticed service finished");
			break;
		}
	}
	CoUninitialize();

	DEBUGMSG("WUAUENG Exiting Debug Thread");
    return 0;
}
#endif
#endif

#ifdef DBG
//=======================================================================
//
//  DebugResetAutoPilot
//
//  Check to see if we want AU to run by itself.
//
//=======================================================================
void DebugResetAutoPilot(void)
{
	DWORD dwAutoPilot;
	
	if ( SUCCEEDED(GetRegDWordValue(TEXT("AutoPilot"), &dwAutoPilot)) &&
		 (0 != dwAutoPilot) )
	{
		SetRegDWordValue(TEXT("AutoPilotIteration"), 0);
	}
}
#endif // DBG


BOOL AllocateAUSysResource(BOOL *pfGPNotificationRegistered)
{
        BOOL fOk = FALSE;

        //Create WindowsUpdate Directory if it doesnt already exist
        if(!CreateWUDirectory())
        {
            goto lCleanUp;
        }

       if (NULL == (ghMutex = CreateMutex(NULL, FALSE, NULL)))
        {
            DEBUGMSG("WUAUENG fail to create global mutex");
            goto lCleanUp;
        }

	// Create ghServiceFinished
	if (!FEnsureValidEvent(ghServiceFinished, TRUE, FALSE))
	{	
		DEBUGMSG("WUAUENG FEnsureValidEvent for AUSERVICE_FINISHED_EVENT failed");
		ghServiceFinished = NULL;
		goto lCleanUp;
	}

	if (!FEnsureValidEvent(ghSettingsChanged, FALSE, FALSE)) //auto
	    {
	        DEBUGMSG("WUAUENG FEnsureValidEvent for settings change event failed");
	        ghSettingsChanged = NULL;
	        goto lCleanUp;
	    }

	if (!FEnsureValidEvent(ghPolicyChanged, FALSE, FALSE)) //auto
	    {
	        DEBUGMSG("WUAUENG FEnsureValidEvent for policy change event failed");
	        ghPolicyChanged = NULL;
	        goto lCleanUp;
	    }
	
       if (!(*pfGPNotificationRegistered = RegisterGPNotification(ghPolicyChanged, TRUE)))
        {
            DEBUGMSG("WUAUENG fail to register group policy notification");
            goto lCleanUp;
        }

	
	// Create ghClientSession
	if (!FEnsureValidEvent(ghClientSession, FALSE, TRUE))
	{
		DEBUGMSG("WUAUENG FEnsureValidEvent for AUACTIVE_ADMIN_SESSION_EVENT failed");
		ghClientSession = NULL;
		goto lCleanUp;
	}
	
	// Create ghEngineState
	if (!FEnsureValidEvent(ghEngineState, FALSE, FALSE))
	{
		DEBUGMSG("WUAUENG FEnsureValidEvent for AUENGINE_STATE_CHANGE_EVENT failed");
		ghEngineState = NULL;
		goto lCleanUp;
	}
	
	//Create ghServiceDisabled
	//fixcode: ghServiceDisabled could really be removed
	if (!FEnsureValidEvent(ghServiceDisabled, TRUE, FALSE))
	{	
		DEBUGMSG("WUAUENG FEnsureValidEvent for ghServiceDisabled failed\n");
		ghServiceDisabled = NULL;
		goto lCleanUp;
	}
	// Create ghNotifyClient
	if (!FEnsureValidEvent(ghNotifyClient, FALSE, FALSE))
	{	
		DEBUGMSG("WUAUENG FEnsureValidEvent for ghNotifyClient failed\n");
		ghNotifyClient = NULL;
		goto lCleanUp;
	}

	// Create ghValidateCatalog
	if (!FEnsureValidEvent(ghValidateCatalog, FALSE, FALSE))
	{	
		DEBUGMSG("WUAUENG FEnsureValidEvent for ghValidateCatalog failed\n");
		ghValidateCatalog = NULL;
		goto lCleanUp;
	}

	if (!FEnsureValidEvent(ghWorkerThreadMsgQueueCreation, FALSE,FALSE))
	{
		DEBUGMSG("WUAUENG FEnsureValidEvent for ghWorkerThreadMsgQueueCreation failed");
		ghWorkerThreadMsgQueueCreation = NULL;
		goto lCleanUp;
	}
	
       fOk = TRUE;
       
lCleanUp:
        return fOk;
}

void ReleaseAUSysResource(BOOL fGPNotificationRegistered)
{
    SafeCloseHandleNULL(ghMutex);
	SafeCloseHandleNULL(ghServiceFinished);	
	SafeCloseHandleNULL(ghClientSession);		
	SafeCloseHandleNULL(ghEngineState);
	SafeCloseHandleNULL(ghServiceDisabled);
	SafeCloseHandleNULL(ghNotifyClient);
	SafeCloseHandleNULL(ghValidateCatalog);
	SafeCloseHandleNULL(ghSettingsChanged);
	SafeCloseHandleNULL(ghWorkerThreadMsgQueueCreation);
	if (NULL != ghPolicyChanged)
        {
            if ( fGPNotificationRegistered)
                {
                UnregisterGPNotification(ghPolicyChanged); //handled closed as well
                }
            SafeCloseHandleNULL(ghPolicyChanged);
        }
}

    
///////////////////////////////////////////////////////////////////////////////////////////////////
// return S_FALSE when selfupdate happened before wizard is shown
// return S_OK if AU last state processing is done successfully
// 
HRESULT InitAUEngine(WORKER_THREAD_INIT_DATA *pinitData, BOOL fUpgraded)
{
     HRESULT hr;

    if (FAILED(hr = HrCreateNewCatalog()))
    {
        DEBUGMSG("Fail to create new catalog with error %#lx", hr);
        goto done;
    }
    if (!AUCatalog::InitStaticVars())
	{
		DEBUGMSG("OUT OF MEMORY and Fail to initialize catalog static variable");
		hr = E_OUTOFMEMORY;
		goto done;
	}

    ProcessInitialState(pinitData, fUpgraded);
    srand(GetTickCount());
done:
    return hr;
}

void UninitAUEngine(void)
{
		AUCatalog::UninitStaticVars();
    	SafeDeleteNULL(gpAUcatalog);
}

BOOL WINAPI RegisterServiceVersion(DWORD dwServiceVersion, DWORD *pdwEngineVersion)
{
    BOOL fIsServiceVersionSupported = TRUE;
    if(NULL == pdwEngineVersion)
        return FALSE;

    gdwServiceVersion = dwServiceVersion;
    *pdwEngineVersion = AUENGINE_VERSION;
    
    switch(gdwServiceVersion)
    {
    case AUSRV_VERSION_1:
        break;
    default:
        fIsServiceVersionSupported = FALSE;
        break;
    }
    return fIsServiceVersionSupported;
}


BOOL WINAPI GetEngineStatusInfo (void *pEngineInfo)
{
    BOOL fIsServiceVersionSupported = TRUE;
    AUENGINEINFO_VER_1 *pEngInfo1 = NULL;

    if(pEngineInfo == NULL)
        return FALSE;    

    switch(gdwServiceVersion)
    {
    case AUSRV_VERSION_1:
        pEngInfo1 =  (AUENGINEINFO_VER_1*)pEngineInfo;
        pEngInfo1->hServiceStatus = ghMyServiceStatus;
        pEngInfo1->serviceStatus = gMyServiceStatus;
        break;

    default:
        //If service version is -1 or any unsupported version
        fIsServiceVersionSupported = FALSE;
        break;
    }
    return fIsServiceVersionSupported;
}


HRESULT WINAPI ServiceMain(DWORD /*dwNumServicesArg*/, 
						LPWSTR * /*lpServiceArgVectors*/,
						AUSERVICEHANDLER pfnServiceHandler,
						BOOL fJustSelfUpdated)
{
    HMODULE hmodTransport = NULL;
    BOOL fUpdateObjectRegistered = FALSE;
    BOOL fGPNotificationRegistered = FALSE;
    BOOL fCOMInited = FALSE;
    Updates *pUpdates  = NULL;
    HRESULT hr = S_OK;
#ifdef DBG
	DebugResetAutoPilot();
#endif

	if (!gAdminSessions.Initialize(TRUE, FALSE))
	{
		DEBUGMSG("FAILED to initialize gAdminSessions");
		hr = E_FAIL;
		goto lCleanUp;
	}
       if (NULL == (g_pGlobalSchemaKeys= new CSchemaKeys))
      	{
      		hr = E_OUTOFMEMORY;
      		goto lCleanUp;
       }

	ZeroMemory(&gMyServiceStatus, sizeof(gMyServiceStatus));

	ghMyServiceStatus = RegisterServiceCtrlHandlerEx(AU_SERVICE_NAME, pfnServiceHandler, NULL);
	if(ghMyServiceStatus == (SERVICE_STATUS_HANDLE)0)
	{
        DEBUGMSG("FAILED to retrieve the service handle");
		hr =  E_FAIL;
		goto lCleanUp;
	}
        DEBUGMSG("WUAUENG Service handler Registered");
        
	gMyServiceStatus.dwServiceType 			= SERVICE_WIN32_SHARE_PROCESS;
	gMyServiceStatus.dwCurrentState 		= SERVICE_START_PENDING;
	gMyServiceStatus.dwCheckPoint			= 1;      
	gMyServiceStatus.dwWaitHint             = 15000;

    if (IsWin2K())
    {
        gMyServiceStatus.dwControlsAccepted		= SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_SHUTDOWN;
    }
    else
    {
        gMyServiceStatus.dwControlsAccepted		= SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_SHUTDOWN | SERVICE_ACCEPT_SESSIONCHANGE;
    }

    // when RegisterServiceCtrlHandler is called, SCM will initialize the status to be
    // SERVICE_START_PENDING and checkpoint==0. So increment this to let it know
    // that we're making progress.
	SetServiceStatus(ghMyServiceStatus, &gMyServiceStatus);
    DEBUGMSG("WUAUENG service status set to SERVICE_START_PENDING");

	//if need to exit service for some particuliar reason, e.g. during setup, exit here

	// Initialization
	fCOMInited = SUCCEEDED(CoInitializeEx(NULL, COINIT_MULTITHREADED));

    // 
    // fix for security bug 563069 -- annah
    // Set Security for COM in Win2k as the default is not IDENTIFY
    //
    if (IsWin2K())
    {
        hr = CoInitializeSecurity(
                        NULL,                       // pSecDesc
                        -1,                         // cAuthSvc
                        NULL,                       // asAuthSvc
                        NULL,                       // pReserved
                        RPC_C_AUTHN_LEVEL_PKT,      // dwAuthnLevel
                        RPC_C_IMP_LEVEL_IDENTIFY,   // dwImpLevel
                        NULL,                       // pReserved2
                        EOAC_NO_CUSTOM_MARSHAL | EOAC_DISABLE_AAA,
                        NULL );          

        // it is possible that svchost already set the security or another thread in this process, 
        // so we don't want to fail if we're just late.
        if (FAILED(hr) && hr != RPC_E_TOO_LATE)
        {
            DEBUGMSG("WUAUENG Failed in call to CoInitializeSecurity");
            goto lCleanUp;
        }
    }

	if (NULL == (pUpdates = new Updates()))
	{
		hr = E_OUTOFMEMORY;
		goto lCleanUp;
	}

	DWORD dwClassToken;
	ITypeLib *pUpdatesTypeLib;

	//fixcode: this needs to be done in setup code
	if ( FAILED(hr = LoadTypeLibEx(_T("wuaueng.dll"), REGKIND_REGISTER, &pUpdatesTypeLib)) )
	    {
			goto lCleanUp;
	    }
	pUpdatesTypeLib->Release();

	if ( FAILED(hr = CoRegisterClassObject(__uuidof(Updates),
			      		pUpdates,
			     		CLSCTX_LOCAL_SERVER,
			      		REGCLS_MULTIPLEUSE,
			      		&dwClassToken)) )
	{
		goto lCleanUp;
	}

	fUpdateObjectRegistered = TRUE;
       DEBUGMSG("WUAUENG Update class object Registered");

	ghClientHandles.InitHandle();

       if (!AllocateAUSysResource(&fGPNotificationRegistered))
        {
            hr = E_FAIL;
            goto lCleanUp;
        }
       
       DEBUGMSG("WUAUENG group policy notification registered");

	gMyServiceStatus.dwCurrentState	= SERVICE_RUNNING;
	gMyServiceStatus.dwCheckPoint	= 0;
	gMyServiceStatus.dwWaitHint     = 0;

	SetServiceStatus(ghMyServiceStatus, &gMyServiceStatus);
        DEBUGMSG("Setting status to SERVICE_RUNNING");


       if ( FAILED(hr = CAUState::HrCreateState()) )
       {
   		goto lCleanUp;
   	}

   	if ( fJustSelfUpdated )
	{
		TCHAR szOldDll[MAX_PATH+1];

		gPingStatus.PingSelfUpdate(TRUE, URLLOGSTATUS_Success, 0);
		// if we just self updated, delete the old wuaueng.bak
		UINT ulen = GetSystemDirectory(szOldDll, ARRAYSIZE(szOldDll));
		if (0 == ulen || ulen >= ARRAYSIZE(szOldDll))
		{
			DEBUGMSG("WUAUENG fail to get system directory");
			goto lCleanUp;
		}

		if (FAILED(PathCchAppend(szOldDll, ARRAYSIZE(szOldDll), _T("wuaueng.bak"))) ||
			!DeleteFile(szOldDll))
		{
			DEBUGMSG("WUAUENG couldn't delete unused %S", szOldDll);		
		}
	}

	BOOL fUpgraded = fJustUpgraded();
	if ( fJustSelfUpdated || fUpgraded )
	{
		DEBUGMSG("AU got selfupdated or upgraded, cleaning up property sheet reg keys");
		//Get rid of localized property sheet keys if they exist (bug 519923)
		if( IsWin2K() )
		{
			(void)RegInstall(g_hInstance, "Win2KPropSheetCleanup", NULL);
		}
		else
		{
			(void)RegInstall(g_hInstance, "DefaultPropSheetCleanup", NULL);
		}
	}

	DEBUGMSG("WUAUENG Service Main sleeping first 60 seconds");	

	// Sleep 60 seconds before doing anything		
     if (FServiceFinishedOrWait(ghServiceFinished, dwTimeToWait(AU_ONE_MIN)))
	{
		DEBUGMSG("WUAUENG Service Stopping or Shutdown in first %d seconds", AU_ONE_MIN);
		goto lCleanUp;
	}
    //
    // If this is win2k, we will be receiving logon/logoff notifications through SENS, not SCM.
    // We need to subscribe to the events during initialization, then.
    //
    if (IsWin2K())
    {
        DEBUGMSG("WUAUENG Activating SENS notifications");
        hr = ActivateSensLogonNotification();
        if (FAILED(hr))
        {
            DEBUGMSG("WUAUENG Service failed to activate logon notifications... Error code is %x. Aborting.", hr);
            goto lCleanUp;
        }
    }

    gAdminSessions.CacheExistingSessions();	

	DEBUGMSG("Svc Worker thread enabled, beginning update process");

    // an optimiziation- load winhttp51.dll here so we don't keep loading & 
    //  unloading it later as needed cuz constant loading / unloading dlls
    //  can cause perf / memory leak issues on certain platforms.
    // In theory, we should just bail if this fails because we only want to
    //  proceed if we're going to use winhttp.dll
    hmodTransport =  LoadLibraryFromSystemDir(c_szWinHttpDll);

    WORKER_THREAD_INIT_DATA initData;

    if (FAILED(hr = InitAUEngine(&initData, fUpgraded)))
    { //selfupdated or error
        goto lCleanUp;
    }


	hWorkerThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)WorkerThread, (LPVOID)&initData, 0, &gdwWorkerThreadId);
	DEBUGMSG("WUAUENG wait for worker thread to create its message queue ......");
	WaitForSingleObject(ghWorkerThreadMsgQueueCreation, INFINITE);
	(void)WorkerClient();
	DWORD dwRet = WaitForSingleObject(hWorkerThread,	// we can't stop until hWorkerThread exits
								INFINITE);

	gdwWorkerThreadId = -1;
	if ( WAIT_OBJECT_0 != dwRet || 
		!GetExitCodeThread(hWorkerThread, (LPDWORD)&hr /* the DWORD is actually an HRESULT */)
		 || (E_FAIL == hr) )
	{
		DEBUGMSG("Worker thread returned a failure, WaitForSingleObject() failed or we couldn't get its exit code");
		hr = E_FAIL;
	}
	else
	{
		DEBUGMSG("Svc Worker thread returned, ret=%#lx", hr);
	}
		
lCleanUp:
    UninitAUEngine();
    if (hmodTransport != NULL)
		FreeLibrary(hmodTransport);

	if (fUpdateObjectRegistered)
    {
        CoRevokeClassObject(dwClassToken);
    }
   
	ReleaseAUSysResource(fGPNotificationRegistered);

	SafeDelete(pUpdates);
	SafeDeleteNULL(gpState);

	if (IsWin2K())
	{
	    DEBUGMSG("WUAUENG Deactivating SENS notifications");
	    DeactivateSensLogonNotification();
	}

	gAdminSessions.Clear();
	
	if (fCOMInited) 
	{
		CoUninitialize();
	}

	SafeDelete(g_pGlobalSchemaKeys);
	CleanupDownloadLib();

    //If it's an old wuauserv version, stop the service
	if ( S_FALSE != hr && gdwServiceVersion == -1)
	{		
		gMyServiceStatus.dwCurrentState	= SERVICE_STOPPED;
		//gMyServiceStatus.dwCheckPoint	= 0;
		//gMyServiceStatus.dwWaitHint	= 0;
		SetServiceStatus(ghMyServiceStatus, &gMyServiceStatus);
	}
	else
	{	//selfupdate succeed
		//PingStatus::ms_ServicePingSelfUpdateStatus(PING_STATUS_CODE_SELFUPDATE_PENDING);
	}

	DEBUGMSG("WUAUENG ServiceMain exits. Error code is %x", hr);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\wuaueng\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       resource.h
//
//--------------------------------------------------------------------------
#include "aucomres.h"
#define IDS_HEADER_CONNECTING           1
#define IDS_HEADER_UNAVAILABLE          2
#define IDS_HEADER_CONNECTED            3
#define IDS_SERVICENAME                 10000  //also used by system property sheet. Should not be changed
//#define IDR_Wuaueng                     100
//#define IDS_UPDATES_DESC                101
//#define IDR_Updates           102
#define IDS_SERVICE_DESC	104
#define IDS_EVT_LISTITEMFORMAT	105
#define IDS_STR_EVERYDAY        106
#define IDS_STR_SUNDAY          107
#define IDS_STR_MONDAY          108
#define IDS_STR_TUESDAY         109
#define IDS_STR_WEDNESDAY       110
#define IDS_STR_THURSDAY        111
#define IDS_STR_FRIDAY          112
#define IDS_STR_SATURDAY        113
	

//#define IDS_PROPPAGE_NAME				10000

#define IDC_STATIC                     -1
#define IDI_AUTOUPDATE                500
#define IDD_AUTOUPDATE                501

//#define IDC_AUTOUPDATE_OPTION1       1000
//#define IDC_AUTOUPDATE_OPTION2       1001
//#define IDC_AUTOUPDATE_OPTION3       1002
//#define IDC_BTN_RESTORE		     1003
#define IDC_GRP_OPTIONS                 1004
#define IDC_TXT_HEADER                  1007
//#define IDC_CHK_KEEPUPTODATE		1008
//#define IDC_CMB_DAYS			1009
//#define IDC_CMB_HOURS			1010

#define IDC_STATICAT			1011
#define IDC_AUTOUPDATELINK		1012
#define IDC_SCHINSTALLINK		1013

#define IDD_RESTOREUPDATE 		1014

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\wuaueng\selfupdate.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       selfupdate.cpp
//
//  Desc:       This file contains all the functions necessary for self-update
//--------------------------------------------------------------------------

#include "pch.h"

#include <osdet.h>
#include <muiutil.h>

#define TCHAR_SCTRUCTURE_DELIMITER  _T('|')

struct AU_FILEINCAB
{
    TCHAR   szFilePath[MAX_PATH + 1];
    TCHAR   szNewFilePath[MAX_PATH + 1];
    TCHAR   szBackupFilePath[MAX_PATH + 1];
    TCHAR   szExtractFilePath[MAX_PATH + 1];
    BOOL    fCreatedBackup;
    BOOL    fFileExists;
    AU_FILEINCAB *pNextFileInCab;
};

struct AU_COMPONENT : AU_FILEINCAB
{
    TCHAR   *pszSectionName;
    TCHAR   szFileName[_MAX_FNAME + 1];
    TCHAR   szCabName[_MAX_FNAME + 1];
    TCHAR   szCabPath[MAX_PATH + 1];
    CHAR    a_szCabPath[MAX_PATH + 1];
    TCHAR   szInfName[_MAX_FNAME + 1];
    CHAR    a_szInfName[_MAX_FNAME + 1];
    DWORD   dwUpdateMS;
    DWORD   dwUpdateLS;
    BOOL    fDoUpgrade;
    BOOL    fNeedToCheckMui;
    BOOL    fMuiFile;
    BOOL    fHasHelpfile;
    AU_COMPONENT *pNext;
};


// AU_UPDATE_VERSION should be updated when incompatible changes are made to the
// self update mechanism required AU to go to a new directory for update info. 
const TCHAR IDENT_TXT[] = _T("iuident.txt");
const TCHAR WUAUCOMP_CAB[] = _T("wuaucomp.cab");
const TCHAR WUAUCOMP_CIF[] = _T("wuaucomp.cif");
const TCHAR WUAUENG_DLL[] = TEXT("wuaueng.dll");
const TCHAR AU_KEY_FILE_NAME[] = TEXT("file");
const TCHAR AU_KEY_FILE_VERSION[] = TEXT("version");
const TCHAR AU_KEY_CAB_NAME[] = TEXT("cab");
const TCHAR AU_KEY_INF_NAME[] = TEXT("inf");
const TCHAR AU_KEY_RESMOD_NAME[] = TEXT("resmodule");
const TCHAR AU_KEY_HELPFILE[] = TEXT("helpfile");
const DWORD MAX_SECTION = 30;

// main selfupdate keys
const TCHAR IDENT_SERVERURLEX[] = _T("ServerUrlEx");
const TCHAR IDENT_STRUCTUREKEYEX[] = _T("StructureKeyEx");

const TCHAR INIVALUE_NOTFOUND[] = _T("??");

BOOL fConvertVersionStrToDwords(LPTSTR pszVer, LPDWORD pdwVer, LPDWORD pdwBuild);
HRESULT InstallUpdatedComponents(LPCTSTR pszSelfUpdateUrl,
                                 LPCTSTR pszMuiUpdateUrl,
                                 LPCTSTR pszIdentTxt,
                                 LPCTSTR pszFileCacheDir,
                                 LPCTSTR pszCif,
                                 BOOL *pfInstalledWUAUENG);
BOOL ReplaceFileInPath(LPCTSTR pszPath, LPCTSTR szNewFile, LPTSTR pszNewPathBuf, DWORD cchNewPathBuf);
BOOL MyGetPrivateProfileString( IN LPCWSTR lpAppName,
                                IN LPCWSTR lpKeyName,
                                OUT LPWSTR lpReturnedString,
                                IN DWORD nSize,
                                IN LPCWSTR lpFileName,
								IN LPCTSTR lpDefault=_T(""));

inline BOOL fNewerFile(DWORD dwUpdateMS, DWORD dwUpdateLS, DWORD dwExistingMS, DWORD dwExistingLS)
{
    return (dwUpdateMS > dwExistingMS) ||
            ((dwUpdateMS == dwExistingMS) && (dwUpdateLS > dwExistingLS));
}

inline HRESULT vAU_W2A(LPCWSTR lpWideCharStr, LPSTR lpMultiByteStr, int cbMultiByte)
{
	if ( 0 != WideCharToMultiByte(CP_ACP, 0, lpWideCharStr, -1, lpMultiByteStr, cbMultiByte, NULL, NULL))
	{
		return S_OK;
	}
	else
	{
		return HRESULT_FROM_WIN32(GetLastError());
	}
}

HRESULT SelfUpdate(void)
{
    HRESULT hr;
    BOOL    fInstalledWUAUENG = FALSE;

    DEBUGMSG("------------------------SELFUPDATE BEGINS---------------------------");
    
    
    if( FAILED(hr = CheckForUpdatedComponents(&fInstalledWUAUENG)) )
    {
        goto lCleanUp;
    }
    
    if ( fInstalledWUAUENG )
    {
        DEBUGMSG("SELFUPDATE installed new wuaueng");
        hr = S_FALSE;
        goto lCleanUp;      
    }

lCleanUp:
    return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////
//
// CleanFileCache()
//
//////////////////////////////////////////////////////////////////////////////////////////

BOOL CleanFileCache(LPCTSTR pszFileCacheDir)
{
    BOOL fRet = TRUE;
    TCHAR szFileCacheDir[MAX_PATH + 1];
    TCHAR szFilePath[MAX_PATH + 1];
    WIN32_FIND_DATA fd;
    HANDLE hFindFile = INVALID_HANDLE_VALUE;

    
    if (FAILED(StringCchCopyEx(szFileCacheDir, ARRAYSIZE(szFileCacheDir), pszFileCacheDir, NULL, NULL, MISTSAFE_STRING_FLAGS)))
    {
        fRet = FALSE;
        goto done;
    }
    
    if (FAILED(PathCchAppend(szFileCacheDir, ARRAYSIZE(szFileCacheDir), TEXT("*.*"))))
    {
        fRet = FALSE;
        goto done;
    }

    // Find the first file
    hFindFile = FindFirstFile(szFileCacheDir, &fd);

    if ( INVALID_HANDLE_VALUE == hFindFile )
    {
        goto done;
    }

    do
    {
        if ( !(fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) )
        {
            // Make file path
            if (FAILED(StringCchCopyEx(szFilePath, ARRAYSIZE(szFilePath), pszFileCacheDir, NULL, NULL, MISTSAFE_STRING_FLAGS)) ||
                FAILED(PathCchAppend(szFilePath, ARRAYSIZE(szFilePath), fd.cFileName)) || 
                !SetFileAttributes(szFilePath, FILE_ATTRIBUTE_NORMAL) ||
                !DeleteFile(szFilePath))
            {
                fRet = FALSE;
                DEBUGMSG("Couldn't delete file %S", szFilePath);
            }
        }
    }
    while ( FindNextFile(hFindFile, &fd) );// Find the next entry

done:
    if ( INVALID_HANDLE_VALUE != hFindFile )
    {
        FindClose(hFindFile);
    }
    
    return fRet;
}


//////////////////////////////////////////////////////////////////////
//
// GetSelfUpdateUrl()
//
// Should be like:
//
//	http://windowsupdate.microsoft.com/selfupdate/x86/XP/en
////////////////////////////////////////////////////////////////////////
HRESULT GetSelfUpdateUrl(LPCTSTR ptszName, 
                           LPCTSTR ptszBaseUrl, 
                           LPCTSTR pszIdentTxt, 
                           LPTSTR  pszSelfUpdateUrl,
                           DWORD   cchSelfUpdateUrl,
                           LPTSTR  pszMuiUpdateUrl,
                           DWORD   cchMuiUpdateUrl)
{
    LOG_Block("GetSelfUpdateUrl");
    HRESULT hr;
    TCHAR   tszKey[MAX_SECTION];    // at least MAX_ISO_CODE_LENGTH
    TCHAR   tszValue[MAX_PATH];
    BOOL    fLangField;
   
    if (FAILED(hr = StringCchCopyEx(tszKey, ARRAYSIZE(tszKey), ptszName, NULL, NULL, MISTSAFE_STRING_FLAGS)) ||
        FAILED(hr = StringCchCatEx(tszKey, ARRAYSIZE(tszKey), _T("SelfUpdate"), NULL, NULL, MISTSAFE_STRING_FLAGS)))
    {
        goto lFinish;
    }

    if (NULL == ptszBaseUrl)
    {
        // Get SelfUpdate Server URL
        if (MyGetPrivateProfileString(
                tszKey,
                IDENT_SERVERURLEX,
                pszSelfUpdateUrl,
                cchSelfUpdateUrl,
                pszIdentTxt) == FALSE)
        {
            // no URL specified in iuident..
            hr = E_FAIL;
            goto lFinish;
        }
        else
        {
            if (FAILED(hr = StringCchCopyEx(pszMuiUpdateUrl, cchMuiUpdateUrl, pszSelfUpdateUrl, NULL, NULL, MISTSAFE_STRING_FLAGS)))
                goto lFinish;
        }
    }
    else
    {
        if (FAILED(hr = StringCchCopyEx(pszSelfUpdateUrl, cchSelfUpdateUrl, ptszBaseUrl, NULL, NULL, MISTSAFE_STRING_FLAGS)) ||
            FAILED(hr = StringCchCopyEx(pszMuiUpdateUrl, cchMuiUpdateUrl, ptszBaseUrl, NULL, NULL, MISTSAFE_STRING_FLAGS)))
        {
            goto lFinish;
        }
        // Remove trailing _T('/') if present
        int nBaseUrlLen = lstrlen(pszSelfUpdateUrl);

        if(nBaseUrlLen <= 0)
        {
            hr = E_FAIL;
            goto lFinish;
        }
        if (_T('/') == pszSelfUpdateUrl[nBaseUrlLen-1])
        {
            pszSelfUpdateUrl[nBaseUrlLen-1] = _T('\0');
            pszMuiUpdateUrl[nBaseUrlLen-1] = _T('\0');
        }
    }

    TCHAR tszStructure[MAX_PATH];

    if (!MyGetPrivateProfileString(
            tszKey,
            IDENT_STRUCTUREKEYEX,
            tszStructure,
            ARRAYSIZE(tszStructure),
            pszIdentTxt))
    {
        // no STRUCTYREKEY specified in iuident..
        hr = E_FAIL;
        goto lFinish;
    }

    // Parse the SelfUpdate Structure Key for Value Names to Read
    LPTSTR ptszWalk = tszStructure;
    while (_T('\0') != ptszWalk[0])
    {
        LPTSTR ptszDelim;

        fLangField = FALSE;

        if (NULL != (ptszDelim = StrChr(ptszWalk, TCHAR_SCTRUCTURE_DELIMITER)))
        {
            *ptszDelim = _T('\0');
        }

        if (_T('/') == ptszWalk[0])
        {
            if (FAILED(hr = StringCchCopyEx(tszValue, ARRAYSIZE(tszValue), ptszWalk, NULL, NULL, MISTSAFE_STRING_FLAGS)))
            {
                goto lFinish;
            }
        }
        else
        {
            int nPrefixLength = lstrlen(ptszName);
            LPCTSTR ptszToken = ptszWalk;

            if (0 == StrCmpNI(ptszWalk, ptszName, nPrefixLength))
            {
                ptszToken += nPrefixLength;
            }

            if (0 == StrCmpI(ptszToken, IDENT_ARCH))
            {
                if (!MyGetPrivateProfileString(
                        ptszWalk,
#ifdef _IA64_
                        IDENT_IA64,
#else
                        IDENT_X86,
#endif
                        tszValue,
                        ARRAYSIZE(tszValue),
                        pszIdentTxt))
                {
                    // insufficient buffer
                    hr = E_FAIL;
                    goto lFinish;
                }
            }
            else if (0 == StrCmpI(ptszToken, IDENT_OS))
            {
                if (FAILED(hr = StringCchCopyEx(tszKey, ARRAYSIZE(tszKey), ptszWalk, NULL, NULL, MISTSAFE_STRING_FLAGS)) ||
                    FAILED(hr = StringCchCatEx(tszKey, ARRAYSIZE(tszKey), _T("NT"), NULL, NULL, MISTSAFE_STRING_FLAGS)))
                {
                    goto lFinish;
                }

                if (S_OK != GetINIValueByOSVer(
                                pszIdentTxt,
                                tszKey,
                                tszValue,
                                ARRAYSIZE(tszValue)))
                {
                    hr = E_FAIL;
                    goto lFinish;
                }
            }
            else if (0 == StrCmpI(ptszToken, IDENT_LANG))
            {
                fLangField = TRUE;
                
                // Get the Current Locale String
                (void) LookupLocaleString(tszKey, ARRAYSIZE(tszKey), FALSE);

                if (0 == StrCmp(tszKey, _T("Error")))
                {
                    DEBUGMSG("GetSelfUpdateUrl() call to LookupLocaleString() failed.");
                    hr = E_FAIL;
                    goto lFinish;
                }

                if (!MyGetPrivateProfileString(
                        ptszWalk,
                        tszKey,
                        tszValue,
                        ARRAYSIZE(tszValue),
                        pszIdentTxt,INIVALUE_NOTFOUND))
                {
                    hr = E_FAIL;
                    goto lFinish;
                }
                if (0 == StrCmp(tszValue, INIVALUE_NOTFOUND))
                {
                    LPTSTR ptszDash = StrChr(tszKey, _T('-'));

                    if (NULL != ptszDash)
                    {
                        *ptszDash = _T('\0');
                        if (!MyGetPrivateProfileString(
                                ptszWalk,
                                tszKey,
                                tszValue,
                                ARRAYSIZE(tszValue),
                                pszIdentTxt))
                        {
                            hr = E_FAIL;
                            goto lFinish;
                        }
                    }
                    else
                    {
                        tszValue[0] = _T('\0');
                    }
                }
            }
            else
            {
                LOG_Internet(_T("Found Unrecognized Token in SelfUpdate Structure String: Token was: %s"), ptszWalk);
                tszValue[0] = _T('\0'); // ignore the unrecognized token
            }
        }

        if (_T('\0') != tszValue[0])
        {
            LPCTSTR ptszMuiCopy;
            
            if (FAILED(hr = StringCchCatEx(pszSelfUpdateUrl, cchSelfUpdateUrl, tszValue, NULL, NULL, MISTSAFE_STRING_FLAGS)))
                goto lFinish;

            if (fLangField)
                ptszMuiCopy = MUI_WEBSUBPATH;
            else
                ptszMuiCopy = tszValue;

            if (FAILED(hr = StringCchCatEx(pszMuiUpdateUrl, cchMuiUpdateUrl, ptszMuiCopy, NULL, NULL, MISTSAFE_STRING_FLAGS)))
                goto lFinish;
        }

        if (NULL == ptszDelim)
        {
            break;
        }

        ptszWalk = ptszDelim + 1; // skip the previous token, and go to the next one in the string.
        *ptszDelim = TCHAR_SCTRUCTURE_DELIMITER;
    }

    DEBUGMSG("GetSelfUpdateUrl() Self Update URL is %S", pszSelfUpdateUrl);
    DEBUGMSG("GetSelfUpdateUrl() MUI Update URL is %S", pszMuiUpdateUrl);
    hr = S_OK;

lFinish:
    if (FAILED(hr))
    {
        if (cchMuiUpdateUrl > 0)
            *pszMuiUpdateUrl = _T('\0');
        if (cchSelfUpdateUrl > 0)
            *pszSelfUpdateUrl = _T('\0');
    }
    return hr;
}

////////////////////////////////////////////////////////////////////////////////////////
//
// CheckForUpdatedComponents
//
////////////////////////////////////////////////////////////////////////////////////////

HRESULT CheckForUpdatedComponents(BOOL *pfInstalledWUAUENG)
{
    HRESULT     hr;
    LPCTSTR     ptszIdentServerUrl = NULL;
    LPTSTR      ptszSelfUpdateUrl = NULL;
    LPTSTR      ptszMuiUpdateUrl = NULL;

    if (NULL != (ptszSelfUpdateUrl = (LPTSTR) malloc(sizeof(TCHAR) * INTERNET_MAX_URL_LENGTH)) &&
        NULL != (ptszMuiUpdateUrl = (LPTSTR) malloc(sizeof(TCHAR) * INTERNET_MAX_URL_LENGTH)) &&
        NULL != (ptszIdentServerUrl = gpState->GetIdentServerURL()))
    {
        TCHAR   szFileCacheDir[MAX_PATH+1];


        if ( FAILED(hr = MakeTempDownloadDir(szFileCacheDir, ARRAYSIZE(szFileCacheDir))) ||
             !CleanFileCache(szFileCacheDir) )
        {
            DEBUGMSG("Couldn't fully clean file cache %S", szFileCacheDir);
		    hr = FAILED(hr) ? hr : E_FAIL;
		    goto done;
        }

        BOOL fInCorpWU = gpState->fInCorpWU();

        if (IsConnected(ptszIdentServerUrl, !fInCorpWU))
        {
            DWORD dwFlags = 0;

            if (fInCorpWU)
            {
                dwFlags |= WUDF_DONTALLOWPROXY;
            }

            if (SUCCEEDED(hr = DownloadIUIdent(
                                    ghServiceFinished,
                                    ptszIdentServerUrl,
                                    szFileCacheDir,
                                    dwFlags)))
            {
                TCHAR   tszIdentTxt[MAX_PATH];

                gPingStatus.ReadLiveServerUrlFromIdent();

                hr = PathCchCombine(tszIdentTxt, ARRAYSIZE(tszIdentTxt), 
                                    szFileCacheDir, IDENT_TXT);
                if (FAILED(hr))
                    goto done;

                if (SUCCEEDED(hr = GetSelfUpdateUrl(
                                        _T("AU"),
                                        gpState->GetSelfUpdateServerURLOverride(),
                                        tszIdentTxt,
                                        ptszSelfUpdateUrl,
                                        INTERNET_MAX_URL_LENGTH,
                                        ptszMuiUpdateUrl,
                                        INTERNET_MAX_URL_LENGTH)) &&
                    SUCCEEDED(hr = DownloadCab(
                                        ghServiceFinished,
                                        WUAUCOMP_CAB,
                                        ptszSelfUpdateUrl,
                                        szFileCacheDir,
                                        dwFlags)))
                {
                    TCHAR szWuaucompCif[MAX_PATH+1];

                    if (SUCCEEDED(hr = PathCchCombine(szWuaucompCif, ARRAYSIZE(szWuaucompCif), szFileCacheDir, WUAUCOMP_CIF)))
                    {
                        // install any updated components
                        hr = InstallUpdatedComponents(
                                     ptszSelfUpdateUrl,
                                     ptszMuiUpdateUrl,
                                     tszIdentTxt,
                                     szFileCacheDir,
                                     szWuaucompCif,
                                     pfInstalledWUAUENG);
#ifdef DBG
                        if (FAILED(hr))
                        {
                            DEBUGMSG("InstallUpdatedComponents failed");
                        }
#endif
                    }
                }
            }
        }
        else
        {
            DEBUGMSG("SelfUpdate: No connection found.");
            hr = E_FAIL;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

done:
	SafeFree(ptszSelfUpdateUrl);
	SafeFree(ptszMuiUpdateUrl);
	return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////
//
// SfcMoveFileEx
//
//////////////////////////////////////////////////////////////////////////////////////////

BOOL SfcMoveFileEx( IN LPCTSTR lpExistingFileName,
                    IN LPCTSTR lpNewFileName,
                    IN LPCTSTR lpSfcProtectedFile,
                    IN HANDLE SfcRpcHandle)
{
    BOOL fRet = TRUE;

    if ( SfcIsFileProtected(SfcRpcHandle, lpSfcProtectedFile) &&
         (ERROR_SUCCESS != SfcFileException(SfcRpcHandle,
                                            lpSfcProtectedFile,
                                            SFC_ACTION_RENAMED_OLD_NAME)) )
    {
        fRet = FALSE;
        goto done;
    }

    fRet = MoveFileEx(lpExistingFileName, lpNewFileName, MOVEFILE_REPLACE_EXISTING);

done:
    if ( !fRet )
    {
        DEBUGMSG("Could not rename %S --> %S", lpExistingFileName, lpNewFileName);
    }

    return fRet;
}


/////////////////////////////////////////////////////////////////////////////////////////
//
// Function BuildPaths()
//
//////////////////////////////////////////////////////////////////////////////////////////
HRESULT BuildPaths(AU_FILEINCAB *paufic, LPCTSTR pszFileName, LPCTSTR pszBasePath, LPCTSTR pszExtractBase, 
                    AU_LANG *paul)
{
    HRESULT hr = S_OK;

    if (paufic == NULL || pszFileName == NULL || pszExtractBase == NULL)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    if (pszBasePath != NULL)
    {
        // build the full file path
        hr = PathCchCombine(paufic->szFilePath, ARRAYSIZE(paufic->szFilePath), 
                            pszBasePath, pszFileName);
        if (FAILED(hr))
            goto done;

        paufic->fFileExists = fFileExists(paufic->szFilePath);
    }

    // file path we'll temporarily copy the original file to
    if (ReplaceFileExtension(paufic->szFilePath, _T(".bak"), 
                             paufic->szBackupFilePath, 
                             ARRAYSIZE(paufic->szBackupFilePath)) == FALSE) 
    {
        hr = E_FAIL;
        goto done;
    }

    // file path we'll temporarily expand the new file to
    if (ReplaceFileExtension(paufic->szFilePath, _T(".new"),
                             paufic->szNewFilePath,
                             ARRAYSIZE(paufic->szNewFilePath)) == FALSE)
    {
        hr = E_FAIL;
        goto done;
    }

    if (ReplaceFileInPath(pszExtractBase, pszFileName, 
                          paufic->szExtractFilePath, 
                          ARRAYSIZE(paufic->szExtractFilePath)) == FALSE)
    {
        hr = E_FAIL;
        goto done;
    }

    // if we are processing a language file, append the language name to
    //  the end of the extraction path to avoid collisions in this directory. 
    if (paul != NULL)
    {
        hr = StringCchCatEx(paufic->szExtractFilePath, 
                            ARRAYSIZE(paufic->szExtractFilePath),
                            paul->szAUName,
                            NULL, NULL, MISTSAFE_STRING_FLAGS);
        if (FAILED(hr))
            goto done;
    }


done:
    return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////
//
// Function ProcessFile()
//
//////////////////////////////////////////////////////////////////////////////////////////
HRESULT ProcessFile(AU_COMPONENT *paucParent, AU_COMPONENT *paucCurr, LPCTSTR pszBasePath, 
                    AU_LANG *paul, LPCTSTR pszCif)
{
    USES_IU_CONVERSION;

    HRESULT hr = NOERROR;
    LPCTSTR pszIniFileVerToUse;
    DWORD   dwExistingMS = 0, dwExistingLS = 0;
    TCHAR   szValue[64], szIniFileVer[32];
    BOOL    fRet;
    int     cch, cchLang;

    // validate params
    if (paucCurr == NULL || pszBasePath == NULL || pszCif == NULL ||
        ((paucParent == NULL) != (paul == NULL)))
    {
        hr = E_INVALIDARG;
        goto done;
    }

    // build the full file path
    hr = PathCchCombine(paucCurr->szFilePath, ARRAYSIZE(paucCurr->szFilePath), 
                        pszBasePath, paucCurr->szFileName);
    if (FAILED(hr))
        goto done;


    // get the version of the file we should have
    if (paul != NULL)
    {
        hr = StringCchPrintfEx(szIniFileVer, ARRAYSIZE(szIniFileVer), 
                               NULL, NULL, MISTSAFE_STRING_FLAGS,
                               _T("%s%s"), AU_KEY_FILE_VERSION, paul->szAUName);
        if (FAILED(hr))
            goto done;
        
        pszIniFileVerToUse = szIniFileVer;
    }
    else
    {
        pszIniFileVerToUse = AU_KEY_FILE_VERSION;
    }
    
    fRet = MyGetPrivateProfileString(paucCurr->pszSectionName,
                                     pszIniFileVerToUse,
                                     szValue, ARRAYSIZE(szValue),
                                     pszCif);
    if (fRet)
    {
        fRet = fConvertVersionStrToDwords(szValue, &paucCurr->dwUpdateMS, 
                                          &paucCurr->dwUpdateLS);
    }
    // if we couldn't find the version string in the ini file, get it from the
    //  parent AU_COMPONENT
    else if (paucParent != NULL)
    {
        paucCurr->dwUpdateMS = paucParent->dwUpdateMS;
        paucCurr->dwUpdateLS = paucParent->dwUpdateLS;
        fRet = TRUE;
    }

    if (fRet == FALSE)
    {
        hr = E_FAIL;
        goto done;
    }

    // see if we need to replace the file
    paucCurr->fFileExists = fFileExists(paucCurr->szFilePath);
    if (paucCurr->fFileExists)
    {   
        LPSTR pszPathForVer;
        
        // if the file exists, then check for the version
        pszPathForVer = T2A(paucCurr->szFilePath);
        if (pszPathForVer == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }

        // this function will never return a failure code.  Intstead, check if 
        //  both return values are 0
        hr = GetVersionFromFileEx(pszPathForVer, &dwExistingMS, &dwExistingLS, 
                                  TRUE);
        if (FAILED(hr) || (dwExistingMS == 0 && dwExistingLS == 0))
        {
            hr = E_FAIL;
            goto done;
        }

        paucCurr->fDoUpgrade = fNewerFile(paucCurr->dwUpdateMS, 
                                          paucCurr->dwUpdateLS,
                                          dwExistingMS, 
                                          dwExistingLS);
    }
    else
    {
        // if the file doesn't exist, obviously gotta replace it
        paucCurr->fDoUpgrade = TRUE;
    }

    // if we don't need to update the file and it's not a parent file with 
    //  resources, then can just bail at this point.  
    if (paucCurr->fDoUpgrade == FALSE)
    {
        if (paul != NULL || 
            (paul == NULL && paucCurr->fNeedToCheckMui == FALSE))
        {
            hr = S_FALSE;
            goto done;
        }
    }
    else
    {
        DEBUGMSG("PASS 1 -- newer file in section %S", paucCurr->pszSectionName);
    }         

    // get the cab and inf name. For non-MUI files, we fetch this out of the ini.
    if (paul == NULL)
    {
        if (MyGetPrivateProfileString(paucCurr->pszSectionName,
                                      AU_KEY_CAB_NAME,
                                      paucCurr->szCabName,
                                      ARRAYSIZE(paucCurr->szCabName),
                                      pszCif) == FALSE)
        {
            hr = E_FAIL;
            goto done;
        }

        // if there is no inf, "" is value of field, so we're ok ignoring a  
        //  failure here
        MyGetPrivateProfileString(paucCurr->pszSectionName,
                                  AU_KEY_INF_NAME,
                                  paucCurr->szInfName,
                                  ARRAYSIZE(paucCurr->szInfName),
                                  pszCif);
    }
    // for MUI files, we base it on the name of the cab from the parent file.
    else
    {
        LPTSTR  pszExt;
        DWORD   cchExt, cchName;
        
        // make sure the buffer is big enuf
        cch = lstrlen(paucParent->szCabName);
        cchLang = lstrlen(paul->szAUName);
        if (cch + cchLang >= ARRAYSIZE(paucCurr->szCabName))
        {
            hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
            goto done;
        }
        
        hr = StringCchCopyEx(paucCurr->szCabName, ARRAYSIZE(paucCurr->szCabName),
                             paucParent->szCabName, 
                             NULL, NULL, MISTSAFE_STRING_FLAGS);
        if (FAILED(hr))
            goto done;

        // paucCurr->szCabName 
        for (pszExt = paucCurr->szCabName + cch, cchExt = 0;
             pszExt > paucCurr->szCabName && *pszExt != _T('\\') && *pszExt != _T('.');
             pszExt--, cchExt++);

        // if we hit a backslash or the beginning of the string, then move the
        //  extension pointer to the NULL terminator.
        if (*pszExt == _T('\\') || pszExt <= paucCurr->szCabName)
        {
            pszExt = paucCurr->szCabName + cch;
            cchExt = 0;
        }

        cchName = (DWORD)(pszExt - paucCurr->szCabName);

        // append the language to where the extension (if any) currently exists
        hr = StringCchCopyEx(pszExt, ARRAYSIZE(paucCurr->szCabName) - cchName, 
                             paul->szAUName,
                             NULL, NULL, MISTSAFE_STRING_FLAGS);
        if (FAILED(hr))
            goto done;

        // if there is an extension, copy it over from the original string in
        //  the parent AU_COMPONENT
        if (cchExt > 0)
        {
            hr = StringCchCopyEx(&paucCurr->szCabName[cchName + cchLang],
                                 ARRAYSIZE(paucCurr->szCabName) - cchName - cchLang,
                                 &paucParent->szCabName[cchName],
                                 NULL, NULL, MISTSAFE_STRING_FLAGS);
            if (FAILED(hr))
                goto done;
                     
        }
    }
    
    if (ReplaceFileInPath(pszCif, paucCurr->szCabName, 
                          paucCurr->szCabPath, 
                          ARRAYSIZE(paucCurr->szCabPath)) == FALSE)
    {
        hr = E_FAIL;
        goto done;
    }

    hr = BuildPaths(paucCurr, paucCurr->szFileName, NULL, pszCif, paul);
    if (FAILED(hr))
        goto done;
    
done:
    return hr;
}


/////////////////////////////////////////////////////////////////////////////////////////
//
// Function InstallUpdatedComponents()
//
//////////////////////////////////////////////////////////////////////////////////////////
HRESULT InstallUpdatedComponents(LPCTSTR pszSelfUpdateUrl,
                                 LPCTSTR pszMuiUpdateUrl,
                                 LPCTSTR pszIdentTxt,
                                 LPCTSTR pszFileCacheDir,
                                 LPCTSTR pszCif,
                                 BOOL *pfInstalledWUAUENG)
{
    USES_IU_CONVERSION;

    AU_COMPONENT    *paucRoot = NULL;
    AU_COMPONENT    *paucCurr = NULL;
    AU_COMPONENT    *paucParent = NULL;
    AU_COMPONENT    *paucMui = NULL;
    AU_FILEINCAB    *paufic = NULL;

    
    HRESULT         hr = S_OK;
    HANDLE          SfcRpcHandle = NULL;
    LPTSTR          pszSection = NULL;
    TCHAR           szSectionNames[1024];
    TCHAR           szSysDir[MAX_PATH + 1];
    TCHAR           szSrcPath[MAX_PATH + 1];
    TCHAR           szHelpFile[_MAX_FNAME + 1];
    DWORD           cchSectionNames, cch;
    BOOL            fFailedInstall = FALSE;

    // MUI stuff
    AU_LANGLIST     aull;
    DWORD           cchMuiDir = 0, cchMuiDirAvail = 0;
    DWORD           cchHelpMuiDir = 0, cchHelpMuiDirAvail = 0;
    TCHAR           szMuiDir[MAX_PATH + 1];
    TCHAR           szHelpMuiDir[MAX_PATH + 1];
    
    ZeroMemory(&aull, sizeof(aull));
    aull.pszIdentFile = pszIdentTxt;
    szMuiDir[0] = _T('\0');
    szHelpMuiDir[0] = _T('\0');
    
    *pfInstalledWUAUENG = FALSE;
    SfcRpcHandle = SfcConnectToServer(NULL);
    if (NULL == SfcRpcHandle)
    {
        hr = E_FAIL;
        goto done;
    }

    // determine how many components there are to update.
    cchSectionNames = GetPrivateProfileSectionNames(szSectionNames, 
                                                    ARRAYSIZE(szSectionNames),
                                                    pszCif);
    if ((ARRAYSIZE(szSectionNames) - 2) == cchSectionNames)
    {
        hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
        goto done;
    }
    
    cchMuiDir = ARRAYSIZE(szMuiDir);
    cchHelpMuiDir = ARRAYSIZE(szHelpMuiDir);
    hr = GetMuiLangList(&aull, szMuiDir, &cchMuiDir, szHelpMuiDir, &cchHelpMuiDir);
    if (FAILED(hr))
        goto done;

    cchMuiDirAvail = ARRAYSIZE(szMuiDir) - cchMuiDir;
    cchHelpMuiDirAvail = ARRAYSIZE(szHelpMuiDir) - cchHelpMuiDir;

    cch = GetSystemDirectory(szSysDir, ARRAYSIZE(szSysDir));
    if (cch == 0 || cch >= ARRAYSIZE(szSysDir))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto done;
    }

    // PASS 1: figure out which files to upgrade
    for (pszSection = szSectionNames; 
         *pszSection != _T('\0'); 
         pszSection += lstrlen(pszSection) + 1)
    {
        szHelpFile[0] = _T('\0');
        
        // if we didn't need to upgrade the parent file from the previous pass
        //  then we don't need to alloc a new blob- just reuse the one from the
        //  previous pass.  To signal this, we'll set paucParent to NULL if we
        //  add it to the linked list- note this covers us for the first time 
        //  thru the loop cuz we initialize paucParent to NULL.
        if (paucParent == NULL)
        {
            paucParent = (AU_COMPONENT *)malloc(sizeof(AU_COMPONENT));
            if (paucParent == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto done;
            }
        }
        ZeroMemory(paucParent, sizeof(AU_COMPONENT));
        paucParent->fMuiFile = FALSE;

        DEBUGMSG("PASS 1 -- section %S", pszSection);
        paucParent->pszSectionName = pszSection;
        if (MyGetPrivateProfileString(paucParent->pszSectionName,
                                      AU_KEY_FILE_NAME,
                                      paucParent->szFileName,
                                      ARRAYSIZE(paucParent->szFileName),
                                      pszCif) == FALSE)
        {
            hr = E_FAIL;
            goto done;
        }

        if (aull.cLangs > 0)
        {
            UINT uiHasResources;
            
            // see if we need to test for MUI file updates
            uiHasResources = GetPrivateProfileInt(paucParent->pszSectionName,
                                                  AU_KEY_RESMOD_NAME,
                                                  0,
                                                  pszCif);

            // if we do have resources, then check if we also have a helpfile
            if (uiHasResources == 1)
            {
                paucParent->fNeedToCheckMui = TRUE;

                if (MyGetPrivateProfileString(paucParent->pszSectionName,
                                              AU_KEY_HELPFILE,
                                              szHelpFile, ARRAYSIZE(szHelpFile),
                                              pszCif) == FALSE)
                {
                    szHelpFile[0] = _T('\0');
                }
            }
            else
            {
                paucParent->fNeedToCheckMui = FALSE;
            }
        }
        else
        {
            paucParent->fNeedToCheckMui = FALSE;
        }

        hr = ProcessFile(NULL, paucParent, szSysDir, NULL, pszCif);
        if (FAILED(hr))
            goto done;

        if (paucParent->fNeedToCheckMui)
        {
            DWORD   iLang;
            DWORD   cchParentFile;

            cchParentFile = lstrlen(paucParent->szFileName);
            if (cchParentFile + ARRAYSIZE(MUI_EXT) > ARRAYSIZE(paucParent->szFileName))
            {
                hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
                goto done;
            }


            for (iLang = 0; iLang < aull.cLangs; iLang++)
            {
                // if we didn't need to upgrade the file from the previous
                //  pass then we don't need to alloc a new blob- just reuse 
                //  the one from the previous pass. 
                if (paucMui == NULL)
                {
                    paucMui = (AU_COMPONENT *)malloc(sizeof(AU_COMPONENT));
                    if (paucMui == NULL)
                    {
                        hr = E_OUTOFMEMORY;
                        goto done;
                    }
                }
                ZeroMemory(paucMui, sizeof(AU_COMPONENT));
                paucMui->pszSectionName = paucParent->pszSectionName;
                paucMui->fMuiFile       = TRUE;

                // ProcessFile does not expect a trailing backslash, so be sure 
                //  not to add one.  Note that we've checked the size of the 
                //  buffer against the largest possible string it will contain
                //  above, so this should not fail.
                // The directory is build with the MUI langauge name (4 hex chars)
                hr = StringCchCopyEx(&szMuiDir[cchMuiDir], cchMuiDirAvail,
                                     aull.rgpaulLangs[iLang]->szMuiName, 
                                     NULL, NULL, MISTSAFE_STRING_FLAGS);
                if (FAILED(hr))
                    goto done;

                // the filename for a language is the same as the parent file with
                //  a ".mui" added to the end
                hr = StringCchCopyEx(paucMui->szFileName, ARRAYSIZE(paucMui->szFileName),
                                     paucParent->szFileName,
                                     NULL, NULL, MISTSAFE_STRING_FLAGS);
                if (FAILED(hr))
                    goto done;
                
                hr = StringCchCopyEx(&paucMui->szFileName[cchParentFile],
                                     ARRAYSIZE(paucMui->szFileName) - cchParentFile,
                                     MUI_EXT,
                                     NULL, NULL, MISTSAFE_STRING_FLAGS);
                if (FAILED(hr))
                    goto done;

                hr = ProcessFile(paucParent, paucMui, 
                                 szMuiDir,
                                 aull.rgpaulLangs[iLang],
                                 pszCif);
                if (FAILED(hr))
                    goto done;

                // Clean up for the next language
                szMuiDir[cchMuiDir] = _T('\0');

                // don't need to update the file 
                if (paucMui->fDoUpgrade == FALSE)
                    continue;

                if (szHelpFile[0] != _T('\0'))
                {
                    paucMui->pNextFileInCab = (AU_FILEINCAB *)malloc(sizeof(AU_FILEINCAB));
                    if (paucMui->pNextFileInCab == NULL)
                    {
                        hr = E_OUTOFMEMORY;
                        goto done;
                    }
                    ZeroMemory(paucMui->pNextFileInCab, sizeof(AU_FILEINCAB));

                    hr = StringCchCopyEx(&szHelpMuiDir[cchHelpMuiDir], cchHelpMuiDirAvail,
                                         aull.rgpaulLangs[iLang]->szMuiName, 
                                         NULL, NULL, MISTSAFE_STRING_FLAGS);
                    if (FAILED(hr))
                        goto done;
                    
                    hr = BuildPaths(paucMui->pNextFileInCab, 
                                    szHelpFile, szHelpMuiDir, 
                                    pszCif, 
                                    aull.rgpaulLangs[iLang]);
                    if (FAILED(hr))
                        goto done;
                }

                // we do need to update the file, so add it to our list of files
                //  to update
                paucMui->pNext = paucRoot;
                paucRoot       = paucMui;
                paucMui        = NULL;
            }
        }

        // if we need to update the parent file, add it to our list of files to
        //  update
        if (paucParent->fDoUpgrade)
        {
            paucParent->pNext = paucRoot;
            paucRoot          = paucParent;
            paucParent        = NULL;
        }

    }

    // short cut the rest of the function if we have no work to do
    hr = S_OK;
    if (paucRoot == NULL)
        goto done;

    // PASS 2: bring down the required cabs
    DWORD dwFlags = 0;

    if (gpState->fInCorpWU())
    {
        dwFlags |= WUDF_DONTALLOWPROXY;
    }

    for (paucCurr = paucRoot; paucCurr != NULL; paucCurr = paucCurr->pNext)
    {   
        LPCTSTR pszDownloadUrl;

        pszDownloadUrl = (paucCurr->fMuiFile) ? pszMuiUpdateUrl : pszSelfUpdateUrl;
        
        DEBUGMSG("PASS 2 -- downloading %S", paucCurr->szCabName);

        // We have to install so bring down the full cab
        hr = DownloadCab(ghServiceFinished,
                         paucCurr->szCabName,
                         pszDownloadUrl,
                         pszFileCacheDir,
                         dwFlags);
        if (FAILED(hr))
        {
            DEBUGMSG("Failed to download %S (%#lx)", paucCurr->szCabName, hr);
            goto done;
        }

        //Verify that the extracted file is a binary and it's subsystem matches that of the OS
        if (FAILED(hr = IsBinaryCompatible(paucCurr->szExtractFilePath)))
        {
            DEBUGMSG("%S is not a valid binary file (error %#lx)", paucCurr->szExtractFilePath, hr);
            goto done;
        }

        // Check version number against cif
        DWORD dwNewMS, dwNewLS;

        LPSTR pszTmp;
        pszTmp = T2A(paucCurr->szExtractFilePath);
        if (pszTmp == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }

        // this function will never return a failure code.  Intstead, check if 
        //  both return values are 0
        hr = GetVersionFromFileEx(pszTmp, &dwNewMS, &dwNewLS, TRUE /* get version */);
        if (FAILED(hr) || (dwNewMS == 0 && dwNewLS == 0))
        {
            DEBUGMSG("Failed to get version info from %S (%#lx)", paucCurr->szExtractFilePath, hr);
            goto done;
        }

        if (paucCurr->dwUpdateMS != dwNewMS || 
            paucCurr->dwUpdateLS != dwNewLS)
        {
            hr = HRESULT_FROM_WIN32(ERROR_INSTALL_PACKAGE_VERSION);
            DEBUGMSG("Version mismatch for %S - %d.%d.%d.%d vs %d.%d.%d.%d",
                paucCurr->szExtractFilePath,
                HIWORD(paucCurr->dwUpdateMS),
                LOWORD(paucCurr->dwUpdateMS),
                HIWORD(paucCurr->dwUpdateLS),
                LOWORD(paucCurr->dwUpdateLS),
                HIWORD(dwNewMS),
                LOWORD(dwNewMS),
                HIWORD(dwNewLS),
                LOWORD(dwNewLS));
            goto done;
        }
    }

    hr = StringCchCopyEx(szSrcPath, ARRAYSIZE(szSrcPath), pszCif,
                         NULL, NULL, MISTSAFE_STRING_FLAGS);
    if (FAILED(hr))
        goto done;
    
    PathRemoveFileSpec(szSrcPath);
    
    // PASS 3: Copy files to *.new in destination directory.
    for (paucCurr = paucRoot; paucCurr != NULL; paucCurr = paucCurr->pNext)
    {
        if (FAILED(hr = vAU_W2A(paucCurr->szCabPath, 
                    paucCurr->a_szCabPath, 
                    sizeof(paucCurr->a_szCabPath))))
        {
            fFailedInstall = TRUE;
            goto done;
        }

        // copy all the files to their new locations
        for (paufic = paucCurr; paufic != NULL; paufic = paufic->pNextFileInCab)
        {
            DEBUGMSG("PASS 3 -- copying %S --> %S", 
                     paufic->szExtractFilePath, 
                     paufic->szNewFilePath);
            

            if ( !CopyFile(paufic->szExtractFilePath, paufic->szNewFilePath, FALSE) )
            {
                fFailedInstall = TRUE;
                hr = E_FAIL;
                goto done;
            }
        }

        // this comparison is sufficient because we don't care if we replaced a 
        //  MUI lang pack for wuaueng.dll.  The reason is that the service runs
        //  as local system, which always uses the native language (and the 
        //  service doesn't pop up UI anyway)
        // we do, however, need to check for a winhttp update
        if (StrCmpI(WUAUENG_DLL, paucCurr->szFileName) == 0 ||
            StrCmpI(c_szWinHttpDll, paucCurr->szFileName) == 0)
        {
            *pfInstalledWUAUENG = TRUE;
        }
    }

    // PASS 4: Move the <file>.new into its proper location
    for (paucCurr = paucRoot; paucCurr != NULL; paucCurr = paucCurr->pNext)
    {
        // copy all the files to their new locations
        for (paufic = paucCurr; paufic != NULL; paufic = paufic->pNextFileInCab)
        {
            if ( paufic->fFileExists )
            {
                DEBUGMSG("PASS 4 -- renaming %S --> %S", paufic->szFilePath, paufic->szBackupFilePath);
                if ( !SfcMoveFileEx(paufic->szFilePath, paufic->szBackupFilePath, 
                                    paufic->szFilePath, SfcRpcHandle) )
                {
                    fFailedInstall = TRUE;
                    hr = E_FAIL;
                    goto done;
                }
                paufic->fCreatedBackup = TRUE;
            }
            
            DEBUGMSG("PASS 4 -- renaming %S --> %S", paufic->szNewFilePath, paufic->szFilePath);
            if (!MoveFileEx(paufic->szNewFilePath, paufic->szFilePath, MOVEFILE_REPLACE_EXISTING))
            {
                fFailedInstall = TRUE;
                hr = E_FAIL;
                goto done;
            }
        }
    }

    // PASS 5: Run any .inf file.
    for (paucCurr = paucRoot; paucCurr != NULL; paucCurr = paucCurr->pNext)
    {
        if (paucCurr->szInfName[0] != _T('\0'))
        {
            DEBUGMSG("PASS 5A -- executing inf %S", paucCurr->szInfName);
            CABINFO cabinfo;
            HRESULT hr2;

            cabinfo.pszCab = paucCurr->a_szCabPath;
            cabinfo.pszInf = paucCurr->a_szInfName;
            if (FAILED( hr2 = vAU_W2A(paucCurr->szInfName, paucCurr->a_szInfName, sizeof(paucCurr->a_szInfName)))
               || FAILED(hr2 = vAU_W2A(szSrcPath, cabinfo.szSrcPath, sizeof(cabinfo.szSrcPath))))
            {
                DEBUGMSG("vAU_W2A failed: %#lx", hr2);
                if (SUCCEEDED(hr))
                {
                    hr = hr2;
                    fFailedInstall = TRUE;
                }
                // don't delete the backup file.  Need to restore it afterwards.
                continue;
            }
            
            
            cabinfo.pszSection = "DefaultInstall";
            cabinfo.dwFlags = ALINF_QUIET;
            if ( FAILED(hr2 = ExecuteCab(NULL, &cabinfo, NULL)) )
            {
                DEBUGMSG("ExecuteCab failed on %s (%#lx)", paucCurr->a_szInfName, hr2);
                if (SUCCEEDED(hr))
                {
                    hr = hr2;
                    fFailedInstall = TRUE;
                }
                // don't delete the backup file.  Need to restore it afterwards.
                continue;
            }
        }

        for (paufic = paucCurr; paufic != NULL; paufic = paufic->pNextFileInCab)
        {

            // delete the backup file corresponding to the .inf which was successfully installed
            if (paufic->fCreatedBackup &&
                StrCmpI(WUAUENG_DLL, paucCurr->szFileName) != 0)
            {
                DEBUGMSG("PASS 5B - deleting bak file %S", paufic->szBackupFilePath);
                if ( DeleteFile(paufic->szBackupFilePath) )
                {
                    paufic->fCreatedBackup = FALSE;
                }
#ifdef DBG
                else
                {
                    DEBUGMSG("Could not delete %S (error %d)", paufic->szBackupFilePath, GetLastError());
                }
#endif
            }
        }
    }
    
done:
    // if we failed an install, revert all the prior installs
    if ( fFailedInstall )
    {
        for (paucCurr = paucRoot; paucCurr != NULL; paucCurr = paucCurr->pNext)
        {
            for(paufic = paucCurr; paufic != NULL; paufic = paufic->pNextFileInCab)
            {
                if (paufic->fCreatedBackup)
                {
                    DEBUGMSG("Reverting %S --> %S", paufic->szBackupFilePath, paufic->szFilePath);
                    MoveFileEx(paufic->szBackupFilePath, paufic->szFilePath, MOVEFILE_REPLACE_EXISTING);
                }
            }
        }
    }

    if (paucParent != NULL)
        free(paucParent);
    if (paucMui != NULL)
    {
        while (paucMui->pNextFileInCab != NULL)
        {
            paufic = paucMui->pNextFileInCab;
            paucMui->pNextFileInCab = paucMui->pNextFileInCab->pNextFileInCab;
            free(paufic);
        }
        free(paucMui);
    }

    // cleanup the linked list of files
    while(paucRoot != NULL)
    {
        paucCurr = paucRoot;
        paucRoot = paucCurr->pNext;
        while (paucCurr->pNextFileInCab != NULL)
        {
            paufic = paucCurr->pNextFileInCab;
            paucCurr->pNextFileInCab = paucCurr->pNextFileInCab->pNextFileInCab;
            free(paufic);
        }
        free(paucCurr);
    }

    // cleanup the MUI stuff
    CleanupMuiLangList(&aull);

    if ( NULL != SfcRpcHandle )
    {
         SfcClose(SfcRpcHandle);
    }

    return hr;
}


////////////////////////////////////////////////////////////////////////////
//
// fConvertDotVersionStrToDwords
//
////////////////////////////////////////////////////////////////////////////
BOOL fConvertVersionStrToDwords(LPTSTR pszVer, LPDWORD pdwMS, LPDWORD pdwLS)
{
    DWORD   grVerFields[4] = {0,0,0,0};
    TCHAR   *pch = pszVer;
    int     i;

    // _ttol will stop when it hits a non-numeric character, so we're 
    //  safe calling it this way
    grVerFields[0] = _ttol(pch);

    for (i = 1; i < 4; i++)
    {
        while (*pch != _T('\0') && _istdigit(*pch))
            pch++;

        if (*pch == _T('\0'))
            break;
        pch++;

        // _ttol will stop when it hits a non-numeric character, so we're 
        //  safe calling it this way
        grVerFields[i] = _ttol(pch);
   }

   *pdwMS = (grVerFields[0] << 16) + grVerFields[1];
   *pdwLS = (grVerFields[2] << 16) + grVerFields[3];

   return true;
}

////////////////////////////////////////////////////////////////////////////
//
// MyGetPrivateProfileString
//
// Same as normal call but if buffer is too small or default string is returned
// then function returns FALSE.
////////////////////////////////////////////////////////////////////////////
BOOL MyGetPrivateProfileString(	IN LPCTSTR lpAppName,
								IN LPCTSTR lpKeyName,
								OUT LPTSTR lpReturnedString,
								IN DWORD nSize,
								IN LPCTSTR lpFileName, 
								IN LPCTSTR lpDefault)
{
    BOOL fRet = TRUE;


	if (NULL == lpAppName || NULL == lpKeyName || NULL == lpDefault || NULL == lpReturnedString)
	{
		return FALSE;
	}
	DWORD dwRet = GetPrivateProfileString(lpAppName,
										  lpKeyName,
										  lpDefault,
										  lpReturnedString,
										  nSize,
										  lpFileName);

    if ( ((nSize - 1) == dwRet) || (_T('\0') == *lpReturnedString) )
    {
        fRet = FALSE;
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\wuaueng\tscompat.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  tscompat.h
//
//  Exported prototypes and definitions for module tscompat.cpp 
//
//  10/11/2001   annah   Created
//
//----------------------------------------------------------------------------

// this is a private NT function that doesn't appear to be defined anywhere public
extern "C" 
{
    HANDLE GetCurrentUserToken_for_Win2KW(  WCHAR Winsta[], DWORD DesiredAccess);
}

BOOL WINAPI _WTSQueryUserToken(/* in */ ULONG SessionId, /* out */ PHANDLE phToken);
BOOL _IsTerminalServiceRunning (VOID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\wuaueng\statusping.cpp ===
//=======================================================================
//
//  Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:    statusping.cpp
//
//  Creator: PeterWi
//
//  Purpose: status ping back functions
//
//=======================================================================
#include "pch.h"
#pragma hdrstop


PingStatus gPingStatus;

void PingStatus::ReadLiveServerUrlFromIdent(void)
{
	LPTSTR ptszLiveServerUrl;

	if (NULL != (ptszLiveServerUrl = (TCHAR*) malloc(sizeof(TCHAR) * INTERNET_MAX_URL_LENGTH)))
	{
		TCHAR tszIdentFile[MAX_PATH];

		if (SUCCEEDED(GetDownloadPath(tszIdentFile, ARRAYSIZE(tszIdentFile))) &&
			SUCCEEDED(PathCchAppend(tszIdentFile, ARRAYSIZE(tszIdentFile), IDENTTXT)))
		{
			DWORD dwStrLen = GetPrivateProfileString(
								_T("IUPingServer"),
								_T("ServerUrl"),
								_T(""),
								ptszLiveServerUrl,
								INTERNET_MAX_URL_LENGTH,
								tszIdentFile);
			if (0 != dwStrLen &&
				INTERNET_MAX_URL_LENGTH-1 != dwStrLen)	// do this until there's a better way to check for errors
			{
				(void) SetLiveServerUrl(ptszLiveServerUrl);
			}
			else
			{
				DEBUGMSG("PingStatus::ReadLiveServerUrlFromIdent() failed to read server URL from ident");
			}
		}
		free(ptszLiveServerUrl);
	}
}


void PingStatus::PingDetectionSuccess(
						BOOL fOnline,
						UINT cItems)
{
	TCHAR tszMessage[30];

	(void) StringCchPrintfEx(tszMessage, ARRAYSIZE(tszMessage), NULL, NULL, MISTSAFE_STRING_FLAGS, _T("items=%u"), cItems);
	_Ping(
		fOnline,
		URLLOGACTIVITY_Detection,
		URLLOGSTATUS_Success,
		0,
		tszMessage,
		NULL,
		NULL);
}

void PingStatus::PingDetectionFailure(
						BOOL fOnline,
						DWORD dwError,
						LPCTSTR ptszMessage)
{
	_Ping(
		fOnline,
		URLLOGACTIVITY_Detection,
		URLLOGSTATUS_Failed,
		dwError,
		ptszMessage,
		NULL,
		NULL);
}


void PingStatus::PingDownload(
						BOOL fOnline,
						URLLOGSTATUS status,
						DWORD dwError,
						LPCTSTR ptszItemID,
						LPCTSTR ptszDeviceID,
						LPCTSTR ptszMessage)
{
	switch (status)
	{
	case URLLOGSTATUS_Success:
	case URLLOGSTATUS_Failed:
	case URLLOGSTATUS_Declined:
		break;
	default:
		DEBUGMSG("ERROR: PingDownload() invalid parameter");
		return;
	}

	_Ping(
		fOnline,
		URLLOGACTIVITY_Download,
		status,
		dwError,
		ptszMessage,
		ptszItemID,
		ptszDeviceID);
}


void PingStatus::PingDeclinedItem(
						BOOL fOnline,
						URLLOGACTIVITY activity,
						LPCTSTR ptszItemID)
{
	switch (activity)
	{
	case URLLOGACTIVITY_Download:
	case URLLOGACTIVITY_Installation:
		break;
	default:
		DEBUGMSG("ERROR: PingDeclinedItem() invalid activity code");
		return;
	}

	if (NULL == ptszItemID)
	{
		DEBUGMSG("ERROR: PingDeclinedItem() invalid item ID");
		return;
	}

	_Ping(
		fOnline,
		activity,
		URLLOGSTATUS_Declined,
		0x0,
		NULL,
		ptszItemID,
		NULL);
}


///////////////////////////////////////////////////////////////////////////////////
// status:		IN ping status code
// dwError:		IN error code
///////////////////////////////////////////////////////////////////////////////////
void PingStatus::PingSelfUpdate(
						BOOL fOnline,
						URLLOGSTATUS status,
						DWORD dwError)
{
	const TCHAR WUAUENGFILE[] = _T("wuaueng.dll");

	TCHAR tszFileVer[30];
	HRESULT hr;
	size_t cchVerLen;
    LPTSTR ptszFileVersion;

	switch (status)
	{
	case URLLOGSTATUS_Success:
	case URLLOGSTATUS_Failed:
	case URLLOGSTATUS_Pending:
		break;
	default:
		DEBUGMSG("ERROR: PingSelfUpdate() invalid parameter");
		return;
	}

    if (FAILED(hr = StringCchCopyEx(
						tszFileVer,
						ARRAYSIZE(tszFileVer),
						_T("ver="),
						&ptszFileVersion,
						&cchVerLen,
						MISTSAFE_STRING_FLAGS)) ||
		FAILED(hr = GetFileVersionStr(
						WUAUENGFILE,
						ptszFileVersion,
						cchVerLen)))
	{
		DEBUGMSG("ERROR: PingSelfUpdate() GetFileVersionStr() failed.");
		return;
	}

	_Ping(
		fOnline,
		URLLOGACTIVITY_SelfUpdate,
		status,
		dwError,
		tszFileVer,
		NULL,	// no item
		NULL);	// no device
}


//----------------------------------------------------------------------
//
// private function to gather common info and perform ping
//
//----------------------------------------------------------------------
void PingStatus::_Ping(
		BOOL fOnline,
		URLLOGACTIVITY activity,
		URLLOGSTATUS status,
		DWORD dwError,
		LPCTSTR ptszMessage,
		LPCTSTR ptszItemID,
		LPCTSTR ptszDeviceID)
{
	HRESULT hr = CUrlLog::Ping(
				fOnline,
				URLLOGDESTINATION_DEFAULT,
				&ghServiceFinished,
				1,
				activity,
				status,
				dwError,
				ptszItemID,
				ptszDeviceID,
				ptszMessage);	// use default base URL and client name
	if (FAILED(hr))
	{
		DEBUGMSG("PingStatus::_Ping() failed to send/queue the request");
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\wuaulib\aucompat.cpp ===
/****************************************************************************
Copyright (c) 2001 Microsoft Corporation

Module Name:
    aucompat.cpp

Revision History:
    DerekM      created     10/28/01

****************************************************************************/

#include "pch.h"
#pragma hdrstop

// **************************************************************************
BOOL AUIsTSRunning(void)
{
    SC_HANDLE   hsc;
    BOOL        fRet = FALSE;

    hsc = OpenSCManager(NULL, NULL, GENERIC_READ);
    if (hsc != NULL) 
    {
        SC_HANDLE hsvcTS;
        
        hsvcTS = OpenService(hsc, L"TermService", SERVICE_QUERY_STATUS);
        if (hsvcTS != NULL) 
        {
            SERVICE_STATUS ss;
            
            if (QueryServiceStatus(hsvcTS, &ss))
                fRet = (ss.dwCurrentState == SERVICE_RUNNING);

            CloseServiceHandle(hsvcTS);
        } 

        CloseServiceHandle(hsc);
    } 

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\wuaueng\tscompat.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  tscompat.cpp
//
//  This module include functions that were introduced to replace missing
//  functions/functionality from Windows XP to Windows 2000. 
//
//  10/11/2001   annah   Created
//
//----------------------------------------------------------------------------

#include "pch.h"
#include "tscompat.h"
#include "service.h"


//----------------------------------------------------------------------------
// Replacements for TS functions
//----------------------------------------------------------------------------

//
// Copied from TS sources, as this function is not available on the
// win2k wtsapi32.dll. The function simpy calls WTSQueryUserToken() on non-Win2K platforms.
//
BOOL WINAPI _WTSQueryUserToken(/* in */ ULONG SessionId, /* out */ PHANDLE phToken)
{
	typedef BOOL (WINAPI * WTSQUERYUSERTOKEN) (ULONG SessionId, PHANDLE phToken);

    BOOL IsTsUp = FALSE;
    BOOL Result = FALSE;
    ULONG ReturnLength;
    WINSTATIONUSERTOKEN Info;
    HANDLE hUserToken = NULL;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
	HMODULE hModule = NULL;
	WTSQUERYUSERTOKEN pfnWTSQueryUserToken = NULL;


	// Let WTSQueryUserToken() handle non-Win2K platforms.
	if (!IsWin2K())
	{
		if ( (NULL != (hModule = LoadLibraryFromSystemDir(TEXT("wtsapi32.dll")))) &&
			 (NULL != (pfnWTSQueryUserToken = (WTSQUERYUSERTOKEN)::GetProcAddress(hModule, "WTSQueryUserToken"))) )
		{
			Result = pfnWTSQueryUserToken(SessionId, phToken);
		}
		goto done;
	}

    // Do parameter Validation
    if (NULL == phToken) {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto done;
    }

	// If it is session 0, don't call winsta. Use GetCurrentUserToken_for_Win2KW instead. 
	if (SessionId == 0)
	{
        hUserToken = GetCurrentUserToken_for_Win2KW(L"WinSta0",
                                            TOKEN_QUERY |
                                            TOKEN_DUPLICATE |
                                            TOKEN_ASSIGN_PRIMARY
                                            );

        if (hUserToken != NULL)
		{
            *phToken = hUserToken;
			Result = TRUE;
		}
   	}
	else	// Non-zero sessions
	{
		//fixcode: mariogo said it is unnecessary to check
		// IsTerminalServiceRunning() if the session is not 0.
		//
		// No one except TS has any idea about non-zero sessions. So, check if the TS is running.
	    IsTsUp = _IsTerminalServiceRunning();
		if (IsTsUp) 
		{	// This is so that CSRSS can dup the handle to our process
			Info.ProcessId = LongToHandle(GetCurrentProcessId());
			Info.ThreadId = LongToHandle(GetCurrentThreadId());

			Result = WinStationQueryInformation(
				        SERVERNAME_CURRENT,
					    SessionId,
						WinStationUserToken,
	                    &Info,
		                sizeof(Info),
			            &ReturnLength
				        );

	        if ( Result )
			{
				*phToken = Info.UserToken ; 
			}
		}
		else
		{	// TS is not running. So, set error for non-zero sessions: WINSTATION_NOT_FOUND.
            SetLastError(ERROR_CTX_WINSTATION_NOT_FOUND);
        }
	}

done:
	if ( NULL != hModule )
	{
		FreeLibrary( hModule );
	}
	return Result;
}

//
// This function determines if the Terminal Service is currently Running.
// Copied from TS sources, as it is required on the _WTSQueryUserToken() function.
//
BOOL _IsTerminalServiceRunning (VOID)
{

    BOOL bReturn = FALSE;
    SC_HANDLE hServiceController;

    hServiceController = OpenSCManager(NULL, NULL, GENERIC_READ);
    if (hServiceController) 
    {
        SC_HANDLE hTermServ ;
        hTermServ = OpenService(hServiceController, L"TermService", SERVICE_QUERY_STATUS);
        if (hTermServ) 
        {
            SERVICE_STATUS tTermServStatus;
            if (QueryServiceStatus(hTermServ, &tTermServStatus)) 
            {
                bReturn = (tTermServStatus.dwCurrentState == SERVICE_RUNNING);
            } 
            else 
            {
                CloseServiceHandle(hTermServ);
                CloseServiceHandle(hServiceController);
                return FALSE;
            }

            CloseServiceHandle(hTermServ);
        } 
        else 
        {
            CloseServiceHandle(hServiceController);
            return FALSE;
        }
        CloseServiceHandle(hServiceController);
    } 
    else 
    {
        return FALSE;
    }

    return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\wuaulib\aubasecatalog.cpp ===
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       aucatalog.cpp
//
//  Purpose:	AU catalog file using IU 
//
//  Creator:	WeiW
//
//  History:	08-15-01 	first created
//
//--------------------------------------------------------------------------
#include "pch.h"
#pragma hdrstop

HANDLE                 ghMutex;


HRESULT AUBaseCatalog::PrepareIU(BOOL fOnline)
{
    HRESULT hr = S_OK;
  	Reset();
   	// all IU function pointers are initialized
   	DEBUGMSG("PrepareIU() starts");
#ifdef DBG
    DWORD dwStart = GetTickCount();
#endif
       m_hIUCtl = LoadLibraryFromSystemDir(_T("iuctl.dll"));	
	if (NULL == m_hIUCtl)
	{
		hr = E_FAIL;
		DEBUGMSG("AUBaseCatalog:PrepareIU() Fail to load iuctl.dll");
		goto end;
	}
	if (NULL == (m_pfnCtlLoadIUEngine = (PFN_LoadIUEngine) GetProcAddress(m_hIUCtl, "LoadIUEngine")))
	{
		hr = E_FAIL;
		DEBUGMSG("AUBaseCatalog:PrepareIU() Fail to GetProcAddress for LoadIUEngine");
		goto end;
	}

	if (NULL == (m_pfnCtlUnLoadIUEngine = (PFN_UnLoadIUEngine) GetProcAddress(m_hIUCtl, "UnLoadIUEngine")))
	{
		hr = E_FAIL;
		DEBUGMSG("AUBaseCatalog:PrepareIU() Fail to getprocaddress for UnloadIUEngine");
		goto end;
	}
	if (NULL == (m_pfnCtlCancelEngineLoad = (PFN_CtlCancelEngineLoad) GetProcAddress(m_hIUCtl, "CtlCancelEngineLoad")))
    {
           hr = E_FAIL;
           DEBUGMSG("AUBaseCatalog:PrepareIU() fail to get procaddress for CtlCancelEngineLoad");
           goto end;
    }
	if (NULL == (m_hIUEng = m_pfnCtlLoadIUEngine(TRUE, !fOnline))) //synchronous mode, selfupdate IU engine if required
	{
		hr = E_FAIL;
		DEBUGMSG("AUBaseCatalog:PrepareIU() Fail to call LoadIUEngine");
		goto end;
	}
       m_fEngineLoaded = TRUE;
	if (NULL == (m_pfnGetSystemSpec = (PFN_GetSystemSpec) GetProcAddress(m_hIUEng, "EngGetSystemSpec")))
	{
		hr = E_FAIL;
		DEBUGMSG("AUBaseCatalog:PrepareIU() Fail to getprocaddress for GetSystemSpec");
		goto end;
	}
	if (NULL == (m_pfnGetManifest = (PFN_GetManifest) GetProcAddress(m_hIUEng, "EngGetManifest")))
	{
		hr = E_FAIL;
		DEBUGMSG("AUBaseCatalog:PrepareIU() Fail to getprocaddress for GetManifest");
		goto end;
	}

	if (NULL == (m_pfnDetect = (PFN_Detect)GetProcAddress(m_hIUEng, "EngDetect")))
	{
		hr = E_FAIL;
		DEBUGMSG("AUBaseCatalog:PrepareIU() Fail to getprocaddress for Detect");
		goto end;
	}
	if (NULL == (m_pfnInstall = (PFN_Install)GetProcAddress(m_hIUEng, "EngInstall")))
	{
		hr = E_FAIL;
		DEBUGMSG("AUBaseCatalog:PrepareIU() Fail to getprocaddress for Install");
		goto end;
	}
	if (NULL == (m_pfnSetOperationMode = (PFN_SetOperationMode)GetProcAddress(m_hIUEng, "EngSetOperationMode")))
	{
		hr = E_FAIL;
		DEBUGMSG("AUBaseCatalog:PrepareIU() Fail to getprocaddress for SetOperationMode");
		goto end;
	}
	if (NULL == (m_pfnCreateEngUpdateInstance = (PFN_CreateEngUpdateInstance)GetProcAddress(m_hIUEng, "CreateEngUpdateInstance")))
	{
		hr = E_FAIL;
		DEBUGMSG("AUBaseCatalog:PrepareIU() Fail to getprocaddress for CreateEngUpdateInstance");
		goto end;
	}
	if (NULL == (m_pfnDeleteEngUpdateInstance = (PFN_DeleteEngUpdateInstance)GetProcAddress(m_hIUEng, "DeleteEngUpdateInstance")))
	{
		hr = E_FAIL;
		DEBUGMSG("AUBaseCatalog:PrepareIU() Fail to getprocaddress for DeleteEngUpdateInstance");
		goto end;
	}

	if (NULL == (m_hIUEngineInst = m_pfnCreateEngUpdateInstance()))
	{
		hr = E_FAIL;
		DEBUGMSG("AUBaseCatalog:PrepareIU() Fail to call CreateEngUpdateInstance");
		goto end;
	}
end:
       if (FAILED(hr))
            {
                FreeIU();
            }
#ifdef DBG
       DEBUGMSG("PrepareIU() take %d msecs", GetTickCount() - dwStart);
#endif
       DEBUGMSG("PrepareIU() done");
        return hr;
}


// could be called even if without PrepareIU() being called first
void AUBaseCatalog::FreeIU()
{
       DEBUGMSG("AUCatalog::FreeIU() starts");
#ifdef DBG
       DWORD dwStart = GetTickCount();
#endif

	if (NULL != m_hIUEng)
	{
		if (NULL != m_pfnDeleteEngUpdateInstance)
		{
			  DEBUGMSG("calling DeleteEngUpdateInstance ....");
			  m_pfnDeleteEngUpdateInstance(m_hIUEngineInst);
		}
		if (NULL != m_pfnCtlUnLoadIUEngine)
		{
			  DEBUGMSG("calling ctlunloadIUengine ....");
			  m_pfnCtlUnLoadIUEngine(m_hIUEng);
		}
	}
	if (NULL != m_hIUCtl)
        {
	   FreeLibrary(m_hIUCtl);
	 }

	Reset();
#ifdef DBG
    DEBUGMSG("FreeIU() take %d msecs", GetTickCount() - dwStart);
#endif
	DEBUGMSG("AUCatalog::FreeIU() done");
}

HRESULT AUBaseCatalog::CancelNQuit(void)
{
    HRESULT hr = S_OK;
    DEBUGMSG("AUBaseCatalog::CancelNQuit() starts");
    if (!m_fEngineLoaded && NULL != m_pfnCtlCancelEngineLoad)
        {
            DEBUGMSG("IU Engine not loaded. Cancel loading if so");
            hr =  m_pfnCtlCancelEngineLoad();
        }
    else if (m_fEngineLoaded && NULL != m_pfnSetOperationMode)
        {
            DEBUGMSG("IU Engine loaded. Cancel any IU operation");
            hr = m_pfnSetOperationMode(m_hIUEngineInst, NULL, UPDATE_COMMAND_CANCEL);
        }
    DEBUGMSG("AUBaseCatalog::CancelNQuit() ends");
    return hr;
}

AUBaseCatalog::~AUBaseCatalog(void)
{
//    DEBUGMSG("AUBaseCatalog::~AUBaseCatalog() starts");
    if (NULL != ghMutex) //client don't need this
        {
        WaitForSingleObject(ghMutex, INFINITE); //If CancelNQuit is being called, wait until it is done
        ReleaseMutex(ghMutex);
        }
//    DEBUGMSG("AUBaseCatalog::~AUBaseCatalog() ends");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\wuaueng\wuaueng.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:      wuaueng.h
//
//--------------------------------------------------------------------------

#pragma once
#include <windows.h>
#include <wchar.h>
#include <tchar.h>
#include <ole2.h>
#include <setupapi.h>
#include <wininet.h>
#include <inseng.h>
//#include <newtrust.h>
#include <malloc.h>
#include <stddef.h>
//#include <atlconv.h>
#include <wuaustate.h>
#include "wuaulib.h"
#include "AUSessions.h"

#include <URLLogging.h>

#define AUSCHEDINSTALLDAY_MIN 		0
#define AUSCHEDINSTALLDAY_MAX 		7
#define AUSCHEDINSTALLTIME_MIN 		0
#define AUSCHEDINSTALLTIME_MAX 		23

typedef struct tagWORKER_THREAD_INIT_DATA 
{
	UINT uFirstMsg;
	BOOL fWaitB4Detect;
	DWORD dwWaitB4Detect;
} WORKER_THREAD_INIT_DATA;


#define E_NOCONNECTION		HRESULT_FROM_WIN32(ERROR_CONNECTION_UNAVAIL)

HRESULT	SelfUpdate(void);
HRESULT CheckForUpdatedComponents(BOOL   *pfInstalledWUAUENG);
HRESULT	InstallFromCIF(LPCTSTR pstrCifCab, LPCTSTR pstrDownloadDir, LPCTSTR pstrWhich);

/////////////////////////////////////////////////////////
// Status ping information
/////////////////////////////////////////////////////////
class PingStatus: public CUrlLog //group together status ping functions
{
public:
	inline PingStatus(void):CUrlLog(_T("au"), NULL, NULL){}

	void ReadLiveServerUrlFromIdent(void);
	void PingDetectionSuccess(
			BOOL fOnline,
			UINT cItems);
	void PingDetectionFailure(
			BOOL fOnline,
			DWORD dwError,
			LPCTSTR ptszMessage = NULL);
	void PingDownload(
			BOOL fOnline,
			URLLOGSTATUS status,
			DWORD dwError,
			LPCTSTR ptszItemID = NULL,
			LPCTSTR ptszDeviceID = NULL,
			LPCTSTR ptszMessage = NULL);
	void PingSelfUpdate(
			BOOL fOnline,
			URLLOGSTATUS status,
			DWORD dwError);
	void PingDeclinedItem(
			BOOL fOnline,
			URLLOGACTIVITY activity,
			LPCTSTR ptszItemID);


private:
	//----------------------------------------------------------------------
	//
	// private function to gather common info and perform ping
	//
	//----------------------------------------------------------------------
	void _Ping(
			BOOL fOnline,
			URLLOGACTIVITY activity,
			URLLOGSTATUS status,
			DWORD dwError,
			LPCTSTR ptszMessage,
			LPCTSTR ptszItemID,
			LPCTSTR ptszDeviceID);
};


#define IDOWNLOAD_COMPLETE_EVT			0
#define IDOWNLOAD_TRANSIENT_ERROR_EVT	1
#define IDOWNLOAD_DOWNLOAD_IN_PROGRESS  2
#define IDOWNLOAD_SERVICE_FINISH		3
#define IDOWNLOAD_SERVICE_DISABLED		4
#define IDOWNLOAD_DOWNLOAD_CANCELED		5

#define IDOWNLOAD_MESSAGE				6
#define CNUM_DOWNLOAD_EVT				6

extern HANDLE ghServiceFinished;
extern HANDLE ghEngineState;
extern HANDLE ghServiceDisabled;
extern HANDLE ghValidateCatalog;
extern HANDLE	ghNotifyClient;
extern HANDLE ghWorkerThreadMsgQueueCreation;
extern CLIENT_NOTIFY_DATA	gClientNotifyData;
extern DWORD	gdwWorkerThreadId;
extern SESSION_STATUS gAdminSessions;
extern PingStatus gPingStatus;


typedef struct _ENGINE_EVENTS
{
public:
void CloseEvents(void)
{
	//Don't close the ServiceFinish handle and EngineState events
	m_grEvents[IDOWNLOAD_SERVICE_FINISH] = NULL; 
	m_grEvents[IDOWNLOAD_SERVICE_DISABLED] = NULL; 	

	for ( int i = 0; i < CNUM_DOWNLOAD_EVT; i++) 
	{
		SafeCloseHandleNULL(m_grEvents[i]);
	}
}

BOOL CreateEvents(void)
{
	BOOL fRet = TRUE;
	ZeroMemory(m_grEvents, sizeof(m_grEvents));
	
	m_grEvents[IDOWNLOAD_SERVICE_FINISH] = ghServiceFinished;
	m_grEvents[IDOWNLOAD_SERVICE_DISABLED] = ghServiceDisabled; 

	for ( int i = 0; i < CNUM_DOWNLOAD_EVT; i++) 
	{
		if ( IDOWNLOAD_SERVICE_FINISH != i && IDOWNLOAD_SERVICE_DISABLED != i )
		{
			if ( NULL == (m_grEvents[i] = CreateEvent(NULL, FALSE, FALSE, NULL)) )
			{
				CloseEvents();
				fRet = FALSE;
				break;
			}
		}
	}

	return fRet;
}

void SetEvent(ULONG iEvent)
{
	if ( (iEvent < CNUM_DOWNLOAD_EVT) && (NULL != m_grEvents[iEvent]) )
	{
		::SetEvent(m_grEvents[iEvent]); 		
	}
}

ULONG cEvents(void)
{
	return CNUM_DOWNLOAD_EVT;
}

CONST HANDLE * grEventHandles(void)
{
	return m_grEvents;
}
private:
	HANDLE m_grEvents[CNUM_DOWNLOAD_EVT];

} ENGINE_EVENTS;

//defined in wuaueng.cpp
HRESULT HrCreateNewCatalog(void);
void CancelDownload(void);
void ResumeDownloadIfNeccesary(void);
HRESULT UpdateProc(WORKER_THREAD_INIT_DATA &initData);
DWORD RandomWaitTimeBeforeDetect();


//defined in service.cpp
BOOL FDownloadIsPaused();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\wuaueng\updates.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       updates.cpp
//
//--------------------------------------------------------------------------

#include "pch.h"

#pragma hdrstop


/////////////////////////////////////////////////////////////////////////////
//

GENERIC_MAPPING Updates::m_AdminGenericMapping = {

        STANDARD_RIGHTS_READ,                    // Generic read

        STANDARD_RIGHTS_WRITE,                   // Generic write

        STANDARD_RIGHTS_EXECUTE,                 // Generic execute

        STANDARD_RIGHTS_READ |                   // Generic all
        STANDARD_RIGHTS_WRITE |
        STANDARD_RIGHTS_EXECUTE
		};

Updates::Updates()
	: m_pAdminSid(NULL),
	  m_pAdminAcl(NULL),
	  m_refs(0)
{
	m_hEngineMutex = CreateMutex(NULL, FALSE, NULL);	
}

Updates::~Updates()
{
    CloseHandle(m_hEngineMutex);

    if ( NULL != m_pAdminAcl )
    {
        delete m_pAdminAcl;
    }

    if ( NULL != m_pAdminSid )
    {
        FreeSid(m_pAdminSid);
    }
	DEBUGMSG("Updates: CoDisconnectObject");
	if ( FAILED(CoDisconnectObject((IUnknown *)this, 0)) )
	{
		DEBUGMSG("CoDisconnectObject() failed");
	}
}

BOOL Updates::m_fInitializeSecurity(void)
{
    BOOL fStatus;
    ULONG cbAcl;
    SID_IDENTIFIER_AUTHORITY ntAuthority = SECURITY_NT_AUTHORITY;

    fStatus = AllocateAndInitializeSid(
                &ntAuthority,
                2,
                SECURITY_BUILTIN_DOMAIN_RID,
                DOMAIN_ALIAS_RID_ADMINS,
                0,0,0,0,0,0,
                &m_pAdminSid);

    if ( !fStatus )
	{
	DEBUGMSG("Fail to initialize SID with error %d", GetLastError());
        return FALSE;
	}

    cbAcl = sizeof(ACL)
		  + sizeof(ACCESS_ALLOWED_ACE)
		  - sizeof(DWORD) //sizeof(ACCESS_ALLOWED_ACE.SidStart)
		  + GetLengthSid(m_pAdminSid);

    m_pAdminAcl = (PACL) new BYTE[ cbAcl ];

    if ( (NULL == m_pAdminAcl)
        || !InitializeAcl(m_pAdminAcl, cbAcl, ACL_REVISION)
		|| !AddAccessAllowedAce(m_pAdminAcl, ACL_REVISION, STANDARD_RIGHTS_WRITE, m_pAdminSid)
		|| !InitializeSecurityDescriptor(&m_AdminSecurityDesc, SECURITY_DESCRIPTOR_REVISION)
		|| !SetSecurityDescriptorOwner(&m_AdminSecurityDesc, m_pAdminSid, FALSE)
		|| !SetSecurityDescriptorGroup(&m_AdminSecurityDesc, m_pAdminSid, FALSE)
		|| !SetSecurityDescriptorDacl(&m_AdminSecurityDesc, TRUE, m_pAdminAcl, FALSE) )
	{
        if ( NULL != m_pAdminAcl )
		{
			delete m_pAdminAcl;
			m_pAdminAcl = NULL;
			FreeSid(m_pAdminSid);
			m_pAdminSid = NULL;
		}
		return FALSE;
	}

    return TRUE;
}

HRESULT Updates::m_AccessCheckClient(void)
{
    BOOL accessGranted = FALSE;
    DWORD grantedAccess;
    HANDLE clientToken = NULL;
    BYTE privilegeSet[500];                      // Large buffer
    DWORD privilegeSetSize = sizeof(privilegeSet);
    static BOOL fInitSecurity = FALSE;

	if ( !fInitSecurity )
	{
		if ( !(fInitSecurity = m_fInitializeSecurity()) )
		{
		    DEBUGMSG("Fail to initialized SID");
			return E_ACCESSDENIED;
		}
	}

    if (FAILED(CoImpersonateClient()))
	{
        return E_ACCESSDENIED;
	}

    if ( OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &clientToken) )
	{
	    if (FALSE == AccessCheck(
                    &m_AdminSecurityDesc,
                    clientToken,
                    STANDARD_RIGHTS_WRITE,
                    &m_AdminGenericMapping,
                    (PPRIVILEGE_SET) privilegeSet,
                    &privilegeSetSize,
                    &grantedAccess,
                    &accessGranted))
	        {
                    DEBUGMSG("Fail to call AccessCheck() with error %d", GetLastError());
	        }
	}

    if ( clientToken != NULL )
	{
        CloseHandle( clientToken );
	}

    if (FAILED(CoRevertToSelf()))
    {
    	return  E_ACCESSDENIED;;
    }

    return (accessGranted )? S_OK : E_ACCESSDENIED;
}

STDMETHODIMP Updates::QueryInterface(REFIID riid, void **ppvObject)
{
	if (NULL == ppvObject)
	{
		return E_INVALIDARG;
	}
	if(riid == IID_IUnknown ||
	   riid == IID_IClassFactory ||
	   riid == IID_IUpdates)
	{
		*ppvObject = this;
		AddRef();
	}
	else
	{
		*ppvObject = NULL;
		return E_NOINTERFACE;
	}
	return S_OK;
}

ULONG __stdcall Updates::AddRef()
{
    long cRef = InterlockedIncrement(&m_refs);
	DEBUGMSG("Updates AddRef = %d", cRef);
	return cRef;	
}

ULONG __stdcall Updates::Release()
{
    long cRef = InterlockedDecrement(&m_refs);
	DEBUGMSG("Updates Release = %d", cRef);
	return cRef;
}
STDMETHODIMP Updates::CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObject)
{
	HRESULT hr = m_AccessCheckClient();
	
	if ( FAILED(hr) )
	{
		return hr;
	}

	if(pUnkOuter != NULL)
	{
		return CLASS_E_NOAGGREGATION;
	}

	if (NULL == ppvObject)
	{
		return E_INVALIDARG;
	}

	if(riid == IID_IUnknown ||
	   riid == IID_IClassFactory ||
	   riid == IID_IUpdates)
	{
		*ppvObject = this;
		AddRef();
	}
	else
	{
		*ppvObject = NULL;
		return E_NOINTERFACE;
	}
	return S_OK;
}

STDMETHODIMP Updates::LockServer(BOOL /*bFlag*/)
{
	HRESULT hr = m_AccessCheckClient();

	if ( FAILED(hr) )
	{
		return hr;
	}

	return E_FAIL;
}

STDMETHODIMP Updates::AvailableSessions(UINT *pcSess)
{
	HRESULT hr = m_AccessCheckClient();	
	
	if ( FAILED(hr))
	{
		return hr;
	}	
	if (NULL == pcSess)
	{
		return E_INVALIDARG;
	}	

	*pcSess = ::AvailableSessions();

    //DEBUGMSG("WUAUENG Updates::AvailableSessions was called and return value is %d", *pcSess);

	return S_OK;
}


STDMETHODIMP Updates::get_State(/*[out, retval]*/ AUSTATE *pAuState)
{
	HRESULT hr = m_AccessCheckClient();

	if ( FAILED(hr) )
	{
		return hr;
	}

	if (NULL == pAuState)
	{
		return E_INVALIDARG;
	}	
	WaitForSingleObject(m_hEngineMutex, INFINITE);
	pAuState->dwState = gpState->GetState();
	pAuState->fDisconnected = gpState->fDisconnected();
	pAuState->dwCltAction = gpState->GetCltAction();
	gpState->SetCltAction(AUCLT_ACTION_NONE); //once client read it, reset
	ReleaseMutex(m_hEngineMutex);

	return S_OK;
}

STDMETHODIMP Updates::GetUpdatesList(/*[out]*/ VARIANT *pUpdates)
{
	HRESULT hr = m_AccessCheckClient();

	if ( FAILED(hr) )
	{
		return hr;
	}
	
	DEBUGMSG("WUAUENG Getting updates list");
	if ( NULL == pUpdates )
	{
		return E_INVALIDARG;
	}

	WaitForSingleObject(m_hEngineMutex, INFINITE);
	hr = ::GetUpdatesList(pUpdates);
	ReleaseMutex(m_hEngineMutex);
	return hr;
}



STDMETHODIMP Updates::GetNotifyData(/*[out]*/ CLIENT_NOTIFY_DATA *pNotifyData)
{
	HRESULT hr = m_AccessCheckClient();

	if ( FAILED(hr) )
	{
		return hr;
	}
	
	DEBUGMSG("WUAUENG Getting client notify data");
	if ( NULL == pNotifyData )
	{
		return E_INVALIDARG;
	}

	WaitForSingleObject(m_hEngineMutex, INFINITE);
	*pNotifyData = gClientNotifyData;
	ReleaseMutex(m_hEngineMutex);
	return hr;
}

/* fixcode, only used by client, could get rid of and add VARIANT to ClientMessage()*/
STDMETHODIMP Updates::SaveSelections(/*[in]*/ VARIANT vUpdates)
{
	HRESULT hr = m_AccessCheckClient();

       DEBUGMSG("Updates::SaveSelections start");
	if ( FAILED(hr) )
	{
		goto done;
	}

	DEBUGMSG("WUAUENG Saving selections, state is %d", gpState->GetState());
	if (vUpdates.vt != (VT_ARRAY | VT_VARIANT))
	{
		DEBUGMSG("WUAUENG invalid variant list");
		return E_INVALIDARG;
	}
	WaitForSingleObject(m_hEngineMutex, INFINITE);
    ::saveSelection(&vUpdates);
    hr = S_OK;
	ReleaseMutex(m_hEngineMutex);
done:
       DEBUGMSG("Updates::SaveSelections end");
	return hr;
}

STDMETHODIMP Updates::StartDownload(void)
{
	DEBUGMSG("WUAUENG updates->StartDownload called");

	HRESULT hr = m_AccessCheckClient();

	if ( FAILED(hr) )
	{
		return hr;
	}

	WaitForSingleObject(m_hEngineMutex, INFINITE);
	hr = ::StartDownload();
	ReleaseMutex(m_hEngineMutex);
	return hr;
}

STDMETHODIMP Updates::GetDownloadStatus(UINT *pPercentage, DWORD *pStatus)
{
	HRESULT hr = m_AccessCheckClient();

	if ( FAILED(hr) )
	{
		return hr;
	}

	if ((NULL == pPercentage) || (NULL == pStatus))
	{
		return E_INVALIDARG;
	}
	WaitForSingleObject(m_hEngineMutex, INFINITE);
	hr = ::GetDownloadStatus(pPercentage, pStatus);
	ReleaseMutex(m_hEngineMutex);
	return hr;
}

STDMETHODIMP Updates::SetDownloadPaused(/*[in]*/ BOOL bPaused)
{
	HRESULT hr = m_AccessCheckClient();

	if ( FAILED(hr) )
	{
		return hr;
	}

	return PauseDownload(bPaused);
}

STDMETHODIMP Updates::ClientMessage(/*[in]*/ UINT msg)
{
	HRESULT hr = m_AccessCheckClient();

	if ( FAILED(hr) )
	{
		return hr;
	}

	// fixcode is this whole interface just one big security whole? what about other
	// routines.  can't anyone call them?
	switch (msg)
	{
		case AUMSG_PRE_INSTALL:
			DEBUGMSG("WUAUENG ClientMessage(AUMSG_PRE_INSTALL)");
            DEBUGMSG("WUAUENG Msg:Install, State->Install Pending");
            gpState->SetState(AUSTATE_INSTALL_PENDING);      // is there any benefit to doing this?
			break;
	default:
		DEBUGMSG("WUAUENG ClientMessage(!!unknown!!)");
		break;
	}

	return S_OK;
}

STDMETHODIMP Updates::get_Option(AUOPTION * pVal)
{
	HRESULT hr = m_AccessCheckClient();

	if ( FAILED(hr) )
	{
		return hr;
	}

	if (NULL == pVal)
	{
		return E_INVALIDARG;
	}

	if (NULL == gpState)
	{
	        return E_FAIL;
	}
	
    *pVal = gpState->GetOption();
    return S_OK;
}

STDMETHODIMP Updates::put_Option(AUOPTION    val)
{
	HRESULT hr = m_AccessCheckClient();

	if ( FAILED(hr) )
	{
		return hr;
	}

    AUOPTION CurrOption = gpState->GetOption();

    if ( FAILED(hr = gpState->SetOption(val)) )
    {
        return hr;
    }
            
	// if asking to disable, post msg
	if ( (AUOPTION_AUTOUPDATE_DISABLE == val.dwOption) && (CurrOption.dwOption != val.dwOption) )
	{
                DEBUGMSG("AU service disabled");
                DisableAU();
	}
	// else if asking to enable, post msg
	else if ((AUOPTION_AUTOUPDATE_DISABLE == CurrOption.dwOption) && (val.dwOption != CurrOption.dwOption)
	    || gpState->GetState() < AUSTATE_DETECT_PENDING)
	{
	    ResetEngine();
	}

       if (CurrOption.dwOption != val.dwOption
        || (AUOPTION_SCHEDULED == val.dwOption  
            && (CurrOption.dwSchedInstallDay != val.dwSchedInstallDay 
                || CurrOption.dwSchedInstallTime != val.dwSchedInstallTime)))
       {
            SetEvent(ghSettingsChanged);
       }
	return S_OK;
}
	
STDMETHODIMP Updates::ConfigureAU()
{
	HRESULT hr = m_AccessCheckClient();

	if ( FAILED(hr) )
	{
		return hr;
	}

	WaitForSingleObject(m_hEngineMutex, 10000);
	if ( AUSTATE_NOT_CONFIGURED == gpState->GetState() )
	{	
            PostThreadMessage(gdwWorkerThreadId, AUMSG_EULA_ACCEPTED, 0, 0);
	}
	ReleaseMutex(m_hEngineMutex);
	return S_OK;
}


STDMETHODIMP Updates::get_EvtHandles(DWORD dwCltProcId, AUEVTHANDLES *pauevtHandles)
{
	HRESULT hr = m_AccessCheckClient();

	if ( FAILED(hr) )
	{
		return hr;
	}

	WaitForSingleObject(ghMutex, INFINITE); // make sure proc id has been populated
       DWORD dwProcId = ghClientHandles.GetProcId();
       ReleaseMutex(ghMutex);
       
	if (dwProcId != dwCltProcId)
		{
		DEBUGMSG("WUAUENG Unauthorized client %d trying to get event handles for real client %d", dwCltProcId, dwProcId);
		return E_ACCESSDENIED;
		}

	if (NULL == pauevtHandles)
	{
		DEBUGMSG("WUAUENG GetEvtHandles invalid argument");
		return E_INVALIDARG;
	}
	WaitForSingleObject(m_hEngineMutex, INFINITE);
	hr = ::GetEvtHandles(pauevtHandles);
	ReleaseMutex(m_hEngineMutex);
	return hr;
}


STDMETHODIMP Updates::GetInstallXML(/*[out]*/ BSTR *pbstrCatalogXML, /*[out]*/ BSTR *pbstrDownloadXML)
{
    DEBUGMSG("Updates::GetInstallXML");

    HRESULT hr = m_AccessCheckClient();

	if ( FAILED(hr) )
	{
		goto done;
	}

	if (NULL == pbstrCatalogXML || NULL == pbstrDownloadXML)
	{
		return E_INVALIDARG;
	}

	WaitForSingleObject(m_hEngineMutex, INFINITE);

    hr = ::GetInstallXML(pbstrCatalogXML, pbstrDownloadXML);

    ReleaseMutex(m_hEngineMutex);
done:
	return hr;
}

STDMETHODIMP Updates::LogEvent(/*[in]*/ WORD wType, /*[in]*/ WORD wCategory, /*[in]*/ DWORD dwEventID, /*[in]*/ VARIANT vItems)
{
    DEBUGMSG("Updates::LogEvent");

    HRESULT hr = m_AccessCheckClient();

	if ( FAILED(hr) )
	{
		return hr;
	}

	if ((VT_ARRAY | VT_BSTR) != vItems.vt ||
		NULL == vItems.parray)
	{
		DEBUGMSG("WUAUENG invalid variant list");
		return E_INVALIDARG;
	}
	WaitForSingleObject(m_hEngineMutex, INFINITE);

	CAUEventLog aueventlog(g_hInstance);
    hr = aueventlog.LogEvent(
			wType,
			wCategory,
			dwEventID,
			vItems.parray) ? S_OK : E_FAIL;

    ReleaseMutex(m_hEngineMutex);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\wuaueng\updates.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       updates.h
//  		     Definition of the Updates class
//
//--------------------------------------------------------------------------

#pragma once


#include "wuauengi.h"
#include "wuaulib.h"
#include <Wtsapi32.h>
#include <wuaustate.h>
#include <wuaueng.h>
#include <accctrl.h>
#include <aclapi.h>
#include "pch.h"

// functions IUpdates uses
void  HrUninit(void);
HRESULT StartDownload(void);
HRESULT PauseDownload(BOOL bPause);
HRESULT GetUpdatesList(VARIANT *vList);
HRESULT GetInstallXML(BSTR *pbstrCatalogXML, BSTR *pbstrDownloadXML);
void saveSelection(VARIANT *selection);
HRESULT GetDownloadStatus(UINT *pPercentage, DWORD *pdwnldStatus, BOOL fCareAboutConnection = TRUE);
HRESULT GetInstallStatus(UINT *pNumFinished, DWORD *pStatus);
HRESULT GetEvtHandles(AUEVTHANDLES *pAuEvtHandles);
DWORD AvailableSessions(void);
BOOL IsSessionAUEnabledAdmin(DWORD dwSessionId);

typedef struct tagAU_CLIENT_INFO  {
	HANDLE hProcess;
	DWORD dwSessionId;
} AU_CLIENT_INFO ;
	


/////////////////////////////////////////////////////////////////////////////
// Updates
class Updates : 
	public IUpdates
{
public:
	HANDLE 	m_hEngineMutex;

	Updates();
	~Updates();
	BOOL m_fInitializeSecurity(void);
	HRESULT m_AccessCheckClient(void);
	HRESULT	GetServiceHandles();
	DWORD	ProcessState();
	BOOL	CheckConnection();

// IUnknown
	STDMETHOD(QueryInterface)(REFIID riid, void **ppvObject);
       STDMETHOD_(ULONG, AddRef)(void);
       STDMETHOD_(ULONG, Release)(void);

// IClassFactory
	STDMETHOD(CreateInstance)(IUnknown*,REFIID,void**);
	STDMETHOD(LockServer)(BOOL);

// IUpdates
	STDMETHOD(get_State)(/*[out, retval]*/ AUSTATE *pAuState);
	STDMETHOD(get_Option)(/*[out, retval]*/ AUOPTION * pAuOpt);
	STDMETHOD(put_Option)(/*[in]*/ AUOPTION  auopt);
	STDMETHOD(GetUpdatesList)(/*[out]*/ VARIANT *pUpdates);
	STDMETHOD(SaveSelections)(/*[in]*/ VARIANT vUpdates);
	STDMETHOD(StartDownload)(void);
	STDMETHOD(GetDownloadStatus)(/*[out]*/ UINT *, /*[out]*/ DWORD *);
	STDMETHOD(SetDownloadPaused)(/*[in]*/ BOOL bPaused);
	STDMETHOD(ConfigureAU)();
	STDMETHOD(AvailableSessions(/*[out]*/ UINT *pcSess));
	STDMETHOD(get_EvtHandles(/*[in]*/DWORD dwCltProcId, /*[out]*/ AUEVTHANDLES *pauevtHandles));
	STDMETHOD(ClientMessage(/*[in]*/ UINT msg));
	//STDMETHOD(PingStatus(/*[in]*/ StatusEntry se));
	STDMETHOD(GetNotifyData(/*[out]*/ CLIENT_NOTIFY_DATA *pNotifyData));	
    STDMETHOD(GetInstallXML(/*[out]*/ BSTR *pbstrCatalogXML, /*[out]*/ BSTR *pbstrDownloadXML));
	STDMETHOD(LogEvent(/*[in]*/ WORD wType, /*[in]*/ WORD wCategory, /*[in]*/ DWORD dwEventID, /*[in]*/ VARIANT vItems));
private:
	SECURITY_DESCRIPTOR m_AdminSecurityDesc;
	static GENERIC_MAPPING m_AdminGenericMapping;	
    PSID m_pAdminSid;
    PACL m_pAdminAcl;	
	long m_refs;
};


class CLIENT_HANDLES
{
public:
	CLIENT_HANDLES(void){
		InitHandle();
	}
	~CLIENT_HANDLES(void){
		Reset(TRUE);
	}
    void StopClients(BOOL fRelaunch) {
    	if (m_fRebootWarningMode)
    	{
	        DEBUGMSG("WUAUENG told %d CLIENT(S) to exit", m_dwRebootWarningClientNum);
    		if (NULL != m_hClientExitEvt)
    		{
    			SetEvent(m_hClientExitEvt);
    		}
    	}
    	else
    	{
			if (fClient())
			{
				if (fRelaunch)
				{
			        DEBUGMSG("WUAUENG told WUAUCLT to relaunch");
					NotifyClient(NOTIFY_RELAUNCH_CLIENT);
				}
				else
				{
					DEBUGMSG("WUAUENG told WUAUCLT to exit");
					NotifyClient(NOTIFY_STOP_CLIENT);
				}
			}
			else
			{
				DEBUGMSG("WARNING: StopClients() : no existing client");
			}
    	}
	}
    void ClientAddTrayIcon(void) {
    	if (m_fRebootWarningMode || m_fAsLocalSystem)
    	{
    		DEBUGMSG("WARNING: ClientAddTrayIcon() called in wrong mode");
    		return;
    	}
    		if (fClient())
    		{
    			NotifyClient(NOTIFY_ADD_TRAYICON); 
    		}
    	}
    void ClientRemoveTrayIcon(void) {
    	if (m_fRebootWarningMode || m_fAsLocalSystem)
    	{
    		DEBUGMSG("WARNING: ClientRemoveTrayIcon() called in wrong mode");
    		return;
    	}
    		if (fClient())
    		{
    			NotifyClient(NOTIFY_REMOVE_TRAYICON); 
    		}
    	}
    void ClientStateChange(void) { 
    	if (m_fRebootWarningMode || m_fAsLocalSystem)
   		{
   			DEBUGMSG("WARNING: ClientStateChange() called in wrong mode");
   			return;
   		}
    	NotifyClient(NOTIFY_STATE_CHANGE);
    	}
    void ClientShowInstallWarning(void){
    	if (m_fRebootWarningMode || m_fAsLocalSystem)
   		{
   			DEBUGMSG("WARNING: ClientShowInstallWarning() called in wrong mode");
   			return;
   		}
    		if (fClient())
    		{
    			NotifyClient(NOTIFY_SHOW_INSTALLWARNING);
    		}
	}
    void ResetClient(void) {
    	if (m_fRebootWarningMode || m_fAsLocalSystem)
   		{
   			DEBUGMSG("WARNING: ResetClient() called in wrong mode");
   			return;
   		}
    		if (fClient())
		{
			NotifyClient(NOTIFY_RESET);
		}
    	}

	//checking existence of client(s)    	
	// if dwSessionId not default value, check existence of client in that session
	// otherwise, check existence of any client
    BOOL fClient(DWORD dwSessionId = CDWNO_SESSION) { 
    	if (m_fRebootWarningMode)
    	{
    		if ( CDWNO_SESSION == dwSessionId)
    		{
    			return m_dwRebootWarningClientNum > 0;
    		}
    		else
		{
			for (DWORD  i = 0; i < m_dwRebootWarningClientNum; i++)
			{
				if (dwSessionId == m_pRebootWarningClients[i].dwSessionId)
				{
					return TRUE;
				}
			}
			return FALSE;
    		}
    	}
    	else
    	{  //deSessionId is ignored in this case
    		return (-1 != m_dwProcId) && (NULL != m_hClientProcess);
   	}
}

void SetHandle(PROCESS_INFORMATION & ProcessInfo, BOOL fAsLocalSystem)
{
	m_fRebootWarningMode = FALSE;
	m_fAsLocalSystem = fAsLocalSystem;
	m_dwProcId = ProcessInfo.dwProcessId;
	m_hClientProcess   = ProcessInfo.hProcess;
	SafeCloseHandle(ProcessInfo.hThread);
}

BOOL AddHandle(PROCESS_INFORMATION    &   ProcessInfo, DWORD dwSessionId)
{
	AU_CLIENT_INFO *pTmp=NULL;
	
	m_fRebootWarningMode = TRUE;
	SafeCloseHandle(ProcessInfo.hThread);
	pTmp  = (AU_CLIENT_INFO*) realloc(m_pRebootWarningClients, (m_dwRebootWarningClientNum+1)*sizeof(AU_CLIENT_INFO));
	if (NULL == pTmp)
	{
		return FALSE;
	}
	m_pRebootWarningClients = pTmp;
	m_pRebootWarningClients[m_dwRebootWarningClientNum].hProcess = ProcessInfo.hProcess;
	m_pRebootWarningClients[m_dwRebootWarningClientNum].dwSessionId = dwSessionId;
	m_dwRebootWarningClientNum ++;
	return TRUE;
}

void RemoveHandle(HANDLE hProcess)
{
	if (m_fRebootWarningMode)
	{
		for (DWORD i = 0; i < m_dwRebootWarningClientNum; i++)
		{
			if (hProcess == m_pRebootWarningClients[i].hProcess)
			{
				CloseHandle(hProcess);
				m_pRebootWarningClients[i] = m_pRebootWarningClients[m_dwRebootWarningClientNum -1];
				m_dwRebootWarningClientNum --;
				DEBUGMSG("RemoveHandle in Reboot warning mode");				
			}
		}
		if (0 == m_dwRebootWarningClientNum)
		{//all clients are gone
			Reset();
		}
	}
	else
	{
		DEBUGMSG("RemoveHandle in regular mode");
		if (hProcess == m_hClientProcess)
		{ //all clients are gone
			Reset();
		}
	}
}
	
void InitHandle(void)
{
	DEBUGMSG("WUAUENG client handles initialized");
	m_hClientProcess = NULL;
	m_dwProcId = -1;
	m_dwRebootWarningClientNum = 0;
	m_pRebootWarningClients = NULL;
	m_fRebootWarningMode = FALSE;
	m_fAsLocalSystem = FALSE;
	m_hClientExitEvt = NULL;
}


DWORD GetProcId(void)
{
	if (m_fRebootWarningMode)
	{
		DEBUGMSG("WARNING: GetProcId() called in wrong mode");
		return -1;
	}
 	return m_dwProcId;
}

CONST HANDLE hClientProcess(void)
{
	if (m_fRebootWarningMode)
	{
		DEBUGMSG("WARNING: hClientProcess() called in wrong mode");
		return NULL;
	}
	return m_hClientProcess;
}

void WaitForClientExits()
{
	if (!m_fRebootWarningMode)
	{
		if (NULL != m_hClientProcess)
		{
			WaitForSingleObject(m_hClientProcess, INFINITE);
		}
	}
	else
	{ 
		if (m_dwRebootWarningClientNum > 0)
		{
			HANDLE *pHandles = (HANDLE *) malloc(m_dwRebootWarningClientNum * sizeof(HANDLE));
			if (NULL != pHandles)
			{
				for (DWORD i = 0; i < m_dwRebootWarningClientNum; i++)
				{
					pHandles[i] = m_pRebootWarningClients[i].hProcess;
				}
				WaitForMultipleObjects(m_dwRebootWarningClientNum, pHandles, TRUE, INFINITE);
				free(pHandles);
			}
		}
	}
	Reset();
	return;
}

//////////////////////////////////////////////////////////////////
// szName should have size of at least MAX_PATH characters
//////////////////////////////////////////////////////////////////
BOOL CreateClientExitEvt(LPTSTR OUT szName, DWORD dwCchSize)
{	
	const TCHAR szClientName[]  = _T("Global\\Microsoft.WindowsUpdate.AU.ClientExitEvt.");
	static TCHAR szClientExitEvtName[100];
	TCHAR szBuf[50];
	GUID guid;
	HRESULT hr;

	if (NULL != m_hClientExitEvt)
	{
		return SUCCEEDED(StringCchCopyEx(szName, dwCchSize, szClientExitEvtName, NULL, NULL, MISTSAFE_STRING_FLAGS));
	}
	if (FAILED(hr = CoCreateGuid(&guid)))
	{
		DEBUGMSG("Fail to Create guid with error %#lx", hr);
		return FALSE;
	}
	StringFromGUID2(guid, szBuf, ARRAYSIZE(szBuf)); // szBuf should be big enough, function always succeed

    if (FAILED(hr = StringCchCopyEx(szName, dwCchSize, szClientName, NULL, NULL, MISTSAFE_STRING_FLAGS)) ||
		FAILED(hr = StringCchCatEx(szName, dwCchSize, szBuf, NULL, NULL, MISTSAFE_STRING_FLAGS))) //szName is now 86 characters long
	{
		DEBUGMSG("Fail to construct client exit event name with error %#lx", hr);
		return FALSE;
	}

	if (NULL == (m_hClientExitEvt = CreateEvent(NULL, TRUE, FALSE, szName)))
	{
		DEBUGMSG("Fail to create client exit event with error %d", GetLastError());
		return FALSE;
	}
	if (!AllowEveryOne(m_hClientExitEvt))
	{
		DEBUGMSG("Fail to grant access on client exit event to everyone");
		SafeCloseHandleNULL(m_hClientExitEvt);
		return FALSE;
	}
	DEBUGMSG("access granted to everyone on client exit event");
	if (FAILED(StringCchCopyEx(szClientExitEvtName, dwCchSize, szName, NULL, NULL, MISTSAFE_STRING_FLAGS)))
	{
		DEBUGMSG("Fail to update internal client exit event name cache");
		SafeCloseHandleNULL(m_hClientExitEvt);
		return FALSE;
	}
	return TRUE;
}


private:
	void NotifyClient(CLIENT_NOTIFY_CODE notClientCode)
	{
		 //notify client even before or after it is created 
#ifdef DBG
				LPCSTR aClientCodeMsg[] = {"stop client", "add trayicon", "remove trayicon", "state change", "show install warning", "reset client", "relaunch client"};
				DEBUGMSG("Notify Client for %s", aClientCodeMsg[notClientCode-1]);
#endif
				gClientNotifyData.actionCode = notClientCode;
				SetEvent(ghNotifyClient);
				return;
	}

	////////////////////////////////////////////////////////////////////
	// grant SYNCHRONIZE access on hObject to everyone
	////////////////////////////////////////////////////////////////////
	BOOL AllowEveryOne (HANDLE hObject)             // handle to the event
	{
	LPTSTR pszTrustee;          // trustee for new ACE
	TRUSTEE_FORM TrusteeForm;   // format of trustee structure
	DWORD dwRes;
	PACL pOldDACL = NULL, pNewDACL = NULL;
	PSECURITY_DESCRIPTOR pSD = NULL;
	EXPLICIT_ACCESS ea;
	PSID pWorldSid = NULL;
	BOOL fRet;

	 // World SID
	SID_IDENTIFIER_AUTHORITY WorldAuth = SECURITY_WORLD_SID_AUTHORITY;
	if (! (fRet =AllocateAndInitializeSid(&WorldAuth,1, SECURITY_WORLD_RID, 0,0,0,0,0,0,0,&pWorldSid)))
	{
		DEBUGMSG("WUAUENG: AllowEveryOne() failed with error %d", GetLastError());
		goto Cleanup;
	}

	// Get a pointer to the existing DACL.
	dwRes = GetSecurityInfo(hObject, SE_KERNEL_OBJECT, 
	      DACL_SECURITY_INFORMATION,
	      NULL, NULL, &pOldDACL, NULL, &pSD);
	if (!(fRet = (ERROR_SUCCESS == dwRes))) {
	    DEBUGMSG( "GetSecurityInfo Error %u", dwRes );
	    goto Cleanup; 
	}  

	// Initialize an EXPLICIT_ACCESS structure for the new ACE. 

	ZeroMemory(&ea, sizeof(EXPLICIT_ACCESS));
	ea.grfAccessPermissions = SYNCHRONIZE;
	ea.grfAccessMode = SET_ACCESS;
	ea.grfInheritance= NO_INHERITANCE;
	ea.Trustee.TrusteeForm = TRUSTEE_IS_SID;
	ea.Trustee.TrusteeType = TRUSTEE_IS_GROUP;
	ea.Trustee.ptstrName = (LPTSTR)pWorldSid;

	// Create a new ACL that merges the new ACE
	// into the existing DACL.

	dwRes = SetEntriesInAcl(1, &ea, pOldDACL, &pNewDACL);
	if (!(fRet = (ERROR_SUCCESS == dwRes)))  {
	    DEBUGMSG( "SetEntriesInAcl Error %u", dwRes );
	    goto Cleanup; 
	}  

	// Attach the new ACL as the object's DACL.
	dwRes = SetSecurityInfo(hObject, SE_KERNEL_OBJECT, 
	      DACL_SECURITY_INFORMATION,
	      NULL, NULL, pNewDACL, NULL);
	if (!(fRet = (ERROR_SUCCESS == dwRes)))  {
	    DEBUGMSG( "SetSecurityInfo Error %u", dwRes );
	    goto Cleanup; 
	}  

	Cleanup:
	    if(pSD != NULL) 
	        LocalFree((HLOCAL) pSD); 
	    if(pNewDACL != NULL) 
	        LocalFree((HLOCAL) pNewDACL); 
	    if (NULL != pWorldSid)
	    {
	    	FreeSid(pWorldSid);
	    }
	    return fRet;
	}

	void Reset( BOOL fDestructor = FALSE)
	{
		SafeCloseHandleNULL(m_hClientProcess);
		SafeCloseHandleNULL(m_hClientExitEvt);
		m_dwProcId = -1;
		if (!fDestructor)
		{
			ResetEvent(ghNotifyClient);
		}
		if (m_dwRebootWarningClientNum > 0)
		{
			DEBUGMSG("WUAUENG CLIENT_HANDLES::Reset() close %d handles", m_dwRebootWarningClientNum);
			for (DWORD  i = 0; i < m_dwRebootWarningClientNum; i++)
			{
				CloseHandle(m_pRebootWarningClients[i].hProcess);
			}
		}
		SafeFreeNULL(m_pRebootWarningClients); //still need to free even m_dwRebootWarningClientNum is 0
		m_dwRebootWarningClientNum = 0;
		m_fRebootWarningMode = FALSE;
		m_fAsLocalSystem = FALSE;
	}

private:
	HANDLE			m_hClientProcess;		//Handle to the client process
	DWORD 			m_dwProcId;
	AU_CLIENT_INFO	*m_pRebootWarningClients;
	DWORD			m_dwRebootWarningClientNum; //number of valid handles in m_pRebootWarningClients
	BOOL 			m_fRebootWarningMode;
	BOOL 			m_fAsLocalSystem;
	HANDLE 			m_hClientExitEvt;

};

extern CLIENT_HANDLES  ghClientHandles;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\wuaueng\wuaueng.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       wuaueng.cpp
//
//--------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

//Handle for Download Events
ENGINE_EVENTS EngineEvents;

AUCatalog *gpAUcatalog;

inline BOOL FServiceDisabled(void)
{
	return (AUSTATE_DISABLED == gpState->GetState());
}

//cancel download if any
void CancelDownload(void)
{
    if (NULL != gpAUcatalog && gpAUcatalog->m_audownloader.getID() != GUID_NULL)
    {
        gpAUcatalog->m_audownloader.DrizzleOperation(DRIZZLEOPS_CANCEL);															
    }
    gpState->SetDisconnected(FALSE);	//In case the disabled happened during TRANSIENT_ERROR we don't want to keep the flag set to disconnected		
}

DWORD RandomWaitTimeBeforeDetect()
{
    return (ULONGLONG)AU_TWENTY_TWO_HOURS - ((ULONGLONG) AU_TWENTY_TWO_HOURS * rand() * AU_RANDOMIZATION_WINDOW ) /( (ULONGLONG) RAND_MAX * 100); //precision to hundredth
}


//void setAuStateDisconnected(BOOL fDisconnected);
BOOL FDisabledDuringDownload(void)
{
	BOOL fRet = FALSE;

	if (FServiceDisabled())
	{
		DEBUGMSG("WUAUENG Detected Disabled State during download");
		CancelDownload();
		fRet = TRUE;
	}
	return fRet;
}

#define ISERVICE_FINISHED	0
#define ISERVICE_DISABLED	1

#define WAIT_SERVICE_FINISHED 0
#define WAIT_SERVICE_DISABLED 1
#define WAIT_NOT_NEEDED		  2
#define WAIT_CONNECTION_FOUND 3
#define WAIT_DONE           4


//fixcode: don't always need to persist in registry
DWORD MWFMO(DWORD dwTimeout, DWORD dwMinTimeout = 1)
{
	HANDLE hEvents[2];	

	hEvents[ISERVICE_FINISHED] = ghServiceFinished;
	hEvents[ISERVICE_DISABLED] = ghServiceDisabled;
	
	if (FAILED(setLastWaitTimeout(dwTimeout)))
	{
		DEBUGMSG("WUAUENG setLastWaitTimeout failed with error %d", GetLastError());
	}

	return MsgWaitForMultipleObjectsEx(2, hEvents, dwTimeToWait(dwTimeout, dwMinTimeout), QS_POSTMESSAGE, MWMO_INPUTAVAILABLE );
}


DWORD _MyMWFMO(DWORD dwTimeout, DWORD dwMinTimeout = 1);
//dwTimeout in seconds
#define MyMWFMO(dwTimeout) _MyMWFMO(dwTimeout)

// wait until a timeout happens or we get a service finished event
DWORD _MyMWFMO(DWORD dwTimeout, DWORD dwMinTimeout)
{	
	DWORD dwRet = WAIT_TIMEOUT;

	while (1)
	{
		dwRet = MWFMO(dwTimeout, dwMinTimeout);
		if (WAIT_TIMEOUT == dwRet)
		{
			DEBUGMSG("WUAUENG MWFMO timed out");			
//			dwRet = WAIT_TIMEOUT;
			goto Done;
		}
		else if (WAIT_OBJECT_0 + ISERVICE_FINISHED == dwRet)
		{
			DEBUGMSG("WUAUENG MWFMO Service Finished");
			dwRet = WAIT_SERVICE_FINISHED;			
			goto Done;
		}
		else if (WAIT_OBJECT_0 + ISERVICE_DISABLED == dwRet)
		{
			DEBUGMSG("WUAUENG MWFMO Engine Changed to Disabled\n");			
			dwRet = WAIT_SERVICE_DISABLED;
			goto Done;
		}		
		else 
		{
			//we expect possible meaningful message here
			//leave it untouch in the queue
		
			MSG msg;
			if (0 == PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
			{
				DEBUGMSG("MyMWFMO got no message. Possible error!");
				continue;	//no message got
			}
			if ( ((AUMSG_ENG_START <= msg.message) && (AUMSG_ENG_END >= msg.message))
				 || (WM_QUIT == msg.message))
			{
				DEBUGMSG("MyMWFMO got user msg %#lx, repost it to the queue", msg.message);
				PostThreadMessage(gdwWorkerThreadId, msg.message, msg.wParam, msg.lParam);
				dwRet = msg.message;
				goto Done;
			}
			else
			{
                DEBUGMSG("WUAUENG MWFMO got system message %#lx", msg.message);
                TranslateMessage( &msg );
                DispatchMessage( &msg );
			}
			
		}
	}
Done:
	if (WAIT_SERVICE_FINISHED != dwRet)
	{	
		removeLastWaitKey();
	}
	return dwRet;
}


	
//** WaitForConnection() will wait for connection or
//** will bail out if Service Finished or service disabled or getting a msg if fIgnoreNonDetectMsg is FALSE
DWORD  WaitForConnection(BOOL fIngoreNonDetectMsg = FALSE)
{
	static BOOL s_fWasConnected = FALSE;
        DWORD dwRet;

	DEBUGMSG("WUAUENG : Polling for connection");
	do
	{
		do
		{
			if (AUSTATE_DETECT_PENDING == gpState->GetState() &&
				gpState->IsUnableToConnect())
			{
				CAUEventLog aueventlog(g_hInstance);
				aueventlog.LogEvent(
								EVENTLOG_WARNING_TYPE,
								IDS_MSG_Download,
								IDS_MSG_UnableToConnect);
				gpState->SetDetectionStartTime(TRUE);
			}
			if (IsConnected(gpState->GetIdentServerURL(), !gpState->fInCorpWU()))
			{
				break;
			}
                     dwRet = MyMWFMO(AU_TEN_MINS);
                     if (WAIT_TIMEOUT != dwRet)
                     {
                        if (!fIngoreNonDetectMsg ||!IsValidAUMsg(dwRet) || AUMSG_DETECT == dwRet )
                        {
                            goto Done;
                        }
                     }
			s_fWasConnected = FALSE;
		}
		while (1);

		if (!s_fWasConnected)
		{
			DEBUGMSG("Found Connection");

			if (AUSTATE_DOWNLOAD_PENDING != gpState->GetState())
			{
				BOOL fWait = TRUE;
#ifdef DBG		
				//wait 5 mins by Default if 'ConnectWait' regvalue does not exist
				// or is set to 1
				DWORD dwConnectWait;
				if (SUCCEEDED(GetRegDWordValue(REG_AUCONNECTWAIT, &dwConnectWait)) 
					&& 0 == dwConnectWait)
				{
					fWait = FALSE;
				}
#endif					
				if (fWait)
				{
					DEBUGMSG("Wait for 5 mins "); 
	                dwRet = MyMWFMO(AU_FIVE_MINS);
	                if (WAIT_TIMEOUT != dwRet)
	                {
	                     if (!fIngoreNonDetectMsg || !IsValidAUMsg(dwRet) || AUMSG_DETECT == dwRet)
	                    {
	                        goto Done;
	                    }
	                }
				}
				if (!IsConnected(gpState->GetIdentServerURL(), !gpState->fInCorpWU()))
				{
					continue;
				}
			}
			s_fWasConnected = TRUE;
		}
		break;
	}
	while (1);
	DEBUGMSG("WUAUENG : Connection found. Polling end");
	dwRet = WAIT_CONNECTION_FOUND;
Done:
	return dwRet;
}


HRESULT PauseDownload(BOOL fPause)
{
       HRESULT hrRet = E_FAIL;
      
	if (NULL != gpAUcatalog)
	{
           hrRet = gpAUcatalog->m_audownloader.DrizzleOperation(fPause? DRIZZLEOPS_PAUSE: DRIZZLEOPS_RESUME);
	}
	DEBUGMSG("PauseDownload return %#lx", hrRet);
       return hrRet;
}

HRESULT GetEvtHandles(AUEVTHANDLES *pAuEvtHandles)
{
	HRESULT hr = E_FAIL;
	HANDLE hSourceProcess = NULL;	

//#define IEVT_ENGINESTATE		0
#define IEVT_NOTIFYCLIENT		0

	struct
	{
		HANDLE hSource;
		HANDLE hTarget;
	} rhandles [] = {/*{ghEngineState,0},*/{ghNotifyClient,0}};

   
	if (NULL == ghClientHandles.hClientProcess())
	{
		goto Done;
	}


	hSourceProcess = GetCurrentProcess();
	
	for ( int i = 0; i < (ARRAYSIZE(rhandles)); i++)
	{
		if (!DuplicateHandle(
			hSourceProcess,  // handle to source process
			rhandles[i].hSource,         // handle to duplicate
			ghClientHandles.hClientProcess(),  // handle to target process
			&rhandles[i].hTarget,      // duplicate handle
			0,        // requested access
			FALSE,          // handle inheritance option
			DUPLICATE_SAME_ACCESS      // optional actions
			))
		{
			DEBUGMSG("WUAUENG DuplicateHandle for rhandles[%d] failed with %#lx", i, GetLastError());
			//should not close target handle cuz it is in target process
			goto Done;
		}
	}
#ifdef _WIN64
	pAuEvtHandles->ulNotifyClient     = (LONG64) rhandles[IEVT_NOTIFYCLIENT].hTarget;
#else	
	pAuEvtHandles->ulNotifyClient     = (LONG) rhandles[IEVT_NOTIFYCLIENT].hTarget;
#endif

	hr = S_OK;
Done:
	return hr;
} 

DWORD AvailableSessions(void)
{
	DWORD dwRet = 0;
    //
    // For win2K, because we're not deleting sessions as soon as we receive
    // logoff notifications, the array gAdminSesssion might be out-of-date
    // in a given point in time. We need to validate the array before
    // saying to client things about it.
    // Remove any old sessions from our array if there's any
    //
    if (IsWin2K())
    {
        DEBUGMSG("WUAUENG Client is querying the number of sessions available; forcing rebuilt of the session cache (win2k)");
        gAdminSessions.ValidateCachedSessions();
    }

	for (int iSession = 0; iSession < gAdminSessions.CSessions(); iSession++)
	{
        DWORD dwAdminSession;
        if (gAdminSessions.m_FGetNextSession(&dwAdminSession) && FSessionActive(dwAdminSession))			
        {			
            dwRet ++;
        }
	}			

//	DEBUGMSG("AvailableSessions return %d", dwRet);

	return dwRet;
}

HRESULT HrCreateNewCatalog()
{	
	HRESULT hr = E_FAIL;

	SafeDeleteNULL(gpAUcatalog);
	gpAUcatalog = new AUCatalog;

	if (NULL == gpAUcatalog)
	{
		goto Done;
	}
	if (FAILED(hr = gpAUcatalog->Init()))
	{		
		SafeDeleteNULL(gpAUcatalog);
	}
Done:
	return hr;
}
/* This function will return only in case of selfupdate. Normally it will keep on looping
 * sleeping on various timeouts when necessary
 */
DWORD CompleteLastMyMWFMO(void)
{	
	DWORD dwRet = WAIT_NOT_NEEDED;
	DWORD dwTimeout; 
	HRESULT hr;

	hr = getLastWaitTimeout(&dwTimeout);
	MyMWFMO(0); //call user api to create the thread queue
	SetEvent(ghWorkerThreadMsgQueueCreation);
    if (FAILED(hr))
	{
	    DEBUGMSG("WUAUENG no need to complete last wait");
		goto Done;
	}
	DEBUGMSG("WUAUENG is going to complete last wait %d ", dwTimeout);
	dwRet = MyMWFMO(dwTimeout);
Done:
	return dwRet;
}

//////////////////////////////////////////////////////////////////////////////////////////////////
// return S_FALSE if selfupdate happens
// return S_OK otherwise
// pdwRet points to return code: service finish, service disabled, selfupdate done, or detect msg
HRESULT PerformSelfUpdate(DWORD *pdwRet)
{
       HRESULT hr= S_OK;
       DEBUGMSG("Doing selfupdate");
	DEBUGMSG("Selfupdate waiting for connection");
	DEBUGMSG("Wait for internet connection...");
	
        while ( WAIT_CONNECTION_FOUND == (*pdwRet = WaitForConnection(TRUE))
	        && ((hr = SelfUpdate()) != S_OK) )
	{
		switch (hr)
		{
			case S_FALSE:  //selfupdate happens
				DEBUGMSG("Telling wuauserv.dll to reload wuaueng.dll");
				gPingStatus.PingSelfUpdate(TRUE, URLLOGSTATUS_Pending, 0);
				*pdwRet = WAIT_DONE;
				goto Done;
			default:
				DEBUGMSG("Error during selfupdate (%#lx), timeout=%d secs", hr, dwTimeToWait(AU_ONE_DAY));
				gPingStatus.PingSelfUpdate(TRUE, URLLOGSTATUS_Failed, hr);
                            *pdwRet = MyMWFMO(AU_ONE_DAY);
                            if (WAIT_TIMEOUT != *pdwRet)
				{
					DEBUGMSG("WUAUENG need to abort wait during SelfUpdate");
					goto Done;                                    
				}
				break;
		}
	}

	if (WAIT_CONNECTION_FOUND == *pdwRet)
       {
         	*pdwRet = WAIT_DONE;
	}
       DEBUGMSG("Finished self update cycle");
    
Done:         
	return hr;
}


void ResumeDownloadIfNeccesary(void)
{	
	if (FDownloadIsPaused())
	{	
		PauseDownload(FALSE);
		DEBUGMSG("WUAUENG Resuming download job");				
	}
}

void PingSuccessfulDownloads(void)
{
	UINT uItemCount = gpAUcatalog->m_ItemList.Count();

	for (UINT i = 0; i < uItemCount; i++)
	{
		AUCatalogItem &item = gpAUcatalog->m_ItemList[i];

		if (item.fSelected())
		{
			BSTR bstrItemId = item.bstrID();

			if (NULL != bstrItemId)
			{
				USES_IU_CONVERSION;

				gPingStatus.PingDownload(
					TRUE,
					URLLOGSTATUS_Success,
					0,
					W2T(bstrItemId));
			}
#ifdef DBG
			else
			{
				DEBUGMSG("WUAUENG title for item %d is NULL!", i);
			}
#endif
		}
	}
}

void ResetState(void)
{
	gpState->SetState(AUSTATE_DETECT_PENDING);
	PostThreadMessage(gdwWorkerThreadId, AUMSG_DETECT, 0, 0);			
}

void ResetState(BOOL *pfWaitB4Detect, DWORD *pdwWaitB4Detect, BOOL fError)
{
	AUASSERT(NULL != pfWaitB4Detect);
	AUASSERT(NULL != pdwWaitB4Detect);
	 *pfWaitB4Detect = TRUE;
	 *pdwWaitB4Detect = fError ? AU_FIVE_HOURS : RandomWaitTimeBeforeDetect();
       ResetState();
}


HRESULT UpdateProc(WORKER_THREAD_INIT_DATA & initData)
{
	HRESULT hr = S_OK;
	DWORD	dwRet;	
	DWORD dwLastWait ;
    BOOL    fReloadAfterSelfUpdate = FALSE;
	MSG     msg;
	UINT uFirstMsg;
       static BOOL    s_fWaitBeforeDetect;
       static DWORD s_dwWaitB4Detect;

        uFirstMsg = initData.uFirstMsg;
        s_fWaitBeforeDetect = initData.fWaitB4Detect;
        s_dwWaitB4Detect = initData.dwWaitB4Detect;

       dwLastWait = CompleteLastMyMWFMO();
	
	switch (dwLastWait)
	    {
	        case WAIT_SERVICE_FINISHED:
                        goto Done;
                case WAIT_TIMEOUT:
                case WAIT_NOT_NEEDED:    
				if (IsValidAUMsg(uFirstMsg))
				{
				DEBUGMSG("Update post first msg %#x", uFirstMsg);
				PostThreadMessage(gdwWorkerThreadId,  uFirstMsg, 0, 0);
				}
				break;
                case WAIT_SERVICE_DISABLED:				
                default:        //msg got
                        break;
	}
                        
	
	DWORD dwRet2 ;
	while(WAIT_OBJECT_0 + 1 == (dwRet2 = MsgWaitForMultipleObjectsEx(1, &ghServiceFinished, INFINITE, QS_POSTMESSAGE, MWMO_INPUTAVAILABLE )))
	{
		if (0 == PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
		{ 
			DEBUGMSG("WUAUENG no message to retrieve. Possible error!");
			continue; 
		}
		if (WM_QUIT == msg.message)
		{
			break; 
		}

		switch(msg.message)
		{
		    case AUMSG_INIT:
                            {
                                  //we wait for the first connection so that we don't prompt users who never 
                                  //make a connection to the internet. no need to have them config AU if they have no
                                  //intention of using the internet
                            	dwRet = WaitForConnection();
                                   switch (dwRet)
                                    {
                                        case WAIT_SERVICE_FINISHED:
                                        		DEBUGMSG("WUAUENG detected that Service finished during WaitForConnection in AUSTATE_OUTOFBOX");
                                        		goto Done;
                                        case WAIT_CONNECTION_FOUND:         
                                                break;
                                        case WAIT_SERVICE_DISABLED:
                                        default:
                                                 continue;
                                   }

                                    dwRet = dwLastWait;
                                    if (WAIT_NOT_NEEDED == dwLastWait)
                                    {
                                            //there was no previous wait for 24 hours
                                    	DEBUGMSG("WUAUENG Out of box, waiting 24 hours (%d secs)", dwSecsToWait(AU_ONE_DAY));
                                    	dwRet = MyMWFMO(AU_ONE_DAY);
                                    }
                            	switch (dwRet)
                            	{
                            	    case WAIT_TIMEOUT:
                                                {
#if 0 //commented out for bug 493789                                                    
                                                    DWORD dwRet4;
                                                    hr = PerformSelfUpdate(&dwRet4);
                                                    if (WAIT_SERVICE_FINISHED == dwRet4)
                                                    {
                                                        setLastWaitTimeout(0);  //no wait next time
                                                        goto Done;
                                                    }
#endif                                                    
                                                    gpState->SetState(AUSTATE_NOT_CONFIGURED);
                                                    DEBUGMSG("WUAUENG waiting for user to configure AU");
#if 0 //commented out for bug 493789                                                     
                                                    if (S_FALSE == hr)
                                                    {
                                                        fReloadAfterSelfUpdate = TRUE;
                                                        goto Done;
                                                    }
#endif                                                    
                                                    break;
                                                }
                            	    case WAIT_SERVICE_FINISHED:
                            		goto Done;
                            	    case WAIT_SERVICE_DISABLED:
                            	    default:                            	        
                            	            continue;
                            	}
                            	break;
                            }
			case AUMSG_EULA_ACCEPTED:
				DEBUGMSG("WUAUENG Msg:Eula accepted, state -> Detect Pending");
				ResetState();
				break;

			case AUMSG_DETECT:
			       if (s_fWaitBeforeDetect)
			       {
			            s_fWaitBeforeDetect = FALSE;
			            DEBUGMSG("WUAUENG Wait %d secs before detection", s_dwWaitB4Detect);
			            DWORD dwRet3 = MyMWFMO(s_dwWaitB4Detect);					
			            s_dwWaitB4Detect = 0;
					if (WAIT_SERVICE_DISABLED == dwRet3)
					{
						break;
					}					
					if (WAIT_SERVICE_FINISHED == dwRet3)
					{
						goto Done;
					}
			       }

					DEBUGMSG("WUAUENG Msg:Detect");						
	                DEBUGMSG("--------------------------------------------------------");
	                DEBUGMSG("Set new detection start time");
					gpState->SetDetectionStartTime(FALSE);
					DEBUGMSG("Read in au option");
	                if (FAILED(hr = gpState->HrInit()))
	                {
	                DEBUGMSG("AU state object fail to init with error %#lx", hr);
	                goto Done;
	                }
	                CancelDownload();                            
					if (FAILED(HrCreateNewCatalog()))
					{ //fixcode: what is the expected behavior here?
						return E_FAIL;
					}
                                    
   			       hr = PerformSelfUpdate(&dwRet);
    			       if (S_FALSE == hr)
    			        {
    			            fReloadAfterSelfUpdate = TRUE;
    			            goto Done;
    			         }
    			       switch (dwRet)
    			       {
    			           case WAIT_SERVICE_FINISHED:
            			            goto Done;
                                case WAIT_SERVICE_DISABLED:
                                        gpState->RemoveDetectionStartTime();
            			            continue;  
            			    case WAIT_DONE:
            			            break;
            			    default: //detect msg got
            			            DEBUGMSG("Detect msg got while detecting");
            			            continue;
    			       }          
				
				hr = gpAUcatalog->DetectItems();

				if (FServiceDisabled())
				{
					gpState->RemoveDetectionStartTime();
					break;
				}

				if (SUCCEEDED(hr))
				{
					//Restart counting period w/ no connection at the beginning of the next cycle.
					gpState->RemoveDetectionStartTime();
				}

				if (S_OK == hr)
				{	
					DEBUGMSG("WUAUENG Catalog built");
					gpState->SetState(AUSTATE_DETECT_COMPLETE);
					DEBUGMSG("WUAUENG State->Detect complete");
				}
				else if (S_FALSE == hr)
				{
                        DEBUGMSG("WUAUENG No items in catalog, sleeping a while before next detection");
			        ResetState(&s_fWaitBeforeDetect,&s_dwWaitB4Detect, FALSE); //wait normal interval time
			        }
				else
				{
					DEBUGMSG("WUAUENG Couldn't build catalog");
					ResetState(&s_fWaitBeforeDetect, &s_dwWaitB4Detect, TRUE); //wait shorter time cuz of error
				}
				break;
			
			case AUMSG_DOWNLOAD:
				{		
				DEBUGMSG("WUAUENG Msg:Download");
				gfDownloadStarted = FALSE;
				gpState->SetState(AUSTATE_DOWNLOAD_PENDING);
				dwRet =WaitForConnection(TRUE);
				switch (dwRet)
				{
				    case WAIT_SERVICE_FINISHED:
					DEBUGMSG("WUAUENG detected that Service finished during WaitForConnection in AUMSG_DOWNLOAD");				
					goto Done;
                                case WAIT_CONNECTION_FOUND:
                                    break;
                                case WAIT_SERVICE_DISABLED:
                                default:
                                    continue;
				}
                                    
				if (S_OK != gpAUcatalog->ValidateItems(TRUE))
				{
					DEBUGMSG("WUAUENG Catalog validation failed or no items, State->Detect Pending");
					ResetState();
					break;	
				}
					
				DEBUGMSG("WUAUENG catalog:validateCatalog finished");						
				
				EngineEvents.CreateEvents();

                        // queue up items for download
		        if (S_OK != (hr = gpAUcatalog->DownloadItems()))
				{
                                  if (S_FALSE == hr)
		                    {
		                        DEBUGMSG("WUAUENG Catalog download items skipped because no items were selected");
		                    }
		                    else
		                    {
			                    DEBUGMSG("WUAUENG Catalog download items failed");
		                    }
					EngineEvents.CloseEvents();
                                  ResetState(&s_fWaitBeforeDetect,&s_dwWaitB4Detect, FALSE);					
					break;
				}
				gfDownloadStarted = TRUE;
				ghClientHandles.ClientStateChange(); //notify client again for status change

				do
				{
					dwRet = MsgWaitForMultipleObjectsEx( EngineEvents.cEvents(), EngineEvents.grEventHandles(), INFINITE, QS_POSTMESSAGE, MWMO_INPUTAVAILABLE );
					if (WAIT_OBJECT_0 + IDOWNLOAD_COMPLETE_EVT == dwRet)		//Download finished
					{				
						if (FDisabledDuringDownload())
						{
							goto CloseHandle;
						}
						DEBUGMSG("WUAUENG file download done");

						ghClientHandles.ClientRemoveTrayIcon();

			                        //Validate downloaded cabs before continuing
			                        AUASSERT(gpAUcatalog);
			                        BSTR bstrErrorItemId = NULL;       //should not be freed
			                        if(FAILED(hr = gpAUcatalog->ValidateDownloadedCabs(&bstrErrorItemId)))
			                        {
			                            USES_IU_CONVERSION;
			                            DEBUGMSG("ValidateDownloadedCabs: Checksum failed, error: %#lx", hr);                            
			                            //bstrErrorItemId will be NULL if it was some error other than ERROR_CRC
			                            if(NULL != bstrErrorItemId)
			                            {
			                                //Pingback failure with itemId
			                                gPingStatus.PingDownload(
									                            TRUE,
									                            URLLOGSTATUS_Failed,
									                            hr,
									                            W2T(bstrErrorItemId));
			                            }
			                            //Reset to detect pending
			                           ResetState(&s_fWaitBeforeDetect,&s_dwWaitB4Detect, TRUE); //wait shorter time cuz of error
			                            goto CloseHandle;
			                        }

						if (!gpState->fOptionSchedInstall())
						{
							DEBUGMSG("WUAUENG download complete, ready for UNSCHEDULED install");
							LogEvent_ItemList(
								EVENTLOG_INFORMATION_TYPE,
								IDS_MSG_Installation,
								IDS_MSG_InstallReady_Unscheduled);
						}
						PingSuccessfulDownloads();
						DEBUGMSG("WUAUENG validating items to prune out items already installed");
						if (  gpAUcatalog->ValidateItems(FALSE) != S_OK)
						{
		                			DEBUGMSG("WUAUENG Validation failed OR no items left in catalog, State->Detect Pending");
		                			ResetState();
						}
						else
						{
							DEBUGMSG(" Items still applicable, State->Download Complete");
							gpState->SetState(AUSTATE_DOWNLOAD_COMPLETE);
						}
						break;
					}
					else if (((WAIT_OBJECT_0 + IDOWNLOAD_TRANSIENT_ERROR_EVT) == dwRet)	||	//Transient error - connection lost
							 ((WAIT_OBJECT_0 + IDOWNLOAD_DOWNLOAD_IN_PROGRESS) == dwRet))	//Download in progress - connection recuperated
					{
						BOOL fCheckDisconnect;					

						fCheckDisconnect = ((WAIT_OBJECT_0 + IDOWNLOAD_DOWNLOAD_IN_PROGRESS) == dwRet);
						
						//AuStateAux = GetState();
						// setState again (and trigger Engine Change State) only if:
						// - It is not disconnected and you got Transient Error Event
						// - It is disconnected and you got a Download in Progress Event
						if ( fCheckDisconnect == gpState->fDisconnected() )
						{
							gpState->SetDisconnected(!fCheckDisconnect);
							gpState->SetState(AUSTATE_DOWNLOAD_PENDING); //relaunch client if it is not launched and notify client of new state
						}															
					}					
					else if ((WAIT_OBJECT_0 + IDOWNLOAD_SERVICE_FINISH) == dwRet)	//Service Finished
					{
						DEBUGMSG("WUAUENG Detected Service Finished while wating for download to be done");
						goto Done;
					}			
					else if ((WAIT_OBJECT_0 + IDOWNLOAD_SERVICE_DISABLED) == dwRet)		//Engine State, should be due to disabled
					{
						if (FDisabledDuringDownload())
						{
							goto CloseHandle;
						}
					}
					else if ((WAIT_OBJECT_0 + IDOWNLOAD_DOWNLOAD_CANCELED) == dwRet)
					{ 
						if (JOB_ERROR ==  gpAUcatalog->m_audownloader.m_FinishReason)
						{
							DEBUGMSG("WUAUENG got error during download, wait for sometime b4 redetect");
							ResetState(&s_fWaitBeforeDetect,&s_dwWaitB4Detect, TRUE); //wait shorter time cuz of error
						}
						else
						{
							DEBUGMSG("WUAUENG download job got canceled, State -> Detect Pending");
							ResetState();
						}
						goto CloseHandle;
					}
					else if ((WAIT_OBJECT_0 + IDOWNLOAD_MESSAGE) == dwRet)			//Messages
					{	
						MSG msg2;
						PeekMessage(&msg2, NULL, NULL, NULL, PM_REMOVE); //we don't expect meaningful message here
						TranslateMessage(&msg2);// Translates virtual key codes
						DispatchMessage(&msg2); // Dispatches message to window
						if ( msg2.message != WM_USER ) //WM_USER is the one to pump to drizzle for processing
						{
							DEBUGMSG("WUAUENG dispatched message %#lx during downloading", msg2.message);
						}
					}
                    else if (((WAIT_ABANDONED_0 + IDOWNLOAD_COMPLETE_EVT) == dwRet) ||
							((WAIT_ABANDONED_0 + IDOWNLOAD_TRANSIENT_ERROR_EVT) == dwRet)||
							((WAIT_ABANDONED_0 + IDOWNLOAD_DOWNLOAD_IN_PROGRESS) == dwRet)||
							((WAIT_ABANDONED_0 + IDOWNLOAD_SERVICE_FINISH) == dwRet)||
							(WAIT_FAILED == dwRet))
					{ //fixcode: when will this actually happen?
						DEBUGMSG("WUAUENG Error in Download Loop with MsgWaitForMultipleObjectsEx");
			                        ResetState();
			                        goto CloseHandle;
					}
					else
					{
						DEBUGMSG("WUAUENG Unexpected returned value dwRet = %d in n Download Loop with MsgWaitForMultipleObjectsEx", dwRet);
					}
				}
                while ( 1 );

CloseHandle:				
				EngineEvents.CloseEvents();
				}
				break;

			case AUMSG_POST_INSTALL:
			    {
                    DEBUGMSG("WUAUENG install done, sleeping a while before next detection");
				//	fixcode: should use ResetState() instead
				 s_fWaitBeforeDetect = TRUE;
			        s_dwWaitB4Detect = RandomWaitTimeBeforeDetect();
				 PostThreadMessage(gdwWorkerThreadId, AUMSG_DETECT, 0, 0);
				break;
			}

			case AUMSG_VALIDATE_CATALOG:
				DEBUGMSG("WUAUENG: validating catalog offline");
				if ( gpAUcatalog->ValidateItems(FALSE) != S_OK)
				{
					DEBUGMSG("WUAUENG Validation failed OR no items left in catalog, State->Detect Pending");
					ResetState();
				}
				SetEvent(ghValidateCatalog);
				break;

			case AUMSG_LOG_EVENT:
				DEBUGMSG("WUAUENG: logging the Ready To Install (Scheduled) event");
				if (gpState->fShouldScheduledInstall())
				{
					LogEvent_ScheduledInstall();
				}
				break;


			default:
				DEBUGMSG("WUAUENG Received unknown msg %#lx", msg.message);
                            TranslateMessage( &msg );
                            DispatchMessage( &msg );
				break;
		}
	}

	if (WAIT_OBJECT_0 == dwRet2)
	{
		DEBUGMSG("Update() exit in response to service finish event");
	}
Done:
	DEBUGMSG("WUAUENG Update func returning");
    // we may ask wuauserv.dll to reload us.
	return fReloadAfterSelfUpdate ? S_FALSE : S_OK;	
}

void saveSelection(VARIANT *selection)
{
    // fixcode this return should return an error
	long n = 0;
	DEBUGMSG("Start saveSelection");
	WaitForSingleObject(ghMutex, INFINITE);
	if ( FAILED(SafeArrayGetUBound(selection->parray, 1, &n)))
	{
		DEBUGMSG("WUAUENG SafeArrayGetUBond failed");
		goto done;
	}

	if (((n + 1) / 2) != gpAUcatalog->m_ItemList.Count())
	{
		AUASSERT(FALSE);
		DEBUGMSG("WUAUENG got unmatched number of items from client");
		goto done;
	}
	
    for ( long i = 0; i < (n + 1) / 2; i++ )
	{
		long dex = i * 2;
		VARIANT var;

		VariantInit(&var);
        if ( FAILED(SafeArrayGetElement(selection->parray, &dex, &var)) )
        {
            DEBUGMSG("SafeArrayGetElement failed");
            continue;
        }

        BOOL fMatch = (WUCompareStringI(var.bstrVal, gpAUcatalog->m_ItemList[i].bstrID()) == CSTR_EQUAL);
        VariantClear(&var);

        if ( fMatch )
        {
	    if ( SUCCEEDED(SafeArrayGetElement(selection->parray, &++dex, &var)) )
            {
        		gpAUcatalog->m_ItemList[i].SetStatus(var.lVal);
//        		DEBUGMSG("Status for item %S is now %d", gpAUcatalog->m_ItemList[i].bstrID(), gpAUcatalog->m_ItemList[i].dwStatus());   		
            }
        }
        else
        {
            DEBUGMSG("item ids did not match for saving selections");
        }
	}
    
//    gpAUcatalog->m_ItemList.DbgDump();
	gpAUcatalog->Serialize();
done:
	ReleaseMutex(ghMutex);
    DEBUGMSG("End saveSelection");
}

HRESULT StartDownload(void)
{
	//DEBUGMSG("WUAUENG ::StartDownload called");
	
	if ( AUSTATE_DETECT_COMPLETE != gpState->GetState() )
	{
		DEBUGMSG("WUAUENG ::StartDownload state incorrect");
		return E_FAIL;
	}
	PostThreadMessage(gdwWorkerThreadId, AUMSG_DOWNLOAD, 0, 0);
	return S_OK;
}

HRESULT GetUpdatesList(VARIANT *vList)
{
	HRESULT hr = E_FAIL;
	DWORD dwWait;

	dwWait = WaitForSingleObject(ghMutex, INFINITE);

	if (WAIT_FAILED == dwWait)
	{
		DEBUGMSG("WUAUENG GetUpdateList got WAIT_ABANDONED");
	}
	else
		DEBUGMSG("WUAUENG Getting Updates list dWait=%d",dwWait);

	if ( (AUSTATE_DETECT_COMPLETE != gpState->GetState()) && (AUSTATE_DOWNLOAD_COMPLETE != gpState->GetState()) )
    {
		goto Done;
    }
	
	hr = gpAUcatalog->getUpdatesList(vList);
Done:
	ReleaseMutex(ghMutex);
	return hr;
}

HRESULT GetInstallXML(/*[out]*/ BSTR *pbstrCatalogXML, /*[out]*/ BSTR *pbstrDownloadXML)
{
//    DEBUGMSG("::GetInstallXML");
	HRESULT hr = E_FAIL;
	DWORD dwWait;

        dwWait = WaitForSingleObject(ghMutex, INFINITE);

	if (WAIT_FAILED == dwWait)
	{
		DEBUGMSG("WUAUENG GetInstallXML got WAIT_ABANDONED");
	}
	else
        {
    		DEBUGMSG("WUAUENG Getting Updates list dWait=%d",dwWait);
        }

	hr = gpAUcatalog->GetInstallXML(pbstrCatalogXML, pbstrDownloadXML);

//Done:
	ReleaseMutex(ghMutex);
	return hr;
}

HRESULT GetDownloadStatus(UINT *pPercentage, DWORD *pdwnldStatus, BOOL fCareAboutConnection)
{
	DWORD dwComplete;
	DWORD dwstatus;
	HRESULT hr;

    if ( AUSTATE_DOWNLOAD_PENDING != gpState->GetState() )
	{
		*pPercentage = (AUSTATE_DOWNLOAD_COMPLETE == gpState->GetState()) ? 100 : 0 ;
		*pdwnldStatus = DWNLDSTATUS_DOWNLOADING;					//for trayicon to show 100%
		//DEBUGMSG("WUAUENG %% complete = %d", *pPercentage);
		return S_OK;
	}
	*pPercentage = 0;
	if (fCareAboutConnection && !gfDownloadStarted) 
	{
		DEBUGMSG("WUAUENG Download status is checking for connection");
		*pdwnldStatus = DWNLDSTATUS_CHECKING_CONNECTION;
		return S_OK;
	}
	WaitForSingleObject(ghMutex, INFINITE);	
	hr = gpAUcatalog->m_audownloader.getStatus(&dwComplete, &dwstatus);
	ReleaseMutex(ghMutex);
	if (FAILED(hr))
	{
		*pdwnldStatus = DWNLDSTATUS_NOT_DOWNLOADING;
		return S_OK;
	}	
	*pPercentage = (int)dwComplete;
	//DEBUGMSG("WUAUENG %% complete = %d", *pPercentage);
	
	switch (dwstatus)
	{
	case BG_JOB_STATE_TRANSFERRING:
	case BG_JOB_STATE_TRANSFERRED:		//for trayicon to show 100%, as in the beginning of the routine
        {
			*pdwnldStatus = DWNLDSTATUS_DOWNLOADING;
			break;
        }				
	case BG_JOB_STATE_SUSPENDED:
		{
			*pdwnldStatus = DWNLDSTATUS_PAUSED;
			break;
		}
	case BG_JOB_STATE_ERROR:			
	case BG_JOB_STATE_TRANSIENT_ERROR:
	case BG_JOB_STATE_ACKNOWLEDGED:
	case BG_JOB_STATE_CANCELLED:    
       case BG_JOB_STATE_QUEUED:
       case BG_JOB_STATE_CONNECTING:
		{
			*pdwnldStatus = DWNLDSTATUS_NOT_DOWNLOADING;
			break;
		}
	default:
		{
			DEBUGMSG("WUAUENG GetDownloadStatus got an unexpected BG_JOB_STATE %d", dwstatus);
			*pdwnldStatus  = DWNLDSTATUS_NOT_DOWNLOADING;
		}
	}
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\wuaulib\audirectory.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       wudirectory.cpp
//  Desc:     This is the definition file that implements function(s)
//			related to find out where to get the Critical Fix cab file.
//
//--------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

TCHAR g_szWUDir[MAX_PATH+1] = _T("\0");        //Path to windows update directory
const TCHAR CABS_DIR[] = _T("cabs");
const TCHAR RTF_DIR[] = _T("RTF");
const TCHAR EULA_DIR[] = _T("EULA");
const TCHAR DETAILS_DIR[] = _T("Details");
const TCHAR C_DOWNLD_DIR[] = _T("wuaudnld.tmp");

BOOL AUDelFileOrDir(LPCTSTR szFileOrDir)
{
	if (NULL == szFileOrDir)
	{
		SetLastError(ERROR_INVALID_PARAMETER);
		return FALSE;
	}
	BOOL fIsDir = TRUE;
	if (fFileExists(szFileOrDir, &fIsDir))
	{
		if (fIsDir)
		{
			if (DelDir(szFileOrDir))
			{
				return RemoveDirectory(szFileOrDir);
			}
			return FALSE;
		}
		else
		{
			return DeleteFile(szFileOrDir);
		}
	}
	SetLastError(ERROR_FILE_NOT_FOUND);
	return FALSE;
}

////////////////////////////////////////////////////////////////////////
// Create the WU directory if it doesnt already exist
// return FALSE if failed 
/////////////////////////////////////////////////////////////////////////
BOOL CreateWUDirectory(BOOL fGetPathOnly)
{
    BOOL fRet = FALSE;
    static BOOL fWUDirectoryExists = FALSE;

    // WindowsUpdate Directory already exists
    if (fWUDirectoryExists)  
    {
        fRet = TRUE;
        goto done;
    }

    //Get the path to the windows update directory
    if( !GetWUDirectory(g_szWUDir, ARRAYSIZE(g_szWUDir)))
    {
        goto done;
    }

    //If we need to set the acls to the directory
    if(!fGetPathOnly)
    {
        //Set ACLS, create directory if it doesnt already exist
        if( FAILED(CreateDirectoryAndSetACLs(g_szWUDir, TRUE)))
        {
            goto done;
        }
        //We shouldnt care if we couldnt set attributes
        SetFileAttributes(g_szWUDir, FILE_ATTRIBUTE_HIDDEN | GetFileAttributes(g_szWUDir));
    }
    //Append the backslash
    if(FAILED(StringCchCatEx(g_szWUDir, ARRAYSIZE(g_szWUDir), _T("\\"), NULL, NULL, MISTSAFE_STRING_FLAGS)))
    {
    	goto done;
    }   

    fRet = TRUE;
    
done:
    if(!fRet)
    {
        g_szWUDir[0] = _T('\0');
    }
    else
    {
        fWUDirectoryExists = TRUE;
    }
    return fRet;
}


//this function delete all the files and subdirectories under lpszDir
int DelDir(LPCTSTR lpszDir)
{
	TCHAR szFilePattern[MAX_PATH], szFileName[MAX_PATH];
	HANDLE	hFind;
	WIN32_FIND_DATA	FindFileData;
	
	if ( NULL == lpszDir ||
		 FAILED(StringCchCopyEx(szFilePattern, ARRAYSIZE(szFilePattern), lpszDir, NULL, NULL, MISTSAFE_STRING_FLAGS)) ||
		 FAILED(StringCchCatEx(szFilePattern, ARRAYSIZE(szFilePattern), _T("\\*.*"), NULL, NULL, MISTSAFE_STRING_FLAGS)) ||
		 INVALID_HANDLE_VALUE == (hFind = FindFirstFile(szFilePattern, &FindFileData)))
	{
		return 0;
	}
	FindNextFile(hFind, &FindFileData);				//skip "." and ".."
	while(FindNextFile(hFind, &FindFileData))
	{
		if ( FAILED(StringCchCopyEx(szFileName, ARRAYSIZE(szFileName), lpszDir, NULL, NULL, MISTSAFE_STRING_FLAGS)) ||
			 FAILED(StringCchCatEx(szFileName, ARRAYSIZE(szFileName), _T("\\"), NULL, NULL, MISTSAFE_STRING_FLAGS)) ||
			 FAILED(StringCchCatEx(szFileName, ARRAYSIZE(szFileName), FindFileData.cFileName, NULL, NULL, MISTSAFE_STRING_FLAGS)) )
		{
			FindClose(hFind);
			return 0;
		}

		if (FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
		{
			DelDir(szFileName);
			RemoveDirectory(szFileName);
		}
		else
		{
			DeleteFile(szFileName);			
		}
	}
	FindClose(hFind);
	return 1;
}

////////////////////////////////////////////////////////////////////////
// Delete file using regular expression (e.g. *, ? etc)
// tszDir : the directory where file resides. It ends with '\'
// tszFilePattern: file(s) expressed in regular expression or plain format
/////////////////////////////////////////////////////////////////////////
int RegExpDelFile(LPCTSTR tszDir, LPCTSTR tszFilePattern)
{
	WIN32_FIND_DATA fd;
	HANDLE hFindFile = INVALID_HANDLE_VALUE;
	BOOL fMoreFiles = FALSE;
	TCHAR tszFileName[MAX_PATH+1];
	INT nRet = 1;

	if (FAILED(StringCchCopyEx(tszFileName, ARRAYSIZE(tszFileName), tszDir, NULL, NULL, MISTSAFE_STRING_FLAGS)) ||
		FAILED(StringCchCatEx(tszFileName, ARRAYSIZE(tszFileName), tszFilePattern, NULL, NULL, MISTSAFE_STRING_FLAGS)))
	{
		nRet = 0;
		goto done;
	}
		
	hFindFile = FindFirstFile(tszFileName, &fd);
	if (INVALID_HANDLE_VALUE == hFindFile)
	{
//		DEBUGMSG("RegExpDelFile() no more files found");
		nRet = 0;
		goto done;
	}
	
	do
	{
		if (SUCCEEDED(StringCchCopyEx(tszFileName, ARRAYSIZE(tszFileName), tszDir, NULL, NULL, MISTSAFE_STRING_FLAGS)) &&
			SUCCEEDED(StringCchCatEx(tszFileName, ARRAYSIZE(tszFileName), _T("\\"), NULL, NULL, MISTSAFE_STRING_FLAGS)) &&
			SUCCEEDED(StringCchCatEx(tszFileName, ARRAYSIZE(tszFileName), fd.cFileName, NULL, NULL, MISTSAFE_STRING_FLAGS)))
		{
//		DEBUGMSG("RegExpDelFile() Deleting file %S", tszFileName);
			DeleteFile(tszFileName);
		}
		else
		{
//			DEBUGMSG("RegExpDelFile() failed to construct file name to delete");
			nRet = 0;
		}
	}
	while (fMoreFiles = FindNextFile(hFindFile, &fd));
	
done:
	if (INVALID_HANDLE_VALUE != hFindFile)
	{
		FindClose(hFindFile);
	}
	return nRet;
}

/////////////////////////////////////////////////////////////////////////////
//
// Function CreateDownloadDir()
//			Creates the download directory
//
// Input:   a string points to the directory to create
// Output:  None
// Return:  HRESULT to tell the result
// Remarks: If the directory already exists, takes no action
//
/////////////////////////////////////////////////////////////////////////////

HRESULT CreateDownloadDir(LPCTSTR lpszDir)
{
//	USES_CONVERSION;
    DWORD dwRet = 0/*, attr*/;
    HRESULT hRet = E_FAIL;

    if (lpszDir == NULL || lpszDir[0] == EOS)
    {
        return E_INVALIDARG;
    }

    if (CreateDirectory(lpszDir, NULL))
    {
		if (!SetFileAttributes(lpszDir, FILE_ATTRIBUTE_HIDDEN))
        {
			dwRet = GetLastError();
            DEBUGMSG("CreateDownloadDir() failed to set hidden attribute to %S (%#lx).", lpszDir, dwRet);
            hRet = S_FALSE; // it's okay to use this dir.
        }
		else
			hRet = S_OK;
    }
    else
    {
		dwRet = GetLastError();

		if (dwRet != ERROR_ALREADY_EXISTS)
		{
			DEBUGMSG("CreateDownloadDir() failed to create directory %S (%#lx).", lpszDir, dwRet);
			hRet = HRESULT_FROM_WIN32(dwRet);
		}
		// ERROR_ALREADY_EXISTS is acceptable
		else
			hRet = S_OK;
	}

    return (hRet);
}


inline BOOL EnsureDirExists(LPCTSTR lpszDir)
{
	BOOL fIsDir = FALSE;
	BOOL fRet = FALSE;

	if (fFileExists(lpszDir, &fIsDir))
	{
		if (!fIsDir)
		{
			DEBUGMSG("WARNING: directory squatting. File with same name %S exists", lpszDir);
			DeleteFile(lpszDir);
		}
		else
		{
//			DEBUGMSG("Direcotry %S exists, no need to create again", lpszDir);
			return TRUE;
		}
	}
    if (!(fRet = CreateNestedDirectory(lpszDir)))
    {
    	DEBUGMSG("Fail to createnesteddirectory with error %d", GetLastError());
    }
	 
//	DEBUGMSG(" Create directory %S %s", lpszDir, fRet ? "succeeded": "failed");
	return fRet;
}


/////////////////////////////////////////////////////////////////////////////
//
// Function GetDownloadPath()
//			Gets the download directory path
// Input:   a buffer to store the directory created and size of the buffer in TCHARs
// Output:  None
// Return:  HRESULT to tell the result
//
/////////////////////////////////////////////////////////////////////////////
HRESULT GetDownloadPath(LPTSTR lpszDir, DWORD dwCchSize)
{
    UINT	nSize;
    TCHAR	szDir[MAX_PATH];
    HRESULT hr;

    if (lpszDir == NULL)
    {
        return (E_INVALIDARG);
    }
    AUASSERT(_T('\0') != g_szWUDir[0]);
    if (FAILED(hr = StringCchCopyEx(szDir, ARRAYSIZE(szDir), g_szWUDir, NULL, NULL, MISTSAFE_STRING_FLAGS)))
    {
        DEBUGMSG("GetDownloadPath() failed to get WinUpd directory");
        return hr;
    }
	if (FAILED(hr = PathCchAppend(szDir, ARRAYSIZE(szDir), C_DOWNLD_DIR)))
	{
        DEBUGMSG("GetDownloadPath() found input buffer too small.");
        return (hr);
	}
    if (FAILED(hr = StringCchCopyEx(lpszDir, dwCchSize, szDir, NULL, NULL, MISTSAFE_STRING_FLAGS)))
	{
		DEBUGMSG("GetDownloadPath() call to StringCchCopyEx() failed.");
		return hr;
	}
    return EnsureDirExists(lpszDir) ? S_OK : E_FAIL;
}

HRESULT GetDownloadPathSubDir(LPTSTR lpszDir, DWORD dwCchSize, LPCTSTR tszSubDir)
{
   HRESULT hr;
    if (FAILED(hr = GetDownloadPath(lpszDir, dwCchSize)))
        {
        DEBUGMSG("GetDownloadPathSubDir() fail to get download path");
        return hr;
        }
	if (FAILED(hr = StringCchCatEx(lpszDir, dwCchSize, _T("\\"), NULL, NULL, MISTSAFE_STRING_FLAGS)) ||
		FAILED(hr = StringCchCatEx(lpszDir, dwCchSize, tszSubDir, NULL, NULL, MISTSAFE_STRING_FLAGS)))
	{
		DEBUGMSG("GetDownloadPathSubDir() failed to construct download path subdir with error %#lx.", hr);
		return hr;
	}
    return EnsureDirExists(lpszDir) ? S_OK : E_FAIL;
}    

///////////////////////////////////////////////////////////////
// get the path to download software update bits
// lpszDir  : IN buffer to store the path and its size in TCHARs
// return : S_OK if success
//           : E_INVALIDARG if buffer too small
//           : E_FAIL if other error
//////////////////////////////////////////////////////////////
HRESULT GetCabsDownloadPath(LPTSTR lpszDir, DWORD dwCchSize)
{
return GetDownloadPathSubDir(lpszDir, dwCchSize, CABS_DIR);
}

///////////////////////////////////////////////////////////////
// get the path to download UI specific data, like description and rtf
// lpszDir  : IN buffer to store the path and its size in TCHARs
// return : S_OK if success
//////////////////////////////////////////////////////////////
HRESULT GetUISpecificDownloadPath(LPTSTR lpszDir, DWORD dwCchSize, LANGID langid, LPCTSTR tszSubDir)
{
    HRESULT hr ;
    if (FAILED(hr = GetDownloadPath(lpszDir, dwCchSize)))
        {
        DEBUGMSG("GetUISpecificDownloadPath() fail to get download path");
        return hr;
        }
    TCHAR tszLangId[10];
    if (FAILED(StringCchPrintfEx(tszLangId, ARRAYSIZE(tszLangId), NULL, NULL, MISTSAFE_STRING_FLAGS, _T("%04x"), langid)))
	{
		return E_INVALIDARG;
	}
	if (FAILED(hr = StringCchCatEx(lpszDir, dwCchSize, _T("\\"), NULL, NULL, MISTSAFE_STRING_FLAGS)) ||
		FAILED(hr = StringCchCatEx(lpszDir, dwCchSize, tszSubDir, NULL, NULL, MISTSAFE_STRING_FLAGS)) ||
		FAILED(hr = StringCchCatEx(lpszDir, dwCchSize, _T("\\"), NULL, NULL, MISTSAFE_STRING_FLAGS)) ||
		FAILED(hr = StringCchCatEx(lpszDir, dwCchSize, tszLangId, NULL, NULL, MISTSAFE_STRING_FLAGS)))
	{
		DEBUGMSG("GetUISpecificDownloadPath() failed to construct ui specific download path with error %#lx.", hr);
		return hr;
	}
    return EnsureDirExists(lpszDir)? S_OK : E_FAIL;
}

///////////////////////////////////////////////////////////////
// get the rtf download path for a language
// lpszDir : IN buffer to store the path and its size in TCHARs
// return: S_OK if success
//           : E_INVALIDARG if buffer too small
//           : E_FAIL if other error
//////////////////////////////////////////////////////////////
HRESULT GetRTFDownloadPath(LPTSTR lpszDir, DWORD dwCchSize, LANGID langid)
{
  return GetUISpecificDownloadPath(lpszDir, dwCchSize, langid, RTF_DIR);
}

/////////////////////////////////////////////////////////////////
// get language independent RTF directory
/////////////////////////////////////////////////////////////////
HRESULT GetRTFDownloadPath(LPTSTR lpszDir, DWORD dwCchSize)
{
    return GetDownloadPathSubDir(lpszDir, dwCchSize, RTF_DIR);
}

/////////////////////////////////////////////////////////////////////////////
//
// Function MakeTempDownloadDir()
//			Insures that a local temporary directory exists for downloads
//
// Input:   pstrTarget  - [out] path to temp dir and its size in TCHARs
// Output:  Makes a new directory if needed
// Return:  HRESULT
/////////////////////////////////////////////////////////////////////////////

HRESULT MakeTempDownloadDir(LPTSTR        pszTarget, DWORD dwCchSize)
{
    HRESULT hr;
    if (FAILED(hr = GetDownloadPath(pszTarget, dwCchSize)) ||
		// Make sure it exists
		FAILED(hr = CreateDownloadDir(pszTarget)))
        return hr;

    return NOERROR;
}

HRESULT GetRTFLocalFileName(BSTR bstrRTFPath, LPTSTR lpszFileName, DWORD dwCchSize, LANGID langid)
{
    HRESULT hr ;
    hr =  GetRTFDownloadPath(lpszFileName, dwCchSize, langid);
    if (SUCCEEDED(hr))
        {
        hr = PathCchAppend(lpszFileName, dwCchSize, PathFindFileName(W2T(bstrRTFPath)));
        }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\wuaulib\auwait.cpp ===
#include "pch.h"
#pragma hdrstop
const TCHAR szAUTestValidationFile[] = _T("autest.cab");

DWORD dwTimeToWait(DWORD dwTimeInSecs, DWORD dwMinSecs)
{
    static DWORD dwSecsInADay = -1;

    if ( -1 == dwSecsInADay)
    {
  		dwSecsInADay = AU_ONE_DAY;

#ifndef DBG
		if (WUAllowTestKeys(szAUTestValidationFile) )
#endif
		{
			if (FAILED(GetRegDWordValue(_T("SecsInADay"), &dwSecsInADay)) ||
             (dwSecsInADay > AU_ONE_DAY) )
			{
				dwSecsInADay = AU_ONE_DAY;
			}
		}
    }

    DWORD dwMS = DWORD((((double(1000) * double(dwTimeInSecs)) / double(AU_ONE_DAY)) * double(dwSecsInADay)));
    DWORD dwMinMS = dwMinSecs * 1000;

    if ( dwMS < dwMinMS )
    {
        dwMS = dwMinMS;
    }

    if ( dwMS < AU_MIN_MS )
	{
		// we dont' wait less that 1 second
		dwMS = AU_MIN_MS;
	}

	return dwMS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\wuaulib\cfreg.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  SYSTEM:     Windows Update Critical Fix Notification
//
//  CLASS:      N/A
//  MODULE:     Connection Detection
//  FILE:       cfreg.CPP
//
/////////////////////////////////////////////////////////////////////
//
//  DESC:   This class implements all functions needed to access
//          machine registry to get information related to 
//          Windows Update  Critical Fix Notification feature.
//
//  AUTHOR: Charles Ma, Windows Update Team
//  DATE:   7/6/1998
//
/////////////////////////////////////////////////////////////////////
//
//  Revision History:
//
//  Date    Author          Description
//  ~~~~    ~~~~~~          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//  7/6/98  Charles Ma      Created
//
/////////////////////////////////////////////////////////////////////
//
//      Copyrights:   1998 Microsoft  Corporation 
//
//      All rights reserved.
//
//      No portion of this source code may be reproduced
//      without express written permission of Microsoft Corporation.
//
//      This source code is proprietary and confidential.
/////////////////////////////////////////////////////////////////////
//
// CriticalFixReg.cpp: implementation of the functions used to 
// handle registry related operations
//
//////////////////////////////////////////////////////////////////////
#include "pch.h"
#pragma hdrstop

const TCHAR AUREGKEY_HKLM_DOMAIN_POLICY[] =        _T("Software\\Policies\\Microsoft\\Windows\\WindowsUpdate\\AU");
const TCHAR	AUREGKEY_HKLM_WINDOWSUPDATE_POLICY[] = _T("Software\\Policies\\Microsoft\\Windows\\WindowsUpdate");
const TCHAR	AUREGKEY_HKLM_IUCONTROL_POLICY[] =     _T("Software\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate\\IUControl");
const TCHAR	AUREGKEY_HKLM_SYSTEM_WAS_RESTORED[] =  _T("Software\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate\\Auto Update\\SystemWasRestored");
const TCHAR AUREGKEY_HKCU_USER_POLICY[] = _T("Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\WindowsUpdate");
const TCHAR	AUREGKEY_HKLM_ADMIN_POLICY[] =         _T("Software\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate\\Auto Update");
const TCHAR AUREGVALUE_DISABLE_WINDOWS_UPDATE_ACCESS[] = _T("DisableWindowsUpdateAccess");
const TCHAR	AUREGKEY_REBOOT_REQUIRED[] = _T("Software\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate\\Auto Update\\RebootRequired");


////////////////////////////////////////////////////////////////////////////
//
// Public Function  GetRegStringValue()
//                  Read the registry value for a REG_SZ key
// Input:   Name of value
// Output:  Buffer containing the registry value if successful
// Return:  HRESULT flag indicating the success of this function
//
////////////////////////////////////////////////////////////////////////////
HRESULT GetRegStringValue(LPCTSTR lpszValueName, LPTSTR lpszBuffer, int nCharCount, LPCTSTR lpszSubKeyName)
{
    HKEY        hKey;
    HRESULT hr = E_FAIL;

    if (lpszValueName == NULL || lpszBuffer == NULL)
    {
        return E_INVALIDARG;     
    }

    if (ERROR_SUCCESS == RegOpenKeyEx(
                                    HKEY_LOCAL_MACHINE,
                                    lpszSubKeyName,
                                    0,
                                    KEY_READ,
                                    &hKey) )
    {
        hr = SafeRegQueryStringValueCch(
                                    hKey,
                                    lpszValueName,
                                    lpszBuffer,
                                    nCharCount,
                                    NULL,
                                    NULL);
        RegCloseKey(hKey);
    }
    return hr;
}


////////////////////////////////////////////////////////////////////////////
//
// Public Function  SetRegStringValue()
//                  Set the registry value of timestamp as current system local time
// Input:   name of the value to set. pointer to the time structure to set time. if null,
//          we use current system time.
// Output:  None
// Return:  HRESULT flag indicating the success of this function
//
////////////////////////////////////////////////////////////////////////////
HRESULT SetRegStringValue(LPCTSTR lpszValueName, LPCTSTR lpszNewValue, LPCTSTR lpszSubKeyName)
{
    HKEY        hKey;
    HRESULT     hRet = E_FAIL;
    DWORD       dwResult;
    
    if (lpszValueName == NULL || lpszNewValue == NULL)
    {
        return E_INVALIDARG;
    }

    //
    // open the key 
    //
    if (RegCreateKeyEx(
                    HKEY_LOCAL_MACHINE,         // root key
                    lpszSubKeyName,     // subkey
                    0,                          // reserved
                    NULL,                       // class name
                    REG_OPTION_NON_VOLATILE,    // option
                    KEY_SET_VALUE,                  // security 
                    NULL,                       // security attribute
                    &hKey,
                    &dwResult) == ERROR_SUCCESS)
    {

        //
        // set the time to the lasttimestamp value
        //
        hRet = (RegSetValueEx(
                        hKey,
                        lpszValueName,
                        0,
                        REG_SZ,
                        (const unsigned char *)lpszNewValue,
                        (lstrlen(lpszNewValue) + 1) * sizeof(*lpszNewValue)
                        ) == ERROR_SUCCESS) ? S_OK : E_FAIL;
        RegCloseKey(hKey);
    }

    return hRet;
}



////////////////////////////////////////////////////////////////////////////
//
// Public Function  DeleteRegValue()
//                  Delete the registry value entry
// Input:   name of the value to entry,
// Output:  None
// Return:  HRESULT flag indicating the success of this function
//
////////////////////////////////////////////////////////////////////////////
HRESULT DeleteRegValue(LPCTSTR lpszValueName)
{
    HKEY        hKey;
    HRESULT     hRet = E_FAIL;
    
    if (lpszValueName == NULL)
    {
        return E_INVALIDARG;
    }

    //
    // open the key 
    //
    if (RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,         // root key
                    AUREGKEY_HKLM_ADMIN_POLICY,     // subkey
                    0,                          // reserved
                    KEY_WRITE,                  // security 
                    &hKey) == ERROR_SUCCESS)
    {

        //
        // set the time to the lasttimestamp value
        //
        hRet = (RegDeleteValue(
                        hKey,
                        lpszValueName
                        ) == ERROR_SUCCESS) ? S_OK : E_FAIL;
        RegCloseKey(hKey);
    }
    else
    {
    	DEBUGMSG("Fail to reg open key with error %d", GetLastError());
    }

    return hRet;

}

//=======================================================================
// GetRegDWordValue
//=======================================================================
HRESULT GetRegDWordValue(LPCTSTR lpszValueName, LPDWORD pdwValue, LPCTSTR lpszSubKeyName)
{
    HKEY        hKey;
    int         iRet;
    DWORD       dwType = REG_DWORD, dwSize = sizeof(DWORD);

    if (lpszValueName == NULL)
    {
        return E_INVALIDARG;
    }

    //
    // open critical fix key
    //
    if (RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    lpszSubKeyName,
                    0,
                    KEY_READ,
                    &hKey) == ERROR_SUCCESS)
    {

        //
        // query the last timestamp value
        //
        iRet = RegQueryValueEx(
                        hKey,
                        lpszValueName,
                        NULL,
                        &dwType,
                        (LPBYTE)pdwValue,
                        &dwSize);
        RegCloseKey(hKey);

        if (iRet == ERROR_SUCCESS && dwType == REG_DWORD && dwSize == sizeof(DWORD))
        {
            return S_OK;
        }
    }
    return E_FAIL;
}

////////////////////////////////////////////////////////////////////////////
//
// Public Function  SetRegDWordValue()
//                  Set the registry value as a DWORD
// Input:   name of the value to set. value to set
// Output:  None
// Return:  HRESULT flag indicating the success of this function
//
////////////////////////////////////////////////////////////////////////////
HRESULT SetRegDWordValue(LPCTSTR lpszValueName, DWORD dwValue, DWORD options, LPCTSTR lpszSubKeyName)
{
    HKEY        hKey;
    HRESULT     hRet = E_FAIL;
    DWORD       dwResult;
    
    if (lpszValueName == NULL)
    {
        return E_INVALIDARG;
    }


    //
    // open the key 
    //
    if (RegCreateKeyEx(
                    HKEY_LOCAL_MACHINE,         // root key
                    lpszSubKeyName,     // subkey
                    0,                          // reserved
                    NULL,                       // class name
                    options,					// option
                    KEY_SET_VALUE,                  // security 
                    NULL,                       // security attribute
                    &hKey,
                    &dwResult) == ERROR_SUCCESS)
    {

        //
        // set the time to the lasttimestamp value
        //
        hRet = (RegSetValueEx(
                        hKey,
                        lpszValueName,
                        0,
                        REG_DWORD,
                        (LPBYTE)&dwValue,
                        sizeof(DWORD)
                        ) == ERROR_SUCCESS) ? S_OK : E_FAIL;
        RegCloseKey(hKey);
    }
    return hRet;
}

BOOL fRegKeyCreate(LPCTSTR tszKey, DWORD dwOptions)
{
    HKEY        hKey;
    DWORD       dwResult;

    //
    // open the key 
    //
    if ( RegCreateKeyEx(
                    HKEY_LOCAL_MACHINE,         // root key
                    tszKey,     // subkey
                    0,                          // reserved
                    NULL,                       // class name
                    dwOptions,					// option
                    KEY_WRITE,                  // security 
                    NULL,                       // security attribute
                    &hKey,
                    &dwResult) == ERROR_SUCCESS )
    {
        RegCloseKey(hKey);
		return TRUE;
    }
    return FALSE;
}

BOOL fRegKeyExists(LPCTSTR tszSubKey, HKEY hRootKey)
{
	HKEY hKey;
	BOOL fRet = FALSE;

    if (RegOpenKeyEx(
//                    HKEY_LOCAL_MACHINE,
					hRootKey,
                    tszSubKey,
                    0,
                    KEY_READ,
                    &hKey) == ERROR_SUCCESS)
    {
        RegCloseKey(hKey);
		fRet = TRUE;
    }

    return fRet;
}


DWORD getTimeOut()             
{
	DWORD dwValue = 0;
	GetRegDWordValue(_T("TimeOut"), &dwValue);
	return dwValue;
}

HRESULT setAddedTimeout(DWORD timeout, LPCTSTR strkey)
{
	HKEY hAUKey;
	SYSTEMTIME	tmCurr;
	SYSTEMTIME  tmTimeOut;
	TCHAR		szCurr[50];
	HRESULT		hr = E_FAIL;

	GetSystemTime(&tmCurr);

	if (FAILED(TimeAddSeconds(tmCurr, timeout, &tmTimeOut)))
	{
		return E_FAIL; 
	}

	if (RegCreateKeyEx(HKEY_LOCAL_MACHINE ,
						  AUTOUPDATEKEY,
						  0, TEXT(""),
						  REG_OPTION_NON_VOLATILE,
						  KEY_SET_VALUE,
						  NULL,
						  &hAUKey,
						  NULL) != ERROR_SUCCESS)
	{
		return E_FAIL;
	}

	if (SUCCEEDED(SystemTime2String(tmTimeOut, szCurr, ARRAYSIZE(szCurr))) &&
		RegSetValueEx(hAUKey,
					  strkey,
					  0, REG_SZ,
					  (BYTE *)szCurr,
					  sizeof(TCHAR)*(lstrlen(szCurr)+1)) == ERROR_SUCCESS)
	{
		hr = S_OK;
	}
	
	RegCloseKey(hAUKey);
	
	return hr;
}
HRESULT getAddedTimeout(DWORD *pdwTimeDiff, LPCTSTR strkey)
{
	HKEY hAUKey;
	LONG lRet;
	TCHAR		szTimeBuf[50];
	DWORD       dwType = REG_SZ, dwSize = sizeof(szTimeBuf);
	SYSTEMTIME	tmCurr, tmReminder;
	
	*pdwTimeDiff = 0;
	if (RegOpenKeyEx(HKEY_LOCAL_MACHINE ,
						  AUTOUPDATEKEY,
						  0, 
						  KEY_READ,
						  &hAUKey) != ERROR_SUCCESS)
	{
		return E_FAIL;
	}

	lRet = RegQueryValueEx(
                        hAUKey,
                        strkey,
                        NULL,
                        &dwType,
                        (LPBYTE)szTimeBuf,
                        &dwSize);

	RegCloseKey(hAUKey);

	if (lRet != ERROR_SUCCESS || dwType != REG_SZ ||
		FAILED(String2SystemTime(szTimeBuf, &tmReminder)))
	{
		return E_FAIL;
	}

	GetSystemTime(&tmCurr);
	
	*pdwTimeDiff = 	max (TimeDiff(tmCurr, tmReminder),0);
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\wuaulib\criticalfixreg.h ===
//=======================================================================
//
//  Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:    criticalfixreg.h
//
//  Creator: PeterWi
//
//  Purpose: AU registry related functions.
//
//=======================================================================

#pragma once
extern const TCHAR AUREGKEY_HKLM_DOMAIN_POLICY[]; // =        _T("Software\\Policies\\Microsoft\\Windows\\WindowsUpdate\\AU");
extern const TCHAR	AUREGKEY_HKLM_WINDOWSUPDATE_POLICY[]; // = _T("Software\\Policies\\Microsoft\\Windows\\WindowsUpdate");
extern const TCHAR	AUREGKEY_HKLM_IUCONTROL_POLICY[]; // =     _T("Software\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate\\IUControl");
extern const TCHAR	AUREGKEY_HKLM_SYSTEM_WAS_RESTORED[]; // =  _T("Software\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate\\Auto Update\\SystemWasRestored");
extern const TCHAR	AUREGKEY_HKLM_ADMIN_POLICY[] ; // =         _T("Software\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate\\Auto Update");
extern const TCHAR AUREGKEY_HKCU_USER_POLICY[]; // = _T("Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\WindowsUpdate");
extern const TCHAR AUREGVALUE_DISABLE_WINDOWS_UPDATE_ACCESS[]; // = _T("DisableWindowsUpdateAccess"); 

////////////////////////////////////////////////////////////////////////////
//
// Public Function	GetRegStringValue()
//					Read the registry value of timestamp for last detection 
// Input:	Name of value, value, and size of value
// Output:	SYSTEMTIME structure contains the time
// Return:	HRESULT flag indicating the success of this function
//
////////////////////////////////////////////////////////////////////////////
HRESULT GetRegStringValue(LPCTSTR lpszValueName, LPTSTR lpszBuffer, int nCharCount, LPCTSTR lpszSubKeyName = AUREGKEY_HKLM_ADMIN_POLICY);


////////////////////////////////////////////////////////////////////////////
//
// Public Function	SetRegStringValue()
//					Set the registry value of timestamp as current system local time
// Input:	name of the value to set. and value,
//			
// Output:	None
// Return:	HRESULT flag indicating the success of this function
//
////////////////////////////////////////////////////////////////////////////
HRESULT SetRegStringValue(LPCTSTR lpszValueName, LPCTSTR lpszNewValue, LPCTSTR lpszSubKeyName = AUREGKEY_HKLM_ADMIN_POLICY);


////////////////////////////////////////////////////////////////////////////
//
// Public Function	DeleteRegValue()
//					Delete the registry value entry
// Input:	name of the value to entry,
// Output:	None
// Return:	HRESULT flag indicating the success of this function
//
////////////////////////////////////////////////////////////////////////////
HRESULT DeleteRegValue(LPCTSTR lpszValueName);


////////////////////////////////////////////////////////////////////////////
//
// Public Function	GetRegDWordValue()
//					Get a DWORD from specified regustry value name
// Input:	name of the value to retrieve value
// Output:	pointer to the retrieved value
// Return:	HRESULT flag indicating the success of this function
//
////////////////////////////////////////////////////////////////////////////
HRESULT GetRegDWordValue(LPCTSTR lpszValueName, LPDWORD pdwValue, LPCTSTR lpszSubKeyName = AUREGKEY_HKLM_ADMIN_POLICY);


////////////////////////////////////////////////////////////////////////////
//
// Public Function	SetRegDWordValue()
//					Set the registry value as a DWORD
// Input:	name of the value to set. value to set
// Output:	None
// Return:	HRESULT flag indicating the success of this function
//
////////////////////////////////////////////////////////////////////////////
HRESULT SetRegDWordValue(LPCTSTR lpszValueName, DWORD dwValue, DWORD options = REG_OPTION_NON_VOLATILE, LPCTSTR lpszSubKeyName = AUREGKEY_HKLM_ADMIN_POLICY);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\wuaulib\debug.cpp ===
//=======================================================================
//
//  Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:    debug.cpp
//
//  Creator: PeterWi
//
//  Purpose: debug functions
//
//=======================================================================

#include "pch.h"
#pragma hdrstop

#ifdef DBG

#define UNLEN 256
#define TYPE_KEY	TEXT("DebugType")
#define LOGFILE		1
#define DEBUGGEROUT	2

void WriteLogFile(LPCSTR s);

///////////////////////////////////////////////////////////////////////////////
//
// Function :	WuAUTrace
// In		:	Variable number of arguments
// Comments :	If DEBUGGEROUT is defined, uses OutputDebugString to write
//				debug messages. If LOGFILEOUT is defined, uses WriteLogFile
//				to write to a file. The filename is founf in the registry
//
///////////////////////////////////////////////////////////////////////////////
void _cdecl WUAUTrace(char* pszFormat, ...)
{
	USES_IU_CONVERSION;
	CHAR szBuf[1024+1];
	va_list ArgList;
	static DWORD dwType = 3;
	TCHAR szTimeString[80];
	SYSTEMTIME timeNow;
	CHAR szTemp[1040];
	LPSTR szTmp = NULL;

	if (! dwType ||			//on the second run this will be 0, 1 or 2
		NULL == pszFormat)
	{
		return;
	}

	va_start(ArgList, pszFormat);
    (void)StringCchVPrintfExA(szBuf, ARRAYSIZE(szBuf), NULL, NULL, MISTSAFE_STRING_FLAGS, pszFormat, ArgList);
	va_end(ArgList);

	if (dwType == 3)						//first time
	{
		if ((FAILED(GetRegDWordValue(TYPE_KEY, &dwType))) || (!dwType))
		{
			dwType = 0;
			return;						//no debug msg if no key or key==0
		}
	}

	GetLocalTime(&timeNow);
	if(SUCCEEDED(SystemTime2String(timeNow, szTimeString, ARRAYSIZE(szTimeString))))
	{
	    szTmp = T2A(szTimeString);
	}

	(void)StringCchPrintfExA(
			szTemp,
			ARRAYSIZE(szTemp),
			NULL, NULL, MISTSAFE_STRING_FLAGS,
			"%lx  %s : %s\r\n",
			GetCurrentThreadId(),
			NULL == szTmp ? "" : szTmp,
			szBuf);

	if (dwType==LOGFILE)
	{
		WriteLogFile(szTemp);
	}
	else
	{
		OutputDebugStringA(szTemp);
	}
}



///////////////////////////////////////////////////////////////////////////////
//
// Function :	CreateOrOpenDebugFile
// Out		:   File Handle to open debug file. Must be closed by caller
// Returns  :   TRUE for success, FALSE for failure
// Comments :	Creates a file "WinDir\wupd\username\wupdlog.txt"
//
///////////////////////////////////////////////////////////////////////////////
BOOL CreateOrOpenDebugFile(HANDLE& hFile)
{
	TCHAR szDir[MAX_PATH+1], szUser[UNLEN+1];
	DWORD dwNameLen = ARRAYSIZE(szUser), dwErr;
	const TCHAR szWUPDDir[] = _T("wupd");
	const TCHAR szLogFileName[] = _T("wupdlog.txt");
	const TCHAR szWUDir[] = _T("C:\\Program Files\\WindowsUpdate");

	if (FAILED(PathCchCombine(
					szDir,
					ARRAYSIZE(szDir),
					_T('\0') == g_szWUDir[0] ? szWUDir : g_szWUDir,
					szWUPDDir)))
	{
		return FALSE;
	}

	if (! CreateDirectory(szDir, NULL))
	{
		dwErr = GetLastError();
		if ((dwErr != ERROR_ALREADY_EXISTS) && (dwErr != ERROR_FILE_EXISTS))
		{
			return FALSE;
		}
	}

	if (! GetUserName(szUser, &dwNameLen))
	{
		const TCHAR szDefault[] = _T("default");

		(void)StringCchCopyEx(szUser, ARRAYSIZE(szUser), szDefault, NULL, NULL, MISTSAFE_STRING_FLAGS);
	}

	if (FAILED(PathCchAppend(szDir, ARRAYSIZE(szDir), szUser)))
	{
		return FALSE;
	}

	if (! CreateDirectory(szDir, NULL))
	{
		dwErr = GetLastError();
		if ((dwErr != ERROR_ALREADY_EXISTS) && (dwErr != ERROR_FILE_EXISTS))
		{
			return FALSE;
		}
	}

	if (FAILED(PathCchAppend(szDir, ARRAYSIZE(szDir), szLogFileName)))
	{
		return FALSE;
	}

	// We now have directory "drive:program files\windowsupdate\username\"
	if ((hFile = CreateFile(szDir,
							GENERIC_WRITE,
							FILE_SHARE_READ,
							NULL,
							OPEN_ALWAYS,
							0,
							NULL)) == INVALID_HANDLE_VALUE)
	{
		return FALSE;
	}

	return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
//
// Function :	WriteLogFile
// In		:	Variable number of arguments
// Comments :	If DEBUGGEROUT is defined, uses OutputDebugString to write
//				debug messages. If LOGFILEOUT is defined, uses WriteLogFile
//				to write to a file. The filename is found in the registry
//				If for some reason the reg value for filename is "", we
//				simply don't log.
// Courtesy	:	darshats
//
///////////////////////////////////////////////////////////////////////////////

void WriteLogFile(LPCSTR s)
{
	DWORD dwCurrSize = 0, cbWritten = 0;
	DWORD cbToWrite = lstrlenA(s);
	HANDLE hFile;

	if (!CreateOrOpenDebugFile(hFile))
		return;

	dwCurrSize = GetFileSize(hFile, NULL);
	SetFilePointer(hFile, dwCurrSize, NULL, FILE_BEGIN);
	(void) WriteFile(hFile, s, cbToWrite, &cbWritten, NULL);
	CloseHandle(hFile);
}


#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\wuaulib\platform.cpp ===
//=======================================================================
//
//  Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:    platform.cpp
//
//  Creator: PeterWi
//
//  Purpose: platform functions.
//
//=======================================================================
#include "pch.h"
#pragma hdrstop



//=======================================================================
//
//  fIsPersonalOrProfessional
//
//  Determine if machine is personal or professional.
//
//  Note: personal is a type of suite of professional.
//  
//=======================================================================
BOOL fIsPersonalOrProfessional(void)
{
	OSVERSIONINFOEX osver;

	ZeroMemory(&osver, sizeof(osver));
	osver.dwOSVersionInfoSize = sizeof(osver);
	
	if ( GetVersionEx((OSVERSIONINFO *)&osver) )
	{
		return (VER_NT_WORKSTATION == osver.wProductType);
	}

	return FALSE;
}

/////////////////////////////////////////////////////////////
// GetFileVersionStr(...) get version of a file
//	and store it in parameter tszbuf in the format 
//  of "MajorVersion.MinorVersion.BuildNumber.XXX"
//	e.g. "5.4.2448.1" 
//  tszFile		: IN stores full path of the file name
//  tszbuf		: IN stores OS version string
//  ubufsize	: IN stores size of tszbuf in charaters. 
//				:	 must be at least 20 charaters long
// return : S_OK			if OS version string got
//		  : E_INVALIDARG	if argument not valid
//		  : STRSAFE_E_INSUFFICIENT_BUFFER	if insufficient buffer
//		  : E_FAIL			if any other error
HRESULT GetFileVersionStr(LPCTSTR tszFile, LPTSTR tszbuf, UINT uSize)
{
	DWORD	dwVerNumberMS = 0;
	DWORD   dwVerNumberLS = 0;
	HRESULT		hr = S_OK; 
	USES_IU_CONVERSION;

	if (uSize < 20 || NULL == tszbuf) 
	{
		hr = E_INVALIDARG;
		goto done;
	}
	LPSTR szTmp = T2A(tszFile);
	if (NULL == szTmp)
	{
	    hr = E_OUTOFMEMORY;
	    goto done;
	}
    	hr = GetVersionFromFileEx(
    		szTmp,
    		&dwVerNumberMS, 
    		&dwVerNumberLS,
    		TRUE);
    	if (SUCCEEDED(hr) &&
			SUCCEEDED(hr = StringCchPrintfEx(
						tszbuf, uSize, NULL, NULL, MISTSAFE_STRING_FLAGS, _T("%d.%d.%d.%d"), 
    					HIWORD(dwVerNumberMS),
    					LOWORD(dwVerNumberMS),
    					HIWORD(dwVerNumberLS),
    					LOWORD(dwVerNumberLS))))
		{
    		DEBUGMSG("file version for %S is %S", tszFile, tszbuf);
    	}
	
done:
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\wuaulib\helpers.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//	SYSTEM:		Windows Update AutoUpdate Client
//
//	CLASS:		N/A
//	MODULE:		
//	FILE:		helpers.CPP
//	DESC:	       This file contains utility functions
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#pragma hdrstop

const LPTSTR HIDDEN_ITEMS_FILE = _T("hidden.xml");

const LPCTSTR AU_ENV_VARS::s_AUENVVARNAMES[] = {_T("AUCLTEXITEVT"),_T("EnableNo"), _T("EnableYes"), _T("RebootWarningMode"), _T("ManualReboot"), _T("StartTickCount")};

BOOL AU_ENV_VARS::ReadIn(void)
{
	BOOL fRet = TRUE;
	
	if (!GetBOOLEnvironmentVar(s_AUENVVARNAMES[3], &m_fRebootWarningMode))
	{ // if not set, implies regular mode
		m_fRebootWarningMode = FALSE;
	}
	if (m_fRebootWarningMode)
	{
		if (!GetBOOLEnvironmentVar(s_AUENVVARNAMES[1], &m_fEnableNo)
			||!GetBOOLEnvironmentVar(s_AUENVVARNAMES[2], &m_fEnableYes)
			||!GetBOOLEnvironmentVar(s_AUENVVARNAMES[4], &m_fManualReboot)
			||!GetDWordEnvironmentVar(s_AUENVVARNAMES[5], &m_dwStartTickCount)
			||!GetStringEnvironmentVar(s_AUENVVARNAMES[0], m_szClientExitEvtName, ARRAYSIZE(m_szClientExitEvtName)))
		{
		    DEBUGMSG("AU_ENV_VARS fails to read in");
			return FALSE;
		}
//		DEBUGMSG("AU_ENV_VARS read in fEnableYes = %d, fEnableNo = %d, fManualReboot = %d, dwStartTickCount = %d",
//	                m_fEnableYes, m_fEnableNo, m_fManualReboot, m_dwStartTickCount); 

	}
//	DEBUGMSG("AU_ENV_VARS read in fRebootWarningMode = %d", m_fRebootWarningMode);
	return TRUE;
}

BOOL AU_ENV_VARS::WriteOut(LPTSTR szEnvBuf,
		size_t IN cchEnvBuf,
		BOOL IN fEnableYes,
		BOOL IN fEnableNo,
		BOOL IN fManualReboot,
		DWORD IN dwStartTickCount,
		LPCTSTR IN szClientExitEvtName)
{
	TCHAR buf2[s_AUENVVARBUFSIZE];
	m_fEnableNo = fEnableNo;
	m_fEnableYes = fEnableYes;
	m_fManualReboot = fManualReboot;
	m_dwStartTickCount = dwStartTickCount;
	m_fRebootWarningMode = TRUE;
//	DEBUGMSG("AU_ENV_VARS write out fEnableYes = %d, fEnableNo = %d, fManualReboot = %d, dwStartTickCount = %d",
//	                fEnableYes, fEnableNo, fManualReboot, dwStartTickCount);
	if (FAILED(StringCchCopyEx(
					m_szClientExitEvtName,
					ARRAYSIZE(m_szClientExitEvtName),
					szClientExitEvtName,
					NULL,
					NULL,
					MISTSAFE_STRING_FLAGS)))
	{
		return FALSE;
	}
	*szEnvBuf = _T('\0');
	for (int i = 0 ; i < ARRAYSIZE(s_AUENVVARNAMES); i++)
	{
        if (FAILED(GetStringValue(i, buf2, ARRAYSIZE(buf2))) || 
            FAILED(StringCchCatEx(szEnvBuf, cchEnvBuf, s_AUENVVARNAMES[i], NULL, NULL, MISTSAFE_STRING_FLAGS)) ||
			FAILED(StringCchCatEx(szEnvBuf, cchEnvBuf, _T("="), NULL, NULL, MISTSAFE_STRING_FLAGS)) ||
			FAILED(StringCchCatEx(szEnvBuf, cchEnvBuf, buf2, NULL, NULL, MISTSAFE_STRING_FLAGS)) ||
			FAILED(StringCchCatEx(szEnvBuf, cchEnvBuf, _T("&"), NULL, NULL, MISTSAFE_STRING_FLAGS)))
		{
			return FALSE;
		}
	}
//	DEBUGMSG("AU Env variable is %S", szEnvBuf);
 	return TRUE;
}
	
HRESULT AU_ENV_VARS::GetStringValue(int index, LPTSTR buf, DWORD dwCchSize)
{
    HRESULT hr = E_INVALIDARG;
	switch (index)
	{
		case 0: hr = StringCchCopyEx(buf, dwCchSize, m_szClientExitEvtName, NULL, NULL, MISTSAFE_STRING_FLAGS);
				break;
		case 1: hr = StringCchCopyEx(buf, dwCchSize, m_fEnableNo? _T("true") : _T("false"), NULL, NULL, MISTSAFE_STRING_FLAGS);
				break;
		case 2: hr = StringCchCopyEx(buf, dwCchSize, m_fEnableYes? _T("true") : _T("false"), NULL, NULL, MISTSAFE_STRING_FLAGS);
				break;
		case 3: hr = StringCchCopyEx(buf, dwCchSize, m_fRebootWarningMode ? _T("true") : _T("false"), NULL, NULL, MISTSAFE_STRING_FLAGS);
				break;
		case 4: hr = StringCchCopyEx(buf, dwCchSize, m_fManualReboot ? _T("true") : _T("false"), NULL, NULL, MISTSAFE_STRING_FLAGS);
		              break;
		case 5: hr = StringCchPrintfEx(buf, dwCchSize, NULL, NULL, MISTSAFE_STRING_FLAGS, _T("%lu"), m_dwStartTickCount);
		              break;
	        default: 
	                    AUASSERT(FALSE); //should never be here
	                    break;
	}
	return hr;
}
		

BOOL AU_ENV_VARS::GetDWordEnvironmentVar(LPCTSTR szEnvVar, DWORD *pdwVal)
{	
	TCHAR szBuf[20];
	*pdwVal = 0;
	if (GetStringEnvironmentVar(szEnvVar, szBuf, ARRAYSIZE(szBuf)))
	{
//     	DEBUGMSG("WUAUCLT   got environment variable %S = %S ", szEnvVar, szBuf);    
		*pdwVal = wcstoul(szBuf, NULL , 10);
		return TRUE;
	}
	return FALSE;
}	


	
BOOL AU_ENV_VARS::GetBOOLEnvironmentVar(LPCTSTR szEnvVar, BOOL *pfVal)
{	
	TCHAR szBuf[20];
	if (GetStringEnvironmentVar(szEnvVar, szBuf, ARRAYSIZE(szBuf)))
	{
//     	DEBUGMSG("WUAUCLT   got environment variable %S = %S ", szEnvVar, szBuf);    
		*pfVal =(0 == lstrcmpi(szBuf, _T("true")));
		return TRUE;
	}
	return FALSE;
}	

/////////////////////////////////////////////////////////////////////////////////////////////
// dwSize: size of szBuf in number of characters
////////////////////////////////////////////////////////////////////////////////////////////
BOOL AU_ENV_VARS::GetStringEnvironmentVar(LPCTSTR szEnvVar, LPTSTR szBuf, DWORD dwSize)
{
	// Assume szEnvVar is not a proper substring in for any parameters in szCmdLine.
	LPTSTR szCmdLine = GetCommandLine();
	LPTSTR pTmp;
 	DWORD  index = 0;
//	DEBUGMSG("WUAUCLT read in command line %S", szCmdLine);
	if (NULL == szCmdLine || 0 == dwSize ||  (NULL == (pTmp = StrStr(szCmdLine, szEnvVar))))
	{
		return FALSE;
	}
 	
 	pTmp += lstrlen(szEnvVar) + 1; //skip '='
 	while (_T('\0') != *pTmp && _T('&') != *pTmp)
 	{
		if (index + 1 >= dwSize)
		{
			// insufficent buffer
			return FALSE;
		}
 		szBuf[index++] = *pTmp++;
 	}
 	szBuf[index] = _T('\0');
// 	DEBUGMSG(" read in %S = %S", szEnvVar, szBuf);
 	return TRUE;
}


#if 0
#ifdef DBG
void DBGCheckEventState(LPSTR szName, HANDLE hEvt)
{
	DWORD dwRet  = WaitForSingleObject(hEvt, 0);
	DEBUGMSG("WUAU   Event %s is %s signalled", szName,( WAIT_OBJECT_0 == dwRet) ? "" : "NOT");
	return;
}		
#endif
#endif




////////////////////////////////////////////////////////////////////////////////////////
// check whether it is win2k for the current system
////////////////////////////////////////////////////////////////////////////////////////
BOOL IsWin2K(void)
{
   static int iIsWin2K        = -1;     // force first time path

   if (iIsWin2K == -1)
   {
       OSVERSIONINFOEX osvi;
       DWORDLONG dwlConditionMask = 0;
       ZeroMemory(&osvi, sizeof(OSVERSIONINFOEX));

       // This is information that identifies win2K
       osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
       osvi.dwMajorVersion      = 5;
       osvi.dwMinorVersion      = 0;

       // Initialize the condition mask.
       VER_SET_CONDITION( dwlConditionMask, VER_MAJORVERSION, VER_EQUAL );
       VER_SET_CONDITION( dwlConditionMask, VER_MINORVERSION, VER_EQUAL );

       // Perform the test.
       iIsWin2K = (VerifyVersionInfo(&osvi, VER_MAJORVERSION | VER_MINORVERSION, dwlConditionMask)? 1 : 0);
   }

   return iIsWin2K;
}



/////////////////////////////////////////////////////////////////////////////////////
// check whether a policy is set to deny current user access to AU
/////////////////////////////////////////////////////////////////////////////////////
BOOL fAccessibleToAU(void)
{
    BOOL fAccessible = TRUE;
    DWORD dwType;
    DWORD dwValue;
    DWORD dwSize = sizeof(dwValue);
    DWORD dwResult = SHGetValue(HKEY_CURRENT_USER,
                                AUREGKEY_HKCU_USER_POLICY,
                                AUREGVALUE_DISABLE_WINDOWS_UPDATE_ACCESS,
                                &dwType,
                                &dwValue,
                                &dwSize);

    if (ERROR_SUCCESS == dwResult && REG_DWORD == dwType && 1 == dwValue)
    {
        fAccessible = FALSE;
    }
    return fAccessible;
}
 
/*
BOOL IsAdministrator()
{
	SID_IDENTIFIER_AUTHORITY SIDAuth = SECURITY_NT_AUTHORITY;
	PSID pSID = NULL;
	BOOL bResult = FALSE;

	if (!AllocateAndInitializeSid(&SIDAuth, 2,
								 SECURITY_BUILTIN_DOMAIN_RID,
								 DOMAIN_ALIAS_RID_ADMINS,
								 0, 0, 0, 0, 0, 0,
								 &pSID) ||
		!CheckTokenMembership(NULL, pSID, &bResult))
	{
		bResult = FALSE;
	}
	if(pSID)
	{
		FreeSid(pSID);
	}
	return bResult;
}
*/


// following are hidden item related functions
BOOL FHiddenItemsExist(void)
{
    //USES_CONVERSION;
    DEBUGMSG("FHiddenItemsExist()");
    TCHAR szFile[MAX_PATH];
   
    //Initialize the global path to WU Dir
    if(!CreateWUDirectory(TRUE))
    {
        return FALSE;
    }
	return
		SUCCEEDED(StringCchCopyEx(szFile, ARRAYSIZE(szFile), g_szWUDir, NULL, NULL, MISTSAFE_STRING_FLAGS)) &&
		SUCCEEDED(StringCchCatEx(szFile, ARRAYSIZE(szFile), HIDDEN_ITEMS_FILE, NULL, NULL, MISTSAFE_STRING_FLAGS)) &&
		fFileExists(szFile);
}

BOOL RemoveHiddenItems(void)
{
    //USES_CONVERSION
   DEBUGMSG("RemoveHiddenItems()");
   TCHAR szFile[MAX_PATH];

   AUASSERT(_T('\0') != g_szWUDir[0]);
   return
		SUCCEEDED(StringCchCopyEx(szFile, ARRAYSIZE(szFile), g_szWUDir, NULL, NULL, MISTSAFE_STRING_FLAGS)) &&
		SUCCEEDED(StringCchCatEx(szFile, ARRAYSIZE(szFile), HIDDEN_ITEMS_FILE, NULL, NULL, MISTSAFE_STRING_FLAGS)) &&
		AUDelFileOrDir(szFile);
}

/////////////////////////////////////////////////////////////////////////////////
// bstrRTFPath is URL for the RTF file on internet
// langid is the language id for the process who download this RTF
////////////////////////////////////////////////////////////////////////////////
BOOL IsRTFDownloaded(BSTR bstrRTFPath, LANGID langid)
{
    TCHAR tszLocalFullFileName[MAX_PATH];
    if (NULL == bstrRTFPath)
        {
            return FALSE;
        }
    if (FAILED(GetRTFDownloadPath(tszLocalFullFileName, ARRAYSIZE(tszLocalFullFileName), langid)) ||
        FAILED(PathCchAppend(tszLocalFullFileName, ARRAYSIZE(tszLocalFullFileName), W2T(PathFindFileNameW(bstrRTFPath)))))
    {
    	return FALSE;
    }    
//    DEBUGMSG("Checking existence of local RTF file %S", T2W(tszLocalFullFileName));
	BOOL fIsDir = TRUE;
    BOOL fExists = fFileExists(tszLocalFullFileName, &fIsDir);
	return fExists && !fIsDir;
}


void DisableUserInput(HWND hwnd)
{
    int ControlIDs[] = { IDC_CHK_KEEPUPTODATE, IDC_OPTION1, IDC_OPTION2,
                                    IDC_OPTION3, IDC_CMB_DAYS, IDC_CMB_HOURS,IDC_RESTOREHIDDEN };

    for (int i = 0; i < ARRAYSIZE(ControlIDs); i++)
        {
            EnableWindow(GetDlgItem(hwnd, ControlIDs[i]), FALSE);
        }
}


////////////////////////////////////////////////////////////////////////////
//
// Helper Function  Hours2LocalizedString()
//          helper function to standardized the way AU formats time string
//			for a given time. For example "3:00 AM"
//
// Parameters:
//		pst - ptr to SYSTEMTIME for localizing the time component
//		ptszBuffer - buffer to hold the resulting localized string
//		cbSize - size of buffer in TCHARs
// Return:  TRUE if successful; FALSE otherwise
//
////////////////////////////////////////////////////////////////////////////
BOOL Hours2LocalizedString(SYSTEMTIME *pst, LPTSTR ptszBuffer, DWORD cbSize)
{
	return (0 != GetTimeFormat(
					LOCALE_SYSTEM_DEFAULT,
					LOCALE_NOUSEROVERRIDE | TIME_NOSECONDS,
					pst,
					NULL,
					ptszBuffer,
					cbSize));
}


////////////////////////////////////////////////////////////////////////////
//
// Helper Function  FillHrsCombo()
//          helper function to standardized the way AU sets up the list
//			of hour values in a combo box.
//
// Parameters:
//		hwnd - handle to obtain the handle to the combobox
//		dwSchedInstallTime - hour value to default the combobox selection to
//							 3:00 AM will be used if this value is not valid.
// Return:  TRUE if successful; FALSE otherwise
//
////////////////////////////////////////////////////////////////////////////
BOOL FillHrsCombo(HWND hwnd, DWORD dwSchedInstallTime)
{
	HWND hComboHrs = GetDlgItem(hwnd,IDC_CMB_HOURS);
    DWORD dwCurrentIndex = 3;
	SYSTEMTIME st = {2000, 1, 5, 1, 0, 0, 0, 0};	// 01/01/2000 00:00:00 can be any valid date/time

	for (WORD i = 0; i < 24; i++)
	{
		TCHAR tszHrs[30];

		st.wHour = i;
		if (!Hours2LocalizedString(&st, tszHrs, ARRAYSIZE(tszHrs)))
		{
			return FALSE;
		}
		LRESULT nIndex = SendMessage(hComboHrs,CB_ADDSTRING,0,(LPARAM)tszHrs);
		SendMessage(hComboHrs,CB_SETITEMDATA,nIndex,i);
		if( dwSchedInstallTime == i )
		{
			dwCurrentIndex = (DWORD)nIndex;
		}
	}
	SendMessage(hComboHrs,CB_SETCURSEL,dwCurrentIndex,(LPARAM)0);
	return TRUE;
}


BOOL FillDaysCombo(HINSTANCE hInstance, HWND hwnd, DWORD dwSchedInstallDay, UINT uMinResId, UINT uMaxResId)
{
	HWND hComboDays = GetDlgItem(hwnd,IDC_CMB_DAYS);
	DWORD dwCurrentIndex = 0;
	for (UINT i = uMinResId, j = 0; i <= uMaxResId; i ++, j++)
	{
		WCHAR szDay[40];
		LoadStringW(hInstance,i,szDay,ARRAYSIZE(szDay));
		LRESULT nIndex = SendMessage(hComboDays,CB_ADDSTRING,0,(LPARAM)szDay);
		SendMessage(hComboDays,CB_SETITEMDATA,nIndex,j);
		if( dwSchedInstallDay == j )
		{
			dwCurrentIndex = (DWORD) nIndex;
		}
	}
	SendMessage(hComboDays,CB_SETCURSEL,dwCurrentIndex,(LPARAM)0);
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\wuaulib\pch.h ===
//#pragma warning( push, 3 )
#include <stdio.h>
#include <tchar.h>
#include <limits.h>
#include <windows.h>
#include <malloc.h>
#include <shlwapi.h>
#include "memutil.h"
#include "criticalfixreg.h"
#include "wuauengi.h"
#include <stdarg.h>
#include <shlobj.h>
#include "WUTestKeys.h"
#include "auwait.h"
#include "auregkeys.h"
#include "wuaulib.h"
#include "aucatitem.h"
#include "schemamisc.h"
#include "audirectory.h"
#include "schemakeys.h"
#include "aubasecatalog.h"
#include "aucomres.h"
#include "aucompat.h"
#include "fileutil.h"
#include "wusafefn.h"
#include "MISTSafe.h"
//#pragma warning( pop )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuv3\wsdu\inc\mistsafe.h ===
//=======================================================================
//
//  Copyright (c) 2002 Microsoft Corporation.  All Rights Reserved.
//
//  File:    MISTSafe.h
//
//  Creator: PeterWi
//
//  Purpose: Definitions related to safe functions.
//
//=======================================================================

#pragma once
#define STRSAFE_NO_DEPRECATE

#include <strsafe.h>

// Flag you should add to your String* functions to safe fill behind
// the complete buffer in chk builds to help locate buffer problems.
// e.g. StringCchCopyEx(szDest, cchDest, szSrc, &pszDestEnd, &cchRemaining, MISTSAFE_STRING_FLAGS);

#ifdef DBG
#define MISTSAFE_STRING_FLAGS   STRSAFE_FILL_BEHIND_NULL
#else
#define MISTSAFE_STRING_FLAGS   STRSAFE_IGNORE_NULLS
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\wuaulib\wuaulib.h ===
//=======================================================================
//
//  Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:    wuaulib.h
//
//  Creator: PeterWi
//
//  Purpose: library function declarations.
//
//=======================================================================

#pragma once

#include <tchar.h>
#include <wchar.h>
#include <timeutil.h>
#include "WUTestKeys.h"

#define	ARRAYSIZE(x)			(sizeof(x)/sizeof(x[0]))

// Defs for boolean AU options
#define AUOPTION_UNSPECIFIED 				0
#define AUOPTION_AUTOUPDATE_DISABLE             1
#define AUOPTION_PREDOWNLOAD_NOTIFY             2
#define AUOPTION_INSTALLONLY_NOTIFY             3
#define AUOPTION_SCHEDULED                      4
#define AUOPTION_ADMIN_MIN						AUOPTION_AUTOUPDATE_DISABLE
#define AUOPTION_DOMAIN_MIN						AUOPTION_PREDOWNLOAD_NOTIFY
#define AUOPTION_MAX							AUOPTION_SCHEDULED

// download status 
#define DWNLDSTATUS_NOT_DOWNLOADING	0
#define DWNLDSTATUS_DOWNLOADING		1
#define DWNLDSTATUS_PAUSED			2
#define DWNLDSTATUS_CHECKING_CONNECTION	3

//////////////////////Client (WUAUCLT) exit codes //////////////////////////
#define CDWWUAUCLT_UNSPECIFY	-1
#define CDWWUAUCLT_OK			1000
#define CDWWUAUCLT_RELAUNCHNOW		1001
#define CDWWUAUCLT_RELAUNCHLATER		1002	//ask service to launch client 
#define CDWWUAUCLT_ENDSESSION	1003	// user logs off or system shuts down
#define CDWWUAUCLT_FATAL_ERROR	1004
#define CDWWUAUCLT_INSTALLNOW 	1005
#define CDWWUAUCLT_REBOOTNOW 	1007
#define CDWWUAUCLT_REBOOTLATER 	1008
#define CDWWUAUCLT_REBOOTNEEDED	1009 	//user hasn't made decision as weather to reboot or not
#define CDWWUAUCLT_REBOOTTIMEOUT 1010 //reboot warning dialog times out

//////////////////////Prompt Dlg defs//////////////////////////////////////
#define AUPROMPTDLG_TOTAL_TIME_ELAPSE AU_FIVE_MINS  // For 5 mins 300

//////////////////////No Active Admin Session found//////////////////////////
#define DWNO_ACTIVE_ADMIN_SESSION_FOUND				-1		// No Active Admin Session Found
#define DWNO_ACTIVE_ADMIN_SESSION_SERVICE_FINISHED  -2		// No Active Admin Sesion found due to Service Finishing or because caller routine needs to finish service
#define DWSYSTEM_ACCOUNT	-3



class AU_ENV_VARS {
public:
	static const int s_AUENVVARCOUNT = 6; 
	static const int s_AUENVVARBUFSIZE = 100;
	BOOL m_fRebootWarningMode ; //regular mode otherwise
	BOOL m_fEnableYes; //for reboot warning dialog
	BOOL m_fEnableNo; //for reboot warning dialog
	BOOL m_fManualReboot; //for reboot warning dialog
	DWORD m_dwStartTickCount; //for reboot warning dialog, in milli secs
	TCHAR m_szClientExitEvtName[s_AUENVVARBUFSIZE]; 
public:
	BOOL ReadIn(void);
	BOOL WriteOut(LPTSTR szEnvBuf, //at least size of 4*AUEVVARBUFSIZE
			size_t IN cchEnvBuf,
			BOOL IN fEnableYes = TRUE,
			BOOL IN fEnableNo = TRUE,
			BOOL IN fManualReboot = FALSE,
			DWORD IN dwStartTickCount = 0,
			LPCTSTR IN szClientExitEvtName = NULL);		
private:
	static const LPCTSTR s_AUENVVARNAMES[s_AUENVVARCOUNT];
	HRESULT GetStringValue(int index, LPTSTR buf, DWORD dwCchSize);			
	BOOL GetBOOLEnvironmentVar(LPCTSTR szEnvVar, BOOL *pfVal);
	BOOL GetDWordEnvironmentVar(LPCTSTR szEnvVar, DWORD *pdwVal);
	BOOL GetStringEnvironmentVar(LPCTSTR szzEnvVar, LPTSTR szBuf, DWORD dwSize);
};

//////////////// The following functions are all called from the outside! ///////////////////////

/////////////////////////////////////////////////////////////////////
// cfreg.cpp - Functions to handle registry keys
/////////////////////////////////////////////////////////////////////
BOOL    fRegKeyCreate(LPCTSTR tszKey, DWORD dwOptions);
BOOL fRegKeyExists(LPCTSTR tszSubKey, HKEY hRootKey = HKEY_LOCAL_MACHINE);

inline HRESULT String2FileTime(LPCTSTR pszDateTime, FILETIME *pft)
{
    SYSTEMTIME st;
    HRESULT hr = String2SystemTime(pszDateTime, &st);
    if ( SUCCEEDED(hr) )
    {
        if ( !SystemTimeToFileTime(&st, pft) )
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }

    return hr;
}

inline HRESULT FileTime2String(FILETIME & ft, LPTSTR pszDateTime, size_t cchSize)
{
    SYSTEMTIME st;
    HRESULT hr;

    if ( !FileTimeToSystemTime(&ft, &st) )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    else
    {
        hr = SystemTime2String(st, pszDateTime, cchSize);
    }

    return hr;
}

BOOL FHiddenItemsExist();
HRESULT setAddedTimeout(DWORD timeout, LPCTSTR strkey);
HRESULT getAddedTimeout(DWORD *pdwTimeDiff, LPCTSTR strkey);

extern const TCHAR	AUREGKEY_REBOOT_REQUIRED[]; // = _T("Software\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate\\Auto Update\\RebootRequired");

inline BOOL fSetRebootFlag(void)
{
	return fRegKeyCreate(AUREGKEY_REBOOT_REQUIRED, REG_OPTION_VOLATILE);
}
inline BOOL    fRegKeyDelete(LPCTSTR tszKey)
{
	return (ERROR_SUCCESS == RegDeleteKey(HKEY_LOCAL_MACHINE, tszKey));
}
inline BOOL fCheckRebootFlag(void)
{
	return fRegKeyExists(AUREGKEY_REBOOT_REQUIRED);
}

/////////////////////////////////////////////////////////////////////
// helpers.cpp
/////////////////////////////////////////////////////////////////////
DWORD getTimeOut();
HRESULT TimeAddSeconds(SYSTEMTIME tmBase, int iSeconds, SYSTEMTIME* pTimeNew);
inline void setTimeOut(DWORD dwTimeOut)            
{
	SetRegDWordValue(_T("TimeOut"), dwTimeOut);
}
BOOL IsRTFDownloaded(BSTR bstrRTFPath, LANGID langid);
BOOL FHiddenItemsExist(void);
BOOL RemoveHiddenItems(void);
void DisableUserInput(HWND hwnd);
BOOL Hours2LocalizedString(SYSTEMTIME *pst, LPTSTR ptszBuffer, DWORD cbSize);
BOOL FillHrsCombo(HWND hwnd, DWORD dwSchedInstallTime);
BOOL FillDaysCombo(HINSTANCE hInstance, HWND hwnd, DWORD dwSchedInstallDay, UINT uMinResId, UINT uMaxResId);
BOOL fAccessibleToAU(void);
BOOL IsWin2K(void);

extern const LPTSTR HIDDEN_ITEMS_FILE;

//////////////////////////////////////////////////////////////////////////////////////
// platform.cpp
//////////////////////////////////////////////////////////////////////////////////////
void GetOSName(LPTSTR _szOSName);
UINT  DetectPlatformID(void);
HRESULT GetOSVersionStr(LPTSTR tszbuf, UINT uSize);
BOOL fIsPersonalOrProfessional(void);
HRESULT GetFileVersionStr(LPCTSTR tszFile, LPTSTR tszbuf, UINT uSize);


const TCHAR g_szPropDialogPtr[]       = TEXT("AutoUpdateProp_DialogPtr");
const TCHAR g_szHelpFile[]            = _T("wuauhelp.chm::/auw2ktt.txt"); //TEXT("sysdm.hlp"); //used on both w2k and xp.
const TCHAR gtszAUOverviewUrl[] = _T("wuauhelp.chm"); //default
const TCHAR gtszAUW2kSchedInstallUrl[] = _T("wuauhelp.chm::/w2k_autoupdate_sched.htm");
const TCHAR gtszAUXPSchedInstallUrl[] = _T("wuauhelp.chm::/autoupdate_sched.htm");

const TCHAR REG_AUNOAUTOREBOOTWITHLOGGEDONUSERS[] = _T("NoAutoRebootWithLoggedOnUsers"); //REG_DWORD


//////////////////////////////////////////////////////////////////////////////////////
//                                      DEBUG STUFF                                 //
//////////////////////////////////////////////////////////////////////////////////////
#ifdef DBG

//===== DBG ==========================================================================

void _cdecl WUAUTrace(char* pszFormat, ...);

#define DEBUGMSG           WUAUTrace

inline BOOL fAUAssertBreak(void)
{
	static DWORD dwVal = -1;
	if (-1 != dwVal)
	{
		return 1 == dwVal;
	}
	if (FAILED(GetRegDWordValue(_T("AssertBreak"), &dwVal)))
	{ //if key is not there, don't read again and again
		dwVal = 0;
	}
	return 1 == dwVal;
}

#define AUASSERT(x)			{ if (!(x) && fAUAssertBreak()) DebugBreak();}

#else  // !DBG
//===== !DBG ==========================================================================

inline void _cdecl WUAUTrace(char* , ...) {}

#define DEBUGMSG          WUAUTrace
#define AUASSERT(x)			

#endif // DBG
//=====================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\wuaulib\itemlist.cpp ===
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       ItemList.cpp
//
//  Purpose:	AU Item List
//
//  Creator:	PeterWi
//
//  History:	08-27-01 	first created
//
//--------------------------------------------------------------------------
#include "pch.h"


//=======================================================================
//
//  AUCatalogItemList::Clear
//
//=======================================================================
void AUCatalogItemList::Clear(void)
{
    if ( NULL != pList )
    {
    	for ( DWORD index = 0; index < Count(); index++ )
		{
			delete pList[index];
		}
    }
    SafeFreeNULL(pList);
    uNum = 0;
}

UINT AUCatalogItemList::GetNum(DWORD dwSelectionStatus)
    {
	    UINT nNum = 0;
	    
        for ( UINT index = 0; index < Count(); index++ )
	    {
		    if ( dwSelectionStatus == operator[](index).dwStatus() )
		    {
			    nNum++;
		    }
	    }
        return nNum;
    }


void  AUCatalogItemList::DbgDump(void)
	{
#ifdef DBG
		DEBUGMSG("Iterating %d items in the list....", uNum);
		for (UINT i = 0; i < uNum; i++)
		{
			pList[i]->dump();
		}
		DEBUGMSG("Iterating item list done");
#endif
	}



//=======================================================================
//
//  AUCatalogItemList::Allocate(DWORD cItems)
//
//=======================================================================
HRESULT AUCatalogItemList::Allocate(DWORD cItems)
{
    HRESULT hr = S_OK;
    DWORD index = 0;

    Clear();

	//pList shouldn't be pointer to pointer
	pList = (AUCatalogItem**)malloc(cItems * sizeof(AUCatalogItem *));
	if ( NULL == pList )
	{
        hr = E_OUTOFMEMORY;
        goto done;
	}

	for ( index = 0; index < cItems; index++ )
	{
		pList[index] = (AUCatalogItem*) new AUCatalogItem;
		if ( NULL == pList[index] )
		{
			hr = E_OUTOFMEMORY;
                    goto done;
		}
	}
done:
    if (FAILED(hr))
    {
        for (DWORD i = 0; i < index; i++)
        {
            delete pList[i];
        }
        free(pList);        
    }
        
    uNum = SUCCEEDED(hr) ? cItems : 0;
	return hr;
}


//=======================================================================
//
//  AUCatalogItemList::Allocate(VARIANT & var)
//
//=======================================================================
HRESULT AUCatalogItemList::Allocate(VARIANT & var)
{
    HRESULT hr = S_OK;
	long UBound = 0;
    long cItems;

	if ( ((VT_ARRAY | VT_VARIANT) != var.vt) ||
		 FAILED(SafeArrayGetUBound(var.parray, 1, &UBound)) /*| (0 != (++cItems % 7))*/ )
	{
		// temp
		DEBUGMSG("Invalid array");
             hr = E_INVALIDARG;
             goto done;
	}

    cItems = (UBound + 1) / 7;
    DEBUGMSG("Variant Array size of %d", UBound + 1);

    hr = Allocate(cItems);
done:
	return hr;
}


//=======================================================================
//
//  AUCatalogItemList::Add
//
//=======================================================================
BOOL AUCatalogItemList::Add(AUCatalogItem *pitem)
{
	AUCatalogItem** pNewList = (AUCatalogItem**)realloc(pList, (uNum+1)*sizeof(AUCatalogItem *));

    BOOL fRet = (NULL != pNewList);

    if ( fRet )
    {
        pList = pNewList;
	    pList[uNum] = pitem;
	    uNum++;
    }

    return fRet;
}

//=======================================================================
//
//  AUCatalogItemList::Remove
//
//=======================================================================
void AUCatalogItemList::Remove(BSTR bstrItemID)
{
    int index = -1;
    AUASSERT(NULL != bstrItemID);
    AUASSERT(L'\0' != *bstrItemID);
    if (0 == SysStringLen(bstrItemID))
    {
    	return ;
    }
    for (UINT u = 0; u < uNum; u++)
        {
            if (0 == StrCmpI(W2T(bstrItemID), W2T(pList[u]->bstrID())))
            {
                index = u;
                break;
            }
        }
    if (-1 == index)
        {
            //DEBUGMSG("Fail to find the item to remove");
            return;
        }
    AUCatalogItem *ptmp;
    ptmp = pList[index];
    pList[index] = pList[uNum-1];
    delete ptmp;
    uNum--;
    return;
}

//=======================================================================
//
//  AUCatalogItemList::Contains
//  returns -1 if item not found. index of the item if it is found
//=======================================================================
INT AUCatalogItemList::Contains(BSTR bstrItemID)
{
  for (UINT u = 0; u < uNum; u++)
        {
            if (0 == StrCmpI(W2T(bstrItemID), W2T(pList[u]->bstrID())))
            {
                return u;
            }
        }
    return -1;
}

HRESULT AUCatalogItemList::Copy(AUCatalogItemList & itemlist2)
{
	AUASSERT(this != &itemlist2);
	if (this == &itemlist2)
	{
		return E_INVALIDARG;
	}
    long lNum = itemlist2.Count();
    HRESULT hr = S_OK;
    Clear();
    for (long l = 0; l < lNum; l++)
    {
        AUCatalogItem *pItem = new AUCatalogItem(itemlist2[l]);
        if ( NULL == pItem)
        {
            DEBUGMSG("Fail to create new aucatalog item");
            hr = E_OUTOFMEMORY;
            break;
        }
        if (!pItem->fEqual(itemlist2[l]) || !Add(pItem))
        {
        	DEBUGMSG("Fail to create new item or add the new item");
        	delete pItem;
        	hr = E_OUTOFMEMORY;
        	break;
        }
    }
	if (FAILED(hr))
	{
		Clear();
	}
    return hr;
}

//////////////////////////////////////////////////////////////////////////////
// walk through each item in the list and use the m_DependentItems information to 
// find all dependent items each item depends on indirectly, add them to m_DependentItems 
// list. 
/////////////////////////////////////////////////////////////////////////////
HRESULT AUCatalogItemList::BuildIndirectDependency()
{
    HRESULT hr = S_OK ;
    BOOL fNeedMoreScan;

//    DEBUGMSG("AUCatalogItemList::BuildIndirectDependency() starts");
    do
    {
        fNeedMoreScan = FALSE;
        for (UINT i = 0; i < uNum; i++)
            {
            if (pList[i]->m_DependingItems.Count() > 0)
                {//has direct depending items
                AUCatalogItem & item =operator[](i);
                for (UINT j = 0; j < item.m_DependingItems.Count() ; j++)
                    {
                     INT directDependingItemIndex = Contains(item.m_DependingItems[j].bstrID());
                     if (directDependingItemIndex < 0)
                        {
                            DEBUGMSG("WARNING: item list is not self contained");
                            continue;
                        }
                     AUCatalogItem & directDependingItem = operator[](directDependingItemIndex);
    //                 DEBUGMSG("direct depending item %S has %d depending items", directDependingItem.bstrID(), directDependingItem.m_DependingItems.Count());
                     for (UINT k = 0; k < directDependingItem.m_DependingItems.Count(); k++)
                        { //add all one level deep indirect depending items, if not duplicated
                            INT indirectDependingItemIndex = Contains(directDependingItem.m_DependingItems[k].bstrID());
                            if (indirectDependingItemIndex < 0)
                                {
                                DEBUGMSG("WARNING: item list is not self contained");
                                continue;
                                }
                            AUCatalogItem &indirectDependingItem = operator[](indirectDependingItemIndex);
                            if (item.m_DependingItems.Contains(indirectDependingItem.bstrID()) < 0)
                                { // need to add the indirect depending item
                                    AUCatalogItem * pnewdependingItem = new AUCatalogItem(indirectDependingItem);
                                    if (NULL == pnewdependingItem)
                                        {
                                            hr = E_OUTOFMEMORY;
                                            goto done;
                                        }
                                    if (!pnewdependingItem->fEqual(indirectDependingItem) || !item.m_DependingItems.Add(pnewdependingItem))
                                    {
                                    	delete pnewdependingItem;
                                    	hr = E_OUTOFMEMORY;
                                    	goto done;
                                    }
                                    
                                    DEBUGMSG("item %S indirectly depending on item %S. Dependency recorded", indirectDependingItem.bstrID(), item.bstrID());
                                    fNeedMoreScan = TRUE;
                               }
                            else
                                {
        //                        DEBUGMSG("item %d indirect dependency alreay in", i);
                                }
                        }
                    }
                }
            }
    }
    while (fNeedMoreScan);
done:
//    DEBUGMSG("AUCatalogItemList::BuildIndirectDependency() ends with result %#lx", hr);
	if (FAILED(hr))
	{
		for (UINT i = 0; i < Count(); i++)
		{
			pList[i]->m_DependingItems.Clear();
		}
	}

    return hr;
}



//////////////////////////////////////////////////////////////////////////////
// check if item indexed is relevant in downloading and installation
// i.e. one or more of its depending items needs to be downloaded or installed (a.k.a selected)
//////////////////////////////////////////////////////////////////////////////
BOOL  AUCatalogItemList::ItemIsRelevant(UINT index) 
{
	if (index >= uNum)
	{
		AUASSERT(FALSE);  //should never be here
		return FALSE;
	}
    for (UINT i = 0;  i < pList[index]->m_DependingItems.Count(); i++)
        {
            AUCatalogItem & dependingItem = pList[index]->m_DependingItems[i];
            INT index2 = Contains(dependingItem.bstrID());
            if (index2 >= 0 && pList[index2]->fSelected())
                {
                    DEBUGMSG("Item %S is relevant because item %S is selected", pList[index2]->bstrID(), dependingItem.bstrID());
                    return TRUE;
                }
        }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\wuauserv\wuauserv.cpp ===
// wuauserv.cpp
#include <windows.h>
#include <ausvc.h>
#include <wusafefn.h>


typedef HRESULT (WINAPI *AUSERVICEMAIN)(DWORD dwNumServicesArg,
											   LPWSTR *lpServiceArgVectors,
											   AUSERVICEHANDLER pfnServiceHandler,
											   BOOL fJustSelfUpdated);

AUSERVICEMAIN		g_pfnServiceMain = NULL;
AUSERVICEHANDLER	g_pfnServiceHandler = NULL;
AUGETENGSTATUS      g_pfnGetEngineStatusInfo = NULL;
AUREGSERVICEVER     g_pfnRegisterServiceVersion = NULL;
BOOL				g_fCSInited = FALSE;
CRITICAL_SECTION    csWuaueng; 


BOOL APIENTRY DllMain(HINSTANCE hinstDLL, 
                      DWORD  dwReason, 
                      LPVOID lpReserved)
{
    switch(dwReason)
	{
		case DLL_PROCESS_ATTACH:
			DisableThreadLibraryCalls(hinstDLL);
			g_fCSInited = SafeInitializeCriticalSection(&csWuaueng);
			break;

		case DLL_PROCESS_DETACH:
			if(g_fCSInited)
			{
				DeleteCriticalSection(&csWuaueng);
			}
			break;

		//case DLL_THREAD_ATTACH:
		//case DLL_THREAD_DETACH:
    }
    return TRUE;
}



DWORD WINAPI ServiceHandler(DWORD fdwControl, DWORD dwEventType, LPVOID pEventData, LPVOID lpContext)
{
	DWORD dwRet = NOERROR;

	EnterCriticalSection(&csWuaueng);

	if ( NULL != g_pfnServiceHandler )
	{
		dwRet = g_pfnServiceHandler(fdwControl, dwEventType, pEventData, lpContext);
	}
	else
	{
		dwRet = ERROR_CALL_NOT_IMPLEMENTED;
	}

	LeaveCriticalSection(&csWuaueng);

	return dwRet;
}


void WINAPI ServiceMain(DWORD dwNumServicesArg, LPWSTR *lpServiceArgVectors)
{
	HRESULT hr = S_OK;
	HMODULE hModule = NULL;
    AUENGINEINFO_VER_1 engineInfo;
    DWORD dwEngineVersion = 0;
    BOOL fCompatibleEngineVersion = FALSE;
	
	//If Initialization of the CS failed in DllMain, bail out
    if (!g_fCSInited)
	{
		return;
	}
	do
	{
	    EnterCriticalSection(&csWuaueng); 

        fCompatibleEngineVersion = FALSE;
        g_pfnServiceHandler = NULL;
	    g_pfnGetEngineStatusInfo = NULL;
    	g_pfnRegisterServiceVersion = NULL;

		// check if we need to release wuaueng.dll
		if ( (S_FALSE == hr) && !FreeLibrary(hModule) )
		{
			hr = E_FAIL;
			hModule = NULL;
			g_pfnServiceMain = NULL;
			g_pfnServiceHandler = NULL;
		}
		else
		{
			// if we can't load wuaueng.dll, we fail to start
			if ( (NULL == (hModule = LoadLibraryFromSystemDir(TEXT("wuaueng.dll")))) ||
				 (NULL == (g_pfnServiceMain = (AUSERVICEMAIN)::GetProcAddress(hModule, "ServiceMain"))) ||
				 (NULL == (g_pfnServiceHandler = (AUSERVICEHANDLER)::GetProcAddress(hModule, "ServiceHandler"))) )
			{
				 hr = E_FAIL;
				 g_pfnServiceMain = NULL;
				 g_pfnServiceHandler = NULL;
			}
            else    //wuaueng.dll successfully loaded, check to see if the engine supports following entry points
            {
                if ( (NULL != (g_pfnRegisterServiceVersion = (AUREGSERVICEVER)::GetProcAddress(hModule, "RegisterServiceVersion"))) &&
                     (NULL != (g_pfnGetEngineStatusInfo = (AUGETENGSTATUS)::GetProcAddress(hModule, "GetEngineStatusInfo"))) )
                {
                    fCompatibleEngineVersion = TRUE;
                }
                      
            }
		}

		LeaveCriticalSection(&csWuaueng);

		if ( SUCCEEDED(hr) )
		{
            if (fCompatibleEngineVersion)
            {
                // Register service version with engine and check if engine supports the service version
                fCompatibleEngineVersion = g_pfnRegisterServiceVersion(AUSRV_VERSION, &dwEngineVersion);
            }            

			hr = g_pfnServiceMain(dwNumServicesArg, lpServiceArgVectors, ServiceHandler, 
									  (S_FALSE == hr) ? TRUE: FALSE /* we just reloaded wuaueng.dll */);
            
            if(fCompatibleEngineVersion)
            {
                //The engine service main has exited, set the service status to SERVICE_STOP_PENDING
                fCompatibleEngineVersion = g_pfnGetEngineStatusInfo((void*)&engineInfo);
            }
        }
	} while ( S_FALSE == hr );

    EnterCriticalSection(&csWuaueng); 

	if ( NULL != hModule )
	{
		FreeLibrary(hModule);
	}
    g_pfnServiceHandler = NULL;
    g_pfnGetEngineStatusInfo = NULL;
    g_pfnRegisterServiceVersion = NULL;
    g_pfnServiceMain = NULL;

	LeaveCriticalSection(&csWuaueng);
	
    if(fCompatibleEngineVersion)
    {
        //stop the service
        engineInfo.serviceStatus.dwCurrentState = SERVICE_STOPPED;
        SetServiceStatus(engineInfo.hServiceStatus, &engineInfo.serviceStatus);
    }

	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuv3\cdmlib\sources.inc ===
!IF 0

  Copyright (c) 1998-1999 Microsoft Corporation.  All Rights Reserved.

  File:   source

  Owner:  YanL

  Description:

      cdmlib.lib sources

!ENDIF

MAJORCOMP =WU
MINORCOMP =cdmlib
TARGETNAME=cdmlib
TARGETPATH=$(_OBJ_DIR)
TARGETTYPE=LIBRARY
INCLUDES  =.; ..\..\cdminc
USE_STATIC_ATL=1
#we'll define these in the ANSI and UNICODE dirs
#C_DEFINES=/D_UNICODE /DUNICODE
USE_MSVCRT=1
USE_STL=1

SOURCES   = \
	..\download.cpp  \
	..\diamond.cpp  \
	..\findoem.cpp  \
	..\bucket.cpp   \
	..\DrvInfo.cpp  \
	..\newtrust.cpp \
	..\calccrc.cpp \
	..\usecrc.cpp \
	..\log.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuv3\wsdu\inc\filecrc.h ===
//=======================================================================
//
//  Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:    filecrc.h
//
//  Purpose: Calculating and using CRC for files
//
//=======================================================================
#ifndef _FILECRC_H
#define _FILECRC_H

// size of the CRC hash in bytes
const int WUCRC_HASH_SIZE =  20;


// binary structure to hold the hash
struct WUCRC_HASH
{
    BYTE HashBytes[WUCRC_HASH_SIZE];
};


struct WUCRCMAP
{
	DWORD dwKey;
	WUCRC_HASH CRC;
};


HRESULT CalculateFileCRC(LPCTSTR pszFN, WUCRC_HASH* pCRC);

HRESULT StringFromCRC(const WUCRC_HASH* pCRC, LPTSTR pszBuf, int cbBuf);

HRESULT CRCFromString(LPCSTR pszCRC, WUCRC_HASH* pCRC);

HRESULT SplitCRCName(LPCSTR pszCRCName, WUCRC_HASH* pCRC, LPSTR pszName);

HRESULT MakeCRCName(LPCTSTR pszFromName, const WUCRC_HASH* pCRC, LPTSTR pszToName, int cbToName);

HRESULT GetCRCNameFromList(int iNo, PBYTE pmszCabList, PBYTE pCRCList, LPTSTR pszCRCName, int cbCRCName, LPTSTR pszCabName);

int __cdecl CompareWUCRCMAP(const void* p1, const void* p2);


class CCRCMapFile
{
public:
	CCRCMapFile(const BYTE* pMemData, DWORD dwMemSize);

	HRESULT GetValue(DWORD dwKey, WUCRC_HASH* pCRC);
	HRESULT GetCRCName(DWORD dwKey, LPCTSTR pszFromName, LPTSTR pszToName, int cbToName);

private:
	CCRCMapFile() {}  // cannot use default constructor

	WUCRCMAP* m_pEntries;
	DWORD m_cEntries;
};


#endif // _FILECRC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuv3\wsdu\inc\log.h ===
//=======================================================================
//
//  Copyright (c) 1998-1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:   log.h
//
//  Original Author:  Yan Leshinsky
//
//  Description:
//
//      Logging support
//
//=======================================================================
#pragma once
#include <stdio.h>

#if 1

	#ifndef LOGGING_LEVEL
		#define LOGGING_LEVEL 0
	#endif

	const DWORD MAX_FORMATTED_STRING = 1024;
	class CLogger
	{
	public:
		CLogger(const char* szBlockName = 0, int nLoggingLevel = 0, const char* szFileName = 0, int nLine = 0);
		~CLogger();
		void __cdecl out(const char *szFormat, ...);
		void __cdecl error(const char *szFormat, ...);
		static void __cdecl out1(const char *szFormat, ...);

	private:
		void v_out( const char* szFormat, va_list va);

		bool m_fOut;
		char m_szBlockName[64];
		DWORD m_dwStartTick;
		
		static FILE* c_pfile;
		static int c_cnIndent;
		static int c_cnLevels;
	};

	#define THIS_FILE          		__FILE__
	#define LOG_block(name)			CLogger logger(name, LOGGING_LEVEL, THIS_FILE, __LINE__)
	#define LOG_out					logger.out
	#define LOG_out1				CLogger::out1
	#define LOG_error				logger.error
#ifdef _UNICODE
	#define return_if_false(f)			if (f) {/*OK*/} else {  LOG_error("%S LastError = %d", #f, GetLastError()); return false;}
	#define return_error_if_false(f)	if (f) {/*OK*/} else { DWORD dwErr = GetLastError(); LOG_error("%S LastError = %d", #f, dwErr); return dwErr;}
	#define return_if_error(f)			{ DWORD dwErr = f; if (dwErr) { LOG_error("%S LastError = %d", #f, dwErr); return dwErr;} }
#else
	#define return_if_false(f)			if (f) {/*OK*/} else { LOG_error("%s LastError = %d", #f, GetLastError()); return false;}
	#define return_error_if_false(f)	if (f) {/*OK*/} else { DWORD dwErr = GetLastError(); LOG_error("%s LastError = %d", #f, dwErr); return dwErr;}
	#define return_if_error(f)			{ DWORD dwErr = f; if (dwErr) { LOG_error("%s LastError = %d", #f, dwErr); return dwErr;} }
#endif																											

#else
	#define LOG_block(name)
	inline void __cdecl ___LOG(const char *szFormat, ...){}
	#define LOG_out					true ? (void)0 : ___LOG
	#define LOG_out1				true ? (void)0 : ___LOG
	#define LOG_error				true ? (void)0 : ___LOG

	#define return_if_false(f)			if (f) {/*OK*/} else { return false;}
	#define return_error_if_false(f)	if (f) {/*OK*/} else { return GetLastError(); }
	#define return_if_error(f)			{ DWORD dwErr = f; if (dwErr) { return dwErr;} }

#endif	
#define tab_out(){if(c_pfile){ for(int i = 0; i < c_cnIndent; i ++)	{_fputtc(_T('\t'),c_pfile);}}}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuv3\wsdu\inc\wubldnum.h ===
#define VER_PRODUCTBUILD_QFE /* WU */ 5
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuv3\wsdu\inc\wutestkeys.h ===
#pragma once
#include "timeutil.h"
/***********************************************************************************************************
// This API returns true if a WU Test authorization file exists.
// The api looks for the input file name (lpszFileName) in the WindowsUpdate directory
// The test file has to have the same name as the cab file and should end with the '.txt' extension.
// Moreover it has to be an ascii file. The cab file has to be signed with a valid MS cert.
// This function will delete the extracted text file
************************************************************************************************************/
BOOL WUAllowTestKeys(LPCTSTR lpszFileName);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuv3\wsdu\inc\v3stdlib.h ===
/*
 * v3stdlib.h - definitions/declarations for shared functions for the V3 catalog
 *
 *  Copyright (c) 1998-1999 Microsoft Corporation.  All Rights Reserved.
 *
 */

#ifndef _INC_V3STDLIB
#define _INC_V3STDLIB

//
// memory management wrappers
//
void *V3_calloc(size_t num,	size_t size);

void V3_free(void *p);

void *V3_malloc(size_t size);

void *V3_realloc(void *memblock, size_t size);

const char* strcpystr(const char* pszStr, const char* pszSep, char* pszTokOut);


// V3 Directory Management Functions
BOOL V3_CreateDirectory(LPCTSTR pszDir);
BOOL GetWindowsUpdateDirectory(LPTSTR pszPath, DWORD dwBuffLen);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuv3\wsdu\inc\newtrust.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1998, 1999, 2000 Microsoft Corporation.  All Rights Reserved.
//
//	SYSTEM:		Windows Update Critical Fix Notification
//
//	CLASS:		N/A
//	MODULE:		MS Cab Trusting Function Header
//	FILE:		NewTrust.h
//
/////////////////////////////////////////////////////////////////////
//
//	DESC:	this header file declares functions used to make Microsoft
//			signed cab trusted.
//
//	AUTHOR:	Alessandro Muti, Windows Update Team
//	DATE:	3/11/1999
//
/////////////////////////////////////////////////////////////////////
//
//	Revision History:
//
//	Date	    Author			Description
//	~~~~	    ~~~~~~			~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//	10/17/2000  Nick Dallett    Porting Charlma's new cert-checking code from SLM tree:
// (8/31/2000	charlma			Changed to only publish VerifyFile())
//
//
/////////////////////////////////////////////////////////////////////
//
//     	(c) Copyrights:   1998, 1999, 2000 Microsoft Corporation 
//
//    	All rights reserved.
//
//     	No portion of this source code may be reproduced
//     	without express written permission of Microsoft Corporation.
//
//     	This source code is proprietary and confidential.
/////////////////////////////////////////////////////////////////////
//

#ifndef __NEWTRUST_HEADER
#define __NEWTRUST_HEADER



//HRESULT CheckWinTrust(LPCTSTR pszFileName, DWORD dwUIChoice);
//HRESULT CheckMSCert(LPCTSTR pszFileName);

#include <wintrust.h>
/////////////////////////////////////////////////////////////////////////////
// 
// Public Function VerifyFile()
//
// This is a wrapper function for CheckWinTrust that both Whistler 
// and WU classic code should use.
//
// Input:	szFileName - the file with complete path
//			fShowBadUI - whether pop up UI in cases 
//						 (1) inproperly signed signature, or
//						 (2) properly signed with a non-MS cert
//
// Return:	HRESULT - S_OK the file is signed with a valid MS cert
//					  or error code.
//					  If the file is signed correctly but cert is not
//					  a known Microsoft cert included in this feature, then
//					  CERT_UNTRUSTED_ROOT is returned.
//
// Good Cert: Here is the deifnition of a good cert, in addition to the fact
//			  that the signature must be valid and not expired.
//				(1) The signature was signed with a cert that has 
//					"Microsoft Root Authority" as root, or
//				(2) The signature was signed with one of the following known
//					Microsoft cert's (they are not rooted to MS)
//					* Microsoft Corporation
//					* Microsoft Corporation MSN
//					* MSNBC Interactive News LLC
//					* Microsoft Corporation MSN (Europe)
//					* Microsoft Corporation (Europe)
//
// Note:	If _WUV3TEST flag is set (for test build), then fShowBadUI is
//			ignored:
//				if reg key SOFTWARE\Microsoft\Windows\CurrentVersion\WindowsUpdate\wuv3test\WinTrustUI
//				is set to 1, then no UI is shown, and this function always return S_OK;
//				otherwise, UI always show no matter what cert, and return value is same
//				as the live build.
//
/////////////////////////////////////////////////////////////////////////////

HRESULT VerifyFile(IN LPCTSTR szFileName, BOOL fShowBadUI = TRUE);
						
#endif //__NEWTRUST_HEADER
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuv3\wsdu\inc\timeutil.h ===
#pragma once
#include <windows.h>
#include <tchar.h>
#include <stdlib.h>
#include <limits.h>
#include <mistsafe.h>

const TCHAR EOS = _T('\0');
const WCHAR WEOS = L'\0';
const int NanoSec100PerSec = 10000000;      // number of 100 nanoseconds per second

////////////////////////////////////////////////////////////////////////////
//
// Function  TimeDiff(tm1, tm2)
//          helper function to find the difference (in seconds) of 2 system times
//
// Input:   2 SYSTEMTIME structures
// Output:  None
// Return:  seconds of difference
//              > 0 if tm2 is later than tm1
//              = 0 if tm2 and tm1 are the same
//              < 0 if tm2 is earlier than tm1
//
// On error the function returns 0 even if the two times are not equal
//
// Comment: If the number of seconds goes beyond INT_MAX (that is 
//          more than 24,855 days, INT_MAX is returned.
//          If the number of seconds goes beyond INT_MIN (a negative value,
//          means 24,855 days ago), INT_MIN is returned.
//
////////////////////////////////////////////////////////////////////////////
int TimeDiff(SYSTEMTIME tm1, SYSTEMTIME tm2);


////////////////////////////////////////////////////////////////////////////
//
// Function  TimeAddSeconds(SYSTEMTIME, int, SYSTEMTIME* )
//          helper function to calculate time by adding n seconds to 
//          the given time.
//
// Input:   a SYSTEMTIME as base time, an int as seconds to add to the base time
// Output:  new time
// Return:  HRESULT
//
////////////////////////////////////////////////////////////////////////////
HRESULT TimeAddSeconds(SYSTEMTIME tmBase, int iSeconds, SYSTEMTIME* pTimeNew);


//Function to convert a string buffer to system time
HRESULT String2SystemTime(LPCTSTR pszDateTime, SYSTEMTIME *ptm);

//Function to convert a system time structure to a string buffer
HRESULT SystemTime2String(SYSTEMTIME & tm, LPTSTR pszDateTime, size_t cSize);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuau\wuaulib\xmllog.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       auxml.cpp
//
//  About:  source file for AU related XML and schema data structure and functions
//--------------------------------------------------------------------------
#include "pch.h"

#if 0
HRESULT MYLoadXMLDoc(BSTR bstrXml, IXMLDOMDocument** ppDoc) //always offline
{
	HRESULT	hr;
	VARIANT_BOOL fSuccess ;

//       DEBUGMSG("MYLoadXMLDoc starts");
 	hr = CoCreateInstance(__uuidof(DOMDocument),
 	                                        NULL,
 	                                        CLSCTX_INPROC_SERVER,
 	                                        __uuidof( IXMLDOMDocument),
						  (void **) ppDoc);
      if (FAILED(hr))
	{
	        DEBUGMSG("Warning: Fail to create DOM document with error %#lx", hr);
            	goto done;
	}
	if (FAILED(hr = (*ppDoc)->put_validateOnParse(VARIANT_FALSE)) ||
	    FAILED(hr = (*ppDoc)->put_resolveExternals(VARIANT_FALSE)) ||
	    FAILED(hr = (*ppDoc)->put_async(VARIANT_FALSE)))
	{
	       DEBUGMSG("Warning: Fail to set document properties with error %#lx", hr);
		SafeRelease(*ppDoc);
        	goto done;
	}

	//
	// load the XML Doc from input string
	//
       if (S_OK != (hr = (*ppDoc)->loadXML(bstrXml, &fSuccess)))
	{
	       DEBUGMSG("Warning: Fail to load document with error %#lx", hr);
		SafeRelease(*ppDoc);
	}

       if (S_FALSE == hr)
        {
            hr = E_FAIL;
        }

done:
    //   DEBUGMSG("MYLoadXMLDoc ends");
       return hr;
       
}
#endif


#ifdef DBG 
void LOGFILE(LPTSTR szFileName, BSTR bstrMessage)
{
//    USES_CONVERSION;
       TCHAR szLogFile[MAX_PATH] ;
       AUASSERT(_T('\0') != g_szWUDir[0]);
	   if (FAILED(StringCchCopyEx(szLogFile, ARRAYSIZE(szLogFile), g_szWUDir, NULL, NULL, MISTSAFE_STRING_FLAGS)) ||
           FAILED(StringCchCatEx(szLogFile, ARRAYSIZE(szLogFile), szFileName, NULL, NULL, MISTSAFE_STRING_FLAGS)))
	   {
            DEBUGMSG("file name and path too long");
            return;
       }
	HANDLE hFile = CreateFile(szLogFile, GENERIC_WRITE, NULL, NULL, CREATE_ALWAYS, NULL, NULL);
	if (INVALID_HANDLE_VALUE == hFile)
	{
		DEBUGMSG("Fail to create file %S", T2W(szLogFile));
		return;
	}
		
	DWORD dwBytesWritten;
    BYTE bMagic1 = 0xff;
    BYTE bMagic2 = 0xfe;
	if (!WriteFile(hFile, &bMagic1, sizeof(bMagic1), &dwBytesWritten, NULL) ||
	    !WriteFile(hFile, &bMagic2, sizeof(bMagic2), &dwBytesWritten, NULL) ||
	    !WriteFile(hFile, bstrMessage, SysStringByteLen(bstrMessage), &dwBytesWritten, NULL))
	{
		DEBUGMSG("Fail to write to file %S with error %d", T2W(szLogFile), GetLastError());
	}
	CloseHandle(hFile);
	return;
}
#endif


HRESULT  LOGXMLFILE(LPCTSTR szFileName, BSTR bstrMessage)
{
    IXMLDOMDocument *pxml;
    HRESULT hr ;
    TCHAR szLogFile[MAX_PATH] ;

    if (NULL == szFileName)
    {	 //no logging needed
    	return E_INVALIDARG;
    }

	AUASSERT(_T('\0') != g_szWUDir[0]);
    if (FAILED(hr = StringCchCopyEx(szLogFile, ARRAYSIZE(szLogFile), g_szWUDir, NULL, NULL, MISTSAFE_STRING_FLAGS)) ||
		FAILED(hr = StringCchCatEx(szLogFile, ARRAYSIZE(szLogFile), szFileName, NULL, NULL, MISTSAFE_STRING_FLAGS)))
        {
            return hr;
        }

    CAU_BSTR aubsTmp;
    if (!aubsTmp.append(T2W(szLogFile)))
    {
    	return E_OUTOFMEMORY;
    }
    if (SUCCEEDED(hr = LoadXMLDoc(bstrMessage, &pxml)))
        {
            if (FAILED(hr = SaveDocument(pxml, aubsTmp)))
                {
                    DEBUGMSG("Warning: Fail to save xml file %S", T2W(szLogFile));
                }
            pxml->Release();
        }
    else
        {
            DEBUGMSG("Warning: fail to load ill formated xml with error %#lx", hr);
#ifdef DBG
            TCHAR szBadFileName[MAX_PATH+1];
            if (SUCCEEDED(StringCchCopyEx(szBadFileName, ARRAYSIZE(szBadFileName), szFileName, NULL, NULL, MISTSAFE_STRING_FLAGS)) &&
				SUCCEEDED(StringCchCatEx(szBadFileName, ARRAYSIZE(szBadFileName), _T(".xml"), NULL, NULL, MISTSAFE_STRING_FLAGS)))
			{
				LOGFILE(szBadFileName, bstrMessage);
			}
#endif
        }
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuv3\wsdu\inc\wuverp.h ===
//
// The purpose of this include file is to change the minor version number for
// Windows Update components from 1 (Whistler) to 4.
//
#include <windows.h>
#include <ntverp.h>

// Override ntverp.h
// Minor version 4 is Windows Update specific, Whistler is minor version 1.
#undef VER_PRODUCTMINORVERSION
#define VER_PRODUCTMINORVERSION     4

// Override the build number when the Windows Update build lab is building.
#ifdef VER_PRODUCTBUILD_QFE
#undef VER_PRODUCTBUILD_QFE
#include "wubldnum.h"
#endif

#undef VER_PRODUCTVERSION_STRING   
#define VER_PRODUCTVERSION_STRING   VER_PRODUCTVERSION_MAJORMINOR1(VER_PRODUCTMAJORVERSION, VER_PRODUCTMINORVERSION)

#undef VER_PRODUCTVERSION          
#define VER_PRODUCTVERSION          VER_PRODUCTMAJORVERSION,VER_PRODUCTMINORVERSION,VER_PRODUCTBUILD,VER_PRODUCTBUILD_QFE

#define WU_VER_FILEDESCRIPTION_STR(component) "Windows Update " component
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuv3\wsdu\inc\varray.h ===
//  Copyright (c) 1998-1999 Microsoft Corporation.  All Rights Reserved.

#ifndef _INC_ARRAY_TEMPLATE


	//If the Version 3 catalog standard library has been included then use its
	//memory allocation definations as these types include the correct error
	//handling.

	#define LOCALMALLOC(size)	V3_calloc(1, size)
	#define LOCALREALLOC(memblock, size)	V3_realloc(memblock, size)
	#define LOCALFREE(p)	V3_free(p)


	/*
	 * Variable Array Template
	 *
	 * This header defines a variable element array. This allows run time arrays
	 * of any size to be used with having to worry about managing the internal
	 * memory.
	 *
	 * For example:
	 *
	 * To use an array of longs declair Varray<long> x;
	 *
	 * You can then say x[50] = 5L; and the array will size itself to provide space for at least
	 * 50 longs.
	 *
	 * You can also specify an initial size in the constructor. So to create a variable array of
	 * class type Cfoo with an initial size of 50 you would declair Varray<Cfoo> x(50);
	 *
	 * To access the array simply use the array symbols in the first example you would write
	 * long ll = x[5]; to get the sixth element.
	 *
	 * Note: The array is 0 based.
	 *
	 * Also when memory for the template's internal storage is allocted it is not initialize in
	 * any manner. This means that a classes constructor is not called. It is the responsibility
	 * of the caller to have any classes that are placed into the array to already be initialized.
	 * 
	 */

	template <class TYPE> class Varray
	{
	public:
			Varray(int iInitialSize = 1);
			~Varray<TYPE>();
			inline TYPE &operator[]( int index );
			inline TYPE &Insert(int insertAt, int iElements);
			inline int SIZEOF(void);
			inline int LastUsed(void);
			//inline TYPE *operator &(); Note: To pass a pointer to the beginning
			//of the array simply use &array[0].
	private:
			TYPE	*m_pArray;
			int		m_iMaxArray;
			int		m_iMinAllocSize;
			int		m_iLastUsedArray;
	};

	/*
	 * Varray class constructor
	 *
	 * Constructs a dynamic size class array of the specified type.
	 *
	 * The array is initialized to have space for 1 element.
	 *
	 */

	template <class TYPE> Varray<TYPE>::Varray(int iInitialSize)
	{
		if ( iInitialSize <= 0 )
			iInitialSize = 1;

		m_pArray = (TYPE *)LOCALMALLOC(iInitialSize * sizeof(TYPE));

		m_iMaxArray			= 1;
		m_iMinAllocSize		= 1;
		m_iLastUsedArray	= -1;
	}

	/*
	 * Varray class destructor
	 *
	 * frees up the space used by a Varray
	 *
	 */

	template <class TYPE>Varray<TYPE>::~Varray()
	{
		if ( m_pArray )
			LOCALFREE( m_pArray );

		m_iMaxArray = 0;
		m_iMinAllocSize	= 1;
	}

	/*
	 * Varray operator [] handler
	 *
	 * Allows one to access the elements of a Varray. The array is resized
	 * as necessary to accomidate the number of elements needed.
	 *
	 *
	 * There are three cases that need to be handled by the allocation scheme.
	 * Sequential allocation this is where the caller is initializing an array
	 * in a sequential manner. We want to keep new requests to the memory
	 * allocator to a mimimum. Two is where the client asks for an array element
	 * far outside the currently allocated block size. Three when the client is
	 * using an element that is allready allocated.
	 * 
	 * This class's solution is to keep a block size count and double it. This
	 * keeps going up to a fixed size limit. The allocation occurs every time
	 * a new array allocation is required.
	 */

	template <class TYPE> inline TYPE &Varray<TYPE>::operator[]( int index )
	{
		int iCurrentSize;
		int	nextAllocSize;

		if ( index >= m_iMaxArray )
		{
			nextAllocSize = m_iMinAllocSize;
			if ( nextAllocSize < 512 )
				nextAllocSize = m_iMinAllocSize * 2;

			iCurrentSize = m_iMaxArray;

			if ( index - m_iMaxArray >= nextAllocSize )
				m_iMaxArray = index + 1;
			else
			{
				m_iMaxArray = m_iMaxArray + nextAllocSize;
				m_iMinAllocSize = nextAllocSize;
			}
			m_pArray = (TYPE *)LOCALREALLOC(m_pArray, m_iMaxArray * sizeof(TYPE));

			//clear out new cells
			memset(m_pArray+iCurrentSize, 0, (m_iMaxArray-iCurrentSize) * sizeof(TYPE));
		}

		if ( index > m_iLastUsedArray )
			m_iLastUsedArray = index;

		return (*((TYPE*) &m_pArray[index]));
	}

	template <class TYPE> inline TYPE &Varray<TYPE>::Insert(int insertAt, int iElements)
	{
		int	i;
		int iCurrentSize;

		iCurrentSize = m_iMaxArray;

		m_iMaxArray += iElements+1;

		m_pArray = (TYPE *)LOCALREALLOC(m_pArray, m_iMaxArray * sizeof(TYPE));

		for(i=iCurrentSize; i>=insertAt; i--)
			memcpy(&m_pArray[i+iElements], &m_pArray[i], sizeof(TYPE));

		//clear out new cells
		memset(m_pArray+insertAt, 0, iElements * sizeof(TYPE));

		return (*((TYPE*) &m_pArray[insertAt]));
	}

	/*
	 * Varray SIZEOF method
	 *
	 * The SIZEOF method returns the currently allocated size of the
	 * internal array.
	 */

	template <class TYPE> inline int Varray<TYPE>::SIZEOF(void)
	{
		return m_iMaxArray;
	}

	//Note: This method will be invalid after elements are inserted into the
	//varray. So use with caution.

	template <class TYPE> inline int Varray<TYPE>::LastUsed(void)
	{
		return m_iLastUsedArray;
	}

	#define _INC_ARRAY_TEMPLATE

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuv3\wsdu\wsdu\dynamic.h ===
// wininet function pointer defs
typedef HINTERNET (*PFN_InternetOpen)(IN LPCSTR lpszAgent, IN DWORD dwAccessType, IN LPCSTR lpszProxyName, 
    IN LPCTSTR lpszProxyBypass, IN DWORD dwFlags);

typedef HINTERNET (*PFN_InternetConnect)(IN HINTERNET hInternet, IN LPCSTR lpszServerName, IN INTERNET_PORT nServerPort,
    IN LPCSTR lpszUserName, IN LPCSTR lpszPassword, IN DWORD dwService, IN DWORD dwFlags, IN DWORD_PTR dwContext);

typedef HINTERNET (*PFN_HttpOpenRequest)(IN HINTERNET hConnect, IN LPCSTR lpszVerb, IN LPCSTR lpszObjectName, 
    IN LPCSTR lpszVersion, IN LPCSTR lpszReferrer, IN LPCSTR FAR * lplpszAcceptTypes, IN DWORD dwFlags, IN DWORD_PTR dwContext);

typedef BOOL (*PFN_HttpSendRequest)(IN HINTERNET hRequest, IN LPCSTR lpszHeaders, IN DWORD dwHeadersLength, 
    IN LPVOID lpOptional, IN DWORD dwOptionalLength);

typedef BOOL (*PFN_HttpQueryInfo)(IN HINTERNET hRequest, IN DWORD dwInfoLevel, IN OUT LPVOID lpBuffer, 
    IN OUT LPDWORD lpdwBufferLength, IN OUT LPDWORD lpdwIndex);

typedef BOOL (*PFN_InternetSetOption)(IN HINTERNET hInternet, IN DWORD dwOption, IN LPVOID lpBuffer, IN DWORD dwBufferLength);

typedef BOOL (*PFN_HttpAddRequestHeaders)(IN HINTERNET hConnect, IN LPCSTR lpszHeaders, IN DWORD dwHeadersLength,
    IN DWORD dwModifiers);

typedef BOOL (*PFN_InternetReadFile)(IN HINTERNET hFile, IN LPVOID lpBuffer, IN DWORD dwNumberOfBytesToRead,
    OUT LPDWORD lpdwNumberOfBytesRead);

typedef BOOL (*PFN_InternetCloseHandle)(IN HINTERNET hInternet);

typedef BOOL (*PFN_InternetCrackUrl)(IN LPCSTR lpszUrl, IN DWORD dwUrlLength, IN DWORD dwFlags, 
    IN OUT LPURL_COMPONENTSA lpUrlComponents);

typedef BOOL (*PFN_InternetGetConnectedState)(OUT LPDWORD dwFlags, IN DWORD dwReserved);

// shlwapi function pointer defs
typedef BOOL (*PFN_PathAppend)(LPSTR pszPath, LPCSTR pMore);

typedef BOOL (*PFN_PathRemoveFileSpec)(LPSTR pszPath);

// private function in wsdueng to set the estimated download speed
typedef void (*PFN_SetEstimatedDownloadSpeed)(DWORD dwBytesPerSecond);

// private function in wsdueng to set whether SSL is usable
typedef void (*PFN_SetIESupportsSSL)(BOOL fUseSSL);

// RogerJ --- add autodial function
typedef BOOL (*PFN_InternetAutodial) (IN DWORD dwFlags, IN HWND hParentWnd);

typedef BOOL (*PFN_InternetAutodialHangup) (IN DWORD dwReserved);
// DONE RogerJ



// callback function declaration
typedef struct 
{
    BOOL fHandled;
    BOOL fUnSupported;
    // char szDriverVer[32]; // not used
} PNPID_INFO, *PPNPID_INFO;

typedef BOOL (WINAPI * PWINNT32QUERY)(IN DWORD dwSetupQueryID, 
                                      IN PVOID pinData, 
                                      IN DWORD dwDataSize, 
                                      IN OUT PVOID poutData, 
                                      IN OUT PDWORD pdwDataSize);

#define SETUPQUERYID_PNPID 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuv3\wsdu\wsdu\log.cpp ===
#include "wsdu.h"

#define REGKEY_WUV3TEST     "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate\\wuv3test"

FILE* CLogger::c_pfile = stdout;
int CLogger::c_cnIndent = 0;
int CLogger::c_cnLevels = -1;

CLogger::CLogger(
    const char* szBlockName /*= 0*/, 
    int nLoggingLevel/*= 0*/, 
    const char* szFileName/*= 0*/, 
    int nLine/*= 0*/
) 
{
    if (-1 == c_cnLevels)
    {
        /*c_cnLevels = 0;
        HKEY hkey;
        if (NO_ERROR == RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGKEY_WUV3TEST, 0, KEY_READ, &hkey)) 
        {
            DWORD dwSize = sizeof(c_cnLevels);
            RegQueryValueEx(hkey, "LogLevel", 0, 0, (LPBYTE)&c_cnLevels, &dwSize);
            char szLogFile[MAX_PATH] = {0};
            dwSize = sizeof(szLogFile);
            RegQueryValueEx(hkey, "LogFile", 0, 0, (LPBYTE)&szLogFile, &dwSize);
            FILE* pfile = fopen(szLogFile, "at");
            if (pfile)
            {
                c_pfile = pfile;
            }
            RegCloseKey(hkey);
        }*/
        char sz_LogFileName[MAX_PATH];
        c_cnLevels = 4; // default to log level 4
        ExpandEnvironmentStrings(cszLoggingFile, sz_LogFileName, MAX_PATH);
        FILE* pfile = fopen(sz_LogFileName, "wt");
        if (pfile)
        {
            c_pfile = pfile;
            fprintf(c_pfile,"****************************************\n");
            SYSTEMTIME timeLocal;
            GetLocalTime(&timeLocal);
            fprintf(c_pfile,"%02d/%02d/%4d, %02d:%02d\n", timeLocal.wMonth, timeLocal.wDay, timeLocal.wYear, timeLocal.wHour, timeLocal.wMinute);
            fprintf(c_pfile,"****************************************\n");
        }
    }
    m_szBlockName[0] = 0;
    //m_fOut = nLoggingLevel < c_cnLevels;
    m_fOut = TRUE;
    if (m_fOut && NULL != szBlockName) 
    {
        lstrcpyn(m_szBlockName, szBlockName, ARRAYSIZE(m_szBlockName));
        //out("%s %s(%d)", szBlockName, szFileName, nLine);
        out ("%s",szBlockName);
        m_dwStartTick = GetTickCount();
        c_cnIndent ++;
    }
}

CLogger::~CLogger()
{
    if (c_pfile && m_fOut && NULL != m_szBlockName[0]) 
    {
        c_cnIndent --;
        out("~%s (%d msecs)", m_szBlockName, GetTickCount() - m_dwStartTick);
    }
}

void __cdecl CLogger::out(const char *szFormat, ...)
{
    if (m_fOut) 
    {
        va_list va;
        va_start (va, szFormat);
        v_out(szFormat, va);
        va_end (va);
    }
}

void __cdecl CLogger::error(const char *szFormat, ...)
{
    if (m_fOut) 
    {
        va_list va;
        va_start (va, szFormat);
        char szOut[4 * 1024];
        if (SUCCEEDED(StringCchVPrintf(szOut, ARRAYSIZE(szOut), szFormat, va)))
        {
            out("ERROR - %s", szOut);
        } 
        va_end(va);
    }
}

void __cdecl CLogger::out1(const char *szFormat, ...)
{
    CLogger logger;
    va_list va;
    va_start (va, szFormat);
    logger.v_out(szFormat, va);
    va_end (va);
}

void CLogger::v_out( const char* szFormat, va_list va)
{
    char szOut[5 * 1024];
    char* pszOut = szOut;
    // Indent first
    for(int i = 0; i < c_cnIndent; i ++)
        *(pszOut ++) = '\t';

    if (SUCCEEDED(StringCchVPrintf(pszOut, ARRAYSIZE(szOut), szFormat, va)))
    {
        // move the file pointer to the end
        if (0 == fseek(c_pfile, 0, SEEK_END))
        {
            fprintf(c_pfile, "%s\n", szOut);
            fflush(c_pfile);
        }
    }
}

void CLogger::close(void)
{
    if (c_pfile) fclose(c_pfile);
    c_pfile = NULL;
    c_cnLevels = -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuv3\wsdu\inc\wuv3.h ===
/*
 * wuv3.h - definitions/declarations for Windows Update V3 Catalog infra-structure
 *
 *  Copyright (c) 1998-1999 Microsoft Corporation.  All Rights Reserved.
 *
 * Purpose:
 *       This file defines the structures, values, macros, and functions
 *       used by the Version 3 Windows Update Catalog
 *
 */

#ifndef _WU_V3_CATALOG_INC

	#pragma pack(1)

	#define BLOCK

	typedef struct _WU_VERSION
	{
		WORD	major;		//major package version (5)
		WORD	minor;		//minor package version (0)
		WORD	build;		//build package version (2014)
		WORD	ext;		//additional version specification (216)
	} WU_VERSION, *PWU_VERSION;


	//The WU_HIDDEN_ITEM_FLAG is used to specify that the item should be hidden even
	//if it would normally detect as available.

	#define WU_HIDDEN_ITEM_FLAG			((BYTE)0x02)

	//The following defines are used for the inventory catalog record's variable type fields.

	//The WU_VARIABLE_END field is the only required field variable field. It is used to signify
	//that there are no more variable fields associated with an inventory record.
	#define	WU_VARIABLE_END						((short)0)

	// An array of CRC hash structs (WUCRC_HASH) for each CAB file name specified in WU_DESCRIPTION_CABFILENAME
	// in the same order.
	#define WU_DESC_CRC_ARRAY               (short)61

	//
	// These values are written into the bitmask.plt file as the platform ids. When additional
	// platforms are added we will need to add a new enumeration value here.
	//
	// IMPORTANT NOTE!!! 
	//     This definition must be consistant with osdet.cpp detection as well as with the database
	typedef enum
	{
		enV3_DefPlat = 0,
		enV3_W95IE5 = 1,
		enV3_W98IE4 = 2,
		enV3_W98IE5 = 3,
		enV3_NT4IE5X86 = 4,
		enV3_NT4IE5ALPHA = 5,
		enV3_NT5IE5X86 = 6,
		//enV3_NT5IE5ALPHA = 7,
		enV3_NT4IE4ALPHA = 8,
		enV3_NT4IE4X86 = 9,
		enV3_W95IE4 = 10,
		enV3_MILLENNIUMIE5 = 11,
		enV3_W98SEIE5 = 12,
		//enV3_NEPTUNEIE5 = 13,
		enV3_NT4IE5_5X86 = 14,
		enV3_W95IE5_5 = 15,
		enV3_W98IE5_5 = 16,
		enV3_NT5IE5_5X86 = 17,
		enV3_Wistler = 18,
		enV3_Wistler64 = 19,
		enV3_NT5DC = 20,
	} enumV3Platform;

	#ifndef PUID
		typedef long	PUID;		//Windows Update assigned identifier
									//that is unique across catalogs.
		typedef PUID	*PPUID;		//Pointer to a PUID type.
	#endif

	//defined value used in the link and installLink fields to indicate
	//no link dependencies

	#define WU_NO_LINK						(PUID)-1

	typedef struct ACTIVESETUP_RECORD
	{
		GUID		g;								//guid that identifies the item to be updated
		PUID		puid;							//Windows Update assigned unique identifier. This value is unique for all inventory record types, (Active Setup, CDM, and Section records). This ID specifies the name of the description and installation cab files.
		WU_VERSION	version;						//version of package that is this inventory record identifies
		BYTE		flags;							//flags specific to this record.
		PUID		link;							//PUID value of other record in inventory list that this record is dependent on. This field contains WU_NO_LINK if this item has no dependencies.
		PUID		installLink;					//The installLink field contains either WU_NO_LINK if there are no install
													//dependencies else this is the index of an item that must be
													//installed before this item can be installed. This is mainly
													//used for device drivers however there is nothing in the catalog
													//structure that precludes this link being used for applications
													//as well.
	} ACTIVESETUP_RECORD, *PACTIVESETUP_RECORD;

	GUID const WU_GUID_SPECIAL_RECORD	= { 0x00000000, 0x0000, 0x0000, { 0x00, 0x00, 0x0, 0x00, 0x0, 0x00, 0x0, 0x00 } };

	#define WU_GUID_DRIVER_RECORD				WU_GUID_SPECIAL_RECORD

	//This is simply for consistenty with the spec. The spec refers to
	//device driver insertion record. From the codes standpoint the is
	//a SECTION_RECORD_TYPE_DEVICE_DRIVER however this define makes it
	//a little unclear so I defined another type with the same value and
	//will change the v3 control code to use it. I am leaving the old define
	//above in place so that the backend tool set does not break.
	#define SECTION_RECORD_TYPE_DEVICE_DRIVER_INSERTION	(BYTE)2
	#define SECTION_RECORD_TYPE_PRINTER					(BYTE)3
	#define SECTION_RECORD_TYPE_DRIVER_RECORD			(BYTE)4
	#define	SECTION_RECORD_TYPE_CATALOG_RECORD			(BYTE)5	//Inventory.plt catalog item record that describes a sub catalog.

	typedef struct _SECTION_RECORD
	{
		GUID	g;								//guid this type of record is WU_GUID_SPECIAL_RECORD
		BYTE	type;							//section record type
		PUID	puid;							//Windows Update assigned unique identifier. This value is unique for all inventory record types, (Active Setup, CDM, and Section records). This ID specifies the name of the description and installation cab files.
		BYTE	flags;							//flags specific to this record.
		BYTE	level;							//section level can be a section, sub section or sub sub section
	} SECTION_RECORD, *PSECTION_RECORD;

	typedef struct _DRIVER_RECORD
	{
		GUID		g;							//guid this type of record is WU_GUID_DRIVER_RECORD
		BYTE		type;						//driver record indicator flag, This type is set to
												//SECTION_RECORD_TYPE_DEVICE_DRIVER
												//i.e. SECTION_RECORD_TYPE_DEVICE_DRIVER_INSERTION
												//for a device driver or printer record place holder.
		PUID		puid;						//Windows Update assigned unique identifier. This value is unique for all inventory record types, (Active Setup, CDM, and Section records). This ID specifies the name of the description and installation cab files.
		WU_VERSION	reserved;						
		BYTE		flags;						//flags specific to this record.
		PUID		link;						//PUID value of other record in inventory list that this record is dependent on. This field contains WU_NO_LINK if this item has no dependencies.
		PUID		installLink;				//The installLink field contains either 0 if there are no install
												//dependencies else this is the index of an item that must be
												//installed before this item can be installed. This is mainly
												//used for device drivers however there is nothing in the catalog
												//structure that precludes this link being used for applications
												//as well.
	} DRIVER_RECORD, *PDRIVER_RECORD;

	typedef union _WU_INV_FIXED
	{
		ACTIVESETUP_RECORD	a;					//Active Setup detection record
		SECTION_RECORD		s;					//Catalog section record
		DRIVER_RECORD		d;					//CDM driver record insertion point
												//if additional inventory detection
												//record types are added they need to be added here.
	} WU_INV_FIXED, *PWU_INV_FIXED;


	typedef struct _WU_VARIABLE_FIELD
	{
		_WU_VARIABLE_FIELD();

		short	id;		//record type identifier
		short	len;	//length of variable record data

		//size we are using a 0 size array place hold we need to disable the
		//compiler warning since it will complain about this being non standard
		//behavor.
		#pragma warning( disable : 4200 )
		BYTE	pData[];	//variable field record data
		#pragma warning( default : 4200 )

		//The GetNextItem function returns a pointer to the next variable array item
		//if it exists or NULL if it does not.
		struct _WU_VARIABLE_FIELD *GetNext(void);

		//The FindItem function returns a pointer to the next variable array item
		//if the requested item is found or NULL the item is not found.
		struct _WU_VARIABLE_FIELD *Find(short id);

		//returns the total size of this variable field array.
		int GetSize(void);
	} WU_VARIABLE_FIELD, *PWU_VARIABLE_FIELD;


	#define	WU_ITEM_STATE_UNKNOWN	0	//Inventory item state has not been detected yet
	#define	WU_ITEM_STATE_PRUNED	3	//Inventory item has been pruned from the list.

	#define WU_STATE_REASON_NONE        0
	#define WU_STATE_REASON_BITMASK     2

	typedef struct _WU_INV_STATE
	{
		BYTE	state;					//Currently defined item state (Unknown, Installed, Update, Pruned)
		BOOL	bChecked;				//TRUE if the user has selected this item to be installed | updated
		BOOL	bHidden;				//Item display state, TRUE = hide from user FALSE = show item to user.
		BOOL    dwReason;			    //reason for the items current state
		WU_VERSION	verInstalled;						
	} WU_INV_STATE, *PWU_INV_STATE;

	//defined variable Description file items.
	#define WU_DESCRIPTION_TITLE			((short)1)		//title of item that is to be displayed
	#define	WU_DESCRIPTION_CABFILENAME		((short)9)		//cab file name for installation this is one or more and is in the format of an array of NULL terminated strings with the last entry double null terminated. This is known as a multisz string in the langauge of the registry.
															
	typedef struct _WU_DESCRIPTION
	{
		DWORD				flags;					//Icon flags to display with description
		DWORD				size;					//compressed total size of package
		DWORD				downloadTime;			//time to download @ 28,800
		PUID				dependency;				//display dependency link
		PWU_VARIABLE_FIELD	pv;						//variable length fields associated with this description file
	} WU_DESCRIPTION, *PWU_DESCRIPTION;

	//These flags are used by the client in memory inventory file to quickly determine
	//the type of inventory record. This is stored in each inventory item

	//add new inventory detection record types if required here.

	#define WU_TYPE_ACTIVE_SETUP_RECORD			((BYTE)1)	//active setup record type
	#define WU_TYPE_CDM_RECORD_PLACE_HOLDER		((BYTE)2)	//cdm code download manager place holder record. This is used to set the insertion point for other CDM driver records. Note: There is only one of these per inventory catalog.
	#define WU_TYPE_CDM_RECORD					((BYTE)3)	//cdm code download manager record type
	#define WU_TYPE_SECTION_RECORD				((BYTE)4)	//a section record place holder
	#define WU_TYPE_SUBSECTION_RECORD			((BYTE)5)	//a sub section record place holder
	#define WU_TYPE_SUBSUBSECTION_RECORD		((BYTE)6)	//a sub sub section record place holder
	#define	WU_TYPE_RECORD_TYPE_PRINTER			((BYTE)7)	//a printer detection record type
	#define	WU_TYPE_CATALOG_RECORD				((BYTE)8)	//Inventory.plt catalog item record that describes a sub catalog.

	//data return values used with GetItemInfo
	#define WU_ITEM_GUID			1	//item's guid.
	#define WU_ITEM_PUID			2	//item's puid.
	#define WU_ITEM_FLAGS			3	//item's flags.
	#define WU_ITEM_LINK			4	//item's detection dependency link.
	#define WU_ITEM_INSTALL_LINK		5	//item's install dependency link.
	#define WU_ITEM_LEVEL			6	//section record's level.

	typedef struct _INVENTORY_ITEM
	{
		int					iReserved;		//inventory record bitmask index
		BYTE				recordType;		//in memory item record type. This is setup when the catalog is parsed by the ParseCatalog method.
		int					ndxLinkDetect;	//index of item upon which this item is dependent. If this item is not dependent on any other items then this item will be -1.
		int					ndxLinkInstall;	//index of item upon which this item is dependent. If this item is not dependent on any other items then this item will be -1.
		PWU_INV_FIXED		pf;				//fixed record portion of the catalog inventory.
		PWU_VARIABLE_FIELD	pv;				//variable portion of the catalog inventory
		PWU_INV_STATE		ps;				//Current item state
		PWU_DESCRIPTION		pd;				//item description structure

		//Copies information about an inventory item to a user supplied buffer.
		BOOL GetFixedFieldInfo
			(
				int		infoType,	//type of information to be returned
				PVOID	pBuffer		//caller supplied buffer for the returned information. The caller is responsible for ensuring that the return buffer is large enough to contain the requested information.
			);

		//Quickly returns an items puid id to a caller.
		PUID GetPuid
			(
				void
			);
	} INVENTORY_ITEM, *PINVENTORY_ITEM;

	typedef struct _WU_CATALOG_HEADER
	{
		short	version;		//version of the catalog (this allows for future expansion)
		int		totalItems;		//total items in catalog
		BYTE	sortOrder;		//catalog sort order. 0 is the default and means use the position value of the record within the catalog.
	} WU_CATALOG_HEADER, *PWU_CATALOG_HEADER;

	typedef struct _WU_CATALOG
	{
		WU_CATALOG_HEADER	hdr;		//catalog header record (note the parsing function will need to fixup the items pointer when the catalog is read)
		PINVENTORY_ITEM		*pItems;	//beginning of individual catalog items
	} WU_CATALOG, *PWU_CATALOG;

	//size of the OEM field in a bitmask record. This is for documentation and clarity
	//The actual field in the BITMASK structure is a pointer to an array of OEM fields.

	//bitmask helper macros
	//returns 1 if bit is set 0 if bit is not set
	inline bool GETBIT(PBYTE pbits, int index) { return (pbits[(index/8)] & (0x80 >> (index%8))) != 0; }

	//sets requested bit to 1
	inline void SETBIT(PBYTE pbits, int index) { pbits[index/8] |= (0x080 >> (index%8)); }
	
	//clears requested bit to 0
	inline void CLRBIT(PBYTE pbits, int index) { pbits[index/8] &= (0xff ^ (0x080 >> (index%8))); }

	#define BITMASK_GLOBAL_INDEX		0		//index of global bitmask
	#define BITMASK_OEM_DEFAULT			1		//index of default OEM bitmask

	#define BITMASK_ID_OEM				((BYTE)1)	//BITMASKID entry is an OEM id
	#define BITMASK_ID_LOCALE			((BYTE)2)	//BITMASKID entry is a LOCALE id

	//The bitmask file is arranged as a series of bit bitmasks in the same order as
	//the oem and langauge ids. For example if DELL1 was the second id in the id
	//array section of the bitmask file then is bitmask would begin the third bitmask
	//in the bitmask section of the file. The reason that it is the third and not
	//second is that the first bitmask is always the global bitmask and there is no
	//corrisponding id field for the global mask as this mask is always present.

	//A bitmask OEM or LOCALE id is a DWORD.

	typedef DWORD BITMASKID;
	typedef DWORD *PBITMASKID;

	typedef struct _BITMASK
	{
		int	iRecordSize;	//number of bits in a single bitmask record
		int iBitOffset;		//offset to bitmap bits in bytes
		int	iOemCount;		//Total number of oem ids in bitmask
		int	iLocaleCount;	//Total number of locale ids in bitmask
		int	iPlatformCount;	//Total number of platforms defined.

		#pragma warning( disable : 4200 )
			BITMASKID	bmID[];		//OEM & LANGAUGE & future types arrays.
		#pragma warning( default : 4200 )

		//since there are one or more array of OEM & LANGAUGE types this needs to be
		//a pointer and will need to be manually set to the correct location when the
		//bitmask file is created or read.

		PBYTE GetBitsPtr(void) { return ((PBYTE)this+iBitOffset); }		//beginning of bitmask bit arrays
		PBYTE GetBitMaskPtr(int index) { return GetBitsPtr() + ((iRecordSize+7)/8) * index; }

	} BITMASK, *PBITMASK;



	//catalog list

	#define	CATLIST_STANDARD			((DWORD)0x00)	
	#define CATLIST_CRITICALUPDATE		((DWORD)0x01)	
	#define CATLIST_DRIVERSPRESENT		((DWORD)0x02)	
	#define CATLIST_AUTOUPDATE			((DWORD)0x04)
	#define CATLIST_SILENTUPDATE		((DWORD)0x08)
	#define CATLIST_64BIT				((DWORD)0x10)
    #define CATLIST_SETUP               ((DWORD)0x20)

	typedef struct _CATALOGLIST
	{
		DWORD dwPlatform;
		DWORD dwCatPuid;
		DWORD dwFlags;
	} CATALOGLIST, *PCATALOGLIST;
	
	
	//Global scope functions that handle creation of variable size objects for the
	//inventory item and description structures.

	//Adds a variable size field to an inventory type Variable size field
	void __cdecl AddVariableSizeField
		(
			IN OUT PINVENTORY_ITEM	*pItem,	//pointer to variable field after pvNew is added.
			IN PWU_VARIABLE_FIELD	pvNew	//new variable field to add
		);

	//Adds a variable size field to a description type Variable size field
	void __cdecl AddVariableSizeField
		(
			IN	PWU_DESCRIPTION	*pDescription,	//pointer to variable field after pvNew is added.
			PWU_VARIABLE_FIELD pvNew	//new variable field to add
		);

	//Adds a variable size field to a variable field chain.
	//The format of a variable size field is:
	//[(short)id][(short)len][variable size data]
	//The variable field always ends with a WU_VARIABLE_END type.

	PWU_VARIABLE_FIELD CreateVariableField
		(
			IN	short	id,			//id of variable field to add to variable chain.
			IN	PBYTE	pData,		//pointer to binary data to add.
			IN	int		iDataLen	//Length of binary data to add.
		);

	//Converts a V3 catalog version to a string format ##,##,##,##
	void __cdecl VersionToString
		(
			IN		PWU_VERSION	pVersion,		//WU version structure that contains the version to be converted to a string.
			IN OUT	LPSTR		szStr			//character string array that will contain the converted version, the caller
												//needs to ensure that this array is at least 16 bytes.
		);

	//0 if they are equal
	//1 if pV1 > pv2
	//-1 if pV1 < pV2
	//compares active setup type versions and returns:

	int __cdecl CompareASVersions
		(
			PWU_VERSION pV1,	//pointer to version1
			PWU_VERSION pV2		//pointer to version2
		);


	BOOL IsValidGuid(GUID* pGuid);


	#define _WU_V3_CATALOG_INC

	//This USEWUV3INCLUDES define is for simplicity. If this present then we include
	//the other headers that are commonly used for V3 control objects. Note: These
	//objects still come from a 1:1 interleave library wuv3.lib. So you only get
	//the objects that you use in your application.

	#pragma pack()

    const int MAX_CATALOG_INI = 1024;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuv3\wsdu\wsdu\fdi.cpp ===
#include "wsdu.h"
#include <io.h>
#include <sys/stat.h>
#include <fcntl.h>

/*
 * Function prototypes 
 */
BOOL    fdi(char *cabinet_file, char *dir);
int     get_percentage(unsigned long a, unsigned long b);
char   *return_fdi_error_string(int err);


/*
 * Destination directory for extracted files
 */
char    dest_dir[256];

/*
 * Memory allocation function
 */
FNALLOC(mem_alloc)
{
    return malloc(cb);
}

/*
 * Memory free function
 */
FNFREE(mem_free)
{
    free(pv);
}


FNOPEN(file_open)
{
    return _open(pszFile, oflag, pmode);
}


FNREAD(file_read)
{
    return _read((int)hf, pv, cb);
}


FNWRITE(file_write)
{
    return _write((int)hf, pv, cb);
}


FNCLOSE(file_close)
{
    return _close((int)hf);
}


FNSEEK(file_seek)
{
    return _lseek((int)hf, dist, seektype);
}


FNFDINOTIFY(notification_function)
{
    if (NULL == pfdin) {
        return 0;
    }

    switch (fdint)
    {
        case fdintCABINET_INFO: // general information about the cabinet
            return 0;

        case fdintPARTIAL_FILE: // first file in cabinet is continuation
            return 0;

        case fdintCOPY_FILE:    // file to be copied
        {
            INT_PTR        handle;
            int        response;
            char    destination[256];

            if (NULL == pfdin->psz1) 
            {
                return NULL;
            }

            if (FAILED(StringCchCopy(destination, ARRAYSIZE(destination), dest_dir))) 
            {
                return NULL;
            }
            if (FAILED(StringCchCat(destination, ARRAYSIZE(destination), pfdin->psz1))) 
            {
                return NULL;
            }

            handle = file_open(
                destination,
                _O_BINARY | _O_CREAT | _O_WRONLY | _O_SEQUENTIAL,
                _S_IREAD | _S_IWRITE 
            );

            return handle;
        }

        case fdintCLOSE_FILE_INFO:    // close the file, set relevant info
        {
            HANDLE  handle;
            DWORD   attrs;
            char    destination[256];

            file_close(pfdin->hf);

            if (NULL == pfdin->psz1) 
            {
                return FALSE;
            }

            if (FAILED(StringCchCopy(destination, ARRAYSIZE(destination), dest_dir)))
            {
                return FALSE;
            }
            if (FAILED(StringCchCat(destination, ARRAYSIZE(destination), pfdin->psz1))) 
            {
                return FALSE;
            }

            handle = CreateFile(
                destination,
                GENERIC_READ | GENERIC_WRITE,
                FILE_SHARE_READ,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL
            );

            if (handle != INVALID_HANDLE_VALUE)
            {
                FILETIME    datetime;

                if (TRUE == DosDateTimeToFileTime(
                    pfdin->date,
                    pfdin->time,
                    &datetime))
                {
                    FILETIME    local_filetime;

                    if (TRUE == LocalFileTimeToFileTime(
                        &datetime,
                        &local_filetime))
                    {
                        (void) SetFileTime(
                            handle,
                            &local_filetime,
                            NULL,
                            &local_filetime
                        );
                     }
                }

                CloseHandle(handle);
            }

            attrs = pfdin->attribs;

            attrs &= (_A_RDONLY | _A_HIDDEN | _A_SYSTEM | _A_ARCH);

            (void) SetFileAttributes(
                destination,
                attrs
            );

            return TRUE;
        }

        case fdintNEXT_CABINET:    // file continued to next cabinet
            return 0;
        
    }
    return 0;
}


BOOL fdi(char *cabinet_fullpath, char * directory)
{
    LOG_block("fdi()");
    HFDI            hfdi;
    ERF             erf;
    FDICABINETINFO  fdici;
    INT_PTR         hf;
    char            *p;
    char            cabinet_name[256];
    char            cabinet_path[256];
    LPSTR           pszDestEnd;

    if (FAILED(StringCchCopyEx(
        dest_dir,
        ARRAYSIZE(dest_dir),
        directory,
        &pszDestEnd,
        NULL,
        STRSAFE_IGNORE_NULLS
    )))
    {
        return FALSE;
    }
                               
    if (pszDestEnd > dest_dir && 
        *(pszDestEnd - 1) != '\\')
    {
        if (FAILED(StringCchCat(dest_dir, ARRAYSIZE(dest_dir), "\\")))
        {
            return FALSE;
        }
    }

    hfdi = FDICreate(
        mem_alloc,
        mem_free,
        file_open,
        file_read,
        file_write,
        file_close,
        file_seek,
        cpu80386,
        &erf
    );

    if (hfdi == NULL)
    {
        LOG_error("FDICreate() failed: code %d [%s]\n", erf.erfOper, return_fdi_error_string(erf.erfOper));
        return FALSE;
    }


    /*
     * Is this file really a cabinet?
     */
    hf = file_open(
        cabinet_fullpath,
        _O_BINARY | _O_RDONLY | _O_SEQUENTIAL,
        0
    );

    if (hf == -1)
    {
        (void) FDIDestroy(hfdi);

        LOG_error("Unable to open '%s' for input\n", cabinet_fullpath);
        return FALSE;
    }

    if (FALSE == FDIIsCabinet(
            hfdi,
            hf,
            &fdici))
    {
        // The file is not compressed, nothing to do. This is not an error, A lot of files on the V3 server use
        // conditional compression depending on whether it benefits the file size. 
        _close((int)hf);

        (void) FDIDestroy(hfdi);
        return FALSE;
    }
    else
    {
        _close((int)hf);
    }

    p = strrchr(cabinet_fullpath, '\\');

    if (p == NULL)
    {
        if (FAILED(StringCchCopy(cabinet_name, ARRAYSIZE(cabinet_name), cabinet_fullpath))) 
        {
            return FALSE;
        }

        if (FAILED(StringCchCopy(cabinet_path, ARRAYSIZE(cabinet_path), ""))) 
        {
            return FALSE;
        }
    }
    else
    {
        if (FAILED(StringCchCopy(cabinet_name, ARRAYSIZE(cabinet_name), p+1))) 
        {
            return FALSE;
        }
        if (FAILED(StringCchCopyN(cabinet_path, ARRAYSIZE(cabinet_path), cabinet_fullpath, (int) (p-cabinet_fullpath)+1))) 
        {
            return FALSE;
        }
    }

    if (TRUE != FDICopy(
        hfdi,
        cabinet_name,
        cabinet_path,
        0,
        notification_function,
        NULL,
        NULL))
    {
        LOG_error("FDICopy() failed: code %d [%s]\n", erf.erfOper, return_fdi_error_string(erf.erfOper));

        (void) FDIDestroy(hfdi);
        return FALSE;
    }

    if (FDIDestroy(hfdi) != TRUE)
    {
        LOG_error("FDIDestroy() failed: code %d [%s]\n", erf.erfOper, return_fdi_error_string(erf.erfOper));
        return FALSE;
    }

    return TRUE;
}


char *return_fdi_error_string(int err)
{
    switch (err)
    {
        case FDIERROR_NONE:
            return "No error";

        case FDIERROR_CABINET_NOT_FOUND:
            return "Cabinet not found";
            
        case FDIERROR_NOT_A_CABINET:
            return "Not a cabinet";
            
        case FDIERROR_UNKNOWN_CABINET_VERSION:
            return "Unknown cabinet version";
            
        case FDIERROR_CORRUPT_CABINET:
            return "Corrupt cabinet";
            
        case FDIERROR_ALLOC_FAIL:
            return "Memory allocation failed";
            
        case FDIERROR_BAD_COMPR_TYPE:
            return "Unknown compression type";
            
        case FDIERROR_MDI_FAIL:
            return "Failure decompressing data";
            
        case FDIERROR_TARGET_FILE:
            return "Failure writing to target file";
            
        case FDIERROR_RESERVE_MISMATCH:
            return "Cabinets in set have different RESERVE sizes";
            
        case FDIERROR_WRONG_CABINET:
            return "Cabinet returned on fdintNEXT_CABINET is incorrect";
            
        case FDIERROR_USER_ABORT:
            return "User aborted";
            
        default:
            return "Unknown error";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuv3\wsdu\wsdu\log.h ===
//=======================================================================
//
//  Copyright (c) 1998-1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:   log.h
//
//  Owner:  Yan Leshinsly
//
//  Description:
//
//      Logging support
//
//=======================================================================
#pragma once

#ifndef LOGGING_LEVEL
    #define LOGGING_LEVEL 0
#endif

const char cszLoggingFile[] = "%WinDir%\\wsdu.log";

class CLogger
{
public:
    CLogger(const char* szBlockName = 0, int nLoggingLevel = 0, const char* szFileName = 0, int nLine = 0);
    ~CLogger();
    void __cdecl out(const char *szFormat, ...);
    void __cdecl error(const char *szFormat, ...);
    static void __cdecl out1(const char *szFormat, ...);
    static void __cdecl close(void);

private:
    void v_out( const char* szFormat, va_list va);

    bool m_fOut;
    char m_szBlockName[64];
    DWORD m_dwStartTick;
    
    static FILE* c_pfile;
    static int c_cnIndent;
    static int c_cnLevels;
};

#define THIS_FILE               __FILE__
#define LOG_block(name)         CLogger logger(name, LOGGING_LEVEL, THIS_FILE, __LINE__)
#define LOG_out                 logger.out
#define LOG_out1                CLogger::out1
#define LOG_error               logger.error
#define LOG_close				CLogger::close

#define report_error_if_false(f)    if (f) {/*OK*/} else { LOG_error("%s LastError = %d", #f, GetLastError()); } 
#define return_error_if_false(f)    if (f) {/*OK*/} else { DWORD dwErr = GetLastError(); LOG_error("%s LastError = %d", #f, dwErr); return dwErr;}
#define return_if_error(f)          { DWORD dwErr = f; if (dwErr) { LOG_error("%s LastError = %d", #f, dwErr); return dwErr;} }
#define return_if_false(f)      if (f) {/*OK*/} else { LOG_error("%s LastError = %d", #f, GetLastError()); return FALSE;}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuv3\wsdu\wsdueng\log.h ===
//=======================================================================
//
//  Copyright (c) 1998-1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:   log.h
//
//  Owner:  Yan Leshinsly
//
//  Description:
//
//      Logging support
//
//=======================================================================
#pragma once

#ifndef LOGGING_LEVEL
    #define LOGGING_LEVEL 0
#endif

const char cszLoggingFile[] = "%WinDir%\\wsdu.log";

class CLogger
{
public:
    CLogger(const char* szBlockName = 0, int nLoggingLevel = 0, const char* szFileName = 0, int nLine = 0);
    ~CLogger();
    void __cdecl out(const char *szFormat, ...);
    void __cdecl error(const char *szFormat, ...);
    static void __cdecl out1(const char *szFormat, ...);
    static void __cdecl close(void);

private:
    void v_out( const char* szFormat, va_list va);

    bool m_fOut;
    char m_szBlockName[64];
    DWORD m_dwStartTick;
    
    static FILE* c_pfile;
    static int c_cnIndent;
    static int c_cnLevels;
};

#define THIS_FILE               __FILE__
#define LOG_block(name)         CLogger logger(name, LOGGING_LEVEL, THIS_FILE, __LINE__)
#define LOG_out                 logger.out
#define LOG_out1                CLogger::out1
#define LOG_error               logger.error
#define LOG_close				CLogger::close

#define report_error_if_false(f)    if (f) {/*OK*/} else { LOG_error("%s LastError = %d", #f, GetLastError()); } 
#define return_error_if_false(f)    if (f) {/*OK*/} else { DWORD dwErr = GetLastError(); LOG_error("%s LastError = %d", #f, dwErr); return dwErr;}
#define return_if_error(f)          { DWORD dwErr = f; if (dwErr) { LOG_error("%s LastError = %d", #f, dwErr); return dwErr;} }
#define return_if_false(f)      if (f) {/*OK*/} else { LOG_error("%s LastError = %d", #f, GetLastError()); return FALSE;}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuv3\wsdu\wsdu\wsdu.cpp ===
#include "wsdu.h"
#include <wutestkeys.h>

HINSTANCE g_hinst;
HMODULE g_hwininet = NULL;
HMODULE g_hshlwapi = NULL;
HMODULE g_hwsdueng = NULL;
GLOBAL_STATEA g_stateA;

const TCHAR szDUTestValidationFile[] = _T("dutest.cab");

// defines
// change default site connection to live site from beta site
//#define WU_DEFAULT_URL  "http://content.beta.windowsupdate.com/content"
#define WU_DEFAULT_URL  "http://windowsupdate.microsoft.com"
//#define WU_DEFAULT_SELFUPD_URL "http://content.beta.windowsupdate.com/dynamicupdate"
#define WU_DEFAULT_SELFUPD_URL "http://windowsupdate.microsoft.com/dynamicupdate"

#define REG_WINNT32_DYNAMICUPDATE  "Software\\Microsoft\\Windows\\CurrentVersion\\Setup\\Winnt32\\5.1"
#define REG_VALUE_DYNAMICUPDATEURL    "DynamicUpdateUrl"
#define REG_VALUE_DYNAMICUPDATESELFUPDATEURL "DynamicUpdateSelfUpdateUrl"

// private helper function forward declares
DWORD OpenHttpConnection(LPCSTR pszServerUrl, BOOL fGetRequest, BOOL fHTTPSRequired);
DWORD DownloadFile(LPCSTR pszUrl, LPCSTR pszDestinationFile, BOOL fDecompress, BOOL fCheckTrust, BOOL fHTTPSRequired, DWORD *pdwDownloadBytesPerSecond);
BOOL IsServerFileNewer(FILETIME ftServerTime, DWORD dwServerFileSize, LPCSTR pszLocalFile);
DWORD DoSelfUpdate(LPCSTR pszTempPath, LPCSTR pszServerUrl, WORD wProcessorArchitecture);
LPSTR DuUrlCombine(LPSTR pszDest, size_t cchDest, LPCSTR pszBase, LPCSTR pszAdd);
BOOL MyGetFileVersion (LPSTR szFileName, VS_FIXEDFILEINFO& vsVersion);
int CompareFileVersion(VS_FIXEDFILEINFO& vs1, VS_FIXEDFILEINFO& vs2);

// --------------------------------------------------------------------------
//
//
//
//
//                             Main Code Begins
//
//
//
//
// --------------------------------------------------------------------------

// --------------------------------------------------------------------------
// Function Name: DllMain
// Function Description: 
//
// Function Returns:
//
//

BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpvReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        DisableThreadLibraryCalls(hInstance);
        g_hinst = hInstance;
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        ;
    }
    return TRUE;
}

// --------------------------------------------------------------------------
// Function Name: DuIsSupported
// Function Description: this method checks whether the required DLL's are on
//      the system to successfully run Dynamic Update. It does NOT attempt to
//      initiate a connection though.
//
// Function Returns:
//      FALSE: Not Supported, Some Required DLL's missing
//      TRUE:  DLL's are OK. Dynamic Update should be possible.
//
//
BOOL WINAPI DuIsSupported()
{
    LOG_block("DuIsSupported()");
    
    if (NULL == g_hshlwapi)
    {
        g_hshlwapi = LoadLibrary("shlwapi.dll");
        if (NULL == g_hshlwapi)
        {
            LOG_error("Unable to Load shlwapi.dll, Dynamic Setup Not Supported");
            return FALSE;
        }
    }

    if (NULL == g_hwininet)
    {
        g_hwininet = LoadLibrary("wininet.dll");
        if (NULL == g_hwininet)
        {
            LOG_error("Unable to Load wininet.dll, Dynamic Setup Not Supported");
            return FALSE;
        }
    }

    // DavidHen, October 24th, 2002
    // Determine if the WININET.DLL version on the client machine is Below IE5.01
    // If its less than IE5.01 do not use SSL, if equal to or greater than, then use SSL
    VS_FIXEDFILEINFO vsCurrent, vsMinimumIEVersion;
    if (!MyGetFileVersion("wininet.dll", vsCurrent))
    {
        // Unable to get File Version, error
        LOG_error("Unable to read version information for wininet");
        return FALSE;
    }
    // IE 5.01 wininet.dll version is 5.0.2314.1003
    vsMinimumIEVersion.dwFileVersionMS = MAKELONG(0,5);
    vsMinimumIEVersion.dwFileVersionLS = MAKELONG(1003, 2314);

    // IE 5.5 SP1's Wininet.DLL version is 5.50.4522.1800
    //vsMinimumIEVersion.dwFileVersionMS = MAKELONG(50,5);
    //vsMinimumIEVersion.dwFileVersionLS = MAKELONG(1800,4522);

    LOG_out("File version for Minimum IE Version is %d.%d.%d.%d", 
        HIWORD(vsMinimumIEVersion.dwFileVersionMS), LOWORD(vsMinimumIEVersion.dwFileVersionMS), 
        HIWORD(vsMinimumIEVersion.dwFileVersionLS), LOWORD(vsMinimumIEVersion.dwFileVersionLS));

    if (CompareFileVersion(vsCurrent, vsMinimumIEVersion) >= 0)
    {
        // Current WININET is equal to or newer than the minimum, so SSL is supported.
        LOG_out("Determined Existing WININET is Equal to or Newer than Required, SSL used");
        g_stateA.fIEVersionOKSupportSLL = TRUE;
    }
    else
    {   
        LOG_out("Determined Existing WININET is older than Required, no SSL");
        g_stateA.fIEVersionOKSupportSLL = FALSE;
    }

    // Dynamic Update relies on a bunch of API's WinInet and Shlwapi. To try to consolidate where these function pointers
    // live throughout the code we'll use a global state structure.
    g_stateA.fpnInternetOpen = (PFN_InternetOpen) GetProcAddress(g_hwininet, "InternetOpenA");
    g_stateA.fpnInternetConnect = (PFN_InternetConnect) GetProcAddress(g_hwininet, "InternetConnectA");
    g_stateA.fpnHttpOpenRequest = (PFN_HttpOpenRequest) GetProcAddress(g_hwininet, "HttpOpenRequestA");
    g_stateA.fpnHttpAddRequestHeaders = (PFN_HttpAddRequestHeaders) GetProcAddress(g_hwininet, "HttpAddRequestHeadersA");
    g_stateA.fpnHttpSendRequest = (PFN_HttpSendRequest) GetProcAddress(g_hwininet, "HttpSendRequestA");
    g_stateA.fpnHttpQueryInfo = (PFN_HttpQueryInfo) GetProcAddress(g_hwininet, "HttpQueryInfoA");
    g_stateA.fpnInternetSetOption = (PFN_InternetSetOption) GetProcAddress(g_hwininet, "InternetSetOptionA");
    g_stateA.fpnInternetCrackUrl = (PFN_InternetCrackUrl) GetProcAddress(g_hwininet, "InternetCrackUrlA");
    g_stateA.fpnInternetReadFile = (PFN_InternetReadFile) GetProcAddress(g_hwininet, "InternetReadFile");
    g_stateA.fpnInternetCloseHandle = (PFN_InternetCloseHandle) GetProcAddress(g_hwininet, "InternetCloseHandle");
    g_stateA.fpnInternetGetConnectedState = (PFN_InternetGetConnectedState) GetProcAddress(g_hwininet, "InternetGetConnectedState");
    g_stateA.fpnPathAppend = (PFN_PathAppend) GetProcAddress(g_hshlwapi, "PathAppendA");
    g_stateA.fpnPathRemoveFileSpec = (PFN_PathRemoveFileSpec) GetProcAddress(g_hshlwapi, "PathRemoveFileSpecA");
    g_stateA.fpnInternetAutodial = (PFN_InternetAutodial) GetProcAddress(g_hwininet, "InternetAutodial");
    g_stateA.fpnInternetAutodialHangup = (PFN_InternetAutodialHangup) GetProcAddress(g_hwininet, "InternetAutodialHangup");

    if (!g_stateA.fpnInternetOpen || ! g_stateA.fpnInternetConnect || !g_stateA.fpnHttpOpenRequest ||
        !g_stateA.fpnHttpAddRequestHeaders || !g_stateA.fpnHttpSendRequest || !g_stateA.fpnHttpQueryInfo ||
        !g_stateA.fpnInternetCrackUrl || !g_stateA.fpnInternetReadFile || !g_stateA.fpnInternetCloseHandle ||
        !g_stateA.fpnInternetGetConnectedState || !g_stateA.fpnPathAppend || !g_stateA.fpnPathRemoveFileSpec ||
        !g_stateA.fpnInternetAutodial || !g_stateA.fpnInternetAutodialHangup)
    {
        // fail to get any of the function pointer above
        SafeFreeLibrary(g_hwininet);
        SafeFreeLibrary(g_hshlwapi);
        return FALSE;
    }
    
    return TRUE;
}


// --------------------------------------------------------------------------
// Function Name: DuInitialize
// Function Description: Initializes the Dynamic Setup Update engine. During
//      initialization this API attempts to establish a connection to the internet
//      and starts a self update process to ensure the latest bits are being used.
//      We also calculate the estimated transfer speed of the connection during this
//      time.
//
// Function Returns:
//      Failure: INVALID_HANDLE_VALUE .. Call GetLastError to retrieve the Error Code
//      Success: Handle of the Dynamic Setup Job
//
//
HANDLE WINAPI DuInitializeA(IN LPCSTR pszBasePath, // base directory used for relative paths for downloaded files
                            IN LPCSTR pszTempPath, // temp directory used to download update dlls, catalog files, etc
                               IN POSVERSIONINFOEXA posviTargetOS, // target OS platform
                            IN LPCSTR pszTargetArch, // string value identifying the architecture 'i386' and 'ia64'
                            IN LCID lcidTargetLocale, // target OS Locale ID
                            IN BOOL fUnattend, // is this an unattended operation
                            IN BOOL fUpgrade, // is this an upgrade
                            IN PWINNT32QUERY pfnWinnt32QueryCallback)
{
    LOG_block("DuInitialize()");
    char szServerUrl[INTERNET_MAX_URL_LENGTH + 1] = {'\0'};
    char szSelfUpdateUrl[INTERNET_MAX_URL_LENGTH + 1] = {'\0'};
    DWORD dwEstimatedDownloadSpeedInBytesPerSecond = 0;

    g_stateA.fUnattended = fUnattend;
    
    // param validation
    if ((NULL == pszBasePath) || (NULL == pszTempPath) || (NULL == posviTargetOS) || (posviTargetOS->dwOSVersionInfoSize != sizeof(OSVERSIONINFOEXA)) 
        || (NULL == pszTargetArch) || (0 == lcidTargetLocale) || (0 == posviTargetOS->dwBuildNumber))
    {
        LOG_error("Invalid Parameter passed to DuInitialize");
        SetLastError(ERROR_INVALID_PARAMETER);
        return INVALID_HANDLE_VALUE;
    }

    WORD wProcessorArchitecture;
    if (!lstrcmpiA(pszTargetArch, "i386"))
        wProcessorArchitecture = PROCESSOR_ARCHITECTURE_INTEL;
    else if (!lstrcmpiA(pszTargetArch,"amd64"))
        wProcessorArchitecture = PROCESSOR_ARCHITECTURE_AMD64;
    else if (!lstrcmpiA(pszTargetArch,"ia64"))
        wProcessorArchitecture = PROCESSOR_ARCHITECTURE_IA64;
    else 
    {
        LOG_error("Invalid Processor Type");
        SetLastError(ERROR_INVALID_PARAMETER);
        return INVALID_HANDLE_VALUE;
    }

    // ROGERJ, verify the caller is using the correct architecture information
    // because of the pointer size, the 64-bit content can not be seen from 32-bit machine and vice versa
    SYSTEM_INFO sysInfo;
    GetSystemInfo(&sysInfo);
    if (sysInfo.wProcessorArchitecture != wProcessorArchitecture)
    {
        LOG_error("Invalid Processor Type. Processor is %d.", sysInfo.wProcessorArchitecture);
        SetLastError(ERROR_INVALID_PARAMETER);
        return INVALID_HANDLE_VALUE;
    }
    
    // Verify that the Temp and Download Folders Exist are Valid.
    DWORD dwAttr = GetFileAttributes(pszBasePath);
    if ((dwAttr == 0xFFFFFFFF) || ((dwAttr & FILE_ATTRIBUTE_DIRECTORY) == 0))
    {
        LOG_error("Error - Base Path (DownloadDir) Does Not Exist");
        SetLastError(ERROR_INVALID_PARAMETER);
        return INVALID_HANDLE_VALUE;
    }
    dwAttr = GetFileAttributes(pszTempPath);
    if ((dwAttr == 0xFFFFFFFF) || ((dwAttr & FILE_ATTRIBUTE_DIRECTORY) == 0))
    {
        LOG_error("Error - Temp Path Does Not Exist");
        SetLastError(ERROR_INVALID_PARAMETER);
        return INVALID_HANDLE_VALUE;
    }

    if (NULL == g_hwininet || NULL == g_hshlwapi)
    {
        // DuIsSupported was not called, or was called and Failed before calling DuInitialize.
        // try again, if it fails, abort.
        if (!DuIsSupported())
        {
            LOG_error("Dynamic Setup Required DLL's not available, Cannot Continue");
            SetLastError(DU_ERROR_MISSING_DLL);
            return INVALID_HANDLE_VALUE;
        }
    }

    // first check for an existing InternetConnection. If we have an existing InternetConnection, we do not
    // need to do any further check, we will use this connection
    char szCurDir[MAX_PATH];
    ZeroMemory(szCurDir, MAX_PATH*sizeof(char));
    GetCurrentDirectoryA(MAX_PATH, szCurDir);
    
    g_stateA.fDialed = FALSE;
    DWORD dwConnectedState = 0;
    if (!g_stateA.fpnInternetGetConnectedState(&dwConnectedState, 0))
    {
        LOG_out("Not online, status %d", dwConnectedState);
        // not online, we need to establish a connection.  If we are at an unattended mode, we do not want to
        // trigger an autodial, thus return FALSE
        if (fUnattend // The machine is not connected to the net, and we are in unattended mode.
            || !(dwConnectedState & INTERNET_CONNECTION_MODEM)) // The machine can not be connected via a modem
        {
            
            SetLastError(ERROR_CONNECTION_UNAVAIL);
            return INVALID_HANDLE_VALUE;
        }
        else 
        {
            if (!g_stateA.fpnInternetAutodial (INTERNET_AUTODIAL_FORCE_ONLINE, // options
                                               NULL))
            {
                SetLastError(ERROR_CONNECTION_UNAVAIL);
                return INVALID_HANDLE_VALUE;
            }
            else
                g_stateA.fDialed = TRUE;
        }
    }

    SetCurrentDirectoryA(szCurDir);
  
    GetModuleFileNameA(NULL, szCurDir, MAX_PATH - 1);
    // find the last backslash
    char* pLastBackSlash = szCurDir + lstrlenA(szCurDir) -1;
    while (pLastBackSlash > szCurDir && *pLastBackSlash != '\\')
        pLastBackSlash--;

    *(pLastBackSlash+1) = '\0';
    
#ifndef DBG
    if (WUAllowTestKeys(szDUTestValidationFile))
#endif
    {
        // We need to get the Server URL where we will get the duident.cab and SelfUpdateUrl. For this we'll be looking at 
        // the registry path (see DEFINE for REG_WINNT32_DYNAMICUPDATE at the top of this file).
        // If we cannot get the URL we will default to the preset URLs. The most common scenario is to default
        // to the hard coded URL's.. the regkey is in place mainly for testing or emergency changes.
        HKEY hkey;
        if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, REG_WINNT32_DYNAMICUPDATE, &hkey))
        {
            DWORD dwType = 0;
            DWORD dwUrlLength = sizeof(szServerUrl);
            RegQueryValueEx(hkey, REG_VALUE_DYNAMICUPDATEURL, NULL, &dwType, (LPBYTE)szServerUrl, &dwUrlLength);
            dwUrlLength = sizeof(szSelfUpdateUrl);
            RegQueryValueEx(hkey, REG_VALUE_DYNAMICUPDATESELFUPDATEURL, NULL, &dwType, (LPBYTE)szSelfUpdateUrl, &dwUrlLength);
            RegCloseKey(hkey);
        }
    }

    // if we get through the reg lookup and we still don't have a server url, use the default.
    if ('\0' == szServerUrl[0])
    {
        if (FAILED(StringCchCopy(szServerUrl, ARRAYSIZE(szServerUrl), WU_DEFAULT_URL))) 
        {
            return INVALID_HANDLE_VALUE;
        }
    }
    if ('\0' == szSelfUpdateUrl[0])
    {
        if (FAILED(StringCchCopy(szSelfUpdateUrl, ARRAYSIZE(szSelfUpdateUrl), WU_DEFAULT_SELFUPD_URL))) 
        {
            return INVALID_HANDLE_VALUE;
        }
    }


    // Download the duident.Cab
    char szIdentCab[MAX_PATH];
    if (FAILED(StringCchCopy(szIdentCab, ARRAYSIZE(szIdentCab), pszTempPath))) 
    {
        return INVALID_HANDLE_VALUE;
    }
    g_stateA.fpnPathAppend(szIdentCab, "duident.cab");
    char szServerIdentCab[INTERNET_MAX_URL_LENGTH + 1];
    DuUrlCombine(szServerIdentCab, INTERNET_MAX_URL_LENGTH + 1, szServerUrl, "duident.cab");

    // Remove any formerly downloaded duident.cab --- solve problem when a untrusted duident.cab is formerly
    // accepted, the system will not ask user to accept again, while it should
    DeleteFile(szIdentCab);
    
    DWORD dwRet = DownloadFile(szServerIdentCab, szIdentCab, TRUE, TRUE, g_stateA.fIEVersionOKSupportSLL, NULL);
    if (ERROR_SUCCESS != dwRet)
    {
        // Most likely the site is down
        LOG_error("Establish Connection Failed, unable to continue");
        SetLastError(ERROR_INTERNET_INVALID_URL);
        return INVALID_HANDLE_VALUE;
    }
    
    SafeFreeLibrary(g_hwsdueng);
    char szEngineDll[MAX_PATH];
    if (FAILED(StringCchCopy(szEngineDll, ARRAYSIZE(szEngineDll), pszTempPath))) 
    {
        return INVALID_HANDLE_VALUE;
    }
    g_stateA.fpnPathAppend(szEngineDll, "wsdueng.dll");
    // remove any old wsdueng.dll in that directory, in order to avoid actually load an older engine
    // we don't care if the DeleteFile call is failed.  If it is failed, most likely,  there is no wsdueng.dll
    // to delete.
    DeleteFile(szEngineDll);

    // SelfUpdate is an optional process, which is why we don't check the return result. The selfupdate CAB
    // is also the only file we can download and try to estimate the connection speed. The selfupdate CAB
    // is approximately 60k.. Every other file we download before downloading the updates themselves is less than
    // 1k, which is far to small to estimate speed.
    dwEstimatedDownloadSpeedInBytesPerSecond = DoSelfUpdate(pszTempPath, szSelfUpdateUrl, wProcessorArchitecture);

    // get the fully qualified name of engine DLL in current directory
    // reuse variable szCurDir here
    if (FAILED(StringCchCat(szCurDir, ARRAYSIZE(szCurDir), "wsdueng.dll")))
    {
        return INVALID_HANDLE_VALUE;
    }
    
    // check file version to decide which dll to load.
    VS_FIXEDFILEINFO vsLocal, vsDownloaded;
    BOOL bCheckLocal = MyGetFileVersion(szCurDir, vsLocal);
    BOOL bCheckServer = MyGetFileVersion(szEngineDll, vsDownloaded);
    if (!bCheckLocal && !bCheckServer)
    {
        LOG_error("Failed to get both file version");
    }

    if (CompareFileVersion(vsLocal, vsDownloaded) >= 0)
    {
        // local file is newer or same
        g_hwsdueng = LoadLibrary(szCurDir);
        LOG_out("Load local engine");
    }
    else
    {
        // Load the self update engine DLL
        g_hwsdueng = LoadLibrary(szEngineDll);
        LOG_out("Load self update engine");
    }
        
    
    if (NULL == g_hwsdueng)
    {
        // if that fails, try to load what ever engine dll the system can find
        g_hwsdueng = LoadLibrary("wsdueng.dll");
        LOG_out("Trying to load any engine");
        if (NULL == g_hwsdueng)
        {
            LOG_error("Unable to load wsdueng.dll, Critical Error: Shouldn't have happened");
            SetLastError(DU_ERROR_MISSING_DLL);
            return INVALID_HANDLE_VALUE;
        }
    }

    PFN_DuInitializeA fpnDuInitialize = (PFN_DuInitializeA) GetProcAddress(g_hwsdueng, "DuInitializeA");
    if (NULL == fpnDuInitialize)
    {
        LOG_error("Unable to find DuInitializeA entrypoint in wsdueng.dll, Critical Error");
        SetLastError(DU_ERROR_MISSING_DLL);
        return INVALID_HANDLE_VALUE;
    }

    HANDLE hRet;
    // Forward the Call to the Engine Dll to complete the initialization.
    hRet = fpnDuInitialize(pszBasePath, pszTempPath, posviTargetOS, pszTargetArch, lcidTargetLocale, fUnattend, fUpgrade, pfnWinnt32QueryCallback);

    // If SelfUpdate happened and we have a valid Estimated Download Speed, Pass the download speed into the Engine Dll for time estimates.
    PFN_SetEstimatedDownloadSpeed fpnSetEstimatedDownloadSpeed = (PFN_SetEstimatedDownloadSpeed) GetProcAddress(g_hwsdueng, "SetEstimatedDownloadSpeed");
    if (NULL != fpnSetEstimatedDownloadSpeed && 0 != dwEstimatedDownloadSpeedInBytesPerSecond)
    {
        fpnSetEstimatedDownloadSpeed(dwEstimatedDownloadSpeedInBytesPerSecond);
    }

    PFN_SetIESupportsSSL fpnSetIESupportsSSL = (PFN_SetIESupportsSSL) GetProcAddress(g_hwsdueng, "SetIESupportsSSL");
    if (NULL != fpnSetIESupportsSSL)
    {
        fpnSetIESupportsSSL(g_stateA.fIEVersionOKSupportSLL);
    }
    return hRet;
}

HANDLE WINAPI DuInitializeW(IN LPCWSTR pwszBasePath, // base directory used for relative paths for downloaded files
                     IN LPCWSTR pwszTempPath, // temp directory used to download update dlls, catalog files, etc
                     IN POSVERSIONINFOEXW posviTargetOS, // target OS platform
                     IN LPCWSTR pwszTargetArch, // string value identifying the architecture 'i386' and 'ia64'
                     IN LCID lcidTargetLocale, // target OS Locale ID
                     IN BOOL fUnattend, // is this an unattended operation
                     IN BOOL fUpgrade, // is this an upgrade
                     IN PWINNT32QUERY pfnWinnt32QueryCallback)
{
    LOG_block("DuInitialize()");
    // param validation
    if ((NULL == pwszBasePath) || (NULL == pwszTempPath) || (NULL == posviTargetOS) || (posviTargetOS->dwOSVersionInfoSize != sizeof(OSVERSIONINFOEXW)) 
        || (0 == lcidTargetLocale))
    {
        LOG_error("Invalid Parameter passed to DuInitialize");
        SetLastError(ERROR_INVALID_PARAMETER);
        return INVALID_HANDLE_VALUE;
    }

    char szBasePath[MAX_PATH];
    char szTempPath[MAX_PATH];
    char szTargetArch[128];

    OSVERSIONINFOEX osvi;

    WideCharToMultiByte(CP_ACP, 0, pwszBasePath, -1, szBasePath, sizeof(szBasePath), NULL, NULL);
    WideCharToMultiByte(CP_ACP, 0, pwszTempPath, -1, szTempPath, sizeof(szTempPath), NULL, NULL);
    WideCharToMultiByte(CP_ACP, 0, pwszTargetArch, -1, szTargetArch, sizeof(szTargetArch), NULL, NULL);

    osvi.dwOSVersionInfoSize = sizeof(osvi);
    osvi.dwMajorVersion = posviTargetOS->dwMajorVersion;
    osvi.dwMinorVersion = posviTargetOS->dwMinorVersion;
    osvi.dwBuildNumber = posviTargetOS->dwBuildNumber;
    osvi.dwPlatformId = posviTargetOS->dwPlatformId;
    WideCharToMultiByte(CP_ACP, 0, posviTargetOS->szCSDVersion, -1, osvi.szCSDVersion, sizeof(osvi.szCSDVersion), NULL, NULL);
    osvi.wServicePackMajor = posviTargetOS->wServicePackMajor;
    osvi.wServicePackMinor = posviTargetOS->wServicePackMinor;
    osvi.wSuiteMask = posviTargetOS->wSuiteMask;
    osvi.wProductType = posviTargetOS->wProductType;
    osvi.wReserved = posviTargetOS->wReserved;

    return DuInitializeA(szBasePath, szTempPath, &osvi, szTargetArch, lcidTargetLocale, fUnattend, fUpgrade, pfnWinnt32QueryCallback);
}

// --------------------------------------------------------------------------
// Function Name: DuDoDetection
// Function Description: Does detection of Drivers on the System, compiles an 
//      internal list of items to download and how long it will take to download
//      them.
//
// Function Returns:
//      Failure: FALSE .. Call GetLastError to retrieve the Error Code
//      Success: TRUE
//
BOOL WINAPI DuDoDetection(IN HANDLE hConnection, OUT PDWORD pdwEstimatedTime, OUT PDWORD pdwEstimatedSize)
{
    LOG_block("DuDoDetection()");
    // param validation
    if (INVALID_HANDLE_VALUE == hConnection || NULL == pdwEstimatedTime || NULL == pdwEstimatedSize)
    {
        LOG_error("Invalid Parameter passed to DuDoDetection");
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    
    // clear any error set by other program
    SetLastError(0);

    if (NULL == g_hwsdueng)
    {
        // DuDoDetection was called without calling DuInitialize, our state is invalid
        LOG_error("Initialization Invalid, Engine is not Initialized");
        SetLastError(DU_NOT_INITIALIZED);
        return FALSE;
    }

    PFN_DuDoDetection fpnDuDoDetection = (PFN_DuDoDetection) GetProcAddress(g_hwsdueng, "DuDoDetection");
    if (NULL == fpnDuDoDetection)
    {
        LOG_error("Unable to find DuDoDetection entrypoint in wsdueng.dll, Critical Error");
        SetLastError(DU_ERROR_MISSING_DLL);
        return FALSE;
    }

    return fpnDuDoDetection(hConnection, pdwEstimatedTime, pdwEstimatedSize);
}


// --------------------------------------------------------------------------
// Function Name: DuBeginDownload
// Function Description: Begins Downloading based on the detection done in the DuDoDetection call.
//      Progress callbacks are made to the specified HWND. Function returns immediately, download
//      is asynchronous.
//
// Function Returns:
//      Failure: FALSE .. Call GetLastError to retrieve the Error Code
//      Success: TRUE
//
BOOL WINAPI DuBeginDownload(IN HANDLE hConnection, IN HWND hwndNotify)
{
    LOG_block("DuBeginDownload()");
    // param validation
    if (INVALID_HANDLE_VALUE == hConnection || NULL == hwndNotify)
    {
        LOG_error("Invalid Parameter passed to DuBeginDownload");
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (NULL == g_hwsdueng)
    {
        // DuDoDetection was called without calling DuInitialize, our state is invalid
        LOG_error("Initialization Invalid, Engine is not Initialized");
        SetLastError(DU_NOT_INITIALIZED);
        return FALSE;
    }

    PFN_DuBeginDownload fpnDuBeginDownload = (PFN_DuBeginDownload) GetProcAddress(g_hwsdueng, "DuBeginDownload");
    if (NULL == fpnDuBeginDownload)
    {
        LOG_error("Unable to find DuBeginDownload entrypoint in wsdueng.dll, Critical Error");
        SetLastError(DU_ERROR_MISSING_DLL);
        return FALSE;
    }

    return fpnDuBeginDownload(hConnection, hwndNotify);
}

// --------------------------------------------------------------------------
// Function Name: DuAbortDownload
// Function Description: Aborts current download.
//
// Function Returns:
//      nothing
//
void WINAPI DuAbortDownload(IN HANDLE hConnection)
{
    LOG_block("DuAbortDownload()");
    if (INVALID_HANDLE_VALUE == hConnection)
    {
        LOG_error("Invalid Parameter passed to DuAbortDownload");
        return;
    }
    
    if (NULL == g_hwsdueng)
    {
        LOG_error("Initialization Invalid, Engine is not Initialized");
        return;
    }

    PFN_DuAbortDownload fpnDuAbortDownload = (PFN_DuAbortDownload) GetProcAddress(g_hwsdueng, "DuAbortDownload");
    if (NULL == fpnDuAbortDownload)
    {
        LOG_error("Unable to find DuBeginDownload entrypoint in wsdueng.dll, Critical Error");
        return;
    }
    
    fpnDuAbortDownload(hConnection);
    return;
}


// --------------------------------------------------------------------------
// Function Name: DuUninitialize
// Function Description: Performs internal CleanUp 
//
//
// Function Returns:
//      nothing
//

void WINAPI DuUninitialize(HANDLE hConnection)
{
    LOG_block("DuUninitialize()");

    // close internet handle
    if (g_stateA.hConnect) 
    {
        if (!g_stateA.fpnInternetCloseHandle (g_stateA.hConnect))
        {
            LOG_error("InternetConnection close handle failed --- %d", GetLastError());
        }
        g_stateA.hConnect = NULL;
    }
    if (g_stateA.hInternet)
    {
        if (!g_stateA.fpnInternetCloseHandle (g_stateA.hInternet))
        {
            LOG_error("InternetOpen close handle failed --- %d", GetLastError());
        }
        g_stateA.hInternet = NULL;
    }

    // disconnect from internet if we dialed
    if (g_stateA.fDialed)
    {
        // we have dialed a connection, now we need to disconnect
        if (!g_stateA.fpnInternetAutodialHangup(0))
        {
            LOG_error("Failed to hang up");
        }
        else
            g_stateA.fDialed = FALSE;
    }
    
    if (INVALID_HANDLE_VALUE == hConnection)
    {
        LOG_error("Invalid Parameter passed to DuUninitialize");
        return;
    }

    if (NULL == g_hwsdueng)
    {
        LOG_error("Initialization Invalid, Engine is not Initialized");
        return;
    }

    PFN_DuUninitialize fpnDuUninitialize = (PFN_DuUninitialize) GetProcAddress(g_hwsdueng, "DuUninitialize");
    if (NULL == fpnDuUninitialize)
    {
        LOG_error("Unable to find DuUninitialize entrypoint in wsdueng.dll, Critical Error");
    }
    else 
        fpnDuUninitialize(hConnection);

    // free libraries
    SafeFreeLibrary(g_hwsdueng);
    SafeFreeLibrary(g_hshlwapi);
    // SafeFreeLibrary(g_hwininet); // It is not advisable to unload wininet from a process after
    //                                 it has been loaded. So sayeths the wininet devs. Let it be so.

    // re-initialize the global structure
    ZeroMemory(&g_stateA, sizeof(GLOBAL_STATEA));
    // close log file
    LOG_close();
    return;
}

// --------------------------------------------------------------------------
// Private Helper Functions
// --------------------------------------------------------------------------

// --------------------------------------------------------------------------
// Function Name: OpenHttpConnection
// Function Description: Determines whether an Internet Connection is available
//
// Function Returns:
//      ERROR_SUCCESS if conection is available, Error Code otherwise. 
//

DWORD OpenHttpConnection(LPCSTR pszServerUrl, BOOL fGetRequest, BOOL fHTTPSRequired)
{
    LOG_block("OpenHttpConnection()");
    DWORD dwErr, dwStatus, dwLength, dwFlags;
    LPSTR AcceptTypes[] = {"*/*", NULL};
    URL_COMPONENTSA UrlComponents;
    // Buffers used to Break the URL into its different components for Internet API calls
    char szServerName[INTERNET_MAX_URL_LENGTH + 1];
    char szObject[INTERNET_MAX_URL_LENGTH + 1];
    char szUserName[UNLEN+1];
    char szPasswd[UNLEN+1];

    dwErr = dwStatus = dwLength = 0;
    
    // We need to break down the Passed in URL into its various components for the InternetAPI Calls. Specifically we
    // Need the server name, object to download, username and password information.
    ZeroMemory(szServerName, INTERNET_MAX_URL_LENGTH + 1);
    ZeroMemory(szObject, INTERNET_MAX_URL_LENGTH + 1);
    ZeroMemory(&UrlComponents, sizeof(UrlComponents));
    UrlComponents.dwStructSize = sizeof(UrlComponents);
    UrlComponents.lpszHostName = szServerName;
    UrlComponents.dwHostNameLength = INTERNET_MAX_URL_LENGTH + 1;
    UrlComponents.lpszUrlPath = szObject;
    UrlComponents.dwUrlPathLength = INTERNET_MAX_URL_LENGTH + 1;
    UrlComponents.lpszUserName = szUserName;
    UrlComponents.dwUserNameLength = UNLEN + 1;
    UrlComponents.lpszPassword = szPasswd;
    UrlComponents.dwPasswordLength = UNLEN + 1;

    if (! g_stateA.fpnInternetCrackUrl(pszServerUrl, 0, 0, &UrlComponents) )
    {
        dwErr = GetLastError();
        LOG_error("InternetCrackUrl Failed, Error %d", dwErr);
        return dwErr;
    }
    
    // Initialize the InternetAPI's
    if (!g_stateA.hInternet &&
        !(g_stateA.hInternet = g_stateA.fpnInternetOpen("Dynamic Update", INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0)) )
    {
        dwErr = GetLastError();
        LOG_error("InternetOpen Failed, Error %d", dwErr);
        return dwErr;
    }

    dwStatus = 30 * 1000; // 30 seconds in milliseconds
    dwLength = sizeof(dwStatus);
    g_stateA.fpnInternetSetOption(g_stateA.hInternet, INTERNET_OPTION_SEND_TIMEOUT, &dwStatus, dwLength);

    if (g_stateA.hConnect)
    {
        g_stateA.fpnInternetCloseHandle(g_stateA.hConnect); 
    }
    // Open a session for the Target Server
    if (!(g_stateA.hConnect = g_stateA.fpnInternetConnect(g_stateA.hInternet, 
                                                                                     szServerName, 
                                                                                     (fHTTPSRequired) ? INTERNET_DEFAULT_HTTPS_PORT : (UrlComponents.nScheme == INTERNET_SCHEME_HTTPS) ? INTERNET_DEFAULT_HTTPS_PORT : INTERNET_DEFAULT_HTTP_PORT, 
                                                                                     szUserName, 
                                                                                     szPasswd, 
                                                                                     INTERNET_SERVICE_HTTP,
                                                                                     INTERNET_FLAG_NO_UI | INTERNET_FLAG_RELOAD, 0)))
    {
        dwErr = GetLastError();
        LOG_error("InternetConnect Failed, Error %d", dwErr);
        return dwErr;
    }
    
    if (fHTTPSRequired || UrlComponents.nScheme == INTERNET_SCHEME_HTTPS)
    {
        dwFlags = INTERNET_FLAG_KEEP_CONNECTION | INTERNET_FLAG_NO_UI | INTERNET_FLAG_SECURE;
    }
    else
    {
        dwFlags = INTERNET_FLAG_KEEP_CONNECTION | INTERNET_FLAG_NO_UI;
    }

    // Create a Request for the File we're going to download
    if (! (g_stateA.hOpenRequest = g_stateA.fpnHttpOpenRequest(g_stateA.hConnect, 
                            (fGetRequest) ? NULL /*GET*/ : "HEAD", 
                            szObject, 
                            NULL /*HTTP1.0*/, 
                            NULL, 
                            (LPCSTR *)AcceptTypes, 
                            dwFlags,
                            0)) )
    {
        dwErr = GetLastError();
        LOG_error("HttpOpenRequest Failed, Error %d", dwErr);
        return dwErr;
    }

    int nNumOfTrial = 0;
    do
    {
        // Send the Request for the File. This will attempt to establish a connection to the internet if one does not 
        // already exist --- As October 17, 2000, an connection is guaranteed to be established at this point (RogerJ)
        if (! g_stateA.fpnHttpSendRequest(g_stateA.hOpenRequest, NULL, 0, NULL, 0) )
        {
            dwErr = GetLastError();
            LOG_error("HttpSendRequest Failed, Error %d", dwErr);
            return dwErr;
        }

        // Determine the HTTP Status Result, did the Request Succeed?
        dwLength = sizeof(dwStatus);
        if (! g_stateA.fpnHttpQueryInfo(g_stateA.hOpenRequest, HTTP_QUERY_STATUS_CODE | HTTP_QUERY_FLAG_NUMBER, 
            (LPVOID)&dwStatus, &dwLength, NULL) )
        {
            dwErr = GetLastError();
            LOG_error("HttpQueryInfo Failed, Error %d", dwErr);
            return dwErr;
        }
        nNumOfTrial++;
    } while (NeedRetry(dwStatus) && nNumOfTrial < DU_CONNECTION_RETRY);

    // ROGERJ, if the site is found but the URL is not in the site, instead of return connection unavailable,
    // will return the actual error --- 404

    // If the Request did not succeed we'll assume we have no internet connection and return the Error Code
    // that Setup will trigger a warning to the user to manually establish a connection.
    if ((HTTP_STATUS_OK != dwStatus) && (HTTP_STATUS_PARTIAL_CONTENT != dwStatus))
    {
        LOG_error("Http Status NOT OK, Status %d", dwStatus);
        if (HTTP_STATUS_NOT_FOUND == dwStatus)
             return ERROR_INTERNET_INVALID_URL;
        else return ERROR_CONNECTION_UNAVAIL;
    }
    

    return ERROR_SUCCESS;
}


// --------------------------------------------------------------------------
// Function Name: DoSelfUpdate
// Function Description: Connects to the Internet and Attempts to Selfupdate
//      the dynamic update code.
//
// Function Returns:
//      nothing - failure to selfupdate is not catastrophic
//

DWORD DoSelfUpdate(LPCSTR pszTempPath, LPCSTR pszServerUrl, WORD wProcessorArchitecture)
{
    LOG_block("DoSelfUpdate()");
    if ((NULL == pszTempPath) || (NULL == pszServerUrl) || (lstrlen(pszTempPath) > MAX_PATH))
    {
        return 0;
    }

    char szINIFile[MAX_PATH];
    if (FAILED(StringCchCopy(szINIFile, ARRAYSIZE(szINIFile), pszTempPath))) 
    {
        return 0;
    }
    g_stateA.fpnPathAppend(szINIFile, "ident.txt");
    DWORD dwRet;
    DWORD dwBytesPerSecond = 0;
    SYSTEM_INFO    sysInfo;    

#define DUHEADER "DuHeader"

    char szSection[MAX_PATH];
    char szValue[MAX_PATH];
    char szKey[MAX_PATH];
    char szUrl[INTERNET_MAX_URL_LENGTH];

    GetPrivateProfileString(DUHEADER, "server", "", szSection, sizeof(szSection), szINIFile);
    if ('\0' == szSection[0])
    {
        if (FAILED(StringCchCopyA(szUrl, ARRAYSIZE(szUrl), pszServerUrl))) 
        {
            return 0;
        }
    }
    else
    {
        GetPrivateProfileString(szSection, "server", "", szValue, sizeof(szValue), szINIFile);
        if ('\0' == szValue[0])
        {
            if (FAILED(StringCchCopyA(szUrl, ARRAYSIZE(szUrl), pszServerUrl))) 
            {
                return 0;
            }
        }
        else
        {
            if (FAILED(StringCchCopyA(szUrl, ARRAYSIZE(szUrl), szValue))) 
            {
                return 0;
            }
        }
    }

    // RogerJ, we find out the processor type based on the parameter passed in
    // find out what type of processor this machine has
    switch ( wProcessorArchitecture )
    {
    case PROCESSOR_ARCHITECTURE_INTEL:
        if (FAILED(StringCchCopy(szKey, ARRAYSIZE(szKey), "x86"))) 
        {
            return 0;
        }
        break;
    case PROCESSOR_ARCHITECTURE_IA64:
        if (FAILED(StringCchCopy(szKey, ARRAYSIZE(szKey), "ia64"))) 
        {
            return 0;
        }
        break;
    default:
        LOG_error("Failed to Determine Processor Architecture");
        return 0;
    }


    GetPrivateProfileString(DUHEADER, "arch", "", szSection, sizeof(szSection), szINIFile);
    if ('\0' == szSection[0])
    {
        LOG_error("Failed to get Arch Section Name from Ident");
        return 0;
    }

    // Get the Directory Name of the Processor Architecture. 
    GetPrivateProfileString(szSection, szKey, "", szValue, sizeof(szValue), szINIFile);
    if ('\0' == szValue[0])
    {
        LOG_error("Failed to get Directory name for Arch from Ident");
        return 0;
    }
    if (FAILED(StringCchCat(szUrl, ARRAYSIZE(szUrl), szValue)))
    {
        return 0;
    }

    GetPrivateProfileString(DUHEADER, "os", "", szSection, sizeof(szSection), szINIFile);
    if ('\0' == szSection[0])
    {
        LOG_error("Failed to get OS Section Name from Ident");
        return 0;
    }

    // get local os information
    OSVERSIONINFO OsInfo;
    ZeroMemory( (PVOID) &OsInfo, sizeof (OsInfo) );
    OsInfo.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);
    if (!GetVersionEx( &OsInfo ))
    {
        // Function call failed, last error is set by GetVersionEx()
        return 0;
    }

    #define LOCAL_OS_BUFFER 10
    char szLocalOS[LOCAL_OS_BUFFER];
    ZeroMemory(szLocalOS, LOCAL_OS_BUFFER * sizeof(char));
    
    if ( VER_PLATFORM_WIN32_NT == OsInfo.dwPlatformId )
    {
        // WinNT, DU driver is supported only from W2K and up
        if ( 4 >= OsInfo.dwMajorVersion )
        {
            // NT 3.51 or NT 4.0
            if (FAILED(StringCchCopy(szLocalOS, ARRAYSIZE(szLocalOS), "nt4"))) 
            {
                return 0;
            }
            
        }
        else if ( 5 == OsInfo.dwMajorVersion)
        {
            if ( 0 == OsInfo.dwMinorVersion)
            {
                // Win2K
                if (FAILED(StringCchCopy(szLocalOS, ARRAYSIZE(szLocalOS), "nt5"))) 
                {
                    return 0;
                }
            }
            else
            {
                // WinXP
                if (FAILED(StringCchCopy(szLocalOS, ARRAYSIZE(szLocalOS), "whi"))) 
                {
                    return 0;
                }
            }
        }
        else
        {
            // Blackcomb? not supported
            LOG_error("OS major version is %d, not supported", OsInfo.dwMajorVersion);
            return 0;
        }
            
    }
    else if ( VER_PLATFORM_WIN32_WINDOWS == OsInfo.dwPlatformId )
    {
        
        if ( 0 == OsInfo.dwMinorVersion )
        {
            // Win 95
            if (FAILED(StringCchCopy(szLocalOS, ARRAYSIZE(szLocalOS), "w95"))) 
            {
                return 0;
            }
        }
        else if (90 <= OsInfo.dwMinorVersion)
        {
            // WinME
            if (FAILED(StringCchCopy(szLocalOS, ARRAYSIZE(szLocalOS), "mil"))) 
            {
                return 0;
            }
        }
        else 
        {
            // Win 98 and Win 98SE
            if (FAILED(StringCchCopy(szLocalOS, ARRAYSIZE(szLocalOS), "w98"))) 
            {
                return 0;
            }
        }
    }
    else
    {
        // Win 3.x and below
        LOG_error("Win 3.x and below? not supported");
        return 0;
    }

    GetPrivateProfileString(szSection, szLocalOS, "", szValue, sizeof(szValue), szINIFile);
    if ('\0' != szValue[0])
    {
        if (FAILED(StringCchCat(szUrl, ARRAYSIZE(szUrl), szValue)))
        {
            return 0;
        }
    }
    
    // The self update server name is: DynamicUpdate\x86\"os name"
    // The Locale is not necessary since dynamic update is not localized.

    // potentially the self update URL is not the same server as the site URL,
    // so we need to close the connection handle and internet handle here
    if (g_stateA.hConnect) 
    {
        if (!g_stateA.fpnInternetCloseHandle (g_stateA.hConnect))
        {
            LOG_error("InternetConnection close handle failed --- %d", GetLastError());
        }
        g_stateA.hConnect = NULL;
    }
    if (g_stateA.hInternet)
    {
        if (!g_stateA.fpnInternetCloseHandle (g_stateA.hInternet))
        {
            LOG_error("InternetOpen close handle failed --- %d", GetLastError());
        }
        g_stateA.hInternet = NULL;
    }


    // Now we have the server path, try to download the wsdueng.cab file.
    char szServerFile[INTERNET_MAX_URL_LENGTH];
    char szLocalFile[MAX_PATH];
    DuUrlCombine(szServerFile, INTERNET_MAX_URL_LENGTH, szUrl, "wsdueng.cab");

    if (FAILED(StringCchCopy(szLocalFile, ARRAYSIZE(szLocalFile), pszTempPath))) 
    {
        return 0;
    }
    g_stateA.fpnPathAppend(szLocalFile, "wsdueng.cab");
    dwRet = DownloadFile(szServerFile, szLocalFile, TRUE, TRUE, FALSE, &dwBytesPerSecond);
    
    // potentially the self update URL is not the same server as the site URL,
    // so we need to close the connection handle and internet handle here
    if (g_stateA.hConnect) 
    {
        if (!g_stateA.fpnInternetCloseHandle (g_stateA.hConnect))
        {
            LOG_error("InternetConnection close handle failed --- %d", GetLastError());
        }
        g_stateA.hConnect = NULL;
    }
    if (g_stateA.hInternet)
    {
        if (!g_stateA.fpnInternetCloseHandle (g_stateA.hInternet))
        {
            LOG_error("InternetOpen close handle failed --- %d", GetLastError());
        }
        g_stateA.hInternet = NULL;
    }
    if (ERROR_SUCCESS == dwRet)
    {
        return dwBytesPerSecond;        
    }
    return 0;
}

// --------------------------------------------------------------------------
// Function Name: DownloadFile
// Function Description: Connects to the Internet and Attempts to Selfupdate
//      the dynamic update code.
//
// Function Returns:
//      ERROR_SUCCESS if all is OK, Error Code from GetLastError otherwise
//

DWORD DownloadFile(LPCSTR pszUrl, LPCSTR pszDestinationFile, BOOL fDecompress, BOOL fCheckTrust, BOOL fHTTPSRequired, DWORD *pdwDownloadBytesPerSecond)
{
    LOG_block("DownloadFile()");
    DWORD dwErr, dwFileSize, dwLength;
    DWORD dwBytesRead, dwBytesWritten;
    DWORD dwCount1, dwCount2, dwElapsedTime;
    SYSTEMTIME st;
    FILETIME ft;
    HANDLE hTargetFile;

    LOG_out("Downloading file URL %s", pszUrl);
    
    if (pdwDownloadBytesPerSecond)
        *pdwDownloadBytesPerSecond = 0; // might be used as an error message in DoSelfUpdate
        
    dwErr = OpenHttpConnection(pszUrl, FALSE, fHTTPSRequired);
    if (ERROR_SUCCESS != dwErr)
    {
        LOG_error("OpenHttpConnection Failed, Error %d", dwErr);
        SetLastError(dwErr);
        return dwErr;
    }
 
    // Now Get The System Time information from the Server
    dwLength = sizeof(st);
    if (! g_stateA.fpnHttpQueryInfo(g_stateA.hOpenRequest, HTTP_QUERY_LAST_MODIFIED | HTTP_QUERY_FLAG_SYSTEMTIME, 
        (LPVOID)&st, &dwLength, NULL) )
    {
        dwErr = GetLastError();
        LOG_error("HttpQueryInfo Failed, Error %d", dwErr);
        g_stateA.fpnInternetCloseHandle(g_stateA.hOpenRequest);
        g_stateA.hOpenRequest = NULL;
        return dwErr;
    }

    SystemTimeToFileTime(&st, &ft);
    
    // Now Get the FileSize information from the Server
    dwLength = sizeof(dwFileSize);
    if (! g_stateA.fpnHttpQueryInfo(g_stateA.hOpenRequest, HTTP_QUERY_CONTENT_LENGTH | HTTP_QUERY_FLAG_NUMBER, 
        (LPVOID)&dwFileSize, &dwLength, NULL) )
    {
        dwErr = GetLastError();
        LOG_error("HttpQueryInfo Failed, Error %d", dwErr);
        g_stateA.fpnInternetCloseHandle(g_stateA.hOpenRequest);
        g_stateA.hOpenRequest = NULL;
        return dwErr;
    }

    // Determine if we need to download the Server File
    if (IsServerFileNewer(ft, dwFileSize, pszDestinationFile))
    {
        dwErr = OpenHttpConnection(pszUrl, TRUE, fHTTPSRequired);
        if (ERROR_SUCCESS != dwErr)
        {
            LOG_error("OpenHttpConnection Failed, Error %d", dwErr);
            SetLastError(dwErr);
            return dwErr;
        }
#define DOWNLOAD_BUFFER_LENGTH 32 * 1024

        PBYTE lpBuffer = (PBYTE) GlobalAlloc(GMEM_ZEROINIT, DOWNLOAD_BUFFER_LENGTH);
        if (NULL == lpBuffer)
        {
            dwErr = GetLastError();
            LOG_error("GlobalAlloc Failed to Alloc Buffer for FileDownload, Error %d", dwErr);
            g_stateA.fpnInternetCloseHandle(g_stateA.hOpenRequest);
            g_stateA.hOpenRequest = NULL;
            return dwErr;
        }

        hTargetFile = CreateFileA(pszDestinationFile, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if (INVALID_HANDLE_VALUE == hTargetFile)
        {
            dwErr = GetLastError();
            LOG_error("Unable to Open Target File %s for Write, Error %d", pszDestinationFile, dwErr);
            SafeGlobalFree(lpBuffer);
            g_stateA.fpnInternetCloseHandle(g_stateA.hOpenRequest);
            g_stateA.hOpenRequest = NULL;
            return dwErr;
        }

        // Download the File
        dwCount1 = GetTickCount();
        while (g_stateA.fpnInternetReadFile(g_stateA.hOpenRequest, lpBuffer, DOWNLOAD_BUFFER_LENGTH, &dwBytesRead))
        {
            if (dwBytesRead == 0)
            {

                // window95 with IE4.01 with finish reading with successful return value but set last error to 126
                if (ERROR_SUCCESS != (dwErr=GetLastError()))
                    {
                        LOG_error("Error %d setted when finishing InternetReadFile",dwErr);
                        SetLastError(0);
                    }
                break; // done reading.
            }
            if (!WriteFile(hTargetFile, lpBuffer, dwBytesRead, &dwBytesWritten, NULL))
            {
                dwErr = GetLastError();
                LOG_error("Unable to Write to Target File %s, Error %d", pszDestinationFile, dwErr);
                SafeGlobalFree(lpBuffer);
                g_stateA.fpnInternetCloseHandle(g_stateA.hOpenRequest);
                g_stateA.hOpenRequest = NULL;
                return dwErr;
            }
        }
        dwCount2 = GetTickCount();
        dwElapsedTime = dwCount2 - dwCount1;
        dwElapsedTime /= 1000; // number of seconds elapsed
        if (0 == dwElapsedTime)
            dwElapsedTime = 1; // at least one second.

        if (NULL != pdwDownloadBytesPerSecond)
        {
            *pdwDownloadBytesPerSecond = dwFileSize / dwElapsedTime; // number of bytes per second
        }

        dwErr = GetLastError();
        if (ERROR_SUCCESS != dwErr)
        {
            LOG_error("InternetReadFile Failed, Error %d", dwErr);
            SafeGlobalFree(lpBuffer);
            g_stateA.fpnInternetCloseHandle(g_stateA.hOpenRequest);
            g_stateA.hOpenRequest = NULL;
            return dwErr;
        }

        // Make one final call to InternetReadFile to commit the file to Cache (downloaded is not complete otherwise)
        BYTE bTemp[32];
        g_stateA.fpnInternetReadFile(g_stateA.hOpenRequest, bTemp, 32, &dwBytesRead);

        SafeCloseHandle(hTargetFile);
        SafeGlobalFree(lpBuffer);

        // check for CheckTrust requested
        if (fCheckTrust)
        {
            HRESULT hr = S_OK;
            // change to verifyFile() by ROGERJ at Sept. 25th, 2000
            // 2nd parameter set to false to prevent UI from poping up when a bad cert is found
            // change to TRUE for testing purpose on October 12th, 2000

            // add unattended mode at October 17th, 2000
            // if we are in unattended mode, then we do want to pop up an UI
            if (FAILED(hr = VerifyFile(pszDestinationFile, !g_stateA.fUnattended)))
            {
                // On failure of CERT.. fail download.
                LOG_error("CabFile %s does not have a valid Signature", pszDestinationFile);
                
                g_stateA.fpnInternetCloseHandle(g_stateA.hOpenRequest);
                g_stateA.hOpenRequest = NULL;

                return HRESULT_CODE(hr);
            }
        }

        if (fDecompress)
        {
            char szLocalDir[MAX_PATH];
            if (FAILED(StringCchCopy(szLocalDir, ARRAYSIZE(szLocalDir), pszDestinationFile))) 
            {
                return 0;
            }
            g_stateA.fpnPathRemoveFileSpec(szLocalDir);
            fdi(const_cast<char *>(pszDestinationFile), szLocalDir);
        }
    }

    // Always close the Request when the file is finished.
    // We intentionally leave the connection to the server Open though, seems more
    // efficient when requesting multiple files from the same server.
    g_stateA.fpnInternetCloseHandle(g_stateA.hOpenRequest);
    g_stateA.hOpenRequest = NULL;
    return ERROR_SUCCESS;
}

BOOL IsServerFileNewer(FILETIME ftServerTime, DWORD dwServerFileSize, LPCSTR pszLocalFile)
{
    HANDLE hFile = INVALID_HANDLE_VALUE;
    FILETIME ftCreateTime;
    LONG lTime;
    DWORD dwLocalFileSize;

    hFile = CreateFile(pszLocalFile, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (INVALID_HANDLE_VALUE != hFile)
    {
        dwLocalFileSize = GetFileSize(hFile, NULL);
        if (dwLocalFileSize != dwServerFileSize)
        {
            SafeCloseHandle(hFile);
            return TRUE; // server and local files do not match, download server file.
        }

        if (GetFileTime(hFile, &ftCreateTime, NULL, NULL))
        {
            lTime = CompareFileTime(&ftCreateTime, &ftServerTime);
            if (lTime < 0)
            {
                SafeCloseHandle(hFile);
                return TRUE; // local file is 'older' than the server file
            }
            else
            {
                SafeCloseHandle(hFile);
                return FALSE; // local file is either equal or newer, leave it.
            }
        }
    }
    // if we couldn't find the file, or we couldn't get the time, assume the server file is newer
    SafeCloseHandle(hFile);
    return TRUE;
}

// cchDest is the maximum buffer size of pszDest, including the NULL terminator
LPSTR DuUrlCombine(LPSTR pszDest, size_t cchDest, LPCSTR pszBase, LPCSTR pszAdd)
{
    if ((NULL == pszDest) || (NULL == pszBase) || (NULL == pszAdd))
    {
        return NULL;
    }

    if (FAILED(StringCchCopy(pszDest, cchDest, pszBase))) 
    {
        return NULL;
    }
    int iLen = lstrlen(pszDest);
    if ('/' == pszDest[iLen - 1])
    {
        // already has a trailing slash, check the 'add' string for a preceding slash
        if ('/' == *pszAdd)
        {
            // has a preceding slash, skip it.
            if (FAILED(StringCchCat(pszDest, cchDest, pszAdd + 1)))
            {
                return 0;
            }
        }
        else
        {
            if (FAILED(StringCchCat(pszDest, cchDest, pszAdd)))
            {
                return 0;
            }
        }
    }
    else
    {
        // no trailing slash, check the add string for a preceding slash
        if ('/' == *pszAdd)
        {
            // has a preceding slash, Add Normally
            if (FAILED(StringCchCat(pszDest, cchDest, pszAdd)))
            {
                return 0;
            }
        }
        else
        {
            if (FAILED(StringCchCat(pszDest, cchDest, "/")))
            {
                return 0;
            }
            if (FAILED(StringCchCat(pszDest, cchDest, pszAdd)))
            {
                return 0;
            }
        }
    }
    return pszDest;
}


// RogerJ, October 2nd, 2000

// ---------------------------------------------------------------------------
// Function Name: DuQueryUnsupportedDriversA
// Function Description: Called by Win9x setup to get the size of total download
//         instead of DuDoDetection()
// Function Returns: BOOL
//        TRUE if succeed
//        FALSE if failed, call GetLastError() to get error information
//
BOOL WINAPI DuQueryUnsupportedDriversA( IN HANDLE hConnection, // connection handle
                                        IN PCSTR* ppszListOfDriversNotOnCD, // list of drivers not on setup CD
                                        OUT PDWORD pdwTotalEstimateTime, // estimate download time
                                        OUT PDWORD pdwTotalEstimateSize // estimate size
                                      )
{
    LOG_block("DuQueryUnsupportedDriversA()");
    // param validation
    if (INVALID_HANDLE_VALUE == hConnection || 
        NULL == pdwTotalEstimateTime || 
        NULL == pdwTotalEstimateSize)
    {
        LOG_error("Invalid Parameter passed to DuDoDetection");
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    // clear any error set by other program
    SetLastError(0);

    PCSTR* ppTemp = NULL;
    
    // passing in NULL for PLIST means that no driver download is needed
    if (!ppszListOfDriversNotOnCD  // NULL pointer
        || !(*ppszListOfDriversNotOnCD) // pointer to a NULL
        || !(**ppszListOfDriversNotOnCD)) // pointer to an empty string
        LOG_out("No driver download is needed");
    else
        ppTemp = ppszListOfDriversNotOnCD;

    if (NULL == g_hwsdueng)
    {
        // DuDoDetection was called without calling DuInitialize, our state is invalid
        LOG_error("Initialization Invalid, Engine is not Initialized");
        SetLastError(DU_NOT_INITIALIZED);
        return FALSE;
    }

    PFN_DuQueryUnsupportedDrivers fpnDuQueryUnsupportedDrivers = 
        (PFN_DuQueryUnsupportedDrivers) GetProcAddress(g_hwsdueng, "DuQueryUnsupportedDriversA");
        
    if (NULL == fpnDuQueryUnsupportedDrivers)
    {
        LOG_error("Unable to find DuQueryUnsupporedDrivers entrypoint in wsdueng.dll, Critical Error");
        SetLastError(DU_ERROR_MISSING_DLL);
        return FALSE;
    }

    return fpnDuQueryUnsupportedDrivers(hConnection, ppTemp, pdwTotalEstimateTime, pdwTotalEstimateSize);

}


// ---------------------------------------------------------------------------
// Function Name: DuQueryUnsupportedDriversW
// Function Description: Could be called by WinNT setup to get the size of total download
//         instead of DuDoDetection()
// Function Returns: BOOL
//        TRUE if succeed
//        FALSE if failed, call GetLastError() to get error information
//
BOOL WINAPI DuQueryUnsupportedDriversW( IN HANDLE hConnection, // connection handle
                                        IN PCWSTR* ppwszListOfDriversNotOnCD, // list of drivers not on setup CD
                                        OUT PDWORD pdwTotalEstimateTime, // estimate download time
                                        OUT PDWORD pdwTotalEstimateSize // estimate size
                                      )
{
    // this function will only convert every string in ppwszListOfDriversNotOnCD to ANSI and call the ANSI version
    LOG_block("DuQueryUnsupportedDriversW");

    BOOL fRetValue = TRUE;
    LPSTR* ppszTempList = NULL;

    if (ppwszListOfDriversNotOnCD   // NULL pointer
        && *ppwszListOfDriversNotOnCD  // pointer points to a NULL value
        && **ppwszListOfDriversNotOnCD) // pointer points to an empty string
    {
    
        // get the count of the strings in the ppwszListOfDriversNotOnCD array
        PWSTR* ppwszTemp = const_cast<PWSTR*>(ppwszListOfDriversNotOnCD);
        int nCount = 0;

        while (*ppwszTemp)
        {
            ppwszTemp++;
            nCount++;
        }

        ppszTempList = (LPSTR*) new LPSTR [nCount+1];
        
        if (!ppszTempList)
        {
            LOG_error("Out of memory");
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
        }
        
        ZeroMemory(ppszTempList, (nCount+1)*sizeof(LPSTR));
        
        // reset ppwszTemp to the beginning of the list
        ppwszTemp = const_cast<PWSTR*>(ppwszListOfDriversNotOnCD);
    
        for (int i=0; i<nCount; i++, ppwszTemp++)
        {
            // the ppwszListOfDriversNotOnCD is an array of multi-sz list, we CAN NOT use lstrlenW to 
            // determine the length
            int nSizeSZ = 0;
            wchar_t* pwszTemp = *ppwszTemp;
            while (*pwszTemp)
            {
                int nTempLength = lstrlenW(pwszTemp)+1;
                nSizeSZ += nTempLength;
                pwszTemp += nTempLength;
            }
            nSizeSZ ++; // for trailing NULL

            char* pszTempContent = new char [nSizeSZ];
            if (!pszTempContent)
            {
                LOG_error("Out of memory");
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                fRetValue = FALSE;
                goto CleanUp;
            }
        
            // convert
            if ( 0 == WideCharToMultiByte( CP_ACP, // code page
                             0, // use default flags
                             *ppwszTemp, // wide char string
                             nSizeSZ, // number of characters in wide char string
                             pszTempContent, // ANSI char string
                             nSizeSZ, // length
                             NULL,
                             NULL))
        
            {
                LOG_error("Wide char to ANSI convertion error");
                fRetValue = FALSE;
                goto CleanUp;
            }
    
            // add converted string to list
            ppszTempList[i] = pszTempContent;
        }
    }
    // call ANSI function
    fRetValue = DuQueryUnsupportedDriversA (hConnection,
                                            (LPCSTR*)ppszTempList,
                                            pdwTotalEstimateTime,
                                            pdwTotalEstimateSize);

    // clean up
CleanUp:

    // delete the list
    if (ppszTempList)
    {
        PSTR* ppszCleanUp = ppszTempList;
        while (*ppszCleanUp)
        {
            // delete content
            char* pszTemp = *ppszCleanUp;
            delete [] pszTemp;
            *ppszCleanUp = NULL;

            // move to next one
            ppszCleanUp++;
        }

        delete [] ppszTempList;
    }
    return fRetValue;
                             
}
                                      


BOOL MyGetFileVersion (LPSTR szFileName, VS_FIXEDFILEINFO& vsVersion)
{
    LOG_block("WsDu --- GetFileVersion");
    
    DWORD dwDummy = 0;    
    int nSize = 0;
    PBYTE pBuffer = NULL;
    BOOL fRetValue = FALSE;
    VS_FIXEDFILEINFO* pTemp = NULL;

    if (!szFileName || !*szFileName) return FALSE;

    LOG_out("FileName = %s", szFileName);

    // clear the version to 0
    ZeroMemory ((PVOID)&vsVersion, sizeof(VS_FIXEDFILEINFO));

    // get the file version
    // 1. get the buffer size we need to allocate
    if (!(nSize= GetFileVersionInfoSize (szFileName, &dwDummy)))
    {
        LOG_error("Can not get the file version info size --- %d", GetLastError());
        goto ErrorReturn;
    }

    // 2. allocate the buffer
    pBuffer = (PBYTE) new BYTE [nSize];
    if (!pBuffer)
    {
        LOG_error("Out of memory");
        goto ErrorReturn;
    }

    // 3. get file version info
    if (!GetFileVersionInfo(szFileName, 
                        0, // ignored
                        nSize, // size
                        (PVOID) pBuffer)) // buffer
    {
        LOG_error("Can not get file version --- %d", GetLastError());
        goto ErrorReturn;
    }

    // 4. get the version number
    if (!VerQueryValue( (PVOID) pBuffer, "\\", (LPVOID *)&pTemp, (PUINT) &dwDummy))
    {
        LOG_error("File version info not exist");
        goto ErrorReturn;
    }

    vsVersion.dwFileVersionMS = pTemp->dwFileVersionMS;
    vsVersion.dwFileVersionLS = pTemp->dwFileVersionLS;
    vsVersion.dwProductVersionMS = pTemp->dwProductVersionMS;
    vsVersion.dwProductVersionLS = pTemp->dwProductVersionLS;

    LOG_out("File version for %s is %d.%d.%d.%d", szFileName, 
        HIWORD(vsVersion.dwFileVersionMS), LOWORD(vsVersion.dwFileVersionMS), 
        HIWORD(vsVersion.dwFileVersionLS), LOWORD(vsVersion.dwFileVersionLS));
    
    fRetValue = TRUE;
    
ErrorReturn:
    if (pBuffer) delete [] pBuffer;
    return fRetValue;
}
    

int CompareFileVersion(VS_FIXEDFILEINFO& vs1, VS_FIXEDFILEINFO& vs2)
{
    if (vs1.dwFileVersionMS > vs2.dwFileVersionMS)
        return 1;
    else if (vs1.dwFileVersionMS == vs2.dwFileVersionMS)
    {
        if (vs1.dwFileVersionLS > vs2.dwFileVersionLS)
            return 1;
        else if (vs1.dwFileVersionLS == vs2.dwFileVersionLS)
            return 0;
        else return -1;
    }
    else return -1;
        
}
    
        
BOOL NeedRetry(DWORD dwErrCode)
{
    BOOL bRetry = FALSE;
    bRetry =   ((dwErrCode == ERROR_INTERNET_CONNECTION_RESET)      //most common
             || (dwErrCode == HTTP_STATUS_NOT_FOUND)                //404
             || (dwErrCode == ERROR_HTTP_HEADER_NOT_FOUND)            //seen sometimes
             || (dwErrCode == ERROR_INTERNET_OPERATION_CANCELLED)   //dont know if..
             || (dwErrCode == ERROR_INTERNET_ITEM_NOT_FOUND)        //..these occur..
             || (dwErrCode == ERROR_INTERNET_OUT_OF_HANDLES)        //..but seem most..
             || (dwErrCode == ERROR_INTERNET_TIMEOUT));             //..likely bet
    return bRetry;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuv3\wsdu\wsdueng\dynamic.h ===
typedef BOOL (WINAPI * PWINNT32QUERY)(IN DWORD dwSetupQueryID, IN PVOID pinData, IN DWORD dwDataSize, IN OUT PVOID poutData, IN OUT PDWORD pdwDataSize);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuv3\wsdu\wsdueng\fdi.cpp ===
#include "wsdueng.h"
#include <io.h>
#include <sys/stat.h>
#include <fcntl.h>

/*
 * Function prototypes 
 */
BOOL	fdi(char *cabinet_file, char *dir);
int		get_percentage(unsigned long a, unsigned long b);
char   *return_fdi_error_string(int err);


/*
 * Destination directory for extracted files
 */
char	dest_dir[256];

/*
 * Memory allocation function
 */
FNALLOC(mem_alloc)
{
	return malloc(cb);
}

/*
 * Memory free function
 */
FNFREE(mem_free)
{
	free(pv);
}


FNOPEN(file_open)
{
	return _open(pszFile, oflag, pmode);
}


FNREAD(file_read)
{
	return _read((int)hf, pv, cb);
}


FNWRITE(file_write)
{
	return _write((int)hf, pv, cb);
}


FNCLOSE(file_close)
{
	return _close((int)hf);
}


FNSEEK(file_seek)
{
	return _lseek((int)hf, dist, seektype);
}


FNFDINOTIFY(notification_function)
{
	switch (fdint)
	{
		case fdintCABINET_INFO: // general information about the cabinet
			return 0;

		case fdintPARTIAL_FILE: // first file in cabinet is continuation
			return 0;

		case fdintCOPY_FILE:	// file to be copied
		{
        	INT_PTR		handle;
            int		response;
			char	destination[256];

            
			StringCchPrintfA(destination,ARRAYSIZE(destination),"%s%s",dest_dir,pfdin->psz1);


            handle = file_open(
					destination,
					_O_BINARY | _O_CREAT | _O_WRONLY | _O_SEQUENTIAL,
					_S_IREAD | _S_IWRITE 
				);

            return handle;
		}

		case fdintCLOSE_FILE_INFO:	// close the file, set relevant info
        {
            HANDLE  handle;
            DWORD   attrs;
            char    destination[256];
            
			
			StringCchPrintf(destination,ARRAYSIZE(destination),"%s%s",dest_dir,pfdin->psz1);
			file_close(pfdin->hf);


            handle = CreateFile(
                destination,
                GENERIC_READ | GENERIC_WRITE,
                FILE_SHARE_READ,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL
            );

            if (handle != INVALID_HANDLE_VALUE)
            {
                FILETIME    datetime;

                if (TRUE == DosDateTimeToFileTime(
                    pfdin->date,
                    pfdin->time,
                    &datetime))
                {
                    FILETIME    local_filetime;

                    if (TRUE == LocalFileTimeToFileTime(
                        &datetime,
                        &local_filetime))
                    {
                        (void) SetFileTime(
                            handle,
                            &local_filetime,
                            NULL,
                            &local_filetime
                        );
                     }
                }

                CloseHandle(handle);
            }

            attrs = pfdin->attribs;

            attrs &= (_A_RDONLY | _A_HIDDEN | _A_SYSTEM | _A_ARCH);

            (void) SetFileAttributes(
                destination,
                attrs
            );

			return TRUE;
        }

		case fdintNEXT_CABINET:	// file continued to next cabinet
			return 0;
        
	}
	return 0;
}


BOOL fdi(char *cabinet_fullpath, char * directory)
{
	LOG_block("fdi()");
	HFDI			hfdi;
	ERF				erf;
	FDICABINETINFO	fdici;
	INT_PTR				hf;
	char			*p;
	char			cabinet_name[256];
	char			cabinet_path[256];

	HRESULT hr=S_OK;
	DWORD dwError=0;


	hr=StringCchCopy(dest_dir,ARRAYSIZE(dest_dir),directory);
	if(FAILED(hr))
	{
		dwError=HRESULT_CODE(hr);
		SetLastError(dwError);
		LOG_error("StringCchCopy Failed ErrorCode:%d",dwError);
		return FALSE;
	}

	if (dest_dir[strlen(dest_dir)] != '\\')
	{
		hr=StringCchCat(dest_dir,ARRAYSIZE(dest_dir),"\\");
		if(FAILED(hr))
		{
			dwError=HRESULT_CODE(hr);
			LOG_error("StringCchCat Failed ErrorCode:%d",dwError);
			SetLastError(dwError);
			return FALSE;
		}

	}

	hfdi = FDICreate(
		mem_alloc,
		mem_free,
		file_open,
		file_read,
		file_write,
		file_close,
		file_seek,
		cpu80386,
		&erf
	);

	if (hfdi == NULL)
	{
		LOG_error("FDICreate() failed: code %d [%s]\n", erf.erfOper, return_fdi_error_string(erf.erfOper));
		return FALSE;
	}


	/*
	 * Is this file really a cabinet?
	 */
	hf = file_open(
		cabinet_fullpath,
		_O_BINARY | _O_RDONLY | _O_SEQUENTIAL,
		0
	);

	if (hf == -1)
	{
		(void) FDIDestroy(hfdi);

		LOG_error("Unable to open '%s' for input\n", cabinet_fullpath);
		return FALSE;
	}

	if (FALSE == FDIIsCabinet(
			hfdi,
			hf,
			&fdici))
	{
		// The file is not compressed, nothing to do. This is not an error, A lot of files on the V3 server use
		// conditional compression depending on whether it benefits the file size. 
		_close((int)hf);

		(void) FDIDestroy(hfdi);
		return FALSE;
	}
	else
	{
		_close((int)hf);
	}

	p = strrchr(cabinet_fullpath, '\\');

	if (p == NULL)
	{
		hr=StringCchCopy(cabinet_name,ARRAYSIZE(cabinet_name),cabinet_fullpath);
		if(FAILED(hr))
		{
			dwError=HRESULT_CODE(hr);
			LOG_error("StringCchCopy Failed ErrorCode:%d",dwError);
			SetLastError(dwError);
			
			if (FDIDestroy(hfdi) != TRUE)
			{
				LOG_error("FDIDestroy() failed: code %d [%s]\n", erf.erfOper, return_fdi_error_string(erf.erfOper));
				
			}
			return FALSE;
		}
		
		hr=StringCchCopy(cabinet_path,ARRAYSIZE(cabinet_name),"");

		if(FAILED(hr))
		{
			dwError=HRESULT_CODE(hr);
			LOG_error("StringCchCopy Failed ErrorCode:%d",dwError);
			SetLastError(dwError);
			
			if (FDIDestroy(hfdi) != TRUE)
			{
				LOG_error("FDIDestroy() failed: code %d [%s]\n", erf.erfOper, return_fdi_error_string(erf.erfOper));
				
			}

			return FALSE;
		}
	}
	else
	{
		hr=StringCchCopy(cabinet_name,ARRAYSIZE(cabinet_name),p+1);

		if(FAILED(hr))
		{
			dwError=HRESULT_CODE(hr);
			LOG_error("StringCchCopy Failed ErrorCode:%d",dwError);
			SetLastError(dwError);
			
			if (FDIDestroy(hfdi) != TRUE)
			{
				LOG_error("FDIDestroy() failed: code %d [%s]\n", erf.erfOper, return_fdi_error_string(erf.erfOper));
				
			}

			return FALSE;
		}

		strncpy(cabinet_path, cabinet_fullpath, (int) (p-cabinet_fullpath)+1);
		cabinet_path[ (int) (p-cabinet_fullpath)+1 ] = 0;
	}

	if (TRUE != FDICopy(
		hfdi,
		cabinet_name,
		cabinet_path,
		0,
		notification_function,
		NULL,
		NULL))
	{
		LOG_error("FDICopy() failed: code %d [%s]\n", erf.erfOper, return_fdi_error_string(erf.erfOper));

		(void) FDIDestroy(hfdi);
		return FALSE;
	}

	if (FDIDestroy(hfdi) != TRUE)
	{
		LOG_error("FDIDestroy() failed: code %d [%s]\n", erf.erfOper, return_fdi_error_string(erf.erfOper));
		return FALSE;
	}

	return TRUE;
}


char *return_fdi_error_string(int err)
{
	switch (err)
	{
		case FDIERROR_NONE:
			return "No error";

		case FDIERROR_CABINET_NOT_FOUND:
			return "Cabinet not found";
			
		case FDIERROR_NOT_A_CABINET:
			return "Not a cabinet";
			
		case FDIERROR_UNKNOWN_CABINET_VERSION:
			return "Unknown cabinet version";
			
		case FDIERROR_CORRUPT_CABINET:
			return "Corrupt cabinet";
			
		case FDIERROR_ALLOC_FAIL:
			return "Memory allocation failed";
			
		case FDIERROR_BAD_COMPR_TYPE:
			return "Unknown compression type";
			
		case FDIERROR_MDI_FAIL:
			return "Failure decompressing data";
			
		case FDIERROR_TARGET_FILE:
			return "Failure writing to target file";
			
		case FDIERROR_RESERVE_MISMATCH:
			return "Cabinets in set have different RESERVE sizes";
			
		case FDIERROR_WRONG_CABINET:
			return "Cabinet returned on fdintNEXT_CABINET is incorrect";
			
		case FDIERROR_USER_ABORT:
			return "User aborted";
			
		default:
			return "Unknown error";
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuv3\wsdu\wsdu\wsdu.h ===
#include <windows.h>
#include <shlwapi.h>
#include <wininet.h>
#include <stdio.h>
#include <lmcons.h>
#include <fdi.h>
#include <newtrust.h>
#include <tchar.h>
#include "log.h"

#include <strsafe.h>

// helper macros
#define ARRAYSIZE(a)  (sizeof(a) / sizeof(a[0]))
#define SafeGlobalFree(x)       if (NULL != x) { GlobalFree(x); x = NULL; }
#define SafeFreeLibrary(x)      if (NULL != x) { FreeLibrary(x); x = NULL; }
#define SafeCloseHandle(x) if (INVALID_HANDLE_VALUE != x) { CloseHandle(x); x = INVALID_HANDLE_VALUE; }

// fdi.cpp
BOOL fdi(char *cabinet_fullpath, char *directory);

// Setup Database Query ID's
#define SETUPQUERYID_PNPID      1

// Dynamic Update Custom Error Codes
#define DU_ERROR_MISSING_DLL        12001L
#define DU_NOT_INITIALIZED          12002L
#define DU_ERROR_ASYNC_FAIL         12003L

#define WM_DYNAMIC_UPDATE_COMPLETE WM_APP + 1000 + 1000
// (WPARAM) Completion Status (SUCCESS, ABORTED, FAILED) : (LPARAM) (DWORD) Error Code if Status Failed
#define WM_DYNAMIC_UPDATE_PROGRESS WM_APP + 1000 + 1001
// (WPARAM) (DWORD) TotalDownloadSize : (LPARAM) (DWORD) BytesDownloaded 

#define DU_CONNECTION_RETRY 2
// RogerJ --- Dynamic.H also contains callback function declaration
// Dynamic.H Contains all the internal Function Pointer Declarations for the wsdueng.dll, wininet.dll and shlwapi.dll calls.
#include "dynamic.h"

typedef struct
{
    PFN_InternetOpen                fpnInternetOpen;
    PFN_InternetConnect             fpnInternetConnect;
    PFN_HttpOpenRequest             fpnHttpOpenRequest;
    PFN_HttpSendRequest             fpnHttpSendRequest;
    PFN_HttpQueryInfo               fpnHttpQueryInfo;
    PFN_InternetSetOption           fpnInternetSetOption;
    PFN_HttpAddRequestHeaders       fpnHttpAddRequestHeaders;
    PFN_InternetReadFile            fpnInternetReadFile;
    PFN_InternetCloseHandle         fpnInternetCloseHandle;
    PFN_InternetCrackUrl            fpnInternetCrackUrl;
    PFN_InternetGetConnectedState   fpnInternetGetConnectedState;
    PFN_PathAppend                  fpnPathAppend;
    PFN_PathRemoveFileSpec          fpnPathRemoveFileSpec;
    PFN_InternetAutodial			fpnInternetAutodial;
    PFN_InternetAutodialHangup		fpnInternetAutodialHangup;
    HINTERNET                       hInternet;
    HINTERNET                       hConnect;
    HINTERNET                       hOpenRequest;
    BOOL							fDialed; // mark as TRUE if we triggered an autodial
    BOOL							fUnattended; // TRUE if we are in unattened mode
    BOOL                            fIEVersionOKSupportSLL; // TRUE if we determine the IE version is high enough to safely use SSL
} GLOBAL_STATEA, *PGLOBAL_STATEA;

// --------------------------------------------------------------------------
// Function Name: DuIsSupported
// Function Description: this method checks whether the required DLL's are on
//      the system to successfully run Dynamic Update. It does NOT attempt to
//      initiate a connection though.
//
// Function Returns:
//      FALSE: Not Supported, Some Required DLL's missing
//      TRUE:  DLL's are OK. Dynamic Update should be possible.
//
//
BOOL DuIsSupported();
BOOL NeedRetry(DWORD dwErrorCode); 

// --------------------------------------------------------------------------
// Function Name: DuInitialize
// Function Description: Initializes the Dynamic Setup Update engine. During
//      initialization this API attempts to establish a connection to the internet
//      and starts a self update process to ensure the latest bits are being used.
//      We also calculate the estimated transfer speed of the connection during this
//      time.
//
// Function Returns:
//      Failure: INVALID_HANDLE_VALUE .. Call GetLastError to retrieve the Error Code
//      Success: Handle of the Dynamic Setup Job
//
//
HANDLE WINAPI DuInitializeA(IN LPCSTR pszBasePath, // base directory used for relative paths for downloaded files
                            IN LPCSTR pszTempPath,
                            IN POSVERSIONINFOEXA posviTargetOS, // target OS platform
                            IN LPCSTR pszTargetArch, // string value identifying the architecture 'i386' and 'ia64'
                            IN LCID lcidTargetLocale, // target OS Locale ID
                            IN BOOL fUnattend, // is this an unattended operation
                            IN BOOL fUpgrade, // is this an upgrade
                            IN PWINNT32QUERY pfnWinnt32QueryCallback);

typedef HANDLE (WINAPI * PFN_DuInitializeA)(IN LPCSTR pszBasePath,
                                            IN LPCSTR pszTempPath,
                                            IN POSVERSIONINFOEXA posviTargetOS,
                                            IN LPCSTR pszTargetArch,
                                            IN LCID lcidTargetLocale,
                                            IN BOOL fUnattend, // is this an unattended operation
                                            IN BOOL fUpgrade,
                                            IN PWINNT32QUERY pfnWinnt32QueryCallback);

#define API_DU_INITIALIZEA "DuInitializeA"


HANDLE WINAPI DuInitializeW(IN LPCWSTR pwszBasePath, // base directory used for relative paths for downloaded files
                            IN LPCWSTR pwszTempPath, 
                            IN POSVERSIONINFOEXW posviTargetOS, // target OS platform
                            IN LPCWSTR pwszTargetArch, // string value identifying the architecture 'i386' and 'ia64'
                            IN LCID lcidTargetLocale, // target OS Locale ID
                            IN BOOL fUnattend, // is this an unattended operation
                            IN BOOL fUpgrade, // is this an upgrade
                            IN PWINNT32QUERY pfnWinnt32QueryCallback);

typedef HANDLE (WINAPI * PFN_DuInitializeW)(IN LPCWSTR pwszBasePath,
                                            IN LPCWSTR pwszTempPath, 
                                            IN POSVERSIONINFOEXW posviTargetOS,
                                            IN LPCWSTR pwszTargetArch,
                                            IN LCID lcidTargetLocale,
                                            IN BOOL fUnattend, // is this an unattended operation
                                            IN BOOL fUpgrade,
                                            IN PWINNT32QUERY pfnWinnt32QueryCallback);

#define API_DU_INITIALIZEW "DuInitializeW"

#ifdef UNICODE
#define DuInitialize DuInitializeW
#define PFN_DuInitialize PFN_DuInitializeW
#define API_DU_INITIALIZE API_DU_INITIALIZEW
#else
#define DuInitialize DuInitializeA
#define PFN_DuInitialize PFN_DuInitializeA
#define API_DU_INITIALIZE API_DU_INITIALIZEA
#endif


// --------------------------------------------------------------------------
// Function Name: DuDoDetection
// Function Description: Does detection of Drivers on the System, compiles an 
//      internal list of items to download and how long it will take to download
//      them.
//
// Function Returns:
//      Failure: FALSE .. Call GetLastError to retrieve the Error Code
//      Success: TRUE
//

BOOL WINAPI DuDoDetection(IN HANDLE hConnection,
                          OUT PDWORD pdwEstimatedTime,
                          OUT PDWORD pdwEstimatedSize);

typedef BOOL (WINAPI * PFN_DuDoDetection)(IN HANDLE hConnection,
                                          OUT PDWORD pdwEstimatedTime,
                                          OUT PDWORD pdwEstimatedSize);

#define API_DU_DODETECTION "DuDoDetection"

// --------------------------------------------------------------------------
// Function Name: DuBeginDownload
// Function Description: Begins Downloading based on the detection done in the DuDoDetection call.
//      Progress callbacks are made to the specified HWND. Function returns immediately, download
//      is asynchronous.
//
// Function Returns:
//      Failure: FALSE .. Call GetLastError to retrieve the Error Code
//      Success: TRUE
//

BOOL WINAPI DuBeginDownload(IN HANDLE hConnection,
                            IN HWND hwndNotify);

typedef BOOL (WINAPI * PFN_DuBeginDownload)(IN HANDLE hConnection,
                                        IN HWND hwndNotify);

#define API_DU_BEGINDOWNLOAD "DuBeginDownload"

// --------------------------------------------------------------------------
// Function Name: DuAbortDownload
// Function Description: Aborts current download.
//
//
// Function Returns:
//      nothing
//

void WINAPI DuAbortDownload(IN HANDLE hConnection);

typedef void (WINAPI * PFN_DuAbortDownload)(IN HANDLE hConnection);

#define API_DU_ABORTDOWNLOAD "DuAbortDownload"

// --------------------------------------------------------------------------
// Function Name: DuUninitialize
// Function Description: Performs internal CleanUp 
//
//
// Function Returns:
//      nothing
//

void WINAPI DuUninitialize(IN HANDLE hConnection);

typedef void (WINAPI * PFN_DuUninitialize)(IN HANDLE hConnection);

#define API_DU_UNINITIALIZE "DuUninitialize"

// RogerJ, Oct 2nd, 2000

// ---------------------------------------------------------------------------
// Function Name: DuQueryUnsupportedDriversA
// Function Description: Called by Win9x setup to get the size of total download
// 		instead of DuDoDetection()
// Function Returns: BOOL
//		TRUE if succeed
//		FALSE if failed, call GetLastError() to get error information
//
BOOL WINAPI DuQueryUnsupportedDriversA( IN HANDLE hConnection, // connection handle
										IN PCSTR* ppszListOfDriversNotOnCD, // list of drivers not on setup CD
										OUT PDWORD pdwTotalEstimateTime, // estimate download time
										OUT PDWORD pdwTotalEstimateSize // estimate size
									  );
									  
typedef BOOL (WINAPI * PFN_DuQueryUnsupportedDriversA)(IN HANDLE hConnection, 
													   IN PCSTR* ppszListOfDriversNotOnCD,
													   OUT PDWORD pdwTotalEstimateTime,
													   OUT PDWORD pdwTotalEstimateSize );
													   
#define API_DU_QUERYUNSUPPORTEDDRIVERSA 	"DuQueryUnsupportedDriversA"

// ---------------------------------------------------------------------------
// Function Name: DuQueryUnsupportedDriversW
// Function Description: Could be called by WinNT setup to get the size of total download
// 		instead of DuDoDetection().  WinNT setup should call DuDoDetection() instead of 
//		this function.  
// Function Returns: BOOL
//		TRUE if succeed
//		FALSE if failed, call GetLastError() to get error information
//
BOOL WINAPI DuQueryUnsupportedDriversW( IN HANDLE hConnection, // connection handle
										IN PCWSTR* ppwszListOfDriversNotOnCD, // list of drivers not on setup CD
										OUT PDWORD pdwTotalEstimateTime, // estimate download time
										OUT PDWORD pdwTotalEstimateSize // estimate size
									  );
									  
typedef BOOL (WINAPI * PFN_DuQueryUnsupportedDriversW)(IN HANDLE hConnection, 
													   IN PCWSTR* ppszListOfDriversNotOnCD,
													   OUT PDWORD pdwTotalEstimateTime,
													   OUT PDWORD pdwTotalEstimateSize );
													   
#define API_DU_QUERYUNSUPPORTEDDRIVERSW 	"DuQueryUnsupportedDriversW"

#ifdef UNICODE
#define DuQueryUnsupportedDrivers DuQueryUnsupportedDriversW
#define PFN_DuQueryUnsupportedDrivers PFN_DuQueryUnsupportedDriversW
#define API_DU_QUERYUNSUPPORTEDDERIVERS API_DU_QUERYUNSUPPORTEDDERIVERSW
#else
#define DuQueryUnsupportedDrivers DuQueryUnsupportedDriversA
#define PFN_DuQueryUnsupportedDrivers PFN_DuQueryUnsupportedDriversA
#define API_DU_QUERYUNSUPPORTEDDERIVERS API_DU_QUERYUNSUPPORTEDDERIVERSA
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuv3\wsdu\wsdueng\log.cpp ===
#include "wsdueng.h"

#define REGKEY_WUV3TEST     "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate\\wuv3test"

FILE* CLogger::c_pfile = stdout;
int CLogger::c_cnIndent = 0;
int CLogger::c_cnLevels = -1;

CLogger::CLogger(
    const char* szBlockName /*= 0*/, 
    int nLoggingLevel/*= 0*/, 
    const char* szFileName/*= 0*/, 
    int nLine/*= 0*/
) 
{
    if (-1 == c_cnLevels)
    {
        /*c_cnLevels = 0;
        HKEY hkey;
        if (NO_ERROR == RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGKEY_WUV3TEST, 0, KEY_READ, &hkey)) 
        {
            DWORD dwSize = sizeof(c_cnLevels);
            RegQueryValueEx(hkey, "LogLevel", 0, 0, (LPBYTE)&c_cnLevels, &dwSize);
            char szLogFile[MAX_PATH] = {0};
            dwSize = sizeof(szLogFile);
            RegQueryValueEx(hkey, "LogFile", 0, 0, (LPBYTE)&szLogFile, &dwSize);
            FILE* pfile = fopen(szLogFile, "at");
            if (pfile)
            {
                c_pfile = pfile;
            }
            RegCloseKey(hkey);
        }*/
        char sz_LogFileName[MAX_PATH];
        c_cnLevels = 4; // default to log level 4
        ExpandEnvironmentStrings(cszLoggingFile, sz_LogFileName, MAX_PATH);
        FILE* pfile = fopen(sz_LogFileName, "at");
        if (pfile)
        {
            c_pfile = pfile;
        }
    }
    m_szBlockName[0] = 0;
    //m_fOut = nLoggingLevel < c_cnLevels;
    m_fOut = TRUE;
    if (m_fOut && NULL != szBlockName) 
    {
        lstrcpyn(m_szBlockName, szBlockName, sizeOfArray(m_szBlockName));
        //out("%s %s(%d)", szBlockName, szFileName, nLine);
        out("%s", szBlockName);
        m_dwStartTick = GetTickCount();
        c_cnIndent ++;
    }
}

CLogger::~CLogger()
{
    if (c_pfile && m_fOut && NULL != m_szBlockName[0]) 
    {
        c_cnIndent --;
        out("~%s (%d msecs)", m_szBlockName, GetTickCount() - m_dwStartTick);
    }
}

void __cdecl CLogger::out(const char *szFormat, ...)
{
    if (m_fOut) 
    {
        va_list va;
        va_start (va, szFormat);
        v_out(szFormat, va);
        va_end (va);
    }
}

void __cdecl CLogger::error(const char *szFormat, ...)
{
    if (m_fOut) 
    {
        va_list va;
        va_start (va, szFormat);
        char szOut[4 * 1024];


        StringCchVPrintf(szOut,ARRAYSIZE(szOut),szFormat,va);

        va_end (va);
        out("ERROR - %s", szOut);
    }
}

void __cdecl CLogger::out1(const char *szFormat, ...)
{
    CLogger logger;
    va_list va;
    va_start (va, szFormat);
    logger.v_out(szFormat, va);
    va_end (va);
}

void CLogger::v_out( const char* szFormat, va_list va)
{
    char szOut[5 * 1024];
    char* pszOut = szOut;
    // Indent first
    for(int i = 0; i < c_cnIndent; i ++)
        *(pszOut ++) = '\t';
    
    StringCchVPrintf(pszOut, ARRAYSIZE(szOut)-  (i*sizeof(char)),szFormat, va);

    // move the file pointer to the end
    if (0 == fseek(c_pfile, 0, SEEK_END))
    {
        fprintf(c_pfile, "%s\n", szOut);
        fflush(c_pfile);
    }
}

void CLogger::close(void)
{
    if (c_pfile) fclose(c_pfile);
    c_pfile = NULL;
    c_cnLevels = -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuv3\wsdu\wsdueng\download.cpp ===
#include "wsdueng.h"

DWORD WINAPI DownloadThreadProc(LPVOID lpv);

// private helper function forward declaration
// RogerJ --- Use this function to avoid auto disconnection
void IndicateDialmonActivity(void);


DWORD CDynamicUpdate::OpenHttpConnection(LPCSTR pszDownloadUrl, BOOL fGetRequest)
{
    LOG_block("CDynamicUpdate::OpenHttpConnection()");
    URL_COMPONENTSA UrlComponents;
    DWORD dwErr, dwStatus, dwLength, dwFlags;
    LPSTR AcceptTypes[] = {"*/*", NULL};

    LOG_out("Opening HTTP URL %s", pszDownloadUrl);

    dwErr = dwStatus = dwLength = 0;
    // Buffers used to Break the URL into its different components for Internet API calls
    char szServerName[INTERNET_MAX_URL_LENGTH + 1];
    char szObject[INTERNET_MAX_URL_LENGTH + 1];
    char szUserName[UNLEN+1];
    char szPasswd[UNLEN+1];
    HRESULT hr=S_OK;

    // We need to break down the Passed in URL into its various components for the InternetAPI Calls. Specifically we
    // Need the server name, object to download, username and password information.
    ZeroMemory(szServerName, INTERNET_MAX_URL_LENGTH + 1);
    ZeroMemory(szObject, INTERNET_MAX_URL_LENGTH + 1);
    ZeroMemory(&UrlComponents, sizeof(UrlComponents));
    UrlComponents.dwStructSize = sizeof(UrlComponents);
    UrlComponents.lpszHostName = szServerName;
    UrlComponents.dwHostNameLength = INTERNET_MAX_URL_LENGTH + 1;
    UrlComponents.lpszUrlPath = szObject;
    UrlComponents.dwUrlPathLength = INTERNET_MAX_URL_LENGTH + 1;
    UrlComponents.lpszUserName = szUserName;
    UrlComponents.dwUserNameLength = UNLEN + 1;
    UrlComponents.lpszPassword = szPasswd;
    UrlComponents.dwPasswordLength = UNLEN + 1;

    if (! InternetCrackUrlA(pszDownloadUrl, 0, 0, &UrlComponents) )
    {
        dwErr = GetLastError();
        LOG_error("InternetCrackUrl() Failed, Error: %d", dwErr);
        return dwErr;
    }

    // Check the m_fUseSSL variable to determine if SSL use has been overrided due to Minimum IE Version
    if (FALSE == m_fUseSSL)
    {
        // force IE to use HTTP instead of HTTPS. Regardless of the URL setting.
        UrlComponents.nScheme = INTERNET_SCHEME_HTTP;
    }

    // If the connection has already been established re-use it.
    if (NULL == m_hInternet)
    {
        if (! (m_hInternet = InternetOpenA("Dynamic Update", INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0)) )
        {
            dwErr = GetLastError();
            LOG_error("InternetOpen() Failed, Error: %d", dwErr);
            return dwErr;
        }
    }

    dwStatus = 30 * 1000; // 30 seconds in milliseconds
    dwLength = sizeof(dwStatus);
    InternetSetOptionA(m_hInternet, INTERNET_OPTION_SEND_TIMEOUT, &dwStatus, dwLength);

    // compare the existing connected server and protocol (HTTP, HTTPS) to see if they match.
    if (NULL == m_hConnect || 0 != lstrcmpi(m_szCurrentConnectedServer, szServerName) || m_iCurrentConncectionScheme != UrlComponents.nScheme)
    {
        // No connection established yet, or we are connecting to a new server.
        SafeInternetCloseHandle(m_hConnect);
        if (! (m_hConnect = InternetConnectA(m_hInternet, 
                                                                 szServerName, 
                                                                 (UrlComponents.nScheme == INTERNET_SCHEME_HTTP) ? INTERNET_DEFAULT_HTTP_PORT : INTERNET_DEFAULT_HTTPS_PORT, 
                                                                 szUserName, 
                                                                 szPasswd,
                                                                 INTERNET_SERVICE_HTTP, 
                                                                 INTERNET_FLAG_NO_UI | INTERNET_FLAG_RELOAD, 
                                                                 0)) )
        {
            dwErr = GetLastError();
            LOG_error("InternetConnect() Failed, Error: %d", dwErr);
            return dwErr;
        }
       
        // now that the connection is made, save the values so we can compare for the next connection.
        m_iCurrentConncectionScheme = UrlComponents.nScheme;
        hr = StringCchCopy(m_szCurrentConnectedServer,ARRAYSIZE(m_szCurrentConnectedServer),szServerName);

        if(FAILED(hr))
        {
            dwErr = HRESULT_CODE(hr);
            SetLastError(dwErr);
            LOG_error("StringCchCopy Failed ErrorCode:%d",dwErr);
            return dwErr;
        }
    }

    if (UrlComponents.nScheme == INTERNET_SCHEME_HTTPS)
    {
        dwFlags = INTERNET_FLAG_KEEP_CONNECTION | INTERNET_FLAG_NO_UI | INTERNET_FLAG_SECURE;
    }
    else
    {
        dwFlags = INTERNET_FLAG_KEEP_CONNECTION | INTERNET_FLAG_NO_UI;
    }

    SafeInternetCloseHandle(m_hOpenRequest); // make sure there is no open request before creating the new one.

    if (! (m_hOpenRequest = HttpOpenRequestA(m_hConnect, 
                                             (fGetRequest) ? NULL : "HEAD",
                                             szObject, 
                                             NULL, 
                                             NULL, 
                                             (LPCSTR *)AcceptTypes, 
                                             dwFlags, 
                                             0)) )
    {
        dwErr = GetLastError();
        // log result
        return dwErr;
    }

    int nNumOfTrial = 0;
    do
    {
        if (! HttpSendRequestA(m_hOpenRequest, NULL, 0, NULL, 0) )
        {
            dwErr = GetLastError();
            // log result
            return dwErr;
        }

        dwLength = sizeof(dwStatus);
        if (! HttpQueryInfoA(m_hOpenRequest, HTTP_QUERY_STATUS_CODE | HTTP_QUERY_FLAG_NUMBER, 
            (LPVOID)&dwStatus, &dwLength, NULL) )
        {
            dwErr = GetLastError();
            // log result
            return dwErr;
        }
        nNumOfTrial ++;
    } while (NeedRetry(dwStatus) && nNumOfTrial < DU_CONNECTION_RETRY);

    // If the Request did not succeed we'll assume we have no internet connection and return the Error Code
    // that Setup will trigger a warning to the user to manually establish a connection.
    if ((HTTP_STATUS_OK != dwStatus) && (HTTP_STATUS_PARTIAL_CONTENT != dwStatus))
    {
        LOG_error("Http Status NOT OK, Status %d", dwStatus);
        if (HTTP_STATUS_NOT_FOUND == dwStatus)
        return ERROR_INTERNET_INVALID_URL;
        else return ERROR_CONNECTION_UNAVAIL;
    }

    return ERROR_SUCCESS;
}

DWORD CDynamicUpdate::DownloadFilesAsync()
{
    LOG_block("CDynamicUpdate::DownloadFileAsync()");
    DWORD dwThreadID;
    DWORD dwErr;

    SafeCloseHandle(m_hDownloadThreadProc);
    m_hDownloadThreadProc = CreateThread(NULL, 0, DownloadThreadProc, (void *)this, 0, &dwThreadID);
    if (NULL == m_hDownloadThreadProc)
    {
        dwErr = GetLastError();
        LOG_error("Unable to CreateThread for ASynch Download, Error %d", dwErr);
        return dwErr;
    }

    SetThreadPriority(m_hDownloadThreadProc, THREAD_PRIORITY_NORMAL);
    return ERROR_SUCCESS;
}

DWORD CDynamicUpdate::DownloadFile(LPCSTR pszDownloadUrl, LPCSTR pszLocalFile, BOOL fDecompress, BOOL fCheckTrust)
{
    LOG_block("CDynamicUpdate::DownloadFile()");
    DWORD dwErr, dwFileSize, dwLength;
    DWORD dwBytesRead, dwBytesWritten;
    DWORD dwCount1, dwCount2, dwTimeElapsed;
    SYSTEMTIME st;
    FILETIME ft;
    HANDLE hTargetFile;
    HRESULT hr=S_OK;
    SetLastError(0);

    dwErr = OpenHttpConnection(pszDownloadUrl, FALSE);
    if (ERROR_SUCCESS != dwErr)
    {
        // log error 
        return dwErr;
    }

    dwLength = sizeof(st);
    if (! HttpQueryInfoA(m_hOpenRequest, HTTP_QUERY_LAST_MODIFIED | HTTP_QUERY_FLAG_SYSTEMTIME, 
        (LPVOID)&st, &dwLength, NULL) )
    {
        dwErr = GetLastError();
        LOG_error("HttpQueryInfo Failed on File %s, Error %d", pszDownloadUrl, dwErr);
        SafeInternetCloseHandle(m_hOpenRequest);
        return dwErr;
    }

    SystemTimeToFileTime(&st, &ft);

    // Now Get the FileSize information from the Server
    dwLength = sizeof(dwFileSize);
    if (! HttpQueryInfoA(m_hOpenRequest, HTTP_QUERY_CONTENT_LENGTH | HTTP_QUERY_FLAG_NUMBER, 
        (LPVOID)&dwFileSize, &dwLength, NULL) )
    {
        dwErr = GetLastError();
        LOG_error("HttpQueryInfo Failed on File %s, Error %d", pszDownloadUrl, dwErr);
        SafeInternetCloseHandle(m_hOpenRequest);
        return dwErr;
    }

    if (IsServerFileNewer(ft, dwFileSize, pszLocalFile))
    {
        dwErr = OpenHttpConnection(pszDownloadUrl, TRUE); // need to download the file, send the GET request this time
        if (ERROR_SUCCESS != dwErr)
        {
            // log error 
            return dwErr;
        }
#define DOWNLOAD_BUFFER_LENGTH 32 * 1024

        PBYTE lpBuffer = (PBYTE) GlobalAlloc(GMEM_ZEROINIT, DOWNLOAD_BUFFER_LENGTH);
        if (NULL == lpBuffer)
        {
            dwErr = GetLastError();
            LOG_error("Failed to Allocate Memory for Download Buffer, Error %d", dwErr);
            SafeInternetCloseHandle(m_hOpenRequest);
            return dwErr;
        }

        hTargetFile = CreateFileA(pszLocalFile, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if (INVALID_HANDLE_VALUE == hTargetFile)
        {
            dwErr = GetLastError();
            LOG_error("Failed to Open Target File %s, Error %d", pszLocalFile, dwErr);
            SafeGlobalFree(lpBuffer);
            SafeInternetCloseHandle(m_hOpenRequest);
            return dwErr;
        }

        // Download the File
        BOOL fRet;
        while (fRet = InternetReadFile(m_hOpenRequest, lpBuffer, DOWNLOAD_BUFFER_LENGTH, &dwBytesRead))
        {
            if (0 == dwBytesRead)
            {
                // Make one final call to InternetReadFile to commit the file to Cache (download is not complete otherwise)
                BYTE bTemp[32];
                InternetReadFile(m_hOpenRequest, &bTemp, 32, &dwBytesRead);
                // set the file time to match the server file time since we just downloaded it.
                // If we don't do this the file time will be set to the current system time.
                SetFileTime(hTargetFile, &ft, NULL, NULL); 
                break; // done reading.
            }
            if (!WriteFile(hTargetFile, lpBuffer, dwBytesRead, &dwBytesWritten, NULL))
            {
                LOG_error("Failed to Write to File %s, Error %d", pszLocalFile, dwErr);
                dwErr = GetLastError();
                SafeGlobalFree(lpBuffer);
                SafeInternetCloseHandle(m_hOpenRequest);
                SafeCloseHandle(hTargetFile);
                return dwErr;
            }
        }

        if (!fRet)
        {
            dwErr = GetLastError();
            SafeCloseHandle(hTargetFile);
            DeleteFile(pszLocalFile); // delete the file that we just had an error during downloading
            SafeGlobalFree(lpBuffer);
            LOG_error("InternetReadFile Failed, Error %d", dwErr);
            return dwErr;
        }

        SafeGlobalFree(lpBuffer);
        SafeCloseHandle(hTargetFile);

        // check for decompress requested
        if (fCheckTrust)
        {
            // Use VerifyFile() to verifty the cert of the downloaded component
            // change made by ROGERJ at Sept. 25th, 2000
            if (FAILED(VerifyFile(pszLocalFile, FALSE)))
            {
                LOG_error("CabFile %s does not have a valid Signature", pszLocalFile);
                DeleteFile(pszLocalFile); // not trusted, nuke it.
            }
        }

        if (fDecompress)
        {
            char szLocalDir[MAX_PATH];


            hr=StringCchCopy(szLocalDir,ARRAYSIZE(szLocalDir),pszLocalFile);
            if(FAILED(hr))
            {

                dwErr=HRESULT_CODE(hr);
                LOG_error("StringCchCatA Failed ErrorCode:%d",dwErr);
                SetLastError(dwErr);
                SafeInternetCloseHandle(m_hOpenRequest);
                return dwErr;

            }

            PathRemoveFileSpec(szLocalDir);
            fdi(const_cast<char *>(pszLocalFile), szLocalDir);
        }
    }

    // Always close the Request when the file is finished.
    // We intentionally leave the connection to the server Open though, seems more
    // efficient when requesting multiple files from the same server.
    SafeInternetCloseHandle(m_hOpenRequest);

    return ERROR_SUCCESS;
}

DWORD CDynamicUpdate::DownloadFileToMem(LPCSTR pszDownloadUrl, PBYTE *lpBuffer, DWORD *pdwAllocatedLength, BOOL fDecompress, LPSTR pszFileName, LPSTR pszDecompresedFileName)
{
	LOG_block("CDynamicUpdate::DownloadFileToMem()");
    DWORD dwErr, dwFileSize, dwLength;
    DWORD dwBytesRead, dwBytesWritten;
	DWORD dwCount1, dwCount2, dwTimeElapsed;
    SYSTEMTIME st;
    FILETIME ft;
    HANDLE hTargetFile;
	HRESULT hr=S_OK;

    dwErr = OpenHttpConnection(pszDownloadUrl, TRUE);
    if (ERROR_SUCCESS != dwErr)
    {
        // log error 
        SetLastError(dwErr);
        return dwErr;
    }

    dwLength = sizeof(st);
    if (! HttpQueryInfoA(m_hOpenRequest, HTTP_QUERY_LAST_MODIFIED | HTTP_QUERY_FLAG_SYSTEMTIME, 
        (LPVOID)&st, &dwLength, NULL) )
    {
        dwErr = GetLastError();
        // log error
        SafeInternetCloseHandle(m_hOpenRequest);
        return dwErr;
    }

    SystemTimeToFileTime(&st, &ft);

    // Now Get the FileSize information from the Server
    dwLength = sizeof(dwFileSize);
    if (! HttpQueryInfoA(m_hOpenRequest, HTTP_QUERY_CONTENT_LENGTH | HTTP_QUERY_FLAG_NUMBER, 
        (LPVOID)&dwFileSize, &dwLength, NULL) )
    {
        dwErr = GetLastError();
        // log error
        SafeInternetCloseHandle(m_hOpenRequest);
        return dwErr;
    }

    *lpBuffer = (PBYTE) GlobalAlloc(GMEM_ZEROINIT, dwFileSize);
    if (NULL == *lpBuffer)
    {
        dwErr = GetLastError();
        // log error
        SafeInternetCloseHandle(m_hOpenRequest);
        return dwErr;
    }
    *pdwAllocatedLength = dwFileSize;

    // Read the whole file
	if (!InternetReadFile(m_hOpenRequest, *lpBuffer, dwFileSize, &dwBytesRead))
	{
		dwErr = GetLastError();
		LOG_error("Internet Read File Failed, Error %d", dwErr);
		SafeInternetCloseHandle(m_hOpenRequest);
		return dwErr;
	}

	if (fDecompress)
	{
		char szLocalFile[MAX_PATH];
		char szLocalFileTmp[MAX_PATH];
		if (NULL != pszDecompresedFileName)
		{
			char szCatalogName[MAX_PATH];
			PathCombine(szLocalFile, m_szTempPath, pszDecompresedFileName);
			

			
			hr=StringCchPrintf(szCatalogName,ARRAYSIZE(szCatalogName),"%s.tmp", pszFileName);
			if(FAILED(hr))
			{	
				dwErr=HRESULT_CODE(hr);
				SafeInternetCloseHandle(m_hOpenRequest);
				LOG_error("StringCchPrintf Failed ErrorCode:%d",dwErr);
				SetLastError(dwErr);
				return dwErr;
			}


			PathCombine(szLocalFileTmp, m_szTempPath, szCatalogName);
		}
		else
		{
			PathCombine(szLocalFile, m_szTempPath, pszFileName);

			
			hr=StringCchPrintf(szLocalFileTmp,ARRAYSIZE(szLocalFileTmp),"%s.tmp", szLocalFile);
			if(FAILED(hr))
			{
				dwErr=HRESULT_CODE(hr);
				SafeInternetCloseHandle(m_hOpenRequest);
				LOG_error("StringCchPrintf Failed ErrorCode:%d",dwErr);
				SetLastError(dwErr);
				return dwErr;
			}

		}
		
		HANDLE hFile = CreateFile(szLocalFileTmp, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
		if (INVALID_HANDLE_VALUE == hFile)
		{
			LOG_error("Unable to write temp file for decompress");
			return GetLastError();
		}
		DWORD dwTmp;
		WriteFile(hFile, *lpBuffer, dwFileSize, &dwTmp, NULL);
		FlushFileBuffers(hFile);
		SafeCloseHandle(hFile);
		if (fdi(szLocalFileTmp, m_szTempPath))
		{
			// file was decompressed
			hFile = CreateFile(szLocalFile, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
			if (INVALID_HANDLE_VALUE == hFile)
			{
				LOG_error("Unable to Read decompressed file %s", szLocalFile);
                SafeInternetCloseHandle(m_hOpenRequest);
        		DeleteFile(szLocalFileTmp);
				return GetLastError();
			}
			dwFileSize = GetFileSize(hFile, NULL);
			SafeGlobalFree(*lpBuffer);
			*lpBuffer = (PBYTE) GlobalAlloc(GMEM_ZEROINIT, dwFileSize);
			*pdwAllocatedLength = dwFileSize;
			if (!ReadFile(hFile, *lpBuffer, dwFileSize, &dwTmp, NULL))
            {
                dwErr = GetLastError();
                LOG_error("ReadFile %s Failed, Error %d", szLocalFile, dwErr);
			    SafeInternetCloseHandle(m_hOpenRequest);
			    SafeCloseHandle(hFile);
                DeleteFile(szLocalFile);
        		DeleteFile(szLocalFileTmp);
                return dwErr;
            }

			SafeCloseHandle(hFile);
			DeleteFile(szLocalFile);
		}
		DeleteFile(szLocalFileTmp);
	}

    // Make one final call to InternetReadFile to commit the file to Cache (downloaded is not complete otherwise)
    BYTE bTemp[32];
    InternetReadFile(m_hOpenRequest, &bTemp, 32, &dwBytesRead);

    // Always close the Request when the file is finished.
    // We intentionally leave the connection to the server Open though, seems more
    // efficient when requesting multiple files from the same server.
    SafeInternetCloseHandle(m_hOpenRequest);
    return ERROR_SUCCESS;
}

BOOL CDynamicUpdate::IsServerFileNewer(FILETIME ftServerTime, DWORD dwServerFileSize, LPCSTR pszLocalFile)
{
    HANDLE hFile = INVALID_HANDLE_VALUE;
	FILETIME ftCreateTime;
	LONG lTime;
	DWORD dwLocalFileSize;

    hFile = CreateFile(pszLocalFile, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (INVALID_HANDLE_VALUE != hFile)
	{
		dwLocalFileSize = GetFileSize(hFile, NULL);
		if (dwLocalFileSize != dwServerFileSize)
		{
			SafeCloseHandle(hFile);
			return TRUE; // server and local files do not match, download server file.
		}
		
		if (GetFileTime(hFile, &ftCreateTime, NULL, NULL))
		{
			lTime = CompareFileTime(&ftCreateTime, &ftServerTime);
			if (lTime < 0)
			{
				SafeCloseHandle(hFile);
				return TRUE; // local file is 'older' than the server file
			}
			else
			{
				SafeCloseHandle(hFile);
				return FALSE; // local file is either equal or newer, leave it.
			}
		}
	}
	// if we couldn't find the file, or we couldn't get the time, assume the server file is newer
	SafeCloseHandle(hFile);
    return TRUE;
}

DWORD CDynamicUpdate::AsyncDownloadProc()
{
    LOG_block("CDynamicUpdate::AsyncDownloadProc()");
    char szServerFile[INTERNET_MAX_URL_LENGTH];
    char szLocalFile[MAX_PATH];
    DWORD dwErr = 0, dwFileSize = 0, dwLength = 0;
    DWORD dwBytesRead = 0, dwBytesWritten = 0;
    SYSTEMTIME st;
    FILETIME ft;
    HANDLE hTargetFile = INVALID_HANDLE_VALUE;
    BOOL fAbort = FALSE;
    BOOL fRet = TRUE;
    BOOL fCheckCRC = FALSE;
    HRESULT hr;
    
    // The Download Thread Proc handles downloading all the files from the DownloadItemList in the DynamicUpdate object.
    // It will enumerate the list of items to download, make callbacks to the HWND in the dynamic update object in 1% intervals
    // and a final callback when it is complete. It will also check for cancel requests after downloading each 1k block from the
    // server. We do this in this small of a block to retain some responsiveness to the UI requests.

    EnterCriticalSection(&m_csDownload);
    DOWNLOADITEM *pCurrent = m_pDownloadItemList;
    while (pCurrent)
    {
        // Update the Cab Size for the Current Item and Recalc the total download size
        // We do this because the Estimated Download Size can be 'less' than the real download size. 
        // When providing progress this causes the progress bar to go beyond 100%, which is wrong.
        LPSTR pszCabFile = pCurrent->mszFileList;
        DWORD dwCurrentItemSize = 0;
        for (int i = 0; i < pCurrent->iNumberOfCabs; i++)
        {
            DuUrlCombine(szServerFile, ARRAYSIZE(szServerFile), m_pV3->m_szCabPoolUrl, pszCabFile);
            dwErr = OpenHttpConnection(szServerFile, FALSE);
            if (ERROR_SUCCESS != dwErr)
            {
                LeaveCriticalSection(&m_csDownload);
                LOG_error("Failed to Open Connection for %s, Error Was %d", szServerFile, dwErr);
                // Tell Setup that we're Stopping the Download
                SendMessage(m_hwndClientNotify, WM_DYNAMIC_UPDATE_COMPLETE, (WPARAM)DU_STATUS_FAILED, (LPARAM) dwErr);
                // Send Ping Back Status - Failed Item
                PingBack(DU_PINGBACK_DOWNLOADSTATUS, pCurrent->puid, NULL, FALSE);
                return dwErr;
            }
            // Now Get the FileSize information from the Server
            dwLength = sizeof(dwFileSize);
            if (! HttpQueryInfoA(m_hOpenRequest, HTTP_QUERY_CONTENT_LENGTH | HTTP_QUERY_FLAG_NUMBER, 
                (LPVOID)&dwFileSize, &dwLength, NULL) )
            {
                dwErr = GetLastError();
                LOG_error("HttpQueryInfo Failed on File %s, Error %d, Skipping Item", szServerFile, dwErr);
                SafeInternetCloseHandle(m_hOpenRequest);
                LeaveCriticalSection(&m_csDownload);
                // Tell Setup that we're Stopping the Download
                SendMessage(m_hwndClientNotify, WM_DYNAMIC_UPDATE_COMPLETE, (WPARAM)DU_STATUS_FAILED, (LPARAM) dwErr);
                // Send Ping Back Status - Failed Item
                PingBack(DU_PINGBACK_DOWNLOADSTATUS, pCurrent->puid, NULL, FALSE);
                return dwErr;
            }
                SafeInternetCloseHandle(m_hOpenRequest);
                dwCurrentItemSize += dwFileSize;
                pszCabFile += lstrlen(pszCabFile) + 2; // advance to the next cab.
        }
        pCurrent->dwTotalFileSize = dwCurrentItemSize; // download size in Bytes.
        pCurrent = pCurrent->pNext;
    }

    m_dwCurrentBytesDownloaded = 0;
    UpdateDownloadItemSize();
    // We want to Send a Progress Message Every 1 Percent of the Download.
    DWORD dwBytesPerPercent = m_dwTotalDownloadSize / 100; // in case the 
    if (0 == dwBytesPerPercent)
    {
        dwBytesPerPercent = 1; // must be at least 1 byte, cannot be zero
    }
    DWORD dwCurrentPercentComplete = 0;

    // Now we will start looping through the Items and Download the Files.
    pCurrent = m_pDownloadItemList;
    while (pCurrent)
    {
        fCheckCRC = FALSE;
        EnterCriticalSection(&m_cs);
        fAbort = m_fAbortDownload;
        LeaveCriticalSection(&m_cs);
        if (fAbort)
        {
            LeaveCriticalSection(&m_csDownload);
            // check for abort for each item
            SendMessage(m_hwndClientNotify, WM_DYNAMIC_UPDATE_COMPLETE, (WPARAM) DU_STATUS_ABORT, (LPARAM) NULL);
            SafeInternetCloseHandle(m_hConnect);
            SafeInternetCloseHandle(m_hInternet);
            m_fAbortDownload = FALSE; // reset
            return ERROR_SUCCESS;
        }
        // RogerJ --- call IndicateDialmonActivity() to avoid auto disconnection
        else
            IndicateDialmonActivity();


        // Each 'Item' can have more than one Cab. The Setup Item itself will usually have 3 cabs, Drivers will probably only have 1 cab.
        LPSTR pszCabFile = pCurrent->mszFileList;
        for (int i = 0; i < pCurrent->iNumberOfCabs; i++)
        {
            pCurrent->iCurrentCab = i;
            DuUrlCombine(szServerFile, ARRAYSIZE(szServerFile), m_pV3->m_szCabPoolUrl, pszCabFile); // current cab is the null terminated cab name in the list

            WUCRC_HASH crc;
            char szShortName[MAX_PATH]; // for trimmed filename
            char szCRC[CRC_HASH_STRING_LENGTH];
            if (FAILED(SplitCRCName((LPCSTR)pszCabFile, &crc, szShortName)))
            {
                
                //check for return value and perform proper clean up
                StringCchCopy(szShortName,ARRAYSIZE(szShortName),pszCabFile);

            }
 
            if (SUCCEEDED(StringFromCRC(&crc, szCRC, CRC_HASH_STRING_LENGTH)))
                fCheckCRC = TRUE;

            PathCombine(szLocalFile, m_szDownloadPath, szShortName);

            // Now open the HttpConnection to get this file
            dwErr = OpenHttpConnection(szServerFile, FALSE);
            if (ERROR_SUCCESS != dwErr)
            {
                LeaveCriticalSection(&m_csDownload);
                LOG_error("Failed to Open Connection for %s, Error Was %d", szServerFile, dwErr);
                // Tell Setup that we're Stopping the Download
                SendMessage(m_hwndClientNotify, WM_DYNAMIC_UPDATE_COMPLETE, (WPARAM)DU_STATUS_FAILED, (LPARAM) dwErr);
                // Send Ping Back Status - Failed Item
                PingBack(DU_PINGBACK_DOWNLOADSTATUS, pCurrent->puid, NULL, FALSE);
                return dwErr;
            }

            dwLength = sizeof(st);
            if (! HttpQueryInfoA(m_hOpenRequest, HTTP_QUERY_LAST_MODIFIED | HTTP_QUERY_FLAG_SYSTEMTIME, 
                (LPVOID)&st, &dwLength, NULL) )
            {
                LeaveCriticalSection(&m_csDownload);
                dwErr = GetLastError();
                LOG_error("HttpQueryInfo Failed on File %s, Error %d, Skipping Item", szServerFile, dwErr);
                SafeInternetCloseHandle(m_hOpenRequest);
                // Tell Setup that we're Stopping the Download
                SendMessage(m_hwndClientNotify, WM_DYNAMIC_UPDATE_COMPLETE, (WPARAM)DU_STATUS_FAILED, (LPARAM) dwErr);
                // Send Ping Back Status - Failed Item
                PingBack(DU_PINGBACK_DOWNLOADSTATUS, pCurrent->puid, NULL, FALSE);
                return dwErr;
            }

            SystemTimeToFileTime(&st, &ft);

            // Now Get the FileSize information from the Server
            dwLength = sizeof(dwFileSize);
            if (! HttpQueryInfoA(m_hOpenRequest, HTTP_QUERY_CONTENT_LENGTH | HTTP_QUERY_FLAG_NUMBER, 
                (LPVOID)&dwFileSize, &dwLength, NULL) )
            {
                dwErr = GetLastError();
                LOG_error("HttpQueryInfo Failed on File %s, Error %d, Skipping Item", szServerFile, dwErr);
                SafeInternetCloseHandle(m_hOpenRequest);
                LeaveCriticalSection(&m_csDownload);
                // Tell Setup that we're Stopping the Download
                SendMessage(m_hwndClientNotify, WM_DYNAMIC_UPDATE_COMPLETE, (WPARAM)DU_STATUS_FAILED, (LPARAM) dwErr);
                // Send Ping Back Status - Failed Item
                PingBack(DU_PINGBACK_DOWNLOADSTATUS, pCurrent->puid, NULL, FALSE);
                return dwErr;
            }

            if (IsServerFileNewer(ft, dwFileSize, szLocalFile))
            {
                dwErr = OpenHttpConnection(szServerFile, TRUE);
                if (ERROR_SUCCESS != dwErr)
                {
                    LeaveCriticalSection(&m_csDownload);
                    LOG_error("Failed to Open Connection for %s, Error Was %d", szServerFile, dwErr);
                    // Tell Setup that we're Stopping the Download
                    SendMessage(m_hwndClientNotify, WM_DYNAMIC_UPDATE_COMPLETE, (WPARAM)DU_STATUS_FAILED, (LPARAM) dwErr);
                    return dwErr;
                }

#define ASYNC_DOWNLOAD_BUFFER_LENGTH 1 * 1024 // download in 1k blocks to maintain UI responsiveness to a cancel request.

                PBYTE lpBuffer = (PBYTE) GlobalAlloc(GMEM_ZEROINIT, ASYNC_DOWNLOAD_BUFFER_LENGTH);
                if (NULL == lpBuffer)
                {
                    dwErr = GetLastError();
                    LOG_error("Failed to Allocate Memory for Download Buffer, Error %d", dwErr);
                    SafeInternetCloseHandle(m_hOpenRequest);
                    LeaveCriticalSection(&m_csDownload);
                    // Tell Setup that we're Stopping the Download
                    SendMessage(m_hwndClientNotify, WM_DYNAMIC_UPDATE_COMPLETE, (WPARAM)DU_STATUS_FAILED, (LPARAM) dwErr);
                    return dwErr;
                }

                hTargetFile = CreateFileA(szLocalFile, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
                if (INVALID_HANDLE_VALUE == hTargetFile)
                {
                    dwErr = GetLastError();
                    LOG_error("Failed to Open Target File %s, Error %d", szLocalFile, dwErr);
                    SafeGlobalFree(lpBuffer);
                    SafeInternetCloseHandle(m_hOpenRequest);
                    LeaveCriticalSection(&m_csDownload);
                    // Tell Setup that we're Stopping the Download
                    SendMessage(m_hwndClientNotify, WM_DYNAMIC_UPDATE_COMPLETE, (WPARAM)DU_STATUS_FAILED, (LPARAM) dwErr);
                    return dwErr;
                }


                // Download the File
                while (fRet = InternetReadFile(m_hOpenRequest, lpBuffer, ASYNC_DOWNLOAD_BUFFER_LENGTH, &dwBytesRead))
                {
                    if (0 == dwBytesRead) // done reading
                    {
                        // Make one final call to InternetReadFile to commit the file to Cache (download is not complete otherwise)
                        BYTE bTemp[32];
                        InternetReadFile(m_hOpenRequest, &bTemp, 32, &dwBytesRead);
                        break; // done reading.
                    }

                    EnterCriticalSection(&m_cs);
                    fAbort = m_fAbortDownload;
                    LeaveCriticalSection(&m_cs);
                    if (fAbort)
                    {
                        // Download Abort Requested, Clean Up, Signal the Complete Message and exit the Thread Proc
                        SafeCloseHandle(hTargetFile);
                        DeleteFile(szLocalFile); // file not complete
                        SafeInternetCloseHandle(m_hOpenRequest);
                        SafeInternetCloseHandle(m_hConnect);
                        SafeInternetCloseHandle(m_hInternet);
                        SafeGlobalFree(lpBuffer);
                        LeaveCriticalSection(&m_csDownload);
                        m_fAbortDownload = FALSE; // reset
                        SendMessage(m_hwndClientNotify, WM_DYNAMIC_UPDATE_COMPLETE, (WPARAM)DU_STATUS_ABORT , (LPARAM) NULL);
                        return ERROR_SUCCESS; // cancel is not an error

                    }
                    // RogerJ --- call IndicateDialmonActivity() to avoid auto disconnection
                    else
                        IndicateDialmonActivity();

                    if (!WriteFile(hTargetFile, lpBuffer, dwBytesRead, &dwBytesWritten, NULL))
                    {
                        dwErr = GetLastError();
                        LOG_error("Failed to Write to File %s, Error %d", szLocalFile, dwErr);
                        SafeGlobalFree(lpBuffer);
                        SafeInternetCloseHandle(m_hOpenRequest);
                        SafeCloseHandle(hTargetFile);
                        DeleteFile(szLocalFile); // incomplete download
                        LeaveCriticalSection(&m_csDownload);
                        // Tell Setup that we're Stopping the Download
                        SendMessage(m_hwndClientNotify, WM_DYNAMIC_UPDATE_COMPLETE, (WPARAM)DU_STATUS_FAILED, (LPARAM) dwErr);
                        return dwErr;
                    }
                    
                    m_dwCurrentBytesDownloaded += dwBytesRead;
                    dwCurrentPercentComplete = m_dwCurrentBytesDownloaded / dwBytesPerPercent;
                    if (dwCurrentPercentComplete != m_dwLastPercentComplete)
                    {
                        // We've downloaded another percent of the total size.. Send a Progress Message
                        SendMessage(m_hwndClientNotify, WM_DYNAMIC_UPDATE_PROGRESS, (WPARAM)m_dwTotalDownloadSize, (LPARAM)m_dwCurrentBytesDownloaded);
                                m_dwLastPercentComplete = dwCurrentPercentComplete;
                    }
                }

                // indicates error during InternetReadFile process
                if (!fRet)
                {
                    dwErr = GetLastError();
                    LOG_error("InternetReadFile Failed, Error %d", dwErr);
                    SafeGlobalFree(lpBuffer);
                    SafeInternetCloseHandle(m_hOpenRequest);
                    SafeCloseHandle(hTargetFile);
                    DeleteFile(szLocalFile); // incomplete download
                    LeaveCriticalSection(&m_csDownload);
                    // Tell Setup that we're Stopping the Download
                    SendMessage(m_hwndClientNotify, WM_DYNAMIC_UPDATE_COMPLETE, (WPARAM)DU_STATUS_FAILED, (LPARAM) dwErr);
                    // Send Ping Back Status - Failed Item
                    PingBack(DU_PINGBACK_DOWNLOADSTATUS, pCurrent->puid, NULL, FALSE);
                    return dwErr;
                }

                // set the file time to match the server file time since we just downloaded it.
                // If we don't do this the file time will be set to the current system time.
                SetFileTime(hTargetFile, &ft, NULL, NULL); 
                SafeGlobalFree(lpBuffer);
                SafeCloseHandle(hTargetFile);

                // Now if we successfully had a CRC we need to verify the file contents match the CRC.
                if (fCheckCRC)
                {
                    hr = VerifyFileCRC(szLocalFile, szCRC);
                    if (HRESULT_FROM_WIN32(ERROR_CRC) == hr || FAILED(hr))
                    {
                        // The File CRC's Did Not Match, or we had a problem Calculating the CRC. Fail Safely, delete the file.
                        // The Failed HR will fail the item
                        DeleteFile(szLocalFile);
                        break;
                    }
                }

                // RogerJ --- Add certificate checking code here
                if (FAILED(VerifyFile(szLocalFile, FALSE)))
                {
                    // Send Ping Back Status - Failed Item
                    PingBack(DU_PINGBACK_DOWNLOADSTATUS, pCurrent->puid, NULL, FALSE);

                    LOG_error("CabFile %s does not have a valid Signature, deleted", szLocalFile);
                    if (!DeleteFile(szLocalFile))
                    {
                        LOG_error("Failed to delete file %s --- %d", szLocalFile, GetLastError());
                    }
                }
                else
                {
                    // File Successfully Downloaded and CheckTrusted
                    PingBack(DU_PINGBACK_DOWNLOADSTATUS, pCurrent->puid, NULL, TRUE);
                }
            }
            else
            {
                // File Currently on the System is Already Up to Date
                // Send Progress Message with with this file size indicating it was downloaded. This keeps the progress bar
                // accurate, even if we didn't actually have to download the bits.
                m_dwCurrentBytesDownloaded += dwFileSize;
                SendMessage(m_hwndClientNotify, WM_DYNAMIC_UPDATE_PROGRESS, (WPARAM) m_dwTotalDownloadSize, (LPARAM) m_dwCurrentBytesDownloaded);
            }

            // Always close the Request when the file is finished.
            // We intentionally leave the connection to the server Open though, seems more
            // efficient when requesting multiple files from the same server.
            SafeInternetCloseHandle(m_hOpenRequest);
            pszCabFile += lstrlen(pszCabFile) + 2; // advance to the next cab.
        } // for ()
        pCurrent = pCurrent->pNext;
    } // while ()

    LeaveCriticalSection(&m_csDownload);
    ClearDownloadItemList();
    SendMessage(m_hwndClientNotify, WM_DYNAMIC_UPDATE_COMPLETE, (WPARAM) DU_STATUS_SUCCESS, (LPARAM) NULL);
    SafeInternetCloseHandle(m_hConnect);
    SafeInternetCloseHandle(m_hInternet);
    return ERROR_SUCCESS;
}

DWORD WINAPI DownloadThreadProc(LPVOID lpv)
{
    LOG_block("DownloadThreadProc()");

    if (NULL == lpv)
    {
        return ERROR_INVALID_PARAMETER;
    }

    CDynamicUpdate *pDu = (CDynamicUpdate *)lpv;
    return pDu->AsyncDownloadProc();
}

// RogerJ
// -------------------------------------------------------------------------------------------
// Function Name: IndicateDialmonActivity
// Function Description:  Call this function to avoid auto disconnect
// Function Parameter: None
// Return Value: None
void IndicateDialmonActivity(void)
{
    static HWND hwndDialmon = NULL;
    HWND hwndMonitor;

    // dialmon lives forever - find it once and we're set
    if(NULL == hwndDialmon)
        hwndDialmon = FindWindow(c_szDialmonClass, NULL);
    if(hwndDialmon)
        PostMessage(hwndDialmon, WM_WINSOCK_ACTIVITY, 0, 0);
}

DWORD CDynamicUpdate::PingBack(int iPingBackType, PUID puid, LPCSTR pszPnPID, BOOL fSucceeded)
{
    LOG_block("CDynamicUpdate::PingBack()");
    URL_COMPONENTSA UrlComponents;
    DWORD dwErr, dwStatus, dwLength;
    LPSTR AcceptTypes[] = {"*/*", NULL};

    // Buffers used to Break the URL into its different components for Internet API calls
    char szServerName[INTERNET_MAX_URL_LENGTH + 1];
    char szServerRelPath[INTERNET_MAX_URL_LENGTH + 1];
    char szObject[INTERNET_MAX_URL_LENGTH + 1];
    char szUserName[UNLEN+1];
    char szPasswd[UNLEN+1];

	HRESULT hr=S_OK;

    // We need to break down the Passed in URL into its various components for the InternetAPI Calls. Specifically we
    // Need the server name, object to download, username and password information.
    ZeroMemory(szServerName, INTERNET_MAX_URL_LENGTH + 1);
    ZeroMemory(szObject, INTERNET_MAX_URL_LENGTH + 1);
    ZeroMemory(&UrlComponents, sizeof(UrlComponents));
    ZeroMemory(szServerRelPath, INTERNET_MAX_URL_LENGTH + 1);
    
    UrlComponents.dwStructSize = sizeof(UrlComponents);
    UrlComponents.lpszHostName = szServerName;
    UrlComponents.dwHostNameLength = INTERNET_MAX_URL_LENGTH + 1;
    UrlComponents.lpszUrlPath = szServerRelPath;
    UrlComponents.dwUrlPathLength = INTERNET_MAX_URL_LENGTH + 1;
    UrlComponents.lpszUserName = szUserName;
    UrlComponents.dwUserNameLength = UNLEN + 1;
    UrlComponents.lpszPassword = szPasswd;
    UrlComponents.dwPasswordLength = UNLEN + 1;

    if (! InternetCrackUrlA(m_pV3->m_szV31RootUrl, 0, 0, &UrlComponents) )
    {
        dwErr = GetLastError();
        LOG_error("InternetCrackUrl() Failed, Error: %d", dwErr);
        return dwErr;
    }

    // If the connection has already been established re-use it.
    if (NULL == m_hInternet)
    {
        if (! (m_hInternet = InternetOpenA("Dynamic Update", INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0)) )
        {
            dwErr = GetLastError();
            LOG_error("InternetOpen() Failed, Error: %d", dwErr);
            return dwErr;
        }
    }

    dwStatus = 30 * 1000; // 30 seconds in milliseconds
    dwLength = sizeof(dwStatus);
    InternetSetOptionA(m_hInternet, INTERNET_OPTION_SEND_TIMEOUT, &dwStatus, dwLength);

    if (NULL == m_hConnect || 0 != lstrcmpi(m_szCurrentConnectedServer, szServerName))
    {
        // No connection established yet, or we are connecting to a new server.
        SafeInternetCloseHandle(m_hConnect);
        if (! (m_hConnect = InternetConnectA(m_hInternet, szServerName, INTERNET_DEFAULT_HTTP_PORT, szUserName, szPasswd,
            INTERNET_SERVICE_HTTP, INTERNET_FLAG_NO_UI | INTERNET_FLAG_RELOAD, 0)) )
        {
            dwErr = GetLastError();
            LOG_error("InternetConnect() Failed, Error: %d", dwErr);
            return dwErr;
        }
        

        hr=StringCchCopy(m_szCurrentConnectedServer,ARRAYSIZE(m_szCurrentConnectedServer),szServerName);
        if(FAILED(hr))
        {
            SafeInternetCloseHandle(m_hOpenRequest);
            dwErr=HRESULT_CODE(hr);
            LOG_error("StringCchCopy Failed ErrorCode:%d",dwErr);
            SetLastError(dwErr);
            return dwErr;
        }

    }

    SafeInternetCloseHandle(m_hOpenRequest); // make sure there is no open request before creating the new one.

    switch(iPingBackType)
    {
    case DU_PINGBACK_DOWNLOADSTATUS:
        {
            hr=StringCchPrintfA(szObject,ARRAYSIZE(szObject),"%s/wutrack.bin?PUID=%d&PLAT=%d&BUILD=%d.%d.%d&SP=%d.%d&LOCALE=0x%08x&STATUS=%s&GUID=&PNPID=",
                    szServerRelPath, 
                    puid, 
                    m_iPlatformID, 
                    m_VersionInfo.dwMajorVersion,
                    m_VersionInfo.dwMinorVersion,
                    m_VersionInfo.dwBuildNumber,
                    m_VersionInfo.wServicePackMajor,
                    m_VersionInfo.wServicePackMinor,
                    (long)m_lcidLocaleID, 
                    fSucceeded ? "DU_DOWNLOAD_SUCCESS" : "DU_DOWNLOAD_FAILURE");

            if(FAILED(hr))
            {
                SafeInternetCloseHandle(m_hOpenRequest);
                dwErr=HRESULT_CODE(hr);
                LOG_error("StringCchPrintfA Failed ErrorCode:%d",dwErr);
                SetLastError(dwErr);
                return dwErr;
            }
            break;
        }
    case DU_PINGBACK_DRIVERNOTFOUND:
        {
            // driver not found pingback
          
            hr=StringCchPrintfA(szObject,ARRAYSIZE(szObject),"%s/wutrack.bin?PUID=0&PLAT=%d&BUILD=%d.%d.%d&SP=%d.%d&LOCALE=0x%08x&STATUS=DUNODRIVER&GUID=0&PNPID=%s",
                    szServerRelPath, 
                    m_iPlatformID, 
                    m_VersionInfo.dwMajorVersion,
                    m_VersionInfo.dwMinorVersion,
                    m_VersionInfo.dwBuildNumber,
                    m_VersionInfo.wServicePackMajor,
                    m_VersionInfo.wServicePackMinor,
                    (long)m_lcidLocaleID, 
                    pszPnPID);

            if(FAILED(hr))
            {
                SafeInternetCloseHandle(m_hOpenRequest);
                dwErr=HRESULT_CODE(hr);
                LOG_error("StringCchPrintfA Failed ErrorCode:%d",dwErr);
                SetLastError(dwErr);
                return dwErr;
            }

            break;
        }
    case DU_PINGBACK_SETUPDETECTIONFAILED:
        {
            // this is a detection failed pingback (no specific item info)

            hr=StringCchPrintfA(szObject,ARRAYSIZE(szObject),"%s/wutrack.bin?PUID=0&PLAT=%d&BUILD=%d.%d.%d&SP=%d.%d&LOCALE=0x%08x&STATUS=DUSETUPDETECTIONFAILED&GUID=&PNPID=",
                    szServerRelPath, 
                    m_iPlatformID, 
                    m_VersionInfo.dwMajorVersion,
                    m_VersionInfo.dwMinorVersion,
                    m_VersionInfo.dwBuildNumber,
                    m_VersionInfo.wServicePackMajor,
                    m_VersionInfo.wServicePackMinor,
                    (long)m_lcidLocaleID);

            if(FAILED(hr))
            {
                SafeInternetCloseHandle(m_hOpenRequest);
                dwErr=HRESULT_CODE(hr);
                LOG_error("StringCchPrintfA Failed ErrorCode:%d",dwErr);
                SetLastError(dwErr);
                return dwErr;
            }
            break;
        }
    case DU_PINGBACK_DRIVERDETECTIONFAILED:
        {
            // this is a detection failed pingback (no specific item info)

            hr=StringCchPrintfA(szObject,ARRAYSIZE(szObject), "%s/wutrack.bin?PUID=0&PLAT=%d&BUILD=%d.%d.%d&SP=%d.%d&LOCALE=0x%08x&STATUS=DUDRIVERDETECTIONFAILED&GUID=&PNPID=",
                    szServerRelPath, 
                    m_iPlatformID, 
                    m_VersionInfo.dwMajorVersion,
                    m_VersionInfo.dwMinorVersion,
                    m_VersionInfo.dwBuildNumber,
                    m_VersionInfo.wServicePackMajor,
                    m_VersionInfo.wServicePackMinor,
                    (long)m_lcidLocaleID);

            if(FAILED(hr))
            {
                SafeInternetCloseHandle(m_hOpenRequest);
                dwErr=HRESULT_CODE(hr);
                LOG_error("StringCchPrintfA Failed ErrorCode:%d",dwErr);
                SetLastError(dwErr);
                return dwErr;
            }
            break;
        }
    }

    LOG_out("contact server %s", szObject);
    if (! (m_hOpenRequest = HttpOpenRequestA(m_hConnect, NULL, szObject, NULL, NULL, (LPCSTR *)AcceptTypes, 
        INTERNET_FLAG_KEEP_CONNECTION | INTERNET_FLAG_NO_UI | INTERNET_FLAG_RELOAD, 0)) )
    {
        dwErr = GetLastError();
        // log result
        return dwErr;
    }

    if (! HttpSendRequestA(m_hOpenRequest, NULL, 0, NULL, 0) )
    {
        dwErr = GetLastError();
        // log result
        return dwErr;
    }
    
    SafeInternetCloseHandle(m_hOpenRequest);
    return ERROR_SUCCESS;

}

BOOL CDynamicUpdate::NeedRetry(DWORD dwErrCode)
{
    BOOL bRetry = FALSE;
    bRetry =   ((dwErrCode == ERROR_INTERNET_CONNECTION_RESET)    //most common
             || (dwErrCode == HTTP_STATUS_NOT_FOUND)                          //404
             || (dwErrCode == ERROR_HTTP_HEADER_NOT_FOUND)              //seen sometimes
             || (dwErrCode == ERROR_INTERNET_OPERATION_CANCELLED)  //dont know if..
             || (dwErrCode == ERROR_INTERNET_ITEM_NOT_FOUND)           //..these occur..
             || (dwErrCode == ERROR_INTERNET_OUT_OF_HANDLES)           //..but seem most..
             || (dwErrCode == ERROR_INTERNET_TIMEOUT));                      //..likely bet
    return bRetry;
}

// ----------------------------------------------------------------------------------
// 
// VerifyFileCRC : This function takes a File Path, calculates the hash on this file
// and compares it to the passed in Hash (pCRC).
// Returns:
// S_OK: CRC's Match
// ERROR_CRC (HRESULT_FROM_WIN32(ERROR_CRC): if the CRC's do not match
// Otherwise an HRESULT Error Code
//
// ----------------------------------------------------------------------------------
HRESULT CDynamicUpdate::VerifyFileCRC(LPCTSTR pszFileToVerify, LPCTSTR pszHash)
{
    LOG_block("CDynamicUpdate::VerifyFileCRC()");
    HRESULT hr = S_OK;
    TCHAR szCompareCRC[CRC_HASH_STRING_LENGTH];
       
    // Validate Parameters
    if ((NULL == pszFileToVerify) || (NULL == pszHash))
        return E_INVALIDARG;

    hr = CalculateFileCRC(pszFileToVerify, szCompareCRC, ARRAYSIZE(szCompareCRC));
    if (FAILED(hr))
    {
        // Its possible on some platforms that the CRC DLL (wintrust.dll) is not available, or this API is not available.
        // Assume if this failed, that we just can't check it and assume its ok.
        LOG_out("CalculateFileCRC() returned error %08x, Assuming CRC Checking is Not Possible", hr);
        return S_OK;
    }

    // Now we need to Compare the Calculated CRC with the Passed in CRC
    if (0 == lstrcmpi(szCompareCRC, pszHash))
    {
        LOG_out("File: %s, CRC's Match", pszFileToVerify);
        return S_OK; // CRC's Match
    }
    else
    {
        LOG_error("File: %s, CRC Match Failed!", pszFileToVerify);
        return HRESULT_FROM_WIN32(ERROR_CRC); // CRC's do not match
    }
}

// ----------------------------------------------------------------------------------
// 
// CalculateFileCRC : This function takes a File Path, calculates a CRC from the file
// converts it to a string and returns it in the supplied TCHAR buffer
//
// ----------------------------------------------------------------------------------

typedef BOOL (WINAPI * PFN_CryptCATAdminCalcHashFromFileHandle)(HANDLE hFile,
                                                                                                          DWORD *pcbHash,
                                                                                                          BYTE *pbHash,
                                                                                                          DWORD dwFlags);

HRESULT CDynamicUpdate::CalculateFileCRC(LPCTSTR pszFileToHash, LPTSTR pszHash, int cchBuf)
{
    LOG_block("CDynamicUpdate::CalculateFileCRC()");
    HANDLE hFile;
    HRESULT hr = S_OK;
    DWORD cbHash = CRC_HASH_SIZE;
    BYTE bHashBytes[CRC_HASH_SIZE];
    BYTE b;

    // Validate Parameters
    if ((NULL == pszFileToHash) || (NULL == pszHash) || (cchBuf < CRC_HASH_STRING_LENGTH))
    {
        LOG_error("Invalid Arguments");
        return E_INVALIDARG;
    }

    hFile = CreateFile(pszFileToHash, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (INVALID_HANDLE_VALUE != hFile)
    {
        HMODULE hWinTrust = LoadLibrary("wintrust.dll");
        if (NULL == hWinTrust)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            LOG_error("LoadLibrary Failed. Error: %08x", hr);
        }
        else
        {
            PFN_CryptCATAdminCalcHashFromFileHandle fpnCryptCATAdminCalcHashFromFileHandle = NULL;
            
            fpnCryptCATAdminCalcHashFromFileHandle  = (PFN_CryptCATAdminCalcHashFromFileHandle) GetProcAddress(hWinTrust, "CryptCATAdminCalcHashFromFileHandle");
            if (NULL == fpnCryptCATAdminCalcHashFromFileHandle)
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                LOG_error("GetProcAddress Failed, error %08x", hr);
            }
            else
            {
                if (!fpnCryptCATAdminCalcHashFromFileHandle(hFile, &cbHash, bHashBytes, 0))
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                    LOG_error("CryptCATAdminCalcHashFromFileHandle, error %08x", hr);
                }
                fpnCryptCATAdminCalcHashFromFileHandle = NULL;
            }
            FreeLibrary(hWinTrust);
        }
        CloseHandle(hFile);
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        LOG_error("CreateFile Failed, error %08x", hr);
    }

    if (FAILED(hr))
        return hr;

    LPTSTR p = pszHash;

    // Now we have the Calculated CRC of the File, we need to convert it to a String and Return it. The following 
    // loop will go through each byte in the array and convert it to a Hex Character in the supplied TCHAR buffer
    for (int i = 0; i < CRC_HASH_SIZE; i++)
    {
        b = bHashBytes[i] >> 4;
        if (b <= 9)
            *p = '0' + (TCHAR)b;
        else
            *p = 'A' + (TCHAR)(b - 10);
        p++;

        b = bHashBytes[i] & 0x0F;
        if (b <= 9)
            *p = '0' + (TCHAR)b;
        else
            *p = 'A' + (TCHAR)(b - 10);
        p++;
    }
    *p = '\0';
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuv3\wsdu\wsdueng\multiszarray.h ===
// -------------------------------------------------------------------------------
// Created by RogerJ, October 4th, 2000
// This header file declares two classes that are closely linked to each other. These
// two classes provided a convenient way to construct, add, and remove a multi-sz list
// array.

#ifndef _WINDOWS_UPDATE_MULTI_SZ_LIST_BY_ROGERJ	
#define _WINDOWS_UPDATE_MULTI_SZ_LIST_BY_ROGERJ

struct PosIndex
{
	PosIndex() { x = y = -1;};
	int x;
	int y;
	inline BOOL operator < (PosIndex& other) { return (x<other.x) || ((x==other.x) && (y<other.y));};
	inline BOOL operator > (PosIndex& other) { return (x>other.x) || ((x==other.x) && (y>other.y));};
	inline BOOL operator == (PosIndex& other) { return (x==other.x) && (y==other.y);};
};

// forward declaration
class CMultiSZArray;

class CMultiSZString
{
public:
	// default constructor
	CMultiSZString();
	CMultiSZString (LPCTSTR pszHardwareId, int nSize = -1);
	// copy constructor
	CMultiSZString (CMultiSZString& CopyInfo);
	// destructor
	~CMultiSZString (void);

	// member functions
	BOOL ToString(LPTSTR pszBuffer, int* pnBufferLen);
	BOOL Compare(CMultiSZString& CompareString);
	BOOL CompareNoCase (CMultiSZString& CompareString);
	inline BOOL operator == (CMultiSZString& CompareString) { return Compare(CompareString);};
	inline void ResetIndex(void) { m_nIndex = 0; };
	LPCTSTR GetNextString(void);
	BOOL Contains(LPCTSTR pszIn);
	BOOL ContainsNoCase (LPCTSTR pszIn);
	BOOL PositionIndex(LPCTSTR pszIn, int* pPosition);
	inline void CheckFound(void) { m_bFound = TRUE;};
	inline BOOL IsFound(void) { return m_bFound; };

	// friend class
	friend class CMultiSZArray;
private:
	// member variables
	LPTSTR m_szHardwareId;
	int m_nSize;
	int m_nStringCount;
	int m_nIndex;
	BOOL m_bFound;

	// linking pointers
	CMultiSZString* prev;
	CMultiSZString* next;
};

class CMultiSZArray
{
public:
	// default constructor
	CMultiSZArray();
	// other constructors
	CMultiSZArray(CMultiSZString* pInfo);
	CMultiSZArray(LPCTSTR pszHardwareId, int nSize = -1);
	// destructor
	~CMultiSZArray(void);

	// operations
	BOOL RemoveAll(void);
	BOOL Add(CMultiSZString* pInfo);
	BOOL Add(LPCSTR pszHardwareId, int nSize = -1);
	inline BOOL Remove(CMultiSZString* pInfo) { return Remove(pInfo->m_szHardwareId);};
	inline BOOL Remove(CMultiSZString& Info) { return Remove(Info.m_szHardwareId);};
	BOOL Remove(LPCTSTR pszHardwareId);
	inline int GetCount(void) { return m_nCount;};
	BOOL ToString (LPTSTR pszBuffer, int* pnBufferLen);
	int GetTotalStringCount(void);
	inline void ResetIndex() { m_pIndex = m_pHead; };
	CMultiSZString* GetNextMultiSZString(void);
	BOOL Contains(LPCTSTR pszIn);
	BOOL ContainsNoCase (LPCTSTR pszIn);
	BOOL PositionIndex(LPCTSTR pszIn, PosIndex* pPosition);
	BOOL CheckFound(int nIndex);

private:
	// member vairables
	CMultiSZString* m_pHead;
	CMultiSZString* m_pTail;
	int m_nCount;
	CMultiSZString* m_pIndex;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuv3\wsdu\wsdueng\v3server.h ===
// ----------------------------------------------------------------------------------
// V3.1 Backend Server Apis
//
//
class CDynamicUpdate; // forward declare the CDynamicUpdate class defined in wsdueng.h

#define CATALOGINIFN "catalog.ini"
#define GUIDRVINF "guidrvs.inf"

typedef enum 
{
    enWhistlerConsumer          = 90934, // VER_SUITE_PERSONAL
    enWhistlerProfessional      = 90935, // 0
    enWhistlerServer            = 90936, // VER_SUITE_SMALLBUSINESS
    enWhistlerAdvancedServer    = 90937, // VER_SUITE_ENTERPRISE
    enWhistlerDataCenter        = 90938, // VER_SUITE_DATACENTER
    enWhistlerSmallBusiness     = 90950, // VER_SUITE_SMALLBUSINESS_RESTRICTED
    enWhistlerWebBlade          = 90951, // VER_SUITE_BLADE
} enumPlatformSKUs;

class CV31Server
{
public:
    CV31Server(CDynamicUpdate *pDu);
    ~CV31Server();

public:
    BOOL ReadIdentInfo(void);
    BOOL ReadCatalogINI(void);
    BOOL ReadGuidrvINF(void);
    BOOL GetCatalogPUIDs(void);
    BOOL GetCatalogs(void);
    BOOL UpdateDownloadItemList(OSVERSIONINFOEX& VersionInfo);
	void FreeCatalogs(void);
	BOOL MakeDependentList(OSVERSIONINFOEX& VersionInfo, CCRCMapFile *pMapFile);
	BOOL IsDependencyApply(PUID puid);
	BOOL GetBitMask(LPSTR szBitmapServerFileName, PUID nDirectoryPuid, PBYTE* pByte, LPSTR szDecompressedName);
	BOOL IsPUIDExcluded(PUID nPuid);
	BOOL IsDriverExcluded(LPCSTR szWHQLId, LPCSTR szHardwareId);
	BOOL GetAltName(LPCSTR szCabName, LPSTR szAltName, int nSize);

public:
    // Catalog Parsing Functions
    PBYTE GetNextRecord(PBYTE pRecord, int iBitmaskIndex, PINVENTORY_ITEM pItem);
    int GetRecordType(PINVENTORY_ITEM pItem);
    BOOL ReadDescription(PINVENTORY_ITEM pItem, CCRCMapFile *pMapFile);

public:
    PUID                m_puidConsumerCatalog;
    PUID                m_puidSetupCatalog;
    DWORD               m_dwPlatformID;
    enumPlatformSKUs    m_enumPlatformSKU;
    LCID                m_lcidLocaleID;

    DWORD                   m_dwConsumerItemCount;
   	Varray<PINVENTORY_ITEM>	m_pConsumerItems;		//array of consumer catalog items
	PBYTE                   m_pConsumerCatalog;     //in memory view of the Consumer Catalog.
    DWORD                   m_dwSetupItemCount;
    Varray<PINVENTORY_ITEM> m_pSetupItems;          //array of setup catalog items
	PBYTE					m_pSetupCatalog;        //in memory view of the setup catalog
    DWORD                   m_dwGlobalExclusionItemCount;
    Varray<PUID>            m_GlobalExclusionArray; //array of PUID's that are excluded
    PUID*					m_pValidDependentPUIDArray; // array of PUIDs that is valid for dependent item on this version
    int 					m_nNumOfValidDependentPUID;
    PBYTE					m_pBitMaskAS;			// bitmask for Setup 	
    PBYTE 					m_pBitMaskCDM;			// bitmask for Driver

    CDynamicUpdate *m_pDu;
    
    BOOL					m_fHasDriver;
    LPSTR					m_pszExcludedDriver;

    // Server Ident Paths
    char m_szCabPoolUrl[INTERNET_MAX_URL_LENGTH + 1];
    char m_szV31ContentUrl[INTERNET_MAX_URL_LENGTH + 1];
    char m_szV31RootUrl[INTERNET_MAX_URL_LENGTH + 1];
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuv3\wsdu\wsdueng\multiszarray.cpp ===
// -----------------------------------------------------------------------------------
// Created by RogerJ, October 4th, 2000
// Implementation of MultiSZ smart Array
//

#include <windows.h>
#include "MultiSZArray.h"
#include <strsafe.h>

// class CMultiSZString

// defatul constructor
CMultiSZString::CMultiSZString()
{
	m_nSize = m_nStringCount = m_nIndex = 0;
	m_bFound = FALSE;
	m_szHardwareId = NULL;
	prev = next = NULL;
}

// constructor
CMultiSZString::CMultiSZString(LPCTSTR pszHardwareId, int nSize)
{
	prev = next = NULL;
	m_nSize = m_nStringCount = m_nIndex = 0;
	m_bFound = FALSE;
	m_szHardwareId = NULL;
	if (pszHardwareId)
	{

		if (nSize >= 0)
		{
			// passed in a regular LPCTSTR
			m_nSize = nSize;
			m_nStringCount = 1;
		}
		else
		{
			// passed in a multi-sz LPCTSTR
			// get the size
			LPTSTR pTemp = const_cast<LPTSTR>(pszHardwareId);
			while (*pTemp)
			{
				int nTempSize = lstrlen(pTemp) + 1;
				m_nSize += nTempSize;
				pTemp += nTempSize;

				m_nStringCount++;
			}
		}
		
		
		// allocate memory
		m_szHardwareId = new TCHAR [m_nSize+1];

		if (!m_szHardwareId)
			// failed to allocate memory
			throw ERROR_OUTOFMEMORY;

		// initialize allocated memory
		ZeroMemory (m_szHardwareId, (m_nSize+1) * sizeof(TCHAR)); // +1 for a possible trail NULL
		CopyMemory ((PVOID)m_szHardwareId, (CONST VOID*)pszHardwareId, m_nSize*sizeof(TCHAR));
		m_nSize ++;
	}
}

// copy constructor
CMultiSZString::CMultiSZString(CMultiSZString& CopyInfo)
{
	prev = next = NULL;
	m_nIndex = 0;
	m_nSize = CopyInfo.m_nSize;
	m_bFound = CopyInfo.m_bFound;
	
	// allocate memory
	m_szHardwareId = new TCHAR [m_nSize];
	if (!m_szHardwareId)
		// failed to allocate memory
		throw ERROR_OUTOFMEMORY;
	// initialize allocated memory
	ZeroMemory (m_szHardwareId, m_nSize * sizeof(TCHAR));
	CopyMemory ((PVOID)m_szHardwareId, (CONST VOID*)(CopyInfo.m_szHardwareId), m_nSize*sizeof(TCHAR));
}
	
// destructor
CMultiSZString::~CMultiSZString()
{
	if (m_szHardwareId)
		delete [] m_szHardwareId;
	m_szHardwareId = NULL;
	prev = next = NULL;
	m_nSize = m_nIndex = 0;
}


BOOL CMultiSZString::ToString (LPTSTR pszBuffer, int* pnBufferLen)
{
	if (!pszBuffer)
	{
		// query for output buffer length
		if (m_nSize <= 0) 
			*pnBufferLen = 1;
		else 
			*pnBufferLen = m_nSize;
		return TRUE;
	}

	if (*pnBufferLen < m_nSize)
	{
		*pnBufferLen = m_nSize;
		return FALSE;
	}

	// duel with NULL string special case
	if (m_nSize <= 0)
	{
		*pszBuffer = NULL;
		return TRUE;
	}

	ZeroMemory(pszBuffer, *pnBufferLen * sizeof(TCHAR));
	
	LPTSTR pTemp = m_szHardwareId;
	LPTSTR pTemp2 = pszBuffer;
    size_t bufferSize = *pnBufferLen;

	while (*pTemp)
	{
        if (FAILED(StringCchCopyEx(pTemp2, bufferSize, pTemp, &pTemp2, &bufferSize, STRSAFE_IGNORE_NULLS))) {
            return FALSE;
        }
		// add space in the place of NULL character
//		pTemp2 += lstrlen(pTemp2);
		*pTemp2 = ' ';
		pTemp2++;
		// move to next string in Multi-SZ string
		pTemp += lstrlen(pTemp) + 1;
	}
	return TRUE;
}


// compare two multi-sz string
BOOL CMultiSZString::Compare (CMultiSZString& CompareSZ)
{
	LPTSTR pThis = m_szHardwareId;
	LPTSTR pComp = CompareSZ.m_szHardwareId;

	// compare size first
	if (m_nSize != CompareSZ.m_nSize) return FALSE;

	// size are same
	while (*pThis && *pComp)
	{
		// compare one string in the list
		if (0 != lstrcmp(pThis, pComp))
			return FALSE;

		// move to next string
		int nIncrement = lstrlen(pThis);
		pThis += nIncrement + 1;
		pComp += nIncrement + 1;
	}

	// one multi-sz terminates, check to see if both terminates
	if (*pThis || *pComp) return FALSE;
	else return TRUE;
		
}


// compare two multi-sz string case insensitively
BOOL CMultiSZString::CompareNoCase (CMultiSZString& CompareSZ)
{
	LPTSTR pThis = m_szHardwareId;
	LPTSTR pComp = CompareSZ.m_szHardwareId;

	// compare size first
	if (m_nSize != CompareSZ.m_nSize) return FALSE;

	// size are same
	while (*pThis && *pComp)
	{
		// compare one string in the list
		if (0 != lstrcmpi(pThis, pComp))
			return FALSE;

		// move to next string
		int nIncrement = lstrlen(pThis) + 1;
		pThis += nIncrement;
		pComp += nIncrement;
	}

	// one multi-sz terminates, check to see if both terminates
	if (*pThis || *pComp) return FALSE;
	else return TRUE;
		
}

LPCTSTR CMultiSZString::GetNextString(void)
{
	// reached end of the multiSZ string
	if (m_nIndex >= m_nSize) return NULL;
	
	// else
	LPTSTR pTemp = m_szHardwareId + m_nIndex;
	m_nIndex += lstrlen(pTemp) + 1;
	return pTemp;
}

// return TRUE if pszIn is in the Multi-SZ string
BOOL CMultiSZString::Contains(LPCTSTR pszIn)
{
	LPTSTR pThis = m_szHardwareId;

	while (*pThis)
	{
		if (!lstrcmp(pThis, pszIn))
			// match found
			return TRUE;
		pThis += (lstrlen(pThis) +1);
	}

	// not found
	return FALSE;
}


// return TRUE if pszIn is in the Multi-SZ string
BOOL CMultiSZString::ContainsNoCase(LPCTSTR pszIn)
{
	LPTSTR pThis = m_szHardwareId;

	while (*pThis)
	{
		if (!lstrcmpi(pThis, pszIn))
			// match found
			return TRUE;
		pThis += (lstrlen(pThis) +1);
	}

	// not found
	return FALSE;
}

BOOL CMultiSZString::PositionIndex(LPCTSTR pszIn, int* pPosition)
{
	if (!pPosition) return FALSE;
	*pPosition = 0;
	
	LPTSTR pThis = m_szHardwareId;

	while (*pThis)
	{
		if (!lstrcmpi(pThis, pszIn))
		{	
			// match found
			return TRUE;
		}
		pThis += (lstrlen(pThis) +1);
		(*pPosition)++;
	}

	// not found
	*pPosition = -1;
	return FALSE;
}
	
	


// Class CMultiSZArray

// default constructor
CMultiSZArray::CMultiSZArray()
{
	m_nCount = 0;
	m_pHead = m_pTail = m_pIndex = NULL;
}

// other constructors
CMultiSZArray::CMultiSZArray(LPCTSTR pszHardwareId, int nSize)
{
	CMultiSZString *pNode = new CMultiSZString(pszHardwareId, nSize);

	if (!pNode) throw ERROR_OUTOFMEMORY;

	m_nCount = 1;
	m_pHead = m_pTail = m_pIndex = pNode;
}

CMultiSZArray::CMultiSZArray(CMultiSZString* pNode)
{
	if (!pNode) return;

	m_nCount = 1;
	m_pHead = m_pTail = m_pIndex =pNode;
}

// destructor
CMultiSZArray::~CMultiSZArray(void)
{
	RemoveAll();
}

// member functions

// Function RemoveAll() delete all the memory allocated for the array and set the status back to initial state
BOOL CMultiSZArray::RemoveAll(void)
{
	CMultiSZString* pTemp = NULL;

	for (int i=0; i<m_nCount; i++)
	{
		pTemp = m_pHead;
		m_pHead = m_pHead->next;

		delete pTemp;
	}

	m_pHead = m_pTail = m_pIndex = NULL;
	m_nCount = 0;
	return TRUE;
}

BOOL CMultiSZArray::Add(CMultiSZString* pInfo)
{
	if (!pInfo) return TRUE;

	if (!m_nCount)
		m_pHead = pInfo;
	else
	{
		// link
		m_pTail->next = pInfo;
		pInfo->prev = m_pTail;
		pInfo->next = NULL;
	}
	// move tail
	m_pTail = pInfo;
	m_nCount++;
	return TRUE;
}

BOOL CMultiSZArray::Add(LPCSTR pszHardwareId, int nSize)
{
	CMultiSZString* pNode = new CMultiSZString(pszHardwareId, nSize);
	return Add(pNode);
}


BOOL CMultiSZArray::Remove(LPCSTR pszHardwareId)
{
	CMultiSZString* pTemp = m_pHead;
	while (pTemp)
	{
		if (pTemp->m_szHardwareId == pszHardwareId)
		{
			// found match
			if (pTemp->prev)
				// not the head node
				pTemp->prev->next = pTemp->next;
			else
			{
				// head node, move the head node
				m_pHead = pTemp->next;
				if (m_pHead) m_pHead->prev = NULL;
			}

			if (pTemp->next)
				// not the tail node
				pTemp->next->prev = pTemp->prev;
			else
			{
				// tail node, move the tail node
				m_pTail = pTemp->prev;
				if (m_pTail) m_pTail->next = NULL;
			}
			delete pTemp;
			m_nCount--;
			return TRUE;
		}
		pTemp = pTemp->next;
	}
	// no match found or no node in the array
	return FALSE;
}
		
BOOL CMultiSZArray::ToString(LPTSTR pszBuffer, int* pnBufferLen)
{
	int nTempLen = 0;
	CMultiSZString* pTemp = m_pHead;

	for (int i=0; i<m_nCount; i++)
	{
		nTempLen += pTemp->m_nSize;
		pTemp = pTemp->next;
	}

	nTempLen++; // the trailing NULL character
	
	if (!pszBuffer)
	{
		// request for length
		*pnBufferLen = nTempLen;
		return TRUE;
	}
	else
	{
		if (*pnBufferLen < nTempLen)
		{
			// buffer too small
			*pnBufferLen = nTempLen;
			return FALSE;
		}
		else
		{
			ZeroMemory(pszBuffer, *pnBufferLen * sizeof (TCHAR));
			
			LPTSTR pszTemp = pszBuffer;
			int nSizeLeft = *pnBufferLen;
			pTemp = m_pHead;

			for (int j=0; j<m_nCount; j++)
			{
				pTemp->ToString(pszTemp, &nSizeLeft);
				pszTemp += pTemp->m_nSize - 1;
				*pszTemp = '\n';
				nSizeLeft -= pTemp->m_nSize;

				pTemp = pTemp->next;
			}

			return TRUE;
		}		
	}
}

int CMultiSZArray::GetTotalStringCount()
{
	CMultiSZString* pTemp = m_pHead;
	int nTotalCount = 0;
	
	for (int i = 0; i<m_nCount; i++)
	{
		nTotalCount += pTemp->m_nStringCount;

		pTemp = pTemp->next;
	}

	return nTotalCount;
}

CMultiSZString* CMultiSZArray::GetNextMultiSZString()
{
	CMultiSZString* pTemp = m_pIndex;

	if (m_pIndex) m_pIndex = m_pIndex->next;

	return pTemp;
}
		
BOOL CMultiSZArray::Contains(LPCTSTR pszIn)
{
	CMultiSZString* pTemp = m_pHead;

	for (int i=0; i<m_nCount; i++)
	{
		if (pTemp->Contains(pszIn))
			return TRUE;
		pTemp = pTemp->next;
	}

	return FALSE;
}

BOOL CMultiSZArray::ContainsNoCase(LPCTSTR pszIn)
{
	CMultiSZString* pTemp = m_pHead;

	for (int i=0; i<m_nCount; i++)
	{
		if (pTemp->ContainsNoCase(pszIn))
			return TRUE;
		pTemp = pTemp->next;
	}

	return FALSE;
}

BOOL CMultiSZArray::PositionIndex(LPCTSTR pszIn, PosIndex* pPosition)
{
	if (!pPosition) return FALSE;
	CMultiSZString* pTemp = m_pHead;

	pPosition->y = 0;
	pPosition->x = 0;
	
	for (int i=0; i<m_nCount; i++)
	{
		if (pTemp->PositionIndex(pszIn, &(pPosition->y)))
			return TRUE;
		(pPosition->x)++;
		pTemp = pTemp->next;
	}

	pPosition->x = pPosition->y = -1;
	return FALSE;
}

BOOL CMultiSZArray::CheckFound(int nIndex)
{
    if (nIndex > m_nCount) return FALSE;
    
    CMultiSZString* pTemp = NULL;
    ResetIndex();

    for (int i=0; i<=nIndex; i++)
    {
        pTemp = GetNextMultiSZString();
    }

    pTemp->CheckFound();
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuv3\wsdu\wsdueng\wsdueng.cpp ===
#include "wsdueng.h"

HINSTANCE g_hinst;
CDynamicUpdate *g_pDynamicUpdate = NULL;
DWORD WaitAndPumpMessages(DWORD nCount, LPHANDLE pHandles, DWORD dwWakeMask);

BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpvReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        DisableThreadLibraryCalls(hInstance);
        g_hinst = hInstance;
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        ;
    }
    return TRUE;
}


// Required function to be able to link CDMLIB..
HMODULE GetModule()
{
    return g_hinst;
}


// --------------------------------------------------------------------------
// Function Name: SetEstimatedDownloadSpeed
// Function Description: Sets the Download speed used for download time estimates
//
// Function Returns:
//      Nothing
//
void WINAPI SetEstimatedDownloadSpeed(DWORD dwBytesPerSecond)
{
    if (NULL != g_pDynamicUpdate)
        g_pDynamicUpdate->m_dwDownloadSpeedInBytesPerSecond = dwBytesPerSecond;
}

// --------------------------------------------------------------------------
// Function Name: SetIESupportsSSL
// Function Description: Sets whether SSL support is available from the IE Version, From Wrapper
//
// Function Returns:
//      Nothing
//
void WINAPI SetIESupportsSSL(BOOL fUseSSL)
{
    if (NULL != g_pDynamicUpdate)
        g_pDynamicUpdate->m_fUseSSL = fUseSSL;
}


// --------------------------------------------------------------------------
// Function Name: DuInitializeA
// Function Description: Initializes the DynamicUpdate class and converts the OSVERSIONINFO information into a Platform ID
//
// Function Returns:
//      INVALID_HANDLE_VALUE if it fails
//      HANDLE value of 1 if it succeeds
//
// NOTE: The use of a HANDLE could allow us to return the address of the DynamicUpdate Object, which was originally intended, but it seemed simpler
// to just use a global.. 
HANDLE WINAPI DuInitializeA(IN LPCSTR pszBasePath, IN LPCSTR pszTempPath, POSVERSIONINFOEXA posviTargetOS, IN LPCSTR pszTargetArch, 
                                               IN LCID lcidTargetLocale, IN BOOL fUnattend, IN BOOL fUpgrade, IN PWINNT32QUERY pfnWinnt32QueryCallback)
{
    LOG_block("DuInitializeA in DuEng");

    // parse the OSVERSIONINFO struct for the platform ID
    int iPlatformID = 0;
    // The TargetOS Platform ID is based on a couple of things.
    // The Whister Platform ID is the OSVERSIONINFOEX structure with the fields dwMajorVersion and dwMinorVersion set to 5.1
    // The other identifier in the platform ID is whether its i386 or ia64 (64bit) .. This is defined in the pszTargetArch String

    if (5 == posviTargetOS->dwMajorVersion)
    {
        if (1 == posviTargetOS->dwMinorVersion)
        {
            // Whistler
            if (NULL != StrStrI(pszTargetArch, "i386"))
            {
                iPlatformID = 18; // Whistler x86 (normal)
            }
            else if (NULL != StrStrI(pszTargetArch, "ia64"))
            {
                iPlatformID = 19; // Whistler ia64 (64bit)
            }
        }
        else if (2 == posviTargetOS->dwMinorVersion)
        {
            // Whistler
            if (NULL != StrStrI(pszTargetArch, "i386"))
            {
                iPlatformID = 18; // Whistler x86 (normal)
            }
            else if (NULL != StrStrI(pszTargetArch, "ia64"))
            {
                iPlatformID = 19; // Whistler ia64 (64bit)
            }
        }
    }

    if (0 == iPlatformID)
    {
        // No known Platform ID for DynamicUpdate was found.. Return Error
        return INVALID_HANDLE_VALUE;
    }
    WORD wPlatformSKU = posviTargetOS->wSuiteMask;

    if (g_pDynamicUpdate)
    {
        // a former call to this function has already initialized an instance of CDynamicUpdate class
        delete g_pDynamicUpdate;
        g_pDynamicUpdate = NULL;
    }

    
    g_pDynamicUpdate = new CDynamicUpdate(iPlatformID, lcidTargetLocale, wPlatformSKU, pszTempPath, 
                                                                     pszBasePath, pfnWinnt32QueryCallback, posviTargetOS);
    if (NULL == g_pDynamicUpdate)
    {
        return INVALID_HANDLE_VALUE;
    }
    
    return (HANDLE)1;    
}

// --------------------------------------------------------------------------
// Function Name: DuDoDetection
// Function Description: Searches the Catalogs on the WU Site to find Updates for setup
//
// Function Returns:
//      FALSE if there are no items OR there is an error.. Use GetLastError() for more information.
//      TRUE if it succeeds and there are items to download.
//
// Comment: If return value is FALSE and GetLastError return ERROR_NO_MORE_ITEMS there are no items to download.
//
BOOL WINAPI DuDoDetection(IN HANDLE hConnection, OUT PDWORD pdwEstimatedTime, OUT PDWORD pdwEstimatedSize)
{
    LOG_block("DuDoDetection in DuEng");

    DWORD dwRetSetup;
    dwRetSetup = 0;

    if (NULL == g_pDynamicUpdate)
        return FALSE;

    g_pDynamicUpdate->ClearDownloadItemList();
    dwRetSetup = g_pDynamicUpdate->DoSetupUpdateDetection();
    if (ERROR_SUCCESS != dwRetSetup)
    {
        LOG_error("Failed to get setup update item! --- %d", dwRetSetup);
        g_pDynamicUpdate->PingBack(DU_PINGBACK_SETUPDETECTIONFAILED, 0, NULL, FALSE);
        return FALSE;
    }

    if (g_pDynamicUpdate->m_dwDownloadItemCount > 0)
    {
        g_pDynamicUpdate->UpdateDownloadItemSize();
        *pdwEstimatedSize = g_pDynamicUpdate->m_dwTotalDownloadSize; // size in bytes
        // Time Estimate is based on roughly how long it took us to download the data files.
        if (0 == g_pDynamicUpdate->m_dwDownloadSpeedInBytesPerSecond)
            g_pDynamicUpdate->m_dwDownloadSpeedInBytesPerSecond = 2048; // default to 120k per minute, (2048 bytes per second).

        *pdwEstimatedTime = g_pDynamicUpdate->m_dwTotalDownloadSize / g_pDynamicUpdate->m_dwDownloadSpeedInBytesPerSecond; // number of seconds
        if (*pdwEstimatedTime == 0)
            *pdwEstimatedTime = 1; // at least one second

        SetLastError(dwRetSetup);

        return TRUE;
    }
    else
    {
        // initialize the size and time for setup
        *pdwEstimatedTime = 1;
        *pdwEstimatedSize = 0;
        // At this point there was no error, but we have no items to download, 
        SetLastError(ERROR_NO_MORE_ITEMS);
        return TRUE;
    }
}

// --------------------------------------------------------------------------
//
//
//
//
//
//
// --------------------------------------------------------------------------
BOOL WINAPI DuBeginDownload(IN HANDLE hConnection, IN HWND hwndNotify)
{
    if ((NULL == g_pDynamicUpdate) || (NULL == hwndNotify))
    {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    if (0 == g_pDynamicUpdate->m_dwDownloadItemCount)
    {
        SetLastError(ERROR_NO_MORE_ITEMS);
        PostMessage(hwndNotify, WM_DYNAMIC_UPDATE_COMPLETE, (WPARAM) DU_STATUS_SUCCESS, (LPARAM) NULL);

        return TRUE;
    }

    g_pDynamicUpdate->SetCallbackHWND(hwndNotify);  
    g_pDynamicUpdate->SetAbortDownload(FALSE);

    if (ERROR_SUCCESS != g_pDynamicUpdate->DownloadFilesAsync())
    {
        return FALSE;
    }

    return TRUE; // download has been started
}

// --------------------------------------------------------------------------
//
//
//
//
//
//
// --------------------------------------------------------------------------
void WINAPI DuAbortDownload(IN HANDLE hConnection)
{
    if (NULL == g_pDynamicUpdate)
        return;

    g_pDynamicUpdate->SetAbortDownload(TRUE);
    return;
}

// --------------------------------------------------------------------------
//
//
//
//
//
//
// --------------------------------------------------------------------------
void WINAPI DuUninitialize(IN HANDLE hConnection)
{
    if (NULL == g_pDynamicUpdate)
        return;

    // We want to hold up the Uninitialize process until any other Threads
    // specifically the Download Thread. We are going to wait on the DownloadThreadProc
    // thread handle if it exists. Once the thread finishes, the wait proc will exit
    // and we can continue.

    if (NULL != g_pDynamicUpdate->m_hDownloadThreadProc)
        WaitAndPumpMessages(1, &g_pDynamicUpdate->m_hDownloadThreadProc, QS_ALLINPUT);
    
    delete g_pDynamicUpdate;
    g_pDynamicUpdate = NULL;
    LOG_close();
    return;
}

// --------------------------------------------------------------------------------------------
// Function Name: DuQueryUnsupportedDriversA()
// Function Description: On .NET Server all Driver Related Functions are stubbed out. Please look at the
//      XP SP1 sources for DU Driver Functionality
//      
// Return Code: BOOL
//      TRUE --- Always, LastError will be set to ERROR_NO_MORE_ITEMS
//      
//
BOOL DuQueryUnsupportedDriversA (IN HANDLE hConnection, // connection handle
                                 IN PCSTR *ListOfDriversNotOnCD, // multi-sz string array
                                 OUT PDWORD pdwEstimatedTime,
                                 OUT PDWORD pdwEstimatedSize)
{
	LOG_block("CDynamicUpdate::DuQueryUnsupportedDriversA");

	// parameter validation
	if (INVALID_HANDLE_VALUE == hConnection ||
		NULL == pdwEstimatedTime ||
		NULL == pdwEstimatedSize )
	{
		LOG_error("Invalid Parameter");
		SetLastError(ERROR_INVALID_PARAMETER);
		return FALSE;
	}
	
	// do setup item detection first

    if (NULL == g_pDynamicUpdate)
        return FALSE;

    DWORD dwRetSetup = 0;
    g_pDynamicUpdate->ClearDownloadItemList();
    
    dwRetSetup = g_pDynamicUpdate->DoSetupUpdateDetection();
    if (ERROR_SUCCESS != dwRetSetup)
    {
        LOG_error("Setup item detection failed --- %d", dwRetSetup);
        SetLastError(dwRetSetup);
		return FALSE;
    }

	// determine the download time and download size
    if (g_pDynamicUpdate->m_dwDownloadItemCount > 0)
    {
        g_pDynamicUpdate->UpdateDownloadItemSize();
        *pdwEstimatedSize = g_pDynamicUpdate->m_dwTotalDownloadSize; // size in bytes
        // Time Estimate is based on roughly how long it took us to download the data files.
        if (0 == g_pDynamicUpdate->m_dwDownloadSpeedInBytesPerSecond)
            g_pDynamicUpdate->m_dwDownloadSpeedInBytesPerSecond = 2048; // default to 120k per minute, (2048 bytes per second).

        *pdwEstimatedTime = g_pDynamicUpdate->m_dwTotalDownloadSize / g_pDynamicUpdate->m_dwDownloadSpeedInBytesPerSecond; // number of seconds
        if (*pdwEstimatedTime == 0)
            *pdwEstimatedTime = 1; // at least one second
        return TRUE;
    }
    else
    {
        // At this point there was no error, but we have no items to download, 
        SetLastError(ERROR_NO_MORE_ITEMS);
        return TRUE;
    }
}
    
// --------------------------------------------------------------------------
//
//
//
//
//
//
// --------------------------------------------------------------------------
CDynamicUpdate::CDynamicUpdate(int iPlatformID, LCID lcidLocaleID, WORD wPlatformSKU, LPCSTR pszTempPath, LPCSTR pszDownloadPath, PWINNT32QUERY pfnWinnt32QueryCallback,
                                                        POSVERSIONINFOEXA pVersionInfo)
    :   m_iPlatformID(iPlatformID),
        m_lcidLocaleID(lcidLocaleID),
        m_wPlatformSKU(wPlatformSKU),
        m_hwndClientNotify(NULL),
        m_pDownloadItemList(NULL),
        m_dwDownloadItemCount(0),
        m_dwTotalDownloadSize(0),
        m_dwCurrentBytesDownloaded(0),
        m_hInternet(NULL),
        m_hConnect(NULL),
        m_hOpenRequest(NULL),
        m_pV3(NULL),
        m_fAbortDownload(FALSE),
        m_dwLastPercentComplete(0),
        m_dwDownloadSpeedInBytesPerSecond(0),
        m_fUseSSL(FALSE),
        m_hDownloadThreadProc(NULL),
        m_pfnWinNT32Query(pfnWinnt32QueryCallback)
{

    (void)FixUpV3LocaleID(); // BUG: 435184 - Map 0c0a to 040a for V3 purposes

    if (NULL != pszTempPath)
    {
        StringCchCopy(m_szTempPath,ARRAYSIZE(m_szTempPath),pszTempPath);
    }
    if (NULL != pszDownloadPath)
    {
        StringCchCopy(m_szDownloadPath,ARRAYSIZE(m_szDownloadPath),pszDownloadPath);
    }

    StringCchCopy(m_szCurrentConnectedServer,ARRAYSIZE(m_szCurrentConnectedServer),"");


    CopyMemory((PVOID)&m_VersionInfo, (PVOID)pVersionInfo, sizeof(OSVERSIONINFOEXA));

    InitializeCriticalSection(&m_cs);
    InitializeCriticalSection(&m_csDownload);

//    m_hDevInfo = SetupDiGetClassDevs(NULL, NULL, NULL, DIGCF_PRESENT | DIGCF_ALLCLASSES);
}

// --------------------------------------------------------------------------
//
//
//
//
//
//
// --------------------------------------------------------------------------
CDynamicUpdate::~CDynamicUpdate()
{
    ClearDownloadItemList(); // free up any memory in the download list
    if (m_pV3) delete m_pV3;
    m_pV3 = NULL;

    DeleteCriticalSection(&m_cs);
    DeleteCriticalSection(&m_csDownload);
    SafeInternetCloseHandle(m_hOpenRequest);
    SafeInternetCloseHandle(m_hConnect);
    SafeInternetCloseHandle(m_hInternet);
    SafeCloseHandle(m_hDownloadThreadProc);
}

LPSTR CDynamicUpdate::DuUrlCombine(LPSTR pszDest, size_t cchDest, LPCSTR pszBase, LPCSTR pszAdd)
{
    if ((NULL == pszDest) || (NULL == pszBase) || (NULL == pszAdd))
    {
        return NULL;
    }

    
    if (FAILED(StringCchCopy(pszDest, cchDest, pszBase))) 
    {
        return NULL;
    }
    int iLen = lstrlen(pszDest);
    if ('/' == pszDest[iLen - 1])
    {
        // already has a trailing slash, check the 'add' string for a preceding slash
        if ('/' == *pszAdd)
        {
            // has a preceding slash, skip it.
            if (FAILED(StringCchCat(pszDest, cchDest, pszAdd + 1)))
            {
                return NULL;
            }
        }
        else
        {
            if (FAILED(StringCchCat(pszDest, cchDest, pszAdd)))
            {
                return NULL;
            }
        }
    }
    else
    {
        // no trailing slash, check the add string for a preceding slash
        if ('/' == *pszAdd)
        {
            // has a preceding slash, Add Normally
            if (FAILED(StringCchCat(pszDest, cchDest, pszAdd)))
            {
                return NULL;
            }
        }
        else
        {
            if (FAILED(StringCchCat(pszDest, cchDest, "/")))
            {
                return NULL;
            }
            if (FAILED(StringCchCat(pszDest, cchDest, pszAdd)))
            {
                return NULL;
            }
        }
    }
    return pszDest;
}


LPCSTR CDynamicUpdate::GetDuDownloadPath()
{
    return m_szDownloadPath;
}

LPCSTR CDynamicUpdate::GetDuServerUrl()
{
    return m_szServerUrl;
}

LPCSTR CDynamicUpdate::GetDuTempPath()
{
    return m_szTempPath;
}

// --------------------------------------------------------------------------
//
//
//
//
//
//
// --------------------------------------------------------------------------
DWORD CDynamicUpdate::DoSetupUpdateDetection()
{
    if (NULL == m_pV3)
    {
        m_pV3 = new CV31Server(this);
        if (NULL == m_pV3)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    if (!m_pV3->ReadIdentInfo())
    {
        return GetLastError();
    }

    if (!m_pV3->GetCatalogPUIDs())
    {
        return GetLastError();
    }

    if (!m_pV3->GetCatalogs())
    {
        // there was an error reading the catalogs
        return GetLastError();
    }
    if (!m_pV3->ReadCatalogINI())
    {
        return GetLastError();
    }
    if (!m_pV3->UpdateDownloadItemList(m_VersionInfo))
    {
        // there was an error parsing the catalogs and creating the download list.
        return GetLastError();
    }
    return ERROR_SUCCESS;
}

// --------------------------------------------------------------------------
//
//
//
//
//
//
// --------------------------------------------------------------------------
void CDynamicUpdate::AddDownloadItemToList(DOWNLOADITEM *pDownloadItem)
{
    LOG_block("CDynamicUpdate::AddDownloadItemToList");
    if (NULL == pDownloadItem)
    {
        return;
    }


    if (NULL == m_pDownloadItemList) // no itemss in list yet
    {
        m_pDownloadItemList = pDownloadItem;
    }
    else
    {

        // add to the end of the list
        DOWNLOADITEM *pCurrent = m_pDownloadItemList;
        while (NULL != pCurrent->pNext)
        {
            pCurrent = pCurrent->pNext;
        }

        pCurrent->pNext = pDownloadItem;
        pDownloadItem->pPrev = pCurrent;
    }

    m_dwDownloadItemCount++;
    LOG_out("Item added, %d cab(s), first cab ---\"%s\"", pDownloadItem->iNumberOfCabs, pDownloadItem->mszFileList);
}

// --------------------------------------------------------------------------
//
//
//
//
//
//
// --------------------------------------------------------------------------
void CDynamicUpdate::RemoveDownloadItemFromList(DOWNLOADITEM *pDownloadItem)
{
    if (NULL == pDownloadItem)
    {
        return;
    }

    if (NULL == m_pDownloadItemList)
    {
        return;
    }

    DOWNLOADITEM *pCurrent = m_pDownloadItemList;

    while (NULL != pCurrent)
    {
        if (pCurrent == pDownloadItem)
        {
            break;
        }

        pCurrent = pCurrent->pNext;
    }

    if ((NULL == pCurrent) || (pCurrent != pDownloadItem))
    {
        return; // unexpected
    }

    if (NULL == pCurrent->pPrev) // first item in list
    {
        if (NULL == pCurrent->pNext) // only item in list
        {
            m_pDownloadItemList = NULL;
            m_dwDownloadItemCount = 0;
        }
        else
        {
            pCurrent->pNext->pPrev = NULL; // next job becomes first
            m_pDownloadItemList = pCurrent->pNext;
            m_dwDownloadItemCount--;
        }
    }
    else
    {
        pCurrent->pPrev->pNext = pCurrent->pNext;
        if (NULL != pCurrent->pNext)
        {
            pCurrent->pNext->pPrev = pCurrent->pPrev;
        }
    }
}

void CDynamicUpdate::SetCallbackHWND(HWND hwnd)
{
    m_hwndClientNotify = hwnd;
}

void CDynamicUpdate::SetAbortDownload(BOOL fAbort)
{
    EnterCriticalSection(&m_cs);
    m_fAbortDownload = fAbort;
    LeaveCriticalSection(&m_cs);
}

void CDynamicUpdate::UpdateDownloadItemSize()
{
    m_dwTotalDownloadSize = 0;
    DOWNLOADITEM *pCurrent = m_pDownloadItemList;
    while (pCurrent)
    {
        m_dwTotalDownloadSize += pCurrent->dwTotalFileSize;
        pCurrent = pCurrent->pNext;
    }
}

void CDynamicUpdate::ClearDownloadItemList()
{
    EnterCriticalSection(&m_csDownload);
    DOWNLOADITEM *pCurrent = m_pDownloadItemList;
    DOWNLOADITEM *pNext;
    while (pCurrent)
    {
        pNext = pCurrent->pNext;
        SafeGlobalFree(pCurrent);
        pCurrent = pNext;
    }
    m_pDownloadItemList = NULL;
    m_dwDownloadItemCount = 0;
    LeaveCriticalSection(&m_csDownload);
}

void CDynamicUpdate::EnterDownloadListCriticalSection()
{
    EnterCriticalSection(&m_csDownload);
}

void CDynamicUpdate::LeaveDownloadListCriticalSection()
{
    LeaveCriticalSection(&m_csDownload);
}

void CDynamicUpdate::FixUpV3LocaleID()
{
    // Some XP Locale ID's map to a different Locale ID in V3 Terms
    // First Example was a new Spanish (Modern) Locale ID (0c0a)
    // which in V3 was (040a). For the V3 period we will fix up
    // any specific LCID's until IU handles this.

    switch (m_lcidLocaleID)
    {
    case 3082: // 0c0a = Spanish (Modern)
        {
            m_lcidLocaleID = 1034; // 040a
            break;
        }
    default:
        {
            // do nothing.
        }
    }

    return;
};

DWORD WaitAndPumpMessages(DWORD nCount, LPHANDLE pHandles, DWORD dwWakeMask)
{
    DWORD dwWaitResult;
    MSG msg;

    while (TRUE)
    {
        dwWaitResult = MsgWaitForMultipleObjects(nCount, pHandles, FALSE, 1000, dwWakeMask);
        if (dwWaitResult <= WAIT_OBJECT_0 + nCount - 1)
        {
            return dwWaitResult;
        }

        if (WAIT_OBJECT_0 + nCount == dwWaitResult)
        {
            while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }
    }
    return dwWaitResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuv3\wsdu\wulib\cdmlibp.h ===
//=======================================================================
//
//  Copyright (c) 1998-1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:   cdmlibp.h
//
//  Owner:  YanL
//
//  Description:
//
//      Private header for CDMLIB.lib
//
//=======================================================================

#ifndef _CDMLIBP_H
	
	#define REGKEY_WUV3TEST		_T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate\\wuv3test")
	bool DriverVer2FILETIME(LPCTSTR szDate, FILETIME& ftDate);// Date has to be in format mm-dd-yyyy or mm/dd/yyyy
	#define _CDMLIBP_H

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuv3\wsdu\wsdueng\v3server.cpp ===
#include "wsdueng.h"

#define IDENT_SECTION_CABPOOL "cabpools"
#define IDENT_SECTION_CONTENT31 "content31"
#define IDENT_KEYNAME_DEFAULT "default"
#define IDENT_KEYNAME_ROOT    "root"

CV31Server::CV31Server(CDynamicUpdate *pDu) : m_puidConsumerCatalog(0),
                            m_puidSetupCatalog(0),
                            m_dwPlatformID(0),
                            m_lcidLocaleID(0),
                            m_dwConsumerItemCount(0),
							m_pConsumerCatalog(NULL),
                            m_dwSetupItemCount(0),
							m_pSetupCatalog(NULL),
                            m_dwGlobalExclusionItemCount(0),
                            m_pDu(pDu)
{
	// set the initial state
	m_dwPlatformID = (DWORD)m_pDu->m_iPlatformID;
	m_lcidLocaleID = m_pDu->m_lcidLocaleID;
	
	if (0 == m_pDu->m_wPlatformSKU) // Professional
	{
		m_enumPlatformSKU = enWhistlerProfessional;
	}
	else if (m_pDu->m_wPlatformSKU & VER_SUITE_DATACENTER) // DataCenter
	{
		m_enumPlatformSKU = enWhistlerDataCenter;
	}
	else if (m_pDu->m_wPlatformSKU & VER_SUITE_PERSONAL) // Personal
	{
		m_enumPlatformSKU = enWhistlerConsumer;
	}
    else if (m_pDu->m_wPlatformSKU & VER_SUITE_ENTERPRISE) // Advanced Server
	{
		m_enumPlatformSKU = enWhistlerAdvancedServer;
	}
    // NOTE: We use VER_SUITE_SMALLBUSINESS to indicate Windows XP Server because there is good
    // VER_SUITE define for the Server SKU. We use the VER_SUITE_SMALLBUSINESS_RESTRICTED define 
    // to indicate a SBS SKU
	else if (m_pDu->m_wPlatformSKU & VER_SUITE_SMALLBUSINESS) // Server
	{
		m_enumPlatformSKU = enWhistlerServer;
	}
    else if (m_pDu->m_wPlatformSKU & VER_SUITE_BLADE)
    {
        m_enumPlatformSKU = enWhistlerWebBlade;
    }
    else if (m_pDu->m_wPlatformSKU & VER_SUITE_SMALLBUSINESS_RESTRICTED)
    {
        m_enumPlatformSKU = enWhistlerSmallBusiness;
    }

	// RogerJ October 25th, 2000
	m_pValidDependentPUIDArray = NULL;
	m_nNumOfValidDependentPUID = 0;
	m_pBitMaskAS = m_pBitMaskCDM = NULL;
	m_fHasDriver = FALSE;
	m_pszExcludedDriver = NULL;

}

CV31Server::~CV31Server()
{
	FreeCatalogs(); // clears the m_pConsumerItems and m_pSetupItems Varrays.

	SafeGlobalFree(m_pConsumerCatalog);
	SafeGlobalFree(m_pSetupCatalog);

	// RogerJ, October 25th, 2000
	SafeGlobalFree(m_pValidDependentPUIDArray);
	SafeGlobalFree(m_pBitMaskAS);
	SafeGlobalFree(m_pBitMaskCDM);
	SafeGlobalFree(m_pszExcludedDriver);
}

// ----------------------------------------------------------------------------------
// V3.1 Backend Server Apis
//
//
BOOL CV31Server::ReadIdentInfo()
{
    // ident.cab should already be downloaded at this point. Get the path to it and read the fields we care about
    char szIdent[MAX_PATH];
    char szValueName[32];
    int iServerNumber;
    char szUrl[INTERNET_MAX_URL_LENGTH + 1];
	HRESULT hr=S_OK;

    PathCombine(szIdent, m_pDu->GetDuTempPath(), "ident.txt");

    // --------------------
    // Get the CABPOOL URL
    // --------------------
    iServerNumber = GetPrivateProfileInt(IDENT_SECTION_CABPOOL, IDENT_KEYNAME_DEFAULT, 1, szIdent);
	
	hr=StringCchPrintf(szValueName,ARRAYSIZE(szValueName),"Server%d",iServerNumber);

	if(FAILED(hr))
	{
		SetLastError(HRESULT_CODE(hr));
		return FALSE;
	}

    GetPrivateProfileString(IDENT_SECTION_CABPOOL, szValueName, "", szUrl, sizeof(szUrl), szIdent);
    if ('\0' == szUrl[0])
    {
        // No Server Value was found in the ident. Cannot continue;
		SetLastError(ERROR_FILE_NOT_FOUND);
        return FALSE;
    }

	// The cabpool URL is the string in the Ident + 'cabpool'
	m_pDu->DuUrlCombine(m_szCabPoolUrl, ARRAYSIZE(m_szCabPoolUrl), szUrl, "CabPool");

    // --------------------
    // Get the CONTENT URL
    // --------------------
    iServerNumber = GetPrivateProfileInt(IDENT_SECTION_CONTENT31, IDENT_KEYNAME_DEFAULT, 1, szIdent);
    
	hr=StringCchPrintf(szValueName, ARRAYSIZE(szValueName),"Server%d", iServerNumber);

	if(FAILED(hr))
	{
		SetLastError(HRESULT_CODE(hr));
		return FALSE;
	}

    GetPrivateProfileString(IDENT_SECTION_CONTENT31, szValueName, "", szUrl, sizeof(szUrl), szIdent);
    if ('\0' == szUrl[0])
    {
        // No Server Value
		SetLastError(ERROR_FILE_NOT_FOUND);
		return FALSE;
    }

	hr=StringCchCopy(m_szV31ContentUrl,ARRAYSIZE(m_szV31ContentUrl),szUrl);

	if(FAILED(hr))
	{
		SetLastError(HRESULT_CODE(hr));
		return FALSE;
	}

    // -------------------------
    // Get the CONTENT ROOT URL
    // -------------------------
    iServerNumber = GetPrivateProfileInt(IDENT_SECTION_CONTENT31, IDENT_KEYNAME_ROOT, 2, szIdent);
    
	hr=StringCchPrintf(szValueName,ARRAYSIZE(szValueName),"Server%d", iServerNumber);

	if(FAILED(hr))
	{
		SetLastError(HRESULT_CODE(hr));
		return FALSE;
	}

    GetPrivateProfileString(IDENT_SECTION_CONTENT31, szValueName, "", szUrl, sizeof(szUrl), szIdent);
    if ('\0' == szUrl[0])
    {
        // No Root Server Value
		SetLastError(ERROR_FILE_NOT_FOUND);
		return FALSE;
    }

	
	hr=StringCchCopy(m_szV31RootUrl,ARRAYSIZE(m_szV31RootUrl),szUrl);
	if(FAILED(hr))
	{
		SetLastError(HRESULT_CODE(hr));
		return FALSE;
	}


    return TRUE;
}

BOOL CV31Server::ReadCatalogINI()
{
	LOG_block("CV31Server::ReadCatalogINI()");
    char szServerFile[INTERNET_MAX_URL_LENGTH + 1];
    char szLocalFile[MAX_PATH];
    char szValue[1024];

    // Now read the Catalog.ini file to find out if any of these items needs to be turned off
    m_pDu->DuUrlCombine(szServerFile, ARRAYSIZE(szServerFile), m_szV31ContentUrl, CATALOGINIFN);
    PathCombineA(szLocalFile, m_pDu->GetDuTempPath(), CATALOGINIFN);
    if (ERROR_SUCCESS != m_pDu->DownloadFile(szServerFile, szLocalFile, FALSE, FALSE))
    {
        LOG_out("No catalog.ini found");
        return TRUE;
    }
    

    if (0 != (GetPrivateProfileStringA("exclude", "puids", "", szValue, sizeof(szValue), szLocalFile)))
    {
        LPCSTR pszNext = szValue;
        char szPuid[128];
        while (NULL != pszNext)
        {
            pszNext = strcpystr(pszNext, ",", szPuid);
            if ('\0' != szPuid[0])
            {
                m_GlobalExclusionArray[m_dwGlobalExclusionItemCount] = StrToIntA(szPuid);
                LOG_out("Excluded puid --- %d", m_GlobalExclusionArray[m_dwGlobalExclusionItemCount]);
                m_dwGlobalExclusionItemCount++;
            }
        }
    }
    else
    	LOG_out("No Excluded puid");
    return TRUE;
}


BOOL CV31Server::GetCatalogPUIDs()
{
	LOG_block("CV31Server::GetCatalogPUIDs()");
    // There are two v3 catalogs that we will be looking for the PUID's for.. 
    // One is the Consumer Catalog for the target platform
    // The other is the Setup Catalog for the target platform
    char szServerFile[INTERNET_MAX_URL_LENGTH];
    PBYTE pCatalogList = NULL;
    PBYTE pInventoryList = NULL;
    PBYTE pWalkList = NULL;
    DWORD dwLength;
    m_puidConsumerCatalog = 0;
    m_puidSetupCatalog = 0;

    // Download the Catalog Inventory List
    m_pDu->DuUrlCombine(szServerFile, ARRAYSIZE(szServerFile), m_szV31ContentUrl, "inventory.plt");
    m_pDu->DownloadFileToMem(szServerFile, &pInventoryList, &dwLength, TRUE, "inventory.plt", NULL);

    if (NULL == pInventoryList)
    {
        // error out of memory
        return FALSE;
    }

    // Download the CatalogList
    m_pDu->DuUrlCombine(szServerFile, ARRAYSIZE(szServerFile), m_szV31ContentUrl, "inventory.cat");
    m_pDu->DownloadFileToMem(szServerFile, &pCatalogList, &dwLength, TRUE, "inventory.cat", NULL);

    if (NULL == pCatalogList)
    {
        // error out of memory
        SafeGlobalFree(pInventoryList);
        return FALSE;
    }

    // Now Parse the Inventory List to Find out how many catalogs there are.
    int i;
    WU_CATALOG_HEADER hdr;

    memcpy(&hdr, pInventoryList, sizeof(hdr));

    pWalkList = pCatalogList;
    CATALOGLIST catListElem;
    for (i = 0; i < hdr.totalItems; i++)
    {
        memcpy(&catListElem, pWalkList, sizeof(catListElem));
        
        if (catListElem.dwPlatform == m_dwPlatformID)
        {
			// standard catalog is 0, thus, standard catalog with driver will have same value as driver only
            if ((CATLIST_DRIVERSPRESENT == catListElem.dwFlags) || (catListElem.dwFlags == (CATLIST_DRIVERSPRESENT | CATLIST_64BIT)))
            {
                // consumer catalog for this platform
                m_puidConsumerCatalog = catListElem.dwCatPuid;
            }
            else if (catListElem.dwFlags & CATLIST_SETUP)
            {
                // setup catalog for this platform
                m_puidSetupCatalog = catListElem.dwCatPuid;
                if (0 == m_puidConsumerCatalog && (catListElem.dwFlags & CATLIST_DRIVERSPRESENT))
                	m_puidConsumerCatalog = catListElem.dwCatPuid;
            }
        }
        pWalkList += sizeof(catListElem);
    }
	if (!m_puidConsumerCatalog && ! m_puidSetupCatalog)
	{
		SetLastError(ERROR_INTERNET_NO_CONTEXT);
		SafeGlobalFree(pInventoryList);
		SafeGlobalFree(pCatalogList);
		return FALSE; // this technically is an error.. wrong server was pointed to? Catalogs weren't on the server
	}
	
	SafeGlobalFree(pInventoryList);
	SafeGlobalFree(pCatalogList);

	LOG_out("Consumer catalog %d, Setup catalog %d", m_puidConsumerCatalog, m_puidSetupCatalog);
    return TRUE;
}

BOOL CV31Server::GetCatalogs()
{
    // This will download the two Catalogs (Setup and Consumer) and the InventoryItem Arrays
    LOG_block("CV31Server::GetCatalogs()");
    DWORD dwRet;
    int i;
    char szServerFile[INTERNET_MAX_URL_LENGTH];
    char szLocalFile[MAX_PATH];
    char szCatalog[MAX_PATH];
    char szInvCRC[64];
    char szBmCRC[64];
    char szLocale[32];
    PBYTE pWalkCatalog = NULL;
    WU_CATALOG_HEADER hdr;
    PINVENTORY_ITEM pItem;
    BOOL fDriversAvailable = FALSE;
    DWORD dwLength;

	HRESULT hr=S_OK;

	hr=StringCchPrintf(szLocale,ARRAYSIZE(szLocale),"0x%8.8x", m_lcidLocaleID);


	if(FAILED(hr))
	{
		dwRet=HRESULT_CODE(hr);
		LOG_error("StringCchPrintf failed ErrorCode:%d",dwRet);
		SetLastError(dwRet);
        return FALSE;
	}

	FreeCatalogs(); // free any previously allocated catalog lists
	SafeGlobalFree(m_pValidDependentPUIDArray); // free any previously determined dependency list
	m_pValidDependentPUIDArray = NULL;
	m_nNumOfValidDependentPUID = 0;

    // Read the Catalog.INI to get a list of Globally Excluded Items

    if (0 != m_puidConsumerCatalog)
    {
        // Download the Consumer Catalog for this Platform
        // first we need to download the redirect file to get the CRC value of the catalog

		hr=StringCchPrintf(szCatalog,ARRAYSIZE(szCatalog),"%d/%s.as", m_puidConsumerCatalog, szLocale);

		if(FAILED(hr))
		{
			dwRet=HRESULT_CODE(hr);
			LOG_error("StringCchPrintf failed ErrorCode:%d",dwRet);
			SetLastError(dwRet);
            return FALSE;
		}

        m_pDu->DuUrlCombine(szServerFile, ARRAYSIZE(szServerFile), m_szV31ContentUrl, szCatalog);

		hr=StringCchPrintf(szCatalog,ARRAYSIZE(szCatalog),"%d_%s.as", m_puidConsumerCatalog, szLocale);

		if(FAILED(hr))
		{
			dwRet=HRESULT_CODE(hr);
			LOG_error("StringCchPrintf failed ErrorCode:%d",dwRet);
			SetLastError(dwRet);
            return FALSE;
		}

        PathCombine(szLocalFile, m_pDu->GetDuTempPath(), szCatalog);
        m_pDu->DownloadFile(szServerFile, szLocalFile, TRUE, FALSE);

        if (GetPrivateProfileString("redir", "invCRC", "", szInvCRC, sizeof(szInvCRC), szLocalFile) == 0)
        {
            LOG_error("Unable to Read Inventory CRC value from Consumer Catalog");
            return FALSE;
        }

		// does not need this for consumer catalog
        /*if (GetPrivateProfileString("redir", "bmCRC", "", szBmCRC, sizeof(szBmCRC), szLocalFile) == 0)
        {
            LOG_error("Unable to Read Bitmask CRC value for Consumer Catalog");
            return FALSE;
        }*/

		
        if (!GetBitMask("bitmask.cdm", m_puidConsumerCatalog, &m_pBitMaskCDM, "bitmask.cdm"))
        {
        	LOG_error("Unable to get bitmask for CDM");
        	return FALSE;
        }

        // now download the real catalog
		hr=StringCchPrintf(szCatalog,ARRAYSIZE(szCatalog),"%d/%s.inv",m_puidConsumerCatalog, szInvCRC);

		if(FAILED(hr))
		{
			dwRet=HRESULT_CODE(hr);
			LOG_error("StringCchPrintf failed ErrorCode:%d",dwRet);
			SetLastError(dwRet);
            return FALSE;
		}

        m_pDu->DuUrlCombine(szServerFile, ARRAYSIZE(szServerFile), m_szV31ContentUrl, szCatalog);
        SafeGlobalFree(m_pConsumerCatalog);
		hr=StringCchPrintf(szCatalog,ARRAYSIZE(szCatalog),"%s.inv", szInvCRC);

		if(FAILED(hr))
		{
			dwRet=HRESULT_CODE(hr);
			LOG_error("StringCchPrintf failed ErrorCode:%d",dwRet);
			SetLastError(dwRet);
            return FALSE;
		}


        m_pDu->DownloadFileToMem(szServerFile, &m_pConsumerCatalog, &dwLength, TRUE, szCatalog, "inventory.as");
        if (NULL == m_pConsumerCatalog)
        {
            LOG_error("Failed to download Consumer Catalog, %d", m_puidConsumerCatalog);
            return FALSE;
        }

        pWalkCatalog = m_pConsumerCatalog;

        // Read the Catalog Header
        ZeroMemory(&hdr, sizeof(hdr));
        memcpy(&hdr, pWalkCatalog, sizeof(hdr));

        m_pConsumerItems[hdr.totalItems] = NULL; // just to preinitialize the array.

        pWalkCatalog += sizeof(hdr);

        // walk the list and read the items.
        for (i = 0; i < hdr.totalItems; i++)
        {
            pItem = (PINVENTORY_ITEM) GlobalAlloc(GMEM_ZEROINIT, sizeof(INVENTORY_ITEM));
            if (NULL == pItem)
            {
                dwRet = GetLastError();
                LOG_error("Failed to Alloc Memory for Inventory Item, Error %d", dwRet);
                return FALSE;
            }

            pWalkCatalog = GetNextRecord(pWalkCatalog, i, pItem);
            if (!pWalkCatalog)
           	{
           	    LOG_error("Failed to Alloc Memory for InventoryI Item State, Error %d", GetLastError());
           	    return FALSE;
           	}

            m_pConsumerItems[i] = pItem;
            if ( WU_TYPE_CDM_RECORD_PLACE_HOLDER == pItem->recordType) m_fHasDriver = TRUE;
            m_dwConsumerItemCount++;
        }
    }

    if (0 != m_puidSetupCatalog)
    {
        // Download the Setup Catalog for this Platform
        // first we need to download the redirect file to get the CRC value of the catalog
		hr=StringCchPrintf(szCatalog,ARRAYSIZE(szCatalog),"%d/%s.as", m_puidSetupCatalog, szLocale);
		if(FAILED(hr))
		{
			dwRet=HRESULT_CODE(hr);
			LOG_error("StringCchPrintf failed ErrorCode:%d",dwRet);
			SetLastError(dwRet);
            return FALSE;
		}

        m_pDu->DuUrlCombine(szServerFile, ARRAYSIZE(szServerFile), m_szV31ContentUrl, szCatalog);
		hr=StringCchPrintf(szCatalog,ARRAYSIZE(szCatalog),"%d_%s.as", m_puidSetupCatalog, szLocale);
		if(FAILED(hr))
		{
			dwRet=HRESULT_CODE(hr);
			LOG_error("StringCchPrintf failed ErrorCode:%d",dwRet);
			SetLastError(dwRet);
            return FALSE;
		}


        PathCombine(szLocalFile, m_pDu->GetDuTempPath(), szCatalog);
        dwRet = m_pDu->DownloadFile(szServerFile, szLocalFile, TRUE, FALSE);

        if (ERROR_SUCCESS != dwRet)
        {
        	SetLastError(dwRet);
        	return FALSE;
        }
        
        if (GetPrivateProfileString("redir", "invCRC", "", szInvCRC, sizeof(szInvCRC), szLocalFile) == 0)
        {
            LOG_error("Unable to Read Inventory CRC value from Setup Catalog");
            return FALSE;
        }

        if (GetPrivateProfileString("redir", "bmCRC", "", szBmCRC, sizeof(szBmCRC), szLocalFile) == 0)
        {
            LOG_error("Unable to Read Bitmask CRC value for Setup Catalog");
            return FALSE;
        }

		char szBMCRCFileName[MAX_PATH];
		StringCchPrintf(szBMCRCFileName,ARRAYSIZE(szBMCRCFileName),"%s.bm", szBmCRC);
		if(FAILED(hr))
		{
			dwRet=HRESULT_CODE(hr);
			LOG_error("StringCchPrintf failed ErrorCode:%d",dwRet);
			SetLastError(dwRet);
            return FALSE;
		}
		if (!GetBitMask(szBMCRCFileName, m_puidSetupCatalog, &m_pBitMaskAS, "bitmask.as")) 
		{
			LOG_error("Unable to Read Bitmask File for AS");
			return FALSE;
		}
		
        // now download the real catalog

		hr=StringCchPrintf(szCatalog,ARRAYSIZE(szCatalog),"%d/%s.inv", m_puidSetupCatalog, szInvCRC);
		if(FAILED(hr))
		{
			dwRet=HRESULT_CODE(hr);
			LOG_error("StringCchPrintf failed ErrorCode:%d",dwRet);
			SetLastError(dwRet);
            return FALSE;
		}


        m_pDu->DuUrlCombine(szServerFile, ARRAYSIZE(szServerFile), m_szV31ContentUrl, szCatalog);
        SafeGlobalFree(m_pSetupCatalog);

		hr=StringCchPrintf(szCatalog,ARRAYSIZE(szCatalog),"%s.inv", szInvCRC);

		if(FAILED(hr))
		{
			dwRet=HRESULT_CODE(hr);
			LOG_error("StringCchPrintf failed ErrorCode:%d",dwRet);
			SetLastError(dwRet);
            return FALSE;
		}

        m_pDu->DownloadFileToMem(szServerFile, &m_pSetupCatalog, &dwLength, TRUE, szCatalog, "inventory.as");
        if (NULL == m_pSetupCatalog)
        {
            LOG_error("Failed to download Consumer Catalog, %d", m_puidSetupCatalog);
            return FALSE;
        }

        pWalkCatalog = m_pSetupCatalog;

        // Read the Catalog Header
        ZeroMemory(&hdr, sizeof(hdr));
        memcpy(&hdr, pWalkCatalog, sizeof(hdr));

		m_pSetupItems[hdr.totalItems] = NULL; // just to preinitialize the array.

        pWalkCatalog += sizeof(hdr);

        // walk the list and read the items.
        for (i = 0; i < hdr.totalItems; i++)
        {
            pItem = (PINVENTORY_ITEM) GlobalAlloc(GMEM_ZEROINIT, sizeof(INVENTORY_ITEM));
            if (NULL == pItem)
            {
                dwRet = GetLastError();
                LOG_error("Failed to Alloc Memory for Inventory Item, Error %d", dwRet);
                return FALSE;
            }

            pWalkCatalog = GetNextRecord(pWalkCatalog, i, pItem);
            if (!pWalkCatalog)
           	{
           	    LOG_error("Failed to Alloc Memory for InventoryI Item State, Error %d", GetLastError());
           	    return FALSE;
           	}

			if (!pItem->ps->bHidden && !GETBIT(m_pBitMaskAS, i))
			{
				// this item is masked out
				LOG_out("Item %d is masked out", i);
				pItem->ps->bHidden = TRUE;
				pItem->ps->state = WU_ITEM_STATE_PRUNED;
				pItem->ps->dwReason = WU_STATE_REASON_BITMASK;
			}
            m_pSetupItems[i] = pItem;
            m_dwSetupItemCount++;
        }
    }


    return TRUE;
}

PBYTE CV31Server::GetNextRecord(PBYTE pRecord, int iBitmaskIndex, PINVENTORY_ITEM pItem)
{
  	//first get the fixed length part of the record
	pItem->pf = (PWU_INV_FIXED)pRecord;

	//process the variable part of the record

	pRecord = pRecord + sizeof(WU_INV_FIXED);

	pItem->pv = (PWU_VARIABLE_FIELD)pRecord;

	//since there is no state information create an empty structure
	pItem->ps = (PWU_INV_STATE)GlobalAlloc(GMEM_ZEROINIT, sizeof(WU_INV_STATE));

	if (!pItem->ps) return NULL;		

	//new item is unknown detection, not selected and shown to user.
	pItem->ps->state	= WU_ITEM_STATE_UNKNOWN;
	pItem->ps->bChecked	= FALSE;
	// RogerJ, to support versioning, we will use the bHidden flag
	pItem->ps->bHidden	= pItem->pf->a.flags & WU_HIDDEN_ITEM_FLAG;
	if (pItem->ps->bHidden) m_nNumOfValidDependentPUID++;
	
	pItem->ps->dwReason	= WU_STATE_REASON_NONE;

	//There is no description yet
	pItem->pd			= (PWU_DESCRIPTION)NULL;

	//we need to store the bitmap index (which is the sequential record index)
	//since this information will be lost when we add the driver records.
	// YanL: is not being used
	//	pItem->bitmaskIndex = iBitmaskIndex;

	//Get record type
	pItem->recordType = (BYTE)GetRecordType(pItem);
	pItem->ndxLinkInstall = (PUID) pItem->pf->a.installLink;
	
	//set record pointer to the beginning of the next record

	pRecord += pItem->pv->GetSize();

	return pRecord;
}

int CV31Server::GetRecordType(PINVENTORY_ITEM pItem)
{
	GUID	driverRecordId = WU_GUID_DRIVER_RECORD;
	int		iRecordType = 0;

	if ( memcmp((void *)&pItem->pf->d.g, (void *)&driverRecordId, sizeof(WU_GUID_DRIVER_RECORD)) )
	{
		//if the GUID field is not 0 then we have an active setup record.

		iRecordType = WU_TYPE_ACTIVE_SETUP_RECORD;//active setup record type
	}
	else
	{
		//else this is either a driver record place holder or a section - sub section
		//record. So we need to check the type field

		if ( pItem->pf->d.type == SECTION_RECORD_TYPE_DEVICE_DRIVER_INSERTION )
		{
			//cdm driver place holder record
			iRecordType = WU_TYPE_CDM_RECORD_PLACE_HOLDER;	//cdm code download manager place holder record
		}
		else if ( pItem->pf->d.type == SECTION_RECORD_TYPE_PRINTER )
		{
			//Note: We may need to use this to support printers on win 98.

			iRecordType = WU_TYPE_RECORD_TYPE_PRINTER;	//printer record
		}
		else if ( pItem->pf->d.type == SECTION_RECORD_TYPE_DRIVER_RECORD )
		{
			iRecordType = WU_TYPE_CDM_RECORD;	//Corporate catalog device driver
		}
		else if ( pItem->pf->s.type == SECTION_RECORD_TYPE_CATALOG_RECORD )
		{
			iRecordType = WU_TYPE_CATALOG_RECORD;
		}
		else
		{
			//we have either a section, sub section or sub sub section record

			switch ( pItem->pf->s.level )
			{
				case 0:
					iRecordType = WU_TYPE_SECTION_RECORD;
					break;
				case 1:
					iRecordType = WU_TYPE_SUBSECTION_RECORD;
					break;
				case 2:
					iRecordType = WU_TYPE_SUBSUBSECTION_RECORD;
					break;
			}
		}
	}

	return iRecordType;
}


// --------------------------------------------------------------------------
//  CV31Server::UpdateDownloadItemList()
//  
//  Parses the Catalogs and gets a list of Items in the Correct Platform SKU 
//    section to download.
//
//
// --------------------------------------------------------------------------
BOOL CV31Server::UpdateDownloadItemList(OSVERSIONINFOEX& VersionInfo)
{
    LOG_block("CV31Server::UpdateDownloadItemList()");
    ULONG ulItem = 0;
    int iRecordType = 0;
    BOOL fFound = FALSE, fRet;
    char szServerFile[INTERNET_MAX_URL_LENGTH + 1];
    char szMapFileName[MAX_PATH];
    char szLocale[32];
    DWORD dwLength;
    PBYTE pMapMem = NULL;
    PWU_VARIABLE_FIELD pvCabs;
    PWU_VARIABLE_FIELD pvCRCs;
    int iCabNum = 0;
    BOOL fRetValue = TRUE;
    
    HRESULT hr=S_OK;
	DWORD cchLength=0;
	DWORD cchRemLenght=0;
	DWORD dwError=0;

	
	hr=StringCchPrintf(szLocale,ARRAYSIZE(szLocale),"0x%8.8x", m_lcidLocaleID);
	if(FAILED(hr))
	{
		dwError=HRESULT_CODE(hr);
		LOG_error("StringCchPrintf failed errorCode:%d",dwError);
		SetLastError(dwError);
		return FALSE;
	}

	hr=StringCchPrintf(szMapFileName,ARRAYSIZE(szMapFileName),"%d_%s.des", m_dwPlatformID, szLocale);

	if(FAILED(hr))
	{
		dwError=HRESULT_CODE(hr);
		LOG_error("StringCchPrintf failed ErrorCode:%d",dwError);
		SetLastError(dwError);
		return FALSE;
	}




    m_pDu->DuUrlCombine(szServerFile, ARRAYSIZE(szServerFile), m_szV31ContentUrl, szMapFileName);
    m_pDu->DownloadFileToMem(szServerFile, &pMapMem, &dwLength, TRUE, szMapFileName, NULL);

    if (NULL == pMapMem)
    {
        LOG_error("Failed to Download CRC Map File %s", szServerFile);
        return FALSE;
    }

    CCRCMapFile DescMap(pMapMem, dwLength);

    // Before we add any items to the download list we need to clear the download list
	// from any previous calls to DoDetection.

	m_pDu->EnterDownloadListCriticalSection(); // if we're downloading we don't want to allow the download list to change
	m_pDu->ClearDownloadItemList();

	
    if (0 != m_dwSetupItemCount)
    {
		// We have a valid Setup Catalog, find the Correct Section based on SKU

		// ROGERJ, october 24, 2000
 		// we need to make a list of valid dependency item first
		if (!MakeDependentList(VersionInfo, &DescMap))
		{
			// last error will be set by MakeDependentList() function
			fRetValue = FALSE;
			goto ReturnPoint;
		}
       
        // We want to walk the Catalog Looking for the Section PUID that matches our requested Platform SKU
        for (ulItem = 0; ulItem < m_dwSetupItemCount; ulItem++)
        {
            if (WU_TYPE_SECTION_RECORD == m_pSetupItems[ulItem]->recordType)
            {
                if (m_pSetupItems[ulItem]->pf->s.puid == m_enumPlatformSKU)
                {
                    // found the correct section
                    fFound = TRUE;
                    break;
                }
            }
        }

        if (fFound)
        {
            ulItem++; // advance to the next item
            // until we find the next section, or the end of the catalog
			while ((ulItem < m_dwSetupItemCount) && (WU_TYPE_SECTION_RECORD != GetRecordType(m_pSetupItems[ulItem])))
            {
                PINVENTORY_ITEM pItem = m_pSetupItems[ulItem];

				// ROGERJ, October 24th, 2000 --- determine if the item is applied to this version
				// skip hidden item
				if (pItem->ps->bHidden) 
				{
					ulItem++;
					continue;
				}
                // determine if this item valid on this build
                if ( 0 != pItem->pf->a.installLink && // has dependency
                	!IsDependencyApply(pItem->pf->a.installLink)) // dependency not apply to this version
                	{
                		// if the dependency item is not valid in this version, skip
                		ulItem++;
                		continue;
                	}
                	
                char szServerCab[128];
                char szLocalCab[128];
                // The next section record marks the end of the items valid for this SKU
                fRet = ReadDescription(pItem, &DescMap);
                if (!fRet)
                {
                    // failed to read description file for this item, skip it.
                    ulItem++;
                    continue;
                }

                pvCabs = pItem->pd->pv->Find(WU_DESCRIPTION_CABFILENAME);
                pvCRCs = pItem->pd->pv->Find(WU_DESC_CRC_ARRAY);

                if ((NULL == pvCabs) || (NULL == pvCRCs))
                {
                    // no cab list or CRC list in the description file
                    ulItem++;
                    continue;
                }

                DOWNLOADITEM *pDownloadItem = (DOWNLOADITEM *)GlobalAlloc(GMEM_ZEROINIT, sizeof(DOWNLOADITEM));
                if (NULL == pDownloadItem)
                {
                    LOG_error("Error Allocating Memory for new Download Item");
					fRetValue = FALSE;
					goto ReturnPoint;
                }
                pDownloadItem->dwTotalFileSize = pItem->pd->size * 1024; // Estimated Size in Bytes
                pDownloadItem->puid = pItem->pf->a.puid;

                LPSTR pszCabName = pDownloadItem->mszFileList;

				cchLength=ARRAYSIZE(pDownloadItem->mszFileList);
				cchRemLenght=cchLength;
				iCabNum = 0;

                for (;;)
                {
                    if (FAILED(GetCRCNameFromList(iCabNum, pvCabs->pData, pvCRCs->pData, szServerCab, sizeof(szServerCab), szLocalCab)))
                    {
                        break; // no more cabs
                    }

                    pDownloadItem->iNumberOfCabs++;

					StringCchCopy(pszCabName,cchRemLenght,szServerCab);

					pszCabName += lstrlen(pszCabName) + 1;
                    *pszCabName = '\0'; // double null terminate
                    pszCabName++; // next cab

					//This check is for ensuring that the buffer ponited by 
					//pDownloadItem->mszFileList is not overrun
					cchRemLenght=cchLength- (DWORD)(pszCabName - pDownloadItem->mszFileList);

                    iCabNum++;
                }

				// don't add the item unless there are cabs for it.
				if (pDownloadItem->iNumberOfCabs > 0 && !IsPUIDExcluded(pItem->pf->a.puid))
                    // before adding this item to the list, check to see if it should be excluded based
                    // on the Catalog.INI
                    m_pDu->AddDownloadItemToList(pDownloadItem);

				
				SafeGlobalFree(pItem->pd);
				ulItem++;
            }
        }
    }
    
ReturnPoint:
	m_pDu->LeaveDownloadListCriticalSection();
	SafeGlobalFree(pMapMem);
    return fRetValue;
}

BOOL CV31Server::ReadDescription(PINVENTORY_ITEM pItem, CCRCMapFile *pMapFile)
{
    if ((NULL == pItem) || (NULL == pMapFile))
    {
        return FALSE;
    }

    LOG_block("CV31Server::ReadDescription()");

    char szServerFile[INTERNET_MAX_URL_LENGTH + 1];
    char szDownloadFile[MAX_PATH];
    PWU_DESCRIPTION pd;
    DWORD dwLength;
    char szBase[64];
    char szCRCName[64];
    HRESULT hr = S_OK;
    DWORD dwError=0;

	hr=StringCchPrintf(szBase,ARRAYSIZE(szBase),"%d.des",pItem->GetPuid());

	if (FAILED(hr))
    {
		dwError=HRESULT_CODE(hr);
        LOG_error("StringCchPrintf failed ErrorCode:%d",dwError);
		SetLastError(dwError);
        return FALSE;
    }

    hr = pMapFile->GetCRCName((DWORD)pItem->GetPuid(), szBase, szCRCName, sizeof(szCRCName));
    if (FAILED(hr))
    {
        LOG_error("Failed to get CRC Description Value for Item %d", pItem->GetPuid());
        return FALSE;
    }

	hr=StringCchPrintf(szDownloadFile,ARRAYSIZE(szDownloadFile), "CRCDesc/%s", szCRCName);

	if (FAILED(hr))
    {
        dwError=HRESULT_CODE(hr);
        LOG_error("StringCchPrintf failed ErrorCode:%d",dwError);
		SetLastError(dwError);
        return FALSE;
    }
 
    m_pDu->DuUrlCombine(szServerFile, ARRAYSIZE(szServerFile), m_szV31RootUrl, szDownloadFile);
    m_pDu->DownloadFileToMem(szServerFile, (PBYTE *)&pd, &dwLength, TRUE, szCRCName, "desc.as");

    if (NULL == pd)
    {
        LOG_error("Failed to download Description File %s", szServerFile);
        return FALSE;
    }

    // for 64 bit, the description is off by size of DWORD
    //if (19 == m_pDu->m_iPlatformID)
     	// 64 bit
    //	pd->pv = (PWU_VARIABLE_FIELD)(((PBYTE)pd) + sizeof(WU_DESCRIPTION) + sizeof(DWORD));
   	//else
   		// 32 bit
   		pd->pv = (PWU_VARIABLE_FIELD)(((PBYTE)pd) + sizeof(WU_DESCRIPTION));
    pItem->pd = pd;
    
    return TRUE;
}

void CV31Server::FreeCatalogs()
{
	for (DWORD dwcnt = 0; dwcnt < m_dwSetupItemCount; dwcnt++)
	{
		if (m_pSetupItems[dwcnt])
		{
			SafeGlobalFree(m_pSetupItems[dwcnt]->ps);
			SafeGlobalFree(m_pSetupItems[dwcnt]->pd);
			SafeGlobalFree(m_pSetupItems[dwcnt]);
		}
	}

	for (dwcnt = 0; dwcnt < m_dwConsumerItemCount; dwcnt++)
	{
		if (m_pConsumerItems[dwcnt])
		{
			SafeGlobalFree(m_pConsumerItems[dwcnt]->ps);
			SafeGlobalFree(m_pConsumerItems[dwcnt]->pd);
			SafeGlobalFree(m_pConsumerItems[dwcnt]);
		}
	}

	m_dwSetupItemCount = 0;
	m_dwConsumerItemCount = 0;
}

BOOL CV31Server::MakeDependentList(OSVERSIONINFOEX &VersionInfo, CCRCMapFile *pMapFile)
{
	// Log
	LOG_block("CV31Server::MakeDependentList()");

	// make sure the array is empty
	SafeGlobalFree(m_pValidDependentPUIDArray);
	// no dependency item
	if (!m_nNumOfValidDependentPUID) return TRUE;

	int nPUIDIndex = 0;
	// allocate the memory
	m_pValidDependentPUIDArray = (PUID*) GlobalAlloc(GMEM_ZEROINIT, sizeof(PUID)*m_nNumOfValidDependentPUID);
	if (!m_pValidDependentPUIDArray)
	{
		LOG_error("Out of memory");
		SetLastError(ERROR_NOT_ENOUGH_MEMORY);
		return FALSE;
	}
	
	ULONG ulItem;
    for (ulItem = 0; ulItem < m_dwSetupItemCount && nPUIDIndex < m_nNumOfValidDependentPUID; ulItem++)
    {
    	if (WU_TYPE_ACTIVE_SETUP_RECORD	!=  GetRecordType(m_pSetupItems[ulItem]) ||
    		!m_pSetupItems[ulItem]->ps->bHidden || m_pSetupItems[ulItem]->ps->state == WU_ITEM_STATE_PRUNED) 
    		continue;
    	PINVENTORY_ITEM pItem = m_pSetupItems[ulItem];
    	// get a hidden setup dependency item record
    	BOOL fRet = ReadDescription(pItem, pMapFile);
        if (!fRet)
        	// failed to read description file for this item, assume this dependency does not apply
        	// this way, we will not download any item not apply, but may miss some items that apply
            continue;
        
       
        // Title is composed as BuildMin.BuildMax.SPMajor.SPMinor
        PWU_VARIABLE_FIELD pvField = pItem->pd->pv->Find(WU_DESCRIPTION_TITLE); 
        if (!pvField)
       	{
       		// title is NULL, error, ignore this item
       		LOG_error("Title is NULL");
       		continue;
       	}
        wchar_t * pvTitle = (wchar_t*) pvField->pData;
        
        DWORD dwBuild[4];
        dwBuild[0]=0;
        dwBuild[1]=99999;
        dwBuild[2]=0;
        dwBuild[3]=0;
        
        int nBuildIndex = 0;
        int nTemp = 0;
        BOOL fBreak = FALSE;
        
        while (nBuildIndex<4 && !fBreak)
        {
        	
        	if (*pvTitle != L'.' && *pvTitle != NULL ) 
        	{
   		       	if (*pvTitle > L'9' || *pvTitle < '0')
        		{
        			// illegal use of this title
    	    		LOG_error("Illegal character '%c' found in the title",(char)*pvTitle);
        			SetLastError(ERROR_INVALID_DATA);
        			return FALSE;
        		}
        		else 
        		{
        			nTemp *=10;
        			nTemp += (*pvTitle - L'0');
        		}
        	}
        	else
        	{
        		if (!*pvTitle) fBreak = TRUE;
        		dwBuild[nBuildIndex++] = nTemp;
        		nTemp = 0;
        	}
        	pvTitle++;
        }

        LOG_out("Title is %d.%d.%d.%d\n", dwBuild[0], dwBuild[1], dwBuild[2], dwBuild[3]);
        
        // determine if this item apply
        if (dwBuild[0] <= VersionInfo.dwBuildNumber &&
        	dwBuild[1] >= VersionInfo.dwBuildNumber &&
        	dwBuild[2] == VersionInfo.wServicePackMajor&&
        	dwBuild[3] == VersionInfo.wServicePackMinor)
        {
        	// applys, add this to the list
        	LOG_out("This dependency item applied");
        	m_pValidDependentPUIDArray[nPUIDIndex++] = pItem->GetPuid();
        }
        else
        	LOG_out("This dependency item NOT applied");
    }
    return TRUE;
}


BOOL CV31Server::IsDependencyApply(PUID puid)
{
	LOG_block("CV31Server::IsDependencyApply()");
	LOG_out("puid(%d)", (long)puid);
	
	// handle no link
	if (WU_NO_LINK == puid) return TRUE;
	// no depend item is valid 
	if (!m_nNumOfValidDependentPUID) 
	{
		LOG_out("No dependecy item");
		return FALSE;
	}
	for (int nItem = 0; nItem < m_nNumOfValidDependentPUID; nItem ++)
	{
		if (m_pValidDependentPUIDArray[nItem] == puid) 
		{
			LOG_out ("puid(%d) applies", (long)puid);
			return TRUE;
		}
		if (m_pValidDependentPUIDArray[nItem] == 0) break; // 0 mark the end of valid puid
	}
	LOG_out("puid(%d) does not apply", (long)puid);
	return FALSE;
}

BOOL CV31Server::GetBitMask(LPSTR szBitmapLocalFileName, PUID nDirectoryPuid, PBYTE* pByte, LPSTR szDecompressedName)
{
	LOG_block("CV31Server::GetBitMask()");
	LOG_out("Parameters --- %s",szBitmapLocalFileName);
	SetLastError(0);
	
	// Parameter validation
	if (!szBitmapLocalFileName) 
	{
		LOG_error("Invalid Parameter");
		SetLastError(ERROR_INVALID_PARAMETER);
		return FALSE;
	}

	SafeGlobalFree(*pByte);

	PBITMASK pBitMask = NULL;
	DWORD dwLength = 0;
	DWORD dwError = 0;
	BOOL fRetVal = FALSE;
	HRESULT hr=S_OK;
	// log parameter
	LOG_out("szBitmapLocalFileName(%s)",szBitmapLocalFileName);

	char szBitmapServerFileName[INTERNET_MAX_URL_LENGTH];
	ZeroMemory(szBitmapServerFileName, INTERNET_MAX_URL_LENGTH*sizeof(char));

	char szBitmapFileWithDir[MAX_PATH];
	
	hr=StringCchPrintf(szBitmapFileWithDir,ARRAYSIZE(szBitmapFileWithDir), "%d/%s", nDirectoryPuid, szBitmapLocalFileName);
	if (FAILED(hr))
    {
        dwError=HRESULT_CODE(hr);
        LOG_error("StringCchPrintf failed ErrorCode:%d",dwError);
		SetLastError(dwError);
        return FALSE;
    }


	m_pDu->DuUrlCombine(szBitmapServerFileName, ARRAYSIZE(szBitmapServerFileName), m_szV31ContentUrl, szBitmapFileWithDir);

	dwError = m_pDu->DownloadFileToMem(szBitmapServerFileName, 
						(PBYTE*)&pBitMask, &dwLength, TRUE, szBitmapLocalFileName, szDecompressedName);
						
	if (ERROR_SUCCESS != dwError)
	{
		LOG_error("Failed to download %s --- %d", szBitmapServerFileName, dwError);
		return FALSE;
	}

	int iMaskByteSize = ((pBitMask->iRecordSize+7)/8);
	int nIndex = 0;
	
	for (int nItem =0; nItem < pBitMask->iLocaleCount; nItem ++)
	{
		nIndex = pBitMask->iOemCount + nItem;
		if (pBitMask->bmID[nIndex] == m_pDu->m_lcidLocaleID) break;
	}

	if (nItem >= pBitMask->iLocaleCount)
	{
		// not found
		// bad locale ? or missing locale info?
		LOG_error("LCID %d is not found in %s", m_pDu->m_lcidLocaleID, szBitmapLocalFileName);
		SetLastError(ERROR_UNSUPPORTED_TYPE);
		goto ErrorReturn;
	}

	*pByte =(PBYTE) GlobalAlloc(GMEM_ZEROINIT, iMaskByteSize);
	if (!pByte)
	{
		LOG_error("Out of memory");
		SetLastError(ERROR_NOT_ENOUGH_MEMORY);
		goto ErrorReturn;
	}

	CopyMemory((PVOID)*pByte, (const PVOID) pBitMask->GetBitMaskPtr(nIndex+2), iMaskByteSize);

	fRetVal = TRUE;

    // jthaler - 3/21/02 - deleted commented out code that "can be used to print of bitmask.as"
		
ErrorReturn:
	SafeGlobalFree(pBitMask);
	return fRetVal;	
}


BOOL CV31Server::ReadGuidrvINF()
{
	LOG_block("CV31Server::ReadGuidrvINF()");
    char szServerFile[INTERNET_MAX_URL_LENGTH + 1];
    char szLocalFile[MAX_PATH];
    char szValue[1024];
    int nDefaultBufferLength = 512;

    SafeGlobalFree(m_pszExcludedDriver);
    
    // Now read the Catalog.ini file to find out if any of these items needs to be turned off
    m_pDu->DuUrlCombine(szServerFile, ARRAYSIZE(szServerFile), m_szV31ContentUrl, GUIDRVINF);
    PathCombineA(szLocalFile, m_pDu->GetDuDownloadPath(), GUIDRVINF);
    if (ERROR_SUCCESS!=m_pDu->DownloadFile(szServerFile, szLocalFile, FALSE, FALSE))
    {
        LOG_out("No guidrv.inf found");
        return TRUE;
    }
    int nReadLength;
    do
    {
        nDefaultBufferLength <<=1;
        SafeGlobalFree(m_pszExcludedDriver);
        m_pszExcludedDriver = (LPSTR) GlobalAlloc(GPTR, nDefaultBufferLength * sizeof(char));
        if (!m_pszExcludedDriver)
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            LOG_error("Out of memory");
            return FALSE;
        }
        nReadLength = GetPrivateProfileSectionA("ExcludedDrivers", m_pszExcludedDriver, nDefaultBufferLength, szLocalFile);
    } while ( nDefaultBufferLength-2 == nReadLength);

    if (!lstrlenA(m_pszExcludedDriver))
    {
        SafeGlobalFree(m_pszExcludedDriver);
        m_pszExcludedDriver = NULL;
    }  
    return TRUE;
}


BOOL CV31Server::IsPUIDExcluded(PUID nPuid)
{
    if (m_dwGlobalExclusionItemCount > 0)
    {
        for (DWORD dwCnt = 0; dwCnt < m_dwGlobalExclusionItemCount; dwCnt++)
        {
            if (nPuid == m_GlobalExclusionArray[dwCnt])
                return TRUE;
        }
    }
    return FALSE;
}

BOOL CV31Server::IsDriverExcluded(LPCSTR szWHQLId, LPCSTR szHardwareId)
{
    LOG_block("CV31Server::IsDriverExcluded()");
    LOG_out("%s %s", szWHQLId, szHardwareId);
    if(m_pszExcludedDriver)
    {
        char* pTemp = m_pszExcludedDriver;
        while (*pTemp)
        {
            // try to find if the driver is excluded
            char* pCharEnd = pTemp;
            char* pCharBegin = pTemp;
            // first one is the id for the cab
            while (*pCharEnd != ',' && *pCharEnd != '\0') pCharEnd++;
            if (NULL == *pCharEnd)
            {
                LOG_error("guidrvs.inf corruption --- %s", pTemp);
                return TRUE; // guidrvs.inf corrupted, assume excluded
            }
            if (lstrlenA(szWHQLId) == (int)(pCharEnd - pCharBegin)
               && !StrCmpNI(szWHQLId, pCharBegin, (int)(pCharEnd-pCharBegin)))
            {
                // cab name matches, try to match hardware id
                // ignore second and third one
                for (int i=0; i<2; i++)
                {
                    pCharBegin = pCharEnd + 1;
                    pCharEnd = pCharBegin;
                    while (*pCharEnd != ',' && *pCharEnd != '\0') pCharEnd++;
                    if (NULL == *pCharEnd)
                    {
                        LOG_error("guidrvs.inf corruption --- %s", pTemp);
                        return TRUE; // guidrv.inf corrupted, assume excluded
                    }
                }
                // the forth one should be the hardware id
                pCharBegin = pCharEnd + 1;
                if (!lstrcmpi(szHardwareId, pCharBegin) || ('*' == *pCharBegin && !*(pCharBegin+1)))
                {
                    LOG_out("Found match in guidrvs.inf, excluded --- %s", pTemp);
                    return TRUE;
                }
            }
            // move to next string
            pTemp += lstrlenA(pTemp) + 1;
        }
    }
    return FALSE;
}

BOOL CV31Server::GetAltName(LPCSTR szCabName, LPSTR szAltName, int nSize)
{
    if (!szCabName || !szAltName) return FALSE;

    char* pTemp = const_cast<char*>(szCabName);
    while (*pTemp && *pTemp != '_') pTemp++;
    int nTempSize = (int)(pTemp-szCabName);
    if (nTempSize >= nSize) return FALSE;
    lstrcpynA(szAltName, szCabName, nTempSize+1);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuv3\wsdu\wulib\newtrust.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1998,1999,2000 Microsoft Corporation.  All Rights Reserved.
//
//  SYSTEM:     Windows Update Critical Fix Notification
//
//  CLASS:      N/A
//  MODULE:     MS Cab Trusting Function Implementation
//  FILE:       Newtrust.CPP
//
/////////////////////////////////////////////////////////////////////
//
//  DESC:   this file implements the functions used by class CTrust
//          these function are copied from inseng.dll of IE5 Active Setup.
//          
//
//  AUTHOR: Alessandro Muti, Windows Update Team
//  DATE:   3/11/1999
//
/////////////////////////////////////////////////////////////////////
//
//  Revision History:
//
//  Date        Author          Description
//  ~~~~        ~~~~~~          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//  10/17/2000  Nick Dallett    Porting Charlma's new cert-checking code from SLM tree:
// (8/28/00	    Charles Ma		Rewrite CheckMSCert() function to handle certs with MS root and special cases )
//
/////////////////////////////////////////////////////////////////////
//
//      (c) Copyrights:   1998, 1999, 2000 Microsoft Corporation 
//
//      All rights reserved.
//
//      No portion of this source code may be reproduced
//      without express written permission of Microsoft Corporation.
//
//      This source code is proprietary and confidential.
/////////////////////////////////////////////////////////////////////

#include <windows.h>
#include <urlmon.h>
#include <wintrust.h>
#include <wincrypt.h>
#include <softpub.h>
//#include <atlconv.h>
#include <tchar.h>

#include "cdmlibp.h"
#include "newtrust.h"

#define LOGGING_LEVEL 3
#include <log.h>

//*********************************************************************************//
// Global UNICODE<>ANSI translation helpers
//*********************************************************************************//

#include <malloc.h>	// for _alloca


#define USES_CONVERSION int _convert = 0; _convert; UINT _acp = CP_ACP; _acp; LPCWSTR _lpw = NULL; _lpw; LPCSTR _lpa = NULL; _lpa

inline LPWSTR WINAPI AtlA2WHelper(LPWSTR lpw, LPCSTR lpa, int nChars, UINT acp)
{
	//
	// verify that no illegal character present
	// since lpw was allocated based on the size of lpa
	// don't worry about the number of chars
	//
	lpw[0] = '\0';
	MultiByteToWideChar(acp, 0, lpa, -1, lpw, nChars);
	return lpw;
}

inline LPSTR WINAPI AtlW2AHelper(LPSTR lpa, LPCWSTR lpw, int nChars, UINT acp)
{
	//
	// verify that no illegal character present
	// since lpa was allocated based on the size of lpw
	// don't worry about the number of chars
	//
	lpa[0] = '\0';
	WideCharToMultiByte(acp, 0, lpw, -1, lpa, nChars, NULL, NULL);
	return lpa;
}

#define A2W(lpa) (\
		((_lpa = lpa) == NULL) ? NULL : (\
			_convert = (lstrlenA(_lpa)+1),\
			AtlA2WHelper((LPWSTR)_alloca(_convert*2), _lpa, _convert, CP_ACP)))

#define W2A(lpw) (\
		((_lpw = lpw) == NULL) ? NULL : (\
			_convert = (lstrlenW(_lpw)+1)*2,\
			AtlW2AHelper((LPSTR)_alloca(_convert), _lpw, _convert, CP_ACP)))
#define A2CW(lpa) ((LPCWSTR)A2W(lpa))
#define W2CA(lpw) ((LPCSTR)W2A(lpw))
#ifdef _UNICODE
	#define T2A W2A
	#define A2T A2W
	inline LPWSTR T2W(LPTSTR lp) { return lp; }
	inline LPTSTR W2T(LPWSTR lp) { return lp; }
	#define T2CA W2CA
	#define A2CT A2CW
	inline LPCWSTR T2CW(LPCTSTR lp) { return lp; }
	inline LPCTSTR W2CT(LPCWSTR lp) { return lp; }
#else
	#define T2W A2W
	#define W2T W2A
	inline LPSTR T2A(LPTSTR lp) { return lp; }
	inline LPTSTR A2T(LPSTR lp) { return lp; }
	#define T2CW A2CW
	#define W2CT W2CA
	inline LPCSTR T2CA(LPCTSTR lp) { return lp; }
	inline LPCTSTR A2CT(LPCSTR lp) { return lp; }
#endif
#define OLE2T(p) W2T(p)
#define T2OLE(p) T2W(p)

/////////////////////////////////////////////////////////////////////////////
// 
// typedefs for APIs used in the CheckTrust() function
//
//      Since some of these APIs are new and only available on IE5 we have to
//      try to dynamicaly use them when available and do without the extra checks
//      when we are on an OS that has not been upgraded to the new crypto code.
//
/////////////////////////////////////////////////////////////////////////////


const TCHAR WINTRUST[] =  _T("wintrust.dll");

const TCHAR CRYPT32[] =  _T("crypt32.dll");

//
// declare a global crypt32.dll library handler, so we don't
// need to load the library every time these functions are called.
// NOTE: we do not release the library though. When the process of
// calling this feature exits, the library is released.
// same as wintrust.dll
//
static HINSTANCE shWinTrustDllInst = NULL;
static HINSTANCE shCrypt32DllInst = NULL;


//
// define prototype for function WinVerifyTrust()
// and declare a global variable to point to this function
//
typedef HRESULT 
(WINAPI * PFNWinVerifyTrust)(
                        HWND hwnd, GUID *ActionID, LPVOID ActionData);
PFNWinVerifyTrust pfnWinVerifyTrust = NULL; 


//
// define prototype for function WTHelperProvDataFromStateData()
// and declare a global variable to point to this function
//
typedef CRYPT_PROVIDER_DATA * 
(WINAPI * PFNWTHelperProvDataFromStateData)(
						HANDLE hStateData);
PFNWTHelperProvDataFromStateData pfnWTHelperProvDataFromStateData = NULL;


//
// define prototype for function WTHelperGetProvSignerFromChain()
// and declare a global variable to point to this function
//
typedef CRYPT_PROVIDER_SGNR * 
(WINAPI * PFNWTHelperGetProvSignerFromChain)(
						CRYPT_PROVIDER_DATA *pProvData,
						DWORD idxSigner,
						BOOL fCounterSigner,
						DWORD idxCounterSigner);
PFNWTHelperGetProvSignerFromChain pfnWTHelperGetProvSignerFromChain = NULL;


//
// define prototype for function PFNWTHelperGetProvCertFromChain()
// and declare a global variable to point to this function
//
typedef CRYPT_PROVIDER_CERT * 
(WINAPI * PFNWTHelperGetProvCertFromChain)(
						CRYPT_PROVIDER_SGNR *pSgnr,
						DWORD idxCert);
PFNWTHelperGetProvCertFromChain pfnWTHelperGetProvCertFromChain = NULL;


//
// define prototype for function CryptHashPublicKeyInfo()
// and declare a global variable to point to this function
//
typedef BOOL 
(WINAPI * PFNCryptHashPublicKeyInfo)(
						HCRYPTPROV hCryptProv,
						ALG_ID Algid,
						DWORD dwFlags,
						DWORD dwCertEncodingType,
						PCERT_PUBLIC_KEY_INFO pInfo,
						BYTE *pbComputedHash,
						DWORD *pcbComputedHash);
PFNCryptHashPublicKeyInfo pfnCryptHashPublicKeyInfo = NULL;


//
// define prototype for function CertGetCertificateContextProperty()
// and declare a global variable to point to this function
//
typedef BOOL 
(WINAPI * PFNCertGetCertificateContextProperty)(
						PCCERT_CONTEXT pCertContext,          
						DWORD dwPropId,                       
						void *pvData,                         
						DWORD *pcbData);
PFNCertGetCertificateContextProperty pfnCertGetCertificateContextProperty = NULL;



/////////////////////////////////////////////////////////////////////////////
// 
// pre-defined cert data to check against
//
/////////////////////////////////////////////////////////////////////////////

//
// The following is the sha1 key identifier for the Microsoft root
//
static BYTE rgbSignerRootKeyId[20] = {
    0x4A, 0x5C, 0x75, 0x22, 0xAA, 0x46, 0xBF, 0xA4, 0x08, 0x9D,
    0x39, 0x97, 0x4E, 0xBD, 0xB4, 0xA3, 0x60, 0xF7, 0xA0, 0x1D
};


//
// define the size of each hash values in the known id buffer
// for special certs.
//
//static size_t rgbSpecialCertIdSize[5] = {20, 20, 20, 20, 20};

//
// this is the size of buffer to receive the cert hash value
// it must be not less than the largest number in the
// above-defined array
//
const size_t ShaBufSize = 20;

//
// id buffer to store hash values of all special certs
// Warning: the size of this buffer should match the sum 
// of size_t values defined above.
//
static BYTE rgbSpecialCertId[200] = {
	0xB1,0x59,0xA5,0x2E,0x3D,0xD8,0xCE,0xCD,0x3A,0x9A,0x4A,0x7A,0x73,0x92,0xAA,0x8D,0xA7,0xE7,0xD6,0x7F,	// MS cert
	0xB1,0xC7,0x75,0xE0,0x4A,0x9D,0xFD,0x23,0xB6,0x18,0x97,0x11,0x5E,0xF6,0xEA,0x6B,0x99,0xEC,0x76,0x1D,	// MSN cert
	0x11,0xC7,0x10,0xF3,0xCB,0x6C,0x43,0xE1,0x66,0xEC,0x64,0x1C,0x7C,0x01,0x17,0xC4,0xB4,0x10,0x35,0x30,	// MSNBC cert
	0x95,0x25,0x58,0xD4,0x07,0xDE,0x4A,0xFD,0xAE,0xBA,0x13,0x72,0x83,0xC2,0xB3,0x37,0x04,0x90,0xC9,0x8A,	// MSN Europe
	0x72,0x54,0x14,0x91,0x1D,0x6E,0x10,0x84,0x8E,0x0F,0xFA,0xA0,0xB0,0xA1,0x65,0xBF,0x44,0x8F,0x9F,0x6D,	// MS Europe
	0x20,0x5E,0x48,0x43,0xAB,0xAD,0x54,0x77,0x71,0xBD,0x8D,0x1A,0x3C,0xE0,0xE5,0x9D,0xF5,0xBD,0x25,0xF9,	// Old MS cert: 97~98
	0xD6,0xCD,0x01,0x90,0xB3,0x1B,0x31,0x85,0x81,0x12,0x23,0x14,0xB5,0x17,0xA0,0xAA,0xCE,0xF2,0x7B,0xD5,	// Old MS cert: 98~99
	0x8A,0xA1,0x37,0xF5,0x03,0x9F,0xE0,0x28,0xC9,0x26,0xAA,0x55,0x90,0x14,0x19,0x68,0xFA,0xFF,0xE8,0x1A,	// Old MS cert: 99~00
	0xF3,0x25,0xF8,0x67,0x07,0x29,0xE5,0x27,0xF3,0x77,0x52,0x34,0xE0,0x51,0x57,0x69,0x0F,0x40,0xC6,0x1C,	// Old MS Europe cert: 99~00
    0x6A,0x71,0xFE,0x54,0x8A,0x51,0x08,0x70,0xF9,0x8A,0x56,0xCA,0x11,0x55,0xF6,0x76,0x45,0x92,0x02,0x5A     // Old MS Europe cert: 98~99
    
};



/////////////////////////////////////////////////////////////////////////////
// 
// Private Function ULONG CompareMem(PVOID pBlock1, PVOID pBlock2, ULONG Length)
//
//      This function acts in the same way as RtlCompareMemory() 
//
//
// Input:   two pointers to two memory blocks, and a byte size to compare
// Return:  the number of bytes that compared as equal. 
//			If all bytes compare as equal, the input Length is returned.
//			If any pointer is NULL, 0 is returned.
//
/////////////////////////////////////////////////////////////////////////////
ULONG CompareMem(const BYTE* pBlock1, const BYTE* pBlock2, ULONG Length)
{
	ULONG uLen = 0L;
	if (pBlock1 != NULL && pBlock2 != NULL)
	{
		for (; uLen < Length; uLen++, pBlock1++, pBlock2++)
		{
			if (*pBlock1 != *pBlock2) return uLen;
		}
	}
	return uLen;
}






/////////////////////////////////////////////////////////////////////////////
// 
// Private Function VerifyMSRoot()
//
//      This function takes the passed-in certificate as a root cert,
//		and verifies its public key hash value is the same as 
//		known "Microsoft Root Authority" cert value.
//
//
// Input:   hCrypt32DllInst - handle point to loaded crypt32.dll library
//			pRootCert - the certificate context of the root cert
//
// Return:  HRESULT - result of execution, S_OK if matched.
//			the result code, in case of error, are code retuned by
//			crypt32.dll, with these the exception of E_INVALIDARG if
//			the passed-in parameters are NULL.
//
/////////////////////////////////////////////////////////////////////////////

HRESULT VerifyMSRoot(
					 HINSTANCE hCrypt32DllInst,			// handle point to loaded crypt32.dll librar
					 PCCERT_CONTEXT pRootCert
					 )
{
	HRESULT hr = S_OK;
	BYTE	rgbKeyId[sizeof(rgbSignerRootKeyId)];
    DWORD	cbKeyId = sizeof(rgbSignerRootKeyId);

	LOG_block("VerifyMSRoot()");

	//
	// valid parameter values
	//
	if (NULL == hCrypt32DllInst || NULL == pRootCert)
	{
		hr = E_INVALIDARG;
		goto ErrHandler;
	}

	//
	// get the function we need from the passed in library handle
	// If not available, return error
	//
	if (NULL == (pfnCryptHashPublicKeyInfo = (PFNCryptHashPublicKeyInfo)
		GetProcAddress(hCrypt32DllInst, "CryptHashPublicKeyInfo")))
	{
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_FUNCTION);
		goto ErrHandler;
	}

	//
	// get the public key hash value of this cert
	//
	ZeroMemory(rgbKeyId, sizeof(rgbKeyId));
    if (!pfnCryptHashPublicKeyInfo(
							0,						// use default crypto svc provider
							CALG_SHA1,				// use SHA algorithm
							0,						// dwFlags
							X509_ASN_ENCODING,
							&pRootCert->pCertInfo->SubjectPublicKeyInfo,
							rgbKeyId,
							&cbKeyId
							))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto ErrHandler;
	}

	//
	// compare the hash value of public key of this root cert with the known MS root cert value
	//
	if (sizeof(rgbSignerRootKeyId) != cbKeyId || cbKeyId != CompareMem(rgbSignerRootKeyId, rgbKeyId, cbKeyId))
	{
		hr = S_FALSE;
	}


ErrHandler:

	if (FAILED(hr))
	{
		LOG_out("Faied inside function VerifyMSRoot() with HRESULT 0x%0x", hr);
	}
	else
	{
		LOG_out("Exit VerifyMSRoot() with %s", (S_OK == hr) ? "S_OK" : "S_FALSE");
	}

	return hr;
}





/////////////////////////////////////////////////////////////////////////////
// 
// Private Function VerifySpecialMSCerts()
//
//      This function takes the passed-in certificate as a leaf cert,
//		and verifies its hash value matches the hash value of one of
//		known Microsoft special certs that does not have MS root.
//
//		The known certs are, in comparing order:
//			Microsoft Corporation
//			Microsoft Corporation MSN
//			MSNBC Interactive News LLC
//			Microsoft Corporation MSN (Europe)
//			Microsoft Corporation (Europe)
//
//
// Input:   hCrypt32DllInst - handle point to loaded crypt32.dll library
//			pRootCert - the certificate context of the root cert
//
// Return:  HRESULT - result of execution, S_OK if matched.
//			if not matched, CERT_E_UNTRUSTEDROOT, or
//			E_INVALIDARG if arguments not right, or
//			crypt32.dll error returned by API calls
//
/////////////////////////////////////////////////////////////////////////////
HRESULT VerifySpecialMSCerts(					 
							 HINSTANCE hCrypt32DllInst,			// handle point to loaded crypt32.dll librar
							 PCCERT_CONTEXT pLeafCert
							 )
{
	HRESULT hr = S_FALSE;
	BYTE	btShaBuffer[ShaBufSize];
	DWORD	dwSize = sizeof(btShaBuffer);
	LPBYTE	pId;
	int		i;

	LOG_block("VerifySpecialMSCerts()");

	//
	// valid parameter values
	//
	if (NULL == hCrypt32DllInst || NULL == pLeafCert)
	{
		hr = E_INVALIDARG;
		goto ErrHandler;
	}

	//
	// get the function we need from the passed in library handle
	// If not available, return error
	//
	if (NULL == (pfnCertGetCertificateContextProperty = (PFNCertGetCertificateContextProperty)
		GetProcAddress(hCrypt32DllInst, "CertGetCertificateContextProperty")))
	{
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_FUNCTION);
		goto ErrHandler;
	}
	
	//
	// find out the id hash of leaf cert
	//
	ZeroMemory(btShaBuffer, dwSize);
	if (!pfnCertGetCertificateContextProperty(
						pLeafCert,					// pCertContext
						CERT_SHA1_HASH_PROP_ID,	// dwPropId
						btShaBuffer,
						&dwSize
						))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto ErrHandler;
	}

	//
	// iterrate through all known id hash values to see if this file is signed
	// with any of these special certs.
	//
	if (ShaBufSize == dwSize)
	{
		for (i = 0,pId = rgbSpecialCertId; i < sizeof(rgbSpecialCertId)/ShaBufSize; i++, pId += ShaBufSize)
		{
			if (CompareMem(btShaBuffer, pId, ShaBufSize) == ShaBufSize)
			{
				//
				// found a matching known cert!
				//
				hr = S_OK;
				break;
			}
		}
	}

ErrHandler:

	if (FAILED(hr))
	{
		LOG_out("Faied inside function VerifySpecialMSCerts() with HRESULT 0x%0x", hr);
	}
	else
	{
		LOG_out("Exit VerifySpecialMSCerts() with %s", (S_OK == hr) ? "S_OK" : "S_FALSE");
	}

	return hr;


}

/////////////////////////////////////////////////////////////////////////////
// 
// Private Function CheckWinTrust()
//
//      This function will return the HRESULT for the trust state on the
//      specified file. The file can be pointing to any URL or local file.
//      The verification will be done by the wintrust.dll. 
//
//
// Input:   Fully qualified filename, UIChoice
// Return:  HRESULT - result of execution
//
/////////////////////////////////////////////////////////////////////////////

HRESULT CheckWinTrust(LPCTSTR pszFileName, DWORD dwUIChoice)
{

	LOG_block("CheckWinTrust()");

    USES_CONVERSION;

    // Now verify the file
    WINTRUST_DATA               winData;
    WINTRUST_FILE_INFO          winFile;
    GUID                        gAction = WINTRUST_ACTION_GENERIC_VERIFY_V2; 
    CRYPT_PROVIDER_DATA const   *pProvData = NULL;
    CRYPT_PROVIDER_SGNR         *pProvSigner = NULL;
    CRYPT_PROVIDER_CERT	        *pProvCert = NULL;
    HRESULT                     hr = S_OK;


#ifdef _WUV3TEST
	//
	// handling test case:
	// if a reg key value is set to 1, then we will see if we need to pop up ALL certs
	//
	// NOTE:
	//
	// for the certs that user has checked "Always trust this provider..." previously, 
	// WinCheckTrust() API will still NOT show any UI even if we signal Show-ALL flag
	//
	HKEY	hkey;
	DWORD	dwWinTrustUI = 0;
	DWORD	dwSize = sizeof(dwWinTrustUI);
	if (NO_ERROR == RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGKEY_WUV3TEST, 0, KEY_READ, &hkey)) 
	{
		RegQueryValueEx(hkey, _T("WinTrustUI"), 0, 0, (LPBYTE)&dwWinTrustUI, &dwSize);
		RegCloseKey(hkey);
	}
	if (1 == dwWinTrustUI && WTD_UI_NONE != dwUIChoice)
	{
		//
		// if there is a WinTrustUI reg key exist, and value is 1
		// and caller does not request silence, then we
		// pop up all certs
		//
		dwUIChoice = WTD_UI_ALL;
	}
#endif


	//
	// dynamically load the wintrust.dll
	//
	if (NULL == shWinTrustDllInst)
	{
		if (NULL == (shWinTrustDllInst = LoadLibrary(WINTRUST)))
		{
			LOG_error("Failed to load libary %s, exit function.", WINTRUST);
			return HRESULT_FROM_WIN32(GetLastError());
		}
	}

	//
	// dynamically load the crypt32.dll, which will be used by the two
	// helper functions to verify the cert is MS cert
	//
	if (NULL == shCrypt32DllInst)
	{
		if (NULL == (shCrypt32DllInst = LoadLibrary(CRYPT32)))
		{
			LOG_error("Failed to load libary %s, exit function.", CRYPT32);
			return HRESULT_FROM_WIN32(GetLastError());
		}
	}
	//
	// find the functions we need
	//
	if (NULL == (pfnWinVerifyTrust = (PFNWinVerifyTrust)
				GetProcAddress(shWinTrustDllInst, "WinVerifyTrust")) ||
		NULL == (pfnWTHelperProvDataFromStateData = (PFNWTHelperProvDataFromStateData)
				GetProcAddress(shWinTrustDllInst, "WTHelperProvDataFromStateData")) ||
		NULL == (pfnWTHelperGetProvSignerFromChain = (PFNWTHelperGetProvSignerFromChain) 
				GetProcAddress(shWinTrustDllInst, "WTHelperGetProvSignerFromChain")) ||
		NULL == (pfnWTHelperGetProvCertFromChain = (PFNWTHelperGetProvCertFromChain)
				GetProcAddress(shWinTrustDllInst, "WTHelperGetProvCertFromChain")))
	{
		//
		// at least one function was not found in the loaded cryp32.dll libary.
		// we can not continue, jsut quit. 
		// NOTE: this shouldn't happen since we have tried to get 
		// the least common denomination of different version of this dll
		// on both IE4 and IE5
		//
		LOG_error("CheckWinTrust() did not find functions needed from %s", CRYPT32);
		return HRESULT_FROM_WIN32(ERROR_INVALID_FUNCTION);
	}


	//
	// initialize the data structure used to verify trust
	//
    winFile.cbStruct       = sizeof(WINTRUST_FILE_INFO);
    winFile.hFile          = INVALID_HANDLE_VALUE;
    winFile.pcwszFilePath  = T2OLE((LPTSTR)pszFileName);
    winFile.pgKnownSubject = NULL;

    winData.cbStruct            = sizeof(WINTRUST_DATA);
    winData.pPolicyCallbackData = NULL;
    winData.pSIPClientData      = NULL;
    winData.dwUIChoice          = (WTD_UI_ALL == dwUIChoice) ? dwUIChoice : WTD_UI_NONE;
    winData.fdwRevocationChecks = 0;
    winData.dwUnionChoice       = WTD_CHOICE_FILE;
    winData.dwStateAction       = WTD_STATEACTION_VERIFY;
    winData.hWVTStateData       = 0;
    winData.dwProvFlags         = 0x00000010;
    winData.pFile               = &winFile;

	//
	// verify the signature
	//
    hr = pfnWinVerifyTrust( (HWND)0, &gAction, &winData);

    if (FAILED(hr))
    {
        //
        // The object isn't even trusted so just get out here
        //
		LOG_error("WinVerifyTrust(%s) found error 0x%0x.", pszFileName, hr);
        goto Return;
    }


	//
	// the real usage should never pass in WTD_UI_ALL. If this is the case, 
	// then we are calling this recursively in order to force the show
	// a good but non-MS cert only, so no need to check MS cert again.
	//
	// or, in test mode, we always do this part
	//
	if (WTD_UI_ALL != dwUIChoice)
	{
		//
		// the rset of code is used to verify the signed cert is
		// a valid MS cert.
		//
		pProvData = pfnWTHelperProvDataFromStateData(winData.hWVTStateData);
    
		pProvSigner = pfnWTHelperGetProvSignerFromChain(
										(PCRYPT_PROVIDER_DATA) pProvData, 
										0,      // first signer
										FALSE,  // not a counter signer
										0);

		//
		// check root cert then check leaf (signing) cert if that fails
		//
		// 0 is signing cert, csCertChain-1 is root cert
		//
		pProvCert =  pfnWTHelperGetProvCertFromChain(pProvSigner, pProvSigner->csCertChain - 1);

		hr = VerifyMSRoot(shCrypt32DllInst, pProvCert->pCert);

		if (S_OK != hr)
		{
			pProvCert =  pfnWTHelperGetProvCertFromChain(pProvSigner, 0);

			hr = VerifySpecialMSCerts(shCrypt32DllInst, pProvCert->pCert);
		}


	}

Return:

    //
    // free the wintrust state that was used to get the cert in the chain
    //
    winData.dwStateAction = WTD_STATEACTION_CLOSE;
    pfnWinVerifyTrust( (HWND)0, &gAction, &winData);

//#ifndef _WUV3TEST
	//
	// recursively call this function if not in test mode so we can show
	// UI for this non-MS but good cert.
	// Only the two functions checking MS cert will return S_FALSE
	//
	if (S_OK != hr)
	{
		if (WTD_UI_NOGOOD == dwUIChoice)
		{
			//
			// we need to show UI, so we will have to call this thing again
			// in case this is not a MS cert. From UI, if user clicks YES
			// then the return value will be S_OK;
			//
			hr = CheckWinTrust(pszFileName, WTD_UI_ALL);
			LOG_error("CheckWinTrust() found file not signed by a known MS cert. If user has not checked \"Always trust this\", UI should be shown, and user selected %s", 
				SUCCEEDED(hr) ? "YES" : "NO");
		}
		else
		{
			LOG_error("CheckWinTrust() found file not signed by a known MS cert!");
			hr = TRUST_E_SUBJECT_NOT_TRUSTED;
		}
	}
//#endif

	if (WTD_UI_ALL != dwUIChoice)
	{
		if (FAILED(hr))
		{
			LOG_error("CheckWinTrust(%s) returns 0x%0x", T2CA(pszFileName), hr);
		}
		else
		{
			LOG_out("CheckWinTrust(%s) returns S_OK", T2CA(pszFileName));
		}
	}
    return (hr); 

}    

/////////////////////////////////////////////////////////////////////////////
// 
// Public Function VerifyFile()
//
// This is a wrapper function for CheckWinTrust that both Whistler 
// and WU classic code should use.
//
// Input:	szFileName - the file with complete path
//			fShowBadUI - whether pop up UI in cases 
//						 (1) inproperly signed signature, 
//						 (2) properly signed but not Microsoft signature
//
// Return:	HRESULT - S_OK the file is signed with a valid MS cert
//					  or error code.
//
// Note:	If _WUV3TEST flag is set (for test build), then fShowBadUI is
//			ignored:
//				if reg key SOFTWARE\Microsoft\Windows\CurrentVersion\WindowsUpdate\wuv3test\WinTrustUI
//				is set to 1, then no UI is shown, and this function always return S_OK;
//				otherwise, UI always show no matter what cert, and return value is same
//				as the live build.
//
/////////////////////////////////////////////////////////////////////////////
HRESULT VerifyFile(
				   IN LPCTSTR szFileName,
				   BOOL fShowBadUI /* = TRUE */
				   )
{
	DWORD dwUIChoice = WTD_UI_NOGOOD;

	if (!fShowBadUI)
	{
		dwUIChoice = WTD_UI_NONE;
	}

	return CheckWinTrust(szFileName, dwUIChoice);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuv3\wsdu\wsdueng\wsdueng.h ===
#define ARRAYSIZE(x) (sizeof(x)/sizeof(x[0]))

#include <windows.h>
#include <setupapi.h>
#include <shlwapi.h>
#include <devguid.h>
#include <regstr.h>
#include <stdio.h>
#include <lmcons.h>
#include <wininet.h>
#include <fdi.h>

#include <wuv3.h>
#include <varray.h>
#include <v3stdlib.h>
#include <filecrc.h>
#include <newtrust.h>

#include "log.h"
#include "v3server.h"
#include "dynamic.h"
#include "MultiSZArray.h"


#include <strsafe.h>

#define DU_STATUS_SUCCESS       1
#define DU_STATUS_ABORT         2
#define DU_STATUS_FAILED        3

#define WM_DYNAMIC_UPDATE_COMPLETE WM_APP + 1000 + 1000
// (WPARAM) Completion Status (SUCCESS, ABORTED, FAILED) : (LPARAM) (DWORD) Error Code if Status Failed
#define WM_DYNAMIC_UPDATE_PROGRESS WM_APP + 1000 + 1001
// (WPARAM) (DWORD) TotalDownloadSize : (LPARAM) (DWORD) BytesDownloaded 

#define DU_CONNECTION_RETRY 2

// REMOVE THIS when checked into Whistler Tree .. Personal Should be Defined.
#ifndef VER_SUITE_PERSONAL
#define VER_SUITE_PERSONAL 0x00000200
#endif


// RogerJ --- the next part of this header file contains information for avoid autodisconnection
//
#define WM_DIALMON_FIRST        WM_USER+100
#define WM_WINSOCK_ACTIVITY     WM_DIALMON_FIRST + 0

static const char c_szDialmonClass[] = "MS_WebcheckMonitor";
// DONE

// size of the CRC hash in bytes
const int CRC_HASH_SIZE = 20;
const int CRC_HASH_STRING_LENGTH = CRC_HASH_SIZE * 2 + 1; // Double the CRC HASH SIZE (2 characters for each byte), + 1 for the NULL

#define DU_PINGBACK_DOWNLOADSTATUS          0
#define DU_PINGBACK_DRIVERNOTFOUND          1
#define DU_PINGBACK_SETUPDETECTIONFAILED    2
#define DU_PINGBACK_DRIVERDETECTIONFAILED   3

#define sizeOfArray(a)  (sizeof(a) / sizeof(a[0]))
#define SafeGlobalFree(x)       if (NULL != x) { GlobalFree(x); x = NULL; }
#define SafeInternetCloseHandle(x) if (NULL != x) { InternetCloseHandle(x); x = NULL; }
#define SafeCloseHandle(x) if (INVALID_HANDLE_VALUE != x) { CloseHandle(x); x = INVALID_HANDLE_VALUE; }

void WINAPI SetEstimatedDownloadSpeed(DWORD dwBytesPerSecond);
HANDLE WINAPI DuInitializeA(IN LPCSTR pszBasePath, IN LPCSTR pszTempPath, IN POSVERSIONINFOEXA posviTargetOS, 
                            IN LPCSTR pszTargetArch, IN LCID lcidTargetLocale, IN BOOL fUnattend, IN BOOL fUpgrade, 
                            IN PWINNT32QUERY pfnWinnt32QueryCallback);
BOOL WINAPI DuDoDetection(IN HANDLE hConnection, OUT PDWORD pdwEstimatedTime, OUT PDWORD pdwEstimatedSize);
BOOL WINAPI DuBeginDownload(IN HANDLE hConnection, IN HWND hwndNotify);
void WINAPI DuAbortDownload(IN HANDLE hConnection);
void WINAPI DuUninitialize(IN HANDLE hConnection);

// fdi.cpp
BOOL fdi(char *cabinet_fullpath, char *directory);

typedef struct DOWNLOADITEM
{
    char mszFileList[2048]; // MultiSZ list of Cabs to Download
    DWORD dwTotalFileSize;
    DWORD dwBytesDownload;
    int iCurrentCab;
    int iNumberOfCabs;
    BOOL fComplete;
    PUID puid;

    DOWNLOADITEM *pNext;
    DOWNLOADITEM *pPrev;
} DOWNLOADITEM;

typedef struct DOWNLOADTHREADPROCINFO
{
    char szLocalFile[MAX_PATH];
    BOOL fCheckTrust;
    BOOL fDecompress;
    HWND hwndNotify;
    HINTERNET hInternet;
} DOWNLOADTHREADPROCINFO, *PDOWNLOADTHREADPROCINFO;

class CDynamicUpdate
{
public:
    CDynamicUpdate(int iPlatformID, LCID lcidLocaleID, WORD wPlatformSKU, LPCSTR pszTempPath, 
                   LPCSTR pszDownloadPath, PWINNT32QUERY pfnWinnt32QueryCallback, POSVERSIONINFOEXA pVersionInfo);
    ~CDynamicUpdate();

public:
    DWORD DoSetupUpdateDetection(void);

public:
    // Class Member Access Functions
    LPCSTR GetDuTempPath();
    LPCSTR GetDuDownloadPath();
    LPCSTR GetDuServerUrl();
    int GetTargetPlatformID();
    LCID GetTargetLocaleID();
    void SetCallbackHWND(HWND hwnd);
    void SetAbortDownload(BOOL fAbort);

    // Helper Functions
    LPSTR DuUrlCombine(LPSTR pszDest, size_t cchDest, LPCSTR pszBase, LPCSTR pszAdd);

    // Download Funcntions
    DWORD DownloadFilesAsync();
    DWORD DownloadFile(LPCSTR pszDownloadUrl, LPCSTR pszLocalFile, BOOL fDecompress, BOOL fCheckTrust);
    DWORD DownloadFileToMem(LPCSTR pszDownloadUrl, PBYTE *lpBuffer, DWORD *pdwAllocatedLength, BOOL fDecompress, LPSTR pszFileName, LPSTR pszDecompresedFileName);
    DWORD AsyncDownloadProc();
    DWORD PingBack(int iPingBackType, PUID puid, LPCSTR pszPnPID, BOOL fSucceeded);
 
    // Download Item Management Functions
    void AddDownloadItemToList(DOWNLOADITEM *pDownloadItem);
    void RemoveDownloadItemFromList(DOWNLOADITEM *pDownloadItem);
    void ClearDownloadItemList();
    void UpdateDownloadItemSize();
    void EnterDownloadListCriticalSection();
    void LeaveDownloadListCriticalSection();
    BOOL NeedRetry(DWORD dwErrCode);

    // Language Fix Up Helpers (BUG: 435184) Need to map Some Languages from XP LCID's to V3 LCID's.
    void FixUpV3LocaleID();

    HRESULT VerifyFileCRC(LPCTSTR pszFileToVerify, LPCTSTR pszHash);
    HRESULT CalculateFileCRC(LPCTSTR pszFileToHash, LPTSTR pszHash, int cchBuf);
    
    // Download Helper Functions
    DWORD OpenHttpConnection(LPCSTR pszDownloadUrl, BOOL fGetRequest);
    BOOL IsServerFileNewer(FILETIME ft, DWORD dwServerFileSize, LPCSTR pszLocalFile);

public:
    CV31Server *m_pV3;

    int m_iPlatformID;
    LCID m_lcidLocaleID;
    WORD m_wPlatformSKU;
    char m_szTempPath[MAX_PATH];
    char m_szDownloadPath[MAX_PATH];
    char m_szServerUrl[INTERNET_MAX_URL_LENGTH + 1];
    
    // This is the core list of files that we will download. It contains all the setup
    // update items, and all the drivers that are going to be downloaded.
    DOWNLOADITEM *m_pDownloadItemList;
    DWORD m_dwCurrentBytesDownloaded;
    DWORD m_dwDownloadItemCount;
    DWORD m_dwTotalDownloadSize;
    DWORD m_dwDownloadSpeedInBytesPerSecond;
    BOOL  m_fUseSSL;

    HWND m_hwndClientNotify;
    DWORD m_dwLastPercentComplete;
    BOOL m_fAbortDownload;
    CRITICAL_SECTION m_cs;
    CRITICAL_SECTION m_csDownload;
    OSVERSIONINFOEX m_VersionInfo;

    // Download Connection Handles
    HINTERNET m_hInternet;
    HINTERNET m_hConnect;
    HINTERNET m_hOpenRequest;

    char m_szCurrentConnectedServer[INTERNET_MAX_URL_LENGTH];
    int m_iCurrentConncectionScheme;

    // RogerJ October 5th, 2000
    // call back function pointer
    PWINNT32QUERY m_pfnWinNT32Query;
    HANDLE m_hDownloadThreadProc;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuv3\wsdu\wulib\string.cpp ===
//=======================================================================
//
//  Copyright (c) 1998-1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:    string.cpp
//
//  Purpose:
//
//=======================================================================

#include <windows.h>
#include <v3stdlib.h>

const char* strcpystr(const char* pszStr, const char* pszSep, char* pszTokOut)
{
	
	if (pszStr == NULL || *pszStr == '\0')
	{
		pszTokOut[0] = '\0';
		return NULL;
	}

	const char* p = strstr(pszStr, pszSep);
	if (p != NULL)
	{
		strncpy(pszTokOut, pszStr, p - pszStr);
		pszTokOut[p - pszStr] = '\0';		
		return p + strlen(pszSep);
	}
	else
	{
		strcpy(pszTokOut, pszStr);
		return NULL;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuv3\wsdu\wulib\wutestkeys.cpp ===
//***********************************************************************************
//
//  Copyright (c) 2002 Microsoft Corporation.  All Rights Reserved.
//
//  File:	WUTESTKEYS.CPP
//  Module: WUTESTKEYS.LIB
//
//***********************************************************************************
#include <shlobj.h>
#include <advpub.h>
#include <WUTestKeys.h>
#include <newtrust.h>
#include <atlconv.h>
#include <v3stdlib.h>

#define HOUR (60 * 60)
#define DAY (24 * HOUR)
#define TWO_WEEKS (14 * DAY)

const DWORD MAX_FILE_SIZE = 200;    //Maximum expected file size in bytes
const TCHAR WU_DIR[] = _T("\\WindowsUpdate\\");
const CHAR WU_SENTINEL_STRING[] = "Windows Update Test Key Authorization File\r\n";

#define ARRAYSIZE(a)  (sizeof(a) / sizeof(a[0]))

//function to check if the specified file is a valid WU test file
BOOL IsValidWUTestFile(LPCTSTR lpszFilePath);

BOOL FileExists(LPCTSTR lpsFile	);
BOOL ReplaceFileExtension(LPCTSTR pszPath, LPCTSTR pszNewExt, LPTSTR pszNewPathBuf, DWORD cchNewPathBuf);

// This function returns true if the specified file is a valid WU Test Authorization file
BOOL WUAllowTestKeys(LPCTSTR lpszFileName)
{
    TCHAR szWUDirPath[MAX_PATH + 1];
    TCHAR szFilePath[MAX_PATH + 1];
    TCHAR szTxtFilePath[MAX_PATH+1];
    TCHAR szTextFile[MAX_PATH+1];          

    if (!GetWindowsUpdateDirectory(szWUDirPath, ARRAYSIZE(szWUDirPath)))
    {
        return FALSE;
    } 
    if (NULL == lpszFileName || 
        FAILED(StringCchCopyEx(szFilePath, ARRAYSIZE(szFilePath), szWUDirPath, NULL, NULL, MISTSAFE_STRING_FLAGS)) ||
        FAILED(StringCchCatEx(szFilePath, ARRAYSIZE(szFilePath), lpszFileName, NULL, NULL, MISTSAFE_STRING_FLAGS)) ||
        !FileExists(szFilePath))
    {
        return FALSE;
    }
    //The filename of the compressed text file should be the same as the name of the cab file
    _tsplitpath(lpszFileName, NULL, NULL, szTextFile, NULL);    
    if(FAILED(StringCchCatEx(szTextFile, ARRAYSIZE(szTextFile), _T(".txt"), NULL, NULL, MISTSAFE_STRING_FLAGS)))
    {
        return FALSE;
    }
    //Verify the cab is signed with a Microsoft Cert and extract the file 
    if (FAILED(VerifyFile(szFilePath, FALSE)) ||
        FAILED(ExtractFiles(szFilePath, szWUDirPath, 0,  szTextFile, 0, 0)))
    {
        return FALSE;
    }
    //Generate path to the txt file. The filename should be the same as the name of the cab file
    if (!ReplaceFileExtension(szFilePath, _T(".txt"), szTxtFilePath, ARRAYSIZE(szTxtFilePath)))
    {
    	return FALSE;
    }
    //Check if it is a valid WU test file
    BOOL fRet = IsValidWUTestFile(szTxtFilePath);
    DeleteFile(szTxtFilePath);       //Delete the uncabbed file
    return fRet;
}

/*****************************************************************************************
//This function will open the specified file and parse it to make sure:
//  (1) The file has the WU Test Sentinel string at the top
//  (2) The time stamp on the file is not more than 2 weeks old and 
//      that it is not a future time stamp.
//   The format of a valid file should be as follows:
//      WINDOWSUPDATE_SENTINEL_STRING
//      YYYY.MM.DD HH:MM:SS
*****************************************************************************************/
BOOL IsValidWUTestFile(LPCTSTR lpszFilePath)
{
    USES_CONVERSION;
    DWORD cbBytesRead = 0;
    const DWORD cbSentinel = ARRAYSIZE(WU_SENTINEL_STRING) - 1;     //Size of the sentinel string
    //Ansi buffer to read file data
    CHAR szFileData[MAX_FILE_SIZE+1];                        
    ZeroMemory(szFileData, ARRAYSIZE(szFileData));
    BOOL fRet = FALSE;
 
    HANDLE hFile = CreateFile(lpszFilePath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, NULL, NULL);
    if (hFile == INVALID_HANDLE_VALUE) 
    {
        goto done;
    }
    //If the file size is greater than MAX_FILE_SIZE then bail out
    DWORD cbFile = GetFileSize(hFile, NULL);
    if(cbFile == INVALID_FILE_SIZE || cbFile > MAX_FILE_SIZE)
    {
        goto done;
    }
    if(!ReadFile(hFile, &szFileData, cbFile, &cbBytesRead, NULL) ||
        cbBytesRead != cbFile)
    {
        goto done;
    }
    //Compare with sentinel string
    if(0 != memcmp(szFileData, WU_SENTINEL_STRING, cbSentinel))
    {
        goto done;
    }

    LPTSTR tszTime = A2T(szFileData + cbSentinel);
    if(tszTime == NULL)
    {
        goto done;
    }
    SYSTEMTIME tmCur, tmFile;
    if(FAILED(String2SystemTime(tszTime, &tmFile)))
    {
        goto done;
    }
    GetSystemTime(&tmCur);
    int iSecs = TimeDiff(tmFile, tmCur);  
    //If the time stamp is less than 2 weeks old and not newer than current time than it is valid
    fRet = iSecs > 0 && iSecs < TWO_WEEKS;
    
done:
    if(hFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hFile);
    }
    return fRet;
}


BOOL FileExists(
    LPCTSTR lpsFile		// file with path to check
)
{

    DWORD dwAttr;
    BOOL rc;

    if (NULL == lpsFile || _T('\0') == *lpsFile)
    {
        return FALSE;
    }

    dwAttr = GetFileAttributes(lpsFile);

    if (-1 == dwAttr)
    {
        rc = FALSE;
    }
    else
    {
        rc = (0x0 == (FILE_ATTRIBUTE_DIRECTORY & dwAttr));
    }

    return rc;
}

/////////////////////////////////////////////////////////////////////////////
//
// ReplaceFileExtension
//
/////////////////////////////////////////////////////////////////////////////

BOOL ReplaceFileExtension(  LPCTSTR pszPath,
                          LPCTSTR pszNewExt,
                          LPTSTR pszNewPathBuf, 
                          DWORD cchNewPathBuf)
{
    LPCTSTR psz;
    HRESULT hr;
    DWORD   cchPath, cchExt, cch;

    if (pszPath == NULL || *pszPath == _T('\0'))
        return FALSE;

    cchPath = lstrlen(pszPath);

    // note that only a '>' comparison is needed since the file extension
    //  should never start at the 1st char in the path.
    for (psz = pszPath + cchPath;
         psz > pszPath && *psz != _T('\\') && *psz != _T('.');
         psz--);
    if (*psz == _T('\\'))
        psz = pszPath + cchPath;
    else if (psz == pszPath)
        return FALSE;

    // ok, so now psz points to the place where the new extension is going to 
    //  go.  Make sure our buffer is big enough.
    cchPath = (DWORD)(psz - pszPath);
    cchExt  = lstrlen(pszNewExt);
    if (cchPath + cchExt >= cchNewPathBuf)
        return FALSE;

    // yay.  we got a big enuf buffer.
    hr = StringCchCopyEx(pszNewPathBuf, cchNewPathBuf, pszPath, 
                         NULL, NULL, MISTSAFE_STRING_FLAGS);
    if (FAILED(hr))
        return FALSE;
    
    hr = StringCchCopyEx(pszNewPathBuf + cchPath, cchNewPathBuf - cchPath, pszNewExt,
                         NULL, NULL, MISTSAFE_STRING_FLAGS);
    if (FAILED(hr))
        return FALSE;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuv3\wsdu\wulib\timeutil.cpp ===
#include <timeutil.h>
#define ARRAYSIZE(a)  (sizeof(a) / sizeof(a[0]))

////////////////////////////////////////////////////////////////////////////
//
// Helper Function  TimeDiff(tm1, tm2)
//          helper function to find the difference (in seconds) of 2 system times
//
// Input:   2 SYSTEMTIME structures
// Output:  None
// Return:  seconds of difference
//              > 0 if tm2 is later than tm1
//              = 0 if tm2 and tm1 are the same
//              < 0 if tm2 is earlier than tm1
//
// On error the function returns 0 even if the two times are not equal
//
// Comment: If the number of seconds goes beyond INT_MAX (that is 
//          more than 24,855 days, INT_MAX is returned.
//          If the number of seconds goes beyond INT_MIN (a negative value,
//          means 24,855 days ago), INT_MIN is returned.
//
////////////////////////////////////////////////////////////////////////////
int TimeDiff(SYSTEMTIME tm1, SYSTEMTIME tm2)
{
    LONGLONG i64Sec;
    int iSec;
    //
    // convert the two times from SYSTEMTIME format into FILETIME format
    //
    FILETIME ftm1, ftm2;

    if ((SystemTimeToFileTime(&tm1, &ftm1) == 0) ||
        (SystemTimeToFileTime(&tm2, &ftm2) == 0))
    {
        return 0;
    }

    if ((ftm1.dwHighDateTime == ftm2.dwHighDateTime) &&
        (ftm1.dwLowDateTime == ftm2.dwLowDateTime))
    {
        return 0;
    }

    //
    // convert the two times from FILETIME to LARGE_INTEGER type,
    //
    LARGE_INTEGER i64Sec1, i64Sec2;
    i64Sec2.LowPart = ftm2.dwLowDateTime;
    i64Sec2.HighPart = ftm2.dwHighDateTime;
    i64Sec1.LowPart = ftm1.dwLowDateTime;
    i64Sec1.HighPart = ftm1.dwHighDateTime;
    
    
    //
    // since Windows support LONGLONG, we directly use the quad portion of LARGE_INTEGER
    // to get the difference, which is 100 nanoseconds. Then convert the number to seconds.
    //
    i64Sec = (i64Sec2.QuadPart - i64Sec1.QuadPart) / NanoSec100PerSec;

    //
    // convert the LONGLONG seconds value into integer, since it shouldn't exceed 
    // integer limit
    //
    if (i64Sec > INT_MAX)
    {
        //
        // just in case user is playing with the system time.
        // Otherwise, this difference should not go beyond 68 years.
        //
        iSec = INT_MAX;
    }
    else
    {
        if (i64Sec < INT_MIN)
        {
            iSec = INT_MIN;
        }
        else
        {
            iSec = (int)i64Sec;
        }
    }
    
    return iSec;
}
    

////////////////////////////////////////////////////////////////////////////
//
// Helper Function  TimeAddSeconds(SYSTEMTIME, int, SYSTEMTIME* )
//          helper function to calculate time by adding n seconds to 
//          the given time.
//
// Input:   a SYSTEMTIME as base time, an int as seconds to add to the base time
// Output:  new time
// Return:  HRESULT
//
////////////////////////////////////////////////////////////////////////////
HRESULT TimeAddSeconds(SYSTEMTIME tmBase, int iSeconds, SYSTEMTIME* pTimeNew)
{
	// fixcode use i64 calcs
    FILETIME ftm;

    if (SystemTimeToFileTime(&tmBase, &ftm) == 0)
    {
        return E_FAIL;
    }

    LARGE_INTEGER i64Sec;
    i64Sec.LowPart  = ftm.dwLowDateTime;
    i64Sec.HighPart = ftm.dwHighDateTime;

    __int64 i64Delay = NanoSec100PerSec;
    i64Delay *= iSeconds;
    i64Sec.QuadPart += i64Delay;    
    ftm.dwLowDateTime = i64Sec.LowPart;
    ftm.dwHighDateTime = i64Sec.HighPart;
    if (FileTimeToSystemTime(&ftm, pTimeNew) == 0)
    {
        return E_FAIL;
    }
    return S_OK;
}



//=======================================================================
// String2SystemTime
//=======================================================================
HRESULT String2SystemTime(LPCTSTR pszDateTime, SYSTEMTIME *ptm)
{
    // we expect the date/time format as 4-digit year ISO:
    //      01234567890123456789
    //      YYYY.MM.DD HH:MM:SS
    //
    const TCHAR C_DATE_DEL      = _T('.');
    const TCHAR C_DATE_TIME_DEL = _T(' ');
    const TCHAR C_TIME_DEL      = _T(':');
    TCHAR szBuf[20];
	LPTSTR pszDestEnd;

    if (FAILED(StringCchCopyEx(szBuf, ARRAYSIZE(szBuf), pszDateTime, &pszDestEnd, NULL, MISTSAFE_STRING_FLAGS)) ||
		19 != pszDestEnd - szBuf)
    {
        return E_INVALIDARG;
    }

    for (int i = 0; i < 19; i++)
    {
        switch (i)
        {
        case 4:
        case 7:
            if (szBuf[i] != C_DATE_DEL)
            {
                return E_INVALIDARG;
            }
            break;
        case 10:
            if (szBuf[i] != C_DATE_TIME_DEL)
            {
                return E_INVALIDARG;
            }
            break;
        case 13:
        case 16:
            if (szBuf[i] != C_TIME_DEL)
            {
                return E_INVALIDARG;
            }
            break;
        default:
            if (szBuf[i] < _T('0') || pszDateTime[i] > _T('9'))
            {
                return E_INVALIDARG;
            }
            break;
        }
    }

    //
    // get values
    //
    szBuf[4]            = EOS;
    ptm->wYear          = (short)_ttoi(szBuf);
    szBuf[7]            = EOS;
    ptm->wMonth         = (short)_ttoi(szBuf + 5);
    szBuf[10]           = EOS;
    ptm->wDay           = (short)_ttoi(szBuf + 8);
    szBuf[13]           = EOS;
    ptm->wHour          = (short)_ttoi(szBuf + 11);
    szBuf[16]           = EOS;
    ptm->wMinute        = (short)_ttoi(szBuf + 14);
    ptm->wSecond        = (short)_ttoi(szBuf + 17); 
    ptm->wMilliseconds  = 0;

    //
    // validate if this constructed SYSTEMTIME data is good
    //
    // fixcode should this just be SystemTimeToFileTime() ?
    if (GetDateFormat(LOCALE_SYSTEM_DEFAULT,DATE_SHORTDATE, ptm, NULL, NULL, 0) == 0)
    {
        return E_INVALIDARG;
    }
    if (GetTimeFormat(LOCALE_SYSTEM_DEFAULT,LOCALE_NOUSEROVERRIDE, ptm, NULL, NULL, 0) == 0)
    {
        return E_INVALIDARG;
    }

    return S_OK;
}


//=======================================================================
// SystemTime2String
//=======================================================================
HRESULT SystemTime2String(SYSTEMTIME & tm, LPTSTR pszDateTime, size_t cchSize)
{
    if ( pszDateTime == NULL )
    {
        return E_INVALIDARG;
    }

    // bug fixed: changed from wsprintf to _snwprintf because an invalid
    // date on tm was causing buffer overflow
    LPTSTR pszDestEnd;
	if (FAILED(StringCchPrintfEx(
					pszDateTime,
					cchSize,
					&pszDestEnd,
					NULL,
					MISTSAFE_STRING_FLAGS,
					TEXT("%4i.%02i.%02i %02i:%02i:%02i"),
					tm.wYear,
					tm.wMonth,
					tm.wDay,
					tm.wHour,
					tm.wMinute,
					tm.wSecond)) ||
		pszDestEnd - pszDateTime != 19)
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuv3\wsdu\wulib\usecrc.cpp ===
//=======================================================================
//
//  Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:    filecrc.h
//
//  Purpose: Calculating and using CRC for files
//
//=======================================================================

#include <windows.h>
#include <objbase.h>
#include <filecrc.h>
#include <search.h>   // for bsearch
#include <tchar.h>
#include <atlconv.h>


HRESULT GetCRCNameFromList(int iNo, PBYTE pmszCabList, PBYTE pCRCList, LPTSTR pszCRCName, int cbCRCName, LPTSTR pszCabName)
{
	USES_CONVERSION;
	
	int i = 0;
	WUCRC_HASH* pCRC = (WUCRC_HASH*)pCRCList;

	if ( (NULL == pmszCabList) || (NULL == pCRCList) )
		return E_INVALIDARG;

	for (LPSTR pszFN = (LPSTR)pmszCabList; *pszFN; pszFN += strlen(pszFN) + 1)
	{
		if (i == iNo)
		{
			lstrcpy(pszCabName, A2T(pszFN));
			
			return MakeCRCName(A2T(pszFN), pCRC, pszCRCName, cbCRCName);
		}
		pCRC++;
		i++;
	}

	// if we got here that means we did not find the request element
	return HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
}


HRESULT StringFromCRC(const WUCRC_HASH* pCRC, LPTSTR pszBuf, int cbBuf)
{
	LPTSTR p = pszBuf;
	BYTE b;
	
	//check the input argument, to see that it is not NULL
	if (NULL == pCRC)
	{
		return E_INVALIDARG;
	}

    if (cbBuf < ((WUCRC_HASH_SIZE * 2) + 1))
	{
		return TYPE_E_BUFFERTOOSMALL;
	}
	
	for (int i = 0; i < WUCRC_HASH_SIZE; i++)
	{
		b = pCRC->HashBytes[i] >> 4;
		if (b <= 9)
			*p = '0' + (TCHAR)b;
		else
			*p = 'A' + (TCHAR)(b - 10);
		p++;

		b = pCRC->HashBytes[i] & 0x0F;
		if (b <= 9)
			*p = '0' + (TCHAR)b;
		else
			*p = 'A' + (TCHAR)(b - 10);
		p++;
	}
	*p = _T('\0');
	
	return S_OK;
}



static BYTE hex2dec(char ch)
{
    if (ch >= '0' && ch <= '9')
    {
	    return (ch - '0');
    }

    if (ch >= 'A' && ch <= 'F')
    {
	    return (ch - 'A' + 0xA);
    }

    if (ch >= 'a' && ch <= 'f')
    {
	    return (ch - 'a' + 0xA);
    }

	// we do not expect illegal values here
	return 0;
}



HRESULT CRCFromString(LPCSTR pszCRC, WUCRC_HASH* pCRC)
{
	if (strlen(pszCRC) != (2 * WUCRC_HASH_SIZE))
	{
		return E_INVALIDARG;
	}
	
	LPCSTR p = pszCRC;
    
    
	for (int i = 0; i < WUCRC_HASH_SIZE; i++)
	{
        // broken into two lines because the optimizer was doing the wrong thing when on one line
		pCRC->HashBytes[i] = (hex2dec(*p++) << 4);
        pCRC->HashBytes[i] += hex2dec(*p++);
	}
	
	return S_OK;
}




HRESULT MakeCRCName(LPCTSTR pszFromName, const WUCRC_HASH* pCRC, LPTSTR pszToName, int cbToName)
{
	int iLen = lstrlen(pszFromName);
	LPTSTR pDot;
	TCHAR szCRC[WUCRC_HASH_SIZE * 2 + 1];
	HRESULT hr = S_OK;

	// make sure we have enough space for orignal file name + hash + a '_' + null terminator
	if (cbToName < (WUCRC_HASH_SIZE * 2 + iLen + 2))
	{
		return TYPE_E_BUFFERTOOSMALL;
	}

	hr = StringFromCRC(pCRC, szCRC, sizeof(szCRC));
	if (FAILED(hr))
	{
		return hr;
	}

	lstrcpy(pszToName, pszFromName);

	// find the extension in the new copy
	pDot = _tcschr(pszToName, _T('.'));
	if (pDot != NULL)
	{
		*pDot = _T('\0');
	}
	lstrcat(pszToName, _T("_"));
	lstrcat(pszToName, szCRC);

	// copy the extension from the original name
	pDot = _tcschr(pszFromName, _T('.'));
	if (pDot != NULL)
	{
		lstrcat(pszToName, pDot);
	}

	return hr;
}




// splits abc_12345.cab into  abc.cab and 12345 returned as CRC
HRESULT SplitCRCName(LPCSTR pszCRCName, WUCRC_HASH* pCRC, LPSTR pszName)
{
// YANL - unreferenced local variable
//	char szCRC[WUCRC_HASH_SIZE * 2 + 1];
	char szTmp[MAX_PATH];
	int l = strlen(pszCRCName);
	int i;
	LPSTR pszExt = NULL;
	LPSTR pszHash = NULL;

	pszName[0] = '\0';
	if (l < (2 * WUCRC_HASH_SIZE))
	{
		// cannot be a valid name if it does not have atleast 2*WUCRC_HASH_SIZE characters
		return E_INVALIDARG;
	}

	strcpy(szTmp, pszCRCName);

	// start at the end, set pointers to put nulls at last period and last underscore
	// record the starting position of the extension and hash code
	i = l - 1;
	while (i >= 0)
	{
		if ((szTmp[i] == '.') && (pszExt == NULL))
		{
			pszExt = &(szTmp[i + 1]);
			szTmp[i] = '\0';
		}
		else if ((szTmp[i] == '_') && (pszHash == NULL))
		{
			pszHash = &(szTmp[i + 1]);
			szTmp[i] = '\0';
		}
		i--;
	}

	if (pszHash == NULL)
	{
		return E_INVALIDARG;
	}

	// copy original cab name
	strcpy(pszName, szTmp);
	if (pszExt != NULL)
	{
		strcat(pszName, ".");
		strcat(pszName, pszExt);
	}


	return CRCFromString(pszHash, pCRC);
}



int __cdecl CompareWUCRCMAP(const void* p1, const void* p2)
{
	//check if the input arguments are not NULL
	if (NULL == p1 || NULL == p2)
	{
		return 0;
	}

	DWORD d1 = ((WUCRCMAP*)p1)->dwKey;
	DWORD d2 = ((WUCRCMAP*)p2)->dwKey;

	if (d1 > d2)
		return +1;
	else if (d1 < d2)
		return -1;
	else
		return 0;
}


//
// CCRCMapFile class
//


// Constructs an object to search the CRC index file data passed in 
// with pMemData.  
//
// NOTE: The memory pointed by pMemData buffer must stay valid
//       for the lifetime of this object
//
// structure for map file:
//   DWORD count
//   WUCRCMAP[0]
//   WUCRCMAP[1]
//   WUCRCMAP[count - 1]
//
CCRCMapFile::CCRCMapFile(const BYTE* pMemData, DWORD dwMemSize)
{
	//check the input argument for NULLs
	if (NULL == pMemData) 
	{
		m_pEntries = NULL;
		m_cEntries = 0;
		return;
	}

	// get the count
	m_cEntries = *((DWORD*)pMemData);

	// validate the memory buffer size
	if ((sizeof(DWORD) + m_cEntries * sizeof(WUCRCMAP)) != dwMemSize)
	{
		// invalid size is passed, we cannot process it
		m_pEntries = NULL;
		m_cEntries = 0;
	}
	else
	{
		// set the pointer to begining of the map entries
		m_pEntries = (WUCRCMAP*)(pMemData + sizeof(DWORD));
	}
}


HRESULT CCRCMapFile::GetValue(DWORD dwKey, WUCRC_HASH* pCRC)
{
	WUCRCMAP* pEntry;
	WUCRCMAP key;

	if (m_cEntries == 0)
	{
		// memory buffer passed to us was invalid
		return HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
	}

	// fill the key field need for compare function in the structure
	key.dwKey = dwKey;

	// binary search to find the item
	pEntry = (WUCRCMAP*)bsearch((void*)&key, (void*)m_pEntries, m_cEntries, sizeof(WUCRCMAP), CompareWUCRCMAP);

	if (pEntry == NULL)
	{
		// not found
		return HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
	}

	// found the entry
	memcpy(pCRC, &pEntry->CRC, sizeof(WUCRC_HASH));

	return S_OK;
}


HRESULT CCRCMapFile::GetCRCName(DWORD dwKey, LPCTSTR pszFromName, LPTSTR pszToName, int cbToName)
{
	WUCRC_HASH CRC;

	HRESULT hr = GetValue(dwKey, &CRC);

	if (SUCCEEDED(hr))
	{
		hr = MakeCRCName(pszFromName, &CRC, pszToName, cbToName);
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuv3\wsdu\wulib\util.cpp ===
//=======================================================================
//
//  Copyright (c) 1998-1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:    util.cpp
//
//  Purpose:
//
//=======================================================================

#include <windows.h>
#include <malloc.h>
#include <v3stdlib.h>
#include <tchar.h>
#include <mistsafe.h>

#define ARRAYSIZE(a)  (sizeof(a) / sizeof(a[0]))

//---------------------------------------------------------------------
// Memory management wrappers
//
// main difference is that they will throw an exception if there is
// not enough memory available.  V3_free handles NULL value
//---------------------------------------------------------------------
void *V3_calloc(size_t num, size_t size)
{
	void *pRet;

	if (!(pRet = calloc(num, size)))
	{
		throw HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
	}
	return pRet;
}


void V3_free(void *p)
{
	if (p)
		free(p);
}


void *V3_malloc(size_t size)
{
	void *pRet;

	if (!(pRet = malloc(size)))
	{
		throw HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
	}

	return pRet;
}


void *V3_realloc(void *memblock, size_t size)
{
	void *pRet;

	if (!(pRet = realloc(memblock, size)))
	{
		throw HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
	}

	return pRet;
}


//-----------------------------------------------------------------------------------
//  GetWindowsUpdateDirectory
//		This function returns the location of the WindowsUpdate directory. All local
//		files are store in this directory. The pszPath parameter needs to be at least
//		MAX_PATH.  The directory is created if not found
//-----------------------------------------------------------------------------------
BOOL GetWindowsUpdateDirectory(LPTSTR pszPath, DWORD dwBuffLen)
{
	static TCHAR szCachePath[MAX_PATH + 1] = {_T('\0')};

    if (NULL == pszPath)
        return FALSE;

	if (szCachePath[0] == _T('\0'))
	{
		HKEY hkey;

		pszPath[0] = _T('\0');
		if (RegOpenKey(HKEY_LOCAL_MACHINE, _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion"), &hkey) == ERROR_SUCCESS)
		{
			DWORD cbPath = dwBuffLen;
			RegQueryValueEx(hkey, _T("ProgramFilesDir"), NULL, NULL, (LPBYTE)pszPath, &cbPath);
			RegCloseKey(hkey);
		}
		if (pszPath[0] == _T('\0'))
		{
			TCHAR szWinDir[MAX_PATH + 1];
			if (! GetWindowsDirectory(szWinDir, ARRAYSIZE(szWinDir)))
			{
                if (FAILED(StringCchCopyEx(szWinDir, ARRAYSIZE(szWinDir), _T("C"), NULL, NULL, MISTSAFE_STRING_FLAGS)))
                    return FALSE;
			}
			pszPath[0] = szWinDir[0];
			pszPath[1] = _T('\0');
            if (FAILED(StringCchCatEx(pszPath, dwBuffLen, _T(":\\Program Files"), NULL, NULL, MISTSAFE_STRING_FLAGS)))
                return FALSE;
		}	

        if (FAILED(StringCchCatEx(pszPath, dwBuffLen, _T("\\WindowsUpdate\\"), NULL, NULL, MISTSAFE_STRING_FLAGS)))
            return FALSE;
		
		V3_CreateDirectory(pszPath);

		//
		// save it in the cache
		//
        if (FAILED(StringCchCopyEx(szCachePath, ARRAYSIZE(szCachePath), pszPath, NULL, NULL, MISTSAFE_STRING_FLAGS)))
        {
            // ignore
        }
	}
	else
	{
        if (FAILED(StringCchCopyEx(pszPath, dwBuffLen, szCachePath, NULL, NULL, MISTSAFE_STRING_FLAGS)))
            return FALSE;
	}
    return TRUE;
}

//---------------------------------------------------------------------
//  V3_CreateDirectory
//      Creates the full path of the directory (nested directories)
//---------------------------------------------------------------------
BOOL V3_CreateDirectory(LPCTSTR pszDir)
{
	BOOL bRc;
	TCHAR szPath[MAX_PATH + 1];

	//
	// make a local copy and remove final slash
	//
    if (FAILED(StringCchCopyEx(szPath, ARRAYSIZE(szPath), pszDir, NULL, NULL, MISTSAFE_STRING_FLAGS)))
        return FALSE;

	int iLast = lstrlen(szPath) - 1;
	if (szPath[iLast] == _T('\\'))
		szPath[iLast] = 0;

	//
	// check to see if directory already exists
	//
	DWORD dwAttr = GetFileAttributes(szPath);

	if (dwAttr != 0xFFFFFFFF)   
	{
		if ((dwAttr & FILE_ATTRIBUTE_DIRECTORY) != 0)
			return TRUE;
	}

	//
	// create it
	//
    TCHAR* p = szPath;
	if (p[1] == _T(':'))
		p += 2;
	else 
	{
		if (p[0] == _T('\\') && p[1] == _T('\\'))
			p += 2;
	}
	
	if (*p == _T('\\'))
		p++;
    while (p = _tcschr(p, _T('\\')))
    {
        *p = 0;
		bRc = CreateDirectory(szPath, NULL);
		*p = _T('\\');
		p++;
		if (!bRc)
		{
			if (GetLastError() != ERROR_ALREADY_EXISTS)
			{
				return FALSE;
			}
		}
	}

	bRc = CreateDirectory(szPath, NULL);
	if ( !bRc )
	{
		if (GetLastError() != ERROR_ALREADY_EXISTS)
		{
			return FALSE;
		}
	}

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuv3\wuv3\sources.inc ===
!IF 0

Copyright (c) 1998	Microsoft Corporation

Module Name:	WUV3

Abstract:		WUV3 is a common libarary for Windows Update V3.
				This libarary forms a reprository for commonly used
				function V3 catalog functions.

!ENDIF


MAJORCOMP =WUPPT
MINORCOMP =WUV3
TARGETNAME=WUV3
TARGETPATH=$(_OBJ_DIR)
TARGETTYPE=LIBRARY

INCLUDES= $(INCLUDES);..\..\cdminc;..\..\inc
USE_STATIC_ATL=1
USE_MSVCRT=1
USE_STL=1
# moving these into the unicode and ansi directories' sources files
#C_DEFINES=$(C_DEFINES) /D_UNICODE /DUNICODE

SOURCES   = ..\version.cpp  \
			..\wufix.cpp	 \
			..\wuvar.cpp	 \
			..\string.cpp	 \
			..\util.cpp	\
			..\cstate.cpp	 \
			..\CWUDload.cpp \
			..\ccatalog.cpp \
			..\cbitmask.cpp \
			..\selection.cpp \
			..\applog.cpp \
			..\debug.cpp \
			..\locstr.cpp \
			..\speed.cpp

USE_NATIVE_EH=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuv3\wsdu\wulib\wuvar.cpp ===
//=======================================================================
//
//  Copyright (c) 1998-1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:    wuvar.cpp
//
//  Purpose:
//
//=======================================================================

#include <windows.h>
#include <v3stdlib.h>
#include <varray.h>
#include <wuv3.h>

//The GetNext function returns a pointer to the next variable array item in a
//variable chain. If the next variable item does not exit then this method
//return NULL.

PWU_VARIABLE_FIELD WU_VARIABLE_FIELD::GetNext
	(
		void
	)
{
	PWU_VARIABLE_FIELD	pv;

	//walk though the varaible field array associated with this data item
	//and return the requested item or NULL if the item is not found.
	pv = this;
	if ( pv->id == WU_VARIABLE_END )
		return NULL;

	pv = (PWU_VARIABLE_FIELD)((PBYTE)pv + pv->len);

	return pv;
}

//find a variable item in a variable item chain.
PWU_VARIABLE_FIELD WU_VARIABLE_FIELD::Find
	(
		short id	//id of variable size field to search for in the variable size chain.
	)
{
	PWU_VARIABLE_FIELD	pv;

	//walk though the varaible field array associated with this data item
	//and return the requested item or NULL if the item is not found.
	pv = this;

	//If this variable record only contains an end record then we
	//need to handle it specially since the normal find loop
	//updates the pv pointer before the end check is made so if
	//end is the first field it can be missed.

	if ( pv->id == WU_VARIABLE_END )
		return ( id == WU_VARIABLE_END ) ? pv : (PWU_VARIABLE_FIELD)NULL;

	do
	{
		if ( pv->id == id )
			return pv;

        //NT Bug #255962 - this prevents a non-terminal loop if the len is 0
	    if(NULL == pv->len)
		    return (PWU_VARIABLE_FIELD)NULL;

		pv = (PWU_VARIABLE_FIELD)((PBYTE)pv + pv->len);
	} while( (NULL != pv) && (pv->id != WU_VARIABLE_END) );
 
	//case where caller asked to search for the WU_VARIABLE_END field
	if ( (NULL != pv) && (pv->id == id) )
		return pv;

	return (PWU_VARIABLE_FIELD)NULL;
}

//Variable size field constructor.

_WU_VARIABLE_FIELD::_WU_VARIABLE_FIELD()
{
	id = WU_VARIABLE_END;
	len = sizeof(id) + sizeof(len);
}

//returns the total size of a variable field
int _WU_VARIABLE_FIELD::GetSize
	(
		void
	)
{
	PWU_VARIABLE_FIELD	pv;
	int					iSize;

	iSize = 0;
	pv = this;

	while( (NULL != pv) && (pv->id != WU_VARIABLE_END) )
	{
		//check if the len value is greater that 0 otherwise it might go in an infinite loop
		if (pv->len < 1)
		{
			return 0;
		}

		iSize += pv->len;
		pv = (PWU_VARIABLE_FIELD)((PBYTE)pv + pv->len);
	}

	if (NULL != pv)
	{
		iSize += pv->len;
	}

	return iSize;
}

//This function will seem tricky at first. The problem here is that the
//returned variable field array needs to be in a single block of memory.
//The reason that the memory must be contigous is that the variable field
//items that walk from one record to the next use the len parameter to find
//the beginning of the next variable record. This then prevents us from
//being able to simply take the pvNew pointer and add it to the variable
//field array. Instead we calulate the new needed size of the array and
//realloc the current pointer to this new size. We then copy the pvNew
//pointer into the newly sized array.

//The other problem here is that we cannot change the this pointer for the
//variable field array while inside a function handler for a variable field.
//So each structure that needs to manage variable fields needs one of these
//add functions. We could have set this up as a virtual function however this
//would have added a vtable to the structure. Since we are interested in the
//keeping the code size as small as possible this vtable is best avoided.

//This function has to be handled outside of the inventory item structure
//because the inventory item needs to be a continuous block of memory for
//file management. So when we add a variable field to the structure we also
//need to reallocate item structure. If we were to put this function into
//the inventory structure then we would not be able to do this because of
//this pointer semantics.

//Note: In order to use this function a valid pItem must already exist and
//since a pItem exits it must contain at least one variable type field which
//needs to be an end field.

void __cdecl AddVariableSizeField
	(
		PINVENTORY_ITEM *pItem,		//pointer to inventory item variable size field chain.
		PWU_VARIABLE_FIELD pvNew	//pointer to new variable size field to add.
	)
{
	int					iSize;
	PWU_VARIABLE_FIELD	pvTmp;

	//calculate the size needed by the new variable field array
	iSize = sizeof(INVENTORY_ITEM) + sizeof(WU_INV_FIXED) + (*pItem)->pv->GetSize() + pvNew->len;

	//realloc array and fix up variable pointer

	*pItem = (PINVENTORY_ITEM)V3_realloc(*pItem, iSize);

	(*pItem)->pf = (PWU_INV_FIXED)(((PBYTE)(*pItem)) + sizeof(INVENTORY_ITEM));

	//fix up the variable pointer since the underlying block
	//may have been moved.
	(*pItem)->pv = (PWU_VARIABLE_FIELD)(((PBYTE)*pItem) + sizeof(INVENTORY_ITEM) + sizeof(WU_INV_FIXED));

	pvTmp = (*pItem)->pv;

	//get a pointer to the last field in the variable field array
	pvTmp = (*pItem)->pv->Find(WU_VARIABLE_END);
	if ( !pvTmp )
	{
		//something is very wrong here the variable item array
		//links are messed up some how. This should never happen
		//in a production environment however we may see this
		//in the course of development and testing.
		throw (HRESULT)MEM_E_INVALID_LINK;
	}

	//copy over last field with new variable size field
	memcpy(pvTmp, pvNew, pvNew->len);

	//add new end type variable size field to end of array since
	//we destroyed the existing one with the copy of the new
	//variable size field.

	pvTmp = (PWU_VARIABLE_FIELD)((PBYTE)pvTmp + pvTmp->len);
	pvTmp->id = WU_VARIABLE_END;
	pvTmp->len = sizeof(WU_VARIABLE_FIELD);

	return;
}

//This function will seem tricky at first. The problem here is that the
//returned variable field array needs to be in a single block of memory.
//The reason that the memory must be contigous is that the variable field
//items that walk from one record to the next use the len parameter to find
//the beginning of the next variable record. This then prevents us from
//being able to simply take the pvNew pointer and add it to the variable
//field array. Instead we calulate the new needed size of the array and
//realloc the current pointer to this new size. We then copy the pvNew
//pointer into the newly sized array.

//The other problem here is that we cannot change the this pointer for the
//variable field array while inside a function handler for a variable field.
//So each structure that needs to manage variable fields needs one of these
//add functions. We could have set this up as a virtual function however this
//would have added a vtable to the structure. Since we are interested in the
//keeping the code size as small as possible this vtable is best avoided.

//This function has to be handled outside of the inventory item structure
//because the inventory item needs to be a continuous block of memory for
//file management. So when we add a variable field to the structure we also
//need to reallocate item structure. If we were to put this function into
//the inventory structure then we would not be able to do this because of
//this pointer semantics.

//Note: In order to use this function a valid pItem must already exist and
//since a pItem exits it must contain at least one variable type field which
//needs to be an end field.

void __cdecl AddVariableSizeField
	(
		PWU_DESCRIPTION *pDescription,	//pointer to description record type variable size field.
		PWU_VARIABLE_FIELD pvNew		//pointer to new variable size field to add.
	)
{
	int					iSize;
	PWU_VARIABLE_FIELD	pvTmp;

	//calculate the size needed by the new variable field array
	iSize = sizeof(WU_DESCRIPTION) + (*pDescription)->pv->GetSize() + pvNew->len;

	//realloc array and fix up variable pointer

	*pDescription = (PWU_DESCRIPTION)V3_realloc(*pDescription, iSize);

	//fix up the variable pointer since the underlying block may have been moved.
	(*pDescription)->pv = (PWU_VARIABLE_FIELD)(((PBYTE)*pDescription) + sizeof(WU_DESCRIPTION));

	pvTmp = (*pDescription)->pv;

	//get a pointer to the last field in the variable field array
	pvTmp = (*pDescription)->pv->Find(WU_VARIABLE_END);
	if ( !pvTmp )
	{
		//something is very wrong here the variable item array
		//links are messed up some how. This should never happen
		//in a production environment however we may see this
		//in the course of development and testing.
		throw (HRESULT)MEM_E_INVALID_LINK;
	}

	//copy over last field with new variable size field
	memcpy(pvTmp, pvNew, pvNew->len);

	//add new end type variable size field to end of array since
	//we destroyed the existing one with the copy of the new
	//variable size field.

	pvTmp = (PWU_VARIABLE_FIELD)((PBYTE)pvTmp + pvTmp->len);
	pvTmp->id = WU_VARIABLE_END;
	pvTmp->len = sizeof(WU_VARIABLE_FIELD);

	return;
}

//Adds a variable size field to a variable field chain.
//The format of a variable size field is:
//[(short)id][(short)len][variable size data]
//The variable field always ends with a WU_VARIABLE_END type.

PWU_VARIABLE_FIELD CreateVariableField
	(
		IN	short	id,			//id of variable field to add to variable chain.
		IN	PBYTE	pData,		//pointer to binary data to add.
		IN	int		iDataLen	//Length of binary data to add.
	)
{
	PWU_VARIABLE_FIELD	pVf;

	pVf = (PWU_VARIABLE_FIELD)V3_malloc(sizeof(WU_VARIABLE_FIELD) + iDataLen);

	if ( iDataLen )
		memcpy(pVf->pData, pData, iDataLen);

	pVf->id  = id;
	pVf->len = (short)(sizeof(WU_VARIABLE_FIELD) + iDataLen);

	return pVf;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\wuv3\wsdu\wulib\wufix.cpp ===
//=======================================================================
//
//  Copyright (c) 1998-1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:    wifix.cpp
//
//  Purpose:
//
//=======================================================================

#include <windows.h>
#include <memory.h>
#include <objbase.h>
#include <atlconv.h>

#include <v3stdlib.h>
#define USEWUV3INCLUDES
#include <wuv3.h>
#undef USEWUV3INCLUDES

//Perf function, Since puids are used by the control every where we
//provide a quick way of returning the puid information to a caller.

PUID _INVENTORY_ITEM::GetPuid(void)
{
	if(NULL == pf)
	{
		return 0; //clients must check for 0 return
	}

	switch( recordType )
	{
		case WU_TYPE_ACTIVE_SETUP_RECORD:
			return pf->a.puid;
			break;
		case WU_TYPE_CDM_RECORD:
		case WU_TYPE_CDM_RECORD_PLACE_HOLDER:
		case WU_TYPE_RECORD_TYPE_PRINTER:
		case WU_TYPE_CATALOG_RECORD:
			return pf->d.puid;
			break;
		case WU_TYPE_SECTION_RECORD:
		case WU_TYPE_SUBSECTION_RECORD:
		case WU_TYPE_SUBSUBSECTION_RECORD:
			return pf->s.puid;
			break;
		default:
			break;
	}

	return -1;	//Error invalid record type
}

//copies information about an inventory item to a user supplied buffer.
BOOL _INVENTORY_ITEM::GetFixedFieldInfo
	(
		int	infoType,	//type of information to be returned
		PVOID	pBuffer		//caller supplied buffer for the returned information. The caller is
					//responsible for ensuring that the return buffer is large enough to
					//contain the requested information.
	)
{

	if (NULL == pf) 
	{
		return FALSE;
	}

	switch( recordType )
	{
		case WU_TYPE_ACTIVE_SETUP_RECORD:
			switch(infoType)
			{
				case WU_ITEM_GUID:
					// Check if the buffer pBuffer is not NULL
					if (NULL == pBuffer)
					{
						return FALSE;
					}
					memcpy(pBuffer, &pf->a.g, sizeof(GUID));
					return TRUE;
				case WU_ITEM_PUID:
					*((PUID *)pBuffer) = pf->a.puid;
					return TRUE;
				case WU_ITEM_FLAGS:
					*((PBYTE)pBuffer) = pf->a.flags;
					return TRUE;
				case WU_ITEM_LINK:
					pf->a.link;
					return TRUE;
				case WU_ITEM_INSTALL_LINK:
					pf->a.installLink;
					return TRUE;
				case WU_ITEM_LEVEL:
					break;
			}
			break;
		case WU_TYPE_CDM_RECORD:
		case WU_TYPE_CDM_RECORD_PLACE_HOLDER:	//note cdm place holder record does not have an associated description record.
		case WU_TYPE_RECORD_TYPE_PRINTER:
		case WU_TYPE_CATALOG_RECORD:
			switch(infoType)
			{
				case WU_ITEM_PUID:
					*((PUID *)pBuffer) = pf->d.puid;
					return TRUE;
				case WU_ITEM_GUID:
				case WU_ITEM_FLAGS:
				case WU_ITEM_LINK:
				case WU_ITEM_INSTALL_LINK:
				case WU_ITEM_LEVEL:
					break;
			}
			break;
		case WU_TYPE_SECTION_RECORD:
		case WU_TYPE_SUBSECTION_RECORD:
		case WU_TYPE_SUBSUBSECTION_RECORD:
			switch(infoType)
			{
				case WU_ITEM_GUID:
					// Check if the buffer pBuffer is not NULL
					if (NULL == pBuffer)
					{
						return FALSE;
					}
					memcpy(pBuffer, &pf->s.g, sizeof(GUID));
					return TRUE;
				case WU_ITEM_PUID:
					*((PUID *)pBuffer) = pf->s.puid;
					return TRUE;
				case WU_ITEM_FLAGS:
					*((PBYTE)pBuffer) = pf->s.flags;
					return TRUE;
				case WU_ITEM_LEVEL:
					*((PBYTE)pBuffer) = pf->s.level;
					break;
				case WU_ITEM_LINK:
				case WU_ITEM_INSTALL_LINK:
					break;
			}
			break;
	}

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\games\backgammon\backgammon.cpp ===
/*******************************************************************************

	Backgammon.c
	
		The client backgammon game.
		

	Change History (most recent first):
	----------------------------------------------------------------------------
	Rev	 |	Date	 |	Who	 |	What
	----------------------------------------------------------------------------
	0		11/1/96		CHB		Created
	 
*******************************************************************************/

#include <windows.h>
#include <commctrl.h>
#include <mmsystem.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#include "game.h"
#include "zonecli.h"
#include "zonehelpids.h"


// Defines
#define zGameNameLen	63


// Global variables that don't need to be thread safe
//const TCHAR* gGameRegName = _T("Backgammon");
HWND  gOCXHandle		 = NULL;

#ifndef ZONECLI_DLL

	static HINSTANCE	 ghInstance;
	static TCHAR		 gVillageName[zUserNameLen + 1];
	static TCHAR		 gGameDir[zGameNameLen + 1];
	static TCHAR		 gGameName[zGameNameLen + 1];
	static TCHAR		 gGameDataFile[zGameNameLen + 1];
	static TCHAR		 gGameServerName[zGameNameLen + 1];
	static uint32		 gGameServerPort;
	static ZImage		 gGameIdle;
	static ZImage		 gGaming;
	static TCHAR		 gHelpURL;

#else

	typedef struct
	{
		HINSTANCE	m_ghInstance;
		TCHAR		m_gVillageName[zUserNameLen + 1];
		TCHAR		m_gGameDir[zGameNameLen + 1];
		TCHAR		m_gGameName[zGameNameLen + 1];
		TCHAR		m_gGameDataFile[zGameNameLen + 1];
		TCHAR		m_gGameServerName[zGameNameLen + 1];
		TCHAR		m_gHelpURL[ 128 ];
		uint32		m_gGameServerPort;
		ZImage		m_gGameIdle;
		ZImage		m_gGaming;
	} GameGlobalsType, *GameGlobals;

	#define ghInstance			(pGameGlobals->m_ghInstance)
	#define gVillageName		(pGameGlobals->m_gVillageName)
	#define gGameDir			(pGameGlobals->m_gGameDir)
	#define gGameName			(pGameGlobals->m_gGameName)
	#define gGameDataFile		(pGameGlobals->m_gGameDataFile)
	#define gGameServerName		(pGameGlobals->m_gGameServerName)
	#define gGameServerPort		(pGameGlobals->m_gGameServerPort)
	#define gGameIdle			(pGameGlobals->m_gGameIdle)
	#define gGaming				(pGameGlobals->m_gGaming)
	#define	gHelpURL			(pGameGlobals->m_gHelpURL)

#endif //!ZONECLI_DLL


///////////////////////////////////////////////////////////////////////////////
// Inline Functions
///////////////////////////////////////////////////////////////////////////////

inline BOOL IsValidSeat( int seat )
{
	return ((seat >= 0) && (seat < zNumPlayersPerTable));
}


///////////////////////////////////////////////////////////////////////////////
// EXPORTED ROUTINES
///////////////////////////////////////////////////////////////////////////////

extern "C" static ZBool GetObjectFunc(int16 objectType, int16 modifier, ZImage* image, ZRect* rect)
{
#ifdef ZONECLI_DLL
	GameGlobals	pGameGlobals = (GameGlobals) ZGetGameGlobalPointer();
#endif
/*
	HRSRC hrc;
	ZImageDescriptor* ptr;
	int sz;

	switch (objectType)
	{
		case zRoomObjectGameMarker:
			if (image != NULL)
			{
				if (modifier == zRoomObjectIdle)
				{
					if ( gGameIdle )
						*image = gGameIdle;
					else
					{
						hrc = FindResource( ghInstance, MAKEINTRESOURCE(ID_ZIMAGE_IDLE), _T("ZIMAGE") );
						if ( !hrc )
							return FALSE;
						ptr = (ZImageDescriptor*) new BYTE [ sz = SizeofResource( ghInstance, hrc ) ];
						if ( !ptr )
							return FALSE;
						CopyMemory( ptr, LockResource( LoadResource( ghInstance, hrc ) ), sz );
						ZImageDescriptorEndian( ptr, TRUE, zEndianFromStandard );
						gGameIdle = ZImageNew();
						ZImageInit( gGameIdle, ptr, NULL );
						*image = gGameIdle;
						delete [] ptr;
					}
				}
				else if (modifier == zRoomObjectGaming)
				{
					if ( gGaming )
						*image = gGaming;
					else
					{
						hrc = FindResource( ghInstance, MAKEINTRESOURCE(ID_ZIMAGE_PLAY), _T("ZIMAGE") );
						if ( !hrc )
							return FALSE;
						ptr = (ZImageDescriptor*) new BYTE [ sz = SizeofResource( ghInstance, hrc ) ];
						if ( !ptr )
							return FALSE;
						CopyMemory( ptr, LockResource( LoadResource( ghInstance, hrc ) ), sz );
						ZImageDescriptorEndian( ptr, TRUE, zEndianFromStandard );
						gGaming = ZImageNew();
						ZImageInit( gGaming, ptr, NULL );
						*image = gGaming;
						delete [] ptr;
					}
				}
			}
			return (TRUE);
	}
	*/
	return (TRUE);
}



extern "C" static void DeleteObjectsFunc(void)
{
#ifdef ZONECLI_DLL
	GameGlobals	pGameGlobals = (GameGlobals) ZGetGameGlobalPointer();
#endif
/*
	if ( gGaming )
	{
		ZImageDelete(gGaming);
		gGaming = NULL;
	}
	if ( gGameIdle )
	{
		ZImageDelete(gGameIdle);
		gGameIdle = NULL;
	}
*/
}



extern "C" ZError ZoneGameDllInit(HINSTANCE hLib, GameInfo gameInfo)
{
#ifdef ZONECLI_DLL
	GameGlobals	pGameGlobals = (GameGlobals) ZCalloc(1, sizeof(GameGlobalsType));
	if (pGameGlobals == NULL)
		return (zErrOutOfMemory);
	ZSetGameGlobalPointer(pGameGlobals);
#endif

	// global variables
//	lstrcpyn(gGameDir, gameInfo->game, zGameNameLen);
//	lstrcpyn(gGameName, gameInfo->gameName, zGameNameLen);
//	lstrcpyn(gGameDataFile, gameInfo->gameDataFile, zGameNameLen);
//	lstrcpyn(gGameServerName, gameInfo->gameServerName, zGameNameLen);

	gGameServerPort = gameInfo->gameServerPort;
	ghInstance = hLib;
	gGameIdle = NULL;
	gGaming = NULL;
//	gHelpURL[0] = _T('\0');
	
	// random numbers
    srand(GetTickCount());

	// common controls
	InitCommonControls();
	
	return (zErrNone);
}



extern "C" void ZoneGameDllDelete(void)
{
#ifdef ZONECLI_DLL
	GameGlobals pGameGlobals = (GameGlobals) ZGetGameGlobalPointer();
	if (pGameGlobals != NULL)
	{
		ZSetGameGlobalPointer(NULL);
		ZFree(pGameGlobals);
	}
#endif
}



ZError ZoneClientMain( _TUCHAR *commandLineData, IGameShell *piGameShell )
{
#ifdef ZONECLI_DLL
	GameGlobals	pGameGlobals = (GameGlobals) ZGetGameGlobalPointer();
#endif

	ZError err = zErrNone;
/*
	// Copy Help URL
	lstrcpy( gHelpURL, (TCHAR*) commandLineData );
*/	
	// Initialize room
	err = ZClient2PlayerRoom(
				gGameServerName,
				(uint16) gGameServerPort,
				gGameName,
				GetObjectFunc,
				DeleteObjectsFunc, 
				NULL );
	return (err);
}



extern "C" void ZoneClientExit(void)
{
	ZCRoomExit();
}



extern "C" TCHAR* ZoneClientName(void)
{
#ifdef ZONECLI_DLL
	GameGlobals pGameGlobals = (GameGlobals) ZGetGameGlobalPointer();
#endif

	return (gGameName);
}



extern "C" TCHAR* ZoneClientInternalName(void)
{
#ifdef ZONECLI_DLL
	GameGlobals	pGameGlobals = (GameGlobals) ZGetGameGlobalPointer();
#endif

	return (gGameDir);
}



extern "C" ZVersion ZoneClientVersion(void)
{
	return (zGameVersion);
}



extern "C" void ZoneClientMessageHandler(ZMessage* message)
{
}


// Instantiates a new game on the client side of the game at table and from the
// given seat. PlayerType indicates the type of player for the game: originator - one
// of the original players, joiner - one who joins an ongoing game, or kibitzer - one
// who is kibitzing the game. Also, the kibitzers parameters contains all the kibitzers
// at the given table and seat; it includes the given player also if kibitzing.
extern "C" IGameGame* ZoneClientGameNew( ZUserID userID, int16 tableID, int16 seat, int16 playerType, ZRoomKibitzers* kibitzers)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals	 = (GameGlobals)      ZGetGameGlobalPointer();
	ClientDllGlobals	pClientGlobals	 = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif

	HRESULT hr;
//Game* pGame;

	gOCXHandle = pClientGlobals->m_OCXHandle;

    CComObject<CGame> *pIGG = NULL;
    hr = CComObject<CGame>::CreateInstance(&pIGG);

    if(FAILED(hr))
        return NULL;
	/*
	// Create game object
	pGame = new CGame( ghInstance );
	if ( !pGame )
		return NULL;
	*/
	// Initialize game object
	hr = pIGG->Init( ghInstance, userID, tableID, seat, playerType, kibitzers );
	if ( FAILED(hr) )
	{
		pIGG->Release();
		/*		
		delete pGame;
		*/
		return NULL;
	}
	/*
    IGameGame *pIGG = CGameGameDefault::BearInstance(pGame);
    if(!pIGG)
    {
        delete pGame;
        return NULL;
    }
	*/
	return pIGG;
}



extern "C" void	ZoneClientGameDelete(ZCGame cgame)
{
	CGame* pGame = (CGame*) cgame;
	pGame->RoomShutdown();	
}



extern "C" void ZoneClientGameAddKibitzer(ZCGame game, int16 seat, ZUserID userID)
{
	CGame* pGame = (CGame*) game;

	if ( game )
		pGame->AddKibitzer( seat, userID, TRUE );
}



extern "C" void ZoneClientGameRemoveKibitzer(ZCGame game, int16 seat, ZUserID userID)
{
	CGame* pGame = (CGame*) game;

	if ( game )
		pGame->RemoveKibitzer( seat, userID );
}



extern "C" ZBool ZoneClientGameProcessMessage(ZCGame gameP, uint32 messageType, void* message, int32 messageLen)
{
	CGame* pGame = (CGame*) gameP;
	
	switch( messageType )
	{
	case zGameMsgCheckIn:
		pGame->HandleCheckIn( message, messageLen );
		break;
	case zBGMsgTalk:
		pGame->HandleTalk( message, messageLen );
		break;
	case zBGMsgDiceRoll:
		pGame->HandleDiceRoll(message,messageLen);
        break;
	default:
		pGame->QueueMessage( messageType, (BYTE*) message, messageLen );
		break;
	}
	return TRUE;
}



void LaunchHelp()
{
	ZLaunchHelp(zGameHelpID);
}



/*
#define REGISTRY_PATH	_T("SOFTWARE\\Microsoft\\Internet Gaming Zone")
BOOL ZoneGetRegistryDword( const TCHAR* szGame, const TCHAR* szTag, DWORD* pdwResult )
{
	HKEY hKey;
	DWORD bytes;
	long status;
	TCHAR buff[2048];

	// get key to registry
	wsprintf( buff, _T("%s\\%s"), REGISTRY_PATH, szGame );
	status = RegOpenKeyEx( HKEY_CURRENT_USER, buff, 0, KEY_READ, &hKey );
	if (status != ERROR_SUCCESS)
		return FALSE;
	bytes = sizeof(DWORD);
	status = RegQueryValueEx( hKey, szTag, 0, NULL, (BYTE*) pdwResult, &bytes );

	// close registry
	RegCloseKey( hKey );
	return (status != ERROR_SUCCESS) ? FALSE : TRUE;
}



BOOL ZoneSetRegistryDword( const TCHAR* szGame, const TCHAR* szTag, DWORD dwValue )
{
	HKEY hKey;
	DWORD bytes;
	long status;
	TCHAR buff[2048];

	// create top level application key
	wsprintf( buff, _T("%s\\%s"), REGISTRY_PATH, szGame );
	status = RegCreateKeyEx(
				HKEY_CURRENT_USER,
				buff,
				0,
				_T("User Settings"),
				REG_OPTION_NON_VOLATILE,
				KEY_ALL_ACCESS,
				NULL,
				&hKey,
				&bytes );
	if (status != ERROR_SUCCESS)
		return FALSE;

	// write value
	status = RegSetValueEx( hKey, szTag, 0, REG_DWORD, (BYTE*) &dwValue, sizeof(DWORD) );

	// close registry
	RegCloseKey( hKey );
	return (status != ERROR_SUCCESS) ? FALSE : TRUE;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\games\backgammon\backgammon.h ===
#ifndef __BG_H__
#define __BG_H__

//#include "chat.h"
#include "bgmsgs.h"
#include "resource.h"
#include "backgammonres.h"
#include "UAPI.h"
#include "tchar.h"

// Constants
const int zNumPlayersPerTable	= 2;
const int zGameVersion			= 0x00010000;

extern HWND gOCXHandle;

// prototypes
void LaunchHelp();
//BOOL ZoneGetRegistryDword( const TCHAR* szGame, const TCHAR* szTag, DWORD* pdwResult );
//BOOL ZoneSetRegistryDword( const TCHAR* szGame, const TCHAR* szTag, DWORD dwValue );
void DisplayError(long res);

inline DWORD BkFormatMessage(LPTSTR pszFormat, LPTSTR pszBuffer, DWORD size,  ...)
{
    	TCHAR szBuff[MAX_PATH];; 
    	va_list vl;
		va_start(vl,size);
		DWORD result=FormatMessage(FORMAT_MESSAGE_FROM_STRING,pszFormat,0,GetUserDefaultLangID(),pszBuffer,size,&vl);
		va_end(vl);
		return result;			
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\games\backgammon\bgdlgs.h ===
#ifndef __BGDLGS_H__
#define __BGDLGS_H__

#include "game.h"
/*
class CGameSetupDlg : public CDialog
{
public:
	CGameSetupDlg(); 

	HRESULT Init( IResourceManager *pResourceManager, int nResourceId, CGame* pGame, BOOL bReadOnly, int nPoints, BOOL bHostBrown, BOOL bAutoDouble );

	void UpdateSettings( int nPoints, BOOL bHostBrown, BOOL bAutoDouble );
	
	// Message handling
	BEGIN_DIALOG_MESSAGE_MAP( CGameSetupDlg );
		ON_MESSAGE( WM_INITDIALOG, OnInitDialog );
		ON_DLG_MESSAGE( WM_COMMAND, OnCommand );
		ON_DLG_MESSAGE( WM_DESTROY, OnDestroy );
	END_DIALOG_MESSAGE_MAP();

	BOOL OnInitDialog(HWND hwndFocus);
	void OnCommand(int id, HWND hwndCtl, UINT codeNotify);
	void OnDestroy();

public:
	int		m_nPoints;
	int		m_nPointsTmp;
	int		m_nPointsMin;
	int		m_nPointsMax;
	BOOL	m_bHostBrown;
	BOOL	m_bHostBrownTmp;
	BOOL	m_bAutoDouble;
	BOOL	m_bAutoDoubleTmp;
	BOOL	m_bReadOnly;
	CGame*	m_pGame;
};
*/

///////////////////////////////////////////////////////////////////////////////

class CAcceptDoubleDlg : public CDialog
{
public:
	CAcceptDoubleDlg();

	HRESULT Init( IZoneShell* pZoneShell, int nResourceId, CGame* pGame, int nPoints );

	// Message handling
	BEGIN_DIALOG_MESSAGE_MAP( CAcceptDoubleDlg );
		ON_MESSAGE( WM_INITDIALOG, OnInitDialog );
		ON_DLG_MESSAGE( WM_COMMAND, OnCommand );
		ON_DLG_MESSAGE( WM_DESTROY, OnDestroy );		
	END_DIALOG_MESSAGE_MAP();

	BOOL OnInitDialog(HWND hwndFocus);
	void OnCommand(int id, HWND hwndCtl, UINT codeNotify);	
	void OnDestroy();

public:
	int		m_nPoints;
	CGame*	m_pGame;
};

///////////////////////////////////////////////////////////////////////////////

class CRollDiceDlg : public CDialog
{
public:
	BEGIN_DIALOG_MESSAGE_MAP( CRollDiceDlg );
		ON_MESSAGE( WM_INITDIALOG, OnInitDialog );
		ON_DLG_MESSAGE( WM_COMMAND, OnCommand );
		ON_DLG_MESSAGE( WM_DESTROY, OnDestroy );
	END_DIALOG_MESSAGE_MAP();

	BOOL OnInitDialog(HWND hwndFocus);
	void OnCommand(int id, HWND hwndCtl, UINT codeNotify);
	void OnDestroy();

public:
	int m_Dice[2];
};

///////////////////////////////////////////////////////////////////////////////
/*
class CAboutDlg : public CDialog
{
public:
	// Message handling
	BEGIN_DIALOG_MESSAGE_MAP( CAboutDlg );
		ON_MESSAGE( WM_INITDIALOG, OnInitDialog );
		ON_DLG_MESSAGE( WM_COMMAND, OnCommand );
		ON_DLG_MESSAGE( WM_DESTROY, OnDestroy );
	END_DIALOG_MESSAGE_MAP();

	BOOL OnInitDialog(HWND hwndFocus);
	void OnCommand(int id, HWND hwndCtl, UINT codeNotify);
	void OnDestroy();
};

///////////////////////////////////////////////////////////////////////////////

class CRestoreDlg : public CDialog
{
public:
	HRESULT Init( IZoneShell* pZoneShell, int nResourceId, TCHAR* opponentName );

	// Message handling
	BEGIN_DIALOG_MESSAGE_MAP( CRestoreDlg );
		ON_MESSAGE( WM_INITDIALOG, OnInitDialog );
		ON_DLG_MESSAGE( WM_COMMAND, OnCommand );
		ON_DLG_MESSAGE( WM_DESTROY, OnDestroy );
	END_DIALOG_MESSAGE_MAP();

	BOOL OnInitDialog(HWND hwndFocus);
	void OnCommand(int id, HWND hwndCtl, UINT codeNotify);
	void OnDestroy();

protected:
	TCHAR	m_Name[128];
};

///////////////////////////////////////////////////////////////////////////////

class CExitDlg : public CDialog
{
public:
	// Message handling
	BEGIN_DIALOG_MESSAGE_MAP( CExitDlg );
		ON_MESSAGE( WM_INITDIALOG, OnInitDialog );
		ON_DLG_MESSAGE( WM_COMMAND, OnCommand );
		ON_DLG_MESSAGE( WM_DESTROY, OnDestroy );
	END_DIALOG_MESSAGE_MAP();

	BOOL OnInitDialog(HWND hwndFocus);
	void OnCommand(int id, HWND hwndCtl, UINT codeNotify);
	void OnDestroy();
};
*/
///////////////////////////////////////////////////////////////////////////////

class CResignDlg : public CDialog
{
public:
	HRESULT Init( IZoneShell* pZoneShell, int nResourceId, int pts, CGame* pGame );
	

	BEGIN_DIALOG_MESSAGE_MAP( CResignDlg );
		ON_MESSAGE( WM_INITDIALOG, OnInitDialog );
		ON_DLG_MESSAGE( WM_COMMAND, OnCommand );
		ON_DLG_MESSAGE( WM_DESTROY, OnDestroy );
	END_DIALOG_MESSAGE_MAP();

	BOOL OnInitDialog(HWND hwndFocus);
	void OnCommand(int id, HWND hwndCtl, UINT codeNotify);
	void OnDestroy();

protected:
	int			m_Points;
	CGame*		m_pGame;
};

///////////////////////////////////////////////////////////////////////////////

class CResignAcceptDlg : public CDialog
{
public:
	HRESULT Init(IZoneShell* pZoneShell, int nResourceId, int pts, CGame* pGame );
	
	BEGIN_DIALOG_MESSAGE_MAP( CResignAcceptDlg );
		ON_MESSAGE( WM_INITDIALOG, OnInitDialog );
		ON_DLG_MESSAGE( WM_COMMAND, OnCommand );
		ON_DLG_MESSAGE( WM_DESTROY, OnDestroy );
	END_DIALOG_MESSAGE_MAP();

	BOOL OnInitDialog(HWND hwndFocus);
	void OnCommand(int id, HWND hwndCtl, UINT codeNotify);
	void OnDestroy();

protected:
	int			m_Points;
	CGame*		m_pGame;
};

#endif //!__BGDLGS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\games\backgammon\bgdlgs.cpp ===
#include "game.h"
#include <commctrl.h>

/*
CGameSetupDlg::CGameSetupDlg()
{
	m_pGame = NULL;
	m_nPoints = 1;
	m_nPointsMin = 1;
	m_nPointsMax = 200;
	m_nPointsTmp = 0;
	m_bHostBrownTmp = FALSE;
	m_bHostBrown = FALSE;
	m_bAutoDouble = FALSE;
	m_bAutoDoubleTmp = FALSE;
	m_bReadOnly = FALSE;
}


HRESULT CGameSetupDlg::Init( IResourceManager* pResourceManager, int nResourceId, CGame* pGame, BOOL bReadOnly, int nPoints, BOOL bHostBrown, BOOL bAutoDouble )
{
	// Game pointer
	m_pGame = pGame;
	m_pGame->AddRef();

	// Dialog parameters
	m_nPoints = nPoints;
	m_bAutoDouble = bAutoDouble;
	m_bHostBrown = bHostBrown;

	// Tmp copies
	m_nPointsTmp = nPoints;
	m_bHostBrownTmp = bHostBrown;
	m_bAutoDoubleTmp = bAutoDouble;
	
	// Passive mode
	m_bReadOnly = bReadOnly;

	// Initialize parent class
	return CDialog::Init( pResourceManager, nResourceId );
}


void CGameSetupDlg::UpdateSettings( int nPoints, BOOL bHostBrown, BOOL bAutoDouble )
{
	if ( !IsAlive() )
		return;
	m_nPoints = nPoints;
	SetDlgItemInt( m_hWnd, IDC_POINTS, nPoints, FALSE );
	m_bHostBrown = bHostBrown;
	SendDlgItemMessage( m_hWnd, IDC_BROWN, BM_SETCHECK, (WPARAM)(bHostBrown ? BST_CHECKED : BST_UNCHECKED), 0);
	m_bAutoDouble = bAutoDouble;
	SendDlgItemMessage( m_hWnd, IDC_AUTO, BM_SETCHECK, (WPARAM)(bAutoDouble ? BST_CHECKED : BST_UNCHECKED), 0);
}


void CGameSetupDlg::OnDestroy()
{
	// release game object
	m_pGame->Release();
	m_pGame = NULL;

	// restore focus to parent
	SetForegroundWindow( GetParent(m_hWnd) );
}


BOOL CGameSetupDlg::OnInitDialog( HWND hwndFocus )
{
	
	HWND hwnd;
	int i;
	int Indexs[] = { IDC_POINTS, IDC_POINTS_TAG, IDC_POINTS_UPDOWN, IDC_BROWN, IDC_AUTO, IDOK, IDRESET, IDCANCEL };

	// restore window
	ShowWindow( GetParent(m_hWnd), SW_RESTORE );

	// center dialog against backgammon window
	CenterWindow( GetParent(m_hWnd) );

	// Initialize spin control
	CreateUpDownControl(
			WS_CHILD | WS_BORDER | WS_VISIBLE | UDS_WRAP | UDS_ARROWKEYS | UDS_ALIGNRIGHT | UDS_SETBUDDYINT | UDS_NOTHOUSANDS,
			0, 0,
			8, 8,
			m_hWnd,
			IDC_POINTS_UPDOWN,
			m_hInstance,
			GetDlgItem( m_hWnd, IDC_POINTS ),
			m_nPointsMax,
			m_nPointsMin,
			m_nPoints );
	
	// Initialize color check
	SendDlgItemMessage( m_hWnd, IDC_BROWN, BM_SETCHECK, (WPARAM)(m_bHostBrown ? BST_CHECKED : BST_UNCHECKED), 0);

	// Initialize auto double check
	SendDlgItemMessage( m_hWnd, IDC_AUTO, BM_SETCHECK, (WPARAM)(m_bAutoDouble ? BST_CHECKED : BST_UNCHECKED), 0);

	
	if (m_bReadOnly)
	{
		// Disable everything if read-only
		for (i = 0; i < (sizeof(Indexs)/sizeof(int)) ; i++)
		{
			hwnd = GetDlgItem( m_hWnd, Indexs[i] );
			EnableWindow( hwnd, FALSE );
		}
	}
	else
	{
		// Disable buttons until clients sync'd
		if ( !m_pGame->m_SharedState.Get( bgSettingsReady ) )
		{
			EnableWindow( GetDlgItem( m_hWnd, IDOK ), FALSE );
			EnableWindow( GetDlgItem( m_hWnd, IDCANCEL ), FALSE );
		}

		// Sync dialog boxes
		SendMessage( m_hParent, WM_BG_SETTINGDLG_SEND, 0, 0 ); 
	}
	
	return TRUE;
}


void CGameSetupDlg::OnCommand( int id, HWND hwndCtl, UINT codeNotify )
{
	
	TCHAR buff[64];
	int points;
	BOOL update = FALSE;
	BOOL brown = (SendDlgItemMessage( m_hWnd, IDC_BROWN, BM_GETCHECK, 0, 0 ) == BST_CHECKED);
	BOOL autod = (SendDlgItemMessage( m_hWnd, IDC_AUTO, BM_GETCHECK, 0, 0 ) == BST_CHECKED);
	
	switch( id )
	{
	case IDC_POINTS:
		// don't allow leading zeros
		GetDlgItemText( m_hWnd, IDC_POINTS, buff, sizeof(buff) );
		if ( buff[0] == _T('0') )
		{
			SetDlgItemInt( m_hWnd, IDC_POINTS, m_nPointsTmp, FALSE );
			SendMessage( GetDlgItem( m_hWnd, IDC_POINTS ), EM_SETSEL, (WPARAM)(INT)32767, (LPARAM)(INT)32767 );
			SendMessage( GetDlgItem( m_hWnd, IDC_POINTS ), EM_SCROLLCARET, 0, 0 );
			points = m_nPointsTmp;
		}
		else
			points = GetDlgItemInt( m_hWnd, IDC_POINTS, NULL, TRUE );

		// don't allow numbers greater than m_nPointsMax
		if ((points < m_nPointsMin) || (points > m_nPointsMax))
		{
			SetDlgItemInt( m_hWnd, IDC_POINTS, m_nPointsTmp, FALSE );
			SendMessage( GetDlgItem( m_hWnd, IDC_POINTS ), EM_SETSEL, (WPARAM)(INT)32767, (LPARAM)(INT)32767 );
			SendMessage( GetDlgItem( m_hWnd, IDC_POINTS ), EM_SCROLLCARET, 0, 0 );
			points = m_nPointsTmp;
		}

		// points changed?
		if ( m_nPointsTmp != points )
		{
			m_nPointsTmp = points;
			update = TRUE;
		}
		break;
	case IDC_AUTO:
		if ( m_bAutoDoubleTmp != autod )
		{
			m_bAutoDoubleTmp = autod;
			update = TRUE;
		}
	case IDC_BROWN:
		if ( m_bHostBrownTmp != brown )
		{
			m_bHostBrownTmp = brown;
			update = TRUE;
		}
		break;
	case IDOK:
		m_bHostBrown = brown;
		m_bAutoDouble = autod;
		m_nPoints = GetDlgItemInt( m_hWnd, IDC_POINTS, NULL, TRUE );
		Close( 1 );
		break;
	case IDRESET:
		SetDlgItemInt( m_hWnd, IDC_POINTS, 1, FALSE );
		SendDlgItemMessage( m_hWnd, IDC_BROWN, BM_SETCHECK, FALSE, 0);
		SendDlgItemMessage( m_hWnd, IDC_AUTO, BM_SETCHECK, FALSE, 0);
		m_nPointsTmp = 1;
		m_bHostBrownTmp = FALSE;
		m_bAutoDoubleTmp = FALSE;
		update = TRUE;
		break;
	case IDCANCELMATCH:
		Close( 2 );
		break;
	}

	if ( update )
		SendMessage( m_hParent, WM_BG_SETTINGDLG_SEND, 0, 0 ); 
	
}
*/
///////////////////////////////////////////////////////////////////////////////

CAcceptDoubleDlg::CAcceptDoubleDlg()
{
	m_pGame = NULL;
	m_nPoints = 0;
}

HRESULT CAcceptDoubleDlg::Init( IZoneShell* pZoneShell, int nResourceId, CGame* pGame, int nPoints )
{
	// Stash params
	m_pGame = pGame;
	m_pGame->AddRef();
	m_nPoints = nPoints;

	// Initialize parent class
	return CDialog::Init( pZoneShell, nResourceId );
}

BOOL CAcceptDoubleDlg::OnInitDialog(HWND hwndFocus)
{
	TCHAR in[512];
	TCHAR out[512];

	// restore window
	ShowWindow( GetParent(m_hWnd), SW_RESTORE );

	// initialize controls
	SetFocus( GetDlgItem( m_hWnd, IDC_DUMMY_BUTTON ) );
	GetDlgItemText( m_hWnd, IDC_ACCEPT_MESSAGE, in, NUMELEMENTS(in) );
	BkFormatMessage( in, out, 512, m_nPoints >> 1 );
	SetDlgItemText( m_hWnd, IDC_ACCEPT_MESSAGE, out );
	CenterWindow( GetParent(m_hWnd) );
	return FALSE;
}

void CAcceptDoubleDlg::OnDestroy()
{
	// release game object
	m_pGame->Release();
	m_pGame = NULL;

	// restore focus to parent
	SetForegroundWindow( GetParent(m_hWnd) );
}

void CAcceptDoubleDlg::OnCommand(int id, HWND hwndCtl, UINT codeNotify)
{
	switch (id )
	{

		case IDNO:
				// rejected double, game's over
				m_pGame->m_SharedState.StartTransaction( bgTransStateChange );
					m_pGame->m_SharedState.Set( bgState, bgStateGameOver );
					m_pGame->m_SharedState.Set( bgGameOverReason, bgGameOverDoubleRefused );
					m_pGame->m_SharedState.Set( bgActiveSeat, m_pGame->m_Opponent.m_Seat );
				m_pGame->m_SharedState.SendTransaction( TRUE );
				Close(1);
				break;
		case IDOK:
				// accepted double
				ZBGMsgEndTurn msg;
				msg.seat = m_pGame->m_Seat;
				m_pGame->RoomSend( zBGMsgEndTurn, &msg, sizeof(msg) );
				//
				m_pGame->m_SharedState.StartTransaction( bgTransAcceptDouble );
					m_pGame->m_SharedState.Set( bgCubeValue, m_nPoints );
					m_pGame->m_SharedState.Set( bgCubeOwner, m_pGame->m_Player.GetColor() );
				m_pGame->m_SharedState.SendTransaction( TRUE );
				Close(1);
				break;
		break;
	}
}

///////////////////////////////////////////////////////////////////////////////


BOOL CRollDiceDlg::OnInitDialog( HWND hwndFocus )
{
	TCHAR buff[32];

	// restore window
	ShowWindow( GetParent(m_hWnd), SW_RESTORE );

	// initialize controls
	for( int i = 1; i <= 6; i++ )
	{
		wsprintf( buff, _T("%d"), i );
		SendDlgItemMessage( m_hWnd, IDC_DICE_ONE, CB_ADDSTRING, 0, (LPARAM) buff );
		SendDlgItemMessage( m_hWnd, IDC_DICE_TWO, CB_ADDSTRING, 0, (LPARAM) buff );
	}
	SendDlgItemMessage( m_hWnd, IDC_DICE_ONE, CB_SETCURSEL, 5, 0 );
	SendDlgItemMessage( m_hWnd, IDC_DICE_TWO, CB_SETCURSEL, 5, 0 );
	return TRUE;
}


void CRollDiceDlg::OnCommand(int id, HWND hwndCtl, UINT codeNotify)
{
	HWND hwnd;
	TCHAR buff[16];
	int idx;

	switch( id )
	{
	case IDOK:

		// dice 0
		idx = SendDlgItemMessage( m_hWnd, IDC_DICE_ONE, CB_GETCURSEL, 0, 0 );
		if ( idx != CB_ERR )
			m_Dice[0] = idx + 1;
		else
		{
			hwnd = GetDlgItem( m_hWnd, IDC_DICE_ONE );
			GetWindowText( hwnd, buff, sizeof(buff) );
			buff[1] = _T('\0');
			m_Dice[0] = _ttoi(buff);
		}
		if (m_Dice[0] < 1)
			m_Dice[0] = 1;
		else if (m_Dice[0] > 6)
			m_Dice[0] = 6;
		
		// dice 1
		idx = SendDlgItemMessage( m_hWnd, IDC_DICE_TWO, CB_GETCURSEL, 0, 0 );
		if ( idx != CB_ERR )
			m_Dice[1] = idx + 1;
		else
		{
			hwnd = GetDlgItem( m_hWnd, IDC_DICE_TWO );
			GetWindowText( hwnd, buff, NUMELEMENTS(buff) );
			buff[1] = _T('\0');
			m_Dice[1] = _ttoi(buff);
		}
		if (m_Dice[1] < 1)
			m_Dice[1] = 1;
		else if (m_Dice[1] > 6)
			m_Dice[1] = 6;

		Close( TRUE );
		break;
	case IDCANCEL:
		Close( FALSE );
		break;
	}
	
}


void CRollDiceDlg::OnDestroy()
{
	// restore focus to parent
	SetForegroundWindow( GetParent(m_hWnd) );
}

///////////////////////////////////////////////////////////////////////////////
// About box
///////////////////////////////////////////////////////////////////////////////
/*
BOOL CAboutDlg::OnInitDialog(HWND hwndFocus)
{
	/*
	TCHAR key[512], buff[512];
	TCHAR* pKeyEnd = NULL;
	TCHAR* data = NULL;
	char* pData;
	DWORD size, tmp;

	// restore window
	ShowWindow( GetParent(m_hWnd), SW_RESTORE );

	CenterWindow( GetWindow( m_hWnd, GW_OWNER) );
	GetModuleFileName( m_hInstance, buff, sizeof(buff) );
	size = GetFileVersionInfoSize( buff, &tmp );
	if ( !size )
		return FALSE;
	data = new char[ size ];
	if ( !data )
		return FALSE;
	if ( !GetFileVersionInfo( buff, 0, size, data ) )
	{
		delete [] data;
		return FALSE;
	}
	LoadString( m_hInstance, IDS_VERSION, key, sizeof(key) );
	pKeyEnd = &key[ lstrlen( key ) ];
	
	// file description
	lstrcpy( pKeyEnd, "FileDescription" );
	if ( VerQueryValue( data, key, (void**) &pData, (UINT*) &size ) )
		SetDlgItemText( m_hWnd, IDC_DESCRIPTION, pData );

	// Version
	lstrcpy( pKeyEnd, "FileVersion" );
	if ( VerQueryValue( data, key, (void**) &pData, (UINT*) &size ) )
		SetDlgItemText( m_hWnd, IDC_VERSION, pData );

	// copyright
	lstrcpy( pKeyEnd, "LegalCopyright" );
	if ( VerQueryValue( data, key, (void**) &pData, (UINT*) &size ) )
		SetDlgItemText( m_hWnd, IDC_COPYRIGHT, pData );

	delete [] data;
	
	return TRUE;

}


void CAboutDlg::OnCommand(int id, HWND hwndCtl, UINT codeNotify)
{
	
	if ( id == IDOK )
		Close( 0 );
		
}

void CAboutDlg::OnDestroy()
{
	
	// restore focus to parent
	SetForegroundWindow( GetParent(m_hWnd) );
	
}
*/
///////////////////////////////////////////////////////////////////////////////
/*
HRESULT CRestoreDlg::Init( IResourceManager *pResourceManager, int nResourceId, TCHAR* opponentName )
{
	lstrcpy( m_Name, opponentName );
	return CDialog::Init( pResourceManager, nResourceId );
}


BOOL CRestoreDlg::OnInitDialog( HWND hwndFocus )
{
	
	char msg[1024], buff[1024];
	
	// restore window
	ShowWindow( GetParent(m_hWnd), SW_RESTORE );

	// init controls
	GetDlgItemText( m_hWnd, IDC_RESTORE_MSG, buff, sizeof(buff) );
	wsprintf( msg, buff, m_Name );
	SetDlgItemText( m_hWnd, IDC_RESTORE_MSG, msg );
	CenterWindow( GetParent(m_hWnd) );
	
	return FALSE;
}


void CRestoreDlg::OnCommand( int id, HWND hwndCtl, UINT codeNotify )
{
	
	switch (id)
	{
	case IDOK:
		Close( IDOK );
		break;
	case IDCANCEL:
		Close( IDCANCEL );
		break;
	}
	
}


void CRestoreDlg::OnDestroy()
{
	// restore focus to parent
	SetForegroundWindow( GetParent(m_hWnd) );
}

///////////////////////////////////////////////////////////////////////////////

BOOL CExitDlg::OnInitDialog( HWND hwndFocus )
{
	TCHAR buff[1024];

	// restore window
	ShowWindow( GetParent(m_hWnd), SW_RESTORE );

	// center window
	CenterWindow( GetParent(m_hWnd) );

	// init controls
	
	LoadString( m_hInstance, IDS_EXIT_INITIATE, buff, sizeof(buff) );
	SetDlgItemText( m_hWnd, IDC_MESSAGE_TXT, buff );
	
	return FALSE;
}


void CExitDlg::OnCommand( int id, HWND hwndCtl, UINT codeNotify )
{
	Close( id );
}


void CExitDlg::OnDestroy()
{
	// restore focus to parent
	SetForegroundWindow( GetParent(m_hWnd) );
}
*/
///////////////////////////////////////////////////////////////////////////////

HRESULT CResignDlg::Init( IZoneShell* pZoneShell, int nResourceId, int pts, CGame* pGame )
{
	// stash cube value
	ASSERT( pts > 0 );
	m_Points = pts;

	m_pGame = pGame;

	// parent init
	return CDialog::Init( pZoneShell, nResourceId );
}

BOOL CResignDlg::OnInitDialog( HWND hwndFocus )
{
	TCHAR in[128], out[128];

	// restore window
	ShowWindow( GetParent(m_hWnd), SW_RESTORE );

	// set cube text
	GetDlgItemText( m_hWnd, IDC_CUBE, in, NUMELEMENTS(in) );
	BkFormatMessage( in, out, 128, m_Points );
	SetDlgItemText( m_hWnd, IDC_CUBE, out );

	// set gammon text
	GetDlgItemText( m_hWnd, IDC_GAMMON, in, NUMELEMENTS(in) );
	BkFormatMessage( in, out, 128, 2 * m_Points );
	SetDlgItemText( m_hWnd, IDC_GAMMON, out );
	
	// set backgammon text
	GetDlgItemText( m_hWnd, IDC_BACKGAMMON, in, NUMELEMENTS(in) );
	BkFormatMessage( in, out, 128, 3 * m_Points );
	SetDlgItemText( m_hWnd, IDC_BACKGAMMON, out );

	// cancel gets focus
	SetFocus( GetDlgItem( m_hWnd, IDCANCEL ) );

	// center dialog
	CenterWindow( GetParent(m_hWnd) );

	
	m_pGame->OnResignStart();


	return FALSE;
}


void CResignDlg::OnCommand( int id, HWND hwndCtl, UINT codeNotify )
{
	switch ( id )
	{
	case IDC_CUBE:
		Close( m_Points );
		break;
	case IDC_GAMMON:
		Close( 2 * m_Points );
		break;
	case IDC_BACKGAMMON:
		Close( 3 * m_Points );
		break;
	case IDCANCEL:
		Close( 0 );
		break;
	}
}


void CResignDlg::OnDestroy()
{
	m_pGame->OnResignEnd();
		
	// restore focus to parent
	SetForegroundWindow( GetParent(m_hWnd) );

	
}

///////////////////////////////////////////////////////////////////////////////

HRESULT CResignAcceptDlg::Init( IZoneShell* pZoneShell, int nResourceId, int pts, CGame* pGame )
{
	// stash cube value
	ASSERT( pts > 0 );
	m_Points = pts;

	m_pGame = pGame;

	// parent init
	return CDialog::Init( pZoneShell, nResourceId );
}


BOOL CResignAcceptDlg::OnInitDialog( HWND hwndFocus )
{
	TCHAR in[128], out[128];

	// restore window
	ShowWindow( GetParent(m_hWnd), SW_RESTORE );

	// set text
	GetDlgItemText( m_hWnd, IDC_RESIGN_TEXT, in, NUMELEMENTS(in) );
	BkFormatMessage( in, out, 128, m_Points );
	SetDlgItemText( m_hWnd, IDC_RESIGN_TEXT, out );

	// center dialog
	CenterWindow( GetParent(m_hWnd) );

	m_pGame->OnResignStart();
	
	return TRUE;
}


void CResignAcceptDlg::OnCommand( int id, HWND hwndCtl, UINT codeNotify )
{
	switch ( id )
	{
	case IDOK:
		Close( IDOK );
		break;
	case IDCANCEL:
		Close( IDCANCEL );
		break;
	}
}


void CResignAcceptDlg::OnDestroy()
{
	// restore focus to parent
	SetForegroundWindow( GetParent(m_hWnd) );

	m_pGame->OnResignAcceptEnd();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\games\backgammon\boarddata.h ===
// Shared board state is from white's perspective. ( pieces 0 - 14 are white, 15 - 29 are brown )
static int InitPiecePositions[30] =
{
	5,		// W0
	5,		// W1
	5,		// W2
	5,		// W3
	5,		// W4
	7,		// W5
	7,		// W6
	7,		// W7
	12,		// W8
	12,		// W9
	12,		// W10
	12,		// W11
	12,		// W12
	23,		// W13
	23,		// W14

	0,		// B0
	0,		// B1
	11,		// B2
	11,		// B3
	11,		// B4
	11,		// B5
	11,		// B6
	16,		// B7
	16,		// B8
	16,		// B9
	18,		// B10
	18,		// B11
	18,		// B12
	18,		// B13
	18,		// B14
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\games\backgammon\bgwnd.cpp ===
//Release new stuff!!

#include "zoneresids.h"
#include "game.h"
#include "moves.h"
#include <time.h>
#include "SpriteData.h"
#include <winuser.h>
#define WS_EX_LAYOUTRTL         0x00400000L  // Right to left mirroring
#include "zonecli.h"

#ifndef LAYOUT_RTL
#define LAYOUT_LTR                         0x00000000
#define LAYOUT_RTL                         0x00000001
#define NOMIRRORBITMAP                     0x80000000
#endif

#include "zoneutil.h"

typedef DWORD (CALLBACK* GDISETLAYOUTPROC)(HDC, DWORD);
//GDISETLAYOUTPROC SetLayout;

static const BYTE _arbTransparent8 = 253;
#define TRANSPARENT_IDX_8 (&_arbTransparent8)

static const BYTE _arbTransparent24[] = { 255, 0, 255 };
#define TRANSPARENT_IDX_24 _arbTransparent24

#define TRANSPARENT_IDX		253
#define	MOVE_INTERVAL		0.05
#define	STATUS_INTERVAL		500
#define MAX_BUFFER			256

//static const int MenuIndexs[] = { ID_GAME_NEWMATCH, ID_GAME_SETTINGS };

//////////////////////////////////////////////////////////////////////////////
// PointDisplay implementation
///////////////////////////////////////////////////////////////////////////////

PointDisplay::PointDisplay()
	: rect( -1, -1, -1, -1 )
{
	nPieces = 0;
}


int PointDisplay::GetColor()
{
	if ( nPieces <= 0 )
		return zBoardNeutral;
	else if ( pieces[0] < 15 )
		return zBoardWhite;
	else
		return zBoardBrown;
}


//////////////////////////////////////////////////////////////////////////////
// CBGWnd implementation
///////////////////////////////////////////////////////////////////////////////

CBGWnd::CBGWnd()
{
	
	m_OldDoubleState   = -1;
	m_OldResignState   = -1;
	m_OldRollState     = -1;
	m_nAnimatingPieces = 0;

	m_hMovementTimer = NULL;
	m_hDiceTimer     = NULL;
	m_hStatusTimer   = NULL;

	m_hBrush		  = NULL;
	m_pPieceDragging  = NULL;
	m_WorldBackground = NULL;

	m_Backbuffer   = NULL;
	m_Background   = NULL;
	m_StatusDlgBmp = NULL;

	m_Cube   = NULL;
	m_Double = NULL;
	m_Resign = NULL;
	m_Roll   = NULL;
	m_Status = NULL;

	m_BackwardDiamond = NULL;
	m_MatchTxt		  = NULL;

	for ( int i = 0; i < 4; i++ )
		m_Dice[i] = NULL;
	for ( i = 0; i < 30; i++ )
		m_Pieces[i] = NULL;
	for ( i = 0; i < 2; i++ )
	{
		m_Kibitzers[i]		= NULL;
		m_ForwardDiamond[i] = NULL;
		m_Names[i]			= NULL;
		m_Pip[i]			= NULL;
		m_PipTxt[i]			= NULL;
		m_Score[i]			= NULL;
		m_ScoreTxt[i]		= NULL;
	}
	for ( i = 0; i < 4; i++ )
		m_Notation[i] = NULL;

	m_fDiceRollReceived = FALSE;

	m_nRecievedD1 = -1;
	m_nRecievedD2 = -1;

	
	m_hCursorActive = NULL;

}


CBGWnd::~CBGWnd()
{
	// clean up window state
	DragEnd();

	// release brushes
	if ( m_hBrush )
		DeleteObject( m_hBrush );

	// release bitmaps
	if ( m_Backbuffer )
		m_Backbuffer->Release();
	if ( m_WorldBackground )
		m_WorldBackground->Release();
	if ( m_Background )
		m_Background->Release();
	if ( m_StatusDlgBmp )
		m_StatusDlgBmp->Release();

	// release sprites
	if ( m_Status )
		m_Status->Release();
	if ( m_Cube )
		m_Cube->Release();
	if ( m_Double )
		m_Double->Release();
	if ( m_Resign )
		m_Resign->Release();
	if ( m_Roll )
		m_Roll->Release();
	if ( m_BackwardDiamond )
		m_BackwardDiamond->Release();
	if ( m_MatchTxt )
		m_MatchTxt->Release();


	for ( int i = 0; i < 4; i++ )
	{
		if ( m_Dice[i] )
			m_Dice[i]->Release();
	}
	for ( i = 0; i < 30; i++ )
	{
		if ( m_Pieces[i] )
			m_Pieces[i]->Release();
	}
	for ( i = 0; i < 2; i++ )
	{
		if ( m_Kibitzers[i] )
			m_Kibitzers[i]->Release();
		if ( m_ForwardDiamond[i] )
			m_ForwardDiamond[i]->Release();
		if ( m_HighlightPlayer[i] )
			m_HighlightPlayer[i]->Release();
		if ( m_Pip[i] )
			m_Pip[i]->Release();
		if ( m_PipTxt[i] )
			m_PipTxt[i]->Release();
		if ( m_Score[i] )
			m_Score[i]->Release();
		if ( m_ScoreTxt[i] )
			m_ScoreTxt[i]->Release();
		if ( m_Names[i] )
			m_Names[i]->Release();
	}
	for ( i = 0; i < 4; i++ )
	{
		if ( m_Notation[i] )
			m_Notation[i]->Release();
	}
}


HRESULT CBGWnd::Init( HINSTANCE hInstance, CGame* pGame, const TCHAR* szTitle )
{
	HRESULT hr;
	FRX::CRect rc;
	
	// Instance
	m_hInstance = hInstance;

	// Game pointer
	m_pGame = pGame;
	pGame->AddRef();

	// Drag piece
	m_pPieceDragging = NULL;

	// Cursors
	m_hCursorArrow = LoadCursor( NULL, IDC_ARROW );
	m_hCursorHand  = ZShellResourceManager()->LoadCursor( MAKEINTRESOURCE(IDC_HAND) );

	// Create Rectangle list
	hr = m_Rects.Init( ZShellResourceManager(), IDR_BOARD_RECTS );
	if ( FAILED(hr) )
	{
		ZShellGameShell()->ZoneAlert( ErrorTextResourceNotFound, NULL, NULL, FALSE, TRUE );
		return hr;
	}

	// Initialize bitmaps and palettes
	hr = InitGraphics();
	if ( FAILED(hr) ) //If it's not a memory error it can only be a unlocated resource
	{
		switch (hr)
		{
			case E_OUTOFMEMORY:
				ZShellGameShell()->ZoneAlert( ErrorTextOutOfMemory, NULL, NULL, FALSE, TRUE );
				break;
			default:
				ZShellGameShell()->ZoneAlert( ErrorTextResourceNotFound, NULL, NULL, FALSE, TRUE );
		}
		return hr;
	}

	// Call parent init
	rc.SetRect( 0, 0, m_Background->GetWidth(), 480 );
	hr = CWindow2::Init( m_hInstance, szTitle, gOCXHandle, NULL /*&rc */);
	if ( FAILED(hr) )
	{
		ZShellGameShell()->ZoneAlert( ErrorTextUnknown, NULL, NULL, FALSE, TRUE );
		return hr;	
	}
	
#ifdef DEBUG_LAYOUT

	DWORD dwStyle = GetWindowLong(m_hWnd, GWL_EXSTYLE );
	if (dwStyle & WS_EX_LAYOUTRTL )
	{
		dwStyle ^= WS_EX_LAYOUTRTL;
		SetWindowLong(m_hWnd, GWL_EXSTYLE, dwStyle );
	}

#endif DEBUG_LAYOUT

	//Loadtext for the status screen
	hr = m_Status->LoadText( NULL, m_Rects );
	if ( FAILED(hr) )
	{
		switch (hr)
		{
			case E_OUTOFMEMORY:
				ZShellGameShell()->ZoneAlert( ErrorTextOutOfMemory, NULL, NULL, FALSE, TRUE );
				break;
			default:
				ZShellGameShell()->ZoneAlert( ErrorTextResourceNotFound, NULL, NULL, FALSE, TRUE );
		}
		return hr;
	}

	
	FRX::CRect crc;
	//Create the button windows

	// Double button	
	hr = ZShellDataStoreUI()->GetRECT( _T("BACKGAMMON/BUTTON/Double/Rect"), &rc );	
	if ( FAILED(hr) )
	{
		ZShellGameShell()->ZoneAlert( ErrorTextResourceNotFound, NULL, NULL, FALSE, TRUE );
		return hr;
	}

	hr = m_DoubleButton.Init( hInstance, IDC_DOUBLE_BUTTON, m_hWnd, &rc, DoubleButtonDraw, (DWORD) this );
	if ( FAILED(hr) )
	{
		ZShellGameShell()->ZoneAlert( ErrorTextUnknown, NULL, NULL, FALSE, TRUE );	
		return hr;
	}

	
	// Resign button
	hr = ZShellDataStoreUI()->GetRECT( _T("BACKGAMMON/BUTTON/Resign/Rect"), &rc );	
	if ( FAILED(hr) )
	{
		ZShellGameShell()->ZoneAlert( ErrorTextResourceNotFound, NULL, NULL, FALSE, TRUE );
		return hr;
	}

	hr = m_ResignButton.Init( hInstance, IDC_RESIGN_BUTTON, m_hWnd, &rc, ResignButtonDraw, (DWORD) this );
	if ( FAILED(hr) )
	{
		ZShellGameShell()->ZoneAlert( ErrorTextUnknown, NULL, NULL, FALSE, TRUE );	
		return hr;
	}
	
	//Roll Button
	ZShellDataStoreUI()->GetRECT( _T("BACKGAMMON/BUTTON/Roll/Rect"), &rc );	
	hr = m_RollButton.Init( hInstance, IDC_ROLL_BUTTON, m_hWnd, &rc, RollButtonDraw, (DWORD) this );
	if ( FAILED(hr) )
	{
		ZShellGameShell()->ZoneAlert( ErrorTextUnknown, NULL, NULL, FALSE, TRUE );
		return hr;
	}

	OnQueryNewPalette();
		
	
	//Init Accesablity
	hr = InitAcc();
	if ( FAILED(hr) )
	{
		ZShellGameShell()->ZoneAlert( ErrorTextUnknown, NULL, NULL, FALSE, TRUE );
		return hr;
	}
	
	return NOERROR;
}


HRESULT CBGWnd::InitGraphics()
{
	int		type;
	FRX::CRect	rc;
	HRESULT hr;
	TCHAR	szBuffer[MAX_BUFFER];

	// load status dialog bitmaps
	m_StatusDlgBmp = new CDib;
	if ( !m_StatusDlgBmp )
		return E_OUTOFMEMORY;
	hr = m_StatusDlgBmp->Load( ZShellResourceManager(), IDB_STATUS_BACKGROUND );
	if ( FAILED(hr) )
		return hr;

	// load background bitmap
	m_Background = new CDib;
	if ( !m_Background )
		return E_OUTOFMEMORY;	
	hr = m_Background->Load( ZShellResourceManager(), IDB_BACKGROUND );
	if ( FAILED(hr) )
		return hr;

	// create sprite background from backfround dib
	m_WorldBackground = new CSpriteWorldBackgroundDib;
	if ( !m_WorldBackground )
		return E_OUTOFMEMORY;
	hr = m_WorldBackground->Init( m_Background );
	if ( FAILED(hr) )
		return hr;

	// initialize palette from background
	hr = m_Palette.Init( m_WorldBackground->GetPalette() , TRUE, TRANSPARENT_IDX );
	if ( FAILED(hr) )
		return hr;

	// create backbuffer dib section
	m_Backbuffer = new CDibSection;
	if ( !m_Backbuffer )
		return E_OUTOFMEMORY;
	

	hr = m_Backbuffer->Create( m_Background->GetWidth(), m_Background->GetHeight(), m_Palette, 24 );
	if ( FAILED(hr) )
		return hr;

	// initialize sprite world
	hr = m_World.Init( ZShellResourceManager(), m_Backbuffer, m_WorldBackground, bgTopLayer );
	if ( FAILED(hr) )
		return hr;

	// status sprite
	m_Status = new CStatusSprite;
	if ( !m_Status )
		return E_OUTOFMEMORY;
	hr = m_Status->Init( &m_World, &m_Rects, NULL, bgStatusLayer, bgSpriteStatus, 0, StatusSprite,  sizeof(StatusSprite) / sizeof(SpriteInfo) );
	if ( FAILED(hr) )
		return hr;

	// cube sprite
	m_Cube = new CDibSprite;
	if ( !m_Cube )
		return E_OUTOFMEMORY;
	hr = m_Cube->Init( &m_World, &m_Rects, NULL, bgDiceLayer, bgSpriteCube, 0, CubeSprite,  sizeof(CubeSprite) / sizeof(SpriteInfo) );
	if ( FAILED(hr) )
		return hr;

	//Get Cube Positions for player and opponents
	hr = ZShellDataStoreUI()->GetRECT( _T("BACKGAMMON/GRAPHIC/Cube/RectPlayer"), &m_CubePlayerPosition);
	if ( FAILED(hr) )
		return hr;
	
	hr = ZShellDataStoreUI()->GetRECT( _T("BACKGAMMON/GRAPHIC/Cube/RectOpponent"), &m_CubeOpponentPosition);
	if ( FAILED(hr) )
		return hr;

	// double button sprite	
	m_Double = new CButtonTextSprite;
	if ( !m_Double )
		return E_OUTOFMEMORY;
	hr = m_Double->Init( &m_World, &m_Rects, NULL, bgButtonLayer, bgSpriteDouble, 0, DoubleSprite,  sizeof(DoubleSprite) / sizeof(SpriteInfo) );
	if ( FAILED(hr) )
		return hr;

	// resign button sprite
	m_Resign = new CButtonTextSprite;
	if ( !m_Resign )
		return E_OUTOFMEMORY;
	hr = m_Resign->Init( &m_World, &m_Rects, NULL, bgButtonLayer, bgSpriteResign, 0, ResignSprite,  sizeof(ResignSprite) / sizeof(SpriteInfo) );
	if ( FAILED(hr) )
		return hr;

	//Roll Button sprite
	m_Roll = new CButtonTextSprite;
	if ( !m_Roll )
		return E_OUTOFMEMORY;
	hr = m_Roll->Init( &m_World, &m_Rects, NULL, bgButtonLayer, bgSpriteRoll, 0, RollSprite,  sizeof(RollSprite) / sizeof(SpriteInfo) );
	if ( FAILED(hr) )
		return hr;

	
	//Load the button data
	if ( !m_Double->LoadButtonData( IDS_BUTTON_DOUBLE, _T("BACKGAMMON/BUTTON/Double") ) ||
		 !m_Resign->LoadButtonData( IDS_BUTTON_RESIGN, _T("BACKGAMMON/BUTTON/Resign") ) || 
		 !m_Roll->LoadButtonData  ( IDS_BUTTON_ROLL,   _T("BACKGAMMON/BUTTON/Roll")   ) 
	   )
	{
		ASSERT(!"Error loading button data!");
		return E_FAIL;
	}


	// dice
	for ( int i = 0; i < 4; i++ )
	{
		m_Dice[i] = new CDibSprite;
		if ( !m_Dice[i] )
			return E_OUTOFMEMORY;
		if ( i < 2 )
			type = bgSpriteOpponentsDice;
		else
			type = bgSpritePlayersDice;
		hr = m_Dice[i]->Init( &m_World, &m_Rects, NULL, bgDiceLayer, type, 0, DiceSprite, sizeof(DiceSprite) / sizeof(SpriteInfo) );
		if ( FAILED(hr) )
			return hr;
		rc = m_Rects[ IDR_DICE_LEFT_ONE + i ];
		m_Dice[i]->SetXY( rc.left, rc.top );
	}

	// pieces
	for ( i = 0; i < 30; i++ )
	{
		m_Pieces[i] = new CPieceSprite;
		if ( !m_Pieces[i] )
			return E_OUTOFMEMORY;
		m_Pieces[i]->SetIndex( i );
		m_Pieces[i]->SetPoint( -1 );
		m_Pieces[i]->SetLowerIndex( -1 );
		if ( i <= 14 )
			hr = m_Pieces[i]->Init( &m_World, &m_Rects, NULL, bgPieceLayer, bgSpriteWhitePiece, 0, WhitePieceSprite,  sizeof(WhitePieceSprite) / sizeof(SpriteInfo) );
		else
			hr = m_Pieces[i]->Init( &m_World, &m_Rects, NULL, bgPieceLayer, bgSpriteBrownPiece, 0, BrownPieceSprite,  sizeof(BrownPieceSprite) / sizeof(SpriteInfo) );
		if ( FAILED(hr) )
			return hr;
	}

	// highlights
	for ( i = 0; i < 2; i++ )
	{
		m_ForwardDiamond[i] = new CDibSprite;
		if ( !m_ForwardDiamond[i] )
			return E_OUTOFMEMORY;
		hr = m_ForwardDiamond[i]->Init( &m_World, &m_Rects, NULL, bgHighlightLayer, bgSpriteForwardHighlight, 0, ForwardHighlightSprite, sizeof(ForwardHighlightSprite) / sizeof(SpriteInfo) );
		if ( FAILED(hr) )
			return hr;

		m_HighlightPlayer[i] = new CDibSprite;
		if ( !m_HighlightPlayer[i] )
			return E_OUTOFMEMORY;
		hr = m_HighlightPlayer[i]->Init( &m_World, &m_Rects, NULL, bgHighlightLayer, bgSpritePlayerHighlight, 0, PlayerHighlightSprite, sizeof(PlayerHighlightSprite) / sizeof(SpriteInfo) );
		if ( FAILED(hr) )
			return hr;
	}

	//Set the active player highlight rects
	rc = m_Rects[ IDR_OPPONENT_HIGHLIGHT ];
	m_HighlightPlayer[0]->SetXY(rc.left , rc.top);
	m_HighlightPlayer[0]->SetEnable( TRUE );

	rc = m_Rects[ IDR_PLAYER_HIGHLIGHT ];
	m_HighlightPlayer[1]->SetXY(rc.left , rc.top );
	m_HighlightPlayer[1]->SetEnable( TRUE );

	m_BackwardDiamond = new CDibSprite;
	if ( !m_BackwardDiamond )
		return E_OUTOFMEMORY;
	hr = m_BackwardDiamond->Init( &m_World, &m_Rects, NULL, bgHighlightLayer, bgSpriteBackwardHighlight, 0, BackwardHighlightSprite, sizeof(BackwardHighlightSprite) / sizeof(SpriteInfo) );
	if ( FAILED(hr) )
		return hr;

	// avatars, pip, and score.
	for ( i = 0; i < 2; i++ )
	{
		m_Pip[i] = new CTextSprite;
		if ( !m_Pip[i] )
			return E_OUTOFMEMORY;
		hr = m_Pip[i]->Init( &m_World, bgDiceLayer, bgSpritePip, 0 , 0 );
		if ( FAILED(hr) )
			return hr;
		
		m_PipTxt[i] = new CTextSprite;
		if ( !m_PipTxt[i] )
			return E_OUTOFMEMORY;
		hr = m_PipTxt[i]->Init( &m_World, bgDiceLayer, bgSpritePipTxt, 0, 0 );
		if ( FAILED(hr) )
			return hr;

		m_Score[i] = new CTextSprite;
		if ( !m_Score[i] )
			return E_OUTOFMEMORY;
		hr = m_Score[i]->Init( &m_World, bgDiceLayer, bgSpriteScore, 0, 0 );
		if ( FAILED(hr) )
			return hr;
		
		m_ScoreTxt[i] = new CTextSprite;
		if ( !m_ScoreTxt[i] )
			return E_OUTOFMEMORY;
		hr = m_ScoreTxt[i]->Init( &m_World, bgDiceLayer, bgSpriteScoreTxt, 0, 0 );
		if ( FAILED(hr) )
			return hr;

		m_Names[i] = new CTextSprite;
		if ( !m_Names[i] )
			return E_OUTOFMEMORY;
		hr = m_Names[i]->Init( &m_World, bgDiceLayer, bgSpriteName, 0,0 );
		if ( FAILED(hr) )
			return hr;
		
	}

	// match points
	m_MatchTxt= new CTextSprite;
	if ( !m_MatchTxt )
		return E_OUTOFMEMORY;
	hr = m_MatchTxt->Init( &m_World, bgDiceLayer, bgSpriteMatchTxt, 0, 0 );
	if ( FAILED(hr) )
		return hr;

	//Load SpriteText strings from resources
	
	//Pip Text
	if ( !m_Pip[0]->Load(IDS_PIPS, _T("BACKGAMMON/TEXT/PipData/Opponent/Rect"),    _T("BACKGAMMON/TEXT/PipData/Common/Font"),    _T("BACKGAMMON/TEXT/PipData/Common/RGB"))    ||
		 !m_Pip[1]->Load(IDS_PIPS, _T("BACKGAMMON/TEXT/PipData/Player/Rect"),      _T("BACKGAMMON/TEXT/PipData/Common/Font"),	 _T("BACKGAMMON/TEXT/PipData/Common/RGB"))    ||
		 !m_PipTxt[0]->Load(0,     _T("BACKGAMMON/TEXT/PipData/Opponent/RectNum"), _T("BACKGAMMON/TEXT/PipData/Common/Font"),    _T("BACKGAMMON/TEXT/PipData/Common/RGB"))    ||
	     !m_PipTxt[1]->Load(0,     _T("BACKGAMMON/TEXT/PipData/Player/RectNum"),   _T("BACKGAMMON/TEXT/PipData/Common/Font"),    _T("BACKGAMMON/TEXT/PipData/Common/RGB")) 
	   )	     
	{		
		ASSERT( FALSE );
		return E_FAIL;
	}

	//Score Text
	if ( !m_Score[0]->Load(IDS_SCORE, _T("BACKGAMMON/TEXT/ScoreData/Opponent/Rect"),	  _T("BACKGAMMON/TEXT/ScoreData/Common/Font"),     _T("BACKGAMMON/TEXT/ScoreData/Common/RGB"))    ||
		 !m_Score[1]->Load(IDS_SCORE, _T("BACKGAMMON/TEXT/ScoreData/Player/Rect"),		  _T("BACKGAMMON/TEXT/ScoreData/Common/Font"),     _T("BACKGAMMON/TEXT/ScoreData/Common/RGB"))    ||
		 !m_ScoreTxt[0]->Load(0,	  _T("BACKGAMMON/TEXT/ScoreData/Opponent/RectNum"),   _T("BACKGAMMON/TEXT/ScoreData/Common/Font"),     _T("BACKGAMMON/TEXT/ScoreData/Common/RGB"))    ||
		 !m_ScoreTxt[1]->Load(0,	  _T("BACKGAMMON/TEXT/ScoreData/Player/RectNum"),	  _T("BACKGAMMON/TEXT/ScoreData/Common/Font"),     _T("BACKGAMMON/TEXT/ScoreData/Common/RGB"))
	   )
	{
		ASSERT( FALSE );
		return E_FAIL;
	}
	

	//Brown White Text
	if (!m_MatchTxt->Load( 0,   _T("BACKGAMMON/TEXT/MatchData/Rect"),    _T("BACKGAMMON/TEXT/MatchData/Font"), _T("BACKGAMMON/TEXT/MatchData/RGB") ) )
	{
		ASSERT( FALSE );
		return E_FAIL;
	}
	
	if ( !m_Names[0]->Load(IDS_PLAYER_2, 0, _T("BACKGAMMON/TEXT/NameData/Common/Font"), 0) ||
		 !m_Names[1]->Load(IDS_PLAYER_1, 0, _T("BACKGAMMON/TEXT/NameData/Common/Font"), 0) 
	   )
	{
		ASSERT( FALSE );
		return E_FAIL;
	}
	
	
	// notation pane bitmaps
	for ( i = 0; i < 4; i++ )
	{
		m_Notation[i] = new CDibSprite;
		if ( !m_Notation[i] )
			return E_OUTOFMEMORY;
		hr = m_Notation[i]->Init( &m_World, &m_Rects, NULL, bgDiceLayer, bgSpriteNotation, 0, NotationSprite, sizeof(NotationSprite) / sizeof(SpriteInfo) );
		if ( FAILED(hr) )
			return hr;
	}

	//Create the focus and selected rectangles
	m_FocusRect.Init( &m_World, bgRectSpriteLayer,  0, 0, 0 );
	m_SelectRect.Init( &m_World, bgRectSpriteLayer, 0, 0, 0 );

	//Set the style of the focus rectangles
	m_FocusRect.SetStyle(RECT_DOT);
	m_SelectRect.SetStyle(RECT_SOLID);

	// create identity palette now that we have all our graphics	
	m_Palette.RemapToIdentity();
	m_StatusDlgBmp->RemapToPalette( m_Palette );	
	m_World.SetTransparencyIndex( TRANSPARENT_IDX_24 );	
	m_World.RemapToPalette( m_Palette );	

//  8-bit
//	m_FocusRect.SetColor( m_Palette, RGB(255,255,204)    );
//	m_SelectRect.SetColor( m_Palette, RGB(255,255,204) );

//  24-bit
	m_FocusRect.SetColor( RGB(255,255,204) );
	m_SelectRect.SetColor( RGB(255,255,204) );

	return NOERROR;
}


HRESULT CBGWnd::InitPoints()
{
	int i, idx;

	//Load the proper rectangles
	if ( m_pGame->m_Player.GetColor() == zBoardWhite )
	{
		if ( !m_Names[0]->Load(0, _T("BACKGAMMON/TEXT/NameData/Player/Rect"),   0, _T("BACKGAMMON/TEXT/NameData/Player/RGB")  , DT_LEFT | DT_TOP ) ||
			 !m_Names[1]->Load(0, _T("BACKGAMMON/TEXT/NameData/Opponent/Rect"), 0, _T("BACKGAMMON/TEXT/NameData/Opponent/RGB"), DT_LEFT | DT_TOP ) 
		   )
		{
			ZShellGameShell()->ZoneAlert( ErrorTextResourceNotFound, NULL, NULL, FALSE, TRUE );
			return E_FAIL;
		}
	}
	else
	{
		if ( !m_Names[1]->Load(0, _T("BACKGAMMON/TEXT/NameData/Player/Rect"),   0, _T("BACKGAMMON/TEXT/NameData/Player/RGB")  , DT_LEFT | DT_TOP ) ||
			 !m_Names[0]->Load(0, _T("BACKGAMMON/TEXT/NameData/Opponent/Rect"), 0, _T("BACKGAMMON/TEXT/NameData/Opponent/RGB"), DT_LEFT | DT_TOP ) 
		   )
		{
			ZShellGameShell()->ZoneAlert( ErrorTextResourceNotFound, NULL, NULL, FALSE, TRUE );
			return E_FAIL;
		}
	}
	
	// init point structures
	for ( i = 0; i < 28; i++ )
	{
		idx = m_pGame->GetPointIdx( i );
		
		m_Points[i].nPieces		= 0;
		m_Points[i].rect		= m_Rects[ IDR_PT1 + idx ];
		m_Points[i].rectHit		= m_Rects[ IDR_HIT_PT1 + idx ];

		if ( idx <= 11 )
			m_Points[i].topDown = FALSE;
		else if ( idx < 23 )
			m_Points[i].topDown = TRUE;
		else if ( idx == bgBoardPlayerHome )
			m_Points[i].topDown = FALSE;
		else if ( idx == bgBoardOpponentHome )
			m_Points[i].topDown = TRUE;
		else if ( idx == bgBoardPlayerBar )
			m_Points[i].topDown = FALSE;
		else
			m_Points[i].topDown = TRUE;
	}

	// clear sprite indexs
	for ( i = 0; i < 30; i++ )
		m_Pieces[i]->SetPoint( -1 );

	m_Double->SetEnable( TRUE );
	m_Resign->SetEnable( TRUE );

	return S_OK;
}

HRESULT CBGWnd::InitAcc()
{

	RECT rc;

	//Load the acclerator table
	m_hAccelTable = ZShellResourceManager()->LoadAccelerators( MAKEINTRESOURCE(IDR_PREROLL_ACCELERATORS) );
	if ( !m_hAccelTable )
		return E_FAIL;


	//Copy the default info into all of the items first
	for ( int i = 0; i < NUM_PREROLL_GACCITEMS; i++ )
		CopyACC( m_BkGAccItems[i], ZACCESS_DefaultACCITEM );
  
	//Setup the roll button
	m_BkGAccItems[accRollButton].fGraphical		   = true;
	m_BkGAccItems[accRollButton].wID			   = IDC_ROLL_BUTTON;

	m_Roll->GetXY( &rc.left, &rc.top );
	rc.right   = rc.left + m_Roll->GetWidth()  + 1;
	rc.bottom  = rc.top  + m_Roll->GetHeight() + 1;
	rc.left   -=2;
	rc.top	  -=2;

	m_BkGAccItems[accRollButton].rc				       = rc;

	//Setup the arrow key behavior
	m_BkGAccItems[accRollButton].nArrowRight		   = accDoubleButton;
	m_BkGAccItems[accRollButton].nArrowDown			   = accDoubleButton;
	m_BkGAccItems[accRollButton].nArrowLeft			   = accResignButton;
	m_BkGAccItems[accRollButton].nArrowUp			   = accResignButton;

	//Double Button
	m_BkGAccItems[accDoubleButton].fGraphical		   = true;	
	m_BkGAccItems[accDoubleButton].wID				   = IDC_DOUBLE_BUTTON;

	m_Double->GetXY( &rc.left, &rc.top );
	rc.right   = rc.left + m_Double->GetWidth()  + 1;
	rc.bottom  = rc.top  + m_Double->GetHeight() + 1;
	rc.left   -=2;	
	rc.top	  -=2;

	m_BkGAccItems[accDoubleButton].rc				   = rc;

	//Setup the arrow key behavior
	m_BkGAccItems[accDoubleButton].nArrowRight			   = accResignButton;
	m_BkGAccItems[accDoubleButton].nArrowDown			   = accResignButton;
	m_BkGAccItems[accDoubleButton].nArrowLeft			   = accRollButton;
	m_BkGAccItems[accDoubleButton].nArrowUp				   = accRollButton;

	//Resign Button
	m_BkGAccItems[accResignButton].fGraphical		   = true;	
	m_BkGAccItems[accResignButton].wID			       = IDC_RESIGN_BUTTON;
	

	m_Resign->GetXY( &rc.left, &rc.top );
	rc.right   = rc.left + m_Resign->GetWidth()  + 1;
	rc.bottom  = rc.top  + m_Resign->GetHeight() + 1;
	rc.left   -=2;	
	rc.top	  -=2;

	m_BkGAccItems[accResignButton].rc				   = rc;

	//Setup the arrow key
	m_BkGAccItems[accResignButton].nArrowRight			   = accRollButton;
	m_BkGAccItems[accResignButton].nArrowDown			   = accRollButton;
	m_BkGAccItems[accResignButton].nArrowLeft			   = accDoubleButton;
	m_BkGAccItems[accResignButton].nArrowUp 			   = accDoubleButton;

	
	for (int pointIdx = 0; pointIdx < NUM_POSTROLL_GACCITEMS; pointIdx++, i++ )
	{
		CopyACC( m_BkGAccItems[i], ZACCESS_DefaultACCITEM );

		//Load the rectangle for the point
		m_BkGAccItems[i].rc			= m_Rects[ IDR_PT1 + pointIdx ];
		
		//Masage the given area rectangles to make them look pretty for highlighting
		//in accesssibility
		if ( i < accPlayerBearOff )
		{
			m_BkGAccItems[i].rc.left      -= 3;  //Board rects
		}
		else if ( i >= accPlayerBearOff && i < accMoveBar )
		{
			m_BkGAccItems[i].rc.left    -= 1;  //Bear off rects
			m_BkGAccItems[i].rc.top	    -= 1;
			m_BkGAccItems[i].rc.right   += 1;
			m_BkGAccItems[i].rc.bottom	+= 1;
		}

		//Want the rect drawn
		m_BkGAccItems[i].fGraphical	= true;

		m_BkGAccItems[i].wID			= ZACCESS_InvalidCommandID;
		m_BkGAccItems[i].oAccel.cmd		= ZACCESS_InvalidCommandID;
		m_BkGAccItems[i].eAccelBehavior	= ZACCESS_Ignore;		
		m_BkGAccItems[i].fTabstop		= false;

		m_BkGAccItems[i].nArrowUp   = ZACCESS_ArrowNone;
		m_BkGAccItems[i].nArrowDown = ZACCESS_ArrowNone;
		if ( i < accPlayerBearOff ) //Handle reg board rects 
		{
            if(i < accOpponentSideStart)
			    m_BkGAccItems[i].nArrowUp   = accOpponentSideEnd - pointIdx;
            else
			    m_BkGAccItems[i].nArrowDown = accOpponentSideEnd - pointIdx;
		}

		//Change direction of lower item arrow moves to opposite direction
		if ( i < accOpponentSideStart )
		{
			m_BkGAccItems[i].nArrowLeft  = i + 1;
			m_BkGAccItems[i].nArrowRight = i - 1;
		}
	}

	m_BkGAccItems[accPlayerSideStart].nArrowRight   = accPlayerBearOff; //First pos to bear off
	
	m_BkGAccItems[accPlayerBearOff].nArrowLeft      = accPlayerSideStart;  //player home to first pos
	m_BkGAccItems[accPlayerBearOff].nArrowRight     = ZACCESS_ArrowNone; //player home wrap to opposite of first pos
	
	m_BkGAccItems[accPlayerSideEnd].nArrowLeft      = ZACCESS_ArrowNone;  //wraparound to bear off
	
	//Opponent side no hassle like above
	m_BkGAccItems[accOpponentSideStart].nArrowLeft = ZACCESS_ArrowNone;
	m_BkGAccItems[accOpponentSideEnd].nArrowRight = ZACCESS_ArrowNone;

	//Handle player bar
	m_BkGAccItems[accPreBar].nArrowRight   = accMoveBar; //board to bar
	m_BkGAccItems[accPostBar].nArrowLeft   = accMoveBar;  //board to bar
	
	m_BkGAccItems[accMoveBar].nArrowLeft   = accPreBar;  //bar to board
	m_BkGAccItems[accMoveBar].nArrowRight  = accPostBar;  //bar to board


	m_BkGAccItems[accPlayerSideStart].fTabstop		 = true;
	m_BkGAccItems[accPlayerSideStart].wID			 = IDC_GAME_WINDOW;	
    m_BkGAccItems[accPlayerSideStart].eAccelBehavior = ZACCESS_FocusGroup;
    m_BkGAccItems[accPlayerSideStart].nGroupFocus	 = accOpponentSideStart;  // start on your upper-left checker


	//Status box canceling
	m_BkGAccItems[accStatusExit].fGraphical		= false;
	m_BkGAccItems[accStatusExit].wID			= IDC_ESC;
	m_BkGAccItems[accStatusExit].fTabstop		= false;
	m_BkGAccItems[accStatusExit].fVisible		= false;


	//Create the graphically accessible object
	HRESULT hr = ZShellCreateGraphicalAccessibility( &m_pGAcc );
	if ( FAILED(hr) ) 
		return hr;

	//Init the graphical accessability control 
	//TODO:: change to global
	m_pGAcc->InitAccG(m_pGame, m_hWnd, 0, NULL);

	//Place the Gameboard item list on the stack first
	m_pGAcc->PushItemlistG( m_BkGAccItems, NUM_BKGACC_ITEMS, 0, true, m_hAccelTable );
	

	//Set to the inital roll state
	m_pGAcc->SetItemEnabled(true,  accRollButton);
	m_pGAcc->SetItemEnabled(false, accDoubleButton);
	m_pGAcc->SetItemEnabled(false, accResignButton);
	DisableBoard();

	return S_OK;
}


int CBGWnd::GetPointIdxFromXY( long x, long y )
{
	// returns white's point idx
	for ( int i = 0; i < 28; i++ )
	{
		if ( m_Points[i].rectHit.PtInRect( x, y ) )
			return i;
	}
	return -1;
}


void CBGWnd::DragStart( CPieceSprite* sprite )
{
	RECT rc;
	POINT pt;

	if ( m_pPieceDragging )
		DragEnd();
	m_pPieceDragging = sprite;
	
	DrawHighlights(  m_pGame->GetPointIdx( m_pPieceDragging->GetWhitePoint() ) );

	// set sprite properties
	sprite->SetState( 0 );
	sprite->SetLayer( bgDragLayer );
	m_DragOffsetX = -(sprite->GetWidth() / 2);
	m_DragOffsetY = -(sprite->GetHeight() / 2);

	// Calculate cursor region
	rc = m_Rects[ IDR_BOARD ];
	pt.x = rc.left - m_DragOffsetX;
	pt.y = rc.top - m_DragOffsetX;
	ClientToScreen( m_hWnd, &pt );
	rc.left = pt.x;
	rc.top = pt.y;
	pt.x = rc.right - sprite->GetWidth() - m_DragOffsetX;
	pt.y = rc.bottom - sprite->GetHeight() - m_DragOffsetX;
	ClientToScreen( m_hWnd, &pt );
	rc.right = pt.x;
	rc.bottom = pt.y;

	// Capture cursor
	SetCapture( m_hWnd );
	ShowCursor( FALSE );
	ClipCursor( &rc );

	// redraw sprite
	UpdateWnd();
}


void CBGWnd::DragUpdate( long x, long y )
{
	m_pPieceDragging->SetXY( x + m_DragOffsetX, y + m_DragOffsetY );
	UpdateWnd();
}


void CBGWnd::DragEnd()
{
	int pt;

	// are we dragging the cursor?
	if ( !m_pPieceDragging )
		return;

	// update piece position
	pt = m_pPieceDragging->GetWhitePoint();
	if ( pt >= 0 )
		AdjustPieces( pt );

	m_pPieceDragging = NULL;

	// redraw backbuffer
	UpdateWnd();	

	// restore cursor
	ClipCursor( NULL );
	ReleaseCapture();
	ShowCursor( TRUE );
	

}

void CBGWnd::OverrideClassParams( WNDCLASSEX& WndClass )
{
	WndClass.hbrBackground = NULL;
}


void CBGWnd::OverrideWndParams( WNDPARAMS& WndParams )
{
	BOOL HaveCoords;
	DWORD x, y, width, height;
	FRX::CRect rc;

	x = 0;y=0;
	WndParams.dwStyle &= ~( WS_MAXIMIZEBOX | WS_OVERLAPPEDWINDOW );
	WndParams.dwStyle |= WS_CHILD | WS_VISIBLE ;
	WndParams.x = 0;
	WndParams.y = 0;
	WndParams.nWidth  = 640;
	WndParams.nHeight = 379;
}


///////////////////////////////////////////////////////////////////////////////
// Message handlers
/////////////////////////////////////////////////////////////////////////////////

void CBGWnd::OnClose()
{
	/*
	if ( !m_pGame->IsKibitzer() )
	{
		// select exit dialog based on rated game and state
		if ( ZCRoomGetRoomOptions() & zGameOptionsRatingsAvailable )
		{
			/*
			if (m_pGame->m_bOpponentTimeout)
			{
				m_pGame->m_ExitId=IDD_EXIT_TIMEOUT ;
				m_pGame->m_ExitDlg.Init( m_hInstance, IDD_EXIT_TIMEOUT );
			}
			else if (m_pGame->m_GameStarted)
			{
				m_pGame->m_ExitId=IDD_EXIT_ABANDON ;
				m_pGame->m_ExitDlg.Init( m_hInstance, IDD_EXIT_ABANDON );
			}
			else
			{
				m_pGame->m_ExitId=IDD_EXIT ;
				m_pGame->m_ExitDlg.Init( m_hInstance, IDD_EXIT);
			};

			m_pGame->AddRef();
			// display exit dialog
			m_pGame->m_ExitDlg.ModelessViaThread( m_hWnd , WM_BG_EXIT_RATED_START, WM_BG_EXIT_RATED_END  );
			
		}
		else
		{
			
			if ( m_pGame->IsStateInList( gExitSaveStates ) )
				m_pGame->m_ExitDlg.Init( m_hInstance, IDD_EXIT_SAVE );
			else
			

			m_pGame->m_ExitDlg.Init( m_hInstance, IDD_EXIT );
			
			m_pGame->AddRef();
			// display exit dialog
			m_pGame->m_ExitDlg.ModelessViaThread( m_hWnd , WM_BG_EXIT_START, WM_BG_EXIT_END  );
			
			
		}

	}
    else
    {
        PostMessage( m_hWnd, WM_BG_SHUTDOWN, 0, 0 );
	    ShowWindow( m_hWnd, SW_HIDE );
		ShowWindow( m_pGame->m_Notation, SW_HIDE );    
    }
	*/
    PostMessageA(m_hWnd, WM_BG_SHUTDOWN, 0, 0 );
    ShowWindow( m_hWnd, SW_HIDE );
	/*
	ShowWindow( m_pGame->m_Notation, SW_HIDE );     	
	*/
}


void CBGWnd::OnDestroy()
{

	//Close the Accessibility object..	
	if ( m_pGAcc )
		m_pGAcc->CloseAcc();


	// release palette
	HDC hdc = GetDC( m_hWnd );
	SelectPalette( hdc, GetStockObject(DEFAULT_PALETTE), FALSE );
	ReleaseDC( m_hWnd, hdc );

	// release timers
	if ( m_hMovementTimer )
	{
		KillTimer( m_hWnd, 1 );
		m_hMovementTimer = NULL;
	}
	if ( m_hDiceTimer )
	{
		KillTimer( m_hWnd, 2 );
		m_hDiceTimer = NULL;
	}
	if ( m_hStatusTimer )
	{
		KillTimer( m_hWnd, 3 );
		m_hStatusTimer = NULL;
	}

	// release game object
	m_pGame->Release();
}


void CBGWnd::OnCommand(int id, HWND hwndCtl, UINT codeNotify)
{
	CSettings dlg2;

	//CAboutDlg about;
	CSprite*	pSprite;

	switch (id)
	{
	case IDC_DOUBLE_BUTTON:
		m_pGame->Double();
		break;
	case IDC_RESIGN_BUTTON:
		m_pGame->Resign();
		break;
	case IDC_ROLL_BUTTON:		
		DiceStart();
		break;
	/*
	case ID_GAME_NEWMATCH:
		if ( m_pGame->IsHost() && !(ZCRoomGetRoomOptions() & zGameOptionsRatingsAvailable) )
			m_pGame->SetState( bgStateNewMatch );
		break;

	case ID_GAME_SETTINGS:
		m_pGame->SetQueueMessages( TRUE );
		dlg2.Init( m_hInstance, IDD_SETTINGS_GAME, m_hWnd, m_pGame );
		m_pGame->SetQueueMessages( FALSE );
		break;
	*/
	case ID_GAME_EXIT:
		PostMessageA( m_hWnd, WM_CLOSE, 0, 0 );
		break;
	/*
	#if _DEBUG_UI
	case ID_DEBUG_ROLLDICE:
		if ( !m_pGame->NeedToRollDice() )
			return;
		m_pGame->GetDice( m_pGame->m_Player.m_Seat, &v0, &v1 );
		if ( FAILED(dlg.Init( m_hInstance, IDD_ROLL_DICE )) )
			return;
		if ( !dlg.Modal( m_hWnd ) )
			return;
		m_pGame->m_SharedState.StartTransaction( bgTransDice );
			if ( v1 == 0 )
				m_pGame->SetDice( m_pGame->m_Player.m_Seat, dlg.m_Dice[0], dlg.m_Dice[1] );
			else
				m_pGame->SetDice( m_pGame->m_Player.m_Seat, dlg.m_Dice[0], -1 );
		m_pGame->m_SharedState.SendTransaction( TRUE );
	#endif
		*/
		break;
	}
}


void CBGWnd::OnPaint()
{

	if ( !m_Backbuffer ) return;


	PAINTSTRUCT ps;
	HDC hdc = BeginPaint(m_hWnd, &ps);
	m_Backbuffer->Draw( hdc, 0, 0 );
	EndPaint( m_hWnd, &ps );
}

void CBGWnd::OnPaletteChanged( HWND hwndPaletteChange )
{
	if ( hwndPaletteChange != m_hWnd )
	{
       // Need the window's DC for SelectPalette/RealizePalette
       HDC hDC = GetDC(m_hWnd);

       // Select and realize hPalette
       HPALETTE hOldPal = SelectPalette(hDC, m_Palette, TRUE);
       RealizePalette(hDC);

       // When updating the colors for an inactive window,
       // UpdateColors can be called because it is faster than
       // redrawing the client area (even though the results are
       // not as good)
       InvalidateRect( m_hWnd, NULL, TRUE );

       // Clean up

       if (hOldPal)
          SelectPalette(hDC, hOldPal, TRUE);

       ReleaseDC(m_hWnd, hDC);
	}	
}


BOOL CBGWnd::OnQueryNewPalette()
{
	HDC hdc = GetDC( m_hWnd );
	HPALETTE hOldPal = SelectPalette( hdc, m_Palette, FALSE );
	if ( RealizePalette( hdc ) )
	{
		if ( m_hBrush )
		{
			DeleteObject( m_hBrush );
			m_hBrush = NULL;
		}
		InvalidateRect( m_hWnd, NULL, TRUE );

	}
	ReleaseDC( m_hWnd, hdc );
	return TRUE;
}


void CBGWnd::OnSettingDlgStart()
{
	ASSERT( FALSE );
	/*
	HMENU hmenu;

	// Reference count game object
	m_pGame->AddRef();

	// Disable menus
	if ( hmenu  = GetMenu( m_hWnd ) )
	{
		for ( int i = 0; i < (sizeof(MenuIndexs) / sizeof(int)); i++ )
			EnableMenuItem( hmenu, MenuIndexs[i], MF_BYCOMMAND | MF_GRAYED );
	}

	// Starting handling messages again
	m_pGame->SetQueueMessages( FALSE );
	
	// Tell host settings dialog is active
	if ( !m_pGame->IsHost() && !m_pGame->IsKibitzer() )
	{
		m_pGame->m_SharedState.StartTransaction( bgTransSettingsDlgReady );
			m_pGame->m_SharedState.Set( bgSettingsReady, TRUE );
		m_pGame->m_SharedState.SendTransaction( FALSE );
	}
	*/
}


void CBGWnd::OnSettingDlgEnd()
{

	ASSERT( FALSE );
	/*
	CGameSetupDlg* dlg;
	HMENU hmenu;

	// Enable menus
	if ( hmenu = GetMenu( m_hWnd ) )
	{
		if ( !m_pGame->IsKibitzer() )
		{
			// re-enable menu
			for ( int i = 0; i < (sizeof(MenuIndexs) / sizeof(int)); i++ )
				EnableMenuItem( hmenu, MenuIndexs[i], MF_BYCOMMAND | MF_ENABLED );

			// Only host gets new game
			if ( !m_pGame->IsHost() || (ZCRoomGetRoomOptions() & zGameOptionsRatingsAvailable) )
				EnableMenuItem( hmenu, ID_GAME_NEWMATCH, MF_BYCOMMAND | MF_GRAYED );
		}
	}


	if ( m_pGame->GetState() != bgStateDelete )
	{
		// Handle host's dialog results
		if ( m_pGame->IsHost() )
		{
			dlg = &m_pGame->m_SetupDlg;
			switch ( dlg->GetResult() )
			{
			case -1:
				break;
			case 1:
				m_pGame->m_SharedState.StartTransaction( bgTransInitSettings );
					m_pGame->m_SharedState.Set( bgHostBrown, dlg->m_bHostBrownTmp );
					m_pGame->m_SharedState.Set( bgAutoDouble, dlg->m_bAutoDoubleTmp );
					m_pGame->m_SharedState.Set( bgTargetScore, dlg->m_nPointsTmp );
					m_pGame->m_SharedState.Set( bgSettingsDone, TRUE );
				m_pGame->m_SharedState.SendTransaction( FALSE );

				// stash setup params in registry
				ZoneSetRegistryDword( gGameRegName, "Match Points", dlg->m_nPointsTmp );
				ZoneSetRegistryDword( gGameRegName, "Host Brown",	dlg->m_bHostBrownTmp );
				ZoneSetRegistryDword( gGameRegName, "Auto Doubles",	dlg->m_bAutoDoubleTmp );

				// get on with the game
				m_pGame->DeleteGame();
				m_pGame->SetState( bgStateInitialRoll );
				break;
			case 2:
				PostMessage( m_hWnd, WM_BG_SHUTDOWN, 0, 0 );
				break;
			}
		}

		// Tell host settings dialog is NOT active
		else if ( !m_pGame->IsKibitzer() )
		{
			m_pGame->m_SharedState.StartTransaction( bgTransSettingsDlgReady );
				m_pGame->m_SharedState.Set( bgSettingsReady, FALSE );
			m_pGame->m_SharedState.SendTransaction( FALSE );
		}
	}

	// Release game object
	m_pGame->Release();
	*/
}


void CBGWnd::OnSettingsDlgSend()
{
	ASSERT( FALSE );
	/*
	// Hack to prevent dialog thread from calling into zone libraries
	if ( m_pGame->IsHost() )
	{
		CGameSetupDlg* dlg = &m_pGame->m_SetupDlg;
		m_pGame->m_SharedState.StartTransaction( bgTransInitSettings );
			m_pGame->m_SharedState.Set( bgHostBrown, dlg->m_bHostBrownTmp );
			m_pGame->m_SharedState.Set( bgAutoDouble, dlg->m_bAutoDoubleTmp );
			m_pGame->m_SharedState.Set( bgTargetScore, dlg->m_nPointsTmp );
		m_pGame->m_SharedState.SendTransaction( FALSE );
	}
	*/
}

/*
void CBGWnd::OnKibitzerEnd()
{
	if ( m_pGame->m_pKibitzerWnd )
	{
		delete m_pGame->m_pKibitzerWnd;
		m_pGame->m_pKibitzerWnd = NULL;
	}
}
*/


void CBGWnd::OnShutdown()
{
	ZCRoomGameTerminated( m_pGame->m_TableId );
}


void CBGWnd::OnGetMinMaxInfo(LPMINMAXINFO lpMinMaxInfo)
{
	lpMinMaxInfo->ptMaxSize.x = m_Width;
	lpMinMaxInfo->ptMinTrackSize.x = m_Width;
	lpMinMaxInfo->ptMinTrackSize.y = 480;
	lpMinMaxInfo->ptMaxTrackSize.x = m_Width;
}


void CBGWnd::OnSize(UINT state, int cx, int cy)
{
	// update chat windows
	/*
	FRX::CRect rc( 0, m_Background->GetHeight() + 1, m_Background->GetWidth(), cy );
	
	if ( m_pChat )
		m_pChat->ResizeWindow( &rc );
	*/
}


void CBGWnd::OnLButtonDown( BOOL fDoubleClick, int x, int y, UINT keyFlags )
{
	FRX::CRect		rc;
	CPieceSprite*	piece;
	CSprite*		sprite;
	Move*			move;
	int				toPoint, fromPoint;
	BOOL			bNeedRedraw = FALSE;

	// Status sprite?
	if ( m_Status->Enabled() && m_World.Hit( x, y, bgStatusLayer, bgStatusLayer ) )
	{
		bNeedRedraw = FALSE;
		m_Status->Tick( m_hWnd, 0 );
		OnStatusEnd();
	}
	// Dragging a piece?
	else if ( m_pPieceDragging )
	{
		bNeedRedraw = FALSE;
		fromPoint = m_pGame->GetPointIdx( m_pPieceDragging->GetWhitePoint() );
		toPoint = m_pGame->GetPointIdx( GetPointIdxFromXY( x, y ) );
		EraseHighlights();
		if ( m_pGame->IsValidDestPoint( fromPoint, toPoint, &move ) )
		{
			m_pGame->MakeMove( m_pPieceDragging->GetIndex(), fromPoint, toPoint, move );
			if ( m_pGame->IsTurnOver() )
			{
				DragEnd();
				
				SetCursor( m_hCursorArrow );

				m_pGame->SetState( bgStateEndTurn );

				//DisableBoard();

			}
			else
			{
				DragEnd();
				OnMouseMove( x, y, keyFlags );
			}
		}
		else
			DragEnd();
	}

	// Stone?
	else if (		( m_pGame->IsMyMove() )
			  &&    ( m_pGame->GetState() != bgStateRoll)
			  &&	(!m_pPieceDragging)
			  &&	(piece = (CPieceSprite*) m_World.Hit( x, y, bgHighlightLayer - 1, bgPieceLayer ) )
			)			
	{		
		fromPoint = m_pGame->GetPointIdx( piece->GetWhitePoint() );
		if ( m_pGame->IsValidStartPoint( fromPoint ) )
		{
			DragStart( piece );
			SetCursor( m_hCursorHand );
			bNeedRedraw = FALSE;
		}

	}

	if ( bNeedRedraw )
	{
		UpdateWnd();
	}
}


void CBGWnd::OnLButtonDblClick( BOOL fDoubleClick, int x, int y, UINT keyFlags )
{

#ifdef BCKG_EASTEREGG

	CSprite* s;

	if (	(m_pGame->NeedToRollDice())
		&&	(s = m_World.Hit( x, y, bgDiceLayer, bgDiceLayer ) )
		&&	(s->GetCookie() == bgSpriteCube)
		&&	(keyFlags & MK_CONTROL)
		&&	(keyFlags & MK_SHIFT) )
	{
		CreditWnd* p = new CreditWnd;
		p->Init( m_hInstance, m_hWnd, m_Palette );
	}

#endif

}

#if _DEBUG_UI

void CBGWnd::OnRButtonDblClick( BOOL fDoubleClick, int x, int y, UINT keyFlags )
{

	CRollDiceDlg dlg;
	int v0, v1;

	if ( !m_pGame->NeedToRollDice() )
		return;
	m_pGame->GetDice( m_pGame->m_Player.m_Seat, &v0, &v1 );
	
	HINSTANCE hInstance = ZShellResourceManager()->GetResourceInstance( MAKEINTRESOURCE(IDD_ROLL_DICE), RT_DIALOG );

	if ( FAILED(dlg.Init( hInstance, IDD_ROLL_DICE )) )
		return;
	if ( !dlg.Modal( m_hWnd ) )
		return;
	m_pGame->m_SharedState.StartTransaction( bgTransDice );
	if ( v1 == 0 )
		m_pGame->SetDice( m_pGame->m_Player.m_Seat, dlg.m_Dice[0], dlg.m_Dice[1] );
	else
		m_pGame->SetDice( m_pGame->m_Player.m_Seat, dlg.m_Dice[0], -1 );
	m_pGame->m_SharedState.SendTransaction( TRUE );
}

#endif _DEBUG_UI

void CBGWnd::OnMouseMove( int x, int y, UINT keyFlags )
{
	CSprite* sprite;
	CPieceSprite* piece;

	/*
	// don't really care if kibitzer is moving the mouse
	if ( m_pGame->IsKibitzer() )
	{
		SetCursor( m_hCursorArrow );
		return;
	}
	*/

	// dragging a piece
	if ( m_pPieceDragging )
	{
		DragUpdate( x, y );
		SetCursor( m_hCursorHand );
	}
	/*
	// need to roll dice?
	else if (	(m_pGame->NeedToRollDice())
			 &&	(sprite = m_World.Hit( x, y, bgDiceLayer, bgDiceLayer ))
			 &&	(sprite->GetCookie() == bgSpritePlayersDice) )
	{
		SetCursor( m_hCursorHand );
	}
	*/
	// need to move a stone?
	else if ( m_pGame->IsMyMove() && !m_SelectRect.Enabled() && !m_FocusRect.Enabled() )	//We only want to erase the highlights if the selection rect or focus rect is not enabled.
																							//if it is enabled it means that the keyboard had the current input focus
	{
		if (	(piece = (CPieceSprite*) m_World.Hit( x, y, bgHighlightLayer - 1, bgPieceLayer ))
			&&	(m_pGame->IsValidStartPoint( m_pGame->GetPointIdx( piece->GetWhitePoint() )) ))
		{
			DrawHighlights(  m_pGame->GetPointIdx( piece->GetWhitePoint() ) );
			SetCursor( m_hCursorHand );
		}
		else
		{
			EraseHighlights();
			SetCursor( m_hCursorArrow );
		}
	}

	// default to arrow
	else
	{
		SetCursor( m_hCursorArrow );
	}
}


void CBGWnd::OnKey(UINT vk, BOOL fDown, int cRepeat, UINT flags)
{
	if ( !fDown && (vk == VK_ESCAPE) )
	{

		if ( m_Status->Enabled() )
		{
			m_Status->Tick( m_hWnd, 0 );
			OnStatusEnd();
		}

		DragEnd();

	}

}


void CBGWnd::OnActivate( UINT state, HWND hwndActDeact, BOOL fMinimized )
{
	if ( state == WA_INACTIVE )
		DragEnd();
}


void CBGWnd::OnTimer( UINT id )
{
	switch ( id )
	{
	case 1:
		UpdatePieces();
		break;
	case 2:
		UpdateDice();
		break;
	case 3:
		if ( m_Status->Tick( m_hWnd, STATUS_INTERVAL ) )
			OnStatusEnd();
		break;
	}
}


void CBGWnd::OnEnable( BOOL bEnabled )
{
	if ( bEnabled )
		m_pGAcc->GeneralEnable();
	else
		m_pGAcc->GeneralDisable();
}


void CBGWnd::UpdatePieces()
{
	long x, y;
	double t;
	int snd;
	CPieceSprite* s;

	while ( m_nAnimatingPieces )
	{
		s = m_AnimatingPieces[ m_nAnimatingPieces - 1 ];
		s->time += MOVE_INTERVAL;
		if ( s->time >= 1.0 )
		{
			// which sound should we play?
			switch( s->destEnd )
			{
			case bgBoardPlayerHome:
			case bgBoardOpponentHome:
				snd = bgSoundBear;
				break;
			case bgBoardPlayerBar:
			case bgBoardOpponentBar:
				snd = bgSoundHit;
				break;
			default:
				snd = bgSoundPlacePiece;
				break;
			}

			// remove sprite from list and put it on the point
			AddPiece( s->destEnd, s->GetIndex(), snd );
			m_nAnimatingPieces--;
		}
		else
		{
			t = 1.0 - s->time;
			x = (long) ((t * t * s->start.x) + (s->time * s->time * s->end.x) + (2 * s->time * t * s->ctrl.x));
			y = (long) ((t * t * s->start.y) + (s->time * s->time * s->end.y) + (2 * s->time * t * s->ctrl.y));
			s->SetXY( (long) x, (long) y );
			break;
		}
	}

	// update display
	UpdateWnd();

	// remove timer
	if ( m_nAnimatingPieces <= 0 )
	{
		KillTimer( NULL, m_hMovementTimer );
		m_hMovementTimer = NULL;
		m_pGame->SetQueueMessages( FALSE );
	}
}


int CBGWnd::PickDie( int idx )
{
	int v = 0;
	int x = ZRandom(6);
	for (;;)
	{
		for ( int i = 0; i < 6; i++, x++ )
		{
			if ( v = m_DiceValues[idx][x % 6] )
			{
				m_DiceValues[idx][x % 6] = 0;
				return v;
			}
		}
		for ( i = 0; i < 6; i++ )
			m_DiceValues[idx][i] = i + 1;
	}
}


void CBGWnd::UpdateDice()
{
	int state, color;

	//Behavior change for server side dice roll make sure that 
	if ( m_DiceCounter++ < 5)
	{
		if((m_DiceCounter == 5) && (m_pGame->GetState() != bgStateInitialRoll) && !m_fDiceRollReceived)
			m_DiceCounter = 0;
			
		// get player's dice color
		if ( m_pGame->m_Player.GetColor() == zBoardBrown )
			color = 0;
		else
			color = 1;

		// get first random die
		state = DiceStates[ color ][ 0 ][ PickDie( 0 ) ];
		state += m_DiceCounter % 2;
		m_Dice[2]->SetEnable( TRUE );
		m_Dice[2]->SetState( state );

		// get second random die
		if (	(m_pGame->GetState() == bgStateRoll)
			||	(m_pGame->GetState() == bgStateRollPostDouble)
			||	(m_pGame->GetState() == bgStateRollPostResign) )
		{
			state = DiceStates[ color ][ 0 ][ PickDie( 1 ) ];
			state += m_DiceCounter % 2;
			m_Dice[3]->SetEnable( TRUE );
			m_Dice[3]->SetState( state );
		}

		// update screen
		UpdateWnd();
	}
	else
	{
		// cancel timer
		KillTimer( m_hWnd, 2);
		m_hDiceTimer = NULL;

		// set cursor to arrow
		SetCursor( m_hCursorArrow );

		// done rolling dice, settle on final state
	
			if (	(m_pGame->GetState() == bgStateRoll) 
				||	(m_pGame->GetState() == bgStateRollPostDouble)
				||	(m_pGame->GetState() == bgStateRollPostResign ) )
			{ 
				//final dice setting is here.
				m_pGame->SetDice( m_pGame->m_Player.m_Seat, m_nRecievedD1, m_nRecievedD2 );
				m_pGame->SetState( bgStateMove );

				//DrawDice(TRUE);
			}
			else
			{
                //Why are we doing this because server needs to know when first roll occurs
                //of course previous owners of this code didn't put this roll on server
                ZBGMsgEndTurn msg;
		        msg.seat = m_pGame->m_Seat;
		        m_pGame->RoomSend( zBGMsgGoFirstRoll, &msg, sizeof(msg) );

				m_pGame->m_SharedState.StartTransaction( bgTransDice );
					m_pGame->SetDiceSize( m_pGame->m_Player.m_Seat, 0, 0 );
					m_pGame->SetDice( m_pGame->m_Player.m_Seat, (rand() % 6)+1/*ZRandom(6)+1*/, -1 );
				m_pGame->m_SharedState.SendTransaction( TRUE );			

			}

	}
}

///////////////////////////////////////////////////////////////////////////////
// Animation functions
/////////////////////////////////////////////////////////////////////////////////

void CBGWnd::DiceStart()
{
	// disable buttons
	m_pGame->EnableDoubleButton( FALSE );
	m_pGame->EnableResignButton( FALSE );
	m_pGame->EnableRollButton( FALSE, TRUE );

	// update screen
	UpdateWnd();

	// start dice rolling
	if ( !m_hDiceTimer )
	{
		m_pGame->PlaySound( bgSoundRoll );
		m_pGame->SetDice( m_pGame->m_Player.m_Seat, -1, -1 );
		m_DiceCounter = 0;
		for ( int i = 0; i < 6; i++ )
		{
			m_DiceValues[0][i] = i + 1;
			m_DiceValues[1][i] = i + 1;
		}
		
		//Server side rolling
		if((m_pGame->GetState() == bgStateRoll)
			||	(m_pGame->GetState() == bgStateRollPostDouble)
			||	(m_pGame->GetState() == bgStateRollPostResign))
			m_pGame->SendRollRequest();

		m_hDiceTimer = SetTimer( m_hWnd, 2, 115, NULL );
		UpdateDice();
		
	}
}


void CBGWnd::MovementStart( CPieceSprite* s, int destPt )
{	
	// add piece to animating list
	m_AnimatingPieces[ m_nAnimatingPieces++ ] = s;

	// remove blotted piece
	if ( m_nAnimatingPieces == 2 )
		DelPiece( destPt, m_AnimatingPieces[0]->GetIndex() );
	
	// initialize animation data
	s->GetXY( &s->start.x, &s->start.y );
	s->destEnd = destPt;
	CalcEndPosition( s );

	// restore blotted piece to screen, but not point
	if ( m_nAnimatingPieces == 2 )
		m_AnimatingPieces[0]->SetEnable( TRUE );

	// prepare sprite for animation
	s->ctrl.y = 188;
	if ( s->start.x > s->end.x )
		s->ctrl.x = s->end.x + (s->start.x - s->end.x) / 2;
	else
		s->ctrl.x = s->start.x + (s->end.x - s->start.x) / 2;
	s->time = 0;
	s->SetXY( s->start.x, s->start.y );
	s->SetLayer( bgDragLayer );
	s->SetState( 0 );

	// create timer
	if ( !m_hMovementTimer )
	{
		m_hMovementTimer = SetTimer( m_hWnd, 1, (UINT)(MOVE_INTERVAL * 1000), NULL );
		m_pGame->SetQueueMessages( TRUE );
	}
}


///////////////////////////////////////////////////////////////////////////////
// Update functions
/////////////////////////////////////////////////////////////////////////////////

void CBGWnd::AddPiece( int pt, int pi, int sound )
{
	PointDisplay* p = &m_Points[ pt ];
	CPieceSprite* s = m_Pieces[ pi ];

	// piece already assigned to this point?
	if ( s->GetWhitePoint() == pt )
		return;

	// remove piece from previous point
	if ( s->GetWhitePoint() >= 0 )
		DelPiece( s->GetWhitePoint(), pi );

	// add piece to current point
	p->pieces[ p->nPieces ] = pi;
	s->SetPoint( pt );
	m_pGame->m_SharedState.Set( bgPieces, pi, pt );
	p->nPieces++;

	// move pieces around
	AdjustPieces( pt );

	// play sound
	m_pGame->PlaySound( (BackgammonSounds) sound );
}


void CBGWnd::DelPiece( int pt, int pi )
{
	PointDisplay* p = &m_Points[ pt ];

	// remove piece from array
	for ( int i = 0; i < p->nPieces; i++ )
	{
		if ( p->pieces[i] == pi )
			break;
	}
	if ( i == p->nPieces )
		return;
	m_Pieces[ pi ]->SetPoint( -1 );
	m_Pieces[ pi ]->SetEnable( FALSE );
	for ( p->nPieces--; i < p->nPieces; i++ )
		p->pieces[i] = p->pieces[i+1];

	// move pieces around
	AdjustPieces( pt );
}


void CBGWnd::AdjustPieces( int pt )
{
	long x, y, height;
	CPieceSprite* s;
	PointDisplay* p = &m_Points[ pt ];
	int state;

	// nothing to do
	if ( p->nPieces <= 0 )
		return;

	// final piece state
	if ( (pt == bgBoardPlayerHome) || (pt == bgBoardOpponentHome) )
		state = 1;
	else
		state = 0;

	// calculate height increment per piece
	height = m_Pieces[ p->pieces[0] ]->GetStateHeight( state );
	if ( (p->nPieces * height) > p->rect.GetHeight() )
		height = ( p->rect.GetHeight() - height ) / ( p->nPieces - 1 );

	// set piece position and state
	if ( p->topDown )
	{
		x = p->rect.left;
		y = p->rect.top;
		for ( int i = 0; i < p->nPieces; i++ )
		{
			s = m_Pieces[ p->pieces[i] ];
			s->SetState( state );
			s->SetLayer( bgPieceLayer + i );
			s->SetEnable( TRUE );
			s->SetXY( x, y );
			y += height;
		}
	}
	else
	{
		x = p->rect.left;
		y = p->rect.bottom - m_Pieces[ p->pieces[0] ]->GetStateHeight( state );
		for ( int i = 0; i < p->nPieces; i++ )
		{
			s = m_Pieces[ p->pieces[i] ];
			s->SetState( state );
			s->SetLayer( bgPieceLayer + i );
			s->SetEnable( TRUE );
			s->SetXY( x, y );
			y -= height;
		}
	}
}


void CBGWnd::CalcEndPosition( CPieceSprite* s )
{
	long y, height;
	PointDisplay* p = &m_Points[ s->destEnd ];
	int state;

	// final piece state
	if ( (s->destEnd == bgBoardPlayerHome) || (s->destEnd == bgBoardOpponentHome) )
		state = 1;
	else
		state = 0;

	// calculate height increment per piece
	height = s->GetStateHeight( state );
	if ( ((p->nPieces + 1) * height) > p->rect.GetHeight() )
		height = ( p->rect.GetHeight() - height ) / p->nPieces;

	// set piece position and state
	if ( p->topDown )
		y = p->rect.top + (height * p->nPieces);
	else
		y = (p->rect.bottom - s->GetStateHeight( state )) - (height * p->nPieces);
	s->SetEnable( TRUE );
	s->end.x = p->rect.left;
	s->end.y = y;
}


///////////////////////////////////////////////////////////////////////////////
// Draw functions
/////////////////////////////////////////////////////////////////////////////////

void CBGWnd::DrawAll()
{
	// redraw everything
	DrawBoard( FALSE );
	DrawNotation( FALSE );
	DrawDice( FALSE );
	DrawCube( FALSE );
	DrawAvatars( FALSE );
	DrawScore( FALSE );
	DrawPips( FALSE );
	DrawPlayerHighlights( FALSE );

	// update screen
	UpdateWnd();
}


void CBGWnd::DrawBoard( BOOL fPaint )
{
	int pt;

	// assign pieces to their points
	for ( int i = 0; i < 30; i++ )
	{
		pt = m_pGame->m_SharedState.Get( bgPieces, i );
		if ( pt < 0 )
			continue;
		AddPiece( pt, i, bgSoundNone );
	}

	// update screen
	if ( fPaint )
	{
		UpdateWnd();
	}
}


void CBGWnd::DrawNotation( BOOL fPaint )
{
	FRX::CRect rc;
	int i;

	if ( m_pGame->m_Settings.Notation )
	{

		for ( i = 0; i < 4; i++ )
			m_Notation[i]->SetEnable( TRUE );
		
		rc = m_Rects[ IDR_NOTATION_TOP_HIGH ];
		m_Notation[0]->SetXY( rc.left, rc.top );
		m_Notation[0]->SetState( 1 );

		rc = m_Rects[ IDR_NOTATION_TOP_LOW ];
		m_Notation[1]->SetXY( rc.left, rc.top );
		m_Notation[1]->SetState( 0 );

		rc = m_Rects[ IDR_NOTATION_BOT_HIGH ];
		m_Notation[2]->SetXY( rc.left, rc.top );
		m_Notation[2]->SetState( 1 );

		rc = m_Rects[ IDR_NOTATION_BOT_LOW ];
		m_Notation[3]->SetXY( rc.left, rc.top );
		m_Notation[3]->SetState( 0 );

	}
	else
	{
		for ( i = 0; i < 4; i++ )
			m_Notation[i]->SetEnable( FALSE );
	}

	// update screen
	if ( fPaint )
	{
		UpdateWnd();
	}
}


void CBGWnd::DrawDice( BOOL fPaint )
{
	FRX::CRect rc;
	int color;
	int state;
	int v0, v1, s0, s1;
	
	// opponent's dice
	if ( m_pGame->m_Opponent.GetColor() == zBoardBrown )
		color = 0;
	else
		color = 1;
		
	if(m_fDiceRollReceived) //lee
	{
		if( m_pGame->m_SharedState.Get( bgActiveSeat ) != m_pGame->m_Player.m_Seat )
		{
	   	  v0 = m_nRecievedD1;
		  v1 = m_nRecievedD2;
		}
		else
		{
		  v0=v1=-1;
		}
	}
	else
		m_pGame->GetDice( m_pGame->m_Opponent.m_Seat, &v0, &v1 );

	m_pGame->GetDiceSize( m_pGame->m_Opponent.m_Seat, &s0, &s1 );
	ASSERT( (v0 <= 6) && (v1 <= 6) );
	ASSERT( (s0 >= 0) && (s0 <= 2 ) && (s1 >= 0) && (s1 <= 2) );
	if ( v0 <= 0 )
		m_Dice[0]->SetEnable( FALSE );
	else
	{
		state = DiceStates[ color ][ s0 ][ v0 ];
		m_Dice[0]->SetState( state );
		m_Dice[0]->SetEnable( TRUE );
	}
	if ( v1 <= 0 )
		m_Dice[1]->SetEnable( FALSE );
	else
	{
		state = DiceStates[ color ][ s1 ][ v1 ];
		m_Dice[1]->SetState( state );
		m_Dice[1]->SetEnable( TRUE );
	}
		
	// player's dice
	color = !color;
	if(m_fDiceRollReceived) //lee
	{
		if( m_pGame->m_SharedState.Get( bgActiveSeat ) == m_pGame->m_Player.m_Seat )
		{
	   	  v0 = m_nRecievedD1;
		  v1 = m_nRecievedD2;
		}
		else
		{
		  v0=v1=-1;
		}
	}
	else
		m_pGame->GetDice( m_pGame->m_Player.m_Seat, &v0, &v1 );

	m_pGame->GetDiceSize( m_pGame->m_Player.m_Seat, &s0, &s1 );
	ASSERT( (v0 <= 6) && (v1 <= 6) );
	ASSERT( (s0 >= 0) && (s0 <= 2 ) && (s1 >= 0) && (s1 <= 2) );
	if ( v0 < 0 || ( v0 == 0 && m_pGame->IsKibitzer() ) )
		m_Dice[2]->SetEnable( FALSE );
	else
	{
		state = DiceStates[ color ][ s0 ][ v0 ];
		m_Dice[2]->SetState( state );
		m_Dice[2]->SetEnable( TRUE );
		
	}
	if ( v1 < 0 || ( v1 == 0 && m_pGame->IsKibitzer() ) )
		m_Dice[3]->SetEnable( FALSE );
	else
	{
		state = DiceStates[ color ][ s1 ][ v1 ];
		m_Dice[3]->SetState( state );
		m_Dice[3]->SetEnable( TRUE );
	}
	// center dice
	if ( m_pGame->GetState() == bgStateInitialRoll &&  !m_Dice[1]->Enabled() && !m_Dice[3]->Enabled())
	{			
			//rc = m_Rects[ IDR_BROWN_BIG_DICE_0 ];
			
			if ( m_Dice[0]->Enabled() )
			{
				//rc.CenterRect( m_Rects[ IDR_DICE_INITAL_LEFT ] );
				rc = m_Rects[ IDR_DICE_INITAL_LEFT ];
				m_Dice[0]->SetXY( rc.left, rc.top );
			}

			if ( m_Dice[2]->Enabled() )
			{
				//rc.CenterRect( m_Rects[ IDR_DICE_INITAL_RIGHT ] );
				rc = m_Rects[ IDR_DICE_INITAL_RIGHT ];
				m_Dice[2]->SetXY( rc.left, rc.top );
			}			
	}
	else
	{
		for ( int i = 0; i < 4; i++ )
		{
			rc.SetRect( 0, 0, m_Dice[i]->GetWidth(), m_Dice[i]->GetHeight() );		
			rc.CenterRect( m_Rects[ IDR_DICE_LEFT_ONE + i ] );
			m_Dice[i]->SetXY( rc.left, rc.top );
		}
	}
	// update screen
	if ( fPaint )
	{
		UpdateWnd();
	}
}


void CBGWnd::DrawCube( BOOL fPaint )
{
	
	RECT rc;
	int value = m_pGame->m_SharedState.Get( bgCubeValue );
	int owner = m_pGame->m_SharedState.Get( bgCubeOwner );

	// set enable
	if ( value < 2 )
		m_Cube->SetEnable( FALSE );
	else
		m_Cube->SetEnable( TRUE );

	// set position
	//if ( owner == zBoardNeutral )
	//	rc = m_Rects[ IDR_CUBE_NEUTRAL ];
	
	if ( owner == m_pGame->m_Player.GetColor() )
		rc = m_CubePlayerPosition;
	else
		rc = m_CubeOpponentPosition;
	m_Cube->SetXY( rc.left, rc.top );

	// set face value (i.e. sprite state)
	int idx = 0;
	for ( value >>= 1; value > 1; value >>= 1 )
		idx++;
	m_Cube->SetState( idx );

	// update screen
	if ( fPaint )
	{
		UpdateWnd();
	}
	
}

void CBGWnd::RollButtonDraw( CRolloverButton* pButton, CRolloverButton::ButtonState state, DWORD cookie )
{
	FRX::CRect				 rc;
	RECT					 rect;
	BackgammonSounds		 snd;		
	CBGWnd* pObj = (CBGWnd*) cookie;
	HRESULT					 hr;
	
	pObj->m_Roll->SetState( state );

	pObj->UpdateWnd();

	if ( pObj->m_OldRollState != (int) state )
	{
		switch ( state )
		{
		case CRolloverButton::Highlight:
			if ( pObj->m_OldRollState != CRolloverButton::Pressed )
				snd = bgSoundButtonHighlight;
			else
				snd = bgSoundNone;
			SetCursor( pObj->m_hCursorHand );
			break;
		case CRolloverButton::Pressed:			
			snd = bgSoundNone;
			SetCursor( pObj->m_hCursorHand );
			break;
		default:
			SetCursor( pObj->m_hCursorArrow );
			snd = bgSoundNone;
			break;
		}
		pObj->m_pGame->PlaySound( snd );
		pObj->m_OldRollState = (int) state;
	}
	
}



void CBGWnd::DoubleButtonDraw( CRolloverButton* pButton, CRolloverButton::ButtonState state, DWORD cookie )
{
	
	FRX::CRect			 rc;
	BackgammonSounds snd;
	CBGWnd*			 pObj = (CBGWnd*) cookie;

	pObj->m_Double->SetState( state );
	
	pObj->UpdateWnd();

	if ( pObj->m_OldDoubleState != (int) state )
	{
		switch ( state )
		{
		case CRolloverButton::Highlight:
			if ( pObj->m_OldDoubleState != CRolloverButton::Pressed )
				snd = bgSoundButtonHighlight;
			else
				snd = bgSoundNone;

			SetCursor( pObj->m_hCursorHand );
			break;
		case CRolloverButton::Pressed:			
			snd = bgSoundButtonDown;
			SetCursor( pObj->m_hCursorHand );
			break;
		default:
			SetCursor( pObj->m_hCursorArrow );
			snd = bgSoundNone;
			break;
		}
		pObj->m_pGame->PlaySound( snd );
		pObj->m_OldDoubleState = (int) state;
	}
	
}


void CBGWnd::ResignButtonDraw( CRolloverButton* pButton, CRolloverButton::ButtonState state, DWORD cookie )
{
	
	FRX::CRect					 rc;
	BackgammonSounds		 snd;
	CBGWnd* pObj = (CBGWnd*) cookie;

	pObj->m_Resign->SetState( state );
	
	pObj->UpdateWnd();

	if ( pObj->m_OldResignState != (int) state )
	{
		switch ( state )
		{
		case CRolloverButton::Highlight:
			if ( pObj->m_OldResignState != CRolloverButton::Pressed )
				snd = bgSoundButtonHighlight;
			else
				snd = bgSoundNone;
			SetCursor( pObj->m_hCursorHand );
			break;
		case CRolloverButton::Pressed:			
			snd = bgSoundButtonDown;
			SetCursor( pObj->m_hCursorHand );
			break;
		default:
			snd = bgSoundNone;
			SetCursor( pObj->m_hCursorArrow );
			break;
		}
		pObj->m_pGame->PlaySound( snd );
		pObj->m_OldResignState = (int) state;
	}	
}


void CBGWnd::DrawHighlights( int PointIdx, BOOL fPaint )
{
	FRX::CRect rc;
	int i, j, idx;
	
	// get board state index
	idx = PointIdxToBoardStateIdx( PointIdx );
	if ( (idx < 0) || (idx > zMoveBar) )
	{
		EraseHighlights( fPaint );
		return;
	}
	
	// traverse valid move list
	MoveList* mlist = &m_pGame->m_TurnState.valid[idx];
	for ( j = 0, i = 0; (i < mlist->nmoves) && (j < 2); i++ )
	{
		rc = m_Rects[ IDR_HPT_HOME + mlist->moves[i].to ];
		if ( mlist->moves[i].takeback >= 0 )
		{
			if ( mlist->moves[i].to == 25 )
				m_BackwardDiamond->SetState( 1 );
			else
				m_BackwardDiamond->SetState( 0 );
			m_BackwardDiamond->SetEnable( m_pGame->m_Settings.Moves );
			m_BackwardDiamond->SetXY( rc.left, rc.top );
		}
		else
		{
			m_ForwardDiamond[j]->SetEnable( m_pGame->m_Settings.Moves );
			m_ForwardDiamond[j++]->SetXY( rc.left, rc.top );
		}		
	}

	// update screen
	if ( fPaint )
	{
		UpdateWnd();
	}
}


void CBGWnd::EraseHighlights( BOOL fPaint )
{
	// disable hightlight sprites
	m_BackwardDiamond->SetEnable( FALSE );
	for ( int i = 0; i < 2; i++ )
		m_ForwardDiamond[i]->SetEnable( FALSE );

	// update screen
	if ( fPaint )
	{
		UpdateWnd();
	}
}


void CBGWnd::DrawAvatars( BOOL fPaint )
{
	//Draw Brown
	m_Names[1]->SetEnable( TRUE );
	m_Names[1]->Update();

	//Draw White
	m_Names[0]->SetEnable( TRUE );
	m_Names[0]->Update();

	// update sprites on screen
	if ( fPaint )
	{
		UpdateWnd();
	}

}


void CBGWnd::DrawPlayerHighlights( BOOL fPaint )
{

	FRX::CRect rc;

	if ( (m_pGame->GetState() == bgStateInitialRoll) )
	{
		m_HighlightPlayer[0]->SetState( 0 );
		m_HighlightPlayer[1]->SetState( 0 );		
	}
	//Player is active
	else if( m_pGame->m_SharedState.Get( bgActiveSeat ) != m_pGame->m_Player.m_Seat )
	{
		m_HighlightPlayer[0]->SetState( 0 );
		m_HighlightPlayer[1]->SetState( 1 );
	}
	else //Opponent is active
	{
		m_HighlightPlayer[0]->SetState( 1 );
		m_HighlightPlayer[1]->SetState( 0 );
	}

	// update sprites on screen
	if ( fPaint )
	{
		UpdateWnd();
	}
}


void CBGWnd::DrawScore( BOOL fPaint )
{
	int Score;
	TCHAR buff[128], title[128];
	FRX::CRect rc;
	
	Score = m_pGame->m_SharedState.Get( bgScore, m_pGame->m_Opponent.m_Seat );	

	m_Score[0]->SetEnable( TRUE );
	m_Score[0]->Update();

	wsprintf( buff, _T("%d"), Score );
	m_ScoreTxt[0]->SetText( buff, DT_RIGHT | DT_TOP );	
	m_ScoreTxt[0]->SetEnable( TRUE );

	Score = m_pGame->m_SharedState.Get( bgScore, m_pGame->m_Player.m_Seat   );

	m_Score[1]->SetEnable( TRUE );
	m_Score[1]->Update();

	wsprintf( buff, _T("%d"), Score );
	m_ScoreTxt[1]->SetText( buff, DT_RIGHT | DT_TOP );	
	m_ScoreTxt[1]->SetEnable( TRUE );


	ZShellResourceManager()->LoadString( IDS_MATCH_POINTS, title, 128 );
	Score = m_pGame->m_SharedState.Get( bgTargetScore );	
	wsprintf( buff, _T("%s %d"), title, Score );	
	m_MatchTxt->SetText( buff, DT_CENTER );
	m_MatchTxt->SetEnable( TRUE );
	
	// update screen
	if ( fPaint )
	{
		UpdateWnd();
	}
}


void CBGWnd::DrawPips( BOOL fPaint )
{
	int Score;
	TCHAR buff[64], temp[64];
	FRX::CRect rc;


	Score = m_pGame->CalcPipsForColor( m_pGame->m_Opponent.GetColor() );
		
	m_Pip[0]->SetEnable( m_pGame->m_Settings.Pip );	
	m_Pip[0]->Update();

	wsprintf( buff, _T("%d"), Score );	
	m_PipTxt[0]->SetEnable( m_pGame->m_Settings.Pip );
	m_PipTxt[0]->SetText( buff, DT_RIGHT | DT_TOP );
		
	
	Score = m_pGame->CalcPipsForColor( m_pGame->m_Player.GetColor() );

	m_Pip[1]->SetEnable( m_pGame->m_Settings.Pip );	
	m_Pip[1]->Update();

	wsprintf( buff, _T("%d"), Score );	
	m_PipTxt[1]->SetText( buff, DT_RIGHT | DT_TOP );
	m_PipTxt[1]->SetEnable( m_pGame->m_Settings.Pip );	

	

	// update screen
	if ( fPaint )
	{
		UpdateWnd();
	}
}


HBRUSH CBGWnd::OnCtlColor(HDC hdc, HWND hwndChild, int type)
{
	/*
	LOGBRUSH brush;
	
	if ( (hwndChild == m_pChat->m_hWndDisplay) || (hwndChild == m_pChat->m_hWndEnter) )
	{
		if ( !m_hBrush )
		{
			brush.lbStyle = BS_SOLID;
			brush.lbColor = PALETTERGB( 255, 255, 255 );
			m_hBrush = CreateBrushIndirect( &brush );
		}
		return m_hBrush;
	}
	*/
	return NULL;
}


void CBGWnd::StatusDisplay( int type, int nTxtId, int nTimeout, int NextState )
{
	TCHAR buff[2048];

	ZShellResourceManager()->LoadString( nTxtId, buff, 2048 );
	StatusDisplay( type, buff, nTimeout, NextState );
}


void CBGWnd::StatusDisplay( int type, TCHAR* txt, int nTimeout, int NextState )
{
	m_Status->Properties( m_hWnd, m_Rects, type, nTimeout, txt, NextState );
	if ( !m_hStatusTimer )
		m_hStatusTimer =  SetTimer( m_hWnd, 3, STATUS_INTERVAL, NULL );
}


void CBGWnd::StatusClose()
{
	if ( m_Status->Tick( m_hWnd, 0 ) )
	{
		m_Status->SetNextState( bgStateUnknown );
		OnStatusEnd();
	}
}


void CBGWnd::OnStatusEnd()
{
		// release timer
	if ( m_hStatusTimer )
	{
		KillTimer( m_hWnd, 3 );
		m_hStatusTimer =  NULL;
	}
	

	if ( (m_pGame->GetState() == bgStateInitialRoll && m_Status->m_bEnableRoll == TRUE ) /*|| m_pGame->GetState() == bgStateGameOver */) 
	{
		//We want to enable the roll button here as if StateInitalRoll was set before the status
		//dialog was dismissed the button was not enabled.  
		m_pGame->EnableRollButton( TRUE );

		// disable buttons
		m_pGame->EnableDoubleButton( FALSE );
		m_pGame->EnableResignButton( FALSE );
		m_Status->m_bEnableRoll = FALSE;		

		SetupRoll();
	}
	else if ( m_pGame->GetState() == bgStateMatchOver )
	{
		ZShellGameShell()->GameOver(m_pGame);
	}
	else if ( m_Status->GetNextState() > bgStateUnknown )
	{
		m_pGame->SetState( m_Status->GetNextState(), TRUE  );
	}
	
}


void CBGWnd::OnRatedEnd()
{
	ASSERT( FALSE );
};

void CBGWnd::OnRatedStart()
{
	ASSERT( FALSE );
};

void CBGWnd::OnExitEnd()
{

	PostMessageA( m_hWnd, WM_BG_SHUTDOWN, 0, 0 );
	ShowWindow( m_hWnd, SW_HIDE );

	m_pGame->Release();

};

void CBGWnd::OnExitStart()
{};
	

BOOL CBGWnd::OnSetCursor(HWND hwndCursor, UINT codeHitTest, UINT msg)
{
	return TRUE;
}

void CBGWnd::UpdateWnd()
{
	HDC hdc = GetDC( m_hWnd );
	m_World.Draw( hdc );
	ReleaseDC( m_hWnd, hdc );
}

void CBGWnd::DisableBoard()
{
	//Disable all the items on the board
	for ( long x = 0; x < NUM_POSTROLL_GACCITEMS; x++)
		m_pGAcc->SetItemEnabled(false, x + NUM_PREROLL_GACCITEMS ) ;
}

void CBGWnd::SetupMove()
{
	/*
	//Pop the roll items from the acc stack
	m_pGAcc->PopItemlist();
	*/
	//Enable all the items again
	for ( long x = 0; x < NUM_POSTROLL_GACCITEMS; x++)
		m_pGAcc->SetItemEnabled(true, x + NUM_PREROLL_GACCITEMS);

	//If there are any pieces on the bar then set the focus to the bar to start the turn
	if ( m_pGame->m_TurnState.points[zMoveBar].pieces > 0 )
	{
		m_pGAcc->SetItemEnabled( true, accMoveBar );
		m_pGAcc->SetFocus( accMoveBar );
	}
	else
	{
		// disable the bar, set focus
        m_pGAcc->SetFocus(m_pGAcc->GetItemGroupFocus(accPlayerSideStart));
		m_pGAcc->SetItemEnabled( false, accMoveBar );
	}

	//Disable the bear off zone in case it was enabled
	m_pGAcc->SetItemEnabled( false, accPlayerBearOff );	
}

void CBGWnd::SetupRoll()
{
	//Push the roll item list on the stack
	//m_pGAcc->PushItemlistG( m_PreRollGAccItem, NUM_PREROLL_GACCITEMS, 0, true, m_hRollAccelTable );
    DWORD dwDummy;
    if(m_pGAcc->GetGlobalFocus(&dwDummy) != S_OK)  // checks if the focus is active somewhere already (such as chat)
	    m_pGAcc->SetFocus(accRollButton);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\games\backgammon\bgwnd.h ===
#ifndef __BGWND_H__
#define __BGWND_H__

//#include "chat.h"
#include "BoardRects.h"
#include "sprites.h"
#include "GraphicalAcc.h"
#include "frx.h"

#define NEWACC 1

#if _DEBUG
#define _DEBUG_UI	0
#else
#define _DEBUG_UI	0
#endif


#define NUM_PREROLL_GACCITEMS   4
#define NUM_POSTROLL_GACCITEMS 29
#define NUM_BKGACC_ITEMS		NUM_PREROLL_GACCITEMS + NUM_POSTROLL_GACCITEMS


enum BackgammonCursorType
{
	bgCursorArrow,
	bgCursorHand,
	bgCursorNone
};



enum AccessibilityTypeLayer
{
	accMoveLayer = 1,
	accRollLayer = 2
};


#define ACCTOBOARD( idx ) ((idx) - NUM_PREROLL_GACCITEMS)

enum AccessibilityTypeItem
{
	accMoveBar			= 26 + NUM_PREROLL_GACCITEMS,				//Player bar
	accPreBar			= 17 + NUM_PREROLL_GACCITEMS,
	accPostBar			= 18 + NUM_PREROLL_GACCITEMS,
	accPlayerBearOff	= 24 + NUM_PREROLL_GACCITEMS,				
	accPlayerSideStart  = 0  + NUM_PREROLL_GACCITEMS,
	accPlayerSideEnd    = 11 + NUM_PREROLL_GACCITEMS,
	accOpponentSideStart= 12 + NUM_PREROLL_GACCITEMS,
	accOpponentSideEnd  = 23 + NUM_PREROLL_GACCITEMS,
	accRollButton		= 0,
	accDoubleButton		= 1,
	accResignButton		= 2,
	accStatusExit		= 3,
};




///////////////////////////////////////////////////////////////////////////////
// User defined window messages
///////////////////////////////////////////////////////////////////////////////

enum
{
	// User define messages
	WM_BG_SETTINGDLG_START = WM_USER + 1,
	WM_BG_SETTINGDLG_END,
	WM_BG_SETTINGDLG_SEND,
	WM_BG_KIBITZER_END,
	WM_BG_RESIGN_START,
	WM_BG_RESIGN_END,
	WM_BG_RESIGNACCEPT_END,
	WM_BG_SHUTDOWN,
	WM_BG_EXIT_START,
	WM_BG_EXIT_END,
	WM_BG_EXIT_RATED_START,
	WM_BG_EXIT_RATED_END,

};


/* void OnSettingDlgStart() */
#define PROCESS_WM_BG_SETTINGDLG_START(wParam, lParam, fn) \
	((fn)(), 0L)

/* void OnSettingDlgEnd() */
#define PROCESS_WM_BG_SETTINGDLG_END(wParam, lParam, fn) \
	((fn)(), 0L)

/* void OnSettingDlgSend() */
#define PROCESS_WM_BG_SETTINGDLG_SEND(wParam, lParam, fn) \
	((fn)(), 0L)

/* void OnKibitzerEnd() */
#define PROCESS_WM_BG_KIBITZER_END(wParam, lParam, fn) \
	((fn)(), 0L)

/* void OnShutdown() */
#define PROCESS_WM_BG_SHUTDOWN(wParam, lParam, fn) \
	((fn)(), 0L)

/* void OnResignStart() */
#define PROCESS_WM_BG_RESIGN_START(wParam, lParam, fn) \
	((fn)(), 0L)

/* void OnResignEnd() */
#define PROCESS_WM_BG_RESIGN_END(wParam, lParam, fn) \
	((fn)(), 0L)

/* void OnResignEnd() */
#define PROCESS_WM_BG_EXIT_END(wParam, lParam, fn) \
	((fn)(), 0L)

/* void OnResignStart() */
#define PROCESS_WM_BG_EXIT_START(wParam, lParam, fn) \
	((fn)(), 0L)

/* void OnResignEnd() */
#define PROCESS_WM_BG_EXIT_RATED_END(wParam, lParam, fn) \
	((fn)(), 0L)

/* void OnResignStart() */
#define PROCESS_WM_BG_EXIT_RATED_START(wParam, lParam, fn) \
	((fn)(), 0L)



/* void OnResignAcceptEnd() */
#define PROCESS_WM_BG_RESIGNACCEPT_END(wParam, lParam, fn) \
	((fn)(), 0L)


///////////////////////////////////////////////////////////////////////////////
// Point structures
///////////////////////////////////////////////////////////////////////////////

struct PointDisplay
{
	PointDisplay();
	int			GetColor();

	int			topDown;
	int			nPieces;
	FRX::CRect	rect;
	FRX::CRect	rectHit;
	int			pieces[15];
};


///////////////////////////////////////////////////////////////////////////////
// Forward references
///////////////////////////////////////////////////////////////////////////////

class CGame;


///////////////////////////////////////////////////////////////////////////////
// Main backgammmon window
//////////////////////////////////////////////////////////////////////////////

class CBGWnd : public CWindow2
{
public:
	// Constructor and destructor
	CBGWnd();
	~CBGWnd();

	// Initialization routines
	HRESULT Init( HINSTANCE hInstance, CGame* pGame, const TCHAR* szTitle = NULL );
	HRESULT InitGraphics();
	HRESULT InitPoints();
	HRESULT InitAcc();

	virtual void OverrideClassParams( WNDCLASSEX& WndClass );
	virtual void OverrideWndParams( WNDPARAMS& WndParams );
	
	// Message map
	BEGIN_MESSAGE_MAP( CBGWnd );
		ON_MESSAGE( WM_CLOSE, OnClose );
		ON_MESSAGE( WM_DESTROY, OnDestroy );
		ON_MESSAGE( WM_PAINT, OnPaint );
		ON_MESSAGE( WM_COMMAND, OnCommand );
		ON_MESSAGE( WM_QUERYNEWPALETTE, OnQueryNewPalette );
		ON_MESSAGE( WM_PALETTECHANGED, OnPaletteChanged );
		ON_MESSAGE( WM_GETMINMAXINFO, OnGetMinMaxInfo );
		ON_MESSAGE( WM_SIZE, OnSize );
		ON_MESSAGE( WM_LBUTTONDOWN, OnLButtonDown );
		ON_MESSAGE( WM_LBUTTONDBLCLK, OnLButtonDblClick );
#if _DEBUG_UI
		ON_MESSAGE( WM_RBUTTONDBLCLK, OnRButtonDblClick );
#endif _DEBUG_UI
		ON_MESSAGE( WM_MOUSEMOVE, OnMouseMove );
		ON_MESSAGE( WM_KEYUP, OnKey );
		ON_MESSAGE( WM_KEYDOWN, OnKey );
		ON_MESSAGE( WM_ACTIVATE, OnActivate );
		ON_MESSAGE( WM_CTLCOLOREDIT, OnCtlColor );
		ON_MESSAGE( WM_CTLCOLORSTATIC, OnCtlColor );
		ON_MESSAGE( WM_TIMER, OnTimer );
		ON_MESSAGE( WM_BG_SETTINGDLG_START, OnSettingDlgStart );
		ON_MESSAGE( WM_BG_SETTINGDLG_END, OnSettingDlgEnd );
		ON_MESSAGE( WM_BG_SETTINGDLG_SEND, OnSettingsDlgSend );
//		ON_MESSAGE( WM_BG_KIBITZER_END, OnKibitzerEnd );
		ON_MESSAGE( WM_BG_SHUTDOWN, OnShutdown );
//		ON_MESSAGE( WM_BG_RESIGN_START, OnResignStart );
//		ON_MESSAGE( WM_BG_RESIGN_END, OnResignEnd );
		ON_MESSAGE( WM_BG_EXIT_START, OnExitStart );
		ON_MESSAGE( WM_BG_EXIT_END, OnExitEnd );
		ON_MESSAGE( WM_BG_EXIT_RATED_START, OnRatedStart );
		ON_MESSAGE( WM_BG_EXIT_RATED_END, OnRatedEnd );
		ON_MESSAGE( WM_SETCURSOR, OnSetCursor );
		ON_MESSAGE( WM_ENABLE, OnEnable );
		//ON_MESSAGE( WM_BG_RESIGNACCEPT_END, OnResignAcceptEnd );
	END_MESSAGE_MAP();

	// Message handlers
	BOOL OnQueryNewPalette();
	void OnClose();
	void OnDestroy();
	void OnPaint();
	void OnPaletteChanged( HWND hwndPaletteChange );
	void OnCommand(int id, HWND hwndCtl, UINT codeNotify);
	void OnGetMinMaxInfo(LPMINMAXINFO lpMinMaxInfo);
	void OnSize(UINT state, int cx, int cy);
	void OnLButtonDown( BOOL fDoubleClick, int x, int y, UINT keyFlags );
	void OnLButtonDblClick( BOOL fDoubleClick, int x, int y, UINT keyFlags );

#if _DEBUG_UI
	void OnRButtonDblClick( BOOL fDoubleClick, int x, int y, UINT keyFlags );
#endif _DEBUG_UI
	
	BOOL OnSetCursor(HWND hwndCursor, UINT codeHitTest, UINT msg);

	void OnMouseMove( int x, int y, UINT keyFlags );
	void OnKey( UINT vk, BOOL fDown, int cRepeat, UINT flags );
	void OnActivate( UINT state, HWND hwndActDeact, BOOL fMinimized );
	void OnTimer(UINT id);
	HBRUSH OnCtlColor(HDC hdc, HWND hwndChild, int type);
	void OnEnable( BOOL bEnabled );

	void OnShutdown();
	void OnSettingDlgStart();
	void OnSettingDlgEnd();
	void OnSettingsDlgSend();
	/*
	void OnKibitzerEnd();	
	void OnResignStart();
	void OnResignEnd();
	void OnResignAcceptStart();
	void OnResignAcceptEnd();
	*/
	void OnRatedEnd();
	void OnRatedStart();
	void OnExitEnd();
	void OnExitStart();
	

	// button callbacks
	static void DoubleButtonDraw( CRolloverButton* pButton, CRolloverButton::ButtonState state, DWORD cookie );
	static void ResignButtonDraw( CRolloverButton* pButton, CRolloverButton::ButtonState state, DWORD cookie );
	static void RollButtonDraw( CRolloverButton* pButton, CRolloverButton::ButtonState state, DWORD cookie );

	// Draw functions
	void DrawAll();
	void DrawAvatars( BOOL fPaint = TRUE );
	void DrawBoard( BOOL fPaint = TRUE );
	void DrawNotation( BOOL fPaint = TRUE );
	void DrawDice( BOOL fPaint = TRUE );
	void DrawCube( BOOL fPaint = TRUE );
	void DrawScore( BOOL fPaint = TRUE );
	void DrawPips( BOOL fPaint = TRUE );
	void DrawPlayerHighlights( BOOL fPaint = TRUE );
	void DrawHighlights( int PointIdx, BOOL fPaint = TRUE );
	void EraseHighlights( BOOL fPaint = TRUE );

	// update display
	void AddPiece( int pt, int pi, int sound );
	void DelPiece( int pt, int pi );
	void AdjustPieces( int pt );
	void CalcEndPosition( CPieceSprite* s );

	// utility functions
	int GetPointIdxFromXY( long x, long y );

	// animation
	int PickDie( int idx );
	void MovementStart( CPieceSprite* sprite, int destPt );
	void DiceStart();
	
	// drag functions
	void DragStart( CPieceSprite* sprite );
	void DragUpdate( long x, long y );
	void DragEnd();

	// timer functions
	void UpdatePieces();
	void UpdateDice();

	void UpdateWnd();

	// status display
	void StatusDisplay( int type, int nTxtId, int nTimeout, int NextState = -1 );
	void StatusDisplay( int type, TCHAR* txt, int nTimeout, int NextState = -1 );
	void StatusClose();
	void OnStatusEnd();


	void SetupMove();
	void SetupRoll();
	void DisableBoard();


public:
	
	// Child windows
	CRectSprite		m_FocusRect;
	CRectSprite		m_SelectRect;

	HACCEL			m_hAccelTable;
	
	// Child windows
	//CChatWnd* m_pChat;

	// Game pointer
	CGame* m_pGame;

	// Main window sizes
	long m_Width;

	// Rectangle lists
	CRectList m_Rects;
	CRectList m_RectList;
	
	// Palette pulled from m_Background
	CPalette m_Palette;

	// Turn state
	long			m_DragOffsetX;
	long			m_DragOffsetY;
	CPieceSprite*	m_pPieceDragging;
	int				m_ValidPoints[2];
	int				m_nValidPoints;

	// Cursors and highlights
	HCURSOR		m_hCursorHand;
	HCURSOR		m_hCursorArrow;
	HCURSOR		m_hCursorActive;

	BOOL		m_bHighlightOn;

	// Buttons
	CRolloverButton			m_DoubleButton;
	CButtonTextSprite*		m_Double;

	CRolloverButton			m_ResignButton;
	CButtonTextSprite*		m_Resign;

	CRolloverButton		    m_RollButton;
	CButtonTextSprite*      m_Roll;
		
	int						m_OldDoubleState;
	int						m_OldResignState;
	int						m_OldRollState;

	//Accesiblity
	CComPtr<IGraphicalAccessibility> m_pGAcc;

	struct GACCITEM			  m_BkGAccItems[NUM_BKGACC_ITEMS];

	// Sprite engine
	CSpriteWorldBackgroundDib*	m_WorldBackground;
	CSpriteWorld	m_World;
	CDibSection*	m_Backbuffer;
	CDib*			m_Background;
	CDib*			m_StatusDlgBmp;
	CStatusSprite*	m_Status;

	CDibSprite*		m_Cube;
	RECT			m_CubePlayerPosition;
	RECT			m_CubeOpponentPosition;
	
	CDibSprite*		m_BackwardDiamond;
	CDibSprite*		m_Kibitzers[ 2 ];
	CDibSprite*		m_ForwardDiamond[ 2 ];
	CDibSprite*		m_Dice[ 4 ];
	CDibSprite*		m_Notation[ 4 ];
	CDibSprite*     m_HighlightPlayer[ 2 ];


	CTextSprite*    m_Pip[ 2 ];
	CTextSprite*    m_Score[ 2 ];
	CTextSprite*	m_Names[ 2 ];
	CTextSprite*	m_ScoreTxt[ 2 ];
	CTextSprite*	m_PipTxt[ 2 ];
	CTextSprite*	m_MatchTxt;

	CPieceSprite*	m_Pieces[ 30 ];

	// board layout
	PointDisplay	m_Points[28];

	// brushes
	HBRUSH			m_hBrush;

	// piece animation list
	int				m_nAnimatingPieces;
	CPieceSprite*	m_AnimatingPieces[12];
	UINT			m_hMovementTimer;

	// dice animation
	UINT			m_hDiceTimer;
	int				m_DiceCounter;
	int				m_DiceValues[2][6];

	// status sprite
	UINT			m_hStatusTimer;

	//Variables for server side dice roll
	int16			m_fDiceRollReceived; 
	int16 			m_nRecievedD1,m_nRecievedD2;


};

#endif //!__BGWND_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\games\backgammon\game.cpp ===
#include "game.h"
#include "BoardData.h"

#include "zoneutil.h"

typedef DWORD (CALLBACK* GDIGETLAYOUTPROC)(HDC);
typedef DWORD (CALLBACK* GDISETLAYOUTPROC)(HDC, DWORD);

#ifndef LAYOUT_RTL
#define LAYOUT_LTR                         0x00000000
#define LAYOUT_RTL                         0x00000001
#define NOMIRRORBITMAP                     0x80000000
#endif

//WINBUG: some mirroring stuff will be in winuser.h someday
#ifndef WS_EX_LAYOUTRTL
#define WS_EX_LAYOUTRTL                    0x00400000L
#endif

BOOL ISRTL()
{		

	static BOOL bInit = FALSE;
	static BOOL bRet  = FALSE;
	
	if ( !bInit )
	{
		bRet  = ZIsLayoutRTL();	
		bInit = TRUE;
	}

	return bRet;
}


///////////////////////////////////////////////////////////////////////////////
// Global initialization
///////////////////////////////////////////////////////////////////////////////

const int gExitSaveStates[] =
{
	bgStateInitialRoll,
	bgStateDouble,
	bgStateRoll,
	bgStateRollPostDouble,
	bgStateRollPostResign,
	bgStateMove,
	bgStateEndTurn,
	bgStateGameOver,
	bgStateResignOffer,
	bgStateResignAccept,
	bgStateResignRefused,
	bgStateLastEntry
};


const int gNoAbandonStates[] =
{
	bgStateNotInit,
	bgStateWaitingForGameState,
	bgStateCheckSavedGame,
	bgStateRestoreSavedGame,
	bgStateGameSettings,
	bgStateInitialRoll,
	bgStateMatchOver,
	bgStateLastEntry
};

#define zBackgammonRes   _T("bckgres.dll")

///////////////////////////////////////////////////////////////////////////////
// Local initialization
///////////////////////////////////////////////////////////////////////////////

// must same order is SharedState enums
static SharedStateEntry InitSharedState[] =
{
	{ bgState,				0 },
	{ bgCrawford,			0 },
	{ bgTimestampHi,		2 },	// host = 0
	{ bgTimestampLo,		2 },	// host = 0
	{ bgTimestampSet,		2 },	// host = 0
	{ bgSettingsReady,		0 },
	{ bgGameOverReason,		0 },
	{ bgUserIds,			2 },	// seat
	{ bgActiveSeat,			0 },
	{ bgAutoDouble,			0 },
	{ bgHostBrown,			0 },
	{ bgTargetScore,		0 },
	{ bgSettingsDone,		0 },
	{ bgCubeValue,			0 },
	{ bgCubeOwner,			0 },
	{ bgResignPoints,		0 },
	{ bgScore,				2 },	// seat
	{ bgAllowWatching,		2 },	// seat
	{ bgSilenceKibitzers,	2 },	// seat
	{ bgDice,				4 },	// seat (0,1 = seat 0)
	{ bgDiceSize,			4 },	// seat	(0,1 = seat 0)
	{ bgReady,				0 },
	{ bgPieces,				30},	// point
};


struct TransactionCallbackEntry
{
	int					tag;
	PFTRANSACTIONFUNC	pfn;
};

static TransactionCallbackEntry InitTransactionCallback[] =
{
	{ bgTransInitSettings,		CGame::SettingsTransaction },
	{ bgTransDoublingCube,		CGame::DoublingCubeTransaction },
	{ bgTransDice,				CGame::DiceTransaction },
	{ bgTransStateChange,		CGame::StateChangeTransaction },
	{ bgTransBoard,				CGame::BoardTransaction },
	{ bgTransAcceptDouble,		CGame::AcceptDoubleTransaction },
	{ bgTransAllowWatchers,		CGame::AllowWatchersTransaction },
	{ bgTransSilenceKibitzers,	CGame::SilenceKibitzersTransaction },
	{ bgTransSettingsDlgReady,	CGame::SettingsReadyTransaction },
	{ bgTransTimestamp,			CGame::TimestampTransaction },
	{ bgTransRestoreGame,		CGame::RestoreGameTransaction },
	{ bgTransMiss,				CGame::MissTransaction },
	{ bgTransReady,				CGame::ReadyTransaction },
};


struct StateCallbackEntry
{
	int					tag;
	CGame::pfnstate		pfn;
};

static StateCallbackEntry InitStateCallback[] =
{
	{ bgStateNotInit,				CGame::StateNotInitialized },
	{ bgStateWaitingForGameState,	CGame::StateWaitingForGameState },
	{ bgStateCheckSavedGame,		CGame::StateCheckSavedGame },
	{ bgStateRestoreSavedGame,		CGame::StateRestoreSavedGame },
	{ bgStateGameSettings,			CGame::StateMatchSettings },
	{ bgStateInitialRoll,			CGame::StateInitialRoll },
	{ bgStateRoll,					CGame::StateRoll },
	{ bgStateDouble,				CGame::StateDouble },
	{ bgStateRollPostDouble,		CGame::StateRollPostDouble },
	{ bgStateRollPostResign,		CGame::StateRollPostResign },
	{ bgStateMove,					CGame::StateMove },
	{ bgStateEndTurn,				CGame::StateEndTurn },
	{ bgStateGameOver,				CGame::StateGameOver },
	{ bgStateMatchOver,				CGame::StateMatchOver },
	{ bgStateNewMatch,				CGame::StateNewMatch },
	{ bgStateResignOffer,			CGame::StateResignOffer },
	{ bgStateResignAccept,			CGame::StateResignAccept },
	{ bgStateResignRefused,			CGame::StateResignRefused },
	{ bgStateDelete,				CGame::StateDelete },
};


///////////////////////////////////////////////////////////////////////////////
// Local inlines and functions
///////////////////////////////////////////////////////////////////////////////

static inline BOOL IsValidSeat( int seat )
{
	return ((seat >= 0) && (seat < zNumPlayersPerTable));
}


static DWORD Checksum( BYTE* buff, int buffsz )
{
	DWORD sum = 0;
	DWORD* p;

	p = (DWORD*) buff;
	while ( buffsz >= sizeof(DWORD) )
	{
		sum ^= *p++;
		buffsz -= sizeof(DWORD);
	}
	if ( buffsz > 0 )
	{
		DWORD mask = 0xffffffff >> (8 * (sizeof(DWORD) - buffsz));
		sum ^= *p & mask;
	}

	return sum;
}


///////////////////////////////////////////////////////////////////////////////
// CUser and CPlayer constructors
///////////////////////////////////////////////////////////////////////////////

CUser::CUser()
{
	m_Id = -1;
	m_Seat = -1;
	m_NameLen = 0;
	m_bKibitzer = FALSE;
	m_Name[0] = _T('\0');
	m_Host[0] = _T('\0');
}


CPlayer::CPlayer()
{
	m_nColor = zBoardNeutral;
}

///////////////////////////////////////////////////////////////////////////////
// IGameGame Meathods
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CGame::GameOverReady()
{

	m_SharedState.StartTransaction( bgTransReady );
		m_SharedState.Set( bgReady, 1 );	
	m_SharedState.SendTransaction( TRUE );
	
	return S_OK;
}

STDMETHODIMP CGame::SendChat(TCHAR *szText, DWORD cchChars)
{
	ZBGMsgTalk* msgTalk = NULL;
	int16 msgLen 			= (int16)(sizeof(ZBGMsgTalk) + cchChars*sizeof(TCHAR));

	//Allocate the buffer
	msgTalk = (ZBGMsgTalk*) ZCalloc(1, msgLen);

    /*BYTE 		buff[ sizeof(ZBGMsgTalk) + 512 ];*/
	/*	CGame* pGame = (CGame*) cookie;*/		

	if ( msgTalk != NULL )
	{
		msgTalk->userID 	= m_pMe->m_Id;
		msgTalk->seat 		= m_Seat;
		msgTalk->messageLen = (WORD)cchChars*sizeof(TCHAR);
		ZBGMsgTalkEndian( msgTalk );
		CopyMemory( (BYTE*)(msgTalk) + sizeof(ZBGMsgTalk), (void*)szText, cchChars*sizeof(TCHAR) );
		RoomSend( zBGMsgTalk, msgTalk, msgLen );
        ZFree(msgTalk);
		return S_OK;
	}
	else
	{
		return E_OUTOFMEMORY;
	}

}


///////////////////////////////////////////////////////////////////////////////
// CGame constructor and destructor
///////////////////////////////////////////////////////////////////////////////

CGame::CGame()
{
	// kibitzer window
//	m_pKibitzerWnd = NULL;

	// fill in state table function array
	ZeroMemory( m_StateFunctions, sizeof(m_StateFunctions) );
	for ( int i = 0; i < bgStateLastEntry; i++ )
		m_StateFunctions[ InitStateCallback[i].tag ] = InitStateCallback[i].pfn;

	// Reference count
	m_RefCnt = 1;

	// turn state cube
	m_TurnState.cube = 0;

	// Instance info
	m_Seat = -1;
	m_TableId = -1;
	m_pMe = NULL;

	m_hInstance    = NULL;

	for( i = 0; i < zNumPlayersPerTable; i++ )
		m_CheckIn[i] = FALSE;

	// Flags
	m_SilenceMsg = FALSE;
	m_AllowMsg = TRUE;
	m_bDeleteGame = FALSE;
	m_bQueueMessages = FALSE;
	m_bShutdown = FALSE;
	m_bSaveGame = TRUE;
	m_bSentMatchResults = FALSE;

	// Timestamp
	m_Timestamp.dwLowDateTime = 1;
    m_Timestamp.dwHighDateTime = 0;

	// Turn roll
	m_TurnStartState = NULL;

	//move timeout
	m_bOpponentTimeout=FALSE;

	//helps to distinguish between aborts and end games
	m_EndLogReceived=FALSE;

	m_GameStarted=FALSE;

	//keep track of expected exit state
	m_ExitId=0;
}


CGame::~CGame()
{
	CUser* user;
	CMessage* msg;

	// Delete kibitzer list
	while ( user = m_Kibitzers.PopHead() )
		delete user;

	// Delete queued messages
	while( msg = m_MsgQueue.PopHead() )
		delete msg;

	// Delete turn rollback
	delete [] m_TurnStartState;
}

/*
ULONG CGame::AddGameRef()
{
	return ++m_RefCnt;
}


ULONG CGame::ReleaseGame()
{
	ASSERT( m_RefCnt > 0 );
	if ( --m_RefCnt == 0 )
	{
		delete this;
		return 0;
	}
	return m_RefCnt;
}
*/

void CGame::CloseAllDialogs( BOOL fExit )
{
	/*
	if ( m_ExitDlg.IsAlive() )
		m_ExitDlg.Close( fExit ? IDYES : IDCANCEL );	
	if ( m_RestoreDlg.IsAlive() )
		m_RestoreDlg.Close( -1 );
	*/
	if ( m_AcceptDoubleDlg.IsAlive() )
		m_AcceptDoubleDlg.Close( -1 );
	if ( m_ResignDlg.IsAlive() )
		m_ResignDlg.Close( -1 );
	if ( m_ResignAcceptDlg.IsAlive() )
		m_ResignAcceptDlg.Close( -1 );
	/*
	if ( m_SetupDlg.IsAlive() )
		m_SetupDlg.Close( -1 );
	*/
}


BOOL CGame::RoomShutdown()
{
	// room occasionally double deletes the game
	if ( m_bShutdown ) 
		return FALSE;
	m_bShutdown = TRUE;
  
	// destroy the windows
	Shutdown();

	// release room's reference
	Release();
	return TRUE;
}


void CGame::Shutdown()
{
	TCHAR title[128], txt[512];

	// object already being deleted?
	if ( GetState() == bgStateDelete )
		return;
	/*
	// duh
	SaveGame();
	*/

	// mark object as deleted
	SetState( bgStateDelete );

	// close kibitzer window
	/*
	if ( m_pKibitzerWnd)
	{
		delete m_pKibitzerWnd;
		m_pKibitzerWnd = NULL;
	}
	*/

	// close dialogs
	CloseAllDialogs( TRUE );

	//Check to see if opponent still in game
	//if they are then it is me who is quitting
	//if not and no end game message assume they aborted

	/*
	if (!ZCRoomGetSeatUserId(m_TableId,m_Opponent.m_Seat) && !m_EndLogReceived && !IsKibitzer() )
	{
		
        if (m_GameStarted && ( ZCRoomGetRoomOptions() & zGameOptionsRatingsAvailable ))
        {
		    LoadString( m_hInstance, IDS_GAME_NAME, title, sizeof(title) );
		    LoadString( m_hInstance, IDS_MATCH_ABANDON_RATED, txt, sizeof(txt) );
		    MessageBox( NULL, txt, title, MB_OK | MB_ICONINFORMATION | MB_TASKMODAL );
        }
        else
        {
		}
		LoadString( m_hInstance, IDS_GAME_NAME, title, 128 );
	    LoadString( m_hInstance, IDS_MATCH_RESET, txt, 512 );
		

		ZShellResourceManager()->LoadString( IDS_GAME_NAME, (TCHAR*)title, 128 );
		ZShellResourceManager()->LoadString( IDS_MATCH_RESET, (TCHAR*)txt, 512 );
		MessageBox( NULL, txt, title, MB_OK | MB_ICONINFORMATION | MB_TASKMODAL );
		
	};	
	*/

	// close open windows
	/*
	if ( IsWindow( m_Notation ) )
		DestroyWindow( m_Notation );
	*/

	if ( IsWindow( m_Wnd.GetHWND() ) )
		DestroyWindow( m_Wnd );
}


///////////////////////////////////////////////////////////////////////////////
// game functions
///////////////////////////////////////////////////////////////////////////////

void CGame::NewMatch()
{
	// reset match settings
	m_bSentMatchResults = FALSE;
	m_SharedState.Set( bgScore, 0, 0 );
	m_SharedState.Set( bgScore, 1, 0 );
	m_SharedState.Set( bgCrawford, -1 );
	for ( int i = 0; i < 30; i++ )
		m_SharedState.Set( bgPieces, i, -1 );
	ResetDice( -1 );
	for( i = 0; i < zNumPlayersPerTable ; i++)
		m_Ready[i] = FALSE;
		
	// tell server new match is starting
	if ( IsHost() )
		RoomSend( zBGMsgNewMatch, NULL, 0 );

	ZShellGameShell()->GameOverGameBegun(this);

	m_GameStarted=FALSE;
}


void CGame::NewGame()
{
	// Initialize player colors
	BOOL hostBrown = m_SharedState.Get( bgHostBrown );
	if ( (hostBrown && !m_Seat) || (!hostBrown && m_Seat) )
	{
		m_Player.m_nColor = zBoardBrown;
		m_Opponent.m_nColor = zBoardWhite;
	}
	else
	{
		m_Player.m_nColor = zBoardWhite;
		m_Opponent.m_nColor = zBoardBrown;
	}

	// Reset board
	for ( int i = 0; i < 30; i++ )
		m_SharedState.Set( bgPieces, i, InitPiecePositions[i] );

	m_Wnd.InitPoints();

	// Reset shared state
	m_SharedState.Set( bgActiveSeat, 0 );
	m_SharedState.Set( bgCubeValue, 1 );
	m_SharedState.Set( bgCubeOwner, zBoardNeutral );
	SetDice( m_Player.m_Seat, 0, -1 );
	SetDice( m_Opponent.m_Seat, 0, -1 );
	m_Wnd.m_nRecievedD1 = 0;
	m_Wnd.m_nRecievedD2 = -1;
	// Draw board
	m_Wnd.DrawAll();
}


BOOL CGame::StartPlayersTurn()
{
	InitTurnState( this, &m_TurnState );
	return CalcValidMoves( &m_TurnState );
}


BOOL CGame::IsTurnOver()
{
	return !CalcValidMoves( &m_TurnState );
}


BOOL CGame::IsValidDestPoint( int fromPoint, int toPoint, Move** move )
{
	// Note: expects players point indexes

	// Quick sanity check
	if ( (fromPoint < 0) || (toPoint < 0) )
		return FALSE;

	// Get from index
	int iFrom = PointIdxToBoardStateIdx( fromPoint );
	if ( (iFrom < 0) || (iFrom > zMoveBar) )
		return FALSE;

	// Get to index
	int iTo = PointIdxToBoardStateIdx( toPoint );
	if ( (iTo < 0) || (iTo > zMoveBar) )
		return FALSE;

	// Is this move in the valid list?
	MoveList* mlist = &m_TurnState.valid[iFrom];
	for ( int i = 0; i < mlist->nmoves; i++ )
	{
		if (	(mlist->moves[i].from == iFrom)
			&&	(mlist->moves[i].to == iTo) )
		{
			*move = &mlist->moves[i];
			return TRUE;
		}
	}
	return FALSE;
}


BOOL CGame::IsValidStartPoint( int fromPoint )
{
	// Note: expects players point indexes

	// Quick sanity check
	if ( fromPoint < 0 )
		return FALSE;

	// Get from index
	int iFrom = PointIdxToBoardStateIdx( fromPoint );
	if ( (iFrom < 0) || (iFrom > zMoveBar) )
		return FALSE;

	return (m_TurnState.valid[iFrom].nmoves > 0);
}


BOOL CGame::MovePiece( int piece, int toPoint )
{
	// Note: expects white point indexes

	PointDisplay* from;
	PointDisplay* to;
	int fromPoint;
	int pieceColor;
	
	// parameter paranoia
	if ( (piece < 0) || (piece >= 30) || (toPoint < 0) || (toPoint >= 28))
		return FALSE;

	// get starting point
	fromPoint = m_Wnd.m_Pieces[ piece ]->GetWhitePoint();
	if ( fromPoint < 0 )
		return FALSE;
	
	if ( fromPoint == toPoint )
	{
		// No movement
		m_Wnd.AdjustPieces( toPoint );
		return FALSE;
	}

	// get point pointers for easy access
	from = &m_Wnd.m_Points[ fromPoint ];
	to = &m_Wnd.m_Points[ toPoint ];

	if ( piece < 15 )
		pieceColor = zBoardWhite;
	else
		pieceColor = zBoardBrown;
	if ( (to->GetColor() == zBoardNeutral) || (to->GetColor() == pieceColor))
	{
		// Destination is empty or already occupied with same color pieces
		if ( (toPoint == bgBoardPlayerHome) || (toPoint == bgBoardOpponentHome) )
			m_Wnd.AddPiece( toPoint, piece, bgSoundBear );
		else
			m_Wnd.AddPiece( toPoint, piece, bgSoundPlacePiece );
		return TRUE;
	}
	else if (to->nPieces == 1 )
	{
		// Destination has enemy piece
		if ( to->GetColor() == zBoardWhite )
			m_Wnd.AddPiece( bgBoardPlayerBar, to->pieces[0], bgSoundPlacePiece );
		else
			m_Wnd.AddPiece( bgBoardOpponentBar, to->pieces[0], bgSoundPlacePiece );
		m_Wnd.AddPiece( toPoint, piece, bgSoundHit );
		return TRUE;
	}
	else
	{
		// illegal move?!
		m_Wnd.AdjustPieces( toPoint );
		return FALSE;
	}
}


void CGame::MakeMove( int pieceIdx, int fromPoint, int toPoint, Move* move )
{
	// Note: expects players point indexes

	if ( IsKibitzer() || (m_SharedState.Get( bgActiveSeat ) != m_Player.m_Seat ) )
		return;

	m_SharedState.StartTransaction( bgTransBoard );

		// update turn state and screen
		if ( move->takeback >= 0 )
		{
			TakeBackMove( &m_TurnState, move );
			MovePiece( pieceIdx, GetPointIdx( toPoint ) );
			if ( move->bar )
			{	
				pieceIdx = m_Wnd.m_Points[ GetPointIdx(bgBoardOpponentBar) ].pieces[0];
				MovePiece( pieceIdx, GetPointIdx( fromPoint ) );
			}
		}
		else
		{
			DoMove( &m_TurnState, move->from, move->diceIdx, move->ndice );
			MovePiece( pieceIdx, GetPointIdx( toPoint ) );
		}

		// Set dice size based on turn state
		int s0, s1;
		if ( m_TurnState.doubles )
		{
			s0  = m_TurnState.dice[0].used ? 1 : 0;
			s0 += m_TurnState.dice[1].used ? 1 : 0;
			s1  = m_TurnState.dice[2].used ? 1 : 0;
			s1 += m_TurnState.dice[3].used ? 1 : 0;
		}
		else
		{
			if ( !m_TurnState.dice[0].used )
				s0 = 0;
			else
				s0 = 2;
			if ( !m_TurnState.dice[1].used )
				s1 = 0;
			else
				s1 = 2;
		}
		SetDiceSize( m_Player.m_Seat, s0, s1 );

	m_SharedState.SendTransaction( TRUE );
}


void CGame::EnableRollButton( BOOL fEnable, BOOL fOff )
{
	if ( m_Wnd.m_RollButton.GetHWND() == NULL )
		return;

	//Only active player should see roll button
	
	if ( !(GetState() == bgStateInitialRoll) && (m_SharedState.Get( bgActiveSeat ) != m_Player.m_Seat) )
		fOff = TRUE;

	/*
	if ( fEnable )
	{
	//Only enable if we have to roll the dice
	//	if ( !NeedToRollDice() )
	//		fEnable = FALSE;

		
		if ( m_Wnd.m_Roll )
		{
			m_Wnd.m_Roll->SetEnable( TRUE );
			
			m_Wnd.m_RollBtn->SetEnable( TRUE );
			
		}
	}
	*/

	if ( fOff == FALSE && m_Wnd.m_Roll )
	{
		m_Wnd.m_Roll->SetEnable( TRUE );		
	}
	else if ( m_Wnd.m_Roll )
	{
		m_Wnd.m_Roll->SetEnable( FALSE );		
	}

	if ( m_Wnd.m_pGAcc )
	{
		if ( fEnable == TRUE )			
			m_Wnd.m_pGAcc->SetItemEnabled( true, accRollButton );
		else
			m_Wnd.m_pGAcc->SetItemEnabled( false, accRollButton );
	}

	EnableWindow( m_Wnd.m_RollButton, fEnable );
}

void CGame::EnableResignButton( BOOL fEnable )
{

	if ( m_Wnd.m_ResignButton.GetHWND() == NULL )
		return;


	/*
	if ( fEnable )
	{
		// kibitzers just watch
		if ( IsKibitzer() )
			fEnable = FALSE;
	}
	*/
	if ( m_Wnd.m_pGAcc )
	{
		if ( fEnable == TRUE )			
			m_Wnd.m_pGAcc->SetItemEnabled( true, accResignButton );
		else
			m_Wnd.m_pGAcc->SetItemEnabled( false, accResignButton );
	}


	EnableWindow( m_Wnd.m_ResignButton, fEnable );
}


void CGame::EnableDoubleButton( BOOL fEnable )
{
	if ( m_Wnd.m_DoubleButton.GetHWND() == NULL )
		return;

	if ( fEnable )
	{
		int owner = m_SharedState.Get( bgCubeOwner );

		// kibitzers just watch
		if ( IsKibitzer() )
			fEnable = FALSE;

		// only active player can double
		else if ( m_SharedState.Get( bgActiveSeat ) != m_Player.m_Seat )
			fEnable = FALSE;

		// player must owns cube
		else if ( owner == m_Opponent.GetColor() )
			fEnable = FALSE;

		// cube already at max value?
		if ( m_SharedState.Get( bgCubeValue ) >= 64 )
			fEnable = FALSE;

		// only double before rolling dice
		else if ( (GetState() != bgStateRoll ) && ( GetState() != bgStateResignOffer ) )
			fEnable = FALSE;

		// crawford rule in effect
		else if ( m_SharedState.Get( bgCrawford ) == m_Player.m_Seat )
			fEnable = FALSE;
	}


	//Disable the double button
	if ( m_Wnd.m_pGAcc )
	{
		//Yes I know stupid.. avoids performance warning for casting BOOL to bool
		if ( fEnable == TRUE )			
			m_Wnd.m_pGAcc->SetItemEnabled( true, accDoubleButton );
		else
			m_Wnd.m_pGAcc->SetItemEnabled( false, accDoubleButton );
	}

	EnableWindow( m_Wnd.m_DoubleButton, fEnable );	
}


void CGame::Double()
{
	int value = m_SharedState.Get( bgCubeValue );
	int owner = m_SharedState.Get( bgCubeOwner );

	// Am I allowed to double?
	if (	IsKibitzer()
		||	(value >= 64)
		||	(owner == m_Opponent.GetColor())
		||	((GetState() != bgStateRoll) && (GetState() != bgStateRollPostResign))
		||	(m_SharedState.Get( bgActiveSeat ) != m_Player.m_Seat ) )
	{
		return;
	}

	// accepted double
	ZBGMsgEndTurn msg;
	msg.seat = m_Seat;
	RoomSend( zBGMsgEndTurn, &msg, sizeof(msg) );

	// jump to double state
	SetState( bgStateDouble );
}


void CGame::Resign()
{
	// kibitzers can't resign
	if ( IsKibitzer() )
		return;

	// only active player can resign
	if ( m_SharedState.Get( bgActiveSeat ) != m_Player.m_Seat )
		return;

	// goto resign offer state
	SetState( bgStateResignOffer );

#if 0
	// transition to resign offer
	m_SharedState.StartTransaction( bgTransStateChange );
		m_SharedState.Set( bgState, bgStateGameOver );
		m_SharedState.Set( bgGameOverReason, bgGameOverResign );
		m_SharedState.Set( bgActiveSeat, m_Opponent.m_Seat );
	m_SharedState.SendTransaction( TRUE );
#endif

}

void CGame::Forfeit()
{

	ZBGMsgEndLog log;

	// kibitzers can't resign
	if ( IsKibitzer() )
		return;

	log.reason=zBGEndLogReasonForfeit;
	log.seatLosing=m_Seat;
	log.seatQuitting=m_Seat;
	log.numPoints = m_SharedState.Get( bgTargetScore );
			
	RoomSend( zBGMsgEndLog, &log, sizeof(log) );
	
}



int CGame::CalcPipsForColor( int color )
{
	int start, end;
	int i, cnt;

	// which pieces do we care about
	if ( color == zBoardWhite )
		start = 0;
	else
		start = 15;
	end = start + 15;

	// run through pieces for pip count
	for ( cnt = 0, i = start; i < end; i++ )
		cnt += PointIdxToBoardStateIdx( GetPointIdxForColor( color, m_SharedState.Get( bgPieces, i ) ) );
	if ( cnt < 0 )
		cnt = 0;

	return cnt;
}


int CGame::CalcBonusForSeat( int seat )
{
	// calculate bonus multiplier for gammons and backgammons
	int color, start, end, pt;
	BOOL bEnemy = FALSE;

	// convert seat --> opposite color --> piece range
	if ( m_Player.m_Seat == seat )
		color = m_Opponent.GetColor();
	else
		color = m_Player.GetColor();
	if ( color == zBoardWhite )
		start = 0;
	else
		start = 15;
	end = start + 15;

	// how bad was the loss?
	for ( int i = start; i < end; i++ )
	{
		pt = PointIdxToBoardStateIdx( GetPointIdxForColor( color, m_SharedState.Get( bgPieces, i ) ) );
		if ( pt == 0 )
			return 1;			// home, no bonus
		else if ( pt >= 19 )
			bEnemy = TRUE;		// enemy home board, possible backgammon
	}
	if ( bEnemy )
		return 3;		// backgammoned
	else
		return 2;		// gammoned
}


///////////////////////////////////////////////////////////////////////////////
// game utility functions
///////////////////////////////////////////////////////////////////////////////

int CGame::GetPointIdxForColor( int color, int WhiteIdx )
{
	// converts point from white to player and vice versa
	if ( color == zBoardWhite )
		return WhiteIdx;
	if ( WhiteIdx < 24 )
		return 23 - WhiteIdx;
	switch ( WhiteIdx )
	{
	case bgBoardPlayerHome:
		return bgBoardOpponentHome;
	case bgBoardOpponentHome:
		return bgBoardPlayerHome;
	case bgBoardPlayerBar:
		return bgBoardOpponentBar;
	case bgBoardOpponentBar:
		return bgBoardPlayerBar;
	}
	ASSERT( FALSE );
	return WhiteIdx;
}


void CGame::GetTxtForPointIdx( int PlayerIdx, TCHAR* txt )
{
	int idx;
	TCHAR prefix;

	if ( (PlayerIdx == bgBoardPlayerHome) || (PlayerIdx == bgBoardOpponentHome) )
		lstrcpy( txt, _T("off") );
	else if ( (PlayerIdx == bgBoardPlayerBar) || (PlayerIdx == bgBoardPlayerBar) )
		lstrcpy( txt, _T("e") );
	else
	{
		if ( m_Player.GetColor() == zBoardWhite )
		{
			if ( PlayerIdx <= 11 )
			{
				prefix = _T('W');
				idx = PlayerIdx + 1;
			}
			else
			{
				prefix = _T('B');
				idx = 24  - PlayerIdx;
			}
		}
		else
		{
			if ( PlayerIdx <= 11 )
			{
				prefix = _T('B');
				idx = PlayerIdx + 1;
			}
			else
			{
				prefix = _T('W');
				idx = 24 - PlayerIdx;
			}
		}
		wsprintf( txt, _T("%c%d"), prefix, idx );
	}
}

///////////////////////////////////////////////////////////////////////////////
// CGame zone exports
///////////////////////////////////////////////////////////////////////////////

HRESULT CGame::Init(HINSTANCE hInstance, ZUserID userID, int16 tableID, int16 seat, int16 playerType, ZRoomKibitzers* kibitzers)
{

	HRESULT hr;
	CUser* pKib;
	ZPlayerInfoType PlayerInfo;
	TCHAR in[512], out[512];
	int i;

	AddRef();

	m_hInstance = hInstance;
	
	// initialize shared state
	hr = m_SharedState.Init( userID, tableID, seat, InitSharedState, sizeof(InitSharedState) / sizeof(SharedStateEntry) );
	if ( FAILED(hr) )
	{
		switch (hr)//Only returns E_OUTOFMEMORY ON ERROR
		{
			case E_OUTOFMEMORY:
				ZShellGameShell()->ZoneAlert( ErrorTextOutOfMemory, NULL, NULL, FALSE, TRUE );
				break;
			default:
				ZShellGameShell()->ZoneAlert( ErrorTextUnknown, NULL, NULL, FALSE, TRUE );
		}			
		return hr;
	}
	
	// alloc memory for turn rollback
	m_TurnStartState = new BYTE[ m_SharedState.GetSize() ];
	if ( !m_TurnStartState )
	{
		ZShellGameShell()->ZoneAlert( ErrorTextOutOfMemory, NULL, NULL, FALSE, TRUE );
		return E_OUTOFMEMORY;
	}

	// initialize game settings (not reset per match)
	m_SharedState.Set( bgSettingsDone, FALSE );	

	LoadSettings( &m_Settings, seat );
	
	for ( i = 0; i < 2; i++ )
	{
		m_SharedState.Set( bgTimestampHi, i, 0 );
		m_SharedState.Set( bgTimestampLo, i, 0 );
		m_SharedState.Set( bgTimestampSet, i, FALSE );
		m_SharedState.Set( bgAllowWatching, i, m_Settings.Allow[i] );
		m_SharedState.Set( bgSilenceKibitzers, i, m_Settings.Silence[i] );
	}
	
	// start state machine
	SetState( bgStateNotInit );

	// clear shared state
	NewMatch();

	// init player board indexs
	m_Player.m_iHome	= bgBoardPlayerHome;
	m_Player.m_iBar		= bgBoardPlayerBar;
	m_Opponent.m_iHome	= bgBoardOpponentHome;
	m_Opponent.m_iBar	= bgBoardOpponentBar;
	
	// setup transaction callbacks
	for ( i = 0; i < sizeof(InitTransactionCallback) / sizeof(TransactionCallbackEntry); i++ )
	{
		hr = m_SharedState.SetTransactionCallback(
						InitTransactionCallback[i].tag,
						InitTransactionCallback[i].pfn,
						(DWORD) this );
		
		if ( FAILED(hr) )
		{		
			switch (hr)//Only returns E_OUTOFMEMORY ON ERROR
			{
				case E_OUTOFMEMORY:
					ZShellGameShell()->ZoneAlert( ErrorTextOutOfMemory, NULL, NULL, FALSE, TRUE );
					break;
				default:
					ZShellGameShell()->ZoneAlert( ErrorTextUnknown, NULL, NULL, FALSE, TRUE );
			}			
			return hr;
		}
	}
	
	// Store game instance info
	m_TableId = tableID;

	if (m_TableId < 0)
	{
		ZShellGameShell()->ZoneAlert( ErrorTextSync, NULL, NULL, TRUE, FALSE );
		return E_FAIL;
	}
	
	if (!IsValidSeat(seat))
	{
		ZShellGameShell()->ZoneAlert( ErrorTextSync, NULL, NULL, TRUE, FALSE );
		return E_FAIL;
	}

	m_Seat = seat;
	
	// Store this client's user info
	if (playerType != zGamePlayerKibitzer)
	{
		m_pMe = &m_Player;
	}
	else
	{
		pKib = new CUser;
		if ( !pKib )
		{
			ZShellGameShell()->ZoneAlert( ErrorTextOutOfMemory, NULL, NULL, FALSE, TRUE );
			return E_OUTOFMEMORY;
		}

		pKib->m_bKibitzer = TRUE;
		ZCRoomGetPlayerInfo( userID, &PlayerInfo );
		lstrcpy( pKib->m_Name, PlayerInfo.userName );
		lstrcpy( pKib->m_Host, PlayerInfo.hostName );
		m_pMe = pKib;
		m_Kibitzers.AddHead( pKib );
	}
	
	m_pMe->m_Id = userID;
	m_pMe->m_Seat = seat;
	
	// Store kibitzers
	if ( kibitzers )
	{
		for( i = 0; i < (int) kibitzers->numKibitzers; i++ )
			AddKibitzer( kibitzers->kibitzers[i].seat, kibitzers->kibitzers[i].userID, FALSE );
	}

	// Create window
	ZShellResourceManager()->LoadString( IDS_GAME_NAME, (TCHAR*)in, 512 );

	wsprintf( out, in );
	hr = m_Wnd.Init( m_hInstance, this, out );
	if ( FAILED(hr) ) // Error dialogs handled inside
	{
		return hr;
	}
	SetForegroundWindow( m_Wnd );

	// Create notation window
	/*
	hr = m_Notation.Init( this, m_Wnd.m_Palette );
	if ( FAILED(hr) )
		return hr;
	if ( m_Settings.NotationPane )
		ShowWindow( m_Notation, SW_SHOW );
	else
		ShowWindow( m_Notation, SW_HIDE );
	*/

	// prime state machine
	/*
	if ( playerType == zGamePlayerKibitzer )
		SetState( bgStateWaitingForGameState );
	else
	*/
	
	SendCheckIn();
	
	return NOERROR;
}


void CGame::AddKibitzer( int16 seat, ZUserID userID, BOOL fRedraw )
{
	ZPlayerInfoType PlayerInfo;
	ListNodeHandle pos;
	CUser* player;

	// Check incoming data
	if ( !IsValidSeat(seat) )
		return;

	// Is the kibitzer already in the list?
	for( pos = m_Kibitzers.GetHeadPosition(); pos; pos = m_Kibitzers.GetNextPosition( pos ) )
	{
		player = m_Kibitzers.GetObjectFromHandle( pos );
		if (player->m_Id == userID)
			return;
	}

	// Add kibitzer
	player = new CUser;
	if ( !player )
		return;

	player->m_Id = userID;
	player->m_Seat = seat;
	player->m_bKibitzer = TRUE;
	ZCRoomGetPlayerInfo( userID, &PlayerInfo );
	lstrcpy( player->m_Name, PlayerInfo.userName );
	lstrcpy( player->m_Host, PlayerInfo.hostName );
	m_Kibitzers.AddHead( player );

	// update screen
	if ( fRedraw )
		m_Wnd.DrawAvatars( TRUE );
}


void CGame::RemoveKibitzer( int16 seat, ZUserID userID )
{
	ListNodeHandle pos;
	CUser* player;

	if (userID == zRoomAllPlayers)
	{
		// Remove all kibitzers
		while ( player = m_Kibitzers.PopHead() )
			delete player;
	}
	else
	{
		// Remove matching kibitzers
		for( pos = m_Kibitzers.GetHeadPosition(); pos; pos = m_Kibitzers.GetNextPosition( pos ) )
		{
			player = m_Kibitzers.GetObjectFromHandle( pos );
			if ((player->m_Id == userID) && (player->m_Seat == seat))
			{
				m_Kibitzers.DeleteNode( pos );
				delete player;
			}
		}
	}

	// update screen
	m_Wnd.DrawAvatars( TRUE );
}


BOOL CGame::HasKibitzers( int seat )
{
	ListNodeHandle pos;
	CUser* player;

	// look for a kibitzer on specified seat
	for( pos = m_Kibitzers.GetHeadPosition(); pos; pos = m_Kibitzers.GetNextPosition( pos ) )
	{
		player = m_Kibitzers.GetObjectFromHandle( pos );
		if (player->m_Seat == seat)
			return TRUE;
	}
	return FALSE;
}


///////////////////////////////////////////////////////////////////////////////
// Message queue
///////////////////////////////////////////////////////////////////////////////

void CGame::ProcessMessage( int type, BYTE* msg, int len )
{
	ZBGMsgTimestamp* ts;

	// ignore messages if waiting for game state
    ASSERT(GetState() != bgStateWaitingForGameState);
	if ( (GetState() == bgStateWaitingForGameState) && (type != zGameMsgGameStateResponse) )
		return;

	switch( type )
	{
	case zBGMsgTransaction:
		if(!m_SharedState.ProcessTransaction(msg, len))
		    ZShellGameShell()->ZoneAlert(ErrorTextSync, NULL, NULL, TRUE, FALSE);
		break;

	case zBGMsgTimestamp:
		if( len >= sizeof( ZBGMsgTimestamp ) )
		{
			ts = (ZBGMsgTimestamp*) msg;
			ZBGMsgTimestampEndian( ts );
			m_Timestamp.dwLowDateTime = ts->dwLoTime;
			m_Timestamp.dwHighDateTime = ts->dwHiTime;
		}
		else
		{
			ZShellGameShell()->ZoneAlert( ErrorTextSync, NULL, NULL, TRUE, FALSE );
		}
		
		break;

	case zBGMsgTurnNotation:
	case zBGMsgSavedGameState:
	case zGameMsgGameStateResponse:
	case zGameMsgGameStateRequest:
	case zBGMsgMoveTimeout:
	case zBGMsgEndTurn:
	case zBGMsgEndLog:
        ASSERT(FALSE);
    default:
		ZShellGameShell()->ZoneAlert(ErrorTextSync, NULL, NULL, TRUE, FALSE);
	}
}


void CGame::QueueMessage( int type, BYTE* msg, int len )
{
	CMessage* NewMsg;

	AddRef();
	if ( !m_bQueueMessages && m_MsgQueue.IsEmpty() )
	{
		ProcessMessage( type, msg, len );
	}
	else
	{
		NewMsg = new CMessage( type, msg, len );
		m_MsgQueue.AddHead( NewMsg );
	}
	while ( (!m_bQueueMessages) && (NewMsg = m_MsgQueue.PopTail()) )
	{
		ProcessMessage( NewMsg->m_Type, NewMsg->m_Msg, NewMsg->m_Len );
		delete NewMsg;
	}
	Release();
}


void CGame::SetQueueMessages( BOOL bQueueMessages )
{
	CMessage* NewMsg;

	AddRef();
	m_bQueueMessages = bQueueMessages;
	while ( (!m_bQueueMessages) && (NewMsg = m_MsgQueue.PopTail()) )
	{
		ProcessMessage( NewMsg->m_Type, NewMsg->m_Msg, NewMsg->m_Len );
		delete NewMsg;
	}
	Release();
}


///////////////////////////////////////////////////////////////////////////////
// CGame Message Senders
///////////////////////////////////////////////////////////////////////////////

HRESULT CGame::SendCheckIn()
{
	ZGameMsgCheckIn msg;

	if ( IsKibitzer() )
		return E_FAIL;
	msg.protocolSignature = zBackgammonProtocolSignature;
	msg.protocolVersion	  = zBackgammonProtocolVersion;
	msg.clientVersion	  = zGameVersion;
	msg.playerID		  = m_pMe->m_Id;
	msg.seat			  = m_pMe->m_Seat;
	msg.playerType		  = m_pMe->m_bKibitzer ?  zGamePlayerKibitzer : zGamePlayer;
	ZGameMsgCheckInEndian( &msg );
	RoomSend( zGameMsgCheckIn, &msg, sizeof(msg) );
	return NOERROR;
}


HRESULT CGame::SendTalk( TCHAR* str, int len, DWORD cookie )
{
	ASSERT( FALSE );
	/*
	ZBGMsgTalk* msg;
	TCHAR buff[ sizeof(ZBGMsgTalk) + 512 ];
	CGame* pGame = (CGame*) cookie;
		
	int msgLen = sizeof(ZBGMsgTalk) + len;
	msg = (ZBGMsgTalk*) buff;
	msg->userID = pGame->m_pMe->m_Id;
	msg->seat = pGame->m_Seat;
	msg->messageLen = len;
	ZBGMsgTalkEndian( msg );
	CopyMemory( buff + sizeof(ZBGMsgTalk), str, len );
	pGame->RoomSend( zBGMsgTalk, buff, msgLen );
	*/
	return NOERROR;
}


HRESULT CGame::SendNotationString( int type, TCHAR* str )
{
	ASSERT( FALSE );
	/*
	ZBGMsgTurnNotation* msg;
	TCHAR buff[ sizeof(ZBGMsgTurnNotation) + 512 ];
	int msgLen, len;

	if ( !IsMyTurn() )
		return NOERROR;

	len = lstrlen( str ) + 1;
	msgLen = sizeof(ZBGMsgTurnNotation) + len;
	msg = (ZBGMsgTurnNotation*) buff;
	msg->seat = m_Seat;
	msg->type = type;
	msg->nTCHARs = len;
	ZBGMsgTurnNotationEndian( msg );
	CopyMemory( buff + sizeof(ZBGMsgTurnNotation), str, len);
	RoomSend( zBGMsgTurnNotation, buff, msgLen );
	*/
	return NOERROR;
}

HRESULT CGame::SendRollRequest(void)
{
	ZBGMsgRollRequest msg;
	int msgLen;
	msgLen = sizeof(ZBGMsgRollRequest);
	msg.seat = m_Seat;
	ZBGMsgRollRequestEndian(&msg);
	RoomSend(zBGMsgRollRequest,&msg,msgLen);
	m_Wnd.m_fDiceRollReceived = FALSE;
	m_Wnd.m_nRecievedD1 = -1;
	m_Wnd.m_nRecievedD2 = -1;

	return NOERROR;
}
///////////////////////////////////////////////////////////////////////////////
// CGame save / load game
///////////////////////////////////////////////////////////////////////////////

#define BACKGAMMON_SAVED_GAME_MAGIC		0xbacbacf
#define BACKGAMMON_SAVED_GAME_VERSION	0x04

struct BackgammonSavedGameHeader
{
	DWORD		magic;
	DWORD		version;
	DWORD		checksum;
	DWORD		bufferSize;
	BOOL		host;
	FILETIME	fileTime;
};

/*
void CGame::DeleteGame()
{
	TCHAR fname[1024];

	// kibitzers shouldn't be deleteing games
	if ( IsKibitzer() )
		return;

	// Get saved game path
	if ( lstrlen( m_Opponent.m_Name ) > 0 )
	{
		wsprintf( fname, _T("%s%s.sav"), ZGetProgramDataFileName( _T("") ), m_Opponent.m_Name );
		DeleteFile( fname );
	}
}
*/

static BOOL GetSavePath( CGame* pGame, TCHAR* dirBase, TCHAR* dirName, TCHAR* fname )
{
	ASSERT( FALSE );

	/*
	TCHAR*	p = NULL;
	TCHAR*	o = NULL;
	int		i = 0;

	// get player and opponent names, stripping bad leading characers
	p = pGame->m_Player.m_Name;
	while ((*p != _T('\0') && (isalpha( *p ) == 0))
		p++;
	if ( *p == '\0' )
		return FALSE;
	o = pGame->m_Opponent.m_Name;
	while ((*o != '\0') && (isalpha( *o ) == 0))
		o++;
	if ( *o == '\0' )
		return FALSE;

	// create path components
	lstrcpy( dirBase, ZGetProgramDataFileName( _T("") ) );
	wsprintf( dirName, _T("%s%s\\"), dirBase, p );
	wsprintf( fname, _T("%s%s.sav"), dirName, o );
	*/
	return TRUE;
}


void CGame::SaveGame()
{
	ASSERT( FALSE );
	/*
	BackgammonSavedGameHeader header;
	HANDLE hfile = INVALID_HANDLE_VALUE;
	char dirBase[1024], dirName[1024], fname[1024];
	char *buff = NULL;
	int *pNot, *pTab;
	int sz, szt;
	DWORD bytes;

	// kibitzers can't save games
	if ( IsKibitzer() )
		return;

	// don't save rated games
	if ( ZCRoomGetRoomOptions() & zGameOptionsRatingsAvailable )
		return;

	// Get saved game path
	if ( !GetSavePath( this, dirBase, dirName, fname ) )
		return;

	// save the game?
	if ( !m_bSaveGame )
	{
		DeleteFile( fname );
		return;
	}

	// Create directories if they're not there.
	CreateDirectory( dirBase, NULL );
	CreateDirectory( dirName, NULL );

	// Decide what to do
	switch( GetState() )
	{
	case bgStateNotInit:
	case bgStateWaitingForGameState:
	case bgStateCheckSavedGame:
	case bgStateRestoreSavedGame:
		// Haven't progressed far enough to know what to do.
		return;

	case bgStateGameSettings:
	case bgStateMatchOver:
	case bgStateNewMatch:
		// Match either hasn't started or is over.
		DeleteFile( fname );
		return;
	
	case bgStateDelete:
		// Too late, save game shouldn't have been called
		ASSERT( FALSE );
		break;
	}

	// allocate state and notaiton buffer
	sz = m_SharedState.GetSize() + m_Notation.GetSize() + (sizeof(int) * 2);
	buff = new char[ sz ];
	if ( !buff )
		return;
	pTab = (int*) buff;
	szt = m_SharedState.GetSize();
	*pTab++ = szt;

	// fill game state buffer
	switch ( GetState() )
	{
	case bgStateRoll:
	case bgStateRollPostDouble:
	case bgStateRollPostResign:
	case bgStateDouble:
	case bgStateMove:
	case bgStateEndTurn:
	case bgStateResignOffer:
	case bgStateResignAccept:
	case bgStateResignRefused:
		CopyMemory( (char*) pTab, m_TurnStartState, szt );
		break;
	default:
		m_SharedState.Dump( (char*) pTab, szt );
		break;
	}

	// fill notation buffer
	pNot = pTab + (szt / sizeof(int));
	szt = m_Notation.GetSize();
	*pNot++ = szt;
	m_Notation.GetStrings( (char*) pNot, szt );

	// write file
	hfile = CreateFile( fname, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );
	if ( INVALID_HANDLE_VALUE == hfile )
		goto error;
	header.version = BACKGAMMON_SAVED_GAME_VERSION;
	header.magic = BACKGAMMON_SAVED_GAME_MAGIC;
	header.checksum = Checksum( buff, sz );
	header.bufferSize = sz;
	header.fileTime = m_Timestamp;
	header.host = IsHost();
	if ( !WriteFile( hfile, &header, sizeof(header),  &bytes, NULL ) )
		goto error;
	if ( !WriteFile( hfile, buff, sz, &bytes, NULL ) )
		goto error;

	// we're done
	CloseHandle( hfile );
	delete [] buff;
	return;

error:
	LoadString( m_hInstance, IDS_SAVE_ERROR_TITLE, fname, sizeof(fname) );
	LoadString( m_hInstance, IDS_SAVE_ERROR_CREATE, dirBase, sizeof(dirBase) );
	MessageBox( NULL, dirBase, fname, MB_OK | MB_ICONERROR | MB_TASKMODAL );
	if ( INVALID_HANDLE_VALUE != hfile )
		CloseHandle( hfile );
	if ( buff )
		delete [] buff;
	return;
	*/
}


void CGame::LoadGame( BYTE** ppData, DWORD* pSize )
{

	ASSERT( FALSE );
	// LoadGame allocates memory for ppData.  The calling
	// procedure is responsible for freeing this memory.
/*
	BackgammonSavedGameHeader* header = NULL;
	HANDLE hfile = INVALID_HANDLE_VALUE;
	HANDLE hmap = NULL;
	DWORD size;
	BYTE* pfile = NULL;
	BYTE* pbuff = NULL;
	char fname[1024], dirBase[1024], dirName[1024];

	*ppData = NULL;

	// don't load rated games
	if ( ZCRoomGetRoomOptions() & zGameOptionsRatingsAvailable )
		return;

	// get filename
	if ( !GetSavePath( this, dirBase, dirName, fname ) )
		return;

	// open memory mapped file
	hfile = CreateFile( fname, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
	if ( INVALID_HANDLE_VALUE == hfile )
		goto error;
	hmap = CreateFileMapping( hfile, NULL, PAGE_READONLY, 0, 0, NULL);
	if ( !hmap )
		goto error;
	pfile = (BYTE*) MapViewOfFile( hmap, FILE_MAP_READ, 0, 0, 0);
	if ( !pfile )
		goto error;

	// verify file header
	size = GetFileSize( hfile, NULL );
	if ( size < sizeof(header) )
		goto error;
	header  = (BackgammonSavedGameHeader*) pfile;
	if ( BACKGAMMON_SAVED_GAME_MAGIC != header->magic )
		goto error;
	if ( BACKGAMMON_SAVED_GAME_VERSION != header->version )
		goto error;

	// verify buffer
	if ( size < (sizeof(header) + header->bufferSize) )
		goto error;
	if ( header->checksum != Checksum( (BYTE*)( header + 1 ), header->bufferSize ) )
		goto error;

	// copy file data into data pointer
	*pSize = size;
	*ppData = new BYTE[ size ];
	if ( *ppData )
		CopyMemory( *ppData, pfile, size );

	// close file
	UnmapViewOfFile( pfile );
	CloseHandle( hmap );
	CloseHandle( hfile );
	return;
	
error:
	if ( pfile )
		UnmapViewOfFile( pfile );
	if ( hmap )
		CloseHandle( hmap );
	if ( INVALID_HANDLE_VALUE != hfile )
		CloseHandle( hfile );
	*ppData = NULL;
	return;
	*/
}


void CGame::LoadGameTimestamp()
{

	ASSERT( FALSE );
	/*
	BackgammonSavedGameHeader* header = NULL;
	BYTE* pData = NULL;
	DWORD Size = 0;
	int idx = IsHost() ? 0 : 1;

	LoadGame( &pData, &Size );
	if ( pData )
	{
		header = (BackgammonSavedGameHeader*) pData;
		m_SharedState.Set( bgTimestampHi,  idx, header->fileTime.dwHighDateTime );
		m_SharedState.Set( bgTimestampLo,  idx, header->fileTime.dwLowDateTime );
		m_SharedState.Set( bgTimestampSet, idx, TRUE );
		delete [] pData;
	}
	else
	{
		m_SharedState.Set( bgTimestampHi,  idx, 0 );
		m_SharedState.Set( bgTimestampLo,  idx, 0 );
		m_SharedState.Set( bgTimestampSet, idx, TRUE );
	}
	*/
}


///////////////////////////////////////////////////////////////////////////////
// CGame Message Handlers
///////////////////////////////////////////////////////////////////////////////


HRESULT	CGame::HandleGameStateRequest( void* msg, int32 len )
{

	ASSERT( FALSE );
	/*
	ZGameMsgGameStateResponse* pRep;
	BYTE *buff;
	int *pNot, *pTab;
	int sz, szt;

	// get player id from request
	ZGameMsgGameStateRequest* pMsg = (ZGameMsgGameStateRequest*) msg;
	ZGameMsgGameStateRequestEndian( pMsg );
	
	// allocate message buffer
	sz = sizeof(ZGameMsgGameStateResponse) + m_SharedState.GetSize() + m_Notation.GetSize() + (sizeof(int) * 2);
	buff = new BYTE[ sz ];
	if ( !buff )
		return E_OUTOFMEMORY;

	// response info
	pRep = (ZGameMsgGameStateResponse*) buff;
	pRep->playerID = pMsg->playerID;
	pRep->seat = m_Player.m_Seat;
	ZGameMsgGameStateResponseEndian( pRep );

	// shared state
	pTab = (int*)( pRep + 1 );
	szt = m_SharedState.GetSize();
	*pTab++ = szt;
	m_SharedState.Dump( (BYTE*) pTab, szt );

	// notation pane
	pNot = pTab + (szt / sizeof(int));
	szt = m_Notation.GetSize();
	*pNot++ = szt;
	m_Notation.GetStrings( (TCHAR*) pNot, szt );

	// send message
	RoomSend( zGameMsgGameStateResponse, buff, sz );

	// we're done
	delete [] buff;
	*/
	return NOERROR;
}


HRESULT CGame::HandleGameStateResponse( void* msg, int32 msgLen )
{
	ASSERT( FALSE );
	/*
	TCHAR title[128], txt[512];
	BYTE* buff;
	int id, seat;
	int stateSz, notSz;
	ZPlayerInfoType PlayerInfo;

	// are we expecting the game state?
	if ( GetState() != bgStateWaitingForGameState )
		return NOERROR;

	// clear status dialog
	m_Wnd.StatusClose();

	// update shared state
	buff = (BYTE*) msg;
	buff += sizeof(ZGameMsgGameStateResponse);
	stateSz = *( (int*) buff );
	buff += sizeof(int);
	m_SharedState.ProcessDump( buff, stateSz );
	buff += stateSz;

	// update notation
	notSz = *( (int*) buff );
	buff += sizeof(int);
	m_Notation.SetStrings((TCHAR*)buff, notSz );
	
	// verify seat
	seat = m_pMe->m_Seat;
	if ( (m_pMe->m_Seat != 0) && (m_pMe->m_Seat != 1) )
		return E_FAIL;
	
	// get player info
	id = m_SharedState.Get( bgUserIds, seat );
	ZCRoomGetPlayerInfo( id, &PlayerInfo );
	m_Player.m_Id = id;
	m_Player.m_Seat = seat;
	lstrcpy( m_Player.m_Name, PlayerInfo.userName );
	lstrcpy( m_Player.m_Host, PlayerInfo.hostName );
	m_Player.m_NameLen = lstrlen( m_Player.m_Name );
	
	// get opponent info
	seat = !seat;
	id = m_SharedState.Get( bgUserIds, seat );
	ZCRoomGetPlayerInfo( id, &PlayerInfo );
	m_Opponent.m_Id = id;
	m_Opponent.m_Seat = seat;
	lstrcpy( m_Opponent.m_Name, PlayerInfo.userName );
	lstrcpy( m_Opponent.m_Host, PlayerInfo.hostName );
	m_Opponent.m_NameLen = lstrlen( m_Opponent.m_Name );
	
	// player color is normally set in NewGame
	if ( GetState() > bgStateGameSettings )
	{
		BOOL hostBrown = m_SharedState.Get( bgHostBrown );
		if ( (hostBrown && !m_Seat) || (!hostBrown && m_Seat) )
		{
			m_Player.m_nColor = zBoardBrown;
			m_Opponent.m_nColor = zBoardWhite;
		}
		else
		{
			m_Player.m_nColor = zBoardWhite;
			m_Opponent.m_nColor = zBoardBrown;
		}
		
		// initialize points
		m_Wnd.InitPoints();

		// update screen
		m_Wnd.DrawAll();
	}

	// notify kibitzer if players in match setup
/*
	if ( GetState() == bgStateGameSettings )
		m_Wnd.StatusDisplay( bgStatusNormal, IDS_WAIT_SETUP, -1 );

	// notify kibitzer if they are silenced
	m_Settings.Silence[0] = m_SharedState.Get( bgSilenceKibitzers, 0 );
	m_Settings.Silence[1] = m_SharedState.Get( bgSilenceKibitzers, 1 );
	if (	( IsKibitzer() )
		&&	( !m_SilenceMsg )
		&&	( m_Settings.Silence[0] || m_Settings.Silence[1] ) )
	{
		m_SilenceMsg = TRUE;
		LoadString( m_hInstance, IDS_SILENCE_TITLE, title, sizeof(title) );
		LoadString( m_hInstance, IDS_SILENCE_MSG_ON, txt, sizeof(txt) );
		MessageBox( NULL, txt, title, MB_OK | MB_ICONINFORMATION | MB_TASKMODAL );
	}
*/
	return NOERROR;
}


HRESULT CGame::HandleSavedGameState( void* msg, int32 msgLen )
{

	ASSERT( FALSE );
	/*
	BYTE* buff = (BYTE*) msg;
	int stateSz, notSz;

	// are we expecting the game state?
	if ( GetState() != bgStateRestoreSavedGame )
		return NOERROR;

	// close any status dialogs
	m_Wnd.StatusClose();

	// update state
	stateSz = *( (int*) buff );
	buff += sizeof(int);
	m_SharedState.ProcessDump( buff, stateSz );
	buff += stateSz;
	ASSERT( m_SharedState.GetSize() == stateSz );

	// update notation
	notSz = *( (int*) buff );
	buff += sizeof(int);
	m_Notation.SetStrings( (TCHAR*)buff, notSz );
	ASSERT( m_Notation.GetSize() == notSz );

	// player color is normally set in NewGame
	BOOL hostBrown = m_SharedState.Get( bgHostBrown );
	if ( (hostBrown && !m_Seat) || (!hostBrown && m_Seat) )
	{
		m_Player.m_nColor = zBoardBrown;
		m_Opponent.m_nColor = zBoardWhite;
	}
	else
	{
		m_Player.m_nColor = zBoardWhite;
		m_Opponent.m_nColor = zBoardBrown;
	}

	// update settings
	for ( int i = 0; i < 2; i++ )
	{
		m_Settings.Allow[i] = m_SharedState.Get( bgAllowWatching, i );
		m_Settings.Silence[i] = m_SharedState.Get( bgSilenceKibitzers, i );
	}
		
	// initialize points
	m_Wnd.InitPoints();

	// update screen
	m_Wnd.DrawAll();

	// re-start state
	if ( !IsKibitzer() )
		SetState( m_SharedState.Get( bgState ), TRUE, TRUE );
	*/
	return NOERROR;
}



HRESULT CGame::HandleCheckIn( void* msg, int32 msgLen )
{
	ZPlayerInfoType PlayerInfo;
	ZGameMsgCheckIn* pMsg = (ZGameMsgCheckIn*) msg;

	// check message 
	if(msgLen < sizeof(ZGameMsgCheckIn) || GetState() != bgStateNotInit)
	{
		ASSERT(!"HandleCheckIn sync");
		ZShellGameShell()->ZoneAlert( ErrorTextSync, NULL, NULL, TRUE, FALSE );
		return E_FAIL;
	}

	ZGameMsgCheckInEndian( pMsg );

    pMsg->playerType = 0;  // unused
    pMsg->clientVersion = 0;  // unused
	if(!IsValidSeat(pMsg->seat) || pMsg->protocolSignature != zBackgammonProtocolSignature ||
        pMsg->protocolVersion < zBackgammonProtocolVersion || m_CheckIn[pMsg->seat] ||
        pMsg->playerID == zTheUser || pMsg->playerID == 0)
	{
		ASSERT(!"HandleCheckIn sync");
		ZShellGameShell()->ZoneAlert( ErrorTextSync, NULL, NULL, TRUE, FALSE );
		return E_FAIL;
	}

	m_SharedState.Set( bgUserIds, pMsg->seat, pMsg->playerID );
	ZCRoomGetPlayerInfo( pMsg->playerID, &PlayerInfo );
    if(!PlayerInfo.userName[0])
	{
		ASSERT(!"HandleCheckIn sync");
		ZShellGameShell()->ZoneAlert( ErrorTextSync, NULL, NULL, TRUE, FALSE );
		return E_FAIL;
	}

	// Process player info
	if ( pMsg->seat == m_Seat )
	{
		m_Player.m_Id = pMsg->playerID;
		m_Player.m_Seat = pMsg->seat;
		m_Player.m_bKibitzer = FALSE;
		lstrcpy( m_Player.m_Name, PlayerInfo.userName );
		lstrcpy( m_Player.m_Host, PlayerInfo.hostName );
		m_Player.m_NameLen = lstrlen( m_Player.m_Name );
	}
	else
	{
		m_Opponent.m_Id = pMsg->playerID;
		m_Opponent.m_Seat = pMsg->seat;
		m_Opponent.m_bKibitzer = FALSE;
		lstrcpy( m_Opponent.m_Name, PlayerInfo.userName );
		lstrcpy( m_Opponent.m_Host, PlayerInfo.hostName );
		m_Opponent.m_NameLen = lstrlen( m_Opponent.m_Name );
	}

	// Wait till everyone has checked in
	m_CheckIn[ pMsg->seat ] = TRUE;
	for( int i = 0; i < zNumPlayersPerTable; i++)
	{
		if ( !m_CheckIn[i] )
			return NOERROR;
	}

	/*
	// Draw avatar info
	m_Wnd.DrawAvatars( TRUE );

	*/
#if 0 // Don't save watcher state anymore, so don't need to send it
	if ( !IsKibitzer() )
	{
		int seat = m_Player.m_Seat;
		m_SharedState.StartTransaction( bgTransAllowWatchers );
				m_SharedState.Set( bgAllowWatching, seat, m_Settings.Allow[ seat ] );
		m_SharedState.SendTransaction( FALSE );
		m_SharedState.StartTransaction( bgTransSilenceKibitzers );
			m_SharedState.Set( bgSilenceKibitzers, seat, m_Settings.Silence[ seat ] );
		m_SharedState.SendTransaction( FALSE );
	}
#endif

	//Millennium no longer check for saved games
	//Always start a new game
	if ( IsHost() )
		SetState( bgStateGameSettings );

	//SetState( bgStateCheckSavedGame, FALSE, FALSE );
	
	return NOERROR;
}

HRESULT CGame::HandleDiceRoll(void *msg, int32 msgLen)
{
	ZBGMsgDiceRoll *pMsg = (ZBGMsgDiceRoll *)msg;
	if(msgLen < sizeof(ZBGMsgDiceRoll))
	{
		ASSERT(!"HandleDiceRoll sync");
		ZShellGameShell()->ZoneAlert( ErrorTextSync, NULL, NULL, TRUE, FALSE );
		return E_FAIL;
	}
	
	ZSeat seat = pMsg->seat;
	ZEnd16(&seat)
	
	m_Wnd.m_nRecievedD1 = pMsg->d1.Value;
	ZEnd16(&(m_Wnd.m_nRecievedD1) );
	
	m_Wnd.m_nRecievedD2 = pMsg->d2.Value;
	ZEnd16(&(m_Wnd.m_nRecievedD2));

	m_Wnd.m_fDiceRollReceived = TRUE;
		
	if(!IsValidSeat(seat) || m_Wnd.m_nRecievedD1 < 1 || m_Wnd.m_nRecievedD1 > 6 ||
        m_Wnd.m_nRecievedD2 < 1 || m_Wnd.m_nRecievedD2 > 6)
	{
		ASSERT(!"HandleDiceRoll sync");
		ZShellGameShell()->ZoneAlert( ErrorTextSync, NULL, NULL, TRUE, FALSE );
		return E_FAIL;
	}

	if( seat == m_Seat && !IsKibitzer() ) //update ONLY if you didn't roll
		return NOERROR;
	
    // not validating all this crap.  what is it??
	m_OppDice1.EncodedValue = pMsg->d1.EncodedValue;	
	m_OppDice1.EncoderAdd   = pMsg->d1.EncoderAdd;	
	m_OppDice1.EncoderMul	= pMsg->d1.EncoderMul;
	m_OppDice1.numUses		= pMsg->d1.numUses;
	m_OppDice1.Value		= m_Wnd.m_nRecievedD1;

	ZEnd32( &(m_OppDice1.EncodedValue) );
	ZEnd16( &(m_OppDice1.EncoderAdd)   );
	ZEnd16( &(m_OppDice1.EncoderMul)   );
	ZEnd32( &(m_OppDice1.numUses)      );

	m_OppDice2.EncodedValue = pMsg->d2.EncodedValue;	
	m_OppDice2.EncoderAdd   = pMsg->d2.EncoderAdd;	
	m_OppDice2.EncoderMul	= pMsg->d2.EncoderMul;
	m_OppDice2.numUses		= pMsg->d2.numUses;
	m_OppDice2.Value		= m_Wnd.m_nRecievedD2;

	ZEnd32( &(m_OppDice2.EncodedValue) );
	ZEnd16( &(m_OppDice2.EncoderAdd)   );
	ZEnd16( &(m_OppDice2.EncoderMul)   );
	ZEnd32( &(m_OppDice2.numUses)      );

	SetDice( seat, m_Wnd.m_nRecievedD1, m_Wnd.m_nRecievedD2 );
//	if ( (m_Wnd.m_nRecievedD1 > 0) && (m_Wnd.m_nRecievedD2 > 0) )
//		SetState( bgStateMove );

	return NOERROR;
	
}


HRESULT CGame::HandleTalk( void* msg, int32 msgLen )
{
    int i;
	ZBGMsgTalk* pMsg = (ZBGMsgTalk*) msg;
	TCHAR*	    str  = (TCHAR *) ((BYTE *) pMsg + sizeof(ZBGMsgTalk));

	/*	ZPlayerInfoType PlayerInfo;*/
	// check message
	if(msgLen < sizeof(ZBGMsgTalk))
	{
		ASSERT(!"HandleTalk sync");
		ZShellGameShell()->ZoneAlert( ErrorTextSync, NULL, NULL, TRUE, FALSE );
		return E_FAIL;
	}

	ZBGMsgTalkEndian( pMsg );

    if(pMsg->messageLen < 1 || pMsg->messageLen + sizeof(ZBGMsgTalk) != (uint32) msgLen || !pMsg->userID || pMsg->userID == zTheUser)
	{
		ASSERT(!"HandleTalk sync");
		ZShellGameShell()->ZoneAlert( ErrorTextSync, NULL, NULL, TRUE, FALSE );
		return E_FAIL;
	}

    // make sure it's got a null in it
    for(i = 0; i < pMsg->messageLen; i++)
        if(!str[i])
            break;
    if(i == pMsg->messageLen)
    {
		ASSERT(!"HandleTalk sync");
		ZShellGameShell()->ZoneAlert( ErrorTextSync, NULL, NULL, TRUE, FALSE );
		return E_FAIL;
    }
    
	/*
	// are kibitzers silenced?
	if (	( !IsKibitzer() )
		&&	( m_Settings.Silence[ 0 ] || m_Settings.Silence[ 1 ] )
		&&	( (pMsg->userID != m_Player.m_Id) && (pMsg->userID != m_Opponent.m_Id) ) )
	{
		return NOERROR;
	}	
	// process message
	ZCRoomGetPlayerInfo( pMsg->userID, &PlayerInfo );
	*/
	
	/*(str + pMsg->messageLen) = _T('\0');	*/
	ZShellGameShell()->ReceiveChat( this, pMsg->userID, str, pMsg->messageLen / sizeof(TCHAR));
	/*
	if ( m_Wnd.m_pChat )
		m_Wnd.m_pChat->AddText( PlayerInfo.userName, str );
	*/
	return NOERROR;
}


HRESULT CGame::HandleNotationString( void* msg, int32 msgLen )
{

	ASSERT( FALSE );
	/*
	int col;
	ZBGMsgTurnNotation* pMsg = (ZBGMsgTurnNotation*) msg;

	// check message 
	if ( msgLen < sizeof(ZBGMsgTurnNotation) )
		return E_FAIL;
	ZBGMsgTurnNotationEndian( pMsg );
	if ( !IsValidSeat(pMsg->seat) )
		return E_FAIL;

	// ignore messages from myself
	if ( !IsKibitzer() && (pMsg->seat == m_pMe->m_Seat) )
		return NOERROR;

	// add string
	if ( pMsg->seat == m_Player.m_Seat )
		col = m_Player.GetColor();
	else
		col = m_Opponent.GetColor();
	switch( pMsg->type )
	{
	case 0:
		m_Notation.AddMove( col, ((TCHAR*) pMsg) + sizeof(ZBGMsgTurnNotation) );
		break;
	case 1:
		m_Notation.AddGame( col, ((TCHAR*) pMsg) + sizeof(ZBGMsgTurnNotation) );
		break;
	case 2:
		m_Notation.AddMatch( col, ((TCHAR*) pMsg) + sizeof(ZBGMsgTurnNotation) );
		break;
	default:
		ASSERT( FALSE );
	}
	*/
	return NOERROR;
}




HRESULT CGame::HandleEndLog( void* msg, int32 msgLen )
{
	TCHAR title[128], txt[512];
	ZBGMsgEndLog*pMsg = (ZBGMsgEndLog*) msg;

    if (!IsKibitzer() )
    {
        /*
	    if (pMsg->reason==zBGEndLogReasonTimeout)
	    {
			
		    if (pMsg->seatLosing==m_Seat)
		    {
			
			    LoadString( m_hInstance, IDS_GAME_NAME, title, sizeof(title) );
			    LoadString( m_hInstance, IDS_MATCH_TIMEOUT, txt, sizeof(txt) );
			    MessageBox( NULL, txt, title, MB_TASKMODAL );
			    m_EndLogReceived=TRUE;
				
		    }
            else
		    {
			
		    LoadString( m_hInstance, IDS_GAME_NAME, title, sizeof(title) );
		    LoadString( m_hInstance, IDS_MATCH_FORFEIT, txt, sizeof(txt) );
			MessageBox( NULL, txt, title,  MB_OK | MB_ICONINFORMATION | MB_TASKMODAL );
			m_EndLogReceived=TRUE;
		   }
	    } 
	    else 
	    {
		    if (pMsg->seatLosing!=m_Seat)
		    {
		    LoadString( m_hInstance, IDS_GAME_NAME, title, sizeof(title) );
		    LoadString( m_hInstance, IDS_MATCH_FORFEIT, txt, sizeof(txt) );
			    MessageBox( NULL, txt, title,  MB_OK | MB_ICONINFORMATION | MB_TASKMODAL );
			    m_EndLogReceived=TRUE;
		    } 
	    }
		*/
    }
	
	ZCRoomGameTerminated( m_TableId );

	return NOERROR;
};

HRESULT CGame::HandleMoveTimeout( void* msg, int32 msgLen )
{
	ASSERT( FALSE );
/*	
	char title[128], txt[512],buff[512];
	ZBGMsgMoveTimeout *pMsg=(ZBGMsgMoveTimeout *) msg;

    if (IsKibitzer() )
    {
        return NOERROR;
    }

	if ( pMsg->seat == m_Seat ) 
	{
		// then its me timing out and I don't get a warning
	}
	else
	{
        m_bOpponentTimeout=TRUE;
		LoadString( m_hInstance, IDS_GAME_NAME, title, sizeof(title) );
		LoadString( m_hInstance, IDS_TURN_TIMEOUT, txt, sizeof(txt) );
		wsprintf(buff,txt,pMsg->userName,pMsg->timeout);
		MessageBox( NULL, buff, title, MB_OK | MB_ICONINFORMATION | MB_TASKMODAL );
	}
*/
	return NOERROR;

};

HRESULT CGame::HandleEndTurn( void* msg, int32 msgLen )
{
	m_bOpponentTimeout=FALSE;
	return NOERROR;
}


///////////////////////////////////////////////////////////////////////////////
// Transaction callbacks
///////////////////////////////////////////////////////////////////////////////

void CGame::SettingsTransaction( int tag, int seat, DWORD cookie )
{
	
/*
	CGame* pObj = (CGame*) cookie;

	// ignore transaction if not setting up a game
	if ( pObj->GetState() != bgStateGameSettings )
		return;

	// kibitizers don't have a match settings dialog
	if ( pObj->IsKibitzer() )
		return;



	// manage dialog box
	if ( pObj->m_SetupDlg.IsAlive() )
	{
		pObj->m_SetupDlg.UpdateSettings(
				pObj->m_SharedState.Get( bgTargetScore),
				pObj->m_SharedState.Get( bgHostBrown ),
				pObj->m_SharedState.Get( bgAutoDouble ) );
	}
*/
}


void CGame::SettingsReadyTransaction( int tag, int seat, DWORD cookie )
{

	ASSERT( FALSE );
/*
	CGame* pObj = (CGame*) cookie;

	// ignore transaction if not setting up a game
	if ( pObj->GetState() != bgStateGameSettings )
		return;

	// ignore transaction if not host
	if ( !pObj->IsHost() )
		return;

	// ignore transaction if dialog not up
	if ( !pObj->m_SetupDlg.IsAlive() )
		return;

	// enable buttons
	if ( pObj->m_SharedState.Get( bgSettingsReady ) )
	{
		EnableWindow( GetDlgItem( pObj->m_SetupDlg, IDOK ), TRUE );
		EnableWindow( GetDlgItem( pObj->m_SetupDlg, IDCANCEL ), TRUE );
	}
	else
	{
		EnableWindow( GetDlgItem( pObj->m_SetupDlg, IDOK ), FALSE );
		EnableWindow( GetDlgItem( pObj->m_SetupDlg, IDCANCEL ), FALSE );
	}
*/
}


void CGame::DoublingCubeTransaction( int tag, int seat, DWORD cookie )
{
	CGame* pObj = (CGame*) cookie;

	// redraw doubling cube
	pObj->m_Wnd.DrawCube();
}


void CGame::DiceTransaction( int tag, int seat, DWORD cookie )
{
	int v0, v1;
	CGame* pObj = (CGame*) cookie;

	// redraw dice
	pObj->m_Wnd.DrawDice();

	// kibitzers only draw the dice
	if ( pObj->IsKibitzer() )
		return;

	// adjust state as appropriate
	switch ( pObj->GetState() )
	{
	case bgStateInitialRoll:
		pObj->WhoGoesFirst();		
		break;
	case bgStateRoll:
	case bgStateRollPostDouble:
	case bgStateRollPostResign:
		if ( pObj->m_SharedState.Get(bgActiveSeat) == pObj->m_Player.m_Seat )
		{  //setting of the dice
			pObj->GetDice( pObj->m_Player.m_Seat, &v0,&v1 );
			if ( (v0 > 0) && (v1 > 0) )
				pObj->SetState( bgStateMove );
		}
		break;
	}		
}


void CGame::StateChangeTransaction( int tag, int seat, DWORD cookie )
{
	CGame* pObj = (CGame*) cookie;

	// switch to new state
	pObj->SetState( pObj->m_SharedState.Get(bgState), TRUE  );
}


void CGame::BoardTransaction( int tag, int seat, DWORD cookie )
{
	CGame* pObj = (CGame*) cookie;
	CPieceSprite* s;
	CPieceSprite* Sprites[2];
	int Dests[2];
	int nChanged = 0;
	int i, j;
	int checkseat;
	
	if (	(pObj->m_Settings.Animation)
		&&	(	(pObj->IsKibitzer() )
			 || (pObj->m_SharedState.Get( bgActiveSeat ) != pObj->m_Player.m_Seat) ) )
	{
		// what changed?
		for ( i = 0; i < 30; i++ )
		{
			s = pObj->m_Wnd.m_Pieces[i];
			j = pObj->m_SharedState.Get( bgPieces, i );
			if ( s->GetWhitePoint() != j )
			{
				Sprites[ nChanged ] = s;
				Dests[ nChanged++ ] = j;
			}
		}

		//Get the opponents seat
		//checkseat = pObj->m_Opponent.m_Seat;
		checkseat = pObj->GetActiveSeatColor() - 1; //since neutral is 0
			
		// handle changes
		switch ( nChanged )
		{
		case 0:
			break;
		case 1:
			pObj->ValidateMove( seat, Sprites[0]->m_Point, Dests[0] );
			pObj->m_Wnd.MovementStart( Sprites[0], Dests[0] );
			break;
		case 2:
			if ( pObj->GetActiveSeatColor() == zBoardWhite )
				i = 0, j = 1;
			else
				i = 1, j = 0;
			pObj->ValidateMove( seat, Sprites[checkseat]->m_Point, Dests[checkseat] );
			pObj->m_Wnd.MovementStart( Sprites[j], Dests[j] );
			pObj->m_Wnd.MovementStart( Sprites[i], Dests[i] );
			break;
		default:
			ASSERT( FALSE );
		}
	}

	// redraw board
	pObj->m_Wnd.DrawDice( FALSE );
	pObj->m_Wnd.DrawPips( FALSE );
	
	if ( !nChanged )
		pObj->m_Wnd.DrawBoard( FALSE );
	
	pObj->m_Wnd.UpdateWnd();

}


void CGame::AcceptDoubleTransaction( int tag, int seat, DWORD cookie )
{
	CGame* pObj = (CGame*) cookie;

	// redraw cube
	pObj->m_Wnd.DrawCube();

	// return to roll state
	pObj->SetState( bgStateRollPostDouble, TRUE );
}


void CGame::AllowWatchersTransaction( int tag, int seat, DWORD cookie )
{
	ZGameMsgTableOptions msg;
	CGame* pObj = (CGame*) cookie;

	// update settings
	pObj->m_Settings.Allow[0] = pObj->m_SharedState.Get( bgAllowWatching, 0 );
	pObj->m_Settings.Allow[1] = pObj->m_SharedState.Get( bgAllowWatching, 1 );

	// only players update table options
	if ( pObj->IsKibitzer() )
		return;

	// update options on the server
	msg.seat = pObj->m_Player.m_Seat;
	if ( pObj->m_Settings.Allow[ msg.seat ] )
	{
		if ( !pObj->m_AllowMsg )
		{
			pObj->m_AllowMsg = TRUE;
			msg.options = 0;
			ZGameMsgTableOptionsEndian( &msg );
			pObj->RoomSend( zGameMsgTableOptions, &msg, sizeof(msg) );
		}
	}
	else
	{
		if ( pObj->m_AllowMsg )
		{
			pObj->m_AllowMsg = FALSE;
			msg.options = zRoomTableOptionNoKibitzing;
			ZGameMsgTableOptionsEndian( &msg );
			pObj->RoomSend( zGameMsgTableOptions, &msg, sizeof(msg) );
		}
	}

	// redraw screen
	pObj->m_Wnd.DrawAvatars( TRUE );
}


void CGame::SilenceKibitzersTransaction( int tag, int seat, DWORD cookie )
{

	/*
	CGame* pObj = (CGame*) cookie;
	char title[128], msg[1028];

	// update settings
	pObj->m_Settings.Silence[0] = pObj->m_SharedState.Get( bgSilenceKibitzers, 0 );
	pObj->m_Settings.Silence[1] = pObj->m_SharedState.Get( bgSilenceKibitzers, 1 );

	if ( !pObj->IsKibitzer() )
		return;

	// display message to kibitzers
	if ( pObj->m_Settings.Silence[0] || pObj->m_Settings.Silence[1] )
	{
		if ( !pObj->m_SilenceMsg )
		{
			pObj->m_SilenceMsg = TRUE;
			LoadString( pObj->m_hInstance, IDS_SILENCE_TITLE, title, sizeof(title) );
			LoadString( pObj->m_hInstance, IDS_SILENCE_MSG_ON, msg, sizeof(msg) );
			MessageBox( NULL, msg, title, MB_OK | MB_ICONINFORMATION | MB_TASKMODAL );
		}

	}
	else
	{
		if ( pObj->m_SilenceMsg )
		{
			pObj->m_SilenceMsg = FALSE;
			LoadString( pObj->m_hInstance, IDS_SILENCE_TITLE, title, sizeof(title) );
			LoadString( pObj->m_hInstance, IDS_SILENCE_MSG_OFF, msg, sizeof(msg) );
			MessageBox( NULL, msg, title, MB_OK | MB_ICONINFORMATION | MB_TASKMODAL );
		}
	}
*/
}



void CGame::TimestampTransaction( int tag, int seat, DWORD cookie )
{
	DWORD hi0, hi1, lo0, lo1;
	CGame* pObj = (CGame*) cookie;

	// only host gets to process timestamps
	if ( !pObj->IsHost() )
		return;

	// need both player's timestamps
	if ( !pObj->m_SharedState.Get( bgTimestampSet, 0 ) || !pObj->m_SharedState.Get( bgTimestampSet, 1 ) )
		return;

	hi0 = pObj->m_SharedState.Get( bgTimestampHi, 0 );
	hi1 = pObj->m_SharedState.Get( bgTimestampHi, 1 );
	lo0 = pObj->m_SharedState.Get( bgTimestampLo, 0 );
	lo1 = pObj->m_SharedState.Get( bgTimestampLo, 1 );
	if ( !hi0 && !hi1 && !lo0 && !lo1 )
		pObj->SetState( bgStateGameSettings );	
	else
    {
        ASSERT(FALSE);
		pObj->SetState( bgStateRestoreSavedGame );
    }
}


void CGame::RestoreGameTransaction( int tag, int seat, DWORD cookie )
{
	ASSERT( FALSE );
	/*
	CSharedState state;
	HRESULT hr;
	BackgammonSavedGameHeader* header = NULL;
	BYTE* pData = NULL;
	BYTE* pDump = NULL;
	int* pState = NULL;
	DWORD size = 0;
	int i;
	CGame* pObj = (CGame*) cookie;
	
	// shouldn't be restoring games
	if ( pObj->IsKibitzer() )
		return;

	// other guy restoring the game
	if ( pObj->m_SharedState.Get( bgActiveSeat ) != pObj->m_Player.m_Seat )
		return;

	// get game data
	pObj->LoadGame( &pData, &size );
	if ( !pData )
		goto error;

	// load state
	header = (BackgammonSavedGameHeader*) pData;
	pState = (int*)( header + 1 );
	hr = state.Init( 0, 0, 0, InitSharedState, sizeof(InitSharedState) / sizeof(SharedStateEntry) );
	if ( FAILED(hr) )
		goto error;
	state.ProcessDump( (BYTE*)(pState + 1), *pState );

	// reset kibitzer options
	for ( i = 0; i < 2; i++ )
	{
		state.Set( bgAllowWatching, i, TRUE );
		state.Set( bgSilenceKibitzers, i, FALSE );
	}

	// replace old user ids
	state.Set( bgUserIds, pObj->m_Player.m_Seat,   pObj->m_Player.m_Id );
	state.Set( bgUserIds, pObj->m_Opponent.m_Seat, pObj->m_Opponent.m_Id );
	
	// has seating order changed?
	if ( header->host != pObj->IsHost() )
	{
		// swap values indexed by seat
		state.Set( bgHostBrown, !state.Get( bgHostBrown ) );
		state.Set( bgActiveSeat, !state.Get( bgActiveSeat ) );
		state.Swap( bgScore, 0, 1 );
		state.Swap( bgDice, 0, 2 );
		state.Swap( bgDice, 1, 3 );
		state.Swap( bgDiceSize, 0, 2 );
		state.Swap( bgDiceSize, 1, 3 );
	}

	// save state
	state.Dump( (BYTE*)(pState + 1), *pState );
	
	// send game state to everyone
	pDump = (BYTE*)(header + 1);
	pObj->RoomSend( zBGMsgSavedGameState, pDump, size - sizeof(BackgammonSavedGameHeader) );
	
	// we're done
	delete [] pData;
	return;

error:
	if ( pData )
		delete [] pData;
	pObj->SetState( bgStateGameSettings );
	return;
	*/
}


void CGame::MissTransaction( int tag, int seat, DWORD cookie )
{
	TCHAR in[512], out[512];
	CGame* pObj = (CGame*) cookie;

	//Now only called when opponent cannot move
	
	ZShellResourceManager()->LoadString( IDS_MISS_KIBITZER, (TCHAR*)in, 512 );

	BkFormatMessage( in, out, 512, pObj->m_Opponent.m_Name );

	pObj->m_Wnd.StatusDisplay( bgStatusNormal, out, 4000, -1 );
}

void CGame::ReadyTransaction( int tag, int seat, DWORD cookie )
{
	
	CGame* pObj = (CGame*) cookie;
	
	pObj->m_Ready[seat] = TRUE;
	
	if ( seat == pObj->m_Player.m_Seat )
		ZShellGameShell()->GameOverPlayerReady(pObj, pObj->m_Player.m_Id);
	else
		ZShellGameShell()->GameOverPlayerReady(pObj, pObj->m_Opponent.m_Id);

	for( int i = 0; i < zNumPlayersPerTable ; i++)
	{
		if ( pObj->m_Ready[i] == FALSE )
			return;
	}
		
	pObj->SetState( bgStateGameSettings, TRUE );

}	

///////////////////////////////////////////////////////////////////////////////

void CGame::UpdateNotationPane( int nGameOver )
{

	ASSERT( FALSE );
	/*
	TCHAR line[512];
	TCHAR buff[64];
	TCHAR szFrom[16], szTo[16];
	BOOL first;
	BOOL bar;
	int i, j, from, to, cnt;

	if ( !IsMyTurn() )
		return;

	switch ( nGameOver )
	{
	case 0: // standard turn

		// dice
		wsprintf( line, _T("%d%d  "), m_TurnState.dice[0].val, m_TurnState.dice[1].val );

		// double
		if ( m_TurnState.cube )
		{
			wsprintf( buff, _T("dbl%d "), m_TurnState.cube );
			lstrcat( line, buff );
		}
	
		// turns
		if ( m_TurnState.moves.nmoves )
		{
			for ( first = TRUE, i = 0; i < m_TurnState.moves.nmoves; i++ )
			{
				// find a turn
				if ( m_TurnState.moves.moves[i].takeback >= 0 )
					continue;
				bar = m_TurnState.moves.moves[i].bar;
				to = m_TurnState.moves.moves[i].to;
				from = m_TurnState.moves.moves[i].from;
				for ( cnt = 1, j = i + 1; j < m_TurnState.moves.nmoves; j++ )
				{
					if ( m_TurnState.moves.moves[i].takeback >= 0 )
						continue;
					if ( (to != m_TurnState.moves.moves[j].to) || (from != m_TurnState.moves.moves[j].from) )
						break;
					cnt++;
					m_TurnState.moves.moves[j].takeback = 1;
				}

				// add coma
				if ( !first )
					lstrcat( line, _T(", ") );

				// create point strings
				GetTxtForPointIdx( BoardStateIdxToPointIdx( to ), szTo );
				GetTxtForPointIdx( BoardStateIdxToPointIdx( from ), szFrom );
				if ( cnt > 1 )
					wsprintf( buff, _T("%s-%s(%d)"), szFrom, szTo, cnt );
				else
					wsprintf( buff, _T("%s-%s"), szFrom, szTo );
		
				// add hit indicator
				if ( bar )
					lstrcat( buff, _T("*") );

				// add move to turn
				lstrcat( line, buff );
				first = FALSE;
			}
		}
		else
			lstrcat( line, _T("miss") );
		
		// add move
		m_Notation.AddMove( m_Player.GetColor(), line );
		SendNotationString( 0, line );
		break;

	case 1: // game over
		if ( m_GameScore == 1 )
			lstrcpy( buff, _T("pt") );
		else
			lstrcpy( buff, _T("pts") );
		wsprintf( line, _T("game over (won %d %s)"), m_GameScore, buff );
		m_Notation.AddGame( m_Player.GetColor(), line );
		SendNotationString( 1, line );
		break;

	case 2: // match over
		if ( m_GameScore == 1 )
			lstrcpy( buff, "pt" );
		else
			lstrcpy( buff, "pts" );
		wsprintf( line, "game over (won %d %s), match over", m_GameScore, buff );
		m_Notation.AddMatch( m_Player.GetColor(), line );
		SendNotationString( 2, line );
		break;
	}
	*/

	// clear cube
	m_TurnState.cube = 0;
}


///////////////////////////////////////////////////////////////////////////////
// Game Functions
///////////////////////////////////////////////////////////////////////////////

void CGame::WhoGoesFirst()
{

	int valp, valo;
	int ret;
	ZBGMsgFirstMove msg;

	// kibitzers aren't involved in the initial roll
	if ( IsKibitzer() )
		return;

	// Do we have both rolls?
	GetDice( m_Player.m_Seat, &valp, &ret );
	GetDice( m_Opponent.m_Seat, &valo, &ret );
	if ((valp <= 0) || (valo <= 0))
		return;

	// display roll status
	if ( valp == valo )
		m_Wnd.StatusDisplay( bgStatusNormal, IDS_INIT_ROLL_TIE,  3000 );
	else if ( valp < valo )
		m_Wnd.StatusDisplay( bgStatusNormal, IDS_INIT_ROLL_LOSS, 3000 );
	else
		m_Wnd.StatusDisplay( bgStatusNormal, IDS_INIT_ROLL_WIN,  3000 );

	// host decides what to do next
	if ( valp == valo )
	{
		
		EnableRollButton( TRUE );
        ZShellGameShell()->MyTurn();

		// only the host decides what to do next
		if ( !IsHost() )
			return;

        //Why are we doing this because server needs to know when first roll occurs
        //of course previous owners of this code didn't put this roll on server
        ZBGMsgEndTurn msg;
		msg.seat = m_Seat;
		RoomSend( zBGMsgTieRoll, &msg, sizeof(msg) );


		if ( m_SharedState.Get( bgAutoDouble ) )
		{
			// tied, set doubling cube
			m_SharedState.StartTransaction( bgTransDoublingCube );
				m_SharedState.Set( bgCubeOwner, zBoardNeutral );
				m_SharedState.Set( bgCubeValue, 2 );
			m_SharedState.SendTransaction( TRUE );
		}
		m_SharedState.StartTransaction( bgTransDice );
			SetDice( m_Player.m_Seat, 0, -1 );
			SetDice( m_Opponent.m_Seat, 0, -1 );
			m_Wnd.m_nRecievedD1 = 0;
			m_Wnd.m_nRecievedD2 = -1;
		m_SharedState.SendTransaction( TRUE );

	}
	else if ( valp < valo )
	{		
		
		m_GameStarted=TRUE;

		//Need to pop the roll items and disable the board
//		m_Wnd.m_pGAcc->PopItemlist();
		m_Wnd.DisableBoard();

		//Get the dice for move validation
		m_OppDice1 = EncodeDice( valo );
		m_OppDice2 = EncodeDice( valp );		

		if ( m_OppDice1.Value == m_OppDice2.Value )
		{
			EncodeUses( &m_OppDice1, 2 );
			EncodeUses( &m_OppDice2, 2 );
		}
 		else
		{
			EncodeUses( &m_OppDice1, 1 );
			EncodeUses( &m_OppDice2, 1 );		
		}
		
		// only the host decides what to do next
		if ( !IsHost() )
			return;
		
		m_SharedState.StartTransaction( bgTransDice );
			SetDice( m_Player.m_Seat, -1, -1 );
			SetDice( m_Opponent.m_Seat, valo, valp );
			m_Wnd.m_nRecievedD1 = valo;
			m_Wnd.m_nRecievedD2 = valp;
			m_SharedState.Set( bgActiveSeat, m_Opponent.m_Seat );
		m_SharedState.SendTransaction( TRUE );

		SetState( bgStateMove );

		// tell server first move is starting and number of points in match
		msg.numPoints = m_SharedState.Get( bgTargetScore );
		msg.seat = m_Opponent.m_Seat;
		ZBGMsgFirstMoveEndian( &msg );
		RoomSend( zBGMsgFirstMove, &msg, sizeof( msg ) );
		
	}
	else
	{
		m_GameStarted=TRUE;

		// only the host decides what to do next
		if ( !IsHost() )
			return;

		m_SharedState.StartTransaction( bgTransDice );
			SetDice( m_Player.m_Seat, valp, valo );
			m_Wnd.m_nRecievedD1 = valp;
			m_Wnd.m_nRecievedD2 = valo;
			SetDice( m_Opponent.m_Seat, -1, -1 );
			m_SharedState.Set( bgActiveSeat, m_Player.m_Seat );
		m_SharedState.SendTransaction( TRUE );

		SetState( bgStateMove );

		// tell server first move is starting and number of points in match
		msg.numPoints = m_SharedState.Get( bgTargetScore );
		msg.seat = m_Player.m_Seat;
		ZBGMsgFirstMoveEndian( &msg );
		RoomSend( zBGMsgFirstMove, &msg, sizeof( msg ) );		
		
	}
}

///////////////////////////////////////////////////////////////////////////////
// Sound Functions
///////////////////////////////////////////////////////////////////////////////

struct SoundEntry
{
	int Id;
	int Resource;
};

static SoundEntry SoundMap[] =
{
	{ bgSoundPlacePiece,		IDR_SOUND_PLACE },
	{ bgSoundGameWin,			IDR_SOUND_WIN },
	{ bgSoundGameLose,			IDR_SOUND_LOSE },
	{ bgSoundButtonHighlight,	IDR_SOUND_BUTTON_HIGHLIGHT },
	{ bgSoundButtonDown,		IDR_SOUND_BUTTON_DOWN },
	{ bgSoundAlert,				IDR_SOUND_ALERT },
//	{ bgSoundMiss,				IDR_SOUND_MISS },
	{ bgSoundGameWin,			IDR_SOUND_WIN },
	{ bgSoundGameLose,			IDR_SOUND_LOSE },
	{ bgSoundMatchWin,			IDR_SOUND_MATCH_WIN },
	{ bgSoundMatchLose,			IDR_SOUND_MATCH_LOSE },
	{ bgSoundHit,				IDR_SOUND_HIT },
	{ bgSoundBear,				IDR_SOUND_PLACE },
	{ bgSoundRoll,				IDR_SOUND_ROLL }
};



void CGame::PlaySound( BackgammonSounds sound, BOOL fSync )
{
	//Only play if sounds are on,,,
	if ( ZIsSoundOn() )
	{
	
		DWORD flags;
		int i, rc;
	
		// ignore request
		if (	( sound < 0 )
			||	( (sound == bgSoundAlert) && ( !m_Settings.Alert ) )
			||	( (sound != bgSoundAlert) && ( !m_Settings.Sounds ) ) )
		{
			return;
		}

		// find sound
		for ( rc = -1, i = 0; i < (sizeof(SoundMap) / sizeof(SoundEntry)); i++ )
		{
			if ( SoundMap[i].Id == sound )
				rc = SoundMap[i].Resource;
		}
		if ( rc < 0 )
			return;

		// The alert sound usually cuts off piece placement sound.  This little
		// kludge waits gives the placement sound a little more time.
		if ( (sound == bgSoundAlert) && (m_Settings.Sounds) )
			Sleep( 400 );
		flags = SND_RESOURCE | SND_NODEFAULT;
		if ( fSync )
			flags |= SND_SYNC;
		else
			flags |= SND_ASYNC;
	
		HINSTANCE hInstance = ZShellResourceManager()->GetResourceInstance( MAKEINTRESOURCE(rc), _T("WAVE"));
	
		::PlaySound( MAKEINTRESOURCE(rc), hInstance, flags );
	}
}



void CGame::OnResignStart()
{

	// Reference count game object
	AddRef();

	//Disable the roll button
	EnableRollButton( FALSE );
	EnableResignButton( FALSE );
	EnableDoubleButton( FALSE );



}

void CGame::OnResignEnd()
{
	int result = m_ResignDlg.GetResult();
	switch ( result )
	{
	case -1:
		// premature close, probably exit

		//Enable the roll button
		EnableRollButton( TRUE );
		EnableResignButton( TRUE );
		EnableDoubleButton( TRUE );

		break;

	case 0:

		//Enable the roll button
		EnableRollButton( TRUE );
		EnableResignButton( TRUE );
		EnableDoubleButton( TRUE );

		// user canceled
		SetState( bgStateRollPostResign );
		break;

	default:
		// transition to resign accept
		m_SharedState.StartTransaction( bgTransStateChange );
			m_SharedState.Set( bgState, bgStateResignAccept );
			m_SharedState.Set( bgResignPoints, result  );
		m_SharedState.SendTransaction( TRUE );
		
		ZBGMsgEndTurn msg;
		msg.seat = m_Seat;
		RoomSend( zBGMsgEndTurn, &msg, sizeof(msg) );
		break;
	}

	// Release game object
	Release();
}



void CGame::OnResignAcceptEnd()
{
	ZBGMsgEndTurn msg;
	
	int result = m_ResignAcceptDlg.GetResult();
	
	switch ( result )
	{
	case -1:
		// premature close, probably exit
		break;

	case IDOK:
		// user accepted, transition to gameover
		m_SharedState.StartTransaction( bgTransStateChange );
			m_SharedState.Set( bgState, bgStateGameOver );
			m_SharedState.Set( bgGameOverReason, bgGameOverResign );
			m_SharedState.Set( bgActiveSeat, m_Player.m_Seat );
		m_SharedState.SendTransaction( TRUE );
		
		break;

	case IDCANCEL:
		// user refused
		SetState( bgStateResignRefused );

		msg.seat = m_Seat;
		RoomSend( zBGMsgEndTurn, &msg, sizeof(msg) );
		break;
	}

	// Release game object
	Release();
}


DWORD  CGame::Focus(long nIndex, long nIndexPrev, DWORD rgfContext, void *pvCookie)
{
    if(nIndex != ZACCESS_InvalidItem)
        SetFocus(m_Wnd.GetHWND());

	//In Rollbutton State only the Roll Double and Resign buttons should be enabled
	if ( NeedToRollDice() )
	{
		
		//If the button is disabled reject the focus
		switch( nIndex )
		{			
			case 0:
				if ( m_Wnd.m_RollButton.CurrentState()   == CRolloverButton::ButtonState::Disabled )
					return ZACCESS_Reject;
				break;
			case 1:
				if ( m_Wnd.m_DoubleButton.CurrentState() == CRolloverButton::ButtonState::Disabled )
					return ZACCESS_Reject;
				break;
			case 2:
				if ( m_Wnd.m_ResignButton.CurrentState() == CRolloverButton::ButtonState::Disabled )
					return ZACCESS_Reject;
				break;
			case 3:
				if ( !m_Wnd.m_Status->Enabled() )
					return ZACCESS_Reject;
				break;
			case ZACCESS_InvalidItem:
				return ZACCESS_Reject;
			default:
				ASSERT(!"ERROR IN FOCUS");
				return ZACCESS_Reject;
		}

		return 0;
		
	}
	else if ( GetState() == bgStateMove )
	{		
		
		if ( nIndex == accStatusExit && m_Wnd.m_Status->Enabled() )
			return 0;
		

		if ( !IsMyTurn() )
			return ZACCESS_Reject;

		return 0;
	}
	
	return ZACCESS_Reject;
}

DWORD CGame::Select(long nIndex, DWORD rgfContext, void *pvCookie)
{
	//Same functionality as Activate
	return Activate( nIndex, rgfContext, pvCookie );	
}

DWORD CGame::Activate(long nIndex, DWORD rgfContext, void *pvCookie)
{	
	
	//If the status sprite is enabled and esc is pressed then get rid of it
	if ( m_Wnd.m_pGAcc->GetItemID(nIndex) == IDC_ESC )
	{
		if ( m_Wnd.m_Status->Enabled() )
		{
			m_Wnd.m_Status->Tick( m_Wnd.GetHWND(), 0 );
			m_Wnd.OnStatusEnd();
		}
	}	
	else if ( NeedToRollDice() )
	{

		 switch ( m_Wnd.m_pGAcc->GetItemID(nIndex) )
		 {
			case IDC_ROLL_BUTTON:				
				m_Wnd.DiceStart();
				break;
			case IDC_DOUBLE_BUTTON:
				Double();
				break;
			case IDC_RESIGN_BUTTON:
				Resign();
				break;
			default:
				ASSERT(!"ERROR ACTIVATE");
		 }

	}
	else if ( GetState() == bgStateMove )
	{
		
		//If there are no pieces on this index or the pieces belong to the other player then reject the activate
		//else begin a drag operation
		if ( !IsValidStartPoint( ACCTOBOARD(nIndex) ))
			return ZACCESS_Reject;

		//TODO.. allocation
		Move* pMove;

		//If we can bear off then enable the bar space
		if ( IsValidDestPoint( ACCTOBOARD(nIndex), 24, &pMove ) )
			m_Wnd.m_pGAcc->SetItemEnabled(true, accPlayerBearOff );

		//Update the window
		m_Wnd.UpdateWnd();

		return ZACCESS_BeginDrag;		
	}
	
	return 0;

}


DWORD CGame::Drag(long nIndex, long nIndexOrig, DWORD rgfContext, void *pvCookie)
{
	if ( NeedToRollDice() )
	{
		ASSERT(!"SHOULDN'T BE IN HERE ");	

	}
	else if ( GetState() == bgStateMove )
	{
		Move* pMove;

		//Toggle the selection off
		if ( nIndexOrig == nIndex )
			return 0;

		//Make sure its a valid destination point
		if(!IsValidDestPoint( ACCTOBOARD(nIndexOrig), ACCTOBOARD(nIndex), &pMove))
			return ZACCESS_Reject;
	
		//Make the move
		MakeMove( m_Wnd.m_Points[GetPointIdx(ACCTOBOARD(nIndexOrig))].pieces[m_Wnd.m_Points[GetPointIdx(ACCTOBOARD(nIndexOrig))].nPieces-1] , ACCTOBOARD(nIndexOrig), ACCTOBOARD(nIndex), pMove );
			
		//Get rid of the selection rectangle
		//m_Wnd.m_SelectRect.SetEnable(FALSE);

		//set the bear off as disabled in case it was enabled
		m_Wnd.m_pGAcc->SetItemEnabled(false, accPlayerBearOff );

		//Set the end turn state if required
		if ( IsTurnOver() )
		{
			SetState( bgStateEndTurn );
			m_Wnd.m_FocusRect.SetEnable(FALSE);

            // if the last spot was the bear off, move the default focus
	        if(nIndex == accPlayerBearOff)
		        m_Wnd.m_pGAcc->SetItemGroupFocus(accPlayerSideStart, accPlayerSideStart);

			//m_Wnd.DisableBoard();
		}

		return 0;
	}
	
	return ZACCESS_InvalidItem;
}
 

void CGame::DrawFocus(RECT *prc, long nIndex, void *pvCookie)
{
	if ( prc == NULL )
	{
		m_Wnd.m_FocusRect.SetEnable(FALSE);				

		//Get rid of the highlights
		m_Wnd.EraseHighlights();

	}
	else
	{

		//End a mouse drag if one is in progress
		if ( m_Wnd.m_pPieceDragging != NULL )
		{
			m_Wnd.DragEnd();
			SetCursor( m_Wnd.m_hCursorArrow );
		}
	
		if ( !m_Wnd.m_SelectRect.Enabled() )
		{
			//Get rid of the old highlights
			m_Wnd.EraseHighlights();

			//Draw the new highlights
			m_Wnd.DrawHighlights(ACCTOBOARD(nIndex), FALSE);
		}
	
		//Enable the rect sprite if not yet enabled
		if ( !m_Wnd.m_FocusRect.Enabled() )
			m_Wnd.m_FocusRect.SetEnable( true );

		//Set the rectangle and dimensions for the rectangle
		//also set the x and y
		m_Wnd.m_FocusRect.SetRECT( *prc );
		m_Wnd.m_FocusRect.SetImageDimensions( prc->right - prc->left + 2, prc->bottom - prc->top + 2 );
		m_Wnd.m_FocusRect.SetXY( prc->left-1, prc->top-1 );	
		m_Wnd.m_FocusRect.Draw();
	}

	m_Wnd.UpdateWnd();
	
} 
  
void CGame::DrawDragOrig(RECT *prc, long nIndex, void *pvCookie)
{
	if ( prc == NULL )
	{
		m_Wnd.m_SelectRect.SetEnable(FALSE);

        // draw the highlights at the focus
		m_Wnd.EraseHighlights();
        long nFocus = m_Wnd.m_pGAcc->GetFocus();
		if ( m_Wnd.m_FocusRect.Enabled() && nFocus != ZACCESS_InvalidItem)
			m_Wnd.DrawHighlights(ACCTOBOARD(nFocus));
	}
	else
	{

		//Enable the rect sprite if not yet enabled
		if ( !m_Wnd.m_SelectRect.Enabled() )
			m_Wnd.m_SelectRect.SetEnable( TRUE );

		//Draw the highlights for the point
		m_Wnd.DrawHighlights(ACCTOBOARD(nIndex), FALSE);


		//Set the rectangle and dimensions for the rectangle
		//also set the x and y
		RECT rect;
		rect.top  = prc->top  - 2; rect.bottom = prc->bottom + 2;
		rect.left = prc->left - 2; rect.right  = prc->right  + 2;


		m_Wnd.m_SelectRect.SetRECT(rect);
		m_Wnd.m_SelectRect.SetImageDimensions( prc->right - prc->left + 5, prc->bottom - prc->top + 5 );
		m_Wnd.m_SelectRect.SetXY( prc->left - 2, prc->top - 2);	
		m_Wnd.m_SelectRect.Draw();		
	}

	m_Wnd.UpdateWnd();	
}


BOOL CGame::ValidateMove(int seat,int start, int end)
{

	BOOL	bTakeback = false;

	ASSERT( seat == 0 || seat == 1 );
    
	if( (seat<0) || (seat>1) )
        return FALSE;

    int move; 
	
	//Convert to use the same indexing for both colors..
	if ( m_Opponent.m_nColor == zBoardBrown )
	{
		
		start = start < 24 ? 23 - start : start - 1;
		end   = end   < 24 ? 23 - end	: end   - 1;

		ASSERT( start >= 0 && end >= 0 );
	}
    
	//Note: Could order based on value but this is clearer

	//First case, the piece is in the middle
    if(start == 26) 
    {
        move = 24 - end;      // 26 - ( end + 2 )
    }
	else if ( end == 26 ) //takeback from the middle
	{
		bTakeback = true;
		move = 24 - start;
	}
	else if ( end == 24 ) //moving piece to the bear off zone
	{
		move = start + 1;
	}
	else if ( start == 24 ) //take back from bear off zone
	{
		bTakeback = true;
		move = end + 1;
	}
	else if ( start > end ) //take back moving in reverse
	{		
		move = start - end;
	}
    else if ( start < end )  //note I have to test the reverse case for taking back moves.
    {
		bTakeback = true;
        move = end - start;
    }
	else
	{
		//Should never ever,ever,everx100 get in here...
		ASSERT( 0 );
		return FALSE;
	}

	if ( bTakeback )
	{
	
		if ( m_OppDice1.Value == move )
		{
			EncodedUsesAdd(&m_OppDice1);
			return TRUE;
		}
		else if ( m_OppDice2.Value == move )
		{
			EncodedUsesAdd(&m_OppDice2);
			return TRUE;
		}

		//If we reach here someone must be cheating
		
	}
	else
	{

		//Check the move values against the dice values.  Make sure dice has not already been moved
		if ( DecodeUses(&m_OppDice1) && move == m_OppDice1.Value )
		{
			EncodedUsesSub(&m_OppDice1);			
			return TRUE;
		}

		if ( DecodeUses(&m_OppDice2) && move == m_OppDice2.Value )
		{
			EncodedUsesSub(&m_OppDice2);
			return TRUE;
		}

		if ( end == 24 ) //Moved to the bar with a roll that was greater then required, no other moves possible
		{
			LPDICEINFO pDiceMax = NULL;
		
			//We need the max dice value that is not already used
			if ( DecodeUses(&m_OppDice1) ) 
				pDiceMax = &m_OppDice1;

			if ( DecodeUses(&m_OppDice2) )
			{
				if ( !pDiceMax )
					pDiceMax = &m_OppDice2;
				else if ( m_OppDice2.Value > pDiceMax->Value ) 
					pDiceMax = &m_OppDice2;
			}
		
			//ASSERT( pDiceMax && move < pDiceMax->Value );
			
			if ( pDiceMax ) 
			{
				if ( move < pDiceMax->Value )
				{


					//Here we have to change the value so a takeback can be handled..
					//change the value and incode the dice using a new scheme
					//there should be no overlap between the 2 encoding schemes.. 
					//Encoding it on the client doesn't seem like a good idea...
					//but I don't see any good way around that..
					ClientNewEncode(pDiceMax, move);
					EncodedUsesSub(pDiceMax);

					return TRUE;
				}
			}

			//Reach here someone cheating
		}

		//If we reach here someone is cheating
	}

   //ASSERT(0);
    ZBGMsgCheater msg;

	msg.seat  = m_Seat;
    msg.dice1 = m_OppDice1;
    msg.dice2 = m_OppDice2;
	msg.move  = move;

	RoomSend( zBGMsgCheater, &msg, sizeof(msg) );    

	ZShellGameShell()->ZoneAlert( ErrorTextSync, NULL, NULL, TRUE, FALSE );
	//ZCRoomGameTerminated( m_TableId );

    return FALSE; //he's a bad boy

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\games\backgammon\boardrects.h ===
#ifndef __RECT_1223_H__
#define __RECT_1223_H__

#define IDR_BOARD                 0
#define IDR_PT1                   1
#define IDR_PT2                   2
#define IDR_PT3                   3
#define IDR_PT4                   4
#define IDR_PT5                   5
#define IDR_PT6                   6
#define IDR_PT7                   7
#define IDR_PT8                   8
#define IDR_PT9                   9
#define IDR_PT10                  10
#define IDR_PT11                  11
#define IDR_PT12                  12
#define IDR_PT13                  13
#define IDR_PT14                  14
#define IDR_PT15                  15
#define IDR_PT16                  16
#define IDR_PT17                  17
#define IDR_PT18                  18
#define IDR_PT19                  19
#define IDR_PT20                  20
#define IDR_PT21                  21
#define IDR_PT22                  22
#define IDR_PT23                  23
#define IDR_PT24                  24
#define IDR_PLAYER_HOME           25
#define IDR_OPPONENT_HOME         26
#define IDR_PLAYER_BAR            27
#define IDR_OPPONENT_BAR          28
#define IDR_HIT_PT1               29
#define IDR_HIT_PT2               30
#define IDR_HIT_PT3               31
#define IDR_HIT_PT4               32
#define IDR_HIT_PT5               33
#define IDR_HIT_PT6               34
#define IDR_HIT_PT7               35
#define IDR_HIT_PT8               36
#define IDR_HIT_PT9               37
#define IDR_HIT_PT10              38
#define IDR_HIT_PT11              39
#define IDR_HIT_PT12              40
#define IDR_HIT_PT13              41
#define IDR_HIT_PT14              42
#define IDR_HIT_PT15              43
#define IDR_HIT_PT16              44
#define IDR_HIT_PT17              45
#define IDR_HIT_PT18              46
#define IDR_HIT_PT19              47
#define IDR_HIT_PT20              48
#define IDR_HIT_PT21              49
#define IDR_HIT_PT22              50
#define IDR_HIT_PT23              51
#define IDR_HIT_PT24              52
#define IDR_HIT_PLAYER_HOME       53
#define IDR_HIT_OPPONENT_HOME     54
#define IDR_HIT_PLAYER_BAR        55
#define IDR_HIT_OPPONENT_BAR      56
#define IDR_BOARD_TOP             57
#define IDR_BOARD_BOTTOM          58
#define IDR_HPT_HOME              59
#define IDR_HPT1                  60
#define IDR_HPT2                  61
#define IDR_HPT3                  62
#define IDR_HPT4                  63
#define IDR_HPT5                  64
#define IDR_HPT6                  65
#define IDR_HPT7                  66
#define IDR_HPT8                  67
#define IDR_HPT9                  68
#define IDR_HPT10                 69
#define IDR_HPT11                 70
#define IDR_HPT12                 71
#define IDR_HPT13                 72
#define IDR_HPT14                 73
#define IDR_HPT15                 74
#define IDR_HPT16                 75
#define IDR_HPT17                 76
#define IDR_HPT18                 77
#define IDR_HPT19                 78
#define IDR_HPT20                 79
#define IDR_HPT21                 80
#define IDR_HPT22                 81
#define IDR_HPT23                 82
#define IDR_HPT24                 83
#define IDR_HPT_BAR               84
#define IDR_OPPONENT_HIGHLIGHT    85
#define IDR_PLAYER_HIGHLIGHT      86
#define IDR_HIGHLIGHT_FORWARD     87
#define IDR_HIGHLIGHT_BACKWARD    88
#define IDR_HIGHLIGHT_TRANS       89
#define IDR_HIGHLIGHT_PACTIVE     90
#define IDR_HIGHLIGHT_PNONACTIVE  91
#define IDR_DICE_INITAL_LEFT      92
#define IDR_DICE_INITAL_RIGHT     93
#define IDR_DICE_LEFT_ONE         94
#define IDR_DICE_LEFT_TWO         95
#define IDR_DICE_RIGHT_ONE        96
#define IDR_DICE_RIGHT_TWO        97
#define IDR_CUBE                  98
#define IDR_BROWN_BIG_DICE_0      99
#define IDR_BROWN_BIG_DICE_1      100
#define IDR_BROWN_BIG_DICE_2      101
#define IDR_BROWN_BIG_DICE_3      102
#define IDR_BROWN_BIG_DICE_4      103
#define IDR_BROWN_BIG_DICE_5      104
#define IDR_BROWN_BIG_DICE_6      105
#define IDR_BROWN_TWT_DICE_1      106
#define IDR_BROWN_TWT_DICE_2      107
#define IDR_BROWN_TWT_DICE_3      108
#define IDR_BROWN_TWT_DICE_4      109
#define IDR_BROWN_TWT_DICE_5      110
#define IDR_BROWN_TWT_DICE_6      111
#define IDR_BROWN_MED_DICE_0      112
#define IDR_BROWN_MED_DICE_1      113
#define IDR_BROWN_MED_DICE_2      114
#define IDR_BROWN_MED_DICE_3      115
#define IDR_BROWN_MED_DICE_4      116
#define IDR_BROWN_MED_DICE_5      117
#define IDR_BROWN_MED_DICE_6      118
#define IDR_BROWN_SML_DICE_0      119
#define IDR_BROWN_SML_DICE_1      120
#define IDR_BROWN_SML_DICE_2      121
#define IDR_BROWN_SML_DICE_3      122
#define IDR_BROWN_SML_DICE_4      123
#define IDR_BROWN_SML_DICE_5      124
#define IDR_BROWN_SML_DICE_6      125
#define IDR_WHITE_BIG_DICE_0      126
#define IDR_WHITE_BIG_DICE_1      127
#define IDR_WHITE_BIG_DICE_2      128
#define IDR_WHITE_BIG_DICE_3      129
#define IDR_WHITE_BIG_DICE_4      130
#define IDR_WHITE_BIG_DICE_5      131
#define IDR_WHITE_BIG_DICE_6      132
#define IDR_WHITE_TWT_DICE_1      133
#define IDR_WHITE_TWT_DICE_2      134
#define IDR_WHITE_TWT_DICE_3      135
#define IDR_WHITE_TWT_DICE_4      136
#define IDR_WHITE_TWT_DICE_5      137
#define IDR_WHITE_TWT_DICE_6      138
#define IDR_WHITE_MED_DICE_0      139
#define IDR_WHITE_MED_DICE_1      140
#define IDR_WHITE_MED_DICE_2      141
#define IDR_WHITE_MED_DICE_3      142
#define IDR_WHITE_MED_DICE_4      143
#define IDR_WHITE_MED_DICE_5      144
#define IDR_WHITE_MED_DICE_6      145
#define IDR_WHITE_SML_DICE_0      146
#define IDR_WHITE_SML_DICE_1      147
#define IDR_WHITE_SML_DICE_2      148
#define IDR_WHITE_SML_DICE_3      149
#define IDR_WHITE_SML_DICE_4      150
#define IDR_WHITE_SML_DICE_5      151
#define IDR_WHITE_SML_DICE_6      152
#define IDR_CUBE_0                153
#define IDR_CUBE_1                154
#define IDR_CUBE_2                155
#define IDR_CUBE_3                156
#define IDR_CUBE_4                157
#define IDR_CUBE_5                158
#define IDR_BUTTON_0              159
#define IDR_BUTTON_1              160
#define IDR_BUTTON_2              161
#define IDR_BUTTON_3              162
#define IDR_BUTTON_4              163
#define IDR_ROLLBUTTON_0          164
#define IDR_ROLLBUTTON_1          165
#define IDR_ROLLBUTTON_2          166
#define IDR_ROLLBUTTON_3          167
#define IDR_PIP_SPRITE            168
#define IDR_SCORE_SPRITE          169
#define IDR_KIBITZER_OPPONENT     170
#define IDR_KIBITZER_PLAYER       171
#define IDR_KIBITZER_ACTIVE       172
#define IDR_KIBITZER_OFF          173
#define IDR_NOTATION_LOW          174
#define IDR_NOTATION_HIGH         175
#define IDR_NOTATION_BROWN        176
#define IDR_NOTATION_WHITE        177
#define IDR_NOTATION_TOP_HIGH     178
#define IDR_NOTATION_TOP_LOW      179
#define IDR_NOTATION_TOP_LABEL    180
#define IDR_NOTATION_BOT_HIGH     181
#define IDR_NOTATION_BOT_LOW      182
#define IDR_NOTATION_BOT_LABEL    183

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\games\backgammon\moves.cpp ===
#include "game.h"
#include "moves.h"

inline int Max( int a, int b )
{
	return ( a > b ) ? a : b;
}

///////////////////////////////////////////////////////////////////////////////
// Local prototypes
///////////////////////////////////////////////////////////////////////////////

int MaxUsableDiceOrderDependant( BoardState* state, int val0, int val1 );
int MaxUsableDice( BoardState* state, int val, int cnt );
int MaxUsableDiceFromPoint( BoardState* state, int pt, int val, int cnt );
BOOL CalcValidMovesForPoint( BoardState* state, int pt, int ndice, int* dice, int *idice );


///////////////////////////////////////////////////////////////////////////////
// CBoard to Board State conversion
///////////////////////////////////////////////////////////////////////////////

int PointIdxToBoardStateIdx( int PlayerIdx )
{
	if ((PlayerIdx == bgBoardOpponentHome) || (PlayerIdx == bgBoardOpponentBar))
		return -1;
	else if (PlayerIdx == bgBoardPlayerHome)
		PlayerIdx = 0;
	else if (PlayerIdx == bgBoardPlayerBar)
		PlayerIdx = 25;
	else
		PlayerIdx++;
	return PlayerIdx;
}


int BoardStateIdxToPointIdx( int BoardIdx )
{
	if ( BoardIdx == 0 )
		BoardIdx = bgBoardPlayerHome;
	else if (BoardIdx == 25)
		BoardIdx = bgBoardPlayerBar;
	else
		BoardIdx--;
	return BoardIdx;
}


void InitTurnState( CGame* pGame, BoardState* state )
{
	int d0, d1;
	int pt, i;

	// points
	for ( i = 0; i < 26; i++ )
	{
		state->points[i].color = zBoardNeutral;
		state->points[i].pieces = 0;
	}
	for ( i = 0; i < 30; i++ )
	{
		pt = pGame->GetPointIdx( pGame->m_SharedState.Get( bgPieces, i ) );
		pt = PointIdxToBoardStateIdx( pt );
		if ( pt < 0 )
			continue;
		state->points[pt].pieces++;
		if ( i < 15 )
			state->points[pt].color = zBoardWhite;
		else
			state->points[pt].color = zBoardBrown;
	}

	// valid moves
	for ( i = 0; i < 26; i++ )
		state->valid[i].nmoves = 0;

	// dice
	pGame->GetDice( pGame->m_Player.m_Seat, &d0, &d1 );
	if ( d0 == d1 )
	{
		state->doubles = TRUE;
		for ( i = 0; i < 4; i++ )
		{
			state->dice[i].val = d0;
			state->dice[i].used = FALSE;
		}
	}
	else
	{
		state->doubles = FALSE;
		state->dice[0].val = d0;
		state->dice[0].used = FALSE;
		state->dice[1].val = d1;
		state->dice[1].used = FALSE;
		state->dice[2].val = 0;
		state->dice[2].used = TRUE;
		state->dice[3].val = 0;
		state->dice[3].used = TRUE;
	}

	// color
	state->color = pGame->m_Player.GetColor();

	// moves
	state->moves.nmoves = 0;
}


///////////////////////////////////////////////////////////////////////////////
// Move list implementation
///////////////////////////////////////////////////////////////////////////////

void MoveList::Add( int iFrom, int iTo, int iTakeback, BOOL bBar, int* iDice, int nDice )
{
	Move* m;
	
	ASSERT( nmoves < (sizeof(moves) / sizeof(Move)) );
	m = &moves[nmoves++];
	m->from = iFrom;
	m->to = (iTo < zMoveHome) ? zMoveHome : iTo;
	m->takeback = iTakeback;
	m->bar = bBar;
	m->ndice = nDice;
	for ( int i = 0; i < nDice; i++ )
		m->diceIdx[i] = iDice[i];
}

void MoveList::Del( int idx )
{
	if ( (idx < 0) || (idx >= nmoves) )
	{
		ASSERT( FALSE );
		return;
	}
	nmoves--;
	for ( int i = idx; i < nmoves; i++ )
		CopyMemory( &moves[i], &moves[i+1], sizeof(Move) );
}


///////////////////////////////////////////////////////////////////////////////
// Move validation
///////////////////////////////////////////////////////////////////////////////

BOOL IsLegalMove( BoardState* state, int iFrom, int iTo )
{
	Point* from;
	Point* to;
	int i, start;

	// Parameter paranoia
	if ( (!state) || (iFrom <= zMoveHome) || (iFrom > zMoveBar) || (iTo >= zMoveBar) )
		return FALSE;

	// Does 'from' point have the right color and number of pieces?
	from = &state->points[iFrom];
	if ( (from->color != state->color) || (from->pieces <= 0) )
		return FALSE;
	
	// Pieces on the bar?  Have to move them first.
	if ( (state->points[zMoveBar].pieces > 0) && (iFrom != zMoveBar) )
		return FALSE;

	// Bearing off?
	if ( iTo <= zMoveHome )
	{
		// Not an exact roll off the board, adjust home area to check for
		// pieces above the one being removed.
		start = ( iTo < zMoveHome ) ? (iFrom + 1) : 7;

		// Can't remove piece if there are pieces not in the home area?
		for ( i = start; i <= zMoveBar; i++ )
		{
			if ( (state->points[i].color == state->color) && (state->points[i].pieces > 0) )
				return FALSE;
		}
		
		// Looks like it's ok to bear off the piece
		return TRUE;
	}

	// Open point?
	to = &state->points[iTo];
	if ( (to->pieces > 1) && (to->color != from->color) )
		return FALSE;

	// Passed all the simple stuff
	return TRUE;
}


void DoMoveLite( BoardState* state, int iFrom, int iTo, BOOL* bBar )
{
	Point* from;
	Point* to;

	// Parameter paranoia
	if ( (!state) || (iFrom < zMoveHome) || (iFrom > zMoveBar) || (iTo > zMoveBar) || (iFrom == iTo) )
	{
		ASSERT( FALSE );
		return;
	}

	// Remove piece from 'from' point
	from = &state->points[iFrom];
	ASSERT( from->pieces > 0 );
	from->pieces--;
	
	// Add piece to 'to' point
	if ( iTo <= zMoveHome )
		to = &state->points[zMoveHome];
	else
		to = &state->points[iTo];
	if ( to->color != from->color )
	{
		ASSERT( to->pieces <= 1 );
		if ( bBar )
		{
			if (to->pieces == 1)
				*bBar = TRUE;
			else
				*bBar = FALSE;
		}
		to->pieces = 1;
	}
	else
	{
		if (bBar)
			*bBar = FALSE;
		to->pieces++;
	}

	// Adjust point colors
	to->color = from->color;
	if ( from->pieces <= 0 )
		from->color = zBoardNeutral;
}


void DoMove( BoardState* state, int iFrom, int* iDice, int nDice )
{
	BOOL bBar;
	int i, iTo, die;

	// Parameter paranoia
	if ( (!state) || (!iDice) || (iFrom <= zMoveHome) || (iFrom > zMoveBar) || (nDice <= 0) || (nDice > 4) )
	{
		ASSERT( FALSE );
		return;
	}

	// Get dice values
	for( die = 0, i = 0; i < nDice; i++ )
	{
		die += state->dice[iDice[i]].val;
		state->dice[iDice[i]].used = TRUE;
	}

	// Get destination point
	iTo = iFrom - die;
	if ( (iTo >= zMoveBar) || (iTo == iFrom) )
	{
		ASSERT( FALSE );
		return;
	}

	// Move pieces
	DoMoveLite( state, iFrom, iTo, &bBar );

	// Record the move
	state->moves.Add( iFrom, iTo, -1, bBar, iDice, nDice );
}


void TakeBackMove( BoardState* state, Move* move )
{
	// Parameter paranoia
	if ( (!state) || (!move) )
	{
		ASSERT( FALSE );
		return;
	}

	// Restore dice state
	for ( int i = 0; i < move->ndice; i++ )
		state->dice[move->diceIdx[i]].used = FALSE;

	// Restore points
	DoMoveLite( state, move->from, move->to, NULL );
	if ( move->bar )
	{
		ASSERT( state->points[move->from].pieces == 0 );
		state->points[move->from].pieces = 1;
		if ( state->points[move->to].color == zBoardWhite )
			state->points[move->from].color = zBoardBrown;
		else
			state->points[move->from].color = zBoardWhite;
	}

	// Delete the move
	state->moves.Del( move->takeback );
}


static int MaxUsableDiceOrderDependant( BoardState* state, int val0, int val1 )
{
	BoardState cpy;
	int moves;

	moves = 0;
	for ( int i = 1; i <= zMoveBar; i++ )
	{
		if ( IsLegalMove( state, i, i - val0 ) )
		{
			CopyMemory( &cpy, state, sizeof(BoardState) );
			DoMoveLite( &cpy, i, i - val0, NULL );
			if ( MaxUsableDice( &cpy, val1, 1 ) == 1 )
				return 2;
			else
				moves = Max( moves, 1 );
		}

		if ( IsLegalMove( state, i, i - val1 ) )
		{
			CopyMemory( &cpy, state, sizeof(BoardState) );
			DoMoveLite( &cpy, i, i - val1, NULL );
			if ( MaxUsableDice( &cpy, val0, 1 ) == 1 )
				return 2;
			else
				moves = Max( moves, 1 );
		}
	}

	return moves;
}


static int MaxUsableDice( BoardState* state, int val, int cnt )
{
	BoardState cpy;
	int i, total;

	for( total = 0, i = 1; (i <= zMoveBar) && (total < cnt); i++ )
	{
		if ( !IsLegalMove( state, i, i - val ) )
			continue;
		if ( cnt <= 1 )
			return 1;
		CopyMemory( &cpy, state, sizeof(BoardState) );
		DoMoveLite( &cpy, i, i - val, NULL );
		total = Max( total, 1 + MaxUsableDice( &cpy, val, cnt - 1 ) );
	}
	return total;
}


static int MaxUsableDiceFromPoint( BoardState* state, int pt, int val, int cnt )
{
	BoardState cpy;

	if ( !IsLegalMove( state, pt, pt - val ) )
		return 0;
	if ( cnt <= 1 )
		return 1;
	CopyMemory( &cpy, state, sizeof(BoardState) );
	DoMoveLite( &cpy, pt, pt - val, NULL );
	return 1 + MaxUsableDice( &cpy, val, cnt - 1 );
}


static BOOL CalcValidMovesForPoint( BoardState* state, int pt, int ndice, int* dice, int *idice )
{
	BoardState cpy;
	BOOL bMove;
	int dieOne;
	int dieTwo;
	int i;
	
	// Parameter paranoia
	if ( (!state) || (!dice) || (!idice) || (pt <= zMoveHome) || (pt > zMoveBar) || (ndice <= 1) || (ndice > 4) )
	{
		ASSERT( FALSE );
		return FALSE;
	}
	
	// Handle doubles
	if ( state->doubles )
	{
		if ( MaxUsableDiceFromPoint( state, pt, dice[0], ndice ) < state->usableDice )
			return FALSE;
		state->valid[pt].Add( pt, pt - dice[0], -1, FALSE, &idice[0], 1 );
		return TRUE;
	}

	// We should be dealing with 2 dice with different values
	ASSERT( ndice == 2);
	ASSERT( dice[0] != dice[1] );
	
	// How many moves can we make starting with die0
	bMove = FALSE;
	if ( IsLegalMove( state, pt, pt - dice[0] ) )
	{
		CopyMemory( &cpy, state, sizeof(BoardState) );
		DoMoveLite( &cpy, pt, pt - dice[0], NULL );
		if ( MaxUsableDice( &cpy, dice[1], 1 ) == 1 )
			dieOne = 2;
		else
		{
			if ( state->usableDice == 1 )
				dieOne = 1;
			else
				dieOne = 0;
		}
	}
	else
		dieOne = 0;

	// How many moves can we make starting with die1
	if ( IsLegalMove( state, pt, pt - dice[1] ) )
	{
		CopyMemory( &cpy, state, sizeof(BoardState) );
		DoMoveLite( &cpy, pt, pt - dice[1], NULL );
		if ( MaxUsableDice( &cpy, dice[0], 1 ) == 1 )
			dieTwo = 2;
		else
		{
			if ( state->usableDice == 1 )
				dieTwo = 1;
			else
				dieTwo = 0;
		}
	}
	else
		dieTwo = 0;

	// evaluate results 
	if ( (dieOne == 0) && (dieTwo == 0) )
	{
		return FALSE;
	}
	else if ( dieOne == 2 )
	{
		state->valid[pt].Add( pt, pt - dice[0], -1, FALSE, &idice[0], 1 );
		if ( dieTwo == 2 )
			state->valid[pt].Add( pt, pt - dice[1], -1, FALSE, &idice[1], 1 );
	}
	else if ( dieTwo == 2 )
	{
		state->valid[pt].Add( pt, pt - dice[1], -1, FALSE, &idice[1], 1 );
	}
	else if ( (dieOne == 1) && (dieTwo == 1) )
	{
		if ( dice[0] >= dice[1] )
			state->valid[pt].Add( pt, pt - dice[0], -1, FALSE, &idice[0], 1 );
		else
			state->valid[pt].Add( pt, pt - dice[1], -1, FALSE, &idice[1], 1 );
	}
	else if ( dieOne == 1 )
	{
		state->valid[pt].Add( pt, pt - dice[0], -1, FALSE, &idice[0], 1 );
	}
	else if ( dieTwo == 1 )
	{
		state->valid[pt].Add( pt, pt - dice[1], -1, FALSE, &idice[1], 1 );
	}
	else
	{
		ASSERT( FALSE );
	}

	// we're done
	return TRUE;
}



BOOL CalcValidMoves( BoardState* state )
{
	BOOL move = FALSE;
	BOOL skip;
	int idice[4];
	int dice[4];
	int ndice;
	int i, j;

	// Clear valid move array
	for ( i = zMoveHome; i <= zMoveBar; i++ )
		state->valid[i].nmoves = 0;
	
	// Create algorithm friendly dice array
	for ( ndice = 0, i = 0; i < 4; i++ )
	{
		if ( state->dice[i].used )
			continue;
		ASSERT( state->dice[i].val > 0 );
		dice[ndice] = state->dice[i].val;
		idice[ndice++] = i;
	}
	if ( ndice == 0 )
	{
		return FALSE;
	}
	else if ( ndice == 1 )
	{
		for ( i = 1; i <= zMoveBar; i++ )
		{
			if ( !IsLegalMove( state, i, i - dice[0] ) )
				continue;
			state->valid[i].Add( i, i - dice[0], -1, FALSE, &idice[0], 1 );
			move = TRUE;
		}
		if ( !move )
			return FALSE;
		goto TakeBacks;
	}
	
	// Store number of usable dice to speed valid move calculcations
	if ( state->doubles )
		state->usableDice = MaxUsableDice( state, dice[0], ndice );
	else
		state->usableDice = MaxUsableDiceOrderDependant( state, dice[0], dice[1] );
	if ( state->usableDice == 0 )
		return FALSE;

	// Find valid moves for each point
	for ( move = FALSE, i = 1; i <= zMoveBar; i++ )
		move |= CalcValidMovesForPoint( state, i, ndice, &dice[0], &idice[0] );

TakeBacks:

	// Add takebacks to list of moves
	for ( i = 0; i < state->moves.nmoves; i++ )
	{
		
		Move* m = &state->moves.moves[i];
		skip = FALSE;
		if ( m->from == zMoveBar )
		{
			// Can only take back moves starting from the bar if there aren't
			// any other type of moves in the list.
			for ( j = 0; j < state->moves.nmoves; j++ )
			{
				if ( j == i )
					continue;
				if ( state->moves.moves[j].from != zMoveBar )
				{
					skip = TRUE;
					break;
				}
			}
		}
		if ( !skip && m->bar )
		{
			// Can only take back a move that barred an opponent's piece if
			// their hasn't been another move to that point
			for( j = 0; j < state->moves.nmoves; j++ )
			{
				if ( j == i )
					continue;
				if ( state->moves.moves[j].to == m->to )
				{
					skip = TRUE;
					break;
				}
			}
		}
		if ( skip )
			continue;
		state->valid[m->to].Add( m->to, m->from, i, m->bar, m->diceIdx, m->ndice );
	}
	if ( i > 0 )
		move = TRUE;
	return move;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\games\backgammon\init.cpp ===
/*******************************************************************************

	init.cpp
	
		Zone(tm) game main file.
	
	Copyright (c) Microsoft Corp. 1996. All rights reserved.
	Written by Hoon Im
	Created on December 11, 1996.
	
	Change History (most recent first):
	----------------------------------------------------------------------------
	Rev	 |	Date	 |	Who	 |	What
	----------------------------------------------------------------------------
	0		12/11/96	HI		Created.
	 
*******************************************************************************/
#include "BasicATL.h"

#include <ZoneShell.h>

CZoneComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
END_OBJECT_MAP()


/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE
/////////////////////////////////////////////////////////////////////////////

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type
/////////////////////////////////////////////////////////////////////////////

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/****************************************************************************
   FUNCTION: DllMain(HANDLE, DWORD, LPVOID)

   PURPOSE:  DllMain is called by Windows when
             the DLL is initialized, Thread Attached, and other times.
             Refer to SDK documentation, as to the different ways this
             may be called.


*******************************************************************************/
extern "C"
BOOL APIENTRY DllMain( HMODULE hMod, DWORD dwReason, LPVOID lpReserved )
{
    BOOL bRet = TRUE;

    switch( dwReason )
    {
        case DLL_PROCESS_ATTACH:
		    _Module.Init(ObjectMap, hMod);
		    //DisableThreadLibraryCalls(hInstance);
            // fall thru, b/c this is the first thread attach as well
        case DLL_THREAD_ATTACH:
            // allocate memory and use TlsSetValue
            break;

        case DLL_THREAD_DETACH:
            // free memory retrieved by TlsGetValue
            break;

        case DLL_PROCESS_DETACH:
        	_Module.Term();
            break;
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\games\backgammon\player.h ===
#ifndef __PLAYER_H__
#define __PLAYER_H__

struct CUser
{
	CUser();

	ZUserID	m_Id;
	int		m_Seat;
	int		m_NameLen;
	BOOL	m_bKibitzer;
	TCHAR	m_Name[zUserNameLen + 1];
	TCHAR	m_Host[zHostNameLen + 1];
};


struct CPlayer : CUser
{
	CPlayer();

	int GetColor() { return m_nColor; }

	int m_nColor;
	int	m_iHome;
	int m_iBar;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\games\backgammon\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by backgammon.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     101
#define _APS_NEXT_RESOURCE_VALUE        14243
#define _APS_NEXT_COMMAND_VALUE         40013
#define _APS_NEXT_CONTROL_VALUE         1005
#define _APS_NEXT_SYMED_VALUE           107
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\games\backgammon\game.h ===
#ifndef __BG_GAME_H__
#define __BG_GAME_H__

#include "zone.h"
#include "zroom.h"
#include "zui.h"
#include "queue.h"
#include "frx.h"

#include "zoneresource.h"
#include "backgammonres.h"
#include "resource.h"
#include "backgammon.h"
#include "shared.h"
#include "player.h"
#include "moves.h"
#include "bgwnd.h"
#include "bgdlgs.h"
#include "settings.h"


#define MATCH_POINTS 3

#include "zonecli.h"

extern const TCHAR*	gGameRegName;			// registry name
extern const int	gExitSaveStates[];		// states that should get EXIT_SAVE dialog
extern const int	gNoAbandonStates[];		// states that don't get counted as abandons


extern BOOL ISRTL();

enum BackgammonSounds
{
	bgSoundNone = -1,
	bgSoundAlert,
	bgSoundPlacePiece, 
	bgSoundGameWin,
	bgSoundGameLose,
	bgSoundMatchWin,
	bgSoundMatchLose,
	bgSoundHit,
	bgSoundMiss,
	bgSoundBear,
	bgSoundButtonHighlight,
	bgSoundButtonDown,
	bgSoundRoll
};

enum BackgammonBoard
{	
	// colors
	zBoardNeutral = 0,
	zBoardWhite,
	zBoardBrown,

	// locations
	bgBoardPlayerHome = 24,
	bgBoardOpponentHome,
	bgBoardPlayerBar,
	bgBoardOpponentBar
};


enum BackgammonStates
{
	bgStateUnknown = -1,
	bgStateNotInit,
	bgStateWaitingForGameState,
	bgStateCheckSavedGame,
	bgStateRestoreSavedGame,
	bgStateGameSettings,
	bgStateInitialRoll,
	bgStateDouble,
	bgStateRoll,
	bgStateRollPostDouble,
	bgStateRollPostResign,
	bgStateMove,
	bgStateEndTurn,
	bgStateGameOver,
	bgStateMatchOver,
	bgStateNewMatch,
	bgStateDelete,
	bgStateResignOffer,
	bgStateResignAccept,
	bgStateResignRefused,
	bgStateLastEntry
};


enum GameOverReasons
{
	bgGameOverNormal = 0,
	bgGameOverDoubleRefused,
	bgGameOverResign
};


enum SharedStates
{
	bgState = 0,
	bgCrawford,
	bgTimestampHi,
	bgTimestampLo,
	bgTimestampSet,
	bgSettingsReady,
	bgGameOverReason,
	bgUserIds,
	bgActiveSeat,
	bgAutoDouble,
	bgHostBrown,
	bgTargetScore,
	bgSettingsDone,
	bgCubeValue,
	bgCubeOwner,
	bgResignPoints,
	bgScore,
	bgAllowWatching,
	bgSilenceKibitzers,
	bgDice,
	bgDiceSize,
	bgReady ,
	bgPieces,
};


enum SharedStateTransactions
{
	bgTransStateChange = 0,
	bgTransInitSettings,
	bgTransDice,
	bgTransDoublingCube,
	bgTransBoard,
	bgTransAcceptDouble,
	bgTransAllowWatchers,
	bgTransSilenceKibitzers,
	bgTransSettingsDlgReady,
	bgTransTimestamp,
	bgTransRestoreGame,
	bgTransMiss,
	bgTransReady,
	bgTransNone
};


struct CMessage
{
	CMessage( int type, BYTE* msg, int len );
	~CMessage();

	int		m_Type;
	int		m_Len;
	BYTE*	m_Msg;
};



class CGame : public IGameGame,
			  public IGraphicallyAccControl,
			  public CComObjectRootEx<CComSingleThreadModel>
{
public:
	
	//IGameGame
    STDMETHOD(SendChat)(TCHAR *szText, DWORD cchChars);
	STDMETHOD(GameOverReady)();

	STDMETHOD_(ZCGame, GetGame)() { return this; }
    STDMETHOD(GamePromptResult)(DWORD nButton, DWORD dwCookie){ ASSERT(!"NYI"); return E_FAIL;};
    STDMETHOD_(HWND, GetWindowHandle)() { return  m_Wnd.GetHWND(); }
    STDMETHOD(ShowScore)() { return S_OK; }

public:
	
	//IGraphicallyAccControl	
    STDMETHOD_(DWORD, Focus)(long nIndex, long nIndexPrev, DWORD rgfContext, void *pvCookie);
    STDMETHOD_(DWORD, Select)(long nIndex, DWORD rgfContext, void *pvCookie);
    STDMETHOD_(DWORD, Activate)(long nIndex, DWORD rgfContext, void *pvCookie);
    STDMETHOD_(DWORD, Drag)(long nIndex, long nIndexOrig, DWORD rgfContext, void *pvCookie);
	
	STDMETHOD_(void, DrawFocus)(RECT *prc, long nIndex, void *pvCookie);
    STDMETHOD_(void, DrawDragOrig)(RECT *prc, long nIndex, void *pvCookie);
	
public:


BEGIN_COM_MAP(CGame)
	COM_INTERFACE_ENTRY(IGameGame)
	COM_INTERFACE_ENTRY(IGraphicallyAccControl)
END_COM_MAP()

DECLARE_NO_REGISTRY()
DECLARE_PROTECT_FINAL_CONSTRUCT()


public:
	CGame( );
	~CGame();
	
	/*
	ULONG AddRef();
	ULONG Release();
	*/
	
	// Close windows
	void Shutdown();
	BOOL RoomShutdown();

	// Exported zone functions
	HRESULT Init(HINSTANCE hInstance, ZUserID userID, int16 tableID, int16 seat, int16 playerType, ZRoomKibitzers* kibitzers);
	void AddKibitzer( int16 seat, ZUserID userID, BOOL fRepaint );
	void RemoveKibitzer( int16 seat, ZUserID userID );

	// Message queue
	void QueueMessage( int type, BYTE* msg, int len );
	void ProcessMessage( int type, BYTE* msg, int len );
	void SetQueueMessages( BOOL bQueueMessages );

	// Message senders
	HRESULT SendCheckIn();
	HRESULT SendNotationString( int type, TCHAR* string );
	//Server side roll data
	HRESULT SendRollRequest(void);

	// SendTalk is different since it is CChatWnd's callback
	static HRESULT SendTalk( TCHAR* str, int len, DWORD cookie );

	
	// Message handlers
	void RoomSend( uint32 messageType, void* message, int32 messageLen);
	HRESULT HandleCheckIn( void* msg, int32 msgLen );
	HRESULT HandleTalk( void* msg, int32 msgLen );
	HRESULT HandleGameStateResponse( void* message, int32 messageLen );
	HRESULT HandleGameStateRequest( void* msg, int32 len );
	HRESULT HandleNotationString( void* msg, int32 msgLen );
	HRESULT HandleSavedGameState( void* msg, int32 msgLen );
	HRESULT HandleDiceRoll( void* msg, int32 msgLen );
	HRESULT HandleMoveTimeout( void* msg, int32 msgLen );
	HRESULT HandleEndTurn( void* msg, int32 msgLen );
	HRESULT	HandleEndLog( void* msg, int32 msgLen );

	// Transaction handlers
	static void SettingsTransaction( int tag, int seat, DWORD cookie );
	static void DoublingCubeTransaction( int tag, int seat, DWORD cookie );
	static void DiceTransaction( int tag, int seat, DWORD cookie );
	static void StateChangeTransaction( int tag, int seat, DWORD cookie );
	static void BoardTransaction( int tag, int seat, DWORD cookie );
	static void AcceptDoubleTransaction( int tag, int seat, DWORD cookie );
	static void AllowWatchersTransaction( int tag, int seat, DWORD cookie );
	static void SilenceKibitzersTransaction( int tag, int seat, DWORD cookie );
	static void SettingsReadyTransaction( int tag, int seat, DWORD cookie );
	static void TimestampTransaction( int tag, int seat, DWORD cookie );
	static void RestoreGameTransaction( int tag, int seat, DWORD cookie );
	static void MissTransaction( int tag, int seat, DWORD cookie );
	static void ReadyTransaction( int tag, int seat, DWORD cookie );

	// Game state functions
	void ResetDice( int val );
	void SetDice( int seat, int v0, int v1 );
	void GetDice( int seat, int* v0, int* v1 );
	void SetDiceSize( int seat, int s0, int s1 );
	void GetDiceSize( int seat, int* s0, int* s1 );

	// Game functions
	void NewMatch();
	void NewGame();
	void Double();
	void Resign();
	void Forfeit();
	void EnableDoubleButton( BOOL fEnable );
	void EnableResignButton( BOOL fEnable );
	void EnableRollButton(BOOL fEnable, BOOL fOff = FALSE );
	BOOL StartPlayersTurn();
	BOOL IsValidDestPoint( int fromPoint, int toPoint, Move** move );
	BOOL IsValidStartPoint( int fromPoint );
	BOOL IsTurnOver();
	BOOL MovePiece( int piece, int toPoint );
	void MakeMove( int pieceIdx, int fromPoint, int toPoint, Move* move );
	int CalcPipsForColor( int color );
	int CalcBonusForSeat( int seat );

	// game utility functions
	int  GetPointIdxForColor( int color, int WhiteIdx );
	int  GetPointIdx( int WhiteIdx );
	int  GetActiveSeatColor();
	void GetTxtForPointIdx( int PlayerIdx, TCHAR* txt );
	void UpdateNotationPane( int nGameOver = 0 );
	void SaveGame();
//	void DeleteGame();
	void LoadGame( BYTE** ppData, DWORD* pSize );
	void LoadGameTimestamp();
	void CloseAllDialogs( BOOL fExit );

	void OnResignStart();
	void OnResignEnd();
	void OnResignAcceptStart();
	void OnResignAcceptEnd();

	//Used to validate the opponents move to make sure there not cheating.
	BOOL ValidateMove(int seat,int start, int end);

	
	// Accessors
	BOOL IsHost();
	BOOL IsKibitzer();
	BOOL HasKibitzers( int seat );
	BOOL IsMyTurn();
	BOOL IsMyMove();
	BOOL NeedToRollDice();
	
	// Game functions
	void WhoGoesFirst();

	// Sounds
	void PlaySound( BackgammonSounds sound, BOOL fSync = FALSE );

	// state table functions
	int GetState();
	BOOL IsStateInList( const int* states );
	void SetState( int state, BOOL bCalledFromHandler = FALSE, BOOL bCalledFromRestoreGame = FALSE );

	typedef void (CGame::*pfnstate)( BOOL, BOOL );	
	void StateNotInitialized( BOOL bCalledFromHanlder, BOOL bCalledFromRestoreGame );
	void StateWaitingForGameState( BOOL bCalledFromHanlder, BOOL bCalledFromRestoreGame );
	void StateMatchSettings( BOOL bCalledFromHandler, BOOL bCalledFromRestoreGame );
	void StateInitialRoll( BOOL bCalledFromHandler, BOOL bCalledFromRestoreGame );
	void StateRoll( BOOL bCalledFromHandler, BOOL bCalledFromRestoreGame );
	void StateMove( BOOL bCalledFromHandler, BOOL bCalledFromRestoreGame );
	void StateRollPostDouble( BOOL bCalledFromHandler, BOOL bCalledFromRestoreGame );
	void StateRollPostResign( BOOL bCalledFromHandler, BOOL bCalledFromRestoreGame );
	void StateEndTurn( BOOL bCalledFromHandler, BOOL bCalledFromRestoreGame );
	void StateGameOver( BOOL bCalledFromHandler, BOOL bCalledFromRestoreGame );
	void StateMatchOver( BOOL bCalledFromHandler, BOOL bCalledFromRestoreGame );
	void StateDelete( BOOL bCalledFromHandler, BOOL bCalledFromRestoreGame );
	void StateCheckSavedGame( BOOL bCalledFromHandler, BOOL bCalledFromRestoreGame );
	void StateRestoreSavedGame( BOOL bCalledFromHandler, BOOL bCalledFromRestoreGame );
	void StateDouble( BOOL bCalledFromHandler, BOOL bCalledFromRestoreGame );
	void StateNewMatch( BOOL bCalledFromHandler, BOOL bCalledFromRestoreGame );
	void StateResignOffer( BOOL bCalledFromHandler, BOOL bCalledFromRestoreGame );
	void StateResignAccept( BOOL bCalledFromHandler, BOOL bCalledFromRestoreGame );
	void StateResignRefused( BOOL bCalledFromHandler, BOOL bCalledFromRestoreGame );

public:



	// Reference count
	ULONG				m_RefCnt;

	// Instance settings
	int					m_TableId;
	int					m_Seat;
		
	HINSTANCE			m_hInstance;

	BOOL				m_CheckIn[ zNumPlayersPerTable ];
	BOOL				m_Ready  [ zNumPlayersPerTable ];
	CPlayer				m_Player;
	CPlayer				m_Opponent;
	CUser*				m_pMe;
	CList<CUser>		m_Kibitzers;

	// Message queue
	CList<CMessage>		m_MsgQueue;
	BOOL				m_bQueueMessages;
	
	// Visuals
	CBGWnd				m_Wnd;

	CAcceptDoubleDlg	m_AcceptDoubleDlg;
	CResignDlg			m_ResignDlg;
	CResignAcceptDlg	m_ResignAcceptDlg;

	// state table
	pfnstate m_StateFunctions[ bgStateLastEntry ];

	// Game state
	CSharedState		m_SharedState;

	// Turn state
	BoardState			m_TurnState;
	int					m_GameScore;
	BOOL				m_EndLogReceived;
	BOOL				m_GameStarted;

	// Game settings
	GameSettings		m_Settings;

	// Server timestamp
	FILETIME			m_Timestamp;

	// flags
	BOOL				m_SilenceMsg;			// kibitzers silenced flag
	BOOL				m_AllowMsg;				// kibitzers locked out flag
	BOOL				m_bDeleteGame;			// prevents state changes once inside bgStateDelete
	BOOL				m_bShutdown;			// start shutdown has already been called (prevents double deletes from room)
	BOOL				m_bSaveGame;
	BOOL				m_bSentMatchResults;	// send server match results, prevent duplicate sends;
	BOOL				m_bOpponentTimeout;		//keep track of other user timing out
	DWORD				m_ExitId;				//keep track of expected exit state

	// Turn rollback for saved game
	BYTE*				m_TurnStartState;

	//Used to keep track of what Item list is on the Accessiblity stack

	DICEINFO			m_OppDice1;
	DICEINFO			m_OppDice2;
};



///////////////////////////////////////////////////////////////////////////////
// Inlines
///////////////////////////////////////////////////////////////////////////////

inline CMessage::CMessage( int type, BYTE* msg, int len )
{
	m_Type = type;
	m_Len = len;
	m_Msg = new BYTE[ len ];
	CopyMemory( m_Msg, msg, len );
}


inline CMessage::~CMessage()
{
	if ( m_Msg )
		delete [] m_Msg;
}


inline int CGame::GetPointIdx( int WhiteIdx )
{
	return GetPointIdxForColor( m_Player.GetColor(), WhiteIdx );
}


inline BOOL CGame::IsHost()
{
	return ((m_Seat == 0) && (!m_pMe->m_bKibitzer));
}


inline BOOL CGame::IsKibitzer()
{
	return ( m_pMe->m_bKibitzer );
}


inline BOOL CGame::IsMyMove()
{
	return (	(m_SharedState.Get( bgActiveSeat ) == m_Player.m_Seat)
			&&	(m_SharedState.Get( bgState ) == bgStateMove )
			&&	(!IsKibitzer()) );
}


inline BOOL CGame::IsMyTurn()
{
	return (	(m_SharedState.Get( bgActiveSeat ) == m_Player.m_Seat)
			&&	(!IsKibitzer()) );
}


inline BOOL CGame::NeedToRollDice()
{
	int v0, v1;
	int state = m_SharedState.Get( bgState );

	if ( IsKibitzer() )
		return FALSE;
	if (	(state != bgStateInitialRoll)
		&&	(state != bgStateRoll)
		&&  (state != bgStateRollPostDouble)
		&&	(state != bgStateRollPostResign) )
		return FALSE;
	GetDice( m_Player.m_Seat, &v0, &v1 );
	if ( v0 == 0 || v1 == 0 )
		return TRUE;
	return FALSE;
}


inline void CGame::SetState( int state, BOOL bCalledFromHandler, BOOL bCalledFromRestoreGame )
{
	ASSERT( m_StateFunctions[ state ] != NULL );
	if ( m_bDeleteGame )
		return;
	//Server side change insure the initial dice roll is not affected.
	if(state == bgStateInitialRoll)
		m_Wnd.m_fDiceRollReceived = FALSE;
		
	(this->*m_StateFunctions[ state ])( bCalledFromHandler, bCalledFromRestoreGame );
}


inline int CGame::GetState()
{
	return m_SharedState.Get( bgState );
}


inline BOOL CGame::IsStateInList( const int* states )
{
	for ( int s = m_SharedState.Get( bgState ); *states < bgStateLastEntry; states++ )
	{
		if ( *states == s )
			return TRUE;
	}
	return FALSE;
}


inline void CGame::ResetDice( int val )
{
	for ( int i = 0; i < 4; i++ )
	{
		m_SharedState.Set( bgDice, i, val );
		m_SharedState.Set( bgDiceSize, i, 0 );
	}
}

inline void CGame::SetDice( int seat, int v0, int v1 )
{
	m_SharedState.Set( bgDice, seat * 2, v0			 );
	m_SharedState.Set( bgDice, (seat * 2) + 1, v1	 );
	m_SharedState.Set( bgDiceSize, seat * 2, 0		 );
	m_SharedState.Set( bgDiceSize, (seat * 2) + 1, 0 );

	m_Wnd.DrawDice(TRUE);
}

inline void CGame::GetDice( int seat, int* v0, int* v1 )
{
	*v0 = m_SharedState.Get( bgDice, seat * 2 );
	*v1 = m_SharedState.Get( bgDice, (seat * 2) + 1 );
}

inline void CGame::SetDiceSize( int seat, int s0, int s1 )
{
	m_SharedState.Set( bgDiceSize, seat * 2, s0 );
	m_SharedState.Set( bgDiceSize, (seat * 2) + 1, s1 );
}

inline void CGame::GetDiceSize( int seat, int* s0, int* s1 )
{
	*s0 = m_SharedState.Get( bgDiceSize, seat * 2 );
	*s1 = m_SharedState.Get( bgDiceSize, (seat * 2) + 1 );
}


inline int CGame::GetActiveSeatColor()
{
	if ( m_SharedState.Get( bgActiveSeat ) == m_Player.m_Seat )
		return m_Player.GetColor();
	else
		return m_Opponent.GetColor();
}


inline void CGame::RoomSend( uint32 messageType, void* message, int32 messageLen)
{
	ZCRoomSendMessage( m_TableId, messageType, message, messageLen );
}


#endif //!__BG_GAME_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\games\backgammon\moves.h ===
#ifndef __MOVES_H__
#define __MOVES_H__

// forward reference
class CGame;

enum
{
	zMoveHome = 0,
	zMoveBar  = 25,
	zMoveOpponentHomeStart = 19,
	zMoveOpponentHomeEnd   = 24
};


struct Die
{
	int	 val;
	BOOL used;
};


struct Point
{
	int color;
	int pieces;
};


struct Move
{
	int from;			// from point
	int to;				// to point
	int ndice;			// number of dice
	int diceIdx[4];		// dice index array
	int takeback;		// index of move this is taking back, -1 not a takeback
	BOOL bar;			// move placed opponent's piece on the bar
};


struct MoveList
{
	MoveList()	{ nmoves = 0; }
	void Add( int iFrom, int iTo, int iTakeBack, BOOL bBar, int* iDice, int nDice );
	void Del( int idx );
	
	int		nmoves;
	Move	moves[10];
};


struct BoardState
{
	int			color;			// player's color
	Point		points[26];		// 0 home, 1-24, normal, 25 bar
	MoveList	valid[26];		// valid moves for respective point
	MoveList	moves;			// player moves 
	Die			dice[4];		// dice values
	BOOL		doubles;		// player rolled doubles
	int			usableDice;		// number of usable dice
	int			cube;			// cube value if doubled during turn
};

// prototypes
int PointIdxToBoardStateIdx( int PlayerIdx );
int BoardStateIdxToPointIdx( int BoardIdx );
BOOL IsLegalMove( BoardState* state, int iFrom, int iTo );
BOOL CalcValidMoves( BoardState* state );
void DoMoveLite( BoardState* state, int iFrom, int iTo, BOOL* bBar );
void DoMove( BoardState* state, int iFrom, int* iDice, int nDice );
void TakeBackMove( BoardState* state, Move* move );
void InitTurnState( CGame* pGame, BoardState* state );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\games\backgammon\settings.h ===
#ifndef __SETTINGS_H__
#define __SETTINGS_H__

#include "game.h"

#undef BCKG_EASTEREGG

struct GameSettings
{
	BOOL Allow[2];
	BOOL Silence[2];
	BOOL NotationPane;
	BOOL Notation;
	BOOL Pip;
	BOOL Moves;
	BOOL Animation;
	BOOL Alert;
	BOOL Sounds;
};


class CSettings
{
public:
	CSettings();
	~CSettings();
	HRESULT Init( HINSTANCE hInstance, int nResourceId, HWND hwndParent, CGame* pGame );

	// dialog procedures
	static BOOL CALLBACK GameDlgProc( HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam ); 
	static BOOL CALLBACK DisplayDlgProc( HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam );
	static BOOL CALLBACK SoundDlgProc( HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam );

public:
	TCHAR			m_szCaption[256];
	CGame*			m_pGame;
	PROPSHEETPAGE	m_Pages[3];
	PROPSHEETHEADER	m_Header;
	GameSettings	m_Settings;
};


///////////////////////////////////////////////////////////////////////////////

class CBackground : public CSpriteWorldBackground
{
public:
	// initialization
	void Init( HPALETTE hPalette );

	// draw functions
	void Draw( CDibSection& dest );
	void Draw( CDibSection& dest, long dx, long dy, const RECT* rc );

	// palette functions
	HRESULT		RemapToPalette( CPalette& palette, BOOL bUseIndex = FALSE );
	RGBQUAD*	GetPalette();

protected:
	BYTE		m_FillIdx;
};


class CText : public CSprite
{
public:
	CText();

	void Draw();
	void Props( TCHAR* txt, HFONT hfont );
	void Delta( POINT loc, double x, double y ) { pt = loc, dx = x, dy = y; }

	HFONT		hfont;
	TCHAR		buff[64];
	int			len;
	POINT		pt;
	double		dx;
	double		dy;
};


struct Animation
{
	TCHAR	name[64];
	POINT	start;
	POINT	middle;
	POINT	end;
};


#ifdef BCKG_EASTEREGG

class CreditWnd : public CWindow2
{
public:
	CreditWnd();
	~CreditWnd();
	HRESULT Init( HINSTANCE hInstance, HWND hParent, CPalette palette );
	void OverrideWndParams( WNDPARAMS& WndParams );

protected:
	// window messages
	BEGIN_MESSAGE_MAP(CreditWnd);
		ON_MESSAGE( WM_CREATE, OnCreate );
		ON_MESSAGE( WM_LBUTTONDOWN, OnLButtonDown );
		ON_MESSAGE( WM_DESTROY, OnDestroy );
		ON_MESSAGE( WM_TIMER, OnTimer );
		ON_MESSAGE( WM_PAINT, OnPaint );
	END_MESSAGE_MAP();

	BOOL OnCreate( LPCREATESTRUCT lpCreateStruct );
	void OnLButtonDown( BOOL fDoubleClick, int x, int y, UINT keyFlags );
	void OnPaint();
	void OnDestroy();
	void OnTimer(UINT id);

protected:
	HFONT			m_Font;
	CPalette		m_Palette;
	CSpriteWorld	m_World;
	CText*			m_Sprites[5];
	long			m_Frames;
	long			m_State;
	Animation*		m_Lines;
	int				m_nLines;
};

#endif

void SaveSettings( GameSettings* s, int seat, BOOL fKibitzer );
void LoadSettings( GameSettings* s, int seat );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\games\backgammon\settings.cpp ===
#include "game.h"
#include <commctrl.h>


CSettings::CSettings()
{
	m_pGame = NULL;
}


CSettings::~CSettings()
{
	if ( m_pGame )
		m_pGame->Release();
}


HRESULT CSettings::Init( HINSTANCE hInstance, int nResourceId, HWND hwndParent, CGame* pGame )
{
	int seat;
	HRESULT status = NOERROR;
	
	// stash game object pointer;
	m_pGame = pGame;
	m_pGame->AddRef();

	/*
	//copy settings
	CopyMemory( &m_Settings, &pGame->m_Settings, sizeof(GameSettings) );

	// get property sheet caption
	LoadString( hInstance, IDS_SETTINGS_CAPTION, m_szCaption, sizeof(m_szCaption) );

	// create pages
	for ( int i = 0; i < 3; i++ )
	{
		ZeroMemory( &m_Pages[i], sizeof(PROPSHEETPAGE) );
		m_Pages[i].dwSize = sizeof(PROPSHEETPAGE);
		m_Pages[i].dwFlags = PSP_USECALLBACK;
		m_Pages[i].hInstance = hInstance;
		m_Pages[i].lParam = (LPARAM) this;
		switch ( i )
		{
		case 0:
			m_Pages[i].pszTemplate = MAKEINTRESOURCE( IDD_SETTINGS_GAME );
			m_Pages[i].pfnDlgProc = GameDlgProc;
			break;
		case 1:
			m_Pages[i].pszTemplate = MAKEINTRESOURCE( IDD_SETTINGS_DISPLAY );
			m_Pages[i].pfnDlgProc = DisplayDlgProc;
			break;
		case 2:
			m_Pages[i].pszTemplate = MAKEINTRESOURCE( IDD_SETTINGS_SOUND );
			m_Pages[i].pfnDlgProc = SoundDlgProc;
			break;
		}
	}

	// create header
	ZeroMemory( &m_Header, sizeof(PROPSHEETHEADER) );
	m_Header.dwSize = sizeof(PROPSHEETHEADER);
	m_Header.dwFlags = PSH_NOAPPLYNOW | PSH_PROPSHEETPAGE;
	m_Header.hwndParent = hwndParent;
	m_Header.hInstance = hInstance;
	m_Header.pszCaption = m_szCaption;
	m_Header.nPages = 3;
	m_Header.nStartPage = 0;
	m_Header.ppsp = m_Pages;

	// process property sheet
	if ( PropertySheet( &m_Header ) > 0 )
	{
		// save current settings
		SaveSettings( &m_Settings, m_pGame->m_Player.m_Seat, m_pGame->IsKibitzer() );

		// display pips?
		if ( m_Settings.Pip != m_pGame->m_Settings.Pip )
		{
			m_pGame->m_Settings.Pip = m_Settings.Pip;
			m_pGame->m_Wnd.DrawPips( TRUE );
		}

		// display notation
		if ( m_Settings.Notation != m_pGame->m_Settings.Notation )
		{
			m_pGame->m_Settings.Notation = m_Settings.Notation;
			m_pGame->m_Wnd.DrawNotation( TRUE );
		}

		// open notation window
		if ( m_Settings.NotationPane != m_pGame->m_Settings.NotationPane )
			ShowWindow( m_pGame->m_Notation, m_Settings.NotationPane ? SW_SHOW : SW_HIDE );

		// allow watchers?
		seat = m_pGame->m_Player.m_Seat;
		if ( m_Settings.Allow[ seat ] != m_pGame->m_Settings.Allow[ seat ] )
		{
			m_pGame->m_Settings.Allow[ seat ] = m_Settings.Allow[ seat ];
			m_pGame->m_SharedState.StartTransaction( bgTransAllowWatchers );
				m_pGame->m_SharedState.Set( bgAllowWatching, seat, m_Settings.Allow[ seat ] );
			m_pGame->m_SharedState.SendTransaction( TRUE );
		}

		// silence kibitzers?
		if ( m_Settings.Silence[ seat ] != m_pGame->m_Settings.Silence[ seat ] )
		{
			m_pGame->m_Settings.Silence[ seat ] = m_Settings.Silence[ seat ];
			m_pGame->m_SharedState.StartTransaction( bgTransSilenceKibitzers );
				m_pGame->m_SharedState.Set( bgSilenceKibitzers, seat, m_Settings.Silence[ seat ] );
			m_pGame->m_SharedState.SendTransaction( TRUE );
		}

		// update games settings
		CopyMemory( &pGame->m_Settings, &m_Settings, sizeof(GameSettings) );
	}
*/
	// we're done
	if ( m_pGame )
	{
		m_pGame->Release();
		m_pGame = NULL;
	}
	return NOERROR;
}


INT_PTR CALLBACK CSettings::GameDlgProc( HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam )
{
	/*
	int seat;
	CSettings* pObj = NULL;
	if ( msg == WM_INITDIALOG )
	{
		pObj = (CSettings*) ((PROPSHEETPAGE*) lParam)->lParam;
		::SetWindowLong(hwnd, GWL_USERDATA, (long) pObj);
	}
	else
		pObj = (CSettings*) ::GetWindowLong(hwnd, GWL_USERDATA);
	if ( !pObj )
		return FALSE;

	switch ( msg )
	{
	case WM_INITDIALOG:
		seat = pObj->m_pGame->m_Player.m_Seat;
		SetDlgItemText( hwnd, IDC_PLAYER_NAME, pObj->m_pGame->m_Player.m_Name );
		SetDlgItemText( hwnd, IDC_OPPONENT_NAME, pObj->m_pGame->m_Opponent.m_Name );
		SendDlgItemMessage( hwnd, IDC_PLAYER_ALLOW, BM_SETCHECK, pObj->m_Settings.Allow[ seat ], 0 );
		SendDlgItemMessage( hwnd, IDC_PLAYER_SILENCE, BM_SETCHECK, pObj->m_Settings.Silence[ seat ], 0 );
		SendDlgItemMessage( hwnd, IDC_OPPONENT_ALLOW, BM_SETCHECK, pObj->m_Settings.Allow[ !seat ], 0 );
		SendDlgItemMessage( hwnd, IDC_OPPONENT_SILENCE, BM_SETCHECK, pObj->m_Settings.Silence[ !seat ], 0 );
		if ( pObj->m_pGame->IsKibitzer() )
		{
			EnableWindow( GetDlgItem( hwnd, IDC_PLAYER_ALLOW ), FALSE );
			EnableWindow( GetDlgItem( hwnd, IDC_PLAYER_SILENCE ), FALSE );
		}
		return TRUE;

	case WM_COMMAND:
		seat = pObj->m_pGame->m_Player.m_Seat;
		switch ( LOWORD(wParam) )
		{
		case IDC_PLAYER_ALLOW:
			pObj->m_Settings.Allow[ seat ] = SendDlgItemMessage( hwnd, IDC_PLAYER_ALLOW, BM_GETCHECK, 0, 0 );
			break;
		case IDC_PLAYER_SILENCE:
			pObj->m_Settings.Silence[ seat ] = SendDlgItemMessage( hwnd, IDC_PLAYER_SILENCE, BM_GETCHECK, 0, 0 );
			break;
		}
		return TRUE;
	}
	*/
	return FALSE;
}


INT_PTR CALLBACK CSettings::DisplayDlgProc( HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam )
{
	/*
	CSettings* pObj = NULL;
	if ( msg == WM_INITDIALOG )
	{
		pObj = (CSettings*) ((PROPSHEETPAGE*) lParam)->lParam;
		::SetWindowLong(hwnd, GWL_USERDATA, (long) pObj);
	}
	else
		pObj = (CSettings*) ::GetWindowLong(hwnd, GWL_USERDATA);
	if ( !pObj )
		return FALSE;

	switch ( msg )
	{
	case WM_INITDIALOG:
		SendDlgItemMessage( hwnd, IDC_NOTATION_PANE, BM_SETCHECK, pObj->m_Settings.NotationPane, 0 );
		SendDlgItemMessage( hwnd, IDC_NOTATION, BM_SETCHECK, pObj->m_Settings.Notation, 0 );
		SendDlgItemMessage( hwnd, IDC_PIP, BM_SETCHECK, pObj->m_Settings.Pip, 0 );
		SendDlgItemMessage( hwnd, IDC_MOVES, BM_SETCHECK, pObj->m_Settings.Moves, 0 );
		SendDlgItemMessage( hwnd, IDC_ANIMATE, BM_SETCHECK, pObj->m_Settings.Animation, 0 );
		return TRUE;

	case WM_COMMAND:
		switch ( LOWORD(wParam) )
		{
		case IDC_NOTATION_PANE:
			pObj->m_Settings.NotationPane = SendDlgItemMessage( hwnd, IDC_NOTATION_PANE, BM_GETCHECK, 0, 0 );
			break;
		case IDC_NOTATION:
			pObj->m_Settings.Notation = SendDlgItemMessage( hwnd, IDC_NOTATION, BM_GETCHECK, 0, 0 );
			break;
		case IDC_PIP:
			pObj->m_Settings.Pip = SendDlgItemMessage( hwnd, IDC_PIP, BM_GETCHECK, 0, 0 );
			break;
		case IDC_MOVES:
			pObj->m_Settings.Moves = SendDlgItemMessage( hwnd, IDC_MOVES, BM_GETCHECK, 0, 0 );
			break;
		case IDC_ANIMATE:
			pObj->m_Settings.Animation = SendDlgItemMessage( hwnd, IDC_ANIMATE, BM_GETCHECK, 0, 0 );
			break;
		}
		return TRUE;
	}
*/
	return FALSE;
}


INT_PTR CALLBACK CSettings::SoundDlgProc( HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam )
{
	/*
	CSettings* pObj = NULL;
	if ( msg == WM_INITDIALOG )
	{
		pObj = (CSettings*) ((PROPSHEETPAGE*) lParam)->lParam;
		::SetWindowLong(hwnd, GWL_USERDATA, (long) pObj);
	}
	else
		pObj = (CSettings*) ::GetWindowLong(hwnd, GWL_USERDATA);
	if ( !pObj )
		return FALSE;

	switch ( msg )
	{
	case WM_INITDIALOG:
		SendDlgItemMessage( hwnd, IDC_ALERT, BM_SETCHECK, pObj->m_Settings.Alert, 0 );
		SendDlgItemMessage( hwnd, IDC_SOUNDS, BM_SETCHECK, pObj->m_Settings.Sounds, 0 );
		return TRUE;

	case WM_COMMAND:
		switch ( LOWORD(wParam) )
		{
		case IDC_ALERT:
			pObj->m_Settings.Alert = SendDlgItemMessage( hwnd, IDC_ALERT, BM_GETCHECK, 0, 0 );
			break;
		case IDC_SOUNDS:
			pObj->m_Settings.Sounds = SendDlgItemMessage( hwnd, IDC_SOUNDS, BM_GETCHECK, 0, 0 );
			break;
		}
		return TRUE;
	}
	*/
	return FALSE;
}


void SaveSettings( GameSettings* s, int seat, BOOL fKibitzer )
{
	/*
	ZoneSetRegistryDword( gGameRegName, _T("Notation Pane"),	s->NotationPane );
	ZoneSetRegistryDword( gGameRegName, _T("Board Notation"),	s->Notation );
	ZoneSetRegistryDword( gGameRegName, _T("Pips"),				s->Pip );
	ZoneSetRegistryDword( gGameRegName, _T("Highlight Moves"),	s->Moves );
	ZoneSetRegistryDword( gGameRegName, _T("Piece Animation"),	s->Animation );
	ZoneSetRegistryDword( gGameRegName, _T("Turn Alert"),		s->Alert );
	ZoneSetRegistryDword( gGameRegName, _T("Sounds"),			s->Sounds );
	*/
}


void LoadSettings( GameSettings* s, int seat )
{
	s->Allow[0] = TRUE;
	s->Allow[1] = TRUE;
	s->Silence[0] = FALSE;
	s->Silence[1] = FALSE;

	s->NotationPane = FALSE;
	s->Notation		= TRUE;
	s->Pip			= TRUE;
	s->Moves		= TRUE;
	s->Animation	= TRUE;
	s->Alert		= TRUE;
	s->Sounds		= TRUE;

	/*
	if ( !ZoneGetRegistryDword( gGameRegName, _T("Notation Pane"), (DWORD*) &(s->NotationPane) ) )
		s->NotationPane = FALSE;
	if ( !ZoneGetRegistryDword( gGameRegName, _T("Board Notation"), (DWORD*) &(s->Notation) ) )
		s->Notation = TRUE;
	if ( !ZoneGetRegistryDword( gGameRegName, _T("Pips"), (DWORD*) &(s->Pip) ) )
		s->Pip = TRUE;
	if ( !ZoneGetRegistryDword( gGameRegName, _T("Highlight Moves"), (DWORD*) &(s->Moves) ) )
		s->Moves = TRUE;
	if ( !ZoneGetRegistryDword( gGameRegName, _T("Piece Animation"), (DWORD*) &(s->Animation) ) )
		s->Animation = TRUE;
	if ( !ZoneGetRegistryDword( gGameRegName, _T("Turn Alert"), (DWORD*) &(s->Alert) ) )
		s->Alert = FALSE;
	if ( !ZoneGetRegistryDword( gGameRegName, _T("Sounds"), (DWORD*) &(s->Sounds) ) )
		s->Sounds = TRUE;
	*/
}


///////////////////////////////////////////////////////////////////////////////
// Credit Wnd
///////////////////////////////////////////////////////////////////////////////

const COLORREF	FillColor = PALETTERGB( 107, 49, 24 );
const COLORREF	TextColor = PALETTERGB( 255, 189, 82 );


void CBackground::Init( HPALETTE hPalette )
{
	m_FillIdx = GetNearestPaletteIndex( hPalette, FillColor );
}

void CBackground::Draw( CDibSection& dest )
{
	dest.Fill( m_FillIdx );
}

void CBackground::Draw( CDibSection& dest, long dx, long dy, const RECT* rc )
{
	dest.Fill( rc, m_FillIdx );
}

HRESULT	CBackground::RemapToPalette( CPalette& palette, BOOL bUseIndex )
{
	return NOERROR;
}

RGBQUAD* CBackground::GetPalette()
{
	return NULL;
}

CText::CText()
{
	len = 0;
}

void CText::Draw()
{
	// don't have any text to draw
	if ( len <= 0 )
		return;

	HDC hdc = m_pWorld->GetBackbuffer()->GetDC();
	HFONT oldFont = SelectObject( hdc, hfont );
	SetBkMode( hdc, TRANSPARENT );
	SetTextColor( hdc, TextColor );
	DrawText( hdc, buff, len, &m_rcScreen, DT_CENTER | DT_VCENTER );
	SelectObject( hdc, oldFont );
}

void CText::Props( TCHAR* txt, HFONT font )
{
	lstrcpy( buff, txt );
	len = lstrlen(txt);
	hfont = font;
	m_pWorld->Modified( this );
}

#ifdef BCKG_EASTEREGG

static Animation Intro[] =
{
	{ _T("Zone"),					{ -200,   40 },	{ 20, 40 },	{ -500,   40 } },
	{ _T("Backgammon"),				{  500,   40 },	{ 90, 40 },	{  800,   40 } },
	{ _T("brought to you"),			{   70,  180 },	{ 70, 60 },	{   70,  330 } },
	{ _T("by"),						{   70,  -30 },	{ 70, 80 },	{   70, -180 } },
};

static Animation Dev[] =
{
	{_T("Developers"),				{   70, -30 },	{ 70, 30 },	{   70, -180 } },
	{_T("Chad Barry (Glitch)"),	{ -200,  70 },	{ 70, 70 },	{ -500,   70 } },
	{_T("Bear"),					{  500,  90 },	{ 70, 90 },	{  800,   90 } },
};

static Animation Test[] =
{
	{_T("Testing"),				{   70, -30 },	{ 70, 30 },	{   70, -180 } },
	{_T("Jason Van Eaton"),		{  500,  70 },	{ 70, 70 },	{ -500,   70 } },
	{_T("Barry Curran"),			{ -200,  90 },	{ 70, 90 },	{  800,   90 } },
};

static Animation Art[] =
{
	{_T("Art / Design"),			{  70,  -30 },	{ 70, 30 },	{   70, -180 } },
	{_T("Naomi Davidson"),			{  500,  70 },	{ 70, 70 },	{  800,   70 } },
	{_T("Corey Dangel"),			{ -200,  90 },	{ 70, 90 },	{ -500,   90 } },
};

static Animation Sound[] =
{
	{_T("Sound"),					{  70, -30 },	{ 70, 40 },	{ 70, -180 } },
	{_T("Barry Dowsett"),			{  70, 180 },	{ 70, 70 },	{ 70,  330 } },
};

static Animation UA[] =
{
	{_T("User Assistance"),		{   70, -30 },	{  70, 20 },	{   70, -180 } },
	{_T("Mary Sloat"),				{ -200,  60 },	{  70, 60 },	{  800,   60 } },
	{_T("Caitlin Sullivan"),		{  500,  80 },	{  70, 80 },	{ -500,   80 } },
	{_T("Daj Oberg"),				{ -200, 100 },	{  70, 100 },	{  800,  100 } },
};

static Animation PM[] = 
{
	{_T("Program Management"),		{  70, -30 },	{ 70, 40 },	{ 70, -180 } },
	{_T("Laura Fryer"),			{  70,  180 },	{ 70, 70 },	{ 70,  330 } },
};

static Animation Planning[] =
{
	{_T("Product Planning"),		{ -200, 40 },	{ 70, 40 },	{ -500, 40 } },
	{_T("Jon Grande"),				{  500, 70 },	{ 70, 70 },	{  800, 70 } },
};

static Animation Support[] =
{
	{_T("Product Support"),		{  500, 40 },	{ 70, 40 },	{  800, 40 } },
	{_T("Jenette Paulson"),		{ -200, 70 },	{ 70, 70 },	{ -500, 70 } },
};

static Animation Thanks[] =
{
	{_T("And special thanks to"),	{  500, -30 },	{ 70, 40 },	{ -200, -30 } },
	{_T("the Zone Team"),			{ -200, 160 },	{ 70, 70 },	{  500, 160 } },
};


CreditWnd::CreditWnd()
{
	m_Font = NULL;
	for ( int i = 0; i < 5; i++ )
		m_Sprites[i] = NULL;
}


CreditWnd::~CreditWnd()
{
	DeleteObject( m_Font );
	for ( int i = 0; i < 5; i++ )
		m_Sprites[i]->Release();
}


HRESULT CreditWnd::Init( HINSTANCE hInstance, HWND hParent, CPalette palette )
{
	HRESULT hr;
	const int width = 300;
	const int height = 140;

	// copy palette
	m_Palette.Init( palette );

	// initialize sprite engine
	CBackground* background = new CBackground;
	if ( !background )
		return E_OUTOFMEMORY;
	background->Init( palette.GetHandle() );
	CDibSection* backbuffer = new CDibSection;
	if ( !backbuffer )
		return E_OUTOFMEMORY;
	hr = backbuffer->Create( width, height, m_Palette );
	if ( FAILED(hr) )
		return hr;
	background->Draw( *backbuffer );
	hr = m_World.Init( ZShellResourceManager(), backbuffer, background, 5 );
	if ( FAILED(hr) )
		return hr;
	for ( int i = 0; i < 5; i++ )
	{
		m_Sprites[i] = new CText;
		if ( !m_Sprites[i] )
			return E_OUTOFMEMORY;
		hr = m_Sprites[i]->Init( &m_World, 1, 0, 160, 20 );
		if ( FAILED(hr) )
			return hr;
		m_Sprites[i]->SetEnable( FALSE );
	}

	// sprite engine owns these
	background->Release();
	backbuffer->Release();

	// animation state
	m_Frames = 0;
	m_State = 0;
	m_nLines = 0;
	m_Lines = NULL;

	// create font
	LOGFONT font;
	ZeroMemory( &font, sizeof(font) );
	font.lfHeight = -15;
	font.lfWeight = FW_BOLD;
	lstrcpy( font.lfFaceName, _T("Arial") );
	m_Font = CreateFontIndirect( &font );

	// create window
	POINT pt = { 105, 119 };
	FRX::CRect rc( pt.x, pt.y, pt.x + width, pt.y + height );
	hr = CWindow2::Init( hInstance, NULL, hParent, &rc );
	if ( FAILED(hr) )
		return hr;

	return NOERROR;
}


void CreditWnd::OverrideWndParams( WNDPARAMS& WndParams )
{
	WndParams.dwStyle = WS_CHILD;
}


BOOL CreditWnd::OnCreate( LPCREATESTRUCT lpCreateStruct )
{
	// load palette
	HDC hdc = GetDC( m_hWnd );
	SelectPalette( hdc, m_Palette, TRUE );
	RealizePalette( hdc );
	ReleaseDC( m_hWnd, hdc );

	// start timer
	SetTimer( m_hWnd, 1, 66, NULL );

	// capture mouse
	SetCapture( m_hWnd );

	// we're done
	return TRUE;
}


void CreditWnd::OnPaint()
{
	PAINTSTRUCT ps;
	HDC hdc = BeginPaint( m_hWnd, &ps );
	m_World.GetBackbuffer()->Draw( hdc, 0, 0 );
	EndPaint( m_hWnd, &ps );
}


void CreditWnd::OnLButtonDown( BOOL fDoubleClick, int x, int y, UINT keyFlags )
{
	DestroyWindow( m_hWnd );
}


void CreditWnd::OnDestroy()
{
	// release mouse
	ReleaseCapture();

	// delete timer
	KillTimer( m_hWnd, 1 );

	// make sure class won't be used again
	::SetWindowLong( m_hWnd, GWL_USERDATA, NULL );

	// free class memory
	delete this;
}


void CreditWnd::OnTimer(UINT id)
{
	const int frames = 15;

	BOOL move = FALSE;
	double dx, dy;
	long x, y, t;

	if ( m_Frames == 0 )
	{
		// start new sequence
		switch ( m_State )
		{
		case 0:
			m_Lines = Intro;
			m_nLines = sizeof(Intro) / sizeof(Animation);
			m_State = 1;
			break;
		case 1:
			m_Lines = Dev;
			m_nLines = sizeof(Dev) / sizeof(Animation);
			m_State = 2;
			break;
		case 2:
			m_Lines = Test;
			m_nLines = sizeof(Test) / sizeof(Animation);
			m_State = 3;
			break;
		case 3:
			m_Lines = Art;
			m_nLines = sizeof(Art) / sizeof(Animation);
			m_State = 4;
			break;
		case 4:
			m_Lines = Sound;
			m_nLines = sizeof(Sound) / sizeof(Animation);
			m_State = 5;
			break;
		case 5:
			m_Lines = UA;
			m_nLines = sizeof(UA) / sizeof(Animation);
			m_State = 6;
			break;
		case 6:
			m_Lines = PM;
			m_nLines = sizeof(PM) / sizeof(Animation);
			m_State = 7;
			break;
		case 7:
			m_Lines = Planning;
			m_nLines = sizeof(Planning) / sizeof(Animation);
			m_State = 8;
			break;
		case 8:
			m_Lines = Support;
			m_nLines = sizeof(Support) / sizeof(Animation);
			m_State = 9;
			break;
		case 9:
			m_Lines = Thanks;
			m_nLines = sizeof(Thanks) / sizeof(Animation);
			m_State = 10;
			break;
		case 10:
			DestroyWindow( m_hWnd );
			return;
		}

		// initialize sprites
		for ( int i = 0; i < m_nLines; i++ )
		{
			dx = (m_Lines[i].middle.x - m_Lines[i].start.x) / (double) frames;
			dy = (m_Lines[i].middle.y - m_Lines[i].start.y) / (double) frames;
			m_Sprites[i]->SetLayer( i + 1 );
			m_Sprites[i]->Props( m_Lines[i].name, m_Font );
			m_Sprites[i]->Delta( m_Lines[i].start, dx, dy );
			m_Sprites[i]->SetEnable( TRUE );
		}
	}
	else if ( m_Frames == frames )
	{
		// force text to middle positions
		for ( int i = 0; i < m_nLines; i++ )
		{
			m_Sprites[i]->SetXY( m_Lines[i].middle.x, m_Lines[i].middle.y );
			m_Sprites[i]->Delta( m_Lines[i].middle, 0, 0 );
		}
	}
	else if ( m_Frames == (2 * frames) )
	{
		// start text moving in other direction
		for ( int i = 0; i < m_nLines; i++ )
		{
			dx = (m_Lines[i].end.x - m_Lines[i].middle.x) / (double) frames;
			dy = (m_Lines[i].end.y - m_Lines[i].middle.y) / (double) frames;
			m_Sprites[i]->Delta( m_Lines[i].middle, dx, dy );
		}
	}
	else if ( m_Frames == (3 * frames) )
	{
		// force next state
		m_Frames = 0;
		return;
	}
	
	// update sprite positions
	t = m_Frames % frames;
	for ( int i = 0; i < m_nLines; i++ )
	{
		m_Sprites[i]->SetXY( 
				(long)(m_Sprites[i]->pt.x + (t * m_Sprites[i]->dx)),
				(long)(m_Sprites[i]->pt.y + (t * m_Sprites[i]->dy)) );
	}

	// update screen
	HDC hdc = GetDC( m_hWnd );
	m_World.Draw( hdc );
	ReleaseDC( m_hWnd, hdc );

	// update frame counter
	m_Frames++;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\games\backgammon\shared.cpp ===
#include "zone.h"
#include "zonedebug.h"
#include "zroom.h"
#include "bgmsgs.h"
#include "shared.h"

bool CSharedState::CallbackCmp( Callback* obj, int tag )
{
	return ( obj->m_Tag == tag );
}


bool CSharedState::CallbackDel( Callback* obj, MTListNodeHandle node, void* cookie )
{
	CSharedState* pObj = (CSharedState*) cookie;
	pObj->m_Callbacks.MarkNodeDeleted( node );
	delete obj;
	return TRUE;
}

CSharedState::CSharedState()
	: m_Callbacks( HashInt, CallbackCmp,NULL,  8, 2 )
{
	m_Entries = NULL;
	m_nSize = 0;
	m_nEntries = 0;
	m_Transactions.transCnt = -1;
}


CSharedState::~CSharedState()
{
	m_Callbacks.ForEach( CallbackDel, this );
	if ( m_Entries )
	{
		for ( int i = 0; i < m_nEntries; i++ )
		{
			if ( m_Entries[i].m_Array )
			{
				delete [] m_Entries[i].m_Array;
				m_Entries[i].m_Array = NULL;
			}
		}
		delete [] m_Entries;
	}
}


HRESULT CSharedState::Init( int user, int table, int seat, SharedStateEntry* pEntries, int nEntries )
{
	m_User = user;
	m_Table = table;
	m_Seat = seat;
	m_Transactions.transCnt = -1;
	m_nEntries = nEntries;
	m_Entries = new Entry[ m_nEntries ];
	if ( !m_Entries )
		return E_OUTOFMEMORY;
	for ( int i = 0; i < nEntries; i++ )
	{
		ASSERT( pEntries[i].tag == i );
		if ( pEntries[i].count <= 1 )
		{
			m_Entries[i].m_Num = -1;
			m_Entries[i].m_Array = NULL;
			m_nSize += sizeof(int);
		}
		else
		{
			m_Entries[i].m_Num = pEntries[i].count;
			m_Entries[i].m_Array = new int [ pEntries[i].count ];
			if ( !m_Entries[i].m_Array )
				return E_OUTOFMEMORY;
			m_nSize += sizeof(int) * pEntries[i].count;
			for ( int j = 0; j < m_Entries[i].m_Num; j++ )
				m_Entries[i].m_Array[j] = -1;
		}
	}
	return NOERROR;
}


HRESULT CSharedState::SetTransactionCallback( int tag, PFTRANSACTIONFUNC fn, DWORD cookie )
{
	Callback* p;

	if ( !(p = new Callback) )
		return E_OUTOFMEMORY;
	p->m_Tag = tag;
	p->m_Cookie = cookie;
	p->m_Fn = fn;
	if ( !m_Callbacks.Add( p->m_Tag, p ) )
	{
		delete p;
		return E_OUTOFMEMORY;
	}
	return NOERROR;
}

void CSharedState::StartTransaction( int tag )
{
	ASSERT( m_Transactions.transCnt < 0 );
	m_Transactions.transCnt = 0;
	m_Transactions.user = m_User;
	m_Transactions.seat = m_Seat;
	m_Transactions.transTag = tag;
}


void CSharedState::SendTransaction( BOOL fTriggerCallback )
{
	// send transaction
	if ( m_Transactions.transCnt >= 0 )
	{
		int size = ((BYTE*) &m_Transactions.trans[m_Transactions.transCnt]) - ((BYTE*) &m_Transactions);
		ZCRoomSendMessage( m_Table, zBGMsgTransaction, &m_Transactions, size );
	}
	m_Transactions.transCnt = -1;

	// do callback
	if ( fTriggerCallback )
	{
		Callback* pCallback = m_Callbacks.Get( m_Transactions.transTag );
		if ( pCallback && pCallback->m_Fn )
			pCallback->m_Fn( m_Transactions.transTag, m_Transactions.seat, pCallback->m_Cookie );
	}
}


void CSharedState::CancelTransaction()
{
	m_Transactions.transCnt = -1;
}


bool CSharedState::ProcessTransaction( BYTE* msg, int len )
{
	Callback* pCallback;
	TransactionMsg* pTrans = (TransactionMsg*) msg;
    int tag, idx;

    if(len < sizeof(*pTrans) - sizeof(pTrans->trans) ||
        (unsigned int) len < sizeof(*pTrans) - sizeof(pTrans->trans) + pTrans->transCnt * sizeof(pTrans->trans[0]) ||
        (pTrans->seat != 0 && pTrans->seat != 1))
    {
        ASSERT(!"ProcessTransaction sync");
        return false;
    }

	// ignore messages from ourselves
	if ( pTrans->user == m_User )
		return true;
    pTrans->user = 0;  // unused after this

	// update table
	for ( int i = 0; i < pTrans->transCnt; i++ )
	{
        tag = pTrans->trans[i].m_EntryTag;
        idx = pTrans->trans[i].m_EntryIdx;

        if(tag < 0 || tag >= m_nEntries ||
            idx < -1 || (idx == -1 && m_Entries[tag].m_Array) ||
            (idx >= 0 && (!m_Entries[tag].m_Array || idx >= m_Entries[tag].m_Num)))
        {
            ASSERT(!"ProcessTransaction sync");
            return false;
        }

		if(idx == -1)
			Set(tag, pTrans->trans[i].m_EntryVal);
		else
			Set(tag, idx, pTrans->trans[i].m_EntryVal);
	}

	// do callback
	pCallback = m_Callbacks.Get( pTrans->transTag );
    if(!pCallback)
    {
        ASSERT(!"ProcessTransaction sync");
        return false;
    }

	if(pCallback->m_Fn)
		pCallback->m_Fn( pTrans->transTag, pTrans->seat, pCallback->m_Cookie );
    return true;
}


void CSharedState::Dump( BYTE* buff, int buffsz )
{
	// writes compact dump of the shared state into the
	// specified buffer.
	int* ibuff = (int*) buff;

	for ( int i = 0; (i < m_nEntries) && (buffsz >= 4); i++ )
	{
		if ( !m_Entries[i].m_Array )
		{
			*ibuff++ = m_Entries[i].m_Num;
			buffsz -= sizeof(int);
		}
		else
		{
			for ( int j = 0; (j < m_Entries[i].m_Num) && (buffsz >= 4); j++ )
			{
				*ibuff++ = m_Entries[i].m_Array[j];
				buffsz -= sizeof(int);
			}
		}
	}
}


void CSharedState::ProcessDump( BYTE* buff, int buffsz )
{
	// transfers a compact dump into the shared state.
	int* ibuff = (int*) buff;

	for ( int i = 0; (i < m_nEntries) && (buffsz >= 4); i++ )
	{
		if ( !m_Entries[i].m_Array )
		{
			m_Entries[i].m_Num = *ibuff++;
			buffsz -= sizeof(int);
		}
		else
		{
			for ( int j = 0; (j < m_Entries[i].m_Num) && (buffsz >= 4); j++ )
			{
				m_Entries[i].m_Array[j] = *ibuff++;
				buffsz -= sizeof(int);
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\games\backgammon\shared.h ===
#ifndef __SHARED_STATE__
#define __SHARED_STATE__

#include "hash.h"

typedef void (*PFTRANSACTIONFUNC)( int tag, int seat, DWORD cookie );

struct SharedStateEntry
{
	int tag;
	int count;
};


class CSharedState
{
public:
	// constructor & destructor
	CSharedState();
	~CSharedState();

	// initialization
	HRESULT Init( int user, int table, int seat, SharedStateEntry* pEntries, int nEntries );

	// transaction
	HRESULT SetTransactionCallback( int tag, PFTRANSACTIONFUNC fn, DWORD cookie );
	void StartTransaction( int tag );
	void CancelTransaction();
	void SendTransaction( BOOL fTriggerCallback = FALSE );
	bool ProcessTransaction( BYTE* msg, int len );
	
	void Dump( BYTE* buff, int buffsz );
	void ProcessDump( BYTE* buff, int len );

	int GetSize()	{ return m_nSize; }

	// accessors
	const int* GetArray( int tag ) const;
	int Get( int tag ) const;
	int Get( int tag, int idx ) const;
	void Set( int tag, int value );
	void Set( int tag, int idx, int value );
	void Swap( int tag, int idx0, int idx1 );
		
protected:

	struct Entry
	{
		int		m_Num;
		int*	m_Array;
	};

	struct Callback
	{
		int					m_Tag;
		DWORD				m_Cookie;
		PFTRANSACTIONFUNC	m_Fn;
	};

	struct Transaction
	{
		int m_EntryTag;
		int m_EntryIdx;
		int m_EntryVal;
	};

	struct TransactionMsg
	{
		int			user;
		int			seat;
		int			transCnt;
		int			transTag;
		Transaction trans[128];
	};

	struct FullStateMsg
	{
		ZGameMsgGameStateResponse	response;
		int							transCnt;
		Transaction					trans[128];
	};

	static bool CallbackCmp( Callback* obj, int tag );
	static bool CallbackDel( Callback* obj, MTListNodeHandle node, void* cookie );

	// game instance data
	int m_User;
	int	m_Table;
	int m_Seat;
	
	// table entries
	Entry*	m_Entries;
	int		m_nEntries;
	int		m_nSize;
	
	// transactions
	CMTHash<Callback,int>	m_Callbacks;
	TransactionMsg			m_Transactions;
};


///////////////////////////////////////////////////////////////////////////////
// Inlines
///////////////////////////////////////////////////////////////////////////////

inline const int* CSharedState::GetArray( int tag ) const
{
	ASSERT( (tag >= 0) && (tag < m_nEntries) );
	ASSERT( m_Entries[tag].m_Array );

	return m_Entries[tag].m_Array;
}


inline int CSharedState::Get( int tag ) const
{
	ASSERT( (tag >= 0) && (tag < m_nEntries) );
	ASSERT( m_Entries[tag].m_Array == NULL );

	return m_Entries[tag].m_Num;
}


inline int CSharedState::Get( int tag, int idx ) const
{
	ASSERT( (tag >= 0) && (tag < m_nEntries) );
	ASSERT( m_Entries[tag].m_Array );
	ASSERT( (idx >= 0) && (idx < m_Entries[tag].m_Num) );

	return m_Entries[tag].m_Array[idx];
}


inline void CSharedState::Set( int tag, int value )
{
	ASSERT( (tag >= 0) && (tag < m_nEntries) );
	ASSERT( m_Entries[tag].m_Array == NULL );

	m_Entries[tag].m_Num = value;
	if ( m_Transactions.transCnt >= 0 )
	{
		m_Transactions.trans[m_Transactions.transCnt].m_EntryTag = tag;
		m_Transactions.trans[m_Transactions.transCnt].m_EntryIdx = -1;
		m_Transactions.trans[m_Transactions.transCnt++].m_EntryVal = value;
	}
}


inline void CSharedState::Set( int tag, int idx, int value )
{
	ASSERT( (tag >= 0) && (tag < m_nEntries) );
	ASSERT( m_Entries[tag].m_Array );
	ASSERT( (idx >= 0) && (idx < m_Entries[tag].m_Num) );

	m_Entries[tag].m_Array[idx] = value;
	if ( m_Transactions.transCnt >= 0 )
	{
		m_Transactions.trans[m_Transactions.transCnt].m_EntryTag = tag;
		m_Transactions.trans[m_Transactions.transCnt].m_EntryIdx = idx;
		m_Transactions.trans[m_Transactions.transCnt++].m_EntryVal = value;
	}
}


inline void CSharedState::Swap( int tag, int idx0, int idx1 )
{
	ASSERT( (tag >= 0) && (tag < m_nEntries) );
	ASSERT( m_Entries[tag].m_Array );
	ASSERT( (idx0 >= 0) && (idx0 < m_Entries[tag].m_Num) );
	ASSERT( (idx1 >= 0) && (idx1 < m_Entries[tag].m_Num) );

	int tmp0 = m_Entries[tag].m_Array[idx1];
	int tmp1 = m_Entries[tag].m_Array[idx0];
	m_Entries[tag].m_Array[idx0] = tmp0;
	m_Entries[tag].m_Array[idx1] = tmp1;
	if ( m_Transactions.transCnt >= 0 )
	{
		m_Transactions.trans[m_Transactions.transCnt].m_EntryTag = tag;
		m_Transactions.trans[m_Transactions.transCnt].m_EntryIdx = idx0;
		m_Transactions.trans[m_Transactions.transCnt++].m_EntryVal = tmp0;
		m_Transactions.trans[m_Transactions.transCnt].m_EntryTag = tag;
		m_Transactions.trans[m_Transactions.transCnt].m_EntryIdx = idx1;
		m_Transactions.trans[m_Transactions.transCnt++].m_EntryVal = tmp1;
	}
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\games\backgammon\spritedata.h ===
#ifndef __SPRITE_DATA__
#define __SPRITE_DATA__

enum SpriteLayers
{
	bgDiceLayer = 1,
	bgKibitzerLayer,
	bgButtonLayer,
	bgButtonTextLayer,
	bgPieceLayer,
	bgHighlightLayer = 18,
	bgDragLayer,
	bgStatusLayer,
	bgRectSpriteLayer,
	bgTopLayer	
};


static int DiceStates[2 /*color*/ ][3 /*size*/ ][7 /*value*/ ] =
{
	{									// brown = 0
		{ 0,   1,  3,  5,  7,  9, 11 },	//	big
		{ 13, 14, 15, 16, 17, 18, 19 },	//	medium
		{ 20, 21, 22, 23, 24, 25, 26 }	//	small
	},
	{									// white = 1
		{ 27, 28, 30, 32, 34, 36, 38 },	//	big
		{ 40, 41, 42, 43, 44, 45, 46 },	//	medium
		{ 47, 48, 49, 50, 51, 52, 53 }	//	small
	}
};


static SpriteInfo DiceSprite[] =
{
	{ IDB_BIG_DICE,		IDR_BROWN_BIG_DICE_0 },	// 0
	{ IDB_BIG_DICE,		IDR_BROWN_BIG_DICE_1 },	// 1
	{ IDB_BIG_DICE,		IDR_BROWN_TWT_DICE_1 },	// 2
	{ IDB_BIG_DICE,		IDR_BROWN_BIG_DICE_2 },	// 3
	{ IDB_BIG_DICE,		IDR_BROWN_TWT_DICE_2 },	// 4
	{ IDB_BIG_DICE,		IDR_BROWN_BIG_DICE_3 },	// 5
	{ IDB_BIG_DICE,		IDR_BROWN_TWT_DICE_3 },	// 6
	{ IDB_BIG_DICE,		IDR_BROWN_BIG_DICE_4 },	// 7
	{ IDB_BIG_DICE,		IDR_BROWN_TWT_DICE_4 },	// 8
	{ IDB_BIG_DICE,		IDR_BROWN_BIG_DICE_5 },	// 9
	{ IDB_BIG_DICE,		IDR_BROWN_TWT_DICE_5 },	// 10
	{ IDB_BIG_DICE,		IDR_BROWN_BIG_DICE_6 },	// 11
	{ IDB_BIG_DICE,		IDR_BROWN_TWT_DICE_6 },	// 12

	{ IDB_MEDIUM_DICE,	IDR_BROWN_MED_DICE_0 },	// 13
	{ IDB_MEDIUM_DICE,	IDR_BROWN_MED_DICE_1 },	// 14
	{ IDB_MEDIUM_DICE,	IDR_BROWN_MED_DICE_2 },	// 15
	{ IDB_MEDIUM_DICE,	IDR_BROWN_MED_DICE_3 }, // 16
	{ IDB_MEDIUM_DICE,	IDR_BROWN_MED_DICE_4 }, // 17
	{ IDB_MEDIUM_DICE,	IDR_BROWN_MED_DICE_5 },	// 18
	{ IDB_MEDIUM_DICE,	IDR_BROWN_MED_DICE_6 },	// 19

	{ IDB_SMALL_DICE,	IDR_BROWN_SML_DICE_0 },	// 20
	{ IDB_SMALL_DICE,	IDR_BROWN_SML_DICE_1 },	// 21
	{ IDB_SMALL_DICE,	IDR_BROWN_SML_DICE_2 },	// 22
	{ IDB_SMALL_DICE,	IDR_BROWN_SML_DICE_3 },	// 23
	{ IDB_SMALL_DICE,	IDR_BROWN_SML_DICE_4 },	// 24
	{ IDB_SMALL_DICE,	IDR_BROWN_SML_DICE_5 },	// 25
	{ IDB_SMALL_DICE,	IDR_BROWN_SML_DICE_6 },	// 26
	
	{ IDB_BIG_DICE,		IDR_WHITE_BIG_DICE_0 },	// 27
	{ IDB_BIG_DICE,		IDR_WHITE_BIG_DICE_1 },	// 28
	{ IDB_BIG_DICE,		IDR_WHITE_TWT_DICE_1 },	// 29
	{ IDB_BIG_DICE,		IDR_WHITE_BIG_DICE_2 },	// 30
	{ IDB_BIG_DICE,		IDR_WHITE_TWT_DICE_2 },	// 31
	{ IDB_BIG_DICE,		IDR_WHITE_BIG_DICE_3 },	// 32
	{ IDB_BIG_DICE,		IDR_WHITE_TWT_DICE_3 }, // 33
	{ IDB_BIG_DICE,		IDR_WHITE_BIG_DICE_4 },	// 34
	{ IDB_BIG_DICE,		IDR_WHITE_TWT_DICE_4 },	// 35
	{ IDB_BIG_DICE,		IDR_WHITE_BIG_DICE_5 },	// 36
	{ IDB_BIG_DICE,		IDR_WHITE_TWT_DICE_5 },	// 37
	{ IDB_BIG_DICE,		IDR_WHITE_BIG_DICE_6 },	// 38
	{ IDB_BIG_DICE,		IDR_WHITE_TWT_DICE_6 },	// 39

	{ IDB_MEDIUM_DICE,	IDR_WHITE_MED_DICE_0 }, // 40
	{ IDB_MEDIUM_DICE,	IDR_WHITE_MED_DICE_1 }, // 41
	{ IDB_MEDIUM_DICE,	IDR_WHITE_MED_DICE_2 }, // 42
	{ IDB_MEDIUM_DICE,	IDR_WHITE_MED_DICE_3 }, // 43
	{ IDB_MEDIUM_DICE,	IDR_WHITE_MED_DICE_4 },	// 44
	{ IDB_MEDIUM_DICE,	IDR_WHITE_MED_DICE_5 },	// 45
	{ IDB_MEDIUM_DICE,	IDR_WHITE_MED_DICE_6 },	// 46

	{ IDB_SMALL_DICE,	IDR_WHITE_SML_DICE_0 },	// 47
	{ IDB_SMALL_DICE,	IDR_WHITE_SML_DICE_1 },	// 48
	{ IDB_SMALL_DICE,	IDR_WHITE_SML_DICE_2 },	// 49
	{ IDB_SMALL_DICE,	IDR_WHITE_SML_DICE_3 },	// 50
	{ IDB_SMALL_DICE,	IDR_WHITE_SML_DICE_4 },	// 51
	{ IDB_SMALL_DICE,	IDR_WHITE_SML_DICE_5 }, // 52
	{ IDB_SMALL_DICE,	IDR_WHITE_SML_DICE_6 }	// 53
};


static SpriteInfo CubeSprite[] =
{
	{ IDB_CUBE, IDR_CUBE_0 },
	{ IDB_CUBE,	IDR_CUBE_1 },
	{ IDB_CUBE, IDR_CUBE_2 },
	{ IDB_CUBE, IDR_CUBE_3 },
	{ IDB_CUBE, IDR_CUBE_4 },
	{ IDB_CUBE, IDR_CUBE_5 }
};


static SpriteInfo DoubleSprite[] =
{
	{ IDB_BUTTON, IDR_BUTTON_0 },
	{ IDB_BUTTON, IDR_BUTTON_1 },
	{ IDB_BUTTON, IDR_BUTTON_1 },
	{ IDB_BUTTON, IDR_BUTTON_2 },
	{ IDB_BUTTON, IDR_BUTTON_3 }
};


static SpriteInfo ResignSprite[] =
{
	{ IDB_BUTTON, IDR_BUTTON_0 },
	{ IDB_BUTTON, IDR_BUTTON_1 },
	{ IDB_BUTTON, IDR_BUTTON_1 },
	{ IDB_BUTTON, IDR_BUTTON_2 },
	{ IDB_BUTTON, IDR_BUTTON_3 }
};

static SpriteInfo RollSprite[] =
{
	{ IDB_BUTTON_ROLL, IDR_ROLLBUTTON_0 },
	{ IDB_BUTTON_ROLL, IDR_ROLLBUTTON_1 },
	{ IDB_BUTTON_ROLL, IDR_ROLLBUTTON_1 },
	{ IDB_BUTTON_ROLL, IDR_ROLLBUTTON_2 },
	{ IDB_BUTTON_ROLL, IDR_ROLLBUTTON_3 }
};

static SpriteInfo WhitePieceSprite[] =
{
	{ IDB_WHITE_FRONT,	-1 },
	{ IDB_WHITE_SIDE,	-1 }
};


static SpriteInfo BrownPieceSprite[] =
{
	{ IDB_BROWN_FRONT,	-1 },
	{ IDB_BROWN_SIDE,	-1 }
};


static SpriteInfo ForwardHighlightSprite[] =
{
	{ IDB_HIGHLIGHT, IDR_HIGHLIGHT_FORWARD }
};


static SpriteInfo BackwardHighlightSprite[] =
{
	{ IDB_HIGHLIGHT, IDR_HIGHLIGHT_BACKWARD },
	{ IDB_HIGHLIGHT, IDR_HIGHLIGHT_TRANS }
};

static SpriteInfo PlayerHighlightSprite[] =
{
	{ IDB_HIGHLIGHT_PLAYER, IDR_HIGHLIGHT_PACTIVE },
	{ IDB_HIGHLIGHT_PLAYER, IDR_HIGHLIGHT_PNONACTIVE }
};

/*
static SpriteInfo AvatarSprite[] =
{
	{ IDB_AVATAR, -1 }
};
*/

static SpriteInfo PipSprite[] =
{
	{ IDB_TEXT, IDR_PIP_SPRITE }
};


static SpriteInfo ScoreSprite[] =
{
	{ IDB_TEXT, IDR_SCORE_SPRITE }
};


/*
static SpriteInfo KibitzerSprite[] =
{
	{ IDB_KIBITZER, IDR_KIBITZER_ACTIVE },
	{ IDB_KIBITZER, IDR_KIBITZER_OFF }
};
*/

static SpriteInfo NotationSprite[] =
{
	{ IDB_NOTATION,	IDR_NOTATION_LOW },
	{ IDB_NOTATION, IDR_NOTATION_HIGH },
	{ IDB_NOTATION, IDR_NOTATION_BROWN },
	{ IDB_NOTATION, IDR_NOTATION_WHITE }
};


static SpriteInfo StatusSprite[] =
{
	// main bitmaps
	{ IDB_STATUS_BACKGROUND,	-1 },
	{ IDB_STATUS_GAME,			-1 },
	{ IDB_STATUS_MATCHWON,		-1 },
	{ IDB_STATUS_MATCHLOST,		-1 }
};
/*

enum UIRects
{
	IDR_DOUBLE_BUTTON,
	IDR_RESIGN_BUTTON,
	IDR_ROLL_BUTTON, 
	IDR_PLAYER_PIP,
	IDR_PLAYER_PIPTXT,
	IDR_OPPONENT_PIP, 
	IDR_OPPONENT_PIPTXT,
	IDR_PLAYER_SCORE, 
	IDR_PLAYER_SCORETXT,
	IDR_OPPONENT_SCORE,
	IDR_OPPONENT_SCORETXT,
	IDR_MATCH_POINTS,
	NUMUIRECTS
};


static CRect UIRects[] =
{
	{ IDR_DOUBLE_BUTTON,     _T("ButtonData\DoubleBtnRect")     },
	{ IDR_RESIGN_BUTTON,     _T("ButtonData\ResignBtnRect")     },
	{ IDR_ROLL_BUTTON,	     _T("ButtonData\RollBtnRect")       },
	{ IDR_PLAYER_PIP,	     _T("PipData\PlayerPipRect")	    },
	{ IDR_PLAYER_PIPTXT,     _T("PipData\PlayerPiptxtRect")	    },
	{ IDR_OPPONENT_PIP,	     _T("PipData\OpponentPipRect")	    },
	{ IDR_OPPONENT_PIPTXT,   _T("PipData\OpponentPipTxtRect")   },
	{ IDR_PLAYER_SCORE,	     _T("PipData\PlayerScoreRect")	    },
	{ IDR_PLAYER_SCORETXT,   _T("PipData\PlayerScoreTxtRect")   },
	{ IDR_OPPONENT_SCORE,    _T("PipData\OpponentScoreRect")    },
	{ IDR_OPPONENT_SCORETXT, _T("PipData\OpponentScoreTxtRect")	},
	{ IDR_MATCH_POINTS,      _T("PipData\MatchPointsRect")		}
};
*/
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\games\backgammon\states.cpp ===
#include "game.h"

class AutoRef
{
public:
	AutoRef( CGame* pGame )
	{
		m_pGame = pGame;
		m_pGame->AddRef();
	}

	~AutoRef()
	{
		m_pGame->Release();
	}

	CGame* m_pGame;
};


inline static void StateChange( CGame* const game, BOOL bCalledFromHandler, int state, int seat = -1 )
{
	// update shared properties
	if ( !bCalledFromHandler )
		game->m_SharedState.StartTransaction( bgTransStateChange );
	game->m_SharedState.Set( bgState, state );
	if ( (seat == 0) || (seat == 1) )
		game->m_SharedState.Set( bgActiveSeat, seat );
	if ( !bCalledFromHandler )
		game->m_SharedState.SendTransaction( FALSE );

	// cancel any status dialog state changes
	if ( game->m_Wnd.m_Status )
		game->m_Wnd.m_Status->SetNextState( bgStateUnknown );
}


void CGame::StateNotInitialized( BOOL bCalledFromHandler, BOOL bCalledFromRestoreGame )
{
	AutoRef ref(this);

	// shouldn't happen
	ASSERT( bCalledFromRestoreGame == FALSE );

	// never send this over the network
	StateChange( this, TRUE, bgStateNotInit, 0 );

	// disable buttons
	EnableDoubleButton( FALSE );
	EnableResignButton( FALSE );
	EnableRollButton( FALSE, TRUE );
}


void CGame::StateWaitingForGameState( BOOL bCalledFromHandler, BOOL bCalledFromRestoreGame )
{
	AutoRef ref(this);

	// shouldn't happen
	ASSERT( bCalledFromRestoreGame == FALSE );

	// never send this over the network
	StateChange( this, TRUE, bgStateWaitingForGameState, 0 );

	// disable buttons
	EnableDoubleButton( FALSE );
	EnableResignButton( FALSE );
	EnableRollButton( FALSE, TRUE );
	
	// request game state
	ZGameMsgGameStateRequest msg;
	msg.playerID = m_pMe->m_Id;
	msg.seat = m_pMe->m_Seat;
	ZGameMsgGameStateRequestEndian( &msg );
	RoomSend( zGameMsgGameStateRequest, &msg, sizeof(ZGameMsgGameStateRequest));

	// tell kibitzer what's going on
	/*
	if ( IsKibitzer() )
		m_Wnd.StatusDisplay( bgStatusNormal, IDS_WAIT_SYNCING, -1 );
	*/
}


void CGame::StateMatchSettings( BOOL bCalledFromHandler, BOOL bCalledFromRestoreGame )
{
	AutoRef ref(this);
	DWORD i, j, k;

	// shouldn't happen
	ASSERT( bCalledFromRestoreGame == FALSE );

	// close 'host is deciding to restore game' dialog
	if ( m_Wnd.m_Status->GetType() == bgStatusNormal )
		m_Wnd.StatusClose();

	// initiate the state change
	StateChange( this, bCalledFromHandler, bgStateGameSettings, 0 );

	// disable buttons
	EnableDoubleButton( FALSE );
	EnableResignButton( FALSE );
	EnableRollButton( FALSE, TRUE );

	// reset match variables
	NewMatch();
	
	// tell kibitzers what's going on
/*
	if ( IsKibitzer() )
	{
		m_Wnd.StatusDisplay( bgStatusNormal, IDS_WAIT_SETUP, -1 );
		return;
	}
*/
	// slow machines take too long setting up and lose packets, save
	// packets until we're ready for them.
	SetQueueMessages( TRUE );

	// If the status dialog is on the screen, we don't want to display
	// the setup dialog.  The status dialog notification handler will 
	// call us again when the dialog goes away
	if ( m_Wnd.m_Status->Enabled() )
		return;

	// Starting handling messages again
	SetQueueMessages( FALSE );

	/*
	// Get settings from registry
	if ( !ZoneGetRegistryDword( gGameRegName, "Match Points", &i ) )
		i = 1;
	if ( !ZoneGetRegistryDword( gGameRegName, "Host Brown",	&j ) )
		j = FALSE;
	if ( !ZoneGetRegistryDword( gGameRegName, "Auto Doubles", &k ) )
		k = FALSE;
	*/

	if ( IsHost() )
	{
		m_SharedState.StartTransaction( bgTransInitSettings );
			m_SharedState.Set( bgHostBrown, TRUE );
			m_SharedState.Set( bgAutoDouble, FALSE );
			m_SharedState.Set( bgTargetScore, MATCH_POINTS );
			m_SharedState.Set( bgSettingsDone, TRUE );			
		m_SharedState.SendTransaction( FALSE );
		// get on with the game
//		DeleteGame();
		SetState( bgStateInitialRoll );
	}

}


void CGame::StateInitialRoll( BOOL bCalledFromHandler, BOOL bCalledFromRestoreGame )
{
	AutoRef ref(this);	

	// initiate state change
	StateChange( this, bCalledFromHandler, bgStateInitialRoll, 0 );

	// close status window
	if ( m_Wnd.m_Status->GetType() == bgStatusNormal )
		m_Wnd.StatusClose();
	
	// reset flags for next match that are effected by race conditions
	m_SharedState.Set( bgSettingsDone, FALSE );
	m_SharedState.Set( bgSettingsReady, FALSE );

	// reset game variables
	if ( !bCalledFromRestoreGame )
	{
		NewGame();
        ZShellGameShell()->MyTurn();
//		PlaySound( bgSoundAlert );
	}

	//Only enable the roll button if the status sprite is not present.
	//if it is present set a flag to enable the roll button when the status 
	//sprite closes
	if ( !m_Wnd.m_Status->Enabled() )
	{
		EnableRollButton( TRUE );

		// disable buttons		
		EnableDoubleButton( FALSE );
		EnableResignButton( FALSE );

		m_Wnd.SetupRoll();
	}
	else
	{
		m_Wnd.m_Status->m_bEnableRoll = TRUE;
	}

	// copy state
	m_SharedState.Dump( m_TurnStartState, m_SharedState.GetSize() );
}


void CGame::StateRoll( BOOL bCalledFromHandler, BOOL bCalledFromRestoreGame )
{
	AutoRef ref(this);

	// initiate state change, toggle active seat
	if ( !bCalledFromHandler && !bCalledFromRestoreGame )
	{
		int seat = m_SharedState.Get( bgActiveSeat );
		StateChange( this, bCalledFromHandler, bgStateRoll, !seat );
	}
	else
		StateChange( this, bCalledFromHandler, bgStateRoll );
	
	m_Wnd.DrawPlayerHighlights();

	//Get the turn state
	InitTurnState( this, &m_TurnState );
		
	if ( m_SharedState.Get( bgActiveSeat ) == m_Player.m_Seat /*&& !IsKibitzer()*/ )
	{
		if ( m_TurnState.points[zMoveBar].pieces > 0 )	 //Check if we have any valid moves
		{											     //if not don't let them roll
			BOOL bCanMove = FALSE;

			//Check if theres room to place the bar piece on the opps home
			for (int x = zMoveOpponentHomeStart; x <= zMoveOpponentHomeEnd ; x++ )
			{
				if ( m_TurnState.points[x].pieces <= 1 || m_TurnState.points[x].color == m_Player.m_nColor )
				{
					bCanMove = TRUE;
					break;
				}
			}

			if ( bCanMove == FALSE ) //No valid moves no matter what is rolled
			{
				// notify player they can't move
				PlaySound( bgSoundMiss );
				m_Wnd.StatusDisplay( bgStatusNormal, IDS_MISS, 4000, -1 );

				SetState( bgStateEndTurn );

				/*
				ZBGMsgEndTurn msg;
				msg.seat = m_Seat;
				RoomSend( zBGMsgEndTurn, &msg, sizeof(msg) );
				*/

				// transaction to notify other people of the miss
				m_SharedState.StartTransaction( bgTransMiss );
				m_SharedState.SendTransaction( FALSE );

				return;

			}


		}

		// active player rolls dice and double
		m_SharedState.StartTransaction( bgTransDice );
			m_Wnd.m_nRecievedD1 = 0;
			m_Wnd.m_nRecievedD2 = 0;

			SetDice( m_Player.m_Seat, 0, 0 );
			SetDiceSize( m_Player.m_Seat, 0, 0 );
			SetDice( m_Opponent.m_Seat, -1, -1 );
			SetDiceSize( m_Opponent.m_Seat, 0, 0 );
		m_SharedState.SendTransaction( TRUE );
		
		EnableResignButton( TRUE );
		EnableDoubleButton( TRUE );
		EnableRollButton( TRUE );

		m_Wnd.SetupRoll();

	//PlaySound( bgSoundAlert );
    ZShellGameShell()->MyTurn();

	}
	else
	{
		m_Wnd.m_nRecievedD1 = -1;
		m_Wnd.m_nRecievedD2 = -1;

		// disable buttons
		EnableDoubleButton( FALSE );
		EnableResignButton( FALSE );
		EnableRollButton( FALSE, TRUE );
	}

	// copy state
	m_SharedState.Dump( m_TurnStartState, m_SharedState.GetSize() );
}


void CGame::StateDouble( BOOL bCalledFromHandler, BOOL bCalledFromRestoreGame )
{
	AutoRef ref(this);
	HRESULT hr;	
	TCHAR fmt[1024], buff[1024];
	int result;
	int value;
	
	// initiate state change
	StateChange( this, bCalledFromHandler, bgStateDouble );

	// disable buttons
	EnableResignButton( FALSE );
	EnableDoubleButton( FALSE );
	EnableRollButton( FALSE );

//	m_Wnd.m_pGAcc->GeneralDisable();

	/*
	if ( IsKibitzer() )
	{
		
		LoadString( m_hInstance, IDS_DOUBLE_KIBITZER, fmt, sizeof(fmt) );
		if ( m_SharedState.Get( bgActiveSeat ) == m_Player.m_Seat )
			wsprintf( buff, fmt, m_Player.m_Name, m_Opponent.m_Name );
		else
			wsprintf( buff, fmt, m_Opponent.m_Name, m_Player.m_Name );
		m_Wnd.StatusDisplay( bgStatusNormal, buff, -1 );
		
	}
	else
	{
	*/

	if ( m_SharedState.Get( bgActiveSeat ) == m_Player.m_Seat )
	{
		m_Wnd.StatusDisplay( bgStatusNormal, IDS_OFFER_DOUBLE, -2 );
	}
	else
	{
		value = m_SharedState.Get( bgCubeValue );
		
		hr = m_AcceptDoubleDlg.Init( ZShellZoneShell(), IDD_ACCEPT_DOUBLE, this, value * 2 );										
		
		hr = m_AcceptDoubleDlg.ModelessViaRegistration( m_Wnd );

        ZShellGameShell()->MyTurn();

			/*
			switch ( result )
			{
			case -1:
				// dialog prematurely closed, probably new match or exiting
				break;
			default:
				ASSERT( FALSE );
				break;
			}
			*/
	}
}


void CGame::StateRollPostDouble( BOOL bCalledFromHandler, BOOL bCalledFromRestoreGame )
{
	AutoRef ref(this);

	// don't send over the network
	StateChange( this, TRUE, bgStateRollPostDouble );
	
	m_Wnd.DrawPlayerHighlights();
	
	/*
	if ( IsKibitzer() )
	{
		EnableResignButton( FALSE );
		EnableDoubleButton( FALSE );
		EnableRollButton( FALSE );
		m_Wnd.StatusDisplay( bgStatusNormal, IDS_ACCEPTED_DOUBLE, 4000 );
	}
	*/

	//m_Wnd.m_pGAcc->GeneralEnable();

	if ( m_SharedState.Get( bgActiveSeat ) == m_Player.m_Seat )
	{
		// store cube value for notation pane
		m_TurnState.cube = m_SharedState.Get( bgCubeValue );

		// update status
		m_Wnd.StatusDisplay( bgStatusNormal, IDS_ACCEPTED_DOUBLE, 4000 );

		// set buttons
		EnableDoubleButton( FALSE );
		EnableResignButton( TRUE );
		EnableRollButton( TRUE );

        ZShellGameShell()->MyTurn();
	}
	else
	{
		// disable buttons
		EnableDoubleButton( FALSE );
		EnableResignButton( FALSE );
		EnableRollButton( FALSE, TRUE );
	}

	// copy state
	m_SharedState.Dump( m_TurnStartState, m_SharedState.GetSize() );
}


void CGame::StateRollPostResign( BOOL bCalledFromHandler, BOOL bCalledFromRestoreGame )
{
	AutoRef ref(this);

	// initiate state change
	StateChange( this, bCalledFromHandler, bgStateRollPostResign );

	if ( m_SharedState.Get( bgActiveSeat ) == m_Player.m_Seat )
	{
		EnableRollButton( TRUE );
        ZShellGameShell()->MyTurn();
	}
}


void CGame::StateMove( BOOL bCalledFromHandler, BOOL bCalledFromRestoreGame )
{
	AutoRef ref(this);
	
	// initiate state change
	StateChange( this, bCalledFromHandler, bgStateMove );

	// copy state
	m_SharedState.Dump( m_TurnStartState, m_SharedState.GetSize() );

	// diasble buttons
	EnableDoubleButton( FALSE );
	EnableResignButton( FALSE );
	EnableRollButton( FALSE, TRUE );

	if ( IsMyTurn() )
	{

		if ( !StartPlayersTurn() )
		{
			// notify player they can't move
			PlaySound( bgSoundMiss );
			
			m_Wnd.StatusDisplay( bgStatusNormal, IDS_MISS, 4000, bgStateEndTurn );

			//SetState( bgStateEndTurn );
			/*
            ZBGMsgEndTurn msg;
		    msg.seat = m_Seat;
		    RoomSend( zBGMsgEndTurn, &msg, sizeof(msg) );
			*/

			// transaction to notify other people of the miss
			m_SharedState.StartTransaction( bgTransMiss );
			m_SharedState.SendTransaction( FALSE );
		}
		else
			m_Wnd.SetupMove();

	}

	m_Wnd.DrawPlayerHighlights();
}


void CGame::StateEndTurn( BOOL bCalledFromHandler, BOOL bCalledFromRestoreGame )
{
	AutoRef ref(this);

	// don't send over network
	StateChange( this, TRUE, bgStateEndTurn );

	/*
	// kibitzers just watch
	if ( IsKibitzer() )
		return;
	*/

	m_Wnd.DisableBoard();

	/*
	// Print moves
	if ( IsMyTurn() )
		UpdateNotationPane( 0 );\
	*/

	// is the game over?
	if ( m_TurnState.points[zMoveHome].pieces >= 15 )
	{
		m_SharedState.StartTransaction( bgTransStateChange );
			m_SharedState.Set( bgState, bgStateGameOver );
			m_SharedState.Set( bgGameOverReason, bgGameOverNormal );
			m_SharedState.Set( bgActiveSeat, m_Player.m_Seat );
		m_SharedState.SendTransaction( TRUE );

        return;
	}

    if (!bCalledFromRestoreGame )
    {
        ZBGMsgEndTurn msg;
		msg.seat = m_Seat;
		RoomSend( zBGMsgEndTurn, &msg, sizeof(msg) );
    }

	// opponent's turn
	SetState( bgStateRoll );
}


void CGame::StateGameOver( BOOL bCalledFromHandler, BOOL bCalledFromRestoreGame )
{
	AutoRef ref(this);
	TCHAR fmt[512];
	TCHAR buff[512];
	int seat, bonus, score;

	// initiate state change
	StateChange( this, bCalledFromHandler, bgStateGameOver );

    if (!bCalledFromRestoreGame )
    {
        ZBGMsgEndTurn msg;
		msg.seat = m_Seat;
		RoomSend( zBGMsgEndGame, &msg, sizeof(msg) );

    }


	// disable buttons
	EnableDoubleButton( FALSE );
	EnableResignButton( FALSE );
	EnableRollButton( FALSE, TRUE );

	if ( !bCalledFromRestoreGame )
	{
		// calculate new score
		seat = m_SharedState.Get( bgActiveSeat );
		switch ( m_SharedState.Get( bgGameOverReason ) )
		{
		case bgGameOverNormal:			
			m_GameScore = m_SharedState.Get( bgCubeValue ) * CalcBonusForSeat( seat );
			break;
		case bgGameOverDoubleRefused:
			m_GameScore = m_SharedState.Get( bgCubeValue );
			break;
		case bgGameOverResign:
			m_GameScore = m_SharedState.Get( bgResignPoints );
			break;
		default:
			ASSERT( FALSE );
		}

		// update score on screen
		score = m_SharedState.Get( bgScore, seat ) + m_GameScore;
		m_SharedState.Set( bgScore, seat, score );
		m_Wnd.DrawScore( TRUE );
		
		// update crawford counter
		if ( m_SharedState.Get( bgCrawford ) < 0 )
		{
			if ( score >= (m_SharedState.Get( bgTargetScore ) - 1) )
				m_SharedState.Set( bgCrawford, !seat );
		}
		else
		{
			m_SharedState.Set( bgCrawford, 3 );
		}

		// is the match over?
		if ( score >= m_SharedState.Get( bgTargetScore ) )
		{
            m_GameStarted=FALSE;

			if ( IsHost() )
				SetState( bgStateMatchOver );
			return;
		}

		// print game over
		/*
		if ( IsMyTurn() )
			UpdateNotationPane( 1 );
		*/
	}

	// notify players of winner
	/*
	if ( IsKibitzer() )
	{
		
		LoadString( m_hInstance, IDS_WON_KIBITZER, fmt, sizeof(fmt) );
		if ( m_SharedState.Get( bgActiveSeat ) == m_Player.m_Seat )
			wsprintf( buff, fmt, m_Player.m_Name, m_GameScore );
		else
			wsprintf( buff, fmt, m_Opponent.m_Name, m_GameScore );

		m_Wnd.StatusDisplay( bgStatusGameover | bgStatusKibitzer, buff, 10000, bgStateInitialRoll );
		PlaySound( bgSoundGameWin );
	}
	*/
/*
	//If the roll items are still on the stack pop them off... 
	if ( m_Wnd.m_pGAcc->GetStackSize() == accRollLayer )
	{
		m_Wnd.m_pGAcc->PopItemlist();
	}
*/

	if ( m_SharedState.Get( bgActiveSeat ) == m_Player.m_Seat )
	{
		
		if ( m_SharedState.Get( bgGameOverReason ) == bgGameOverNormal )			
			ZShellResourceManager()->LoadString( IDS_WON, fmt, 512 );
		else
			ZShellResourceManager()->LoadString( IDS_WON_RESIGN, fmt, 512 );
		
		BkFormatMessage( fmt, buff, 512, m_GameScore );
		m_Wnd.StatusDisplay( bgStatusGameover | bgStatusWinner, buff, 10000, bgStateInitialRoll );
		PlaySound( bgSoundGameWin );
	}
	else
	{			
		ZShellResourceManager()->LoadString( IDS_LOST, fmt, 512 );

		BkFormatMessage( fmt, buff, 512, m_GameScore );
		m_Wnd.StatusDisplay( bgStatusGameover | bgStatusLoser, buff, 10000, bgStateInitialRoll );
		PlaySound( bgSoundGameLose );
	}



	if ( IsHost() )
		SetState( bgStateInitialRoll );

}


void CGame::StateMatchOver( BOOL bCalledFromHandler, BOOL bCalledFromRestoreGame )
{
	AutoRef ref(this);
	TCHAR buff[512];
	TCHAR fmt[512];

	// shouldn't happen
	ASSERT( bCalledFromRestoreGame == FALSE );

	// initiate state change
	StateChange( this, bCalledFromHandler, bgStateMatchOver );

	// disable buttons
	EnableDoubleButton( FALSE );
	EnableResignButton( FALSE );
	EnableRollButton( FALSE, TRUE );

	// notify players of winner
	if ( IsKibitzer() )
	{
		/*
		LoadString( m_hInstance, IDS_WON_MATCH_KIBITZER, fmt, sizeof(buff) );
		if ( m_SharedState.Get( bgActiveSeat ) == m_Player.m_Seat )
			wsprintf( buff, fmt, m_Player.m_Name );
		else
			wsprintf( buff, fmt, m_Opponent.m_Name );
		m_Wnd.StatusDisplay( bgStatusMatchover | bgStatusKibitzer, buff, 15000, bgStateGameSettings );
		PlaySound( bgSoundMatchWin );
		*/
	}
	else if ( m_SharedState.Get( bgActiveSeat ) == m_Player.m_Seat )
	{
//		LoadString( m_hInstance, IDS_WON_MATCH, buff, sizeof(buff) );
		m_Wnd.StatusDisplay( bgStatusMatchover | bgStatusWinner, buff, 15000, bgStateGameSettings);
		PlaySound( bgSoundMatchWin );
	}
	else
	{
//		LoadString( m_hInstance, IDS_LOST_MATCH, buff, sizeof(buff) );
		m_Wnd.StatusDisplay( bgStatusMatchover | bgStatusLoser, buff, 15000, bgStateGameSettings );
		PlaySound( bgSoundMatchLose );
	}

	// host notifies server of winner
	if ( IsHost() && !m_bSentMatchResults )
	{
		ZBGMsgEndLog log;
		log.numPoints = m_SharedState.Get( bgTargetScore );
		if (m_SharedState.Get( bgActiveSeat ) == 0)
			log.seatLosing =1;
		else
			log.seatLosing =0;

		log.reason=zBGEndLogReasonGameOver;
		
		RoomSend( zBGMsgEndLog, &log, sizeof(log) );
		m_bSentMatchResults = TRUE;
	}

	/*
	Put the upsell dialog up
	*/
	
/*	ZShellGameShell()->GameOver(this);*/
	
	// Print match over
	/*
	if ( IsMyTurn() )
		UpdateNotationPane( 2 );
	*/
}


void CGame::StateDelete( BOOL bCalledFromHandler, BOOL bCalledFromRestoreGame )
{
	// shouldn't happen
	ASSERT( bCalledFromRestoreGame == FALSE );

	// never send this over the network
	StateChange( this, TRUE, bgStateDelete, 0 );

	// mark object as going away
	m_bDeleteGame = TRUE;
}


void CGame::StateCheckSavedGame( BOOL bCalledFromHandler, BOOL bCalledFromRestoreGame )
{
	AutoRef ref(this);

	// shouldn't happen
	ASSERT( bCalledFromRestoreGame == FALSE );

	// never send this over the network
	StateChange( this, TRUE, bgStateCheckSavedGame, 0 );
/*
	// kibitzers don't have saved games
	if ( IsKibitzer() )
	{
		m_Wnd.StatusDisplay( bgStatusNormal, IDS_WAIT_SETUP, -1 );
		return;
	}
*/
	// load game time stamp
	m_SharedState.StartTransaction( bgTransTimestamp );
		LoadGameTimestamp();
	m_SharedState.SendTransaction( TRUE );
}


void CGame::StateRestoreSavedGame( BOOL bCalledFromHandler, BOOL bCalledFromRestoreGame )
{


	ASSERT( FALSE );

	/*
	AutoRef ref(this);
	DWORD hi0, hi1, lo0, lo1;
	int seat;

	// shouldn't happen
	ASSERT( bCalledFromRestoreGame == FALSE );

	// initiate the state change
	StateChange( this, bCalledFromHandler, bgStateRestoreSavedGame, 0 );

	// tell players what the host is doing
	if ( !IsHost() )
	{
		m_Wnd.StatusDisplay( bgStatusNormal, IDS_WAIT_RESTORE, -1 );
		return;
	}

	// ask user if they want to restore a saved game
	m_RestoreDlg.Init( m_hInstance, IDD_RESTORE_GAME, m_Opponent.m_Name );
	m_RestoreDlg.Modal( m_Wnd );
	if ( m_RestoreDlg.GetResult() == IDCANCEL )
	{
		SetState( bgStateGameSettings );
		return;
	}

	// pick the seat with highest timestamp
	hi0 = m_SharedState.Get( bgTimestampHi, 0 );
	hi1 = m_SharedState.Get( bgTimestampHi, 1 );
	if ( hi0 > hi1 )
		seat = m_Player.m_Seat;
	else if ( hi0 < hi0 )
		seat = m_Opponent.m_Seat;
	else
	{
		lo0 = m_SharedState.Get( bgTimestampLo, 0 );
		lo1 = m_SharedState.Get( bgTimestampLo, 1 );
		if ( lo0 >= lo1 )
			seat = m_Player.m_Seat;
		else if ( lo0 < lo1 )
			seat = m_Opponent.m_Seat;
	}
	m_SharedState.StartTransaction( bgTransRestoreGame );
		m_SharedState.Set( bgActiveSeat, seat );
	m_SharedState.SendTransaction( TRUE );

	// close status dialog
	m_Wnd.StatusClose();
	*/
}


void CGame::StateNewMatch( BOOL bCalledFromHandler, BOOL bCalledFromRestoreGame )
{
	AutoRef ref(this);

	// shouldn't happen
	ASSERT( bCalledFromRestoreGame == FALSE );

	// initiate state change
	StateChange( this, bCalledFromHandler, bgStateNewMatch );

	// clean up dialogs
	CloseAllDialogs( FALSE );

	// disable buttons
	EnableDoubleButton( FALSE );
	EnableResignButton( FALSE );
	EnableRollButton( FALSE, TRUE );

	// notify players of new match
	m_Wnd.StatusDisplay( bgStatusNormal, IDS_MATCH_RESET, 5000, bgStateGameSettings );
}


void CGame::StateResignOffer( BOOL bCalledFromHandler, BOOL bCalledFromRestoreGame  )
{
	AutoRef ref(this);

	// initiate state change
	StateChange( this, bCalledFromHandler, bgStateResignOffer );

	// only active player does anything in this state
	if ( IsKibitzer() || (m_SharedState.Get( bgActiveSeat ) != m_Player.m_Seat) )
		return;

	// display resign dialog
	m_ResignDlg.Init( ZShellZoneShell(), IDD_RESIGN, m_SharedState.Get( bgCubeValue ) , this);
	m_ResignDlg.ModelessViaRegistration( m_Wnd );

	/*
	m_ResignDlg.ModelessViaThread( m_Wnd, WM_BG_RESIGN_START, WM_BG_RESIGN_END );
	*/
}


void CGame::StateResignAccept( BOOL bCalledFromHandler, BOOL bCalledFromRestoreGame )
{
	AutoRef ref(this);
	TCHAR fmt[512], buff[512];
	int pts;

	// initiate state change
	StateChange( this, bCalledFromHandler, bgStateResignAccept );

	// how many points are at stake?
	pts = m_SharedState.Get( bgResignPoints );

	/*
	// tell kibitzers what's going on
	if ( IsKibitzer() )
	{
		
		LoadString( m_hInstance, IDS_RESIGN_KIBITZER, fmt, sizeof(fmt) );
		if ( m_SharedState.Get( bgActiveSeat ) == m_Player.m_Seat )
			wsprintf( buff, fmt, m_Player.m_Name, pts );
		else
			wsprintf( buff, fmt, m_Opponent.m_Name, pts );
		m_Wnd.StatusDisplay( bgStatusNormal, buff, -1 );
		
	}
	*/

	// tell player to wait
	if ( m_SharedState.Get( bgActiveSeat ) == m_Player.m_Seat )
	{
		m_Wnd.StatusDisplay( bgStatusNormal, IDS_RESIGN_WAIT, -1 );
	}

	// prompt for response
	else
	{
		m_ResignAcceptDlg.Init( ZShellZoneShell(), IDD_RESIGN_ACCEPT, pts, this );
		m_ResignAcceptDlg.ModelessViaRegistration( m_Wnd );

        ZShellGameShell()->MyTurn();
		/*
		m_ResignAcceptDlg.ModelessViaThread( m_Wnd, WM_BG_RESIGN_START, WM_BG_RESIGNACCEPT_END );
		*/
	}
}


void CGame::StateResignRefused( BOOL bCalledFromHandler, BOOL bCalledFromRestoreGame )
{
	AutoRef ref(this);
	TCHAR fmt[512], buff[512];

	// initiate state change
	StateChange( this, bCalledFromHandler, bgStateResignRefused );

	EnableRollButton( FALSE, TRUE );
	EnableResignButton( FALSE );
	EnableDoubleButton( FALSE );

	// update status
	if ( IsKibitzer() || (m_SharedState.Get( bgActiveSeat ) == m_Player.m_Seat) )
		m_Wnd.StatusDisplay( bgStatusNormal, IDS_RESIGN_REFUSED, 5000 );

	// go back to rolling the dice
	if ( IsHost() )
		SetState( bgStateRollPostResign );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\games\backgammon\sprites.h ===
#ifndef __SPRITES_H__
#define __SPRITES_H__

#include "game.h"

enum SpritesTypes
{
	bgSpriteCube,
	bgSpriteOpponentsDice,
	bgSpritePlayersDice,
	bgSpriteDouble,
	bgSpriteResign,
	bgSpriteRoll,
	bgSpriteWhitePiece,
	bgSpriteBrownPiece,
	bgSpriteForwardHighlight,
	bgSpriteBackwardHighlight,
	bgSpritePlayerHighlight,
	bgSpriteAvatar,
	bgSpritePip,
	bgSpriteScore,
	bgSpriteName,
	bgSpriteScoreTxt,
	bgSpritePipTxt,
	bgSpriteMatchTxt,
	bgSpriteKibitzerOpponent,
	bgSpriteKibitzerPlayer,
	bgSpriteNotation,
	bgSpriteStatus,
	bgSpriteButtonText,
	bgSpriteStatusGameWonTxt,
	bgSpriteStatusGameLostTxt,
	bgSpriteStatusMatchWonTxt,
	bgSpriteStatusMatchLostTxt,
	bgSpriteStatusNormal
};


enum StatusTypes
{
	bgStatusUnknown			= 0x00000000,
	bgStatusWinner			= 0x00000001,
	bgStatusLoser			= 0x00000002,
	bgStatusKibitzer		= 0x00000003,

	bgStatusNormal			= 0x00000010,
	bgStatusGameover		= 0x00000020,
	bgStatusMatchover		= 0x00000030,

	bgStatusTypeMask		= 0x000000f0,
	bgStatusDetailMask		= 0x0000000f
};


class CPieceSprite : public CDibSprite
{
public:
	void SetLowerIndex( int LowerIdx ) { m_LowerIdx = LowerIdx; }
	void SetIndex( int idx )		   { m_Idx = idx;		}
	void SetPoint( int point )		   { m_Point = point;	}
	int  GetWhitePoint()			   { return m_Point;	}
	int  GetIndex()					   { return m_Idx;		}

public:
	// board and shared state
	int	m_Point;
	int m_Idx;
	int m_LowerIdx;

	// animation
	POINT	start;
	POINT	end;
	POINT	ctrl;
	double	time;
	int		destEnd;
};


class CTextSprite : public CSprite
{
public:
	CTextSprite();
	~CTextSprite();

	void Offset(long x, long y) { SetXY(m_X +x ,m_Y + y); }
	void Draw();
	void SetText( TCHAR* txt, DWORD flags = DT_LEFT | DT_TOP );
	void SetFont( HFONT Font )			{ font = Font; }
	void SetColor( COLORREF Color )		{ color = Color; }
	void Update()						{ m_pWorld->Modified( this );}
	BOOL Load( UINT uID, TCHAR* szRectKey, TCHAR* szFontKey, TCHAR* szColourKey, DWORD flags = DT_LEFT | DT_TOP);

protected:
	TCHAR		buff[256];
	int			len;
	COLORREF	color;
	HFONT		font;
	DWORD		txtFlags;
};


class CButtonTextSprite: public CDibSprite
{
	public:
		CButtonTextSprite() : m_pText(NULL), m_bInit(FALSE)
		{};
		~CButtonTextSprite(){};
		void SetEnable( BOOL bEnable );
		void SetState( int idx );
		BOOL LoadButtonData(UINT uID, TCHAR *szButtonData);

	protected:
		CTextSprite*    m_pText;
		CTextSprite		m_arText[5];		
		FRX::CRect			m_pressRect;
		FRX::CRect			m_NormRect;
		BOOL			m_bInit;
};


class CStatusSprite : public CDibSprite
{
public:
	CStatusSprite();
	~CStatusSprite();
	void Properties( HWND hwnd, FRX::CRectList& rects, int type, int timeout, TCHAR* txt, int NextState );
	void Draw();
	BOOL Tick( HWND hwnd, int interval );

	// properties
	int GetNextState()						{ return m_NextState; }
	int GetType()							{ return m_Type & bgStatusTypeMask; }
	void SetNextState( int NextState )		{ m_NextState = NextState; }
	HRESULT LoadText(HINSTANCE hInstance, FRX::CRectList& rects);

	BOOL		 m_bEnableRoll;

protected:
	TCHAR		 m_Txt[ 2048 ];
	int			 m_Len;
	int			 m_Type;
	int			 m_Timeout;
	/*
	HFONT		 m_hFont;
	*/
	CDibLite*	 m_pOverDib;
	FRX::CRect	 m_rcOver;
	FRX::CRect	 m_rcTxt;
	DWORD		 m_TxtFlags;
	COLORREF	 m_TxtColor;
	int			 m_NextState;
	
	CTextSprite* m_NormalText;

	CTextSprite* m_GameText;
	CTextSprite* m_GameWon;
	CTextSprite* m_GameLost;

	CTextSprite* m_Match;
	CTextSprite* m_MatchWon;
	CTextSprite* m_MatchLost;

	CTextSprite* m_Active[3];
	
	POINT		 m_Pts[3];

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\games\checkers\init.cpp ===
/*******************************************************************************

	init.cpp
	
		Zone(tm) game main file.
	
	Copyright (c) Microsoft Corp. 1996. All rights reserved.
	Written by Hoon Im
	Created on December 11, 1996.
	
	Change History (most recent first):
	----------------------------------------------------------------------------
	Rev	 |	Date	 |	Who	 |	What
	----------------------------------------------------------------------------
	0		12/11/96	HI		Created.
	 
*******************************************************************************/
#include "BasicATL.h"

#include <ZoneShell.h>

CZoneComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
END_OBJECT_MAP()


/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE
/////////////////////////////////////////////////////////////////////////////

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type
/////////////////////////////////////////////////////////////////////////////

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/****************************************************************************
   FUNCTION: DllMain(HANDLE, DWORD, LPVOID)

   PURPOSE:  DllMain is called by Windows when
             the DLL is initialized, Thread Attached, and other times.
             Refer to SDK documentation, as to the different ways this
             may be called.


*******************************************************************************/
extern "C"
BOOL APIENTRY DllMain( HMODULE hMod, DWORD dwReason, LPVOID lpReserved )
{
    BOOL bRet = TRUE;

    switch( dwReason )
    {
        case DLL_PROCESS_ATTACH:
		    _Module.Init(ObjectMap, hMod);
		    //DisableThreadLibraryCalls(hInstance);
            // fall thru, b/c this is the first thread attach as well
        case DLL_THREAD_ATTACH:
            // allocate memory and use TlsSetValue
            break;

        case DLL_THREAD_DETACH:
            // free memory retrieved by TlsGetValue
            break;

        case DLL_PROCESS_DETACH:
        	_Module.Term();
            break;
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\games\checkers\checklib.cpp ===
/*
** Checkerslib.c
*/

#include "zone.h"
#include "checklib.h"
#include "checkmov.h"
#include "zonecrt.h"
#include "zonemem.h"

#define ZCheckersPlayerWhiteToMove(pCheckers) ((pCheckers->moves & 1) == 1)

#define zCheckersHistoryMallocIncrement 8

typedef struct {
	ZCheckersState state; 
	ZCheckersState oldState;
	ZCheckersSquare squaresChanged[12];

	/* the number of moves made */
	uint16 moves; 
} ZCheckersI;

int16 ZCheckersIsLegalMoveInternal(ZCheckers checkers, ZCheckersMoveTry *pTry);
void ZCheckersStateEndian(ZCheckersState* state);
void ZCheckersIEndian(ZCheckersI* pCheckers, int16 conversion);

ZCheckersBoard gBoardStart = {  
								zCheckersPieceBlackPawn, zCheckersPieceNone, zCheckersPieceBlackPawn, zCheckersPieceNone,
								zCheckersPieceBlackPawn, zCheckersPieceNone, zCheckersPieceBlackPawn, zCheckersPieceNone,

								zCheckersPieceNone, zCheckersPieceBlackPawn, zCheckersPieceNone, zCheckersPieceBlackPawn,
								zCheckersPieceNone, zCheckersPieceBlackPawn, zCheckersPieceNone, zCheckersPieceBlackPawn,

								zCheckersPieceBlackPawn, zCheckersPieceNone, zCheckersPieceBlackPawn, zCheckersPieceNone,
								zCheckersPieceBlackPawn, zCheckersPieceNone, zCheckersPieceBlackPawn, zCheckersPieceNone,

								zCheckersPieceNone, zCheckersPieceNone, zCheckersPieceNone, zCheckersPieceNone,
								zCheckersPieceNone, zCheckersPieceNone, zCheckersPieceNone, zCheckersPieceNone,

								zCheckersPieceNone, zCheckersPieceNone, zCheckersPieceNone, zCheckersPieceNone,
								zCheckersPieceNone, zCheckersPieceNone, zCheckersPieceNone, zCheckersPieceNone,

								zCheckersPieceNone, zCheckersPieceWhitePawn, zCheckersPieceNone, zCheckersPieceWhitePawn,
								zCheckersPieceNone, zCheckersPieceWhitePawn, zCheckersPieceNone, zCheckersPieceWhitePawn,

								zCheckersPieceWhitePawn, zCheckersPieceNone, zCheckersPieceWhitePawn, zCheckersPieceNone,
								zCheckersPieceWhitePawn, zCheckersPieceNone, zCheckersPieceWhitePawn, zCheckersPieceNone,

								zCheckersPieceNone, zCheckersPieceWhitePawn, zCheckersPieceNone, zCheckersPieceWhitePawn,
								zCheckersPieceNone, zCheckersPieceWhitePawn, zCheckersPieceNone, zCheckersPieceWhitePawn
						};

/*-------------------------------------------------------------------------------*/
ZCheckers ZCheckersNew()
{
	ZCheckersI* pCheckers = (ZCheckersI*)ZMalloc(sizeof(ZCheckersI));

	if (pCheckers)
		pCheckers->moves = 0;

	return (ZCheckers)pCheckers;
}

void ZCheckersDelete(ZCheckers checkers)
{
	ZCheckersI* pCheckers = (ZCheckersI*)checkers;

	ZFree(pCheckers);
}

void ZCheckersInit(ZCheckers checkers)
{
	ZCheckersI* pCheckers = (ZCheckersI*)checkers;
	pCheckers->moves = 0;
	/* required, boolean flags must be zero'd */
	z_memset(&pCheckers->state,0,sizeof(ZCheckersState));
	/*pCheckers->state.nCapturedPieces = 0;*/
	pCheckers->state.capturedPieces[0] = zCheckersPieceNone;
	pCheckers->state.nPlayer = zCheckersPlayerBlack;
	z_memcpy((void*)pCheckers->state.board, (void*)gBoardStart, sizeof(ZCheckersBoard));

	/* copy the new state */
	z_memcpy(&pCheckers->oldState,&pCheckers->state,sizeof(ZCheckersState));
}

ZCheckersPiece ZCheckersPieceAt(ZCheckers checkers, ZCheckersSquare* pSquare)
/* returns id of piece at this square, return 0 if no piece */
{
	ZCheckersI* pCheckers = (ZCheckersI*)checkers;
	return (pCheckers->state.board[pSquare->row][pSquare->col]);
}

void ZCheckersPlacePiece(ZCheckers checkers, ZCheckersSquare* pSquare, ZCheckersPiece nPiece)
{
	ZCheckersI* pCheckers = (ZCheckersI*)checkers;
	pCheckers->state.board[pSquare->row][pSquare->col] = nPiece;
}

// Barna 091099
//ZBool ZCheckersIsLegalMoveInternal(ZCheckers checkers, ZCheckersMoveTry* pTry)
int16 ZCheckersIsLegalMoveInternal(ZCheckers checkers, ZCheckersMoveTry* pTry)
{
	ZCheckersI* pCheckers = (ZCheckersI*)checkers;
	ZCheckersPiece nPiece;

	/* is there a piece there? */
	nPiece = ZCheckersPieceAt(checkers, &pTry->move.start);
	if (!nPiece) {
		return zOtherIllegalMove;
	}

	/* is it this players turn? */
	if ((ZCheckersPlayerWhiteToMove(pCheckers) && ZCheckersPieceColor(nPiece) != zCheckersPieceWhite) ||
		(!ZCheckersPlayerWhiteToMove(pCheckers) && ZCheckersPieceColor(nPiece) != zCheckersPieceBlack) ) {
		return zOtherIllegalMove;
	}

	/* check to see if it is legal */
	// Barna 091099
	return ZCheckersPieceCanMoveTo(pTry);
	/*if (!ZCheckersPieceCanMoveTo(pTry)) { 
		return FALSE; 
	}

	return zCorrectMove;*/
	// Barna 091099
}

// Barna 091099
//ZBool ZCheckersIsLegalMove(ZCheckers checkers, ZCheckersMove* pMove)
int16 ZCheckersIsLegalMove(ZCheckers checkers, ZCheckersMove* pMove)
/* returns true if this is a legal move */
{
	ZCheckersI* pCheckers = (ZCheckersI*)checkers;
	ZCheckersMoveTry zChkTry;
	int16 rval;

	zChkTry.move = *pMove;
	z_memcpy(&zChkTry.state,&pCheckers->state,sizeof(ZCheckersState));
	rval = ZCheckersIsLegalMoveInternal(checkers, &zChkTry);
	return rval;
}

ZCheckersPiece* ZCheckersGetCapturedPieces(ZCheckers checkers)
{
	ZCheckersI* pCheckers = (ZCheckersI*)checkers;
	return pCheckers->state.capturedPieces;
}

void ZCheckersCalcSquaresChanged(ZCheckers checkers, ZCheckersState* state0, ZCheckersState* state1)
{
	ZCheckersI* pCheckers = (ZCheckersI*)checkers;
	int16 cnt;
	BYTE i,j;

	/* find the squares that changed so we can return them */
	cnt = 0;
	for (i = 0;i < 8;i ++) {
		for (j = 0; j < 8; j++) {
			if (state0->board[i][j] != state1->board[i][j]) {
				pCheckers->squaresChanged[cnt].row = i;
				pCheckers->squaresChanged[cnt].col = j;
				cnt++;
			}
		}
	}
	pCheckers->squaresChanged[cnt].row = zCheckersSquareNone;
	pCheckers->squaresChanged[cnt].col = zCheckersSquareNone;
}

void ZCheckersEndGame(ZCheckers checkers,  uint32 flags)
{
	ZCheckersI* pCheckers = (ZCheckersI*)checkers;

	pCheckers->state.flags = flags;

	/* advance to next move, there will be none */
	ZCheckersFinishMove(checkers, (int32*)&flags);
}

ZCheckersSquare* ZCheckersMakeMove(ZCheckers checkers, ZCheckersMove* pMove, ZCheckersPiece* pPiece, int32* flags)
/* makes the given move, returns NULL if illegal */ 
{
	ZCheckersI* pCheckers = (ZCheckersI*)checkers;
	ZCheckersMoveTry zChkTry;

	zChkTry.move = *pMove;
	z_memcpy(&zChkTry.state,&pCheckers->state,sizeof(ZCheckersState));
	zChkTry.state.flags = 0;

	// Barna 091099
	/*if (!ZCheckersIsLegalMoveInternal(checkers, &zChkTry)) {
		return NULL;
	}*/
	if (ZCheckersIsLegalMoveInternal(checkers, &zChkTry) != zCorrectMove) {
		return NULL;
	}
	// Barna 091099

	if (zChkTry.capture) {
		pCheckers->state.capturedPieces[pCheckers->state.nCapturedPieces] = zChkTry.capture;
		pCheckers->state.nCapturedPieces++;
		pCheckers->state.capturedPieces[pCheckers->state.nCapturedPieces] = zCheckersPieceNone; 
	}

	/* copy the new state */
	z_memcpy(&pCheckers->oldState,&pCheckers->state,sizeof(ZCheckersState));

	/* copy the new state */
	z_memcpy(&pCheckers->state,&zChkTry.state,sizeof(ZCheckersState));

	/* find the squares that changed so we can return them */
	ZCheckersCalcSquaresChanged(checkers, &pCheckers->state, &pCheckers->oldState);

	/* update the piece that changed */
	*pPiece = zChkTry.capture; 
	*flags = pCheckers->state.flags;

	return pCheckers->squaresChanged;
}

/* finish the MakeMove, allows for pawn promotion */
/* caller should do ZCheckersSetPiece to change piece type then call FinishMove */
/* must be called after each ZCheckersMakeMove Call */
ZCheckersSquare* ZCheckersFinishMove(ZCheckers checkers, int32* flags)
{
	ZCheckersI* pCheckers = (ZCheckersI*)checkers;

	/* calc the flags (like check, checkmate) */
	ZCheckersCheckCheckmateFlags(&pCheckers->state);

	/* find the squares that changed so we can return them */
	ZCheckersCalcSquaresChanged(checkers, &pCheckers->state, &pCheckers->oldState);

	pCheckers->moves++;
	pCheckers->state.nPlayer = (pCheckers->state.nPlayer+1) & 1;

	*flags = pCheckers->state.flags;
	return pCheckers->squaresChanged;
}

int32 ZCheckersPlayerToMove(ZCheckers checkers)
/* returns the player to move: zCheckersPlayerWhite or zCheckersPlayerBlack */
{
	ZCheckersI* pCheckers = (ZCheckersI*)checkers;
	return pCheckers->state.nPlayer;
}

ZBool ZCheckersGetMove(ZCheckers checkers, ZCheckersMove* move, int16 moveNum)
/* the argument moveNum is user visible move num, internally */
/* moves are counted twice as fast */
{
	ZCheckersI* pCheckers = (ZCheckersI*)checkers;

	*move = pCheckers->state.lastMove;
	return TRUE;
}

int16 ZCheckersNumMovesMade(ZCheckers checkers)
{
	ZCheckersI* pCheckers = (ZCheckersI*)checkers;

	/* return the move # we are on, round up */

	return pCheckers->moves;
}

uint32 ZCheckersGetFlags(ZCheckers checkers)
/* returns the flags for the move */
{
	ZCheckersI* pCheckers = (ZCheckersI*)checkers;
	return pCheckers->state.flags;
}


ZBool ZCheckersIsGameOver(ZCheckers checkers, int16* score)
{
	ZCheckersI* pCheckers = (ZCheckersI*)checkers;
	int16	lastMove = ZCheckersNumMovesMade(checkers)-1;
	int16 	player = (lastMove+1)&1;

	{
		uint32 flags;

		flags = ZCheckersGetFlags(checkers);

		/* did the player resign or lose on time? */
		if ((zCheckersFlagResign) & flags)
		{
			if (player == zCheckersPlayerWhite)
				*score = zCheckersScoreWhiteWins;
			else
				*score = zCheckersScoreBlackWins;
			return TRUE;
		}

		/* is the player in checkmate */
		if ((zCheckersFlagStalemate) & flags)
		{
			if (player == zCheckersPlayerWhite)
				*score = zCheckersScoreBlackWins;
			else
				*score = zCheckersScoreWhiteWins;
			return TRUE;
		}

		/* is it a draw */
		if ((zCheckersFlagDraw) & flags)
		{
			*score = zCheckersScoreDraw;
			return TRUE;
		}
	}

	/* not game over */
	return FALSE;
}

void ZCheckersStateEndian(ZCheckersState* state)
{
	ZEnd16(&state->nMoves);
	ZEnd32(&state->flags);
}


void ZCheckersIEndian(ZCheckersI* pCheckers, int16 conversion)
{
	ZCheckersStateEndian(&pCheckers->state);
	ZEnd16(&pCheckers->moves);
}

int32 ZCheckersGetStateSize(ZCheckers checkers)
{
	ZCheckersI* pCheckers = (ZCheckersI*)checkers;
	int32 size;

	size = sizeof(ZCheckersI);
	return size;
}

void ZCheckersGetState(ZCheckers checkers, void* buffer)
{
	ZCheckersI* pCheckers = (ZCheckersI*) checkers;
	TCHAR* p0 = (TCHAR*)buffer;
	TCHAR* p = p0;

	/* copy the CheckersI structure */
	z_memcpy((void*)p,(void*)pCheckers,sizeof(ZCheckersI));
	p += sizeof(ZCheckersI);

	/* endianize the whole mess */
	ZCheckersIEndian((ZCheckersI*)p0, zEndianToStandard);
}

ZCheckers ZCheckersSetState(void* buffer)
{
	ZCheckersI* pCheckers = NULL;
	TCHAR* p = (TCHAR*)buffer;

	/* endianize the new checkers state */
	ZCheckersIEndian((ZCheckersI*) buffer, zEndianFromStandard); /* history assumed to follow ZCheckersState */

	/* set the new state */
	pCheckers = (ZCheckersI*)ZMalloc(sizeof(ZCheckersI));
	if (!pCheckers)
		return NULL;

	z_memcpy(pCheckers,p,sizeof(ZCheckersI));
	p += sizeof(ZCheckersI);

	return (ZCheckers)pCheckers;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\games\checkers\checkers.cpp ===
/*******************************************************************************

	Checkers.c

	The client checkers game.

	Notes:
	1.	The game window's userData field contains the game object.
		Dereference this value to access needed information.

	Copyright  Electric Gravity, Inc. 1995. All rights reserved.
	Written by Kevin Binkley
	Created on Saturday, July 15, 1995

	Change History (most recent first):
	----------------------------------------------------------------------------
	Rev	 |	Date	 |	Who	 |	What
	----------------------------------------------------------------------------
	25		05/20/98	leonp	Added Offer Draw Button
	24		07/14/97	leonp	Fixed bug 4034, removed ghost images by forcing a 
								repaint after a failed click
	23		06/19/97	leonp	Fixed bug 535, activate event cause dragging of
								pieces to be canceled
	22		01/15/97	HI		Fixed bug in HandleJoinerKibitzerClick() to
								delete the show player window if one already
								exists before creating another one.
	21		12/18/96	HI		Cleaned up ZoneClientExit().
	20		12/18/96	HI		Cleaned up DeleteObjectsFunc().
								Changed memcpy() to z_memcpy(). We don't have
								to link with LIBCMT anymore.
    19      12/16/96    HI      Changed ZMemCpy() to memcpy().
	18		12/12/96	HI		Dynamically allocate volatible globals for reentrancy.
								Removed MSVCRT dependency.
	17		11/21/96	HI		Use game information from gameInfo in
								ZoneGameDllInit().
	16		11/21/96	HI		Now references color and fonts through
								ZGetStockObject().
								Modified code to use ZONECLI_DLL.
	15		11/15/96	HI		Removed authentication stuff from ZClientMain().
	14		10/29/96	CHB		Removed selected queueing of messages.  It now
								queues everything except talk while animating.

	13		10/28/96	CHB		Removed gAnimating flag in favor of blocking
								messages based on game state.

	12		10/23/96	HI		Modified ZClientMain() for the new commandline
								format.

    11      10/23/96    HI      Modified serverAddr to char* from int32 in
                                ZClientMain().
                                Included mmsystem.h.
	10		10/23/96	CHB		Added basic sounds

	9		10/22/96	CHB		Added gAnimating flag and changed ZCGameProcessMessage
								to queue messages while animating moves.
								(ZoneBugs 339, 446, and 341).
	
	8		10/16/96	CHB		Changed DrawPiece so it doesn't draw the piece
								currently being dragged around.  Added window
								refresh on window activation since it seemed
								to fix part 2 of the bug.  (Zone Bug 532)

	7		10/16/96	CHB		Moved ZWindowInvalidate in HandleNewGameMsg to
								fix inherited move counter.  (Zone Bug 335)

	6		10/10/96	CHB		Added gActivated flag so that dragging is turned
								off when the window looses focus.  (Zone Bug 250)

	5		10/11/96	HI		Added controlHandle parameter to ZClientMain().
	
	4		10/10/96	CHB		Modified DrawDragSquareOutline so that white
								squares are not highlighted.  (Zone Bug 274)

	3		10/09/96	CHB		Prompt users if they really want to exit the
								game.  (Zone Bug 227)

	2		10/08/96	CHB		Added gDontDrawResults flag allowing users to
								remove the who wins bitmap by clicking in the
								play arena. (Zone Bug 212)

	0		07/15/95	KJB		Created.
				
*******************************************************************************/
//#define UNICODE 


#include <windows.h>
#include <mmsystem.h>

#include "zone.h"
#include "zroom.h"
#include "zonemem.h"
#include "zonecli.h"
#include "zonecrt.h"
#include "zonehelpids.h"

#include "checklib.h"
#include "checkmov.h"
#include "checkers.h"

#include "zui.h"
#include "resource.h"
#include "zoneresource.h"
#include "ResourceManager.h"
// Barna 090999
#include "zrollover.h"
#include "checkersres.h" 

#include "UAPI.h"

#define __INIT_KEYNAMES
#include "KeyName.h"
#include "AccessibilityManager.h"
#include "GraphicalAcc.h"
#include "client.h"


/*******************************************************************************
	EXPORTED ROUTINES
*******************************************************************************/



ZError ZoneGameDllInit(HINSTANCE hLib, GameInfo gameInfo)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals;


	pGameGlobals = new GameGlobalsType;
    // changed to new for CComPtr, but members still count on being zeroed out
    ZeroMemory(pGameGlobals, sizeof(GameGlobalsType));

	if (pGameGlobals == NULL)
		return (zErrOutOfMemory);
	ZSetGameGlobalPointer(pGameGlobals);

	pGameGlobals->m_gDontDrawResults = FALSE;
	pGameGlobals->m_Unblocking = FALSE;
#endif

	ghInst = hLib;

	lstrcpyn((TCHAR*)gGameDir, gameInfo->game, zGameNameLen);
	
	// Barna 091399
	lstrcpyn((TCHAR*)gGameName, gameInfo->game, zGameNameLen);
	//lstrcpyn(gGameName, gameInfo->gameName, zGameNameLen);
	// Barna 091399

	lstrcpyn((TCHAR*)gGameDataFile, gameInfo->gameDataFile, zGameNameLen);

	lstrcpyn((TCHAR*)gGameServerName, gameInfo->gameServerName, zGameNameLen);

	gGameServerPort = gameInfo->gameServerPort;
	
	return (zErrNone);
}

void ZoneGameDllDelete(void)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();

	if (pGameGlobals != NULL)
	{
		ZSetGameGlobalPointer(NULL);
		delete pGameGlobals;
	}
#endif
}

ZError ZoneClientMain(BYTE *commandLineData, IGameShell *piGameShell)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	ZError				err = zErrNone;

	// Get the IGraphicalAccessibility interface
	HRESULT hret = ZShellCreateGraphicalAccessibility(&gCheckersIGA);
	if (!SUCCEEDED (hret))
        return zErrLaunchFailure;

//	ZInitSounds();
	LoadRoomImages();

	err = ZClient2PlayerRoom((TCHAR*)gGameServerName, (uint16) gGameServerPort, (TCHAR*)gGameName,
			GetObjectFunc, DeleteObjectsFunc, NULL);
	
	gInited = FALSE;
	gActivated = TRUE;
		
	return (err);
}

void ZoneClientExit(void)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	int16 i;

	ZCRoomExit();

	if (gInited)
	{//cleanup
		if (gOffscreenBackground != NULL)
			ZOffscreenPortDelete(gOffscreenBackground);
		gOffscreenBackground = NULL;

		if (gOffscreenGameBoard != NULL)
			ZOffscreenPortDelete(gOffscreenGameBoard);
		gOffscreenGameBoard = NULL;
		
		if (gTextBold != NULL)
			ZFontDelete(gTextBold);
		gTextBold = NULL;
		if (gTextNormal != NULL)
			ZFontDelete(gTextNormal);
		gTextNormal = NULL;

		/* Delete all game images. */
		for (i = 0; i < zNumGameImages; i++)
		{
			if (gGameImages[i] != NULL)
				ZImageDelete(gGameImages[i]);
			gGameImages[i] = NULL;
		}

		ZImageDelete(gButtonMask);
		/* Delete all fonts*/

		for (i = 0; i<zNumFonts; i++)
		{
			if ( gCheckersFont[i].m_hFont )
			{
				DeleteObject(gCheckersFont[i].m_hFont);
				gCheckersFont[i].m_hFont = NULL;
			}
			
		}
		//if(gDrawImage != NULL)
			//ZImageDelete(gDrawImage);
		//gDrawImage = NULL;
		
		// Barna 090999
		for (i = 0; i < zNumRolloverStates; i++)
		{
			if (gSequenceImages[i] != NULL)
				ZImageDelete(gSequenceImages[i]);
			gSequenceImages[i] = NULL;

			if (gDrawImages[i] != NULL)
				ZImageDelete(gDrawImages[i]);
			gDrawImages[i] = NULL;
		}
		// Barna 090999

        if(gNullPen)
            DeleteObject(gNullPen);
        gNullPen = NULL;

        if(gFocusPattern)
            DeleteObject(gFocusPattern);
        gFocusPattern = NULL;

        if(gFocusBrush)
            DeleteObject(gFocusBrush);
        gFocusBrush = NULL;

        if(gDragPattern)
            DeleteObject(gDragPattern);
        gDragPattern = NULL;

        if(gDragBrush)
            DeleteObject(gDragBrush);
        gDragBrush = NULL;

		// close the accessibility interface object
		gCheckersIGA.Release();

        gpButtonFont->Release();

		gInited = FALSE;
	}
}


TCHAR* ZoneClientName(void)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	return ((TCHAR*)gGameName);
}


TCHAR* ZoneClientInternalName(void)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	return ((TCHAR*)gGameDir);
}


ZVersion ZoneClientVersion(void)
{
	return (zGameVersion);
}

void ZoneClientMessageHandler(ZMessage* message)
{
}


ZError		GameInit(void)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	ZError		err = zErrNone;
	
	
	gInited = TRUE;
	
	ZSetColor(&gWhiteSquareColor, 200, 200, 80);
	ZSetColor(&gBlackSquareColor, 0, 60, 0);

	ZSetCursor(NULL, zCursorBusy);
	
	err = LoadGameImages();
	if (err != zErrNone)
		goto Exit;
	
	/* Load the rsc strings*/
	LoadStringsFromRsc();
	/* Create bold text font. */	
	//gTextBold = ZFontNew();
	//ZFontInit(gTextBold, zFontApplication, zFontStyleBold, 9);
	
	/* Create normal text font. */	
	//gTextNormal = ZFontNew();
	//ZFontInit(gTextNormal, zFontApplication, zFontStyleNormal, 10);
	LoadGameFonts();
	/* Set the background color */
	ZSetColor(&gWhiteColor, 0xff, 0xff, 0xff);
	
	ZSetCursor(NULL, zCursorArrow);

	/* create a background bitmap */
	gOffscreenBackground = ZOffscreenPortNew();
	if (!gOffscreenBackground){
		err = zErrOutOfMemory;
		ZShellGameShell()->ZoneAlert(ErrorTextOutOfMemory);
		goto Exit;
	}
	ZOffscreenPortInit(gOffscreenBackground,&gRects[zRectWindow]);
	ZBeginDrawing(gOffscreenBackground);
	ZImageDraw(gGameImages[zImageBackground], gOffscreenBackground, &gRects[zRectWindow], NULL, zDrawCopy);
	ZEndDrawing(gOffscreenBackground);

	// Initialising the offscreen port
	gOffscreenGameBoard = ZOffscreenPortNew();
	if (!gOffscreenGameBoard){
		err = zErrOutOfMemory;
		ZShellGameShell()->ZoneAlert(ErrorTextOutOfMemory);
		goto Exit;
	}
	ZOffscreenPortInit(gOffscreenGameBoard,&gRects[zRectWindow]);

    // create drag brush
    gDragBrush = CreatePatternBrush(gDragPattern);
    if(!gDragBrush)
    {
        err = zErrOutOfMemory;
		ZShellGameShell()->ZoneAlert(ErrorTextOutOfMemory);
		goto Exit;
    }

    // create focus brush
    gFocusBrush = CreatePatternBrush(gFocusPattern);
    if(!gFocusBrush)
    {
        err = zErrOutOfMemory;
		ZShellGameShell()->ZoneAlert(ErrorTextOutOfMemory);
		goto Exit;
    }

    gNullPen = CreatePen(PS_NULL, 0, 0);

Exit:
	return (err);
}


IGameGame* ZoneClientGameNew(ZUserID userID, int16 tableID, int16 seat, int16 playerType,
					ZRoomKibitzers* kibitzers)
	/*
		Instantiates a new game on the client side of the game at table and from the
		given seat. PlayerType indicates the type of player for the game: originator - one
		of the original players, joiner - one who joins an ongoing game, or kibitzer - one
		who is kibitzing the game. Also, the kibitzers parameters contains all the kibitzers
		at the given table and seat; it includes the given player also if kibitzing.
	*/
{	
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
	ClientDllGlobals	pClientGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif
	Game g = (Game)ZMalloc(sizeof(GameType));
	int16 i, width, just;
	TCHAR title[zGameNameLen];
// Barna 090899
	//ZBool kibitzer = playerType == zGamePlayerKibitzer;
	ZBool kibitzer = FALSE;
	ZError						err = zErrNone;
// Barna 090899
	CGameGameCheckers* pCGGC = NULL;
	HWND OCXHandle = pClientGlobals->m_OCXHandle;
    IGameGame *pIGG;

	if (gInited == FALSE)
		if (GameInit() != zErrNone)
			return (NULL);
	
	if (!g) return NULL;

	g->drawDialog = NULL;
	g->tableID = tableID;
	g->seat = seat;
	g->seatOfferingDraw = -1;
	
	g->gameWindow = ZWindowNew();
	if (g->gameWindow == NULL)
		goto ErrorExit;

	//Barna 090799
	//wsprintf(title, "%s:Table %d", ZoneClientName(), tableID+1);
	lstrcpyn((TCHAR*)title, ZoneClientName(), zGameNameLen);
	//Barna 090799

	if ((ZWindowInit(g->gameWindow, &gRects[zRectWindow], zWindowChild, NULL, (TCHAR*)title, 
		FALSE, FALSE, FALSE, GameWindowFunc, zWantAllMessages, (void*) g)) != zErrNone)		
		goto ErrorExit;


	ZBeginDrawing(g->gameWindow);
	if((g->sequenceButton = ZRolloverButtonNew()) == NULL)
		goto ErrorExit;

	if(ZRolloverButtonInit2(g->sequenceButton,
								g->gameWindow,
								&gRects[zRectSequenceButton],
								TRUE, FALSE,	//TRUE,TRUE,
								gSequenceImages[zButtonInactive], // TO TEST
								gSequenceImages[zButtonActive],
								gSequenceImages[zButtonPressed],
								gSequenceImages[zButtonDisabled],
								gButtonMask, //gSequenceImages[zButtonDisabled],	// mask
								(TCHAR*)gStrResignBtn,	// text
								NULL ,SequenceRButtonFunc,
								(void*) g) != zErrNone)
		goto ErrorExit;

	ZRolloverButtonSetMultiStateFont( g->sequenceButton, gpButtonFont );

	if((g->drawButton = ZRolloverButtonNew()) == NULL)
		goto ErrorExit;

	if(ZRolloverButtonInit2(g->drawButton,
								g->gameWindow,
								&zDrawButtonRect,/*&gRects[zDrawButtonRect],*/
								TRUE, FALSE,	//TRUE,TRUE,
								gDrawImages[zButtonInactive],
								gDrawImages[zButtonActive],
								gDrawImages[zButtonPressed],
								gDrawImages[zButtonDisabled],
								gButtonMask,	// mask
								(TCHAR*)gStrDrawBtn,	// text
								NULL ,DrawRButtonFunc,
								(void*) g) != zErrNone)
		goto ErrorExit;

	ZRolloverButtonSetMultiStateFont( g->drawButton, gpButtonFont );
	ZEndDrawing(g->gameWindow);
	// Barna 090799
	//g->helpButton = ZHelpButtonNew();
	//ZHelpButtonInit(g->helpButton, g->gameWindow, &gRects[zRectHelp], NULL, HelpButtonFunc, NULL);
	// Barna 090799

	/* the offscreen port to save the drag piece background */
	{
		ZRect rect;
		rect.left = 0; rect.top = 0;
		rect.right = zCheckersPieceImageWidth;
		rect.bottom = zCheckersPieceImageHeight;
		if ((g->offscreenSaveDragBackground = ZOffscreenPortNew()) == NULL)
			goto ErrorExit;
		ZOffscreenPortInit(g->offscreenSaveDragBackground,&rect);
	}
  
	/* for now, just set these to empty */
	/* we will get all this information in NewGame */

	for (i = 0; i < zNumPlayersPerTable; i++)
	{
		g->players[i].userID = 0;
		g->players[i].name[0] = '\0';
		g->players[i].host[0] = '\0';
		
		g->playersToJoin[i] = 0;

		g->numKibitzers[i] = 0;
		g->kibitzers[i] = ZLListNew(NULL);
		
		g->tableOptions[i] = 0;
	}
		
	if (kibitzers != NULL)
	{
		uint16 i;

		for (i = 0; i < kibitzers->numKibitzers; i++)
		{
			ZLListAdd(g->kibitzers[kibitzers->kibitzers[i].seat], NULL,
					(void*) kibitzers->kibitzers[i].userID,
					(void*) kibitzers->kibitzers[i].userID, zLListAddLast);
			g->numKibitzers[kibitzers->kibitzers[i].seat]++;
		}
	}

	// Barna 090799
	/* initialize beep on move to true */
	//g->beepOnTurn = TRUE;

	/* Beep on my turn should be off and cannot be changed by the player */
	g->beepOnTurn = FALSE;
	// Barna 090799

	g->optionsWindow = NULL;
	g->optionsWindowButton = NULL;
	g->optionsBeep = NULL;
	for (i= 0; i < zNumPlayersPerTable; i++)
	{
		g->optionsKibitzing[i] = NULL;
		g->optionsJoining[i] = NULL;
	}
	g->kibitzer = kibitzer;

	g->ignoreMessages = FALSE;

	if (kibitzer == FALSE)
	{
		SendNewGameMessage(g);
		CheckersSetGameState(g,zGameStateNotInited);
	} else {
		/* Request current game state. */
		{
			ZCheckersMsgGameStateReq gameStateReq;
			ZPlayerInfoType			playerInfo;

			ZCRoomGetPlayerInfo(zTheUser, &playerInfo);
			gameStateReq.userID = playerInfo.playerID;

			gameStateReq.seat = seat;
			ZCheckersMsgGameStateReqEndian(&gameStateReq);
			ZCRoomSendMessage(tableID, zCheckersMsgGameStateReq, &gameStateReq, sizeof(ZCheckersMsgGameStateReq));
		}
		
		g->ignoreMessages = TRUE;
		CheckersSetGameState(g, zGameStateKibitzerInit);

		/* kibitzer does not beep on move */
		g->beepOnTurn = FALSE;
	}


	/* Note: for now, use seat to indicate player color */

	/* initialize new game state */
	g->checkers = NULL;

	g->showPlayerWindow = NULL;
	g->showPlayerList = NULL;

	g->bStarted=FALSE;
	g->bEndLogReceived=FALSE;
	g->bOpponentTimeout=FALSE;
	g->exitInfo=NULL;

	/* new game vote initialized to FALSE */
	{
		int i;

		for (i = 0;i <2; i++ ) {
			g->newGameVote[i] = FALSE;
		}
	}

	g->animateTimer = ZTimerNew();
	if (g->animateTimer == NULL){
		ZShellGameShell()->ZoneAlert(ErrorTextOutOfMemory);
        goto ErrorExit;
	}

	// Barna 091399
	g->resultBoxTimer = ZTimerNew();
	if (g->resultBoxTimer == NULL){
		ZShellGameShell()->ZoneAlert(ErrorTextOutOfMemory);
        goto ErrorExit;
	}

	ZWindowShow(g->gameWindow);

    pIGG = CGameGameCheckers::BearInstance(g);
    if(!pIGG)
        goto ErrorExit;

	if (InitAccessibility(g, pIGG) == FALSE)
        goto ErrorExit;
	return pIGG;

ErrorExit:
    ZFree(g);
	return NULL;
}


void		ZoneClientGameDelete(ZCGame cgame)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	Game game = I(cgame);
	int i;
	int16 seatOpponent;

	if (game != NULL)
	{
		if( game->drawDialog)
		{
			DestroyWindow(game->drawDialog);
			game->drawDialog = NULL;
		}

		if (game->exitInfo)
		{
			ZInfoDelete(game->exitInfo);
			game->exitInfo=NULL;
		};

		seatOpponent = !game->seat;
		//Check to see if opponent still in game
		//if they are then it is me who is quitting
		//if not and no end game message assume they aborted
		
		/*if (!ZCRoomGetSeatUserId(game->tableID,seatOpponent) && !game->bEndLogReceived 
			&& !game->kibitzer)
		{
			if (game->bStarted &&( ZCRoomGetRoomOptions() & zGameOptionsRatingsAvailable ) )
            {
			    ZAlert( zAbandonRatedStr	,game->gameWindow);
            }
            else
            {
                ZAlert( zAbandonStr	,game->gameWindow);
            }

		};	*/
        
		if (game->checkers) ZCheckersDelete(game->checkers);

		// Barna 090899
		//OptionsWindowDelete(game);
		// Barna 090899

		ShowPlayerWindowDelete(game);

		// Barna 090799
		//ZButtonDelete(game->optionsButton);
		// Barna 090799
		ZRolloverButtonDelete(game->sequenceButton);
		ZRolloverButtonDelete(game->drawButton);
		// Barna 090799
		//ZHelpButtonDelete(game->helpButton);
		// Barna 090799
		
		ZWindowDelete(game->gameWindow);

		ZOffscreenPortDelete(game->offscreenSaveDragBackground);
		
		if (game->animateTimer) ZTimerDelete(game->animateTimer);

		//barna 091399
		if (game->resultBoxTimer) 
			ZTimerDelete(game->resultBoxTimer);
		game->resultBoxTimer= NULL;
		//barna 091399

		for (i = 0; i < zNumPlayersPerTable; i++)
		{
			ZLListDelete(game->kibitzers[i]);
		}

		// close accessibility
		gCheckersIGA->PopItemlist();
		gCheckersIGA->CloseAcc();
		ZFree(game);
	}
}

/*
	Add the given user as a kibitzer to the game at the given seat.
	
	This user is kibitzing the game.
*/
void		ZoneClientGameAddKibitzer(ZCGame game, int16 seat, ZUserID userID)
{
#if 0
Game		pThis = I(game);
	
	
	ZLListAdd(pThis->kibitzers[seat], NULL, (void*) userID, (void*) userID, zLListAddLast);
	pThis->numKibitzers[seat]++;
	
	UpdateJoinerKibitzers(pThis);
#endif
}
/*
	Remove the given user as a kibitzer from the game at the given seat.
	
	This is user is not kibitzing the game anymore.
*/
void		ZoneClientGameRemoveKibitzer(ZCGame game, int16 seat, ZUserID userID)
{
#if 0
	
	Game		pThis = I(game);
	
	if (userID == zRoomAllPlayers)
	{
		ZLListRemoveType(pThis->kibitzers[seat], zLListAnyType);
		pThis->numKibitzers[seat] = 0;
	}
	else
	{
		ZLListRemoveType(pThis->kibitzers[seat], (void*) userID);
		pThis->numKibitzers[seat] = (int16)ZLListCount(pThis->kibitzers[seat], zLListAnyType);
	}

	UpdateJoinerKibitzers(pThis);
#endif
}

ZBool		ZoneClientGameProcessMessage(ZCGame gameP, uint32 messageType, void* message,
					int32 messageLen)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif

	Game	game = I(gameP);
	ZBool	status = TRUE;
	
	
	/* Are messages being ignored? */
	if (game->ignoreMessages == FALSE)
	{
		/* can't handle anything but talk messages while animating */
		if (	(game->gameState == zGameStateAnimatePiece) 
			&&	(messageType != zCheckersMsgTalk) )
			return FALSE;

		switch (messageType)
		{
			case zCheckersMsgMovePiece:
				/* for speed purposes, we will send move piece messages directly*/
				/* when the local player moves.  We will not wait for server */
				/* to send game local players move back */
				/* but since the server does game anyway, we must ignore it */
			{
				if( messageLen < sizeof( ZCheckersMsgMovePiece ) )
				{
                    ASSERT(!"zCheckersMsgMovePiece sync");
					ZShellGameShell()->ZoneAlert(ErrorTextSync, NULL, NULL, true, false);	
                    return TRUE;
				}
				ZCheckersMsgMovePiece* msg = (ZCheckersMsgMovePiece*)message;
				int16 seat = msg->seat;
				ZEnd16(&seat);

				/* don't process message from ourself */
				if (seat == game->seat && !game->kibitzer)
					break;
					
				
				/* handle message */
				if(!HandleMovePieceMessage(game, msg))
				{
                    ASSERT(!"zCheckersMsgMovePiece sync");
					ZShellGameShell()->ZoneAlert(ErrorTextSync, NULL, NULL, true, false);	
                    return TRUE;
				}
				break;
			}
			case zCheckersMsgEndGame:
			{
				if( messageLen < sizeof( ZCheckersMsgEndGame ) )
				{
                    ASSERT(!"zCheckersMsgEndGame sync");
					ZShellGameShell()->ZoneAlert(ErrorTextSync, NULL, NULL, true, false);	
                    return TRUE;
				}
				ZCheckersMsgEndGame* msg = (ZCheckersMsgEndGame*)message;
				int16 seat = msg->seat;
				ZEnd16(&seat);

				/* don't process message from ourself */
				if (seat == game->seat && !game->kibitzer)
					break;

				/* handle message */
				if(!HandleEndGameMessage(game, msg))
                {
                    ASSERT(!"zCheckersMsgEndGame sync");
					ZShellGameShell()->ZoneAlert(ErrorTextSync, NULL, NULL, true, false);	
                    return TRUE;
				}
				break;
			}

			case zCheckersMsgFinishMove:
			{
				if(messageLen < sizeof(ZCheckersMsgFinishMove))
				{
                    ASSERT(!"zCheckersMsgFinishMove sync");
					ZShellGameShell()->ZoneAlert(ErrorTextSync, NULL, NULL, true, false);	
                    return TRUE;
				}

				ZCheckersMsgFinishMove* msg = (ZCheckersMsgFinishMove*) message;
				int16 seat = msg->seat;
				ZEnd16(&seat);

				/* don't process message from ourself */
				if (seat == game->seat && !game->kibitzer)
					break;
                game->bOpponentTimeout=FALSE;
                game->bEndLogReceived=FALSE;
        	    game->bStarted=TRUE;


				/* handle message */
				if(!HandleFinishMoveMessage(game, msg))
				{
                    ASSERT(!"zCheckersMsgFinishMove sync");
					ZShellGameShell()->ZoneAlert(ErrorTextSync, NULL, NULL, true, false);	
                    return TRUE;
				}
				break;
			}

			case zCheckersMsgDraw:
			{
				ZCheckersMsgDraw *msg = (ZCheckersMsgDraw*)message;
				ZCheckersMsgEndGame		end;
				DWORD 					dResult;
				//BYTE 					buff[255];
				ZPlayerInfoType 		PlayerInfo;		
				HWND					hwnd;

				if( messageLen < sizeof( ZCheckersMsgDraw ) )
				{
                    ASSERT(!"zCheckersMsgDraw sync");
					ZShellGameShell()->ZoneAlert(ErrorTextSync, NULL, NULL, true, false);	
                    return TRUE;
				}
				
				ZCheckersMsgOfferDrawEndian(msg);

                if(game->gameState != zGameStateDraw ||
                    (msg->seat != 0 && msg->seat != 1) || ((game->seat == msg->seat) == !game->fIVoted) ||
                    msg->seat == game->seatOfferingDraw || (msg->vote != zAcceptDraw && msg->vote != zRefuseDraw))
				{
                    ASSERT(!"zCheckersMsgDraw sync");
					ZShellGameShell()->ZoneAlert(ErrorTextSync, NULL, NULL, true, false);	
                    return TRUE;
				}

    			game->seatOfferingDraw = -1;  // should already be true
                game->fIVoted = false;

				if (game->kibitzer == FALSE)
				{
					if(msg->vote == zAcceptDraw)
					{
						// host sends game over
						if ( !game->kibitzer && game->seat == 0 )
						{
							end.seat = game->seat;
							end.flags = zCheckersFlagDraw;
							ZCheckersMsgEndGameEndian(&end);
							ZCRoomSendMessage(game->tableID, zCheckersMsgEndGame, &end, sizeof(ZCheckersMsgEndGame) );
							HandleEndGameMessage( game, &end );
						}
						// Draw acceptance confirmation is unnecessary.
						//if( msg->seat != game->seat )
						//ZShellGameShell()->ZoneAlert((TCHAR*)gStrDrawAccept);
						//ZAlert( (TCHAR*)gStrDrawAccept, NULL );
					}
					else
					{
						if( msg->seat != game->seat )
							ZShellGameShell()->ZoneAlert((TCHAR*)gStrDrawReject);
							//ZAlert((TCHAR*)gStrDrawReject,NULL);
						CheckersSetGameState( game, zGameStateMove );
					}
				}

			break;
			}

			case zCheckersMsgTalk:
			{
				if( messageLen < sizeof( ZCheckersMsgTalk ) )
				{
                    ASSERT(!"zCheckersMsgTalk sync");
					ZShellGameShell()->ZoneAlert(ErrorTextSync, NULL, NULL, true, false);	
                    return TRUE;
				}

                ZCheckersMsgTalk *msg = (ZCheckersMsgTalk *) message;
                uint16 talklen = msg->messageLen;
                ZEnd16(&talklen);

				if(talklen < 1 || (uint32) messageLen < talklen + sizeof(ZCheckersMsgTalk) || !HandleTalkMessage(game, msg))
				{
                    ASSERT(!"zCheckersMsgTalk sync");
					ZShellGameShell()->ZoneAlert(ErrorTextSync, NULL, NULL, true, false);	
                    return TRUE;
				}
				break;
			}

			case zCheckersMsgNewGame:
			{
				if( messageLen < sizeof( ZCheckersMsgNewGame ) )
				{
                    ASSERT(!"zCheckersMsgNewGame sync");
					ZShellGameShell()->ZoneAlert(ErrorTextSync, NULL, NULL, true, false);	
                    return TRUE;
				}

				if(!HandleNewGameMessage(game, (ZCheckersMsgNewGame *) message))
				{
                    ASSERT(!"zCheckersMsgNewGame sync");
					ZShellGameShell()->ZoneAlert(ErrorTextSync, NULL, NULL, true, false);	
                    return TRUE;
				}
				break;
			}

			case zCheckersMsgVoteNewGame:
			{
				if( messageLen < sizeof( ZCheckersMsgVoteNewGame ) )
				{
                    ASSERT(!"zCheckersMsgVoteNewGame sync");
					ZShellGameShell()->ZoneAlert(ErrorTextSync, NULL, NULL, true, false);	
                    return TRUE;
				}

				if(!HandleVoteNewGameMessage(game, (ZCheckersMsgVoteNewGame *) message))
				{
                    ASSERT(!"zCheckersMsgVoteNewGame sync");
					ZShellGameShell()->ZoneAlert(ErrorTextSync, NULL, NULL, true, false);	
                    return TRUE;
				}
				break;
			}

			case zCheckersMsgMoveTimeout:
			case zCheckersMsgGameStateReq:
			case zGameMsgTableOptions:
			case zCheckersMsgEndLog:
                ASSERT(FALSE);
			default:
				//These messages shouldn't be comming in for Whistler
				ZShellGameShell()->ZoneAlert(ErrorTextSync, NULL, NULL, true, false );	
				return TRUE;
		}
	} else {
		switch (messageType)
		{
			case zCheckersMsgTalk:
			{
				if( messageLen < sizeof( ZCheckersMsgTalk ) )
				{
                    ASSERT(!"zCheckersMsgTalk sync");
					ZShellGameShell()->ZoneAlert(ErrorTextSync, NULL, NULL, true, false);	
                    return TRUE;
				}

                ZCheckersMsgTalk *msg = (ZCheckersMsgTalk *) message;
                uint16 talklen = msg->messageLen;
                ZEnd16(&talklen);

				if(talklen < 1 || (uint32) messageLen < talklen + sizeof(ZCheckersMsgTalk) || !HandleTalkMessage(game, msg))
				{
                    ASSERT(!"zCheckersMsgTalk sync");
					ZShellGameShell()->ZoneAlert(ErrorTextSync, NULL, NULL, true, false);	
                    return TRUE;
				}
				break;
			}

			case zCheckersMsgPlayers:
			case zCheckersMsgGameStateResp:
                ASSERT(FALSE);
			default:
				//These messages shouldn't be comming in for Whistler
				ZShellGameShell()->ZoneAlert(ErrorTextSync, NULL, NULL, true, false );	
				return TRUE;
				
		}
	}

	return status;
}


/*******************************************************************************
	INTERNAL ROUTINES
*******************************************************************************/

static void CheckersInitNewGame(Game game)
{
	if (game->checkers) {
		/* remove any old checkers state lying around */
		ZCheckersDelete(game->checkers);
	}

	/* block messages by default */
	ZCRoomBlockMessages( game->tableID, zRoomFilterAllMessages, 0 );

	/* stop animation timer from previous game */
	if (game->animateTimer)
		ZTimerSetTimeout( game->animateTimer, 0 );

	/* initialize the checkers logic */
	game->checkers = ZCheckersNew();
	if (game->checkers == NULL){
		ZShellGameShell()->ZoneAlert(ErrorTextOutOfMemory);
		return;
	}
	ZCheckersInit(game->checkers);

	ZResetSounds();

	/* time control stuff */
	{
		int16 i;
		for (i = 0;i < 2;i++) {
			game->newGameVote[i] = FALSE;
		}
	}
}

static void CheckersSetGameState(Game game, int16 state)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif

	//BYTE 					buff[255];
	ZPlayerInfoType 		PlayerInfo;		
	HWND					hwnd;
	int16					seatLosing;
	ZCheckersMsgEndLog		logMsg;

	game->gameState = state;
	switch (state)
	{
	case zGameStateNotInited:
		//Barna 090899
		//ZButtonSetTitle(game->sequenceButton,"Start Game");
		//Barna 090899
		SuperRolloverButtonDisable(game, game->sequenceButton);
		SuperRolloverButtonDisable(game, game->drawButton);
        EnableBoardKbd(false);
		/*if (ZCheckersPlayerIsWhite(game))
			game->bMoveNotStarted = FALSE;
		else
			game->bMoveNotStarted = TRUE;*/
		break;

	case zGameStateMove:
		if (!game->kibitzer) {
			/* lets only let them resign on their turn */
			if (!ZCheckersPlayerIsMyMove(game))
			{
				SuperRolloverButtonDisable(game, game->sequenceButton);
				SuperRolloverButtonDisable(game, game->drawButton);
                EnableBoardKbd(false);

			}
			else {
				if(game->bMoveNotStarted)
				{
					SuperRolloverButtonDisable(game, game->sequenceButton);
					SuperRolloverButtonDisable(game, game->drawButton);
				}
				else
				{
					SuperRolloverButtonEnable(game, game->sequenceButton);
					SuperRolloverButtonEnable(game, game->drawButton);
				}
                EnableBoardKbd(true);
			}
		}
		// Barna 090999 - I guess this is not reqd anymore as the text is not changing for te seq btn - verify
		//if ((game->gameState != zGameStateMove) || (game->gameState != zGameStateDragPiece)) {
			//ZButtonSetTitle(game->sequenceButton,"Resign");
		//}
		break;
	case zGameStateDragPiece:
		break;

	case zGameStateGameOver:
		/* Note: could be called twice at end of game due to time loss */
		/* could be a time loss with a pawn promotion dialog up */

		/* if user in middle of dragging piece */
		if (game->gameState == zGameStateDragPiece) {
			ClearDragState(game);
		}

        if(game->seat == game->seatOfferingDraw)
            UpdateDrawWithNextMove(game);

		// May be this becomes an redundant line ?? verify // Barna 090999
		//SuperRolloverButtonEnable(game, game->sequenceButton);

		// Barna 090899
		//ZButtonSetTitle(game->sequenceButton,"New Game");
		SuperRolloverButtonDisable(game, game->sequenceButton);
		// Barna 090899
		SuperRolloverButtonDisable(game, game->drawButton);
        EnableBoardKbd(false);

		if (ZCheckersPlayerIsBlack(game)) // Assumption : First player is Red. This restriction is only for the first player.
			game->bMoveNotStarted = TRUE;
		else
			game->bMoveNotStarted = FALSE;

		/* determine winner */
		if ( game->finalScore == zCheckersScoreBlackWins )
		{
			if (ZCheckersPlayerIsBlack(game))
				seatLosing = !game->seat;
			else
				seatLosing = game->seat;
		}
		else if(game->finalScore == zCheckersScoreWhiteWins)
		{
			if (ZCheckersPlayerIsWhite(game))
				seatLosing = !game->seat;
			else
				seatLosing = game->seat;
		} 
		else if(game->finalScore == zCheckersScoreDraw)
		{
			seatLosing = 2;
		}
		else
		{
			seatLosing = -1;
		}
        game->bOpponentTimeout=FALSE;
        game->bEndLogReceived=FALSE;
	    game->bStarted=FALSE;

		// host reports game results
		if ( !game->kibitzer && game->seat == 0 )
		{
			if ( seatLosing >= 0 && seatLosing <= 2)
			{
				logMsg.reason=zCheckersEndLogReasonGameOver; 
				logMsg.seatLosing = seatLosing;
				ZCheckersMsgEndLogEndian( &logMsg );
				ZCRoomSendMessage( game->tableID, zCheckersMsgEndLog, &logMsg, sizeof(ZCheckersMsgEndLog) );
			}
		}
		break;

	case zGameStateKibitzerInit:
		ZRolloverButtonHide(game->sequenceButton, TRUE);

		// Barna 090799
		//ZButtonHide(game->optionsButton);
		// Barna 090799

		ZRolloverButtonHide(game->drawButton, TRUE);
		break;

	case zGameStateAnimatePiece:
		break;

	case zGameStateWaitNew:
		break;

	case zGameStateDraw:
        if (game->seatOfferingDraw != game->seat )
			ZShellGameShell()->GamePrompt(game, (TCHAR*)gStrDrawOffer, (TCHAR*)gStrDrawAcceptCaption,
							AlertButtonYes, AlertButtonNo, NULL, 0, zDrawPrompt);
        else
            UpdateDrawWithNextMove(game);

		game->seatOfferingDraw = -1;
		break;
	}

	if (	(state != zGameStateAnimatePiece)
		&&	(state != zGameStateWaitNew))
	{
		/* recursive calls into ZCRoomUnblocking is bad */
		if (!Unblocking)
		{
			Unblocking = TRUE;
			ZCRoomUnblockMessages( game->tableID );
			Unblocking = FALSE;
			ZCRoomBlockMessages( game->tableID, zRoomFilterAllMessages, 0 );
		}
	}
	else
	{
		ZCRoomBlockMessages( game->tableID, zRoomFilterAllMessages, 0 );
	}
}

// Barna 090999
ZBool LoadRolloverButtonImage(ZResource resFile, int16 dwResID, /*int16 dwButtonWidth,*/
							  ZImage rgImages[zNumRolloverStates])
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	int i;
	ZOffscreenPort		tmpOSP;
	
	ZRect				tmpRect;
	ZImage				tmpImage = NULL;
	int16				nWidth;
	ZError				err = zErrNone;

	
	tmpImage = ZResourceGetImage(resFile, dwResID - 100); // patch to get the correct Id
	if(!tmpImage)
		return FALSE;

	nWidth = ZImageGetWidth(tmpImage) / 4;	//dwButtonWidth;
	tmpRect.left = 0;
	tmpRect.top = 0;
	tmpRect.right = tmpRect.left + nWidth;
	tmpRect.bottom = ZImageGetHeight(tmpImage);

	tmpOSP = ZConvertImageToOffscreenPort(tmpImage);
	
	if(!tmpOSP)
    {
        ZImageDelete(tmpImage);
		return FALSE;
    }

	for(i = 0; i < zNumRolloverStates; i++)
	{
		rgImages[i] = ZImageNew();
				
		if(!rgImages[i] || ZImageMake(rgImages[i], tmpOSP, &tmpRect, NULL, NULL) != zErrNone)
        {
            if(!rgImages[i])
			    i--;
            for(; i >= 0; i--)
                ZImageDelete(rgImages[i]);
	        ZOffscreenPortDelete(tmpOSP);
			return FALSE;
		}

		tmpRect.left = tmpRect.right;
		tmpRect.right += nWidth;
	}

	ZOffscreenPortDelete(tmpOSP);

	return TRUE;
}

static ZError LoadGameImages(void)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	ZError				err = zErrNone;
	uint16				i;
	ZResource			resFile;
	//ZInfo				info;
	ZBool				fResult;	


	//info = ZInfoNew();
	//ZInfoInit(info, NULL, _T("Loading game images ..."), 200, TRUE, zNumGameImages);
	
	if ((resFile = ZResourceNew()) == NULL)
		ZShellGameShell()->ZoneAlert(ErrorTextOutOfMemory, NULL, NULL, true, true);
	if ((err = ZResourceInit(resFile, ZGetProgramDataFileName(zGameImageFileName))) == zErrNone)
	{
		//ZInfoShow(info);
		
		for (i = 0; i < zNumGameImages; i++)
		{
			gGameImages[i] = ZResourceGetImage(resFile, i ? i + zRscOffset : (IDB_BACKGROUND - 100));
			if (gGameImages[i] == NULL)
			{
				err = zErrResourceNotFound;
#if 1
				ZShellGameShell()->ZoneAlert(ErrorTextResourceNotFound, NULL, NULL, true, true);
#else
				ZAlert(_T("Out of memory."), NULL);
#endif
				break;
			}
			//ZInfoIncProgress(info, 1);
		}
	}
	else
	{
#if 1
		ZShellGameShell()->ZoneAlert(ErrorTextResourceNotFound, NULL, NULL, true, true);
#else
		ZAlert(_T("Failed to open image file."), NULL);
#endif
	}

	
	if ( !LoadRolloverButtonImage(resFile, IDB_RESIGN_BUTTON, gSequenceImages) )
		ZShellGameShell()->ZoneAlert(ErrorTextResourceNotFound, NULL, NULL, true, true);

	if ( !LoadRolloverButtonImage(resFile, IDB_DRAW_BUTTON, gDrawImages) )
		ZShellGameShell()->ZoneAlert(ErrorTextResourceNotFound, NULL, NULL, true, true);

	ZResourceDelete(resFile);
	//ZInfoDelete(info);

    gDragPattern = ZShellResourceManager()->LoadBitmap(MAKEINTRESOURCE(IDB_DRAG_PATTERN));
    if(!gDragPattern)
	    ZShellGameShell()->ZoneAlert(ErrorTextResourceNotFound, NULL, NULL, true, true);

    gFocusPattern = ZShellResourceManager()->LoadBitmap(MAKEINTRESOURCE(IDB_FOCUS_PATTERN));
    if(!gFocusPattern)
	    ZShellGameShell()->ZoneAlert(ErrorTextResourceNotFound, NULL, NULL, true, true);

	return (err);
}


static void QuitGamePromptFunc(int16 result, void* userData)
{
	Game game = (Game) userData;
	ZCheckersMsgEndLog log;
		
	if ( result == zPromptYes )
	{
        if (ZCRoomGetRoomOptions() & zGameOptionsRatingsAvailable )
        {
         
		    if (game->bOpponentTimeout)
		    {
			    log.reason=zCheckersEndLogReasonTimeout;
		    }
		    else if (game->bStarted)
		    {
			    log.reason=zCheckersEndLogReasonForfeit;
		    }
		    else
		    {
			    //game hasn't started
			    log.reason=zCheckersEndLogReasonWontPlay;
		    }

            if (log.reason!= game->gameCloseReason)
            {
                //state has changed
                CloseGameFunc(game);
                return;
            }
		    
		    //server determines seat losing
		    log.seatLosing=game->seat;
		    log.seatQuitting=game->seat;
		    
		    ZCRoomSendMessage(game->tableID, zCheckersMsgEndLog, &log, sizeof(log));				
		    
		    if (!game->exitInfo)
		    {
			    /*game->exitInfo = ZInfoNew();
			    ZInfoInit(game->exitInfo , game->gameWindow, _T("Exiting game ..."), 300, FALSE, 0);
			    ZInfoShow(game->exitInfo );*/

			    ClearDragState(game);

			    SuperRolloverButtonDisable(game, game->sequenceButton);
			    SuperRolloverButtonDisable(game, game->drawButton);
                EnableBoardKbd(false);
	    
		    };
        }
        else
        {
#if 1
			ZShellGameShell()->GameCannotContinue(game);
#else
            ZCRoomGameTerminated( game->tableID);
#endif
        }
	}
	else
	{
		/* Do nothing. */
	}
}


static ZBool  GameWindowFunc(ZWindow window, ZMessage* pMessage)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	ZBool	msgHandled;
	Game	game = (Game) pMessage->userData;
	TCHAR    keyPressed;	
	msgHandled = FALSE;
	
	switch (pMessage->messageType) 
	{
		case zMessageWindowActivate:
			gActivated = TRUE;
			game->dragPoint.x = 0;
			game->dragPoint.y = 0;
			ZWindowInvalidate( window, NULL );
			msgHandled = TRUE;
			break;

		case zMessageWindowDeactivate:
			gActivated = FALSE;
			game->dragPoint.x = 0;
			game->dragPoint.y = 0;
			ZWindowInvalidate( window, NULL );

			//leonp fix for bug 535 - when the window looses focus cancel the drag.
			ClearDragState(game);

			msgHandled = TRUE;
			break;

        case zMessageWindowEnable:
            gCheckersIGA->GeneralEnable();
            break;

        case zMessageWindowDisable:
            gCheckersIGA->GeneralDisable();
            break;

        case zMessageSystemDisplayChange:
            DisplayChange(game);
            break;

		case zMessageWindowDraw:
			GameWindowDraw(window, pMessage);
			msgHandled = TRUE;
			break;
		case zMessageWindowButtonDown:
			if(game->drawDialog)
			{
				DestroyWindow(game->drawDialog);
				game->drawDialog = NULL;
			}

			HandleButtonDown(window, pMessage);
			msgHandled = TRUE;
			break;
		case zMessageWindowButtonUp:
			HandleButtonUp(window, pMessage);
			msgHandled = TRUE;
			break;
		case zMessageWindowClose:
			CloseGameFunc(game);
            msgHandled = TRUE;
			break;
		case zMessageWindowTalk:
			GameSendTalkMessage(window, pMessage);
			msgHandled = TRUE;
			break;
		case zMessageWindowIdle:
			HandleIdleMessage(window,pMessage);
			msgHandled = TRUE;
			break;
		case zMessageWindowChar:
			if (game->gameState == zGameStateGameOver && !gDontDrawResults)
			{
				gDontDrawResults = TRUE;
				ZWindowInvalidate( game->gameWindow, &gRects[zRectResultBox] );
			}
			break;
	}
	
	return (msgHandled);
}


// all offscreen ports need to be regenerated
static void DisplayChange(Game game)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif

    int i;

    // delete our personal offscreen ports
	if(gOffscreenBackground)
		ZOffscreenPortDelete(gOffscreenBackground);
	gOffscreenBackground = NULL;

	if(gOffscreenGameBoard)
		ZOffscreenPortDelete(gOffscreenGameBoard);
	gOffscreenGameBoard = NULL;

    // drag background
	ZOffscreenPortDelete(game->offscreenSaveDragBackground);

    // now remake them all
	gOffscreenBackground = ZOffscreenPortNew();
	if(!gOffscreenBackground)
    {
	    ZShellGameShell()->ZoneAlert(ErrorTextOutOfMemory, NULL, NULL, true, true);
		return;
	}
	ZOffscreenPortInit(gOffscreenBackground, &gRects[zRectWindow]);
	ZBeginDrawing(gOffscreenBackground);
	ZImageDraw(gGameImages[zImageBackground], gOffscreenBackground, &gRects[zRectWindow], NULL, zDrawCopy);
	ZEndDrawing(gOffscreenBackground);

	gOffscreenGameBoard = ZOffscreenPortNew();
	if(!gOffscreenGameBoard)
    {
	    ZShellGameShell()->ZoneAlert(ErrorTextOutOfMemory, NULL, NULL, true, true);
		return;
	}
	ZOffscreenPortInit(gOffscreenGameBoard, &gRects[zRectWindow]);

	ZRect rect;
	rect.left = 0;
    rect.top = 0;
	rect.right = zCheckersPieceImageWidth;
	rect.bottom = zCheckersPieceImageHeight;
    game->offscreenSaveDragBackground = ZOffscreenPortNew();
	if(!game->offscreenSaveDragBackground)
    {
	    ZShellGameShell()->ZoneAlert(ErrorTextOutOfMemory, NULL, NULL, true, true);
		return;
	}
	ZOffscreenPortInit(game->offscreenSaveDragBackground, &rect);

    ZWindowInvalidate(game->gameWindow, NULL);
}


static void CloseGameFunc(Game game)
{
    if ( !game->kibitzer )
	{
		BYTE szBuff[512];

		//if we already clicked close just ignore
		if (!game->exitInfo)
		{
			// select exit dialog based on rated game and state
			/*if ( ZCRoomGetRoomOptions() & zGameOptionsRatingsAvailable )
			{
				if (game->bOpponentTimeout)
                {
					wsprintf((TCHAR*)szBuff,zExitTimeoutStr);
                    game->gameCloseReason=zCheckersEndLogReasonTimeout;
                }
				else if (game->bStarted)
                {
					wsprintf((TCHAR*)szBuff,zExitForfeitStr);
                    game->gameCloseReason=zCheckersEndLogReasonForfeit;
                }
				else
                {
                    game->gameCloseReason= zCheckersEndLogReasonWontPlay;
					wsprintf((TCHAR*)szBuff,zQuitGamePromptStr);
                }

			}
            else
            {
				wsprintf((TCHAR*)szBuff,zQuitGamePromptStr);
                game->gameCloseReason= zCheckersEndLogReasonWontPlay;
            }*/
			/* Ask user if desires to leave the current game. */
#if 1
			ZShellGameShell()->GamePrompt(game, (TCHAR*)szBuff, NULL, AlertButtonYes, AlertButtonNo, NULL, 0, zQuitprompt);
#else
			ZPrompt((TCHAR*)szBuff,	&gQuitGamePromptRect, game->gameWindow,	TRUE,
				zPromptYes | zPromptNo,	NULL, NULL, NULL, QuitGamePromptFunc, game );
#endif
		}
	}
	else
	{
#if 1
			ZShellGameShell()->GameCannotContinue(game);
#else
            ZCRoomGameTerminated( game->tableID);
#endif
	}

}

static void ConfirmResignPrompFunc(int16 result, void* userData)
{
	Game game = (Game) userData;

	//if(result == zPromptNo)
	if(result == IDNO || result == IDCANCEL)
	{
		if ((game->gameState == zGameStateMove) && ZCheckersPlayerIsMyMove(game))
		{
			SuperRolloverButtonEnable(game, game->sequenceButton);
            EnableBoardKbd(true);
		}
		return;
	}
	else
	{
		ZCheckersMsgEndGame		msg;

		msg.seat = game->seat;
		msg.flags = zCheckersFlagResign;
		ZCheckersMsgEndGameEndian(&msg);
		ZCRoomSendMessage(game->tableID, zCheckersMsgEndGame, &msg, sizeof(ZCheckersMsgEndGame));
		HandleEndGameMessage(game, (ZCheckersMsgEndGame*)&msg);
	}
}

// Barna 090999
static ZBool SequenceRButtonFunc(ZRolloverButton button, int16 state, void* userData)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	Game game = (Game) userData;

	if(state!=zRolloverButtonClicked)
		return TRUE;

	switch (game->gameState) {
	case zGameStateMove:
		if (ZCheckersPlayerIsMyMove(game)) {
			gCheckersIGA->SetFocus(0);
#if 1
			ZShellGameShell()->GamePrompt(game, (TCHAR*)gResignConfirmStr, (TCHAR*)gResignConfirmStrCap,
							AlertButtonYes, AlertButtonNo, NULL, 0, zResignConfirmPrompt);
#else
			ZPromptM((TCHAR*)gResignConfirmStr,game->gameWindow, MB_YESNO, (TCHAR*)gResignConfirmStrCap, ConfirmResignPrompFunc, game);		
#endif
		}
		break;
	case zGameStateDragPiece:
		/* some fellow is trying to click on the resign/other button while dragging a piece */
		/* force the user to drop the piece first, then resign */
		/* ignore this message */
		break;
	default:
		ASSERT(FALSE);
        break;
	}

	return TRUE;
}
// Barna 090999

static void SendNewGameMessage(Game game) 
{
	/* if we are a real player */
	ZCheckersMsgNewGame newGame;
	newGame.seat = game->seat;
	newGame.protocolSignature = zCheckersProtocolSignature;
	newGame.protocolVersion = zCheckersProtocolVersion;
	newGame.clientVersion = ZoneClientVersion();
	ZCheckersMsgNewGameEndian(&newGame);
	ZCRoomSendMessage(game->tableID, zCheckersMsgNewGame, &newGame, sizeof(ZCheckersMsgNewGame));
}

static void DrawFocusRectangle (Game game)
{ 
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif

	RECT prc;

	// draw a from square focus rect if it is in a drag state
	if(!IsRectEmpty(&game->m_DragRect))
	{
		HDC	hdc = ZGrafPortGetWinDC(game->gameWindow);
		SetROP2(hdc, R2_MASKPEN);
        SetBkMode(hdc, TRANSPARENT);
        HBRUSH hBrush = SelectObject(hdc, gDragBrush);
        HPEN hPen = SelectObject(hdc, gNullPen);
		Rectangle(hdc, game->m_DragRect.left, game->m_DragRect.top, game->m_DragRect.right + 1, game->m_DragRect.bottom + 1);  // to make up for the pen
        SelectObject(hdc, hBrush);
        SelectObject(hdc, hPen);
        SetROP2(hdc, R2_COPYPEN);
	}

	// draw a rectangle around the object with kbd focus
	if(!IsRectEmpty(&game->m_FocusRect))
	{
		CopyRect(&prc, &game->m_FocusRect);
		HDC	hdc = ZGrafPortGetWinDC( game->gameWindow );

        // brush type based on whether the focus rectangle is square.  could change to use cookies associated with ui items to distinguish type
        bool fBoard = (prc.bottom - prc.top == prc.right - prc.left);

		ZSetForeColor(game->gameWindow, (ZColor*) ZGetStockObject(zObjectColorYellow));
		SetROP2(hdc, R2_COPYPEN);
		POINT pts[] = {prc.left, prc.top,
					    prc.left, prc.bottom - 1,
						prc.right - 1, prc.bottom - 1,
						prc.right - 1, prc.top,
						prc.left, prc.top};
		Polyline(hdc, pts, 5);

//		HDC	hdc = ZGrafPortGetWinDC(game->gameWindow);
		SetROP2(hdc, R2_MERGENOTPEN);
        SetBkMode(hdc, TRANSPARENT);
        COLORREF color = SetTextColor(hdc, PALETTEINDEX(4));  // the inverse of 255, 255, 0 in the palette
        HBRUSH hBrush = SelectObject(hdc, fBoard ? gFocusBrush : GetStockObject(NULL_BRUSH));
        HPEN hPen = SelectObject(hdc, gNullPen);
		Rectangle(hdc, game->m_FocusRect.left + 1, game->m_FocusRect.top + 1, game->m_FocusRect.right, game->m_FocusRect.bottom);  // to make up for the pen - 1 inward
        SelectObject(hdc, hBrush);
        SelectObject(hdc, hPen);
        SetTextColor(hdc, color);
        SetROP2(hdc, R2_COPYPEN);
	}

}

static void GameWindowDraw(ZWindow window, ZMessage *message)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	ZRect				rect;
	ZRect				oldClipRect;
	Game				game;
	
	game = (Game) message->userData;
	
	// Beta2 bug #15398
	// barna - if animation is in progress postpone the drawing till it is over
	if ( (game->gameState == zGameStateAnimatePiece) && (game->animateStepsLeft >= 0) )
	{
		game->bDrawPending = TRUE;
		return;
	}
	if (ZRectEmpty(&message->drawRect) == FALSE)
	{
		rect = message->drawRect;
	}
	else
	{
		ZWindowGetRect(window, &rect);
		ZRectOffset(&rect, (int16)-rect.left, (int16)-rect.top);
	}
		
	ZBeginDrawing(window);
	ZBeginDrawing(gOffscreenGameBoard);

	ZGetClipRect(window, &oldClipRect);
	ZSetClipRect(window, &rect);
	
	DrawBackground(NULL, NULL);
	
	/* if we have the checkers state then draw the pieces */
	if (game->checkers != NULL)
	{
		DrawPlayers(game, TRUE);
		DrawTable(game, TRUE);
		DrawDragPiece(game, TRUE);
		DrawResultBox(game, TRUE);
		DrawMoveIndicator(game, TRUE);
        DrawDrawWithNextMove(game, TRUE);
		// Barna 090899
		IndicatePlayerTurn(game, TRUE);
		ZRolloverButtonShow(game->sequenceButton);
		ZRolloverButtonShow(game->drawButton);
	}
	ZCopyImage(gOffscreenGameBoard, window, &rect, &rect, NULL, zDrawCopy);
	ZSetClipRect(window, &oldClipRect);
	ZEndDrawing(gOffscreenGameBoard);

	// Draw the bounding rectangle
	DrawFocusRectangle(game);
	ZEndDrawing(window);
}

static void DrawResultBox(Game game, BOOL bDrawInMemory)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	ZImage			image = NULL;
	int16			result;
	BYTE szBuf [zMediumStrLen];

	result = -1;
	//if (((game->gameState == zGameStateGameOver) && gDontDrawResults) || (game->gameState == zGameStateWaitNew))
	if (game->gameState == zGameStateGameOver && gDontDrawResults)
	{
		if (game->resultBoxTimer) 
			ZTimerDelete(game->resultBoxTimer);
		game->resultBoxTimer= NULL;
		//RemoveResultboxAccessibility();
        ZShellGameShell()->GameOver( Z(game) );
	}
	if (game->gameState == zGameStateGameOver && !gDontDrawResults)
	{
		if (game->finalScore == zCheckersScoreBlackWins )
		{
			result = zImageFinalScoreDraw;
			if (ZCheckersPlayerIsBlack(game))
				ZPlaySound( game, zSndWin, FALSE, TRUE );
			else
				ZPlaySound( game, zSndLose, FALSE, TRUE );
			
			CheckersFormatMessage((TCHAR*)szBuf, sizeof(szBuf) / sizeof(szBuf[0]), 
					IDS_GAME_OVER_TEXT, (TCHAR*) game->players[game->finalScore].name);
		}
		else if(game->finalScore == zCheckersScoreWhiteWins)
		{
			result = zImageFinalScoreDraw;
			if (ZCheckersPlayerIsWhite(game))
				ZPlaySound( game, zSndWin, FALSE, TRUE );
			else
				ZPlaySound( game, zSndLose, FALSE, TRUE );
			
			CheckersFormatMessage((TCHAR*)szBuf, sizeof(szBuf) / sizeof(szBuf[0]), 
					IDS_GAME_OVER_TEXT, (TCHAR*) game->players[game->finalScore].name);
		}
		else if (game->finalScore == zCheckersScoreDraw)//todo add draw graphic
		{
			result = zImageFinalScoreDraw;
			ZPlaySound( game, zSndWin, FALSE, TRUE );
			
			lstrcpy((TCHAR*)szBuf, (TCHAR*)gStrDrawText);
		}
		
		if( result != -1 )
		{
			SuperRolloverButtonDisable(game, game->drawButton);
			SuperRolloverButtonDisable(game, game->sequenceButton);
            EnableBoardKbd(false);

			// Draw the result window
			HDC hdc;
			image = gGameImages[result];
			if (bDrawInMemory){
				ZImageDraw(image, gOffscreenGameBoard, &gRects[zRectResultBox], NULL, zDrawCopy | (ZIsLayoutRTL() ? zDrawMirrorHorizontal : 0));
				hdc = ZGrafPortGetWinDC( gOffscreenGameBoard );
			}else{
				ZImageDraw(image, game->gameWindow, &gRects[zRectResultBox], NULL, zDrawCopy | (ZIsLayoutRTL() ? zDrawMirrorHorizontal : 0));
				hdc = ZGrafPortGetWinDC( game->gameWindow );
			}
			// Add Text on the image.. // Barna 091099
			// Reading from data store
			HFONT hOldFont = SelectObject( hdc, gCheckersFont[zFontResultBox].m_hFont );
			COLORREF colorOld = SetTextColor( hdc, gCheckersFont[zFontResultBox].m_zColor );
			
			int16 width, just;
			width = ZTextWidth(game->gameWindow, (TCHAR*)szBuf);
			if (width > ZRectWidth(&gRects[zRectResultBoxName]))
				just = zTextJustifyLeft;
			else
				just = zTextJustifyCenter;

			if (bDrawInMemory)
				ZDrawText(gOffscreenGameBoard, &gRects[zRectResultBoxName], just, (TCHAR*)szBuf);
			else
				ZDrawText(game->gameWindow, &gRects[zRectResultBoxName], just, (TCHAR*)szBuf);

			// add the accell list for the result box
			//AddResultboxAccessibility();
			// set the timer // Barna 091399
			if (game->resultBoxTimer == NULL){
				game->resultBoxTimer = ZTimerNew();
				if (!game->resultBoxTimer)
					ZShellGameShell()->ZoneAlert(ErrorTextOutOfMemory);
			}

			if (game->resultBoxTimer)
				ZTimerInit(game->resultBoxTimer, zResultBoxTimeout, resultBoxTimerFunc, game);
		}
	}
}

static void DrawMoveIndicator(Game game, BOOL bDrawInMemory)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	ZImage			image = NULL;
	ZRect* rect1, *rect2;

	if (ZCheckersPlayerToMove(game->checkers) == zCheckersPlayerBlack) {
		image = gGameImages[zImageBlackMarker];
	} else {
		image = gGameImages[zImageWhiteMarker];
	}

	if (ZCheckersPlayerIsMyMove(game)) {
		/* fill top spot with the background */
		rect1 = &gRects[zRectMove1];
		//DrawBackground(game,rect1); 

		/* fill bottom spot with piece */
		rect2 = &gRects[zRectMove2];
		//ZImageDraw(image, game->gameWindow, rect2, NULL, zDrawCopy);
	} else {
		/* fill bottom spot with the background */
		rect1 = &gRects[zRectMove2];
		//DrawBackground(game,rect1); 

		/* fill top spot with piece */
		rect2 = &gRects[zRectMove1];
		//ZImageDraw(image, game->gameWindow, rect2, NULL, zDrawCopy);
	}

	if (bDrawInMemory)
	{
		DrawBackground(NULL,rect1); 
		ZImageDraw(image, gOffscreenGameBoard, rect2, NULL, zDrawCopy);
	}
	else
	{
		DrawBackground(game,rect1); 
		ZImageDraw(image, game->gameWindow, rect2, NULL, zDrawCopy);
	}
}


static void DrawBackground(Game game, ZRect* clipRect)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	if (!game){
		ZCopyImage(gOffscreenBackground, gOffscreenGameBoard, clipRect? clipRect: &gRects[zRectWindow], 
			clipRect? clipRect: &gRects[zRectWindow], NULL, zDrawCopy);
		return;
	}

	ZRect			oldClipRect;
	ZRect*			rect;
	ZWindow			window = game->gameWindow;

	rect = &gRects[zRectWindow];
	
	if (clipRect != NULL)
	{
		ZGetClipRect(window, &oldClipRect);
		ZSetClipRect(window, clipRect);
		rect = clipRect;
	}

	/* copy the whole background from the offscreen port */
	ZCopyImage(gOffscreenBackground, window, rect, rect, NULL, zDrawCopy);

	if (clipRect != NULL)
	{
		ZSetClipRect(window, &oldClipRect);
	}
}


static void DrawTable(Game game, BOOL bDrawInMemory)
{
	BYTE			i;
	BYTE			j;

	for (i = 0;i < 8; i++) {
		for (j = 0;j < 8; j++) {
			ZCheckersSquare sq;
			sq.row = j;
			sq.col = i;
			DrawPiece(game, &sq, bDrawInMemory);
		}
	}
}

static void DrawSquares(Game game, ZCheckersSquare* squares)
{
	while (squares && !ZCheckersSquareIsNull(squares)) {
		DrawPiece(game, squares, FALSE);
		squares++;
	}
}

static void UpdateSquares(Game game, ZCheckersSquare* squares)
{
	ZBeginDrawing(game->gameWindow);
	DrawSquares(game,squares);
	ZEndDrawing(game->gameWindow);
}

static void UpdateTable(Game game)
{
	ZBeginDrawing(game->gameWindow);
	DrawTable(game, FALSE);
	ZEndDrawing(game->gameWindow);
}

static void UpdateResultBox(Game game)
{
	ZBeginDrawing(game->gameWindow);
	DrawResultBox(game, FALSE);
	ZEndDrawing(game->gameWindow);
}

static void UpdateMoveIndicator(Game game)
{
	ZBeginDrawing(game->gameWindow);
	DrawMoveIndicator(game, FALSE);
	// Barna 090899
	IndicatePlayerTurn(game, FALSE);
	ZEndDrawing(game->gameWindow);
}

// returns entire square rect 
static void GetPieceRect(Game game, ZRect* rect, int16 col, int16 row)
{
	/* checkers player who is white must have the board reversed */
	if (ZCheckersPlayerIsBlack(game)) {
		row = 7 - row;
		col = col;
	} else {
		row = row;
		col = 7 - col;
	}

	rect->left = gRects[zRectCells].left + col * zCheckersPieceSquareWidth-1;
	rect->top = gRects[zRectCells].top + row * zCheckersPieceSquareHeight-1;
	rect->right = rect->left + zCheckersPieceImageWidth+1;
	rect->bottom = rect->top + zCheckersPieceImageHeight+1;
}

static void GetPieceBackground(Game game, ZGrafPort window, ZRect* rectDest, int16 col, int16 row)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	ZRect rect;

	GetPieceRect(game,&rect,col,row);

    // add one pixel for safety (sometimes focus will leage garbage)
    rect.top--;
    rect.left--;

	/* provide default destination rect same as source rect */
	if (!rectDest)
		rectDest = &rect;

	/* copy the background */
	ZCopyImage(gOffscreenBackground, window, &rect, rectDest, NULL, zDrawCopy);
}	


static void DrawPiece(Game game, ZCheckersSquare* sq, BOOL bDrawInMemory)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	ZImage			image = NULL;
	ZCheckersPiece		piece;

	if (	(game->gameState == zGameStateDragPiece)
		&&	(sq->row == game->selectedSquare.row)
		&&	(sq->col == game->selectedSquare.col) )
	{
		/* don't draw piece if it is currently selected */
		piece = zCheckersPieceNone;
	}
	else
	{
		piece = ZCheckersPieceAt(game->checkers, sq);
	}

	if (piece != zCheckersPieceNone)
	{
		image = gGameImages[ZCheckersPieceImageNum(piece)];
	}

	/* copy the background, in case we are removing a piece */
	//GetPieceBackground(game, game->gameWindow, NULL, sq->col,sq->row);
	if (bDrawInMemory)
		GetPieceBackground(game, gOffscreenGameBoard, NULL, sq->col,sq->row);
	else
		GetPieceBackground(game, game->gameWindow, NULL, sq->col,sq->row);

	
	if (image != NULL) 
	{
		ZRect			rect;
		GetPieceRect(game,&rect,sq->col,sq->row);
		ZRect drawRect;
        drawRect.top = rect.top+1;
        drawRect.left = rect.left+1;
        drawRect.bottom = drawRect.top + zCheckersPieceImageHeight;
        drawRect.right = drawRect.left + zCheckersPieceImageWidth;

		if (bDrawInMemory)
			ZImageDraw(image, gOffscreenGameBoard, &drawRect, NULL, zDrawCopy);
		else
			ZImageDraw(image, game->gameWindow, &drawRect, NULL, zDrawCopy);

        RECT rc;
        RECT rcUpdate;
        rcUpdate.top = rect.top;
        rcUpdate.left = rect.left;
        rcUpdate.bottom = rect.bottom;
        rcUpdate.right = rect.right;

        if(!bDrawInMemory && ((!IsRectEmpty(&game->m_FocusRect) && IntersectRect(&rc, &rcUpdate, &game->m_FocusRect)) ||
            (!IsRectEmpty(&game->m_DragRect) && IntersectRect(&rc, &rcUpdate, &game->m_DragRect))))
            DrawFocusRectangle(game);
	}
}

static ZBool ZCheckersSquareFromPoint(Game game, ZPoint* point, ZCheckersSquare* sq)
{
	int16 x,y;
	BYTE i,j;

	x = point->x - gRects[zRectCells].left;
	y = point->y - gRects[zRectCells].top;

	i = x/zCheckersPieceSquareWidth;
	j = y/zCheckersPieceSquareHeight;

    // this does sometimes occur
	if(i < 0 || i > 7 || j < 0 || j > 7 || x < 0 || y < 0)
        return FALSE;
	
	if (ZCheckersPlayerIsBlack(game))
	{
		/* reverse the row */
		sq->row = (7 - j);
		sq->col = i;
	}
	else
	{
		sq->row = j;
		sq->col = (7 - i);
	}

	return TRUE;
}

static void DrawPlayers(Game game, BOOL bDrawInMemory)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	int16			i, width, just;
	ZImage			image[2];

	if (ZCheckersPlayerIsBlack(game)) {
		image[0] = gGameImages[zImageWhitePlate];
		image[1] = gGameImages[zImageBlackPlate];
	} else {
		image[0] = gGameImages[zImageBlackPlate];
		image[1] = gGameImages[zImageWhitePlate];
	}
	
	//ZSetFont(game->gameWindow, gTextBold);
	
	for (i = 0; i < zNumPlayersPerTable; i++)
	{
		int16 playerNum;
		HDC hdc;
		ZRect* rect;

		/* Draw name plate */
		rect = &gRects[gNamePlateRects[i]];
		if (bDrawInMemory){
			ZImageDraw(image[i], gOffscreenGameBoard, rect, NULL, zDrawCopy);
			hdc = ZGrafPortGetWinDC( gOffscreenGameBoard );
		}else{
			ZImageDraw(image[i], game->gameWindow, rect, NULL, zDrawCopy);
			hdc = ZGrafPortGetWinDC( game->gameWindow );
		}
		/* must move player name to reflect the side of the board the player is on */
		playerNum = (game->seat + 1 + i) & 1;
		
		HFONT hOldFont = SelectObject( hdc, gCheckersFont[zFontPlayerName].m_hFont );
		COLORREF colorOld = SetTextColor( hdc, gCheckersFont[zFontPlayerName].m_zColor );

		width = ZTextWidth(game->gameWindow, (TCHAR*) game->players[playerNum].name);
		if (width > ZRectWidth(&gRects[gNameRects[i]]))
			just = zTextJustifyLeft;
		else
			just = zTextJustifyCenter;
		if (bDrawInMemory)
			ZDrawText(gOffscreenGameBoard, &gRects[gNameRects[i]], just,(TCHAR*) game->players[playerNum].name);
		else
			ZDrawText(game->gameWindow, &gRects[gNameRects[i]], just,(TCHAR*) game->players[playerNum].name);
	}
}


static void UpdatePlayers(Game game)
{
	ZBeginDrawing(game->gameWindow);
	DrawPlayers(game , FALSE);
	ZEndDrawing(game->gameWindow);
}

static void DrawJoinerKibitzers(Game game)
{
// Barna 091599 - No kibitzer should be drawn
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
#if 0
	int16			i;
	

	for (i = 0; i < zNumPlayersPerTable; i++)
	{
		ZRect *rect = &gRects[gKibitzerRectIndex[GetLocalSeat(game,i)]];
		if (game->numKibitzers[i] > 0)
			ZImageDraw(gGameImages[zImageKibitzer], game->gameWindow,
					rect, NULL, zDrawCopy);
		else 
			DrawBackground(game, rect);
	}
#endif
}

#if 0
static void UpdateJoinerKibitzers(Game game)
{
	ZBeginDrawing(game->gameWindow);
	DrawJoinerKibitzers(game);
	ZEndDrawing(game->gameWindow);
}
#endif


static void DrawDrawWithNextMove(Game game, BOOL bDrawInMemory)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif

    HDC hdc;
    HFONT hOldFont;
    COLORREF colorOld;

	if(game->seat == game->seatOfferingDraw && ZCheckersPlayerIsMyMove(game) && game->gameState == zGameStateMove)
    {
		if(bDrawInMemory)
        {
			hdc = ZGrafPortGetWinDC(gOffscreenGameBoard);
		    hOldFont = SelectObject(hdc, gCheckersFont[zFontDrawPend].m_hFont);
		    colorOld = SetTextColor(hdc, gCheckersFont[zFontDrawPend].m_zColor);
			ZDrawText(gOffscreenGameBoard, &gRects[zRectDrawPend], zTextJustifyCenter, gStrDrawPend);
        }
		else
        {
			hdc = ZGrafPortGetWinDC(game->gameWindow);
		    hOldFont = SelectObject(hdc, gCheckersFont[zFontDrawPend].m_hFont);
		    colorOld = SetTextColor(hdc, gCheckersFont[zFontDrawPend].m_zColor);
			ZDrawText(game->gameWindow, &gRects[zRectDrawPend], zTextJustifyCenter, gStrDrawPend);
        }

        SetTextColor(hdc, colorOld);
        SelectObject(hdc, hOldFont);
    }
	else
		DrawBackground(game, &gRects[zRectDrawPend]);
}


static void UpdateDrawWithNextMove(Game game)
{
	ZBeginDrawing(game->gameWindow);
	DrawDrawWithNextMove(game, FALSE);
	ZEndDrawing(game->gameWindow);
}


static void DrawOptions(Game game)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
#if 0
	int16			i;
	uint32			tableOptions;

	tableOptions = 0;
	for (i = 0; i < zNumPlayersPerTable; i++)
		tableOptions |= game->tableOptions[i];
	
	if (tableOptions & zRoomTableOptionNoKibitzing)
		ZImageDraw(gGameImages[zImageNoKibitzer], game->gameWindow,
				&gRects[zRectKibitzerOption], NULL, zDrawCopy);
	else
		DrawBackground(game, &gRects[zRectKibitzerOption]);
#endif
}


static void UpdateOptions(Game game)
{
	ZBeginDrawing(game->gameWindow);
	DrawOptions(game);
	ZEndDrawing(game->gameWindow);
}

static void HandleButtonDown(ZWindow window, ZMessage* pMessage)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	Game				game;
	ZCheckersSquare		sq;
	ZCheckersPiece		piece;
	game = (Game) pMessage->userData;

	//if (((game->gameState == zGameStateGameOver) || (game->gameState == zGameStateWaitNew))
		//&& !gDontDrawResults)
	if (game->gameState == zGameStateGameOver && !gDontDrawResults)
	{
		gDontDrawResults = TRUE;
		//RemoveResultboxAccessibility();
		ZWindowInvalidate( window, &gRects[zRectResultBox] );
	}
#if 0
	/* check for clicks on the kibitzer icon */
	{
		int16				seat;
		ZPoint				point = pMessage->where;
		if ((seat = FindJoinerKibitzerSeat(game, &point)) != -1)
		{
			HandleJoinerKibitzerClick(game, seat, &point);
		}
	}
#endif
	/* kibitzers can't do anyting with the button. */
	if (game->kibitzer) {
		return;
	}

	/* wrong state, can't move now */
	if (game->gameState != zGameStateMove) {
		return;
	}

	if (!ZCheckersPlayerIsMyMove(game)) {
		/* if not players move, can't do anything */
		return;
	}

	if (ZCheckersSquareFromPoint(game, &pMessage->where, &sq)) {
		piece = ZCheckersPieceAt(game->checkers, &sq);
		/* is this really a piece */
		if (piece != zCheckersPieceNone && 
			game->seat == ZCheckersPieceOwner(piece)) {

			/* yup a piece is now selected */
			game->selectedSquare = sq;
			CheckersSetGameState(game,zGameStateDragPiece);

			PrepareDrag(game, piece, pMessage->where);
			EraseDragPiece(game);
		}
	} /* else, not clicked in board */
			
}

static void PrepareDrag(Game game, ZCheckersPiece piece, ZPoint point)
/* initialite the point, piece and the first background rectangle */
{
	ZCheckersSquare sq;

	ZCheckersSquareFromPoint(game, &point, &sq);
	
	game->dragPiece = piece;
//	game->dragPoint.x = -1; // set illegal value to get initial update
	game->startDragPoint = point;
	GetPieceRect(game,&game->rectSaveDragBackground,sq.col,sq.row);
	
	{
		ZRect rect;
		rect.left = 0; rect.top = 0;
		rect.right = zCheckersPieceImageWidth; rect.bottom = zCheckersPieceImageHeight;
		GetPieceBackground(game,game->offscreenSaveDragBackground,&rect,sq.col,sq.row);
	}
}

static void UpdateDragPiece(Game game, bool fForce)
{
	ZPoint point;

	ZGetCursorPosition(game->gameWindow,&point);
	
	/* do nothing if point has not changed */
	if (point.x == game->dragPoint.x && point.y == game->dragPoint.y && !fForce)
	{
		return;
	}

	ZBeginDrawing(game->gameWindow);
	EraseDragPiece(game);
	game->dragPoint = point;
	DrawDragPiece(game, FALSE);
	ZEndDrawing(game->gameWindow);
}

static void DrawDragSquareOutline(Game game)
{
	ZCheckersSquare sq;
	ZRect rect;

	if (ZCheckersSquareFromPoint(game, &game->dragPoint, &sq))
	{
		/* don't outline white squares */
		if ( sq.row & 0x1 )
		{
			if ( !(sq.col & 0x1 ) )
				return;
		}
		else
		{
			if ( sq.col & 0x1 )
				return;
		}

		GetPieceRect(game,&rect,sq.col,sq.row);
		ZSetPenWidth(game->gameWindow,zDragSquareOutlineWidth);
		ZSetForeColor(game->gameWindow,(ZColor*) ZGetStockObject(zObjectColorWhite));
		ZRectDraw(game->gameWindow,&rect);
	}
}

static void EraseDragSquareOutline(Game game)
{
	ZCheckersSquare sq;

	if (ZCheckersSquareFromPoint(game, &game->dragPoint, &sq)) {

		if (ZCheckersSquareEqual(&sq,&game->selectedSquare)) {
			/* if this was the square the piece came from, just redraw background */
			GetPieceBackground(game,game->gameWindow,NULL,sq.col,sq.row);
		} else {
			/* redraw whatever piece might have been there */
			UpdateSquare(game,&sq);
		}
	}
}

static void SaveDragBackground(Game game)
/* calc the save backgroud rect around the drag point */
{
	ZRect rect;
	ZPoint point;

	point = game->dragPoint;
	rect.left = 0; rect.top = 0;
	rect.right = zCheckersPieceImageWidth;
	rect.bottom = zCheckersPieceImageHeight;
	game->rectSaveDragBackground = rect;
	ZRectOffset(&game->rectSaveDragBackground, (int16)(point.x-zCheckersPieceImageWidth/2),
					(int16)(point.y - zCheckersPieceImageHeight/2));

	/* copy the whole background to the offscreen port */
	ZCopyImage(game->gameWindow, game->offscreenSaveDragBackground, 
			&game->rectSaveDragBackground, &rect, NULL, zDrawCopy);
}


static void DrawDragPiece(Game game, BOOL bDrawInMemory)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	ZCheckersSquare sq;
	
	/* could be called from zMessageDraw, do nothing if no piece dragging */
	if (game->gameState != zGameStateDragPiece && game->gameState != zGameStateAnimatePiece) {
		return;
	}

	if (ZCheckersSquareFromPoint(game, &game->dragPoint, &sq)) {
		SaveDragBackground(game);
 
 		/* for person dragging, we will out line square moved */
 		if (game->gameState == zGameStateDragPiece)
			DrawDragSquareOutline(game);

		/* draw the piece on the screen! */
		{
			ZImage image = gGameImages[ZCheckersPieceImageNum(game->dragPiece)];

			if (image != NULL) {
				if (bDrawInMemory)
				{
					ZBeginDrawing(gOffscreenGameBoard);
					ZImageDraw(image, gOffscreenGameBoard, &game->rectSaveDragBackground, NULL, zDrawCopy);
					ZEndDrawing(gOffscreenGameBoard);
				}
				else
				{
					ZBeginDrawing(game->gameWindow);
					ZImageDraw(image, game->gameWindow, &game->rectSaveDragBackground, NULL, zDrawCopy);
					ZEndDrawing(game->gameWindow);
				}
			}
		}
	}
}

static void EraseDragPiece(Game game)
{
	ZRect rect;

 	/* for person dragging, we will out line square moved */
 	if (game->gameState == zGameStateDragPiece)
		EraseDragSquareOutline(game);

	rect = game->rectSaveDragBackground;
	ZRectOffset(&rect, (int16)-rect.left, (int16) -rect.top);

	/* copy the whole background from the offscreen port */
	ZCopyImage(game->offscreenSaveDragBackground, game->gameWindow, 
			&rect, &game->rectSaveDragBackground, NULL, zDrawCopy);

}

static void EndDragState(Game game)
{
	if (game->gameState == zGameStateDragPiece) {
		EraseDragPiece(game);
		CheckersSetGameState(game,zGameStateMove);
	}
}

static void ClearDragState(Game game)
{
	if (game->gameState == zGameStateDragPiece) {
		EraseDragPiece(game);
		CheckersSetGameState(game,zGameStateMove);
		UpdateSquare(game,&game->selectedSquare);
	}
}

void UpdateSquare(Game game, ZCheckersSquare* sq)
{
	ZCheckersSquare squares[2];

	/* redraw piece where it was moved from */
	ZCheckersSquareSetNull(&squares[1]);
	squares[0] = *sq;
	UpdateSquares(game,squares);
}

static void HandleButtonUp(ZWindow window, ZMessage* pMessage)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	Game				game;
	ZCheckersSquare		sq;

	game = (Game) pMessage->userData;
	
	if (game->gameState == zGameStateDragPiece) {

		/* make sure piece ends on valid square and not on same square */
		if (ZCheckersSquareFromPoint(game, &pMessage->where, &sq)) {
			if (!ZCheckersSquareEqual(&sq,&game->selectedSquare)) {
				/* try the move */
				// Barna 091099
				//ZBool legal;
				int16 legal;
				ZCheckersMove move;
				ZCheckersPiece piece = ZCheckersPieceAt(game->checkers, &sq);

				/* in all these cases, end the drag state */
				EndDragState(game);

				move.start = game->selectedSquare;
				move.finish = sq;
				legal = ZCheckersIsLegalMove(game->checkers, &move);
				if (legal == zCorrectMove) {
					/* send message to other player (comes to self too) */
					{
						ZCheckersMsgMovePiece		msg;

						msg.move = move;
						msg.seat = game->seat;
						ZCheckersMsgMovePieceEndian(&msg);

						ZCRoomSendMessage(game->tableID, zCheckersMsgMovePiece, &msg, sizeof(ZCheckersMsgMovePiece));
						/* for speed, send our move directly to be processed */
						/* don't wait for it to go to server and back */
						HandleMovePieceMessage(game, (ZCheckersMsgMovePiece*)&msg);
						// if it is the very first move then enable the rollover buttons
						if (game->bMoveNotStarted == TRUE)
							game->bMoveNotStarted = FALSE;

                        // if it's still our turn, re-attach the piece
                        ZCheckersPiece piece = ZCheckersPieceAt(game->checkers, &sq);
    	                if(ZCheckersPlayerIsMyMove(game) && piece != zCheckersPieceNone && game->seat == ZCheckersPieceOwner(piece))
                        {
			                game->selectedSquare = sq;
			                CheckersSetGameState(game,zGameStateDragPiece);

			                PrepareDrag(game, piece, pMessage->where);
			                UpdateDragPiece(game, true);
                        }
					}
				} else {
					/* illegal move */
					UpdateSquare(game,&move.start);
					ZPlaySound( game, zSndIllegalMove, FALSE, FALSE );
					if (legal == zMustJump)
					{ /* Must jump*/ 
						ZShellGameShell()->ZoneAlert((TCHAR*)gStrMustJumpText);
					}
				}
			} else {
				/* square button up is same as square button down */
				/* lets assume single click and support single clicks */
				/* to move a piece */
				/* do not end the drag state */
				/* was it the same point, ie no drag? */
                /* this should be timeout based, not pixel based */
				int16 dx = game->startDragPoint.x - pMessage->where.x;
				int16 dy = game->startDragPoint.y - pMessage->where.y;
				if (!(dx > -2 && dx < 2 && dy > -2 && dy < 2)) {
					/* else, just clear the drag state, user has placed piece back */
					/* restore piece to original square */
					EndDragState(game);
					UpdateSquare(game,&game->selectedSquare);
				}
				/* yes, this was  a single click, allow piece to */
				/* be in drag state */
			}
		} else {
			EndDragState(game);
			/* not a legal square to drop piece on, don't move it */
			/* restore piece to original square */
			UpdateSquare(game,&game->selectedSquare);
			//leonp Bugfix #4034 - Force an update on a cancelled move.
			ZWindowInvalidate( game->gameWindow, NULL );
		}

	}
}

static void HandleIdleMessage(ZWindow window, ZMessage* pMessage)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	Game				game;

	game = (Game) pMessage->userData;

	if (game->gameState == zGameStateDragPiece && gActivated)
	{
		UpdateDragPiece(game, false);
	}
}

static void GameSendTalkMessage(ZWindow window, ZMessage* pMessage)
{
#if 0
	ZCheckersMsgTalk*			msgTalk;
	Game					game;
	int16					msgLen;
	ZPlayerInfoType			playerInfo;
	
	
	game = (Game) pMessage->userData;
	if (game != NULL)
	{
		msgLen = sizeof(ZCheckersMsgTalk) + pMessage->messageLen;
		msgTalk = (ZCheckersMsgTalk*) ZCalloc(1, msgLen);
		if (msgTalk != NULL)
		{
			ZCRoomGetPlayerInfo(zTheUser, &playerInfo);
			msgTalk->userID = playerInfo.playerID;
			msgTalk->seat = game->seat;
			msgTalk->messageLen = (uint16)pMessage->messageLen;
			z_memcpy((TCHAR*) msgTalk + sizeof(ZCheckersMsgTalk), (TCHAR*) pMessage->messagePtr,
					pMessage->messageLen);
			ZCheckersMsgTalkEndian(msgTalk);
			ZCRoomSendMessage(game->tableID, zCheckersMsgTalk, (void*) msgTalk, msgLen);
			ZFree((TCHAR*) msgTalk);
		}
		else
		{
#if 1
			ZShellGameShell()->ZoneAlert(ErrorTextOutOfMemory);
#else
			ZAlert(_T("Out of memory."),NULL);
#endif
		}
	}
#endif
}


static void SendFinishMoveMessage(Game game, ZCheckersPiece piece)
{
	ZCheckersMsgFinishMove		msg;

	msg.piece = piece;	
	msg.seat = game->seat;
	msg.drawSeat = game->seatOfferingDraw;
	ZCheckersMsgFinishMoveEndian(&msg);
	ZCRoomSendMessage(game->tableID, zCheckersMsgFinishMove, (void*) &msg, sizeof(ZCheckersMsgFinishMove));
	HandleFinishMoveMessage(game,&msg);
}

static bool HandleMovePieceMessage(Game game, ZCheckersMsgMovePiece* msg)
{
	ZCheckersSquare* squares;
	ZCheckersPiece pieceCaptured;
	int32 flags;
	ZCheckersMsgMovePieceEndian(msg);

    // validation
    if(msg->seat != ZCheckersPlayerToMove(game->checkers) || game->gameState != zGameStateMove || game->fMoveOver)
        return false;

	/* if this was not my move, prepare to do some animation! */
	if (msg->seat != game->seat) {
		game->animateMove = msg->move;
		game->animatePiece = ZCheckersPieceAt(game->checkers, &msg->move.start);
	}

	/* do something here for the moved piece */
	squares = ZCheckersMakeMove(game->checkers, &msg->move, &pieceCaptured, &flags);
	if( !squares )
	{
		//This could result from recieving an illegal move
		return false;
	}

	/* king sond high priority than capture */
	if (flags & zCheckersFlagPromote)
	{
		ZPlaySound( game, zSndKing, FALSE, FALSE );
	}
	else if (ZCheckersPieceType(pieceCaptured) != zCheckersPieceNone)
	{
		ZPlaySound( game, zSndCapture, FALSE, FALSE );
	}
	
    if(!(flags & zCheckersFlagContinueJump))
        game->fMoveOver = true;

	/* if my move, then send finish move message */
	/* else, other player will send it */
	if (msg->seat == game->seat && !game->kibitzer) {
		/* don't call finish move, til we are free with jumps or there was a promotion */
		if (!(flags & zCheckersFlagContinueJump)) {

            game->bOpponentTimeout=FALSE;
            game->bEndLogReceived=FALSE;
        	game->bStarted=TRUE;

			SendFinishMoveMessage(game, zCheckersPieceNone);
		} 
	}

	if (flags & zCheckersFlagContinueJump) {
		/* this is the first jump of many, update the squares */
		UpdateSquares(game,squares);
	}
	return true;

}

static bool HandleEndGameMessage(Game game, ZCheckersMsgEndGame* msg)
{
	ZCheckersMsgEndGameEndian(msg);

    if((msg->flags != zCheckersFlagResign || game->gameState != zGameStateMove || msg->seat != ZCheckersPlayerToMove(game->checkers)) &&
        (msg->flags != zCheckersFlagDraw || game->gameState != zGameStateDraw || msg->seat))
        return false;

	//set so that when quitting correct state can be known
	game->bStarted=FALSE;
    game->bOpponentTimeout=FALSE;
    game->bEndLogReceived=FALSE;

	/* game has now finished */	
	ZCheckersEndGame(game->checkers, msg->flags);

	FinishMoveUpdateStateHelper(game,NULL);
    return true;
}

static void HandleEndLogMessage(Game game, ZCheckersMsgEndLog* msg)
{
/*
    if (!game->kibitzer)
    {
	    if (msg->reason==zCheckersEndLogReasonTimeout)
	    {
		    if (msg->seatLosing==game->seat)
		    {
			    ZAlert( zEndLogTimeoutStr, game->gameWindow);
			    game->bEndLogReceived=TRUE;
		    }
		    
	    } 
	    else if (msg->reason==zCheckersEndLogReasonForfeit)
	    {
		    if (msg->seatLosing!=game->seat)
		    {
                if (ZCRoomGetRoomOptions() & zGameOptionsRatingsAvailable )
                {
			        ZAlert(zEndLogForfeitStr, game->gameWindow);
			        game->bEndLogReceived=TRUE;
                }
                else
                {
                    ZAlert(zEndLogWontPlayStr, game->gameWindow);
		            game->bEndLogReceived=TRUE;
                }
			    
		    } 
	    }
        else 
        {
            if (msg->seatLosing!=game->seat)
    	    {
	            ZAlert(zEndLogWontPlayStr, game->gameWindow);
		        game->bEndLogReceived=TRUE;
            }     
	    }


	    if (game->exitInfo)
	    {
		    ZInfoDelete(game->exitInfo);
		    game->exitInfo=NULL;
	    }
    }
*/
#if 1
	ZShellGameShell()->GameCannotContinue(game);
#else
    ZCRoomGameTerminated( game->tableID);
#endif
	
}

static void HandleMoveTimeout(Game game, ZCheckersMsgMoveTimeout* msg)
{
	/*BYTE buff[512];

    if (!game->kibitzer)
    {
	    if ( msg->seat == game->seat ) 
	    {
	    }
	    else
	    {
		    game->bOpponentTimeout=TRUE;
		    wsprintf((TCHAR*)buff,zTimeoutStr,msg->userName,msg->timeout);
		    ZAlert((TCHAR*)buff,  game->gameWindow) ;
	    }
    }  */    

}


static void FinishMoveUpdateStateHelper(Game game, ZCheckersSquare* squaresChanged) 
{
#ifdef ZONECLI_DLL
	GameGlobals pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	/* normal players will be in the move state or the game over state */
	if ( ZCheckersIsGameOver(game->checkers,&game->finalScore) )
	{
		CheckersSetGameState(game,zGameStateGameOver);
		AddResultboxAccessibility();
		if (ZCheckersPlayerIsBlack(game)) // Assumption : First player is Red. This restriction is only for the first player.
			game->bMoveNotStarted = TRUE;
	}
	else
	{
		if(game->seatOfferingDraw != -1)
			CheckersSetGameState( game, zGameStateDraw );
		else
			CheckersSetGameState( game, zGameStateMove );
	}

	if (squaresChanged)
	{
		/* the move was made, update board */
		UpdateSquares(game,squaresChanged);
	}

	UpdateMoveIndicator(game);

	/* see that this gets drawn after the squares changed gets updated */
	if (game->gameState == zGameStateGameOver) {
		UpdateResultBox(game);
		/* goto the pre-inited state to start a new game */
		if (gDontDrawResults){
			ZShellGameShell()->GameOver( Z(game) );
		}
		//ZTimerSetTimeout(game->resultBoxTimer, 0);		// Stop the timer for now.
	}
}

static bool HandleFinishMoveMessage(Game game, ZCheckersMsgFinishMove* msg)
{
		int32 flags;
	ZCheckersSquare* squares;

	ZCheckersMsgFinishMoveEndian(msg);

    msg->time = 0;  // unused
    msg->piece = 0;  // unused
    if(msg->seat != ZCheckersPlayerToMove(game->checkers) || (msg->drawSeat != -1 && msg->drawSeat != msg->seat) ||
        game->gameState != zGameStateMove || !game->fMoveOver)
        return false;

	/* draw included with move? */
	if ( msg->drawSeat != -1 )
		game->seatOfferingDraw = msg->drawSeat;

	/* if end of opponents move, we must animate a piece for about a sec */
	if (game->seat != msg->seat) {
		CheckersSetGameState(game,zGameStateAnimatePiece);
		AnimateBegin(game,  msg);
	} else {
		squares = ZCheckersFinishMove(game->checkers, &flags);

		/* our move, skip animation */
		FinishMoveUpdateStateHelper(game,squares);
	}

    game->fMoveOver = false;

    return true;
}

static void AnimateTimerProc(ZTimer timer, void* userData)
{
	Game game = (Game)userData;

	ZBeginDrawing(game->gameWindow);

	EraseDragPiece(game);
	game->dragPoint.x += game->animateDx;
	game->dragPoint.y += game->animateDy;

	game->animateStepsLeft--;
	if (game->animateStepsLeft < 0) {
		int32 flags;
		ZCheckersSquare *squares;
		/* done with animation */
		/* stop timer */
		ZTimerSetTimeout(timer,0);

		squares = ZCheckersFinishMove(game->checkers, &flags);

		/* allow player to enter move now */
		FinishMoveUpdateStateHelper(game,squares);

		/* play turn alert if appropriate */
		if (	(ZCheckersPlayerIsMyMove(game))
			&&	(game->gameState != zGameStateGameOver) )
		{
			ZPlaySound( game, zSndTurnAlert, FALSE, FALSE );
            ZShellGameShell()->MyTurn();
		}

		// Beta2 bug #15398
		if (game->bDrawPending == TRUE)
		{
			game->bDrawPending = FALSE;
			ZWindowInvalidate( game->gameWindow, NULL );
		}
	} else {
		/* still dragging */
		DrawDragPiece(game, FALSE);
	}

	ZEndDrawing(game->gameWindow);
}

static void AnimateBegin(Game game, ZCheckersMsgFinishMove* msg)
{
	ZRect	rect;
	ZCheckersSquare start,finish;
	ZPoint point;
	int16 x0,y0,x1,y1;
	
	start = game->animateMove.start;
	finish = game->animateMove.finish;

	/* find position to animate from and to, use center of squares */
	GetPieceRect(game, &rect, start.col, start.row);
	x0 = (rect.left + rect.right)/2;
	y0 = (rect.top + rect.bottom)/2;
	GetPieceRect(game, &rect, finish.col, finish.row);
	x1 = (rect.left + rect.right)/2;
	y1 = (rect.top + rect.bottom)/2;

	game->dragPoint.x = x0;
	game->dragPoint.y = y0;
/*	game->animateStepsLeft = (abs(x1-x0) + abs(y1-y0))/zAnimateVelocity; */
	game->animateStepsLeft = zAnimateSteps;
	game->animateDx = (x1 - x0)/game->animateStepsLeft;
	game->animateDy = (y1 - y0)/game->animateStepsLeft;

	point.x = x0;
	point.y = y0;
	PrepareDrag(game, game->animatePiece, point);

	ZTimerInit(game->animateTimer, zAnimateInterval,AnimateTimerProc,(void*)game);
}

static void HandleGameStateReqMessage(Game game, ZCheckersMsgGameStateReq* msg)
{
	int32 size;
	ZCheckersMsgGameStateResp* resp;

	ZCheckersMsgGameStateReqEndian(msg);

	if( msg->userID != game->players[msg->seat].userID )
	{
		ZShellGameShell()->ZoneAlert( ErrorTextSync, NULL, NULL, TRUE, FALSE );
		return;
	}

	/* allocate enough storage for the full resp */
	size = ZCheckersGetStateSize(game->checkers);
	size += sizeof(ZCheckersMsgGameStateResp);
	resp = (ZCheckersMsgGameStateResp*)ZMalloc(size);
	if (!resp){
		ZShellGameShell()->ZoneAlert(ErrorTextOutOfMemory);
		return;
	}

	resp->userID = msg->userID;
	resp->seat = msg->seat;

	/* copy the local game state */
	{
		int i;
		resp->gameState = game->gameState;
		resp->finalScore = game->finalScore;
		for (i = 0;i < 2;i++) {
			resp->newGameVote[i] = game->newGameVote[i];
			resp->players[i] = game->players[i];
		}
	}

	/* copy the full checkers state to send to the kibitzer */
	ZCheckersGetState(game->checkers,(TCHAR*)resp + sizeof(ZCheckersMsgGameStateResp));

	ZCheckersMsgGameStateRespEndian(resp);
	ZCRoomSendMessage(game->tableID, zCheckersMsgGameStateResp, resp, size);
}

static void HandleGameStateRespMessage(Game game, ZCheckersMsgGameStateResp* msg)
{
	ZCheckersMsgGameStateRespEndian(msg);

	/* if we get this, we better be in the kibitzer state */
	if (game->gameState != zGameStateKibitzerInit) {
#if 1
		ZShellGameShell()->ZoneAlert(_T("StateError, kibitzer state expected when game state resp received"));
#else
		ZAlert(_T("StateError, kibitzer state expected when game state resp received"),NULL);
#endif
	}

	/* copy the local game state */
	{
		int i;
		game->gameState = msg->gameState;
		game->finalScore = msg->finalScore;
		for (i = 0;i < 2;i++) {
			game->newGameVote[i] = msg->newGameVote[i];
			game->players[i] = msg->players[i];
		}
	}

	/* create new checkers object with kibitzer state */
	if (game->checkers) {
		ZCheckersDelete(game->checkers);
	}
	game->checkers = ZCheckersSetState((TCHAR*)msg + sizeof(ZCheckersMsgGameStateResp));

	/* cleart the special ignore messages flag for kibitzers */
	game->ignoreMessages = FALSE;

	/* start the clock if needed */
	if (game->gameState == zGameStateMove ||
		game->gameState == zGameStateDragPiece) {
		/* kibitzer can't have these state, must always be in gameStateMove */
		CheckersSetGameState( game, zGameStateMove );
	}

	/* we forgot to send the finalScore field over with the kibitzer... calculate it */
	ZCheckersIsGameOver(game->checkers,&game->finalScore);

	/* redraw the complete window when convenient */
	ZWindowInvalidate(game->gameWindow, NULL);
}

static bool HandleTalkMessage(Game game, ZCheckersMsgTalk* msg)
{
	ZPlayerInfoType		playerInfo;
    int i;
	
	ZCheckersMsgTalkEndian(msg);
#if 0	
	ZCRoomGetPlayerInfo(msg->userID, &playerInfo);
	ZWindowTalk(game->gameWindow, (_TUCHAR*) playerInfo.userName,
			(_TUCHAR*) msg + sizeof(ZCheckersMsgTalk));
#endif
    TCHAR *szText = (TCHAR *) ((BYTE *) msg + sizeof(ZCheckersMsgTalk));

    for(i = 0; i < msg->messageLen; i++)
        if(!szText[i])
            break;

    if(i == msg->messageLen || !msg->userID || msg->userID == zTheUser)
        return false;

    ZShellGameShell()->ReceiveChat(Z(game), msg->userID, szText, msg->messageLen / sizeof(TCHAR));
    return true;
}

static bool HandleVoteNewGameMessage(Game game, ZCheckersMsgVoteNewGame* msg)
{
	ZCheckersMsgVoteNewGameEndian(msg);

    if((msg->seat != 1 && msg->seat != 0) || (game->gameState != zGameStateGameOver &&
        (game->gameState != zGameStateWaitNew || game->seat == msg->seat) && game->gameState != zGameStateNotInited))
        return false;

	ZShellGameShell()->GameOverPlayerReady( Z(game), game->players[msg->seat].userID );
    return true;
}

static bool HandleNewGameMessage(Game game, ZCheckersMsgNewGame* msg)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	
	gDontDrawResults = FALSE;
	game->seatOfferingDraw = -1;
    game->fIVoted = false;
    game->fMoveOver = false;

	ZCheckersMsgNewGameEndian(msg);

    // not looking at versions, etc. because the old client didn't set them right
    if((msg->seat != 0 && msg->seat != 1) || (game->gameState != zGameStateGameOver &&
        (game->gameState != zGameStateWaitNew || msg->seat == game->seat) && game->gameState != zGameStateNotInited) ||
        game->newGameVote[msg->seat] || msg->playerID == zTheUser || !msg->playerID)
        return false;

	if (msg->seat < zNumPlayersPerTable)
	{
		game->newGameVote[msg->seat] = TRUE;

		// inform the shell and the upsell dialog.
		/* get the player name and hostname... for later */
		{
			ZPlayerInfoType			playerInfo;
			uint16 i = msg->seat;
			TCHAR strName [80];

			ZCRoomGetPlayerInfo(msg->playerID, &playerInfo);
            if(!playerInfo.userName[0])
                return false;

			//ZCRoomGetPlayerInfo(game->players[i].userID, &playerInfo);
			game->players[i].userID = playerInfo.playerID;

			// Barna 090999
			// Player name is ot the user name instead it will be obtained from the RSC
			lstrcpy((TCHAR*) game->players[i].name, (TCHAR*) playerInfo.userName);

			lstrcpy((TCHAR*) game->players[i].host, (TCHAR*) playerInfo.hostName);
			UpdatePlayers(game);
		}
	}
	/* if we are waiting for a client ready message and this is not ours.. */
	if (game->newGameVote[0] && game->newGameVote[1])
	{
		// take down the upsell dialog
		ZShellGameShell()->GameOverGameBegun( Z(game) );
		CheckersInitNewGame(game);
		if (ZCheckersPlayerIsBlack(game)) // Assumption : First player is Red. This restriction is only for the first player.
			game->bMoveNotStarted = TRUE;
		else
        {
			game->bMoveNotStarted = FALSE;
            ZShellGameShell()->MyTurn();
        }

		game->bDrawPending = FALSE;
		CheckersSetGameState(game,zGameStateMove);
		//InitAccessibility(game, game->m_pIGG);
		RemoveResultboxAccessibility(); 
	}
	else if (game->newGameVote[game->seat] && !game->newGameVote[!game->seat])
	{
		CheckersSetGameState( game, zGameStateWaitNew );
	}

	if(game->drawDialog)
	{
		DestroyWindow(game->drawDialog);
		game->drawDialog = NULL;
	}

	/* update the whole borad */
	//if (msg->seat == game->seat)
	ZWindowInvalidate(game->gameWindow, NULL);
    return true;
}

/* for now... kibitzers will receive names in the players message */
/* the structure sent will be the new game msg */
static void HandlePlayersMessage(Game game, ZCheckersMsgNewGame* msg)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	ZCheckersMsgNewGameEndian(msg);

	/* get the player name and hostname... for later */
	{
		ZPlayerInfoType			playerInfo;
		uint16 i = msg->seat;
		ZCRoomGetPlayerInfo(msg->playerID, &playerInfo);
		//ZCRoomGetPlayerInfo(zTheUser, &playerInfo);
		game->players[i].userID = playerInfo.playerID;

		// Barna 090999
		// Player name is ot the user name instead it will be obtained from the RSC
		lstrcpy((TCHAR*) game->players[i].name, (TCHAR*) playerInfo.userName);

		lstrcpy((TCHAR*) game->players[i].host, (TCHAR*) playerInfo.hostName);
		UpdatePlayers(game);
	}
}

static void LoadRoomImages(void)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
#if 0 // Barna 092999
	ZError				err = zErrNone;
	ZResource			resFile;
	

	resFile = ZResourceNew();
	if ((err = ZResourceInit(resFile, ZGetProgramDataFileName(zGameImageFileName))) == zErrNone)
	{
		gGameIdle = ZResourceGetImage(resFile, zImageGameIdle + zRscOffset);
		gGaming = ZResourceGetImage(resFile, zImageGaming + zRscOffset);
		
		ZResourceDelete(resFile);
	}
	else
	{
		ZAlert(_T("Failed to open image file."),);
	}
#endif
}


static ZBool GetObjectFunc(int16 objectType, int16 modifier, ZImage* image, ZRect* rect)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif

#if 0	// Barna 092999
	switch (objectType)
	{
		case zRoomObjectGameMarker:
			if (image != NULL)
			{
				if (modifier == zRoomObjectIdle)
					*image = gGameIdle;
				else if (modifier == zRoomObjectGaming)
					*image = gGaming;
			}
			return (TRUE);
	}
#endif 	
	return (FALSE);
}


static void DeleteObjectsFunc(void)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	
#if 0	// Brana 092999
	if (gGameIdle != NULL)
		ZImageDelete(gGameIdle);
	gGameIdle = NULL;
	if (gGaming != NULL)
		ZImageDelete(gGaming);
	gGaming = NULL;
#endif
}


/***********************************************************************************************/
/* Options Window */
/***********************************************************************************************/

static void HandleOptionsMessage(Game game, ZGameMsgTableOptions* msg)
{
	ZGameMsgTableOptionsEndian(msg);
	
	//game->tableOptions[msg->seat] = msg->options;
	
	UpdateOptions(game);
	
	OptionsWindowUpdate(game, msg->seat);
}


#if 0
static void OptionsButtonFunc(ZButton button, void* userData)
{
	ShowOptions(I(userData));
}
#endif

// Barna 090999
static ZBool DrawRButtonFunc(ZRolloverButton button, int16 state, void * userData)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif

	Game game = (Game) userData;
	DWORD dResult;
	ZCheckersMsgDraw 	msg;

	//if(state!=zRolloverButtonDown)
		//return TRUE;
	//DrawBackground (game,&zDrawButtonRect);
	if(state!=zRolloverButtonClicked || game->gameState != zGameStateMove || !ZCheckersPlayerIsMyMove(game))
		return TRUE;

    if(game->seatOfferingDraw != -1)
        game->seatOfferingDraw = -1;
    else
        game->seatOfferingDraw = game->seat;

	gCheckersIGA->SetFocus(1);
    UpdateDrawWithNextMove(game);
	
	return TRUE;
}
// Barna 090999

#if 0
static void ShowOptions(Game game)
{
	int16			i;
	ZBool			enabled, checked;
	
	
	game->optionsWindow = ZWindowNew();
	if (game->optionsWindow == NULL)
		goto OutOfMemoryExit;
	if (ZWindowInit(game->optionsWindow, &gOptionsRects[zRectOptions],
			zWindowDialogType, game->gameWindow, _T("Options"), TRUE, FALSE, TRUE,
			OptionsWindowFunc, zWantAllMessages, game) != zErrNone)
		goto OutOfMemoryExit;
	
	/* Create the check boxes. */
	for (i = 0; i < zNumPlayersPerTable; i++)
	{
		enabled = (i == game->seat) && !(game->tableOptions[i] & zRoomTableOptionTurnedOff);
		
		checked = !(game->tableOptions[i] & zRoomTableOptionNoKibitzing);
		if ((game->optionsKibitzing[i] = ZCheckBoxNew()) == NULL)
			goto OutOfMemoryExit;
		if (ZCheckBoxInit(game->optionsKibitzing[i], game->optionsWindow,
				&gOptionsRects[gOptionsKibitzingRectIndex[i]], NULL, checked, TRUE, enabled,
				OptionsCheckBoxFunc, game) != zErrNone)
			goto OutOfMemoryExit;
	}
	
	if ((game->optionsBeep = ZCheckBoxNew()) == NULL)
		goto OutOfMemoryExit;
	if (ZCheckBoxInit(game->optionsBeep, game->optionsWindow,
			&gOptionsRects[zRectOptionsBeep], zBeepOnTurnStr, game->beepOnTurn, TRUE, TRUE,
			OptionsCheckBoxFunc, game) != zErrNone)
		goto OutOfMemoryExit;

	/* Create button. */
	if ((game->optionsWindowButton = ZButtonNew()) == NULL)
		goto OutOfMemoryExit;
	if (ZButtonInit(game->optionsWindowButton, game->optionsWindow,
			&gOptionsRects[zRectOptionsOkButton], _T("Done"), TRUE,
			TRUE, OptionsWindowButtonFunc, game) != zErrNone)
		goto OutOfMemoryExit;
	ZWindowSetDefaultButton(game->optionsWindow, game->optionsWindowButton);
	
	/* Make the window modal. */
	ZWindowModal(game->optionsWindow);
	
	goto Exit;

OutOfMemoryExit:
		ZShellGameShell()->ZoneAlert(ErrorTextOutOfMemory);
	
Exit:
	
	return;
}
#endif

#if 0
static void OptionsWindowDelete(Game game)
{
	int16			i;
	
	
	for (i = 0; i < zNumPlayersPerTable; i++)
	{
		if (game->optionsKibitzing[i] != NULL)
			ZCheckBoxDelete(game->optionsKibitzing[i]);
		game->optionsKibitzing[i] = NULL;
		game->optionsJoining[i] = NULL;
	}

	if (game->optionsBeep != NULL)
		ZCheckBoxDelete(game->optionsBeep);
	game->optionsBeep = NULL;

	if (game->optionsWindowButton != NULL)
		ZButtonDelete(game->optionsWindowButton);
	game->optionsWindowButton = NULL;

	if (game->optionsWindow != NULL)
		ZWindowDelete(game->optionsWindow);
	game->optionsWindow = NULL;
}
#endif 

#if 0
static ZBool OptionsWindowFunc(ZWindow window, ZMessage* message)
{
	Game		game = I(message->userData);
	ZBool		msgHandled;
	
	
	msgHandled = FALSE;
	
	switch (message->messageType) 
	{
		case zMessageWindowDraw:
			ZBeginDrawing(game->optionsWindow);
			ZRectErase(game->optionsWindow, &message->drawRect);
			ZEndDrawing(game->optionsWindow);
			OptionsWindowDraw(game);
			msgHandled = TRUE;
			break;
		case zMessageWindowClose:
			OptionsWindowDelete(game);
			msgHandled = TRUE;
			break;
	}
	
	return (msgHandled);
}
#endif

static void OptionsWindowUpdate(Game game, int16 seat)
{
	if (game->optionsWindow != NULL)
	{
		if (game->tableOptions[seat] & zRoomTableOptionNoKibitzing)
			ZCheckBoxUnCheck(game->optionsKibitzing[seat]);
		else
			ZCheckBoxCheck(game->optionsKibitzing[seat]);
	}
}

#if 0
static void OptionsWindowButtonFunc(ZButton button, void* userData)
{
	Game			game = I(userData);
	
	
	/* Hide the window and send a close window message. */
	ZWindowNonModal(game->optionsWindow);
	ZWindowHide(game->optionsWindow);
	ZPostMessage(game->optionsWindow, OptionsWindowFunc, zMessageWindowClose, NULL, NULL,
			0, NULL, 0, game);
}
#endif

#if 0
static void OptionsWindowDraw(Game game)
{
	int16			i;


	ZBeginDrawing(game->optionsWindow);

	ZSetFont(game->optionsWindow, (ZFont) ZGetStockObject(zObjectFontSystem12Normal));
	ZSetForeColor(game->optionsWindow, (ZColor*) ZGetStockObject(zObjectColorBlack));

	ZDrawText(game->optionsWindow, &gOptionsRects[zRectOptionsKibitzingText],
			zTextJustifyCenter, _T("Kibitzing"));

	/* Draw player names. */
	ZSetForeColor(game->optionsWindow, (ZColor*) ZGetStockObject(zObjectColorGray));
	for (i = 0; i < zNumPlayersPerTable; i++)
	{
		if (i != game->seat)
			ZDrawText(game->optionsWindow, &gOptionsRects[gOptionsNameRects[i]],
					zTextJustifyLeft, (TCHAR*) game->players[i].name);
	}
	ZSetForeColor(game->optionsWindow, (ZColor*) ZGetStockObject(zObjectColorBlack));
	ZDrawText(game->optionsWindow, &gOptionsRects[gOptionsNameRects[game->seat]],
			zTextJustifyLeft, (TCHAR*) game->players[game->seat].name);
	
	ZEndDrawing(game->optionsWindow);
}
#endif

#if 0
static void OptionsCheckBoxFunc(ZCheckBox checkBox, ZBool checked, void* userData)
{
	Game				game = (Game) userData;
	ZGameMsgTableOptions	msg;
	ZBool				optionsChanged = FALSE;

	
	if (game->optionsKibitzing[game->seat] == checkBox)
	{
		if (checked)
			game->tableOptions[game->seat] &= ~zRoomTableOptionNoKibitzing;
		else
			game->tableOptions[game->seat] |= zRoomTableOptionNoKibitzing;
		optionsChanged = TRUE;
	}
	else if (game->optionsJoining[game->seat] == checkBox)
	{
		if (checked)
			game->tableOptions[game->seat] &= ~zRoomTableOptionNoJoining;
		else
			game->tableOptions[game->seat] |= zRoomTableOptionNoJoining;
		optionsChanged = TRUE;
	}
	else if (game->optionsBeep == checkBox)
	{
		game->beepOnTurn = checked;
	}
	
	if (optionsChanged)
	{
		msg.seat = game->seat;
		msg.options = game->tableOptions[game->seat];
		ZGameMsgTableOptionsEndian(&msg);
		ZCRoomSendMessage(game->tableID, zGameMsgTableOptions, &msg, sizeof(msg));
	}
}
#endif

static int16 FindJoinerKibitzerSeat(Game game, ZPoint* point)
{
	int16			i, seat = -1;
	
	
	for (i = 0; i < zNumPlayersPerTable && seat == -1; i++)
	{
		ZRect *rect = &gRects[gKibitzerRectIndex[GetLocalSeat(game,i)]];

		if (ZPointInRect(point, rect))
			seat = i;
	}
	
	return (seat);
}

#if 0
static void HandleJoinerKibitzerClick(Game game, int16 seat, ZPoint* point)
{
int16				playerType = zGamePlayer;
	ZPlayerInfoType		playerInfo;
	int16				i;
	ZLListItem			listItem;
	ZRect				rect;

	if (game->numKibitzers[seat] > 0)
			playerType = zGamePlayerKibitzer;
	
	if (playerType != zGamePlayer)
	{
		if (game->showPlayerWindow != NULL)
			ShowPlayerWindowDelete(game);
		
		/* Create player list. */
		game->showPlayerCount = game->numKibitzers[seat];
		if ((game->showPlayerList = (TCHAR**) ZCalloc(sizeof(TCHAR*), game->numKibitzers[seat])) == NULL)
			goto OutOfMemoryExit;
		for (i = 0; i < game->showPlayerCount; i++)
		{
			if ((listItem = ZLListGetNth(game->kibitzers[seat], i, zLListAnyType)) != NULL)
			{
				ZCRoomGetPlayerInfo((ZUserID) ZLListGetData(listItem, NULL), &playerInfo);
				if ((game->showPlayerList[i] = (TCHAR*) ZCalloc(1, lstrlen(playerInfo.userName) + 1)) == NULL)
					goto OutOfMemoryExit;
				lstrcpy(game->showPlayerList[i], playerInfo.userName);
			}
		}
		
		/* Create the window. */
		if ((game->showPlayerWindow = ZWindowNew()) == NULL)
			goto OutOfMemoryExit;
		ZSetRect(&rect, 0, 0, zShowPlayerWindowWidth, zShowPlayerLineHeight * game->showPlayerCount + 4);
		ZRectOffset(&rect, point->x, point->y);
		if (rect.right > gRects[zRectWindow].right)
			ZRectOffset(&rect, (int16)(gRects[zRectWindow].right - rect.right), (int16)0);
		if (rect.left < 0)
			ZRectOffset(&rect, (int16)-rect.left, (int16)0);
		if (rect.bottom > gRects[zRectWindow].bottom)
			ZRectOffset(&rect, (int16)0, (int16)(gRects[zRectWindow].bottom - rect.bottom));
		if (rect.top < 0)
			ZRectOffset(&rect, (int16)-rect.top, (int16)0);
		if (ZWindowInit(game->showPlayerWindow, &rect,
				zWindowPlainType, game->gameWindow, NULL, TRUE, FALSE, FALSE,
				ShowPlayerWindowFunc, zWantAllMessages, game) != zErrNone)
			goto OutOfMemoryExit;
		ZWindowTrackCursor(game->showPlayerWindow, ShowPlayerWindowFunc, game);
	}

	goto Exit;

OutOfMemoryExit:
		ZShellGameShell()->ZoneAlert(ErrorTextOutOfMemory);
	
Exit:
	
	return;
}
#endif


static ZBool ShowPlayerWindowFunc(ZWindow window, ZMessage* message)
{
	Game		game = I(message->userData);
	ZBool		msgHandled;
	
	
	msgHandled = FALSE;
	
	switch (message->messageType) 
	{
		case zMessageWindowDraw:
			ZBeginDrawing(window);
			ZRectErase(window, &message->drawRect);
			ZEndDrawing(window);
			ShowPlayerWindowDraw(game);
			msgHandled = TRUE;
			break;
		case zMessageWindowButtonDown:
		case zMessageWindowButtonUp:
			ZWindowHide(game->showPlayerWindow);
			ZPostMessage(game->showPlayerWindow, ShowPlayerWindowFunc,zMessageWindowClose,
				NULL, NULL, 0, NULL, 0, game);
			break;
		case zMessageWindowClose:
			ShowPlayerWindowDelete(game);
			msgHandled = TRUE;
			break;
	}
	
	return (msgHandled);
}

static void ShowPlayerWindowDraw(Game game)
{
	int16			i;
	ZRect			rect;


	ZBeginDrawing(game->showPlayerWindow);

	ZSetFont(game->showPlayerWindow, (ZFont) ZGetStockObject(zObjectFontApp9Normal));
	
	ZSetRect(&rect, 0, 0, zShowPlayerWindowWidth, zShowPlayerLineHeight);
	ZRectOffset(&rect, 0, 2);
	ZRectInset(&rect, 4, 0);
	for (i = 0; i < game->showPlayerCount; i++)
	{
		ZDrawText(game->showPlayerWindow, &rect, zTextJustifyLeft, game->showPlayerList[i]);
		ZRectOffset(&rect, 0, zShowPlayerLineHeight);
	}
	
	ZEndDrawing(game->showPlayerWindow);
}


static void ShowPlayerWindowDelete(Game game)
{
	int16			i;
	
	
	if (game->showPlayerList != NULL)
	{
		for (i = 0; i < game->showPlayerCount; i++)
			ZFree(game->showPlayerList[i]);
		ZFree(game->showPlayerList);
		game->showPlayerList = NULL;
	}
	
	if (game->showPlayerWindow != NULL)
	{
		ZWindowDelete(game->showPlayerWindow);
		game->showPlayerWindow = NULL;
	}
}


/***********************************************************************************************/
/* Sound Routines
/***********************************************************************************************/

static void ZInitSounds()
{
	TCHAR* IniFileName;
	int i;

	IniFileName = _T("zone.ini");
	for( i = 0; i < zSndLastEntry; i++ )
	{
		gSounds[i].played = FALSE;
		GetPrivateProfileString(
				_T("Checkers Sounds"),
				(TCHAR*)gSounds[i].SoundName,
				_T(""),
				(TCHAR*)gSounds[i].WavFile,
				sizeof(gSounds[i].WavFile),
				IniFileName );
	}
}


static void ZResetSounds()
{
	int i;
	for( i = 0; i < zSndLastEntry; i++ )
		gSounds[i].played = FALSE;
}


static void ZStopSounds()
{
	PlaySound( NULL, NULL, SND_ASYNC | SND_NODEFAULT | SND_PURGE );
}


static void ZPlaySound( Game game, int idx, ZBool loop, ZBool once_per_game )
{
	DWORD flags;

	/* should we NOT play the sound? */
	if (	(!game->beepOnTurn)
		||	((idx < 0) || (idx >= zSndLastEntry))
		||	(gSounds[idx].WavFile[0] == '\0' && !gSounds[idx].force_default_sound)
		||	(once_per_game && gSounds[idx].played) )
		return;
		
	flags = SND_ASYNC | SND_FILENAME;
	if (!gSounds[idx].force_default_sound)
		flags |= SND_NODEFAULT;
	if ( loop )
		flags |= SND_LOOP;
	if ( gSounds[idx].WavFile[0] == '\0' )
		ZBeep(); /* NT isn't playing the default sound */
	else
		PlaySound((TCHAR*)gSounds[idx].WavFile, NULL, flags );
	gSounds[idx].played = TRUE;
}

static void SuperRolloverButtonEnable(Game game, ZRolloverButton button)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif

    if(gCheckersIGA)
    {
        if(button == game->sequenceButton)
            gCheckersIGA->SetItemEnabled(true, IDC_RESIGN_BUTTON, false, 0);

        if(button == game->drawButton)
            gCheckersIGA->SetItemEnabled(true, IDC_DRAW_BUTTON, false, 0);
    }

    ZRolloverButtonEnable(button);
}

static void SuperRolloverButtonDisable(Game game, ZRolloverButton button)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif

    if(gCheckersIGA)
    {
        if(button == game->sequenceButton)
            gCheckersIGA->SetItemEnabled(false, IDC_RESIGN_BUTTON, false, 0);

        if(button == game->drawButton)
            gCheckersIGA->SetItemEnabled(false, IDC_DRAW_BUTTON, false, 0);
    }

    ZRolloverButtonDisable(button);
}

static void DrawGamePromptFunc(int16 result, void* userData)
{

	Game game = (Game) userData;
	ZCheckersMsgDraw msg;

	if(result == IDYES)
		msg.vote = zAcceptDraw;
	else
		msg.vote = zRefuseDraw;
	msg.seat = game->seat;
	ZCheckersMsgOfferDrawEndian(&msg);
	ZCRoomSendMessage(game->tableID, zCheckersMsgDraw, &msg, sizeof(msg));

    game->fIVoted = true;
}

#if 0
BOOL __stdcall DrawDlgProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
	Game game = (Game)GetWindowLong(hDlg,DWL_USER);
	
	switch(iMsg)
    {
        case WM_LBUTTONDOWN :
			DestroyWindow(game->drawDialog);
			if(game)
				game->drawDialog = NULL;
            return TRUE;
     }
	return FALSE;
}
#endif

// Dispayes turn on the game board
static void IndicatePlayerTurn(Game game, BOOL bDrawInMemory)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif

	HDC hdc;
	
	if (bDrawInMemory)
	{
		DrawBackground(NULL,&gRects[zRectPlayerTurn1]); 
		DrawBackground(NULL,&gRects[zRectPlayerTurn2]); 
		hdc = ZGrafPortGetWinDC( gOffscreenGameBoard );
	}
	else
	{
		DrawBackground(game,&gRects[zRectPlayerTurn1]); 
		DrawBackground(game,&gRects[zRectPlayerTurn2]); 
		hdc = ZGrafPortGetWinDC( game->gameWindow );
	}

	HFONT hOldFont = SelectObject( hdc, gCheckersFont[zFontIndicateTurn].m_hFont );
	COLORREF colorOld = SetTextColor( hdc, gCheckersFont[zFontIndicateTurn].m_zColor );

	if (ZCheckersPlayerIsMyMove(game)) {/* fill bottom spot with message */
		if (bDrawInMemory)
			ZDrawText(gOffscreenGameBoard, &gRects[zRectPlayerTurn2], zTextJustifyLeft, (TCHAR*)gStrYourTurn);
		else
			ZDrawText(game->gameWindow, &gRects[zRectPlayerTurn2], zTextJustifyLeft, (TCHAR*)gStrYourTurn);
	} else {/* fill top spot with the background */
		if (bDrawInMemory)
			ZDrawText(gOffscreenGameBoard, &gRects[zRectPlayerTurn1], (zTextJustifyWrap + zTextJustifyRight), (TCHAR*)gStrOppsTurn);
		else
			ZDrawText(game->gameWindow, &gRects[zRectPlayerTurn1], (zTextJustifyWrap + zTextJustifyRight), (TCHAR*)gStrOppsTurn);
	}

    SetTextColor(hdc, colorOld);
    SelectObject(hdc, hOldFont);
}


static void LoadStringsFromRsc(void)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	if (!ZShellResourceManager()->LoadString(IDS_UI_MSG_OPPONENT_TURN,	(TCHAR*)gStrOppsTurn,	NUMELEMENTS(gStrOppsTurn)))
		ZShellGameShell()->ZoneAlert(ErrorTextResourceNotFound);
	if (!ZShellResourceManager()->LoadString(IDS_UI_MSG_YOUR_TURN,	(TCHAR*)gStrYourTurn,		NUMELEMENTS(gStrYourTurn)))
		ZShellGameShell()->ZoneAlert(ErrorTextResourceNotFound);
	if (!ZShellResourceManager()->LoadString(IDS_UI_MSG_DRAW_PEND,	(TCHAR*)gStrDrawPend,	    NUMELEMENTS(gStrDrawPend)))
		ZShellGameShell()->ZoneAlert(ErrorTextResourceNotFound);
	if (!ZShellResourceManager()->LoadString(IDS_DLG_DRAW_OFFER,	(TCHAR*)gStrDrawOffer,		NUMELEMENTS(gStrDrawOffer)))
		ZShellGameShell()->ZoneAlert(ErrorTextResourceNotFound);
	if (!ZShellResourceManager()->LoadString(IDS_DLG_DRAW_REJECT,	(TCHAR*)gStrDrawReject,		NUMELEMENTS(gStrDrawReject)))
		ZShellGameShell()->ZoneAlert(ErrorTextResourceNotFound);
	if (!ZShellResourceManager()->LoadString(IDS_DRAW_PANE_TEXT,	(TCHAR*)gStrDrawText,		NUMELEMENTS(gStrDrawText)))
		ZShellGameShell()->ZoneAlert(ErrorTextResourceNotFound);
	if (!ZShellResourceManager()->LoadString(IDS_MUST_JUMP_TEXT,	(TCHAR*)gStrMustJumpText,	NUMELEMENTS(gStrMustJumpText)))
		ZShellGameShell()->ZoneAlert(ErrorTextResourceNotFound);
	if (!ZShellResourceManager()->LoadString(IDS_DLGDRAW_ACCEPT_TITLE,	(TCHAR*)gStrDrawAcceptCaption,	NUMELEMENTS(gStrDrawAcceptCaption)))
		ZShellGameShell()->ZoneAlert(ErrorTextResourceNotFound);
	if (!ZShellResourceManager()->LoadString(IDS_BTN_RESIGN,	(TCHAR*)gStrResignBtn,	NUMELEMENTS(gStrResignBtn)))
		ZShellGameShell()->ZoneAlert(ErrorTextResourceNotFound);
	if (!ZShellResourceManager()->LoadString(IDS_BTN_DRAW,		(TCHAR*)gStrDrawBtn,	NUMELEMENTS(gStrDrawBtn,)))
		ZShellGameShell()->ZoneAlert(ErrorTextResourceNotFound);
	if (!ZShellResourceManager()->LoadString(IDS_RESIGN_CONFIRM,(TCHAR*)gResignConfirmStr,	NUMELEMENTS(gResignConfirmStr)))
		ZShellGameShell()->ZoneAlert(ErrorTextResourceNotFound);
	if (!ZShellResourceManager()->LoadString(IDS_RESIGN_CONFIRM_CAPTION,(TCHAR*)gResignConfirmStrCap,	NUMELEMENTS(gResignConfirmStrCap)))
		ZShellGameShell()->ZoneAlert(ErrorTextResourceNotFound);

}	


void resultBoxTimerFunc(ZTimer timer, void* userData)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	// dismisses the result box 
	Game	game;
	game = (Game) userData;

	if (game->gameState == zGameStateGameOver && !gDontDrawResults)
	{
		gDontDrawResults = TRUE;
		ZWindowInvalidate( game->gameWindow, &gRects[zRectResultBox] );
	}
}


int CheckersFormatMessage( LPTSTR pszBuf, int cchBuf, int idMessage, ... )
{
    int nRet = 0;
    va_list list;
    TCHAR szFmt[1024];
	ZError err = zErrNone;
	if (ZShellResourceManager()->LoadString(idMessage, szFmt, sizeof(szFmt)/sizeof(szFmt[0])))
	{
		va_start( list, idMessage );
		nRet = FormatMessage( FORMAT_MESSAGE_FROM_STRING, szFmt, 
							  idMessage, 0, pszBuf, cchBuf, &list );
		va_end( list ); 
	}
	else
		ZShellGameShell()->ZoneAlert(ErrorTextResourceNotFound);
    return nRet;
}

IResourceManager *ZShellResourceManager()
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGameGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif

    return gGameShell->GetResourceManager();
}


void MAKEAKEY(TCHAR* dest,LPCTSTR key1, LPCTSTR key2, LPCTSTR key3)
{  
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	lstrcpy( dest, (TCHAR*)gGameName );
	lstrcat( dest, _T("/") );
	lstrcat( dest, key1);
	lstrcat( dest, _T("/") );
	lstrcat( dest, key2);
	lstrcat( dest, _T("/") );
	lstrcat( dest, key3);
}

ZBool LoadFontFromDataStore(LPCheckersColorFont* ccFont, TCHAR* pszFontName)
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGameGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif

	IDataStore *pIDS = ZShellDataStoreUI(); // gGameShell->GetDataStoreUI();
	const TCHAR* tagFont [] = {zCheckers, zKey_FontRscTyp, pszFontName, NULL };
	
    tagFont[3] = zKey_FontId;
	if ( FAILED( pIDS->GetFONT( tagFont, 4, &ccFont->m_zFont ) ) )
    {
        return FALSE;
    }

    tagFont[3] = zKey_ColorId;
	if ( FAILED( pIDS->GetRGB( tagFont, 4, &ccFont->m_zColor ) ) )
    {
        return FALSE;
    }
    // create the HFONT
    ccFont->m_hFont = ZCreateFontIndirect( &ccFont->m_zFont );
    if ( !ccFont->m_hFont )
    {
        return FALSE;
    }
    return TRUE;
}

ZBool LoadGameFonts()
{// fonts loaded from ui.txt
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	if (LoadFontFromDataStore(&gCheckersFont[zFontResultBox], zKey_RESULTBOX) != TRUE)
		ZShellGameShell()->ZoneAlert(ErrorTextResourceNotFound);
	if (LoadFontFromDataStore(&gCheckersFont[zFontIndicateTurn], zKey_INDICATETURN) != TRUE)
		ZShellGameShell()->ZoneAlert(ErrorTextResourceNotFound);
	if (LoadFontFromDataStore(&gCheckersFont[zFontPlayerName], zKey_PLAYERNAME) != TRUE)
		ZShellGameShell()->ZoneAlert(ErrorTextResourceNotFound);
	if (LoadFontFromDataStore(&gCheckersFont[zFontDrawPend], zKey_DRAWPEND) != TRUE)
		ZShellGameShell()->ZoneAlert(ErrorTextResourceNotFound);

    TCHAR tagFont [64];
	MAKEAKEY (tagFont, zKey_FontRscTyp, zKey_ROLLOVERTEXT, L"");
	if ( FAILED( LoadZoneMultiStateFont( ZShellDataStoreUI(), tagFont, &gpButtonFont ) ) )
		ZShellGameShell()->ZoneAlert(ErrorTextResourceNotFound);

	return TRUE;
}

/*************************************Accessibility related routines*******************************/
static void ZoneRectToWinRect(RECT* rectWin, ZRect* rectZ)
{
	rectWin->left = rectZ->left;
	rectWin->top = rectZ->top;
	rectWin->right = rectZ->right;
	rectWin->bottom = rectZ->bottom;
}

static void WinRectToZoneRect(ZRect* rectZ, RECT* rectWin)
{
	rectZ->left = (int16)rectWin->left;
	rectZ->top = (int16)rectWin->top;
	rectZ->right = (int16)rectWin->right;
	rectZ->bottom = (int16)rectWin->bottom;
}

static void GetAbsolutePieceRect(Game game, ZRect* rect, int16 col, int16 row)
{// No reversing - only the asolute positions
	row = 7 - row;
	rect->left = gRects[zRectCells].left + col * zCheckersPieceSquareWidth - 1;
	rect->top = gRects[zRectCells].top + row * zCheckersPieceSquareHeight - 1;
	rect->right = rect->left + zCheckersPieceImageWidth;
	rect->bottom = rect->top + zCheckersPieceImageHeight;
}

void GetPiecePos (Game game, int nIndex, BYTE& row, BYTE&  col)
{// Get the position of the cell depending on the accessibility index
	row = (nIndex - 2) % 8;
	col = (nIndex - 2) / 8;
	if (!ZCheckersPlayerIsBlack(game))
	{// reverse the row and the col
		row = 7 - row;
		col = 7 - col;
	}
}

BOOL InitAccessibility(Game game, IGameGame *pIGG)
{// initialises accessibility stuff
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif

	// initialise the list of accessible objects. 
	GACCITEM	listCheckersAccItems[zCheckersAccessibleComponents];	// 8*8 + 2 
	RECT		rcGame;
	ZRect		rcTemp;
	// Get the default values for the items
	int nSize = sizeof (listCheckersAccItems)/sizeof(listCheckersAccItems[0]);
	for (int i = 0; i < nSize; i++)
		CopyACC(listCheckersAccItems[i], ZACCESS_DefaultACCITEM);

	SetRectEmpty(&game->m_FocusRect);
	SetRectEmpty(&game->m_DragRect);
	// set the item specific bits
	// game board - 8*8 squares
	int nIndex = 2;
	for (BYTE ii = 0;ii < 8; ii++) {
		for (BYTE jj = 0;jj < 8; jj++) {
			// rc
			GetAbsolutePieceRect(game,&rcTemp,ii,jj);
			//rcTemp.left--; rcTemp.top--; // adjustment for the focusrect
			//GetPieceRect(game,&rcTemp,ii,jj);
			ZoneRectToWinRect(&rcGame, &rcTemp);
            rcGame.top--;
            rcGame.left--;
            rcGame.right++;
            rcGame.bottom++;
			CopyRect(&listCheckersAccItems[nIndex].rc, &rcGame);
			// arrows
			listCheckersAccItems[nIndex].nArrowUp	= ((nIndex - 2) % 8 != 7) ? nIndex + 1 : ZACCESS_ArrowNone;
			listCheckersAccItems[nIndex].nArrowDown = ((nIndex - 2) % 8) ? nIndex - 1 : ZACCESS_ArrowNone;
			listCheckersAccItems[nIndex].nArrowLeft = (nIndex - 2) > 7 ? nIndex - 8 : ZACCESS_ArrowNone;
			listCheckersAccItems[nIndex].nArrowRight= (nIndex - 2) < 56 ? nIndex + 8 : ZACCESS_ArrowNone;

		    listCheckersAccItems[nIndex].wID = ZACCESS_InvalidCommandID;
		    listCheckersAccItems[nIndex].fTabstop = false;
		    listCheckersAccItems[nIndex].fGraphical = true;

			nIndex++;
		}
	}
	listCheckersAccItems[2].wID = IDC_GAME_WINDOW;
	listCheckersAccItems[2].fTabstop = true;
    listCheckersAccItems[2].eAccelBehavior = ZACCESS_FocusGroup;
    listCheckersAccItems[2].nGroupFocus = 4;  // start on your upper-left checker

	ZRect rect;
    // resign
    listCheckersAccItems[0].wID = IDC_RESIGN_BUTTON;
    listCheckersAccItems[0].fGraphical = true;
    listCheckersAccItems[0].fEnabled = (ZRolloverButtonIsEnabled(game->sequenceButton) ? true : false);
	ZRolloverButtonGetRect(game->sequenceButton, &rect);
	ZoneRectToWinRect(&rcGame, &rect);
    rcGame.top--;
    rcGame.left--;
    rcGame.right++;
    rcGame.bottom++;
	CopyRect(&listCheckersAccItems[0].rc, &rcGame);

    // all arrows to draw button
    listCheckersAccItems[0].nArrowUp = 1;
    listCheckersAccItems[0].nArrowDown = 1;
    listCheckersAccItems[0].nArrowLeft = 1;
    listCheckersAccItems[0].nArrowRight = 1;

    // draw
    listCheckersAccItems[1].wID = IDC_DRAW_BUTTON;
    listCheckersAccItems[1].fGraphical = true;
    listCheckersAccItems[1].fEnabled = (ZRolloverButtonIsEnabled(game->drawButton) ? true : false);
	ZRolloverButtonGetRect(game->drawButton, &rect);
	ZoneRectToWinRect(&rcGame, &rect);
    rcGame.top--;
    rcGame.left--;
    rcGame.right++;
    rcGame.bottom++;
	CopyRect(&listCheckersAccItems[1].rc, &rcGame);

    // all arrows to resign button
    listCheckersAccItems[1].nArrowUp = 0;
    listCheckersAccItems[1].nArrowDown = 0;
    listCheckersAccItems[1].nArrowLeft = 0;
    listCheckersAccItems[1].nArrowRight = 0;

	// Load accelerator table defined in Rsc
	HACCEL hAccel = ZShellResourceManager()->LoadAccelerators (MAKEINTRESOURCE(IDR_CHECKERSACCELERATOR));

	CComQIPtr<IGraphicallyAccControl> pIGAC = pIGG;
	if(!pIGAC)
        return FALSE;

	gCheckersIGA->InitAccG (pIGAC, ZWindowGetHWND(game->gameWindow), 0);

	// push the list of items to be tab ordered
	gCheckersIGA->PushItemlistG(listCheckersAccItems, nSize, 2, true, hAccel);

	return TRUE;
}

static void AddResultboxAccessibility()
{// have one item which responds to Esc..
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	GACCITEM	resultBoxCheckersAccItems;
	CopyACC(resultBoxCheckersAccItems, ZACCESS_DefaultACCITEM);
	resultBoxCheckersAccItems.wID = IDC_RESULT_WINDOW;
	resultBoxCheckersAccItems.fGraphical = true;
	resultBoxCheckersAccItems.rgfWantKeys = ZACCESS_WantEsc;
	resultBoxCheckersAccItems.oAccel.fVirt = FVIRTKEY;
	resultBoxCheckersAccItems.oAccel.key = VK_ESCAPE;
	resultBoxCheckersAccItems.oAccel.cmd = IDC_RESULT_WINDOW;
    CopyRect(&resultBoxCheckersAccItems.rc, ZIsLayoutRTL() ? &zCloseButtonRectRTL : &zCloseButtonRect);
	gCheckersIGA->PushItemlistG(&resultBoxCheckersAccItems, 1, 0, true, NULL);

	gCheckersIGA->SetFocus(0);
}

static void RemoveResultboxAccessibility()
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	if (gCheckersIGA->GetStackSize() >1) // the main accelerator should not get popped
	{
		gCheckersIGA->PopItemlist();
	}
}

static void EnableBoardKbd(bool fEnable)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif

    int i;
    for(i = 2; i < 66; i++)
        gCheckersIGA->SetItemEnabled(fEnable, i, true, 0);
}


/*************************************Accessibility related routines*******************************/

/************************************ IGameGame interface******************************************/

/*************************************************************************************************/
// IGameGame    
STDMETHODIMP CGameGameCheckers::GameOverReady()
{
    // user selected "Play Again"
	Game game = I( GetGame() );
	ZCheckersMsgNewGame msg;
	msg.seat = game->seat;
	msg.protocolSignature = zCheckersProtocolSignature;
	msg.protocolVersion = zCheckersProtocolVersion;
	msg.clientVersion = ZoneClientVersion();
	ZCheckersMsgNewGameEndian(&msg);
	ZCRoomSendMessage(game->tableID, zCheckersMsgNewGame, &msg, sizeof(ZCheckersMsgNewGame));
    return S_OK;
}

STDMETHODIMP CGameGameCheckers::SendChat(TCHAR *szText, DWORD cchChars)
{
#ifdef ZONECLI_DLL
	GameGlobals pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif

	ZCheckersMsgTalk*		msgTalk;
	Game					game = (Game) GetGame();
	int16					msgLen;
	ZPlayerInfoType			playerInfo;

	msgLen = sizeof(ZCheckersMsgTalk) + cchChars * sizeof(TCHAR);
    msgTalk = (ZCheckersMsgTalk*) ZCalloc(1, msgLen);
    if (msgTalk != NULL)
    {
        msgTalk->userID = game->players[game->seat].userID;
		msgTalk->seat = game->seat;
        msgTalk->messageLen = (WORD) cchChars * sizeof(TCHAR);
        CopyMemory((BYTE *) msgTalk + sizeof(ZCheckersMsgTalk), (void *) szText,
            msgTalk->messageLen);
        ZCheckersMsgTalkEndian(msgTalk);
        ZCRoomSendMessage(game->tableID, zCheckersMsgTalk, (void*) msgTalk, msgLen);
        ZFree((char*) msgTalk);
        return S_OK;
    }
    else
    {
        return E_OUTOFMEMORY;
	}
}

STDMETHODIMP CGameGameCheckers::GamePromptResult(DWORD nButton, DWORD dwCookie)
{
	Game game = I( GetGame() );

	switch (dwCookie)
	{
	case zDrawPrompt:
		DrawGamePromptFunc ((int16)nButton, game);
		break;
	case zQuitprompt:
		QuitGamePromptFunc ((int16)nButton, game);
		break;
	case zResignConfirmPrompt:
		ConfirmResignPrompFunc ((int16)nButton, game);
		break;
	default:
		break;
	}
	return S_OK;
}

HWND CGameGameCheckers::GetWindowHandle()
{
	Game game = I( GetGame() );
	return ZWindowGetHWND(game->gameWindow);
}


//IGraphicallyAccControl
void CGameGameCheckers::DrawFocus(RECT *prc, long nIndex, void *pvCookie)
{
#ifdef ZONECLI_DLL
	GameGlobals	pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif

	Game game = I(GetGame());
    ZRect rect;

    if(!IsRectEmpty(&game->m_FocusRect))
    {
        WRectToZRect(&rect, &game->m_FocusRect);
        ZWindowInvalidate(game->gameWindow, &rect);
    }

	if(prc)
		CopyRect(&game->m_FocusRect, prc);
	else
		SetRectEmpty(&game->m_FocusRect);

    if(!IsRectEmpty(&game->m_FocusRect))
    {
        WRectToZRect(&rect, &game->m_FocusRect);
        ZWindowInvalidate(game->gameWindow, &rect);
    }
}

void CGameGameCheckers::DrawDragOrig(RECT *prc, long nIndex, void *pvCookie)
{
#ifdef ZONECLI_DLL
	GameGlobals	pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif

	Game game = I(GetGame());
    ZRect rect;

    if(!IsRectEmpty(&game->m_DragRect))
    {
        WRectToZRect(&rect, &game->m_DragRect);
        ZWindowInvalidate(game->gameWindow, &rect);
    }

	if(prc)
		CopyRect(&game->m_DragRect, prc);
	else
		SetRectEmpty(&game->m_DragRect);

    if(!IsRectEmpty(&game->m_DragRect))
    {
        WRectToZRect(&rect, &game->m_DragRect);
        ZWindowInvalidate(game->gameWindow, &rect);
    }
}

DWORD CGameGameCheckers::Focus(long nIndex, long nIndexPrev, DWORD rgfContext, void *pvCookie)
{
#ifdef ZONECLI_DLL
	GameGlobals		pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif

	if(nIndex != ZACCESS_InvalidItem)
    {
		SetFocus(GetWindowHandle()); // set the window focus on game window
        ClearDragState(I(GetGame()));
    }

	return 0;
}

DWORD CGameGameCheckers::Select(long nIndex, DWORD rgfContext, void *pvCookie)
{
	return Activate(nIndex, rgfContext, pvCookie);
}

DWORD CGameGameCheckers::Activate(long nIndex, DWORD rgfContext, void *pvCookie)
{
#ifdef ZONECLI_DLL
	GameGlobals		pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif

	Game game = I( GetGame() );
	long id = gCheckersIGA->GetItemID(nIndex);

    ClearDragState(game);

    switch(id)
    {
        case IDC_RESULT_WINDOW:
    		if (game->gameState == zGameStateGameOver && !gDontDrawResults)
	    	{
		    	gDontDrawResults = TRUE;
			    ZWindowInvalidate( game->gameWindow, &gRects[zRectResultBox] );
		    }
            break;

        case IDC_RESIGN_BUTTON:
		    if (ZRolloverButtonIsEnabled( game->sequenceButton ))
			    ZShellGameShell()->GamePrompt(game, (TCHAR*)gResignConfirmStr, (TCHAR*)gResignConfirmStrCap,
										    AlertButtonYes, AlertButtonNo, NULL, 0, zResignConfirmPrompt);
            break;

        case IDC_DRAW_BUTTON:
		    if(ZRolloverButtonIsEnabled(game->drawButton) && game->gameState == zGameStateMove && ZCheckersPlayerIsMyMove(game))
            {
                if(game->seatOfferingDraw != -1)
                    game->seatOfferingDraw = -1;
                else
                    game->seatOfferingDraw = game->seat;

                UpdateDrawWithNextMove(game);
            }
            break;

        default:
        {
	        ZCheckersSquare sq;
	        GetPiecePos (game, nIndex, sq.row, sq.col);
	        ZCheckersPiece piece = ZCheckersPieceAt(game->checkers, &sq);
	        if(ZCheckersPlayerIsMyMove(game) && piece != zCheckersPieceNone && game->seat == ZCheckersPieceOwner(piece)) 
                return ZACCESS_BeginDrag;

            break;
        }
	}

	return 0;
}

DWORD CGameGameCheckers::Drag(long nIndex, long nIndexOrig, DWORD rgfContext, void *pvCookie)
{
#ifdef ZONECLI_DLL
	GameGlobals		pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif

	Game game = I( GetGame() );
    if(nIndex != ZACCESS_InvalidItem)
        ClearDragState(game);

	if(!ZCheckersPlayerIsMyMove(game))
		return 0;

    // if they didn't move it, do nothing - this will end the drag
    if(nIndex == nIndexOrig || nIndex == ZACCESS_InvalidItem)
        return 0;

    int16 legal;
    ZCheckersMove move;
    ZCheckersSquare sqStart;
    ZCheckersSquare sq;
    GetPiecePos(game, nIndexOrig, sqStart.row, sqStart.col);
	GetPiecePos (game, nIndex, sq.row, sq.col);

    move.start = sqStart;
    move.finish = sq;
    legal = ZCheckersIsLegalMove(game->checkers, &move);

    /* send message to other player (comes to self too) */
    if (legal == zCorrectMove)
    {
        ZCheckersMsgMovePiece		msg;

        msg.move = move;
        msg.seat = game->seat;
        ZCheckersMsgMovePieceEndian(&msg);

        ZCRoomSendMessage(game->tableID, zCheckersMsgMovePiece, &msg, sizeof(ZCheckersMsgMovePiece));
        /* for speed, send our move directly to be processed */
        /* don't wait for it to go to server and back */
        HandleMovePieceMessage(game, (ZCheckersMsgMovePiece*)&msg);
        // if it is the very first move then enable the rollover buttons
        if (game->bMoveNotStarted == TRUE)
            game->bMoveNotStarted = FALSE;

        // if it's still my turn, let's keep going with a new drag
        ZCheckersPiece piece = ZCheckersPieceAt(game->checkers, &sq);
    	if(ZCheckersPlayerIsMyMove(game) && piece != zCheckersPieceNone && game->seat == ZCheckersPieceOwner(piece))
	    	return ZACCESS_BeginDrag;
    }
    else
    {
        /* illegal move */
        UpdateSquare(game,&move.start);
        ZPlaySound( game, zSndIllegalMove, FALSE, FALSE );
        if (legal == zMustJump)
            ZShellGameShell()->ZoneAlert((TCHAR*)gStrMustJumpText);
        return ZACCESS_Reject;
    }

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\games\backgammon\sprites.cpp ===
#include "game.h"
#define BUFFER_SIZE 256

//////////////////////////////////////////////////////////////////////////////
// text sprite DC handling...
///////////////////////////////////////////////////////////////////////////////


#define FONT_DIV_SIZE  96

CTextSprite::CTextSprite()
{
	len		 = 0;
	buff[0]  = _T('\0');
	font	 = NULL;
	if ( !ISRTL() )
	{
		txtFlags = DT_LEFT | DT_TOP;
	}
	else
	{
		txtFlags = DT_RIGHT | DT_TOP | DT_RTLREADING;
	}	
}

CTextSprite::~CTextSprite()
{
	if ( font )
		DeleteObject( font );
}

void CTextSprite::Draw()
{
	// don't have any text to draw
	if ( len <= 0 )
		return;

	HDC hdc = m_pWorld->GetBackbuffer()->GetDC();
	HFONT oldFont = SelectObject( hdc, font );
	int iOldMode = SetBkMode( hdc, TRANSPARENT );
	SetTextColor( hdc, color );
	DrawText( hdc, buff, len, &m_rcScreen, txtFlags | DT_WORDBREAK );
	SetBkMode( hdc, iOldMode );
	SelectObject( hdc, oldFont );
}


void CTextSprite::SetText( TCHAR* txt, DWORD flags )
{
	if ( ISRTL() )
	{
		//Have to do this as DT_LEFT flag is zero
		if ( !(flags & DT_CENTER) )
		{
	
			if ( flags & DT_RIGHT )
			{
				flags ^= DT_RIGHT;
				flags |= DT_LEFT;
			}
			else //Is left set to right
			{			
				flags |= DT_RIGHT;
			}		
		}

		flags |= DT_RTLREADING;
	}

	txtFlags = flags;
	
	len = lstrlen( txt );
	if ( len >= NUMELEMENTS(buff) )
		len = NUMELEMENTS(buff) - 1;
	for ( int i = 0; i < len; i++ )
		buff[i] = txt[i];
	buff[i] = _T('\0');
	m_pWorld->Modified( this );
}
/*
#define FONT_MULT 96

HFONT ZoneCreateFontIndirect(ZONEFONT* zFont, HDC hDC = NULL, BYTE bItalic = FALSE, BYTE bUnderline = FALSE ,BYTE bStrikeOut = FALSE)
{
	LOGFONT lFont;
	HFONT   hFont = NULL;
		
	memset(&lFont, 0, sizeof(LOGFONT));	
	lFont.lfCharSet = DEFAULT_CHARSET;

	// If font size > 0, it is a fixed pixel size, otherwise it is a
	// true logical font size which respects the user's "large font" setting.
	if ( zFont->lfHeight > 0 )
	{
		lFont.lfHeight = -MulDiv(zFont->lfHeight, FONT_MULT, 72);
	}
	else
	{		
		lFont.lfHeight = MulDiv(zFont->lfHeight, GetDeviceCaps( hDC, LOGPIXELSY), 72);
	}
	
	lFont.lfWeight    = zFont->lfWeight;
	lFont.lfItalic    = bItalic;
	lFont.lfUnderline = bUnderline;
	lFont.lfStrikeOut = bStrikeOut;

	lstrcpyn(lFont.lfFaceName, zFont->lfFaceName, sizeof(lFont.lfFaceName)/sizeof(TCHAR));

	return CreateFontIndirect(&lFont);
}

HFONT ZoneCreateFontIndirect(ZONEFONT* zfPreferred, ZONEFONT* zfBackup, HDC hDC = NULL, BYTE bItalic = FALSE, BYTE bUnderline = FALSE ,BYTE bStrikeOut = FALSE)
{
	HFONT hFont = NULL;

	if ( (hFont = ZoneCreateFontIndirect( zfPreferred, hDC, bItalic, bUnderline, bStrikeOut)) == NULL )
	{
		hFont = ZoneCreateFontIndirect( zfBackup, hdc, bItalic, bUnderline, bStrikeOut);
	}

	return hFont;
}
*/


BOOL CTextSprite::Load( UINT uID, TCHAR* szRectKey, TCHAR* szFontKey, TCHAR* szColourKey, DWORD flags )
{
	HRESULT		hr;
	ZONEFONT	zFont;
	LOGFONT		Font;
	COLORREF    colRef;
	RECT		rect;

	if ( ISRTL() )
	{
		//Have to do this as DT_LEFT flag is zero
		if ( !(flags & DT_CENTER) )
		{
	
			if ( flags & DT_RIGHT )
			{
				flags ^= DT_RIGHT;
				flags |= DT_LEFT;
			}
			else //Is left set to right
			{			
				flags |= DT_RIGHT;
			}		
		}
		
		flags |= DT_RTLREADING;
	
	}


	txtFlags = flags;

	if ( uID )
	{
		//Load the string		
		hr  = ZShellResourceManager()->LoadString( uID, buff, NUMELEMENTS(buff) );		
		if ( FAILED( hr ) )
		{
			ASSERT( FALSE );
			return FALSE;
		}
		len = lstrlen( buff );
	}

	if ( szFontKey )
	{
		//Load the font
		hr = ZShellDataStoreUI()->GetFONT( szFontKey, &zFont);
		if ( FAILED( hr ) )
		{
			ASSERT( FALSE );
			return FALSE;
		}

		HDC hdc = GetDC( NULL );

		// create font	
		ZeroMemory( &Font, sizeof(Font) );

        if(font)
            DeleteObject(font);
		font		  = ZCreateFontIndirect(&zFont); 
		ASSERT( font != NULL );

		ReleaseDC( NULL, hdc );

		if ( font == NULL )
			return FALSE;
	}

	if ( szColourKey )
	{
		//Load the color
		hr = ZShellDataStoreUI()->GetRGB( szColourKey, &colRef );
		if ( FAILED( hr ) )
		{
			ASSERT( FALSE );
			return FALSE;
		}
		color = colRef;
	}

	if ( szRectKey )
	{
		//Load the Rect
		hr = ZShellDataStoreUI()->GetRECT( szRectKey, &rect);
		if ( FAILED( hr ) )
		{
			ASSERT( FALSE );
			return FALSE;
		}
		
		SetImageDimensions( rect.right - rect.left  + 1, rect.bottom - rect.top + 1 );
		SetXY( rect.left, rect.top );
	}


	return TRUE;
}


void CButtonTextSprite::SetEnable( BOOL bEnable )
{
	if ( m_pText )
		m_pText->SetEnable( bEnable );

	CDibSprite::SetEnable( bEnable );
}

void CButtonTextSprite::SetState( int idx )
{	

	ASSERT( idx >= 0 && idx <= 4 );
	if ( !m_bInit )
		return;

	//If have active text disable
	if ( m_pText )
		m_pText->SetEnable( FALSE );

	m_pText		= &m_arText[ idx ];
	m_pText->SetEnable( m_bEnabled );
	m_pText->Update();
	CDibSprite::SetState( idx );
};

#define MAKEKEY(dest,key)   lstrcpy( dest, szButtonData ); \
							lstrcat( dest, _T("/") );\
							lstrcat( dest, key);

BOOL CButtonTextSprite::LoadButtonData(UINT uID, TCHAR *szButtonData)
{

	TCHAR*	 szFont[]  = { _T("FontActive"), _T("FontDisabled") };
	TCHAR*   szRGB[]   = { _T("RGBNormal"),  _T("RGBHighlight"), _T("RGBFocus"), _T("RGBPressed"), _T("RGBDisabled") };
	
	TCHAR	 szRectKey[128];
	TCHAR	 szFontKey[128];
	TCHAR	 szColourKey[128];
	HRESULT	 hr;
	RECT	 rect;

	MAKEKEY( szRectKey, _T("Rect"));

	//Load the Rect
	hr = ZShellDataStoreUI()->GetRECT( szRectKey, &rect);
	if ( FAILED( hr ) )
	{
		ASSERT( FALSE );
		return FALSE;
	}
	SetXY( rect.left, rect.top );
	SetImageDimensions( rect.right - rect.left  + 1, rect.bottom - rect.top + 1 );

	MAKEKEY( szFontKey, szFont[0] );
	for ( DWORD x = 0; x < 4; x++ )
	{
		MAKEKEY( szColourKey, szRGB[x] );
		hr = m_arText[x].Init( m_pWorld, m_nLayer+1, bgSpriteButtonText, 0, 0 );
		if ( FAILED(hr) )
			return FALSE;
		
		if ( !m_arText[x].Load( uID, szRectKey, szFontKey, szColourKey, DT_CENTER | DT_VCENTER | DT_SINGLELINE ) )
			return FALSE;
	}

	MAKEKEY( szFontKey, szFont[1]  );
	MAKEKEY( szColourKey, szRGB[4] );
	hr = m_arText[4].Init( m_pWorld, m_nLayer + 1, bgSpriteButtonText, 0, 0 );
	if ( FAILED(hr) )
		return FALSE;
	if ( !m_arText[4].Load( uID, szRectKey, szFontKey, szColourKey, DT_CENTER | DT_VCENTER | DT_SINGLELINE ) )
		return FALSE;

	
	MAKEKEY( szRectKey, _T("RectPressed"));

	//Set the pressed rect
	if ( !m_arText[3].Load( 0, szRectKey, 0, 0,DT_CENTER | DT_VCENTER | DT_SINGLELINE ) )
		return FALSE;
		
	m_bInit = TRUE;
	
	m_pText = &m_arText[0];

	return TRUE;
};



//////////////////////////////////////////////////////////////////////////////
// status sprite
///////////////////////////////////////////////////////////////////////////////

CStatusSprite::CStatusSprite()
{
	m_Txt[0]    = _T('\0');
	m_Len       = 0;
	m_Type      = bgStatusUnknown;
	m_pOverDib  = NULL;
	m_NextState = bgStateUnknown;

	m_GameWon   = NULL;
    m_GameText  = NULL;
	m_GameLost  = NULL;
	m_MatchWon  = NULL;
	m_MatchLost = NULL;
	m_Active[0] = NULL;
	m_Active[1] = NULL;

	m_bEnableRoll = FALSE;

}


CStatusSprite::~CStatusSprite()
{
	/*
	if ( m_hFont )
		DeleteObject( m_hFont );
	*/
	if ( m_GameWon )
		m_GameWon->Release();
	if ( m_GameText )
		m_GameText->Release();
	if ( m_GameLost )
		m_GameLost->Release();
	if ( m_MatchWon )
		m_MatchWon->Release();
	if ( m_MatchLost )
		m_MatchLost->Release();
	if ( m_Match )
		m_Match->Release();
	if ( m_NormalText )
		m_NormalText->Release();

}


//Errors handled one level up
HRESULT CStatusSprite::LoadText(HINSTANCE hInstance,  FRX::CRectList& rects)
{
	HRESULT hr;
	POINT   pt;
	FRX::CRect	rect;


	hr = ZShellDataStoreUI()->GetPOINT( _T("BACKGAMMON/STATUS/Normal/Position"),   &m_Pts[0]);
	if ( FAILED(hr) )
	{
		ASSERT( FALSE );
		return hr;	
	}
	hr = ZShellDataStoreUI()->GetPOINT( _T("BACKGAMMON/STATUS/GameOver/Position"), &m_Pts[1]);
	if ( FAILED(hr) )
	{
		ASSERT( FALSE );
		return hr;
	}
	hr = ZShellDataStoreUI()->GetPOINT( _T("BACKGAMMON/STATUS/MatchOver/Position"), &m_Pts[2] );
	if ( FAILED(hr) )
	{
		ASSERT( FALSE );
		return hr;
	}

	m_NormalText = new CTextSprite;
	if ( !m_NormalText )
		return E_OUTOFMEMORY;
	hr = m_NormalText->Init( m_pWorld, m_nLayer, bgSpriteStatusNormal, 0 , 0 );
	if ( FAILED(hr) )
		return hr;
	if (!m_NormalText->Load( 0, _T("BACKGAMMON/STATUS/Normal/Text/Rect"), _T("BACKGAMMON/STATUS/Normal/Text/Font"), _T("BACKGAMMON/STATUS/Normal/Text/RGB")) )
		return FALSE;
	m_NormalText->Offset( m_Pts[0].x, m_Pts[0].y);

	m_GameText = new CTextSprite;
	if ( !m_GameText )
		return E_OUTOFMEMORY;
	hr = m_GameText->Init( m_pWorld, m_nLayer, bgSpriteStatusNormal, 0 , 0 );
	if ( FAILED(hr) )
		return hr;
	if (!m_GameText->Load( 0, _T("BACKGAMMON/STATUS/GameOver/Text/Rect"), _T("BACKGAMMON/STATUS/GameOver/Text/Font"), _T("BACKGAMMON/STATUS/GameOver/Text/RGB")) )
		return FALSE;
	m_GameText->Offset( m_Pts[1].x, m_Pts[1].y );

	//Load Game Won text
	m_GameWon = new CTextSprite;
	if ( !m_GameWon )
		return E_OUTOFMEMORY;
	hr = m_GameWon->Init( m_pWorld, m_nLayer, bgSpriteStatusGameWonTxt, 0 , 0 );
	if ( FAILED(hr) )
		return hr;
	if (!m_GameWon->Load( IDS_GAME_WON, _T("BACKGAMMON/STATUS/GameWon/Rect"), _T("BACKGAMMON/STATUS/GameWon/Font"), _T("BACKGAMMON/STATUS/GameWon/RGB"),DT_CENTER | DT_VCENTER | DT_SINGLELINE ))
		return FALSE;
	m_GameWon->Offset( m_Pts[1].x, m_Pts[1].y );

	//Load Game Lost text
	m_GameLost = new CTextSprite;
	if ( !m_GameLost )
		return E_OUTOFMEMORY;
	hr = m_GameLost->Init( m_pWorld, m_nLayer, bgSpriteStatusGameLostTxt, 0 , 0 );
	if ( FAILED(hr) )
		return hr;
	if (!m_GameLost->Load( IDS_GAME_LOST, _T("BACKGAMMON/STATUS/GameLost/Rect"), _T("BACKGAMMON/STATUS/GameLost/Font"), _T("BACKGAMMON/STATUS/GameLost/RGB"),DT_CENTER | DT_VCENTER | DT_SINGLELINE ))
		return FALSE;
	m_GameLost->Offset( m_Pts[1].x, m_Pts[1].y );

	//Load Match Text
	m_Match = new CTextSprite;
	if (!m_Match)
		return E_OUTOFMEMORY;
	hr = m_Match->Init( m_pWorld, m_nLayer, bgSpriteStatusMatchWonTxt, 0 ,0 );
	if ( FAILED(hr) )
		return hr;
	if (!m_Match->Load( IDS_MATCH, _T("BACKGAMMON/STATUS/Match/Rect"), _T("BACKGAMMON/STATUS/Match/Font"), _T("BACKGAMMON/STATUS/Match/RGB"), DT_TOP | DT_SINGLELINE | DT_CENTER ))
		return FALSE;
	m_Match->Offset( m_Pts[2].x, m_Pts[2].y );

	//Load Match Won Text
	m_MatchWon = new CTextSprite;
	if ( !m_MatchWon )
		return E_OUTOFMEMORY;
	hr = m_MatchWon->Init( m_pWorld, m_nLayer, bgSpriteStatusMatchWonTxt, 0 , 0 );
	if ( FAILED(hr) )
		return hr;
	if ( !ISRTL() )
	{
		if (!m_MatchWon->Load( IDS_MATCH_WON, _T("BACKGAMMON/STATUS/MatchWon/Rect"), _T("BACKGAMMON/STATUS/MatchWon/Font"), _T("BACKGAMMON/STATUS/MatchWon/RGB"), DT_RIGHT  ))
			return FALSE;
	}
	else
	{
		if (!m_MatchWon->Load( IDS_MATCH_WON, _T("BACKGAMMON/STATUS/MatchWon/RectRTL"), _T("BACKGAMMON/STATUS/MatchWon/Font"), _T("BACKGAMMON/STATUS/MatchWon/RGB"), DT_RIGHT  ))
			return FALSE;
	}
	m_MatchWon->Offset( m_Pts[2].x, m_Pts[2].y );

	//Load Match Lost text
	m_MatchLost = new CTextSprite;
	if ( !m_MatchLost )
		return E_OUTOFMEMORY;
	hr = m_MatchLost->Init( m_pWorld, m_nLayer, bgSpriteStatusMatchLostTxt, 0 , 0 );
	if ( FAILED(hr) )
		return hr;
	if ( !ISRTL() )
	{
		if (!m_MatchLost->Load( IDS_MATCH_LOST, _T("BACKGAMMON/STATUS/MatchLost/Rect"), _T("BACKGAMMON/STATUS/MatchLost/Font"), _T("BACKGAMMON/STATUS/MatchLost/RGB"), DT_RIGHT  ))
			return FALSE;
	}
	else
	{
		if (!m_MatchLost->Load( IDS_MATCH_LOST, _T("BACKGAMMON/STATUS/MatchLost/RectRTL"), _T("BACKGAMMON/STATUS/MatchLost/Font"), _T("BACKGAMMON/STATUS/MatchLost/RGB"), DT_RIGHT  ))
			return FALSE;

	}
	m_MatchLost->Offset( m_Pts[2].x, m_Pts[2].y );

	return NOERROR;
}


void CStatusSprite::Properties( HWND hwnd, FRX::CRectList& rects, int type, int timeout, TCHAR* txt, int NextState )
{

	FRX::CRect rc;
	// copy text info
	if ( txt )
	{
		lstrcpy( m_Txt, txt );
		m_Len = lstrlen( txt );
	}
	else
	{
		m_Txt[0] = _T('\0');
		m_Len = 0;
	}


	//Disable old active text
	for (int i = 0; i < 2; i++ )
	{
		if (m_Active[i])
		{
			m_Active[i]->SetEnable( FALSE );
			m_Active[i]= NULL;
		}
	}


	/*CHANGED SCREEN RECT*/
	// Copy next state
	m_NextState = NextState;

	// Reset timeout
	m_Timeout = timeout;

	// set sprite state
	m_pOverDib = NULL;
	switch( bgStatusTypeMask & (m_Type = type) )
	{
	case bgStatusNormal:
		SetEnable( TRUE );
		SetState( 0 );		
		
		SetXY( m_Pts[0].x, m_Pts[0].y );

		//Prefix Warning:  txt possibly null, use m_Txt instead
		m_NormalText->SetText( m_Txt, DT_TOP | DT_LEFT | DT_WORDBREAK );

		m_Active[0] = m_NormalText;
		break;

	case bgStatusGameover:

		SetEnable( TRUE );
		SetState( 1 );

		SetXY( m_Pts[1].x, m_Pts[1].y );

		m_GameText->SetText( m_Txt, DT_TOP | DT_LEFT | DT_WORDBREAK );
		m_Active[0] = m_GameText;

		if ( bgStatusWinner == (bgStatusDetailMask & m_Type) )
			m_Active[1] = m_GameWon;			
		else
			m_Active[1] = m_GameLost;


		break;

	case bgStatusMatchover:
		SetEnable( TRUE );

		m_Active[0] = m_Match;
		
		if ( bgStatusWinner == (bgStatusDetailMask & m_Type) )
		{
			m_Active[1] = m_MatchWon;
			SetState( 2 );
		}
		else
		{
			m_Active[1] = m_MatchLost;
			SetState( 3 );
		}

		SetXY( m_Pts[2].x, m_Pts[2].y );
		m_pDib->SetTransparencyIndex( NULL );
		
		break;

	default:
		SetEnable( FALSE );
		ASSERT( FALSE );
		return;
	}

	// update board
	HDC hdc = GetDC( hwnd );
	m_pWorld->Modified( this );
	m_pWorld->Draw( hdc );
	ReleaseDC( hwnd, hdc );
}


void CStatusSprite::Draw()
{

	// draw primary bitmap
	if ( GetState() >= 2  && ISRTL())
		CDibSprite::DrawRTL();
	else
		CDibSprite::Draw();


	// overlay "over" bitmap
	if ( m_pOverDib )
		m_pOverDib->Draw( *m_pWorld->GetBackbuffer(), m_X + m_rcOver.left, m_Y + m_rcOver.top );
	//Draw TextSprite
	for (int i = 0; i < 2; i++ )
	{
		if (m_Active[i])
			m_Active[i]->Draw();
	}
	
}


BOOL CStatusSprite::Tick( HWND hwnd, int interval )
{
	// nothing to do
	if ( !Enabled() )
		return FALSE;

	// forcable close
	if ( interval <= 0 )
		goto close;

	// decrement timeout
	if ( m_Timeout > 0 )
	{
		if ( interval > 0 )
			m_Timeout -= interval;
		else
			m_Timeout = 0;
		if ( m_Timeout <= 0 )
			goto close;
	}

	// done
	return FALSE;
	
close:
	// remove sprite
	SetEnable( FALSE );
	HDC hdc = GetDC( hwnd );
	m_pWorld->Draw( hdc );
	ReleaseDC( hwnd, hdc );
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\games\checkers\checkmov.cpp ===
/*
** checkersmov.c
**
** Contains movement routines for the checkerslib
*/

#include "zone.h"
#include "checklib.h"
#include "checkmov.h"
#include "zonecrt.h"

#define START_ROW pTry->move.start.row
#define START_COL pTry->move.start.col
#define FINISH_ROW pTry->move.finish.row
#define FINISH_COL pTry->move.finish.col
#define MOVE_FORWARD ((pTry->state.nPlayer == zCheckersPlayerBlack) ?  \
						(START_ROW < FINISH_ROW) : (START_ROW > FINISH_ROW) )

#define PieceAt(pState,col,row) ((pState)->board[row][col])
#define PieceAtSquare(pState,sq) ((pState)->board[(sq)->row][(sq)->col])

#define zCheckersPieceAT_FINISH PieceAtSquare(&pTry->state,&pTry->move.finish)
#define zCheckersPieceAT_START PieceAtSquare(&pTry->state,&pTry->move.start)
#define NEXT_TO(x,y) (x == y-1 || x == y+1)


#define PAWN_AT_START_POS (pTry->state.nPlayer == zCheckersPlayerBlack ?  \
				(START_ROW == 1) : (START_ROW == 6) )
#define PAWN_AT_PROMOTION_ROW (pTry->state.nPlayer == zCheckersPlayerBlack ?  \
				(FINISH_ROW == 7) : (FINISH_ROW == 0) )
#define ROW_OFF_BY_TWO ( (START_ROW - FINISH_ROW == 2) || \
			(START_ROW - FINISH_ROW == -2) )
#define COL_OFF_BY_TWO ( (START_COL - FINISH_COL == 2) || \
			(START_COL - FINISH_COL == -2) )
#define ROW_OFF_BY_ONE ( (START_ROW - FINISH_ROW == 1) || \
			(START_ROW - FINISH_ROW == -1) )
#define CURRENT_PLAYER (pTry->state.nPlayer)

/* local prototypes */
ZBool ZCheckersMoveEqual(ZCheckersMove *pMove0, ZCheckersMove *pMove1);
void MovePieceHelperSimple(ZCheckersMoveTry *pTry);
void MovePieceHelper(ZCheckersMoveTry *pTry);
ZBool ZCheckersPawnCanMoveTo(ZCheckersMoveTry *pTry);
ZBool ZCheckersKingCanMoveTo(ZCheckersMoveTry *pTry);
ZBool ZCheckersPieceCanMoveToNoCheck(ZCheckersMoveTry *pTry);
ZBool ZCheckersPieceCanMoveToInternal(ZCheckersMoveTry *pTry);
int16 ZCheckersPieceCanMoveTo(ZCheckersMoveTry *pTry);
ZBool FindPiece(ZCheckersState *pState, BYTE nPieceFind, ZCheckersSquare *pSquare);
ZBool PieceCanMove(ZCheckersState *pState, ZCheckersSquare *pSquare);
ZBool PlayerCanJump(ZCheckersState* pState,BYTE nPlayer, ZCheckersMove* pMove);
static ZBool PlayerCanJumpWithPiece(ZCheckersState* pState,BYTE nPlayer, ZCheckersMove* pMove, ZCheckersSquare *sq);


ZBool ZCheckersSquareEqual(ZCheckersSquare* pSquare0, ZCheckersSquare* pSquare1)
{
	return (pSquare0->row == pSquare1->row &&
		pSquare0->col == pSquare1->col);
}

ZBool ZCheckersMoveEqual(ZCheckersMove* pMove0, ZCheckersMove* pMove1)
{
	return  (ZCheckersSquareEqual(&pMove0->start,&pMove1->start) &&
				ZCheckersSquareEqual(&pMove0->finish,&pMove1->finish) );
}

void MovePieceHelperSimple(ZCheckersMoveTry* pTry) 
{
	ZCheckersPiece piece;

	pTry->capture = zCheckersPieceNone; 
	piece = zCheckersPieceAT_START;
	pTry->state.board[START_ROW][START_COL] = zCheckersPieceNone;
	pTry->state.board[FINISH_ROW][FINISH_COL] = piece; 
}

void MovePieceHelperSimple2(ZCheckersMoveTry* pTry, ZCheckersMove* move) 
{
	ZCheckersPiece piece;

	pTry->capture = zCheckersPieceNone; 
	piece = PieceAtSquare(&pTry->state,&move->start);
	pTry->state.board[move->start.row][move->start.col] = zCheckersPieceNone;
	pTry->state.board[move->finish.row][move->finish.col] = piece; 
}

void MovePieceHelper(ZCheckersMoveTry* pTry)
{
	MovePieceHelperSimple(pTry);
	if (PieceAt(&pTry->state,FINISH_COL,FINISH_ROW)) {
		pTry->capture = zCheckersPieceAT_FINISH;
	} else {
		MovePieceHelperSimple(pTry);
	}
}

ZBool ZCheckersPawnCanMoveTo(ZCheckersMoveTry* pTry)
{
	if (!MOVE_FORWARD) {
		/* checkers cant move on top of anything */
		return FALSE;
	}

	/* except for the move forward restriction, checkers pawn moves like the king */
	if (!ZCheckersKingCanMoveTo(pTry)) {
		return FALSE;
	}

	if (PAWN_AT_PROMOTION_ROW) {
		/* this is a prompotion */
		if (CURRENT_PLAYER == zCheckersPlayerBlack) {
			pTry->state.board[FINISH_ROW][FINISH_COL] = zCheckersPieceBlackKing;
		} else {
			pTry->state.board[FINISH_ROW][FINISH_COL] = zCheckersPieceWhiteKing;
		}
		pTry->state.flags |= zCheckersFlagPromote;
	}
	return TRUE;
}
ZBool ZCheckersKingCanMoveTo(ZCheckersMoveTry* pTry)
{
	if (zCheckersPieceAT_FINISH) {
		/* checkers cant move on top of anything */
		return FALSE;
	}

	if (NEXT_TO(START_COL,FINISH_COL) && NEXT_TO(START_ROW,FINISH_ROW)) {
		MovePieceHelperSimple(pTry);

		/* we are moving just one square */
		return TRUE;
	} else {
		/* this is a jump attemp */
		ZCheckersSquare sq;
		ZCheckersPiece piece;

		if (!ROW_OFF_BY_TWO || !COL_OFF_BY_TWO) {
			/* checkers can jump and must be offset by two diagonally */
			return FALSE;
		}

		sq.col = (START_COL + FINISH_COL)/2;
		sq.row = (START_ROW + FINISH_ROW)/2;

		piece = PieceAtSquare(&pTry->state,&sq);

		if (piece == zCheckersPieceNone || ZCheckersPieceOwner(piece) == pTry->state.nPlayer) {
			/* piece must be there and can't capture your own piece */
			return FALSE;
		}

		MovePieceHelperSimple(pTry);

		/* remove the piece captured */
		pTry->capture = PieceAtSquare(&pTry->state,	&sq); 
		pTry->state.board[sq.row][sq.col] = zCheckersPieceNone;

		/* record the fact that this was a jump */
		pTry->state.flags |= zCheckersFlagWasJump;

		return TRUE;
	}
	/* UNREACHED */
	return TRUE;
}

ZBool ZCheckersPieceCanMoveToNoCheck(ZCheckersMoveTry* pTry)
/* returns true if piece can move to */
{
	BYTE nPiece = ZCheckersPieceType(PieceAtSquare(&pTry->state,&pTry->move.start));
	ZCheckersPiece pieceFinish = PieceAtSquare(&pTry->state,&pTry->move.finish);
	pTry->state.flags = 0;

	
	if (pieceFinish != zCheckersPieceNone &&
		ZCheckersPieceOwner(pieceFinish) == pTry->state.nPlayer) {
		/* can't capture your own piece */
		return FALSE;
	}

	switch (nPiece) {
		case zCheckersPiecePawn:
			if (!ZCheckersPawnCanMoveTo(pTry)) return FALSE;
			break;
		case zCheckersPieceKing:
			if (!ZCheckersKingCanMoveTo(pTry)) return FALSE;
			break;
		default:
			return FALSE;
	}
	return TRUE;
}

ZBool ZCheckersPieceCanMoveToInternal(ZCheckersMoveTry* pTry)
{
	if (!ZCheckersPieceCanMoveToNoCheck(pTry)) {
		return FALSE;
	}

	/* save last move as part of state */
	pTry->state.lastMove = pTry->move;
	return TRUE;
}

int16 ZCheckersPieceCanMoveTo(ZCheckersMoveTry* pTry)
{
	ZCheckersMove move0;
	ZBool mustJump = FALSE;
	if (PlayerCanJump(&pTry->state, pTry->state.nPlayer,&move0)) {
		mustJump = TRUE;
	}
	if (!ZCheckersPieceCanMoveToInternal(pTry)) {
		return zOtherIllegalMove;
	}
	if (mustJump && !(pTry->state.flags & zCheckersFlagWasJump)) {
		return zMustJump;
	} else {
		/* this was a jump must continue jumps */
		/* also, must jump with the same piece that jumped last */
		if (mustJump && PlayerCanJumpWithPiece(&pTry->state, pTry->state.nPlayer, &move0, &pTry->move.finish)) {
			/* don't allow continue jump if promotion to a king occured */
			if (!(pTry->state.flags & zCheckersFlagPromote)) {
				/* indicate that this player should continue turn */
				pTry->state.flags |= zCheckersFlagContinueJump;
			}
		}
	}
	
	return zCorrectMove;
}

/*--------------------------------------------------------------------------*/

ZBool FindPiece(ZCheckersState* pState, BYTE nPieceFind, ZCheckersSquare* pSquare)
{
	int i,j;
	ZCheckersSquare sq;

	/* try all possible moves */
	for (i = 0;i< 8;i++) {
		sq.row = i;
		for (j = 0; j < 8 ; j++) {
			int nPiece;
			sq.col = j;
			nPiece = PieceAtSquare(pState,&sq);
			if (nPiece == nPieceFind) {
				*pSquare = sq;
				return TRUE;
			}
				
		}
	}

	return FALSE;
}

static ZBool PlayerCanJumpWithPiece(ZCheckersState* pState,BYTE nPlayer, ZCheckersMove* pMove, ZCheckersSquare *sq)
{
	ZCheckersMove move;
	ZCheckersPiece nPiece;

	move.start.row = sq->row; 
	move.start.col = sq->col;
				
	nPiece=PieceAtSquare(pState,&move.start);
	if (nPiece != zCheckersPieceNone && ZCheckersPieceOwner(nPiece) == nPlayer) {
		int16 i,j;
		for (i = -2; i<=2; i+=2) {
			for (j = -2; j <=2; j+=2) {
				ZCheckersMoveTry zChkTry;
				z_memcpy(&zChkTry.state,pState,sizeof(ZCheckersState));
				move.finish.row = i + move.start.row;
				move.finish.col = j + move.start.col;
				/* is this a legal jump? */
				if (move.finish.row >= 0 && move.finish.row < 8 &&
					move.start.col >= 0 && move.finish.col < 8) {
					zChkTry.move = move;
					if (ZCheckersPieceCanMoveToNoCheck(&zChkTry) && (zChkTry.state.flags & zCheckersFlagWasJump)) {
						/* yes, this is a jump */
						*pMove = move;
						return TRUE;
					}
				}
			}
		}
	}	
	return FALSE;
}

ZBool PlayerCanJump(ZCheckersState* pState,BYTE nPlayer, ZCheckersMove* pMove)
{
	ZCheckersMove move;
	BYTE row,col;

	/* go through all pieces, see if they can jump. */
	for (row = 0; row < 8; row++) {
		move.start.row = row; 
		for (col = 0; col < 8; col++) {
			int nPiece;
			move.start.col = col;
			nPiece=PieceAtSquare(pState,&move.start);
			if (nPiece != zCheckersPieceNone && ZCheckersPieceOwner(nPiece) == nPlayer) {
				if (PlayerCanJumpWithPiece(pState, nPlayer, pMove, &move.start)) {
					return TRUE;
				}
			}	
		}
	}
	return FALSE;
}

ZBool PieceCanMove(ZCheckersState* pState, ZCheckersSquare* pSquare)
{
	int i,j;
	ZCheckersMoveTry zChkTry;

	/* zChkTry all possible moves */
	zChkTry.move.start = *pSquare;
	for (i = 0;i< 8;i++) {
		zChkTry.move.finish.row = i;
		for (j = 0; j < 8 ; j++) {
			zChkTry.move.finish.col = j;
			z_memcpy(&zChkTry.state,pState,sizeof(ZCheckersState));
			if (ZCheckersPieceCanMoveToInternal(&zChkTry)) {
				return TRUE;
			}
		}
	}
	return FALSE;
}

void ZCheckersCheckCheckmateFlags(ZCheckersState* pState)
{
	BYTE nPlayer;
	ZCheckersSquare sq;
	BYTE i,j;

	/* make a copy of the current state, check for check,checkmate, stalemate */
	ZCheckersState state;
	z_memcpy(&state,pState,sizeof(ZCheckersState));
	state.nPlayer = (state.nPlayer +1) & 1;

	/* go through all pieces of player not moving to see if king is attacked */

	nPlayer = state.nPlayer;
	{
		ZBool isStalemate = TRUE;
		/* check to see if piece of the next player can move... */
		for (i = 0;i< 8;i++) {
			sq.row = i;
			for (j = 0; j < 8 ; j++) {
				int nPiece;
				sq.col = j;
				if ((nPiece = PieceAtSquare(&state,&sq)) == zCheckersPieceNone || 
						ZCheckersPieceOwner(nPiece) != nPlayer) {
					/* this is not a piece of the next player */
					continue;
				}
				if (PieceCanMove(&state,&sq)) {
					isStalemate = FALSE;
					break;
				}
			}
		}
		if (isStalemate)
			state.flags |= zCheckersFlagStalemate;
	}

	pState->flags = state.flags;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\games\hearts\init.cpp ===
/*******************************************************************************

	init.cpp
	
		Zone(tm) game main file.
	
	Copyright (c) Microsoft Corp. 1996. All rights reserved.
	Written by Hoon Im
	Created on December 11, 1996.
	
	Change History (most recent first):
	----------------------------------------------------------------------------
	Rev	 |	Date	 |	Who	 |	What
	----------------------------------------------------------------------------
	0		12/11/96	HI		Created.
	 
*******************************************************************************/
#include "BasicATL.h"

#include <ZoneShell.h>

CZoneComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
END_OBJECT_MAP()


/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE
/////////////////////////////////////////////////////////////////////////////

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type
/////////////////////////////////////////////////////////////////////////////

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/****************************************************************************
   FUNCTION: DllMain(HANDLE, DWORD, LPVOID)

   PURPOSE:  DllMain is called by Windows when
             the DLL is initialized, Thread Attached, and other times.
             Refer to SDK documentation, as to the different ways this
             may be called.


*******************************************************************************/
extern "C"
BOOL APIENTRY DllMain( HMODULE hMod, DWORD dwReason, LPVOID lpReserved )
{
    BOOL bRet = TRUE;

    switch( dwReason )
    {
        case DLL_PROCESS_ATTACH:
		    _Module.Init(ObjectMap, hMod);
		    //DisableThreadLibraryCalls(hInstance);
            // fall thru, b/c this is the first thread attach as well
        case DLL_THREAD_ATTACH:
            // allocate memory and use TlsSetValue
            break;

        case DLL_THREAD_DETACH:
            // free memory retrieved by TlsGetValue
            break;

        case DLL_PROCESS_DETACH:
        	_Module.Term();
            break;
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\games\checkers\checkmov.h ===
/*
** checkersmov.h
**
** Various checkers movement stuff.
*/
#include <tchar.h>

typedef BYTE ZCheckersBoard[8][8];

typedef struct {
	ZCheckersMove lastMove;
	ZCheckersBoard board;
	int16 nMoves;
	BYTE nCapturedPieces;
	ZCheckersPiece capturedPieces[32]; /*two kings can't be captured */
	uint32 flags; /* flags such zCheckersFlagCheck, zCheckersFlagPromote */
	BYTE nPlayer; /* player to move */
} ZCheckersState;

typedef struct {
	ZCheckersMove move;
	ZCheckersState state;
	ZCheckersPiece capture;
} ZCheckersMoveTry;

// Barna 091099
enum
{
	zCorrectMove = 0,
	zMustJump,
	zOtherIllegalMove
};

// Barna 091099
//ZBool ZCheckersPieceCanMoveTo(ZCheckersMoveTry* pTry);
int16 ZCheckersPieceCanMoveTo(ZCheckersMoveTry* pTry);
ZBool ZCheckersSquareEqual(ZCheckersSquare *pSquare0, ZCheckersSquare *pSquare1);
void ZCheckersCheckCheckmateFlags(ZCheckersState* pState);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\games\checkers\client.h ===
#ifndef _CHECKERSCLIENT_H
#define _CHECKERSCLIENT_H


#define I(object)					((Game) (object))
#define Z(object)					((ZCGame) (object))

#define zGameNameLen				63

#define zNumPlayersPerTable			2
#define zGameVersion				0x00010202

#define zCheckers					_T("Checkers")
#define zGameImageFileName			_T("chkrres.dll")

#define zOptionsButtonStr			_T("Options")
#define zBeepOnTurnStr				_T("Beep on my turn")

#define zQuitGamePromptStr			_T("Are you sure you want to leave this game?")
// keys to read rsc control strings from ui.txt
#define zFontRscTyp					_T("Fonts")
#define zFontId						_T("Font")
#define zColorId					_T("Color")

#define zShowPlayerWindowWidth		120
#define zShowPlayerLineHeight		12

#define	zDragSquareOutlineWidth		3

#define zSmallStrLen				128
#define zMediumStrLen				512
#define zLargeStrLen				640

#define zResultBoxTimeout			800 /* 8 Sec*/
#define zRscOffset					12000 /* This is reqd for LoadGameImages() to corectly load the BMP rscs from the Rsc file*/

/* animation velocity in pixels per interval */
/* diagonal pixels is (7 + 7) * 38 = 608 */
/* should be able to travel across the screen in a sec */
/* animation interval in 100ths of sec */
/*#define zAnimateVelocity 15*/
#define zAnimateSteps				8
#define zAnimateTime				50
#define zAnimateInterval ((zAnimateTime+zAnimateSteps-1)/zAnimateSteps)

#define zCellWidth					37
#define zCellRealWidth				38		/* Added a grid line between cells. */

#define zCheckersPieceImageWidth	zCellWidth
#define zCheckersPieceImageHeight	zCellWidth
#define zCheckersPieceSquareWidth	zCellRealWidth
#define zCheckersPieceSquareHeight	zCellRealWidth

/*Accessibility*/
#define zCheckersAccessibleComponents	66


/* sound information */
typedef struct
{
	TCHAR	SoundName[128];
	TCHAR	WavFile[MAX_PATH];
	ZBool	force_default_sound;
	ZBool	played;
} ZCheckersSound;

enum
{
	zSndTurnAlert = 0,
	zSndIllegalMove,
	zSndWin,
	zSndLose,
	zSndCapture,
	zSndKing,
	zSndLastEntry
};

static ZCheckersSound gSounds[ zSndLastEntry ] =
{
	{ _T("TurnAlert"),		_T(""), TRUE,	FALSE },
	{ _T("IllegalMove"),	_T(""), TRUE,	FALSE },
	{ _T("Win"),			_T(""), FALSE,	FALSE },
	{ _T("Lose"),			_T(""), FALSE,  FALSE },
	{ _T("Capture"),		_T(""),	FALSE,	FALSE },
	{ _T("King"),			_T(""), FALSE,	FALSE }
};


/*----------------------UI components positions--------------------------------*/
static ZRect 	zDrawButtonRect=			{1, 288, 107, 318}; // {4,300,104,343};
static ZRect	gQuitGamePromptRect=		{0, 0, 280, 100};

static RECT     zCloseButtonRect =          { 338, 161, 349, 173 };
static RECT     zCloseButtonRectRTL =       { 192, 161, 203, 173 };

static ZRect	gRects[]=			{
										{0, 0, 540, 360},
										{118, 28, 421, 331},	
										{9, 43, 104, 57},
										{435, 302, 530, 316},
										{4, 25, 110, 75},
										{429, 284, 535, 334},
										{1, 257, 107, 287}, // sequence button
										{7, 314, 107, 334},
										{86, 77, 110, 101},
										{429, 201, 453, 225},
										{512, 4, 536, 28},
										{512, 30, 536, 54},
										{180, 149, 360, 209},
										{193, 172, 345, 187},
										{64, 160, 103, 199},
										{436, 160, 475, 199},
										{8, 199, 103, 227}, //213 ->227
										{436, 199, 531, 213},
                                        {0, 340, 540, 360}
									}; 


enum
{
	zRectWindow,
	zRectCells,
	zRectName1,
	zRectName2,
	zRectNamePlate1,
	zRectNamePlate2,
	zRectSequenceButton,
	zRectOptionsButton,
	zRectKibitzer1,
	zRectKibitzer2,
	zRectHelp,
	zRectKibitzerOption,
	zRectResultBox,
	zRectResultBoxName,
	zRectMove1,
	zRectMove2,
	zRectPlayerTurn1,
	zRectPlayerTurn2,
    zRectDrawPend
};


enum {

	/* -------- Options Window Rectangles -------- */
	zRectOptions = 0,
	zRectOptionsOkButton,
	zRectOptionsKibitzingText,
	zRectOptionsPlayer1Name,
	zRectOptionsPlayer2Name,
	zRectOptionsKibitzing1,
	zRectOptionsKibitzing2,
	zRectOptionsBeep
};

static ZRect			gOptionsRects[] =	{
												{0, 0, 249, 147},
												{94, 117, 154, 137},
												{149, 10, 229, 26},
												{20, 35, 140, 51},
												{20, 53, 140, 69},
												{181, 34, 197, 52},
												{181, 52, 197, 70},
												{20, 79, 230, 97}
											};


static int16			gOptionsNameRects[] =	{
													zRectOptionsPlayer1Name,
													zRectOptionsPlayer2Name,
												};
static int16			gOptionsKibitzingRectIndex[] =	{
															zRectOptionsKibitzing1,
															zRectOptionsKibitzing2,
														};
static int16			gKibitzerRectIndex[] =	{
													zRectKibitzer1,
													zRectKibitzer2,
												};


static int16 gNameRects[] = { zRectName1, zRectName2 };
static int16 gNamePlateRects[] = { zRectNamePlate1, zRectNamePlate2 };

static ZRect			gHelpWindowRect = {0, 0, 400, 300};

#define ZCheckersPieceImageNum(x) \
	(ZCheckersPieceIsWhite(x) ? \
			(zImageWhitePawn + (x - zCheckersPieceWhitePawn)) : \
			(zImageBlackPawn + (x - zCheckersPieceBlackPawn)) )


/* -------- Game Images -------- */
enum
{
	/* Game Images */
	zImageBackground = 0,
	zImageBlackPawn,
	zImageBlackKing,
	zImageWhitePawn,
	zImageWhiteKing,
	zImageBlackPlate,
	zImageWhitePlate,
	zImageBlackMarker,
	zImageWhiteMarker,
	zImageFinalScoreDraw,

	zNumGameImages
};


/* -------- Game States -------- */
enum
{
	zGameStateNotInited = 0,
	zGameStateMove,
	zGameStateDragPiece,
	zGameStateGameOver,
	zGameStateKibitzerInit,
	zGameStateAnimatePiece,
	zGameStateWaitNew,
	zGameStateDraw,
};

/* -------- Game Prompt Cookies -------- */
enum{
	zDrawPrompt,
	zQuitprompt,
	zResignConfirmPrompt
};


/* -------- Game Info -------- */
typedef struct
{
	int16			tableID;
	int16			seat;
	ZWindow			gameWindow;

	// Barna 090999
	//ZButton			sequenceButton;
	ZRolloverButton		sequenceButton;

	// Barna 090799
	//ZButton			optionsButton;
	//ZHelpButton		helpButton;
	// Barna 090799

	//draw button
	// Barna 090999
	//ZButton			drawButton;
	ZRolloverButton		drawButton;
	// Barna 090999

	ZSeat			seatOfferingDraw;
	
// Barna 090899
	ZBool			kibitzer;
// Barna 090899
	ZBool			ignoreMessages;
	TPlayerInfo		players[zNumPlayersPerTable];

	ZCheckers checkers; /* the checkers object */

	/* Game Options */
	uint32			gameOptions;

	/* stuff used for dragging of pieces */
	ZOffscreenPort	offscreenSaveDragBackground;
	ZRect			rectSaveDragBackground;
	ZCheckersSquare	selectedSquare;
	ZCheckersPiece		dragPiece;
	ZPoint			dragPoint; /* current point of drag */
	ZPoint			startDragPoint; /* point where drag started */

	/* used for quick display of move */
	int16			finalScore; /* 0 black wins, 1 white wins */

	/* -- stuff below here needs be transferred as game state to kibitzer */
	/* Current Game State Info */
	int16			gameState;
    int16           gameCloseReason;

	/* new game voting */
	ZBool			newGameVote[2];

	/* Options Window Items */
	ZWindow			optionsWindow;
	ZButton			optionsWindowButton;
	ZCheckBox		optionsKibitzing[zNumPlayersPerTable];
	ZCheckBox		optionsJoining[zNumPlayersPerTable];
	ZCheckBox		optionsBeep;
	
	/* flag for beep sound after opponents move */
	ZBool			beepOnTurn;
	ZUserID			playersToJoin[zNumPlayersPerTable];

	int16			numKibitzers[zNumPlayersPerTable];
	ZLList			kibitzers[zNumPlayersPerTable];

	uint32			tableOptions[zNumPlayersPerTable];

	/* Show Player Items */
	ZWindow			showPlayerWindow;
	TCHAR**			showPlayerList;
	int16			showPlayerCount;

	/* stuff used for Animate of opponents piece move */
	ZCheckersMove			animateMove;
	ZCheckersPiece			animatePiece;
	int16					animateDx;
	int16					animateDy;
	int16					animateStepsLeft;
	ZTimer					animateTimer;
	HWND					drawDialog;
	// Barna 091399
	ZTimer				resultBoxTimer;

	//new ratings and move timeout flags
	ZBool			bStarted;
	ZBool			bEndLogReceived;
	ZBool			bOpponentTimeout;
	ZInfo			exitInfo;
	ZBool			bMoveNotStarted;
	ZBool			bDrawPending;	// Flag to consider invalidation during animation

	//CComObject<CCheckersGraphicallyAccControl> mCGA;
	//GACCITEM				listCheckersAccItems[3];
	RECT			m_FocusRect;
	RECT			m_DragRect;

    bool            fMoveOver;
    bool            fIVoted;
} GameType, *Game;

// Barna 091099
typedef struct
{
	BYTE			resFileName[128];
    HINSTANCE       resFile;
} IResourceType, *IResource;

// Dynamic Font loading from UI.TXT
typedef struct
{
	HFONT			m_hFont;
	ZONEFONT		m_zFont;
    COLORREF		m_zColor;
} LPCheckersColorFont, *CheckersColorFont;

/*------------------ Dynamic Font readfrom UI,TXT -------------------*/
#define zNumFonts 4
enum{
	zFontResultBox,
	zFontIndicateTurn,
	zFontPlayerName,
	zFontDrawPend
};

// keys to read rsc control strings from ui.txt
#define zKey_FontRscTyp					_T("Fonts")
#define zKey_FontId						_T("Font")
#define zKey_ColorId					_T("Color")
#define zKey_RESULTBOX					_T("ResultBox")
#define zKey_INDICATETURN				_T("IndicateTurn")
#define zKey_PLAYERNAME					_T("PlayerName")
#define zKey_ROLLOVERTEXT				_T("RolloverText")
#define zKey_DRAWPEND   				_T("DrawPend")

HINSTANCE 				ghInst;

/* traslation for the seatId to the index for rectangles */
#define GetLocalSeat(game,seatId) (seatId - game->seat + zNumPlayersPerTable +1) % zNumPlayersPerTable

#define ZCheckersPlayerIsWhite(g) ((g)->seat == zCheckersPlayerWhite)
#define ZCheckersPlayerIsBlack(g) ((g)->seat == zCheckersPlayerBlack)
#define ZCheckersPlayerIsMyMove(g) ((g)->seat == ZCheckersPlayerToMove(g->checkers))

/* -------- Globals -------- */
#ifndef ZONECLI_DLL

static TCHAR				gGameDir[zGameNameLen + 1];
static TCHAR				gGameName[zGameNameLen + 1];
static TCHAR				gGameDataFile[zGameNameLen + 1];
static TCHAR				gGameServerName[zGameNameLen + 1];
static uint32			gGameServerPort;
static ZBool			gInited;
//static ZImage			gGameIdle;
//static ZImage			gGaming;
static ZImage			gGameImages[zNumGameImages];
static ZHelpWindow		gHelpWindow;
static ZFont			gTextBold;
static ZFont			gTextNormal;
static ZColor			gWhiteColor;
static ZColor			gWhiteSquareColor;
static ZColor			gBlackSquareColor;
static ZOffscreenPort	gOffscreenBackground;
static ZOffscreenPort	m_gOffscreenGameBoard;
static ZBool			gActivated;

/* Bug Fix 212: flag indicating that game results bitmap should not be drawn */
static int16 gDontDrawResults = FALSE;

static ZImage			gSequenceImages[zNumRolloverStates];
static ZImage			gDrawImages[zNumRolloverStates];

//static BYTE				gStrButtonRed[zSmallStrLen];
//static BYTE				gStrButtonWhite[zSmallStrLen];
static TCHAR				gStrOppsTurn[zMediumStrLen];
static TCHAR				gStrYourTurn[zMediumStrLen];
//static TCHAR				gStrDlgCaption[zMediumStrLen];
static TCHAR				gStrDrawPend[ZONE_MaxString];
static TCHAR				gStrDrawOffer[ZONE_MaxString];
static TCHAR				gStrDrawReject[ZONE_MaxString];
//static TCHAR				gStrDrawAccept[ZONE_MaxString];
//static TCHAR				gStrDlgYes[zSmallStrLen];
//static TCHAR				gStrDlgNo[zSmallStrLen];
//static TCHAR				gStrDlgOk[zSmallStrLen];
static TCHAR				gStrDrawText[zMediumStrLen];
//static TCHAR				gStrGameOverText[zMediumStrLen];
static TCHAR				gStrMustJumpText[zLargeStrLen];
static TCHAR				gStrDrawAcceptCaption[zMediumStrLen];
static TCHAR				gStrResignBtn[zSmallStrLen];
static TCHAR				gStrDrawBtn[zSmallStrLen];

static TCHAR				gResignConfirmStr[ZONE_MaxString];
static TCHAR				gResignConfirmStrCap[zLargeStrLen];

static IGameShell*			gGameShell;
static LPCheckersColorFont	gCheckersFont[zNumFonts];
static IZoneMultiStateFont*	gpButtonFont;
static IGraphicalAccessibility *gCheckersIGA;

static HBITMAP      gDragPattern;
static HBRUSH       gDragBrush;
static HBITMAP      gFocusPattern;
static HBRUSH       gFocusBrush;
static HPEN         gNullPen;

#endif

// Barna 090999
#define zNumRolloverStates 4
enum
{
	zButtonInactive = 0,
	zButtonActive,
	zButtonPressed,
	zButtonDisabled
};
// Barna 090999

#ifdef ZONECLI_DLL

/* -------- Volatible Globals & Macros -------- */
typedef struct
{
	TCHAR			m_gGameDir[zGameNameLen + 1];
	TCHAR			m_gGameName[zGameNameLen + 1];
	TCHAR			m_gGameDataFile[zGameNameLen + 1];
	TCHAR			m_gGameServerName[zGameNameLen + 1];
	uint32			m_gGameServerPort;
	//ZImage			m_gGameIdle;
	//ZImage			m_gGaming;
	ZImage			m_gGameImages[zNumGameImages];
	ZImage			m_gDrawImage;
	ZFont			m_gTextBold;
	ZFont			m_gTextNormal;
	ZBool			m_gInited;
	ZColor			m_gWhiteColor;
	ZColor			m_gWhiteSquareColor;
	ZColor			m_gBlackSquareColor;
	ZOffscreenPort	m_gOffscreenBackground;
	ZOffscreenPort	m_gOffscreenGameBoard;
	ZBool			m_gActivated;
	int16			m_gDontDrawResults;
	int				m_Unblocking;
	ZImage			m_gSequenceImages[zNumRolloverStates];
	ZImage			m_gDrawImages[zNumRolloverStates];
    ZImage          m_gButtonMask;
	//BYTE			m_gStrButtonRed[zSmallStrLen];
	//BYTE			m_gStrButtonWhite[zSmallStrLen];
	TCHAR			m_gStrOppsTurn[zMediumStrLen];
	TCHAR			m_gStrYourTurn[zMediumStrLen];
//	TCHAR			m_gStrDlgCaption[zMediumStrLen];
	TCHAR			m_gStrDrawPend[ZONE_MaxString];
	TCHAR			m_gStrDrawOffer[ZONE_MaxString];
	TCHAR			m_gStrDrawReject[ZONE_MaxString];
//	TCHAR			m_gStrDrawAccept[ZONE_MaxString];
//	TCHAR			m_gStrDlgYes[zSmallStrLen];
//	TCHAR			m_gStrDlgNo[zSmallStrLen];
//	TCHAR			m_gStrDlgOk[zSmallStrLen];
	TCHAR			m_gStrDrawText[zMediumStrLen];
//	TCHAR			m_gStrGameOverText[zMediumStrLen];
	TCHAR			m_gStrMustJumpText[zLargeStrLen];	
	TCHAR			m_gStrDrawAcceptCaption[zMediumStrLen];
	TCHAR			m_gStrResignBtn[zSmallStrLen];		
	TCHAR			m_gStrDrawBtn[zSmallStrLen];			
	TCHAR			m_gResignConfirmStr[ZONE_MaxString];
	TCHAR			m_gResignConfirmStrCap[zLargeStrLen];
	LPCheckersColorFont			m_gCheckersFont[zNumFonts];
	IZoneMultiStateFont*		m_gpButtonFont;
    HBITMAP         m_gDragPattern;
    HBRUSH          m_gDragBrush;
    HBITMAP         m_gFocusPattern;
    HBRUSH          m_gFocusBrush;
    HPEN            m_gNullPen;
	CComPtr<IGraphicalAccessibility> m_gCheckersIGA;
} GameGlobalsType, *GameGlobals;

#define gGameDir				(pGameGlobals->m_gGameDir)
#define gGameName				(pGameGlobals->m_gGameName)
#define gGameDataFile			(pGameGlobals->m_gGameDataFile)
#define gGameServerName			(pGameGlobals->m_gGameServerName)
#define gGameServerPort			(pGameGlobals->m_gGameServerPort)
//#define gGameIdle				(pGameGlobals->m_gGameIdle)
//#define gGaming					(pGameGlobals->m_gGaming)
#define gGameImages				(pGameGlobals->m_gGameImages)
//#define gDrawImage				(pGameGlobals->m_gDrawImage)
#define gHelpWindow				(pGameGlobals->m_gHelpWindow)
#define gTextBold				(pGameGlobals->m_gTextBold)
#define gTextNormal				(pGameGlobals->m_gTextNormal)
#define gInited					(pGameGlobals->m_gInited)
#define gWhiteColor				(pGameGlobals->m_gWhiteColor)
#define gWhiteSquareColor		(pGameGlobals->m_gWhiteSquareColor)
#define gBlackSquareColor		(pGameGlobals->m_gBlackSquareColor)
#define gOffscreenBackground	(pGameGlobals->m_gOffscreenBackground)
#define gOffscreenGameBoard		(pGameGlobals->m_gOffscreenGameBoard)
#define gActivated				(pGameGlobals->m_gActivated)
#define gDontDrawResults		(pGameGlobals->m_gDontDrawResults)
#define Unblocking				(pGameGlobals->m_Unblocking)
// Barna 090999
#define gSequenceImages			(pGameGlobals->m_gSequenceImages)
#define gDrawImages				(pGameGlobals->m_gDrawImages)

//#define gStrButtonRed			(pGameGlobals->m_gStrButtonRed)
//#define gStrButtonWhite			(pGameGlobals->m_gStrButtonWhite)
#define gStrOppsTurn			(pGameGlobals->m_gStrOppsTurn)
#define gStrYourTurn			(pGameGlobals->m_gStrYourTurn)
//#define gStrDlgCaption			(pGameGlobals->m_gStrDlgCaption)
#define gStrDrawPend			(pGameGlobals->m_gStrDrawPend)
#define gStrDrawOffer			(pGameGlobals->m_gStrDrawOffer)
#define gStrDrawReject			(pGameGlobals->m_gStrDrawReject)
//#define gStrDrawAccept			(pGameGlobals->m_gStrDrawAccept)
//#define gStrDlgYes				(pGameGlobals->m_gStrDlgYes)
//#define gStrDlgNo				(pGameGlobals->m_gStrDlgNo)
//#define gStrDlgOk				(pGameGlobals->m_gStrDlgOk)
#define gStrDrawText			(pGameGlobals->m_gStrDrawText)
//#define gStrGameOverText		(pGameGlobals->m_gStrGameOverText)
#define gStrMustJumpText		(pGameGlobals->m_gStrMustJumpText)
#define gStrDrawAcceptCaption	(pGameGlobals->m_gStrDrawAcceptCaption)
#define gStrResignBtn			(pGameGlobals->m_gStrResignBtn)
#define gStrDrawBtn				(pGameGlobals->m_gStrDrawBtn)
#define gResignConfirmStr		(pGameGlobals->m_gResignConfirmStr)
#define gResignConfirmStrCap	(pGameGlobals->m_gResignConfirmStrCap)
// Barna 090999
#define gGameShell              (pGameGlobals->m_gGameShell)

#define gCheckersFont			(pGameGlobals->m_gCheckersFont)
#define gpButtonFont			(pGameGlobals->m_gpButtonFont)
#define gButtonMask				(pGameGlobals->m_gButtonMask)
#define gDragPattern            (pGameGlobals->m_gDragPattern)
#define gDragBrush              (pGameGlobals->m_gDragBrush)
#define gFocusPattern           (pGameGlobals->m_gFocusPattern)
#define gFocusBrush             (pGameGlobals->m_gFocusBrush)
#define gNullPen                (pGameGlobals->m_gNullPen)
#define gCheckersIGA			(pGameGlobals->m_gCheckersIGA)

#endif


/* -------- Internal Routine Prototypes -------- */
//BOOL __stdcall DrawDlgProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam);

static bool HandleTalkMessage(Game game, ZCheckersMsgTalk* msg);
static bool HandleMovePieceMessage(Game game, ZCheckersMsgMovePiece* msg);
static bool HandleEndGameMessage(Game game, ZCheckersMsgEndGame* msg);
static bool HandleFinishMoveMessage(Game game, ZCheckersMsgFinishMove* msg);
static void GameSendTalkMessage(ZWindow window, ZMessage* pMessage);
static void HandleButtonDown(ZWindow window, ZMessage* pMessage);
static void UpdatePlayers(Game game);
static void DrawPlayers(Game game, BOOL bDrawInMemory);
static void UpdateTable(Game game);
static void DrawTable(Game game, BOOL bDrawInMemory);
static void UpdateResultBox(Game game);
static void DrawBackground(Game game, ZRect* clipRect);
static void GameWindowDraw(ZWindow window, ZMessage *message);
static void QuitGamePromptFunc(int16 result, void* userData);
static void TakeBackMoveButtonFunc(ZButton button, void* userData);
static void GoForwardMoveButtonFunc(ZButton button, void* userData);
// Barna 090999
static ZBool SequenceRButtonFunc(ZPictButton button, int16 state, void* userData);
static void GameExit(Game game);
static ZBool GameWindowFunc(ZWindow window, ZMessage* pMessage);
static ZError LoadGameImages(void);
ZBool LoadRolloverButtonImage(ZResource resFile, int16 dwResID,/* int16 dwButtonWidth,*/
							  ZImage rgImages[zNumRolloverStates]);
static ZError CheckersInit(void);
static void UpdateSquares(Game game, ZCheckersSquare* squares);
static void DrawSquares(Game game, ZCheckersSquare* squares);
static void DrawPiece(Game game, ZCheckersSquare* sq, BOOL bDrawInMemory);
static void DrawResultBox(Game game, BOOL bDrawInMemory);
static void DrawMoveIndicator(Game game, BOOL bDrawInMemory);
static void UpdateMoveIndicator(Game game);
static ZBool ZCheckersSquareFromPoint(Game game, ZPoint* point, ZCheckersSquare* sq);
static void EndDragState(Game game);
static void EraseDragPiece(Game game);
static void DrawDragPiece(Game game, BOOL bDrawInMemory);
static void HandleIdleMessage(ZWindow window, ZMessage* pMessage);
static void HandleButtonUp(ZWindow window, ZMessage* pMessage);
static void UpdateDragPiece(Game game);
static void GetPieceRect(Game game, ZRect* rect, int16 col, int16 row);
static void GetPieceBackground(Game game, ZGrafPort window, ZRect* rectDest, int16 col, int16 row);
static void UpdateSquare(Game game, ZCheckersSquare* sq);
static void FinishMoveUpdateStateHelper(Game game, ZCheckersSquare* squaresChanged);
static void HandleGameStateReqMessage(Game game, ZCheckersMsgGameStateReq* msg);
static void HandleGameStateRespMessage(Game game, ZCheckersMsgGameStateResp* msg);

static void DrawDrawWithNextMove(Game game, BOOL bDrawInMemory);
static void UpdateDrawWithNextMove(Game game);

static void HandleMoveTimeout(Game game, ZCheckersMsgMoveTimeout* msg);
static void HandleEndLogMessage(Game game, ZCheckersMsgEndLog* msg);

static void CheckersSetGameState(Game game, int16 state);
static bool HandleNewGameMessage(Game game, ZCheckersMsgNewGame* msg);
static bool HandleVoteNewGameMessage(Game game, ZCheckersMsgVoteNewGame* msg);
static void HandlePlayersMessage(Game game, ZCheckersMsgNewGame* msg);
static void CheckersInitNewGame(Game game);
static void SendFinishMoveMessage(Game game, ZCheckersPiece piece);
static void ClearDragState(Game game);

static void LoadRoomImages(void);
static ZBool GetObjectFunc(int16 objectType, int16 modifier, ZImage* image, ZRect* rect);
static void DeleteObjectsFunc(void);
static void SendNewGameMessage(Game game);

static void DisplayChange(Game game);

static void CloseGameFunc(Game game);

//dossier
static void DrawGamePromptFunc(int16 result, void* userData);

static void HandleOptionsMessage(Game game, ZGameMsgTableOptions* msg);
//static void OptionsButtonFunc(ZPictButton pictButton, void* userData);
static ZBool DrawRButtonFunc(ZPictButton pictButton,int16 state, void* userData);

//static void ShowOptions(Game game);
//static void OptionsWindowDelete(Game game);
//static ZBool OptionsWindowFunc(ZWindow window, ZMessage* message);
static void OptionsWindowUpdate(Game game, int16 seat);
//static void OptionsWindowButtonFunc(ZButton button, void* userData);
//static void OptionsWindowDraw(Game game);
//static void OptionsCheckBoxFunc(ZCheckBox checkBox, ZBool checked, void* userData);

static int16 FindJoinerKibitzerSeat(Game game, ZPoint* point);
//static void HandleJoinerKibitzerClick(Game game, int16 seat, ZPoint* point);

static ZBool ShowPlayerWindowFunc(ZWindow window, ZMessage* message);
static void ShowPlayerWindowDraw(Game game);
static void ShowPlayerWindowDelete(Game game);

static void DrawJoinerKibitzers(Game game);
//static void UpdateJoinerKibitzers(Game game);

static void DrawOptions(Game game);
static void UpdateOptions(Game game);

static void EraseDragSquareOutline(Game game);
static void DrawDragSquareOutline(Game game);

static void PrepareDrag(Game game, ZCheckersPiece piece, ZPoint point);
static void SaveDragBackground(Game game);

static void AnimateTimerProc(ZTimer timer, void* userData);
static void AnimateBegin(Game game, ZCheckersMsgFinishMove* msg);

static void ZInitSounds();
static void ZResetSounds();
static void ZStopSounds();
static void ZPlaySound( Game game, int idx, ZBool loop, ZBool once_per_game );

// new addition // Barna 090899
static void IndicatePlayerTurn(Game game, BOOL bDrawInMemory);
static void LoadStringsFromRsc(void);
static void resultBoxTimerFunc(ZTimer timer, void* userData);
static void ZPromptM(TCHAR* prompt,ZWindow parentWindow, UINT buttons, 
				TCHAR* msgBoxTitle, ZPromptResponseFunc responseFunc, void* userData);
static ZBool PromptMMessageFunc(void* pInfo, ZMessage* message);
static int CheckersFormatMessage( LPTSTR pszBuf, int cchBuf, int idMessage, ... );

static ZBool LoadGameFonts();
static ZBool LoadFontFromDataStore(LPCheckersColorFont* ccFont, TCHAR* pszFontName);
static void MAKEAKEY(TCHAR* dest,LPCTSTR key1, LPCTSTR key2, LPCTSTR key3);

static BOOL InitAccessibility(Game game, IGameGame *pIGG);
static void AddResultboxAccessibility();
static void RemoveResultboxAccessibility();

static void SuperRolloverButtonEnable(Game game, ZRolloverButton button);
static void SuperRolloverButtonDisable(Game game, ZRolloverButton button);
static void EnableBoardKbd(bool fEnable);

// utility fns
static void ZoneRectToWinRect(RECT* rectWin, ZRect* rectZ);
static void WinRectToZoneRect(ZRect* rectZ, RECT* rectWin);

/*************************************************************************************************************/
/*************************************************************************************************************/

class CGameGameCheckers : public CGameGameImpl<CGameGameCheckers>,public IGraphicallyAccControl
{
public:
	BEGIN_COM_MAP(CGameGameCheckers)
		COM_INTERFACE_ENTRY(IGameGame)
		COM_INTERFACE_ENTRY(IGraphicallyAccControl)
	END_COM_MAP()
public:
// IGameGame    
	STDMETHOD(SendChat)(TCHAR *szText, DWORD cchChars);
    STDMETHOD(GameOverReady)();
    STDMETHOD(GamePromptResult)(DWORD nButton, DWORD dwCookie);
    STDMETHOD_(HWND, GetWindowHandle)();

//IGraphicallyAccControl
	STDMETHOD_(void, DrawFocus)(RECT *prc, long nIndex, void *pvCookie);
    STDMETHOD_(void, DrawDragOrig)(RECT *prc, long nIndex, void *pvCookie);
    STDMETHOD_(DWORD, Focus)(long nIndex, long nIndexPrev, DWORD rgfContext, void *pvCookie);
    STDMETHOD_(DWORD, Select)(long nIndex, DWORD rgfContext, void *pvCookie);
    STDMETHOD_(DWORD, Activate)(long nIndex, DWORD rgfContext, void *pvCookie);
    STDMETHOD_(DWORD, Drag)(long nIndex, long nIndexOrig, DWORD rgfContext, void *pvCookie);
};

/*************************************************************************************************************/


#endif _CHECKERSCLIENT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\games\hearts\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by hearts.rc
//
#define IDD_DROP                        103
#define IDC_PLAYERA                     1000
#define IDC_PLAYERB                     1001
#define IDC_PLAYERC                     1002
#define IDC_RESPONSE_A                  1003
#define IDC_RESPONSE_B                  1004
#define IDC_RESPONSE_C                  1005
#define IDC_PROMPT                      1006

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1007
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\games\checkers\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by checkers.rc
//
#define IDI_WINDOW                      101
#define IDB_DRAW                        103
#define IDD_DRAW_DLG                    104
#define IDC_TEXT                        1001

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        105
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\games\reversi\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
//
#define IDI_WINDOW                      101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\games\hearts\hearts.cpp ===
/*******************************************************************************

	Hearts.cpp
	
		Hearts client.
		
		Notes:
		1.	The game window's userData field contains the game object.
			Dereference this value to access needed information.
	
	Copyright  Electric Gravity, Inc. 1995. All rights reserved.
	Written by Hoon Im
	Created on Saturday, January 21, 1995 01:39:46 AM
	
	Change History (most recent first):
	----------------------------------------------------------------------------
	Rev	 |	Date	 |	Who	 |	What
	----------------------------------------------------------------------------
	18		06/07/98	leonp   Rewrite how dialogs are dealt with.
	17    	05/06/98	leonp	Added warning about bots and the dossier server
	16		08/06/97	leonp	Leonp - Fix for bug 1045 disable remove button after a player is removed
	15      06/30/97	leonp	Leonp - fix for bug 3561, check options window pointer before 
								attempting to invalidate it.
	14		06/19/97	leonp	Bugfix #293, behavior change, option button disabled 
								when last trick displayed
	13		06/18/97	Leonp	Added ZWindowInvalidate to refresh window after a player
								is removed from the game bug #350
	12		01/15/97	HI		Fixed bug in HandleJoinerKibitzerClick() to
								delete the show player window if one already
								exists before creating another one.
	11		01/08/96	HI		Fixed ShowScores() to show only one scores window.
	10		12/18/96	HI		Cleaned up ZoneClientExit().
	9		12/18/96	HI		Cleaned up HeartsDeleteObjectsFunc().
    8       12/16/96    HI      Changed ZMemCpy() to memcpy().
	7		12/12/96	HI		Dynamically allocate volatible globals for reentrancy.
								Removed MSVCRT dependency.
	6		11/21/96	HI		Use game information from gameInfo in
								ZoneGameDllInit().
	5		11/21/96	HI		Now references color and fonts through
								ZGetStockObject().
								Modified code to use ZONECLI_DLL.
	4		11/15/96	HI		Removed authentication stuff from ZClientMain().
	3		10/31/96	HI		Kibitzers/joiners are no longer prompted when
								another players requests to remove a player.
								Increased zGameScoreTimeout to 30 seconds and
								set the timeout equally for all user: players
								and kibitzers.
	2		10/23/96	HI		Modified ZClientMain() for the new commandline
								format.
	1		10/11/96	HI		Added controlHandle parameter to ZClientMain().
	0		01/21/95	HI		Created.
	 
*******************************************************************************/

#pragma warning (disable:4761)

#define MILL_VER

#include <windows.h>

#include "zone.h"
#include "zroom.h"
#include "zonecli.h"
#include "zonecrt.h"
#include "hearts.h"
#include "zcards.h"
#include "zonehelpids.h"
#include "zui.h"
#include "resource.h"
#include "heartsres.h"
#include "commonres.h"
#include "zoneint.h"
#include "zres.h"
#include "zgame.h"
#include "zrollover.h"
#include "ZoneResource.h"
#include "UAPI.h"
#include "GraphicalAcc.h"
#include <commctrl.h>


#define I(object)					((Game) (object))
#define Z(object)					((ZCGame) (object))

#define zGameVersion				0x00010500

#define zGameNameLen				63

#define zHearts						_T("Hearts")
#define zFontId						_T("Font")
#define zFontRscTyp					_T("Fonts")
#define zColorId					_T("Color")
#define zHistoryDialog              _T("HistoryDialog")
#define zHistoryDialogHandWidth     _T("HandsColumnWidth")
#define zHistoryDialogPlayerWidth   _T("PlayerColumnWidth")

#define RATING_ERROR			_T("A robot player has been detected.  This game will be unrated.  To play a rated game please start a new game with four humans.")
#define RATING_ENABLED			_T("Four human players have been detected.  This game will be rated.")
#define RATING_DISABLED			_T("%s has left the game before it officially started.  This game will not be rated.")
#define RATING_MULTIPLE			_T("More than one player has left the game.  This game will not be rated.")
#define RATING_TITLE			_T("Zone Rating System - Message")
#define RATING_CONT_UNRATED		_T("You have voted to continue playing in an unrated game.")
#define RATING_WAIT				_T("You have voted to wait for the disconnected player.")

#define RATING_WAIT_MSG _T("Wait")
#define RATING_DONT_MSG _T("Don't Wait")

#define FORFEIT_DISP_SCORE 1001
#define TIMEOUT_DISP_SCORE 1002

// we send this to the score history dialog to have it update its scores/names
#define WM_UPDATESCORES             (WM_USER+4321)
#define WM_UPDATENAMES              (WM_USER+4322)

/* This version of Hearts supports only 4 players on a table. */
#define zNumPlayersPerTable			4

#define zNoCard						zCardNone

#define zGameImageFileName			_T("hrtzres.dll")

#define zCardWidth					zCardsSizeWidth
#define zCardHeight					zCardsSizeHeight
#define zCardOffset					16
#define zCardPopup					8

#define zShowTimeout				50
#define zHideTimeout				25
#define zHandScoreTimeout			2000						/* in 1/100 seconds */
#define zShowTrickWinnerTimeout		50
#define zTrickWinnerTimeout			5
#define zEndTrickWinnerTimeout		50
#define zGameScoreTimeout			2000
#define zKibitzerTimeout			100

#define zNumAnimFrames				8
#define zNumAnimGhostFrames			3

#define zCardOutlinePenWidth		3
#define zCardOutlineInset			-4
#define zCardOutlineRadius			4

/* The user's local seat location is 0. */
#define LocalSeat(game, n)			(((n) - (game)->seat + zNumPlayersPerTable) % zNumPlayersPerTable)

/* Given ZCard, return card image index. */
#define CardImageIndex(card)		(gCardSuitConversion[ZSuit(card)] * 13 + ZRank(card))

#define zNewGamePromptStr			_T("Would you like to play another game?")

#define zBeepOnTurnStr				_T("Beep on my turn")
#define zAnimateCardsStr			_T("Animate cards")
#define zKibitzingStr				_T("Kibitz")
#define zJoiningStr					_T("Join")
#define zRemoveStr					_T("Remove")
#define zSilentStr					_T("Silent")
#define zIgnoreStr					_T("Ignore")
#define zHideCardsStr				_T("Hide cards from kibitzer")
#define zRemovePendingStr			_T("Your last request to remove a player is still pending.")

#define zMaxNumBlockedMessages		4

#define zPopupWindowWidth			120
#define zPopupWindowLineHeight		12

#define zClientReadyInfoStr			_T("Synchronizing all players...")
#define zKibitzerInfoStr			_T("Requesting current game state...")
#define zQuitGamePromptStr			_T("Are you sure you want to leave this game?")
#define zCheckInInfoStr				_T("Registering with the server...")
#define zJoiningLockedOutStr		_T("Game joining has been turned off. You are not able to join the game.")
#define zKibitzersSilencedStr		_T("Kibitzers are not allowed to talk on this table.")
#define zRemovePlayerRequestRatedStr _T("%s proposes to remove %s from the table. Everyone at the table will receive an incomplete.  Do you accept?")
#define zRemovePlayerRequestStr		_T("%s proposes to remove %s from the table. Do you accept?")
#define zRemovePlayerAcceptStr		_T("%s ACCEPTS %s's proposal to remove %s from the table.")
#define zRemovePlayerRejectStr		_T("%s REJECTS %s's proposal to remove %s from the table.")

#define zScoreTableRowHeight		14

#define zShowPlayerWindowWidth		120
#define zShowPlayerLineHeight		12

#define zCloseRegularStr			_T("This game is currently not rated.  You may leave without penalty.")
#define zCloseForfeitStr            _T("Are you sure you want to forfeit this game and be in last place?")
#define zCloseTimeoutStr            _T("Are you sure you want to leave this game?  The game will be scored as it stands, except that %s will place last.")
#define zCloseWaitingStr			_T("Are you sure you want to leave this game?  Your rating will not be affected.")

#define zCloseUnknownStr            _T("Are you sure you want to leave this game?  You may receive a loss or an incomplete.")  // should never be used

#define zCloseRegularToForfeitStr   _T("The game has begun.  If you choose to leave now, you will forfeit the game and be in last place.")
#define zCloseRegularToTimeoutStr   _T("%s has not moved in several minutes.  If you choose to leave now, the game will be scored as it stands, except that %s will place last.")
#define zCloseRegularToWaitingStr   _T("A player left the game.  You may leave the game and your rating will not be affected.")
#define zCloseForfeitToRegularStr   _T("The game has ended.  You may now leave without penalty.")
#define zCloseForfeitToTimeoutStr   zCloseRegularToTimeoutStr
#define zCloseForfeitToWaitingStr   zCloseRegularToWaitingStr
#define zCloseTimeoutToRegularStr   _T("The stalling player made a move, and the game has ended.  You may leave without penalty if you choose.")
#define zCloseTimeoutToForfeitStr   _T("The stalling player made a move.  If you choose to leave now, you will forfeit the game and be in last place.")
#define zCloseTimeoutToWaitingStr   zCloseRegularToWaitingStr
#define zCloseWaitingToRegularStr   _T("The disconnected player has returned, and the game has ended.  You may leave without penalty if you choose.")
#define zCloseWaitingToForfeitStr   _T("The disconnected player has returned.  If you choose to leave now, you will forfeit the game and be in last place.")
#define zCloseWaitingToTimeoutStr   _T("The player returned, and %s has not moved in several minutes.  If you leave now, the game will be scored as it stands, except that %s will place last.")

#define zCloseXToUnratedStr         _T("This game has become unrated.  You may leave without penalty if you choose.")
#define zUnknownUserStr             _T("an unknown user")

#define zPlayerTimedOutStr			_T("%s hasn't played in several minutes.  You may end the match by closing the game window\n") \
									_T("now.  The game will be scored as it stands, except that %s will place last.")
#define zLostConnStr				_T("Your Hearts game lost its connection to the Zone.")
#define zIncompleteSufStr			_T("  You will most likely receive\nan incomplete, unless your opponents choose to wait for you to return.")

#define zDisconnectingInfoStr       _T("Exiting game...")
#define zDisconnectingInfoWidth     200

// JRB: Adding global string buffers for resource dll defined strings
#define ZLARGESTRING	256


#define zAnimationNumTimesToRun     5

static TCHAR *g_aszClosePrompts[][3] =
{
	{ zCloseUnknownStr, _T("Leave"), _T("Cancel") },
	{ zCloseRegularStr, _T("Leave"), _T("Cancel") },
	{ zCloseForfeitStr, _T("Forfeit"), _T("Cancel") },
	{ zCloseTimeoutStr, _T("Leave"), _T("Cancel") },
	{ zCloseWaitingStr, _T("Leave"), _T("Cancel") }
};

static TCHAR *g_aszCloseDeniedPrompts[][5] =
{
	{ zCloseUnknownStr,    zCloseUnknownStr,          zCloseUnknownStr,          zCloseUnknownStr,          zCloseUnknownStr },
	{ zCloseXToUnratedStr, zCloseUnknownStr,          zCloseRegularToForfeitStr, zCloseRegularToTimeoutStr, zCloseRegularToWaitingStr },
	{ zCloseXToUnratedStr, zCloseForfeitToRegularStr, zCloseUnknownStr,          zCloseForfeitToTimeoutStr, zCloseForfeitToWaitingStr },
    { zCloseXToUnratedStr, zCloseTimeoutToRegularStr, zCloseTimeoutToForfeitStr, zCloseUnknownStr,          zCloseTimeoutToWaitingStr },
    { zCloseXToUnratedStr, zCloseWaitingToRegularStr, zCloseWaitingToForfeitStr, zCloseWaitingToTimeoutStr, zCloseUnknownStr }
};


/* -------- Image Indices -------- */
enum
{
	zImagePassLeft = 0,
	zImagePassRight,
	zImagePassAcross,
	zImageCardBack,
	zImageHandScoreBack,
	zImageGameScoreBack,
	zImageSmallHeart,
	zImageSmallPassLeft,
	zImageSmallPassRight,
	zImageSmallPassAcross,
	zImageSmallPassHold,

	zNumGameImages
};


/* -------- Accelerators -------- */
enum
{
	zAccScore = 0,
	zAccAutoPlay = 1,
	zAccStop = 2,
    zAccHand = 3,

	zAccPlay = 16,
	zAccLastTrick = 17,
	zAccDone = 18,
	zNumberAccItems
};


enum
{
    zAccRectButton = 0,
    zAccRectCard,
    zAccRectClose
};


/* -------- Game States -------- */
enum
{
	zGameStateNotInited = 0,
	zGameStateInited,
	zGameStateWaitForNewHand,
	zGameStatePassCards,
	zGameStateWaitForPlay,
	zGameStateHandOver,
	zGameStateGameOver
};

/* -------- Timer Indicators -------- */
enum
{
	zGameTimerNone = 0,
	zGameTimerShowPlayer,
	zGameTimerShowHandScore,
	zGameTimerShowTrickWinner,
	zGameTimerAnimateTrickWinner,
	zGameTimerEndTrickWinnerAnimation,
	zGameTimerShowGameScore
};

/* -------- Valid Card Errors -------- */
enum
{
	zNoCardError = 0,
	zMustLead2COnFirstTrick,
	zCantLeadHearts,
	zMustFollowSuit,
	zCantPlayPointsInFirstTrick,
	zPleaseSelect3Cards,
	zPleaseSelect1Card,
	zNumValidCardErrors
};

/*---------- General Errors ------------ */
enum
{
	zErrorCreatingWindow = 0,
	zErrorFailedToInit,
	zErrorInvalidCardIndex,
	zErrorDontHave2C,
	zErrorDontHaveCard,
	zNumErrors
};

/* -------- Rectangle Indices -------- */
enum
{
	/* -------- Game Window Rectangles -------- */
	zRectWindow = 0,
	zRectHand,
	zRectTable,
	zRectSouthCard,
	zRectWestCard,
	zRectNorthCard,
	zRectEastCard,
	zRectPassDirection,
	zRectPassText,
    zRectPassText2,
	zRectPlayButton,
	zRectAutoPlayButton,
	zRectLastTrickButton,
	zRectScoreButton,
	zRectSouthName,
	zRectWestName,
	zRectNorthName,
	zRectEastName,
	zRectSouthPoints,
	zRectWestPoints,
	zRectNorthPoints,
	zRectEastPoints,
	zRectSouthTricks,
	zRectWestTricks,
	zRectNorthTricks,
	zRectEastTricks,
	zRectSouthJoiner,
	zRectWestJoiner,
	zRectNorthJoiner,
	zRectEastJoiner,
	zRectSouthKibitzer,
	zRectWestKibitzer,
	zRectNorthKibitzer,
	zRectEastKibitzer,
	zRectOptionJoiner,
	zRectOptionKibitzer,
	zRectPassIndicator,
	zRectHelp,
	//zRectScoreButton,
	
	/* -------- Options Window Rectangles -------- */
	zRectOptions = 0,
	zRectOptionsOkButton,
	zRectOptionsJoiningText,
	zRectOptionsKibitzingText,
	zRectOptionsSilent1Text,
	zRectOptionsSilent2Text,
	zRectOptionsPlayer1Name,
	zRectOptionsPlayer2Name,
	zRectOptionsPlayer3Name,
	zRectOptionsPlayer4Name,
	zRectOptionsJoining1,
	zRectOptionsJoining2,
	zRectOptionsJoining3,
	zRectOptionsJoining4,
	zRectOptionsKibitzing1,
	zRectOptionsKibitzing2,
	zRectOptionsKibitzing3,
	zRectOptionsKibitzing4,
	zRectOptionsSilent1,
	zRectOptionsSilent2,
	zRectOptionsSilent3,
	zRectOptionsSilent4,
	zRectOptionsBeep,
	zRectOptionsAnimation,
	zRectOptionsHideCards,
	zRectOptionsRemove1,
	zRectOptionsRemove2,
	zRectOptionsRemove3,
	zRectOptionsRemove4,
	zRectOptionsIgnoreText,
	zRectOptionsIgnore1,
	zRectOptionsIgnore2,
	zRectOptionsIgnore3,
	zRectOptionsIgnore4,
	
	/* -------- Score Window Rectangles -------- */
	zRectScore = 0,
	zRectScoreOkButton,
	zRectScorePlayer1Name,
	zRectScorePlayer2Name,
	zRectScorePlayer3Name,
	zRectScorePlayer4Name,
	zRectScoreBox,
	zRectScoreTotal1,
	zRectScoreTotal2,
	zRectScoreTotal3,
	zRectScoreTotal4
};

// ---- score history image list icons indices
enum 
{
    zImageListIconHeart,
    zImageListIconBlank,
    zNumImageListIcons
};
static const int IMAGELIST_ICONS[zNumImageListIcons] =
{
    IDI_HEART,
    IDI_BLANK
};  



/////////////////////////////////////
//
// Main Game Object

class CGameGameHearts : public CGameGameImpl<CGameGameHearts>, public IGraphicallyAccControl
{
public:
	BEGIN_COM_MAP(CGameGameHearts)
		COM_INTERFACE_ENTRY(IGameGame)
		COM_INTERFACE_ENTRY(IGraphicallyAccControl)
	END_COM_MAP()


// IGameGame interface
public:
    STDMETHOD(SendChat)(TCHAR *szText, DWORD cchChars);
	STDMETHOD(GameOverReady)();
    STDMETHOD_(HWND, GetWindowHandle)();
    STDMETHOD(ShowScore)();

// IGraphicallyAccControl interface
public:
	STDMETHOD_(DWORD, Focus)(long nIndex, long nIndexPrev, DWORD rgfContext, void *pvCookie);
	STDMETHOD_(DWORD, Select)(long nIndex, DWORD rgfContext, void *pvCookie);
	STDMETHOD_(DWORD, Activate)(long nIndex, DWORD rgfContext, void *pvCookie);
	STDMETHOD_(DWORD, Drag)(long nIndex, long nIndexOrig, DWORD rgfContext, void *pvCookie);
	STDMETHOD_(void, DrawFocus)(RECT *prc, long nIndex, void *pvCookie);
	STDMETHOD_(void, DrawDragOrig)(RECT *prc, long nIndex, void *pvCookie);

};



/* -------- Player Info -------- */
typedef struct
{
	ZUserID			userID;
	int16			score;
	int16			unused;
	TCHAR			name[zUserNameLen + 1];
	TCHAR			host[zHostNameLen + 1];
} TPlayerInfo, *TPlayerInfoPtr;

/* -------- Game Info -------- */
typedef struct
{
	ZUserID			userID;
	int16			tableID;
	int16			seat;
	ZWindow			gameWindow;
	ZRolloverButton	playButton;
	ZRolloverButton	autoPlayButton;
	ZRolloverButton	lastTrickButton;
#ifndef MILL_VER
	ZButton			optionsButton;
#endif
	ZRolloverButton	scoreButton;

    ZOffscreenPort  gameBackBuffer;
    // we will ALWAYS draw to this, which could either
    // be the window or the back buffer.
    ZGrafPort       gameDrawPort;

	ZTimer			timer;
	int16			timerType;
	ZBool			showPlayerToPlay;
	ZBool			autoPlay;
	int16			playerType;
	ZBool			ignoreMessages;
	TPlayerInfo		players[zNumPlayersPerTable];
	ZUserID			playersToJoin[zNumPlayersPerTable];
	int16			numKibitzers[zNumPlayersPerTable];
	ZLList			kibitzers[zNumPlayersPerTable];
	uint32			tableOptions[zNumPlayersPerTable];
	ZRect			cardRects[zHeartsMaxNumCardsInHand];
	int16			lastClickedCard;
#ifndef MILL_VER
	ZHelpButton		helpButton;
#endif
	ZBool			playButtonWasEnabled;
	ZBool			autoPlayButtonWasEnabled;
	ZBool			lastTrickButtonWasEnabled;
	ZBool			lastTrickShowing;
	int16			oldTimerType;
	int32			oldTimeout;
	ZInfo			gameInfo;
	int16			quitGamePrompted;
	ZBool			beepOnTurn;
	ZBool			animateCards;
	ZBool			removePlayerPending;
	ZBool			hideCardsFromKibitzer;
	ZBool			kibitzersSilencedWarned;
	ZBool			kibitzersSilenced;

	ZBool			fIgnore[zNumPlayersPerTable];
	
	/* Current Game State Info */
	int16			gameState;
	int16			playerToPlay;
	int16			passDirection;
	int16			numCardsInHand;
	ZBool			newGameVote[zNumPlayersPerTable];
	ZBool			passed[zNumPlayersPerTable];
	ZCard			cardsPlayed[zNumPlayersPerTable];
	ZCard			cardsInHand[zHeartsMaxNumCardsInHand];
	ZBool			cardsSelected[zHeartsMaxNumCardsInHand];
	ZCard			cardsReceived[zHeartsMaxNumCardsInPass];
	ZBool			pointsBroken;
	int16			leadPlayer;
	ZCard			cardsLastTrick[zNumPlayersPerTable];
    int16           numTricksTaken[zNumPlayersPerTable];
    int16           numScores;
    int16*          scoreHistory;
	int16			numHandsPlayed;

	ZBool fRatings;
	int16 nCloseStatus;
	int16 nCloseRequested;
	int16 nCloserSeat;

	ZBool fNeedNewGameConf;

	/* Game Options */
	uint32			gameOptions;
	int16			numCardsToPass;
	int16			numCardsDealt;
	int16			numPointsForGame;
	
	/* Hand Score Fields */
	ZWindow			handScoreWindow;
	int16			handScoreOrder[zNumPlayersPerTable];
	int16			handScores[zNumPlayersPerTable];
	
	/* Game Score Fields */
	ZWindow			gameScoreWindow;
	int16			gameScoreOrder[zNumPlayersPerTable];
	int16			gameScores[zNumPlayersPerTable];

	/* Trick Winner Animation */
	ZRect			ghostFrames[zNumPlayersPerTable - 1][zNumAnimGhostFrames];
	ZRect			winnerRect;
	ZRect			loserRects[zNumPlayersPerTable - 1];
	int16			loserSeats[zNumPlayersPerTable - 1];
	int16			trickWinner;
	int16			trickWinnerFrame;
	ZBool			animatingTrickWinner;

#ifdef HEARTS_ANIMATION
	/* Run Animation */
	ZWindow			runAnimationWindow;
	ZAnimation		runAnimation;
	ZBool			deleteRunAnimation;
#endif

	ZBool			fEndGameBlocked;   // are messages being blocked because end game window is up?
	ZInfo			infoDisconnecting;

	/* Options Window Items */
	ZWindow			optionsWindow;
	ZButton			optionsWindowButton;
	ZCheckBox		optionsKibitzing[zNumPlayersPerTable];
	ZCheckBox		optionsJoining[zNumPlayersPerTable];
	ZCheckBox		optionsSilent[zNumPlayersPerTable];
	ZButton			optionsRemove[zNumPlayersPerTable];
	ZCheckBox		optionsIgnore[zNumPlayersPerTable];
	ZCheckBox		optionsBeep;
	ZCheckBox		optionsAnimateCards;
	ZCheckBox		optionsHideCards;
	
	/* Score Window Items */
	HWND            hWndScoreWindow;
	
	/* Show Player Items */
	ZWindow			showPlayerWindow;
	TCHAR**			showPlayerList;
	int16			showPlayerCount;

	/*Dossier information*/
	ZBool			fVotingLock;    //set to true diring voting to prevent playing
	int16 			rgDossierVote[zNumPlayersPerTable]; 
	HWND            voteDialog;
	int16 			voteMap[zNumPlayersPerTable];
	
    RECT            rcFocus;
    DWORD           eFocusType;
    long            iFocus;

    bool fSetFocusToHandASAP;

    HIMAGELIST m_hImageList;
} GameType, *Game;


typedef struct
{
	Game			game;
	int16			requestSeat;
	int16			targetSeat;
} RemovePlayerType, *RemovePlayer;


// JRB:
// store fonts structures and enums
enum
{
	zFontNormal = 0,
	zFontButtons,
	zFontPlayers,
	zFontScores,
	zFontPass,
	zFontScoreTitle,
	zFontScoreText,
	zFontGameOverTitle,
	zFontGameOverText,
	zFontScoreHistLabel,
	zFontScoreHistText,
	zNumFonts
};


static TCHAR *g_aszFontLabel[zNumFonts] =
{
	_T("Normal"),
	_T("Buttons"),
	_T("Players"),
	_T("Scores"),
	_T("Pass"),
	_T("ScoreTitle"),
	_T("ScoreText"),
	_T("GameOverTitle"),
	_T("GameOverText"),
	_T("ScoreHistLabel"),
	_T("ScoreHistText"),
};

static TCHAR* g_szRolloverText = _T("RolloverText");

// Dynamic Font loading from UI.TXT
typedef struct
{
	HFONT			m_hFont;
	ZONEFONT		m_zFont;
    COLORREF		m_zColor;
} LPHeartsColorFont, *HeartsColorFont;


/* -------- Globals -------- */
#ifndef ZONECLI_DLL

static TCHAR			gGameDir[zGameNameLen + 1];
static TCHAR			gGameName[zGameNameLen + 1];
static TCHAR			gGameDataFile[zGameNameLen + 1];
static TCHAR			gGameServerName[zGameNameLen + 1];
static uint32			gGameServerPort;
static ZImage			gGameImages[zNumGameImages];
static ZOffscreenPort	gHandBuffer;
static ZHelpWindow		gHelpWindow;
static ZImage			gBackground;
static ZPoint			gTrickWinnerPos[zNumPlayersPerTable][zNumPlayersPerTable][zNumAnimFrames];
static ZRect			gTrickWinnerBounds;
static ZOffscreenPort	gOffscreenGameBoard;

#endif




static ZRect			gRects[] =	{
										{0, 0, 618, 362},		// window client rect
										{187, 264, 433, 344},	// hand rect
										{214, 60, 404, 222},	// center card animation rect
										{282, 145, 336, 217},	// south card
										{221, 107, 275, 179},	// west card
										{282, 67, 336, 139},	// north card
										{343, 107, 397, 179},	// east card
										{224, 76, 396, 164},	// Pass indicator
										{224, 113, 396, 133},	// Pass text
										{224, 134, 396, 154},	// Pass text line 2
										{446, 260, 568, 287},	// Play button
										{51, 295, 173, 322},	// Auto play button
										{446, 295, 568, 322},	// Last trick button
										{51, 260, 173, 287},	// score button
										{222, 222, 397, 241},	// south name
										{39, 122, 214, 141},	// west name
										{222, 22, 397, 41},		// north name
										{404, 122, 579, 141},	// east name
										{222, 241, 397, 260},	// south points
										{39, 141, 214, 160},	// west points
										{222, 41, 397, 60},		// north points
										{404, 141, 579, 160},	// east points
										{302, 216, 329, 234},
										{101, 138, 128, 156},
										{151, 14, 178, 32},
										{352, 138, 379, 156},
										{128, 216, 152, 240},
										{8, 138, 32, 162},
										{302, 8, 326, 32},
										{422, 138, 446, 162},
										{154, 216, 178, 240},
										{34, 138, 58, 162},
										{328, 8, 352, 32},
										{448, 138, 472, 162},
										{426, 30, 450, 54},
										{452, 30, 476, 54},
										{53, 35, 73, 55},			// small pass indicator
										{452, 4, 476, 28},
									};
static int16			gNameRectIndex[] =	{
												zRectSouthName,
												zRectWestName,
												zRectNorthName,
												zRectEastName
											};
static int16			gPointsRectIndex[] =	{
												zRectSouthPoints,
												zRectWestPoints,
												zRectNorthPoints,
												zRectEastPoints
											};
static int16			gCardRectIndex[] =	{
												zRectSouthCard,
												zRectWestCard,
												zRectNorthCard,
												zRectEastCard
											};
static int16			gTricksRectIndex[] =	{
													zRectSouthTricks,
													zRectWestTricks,
													zRectNorthTricks,
													zRectEastTricks
												};
static int16			gJoinerKibitzerRectIndex[][2] =	{
															{zRectSouthKibitzer, zRectSouthJoiner},
															{zRectWestJoiner, zRectWestKibitzer},
															{zRectNorthJoiner, zRectNorthKibitzer},
															{zRectEastKibitzer, zRectEastJoiner}
														};
static int16			gOptionsRectIndex[] =	{
													zRectOptionKibitzer,
													zRectOptionJoiner
												};
static ZCard			gCardSuitConversion[4] =	{
														zCardsSuitClubs,
														zCardsSuitDiamonds,
														zCardsSuitSpades,
														zCardsSuitHearts
													};
static int16			gPassDirImageIndex[4] =	{
													-1,		/* Hold */
													zImagePassLeft,		/* Left */
													zImagePassAcross,	/* Across */
													zImagePassRight		/* Right */
												};
static ZRect			gHandScoreWindowRect =	{0, 0, 284, 144};
static ZRect			gHandScorePtsRect =		{224, 37, 267, 52};
static ZRect			gHandScoreTitleRect =	{18, 19, 207, 44};
static ZRect			gHandScoreNames[] =	{
												{75, 61, 207, 76},
												{75, 77, 207, 92},
												{75, 93, 207, 108},
												{75, 109, 207, 124}
											};
static ZRect			gHandScoreScores[] =	{
												{224, 61, 267, 76},
												{224, 77, 267, 92},
												{224, 93, 267, 108},
												{224, 109, 267, 124}
											};
static ZRect            gHandScoreCloseBox =    { 269, 3, 280, 15 };

static ZRect			gHandScorePtsRectRTL =		{283-267, 37, 283-224, 52};
static ZRect			gHandScoreTitleRectRTL =	{283-207, 19, 283-18, 44};
static ZRect			gHandScoreNamesRTL[] =	{
												{283-207, 61, 283-75, 76},
												{283-207, 77, 283-75, 92},
												{283-207, 93, 283-75, 108},
												{283-207, 109, 283-75, 124}
											};
static ZRect			gHandScoreScoresRTL[] =	{
												{283-267, 61, 283-224, 76},
												{283-267, 77, 283-224, 92},
												{283-267, 93, 283-224, 108},
												{283-267, 109, 283-224, 124}
											};
static ZRect            gHandScoreCloseBoxRTL =    { 4, 3, 15, 15 };

#ifdef HEARTS_ANIMATION
static ZRect			gRunAnimationWindowRect = {0, 0, 386, 340};
#endif

static ZRect			gGameScoreWindowRect =	{0, 0, 317, 160};
static ZRect			gGameScoreTitleRect =	{14, 24, 219, 50};
static ZRect			gGameScorePtsRect =		{257, 50, 300, 65};
static ZRect			gGameScoreNames[] =	{
												{88, 74, 220, 89},
												{88, 90, 220, 105},
												{88, 106, 220, 121},
												{88, 122, 220, 137}
											};
static ZRect			gGameScoreScores[] =	{
												{257, 74, 300, 89},
												{257, 90, 300, 105},
												{257, 106, 300, 121},
												{257, 122, 300, 137}
											};
static ZRect			gGameScoreWinners[] =	{
													{60, 72, 80, 92},
													{60, 88, 80, 108},
													{60, 104, 80, 124},
													{60, 120, 80, 120}
												};
static ZRect            gGameScoreCloseBox =    { 302, 4, 313, 16 };

static ZRect			gGameScoreTitleRectRTL =	{316-219, 24, 316-14, 50};
static ZRect			gGameScorePtsRectRTL =		{316-300, 50, 316-257, 65};
static ZRect			gGameScoreNamesRTL[] =	{
												{315-220, 74, 315-88, 89},
												{315-220, 90, 315-88, 105},
												{315-220, 106, 315-88, 121},
												{315-220, 122, 315-88, 137}
											};
static ZRect			gGameScoreScoresRTL[] =	{
												{315-300, 74, 315-257, 89},
												{315-300, 90, 315-257, 105},
												{315-300, 106, 315-257, 121},
												{315-300, 122, 315-257, 137}
											};
static ZRect			gGameScoreWinnersRTL[] =	{
													{315-80, 72, 315-60, 92},
													{315-80, 88, 315-60, 108},
													{315-80, 104, 315-60, 124},
													{315-80, 120, 315-60, 120}
												};
static ZRect            gGameScoreCloseBoxRTL =    { 4, 4, 15, 16 };
static ZRect			gGameNewGameWindowRect = {0, 0, 240, 100};

#ifndef MILL_VER
static int16			gNewGameVoteImageIndex[] = {zImageGoRight, zImageGoLeft, zImageGoLeft, zImageGoRight};
#endif

static int16			gSmallPassDirImageIndex[4] =	{
															zImageSmallPassHold,		/* Hold */
															zImageSmallPassLeft,		/* Left */
															zImageSmallPassAcross,		/* Across */
															zImageSmallPassRight		/* Right */
														};

static ZRect			gHelpWindowRect = {0, 0, 400, 300};
static ZRect			gPlayerReplacedRect = {0, 0, 280, 100};
static ZRect			gQuitGamePromptRect = {0, 0, 350, 110};
static ZRect			gOptionsRects[] =	{
												{0, 0, 466, 219},
												{203, 189, 263, 209},
												{159, 16, 209, 32},
												{211, 16, 261, 32},
												{263, 0, 313, 16},
												{263, 16, 313, 32},
												{20, 35, 140, 51},
												{20, 53, 140, 69},
												{20, 71, 140, 87},
												{20, 89, 140, 105},
												{176, 34, 192, 52},
												{176, 52, 192, 70},
												{176, 70, 192, 88},
												{176, 88, 192, 106},
												{228, 34, 244, 52},
												{228, 52, 244, 70},
												{228, 70, 244, 88},
												{228, 88, 244, 106},
												{280, 34, 296, 52},
												{280, 52, 296, 70},
												{280, 70, 296, 88},
												{280, 88, 296, 106},
												{20, 115, 220, 133},
												{20, 133, 220, 151},
												{20, 151, 220, 169},
												{332, 35, 392, 51},
												{332, 53, 392, 69},
												{332, 71, 392, 87},
												{332, 89, 392, 105},
												{411, 16, 461, 32},
												{428, 34, 444, 52},
												{428, 52, 444, 70},
												{428, 70, 444, 88},
												{428, 88, 444, 106}
											};
static int16			gOptionsNameRects[] =	{
													zRectOptionsPlayer1Name,
													zRectOptionsPlayer2Name,
													zRectOptionsPlayer3Name,
													zRectOptionsPlayer4Name
												};
static int16			gOptionsKibitzingRectIndex[] =	{
															zRectOptionsKibitzing1,
															zRectOptionsKibitzing2,
															zRectOptionsKibitzing3,
															zRectOptionsKibitzing4
														};
static int16			gOptionsJoiningRectIndex[] =	{
															zRectOptionsJoining1,
															zRectOptionsJoining2,
															zRectOptionsJoining3,
															zRectOptionsJoining4
														};
static int16			gOptionsSilentRectIndex[] =	{
														zRectOptionsSilent1,
														zRectOptionsSilent2,
														zRectOptionsSilent3,
														zRectOptionsSilent4
													};
static int16			gOptionsRemoveRectIndex[] =	{
														zRectOptionsRemove1,
														zRectOptionsRemove2,
														zRectOptionsRemove3,
														zRectOptionsRemove4
													};
static int16			gOptionsIgnoreRectIndex[] =	{
														zRectOptionsIgnore1,
														zRectOptionsIgnore2,
														zRectOptionsIgnore3,
														zRectOptionsIgnore4
													};
/*
static ZRect			gScoreWindowRects[] =	{
													{0, 0, 460, 222},
													{380, 182, 440, 206},
													{20, 26, 120, 42},
													{120, 26, 220, 42},
													{220, 26, 320, 42},
													{320, 26, 420, 42},
													{20, 42, 440, 162},
													{20, 162, 120, 178},
													{120, 162, 220, 178},
													{220, 162, 320, 178},
													{320, 162, 420, 178}
												};

static int16			gScoreWindowNameRects[] =	{
														zRectScorePlayer1Name,
														zRectScorePlayer2Name,
														zRectScorePlayer3Name,
														zRectScorePlayer4Name
													};
static int16			gScoreWindowTotalRects[] =	{
														zRectScoreTotal1,
														zRectScoreTotal2,
														zRectScoreTotal3,
														zRectScoreTotal4
													};
*/
static ZRect			gJoiningLockedOutRect = {0, 0, 260, 120};
static ZRect			gRemovePlayerRect = {0, 0, 280, 120};


enum 
{
	zScoreHistory = 0,
	zLastTrick,
	zPlay,
	zAutoPlay,
	zPass,
	zClose,
	zDone,
	zStop,
	zScore,
	zPassLeft,
	zPassRight,
	zPassAcross,
	zPoints,
	zScores,
	zGameOver,
	zPointsX,
    zYou,
    zPassSelect,
    zPassWait,
    zPassWait2,
	zNumStrings
};


#ifdef ZONECLI_DLL

/* -------- Volatible Globals & Macros -------- */
typedef struct
{
	TCHAR			m_gGameDir[zGameNameLen + 1];
	TCHAR			m_gGameName[zGameNameLen + 1];
	TCHAR			m_gGameDataFile[zGameNameLen + 1];
	TCHAR			m_gGameServerName[zGameNameLen + 1];
	uint32			m_gGameServerPort;
	ZImage			m_gGameImages[zNumGameImages];
	ZOffscreenPort	m_gHandBuffer;
	ZImage			m_gBackground;
	ZPoint			m_gTrickWinnerPos[zNumPlayersPerTable][zNumPlayersPerTable][zNumAnimFrames];
	ZRect			m_gTrickWinnerBounds;
	HINSTANCE		m_ghInst;

	ZImage			m_gButtonIdle;
	ZImage			m_gButtonHighlighted;
	ZImage			m_gButtonSelected;
	ZImage			m_gButtonDisabled;

	IZoneMultiStateFont*	m_gpButtonFont;

	TCHAR			m_gstrGameName[ZLARGESTRING];

	TCHAR			m_gstrPlayer1[ZLARGESTRING];
	TCHAR			m_gstrPlayer2[ZLARGESTRING];
	TCHAR			m_gstrPlayer3[ZLARGESTRING];
	TCHAR			m_gstrPlayer4[ZLARGESTRING];

	TCHAR			m_gszString[zNumStrings][ZLARGESTRING];
	TCHAR			m_gValidCardErrStr[zNumValidCardErrors][ZLARGESTRING];

	// font array
	LPHeartsColorFont m_gHeartsFont[zNumFonts];

	// accessibility interface
	CComPtr<IGraphicalAccessibility>	m_gGAcc;

    HBITMAP         m_gFocusPattern;
    HBRUSH          m_gFocusBrush;
    HPEN            m_gFocusPen;
} GameGlobalsType, *GameGlobals;

#define gGameDir				(pGameGlobals->m_gGameDir)
#define gGameName				(pGameGlobals->m_gGameName)
#define gGameDataFile			(pGameGlobals->m_gGameDataFile)
#define gGameServerName			(pGameGlobals->m_gGameServerName)
#define gGameServerPort			(pGameGlobals->m_gGameServerPort)
#define gGameImages				(pGameGlobals->m_gGameImages)
#define gHelpWindow				(pGameGlobals->m_gHelpWindow)
#define gHandBuffer				(pGameGlobals->m_gHandBuffer)
#define gBackground				(pGameGlobals->m_gBackground)
#define gTrickWinnerPos			(pGameGlobals->m_gTrickWinnerPos)
#define gTrickWinnerBounds		(pGameGlobals->m_gTrickWinnerBounds)
#define ghInst					(pGameGlobals->m_ghInst)

#define gButtonIdle				(pGameGlobals->m_gButtonIdle)
#define gButtonSelected			(pGameGlobals->m_gButtonSelected)
#define gButtonHighlighted		(pGameGlobals->m_gButtonHighlighted)
#define gButtonDisabled         (pGameGlobals->m_gButtonDisabled)

#define gpButtonFont			(pGameGlobals->m_gpButtonFont)

#define gstrGameName			(pGameGlobals->m_gstrGameName)

#define gstrPlayer1				(pGameGlobals->m_gstrPlayer1)
#define gstrPlayer2				(pGameGlobals->m_gstrPlayer2)
#define gstrPlayer3				(pGameGlobals->m_gstrPlayer3)
#define gstrPlayer4				(pGameGlobals->m_gstrPlayer4)

#define gszString				(pGameGlobals->m_gszString)

#define	gValidCardErrStr		(pGameGlobals->m_gValidCardErrStr)

	// font array
#define	gHeartsFont				(pGameGlobals->m_gHeartsFont)

#define gGAcc					(pGameGlobals->m_gGAcc)

#define ghInst					(pGameGlobals->m_ghInst)

#define gFocusPattern           (pGameGlobals->m_gFocusPattern)
#define gFocusBrush             (pGameGlobals->m_gFocusBrush)
#define gFocusPen               (pGameGlobals->m_gFocusPen)

#endif

/* -------- Internal Routine Prototypes -------- */
INT_PTR CALLBACK DossierDlgProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam);

static ZError HeartsInit(void);
static ZError LoadGameImages(void);
static void GameDeleteFunc(void* type, void* pData);
static void GameExit(Game game);
static ZBool GameWindowFunc(ZWindow window, ZMessage* pMessage);
static void DisplayChange(Game game);
static ZBool PlayButtonFunc(ZRolloverButton button, int16 state, void* userData);
static ZBool AutoPlayButtonFunc(ZRolloverButton button, int16 state,void* userData);
static ZBool LastTrickButtonFunc(ZRolloverButton button, int16 state,void* userData);
static void GameWindowDraw(ZWindow window, ZMessage* pMessage);
static void HandleButtonDown(ZWindow window, ZMessage* pMessage);
static void DrawBackground(Game game, ZWindow window, ZRect* drawRect);
static void DrawTable(Game game);
static void UpdateTable(Game game);
static void DrawPlayedCard(Game game, int16 seat);
static void UpdatePlayedCard(Game game, int16 seat);
static void DrawPassDirection(Game game);
static void UpdatePassDirection(Game game);
static void DrawSmallPassDirection(Game game);
static void DrawPlayers(Game game);
static void UpdatePlayers(Game game);
static void UpdateHand(Game game);
static void DrawHand(Game game);
static void DrawFocusRect(Game game);
static void UpdateTricksTaken(Game game);
static void DrawTricksTaken(Game game);
static void DrawJoinerKibitzers(Game game);
static void UpdateJoinerKibitzers(Game game);
static void DrawOptions(Game game);
static void UpdateOptions(Game game);
static void NewGame(Game game);
static void NewHand(Game game);
static void ClearTable(Game game);
static void GetHandRect(Game game, ZRect *rect);
static int16 GetCardIndex(Game game, ZPoint *point);
static void UnselectCards(Game game);
static int16 GetNumCardsSelected(Game game);
static int16 ReceivePassFrom(Game game);
static void AddCardToHand(Game game, ZCard card);
static void SortHand(Game game);
static int16 GetCardIndexFromRank(Game game, ZCard card);
static void GameSendTalkMessage(ZWindow window, ZMessage* pMessage);
static void GameTimerFunc(ZTimer timer, void* userData);
static void DrawCardBackFace(Game game, ZRect* rect);
static void PlayACard(Game game, int16 cardIndex);
static void AutoPlayCard(Game game);
static void InitTrickWinnerGlobals(void);
static void InitTrickWinner(Game game, int16 trickWinner);
static void UpdateTrickWinner(Game game, ZBool terminate);
static void ShowTrickWinner(Game game, int16 trickWinner);
static void HandleStartGameMessage(Game game, ZHeartsMsgStartGame* msg);
static void HandleReplacePlayerMessage(Game game, ZHeartsMsgReplacePlayer* msg);
static void HandleStartHandMessage(Game game, ZHeartsMsgStartHand* msg);
static void HandleStartPlayMessage(Game game, ZHeartsMsgStartPlay* msg);
static void HandleEndHandMessage(Game game, ZHeartsMsgEndHand* msg);
static void HandleEndGameMessage(Game game, ZHeartsMsgEndGame *msg);
static void HandlePassCardsMessage(Game game, ZHeartsMsgPassCards* msg);
static void HandlePlayCardMessage(Game game, ZHeartsMsgPlayCard* msg);
static void HandleNewGameMessage(Game game, ZHeartsMsgNewGame* msg);
static void HandleTalkMessage(Game game, ZHeartsMsgTalk* msg, DWORD cbLen);
static void HandleGameStateResponseMessage(Game game, ZHeartsMsgGameStateResponse* msg);
static void HandleCheckInMessage(Game game, ZHeartsMsgCheckIn* msg);
static void HandleRemovePlayerRequestMessage(Game game, ZHeartsMsgRemovePlayerRequest* msg);
static void HandleRemovePlayerResponseMessage(Game game, ZHeartsMsgRemovePlayerResponse* msg);
static void PlayerPlayedCard(Game game, int16 seat, ZCard card);
static void OutlinePlayerCard(Game game, int16 seat, ZBool winner);
static void ClearPlayerCardOutline(Game game, int16 seat);
static void OutlineCard(ZGrafPort grafPort, ZRect* rect, ZColor* color);

//dossier work
static void HandleDossierDataMessage(Game game, ZHeartsMsgDossierData* msg);
static void HandleDossierVoteMessage(Game game,ZHeartsMsgDossierVote *msg);

static void HandleCloseDeniedMessage(Game game, ZHeartsMsgCloseDenied* msg);

static void ShowHandScores(Game game);
static ZBool HandScoreWindowFunc(ZWindow window, ZMessage* pMessage);
static void DeleteHandScoreWindow(Game game);
static void HandScoreWindowDraw(ZWindow window, ZMessage* message);
static void OrderHandScore(Game game);

static void ShowGameScores(Game game);
static ZBool GameScoreWindowFunc(ZWindow window, ZMessage* pMessage);
static void DeleteGameScoreWindow(Game game);
static void GameScoreWindowDraw(ZWindow window, ZMessage* message);
static void OrderGameScore(Game game);

static ZError ValidCardToPlay(Game game, ZCard card);
static int16 GetAutoPlayCard(Game game);
static int16 TrickWinner(Game game);
static void CountCardSuits(Game game, int16* counts);
static ZBool IsPointCard(ZCard card);
static int16 GetCardHighestUnder(Game game, int16 suit, int16 rank);
static int16 GetCardHighest(Game game, int16 suit);
static int16 GetCardHighestPlayed(Game game);

#ifdef HEARTS_ANIMATION
static bool g_fDebugRunAnimation;
static void ShowRunAnimation(Game game, int16 player);
static void RunAnimationCheckFunc(ZAnimation animation, uint16 frame, void* userData);
static void DeleteTemporaryObjects(Game game);
#endif

static void NewGamePromptFunc(int16 result, void* userData);
#ifndef MILL_VER
static void HelpButtonFunc( ZHelpButton helpButton, void* userData );
#endif

static ZBool LoadRoomResources(void);
static ZBool HeartsGetObjectFunc(int16 objectType, int16 modifier, ZImage* image, ZRect* rect);
static void HeartsDeleteObjectsFunc(void);
static void QuitGamePromptFunc(int16 result, void* userData);
static void QuitRatedGamePromptFunc(int16 result, void* userData);
static void RemovePlayerPromptFunc(int16 result, void* userData);

static ZBool ScoreButtonFunc(ZRolloverButton pictButton, int16 state, void* userData);
static void ShowScores(Game game);
static void UpdateScoreHistoryDialogScores( Game game );
static void UpdateScoreHistoryDialogNames( Game game );
static void CloseScoreHistoryDialog(Game game);
INT_PTR CALLBACK ScoreHistoryDialogProc( HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam );
static long GetScoreHistoryColumnWidth( HWND hWnd, const TCHAR *pszKey, long lDefault ); 

#ifndef MILL_VER
static void OptionsButtonFunc(ZPictButton pictButton, void* userData);
#endif
static void ShowOptions(Game game);
static void OptionsWindowDelete(Game game);
static ZBool OptionsWindowFunc(ZWindow window, ZMessage* message);
static void OptionsWindowUpdate(Game game, int16 seat);
static void OptionsWindowButtonFunc(ZButton button, void* userData);
static void OptionsWindowDraw(Game game);
static void OptionsCheckBoxFunc(ZCheckBox checkBox, ZBool checked, void* userData);

static int16 FindJoinerKibitzerSeat(Game game, ZPoint* point);
static void HandleJoinerKibitzerClick(Game game, int16 seat, ZPoint* point);
static ZBool ShowPlayerWindowFunc(ZWindow window, ZMessage* message);
static void ShowPlayerWindowDraw(Game game);
static void ShowPlayerWindowDelete(Game game);

// new UI component helper function
static BOOL UIButtonInit( ZRolloverButton *pButton, Game game, ZRect *bounds, 
                   LPCTSTR pszText, ZRolloverButtonFunc func );

static int HeartsFormatMessage( LPTSTR pszBuf, int cchBuf, int idMessage, ... );

static ZBool LoadFontFromDataStore(LPHeartsColorFont* ccFont, TCHAR* pszFontName);
static ZBool LoadGameFonts();
static void MAKEAKEY(LPCTSTR dest,LPCTSTR key1, LPCTSTR key2, LPCTSTR key3);

static BOOL InitAccessibility(Game game, IGameGame *pIGG);
static void EnableAutoplayAcc(Game game, bool fEnable);
static void EnableLastTrickAcc(Game game, bool fEnable);
static void AccPop();


/*******************************************************************************
	EXPORTED ROUTINES
*******************************************************************************/

ZError ZoneGameDllInit(HINSTANCE hLib, GameInfo gameInfo)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals;
	pGameGlobals = new GameGlobalsType;
	if (pGameGlobals == NULL)
		return (zErrOutOfMemory);
    ZeroMemory(pGameGlobals, sizeof(GameGlobalsType));
	ZSetGameGlobalPointer(pGameGlobals);
#endif

	lstrcpyn(gGameDir, gameInfo->game, zGameNameLen);
	lstrcpyn(gGameName, gameInfo->gameName, zGameNameLen);
	lstrcpyn(gGameDataFile, gameInfo->gameDataFile, zGameNameLen);
	lstrcpyn(gGameServerName, gameInfo->gameServerName, zGameNameLen);
	gGameServerPort = gameInfo->gameServerPort;
	ghInst = hLib;
	return (zErrNone);
}


void ZoneGameDllDelete(void)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobalsType *)ZGetGameGlobalPointer();

	if (pGameGlobals != NULL)
	{
		ZSetGameGlobalPointer(NULL);
		delete pGameGlobals;
	}
#endif
}


ZError ZoneClientMain(uchar *commandLineData, IGameShell *piGameShell)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobalsType *)ZGetGameGlobalPointer();
#endif
	ZError				err = zErrNone;

	if ((err = HeartsInit()) != zErrNone)
		return (err);
	
	// Get accessibility interface
	if(FAILED(ZShellCreateGraphicalAccessibility(&gGAcc)))
		return zErrLaunchFailure;

	err = ZClient4PlayerRoom(gGameServerName, (uint16) gGameServerPort, gGameName,
			HeartsGetObjectFunc, HeartsDeleteObjectsFunc, NULL);

	return (err);
}


void ZoneClientExit(void)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobalsType *)ZGetGameGlobalPointer();
#endif
	int16			i;
	
	// clear the accessiblity object
	if(gGAcc)
	{
		gGAcc->CloseAcc();
		gGAcc.Release();
	}

	ZCRoomExit();

	if (gHandBuffer != NULL)
		ZOffscreenPortDelete(gHandBuffer);
	gHandBuffer = NULL;
	

	if (gBackground != NULL)
		ZImageDelete(gBackground);
	gBackground = NULL;

	if (gButtonIdle != NULL)
		ZImageDelete(gButtonIdle);
	gButtonIdle = NULL;

	if (gButtonHighlighted != NULL)
		ZImageDelete(gButtonHighlighted);
	gButtonHighlighted = NULL;

	if (gButtonSelected != NULL)
		ZImageDelete(gButtonSelected);
	gButtonSelected = NULL;

	if (gButtonDisabled != NULL)
		ZImageDelete(gButtonDisabled);
	gButtonDisabled = NULL;

    if(gFocusPen)
        DeleteObject(gFocusPen);
    gFocusPen = NULL;

    if(gFocusBrush)
        DeleteObject(gFocusBrush);
    gFocusBrush = NULL;

    if(gFocusPattern)
        DeleteObject(gFocusPattern);
    gFocusPattern = NULL;

	/* Delete all game images. */
	for (i = 0; i < zNumGameImages; i++)
	{
		if (gGameImages[i] != NULL)
			ZImageDelete(gGameImages[i]);
		gGameImages[i] = NULL;
	}

    // delete fonts
	for(i = 0; i < zNumFonts; i++)
		if(gHeartsFont[i].m_hFont)
			DeleteObject(gHeartsFont[i].m_hFont);

    gpButtonFont->Release();
	
	/* Delete cards. */
	ZCardsDelete(zCardsNormal);
}


void ZoneClientMessageHandler(ZMessage* message)
{
}


TCHAR* ZoneClientName(void)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobalsType *)ZGetGameGlobalPointer();
#endif
	
	return (gGameName);
}


TCHAR* ZoneClientInternalName(void)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobalsType *)ZGetGameGlobalPointer();
#endif

	
	return (gGameDir);
}


ZVersion ZoneClientVersion(void)
{
	return (zGameVersion);
}


IGameGame* ZoneClientGameNew(ZUserID userID, int16 tableID, int16 seat, int16 playerType,
					ZRoomKibitzers* kibitzers)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobalsType *)ZGetGameGlobalPointer();
#endif
	Game						newGame;
	TCHAR						title[100];
	int32						i;
	ZHeartsMsgClientReady		clientReady;
	ZRect						rect;
	ZHeartsMsgGameStateRequest	gameStateReq;
	ZHeartsMsgCheckIn			checkIn;
	ZPlayerInfoType				playerInfo;
	uint32						gameOptions;	
	
	newGame = (Game) ZCalloc(1, sizeof(GameType));

	if(newGame == NULL)
		return NULL;

    newGame->voteDialog = NULL; //init this to null
    
	newGame->userID = userID;
	newGame->tableID = tableID;
	newGame->seat = seat;
	newGame->gameState = zGameStateNotInited;

    SetRectEmpty(&newGame->rcFocus);
    newGame->iFocus = -1;
    newGame->fSetFocusToHandASAP = false;
	
	ZCRoomGetPlayerInfo(userID, &playerInfo);
	
	newGame->gameWindow = ZWindowNew();
#ifndef MILL_VER
	wsprintf(title, _T("%s:Table %d"), ZoneClientName(), tableID + 1);
	ZWindowInit(newGame->gameWindow, &gRects[zRectWindow], zWindowChild, NULL, title, FALSE, FALSE, FALSE, GameWindowFunc, zWantAllMessages, (void*) newGame);
#else
	ZWindowInit(newGame->gameWindow, &gRects[zRectWindow], zWindowChild, NULL, ZoneClientName(), FALSE, FALSE, FALSE, GameWindowFunc, zWantAllMessages, (void*) newGame);
#endif

	// Initializing the offscreen port
	newGame->gameBackBuffer = ZOffscreenPortNew();
	if (!newGame->gameBackBuffer){
		ZShellGameShell()->ZoneAlert(ErrorTextOutOfMemory);
		return NULL;
	}
	ZOffscreenPortInit(newGame->gameBackBuffer,&gRects[zRectWindow]);

    // by default we draw to the window, not the back buffer
    newGame->gameDrawPort = newGame->gameWindow;

    // swap left and right for RTL
    UIButtonInit( &newGame->playButton, newGame, &gRects[ZIsLayoutRTL() ? zRectScoreButton : zRectPlayButton], 
		gszString[zPlay], PlayButtonFunc );
	
    UIButtonInit( &newGame->autoPlayButton, newGame, &gRects[ZIsLayoutRTL() ? zRectLastTrickButton : zRectAutoPlayButton], 
		gszString[zAutoPlay], AutoPlayButtonFunc );
	
    UIButtonInit( &newGame->lastTrickButton, newGame, &gRects[ZIsLayoutRTL() ? zRectAutoPlayButton : zRectLastTrickButton], 
		gszString[zLastTrick], LastTrickButtonFunc );
	
    UIButtonInit( &newGame->scoreButton, newGame, &gRects[ZIsLayoutRTL() ? zRectPlayButton : zRectScoreButton], 
		gszString[zScore], ScoreButtonFunc );

#ifndef MILL_VER		
	newGame->optionsButton = ZButtonNew();
	ZButtonInit(newGame->optionsButton, newGame->gameWindow, &gRects[zRectOptionsButton], zOptionsButtonStr,
			playerInfo.groupID == 1, playerType == zGamePlayer || playerInfo.groupID == 1,
			OptionsButtonFunc, (void*) newGame);

	newGame->helpButton = ZHelpButtonNew();
	ZHelpButtonInit(newGame->helpButton, newGame->gameWindow, &gRects[zRectHelp],
			NULL, HelpButtonFunc, NULL);
#endif
	
	/* Create the timer. */
	newGame->timer = ZTimerNew();
	ZTimerInit(newGame->timer, zHideTimeout, GameTimerFunc, (void*) newGame);
	newGame->timerType = zGameTimerNone;
	
	/* Create hand score window. */
	newGame->handScoreWindow = ZWindowNew();
	if (newGame->handScoreWindow != NULL)
	{
		rect = gHandScoreWindowRect;
		ZCenterRectToRect(&rect, &gRects[zRectWindow], zCenterBoth);
		// JRB: move rect down by 5 pixels to cover a slight visual flaw
		rect.top += 5;
		rect.bottom += 5;
		if (ZWindowInit(newGame->handScoreWindow, &rect, zWindowChild,
				newGame->gameWindow, NULL, FALSE, FALSE, FALSE, HandScoreWindowFunc, zWantAllMessages,
				(void*) newGame) == zErrNone)
		{
//				newGame->handScoreWindowFont = ZFontNew();
//				ZFontInit(newGame->handScoreWindowFont, zFontSystem, zFontStyleNormal, zScoreFontSize);
		}
		else
		{
			ZShellGameShell()->ZoneAlert(ErrorTextUnknown);
		}
	}
	else
	{
		ZShellGameShell()->ZoneAlert(ErrorTextOutOfMemory);
	}

	/* Create game score window. */
	newGame->gameScoreWindow = ZWindowNew();
	if (newGame->gameScoreWindow != NULL)
	{
		rect = gGameScoreWindowRect;
		ZCenterRectToRect(&rect, &gRects[zRectWindow], zCenterBoth);
		if (ZWindowInit(newGame->gameScoreWindow, &rect, zWindowChild,
				newGame->gameWindow, NULL, FALSE, FALSE, FALSE, GameScoreWindowFunc, zWantAllMessages,
				(void*) newGame) == zErrNone)
		{
//				newGame->gameScoreWindowFont = ZFontNew();
//				ZFontInit(newGame->gameScoreWindowFont, zFontSystem, zFontStyleNormal, zScoreFontSize);
		}
		else
		{
			ZShellGameShell()->ZoneAlert(ErrorTextUnknown);
		}
	}
	else
	{
		ZShellGameShell()->ZoneAlert(ErrorTextOutOfMemory);
	}
	
	for (i = 0; i < zNumPlayersPerTable; i++)
	{
		newGame->players[i].userID = 0;
		newGame->players[i].score = 0;
		//newGame->players[i].name[0] = '\0';
		newGame->players[i].host[0] = '\0';
		
		newGame->playersToJoin[i] = 0;
		newGame->numKibitzers[i] = 0;
		newGame->kibitzers[i] = ZLListNew(NULL);
		
		// JRB:
		// Technically, we want kibitzing off, but since the game server no longer allows it
		// at any point, I'm not sure if we need to explicity turn it off here or
		// just ignore the option.
		newGame->tableOptions[i] = 0;
		//newGame->tableOptions[i] = zRoomTableOptionNoKibitzing;
	}
	lstrcpy(newGame->players[0].name, gstrPlayer1);
	lstrcpy(newGame->players[1].name, gstrPlayer2);
	lstrcpy(newGame->players[2].name, gstrPlayer3);
	lstrcpy(newGame->players[3].name, gstrPlayer4);

	
	if (kibitzers != NULL)
	{
		for (i = 0; i < (int16) kibitzers->numKibitzers; i++)
		{
			ZLListAdd(newGame->kibitzers[kibitzers->kibitzers[i].seat], NULL,
					(void*) kibitzers->kibitzers[i].userID,
					(void*) kibitzers->kibitzers[i].userID, zLListAddLast);
			newGame->numKibitzers[kibitzers->kibitzers[i].seat]++;
		}
	}

	newGame->gameState = zGameStateInited;
//		newGame->backFaceShowing = FALSE;
	newGame->showPlayerToPlay = FALSE;
	newGame->autoPlay = FALSE;
	newGame->playerType = playerType;
	newGame->ignoreMessages = FALSE;
	
	newGame->animatingTrickWinner = FALSE;
	
#ifdef HEARTS_ANIMATION
	newGame->runAnimation = NULL;
	newGame->runAnimationWindow = NULL;
	newGame->deleteRunAnimation = FALSE;
#endif
	
	newGame->playButtonWasEnabled = FALSE;
	newGame->autoPlayButtonWasEnabled = FALSE;
	newGame->lastTrickButtonWasEnabled = FALSE;
	newGame->lastTrickShowing = FALSE;
	
	newGame->quitGamePrompted = zCloseNone;
	newGame->beepOnTurn = FALSE;
	newGame->animateCards = TRUE;
	newGame->hideCardsFromKibitzer = FALSE;
	newGame->kibitzersSilencedWarned = FALSE;
	newGame->kibitzersSilenced = FALSE;
	newGame->removePlayerPending = FALSE;

	newGame->fRatings = !!(ZCRoomGetRoomOptions() & zGameOptionsRatingsAvailable);
	newGame->nCloseStatus = zCloseRegular;
	newGame->nCloseRequested = zCloseNone;
	newGame->nCloserSeat = -1;

	newGame->fNeedNewGameConf = FALSE;

	newGame->optionsWindow = NULL;
	newGame->optionsWindowButton = NULL;
	newGame->optionsBeep = NULL;
	for (i= 0; i < zNumPlayersPerTable; i++)
	{
		newGame->optionsKibitzing[i] = NULL;
		newGame->optionsJoining[i] = NULL;
		newGame->optionsIgnore[i] = NULL;
		newGame->optionsRemove[i] = NULL;
		newGame->optionsSilent[i] = NULL;
		newGame->fIgnore[i] = FALSE;
	}

	newGame->hWndScoreWindow = NULL;

	newGame->showPlayerWindow = NULL;
	newGame->showPlayerList = NULL;

	newGame->fEndGameBlocked = FALSE;
	newGame->infoDisconnecting = NULL;

    newGame->m_hImageList = NULL;

	newGame->gameInfo = ZInfoNew();
	ZInfoInit(newGame->gameInfo, newGame->gameWindow, NULL, 240, FALSE, 0);

	//leonp - dossier service
	for(i=0;i<zNumPlayersPerTable;i++)
	{
		newGame->rgDossierVote[i] = -1;
		newGame->voteMap[i] = -1;
	}
	newGame->fVotingLock = FALSE;

	if (playerType == zGamePlayer)
	{
		clientReady.seat = seat;
		clientReady.protocolSignature = zHeartsProtocolSignature;
		clientReady.protocolVersion = zHeartsProtocolVersion;
		clientReady.version = ZoneClientVersion();
		ZHeartsMsgClientReadyEndian(&clientReady);
		ZCRoomSendMessage(tableID, zHeartsMsgClientReady, &clientReady, sizeof(ZHeartsMsgClientReady));
		ZInfoSetText(newGame->gameInfo, zClientReadyInfoStr);
	}
	else if (playerType == zGamePlayerJoiner)
	{
		/* Check in with the server. */
		checkIn.userID = userID;
		checkIn.seat = seat;
		
		ZHeartsMsgCheckInEndian(&checkIn);
		ZCRoomSendMessage(tableID, zHeartsMsgCheckIn, &checkIn, sizeof(checkIn));
		ZInfoSetText(newGame->gameInfo, zCheckInInfoStr);
		
		newGame->ignoreMessages = TRUE;
	}
	else if (playerType == zGamePlayerKibitzer)
	{
		/* Request current game state. */
		gameStateReq.userID = userID;
		gameStateReq.seat = seat;
		ZHeartsMsgGameStateRequestEndian(&gameStateReq);
		ZCRoomSendMessage(tableID, zHeartsMsgGameStateRequest, &gameStateReq, sizeof(gameStateReq));
		ZInfoSetText(newGame->gameInfo, zKibitzerInfoStr);
		
		newGame->ignoreMessages = TRUE;
	}

	NewGame(newGame);
	NewHand(newGame);
	
	ZWindowShow(newGame->gameWindow);
	ZInfoShow(newGame->gameInfo);


    IGameGame *pIGG = CGameGameHearts::BearInstance(newGame);
    if(!pIGG)
    {
        ZFree(newGame);
        return NULL;
    }

	InitAccessibility(newGame, pIGG);

	return pIGG;
}


void		ZoneClientGameDelete(ZCGame game)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobalsType *)ZGetGameGlobalPointer();
#endif
	Game			this_object = I(game);
	int16			i;
	TCHAR buff[1024];

    gGAcc->CloseAcc();

	if (this_object != NULL)
	{
#ifndef MILL_VER
		if(!this_object->nCloseRequested && this_object->playerType == zGamePlayer)
		{
			lstrcpy(buff, zLostConnStr);
			if(this_object->fRatings && (this_object->nCloseStatus == zCloseForfeit || this_object->nCloseStatus == zCloseTimeout))
				lstrcat(buff, zIncompleteSufStr);
			ZShellGameShell()->ZoneAlert(buff);
		}
#endif			
		for (i = 0; i < zNumPlayersPerTable; i++)
		{
			ZLListDelete(this_object->kibitzers[i]);
		}
		
		if (this_object->handScoreWindow != NULL)
			DeleteHandScoreWindow(this_object);
		
		if (this_object->gameScoreWindow != NULL)
			DeleteGameScoreWindow(this_object);
		
		OptionsWindowDelete(this_object);
		ShowPlayerWindowDelete(this_object);

		if(this_object->infoDisconnecting)
			ZInfoDelete(this_object->infoDisconnecting);

        if(this_object->m_hImageList)
            ImageList_Destroy(this_object->m_hImageList);
		
		ZInfoDelete(this_object->gameInfo);
		ZTimerDelete(this_object->timer);
		ZRolloverButtonDelete(this_object->scoreButton);
		ZRolloverButtonDelete(this_object->playButton);
		ZRolloverButtonDelete(this_object->autoPlayButton);
		ZRolloverButtonDelete(this_object->lastTrickButton);
#ifndef MILL_VER
		ZButtonDelete(this_object->optionsButton);
		ZHelpButtonDelete(this_object->helpButton);
#endif
		ZWindowDelete(this_object->gameWindow);
        this_object->gameDrawPort = NULL;

		if(this_object->voteDialog)
		{
			DestroyWindow(this_object->voteDialog);
		}
		this_object->voteDialog = NULL;

        if ( this_object->scoreHistory )
        {
			CloseScoreHistoryDialog(this_object);
            ZFree( this_object->scoreHistory );
            this_object->scoreHistory = NULL;
            this_object->numScores = 0;
        }

		if (this_object->gameBackBuffer != NULL)
			ZOffscreenPortDelete(this_object->gameBackBuffer);
		this_object->gameBackBuffer = NULL;

		ZFree(game);
	}

//	ZResourceDelete(gresFile);

}


ZBool		ZoneClientGameProcessMessage(ZCGame game, uint32 messageType, void* message,
					int32 messageLen)
{
	Game		this_object = I(game);
	
	
	/* Are messages being ignored? */
	if (this_object->ignoreMessages == FALSE)
	{
		switch (messageType)
		{
			case zHeartsMsgStartGame:
				if( messageLen < sizeof( ZHeartsMsgStartGame ) )
				{
					ZShellGameShell()->ZoneAlert(ErrorTextSync, NULL, NULL, true, false );	
				}
				else
				{
					HandleStartGameMessage(this_object, (ZHeartsMsgStartGame*) message);
				}
				break;
			case zHeartsMsgReplacePlayer:
				if( messageLen < sizeof( ZHeartsMsgReplacePlayer ) )
				{
					ZShellGameShell()->ZoneAlert(ErrorTextSync, NULL, NULL, true, false );	
				}
				else
				{
					HandleReplacePlayerMessage(this_object, (ZHeartsMsgReplacePlayer*) message);
				}
				break;
			case zHeartsMsgStartHand:
				if( messageLen < sizeof( ZHeartsMsgStartHand ) )
				{
					ZShellGameShell()->ZoneAlert(ErrorTextSync, NULL, NULL, true, false );	
				}
				else
				{
					HandleStartHandMessage(this_object, (ZHeartsMsgStartHand*) message);
				}
				break;
			case zHeartsMsgStartPlay:
				if( messageLen < sizeof( ZHeartsMsgStartPlay ) )
				{
					ZShellGameShell()->ZoneAlert(ErrorTextSync, NULL, NULL, true, false );	
				}
				else
				{
					HandleStartPlayMessage(this_object, (ZHeartsMsgStartPlay*) message);
				}
				break;
			case zHeartsMsgEndHand:
				if( messageLen < sizeof( ZHeartsMsgEndHand ) )
				{
					ZShellGameShell()->ZoneAlert(ErrorTextSync, NULL, NULL, true, false );
				}
				else
				{
					HandleEndHandMessage(this_object, (ZHeartsMsgEndHand*) message);
				}
				break;
			case zHeartsMsgEndGame:
				if( messageLen < sizeof( ZHeartsMsgEndGame ) )
				{
					ZShellGameShell()->ZoneAlert(ErrorTextSync, NULL, NULL, true, false );
				}
				else
				{
					HandleEndGameMessage(this_object, (ZHeartsMsgEndGame *)message);
				}
				break;
			case zHeartsMsgPassCards:
				if( messageLen < sizeof( ZHeartsMsgPassCards ) )
				{
					ZShellGameShell()->ZoneAlert(ErrorTextSync, NULL, NULL, true, false );
				}
				else
				{
					HandlePassCardsMessage(this_object, (ZHeartsMsgPassCards*) message);
				}
				break;
			case zHeartsMsgPlayCard:
				if( messageLen < sizeof( ZHeartsMsgPlayCard ) )
				{
					ZShellGameShell()->ZoneAlert(ErrorTextSync, NULL, NULL, true, false );
				}
				else
				{
					HandlePlayCardMessage(this_object, (ZHeartsMsgPlayCard*) message);
				}
				break;
			case zHeartsMsgNewGame:
				if( messageLen < sizeof( ZHeartsMsgNewGame ) )
				{
					ZShellGameShell()->ZoneAlert(ErrorTextSync, NULL, NULL, true, false );
				}
				else
				{
					HandleNewGameMessage(this_object, (ZHeartsMsgNewGame*) message);
				}
				break;
			case zHeartsMsgTalk:
            {
                ZHeartsMsgTalk *msg = (ZHeartsMsgTalk *) message;
				if(messageLen < sizeof(ZHeartsMsgTalk))
				{
					ZShellGameShell()->ZoneAlert(ErrorTextSync, NULL, NULL, true, false );
				}
				else
				{
					HandleTalkMessage(this_object, msg, messageLen);
				}
				break;
            }

            // this message is unnecessary, but the existing server still sends it.  removed from server, but
            // have to leave this in until new server is propped.
			case zHeartsMsgOptions:
				break;

			case zHeartsMsgCheckIn:
				ASSERT(FALSE);
			case zHeartsMsgRemovePlayerRequest:
				ASSERT(FALSE);
			case zHeartsMsgRemovePlayerResponse:
				ASSERT(FALSE);
			//dossier
			case zHeartsMsgDossierVote:
				ASSERT(FALSE);
			case zHeartsMsgDossierData:
				ASSERT(FALSE);
			case zHeartsMsgCloseDenied:
				ASSERT(FALSE);
			default:
				//These messages shouldn't be comming in for Whistler
				ZShellGameShell()->ZoneAlert(ErrorTextSync, NULL, NULL, true, false );	
				break;
		}
	}
	else
	{
		/* Messages not to ignore. */
		switch (messageType)
		{
			case zHeartsMsgTalk:
            {
                ZHeartsMsgTalk *msg = (ZHeartsMsgTalk *) message;
				if(messageLen < sizeof(ZHeartsMsgTalk))
				{
					ZShellGameShell()->ZoneAlert(ErrorTextSync, NULL, NULL, true, false );
				}
				else
				{
					HandleTalkMessage(this_object, msg, messageLen);
				}
				break;
            }

			case zHeartsMsgGameStateResponse:
				ASSERT(FALSE);
			default:
				//These messages shouldn't be comming in for Whistler
				ZShellGameShell()->ZoneAlert(ErrorTextSync, NULL, NULL, true, false );	
				break;
		}
	}	
	
	return (TRUE);
}

//dossier work blah
static void HandleDossierDataMessage(Game game, ZHeartsMsgDossierData* msg)
{

	int16 					dResult,i,j;
	TCHAR					buff[1024];
	TCHAR					buff1[1024];
	ZPlayerInfoType 		PlayerInfo;		
	HWND hwnd;
	int16 seat;

	GameGlobals			pGameGlobals = (GameGlobalsType *)ZGetGameGlobalPointer();

#ifdef MILL_VER
    ASSERT(!"Why are we here?");
#endif
	
	ZHeartsMsgDossierDataEndian(msg);
	switch(msg->message)
	{
		case zDossierBotDetected: 
			game->fRatings = FALSE;
			 ZShellGameShell()->ZoneAlert(RATING_ERROR, NULL);
		 	 break;
		case zDossierAbandonNoStart:
#ifndef MILL_VER
			 ZCRoomGetPlayerInfo(msg->user, &PlayerInfo);
#endif
			 wsprintf(buff,RATING_DISABLED, msg->userName);
			game->fRatings = FALSE;
			 ZShellGameShell()->ZoneAlert(buff,NULL);
			 break;
		case zDossierAbandonStart:
			 //vote and send the message to the server.

		     //kibitzers don't get this message
		     //todo: show some type of status to kibitzer
			 if (game->playerType != zGamePlayer)
			 	return;
			 	
			game->nCloseStatus = zCloseWaiting;
			game->nCloserSeat = -1;
			for(i = 0; i < 4; i++)
				if(msg->user == game->players[i].userID)
				{
					game->nCloserSeat = i;
					break;
				}

		     if(ZRolloverButtonIsEnabled(game->playButton))
			    game->playButtonWasEnabled = TRUE;
			 else
			 	game->playButtonWasEnabled = FALSE;
			 	
			if (game->autoPlay)
			{
				/* Turn auto play off. */
				game->autoPlay = FALSE;
				ZRolloverButtonSetText(game->autoPlayButton, gszString[zAutoPlay]);
				ZRolloverButtonEnable(game->playButton);
			}

			 if(ZRolloverButtonIsEnabled(game->autoPlayButton))
			 	game->autoPlayButtonWasEnabled = TRUE;
			 else
			 	game->autoPlayButtonWasEnabled = FALSE;
			 
			 if(ZRolloverButtonIsEnabled(game->lastTrickButton))
			 	game->lastTrickButtonWasEnabled = TRUE;
			 else
			 	game->lastTrickButtonWasEnabled = FALSE;

			 ZRolloverButtonDisable(game->playButton);
  			 ZRolloverButtonDisable(game->autoPlayButton);
  			 ZRolloverButtonDisable(game->lastTrickButton);
#ifndef MILL_VER
			 ZButtonDisable(game->optionsButton);
#endif			
			 //set up mapping    - this maps the remaining players to the 3 available dialog labels
			 for(i=0,j=0;i<=3;i++)	
			 {
			 	if(msg->user!=game->players[i].userID)
			 		game->voteMap[j++] = i;
			 }
			 
  	 		 game->voteMap[3] = -1;  //this is always invalid
			 game->voteDialog = CreateDialog(ghInst,MAKEINTRESOURCE(IDD_DROP),ZWindowWinGetWnd(game->gameWindow), DossierDlgProc);
			 SetWindowLong(game->voteDialog,DWL_USER,(long)game); //set the game object to the window data

			 //set the window names
			 hwnd = GetDlgItem(game->voteDialog,IDC_PLAYERA);
			 SetWindowText(hwnd,game->players[game->voteMap[0]].name);

			 hwnd = GetDlgItem(game->voteDialog,IDC_PLAYERB);
			 SetWindowText(hwnd,game->players[game->voteMap[1]].name);

			 hwnd = GetDlgItem(game->voteDialog,IDC_PLAYERC);
			 SetWindowText(hwnd,game->players[game->voteMap[2]].name);

			 hwnd = GetDlgItem(game->voteDialog,IDC_PROMPT);
			 GetWindowText( hwnd, buff1, sizeof(buff1) );
			 wsprintf( buff, buff1, msg->userName );
			 SetWindowText(hwnd,buff);

			 ShowWindow(game->voteDialog,SW_SHOW);  
			 
			 game->fVotingLock = TRUE;    //the voting lock prevents the user from playing a card.
			 for(i=0;i<zNumPlayersPerTable;i++)
				game->rgDossierVote[i] = -1;

			 break;
		case zDossierMultiAbandon:

			game->fRatings = FALSE;
			game->nCloseStatus = zCloseForfeit;
			game->nCloserSeat = -1;
		     if(game->playButtonWasEnabled)
				 ZRolloverButtonEnable(game->playButton);
		     			 			 	
			 if(game->autoPlayButtonWasEnabled)
			 	 ZRolloverButtonEnable(game->autoPlayButton);
			 	 
			 if(game->lastTrickButtonWasEnabled)
			 	ZRolloverButtonEnable(game->lastTrickButton);

#ifndef MILL_VER
			 ZButtonEnable(game->optionsButton);
#endif
	         ZShellGameShell()->ZoneAlert(RATING_MULTIPLE,NULL);
			     	 game->fVotingLock = FALSE;

		   	 if(game->voteDialog)
		     {
			 	DestroyWindow(game->voteDialog);
			 }
			 game->voteDialog = NULL;

			 break;
		case zDossierRatingsReEnabled:
			game->fRatings = TRUE;
			for(i = 0; i < zNumPlayersPerTable; i++)
				ZButtonDisable(game->optionsRemove[i]);  // for now, if ratings become disabled when options is up, the buttons stay disabled
			game->removePlayerPending = FALSE;
	  	 	 ZShellGameShell()->ZoneAlert(RATING_ENABLED,NULL);
			 break;
		case zDossierHeartsRejoin:  //send when the new player rejoins remove the dialog box
			game->nCloseStatus = zCloseForfeit;
			game->nCloserSeat = -1;
			if(game->playButtonWasEnabled)
				 ZRolloverButtonEnable(game->playButton);
		     			 			 	
			 if(game->autoPlayButtonWasEnabled)
			 	 ZRolloverButtonEnable(game->autoPlayButton);
			 	 
			 if(game->lastTrickButtonWasEnabled)
			 	ZRolloverButtonEnable(game->lastTrickButton);

#ifndef MILL_VER
			 ZButtonEnable(game->optionsButton);
#endif
			 game->fVotingLock = FALSE;  //release UI lock
			 for(i=0;i<zNumPlayersPerTable;i++)
			 {
			 	game->rgDossierVote[i] = zNotVoted;
			 }

			 //destroy the dialog box
			 if(game->voteDialog)
			 {
			 	DestroyWindow(game->voteDialog);
			 }
			 game->voteDialog = NULL;

			 break;
#if 0
		case zDossierVoteCompleteWait://no longer used.
			 game->fVotingLock = FALSE;  //release UI lock
			 for(i=0;i<zNumPlayersPerTable;i++)
			 {
			 	game->rgDossierVote[i] = zNotVoted;
			 }

			hwnd = GetDlgItem(game->voteDialog,IDNO);
		 EnableWindow(hwnd,FALSE);
  			 
             break;
#endif
		case zDossierVoteCompleteCont:
			game->fRatings = FALSE;
			game->nCloseStatus = zCloseForfeit;
			game->nCloserSeat = -1;
			 if(game->playButtonWasEnabled)
				 ZRolloverButtonEnable(game->playButton);
		     			 			 	
			 if(game->autoPlayButtonWasEnabled)
			 	 ZRolloverButtonEnable(game->autoPlayButton);
			 	 
			 if(game->lastTrickButtonWasEnabled)
			 	ZRolloverButtonEnable(game->lastTrickButton);

#ifndef MILL_VER
			 ZButtonEnable(game->optionsButton);
#endif			 
			 game->fVotingLock = FALSE;  //release UI lock.
			 for(i=0;i<zNumPlayersPerTable;i++)
			 {
			 	game->rgDossierVote[i] = zNotVoted;
				game->voteMap[i]= -1;
			}
			 			 
			 //destroy the dialog box
			 if(game->voteDialog)
			 {
				DestroyWindow(game->voteDialog);
			 }
			 game->voteDialog = NULL;

			 ZShellGameShell()->ZoneAlert(RATING_CONT_UNRATED);
			 
		     break;

		case zDossierMoveTimeout:
			for(i = 0; i < 4; i++)
				if(msg->user == game->players[i].userID)
				{
					seat = i;
					break;
				}
			ASSERT(i < 4);

			if(seat == game->seat)
				break;

			game->nCloseStatus = zCloseTimeout;
			game->nCloserSeat = seat;

			if(game->playerType != zGamePlayer)
				break;

			wsprintf(buff, zPlayerTimedOutStr, game->players[seat].name, game->players[seat].name);
			ZShellGameShell()->ZoneAlert(buff);
			break;

		defaut:
			ASSERT(FALSE);

	}
	
}

void HandleDossierVoteMessage(Game game,ZHeartsMsgDossierVote *msg)
{
//dossier system message 
	int16 i;
	HWND hwnd;
	TCHAR buff[255];
	
	ZHeartsMsgDossierVoteEndian(msg);
	
	game->rgDossierVote[msg->seat] = msg->vote;
	if(msg->vote == zVotedYes)
		lstrcpy(buff,RATING_WAIT_MSG);
	else if(msg->vote == zVotedNo)
		lstrcpy(buff,RATING_DONT_MSG);
		
	//voteDialog
	if(game->voteDialog)
	//this is a response to a voting message update the status message accordingly.
	//hasn't voted, wait, don't wait etc.
	{
		//set the window names
		if(msg->seat == game->voteMap[0])
		{
			hwnd = GetDlgItem(game->voteDialog,IDC_RESPONSE_A);
			SetWindowText(hwnd,buff);
		}
		else if(msg->seat == game->voteMap[1])
		{
			hwnd = GetDlgItem(game->voteDialog,IDC_RESPONSE_B);
	  		SetWindowText(hwnd,buff);
	
		}
		else if(msg->seat == game->voteMap[2])
		{
			hwnd = GetDlgItem(game->voteDialog,IDC_RESPONSE_C);
			SetWindowText(hwnd,buff);
		}
			
	}
}


static void HandleCloseDeniedMessage(Game game, ZHeartsMsgCloseDenied* msg)
{
	TCHAR buff[2048];

	ZHeartsMsgCloseDeniedEndian(msg);
	if(msg->seat != game->seat || game->playerType != zGamePlayer || !game->nCloseRequested)
		return;

	if(game->infoDisconnecting)
	{
		ZInfoHide(game->infoDisconnecting);
		ZInfoDelete(game->infoDisconnecting);
		game->infoDisconnecting = NULL;
	}

	ASSERT(game->nCloseRequested >= 0 && game->nCloseRequested < zNumCloseTypes);
	ASSERT(msg->reason >= 0 && msg->reason < zNumCloseTypes);

	wsprintf(buff, g_aszCloseDeniedPrompts[game->nCloseRequested][msg->reason], game->nCloserSeat >= 0 ? game->players[game->nCloserSeat].name : zUnknownUserStr,
		game->nCloserSeat >= 0 ? game->players[game->nCloserSeat].name : zUnknownUserStr);
	if(game->nCloserSeat < 0 && buff[0] >= _T('a') && buff[0] <= _T('z'))
		buff[0] -= _T('j') - _T('J');

	ZPrompt(
		buff,
		&gQuitGamePromptRect,
		game->gameWindow,
		TRUE,
		zPromptYes | zPromptNo,
		g_aszClosePrompts[msg->reason][1],
		g_aszClosePrompts[msg->reason][2],
		NULL,
		msg->reason ? QuitRatedGamePromptFunc : QuitGamePromptFunc,
		game );

	game->nCloseRequested = zCloseNone;
	game->quitGamePrompted = (msg->reason ? msg->reason : zCloseRegular);

	if(msg->reason == zCloseNone)
		game->fRatings = FALSE;
	else
		if(game->nCloseStatus != msg->reason)  // shouldn't happen
		{
			game->nCloseStatus = msg->reason;
			game->nCloserSeat = -1;
		}
}


/*
	Add the given user as a kibitzer to the game at the given seat.
	
	This user is kibitzing the game.
*/
void		ZoneClientGameAddKibitzer(ZCGame game, int16 seat, ZUserID userID)
{
	Game		this_object = I(game);
	
	
	ZLListAdd(this_object->kibitzers[seat], NULL, (void*) userID, (void*) userID, zLListAddLast);
	this_object->numKibitzers[seat]++;
	
	UpdateJoinerKibitzers(this_object);
}


/*
	Remove the given user as a kibitzer from the game at the given seat.
	
	This is user is not kibitzing the game anymore.
*/
void		ZoneClientGameRemoveKibitzer(ZCGame game, int16 seat, ZUserID userID)
{
	Game		this_object = I(game);
	
	
	if (userID == zRoomAllPlayers)
	{
		ZLListRemoveType(this_object->kibitzers[seat], zLListAnyType);
		this_object->numKibitzers[seat] = 0;
	}
	else
	{
		ZLListRemoveType(this_object->kibitzers[seat], (void*) userID);
		this_object->numKibitzers[seat] = (int16) ZLListCount(this_object->kibitzers[seat], zLListAnyType);
	}
	
	UpdateJoinerKibitzers(this_object);
}


/*******************************************************************************
	INTERNAL ROUTINES
*******************************************************************************/
static ZError HeartsInit(void)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobalsType *)ZGetGameGlobalPointer();
#endif
	ZError		err = zErrNone;
	
	
	ZSetCursor(NULL, zCursorBusy);
	
	gHandBuffer = ZOffscreenPortNew();
	ZOffscreenPortInit(gHandBuffer, &gRects[zRectHand]);
	
	err = ZCardsInit(zCardsNormal);
	if (err != zErrNone)
		goto Exit;
	
	err = LoadGameImages();
	if (err != zErrNone)
		goto Exit;
	
	if(!LoadRoomResources())
	{
		err = zErrResourceNotFound;
		goto Exit;
	}

	InitTrickWinnerGlobals();
	
    // create drag brush
    gFocusPattern = ZShellResourceManager()->LoadBitmap(MAKEINTRESOURCE(IDB_FOCUS_PATTERN));
    if(!gFocusPattern)
    {
	    ZShellGameShell()->ZoneAlert(ErrorTextResourceNotFound);
        return zErrResourceNotFound;
    }

    gFocusBrush = CreatePatternBrush(gFocusPattern);
    if(!gFocusBrush)
    {
        DeleteObject(gFocusPattern);
        gFocusPattern = NULL;
		ZShellGameShell()->ZoneAlert(ErrorTextOutOfMemory);
		return zErrOutOfMemory;
    }

    gFocusPen = CreatePen(PS_SOLID, 1, RGB(255, 255, 0));
    if(!gFocusPen)
    {
        DeleteObject(gFocusPattern);
        gFocusPattern = NULL;
        DeleteObject(gFocusBrush);
        gFocusBrush = NULL;
		ZShellGameShell()->ZoneAlert(ErrorTextOutOfMemory);
		return zErrOutOfMemory;
    }

Exit:

	if (err != zErrNone)
	{
		ZShellGameShell()->ZoneAlert(ErrorTextUnknown);
		ZShellGameShell()->ZoneExit();
	}

	ZSetCursor(NULL, zCursorArrow);

	return (err);
}


static void GameDeleteFunc(void* type, void* pData)
{
	if (pData != NULL)
	{
		ZFree(pData);
	}
}


static ZError LoadGameImages(void)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobalsType *)ZGetGameGlobalPointer();
#endif
	ZError				err = zErrNone;
	uint16				i;
	ZImage				tempImage;
    bool fErrorOccurred = false;
    COLORREF clrTrans = PALETTERGB( 255, 0, 255 );
	

#ifndef MILL_VER
	ZInfo				info;
	info = ZInfoNew();
	ZInfoInit(info, NULL, "Loading game images...", 200, TRUE, zNumGameImages + 2);
#endif
	
#ifndef MILL_VER
	ZInfoShow(info);
#endif
	
	for (i = 0; i < zNumGameImages; i++)
	{
		gGameImages[i] = ZImageCreateFromResourceManager(i+IDB_PASS_LEFT, clrTrans);
		if (gGameImages[i] == NULL)
		{
			err = zErrOutOfMemory;
            fErrorOccurred = true;
			break;
		}
		
#ifndef MILL_VER
		ZInfoIncProgress(info, 1);
#endif
	}
	
	// Create the background brush. 
	if (!((gBackground = ZImageCreateFromResourceManager(IDB_BACKGROUND, clrTrans)) != NULL))
    {
        fErrorOccurred = true;
    }
	if (!((gButtonIdle = ZImageCreateFromResourceManager(IDB_BUTTON_IDLE, clrTrans)) != NULL))
    {
        fErrorOccurred = true;
    }
	if (!((gButtonHighlighted = ZImageCreateFromResourceManager(IDB_BUTTON_HIGHLIGHTED, clrTrans)) != NULL))
    {
        fErrorOccurred = true;
    }
	if (!((gButtonSelected = ZImageCreateFromResourceManager(IDB_BUTTON_SELECTED, clrTrans)) != NULL))
    {
        fErrorOccurred = true;
    }
	if (!((gButtonDisabled = ZImageCreateFromResourceManager(IDB_BUTTON_DISABLED, clrTrans)) != NULL))
    {
        fErrorOccurred = true;
    }

    if ( fErrorOccurred )
    {
		ZShellGameShell()->ZoneAlert(ErrorTextResourceNotFound);
	}
	
#ifndef MILL_VER
	ZInfoDelete(info);
#endif

	return (err);
}


static ZBool GameWindowFunc(ZWindow window, ZMessage* pMessage)
{
	ZBool		msgHandled;
	Game		this_object = (Game) pMessage->userData;
	TCHAR buff[1024];
	
	
	msgHandled = FALSE;
	
#ifdef HEARTS_ANIMATION
	DeleteTemporaryObjects(this_object);
#endif

	switch (pMessage->messageType) 
	{
		case zMessageWindowDraw:
			GameWindowDraw(window, pMessage);
			msgHandled = TRUE;
			break;
		case zMessageWindowButtonDown:
		case zMessageWindowButtonDoubleClick:
			HandleButtonDown(window, pMessage);
			msgHandled = TRUE;
			break;
		case zMessageWindowClose:
			if(this_object->playerType == zGamePlayer)
			{
				if(this_object->quitGamePrompted || this_object->nCloseRequested || this_object->nCloseStatus == zCloseClosing)
					break;

				// since fRatings can be false in a rated room, there is the possibility of the game becoming rated while the unrated dialog is up.  this case is not handled
				// and will currently result in the person receiving an incomplete.
				if(!this_object->fRatings)
				{
					/* Ask user if desires to leave the current game. */
					this_object->quitGamePrompted = zCloseRegular;
					ZPrompt(zQuitGamePromptStr, &gQuitGamePromptRect, this_object->gameWindow, TRUE,
							zPromptYes | zPromptNo, NULL, NULL, NULL, QuitGamePromptFunc, this_object);
				}
				else
				{
					this_object->quitGamePrompted = this_object->nCloseStatus;
					ASSERT(this_object->nCloseStatus > 0 && this_object->nCloseStatus < zNumCloseTypes);

					wsprintf(buff, g_aszClosePrompts[this_object->nCloseStatus][0], this_object->nCloserSeat >= 0 ? this_object->players[this_object->nCloserSeat].name : zUnknownUserStr);
					if(this_object->nCloserSeat < 0 && buff[0] >= _T('a') && buff[0] <= _T('z'))
						buff[0] -= _T('j') - _T('J');
					ZPrompt(buff, &gQuitGamePromptRect, this_object->gameWindow, TRUE, zPromptYes | zPromptNo,
						g_aszClosePrompts[this_object->nCloseStatus][1], g_aszClosePrompts[this_object->nCloseStatus][2], NULL, QuitRatedGamePromptFunc, this_object);
				}
			}
			else
			{
				this_object->nCloseRequested = zCloseClosing;
				//ZCRoomGameTerminated(this_object->tableID);
				ZShellGameShell()->ZoneExit();		
			}
			msgHandled = TRUE;
			break;
		case zMessageWindowTalk:
			GameSendTalkMessage(window, pMessage);
			msgHandled = TRUE;
			break;

        case zMessageSystemDisplayChange:
            DisplayChange(this_object);
            break;
	}
	
	return (msgHandled);
}


// all offscreen ports need to be regenerated
static void DisplayChange(Game game)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif

    int i;

    // delete the cards, they're kept as an offscreen port
	ZCardsDelete(zCardsNormal);

    // delete our personal offscreen ports
	if(game->gameBackBuffer)
		ZOffscreenPortDelete(game->gameBackBuffer);
	game->gameBackBuffer = NULL;

	if(gHandBuffer)
		ZOffscreenPortDelete(gHandBuffer);
	gHandBuffer = NULL;

    // now remake them all
	game->gameBackBuffer = ZOffscreenPortNew();
	if(!game->gameBackBuffer)
    {
	    ZShellGameShell()->ZoneAlert(ErrorTextOutOfMemory, NULL, NULL, true, true);
		return;
	}
	ZOffscreenPortInit(game->gameBackBuffer, &gRects[zRectWindow]);

	gHandBuffer = ZOffscreenPortNew();
	if(!gHandBuffer)
    {
	    ZShellGameShell()->ZoneAlert(ErrorTextOutOfMemory, NULL, NULL, true, true);
		return;
	}
	ZOffscreenPortInit(gHandBuffer, &gRects[zRectHand]);

	if(ZCardsInit(zCardsNormal) != zErrNone)
    {
	    ZShellGameShell()->ZoneAlert(ErrorTextOutOfMemory, NULL, NULL, true, true);
		return;
	}

    ZWindowInvalidate(game->gameWindow, NULL);
}


static ZBool PlayButtonFunc(ZRolloverButton button, int16 state, void* userData)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobalsType *)ZGetGameGlobalPointer();
#endif
	int16					i, j;
	Game					game;
	ZHeartsMsgPassCards		passMsg;
	TCHAR					tempStr[ZLARGESTRING];
	int16					cardIndex;
	game = (Game) userData;
	
	if ( state != zRolloverButtonClicked )
        return TRUE;
	
	if(!ZRolloverButtonIsEnabled(game->playButton))
		return TRUE;

#ifdef _DEBUG
#if HEARTS_ANIMATON
    if ( ( GetKeyState( VK_LSHIFT ) & ( 0x1 << 16 ) ) &&
          ( GetKeyState( VK_LCONTROL ) & ( 0x1 << 16 ) ) )
    {
        g_fDebugRunAnimation = true;
        ShowRunAnimation( game, game->seat );
        return TRUE;
    }
#endif
#endif

	if (game->gameState == zGameStatePassCards)
	{
		if (GetNumCardsSelected(game) == game->numCardsToPass)
		{
			for (i = 0, j = 0; i < game->numCardsDealt; i++)
			{
				if (game->cardsInHand[i] != zNoCard)
				{
					if (game->cardsSelected[i])
					{
						passMsg.pass[j++] = game->cardsInHand[i];
						game->cardsInHand[i] = zNoCard;
						game->numCardsInHand--;
					}
				}
			}
			passMsg.seat = game->seat;
			ZHeartsMsgPassCardsEndian(&passMsg);
			ZCRoomSendMessage(game->tableID, zHeartsMsgPassCards, (void*) &passMsg,
					sizeof(ZHeartsMsgPassCards));
						
			ZRolloverButtonDisable(game->playButton);
            gGAcc->SetItemEnabled(false, IDC_PLAY_BUTTON, false, 0);
			UpdateHand(game);
            UpdatePassDirection(game);
		}
		else
		{
			// format this error message from a resource string
			TCHAR buf[ZLARGESTRING];
			_itot(game->numCardsToPass, buf, 10);
			HeartsFormatMessage(tempStr, ZLARGESTRING, IDS_ERR_PLEASE_SELECT_3, buf);
			ZShellGameShell()->ZoneAlert(tempStr);
		}
	}
	else
	{
		if (game->playerToPlay == game->seat)
		{
			if (GetNumCardsSelected(game) == 1)
			{
				for (i = 0; i < game->numCardsDealt; i++)
					if (game->cardsInHand[i] != zNoCard)
						if (game->cardsSelected[i])
							cardIndex = i;
				PlayACard(game, cardIndex);
				
				if (game->numCardsInHand == 0)
                {
					ZRolloverButtonDisable(game->playButton);
                    gGAcc->SetItemEnabled(false, IDC_PLAY_BUTTON, false, 0);
                }
			}
			else
			{
				ZShellGameShell()->ZoneAlert(gValidCardErrStr[zPleaseSelect1Card]);
			}
		}
/*
		else
		{
			ZShellGameShell()->ZoneAlert(gValidCardErrStr[zNotYourTurn]);
		}
*/
	}
	return TRUE;
}


static ZBool AutoPlayButtonFunc(ZRolloverButton button, int16 state, void* userData)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobalsType *)ZGetGameGlobalPointer();
#endif
	Game					game;
	
	if ( state != zRolloverButtonClicked )
        return TRUE;
	
	game = (Game) userData;

	if(!ZRolloverButtonIsEnabled(game->autoPlayButton))
		return TRUE;

	if (game->autoPlay)
	{
		/* Turn auto play off. */
		game->autoPlay = FALSE;
		ZRolloverButtonSetText(game->autoPlayButton, gszString[zAutoPlay]);
		ZRolloverButtonDraw(game->autoPlayButton);
        EnableAutoplayAcc(game, true);
        gGAcc->SetFocus(IDC_AUTOPLAY_BUTTON, false, 0);

		if (game->playerToPlay == game->seat)
        {
			ZRolloverButtonEnable(game->playButton);
            gGAcc->SetItemEnabled(true, IDC_PLAY_BUTTON, false, 0);
        }
	}
	else
	{
		/* Turn auto play on. */
		game->autoPlay = TRUE;
		ZRolloverButtonSetText(game->autoPlayButton, gszString[zStop]);
		ZRolloverButtonDraw(game->autoPlayButton);
		ZRolloverButtonDisable(game->playButton);
        EnableAutoplayAcc(game, true);
        gGAcc->SetItemEnabled(false, IDC_PLAY_BUTTON, false, 0);
        gGAcc->SetFocus(IDC_STOP_BUTTON, false, 0);
		
		UnselectCards(game);
		
		if (game->animatingTrickWinner == FALSE)
		{
			/* Play card if turn to play. */
			if (game->playerToPlay == game->seat)
				AutoPlayCard(game);
		}
		
		UpdateHand(game);
	}
	return TRUE;
}


static ZBool LastTrickButtonFunc(ZRolloverButton button, int16 state, void* userData)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobalsType *)ZGetGameGlobalPointer();
#endif
	Game			game = I(userData);
	ZCard			tempCard;
	int16			i;
	
	if ( state != zRolloverButtonClicked )
        return TRUE;
	
	if(!ZRolloverButtonIsEnabled(game->lastTrickButton))
		return TRUE;

	if (game->lastTrickShowing)
	{
		/* Hide last trick cards. */
		game->lastTrickShowing = FALSE;
		ZRolloverButtonSetText(game->lastTrickButton, gszString[zLastTrick]);
		ZRolloverButtonDraw(game->lastTrickButton);
        EnableLastTrickAcc(game, true);
        gGAcc->SetFocus(IDC_LAST_TRICK_BUTTON, false, 0);

		if (game->playButtonWasEnabled)
        {
			ZRolloverButtonEnable(game->playButton);
            gGAcc->SetItemEnabled(true, IDC_PLAY_BUTTON, false, 0);
        }
		if (game->autoPlayButtonWasEnabled)
        {
			ZRolloverButtonEnable(game->autoPlayButton);
            EnableAutoplayAcc(game, true);
        }
		
		/* Swap currenly played cards with the last trick. */
		for (i = 0; i < zNumPlayersPerTable; i++)
		{
			tempCard = game->cardsPlayed[i];
			game->cardsPlayed[i] = game->cardsLastTrick[i];
			game->cardsLastTrick[i] = tempCard;
		}
		
		game->timerType = game->oldTimerType;
		ZTimerSetTimeout(game->timer, game->oldTimeout);
		
		ClearPlayerCardOutline(game, game->leadPlayer);
		UpdateTable(game);

		//leonp - Bug fix Bug# 356 Since we are blocking all messages, this_object will disable the option button
		//(Behavior change)
#ifndef MILL_VER
		ZButtonEnable(game->optionsButton);
#endif
		game->fEndGameBlocked = FALSE;
		ZCRoomUnblockMessages(game->tableID);
	}
	else
	{
		/* Show last trick cards. */
		game->lastTrickShowing = TRUE;
		ZRolloverButtonSetText(game->lastTrickButton, gszString[zDone]);
		ZRolloverButtonDraw(game->lastTrickButton);
        EnableLastTrickAcc(game, true);
        gGAcc->SetFocus(IDC_DONE_BUTTON, false, 0);

		game->playButtonWasEnabled = ZRolloverButtonIsEnabled(game->playButton);
		game->autoPlayButtonWasEnabled = ZRolloverButtonIsEnabled(game->autoPlayButton);
		ZRolloverButtonDisable(game->playButton);
		ZRolloverButtonDisable(game->autoPlayButton);
        gGAcc->SetItemEnabled(false, IDC_PLAY_BUTTON, false, 0);
        EnableAutoplayAcc(game, false);
		
		/* Swap currenly played cards with the last trick. */
		for (i = 0; i < zNumPlayersPerTable; i++)
		{
			tempCard = game->cardsPlayed[i];
			game->cardsPlayed[i] = game->cardsLastTrick[i];
			game->cardsLastTrick[i] = tempCard;
		}
		
		game->oldTimerType = game->timerType;
		game->timerType = zGameTimerNone;
		game->oldTimeout = ZTimerGetTimeout(game->timer);
		ZTimerSetTimeout(game->timer, 0);
		
		ClearPlayerCardOutline(game, game->playerToPlay);
		UpdateTable(game);
		
		//leonp - Bug fix Bug# 356 Since we are blocking all messages, this_object will disable the option button
		//(Behavior change)
#ifndef MILL_VER
		ZButtonDisable(game->optionsButton);
#endif
		ZCRoomBlockMessages(game->tableID, zRoomFilterThisMessage, zHeartsMsgTalk);
	}
	return TRUE;
}


static void GameWindowDraw(ZWindow window, ZMessage *message)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobalsType *)ZGetGameGlobalPointer();
#endif

	ZRect				rect;
	ZRect				oldClipRect;
	Game				game;
	
	
	if (ZRectEmpty(&message->drawRect) == FALSE)
	{
		rect = message->drawRect;
	}
	else
	{
		rect = gRects[zRectWindow];
	}
		
	
	game = (Game) message->userData;
	if (game != NULL)
	{
	    ZBeginDrawing(game->gameBackBuffer);
	    
		ZGetClipRect(game->gameBackBuffer, &oldClipRect);
	    ZSetClipRect(game->gameBackBuffer, &rect);
        
		// we now draw to the backbuffer
        game->gameDrawPort = game->gameBackBuffer;

		DrawBackground( game, window, NULL);	

		DrawTable(game);
		DrawPlayers(game);
		DrawHand(game);
		DrawTricksTaken(game);
		DrawOptions(game);
		DrawJoinerKibitzers(game);
        DrawFocusRect(game);

		ZEndDrawing( game->gameBackBuffer );

        // reset back to window
        game->gameDrawPort = game->gameWindow;
        
		// now blt everythign onto the window using the same clip rectangle
        // since we already clipped things using the back buffer, there is 
        // no need to here.
	    ZBeginDrawing(window);
        
		ZCopyImage( game->gameBackBuffer, game->gameWindow, &rect, &rect, NULL, zDrawCopy );

		ZEndDrawing(window);
	}

}


static void DrawBackground(Game game, ZWindow window, ZRect* drawRect)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobalsType *)ZGetGameGlobalPointer();
#endif

	
	if (drawRect == NULL)
		drawRect = &gRects[zRectWindow];

	/* Paint the background. */
	if (gBackground != NULL)
	{
		ZPoint pt;
		pt.x = drawRect->left;
		pt.y = drawRect->top;
		// Since changing from a brush background to a bitmap background, it
		// required taking into account the source of the bitmap when updating
		// the background, so ZImageDrawPartial() function was added which
		// can specify the source coordinates to blit from as the last 
		// parameter (ZPoint struct ptr).
		ZImageDrawPartial(gBackground,  game ? game->gameDrawPort : window, drawRect, NULL, zDrawCopy, &pt);

		// uncomment these lines to see rects drawn around background updates
#ifndef MILL_VER
		ZSetForeColor(game ? game->gameDrawPort : window, (ZColor*) ZGetStockObject(zObjectColorBlack));
		ZRectDraw( game ? game->gameDrawPort : window, drawRect);
#endif

	}
	else
		ZRectErase( game ? game->gameDrawPort : window, drawRect);

}


static void DrawTable(Game game)
{

	int16			i;
	ZImage			image = NULL;
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobalsType *)ZGetGameGlobalPointer();
#endif

	
	
	if (game->animatingTrickWinner)
	{
		UpdateTrickWinner(game, FALSE);
	}
	else
	{
		if (game->gameState == zGameStatePassCards)
		{
			for (i = 0; i < zNumPlayersPerTable; i++)
				DrawPlayedCard(game, i);
	
			DrawPassDirection(game);
		}
		else
		{
			for (i = 0; i < zNumPlayersPerTable; i++)
				DrawPlayedCard(game, i);
		}
		
		if (game->showPlayerToPlay)
		{
			/* Show the winner of the last trick (this_object trick's lead player) if showing last trick. */
			if (game->lastTrickShowing)
				OutlinePlayerCard(game, game->leadPlayer, TRUE);
			else
				OutlinePlayerCard(game, game->playerToPlay, FALSE);
		}
	}
	
	DrawSmallPassDirection(game);

	return;
}


static void UpdateTable(Game game)
{
	ZBeginDrawing(game->gameDrawPort);
	DrawTable(game);
	ZEndDrawing(game->gameDrawPort);
}


static void DrawPlayedCard(Game game, int16 seat)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobalsType *)ZGetGameGlobalPointer();
#endif
	ZImage			image = NULL;
	ZBool			drawBack = TRUE;
	
	
	if (game->gameState == zGameStateGameOver)
	{
#ifndef MILL_VER
		if (game->newGameVote[seat])
		{
			image = gGameImages[gNewGameVoteImageIndex[LocalSeat(game, seat)]];
			ZImageDraw(image, game->gameDrawPort, &gRects[gCardRectIndex[LocalSeat(game, seat)]], NULL, zDrawCopy);
			drawBack = FALSE;
		}
#endif
	}
	else
	{
		if (game->cardsPlayed[seat] != zNoCard)
		{
			ZCardsDrawCard(zCardsNormal, CardImageIndex(game->cardsPlayed[seat]),
					game->gameDrawPort, &gRects[gCardRectIndex[LocalSeat(game, seat)]]);
			drawBack = FALSE;
		}
	}
	
	if (drawBack)
		DrawBackground(game, game->gameDrawPort, &gRects[gCardRectIndex[LocalSeat(game, seat)]]);
}


static void UpdatePlayedCard(Game game, int16 seat)
{
	ZBeginDrawing(game->gameDrawPort);
	DrawPlayedCard(game, seat);
	ZEndDrawing(game->gameDrawPort);
}


static void DrawPassDirection(Game game)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobalsType *)ZGetGameGlobalPointer();
#endif

	// it's possible you get a chance to draw between the pass and play messages on a hold hand, in which case the pass direction is -1
	if(game->gameState == zGameStatePassCards && gPassDirImageIndex[game->passDirection] >= 0)
	{
		HDC hdc = ZGrafPortGetWinDC( game->gameDrawPort );
		HFONT hOldFont = SelectObject( hdc, gHeartsFont[zFontPass].m_hFont );
		COLORREF colorOld = SetTextColor( hdc, gHeartsFont[zFontPass].m_zColor );

		ZImageDraw(gGameImages[gPassDirImageIndex[game->passDirection]],
				game->gameDrawPort, &gRects[zRectPassDirection], NULL, zDrawCopy);

        if(game->numCardsInHand == game->numCardsDealt)
        {
		    ZDrawText(game->gameDrawPort, &gRects[zRectPassText], zTextJustifyCenter, gszString[zPassSelect]);
		    switch(game->passDirection)
		    {
		        case 1:
			        ZDrawText(game->gameDrawPort, &gRects[zRectPassText2], zTextJustifyCenter, gszString[zPassLeft]);
			        break;
		        case 2:
			        ZDrawText(game->gameDrawPort, &gRects[zRectPassText2], zTextJustifyCenter, gszString[zPassAcross]);
			        break;
		        case 3:
			        ZDrawText(game->gameDrawPort, &gRects[zRectPassText2], zTextJustifyCenter, gszString[zPassRight]);
			        break;
            }
        }
        else
        {
		    ZDrawText(game->gameDrawPort, &gRects[zRectPassText], zTextJustifyCenter, gszString[zPassWait]);
		    ZDrawText(game->gameDrawPort, &gRects[zRectPassText2], zTextJustifyCenter, gszString[zPassWait2]);
		}
	}
	else
		DrawBackground( game, game->gameDrawPort, &gRects[zRectPassDirection]);
}


static void UpdatePassDirection(Game game)
{
	ZBeginDrawing(game->gameDrawPort);
	DrawPassDirection(game);
	ZEndDrawing(game->gameDrawPort);
}


static void DrawSmallPassDirection(Game game)
{

#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobalsType *)ZGetGameGlobalPointer();
#endif

	
	if (game->gameState == zGameStateWaitForPlay)
		ZImageDraw(gGameImages[gSmallPassDirImageIndex[game->passDirection]],
				game->gameDrawPort, &gRects[zRectPassIndicator], NULL, zDrawCopy);
	else
		DrawBackground(game, game->gameDrawPort, &gRects[zRectPassIndicator]);
}


static void DrawPlayers(Game game)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobalsType *)ZGetGameGlobalPointer();
#endif
	int16			i, width, just;
	TCHAR			tempStr[ZLARGESTRING];
	ZRect			rect;
	
	
	for (i = 0; i < zNumPlayersPerTable; i++)
	{
		rect = gRects[gNameRectIndex[LocalSeat(game, i)]];
		
		// JRB: no need for rectangle around the name now

#ifndef MILL_VER
		ZSetForeColor(game->gameDrawPort, (ZColor*) ZGetStockObject(zObjectColorLightGray));
		ZRectPaint(game->gameDrawPort, &rect);
		
		ZSetForeColor(game->gameDrawPort, (ZColor*) ZGetStockObject(zObjectColorBlack));
		ZRectDraw(game->gameDrawPort, &rect);
#endif

		HDC hdc = ZGrafPortGetWinDC( game->gameDrawPort );
		HFONT hOldFont = SelectObject( hdc, gHeartsFont[zFontPlayers].m_hFont );
		COLORREF colorOld = SetTextColor( hdc, gHeartsFont[zFontPlayers].m_zColor );
		width = ZTextWidth(game->gameDrawPort, game->players[i].name);

		if (width > ZRectWidth(&rect))
			just = zTextJustifyLeft;
		else
			just = zTextJustifyCenter;
		
		// Draw the player name 
		if (game->players[i].userID != 0)
		{
			rect = gRects[gNameRectIndex[LocalSeat(game, i)]];
			DrawBackground(game, game->gameDrawPort, &rect);
			ZDrawText(game->gameDrawPort, &rect, just, game->players[i].name);
		}

		hOldFont = SelectObject( hdc, gHeartsFont[zFontScores].m_hFont );
		colorOld = SetTextColor( hdc, gHeartsFont[zFontScores].m_zColor );

		// Draw the players score below it
		if (game->players[i].userID != 0)
		{
			TCHAR buf[ZLARGESTRING];
			rect = gRects[gPointsRectIndex[LocalSeat(game, i)]];

			_itot(game->players[i].score, buf, 10);
			HeartsFormatMessage(tempStr, ZLARGESTRING, IDS_POINTS_X, buf);

			DrawBackground(game, game->gameDrawPort, &rect);
			ZDrawText(game->gameDrawPort, &rect, zTextJustifyCenter, tempStr);
		}
	}

}


static void UpdatePlayers(Game game)
{
	ZBeginDrawing(game->gameDrawPort);
	DrawPlayers(game);
	ZEndDrawing(game->gameDrawPort);
}


static void UpdateHand(Game game)
{
	ZBeginDrawing(game->gameDrawPort);
	DrawHand(game);
//    DrawFocusRect(game);
	ZEndDrawing(game->gameDrawPort);
}


static void DrawHand(Game game)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobalsType *)ZGetGameGlobalPointer();
#endif
	int16			i;
    int16           j;
	ZRect			rect;
	int16			cardIndex;
	bool            fFrontDrawn;
	
	/* Exit if we don't have cards to display yet. */
	if (game->gameState <= zGameStateWaitForNewHand)
    {
        for(i = zAccHand; i < zAccHand + 13; i++)
            gGAcc->SetItemEnabled(false, i, true, 0);
		return;
	}

	ZBeginDrawing(gHandBuffer);
	
	DrawBackground(NULL, gHandBuffer, &gRects[zRectHand]);
	
	GetHandRect(game, &rect);
	
	rect.top += zCardPopup;
	rect.right = rect.left + zCardWidth;
	
	for (i = 0; i < game->numCardsDealt; i++)
	{
		if (game->cardsInHand[i] != zNoCard)
		{
            fFrontDrawn = false;

			if (game->cardsSelected[i])
				ZRectOffset(&rect, 0, -zCardPopup);
			
            // handle accessibility rect
            RECT rc;
            rc.left = rect.left;
            rc.top = rect.top;
            rc.bottom = rect.bottom;
            rc.right = rect.right;
/*            for(j = i + 1; j < 13; j++)       // only needed for strict rectangles of DrawFocusRect()
                if(game->cardsInHand[j] != zCardNone)
                {
                    rc.right = rc.left + zCardOffset;
                    break;
                }
*/
			if (game->playerType != zGamePlayerKibitzer ||
					(game->playerType == zGamePlayerKibitzer && game->hideCardsFromKibitzer == FALSE))
			{
				cardIndex = CardImageIndex(game->cardsInHand[i]);
				if (cardIndex >= 0 && cardIndex < zHeartsNumCardsInDeck)
					ZCardsDrawCard(zCardsNormal, cardIndex, gHandBuffer,
							&rect);
				else
					ZShellGameShell()->ZoneAlert(ErrorTextUnknown, NULL, NULL, true);
                fFrontDrawn = true;

                if(game->iFocus == zAccHand + i)  // move focus drawing here for non-rectangular shape
                {
		            HDC	hdc = ZGrafPortGetWinDC(gHandBuffer);
		            SetROP2(hdc, R2_MASKPEN);
                    SetBkMode(hdc, TRANSPARENT);
                    COLORREF color = SetTextColor(hdc, RGB(255, 255, 0));
                    HBRUSH hBrush = SelectObject(hdc, gFocusBrush);
                    HPEN hPen = SelectObject(hdc, gFocusPen);
		            Rectangle(hdc, rc.left, rc.top, rc.right, rc.bottom);
                    SelectObject(hdc, hBrush);
                    SelectObject(hdc, hPen);
                    SetTextColor(hdc, color);
		            SetROP2(hdc, R2_COPYPEN);
                }
			}
			else
			{
				ZImageDraw(gGameImages[zImageCardBack], gHandBuffer, &rect, NULL, zDrawCopy);
			}
			
			/* Save card rect. */
			game->cardRects[i] = rect;
			
            // for accessibility, need the whole card space for proper invalidation
            if(game->cardsSelected[i])
                rc.bottom += zCardOffset;
            else
                rc.top -= zCardOffset;

            gGAcc->SetItemRect(&rc, zAccHand + i, true, 0);
            gGAcc->SetItemEnabled(fFrontDrawn, zAccHand + i, true, 0);
            if(fFrontDrawn && game->fSetFocusToHandASAP && !i)
            {
                gGAcc->SetFocus(zAccHand, true, 0);
                game->fSetFocusToHandASAP = false;
            }

			if (game->cardsSelected[i])
				ZRectOffset(&rect, 0, zCardPopup);
				
			ZRectOffset(&rect, zCardOffset, 0);
		}
        else
        {
            gGAcc->SetItemEnabled(false, zAccHand + i, true, 0);
        }
	}
	
	ZCopyImage(gHandBuffer, game->gameDrawPort, &gRects[zRectHand], &gRects[zRectHand], NULL, zDrawCopy);
	
	ZEndDrawing(gHandBuffer);
}


static void DrawFocusRect(Game game)
{
#ifdef ZONECLI_DLL
	GameGlobals pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif

    if(IsRectEmpty(&game->rcFocus))
        return;

    switch(game->eFocusType)
    {
        case zAccRectButton:
        {
		    HDC	hdc = ZGrafPortGetWinDC(game->gameDrawPort);
		    SetROP2(hdc, R2_COPYPEN);
            SetBkMode(hdc, TRANSPARENT);
            HBRUSH hBrush = SelectObject(hdc, GetStockObject(NULL_BRUSH));
            HPEN hPen = SelectObject(hdc, gFocusPen);
		    Rectangle(hdc, game->rcFocus.left, game->rcFocus.top, game->rcFocus.right, game->rcFocus.bottom);
            SelectObject(hdc, hPen);
            SelectObject(hdc, hBrush);
            break;
        }

/*      case zAccRectCard:
        {
		    HDC	hdc = ZGrafPortGetWinDC(game->gameDrawPort);
		    SetROP2(hdc, R2_MASKPEN);
            SetBkMode(hdc, TRANSPARENT);
            COLORREF color = SetTextColor(hdc, RGB(255, 255, 0));
            HBRUSH hBrush = SelectObject(hdc, gFocusBrush);
            HPEN hPen = SelectObject(hdc, gFocusPen);
		    Rectangle(hdc, game->rcFocus.left, game->rcFocus.top, game->rcFocus.right, game->rcFocus.bottom);
            SelectObject(hdc, hBrush);
            SelectObject(hdc, hPen);
            SetTextColor(hdc, color);
		    SetROP2(hdc, R2_COPYPEN);
            break;
        }
*/  }
}


static void UpdateTricksTaken(Game game)
{
#ifndef MILL_VER

	ZBeginDrawing(game->gameDrawPort);
	DrawTricksTaken(game);
	ZEndDrawing(game->gameDrawPort);
#endif
}


static void DrawTricksTaken(Game game)
{
#ifndef MILL_VER

#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobalsType *)ZGetGameGlobalPointer();
#endif
	int16			i;
	char			tempStr[32];
	ZRect			rect;
	

	ZSetForeColor(game->gameDrawPort, (ZColor*) ZGetStockObject(zObjectColorBlack));
	
	for (i = 0; i < zNumPlayersPerTable; i++)
	{
		if (game->numTricksTaken[i] > 0)
		{
			ZImageDraw(gGameImages[zImageTricksTaken], game->gameDrawPort,
					&gRects[gTricksRectIndex[LocalSeat(game, i)]], NULL, zDrawCopy);
	
			wsprintf(tempStr, "%d", game->numTricksTaken[i]);
			ZSetRect(&rect, 0, 0, ZTextWidth(game->gameDrawPort, tempStr),
					ZTextHeight(game->gameDrawPort, tempStr));
			ZCenterRectToRect(&rect, &gRects[gTricksRectIndex[LocalSeat(game, i)]], zCenterBoth);
			ZDrawText(game->gameDrawPort, &rect, zTextJustifyCenter, tempStr);
		}
		else
		{
			DrawBackground(game, game->gameDrawPort, &gRects[gTricksRectIndex[LocalSeat(game, i)]]);
		}
	}
#endif

}


static void DrawJoinerKibitzers(Game game)
{
#ifndef MILL_VER

#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobalsType *)ZGetGameGlobalPointer();
#endif
	int16			i, j;
	

	for (i = 0; i < zNumPlayersPerTable; i++)
	{
		j = 0;
		if (game->numKibitzers[i] > 0)
			ZImageDraw(gGameImages[zImageKibitzer], game->gameDrawPort,
					&gRects[gJoinerKibitzerRectIndex[LocalSeat(game, i)][j++]], NULL, zDrawCopy);
		if (game->playersToJoin[i] != 0)
			ZImageDraw(gGameImages[zImageJoiner], game->gameDrawPort,
					&gRects[gJoinerKibitzerRectIndex[LocalSeat(game, i)][j++]], NULL, zDrawCopy);
		while (j <= 1)
			DrawBackground(game, game->gameDrawPort,
					&gRects[gJoinerKibitzerRectIndex[LocalSeat(game, i)][j++]]);
	}
#endif
}


static void UpdateJoinerKibitzers(Game game)
{
#ifndef MILL_VER

	ZBeginDrawing(game->gameDrawPort);
	DrawJoinerKibitzers(game);
	ZEndDrawing(game->gameDrawPort);
#endif
}


static void DrawOptions(Game game)
{
#ifndef MILL_VER

#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobalsType *)ZGetGameGlobalPointer();
#endif
	int16			i, j;
	uint32			tableOptions;
	

	tableOptions = 0;
	for (i = 0; i < zNumPlayersPerTable; i++)
		tableOptions |= game->tableOptions[i];
	
	j = 0;
	if (tableOptions & zRoomTableOptionNoKibitzing)
		ZImageDraw(gGameImages[zImageNoKibitzer], game->gameDrawPort,
				&gRects[gOptionsRectIndex[j++]], NULL, zDrawCopy);
	if (tableOptions & zRoomTableOptionNoJoining)
		ZImageDraw(gGameImages[zImageNoJoiner], game->gameDrawPort,
				&gRects[gOptionsRectIndex[j++]], NULL, zDrawCopy);
	while (j <= 1)
		DrawBackground(game, game->gameDrawPort, &gRects[gOptionsRectIndex[j++]]);
#endif

}


static void UpdateOptions(Game game)
{
#ifndef MILL_VER

	ZBeginDrawing(game->gameDrawPort);
	DrawOptions(game);
	ZEndDrawing(game->gameDrawPort);
#endif
}


static void NewGame(Game game)
{
	int16			i, j;
	
	
	/* Clear scores. */
	for (i = 0; i < zNumPlayersPerTable; i++)
	{
		game->players[i].score = 0;
		game->newGameVote[i] = FALSE;
	}
	
    /* Clear score history */
    for (i = 0; i < game->numScores; i++)
		for (j = 0; j < zNumPlayersPerTable; j++)
            game->scoreHistory[i*zNumPlayersPerTable+j] = 0;
	
	game->numHandsPlayed = 0;

    UpdateScoreHistoryDialogScores( game );
}


static void NewHand(Game game)
{
	int16			i;
	
	
	/* Initialize new hand. */
	for (i = 0; i < game->numCardsDealt; i++)
	{
		game->cardsInHand[i] = zNoCard;
		game->cardsSelected[i] = FALSE;
	}
	
	for (i = 0; i < zNumPlayersPerTable; i++)
	{
		game->cardsPlayed[i] = zNoCard;
		game->cardsLastTrick[i] = zNoCard;
		game->numTricksTaken[i] = 0;
        game->passed[i] = FALSE;
	}
	
	for (i = 0; i < game->numCardsToPass; i++)
		game->cardsReceived[i] = zNoCard;
		
	game->numCardsInHand = game->numCardsDealt;
	
	game->pointsBroken = FALSE;
	game->lastClickedCard = zNoCard;
	game->lastTrickShowing = FALSE;
}


static void ClearTable(Game game)
{
	int16			i;
	
	
	for (i = 0; i < zNumPlayersPerTable; i++)
	{
		game->cardsPlayed[i] = zNoCard;
		ClearPlayerCardOutline(game, i);
	}
	
	UpdateTable(game);
}


static void GetHandRect(Game game, ZRect *rect)
{
	int16			width;
	
	
	*rect = gRects[zRectHand];
	if (game->numCardsInHand > 0)
	{
		width = (game->numCardsInHand - 1) * zCardOffset + zCardWidth;
		rect->left = (rect->right + rect->left - width) / 2;
		rect->right = rect->left + width;
	}
}


static void HandleButtonDown(ZWindow window, ZMessage* pMessage)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobalsType *)ZGetGameGlobalPointer();
#endif

	Game				game;
	ZPoint				point;
	ZRect				handRect;
	int16				card;
	int16				seat;
	
	
	game = (Game) pMessage->userData;
	if (game != NULL)
	{

		// make any mouse click on game board act as if the user has hit the done button
		// when the last trick is shown. Users were having a hard time seeing that the last trick button
		// had changed to Done button.
		if(game->lastTrickShowing)
		{
			LastTrickButtonFunc(NULL, zRolloverButtonClicked, game);
			return;
		}

		point = pMessage->where;

		/* Debugging Code Begin */
		/* Check if double click occurred in the rectangle. */
//		ZSetRect(&handRect, 0, 0, 8, 8);
//		if (pMessage->messageType == zMessageWindowButtonDoubleClick &&
//				ZPointInRect(&point, &handRect))
//			ZCRoomSendMessage(game->tableID, zHeartsMsgDumpHand, NULL, 0);
		/* Debugging Code End */
		
		/* If trick winner animation is on, terminate it. */
		if (game->animatingTrickWinner)
			UpdateTrickWinner(game, TRUE);
		
		if (game->playerType == zGamePlayer)
		{
			/* Deselect passed cards, if any. */
			if (game->gameState == zGameStateWaitForPlay &&
					game->numCardsInHand == game->numCardsDealt &&
					GetNumCardsSelected(game) == game->numCardsToPass)
			{
				UnselectCards(game);
				UpdateHand(game);
			}
			
			GetHandRect(game, &handRect);
			if (ZPointInRect(&point, &handRect))
			{
				/* Play card if double-clicked and not auto-play. */
				if (game->gameState == zGameStateWaitForPlay &&
						pMessage->messageType == zMessageWindowButtonDoubleClick &&
						game->playerToPlay == game->seat &&
						game->autoPlay == FALSE &&
						game->animatingTrickWinner == FALSE &&
						game->lastTrickShowing == FALSE &&
						game->lastClickedCard != zNoCard)
				{
					PlayACard(game, game->lastClickedCard);
				}
				else
				{
					card = GetCardIndex(game, &point);
					if (card != zNoCard)
					{
						if (game->cardsSelected[card])
						{
							game->cardsSelected[card] = FALSE;
						}
						else
						{
							if (game->gameState == zGameStateWaitForPlay)
								UnselectCards(game);
							game->cardsSelected[card] = TRUE;
						}
						
						game->lastClickedCard = card;
						gGAcc->SetFocus(zAccHand + card, true, 0);
						UpdateHand(game);
					}
					else
					{
						game->lastClickedCard = zNoCard;
					}
				}
			}
		}
		if ((seat = FindJoinerKibitzerSeat(game, &point)) != -1)
		{
			HandleJoinerKibitzerClick(game, seat, &point);
		}
	}
}


static int16 GetCardIndex(Game game, ZPoint *point)
{
	int16			i;
	int16			selectedCard = zNoCard;
	
	
	for (i = game->numCardsDealt - 1; i >= 0 ; i--)
	{
		if (game->cardsInHand[i] != zNoCard)
			if (ZPointInRect(point, &game->cardRects[i]))
			{
				selectedCard = i;
				break;
			}
	}
	
	return (selectedCard);
}


static void UnselectCards(Game game)
{
	int16			i;
	
	
	for (i = 0; i < game->numCardsDealt; i++)
		game->cardsSelected[i] = 0;
}


static int16 GetNumCardsSelected(Game game)
{
	int16			i, count;
	
	
	for (i = 0, count = 0; i < game->numCardsDealt; i++)
		if (game->cardsInHand[i] != zNoCard)
			if (game->cardsSelected[i])
				count++;
	
	return (count);
}


static int16 ReceivePassFrom(Game game)
{
	int16		delta;
	
	
	if (game->passDirection == zHeartsPassLeft)
		delta = 3;
	else if (game->passDirection == zHeartsPassRight)
		delta = 1;
	else if (game->passDirection == zHeartsPassAcross)
		delta = 2;
	else
		delta = 0;
	
	return ((game->seat + delta) % zNumPlayersPerTable);
}


static void AddCardToHand(Game game, ZCard card)
{
	int16		i;
	
	
	/* Find an empty slot in the hand and add the card. */
	for (i = 0; i < game->numCardsDealt; i++)
		if (game->cardsInHand[i] == zNoCard)
		{
			game->cardsInHand[i] = card;
			game->numCardsInHand++;
			break;
		}
}


static void SortHand(Game game)
{
	int16			i;
	ZCard			temp;
	ZBool			swapped;
	
	
	/* Simple bubble-sort. */
	swapped = TRUE;
	while (swapped == TRUE)
	{
		swapped = FALSE;
		for (i = 0; i < game->numCardsDealt - 1; i++)
			if (game->cardsInHand[i] > game->cardsInHand[i + 1])
			{
				/* Swap cards. */
				temp = game->cardsInHand[i + 1];
				game->cardsInHand[i + 1] = game->cardsInHand[i];
				game->cardsInHand[i] = temp;
				
				swapped = TRUE;
			}
	}
}


static int16 GetCardIndexFromRank(Game game, ZCard card)
{
	int16		i;
	
	
	/* Search for the given card in the hand. */
	for (i = 0; i < game->numCardsDealt; i++)
		if (game->cardsInHand[i] == card)
			return (i);
	
	return (zNoCard);
}


static void GameSendTalkMessage(ZWindow window, ZMessage* pMessage)
{
	ZHeartsMsgTalk*			msgTalk;
	Game					game;
	int16					msgLen;
	ZPlayerInfoType			playerInfo;
	
	
	game = (Game) pMessage->userData;
	if (game != NULL)
	{
		
		//	Check if kibitzer has been silenced.
		
		if (game->playerType == zGamePlayerKibitzer && game->kibitzersSilenced)
		{
			if (game->kibitzersSilencedWarned == FALSE)
			{
				ZShellGameShell()->ZoneAlert(zKibitzersSilencedStr);
				game->kibitzersSilencedWarned = TRUE;
			}
			return;
		}
		
		msgLen = sizeof(ZHeartsMsgTalk) + pMessage->messageLen;
		msgTalk = (ZHeartsMsgTalk*) ZCalloc(1, msgLen);
		if (msgTalk != NULL)
		{
			ZCRoomGetPlayerInfo(zTheUser, &playerInfo);
			msgTalk->userID = playerInfo.playerID;
			msgTalk->seat = (game->playerType == zGamePlayerKibitzer ? -1 : game->seat);
			msgTalk->messageLen = (int16) pMessage->messageLen;
			z_memcpy((char*) msgTalk + sizeof(ZHeartsMsgTalk), (char*) pMessage->messagePtr,
					pMessage->messageLen);
			ZHeartsMsgTalkEndian(msgTalk);
			ZCRoomSendMessage(game->tableID, zHeartsMsgTalk, (void*) msgTalk, msgLen);
			ZFree((char*) msgTalk);
		}
		else
		{
			ZShellGameShell()->ZoneAlert(ErrorTextOutOfMemory);
		}
	}
}


STDMETHODIMP CGameGameHearts::SendChat(TCHAR *szText, DWORD cchChars)
{
#ifdef ZONECLI_DLL
    GameGlobals pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif

    ZHeartsMsgTalk*		msgTalk;
    Game				game = (Game) GetGame();
    int16				msgLen;

    msgLen = sizeof(ZHeartsMsgTalk) + cchChars * sizeof(TCHAR);
    msgTalk = (ZHeartsMsgTalk*) ZCalloc(1, msgLen);
    if (msgTalk != NULL)
    {
        msgTalk->userID = game->userID;
        msgTalk->messageLen = (WORD) cchChars * sizeof(TCHAR);
        CopyMemory((BYTE *) msgTalk + sizeof(ZHeartsMsgTalk), (void *) szText,
            msgTalk->messageLen);
        ZHeartsMsgTalkEndian(msgTalk);
        ZCRoomSendMessage(game->tableID, zHeartsMsgTalk, (void*) msgTalk, msgLen);
        ZFree((char*) msgTalk);
        return S_OK;
    }
    else
    {
        return E_OUTOFMEMORY;
    }
}


STDMETHODIMP CGameGameHearts::GameOverReady()
{
    // user selected "Play Again"
	Game game = I( GetGame() );
	ZHeartsMsgNewGame msg;
	msg.seat = game->seat;
	ZHeartsMsgNewGameEndian(&msg);
	ZCRoomSendMessage(game->tableID, zHeartsMsgNewGame, &msg, sizeof(ZHeartsMsgNewGame));
    return S_OK;
}


STDMETHODIMP_(HWND) CGameGameHearts::GetWindowHandle()
{
	Game game = I( GetGame() );
	return ZWindowGetHWND(game->gameWindow);
}


STDMETHODIMP CGameGameHearts::ShowScore()
{
    ShowScores(I(GetGame()));

    return S_OK;
}


static void GameTimerFunc(ZTimer timer, void* userData)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobalsType *)ZGetGameGlobalPointer();
#endif

	Game			game = (Game) userData;
	

	switch (game->timerType)
	{
		case zGameTimerShowPlayer:
			//dossier
							
			ZBeginDrawing(game->gameDrawPort);
			// JRB: remove blinking card
			//if (game->backFaceShowing)
			//{
				/* Erase backface. */
			//	DrawBackground(game->gameDrawPort, &gRects[gCardRectIndex[LocalSeat(game, game->playerToPlay)]]);
			//	ZTimerSetTimeout(game->timer, zHideTimeout);
			//}
			//else
			//{
				/* Draw backface. */
			//DrawCardBackFace(game, &gRects[gCardRectIndex[LocalSeat(game, game->playerToPlay)]]);
			//	ZTimerSetTimeout(game->timer, zShowTimeout);
			//}

			//if(!game->fVotingLock)  //don't blink cards during voting.
			//	game->backFaceShowing = !game->backFaceShowing;
				
			ZEndDrawing(game->gameDrawPort);
			break;
		case zGameTimerShowHandScore:
			ZWindowHide(game->handScoreWindow);
            AccPop();
            game->fSetFocusToHandASAP = true;
			UpdateTable(game);
			UpdatePlayers(game);
			UpdateHand(game);
			
			/* Stop the timer for now. */
			game->timerType = zGameTimerNone;
			ZTimerSetTimeout(game->timer, 0);
			
			game->fEndGameBlocked = FALSE;
			ZCRoomUnblockMessages(game->tableID);

			break;
		case zGameTimerShowGameScore:
			ZWindowNonModal(game->gameScoreWindow);
			ZWindowHide(game->gameScoreWindow);

            AccPop();
            game->fSetFocusToHandASAP = true;

			ZBeginDrawing(game->gameDrawPort);
			DrawBackground(game, game->gameDrawPort, NULL);
			ZEndDrawing(game->gameDrawPort);

			game->timerType = zGameTimerNone;
			ZTimerSetTimeout(game->timer, 0);
			game->fEndGameBlocked = FALSE;
			ZCRoomUnblockMessages(game->tableID);

			if(game->playerType == zGamePlayer && !game->nCloseRequested && !game->quitGamePrompted)
			{
				/* Prompt the user for another game. */
#ifndef MILL_VER
				ZPrompt(zNewGamePromptStr, &gGameNewGameWindowRect, game->gameWindow, TRUE,
						zPromptYes | zPromptNo, NULL, NULL, NULL, NewGamePromptFunc, game);
#endif
			}
			else
			{
				game->fNeedNewGameConf = TRUE;
			}

			ZShellGameShell()->GameOver(Z(game));

			break;
		case zGameTimerShowTrickWinner:
			game->timerType = zGameTimerAnimateTrickWinner;
			ZTimerSetTimeout(game->timer, zTrickWinnerTimeout);
			UpdateTrickWinner(game, FALSE);
			break;
		case zGameTimerAnimateTrickWinner:
			UpdateTrickWinner(game, FALSE);
			break;
		case zGameTimerEndTrickWinnerAnimation:
			game->timerType = zGameTimerShowPlayer;
			ZTimerSetTimeout(game->timer, zShowTimeout);

			game->animatingTrickWinner = FALSE;
			
			if (game->playButtonWasEnabled)
            {
				ZRolloverButtonEnable(game->playButton);
                gGAcc->SetItemEnabled(true, IDC_PLAY_BUTTON, false, 0);
            }
			if (game->lastTrickButtonWasEnabled)
            {
				ZRolloverButtonEnable(game->lastTrickButton);
                EnableLastTrickAcc(game, true);
            }

			ClearTable(game);
			UpdateTricksTaken(game);

			OutlinePlayerCard(game, game->playerToPlay, FALSE);

			if (game->numCardsInHand > 0 && game->playerToPlay == game->seat)
			{
				if (game->autoPlay)
				{
					AutoPlayCard(game);
				}
				else
				{
					ZRolloverButtonEnable(game->playButton);
                    gGAcc->SetItemEnabled(true, IDC_PLAY_BUTTON, false, 0);
					if (game->beepOnTurn)
                    {
						ZBeep();
                        ZShellGameShell()->MyTurn();
                    }
				}
			}
			else
			{
				ZRolloverButtonDisable(game->playButton);
                gGAcc->SetItemEnabled(false, IDC_PLAY_BUTTON, false, 0);
			}

			game->fEndGameBlocked = FALSE;
			ZCRoomUnblockMessages(game->tableID);
			break;
	}
}


static void DrawCardBackFace(Game game, ZRect* rect)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobalsType *)ZGetGameGlobalPointer();
#endif

	
	ZImageDraw(gGameImages[zImageCardBack], game->gameDrawPort, rect, NULL, zDrawCopy);
}


static void PlayACard(Game game, int16 cardIndex)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobalsType *)ZGetGameGlobalPointer();
#endif
	ZHeartsMsgPlayCard		playMsg;
	ZCard					card;
	TCHAR					tempStr[255];
	ZError					err;

	//dossier work - if ratings are on and we are waiting for the users to vote
	//don't allow them to play anymore.
	if(game->fVotingLock) 
		return;
    
	card = game->cardsInHand[cardIndex];
	if ((err = ValidCardToPlay(game, card)) == zErrNone)
	{
		game->cardsInHand[cardIndex] = zNoCard;
		game->numCardsInHand--;
		
		playMsg.seat = game->seat;
		playMsg.card = card;
		ZHeartsMsgPlayCardEndian(&playMsg);
		ZCRoomSendMessage(game->tableID, zHeartsMsgPlayCard, (void*) &playMsg,
				sizeof(ZHeartsMsgPlayCard));
		
		UpdateHand(game);
		
		PlayerPlayedCard(game, game->seat, card);
		
		game->lastClickedCard = zNoCard;
	}
	else
	{
        UpdateHand(game);
		ZShellGameShell()->ZoneAlert(gValidCardErrStr[err]);
	}
}


static void AutoPlayCard(Game game)
{
	int16					cardIndex;

	
	cardIndex = GetAutoPlayCard(game);
	PlayACard(game, cardIndex);
}


static void InitTrickWinnerGlobals(void)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobalsType *)ZGetGameGlobalPointer();
#endif
	int16			diffs[zNumAnimFrames] = { 0, 5, 15, 35, 65, 85, 95, 100};
	int16			i, j, k;
	ZPoint			winner, losers[zNumPlayersPerTable];


	for (k = 0; k < zNumPlayersPerTable; k++)
	{
		winner.x = gRects[gCardRectIndex[k]].left;
		winner.y = gRects[gCardRectIndex[k]].top;
		for (i = 0, j = 0; i < zNumPlayersPerTable; i++)
		{
			losers[j].x = gRects[gCardRectIndex[i]].left;
			losers[j].y = gRects[gCardRectIndex[i]].top;
			j++;
		}
		
		/* Calculate rectangle frame positions. */
		for (i = 0; i < zNumPlayersPerTable; i++)
		{
			gTrickWinnerPos[k][i][0] = losers[i];
			gTrickWinnerPos[k][i][zNumAnimFrames - 1] = winner;
			
			for (j = 1; j < zNumAnimFrames - 1; j++)
			{
				gTrickWinnerPos[k][i][j].x = ((winner.x - losers[i].x) * diffs[j]) /
						100 + losers[i].x;
				gTrickWinnerPos[k][i][j].y = ((winner.y - losers[i].y) * diffs[j]) /
						100 + losers[i].y;
			}
		}
	}

	gTrickWinnerBounds = gRects[zRectTable];
}


static void InitTrickWinner(Game game, int16 trickWinner)
{
	int16			i, j;
	
	
	game->trickWinner = trickWinner;
	game->trickWinnerFrame = 0;
	game->animatingTrickWinner = TRUE;
	
	/* Initialize the ghost frames. */
	for (i = 0; i < zNumAnimGhostFrames; i++)
		for (j = 0; j < zNumPlayersPerTable - 1; j++)
			ZSetRect(&game->ghostFrames[j][i], 0, 0, 0, 0);

	game->winnerRect = gRects[gCardRectIndex[LocalSeat(game, trickWinner)]];
	for (i = 0, j = 0; i < zNumPlayersPerTable; i++)
		if (i != game->trickWinner)
		{
			game->loserRects[j] = gRects[gCardRectIndex[LocalSeat(game, i)]];
			game->loserSeats[j++] = i;
		}
}


static void UpdateTrickWinner(Game game, ZBool terminate)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobalsType *)ZGetGameGlobalPointer();
#endif
	int16			i, j, k;
	ZOffscreenPort	animPort;
	

	if (game->animatingTrickWinner)
	{	
		animPort = ZOffscreenPortNew();
		ZOffscreenPortInit(animPort, &gTrickWinnerBounds);
		
		ZBeginDrawing(animPort);
		
		/* Erase the background. */
		DrawBackground( NULL, animPort, &gTrickWinnerBounds);

		ZColor color;
		color.red = 255;
		color.green = 255;
		color.blue = 204;

		if (ZCRoomGetNumBlockedMessages(game->tableID) < zMaxNumBlockedMessages &&
				terminate == FALSE && game->animateCards == TRUE)
		{
			if ((i = game->trickWinnerFrame) < zNumAnimFrames)
			{
				/* Draw n-1 ghost frames. */
				for (j = 1; j < zNumAnimGhostFrames; j++)
					for (k = 0; k < zNumPlayersPerTable - 1; k++)
						ZCardsDrawCard(zCardsNormal, CardImageIndex(game->cardsPlayed[game->loserSeats[k]]),
								animPort, &game->ghostFrames[k][j]);
				
				/* Draw new frames. */
				for (j = 0; j < zNumPlayersPerTable - 1; j++)
				{
					ZRectOffset(&game->loserRects[j],
							gTrickWinnerPos[LocalSeat(game, game->trickWinner)][LocalSeat(game, game->loserSeats[j])][i].x - game->loserRects[j].left,
							gTrickWinnerPos[LocalSeat(game, game->trickWinner)][LocalSeat(game, game->loserSeats[j])][i].y - game->loserRects[j].top);
					ZCardsDrawCard(zCardsNormal, CardImageIndex(game->cardsPlayed[game->loserSeats[j]]),
							animPort, &game->loserRects[j]);
				}
				
				/* Copy frames. */
				for (j = 0; j < zNumPlayersPerTable - 1; j++)
				{
					for (k = 0; k < zNumAnimGhostFrames - 1; k++)
						game->ghostFrames[j][k] = game->ghostFrames[j][k + 1];
					game->ghostFrames[j][k] = game->loserRects[j];
				}
			}
			else
			{	
				/* Bring in the ghost frames. */
		
				/* Draw n-1 ghost frames. */
				for (j = i; j < zNumAnimGhostFrames; j++)
					for (k = 0; k < zNumPlayersPerTable - 1; k++)
						ZCardsDrawCard(zCardsNormal, CardImageIndex(game->cardsPlayed[game->loserSeats[k]]),
								animPort, &game->ghostFrames[k][j]);
			}
		}
		else
		{
			game->trickWinnerFrame = zNumAnimFrames + zNumAnimGhostFrames;
		}
		
		ZCardsDrawCard(zCardsNormal, CardImageIndex(game->cardsPlayed[game->trickWinner]),
				animPort, &game->winnerRect);
	
		OutlineCard(animPort, &game->winnerRect, &color);

		ZEndDrawing(animPort);
	
		ZCopyImage(animPort, game->gameDrawPort, &gTrickWinnerBounds, &gTrickWinnerBounds,
				NULL, zDrawCopy);
		ZOffscreenPortDelete(animPort);
		
		game->trickWinnerFrame++;
		if (game->trickWinnerFrame >= zNumAnimFrames + zNumAnimGhostFrames)
		{
			game->timerType = zGameTimerEndTrickWinnerAnimation;
			ZTimerSetTimeout(game->timer, zEndTrickWinnerTimeout);
		}
	}
}


static void HandleStartGameMessage(Game game, ZHeartsMsgStartGame* msg)
{  
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobalsType *)ZGetGameGlobalPointer();
#endif

	int16				i;
	ZPlayerInfoType		playerInfo;

	
	ZShellGameShell()->GameOverGameBegun(Z(game));

	ZInfoHide(game->gameInfo);

	ZHeartsMsgStartGameEndian(msg);

// Message verification
    for(i = 0; i < zNumPlayersPerTable; i++)
        if(!msg->players[i] || msg->players[i] == zTheUser)
            break;

    if(i != zNumPlayersPerTable || msg->numCardsInHand != 13 || msg->numCardsInPass != 3 ||
        msg->numPointsInGame != 100 || msg->gameOptions || (game->gameState != zGameStateInited && game->gameState != zGameStateGameOver))
    {
        ASSERT(!"HandleStartGameMessage sync");
        ZShellGameShell()->ZoneAlert(ErrorTextSync, NULL, NULL, true, false);
        return;
    }
// end verification
	
	game->numCardsDealt = msg->numCardsInHand;
	game->numCardsToPass = msg->numCardsInPass;
	game->gameState = zGameStateWaitForNewHand;
	
	for (i = 0; i < zNumPlayersPerTable; i++)
	{
		ZCRoomGetPlayerInfo(msg->players[i], &playerInfo);

        if(!playerInfo.userName[0])
        {
            ASSERT(!"HandleStartGameMessage sync");
            ZShellGameShell()->ZoneAlert(ErrorTextSync, NULL, NULL, true, false);
            return;
        }

		game->players[i].userID = playerInfo.playerID;
		game->players[i].score = 0;
		lstrcpy(game->players[i].name, playerInfo.userName);
		lstrcpy(game->players[i].host, playerInfo.hostName);
	}

	

	NewGame(game);
	
	if (game->playerType != zGamePlayerKibitzer)
	{
		ZRolloverButtonShow(game->playButton);
		ZRolloverButtonShow(game->autoPlayButton);
		ZRolloverButtonShow(game->lastTrickButton);
		ZRolloverButtonShow(game->scoreButton);
		ZRolloverButtonEnable(game->scoreButton);
#ifndef MILL_VER
		ZButtonShow(game->optionsButton);
#endif

        gGAcc->SetItemEnabled(true, IDC_SCORE_BUTTON, false, 0);
	}
	
	ZWindowDraw(game->gameWindow, NULL);

	if(game->playerType != zGamePlayer)
		return;
	
	//leonp - dossier work.
	for(i=0;i<zNumPlayersPerTable;i++)
	{
		game->rgDossierVote[i] = zNotVoted;
		game->voteMap[i] = -1;
	}
	game->fVotingLock = FALSE;

}


static void HandleReplacePlayerMessage(Game game, ZHeartsMsgReplacePlayer* msg)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobalsType *)ZGetGameGlobalPointer();
#endif
	ZPlayerInfoType		playerInfo;
	TCHAR				str[ZLARGESTRING];
	
	ZHeartsMsgReplacePlayerEndian(msg);

	ZCRoomGetPlayerInfo(msg->playerID, &playerInfo);

// Message verification
    if(msg->playerID == 0 || msg->playerID == zTheUser || !playerInfo.userName[0] || msg->seat < 0 || msg->seat > 3 ||
        game->gameState == zGameStateInited || game->gameState == zGameStateNotInited)
    {
        ASSERT(!"HandleReplacePlayerMessage sync");
        ZShellGameShell()->ZoneAlert(ErrorTextSync, NULL, NULL, true, false);
        return;
    }
// end verification

	game->players[msg->seat].userID = msg->playerID;
	lstrcpy(game->players[msg->seat].name, playerInfo.userName);
	lstrcpy(game->players[msg->seat].host, playerInfo.hostName);
	
	UpdatePlayers(game);
	UpdateJoinerKibitzers(game);
    UpdateScoreHistoryDialogNames( game );
}


static void HandleStartHandMessage(Game game, ZHeartsMsgStartHand* msg)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobalsType *)ZGetGameGlobalPointer();
#endif
    int16 i, j;
	
	
	ZHeartsMsgStartHandEndian(msg);
	
	NewHand(game);

// Message verification
    for(i = 0; i < game->numCardsDealt && i < zHeartsMaxNumCardsInHand; i++)
    {
        if(msg->cards[i] < 0 || msg->cards[i] >= 52)
            break;
        for(j = 0; j < i; j++)
            if(msg->cards[i] == msg->cards[j])
                break;
        if(j != i)
            break;
    }
    if(game->passDirection < 0 || game->passDirection > 3 || i < 13 ||
        (game->gameState != zGameStateWaitForNewHand && game->gameState != zGameStateHandOver))
    {
        ASSERT(!"HandleStartHandMessage sync");
        ZShellGameShell()->ZoneAlert(ErrorTextSync, NULL, NULL, true, false);
        return;
    }
// end verification

	game->passDirection = msg->passDir;
	for (i = 0; i < game->numCardsDealt; i++)
		game->cardsInHand[i] = msg->cards[i];
	game->numCardsInHand = game->numCardsDealt;
	
	game->gameState = zGameStatePassCards;
	
	if (game->playerType == zGamePlayer)
	{
		if (game->passDirection != zHeartsPassHold)
        {
			ZRolloverButtonSetText(game->playButton, gszString[zPass]);
            ZShellGameShell()->MyTurn();
        }
		
		ZRolloverButtonEnable(game->playButton);
        gGAcc->SetItemEnabled(true, IDC_PLAY_BUTTON, false, 0);
	}

    ZRolloverButtonEnable(game->scoreButton);
    gGAcc->SetItemEnabled(true, IDC_SCORE_BUTTON, false, 0);
	
	ZWindowDraw(game->gameWindow, NULL);
}


static void HandleStartPlayMessage(Game game, ZHeartsMsgStartPlay* msg)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobalsType *)ZGetGameGlobalPointer();
#endif
	int16			i;
	
	
	ZHeartsMsgStartPlayEndian(msg);

    // do this first which has nothing to do with the message but helps verification
	if (game->passDirection != zHeartsPassHold)
	{
		if (game->playerType == zGamePlayerKibitzer)
		{
			/* Remove selected pass cards first. */
			for (i = 0; i < game->numCardsDealt; i++)
				if (game->cardsSelected[i])
				{
					game->cardsInHand[i] = zNoCard;
					game->numCardsInHand--;
				}
		}
		
		/* Add passed cards to hand. */
		for (i = 0; i < game->numCardsToPass; i++)
			AddCardToHand(game, game->cardsReceived[i]);
		
		/* Sort new hand. */
		SortHand(game);
		
		/* Select passed cards. */
		UnselectCards(game);
		for (i = 0; i < game->numCardsToPass; i++)
			game->cardsSelected[GetCardIndexFromRank(game, game->cardsReceived[i])] = TRUE;

		UpdateHand(game);
	}

// Message verification
    for(i = 0; i < 13; i++)
        if(game->cardsInHand[i] == zCard2C)
            break;

    if(msg->seat < 0 || msg->seat > 3 || (i < 13) != (msg->seat == game->seat) ||
        game->gameState != zGameStatePassCards || (game->cardsReceived[0] == zCardNone) != (game->passDirection == zHeartsPassHold))
    {
        ASSERT(!"HandleStartPlayMessage sync");
        ZShellGameShell()->ZoneAlert(ErrorTextSync, NULL, NULL, true, false);
        return;
    }
// end verification

	game->leadPlayer = game->playerToPlay = msg->seat;
	game->gameState = zGameStateWaitForPlay;
	
	if (game->playerType == zGamePlayer)
	{
		ZRolloverButtonSetText(game->playButton, gszString[zPlay]);
		if (game->playerToPlay == game->seat)
        {
			ZRolloverButtonEnable(game->playButton);
            gGAcc->SetItemEnabled(true, IDC_PLAY_BUTTON, false, 0);

            ZShellGameShell()->MyTurn();
        }
		else
        {
			ZRolloverButtonDisable(game->playButton);
            gGAcc->SetItemEnabled(false, IDC_PLAY_BUTTON, false, 0);
        }
		ZRolloverButtonEnable(game->autoPlayButton);
        EnableAutoplayAcc(game, true);
	}
	
	ZWindowDraw(game->gameWindow, NULL);
	
	game->showPlayerToPlay = TRUE;
	game->timerType = zGameTimerShowPlayer;
	ZTimerSetTimeout(game->timer, zHideTimeout);
	
	OutlinePlayerCard(game, game->playerToPlay, FALSE);
		
	if (game->autoPlay)
		if (game->playerToPlay == game->seat)
			AutoPlayCard(game);
}


static void HandleEndHandMessage(Game game, ZHeartsMsgEndHand* msg)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobalsType *)ZGetGameGlobalPointer();
#endif
    int16 i;
    int16 j = 0;
    int16 n26s = 0;
	
	ZHeartsMsgEndHandEndian(msg);

// Message verification
    for(i = 0; i < 4; i++)
    {
        if(msg->score[i] < 0 || msg->score[i] > 26)
            break;
        j += msg->score[i];
        if(msg->score[i] == 26)
            n26s++;
    }

    // runPlayer is unused
    msg->runPlayer = zHeartsPlayerNone;
    if(i < 4 || (j != 26 && (j != 78 || n26s != 3)) || game->gameState != zGameStateWaitForPlay)
    {
        ASSERT(!"HandleEndHandMessage sync");
        ZShellGameShell()->ZoneAlert(ErrorTextSync, NULL, NULL, true, false);
        return;
    }
// end verification

    if ( game->numHandsPlayed >= game->numScores )
    {
        game->numScores += 20;
        game->scoreHistory = (int16*) ZRealloc( game->scoreHistory, sizeof(int16)*zNumPlayersPerTable*game->numScores);
    }

	for (i = 0; i < zNumPlayersPerTable; i++)
    {
        if ( game->scoreHistory )
            game->scoreHistory[game->numHandsPlayed*zNumPlayersPerTable+i] = msg->score[i];
		game->players[i].score += msg->score[i];
	}
	game->numHandsPlayed++;
	
	/* Set new game status and display scores. */
	game->gameState = zGameStateHandOver;
	
	if (game->playerType == zGamePlayer)
	{
		ZRolloverButtonDisable(game->playButton);
		ZRolloverButtonSetText(game->autoPlayButton, gszString[zAutoPlay]);
		ZRolloverButtonDisable(game->autoPlayButton);
		ZRolloverButtonDisable(game->lastTrickButton);
        ZRolloverButtonDisable(game->scoreButton);

        EnableAutoplayAcc(game, false);
        EnableLastTrickAcc(game, false);
        gGAcc->SetItemEnabled(false, IDC_PLAY_BUTTON, false, 0);
        gGAcc->SetItemEnabled(false, IDC_SCORE_BUTTON, false, 0);
	}

	game->showPlayerToPlay = FALSE;
	ClearPlayerCardOutline(game, game->playerToPlay);
	
	/* Clear tricks taken counter. */
	for (i = 0; i < zNumPlayersPerTable; i++)
		game->numTricksTaken[i] = 0;
	UpdateTricksTaken(game);
	
	game->autoPlay = FALSE;
	
	/* Copy sores and initialize score order array. */
	for (i = 0; i < zNumPlayersPerTable; i++)
	{
		game->handScores[i] = msg->score[i];
		game->handScoreOrder[i] = i;
	}
	
	/* Order hand scores */
	OrderHandScore(game);

#ifdef HEARTS_ANIMATION
	if (msg->runPlayer != zHeartsPlayerNone)
	{
		ShowRunAnimation(game, msg->runPlayer );
	}
	else
	{
#endif
		/* Display hand scores. */
		ShowHandScores(game);
		ZCRoomBlockMessages(game->tableID, zRoomFilterThisMessage, zHeartsMsgTalk);
		game->timerType = zGameTimerShowHandScore;
		if (game->playerType == zGamePlayer)
			ZTimerSetTimeout(game->timer, zHandScoreTimeout);
		else
			ZTimerSetTimeout(game->timer, zKibitzerTimeout);
		
        // set up a different accessibility;
        GACCITEM accClose;

        CopyACC(accClose, ZACCESS_DefaultACCITEM);
        accClose.oAccel.cmd = IDC_CLOSE_BOX;
        accClose.oAccel.key = VK_ESCAPE;
        accClose.oAccel.fVirt = FVIRTKEY;

        accClose.fGraphical = true;
        accClose.pvCookie = (void *) zAccRectClose;
        if(!ZIsLayoutRTL())
            ZRectToWRect(&accClose.rc, &gHandScoreCloseBox);
        else
            ZRectToWRect(&accClose.rc, &gHandScoreCloseBoxRTL);

        gGAcc->PushItemlistG(&accClose, 1, 0, true, NULL);

		UpdatePlayers(game);
#ifdef HEARTS_ANIMATION
	}
#endif
	
	UpdateScoreHistoryDialogScores( game );
}


static void HandleEndGameMessage(Game game, ZHeartsMsgEndGame *msg)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif

	int16			i;

	ZHeartsMsgEndGameEndian(msg);

//Message verification
    // this message actually contains no actionable data
    msg->forfeiter = -1;
    msg->timeout = 0;

    if(game->gameState != zGameStateHandOver)
    {
        ASSERT(!"HandleEndGameMessage sync");
        ZShellGameShell()->ZoneAlert(ErrorTextSync, NULL, NULL, true, false);
        return;
    }
// end verification

	game->gameState = zGameStateGameOver;
	game->nCloseStatus = zCloseRegular;
	game->nCloserSeat = -1;

	game->showPlayerToPlay = FALSE;
	ClearPlayerCardOutline(game, game->playerToPlay);

	ZWindowDraw(game->gameWindow, NULL);

	/* Copy scores and initialize score order array. */
	for (i = 0; i < zNumPlayersPerTable; i++)
	{
		game->gameScores[i] = game->players[i].score;
		game->gameScoreOrder[i] = i;
	}
	
	if(msg->forfeiter >= 0)
		game->gameScores[msg->forfeiter] = msg->timeout ? TIMEOUT_DISP_SCORE : FORFEIT_DISP_SCORE;

	/* Order game scores */
	OrderGameScore(game);

	/* Display game scores. */
	ShowGameScores(game);
	ZCRoomBlockMessages(game->tableID, zRoomFilterThisMessage, zHeartsMsgTalk);
	game->fEndGameBlocked = TRUE;

	if(game->infoDisconnecting)  // looks bad to have this up during the game over window, and messages are blocked.  basically a bad situation generally
	{
		ZInfoHide(game->infoDisconnecting);
		ZInfoDelete(game->infoDisconnecting);
		game->infoDisconnecting = NULL;
	}

    // set up a different accessibility;
    GACCITEM accClose;

    CopyACC(accClose, ZACCESS_DefaultACCITEM);
    accClose.oAccel.cmd = IDC_CLOSE_BOX;
    accClose.oAccel.key = VK_ESCAPE;
    accClose.oAccel.fVirt = FVIRTKEY;

    accClose.fGraphical = true;
    accClose.pvCookie = (void *) zAccRectClose;
    if(!ZIsLayoutRTL())
        ZRectToWRect(&accClose.rc, &gGameScoreCloseBox);
    else
        ZRectToWRect(&accClose.rc, &gGameScoreCloseBoxRTL);

    gGAcc->PushItemlistG(&accClose, 1, 0, true, NULL);

	// Game over dialog comes up after the game score has timed out
	game->timerType = zGameTimerShowGameScore;

	ZTimerSetTimeout(game->timer, zGameScoreTimeout);
}


static void HandlePassCardsMessage(Game game, ZHeartsMsgPassCards* msg)
{
    int16 i, j;
	
	
	ZHeartsMsgPassCardsEndian(msg);

// Message verification
    for(i = 0; i < 3; i++)
        if(msg->pass[i] < 0 || msg->pass[i] > 51)
            break;

	if(i < 3 || msg->pass[0] == msg->pass[1] || msg->pass[1] == msg->pass[2] || msg->pass[0] == msg->pass[2] ||
        msg->seat < 0 || msg->seat > 3 || game->passed[msg->seat] || game->gameState != zGameStatePassCards)
	{
        ASSERT(!"HandlePassCardsMessage sync");
        ZShellGameShell()->ZoneAlert(ErrorTextSync, NULL, NULL, true, false);
        return;
    }

    if(msg->seat == ReceivePassFrom(game))
    {
        for(i = 0; i < 3; i++)
        {
            for(j = 0; j < 13; j++)
	            if(msg->pass[i] == game->cardsInHand[j])
                    break;
            if(j < 13)
                break;
        }
        if(i < 3)
	    {
            ASSERT(!"HandlePassCardsMessage sync");
            ZShellGameShell()->ZoneAlert(ErrorTextSync, NULL, NULL, true, false);
            return;
        }
    }
// end verification

	game->passed[msg->seat] = TRUE;
	if (msg->seat == ReceivePassFrom(game))
	{
		/* Save passed cards for later. */
		for (i = 0; i < game->numCardsToPass; i++)
			game->cardsReceived[i] = msg->pass[i];
	}
	else if (game->playerType != zGamePlayer && msg->seat == game->seat)
	{
		/* Select the player passed cards and remove it from the hand. */
		for (i = 0; i < game->numCardsToPass; i++)
			game->cardsSelected[GetCardIndexFromRank(game, msg->pass[i])] = TRUE;
		UpdateHand(game);
	}
}


static void HandlePlayCardMessage(Game game, ZHeartsMsgPlayCard* msg)
{
    int16 i, j;

	ZHeartsMsgPlayCardEndian(msg);

// ignore from selves
    if(msg->seat == game->seat)
        return;

// Message verification
    for(i = 0; i < 13; i++)
        if(game->cardsInHand[i] == msg->card)
            break;

    for(j = game->leadPlayer; j != game->playerToPlay; j = (j + 1) % 4)
        if(game->cardsPlayed[j] == msg->card)
            break;

    if(i < 13 || j != game->playerToPlay || msg->seat < 0 || msg->seat > 3 || msg->seat != game->playerToPlay ||
        msg->card < 0 || msg->card > 51 || game->gameState != zGameStateWaitForPlay)
    {
        ASSERT(!"HandlePlayCardMessage sync");
        ZShellGameShell()->ZoneAlert(ErrorTextSync, NULL, NULL, true, false);
        return;
    }
// end verification

	game->nCloseStatus = zCloseForfeit;
	game->nCloserSeat = -1;

	// Ignore the user's play card message.
	if (msg->seat != game->seat || game->playerType != zGamePlayer)
		PlayerPlayedCard(game, msg->seat, msg->card);
}


static void HandleNewGameMessage(Game game, ZHeartsMsgNewGame* msg)
{
	ZHeartsMsgNewGameEndian(msg);

// Message verification
    if(msg->seat < 0 || msg->seat > 3 || game->newGameVote[msg->seat] || game->gameState != zGameStateGameOver)
    {
        ASSERT(!"HandleNewGameMessage sync");
        ZShellGameShell()->ZoneAlert(ErrorTextSync, NULL, NULL, true, false);
        return;
    }
// end verification

	game->newGameVote[msg->seat] = TRUE;
	
	UpdateTable(game);

    ZShellGameShell()->GameOverPlayerReady( Z(game), game->players[msg->seat].userID );

}


static void HandleTalkMessage(Game game, ZHeartsMsgTalk* msg, DWORD cbMsg)
{
#ifndef MILL_VER
	ZPlayerInfoType		playerInfo;
	
	
	ZHeartsMsgTalkEndian(msg);	
	ZCRoomGetPlayerInfo(msg->userID, &playerInfo);
	if(msg->seat < 0 || !game->fIgnore[msg->seat])
		ZWindowTalk(game->gameWindow, (_TUCHAR*)playerInfo.userName,
				(_TUCHAR*)msg + sizeof(ZHeartsMsgTalk));
#else
    int32 i;
    TCHAR *szText = (TCHAR *) ((BYTE *) msg + sizeof(ZHeartsMsgTalk));

	ZHeartsMsgTalkEndian(msg);

// Message verification
    if(msg->messageLen < 1 || cbMsg < sizeof(ZHeartsMsgTalk) + msg->messageLen)
    {
        ASSERT(!"HandleTalkMessage sync");
        ZShellGameShell()->ZoneAlert(ErrorTextSync, NULL, NULL, true, false);
        return;
    }

    msg->seat = 0; // unused
    for(i = 0; i < msg->messageLen; i++)
        if(!szText[i])
            break;
    if(i == msg->messageLen)
    {
        ASSERT(!"HandleTalkMessage sync");
        ZShellGameShell()->ZoneAlert(ErrorTextSync, NULL, NULL, true, false);
        return;
    }
// end verification

    ZShellGameShell()->ReceiveChat(Z(game), msg->userID, szText, msg->messageLen / sizeof(TCHAR));	
#endif
}


static void HandleGameStateResponseMessage(Game game, ZHeartsMsgGameStateResponse* msg)
{
	int16					i, j, passCount;
	ZPlayerInfoType			playerInfo;


	ZInfoHide(game->gameInfo);
	
    ZHeartsMsgGameStateResponseEndian(msg, zEndianFromStandard);
	
	/* Set game to the given state. */
	game->gameOptions = msg->gameOptions;
	game->numCardsToPass = msg->numCardsToPass;
	game->numCardsDealt = msg->numCardsInDeal;
	game->numPointsForGame = msg->numPointsForGame;
	game->playerToPlay = msg->playerToPlay;
	game->passDirection = msg->passDirection;
	game->numCardsInHand = msg->numCardsInHand;
	game->leadPlayer = msg->leadPlayer;
	game->pointsBroken = msg->pointsBroken;
	game->numHandsPlayed = msg->numHandsPlayed;
	
	z_memcpy(game->cardsInHand, msg->cardsInHand, zHeartsMaxNumCardsInHand * sizeof(ZCard));
	for (i = 0; i < zNumPlayersPerTable; i++)
	{
		ZCRoomGetPlayerInfo(msg->players[i], &playerInfo);

		game->players[i].userID = playerInfo.playerID;
		lstrcpy(game->players[i].name, playerInfo.userName);
		lstrcpy(game->players[i].host, playerInfo.hostName);

		game->cardsPlayed[i] = zNoCard;
		game->players[i].score = msg->scores[i];
		game->numTricksTaken[i] = msg->tricksWon[i];
		game->tableOptions[i] = msg->tableOptions[i];
		game->playersToJoin[i] = msg->playersToJoin[i];
		game->newGameVote[i] = msg->newGameVotes[i];
	}
	for (i = 0, passCount = 0; i < zNumPlayersPerTable; i++)
		if (game->passed[i] = (msg->playerPassed[i] ? TRUE : FALSE))
			passCount++;

	i = game->leadPlayer;
	while (i != game->playerToPlay)
	{
		game->cardsPlayed[i] = msg->cardsPlayed[i];
		i = (i + 1) % zNumPlayersPerTable;
	}
	
	game->kibitzersSilencedWarned = FALSE;
	game->kibitzersSilenced = FALSE;
	for (i = 0; i < zNumPlayersPerTable; i++)
		if (game->tableOptions[i] & zRoomTableOptionSilentKibitzing)
            game->kibitzersSilenced = TRUE;

	game->hideCardsFromKibitzer =
			(game->tableOptions[game->seat] &zHeartsOptionsHideCards) == 0 ? FALSE : TRUE;
	
    /* Copy score history. */
    if ( game->numHandsPlayed >= game->numScores )
    {
        game->numScores += 20;
        game->scoreHistory = (int16*) ZRealloc( game->scoreHistory, sizeof(int16)*zNumPlayersPerTable*game->numScores);
    }

    if ( game->scoreHistory )
    {
        for (i = 0; i < game->numHandsPlayed; i++)
            for (j = 0; j < zNumPlayersPerTable; j++)
            {
                // **** NOTICE the 2 different constants here ***** //
                game->scoreHistory[i*zNumPlayersPerTable+j] = msg->scoreHistory[i*zHeartsMaxNumPlayers+j];
            }
    }

	game->fRatings = msg->fRatings;
	game->nCloseStatus = msg->nCloseStatus;
	game->nCloserSeat = msg->nCloserSeat;

    /* Set game state */
    switch (msg->state)
    {
        case zHeartsStateNone:
            game->gameState = zGameStateNotInited;
            ZInfoSetText(game->gameInfo, zClientReadyInfoStr);
            break;
        case zHeartsStatePassCards:
            game->gameState = zGameStatePassCards;
            if (msg->playerPassed[ReceivePassFrom(game)])
            {
                /* Save passed cards for later. */
                for (i = 0; i < game->numCardsToPass; i++)
                    game->cardsReceived[i] = msg->cardsPassed[i];
            }
            break;
        case zHeartsStatePlayCards:
            game->gameState = zGameStateWaitForPlay;
            game->showPlayerToPlay = TRUE;
            ZTimerSetTimeout(game->timer, zShowTimeout);
			game->timerType = zGameTimerShowPlayer;
			break;
		case zHeartsStateEndGame:
			game->gameState = zGameStateGameOver;
			break;
	}
	
	game->ignoreMessages = FALSE;
	ZWindowDraw(game->gameWindow, NULL);
}


static void HandleCheckInMessage(Game game, ZHeartsMsgCheckIn* msg)
{
	ZHeartsMsgCheckInEndian(msg);
	game->playersToJoin[msg->seat] = msg->userID;
	UpdateJoinerKibitzers(game);
}


static void HandleRemovePlayerRequestMessage(Game game, ZHeartsMsgRemovePlayerRequest* msg)
{
	RemovePlayer		remove;
	TCHAR				str[256];
	
	
	ZHeartsMsgRemovePlayerRequestEndian(msg);
	
	if (game->playerType == zGamePlayer)
	{
		remove = (RemovePlayer) ZCalloc(sizeof(RemovePlayerType), 1);
		if (remove != NULL)
		{
			remove->game = game;
			remove->requestSeat = msg->seat;
			remove->targetSeat = msg->targetSeat;
			if ( msg->ratedGame )
			{
				wsprintf(	str, zRemovePlayerRequestRatedStr,
							game->players[remove->requestSeat].name,
							game->players[remove->targetSeat].name );
			}
			else
			{
				wsprintf(	str, zRemovePlayerRequestStr,
							game->players[remove->requestSeat].name,
							game->players[remove->targetSeat].name );
			}
			ZPrompt(str, &gRemovePlayerRect, game->gameWindow, TRUE, zPromptYes | zPromptNo,
					NULL, NULL, NULL, RemovePlayerPromptFunc, (void*) remove);
		}
	}
}


static void HandleRemovePlayerResponseMessage(Game game, ZHeartsMsgRemovePlayerResponse* msg)
{
	TCHAR			str[256];
	
	
	ZHeartsMsgRemovePlayerResponseEndian(msg);
	
	if (msg->response == -1)
	{
		