ding a display table
 *	from resources.
 */

typedef struct {
	ULONG			ulCtlType;			/* DTCT_LABEL, etc. */
	ULONG			ulCtlFlags;			/* DT_REQUIRED, etc. */
	LPBYTE			lpbNotif;			/*	pointer to notification data */
	ULONG			cbNotif;			/* count of bytes of notification data */
	LPTSTR			lpszFilter;			/* character filter for edit/combobox */
	ULONG			ulItemID;			/* to validate parallel dlg template entry */
	union {								/* ulCtlType discriminates */
		LPVOID			lpv;			/* Initialize this to avoid warnings */
		LPDTBLLABEL		lplabel;
		LPDTBLEDIT		lpedit;
		LPDTBLLBX		lplbx;
		LPDTBLCOMBOBOX	lpcombobox;
		LPDTBLDDLBX		lpddlbx;
		LPDTBLCHECKBOX	lpcheckbox;
		LPDTBLGROUPBOX	lpgroupbox;
		LPDTBLBUTTON	lpbutton;
		LPDTBLRADIOBUTTON lpradiobutton;
		LPDTBLMVLISTBOX	lpmvlbx;
		LPDTBLMVDDLBX	lpmvddlbx;
		LPDTBLPAGE		lppage;
	} ctl;
} DTCTL, FAR *LPDTCTL;

typedef struct {
	ULONG			cctl;
	LPTSTR			lpszResourceName;	/* as usual, may be an integer ID */
	union {								/* as usual, may be an integer ID */
		LPTSTR			lpszComponent;
		ULONG			ulItemID;
	};
	LPDTCTL			lpctl;
} DTPAGE, FAR *LPDTPAGE;



STDAPI
BuildDisplayTable(	LPALLOCATEBUFFER	lpAllocateBuffer,
					LPALLOCATEMORE		lpAllocateMore,
					LPFREEBUFFER		lpFreeBuffer,
					LPMALLOC			lpMalloc,
					HINSTANCE			hInstance,
					UINT				cPages,
					LPDTPAGE			lpPage,
					ULONG				ulFlags,
					LPMAPITABLE *		lppTable,
					LPTABLEDATA	*		lppTblData );


/* MAPI structure validation/copy utilities */

/*
 *	Validate, copy, and adjust pointers in MAPI structures:
 *		notification
 *		property value array
 *		option data
 */

STDAPI_(SCODE)
ScCountNotifications(int cNotifications, LPNOTIFICATION lpNotifications,
		ULONG FAR *lpcb);

STDAPI_(SCODE)
ScCopyNotifications(int cNotification, LPNOTIFICATION lpNotifications,
		LPVOID lpvDst, ULONG FAR *lpcb);

STDAPI_(SCODE)
ScRelocNotifications(int cNotification, LPNOTIFICATION lpNotifications,
		LPVOID lpvBaseOld, LPVOID lpvBaseNew, ULONG FAR *lpcb);


STDAPI_(SCODE)
ScCountProps(int cValues, LPSPropValue lpPropArray, ULONG FAR *lpcb);

STDAPI_(LPSPropValue)
LpValFindProp(ULONG ulPropTag, ULONG cValues, LPSPropValue lpPropArray);

STDAPI_(SCODE)
ScCopyProps(int cValues, LPSPropValue lpPropArray, LPVOID lpvDst,
		ULONG FAR *lpcb);

STDAPI_(SCODE)
ScRelocProps(int cValues, LPSPropValue lpPropArray,
		LPVOID lpvBaseOld, LPVOID lpvBaseNew, ULONG FAR *lpcb);

STDAPI_(SCODE)
ScDupPropset(int cValues, LPSPropValue lpPropArray,
		LPALLOCATEBUFFER lpAllocateBuffer, LPSPropValue FAR *lppPropArray);


/* General utility functions */

/* Related to the OLE Component object model */

STDAPI_(ULONG)			UlAddRef(LPVOID lpunk);
STDAPI_(ULONG)			UlRelease(LPVOID lpunk);

/* Related to the MAPI interface */

STDAPI					HrGetOneProp(LPMAPIPROP lpMapiProp, ULONG ulPropTag,
						LPSPropValue FAR *lppProp);
STDAPI					HrSetOneProp(LPMAPIPROP lpMapiProp,
						LPSPropValue lpProp);
STDAPI_(BOOL)			FPropExists(LPMAPIPROP lpMapiProp, ULONG ulPropTag);
STDAPI_(LPSPropValue)	PpropFindProp(LPSPropValue lpPropArray, ULONG cValues,
						ULONG ulPropTag);
STDAPI_(void)			FreePadrlist(LPADRLIST lpAdrlist);
STDAPI_(void)			FreeProws(LPSRowSet lpRows);
STDAPI					HrQueryAllRows(LPMAPITABLE lpTable,
						LPSPropTagArray lpPropTags,
						LPSRestriction lpRestriction,
						LPSSortOrderSet lpSortOrderSet,
						LONG crowsMax,
						LPSRowSet FAR *lppRows);




/* C runtime substitutes */


STDAPI_(LPTSTR)			SzFindCh(LPCTSTR lpsz, USHORT ch);		/* strchr */
STDAPI_(LPTSTR)			SzFindLastCh(LPCTSTR lpsz, USHORT ch);	/* strrchr */
STDAPI_(LPTSTR)			SzFindSz(LPCTSTR lpsz, LPCTSTR lpszKey); /*strstr */
STDAPI_(unsigned int)	UFromSz(LPCTSTR lpsz);					/* atoi */

STDAPI_(SCODE)			ScUNCFromLocalPath(LPSTR lpszLocal, LPSTR lpszUNC,
						UINT cchUNC);
STDAPI_(SCODE)			ScLocalPathFromUNC(LPSTR lpszUNC, LPSTR lpszLocal,
						UINT cchLocal);

/* 64-bit arithmetic with times */

STDAPI_(FILETIME)		FtAddFt(FILETIME ftAddend1, FILETIME ftAddend2);
STDAPI_(FILETIME)		FtMulDwDw(DWORD ftMultiplicand, DWORD ftMultiplier);
STDAPI_(FILETIME)		FtMulDw(DWORD ftMultiplier, FILETIME ftMultiplicand);
STDAPI_(FILETIME)		FtSubFt(FILETIME ftMinuend, FILETIME ftSubtrahend);
STDAPI_(FILETIME)		FtNegFt(FILETIME ft);

/* Message composition */

STDAPI_(SCODE)			ScCreateConversationIndex (ULONG cbParent,
							LPBYTE lpbParent,
							ULONG FAR *	lpcbConvIndex,
							LPBYTE FAR * lppbConvIndex);

/* Store support */

STDAPI WrapStoreEntryID (ULONG ulFlags, LPTSTR lpszDLLName, ULONG cbOrigEntry,
	LPENTRYID lpOrigEntry, ULONG *lpcbWrappedEntry, LPENTRYID *lppWrappedEntry);

/* RTF Sync Utilities */

#define RTF_SYNC_RTF_CHANGED	((ULONG) 0x00000001)
#define RTF_SYNC_BODY_CHANGED	((ULONG) 0x00000002)

STDAPI_(HRESULT)
RTFSync (LPMESSAGE lpMessage, ULONG ulFlags, BOOL FAR * lpfMessageUpdated);


/* Flags for WrapCompressedRTFStream() */

/****** MAPI_MODIFY				((ULONG) 0x00000001) mapidefs.h */
/****** STORE_UNCOMPRESSED_RTF	((ULONG) 0x00008000) mapidefs.h */

STDAPI_(HRESULT)
WrapCompressedRTFStream (LPSTREAM lpCompressedRTFStream,
		ULONG ulFlags, LPSTREAM FAR * lpUncompressedRTFStream);

/* Storage on Stream */

#if defined(_WIN32) || defined(WIN16)
STDAPI_(HRESULT)
HrIStorageFromStream (LPUNKNOWN lpUnkIn,
	LPCIID lpInterface, ULONG ulFlags, LPSTORAGE FAR * lppStorageOut);
#endif


/*
 * Setup and cleanup.
 *
 * Providers never need to make these calls.
 *
 * Test applications and the like which do not call MAPIInitialize
 * may want to call them, so that the few utility functions which
 * need MAPI allocators (and do not ask for them explicitly)
 * will work.
 */

/* All flags are reserved for ScInitMapiUtil. */

STDAPI_(SCODE)			ScInitMapiUtil(ULONG ulFlags);
STDAPI_(VOID)			DeinitMapiUtil(VOID);


/*
 *	Entry point names.
 *	
 *	These are for new entry points defined since MAPI first shipped
 *	in Windows 95. Using these names in a GetProcAddress call makes
 *	it easier to write code which uses them optionally.
 */

#if defined (WIN16)
#define szHrDispatchNotifications "HrDispatchNotifications"
#elif defined (_WIN32) && defined (_X86_)
#define szHrDispatchNotifications "_HrDispatchNotifications@4"
#elif defined (_ALPHA_) || defined (_MIPS_) || defined (_PPC_)
#define szHrDispatchNotifications "HrDispatchNotifications"
#endif

typedef HRESULT (STDAPICALLTYPE DISPATCHNOTIFICATIONS)(ULONG ulFlags);
typedef DISPATCHNOTIFICATIONS FAR * LPDISPATCHNOTIFICATIONS;

#if defined (WIN16)
#define szScCreateConversationIndex "ScCreateConversationIndex"
#elif defined (_WIN32) && defined (_X86_)
#define szScCreateConversationIndex "_ScCreateConversationIndex@16"
#elif defined (_ALPHA_) || defined (_MIPS_) || defined (_PPC_)
#define szScCreateConversationIndex "ScCreateConversationIndex"
#endif

typedef SCODE (STDAPICALLTYPE CREATECONVERSATIONINDEX)(ULONG cbParent,
	LPBYTE lpbParent, ULONG FAR *lpcbConvIndex, LPBYTE FAR *lppbConvIndex);
typedef CREATECONVERSATIONINDEX FAR *LPCREATECONVERSATIONINDEX;

#ifdef __cplusplus
}
#endif

#endif /* _WABUTIL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\published\uuid\unixguids.cxx ===
#define INITGUID

#include "mwversion.h"
#include <compobj.h>
#include <initguid.h>
#include <msstkppg.h>

#include <shlguid.h>

#undef INITGUID
#include "unix/guids.h"

// Must be after "unix/guids.h" to expand the GUIDs for olectl.h.
#define INITGUID

// DllMain needed due to this being a shared library

extern "C" BOOL WINAPI DllMain(HINSTANCE, DWORD, LPVOID)
{
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\published\uuid\makefile.inc ===
$(O)\activaut_i.c : ..\inc\$(O)\activaut_i.c
    copy $** $@

$(O)\activdbg_i.c : ..\inc\$(O)\activdbg_i.c
    copy $** $@

$(O)\activscp_i.c : ..\inc\$(O)\activscp_i.c
    copy $** $@

$(O)\AutoDiscovery_i.c : ..\inc\$(O)\AutoDiscovery_i.c
    copy $** $@

$(O)\chanmgr_i.c : ..\inc\$(O)\chanmgr_i.c
    copy $** $@

$(O)\comcat_i.c : ..\inc\$(O)\comcat_i.c
    copy $** $@

$(O)\dbgprop_i.c : ..\inc\$(O)\dbgprop_i.c
    copy $** $@

$(O)\dimm_i.c : ..\inc\$(O)\dimm_i.c
    copy $** $@

$(O)\dispex_i.c : ..\inc\$(O)\dispex_i.c
    copy $** $@

$(O)\dlmgridl_i.c : ..\inc\$(O)\dlmgridl_i.c
    copy $** $@

$(O)\docobj_i.c : ..\inc\$(O)\docobj_i.c
    copy $** $@

$(O)\dxtmsft_i.c : ..\inc\$(O)\dxtmsft_i.c
    copy $** $@

$(O)\dxtrans_i.c : ..\inc\$(O)\dxtrans_i.c
    copy $** $@

$(O)\dxtransp_i.c : ..\inc\$(O)\dxtransp_i.c
    copy $** $@

$(O)\dwnnot_i.c : ..\inc\$(O)\dwnnot_i.c
    copy $** $@

$(O)\emptyvc_i.c : ..\inc\$(O)\emptyvc_i.c
    copy $** $@

$(O)\exdisp_i.c : ..\inc\$(O)\exdisp_i.c
    copy $** $@

$(O)\hlink_i.c : ..\inc\$(O)\hlink_i.c
    copy $** $@

$(O)\htiface_i.c : ..\inc\$(O)\htiface_i.c
    copy $** $@

$(O)\htiframe_i.c : ..\inc\$(O)\htiframe_i.c
    copy $** $@

$(O)\htmlfilter_i.c : ..\inc\$(O)\htmlfilter_i.c
    copy $** $@

$(O)\httprequest_i.c : ..\inc\$(O)\httprequest_i.c
    copy $** $@

$(O)\iedial_i.c : ..\inc\$(O)\iedial_i.c
    copy $** $@

$(O)\iextag_i.c : ..\inc\$(O)\iextag_i.c
    copy $** $@

$(O)\imgutil_i.c : ..\inc\$(O)\imgutil_i.c
    copy $** $@

$(O)\interned_i.c : ..\inc\$(O)\interned_i.c
    copy $** $@

$(O)\mimeinfo_i.c : ..\inc\$(O)\mimeinfo_i.c
    copy $** $@

$(O)\mlang_i.c : ..\inc\$(O)\mlang_i.c
    copy $** $@

$(O)\mobsync_i.c : ..\inc\$(O)\mobsync_i.c
    copy $** $@

$(O)\mobsyncp_i.c : ..\inc\$(O)\mobsyncp_i.c
    copy $** $@

$(O)\mshtmhst_i.c : ..\inc\$(O)\mshtmhst_i.c
    copy $** $@

$(O)\mstime_i.c : ..\inc\$(O)\mstime_i.c
    copy $** $@

$(O)\mshtml_i.c : ..\inc\$(O)\mshtml_i.c
    copy $** $@

$(O)\msident_i.c : ..\inc\$(O)\msident_i.c
    copy $** $@

$(O)\msieftp_i.c : ..\inc\$(O)\msieftp_i.c
    copy $** $@

$(O)\objsafe_i.c : ..\inc\$(O)\objsafe_i.c
    copy $** $@

$(O)\ocmm_i.c : ..\inc\$(O)\ocmm_i.c
    copy $** $@

$(O)\opsprof_i.c : ..\inc\$(O)\opsprof_i.c
    copy $** $@

$(O)\optary_i.c : ..\inc\$(O)\optary_i.c
    copy $** $@

$(O)\perhist_i.c : ..\inc\$(O)\perhist_i.c
    copy $** $@

$(O)\prgsnk_i.c : ..\inc\$(O)\prgsnk_i.c
    copy $** $@

$(O)\procdm_i.c : ..\inc\$(O)\procdm_i.c
    copy $** $@

$(O)\ratingsp_i.c : ..\inc\$(O)\ratingsp_i.c
    copy $** $@

$(O)\recalc_i.c : ..\inc\$(O)\recalc_i.c
    copy $** $@

$(O)\safeocx_i.c : ..\inc\$(O)\safeocx_i.c
    copy $** $@

$(O)\sensevts_i.c : ..\inc\$(O)\sensevts_i.c
    copy $** $@

$(O)\servprov_i.c : ..\inc\$(O)\servprov_i.c
    copy $** $@

$(O)\subsmgr_i.c : ..\inc\$(O)\subsmgr_i.c
    copy $** $@

$(O)\urlhist_i.c : ..\inc\$(O)\urlhist_i.c
    copy $** $@

$(O)\urlmon_i.c : ..\inc\$(O)\urlmon_i.c
    copy $** $@

$(O)\urltrack_i.c : ..\inc\$(O)\urltrack_i.c
    copy $** $@

$(O)\vervec_i.c : ..\inc\$(O)\vervec_i.c
    copy $** $@

$(O)\vrsscan_i.c : ..\inc\$(O)\vrsscan_i.c
    copy $** $@

$(O)\webcheck_i.c : ..\inc\$(O)\webcheck_i.c
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\published\inc\xmldsodid.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1996-1997               **
//*********************************************************************

//;begin_internal
/***********************************************************************************************

  This is a distributed SDK component - do not put any #includes or other directives that rely
  upon files not dropped. If in doubt - build iedev

  If you add comments please include either ;BUGBUG at the beginning of a single line OR
  enclose in a ;begin_internal, ;end_internal block - such as this one!

 ***********************************************************************************************/
//;end_internal

//;begin_internal
#ifndef __XMLDSODID_H__
#define __XMLDSODID_H__
//;end_internal

#define DISPID_XOBJ_MIN                 0x00010000
#define DISPID_XOBJ_MAX                 0x0001FFFF
#define DISPID_XOBJ_BASE                DISPID_XOBJ_MIN

#define  DISPID_XMLDSO                       DISPID_XOBJ_BASE
#define  DISPID_XMLDSO_DOCUMENT              DISPID_XMLDSO  +  1
#define  DISPID_XMLDSO_JAVADSOCOMPATIBLE     DISPID_XMLDSO_DOCUMENT  +  1

//;begin_internal
#endif // __XMLDSODID_H__
//;end_internal
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\published\uuid\unix\clsid.h ===
/*** 
*clsid.h
*
*  Copyright (C) 1992, Microsoft Corporation.  All Rights Reserved.
*  Information Contained Herein Is Proprietary and Confidential.
*
*Purpose:
*  This file defines the CLSIDs
*
*Implementation Notes:
*
*****************************************************************************/

#if defined(WIN32) && 0
DEFINE_OLEGUID(CLSID_PSDispatch, 	0x00020400, 0, 0);
DEFINE_OLEGUID(CLSID_PSEnumVARIANT,	0x00020404, 0, 0);
DEFINE_OLEGUID(CLSID_PSTypeInfo,	0x00020401, 0, 0);
DEFINE_OLEGUID(CLSID_PSTypeLib,		0x00020402, 0, 0);
#else
DEFINE_OLEGUID(CLSID_PSDispatch, 	0x00020420, 0, 0);
DEFINE_OLEGUID(CLSID_PSEnumVARIANT,	0x00020421, 0, 0);
DEFINE_OLEGUID(CLSID_PSTypeInfo,	0x00020422, 0, 0);
DEFINE_OLEGUID(CLSID_PSTypeLib,		0x00020423, 0, 0);
#endif

DEFINE_OLEGUID(CLSID_PSAutomation,	0x00020424, 0, 0);
DEFINE_OLEGUID(CLSID_PSTypeComp,	0x00020425, 0, 0);

DEFINE_OLEGUID(CLSID_InProcFreeMarshaler, 0x0000001c, 0, 0);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\published\uuid\ieguids.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999.
//
//  File:       guids.c
//
//  Contents:   ActiveX releated guids
//
//  Classes:
//
//  Functions:
//
//  History:    6-12-96   JohannP (Johann Posch)   Created
//                        Combined serveral files with guids into this file
//                        and removed duplicated definitions
//
//----------------------------------------------------------------------------

#define INITGUID
#include <guiddef.h>

DEFINE_GUID( CLSID_StdURLMoniker,           0x79eac9e0,0xbaf9,0x11ce,0x8c,0x82,0x00,0xaa,0x00,0x4b,0xa9,0x0b);
DEFINE_GUID( CLSID_StdURLProtocol,          0x79eac9e1,0xbaf9,0x11ce,0x8c,0x82,0x00,0xaa,0x00,0x4b,0xa9,0x0b);
DEFINE_GUID( CLSID_HttpProtocol,            0x79eac9e2,0xbaf9,0x11ce,0x8c,0x82,0x00,0xaa,0x00,0x4b,0xa9,0x0b);
DEFINE_GUID( CLSID_FtpProtocol,             0x79eac9e3,0xbaf9,0x11ce,0x8c,0x82,0x00,0xaa,0x00,0x4b,0xa9,0x0b);
DEFINE_GUID( CLSID_GopherProtocol,          0x79eac9e4,0xbaf9,0x11ce,0x8c,0x82,0x00,0xaa,0x00,0x4b,0xa9,0x0b);
DEFINE_GUID( CLSID_HttpSProtocol,           0x79eac9e5,0xbaf9,0x11ce,0x8c,0x82,0x00,0xaa,0x00,0x4b,0xa9,0x0b);
DEFINE_GUID( CLSID_MkProtocol,              0x79eac9e6,0xbaf9,0x11ce,0x8c,0x82,0x00,0xaa,0x00,0x4b,0xa9,0x0b);
DEFINE_GUID( CLSID_FileProtocol,            0x79eac9e7,0xbaf9,0x11ce,0x8c,0x82,0x00,0xaa,0x00,0x4b,0xa9,0x0b);
DEFINE_GUID( CLSID_PSUrlMonProxy,           0x79eac9f1,0xbaf9,0x11ce,0x8c,0x82,0x00,0xaa,0x00,0x4b,0xa9,0x0b);
DEFINE_GUID( CLSID_UrlMkBindCtx,            0x79eac9f2,0xbaf9,0x11ce,0x8c,0x82,0x00,0xaa,0x00,0x4b,0xa9,0x0b);
DEFINE_GUID( CLSID_ResProtocol,             0x3050f3bc,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID( CLSID_AboutProtocol,           0x3050f406,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID( IID_IAsyncMoniker,             0x79eac9d3,0xbaf9,0x11ce,0x8c,0x82,0x00,0xaa,0x00,0x4b,0xa9,0x0b);
DEFINE_GUID( IID_IBindStatusCallbackHolder, 0x79eac9cc,0xbaf9,0x11ce,0x8c,0x82,0x00,0xaa,0x00,0x4b,0xa9,0x0b);
DEFINE_GUID( IID_IAsyncBindCtx,             0x79eac9d4,0xbaf9,0x11ce,0x8c,0x82,0x00,0xaa,0x00,0x4b,0xa9,0x0b);
DEFINE_GUID( IID_IBindStatusCallbackMsg,    0x79eac9d5,0xbaf9,0x11ce,0x8c,0x82,0x00,0xaa,0x00,0x4b,0xa9,0x0b);

// debug and trace interface ids
DEFINE_GUID( IID_IDebugRegister,            0xc733e4f0,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( IID_IDebugOut,                 0xc733e4f1,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);

//
// clsid for the Notification/Scheduler Module
//
DEFINE_GUID( CLSID_StdNotificationMgr,      0xc733e4af,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( CLSID_WebCheckDefaultProcess,  0xc733e4b0,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);

DEFINE_GUID( IID_IEnumPropertyMap,          0xc733e4a1,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( IID_IPropertyMap,              0xc733e4a2,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( IID_INotification,             0xc733e4a3,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( IID_INotificationMgr,          0xc733e4a4,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( IID_INotificationSink,         0xc733e4a5,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( IID_IScheduleGroup,            0xc733e4a6,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( IID_INotificationReport,       0xc733e4a7,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( IID_IEnumNotification,         0xc733e4a8,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( IID_IEnumScheduleGroup,        0xc733e4a9,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
// private interfaces
DEFINE_GUID( IID_IEnumNotificationSinkItem, 0xc733e4aa,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( IID_INotificationHelper,       0xc733e4ab,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( IID_INotificationPing,         0xc733e4ac,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( IID_INotificationRunning,      0xc733e4ad,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( IID_INotificationProcessMgr0,  0xc733e4ae,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);

//
// old guids; will be removed
//
DEFINE_GUID( IID_IOInet,                    0x79eac9e0,0xbaf9,0x11ce,0x8c,0x82,0x00,0xaa,0x00,0x4b,0xa9,0x0b);
DEFINE_GUID( IID_IOInetBindInfo,            0x79eac9e1,0xbaf9,0x11ce,0x8c,0x82,0x00,0xaa,0x00,0x4b,0xa9,0x0b);
DEFINE_GUID( IID_IOInetBindClient,          0x79eac9e2,0xbaf9,0x11ce,0x8c,0x82,0x00,0xaa,0x00,0x4b,0xa9,0x0b);
DEFINE_GUID( IID_IOInetProtocolRoot,        0x79eac9e3,0xbaf9,0x11ce,0x8c,0x82,0x00,0xaa,0x00,0x4b,0xa9,0x0b);
DEFINE_GUID( IID_IOInetProtocol,            0x79eac9e4,0xbaf9,0x11ce,0x8c,0x82,0x00,0xaa,0x00,0x4b,0xa9,0x0b);
DEFINE_GUID( IID_IOInetProtocolSink,        0x79eac9e5,0xbaf9,0x11ce,0x8c,0x82,0x00,0xaa,0x00,0x4b,0xa9,0x0b);
DEFINE_GUID( IID_IOInetSession,             0x79eac967,0xbaf9,0x11ce,0x8c,0x82,0x00,0xaa,0x00,0x4b,0xa9,0x0b);
DEFINE_GUID( IID_IOInetThreadSwitch,        0x79eac968,0xbaf9,0x11ce,0x8c,0x82,0x00,0xaa,0x00,0x4b,0xa9,0x0b);
DEFINE_GUID( IID_IOInetCache,               0x79eac9ea,0xbaf9,0x11ce,0x8c,0x82,0x00,0xaa,0x00,0x4b,0xa9,0x0b);
DEFINE_GUID( IID_IOInetPriority,            0x79eac9eb,0xbaf9,0x11ce,0x8c,0x82,0x00,0xaa,0x00,0x4b,0xa9,0x0b);
DEFINE_GUID( IID_IOInetProtocolInfo,        0x79eac9ec,0xbaf9,0x11ce,0x8c,0x82,0x00,0xaa,0x00,0x4b,0xa9,0x0b);

// broadcasting a notification
DEFINE_GUID( CLSID_GLOBAL_BROADCAST,        0xd34f1810,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( CLSID_PROCESS_BROADCAST,       0xd34f1811,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( CLSID_THREAD_BROADCAST,        0xd34f1812,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( CLSID_1,                       0xd34f1813,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( CLSID_2,                       0xd34f1814,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( CLSID_3,                       0xd34f1815,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( CLSID_4,                       0xd34f1816,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( CLSID_5,                       0xd34f1817,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( CLSID_6,                       0xd34f1818,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( CLSID_7,                       0xd34f1819,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( CLSID_8,                       0xd34f181a,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( CLSID_9,                       0xd34f181b,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( CLSID_a,                       0xd34f181c,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( CLSID_b,                       0xd34f181d,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( CLSID_c,                       0xd34f181e,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( CLSID_d,                       0xd34f181f,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);

//
// notificationstyps used by the notification mgr
//
DEFINE_GUID( NOTIFICATIONTYPE_ITEM_START,   0xd34f1880,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_ITEM_RESTART, 0xd34f1881,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_ITEM_DONE,    0xd34f1882,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_GROUP_START,  0xd34f1883,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_GROUP_RESTART,0xd34f1884,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_GROUP_DONE,   0xd34f1885,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_i6,           0xd34f1886,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_i7,           0xd34f1887,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_i8,           0xd34f1888,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_i9,           0xd34f1889,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_iA,           0xd34f188A,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_iB,           0xd34f188B,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_iC,           0xd34f188C,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_iD,           0xd34f188D,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_iE,           0xd34f188E,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_iF,           0xd34f188F,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);

//
// predefined scheduled groups
//
DEFINE_GUID( NOTFCOOKIE_SCHEDULE_GROUP_DAILY,   0xd34f18b0,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTFCOOKIE_SCHEDULE_GROUP_WEEKLY,  0xd34f18b1,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTFCOOKIE_SCHEDULE_GROUP_MONTHLY, 0xd34f18b2,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTFCOOKIE_SCHEDULE_GROUP_MANUAL,  0xd34f18b3,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);


// NotificationTypes used and reserved
DEFINE_GUID( NOTIFICATIONTYPE_NULL,            0xd34f17e0,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_ANOUNCMENT,      0xd34f17e1,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_TASK,            0xd34f17e2,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_ALERT,           0xd34f17e3,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_INET_IDLE,       0xd34f17e4,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_INET_OFFLINE,    0xd34f17e5,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_INET_ONLINE,     0xd34f17e6,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_TASKS_SUSPEND,   0xd34f17e7,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_TASKS_RESUME,    0xd34f17e8,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_TASKS_ABORT,     0xd34f17e9,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_TASKS_COMPLETED, 0xd34f17ea,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_TASKS_PROGRESS,  0xd34f17eb,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_AGENT_START,     0xd34f17ec,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_BEGIN_REPORT,    0xd34f17ee,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_END_REPORT,      0xd34f17ef,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_AGENT_INIT,      0x1e4a7390,0xc70b,0x11d0,0x95,0xf8,0x00,0xa0,0xc9,0x03,0x48,0xec);
DEFINE_GUID( NOTIFICATIONTYPE_CONNECT_TO_INTERNET,      0xd34f17f0,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_DISCONNECT_FROM_INTERNET, 0xd34f17f1,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_CONFIG_CHANGED,  0xd34f17f2,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_PROGRESS_REPORT, 0xd34f17f3,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_USER_IDLE_BEGIN, 0xd34f17f4,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_USER_IDLE_END,   0xd34f17f5,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_TASKS_STARTED,   0xd34f17f6,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_TASKS_ERROR,  0xd34f17f7,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_d,            0xd34f17f8,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_e,            0xd34f17f9,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_f,            0xd34f17fa,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_11,           0xd34f17fb,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_12,           0xd34f17fc,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_13,           0xd34f17fd,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_14,           0xd34f17fe,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_15,           0xd34f17ff,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);

DEFINE_GUID( NOTIFICATIONTYPE_START_0,      0xd34f1800,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_START_1,      0xd34f1801,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_START_2,      0xd34f1802,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_START_3,      0xd34f1803,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_START_4,      0xd34f1804,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_START_5,      0xd34f1805,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_START_6,      0xd34f1806,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_START_7,      0xd34f1807,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_START_8,      0xd34f1808,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_START_9,      0xd34f1809,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_START_A,      0xd34f180a,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_START_B,      0xd34f180b,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_START_C,      0xd34f180c,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_START_D,      0xd34f180d,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_START_E,      0xd34f180e,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_START_F,      0xd34f180f,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);

// clsid for testing
DEFINE_GUID( CLSID_NotificaitonTest1,       0xc733e501,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( CLSID_NotificaitonTest2,       0xc733e502,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( CLSID_NotificaitonTest3,       0xc733e503,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( CLSID_NotificaitonTest4,       0xc733e504,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);

//
// end cls ids for notification/scheduler module
//

//
// clsid for the EAPP Module
//

DEFINE_GUID( CLSID_StdEncodingFilterFac,    0x54c37cd0,0xd944,0x11d0,0xa9,0xf4,0x00,0x60,0x97,0x94,0x23,0x11);

DEFINE_GUID( CLSID_DeCompMimeFilter,        0x8f6b0360,0xb80d,0x11d0,0xa9,0xb3,0x00,0x60,0x97,0x94,0x23,0x11);

DEFINE_GUID( CLSID_CdlProtocol,             0x3dd53d40,0x7b8b,0x11d0,0xb0,0x13,0x00,0xaa,0x00,0x59,0xce,0x02);

DEFINE_GUID( CLSID_ClassInstallFilter,      0x32b533bb,0xedae,0x11d0,0xbd,0x5a,0x00,0xaa,0x00,0xb9,0x2a,0xf1);

//
// end cls ids for EAPP module
//


//
DEFINE_GUID( LIBID_Accessibility,           0x1ea4dbf0,0x3c3b,0x11cf,0x81,0x0c,0x00,0xaa,0x00,0x38,0x9b,0x71);
DEFINE_GUID( IID_IAccessible,               0x618736e0,0x3c3d,0x11cf,0x81,0x0c,0x00,0xaa,0x00,0x38,0x9b,0x71);



// From docobj.lib (SriniK)
DEFINE_GUID( SID_SContainerDispatch,        0xb722be00,0x4e68,0x101b,0xa2,0xbc,0x00,0xaa,0x00,0x40,0x47,0x70);

DEFINE_GUID( SID_SDataPathBrowser,          0xFC4801A5,0x2BA9,0x11CF,0xA2,0x29,0x00,0xAA,0x00,0x3D,0x73,0x52);
DEFINE_GUID( GUID_PathProperty,             0x0002DE80,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);
DEFINE_GUID( GUID_HasPathProperties,        0x0002DE81,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

DEFINE_GUID( CLSID_StdHlink,                0x79eac9d0,0xbaf9,0x11ce,0x8c,0x82,0x00,0xaa,0x00,0x4b,0xa9,0x0b);
DEFINE_GUID( CLSID_StdHlinkBrowseContext,   0x79eac9d1,0xbaf9,0x11ce,0x8c,0x82,0x00,0xaa,0x00,0x4b,0xa9,0x0b);

//
// datapath guids
//
DEFINE_GUID( OLE_DATAPATH_BMP,              0x0002DE01,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);
DEFINE_GUID( OLE_DATAPATH_DIB,              0x0002DE02,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);
DEFINE_GUID( OLE_DATAPATH_WMF,              0x0002DE03,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);
DEFINE_GUID( OLE_DATAPATH_ENHMF,            0x0002DE04,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);
DEFINE_GUID( OLE_DATAPATH_GIF,              0x0002DE05,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);
DEFINE_GUID( OLE_DATAPATH_JPEG,             0x0002DE06,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);
DEFINE_GUID( OLE_DATAPATH_TIFF,             0x0002DE07,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);
DEFINE_GUID( OLE_DATAPATH_XBM,              0x0002DE08,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);
DEFINE_GUID( OLE_DATAPATH_PCX,              0x0002DE09,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);
DEFINE_GUID( OLE_DATAPATH_PICT,             0x0002DE0A,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);
DEFINE_GUID( OLE_DATAPATH_CGM,              0x0002DE0B,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);
DEFINE_GUID( OLE_DATAPATH_EPS,              0x0002DE0C,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);
DEFINE_GUID( OLE_DATAPATH_COMMONIMAGE,      0x0002DE0D,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);
DEFINE_GUID( OLE_DATAPATH_ALLIMAGE,         0x0002DE0E,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);
DEFINE_GUID( OLE_DATAPATH_AVI,              0x0002DE0F,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);
DEFINE_GUID( OLE_DATAPATH_MPEG,             0x0002DE10,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);
DEFINE_GUID( OLE_DATAPATH_QUICKTIME,        0x0002DE11,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);
DEFINE_GUID( OLE_DATAPATH_BASICAUDIO,       0x0002DE12,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);
DEFINE_GUID( OLE_DATAPATH_MIDI,             0x0002DE13,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);
DEFINE_GUID( OLE_DATAPATH_WAV,              0x0002DE14,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);
DEFINE_GUID( OLE_DATAPATH_RIFF,             0x0002DE15,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);
DEFINE_GUID( OLE_DATAPATH_SOUND,            0x0002DE16,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);
DEFINE_GUID( OLE_DATAPATH_VIDEO,            0x0002DE17,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);
DEFINE_GUID( OLE_DATAPATH_ALLMM,            0x0002DE18,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);
DEFINE_GUID( OLE_DATAPATH_ANSITEXT,         0x0002DE19,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);
DEFINE_GUID( OLE_DATAPATH_UNICODE,          0x0002DE1A,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);
DEFINE_GUID( OLE_DATAPATH_RTF,              0x0002DE1B,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);
DEFINE_GUID( OLE_DATAPATH_HTML,             0x0002DE1C,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);
DEFINE_GUID( OLE_DATAPATH_POSTSCRIPT,       0x0002DE1D,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);
DEFINE_GUID( OLE_DATAPATH_ALLTEXT,          0x0002DE1E,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);
DEFINE_GUID( OLE_DATAPATH_DIF,              0x0002DE1F,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);
DEFINE_GUID( OLE_DATAPATH_SYLK,             0x0002DE20,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);
DEFINE_GUID( OLE_DATAPATH_BIFF,             0x0002DE21,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);
DEFINE_GUID( OLE_DATAPATH_PALETTE,          0x0002DE22,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);
DEFINE_GUID( OLE_DATAPATH_PENDATA,          0x0002DE23,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

DEFINE_GUID( FLAGID_Internet,               0x96300DA0,0x2BAB,0x11CF,0xA2,0x29,0x00,0xAA,0x00,0x3D,0x73,0x52);
DEFINE_GUID( ARRAYID_PathProperties,        0x7ecbba04,0x2d97,0x11cf,0xa2,0x29,0x00,0xaa,0x00,0x3d,0x73,0x52);

//
// Component category guids
//

DEFINE_GUID( CLSID_StdComponentCategoriesMgr,0x0002E005,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

DEFINE_GUID( CATID_Insertable,              0x40FC6ED3,0x2438,0x11cf,0xA3,0xDB,0x08,0x00,0x36,0xF1,0x25,0x02);
DEFINE_GUID( CATID_Control,                 0x40FC6ED4,0x2438,0x11cf,0xA3,0xDB,0x08,0x00,0x36,0xF1,0x25,0x02);
DEFINE_GUID( CATID_Programmable,            0x40FC6ED5,0x2438,0x11cf,0xA3,0xDB,0x08,0x00,0x36,0xF1,0x25,0x02);
DEFINE_GUID( CATID_IsShortcut,              0x40FC6ED6,0x2438,0x11cf,0xA3,0xDB,0x08,0x00,0x36,0xF1,0x25,0x02);
DEFINE_GUID( CATID_NeverShowExt,            0x40FC6ED7,0x2438,0x11cf,0xA3,0xDB,0x08,0x00,0x36,0xF1,0x25,0x02);
DEFINE_GUID( CATID_DocObject,               0x40FC6ED8,0x2438,0x11cf,0xA3,0xDB,0x08,0x00,0x36,0xF1,0x25,0x02);
DEFINE_GUID( CATID_Printable,               0x40FC6ED9,0x2438,0x11cf,0xA3,0xDB,0x08,0x00,0x36,0xF1,0x25,0x02);
DEFINE_GUID( CATID_RequiresDataPathHost,    0x0de86a50,0x2baa,0x11cf,0xa2,0x29,0x00,0xaa,0x00,0x3d,0x73,0x52);
DEFINE_GUID( CATID_PersistsToMoniker,       0x0de86a51,0x2baa,0x11cf,0xa2,0x29,0x00,0xaa,0x00,0x3d,0x73,0x52);
DEFINE_GUID( CATID_PersistsToStorage,       0x0de86a52,0x2baa,0x11cf,0xa2,0x29,0x00,0xaa,0x00,0x3d,0x73,0x52);
DEFINE_GUID( CATID_PersistsToStreamInit,    0x0de86a53,0x2baa,0x11cf,0xa2,0x29,0x00,0xaa,0x00,0x3d,0x73,0x52);
DEFINE_GUID( CATID_PersistsToStream,        0x0de86a54,0x2baa,0x11cf,0xa2,0x29,0x00,0xaa,0x00,0x3d,0x73,0x52);
DEFINE_GUID( CATID_PersistsToMemory,        0x0de86a55,0x2baa,0x11cf,0xa2,0x29,0x00,0xaa,0x00,0x3d,0x73,0x52);
DEFINE_GUID( CATID_PersistsToFile,          0x0de86a56,0x2baa,0x11cf,0xa2,0x29,0x00,0xaa,0x00,0x3d,0x73,0x52);
DEFINE_GUID( CATID_PersistsToPropertyBag,   0x0de86a57,0x2baa,0x11cf,0xa2,0x29,0x00,0xaa,0x00,0x3d,0x73,0x52);
DEFINE_GUID( CATID_InternetAware,           0x0de86a58,0x2baa,0x11cf,0xa2,0x29,0x00,0xaa,0x00,0x3d,0x73,0x52);
DEFINE_GUID( CATID_SafeForScripting,        0x7dd95801,0x9882,0x11cf,0x9f,0xa9,0x00,0xaa,0x00,0x6c,0x42,0xc4);
DEFINE_GUID( CATID_SafeForInitializing,     0x7dd95802,0x9882,0x11cf,0x9f,0xa9,0x00,0xaa,0x00,0x6c,0x42,0xc4);
DEFINE_GUID( CATID_DesignTimeUIActivatableControl, 0xf2bb56d1,0xdb07,0x11d1,0xaa,0x6b,0x00,0x60,0x97,0xdb,0x95,0x39);

//
// Image component GUIDs
//

DEFINE_GUID( CLSID_IImgCtx,                 0x3050f3d6,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID( IID_IImgCtx,                   0x3050f3d7,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);

DEFINE_GUID( CLSID_IImageDecodeFilter,      0x607fd4e8,0x0a03,0x11d1,0xab,0x1d,0x00,0xc0,0x4f,0xc9,0xb3,0x04);

//
// Trident GUIDs
//

DEFINE_GUID( CGID_MSHTML,                   0xde4ba900,0x59ca,0x11cf, 0x95,0x92,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID( CLSID_MHTMLDocument,           0x3050f3d9,0x98b5,0x11cf, 0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID( CLSID_HTADocument,             0x3050F5C8,0x98B5,0x11CF, 0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID( CLSID_HTMLApplication,         0x3050f4d8,0x98B5,0x11CF, 0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID( CLSID_HTMLPluginDocument,      0x25336921,0x03F9,0x11cf, 0x8F,0xD0,0x00,0xAA,0x00,0x68,0x6F,0x13);
DEFINE_GUID( CGID_DocHostCommandHandler,    0xf38bc242,0xb950,0x11d1, 0x89,0x18,0x00,0xc0,0x4f,0xc2,0xc8,0x36);
DEFINE_GUID( SID_SHTMLEditServices,         0x3050f7f9,0x98b5,0x11cf, 0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);

// OC Multimedia GUIDs

// Bitmap Surface format IDs:
// These are the same guids as used in the equivalent MEDIASUBTYPE_RGB* guids defined by DirectX.
DEFINE_GUID(  BFID_MONOCHROME,              0xe436eb78,0x524f,0x11ce,0x9f,0x53,0x00,0x20,0xaf,0x0b,0xa7,0x70);
DEFINE_GUID(  BFID_RGB_4,                   0xe436eb79,0x524f,0x11ce,0x9f,0x53,0x00,0x20,0xaf,0x0b,0xa7,0x70);
DEFINE_GUID(  BFID_RGB_8,                   0xe436eb7a,0x524f,0x11ce,0x9f,0x53,0x00,0x20,0xaf,0x0b,0xa7,0x70);
DEFINE_GUID(  BFID_RGB_555,                 0xe436eb7c,0x524f,0x11ce,0x9f,0x53,0x00,0x20,0xaf,0x0b,0xa7,0x70);
DEFINE_GUID(  BFID_RGB_565,                 0xe436eb7b,0x524f,0x11ce,0x9f,0x53,0x00,0x20,0xaf,0x0b,0xa7,0x70);
DEFINE_GUID(  BFID_RGB_24,                  0xe436eb7d,0x524f,0x11ce,0x9f,0x53,0x00,0x20,0xaf,0x0b,0xa7,0x70);
DEFINE_GUID(  BFID_RGB_32,                  0xe436eb7e,0x524f,0x11ce,0x9f,0x53,0x00,0x20,0xaf,0x0b,0xa7,0x70);
DEFINE_GUID(  BFID_RGBA_32,                 0x773c9ac0,0x3274,0x11d0,0xb7,0x24,0x00,0xaa,0x00,0x6c,0x1a,0x01);
DEFINE_GUID(  BFID_GRAY_8,                  0xd93de910,0x449c,0x11d0,0x91,0x8c,0x00,0xaa,0x00,0x6c,0x1a,0x01);
DEFINE_GUID(  BFID_GRAY_16,                 0xf9d6bc00,0x449c,0x11d0,0x91,0x8c,0x00,0xaa,0x00,0x6c,0x1a,0x01);

// Access to MSHTML's ditherer

DEFINE_GUID( CLSID_IntDitherer,             0x05f6fe1a,0xecef,0x11d0,0xaa,0xe7,0x00,0xc0,0x4f,0xc9,0xb3,0x04);
DEFINE_GUID( IID_IIntDitherer,              0x06670ca0,0xecef,0x11d0,0xaa,0xe7,0x00,0xc0,0x4f,0xc9,0xb3,0x04);

// Named Timer used by Trident
DEFINE_GUID(  NAMEDTIMER_DRAW,              0x3050f362,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);

// Channel: Code Download: SoftDist GUIDS
DEFINE_GUID( CLSID_SoftDistExt,             0xb15b8dc0,0xc7e1,0x11d0,0x86,0x80,0x00,0xaa,0x00,0xbd,0xcb,0x71);

// ActiveXSafety
DEFINE_GUID( CLSID_IActiveXSafetyProvider,  0xaaf8c6ce,0xf972,0x11d0,0x97,0xeb,0x00,0xaa,0x00,0x61,0x53,0x33);

// Security Manager.
DEFINE_GUID( CLSID_InternetSecurityManager, 0x7b8a2d94,0x0ac9,0x11d1,0x89,0x6c,0x00,0xc0,0x4f,0xb6,0xbf,0xc4);

DEFINE_GUID( CLSID_InternetZoneManager,     0x7b8a2d95,0x0ac9,0x11d1,0x89,0x6c,0x00,0xc0,0x4f,0xb6,0xbf,0xc4);

// HTMLLoadOptions
DEFINE_GUID( CLSID_HTMLLoadOptions,         0x18845040,0x0fa5,0x11d1,0xba,0x19,0x00,0xc0,0x4f,0xd9,0x12,0xd0);

// Webcheck guids
DEFINE_GUID( CLSID_SubscriptionThrottler,   0x1e9b00e5,0x9846,0x11d1,0xa1,0xee,0x00,0xc0,0x4f,0xc2,0xfb,0xe1);

// Download status guids
DEFINE_GUID( CGID_DownloadHost,             0xe0608728,0xae4c,0x11d1,0xba,0x40,0x00,0xc0,0x4f,0xb9,0x2d,0x79);

// IE host exec guids
DEFINE_GUID( CGID_InternetExplorer,         0xeb7eed00,0xf74d,0x11d2,0xbb,0x7f,0x00,0x10,0x4b,0x35,0xe7,0xf9);

// IVersionHost guids
DEFINE_GUID( SID_SVersionHost,              0x371ea634,0xdc5c,0x11d1,0xba,0x57,0x00,0xc0,0x4f,0xc2,0x04,0x0e);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\asctrls\asctlpch.cpp ===
#include "asctlpch.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\published\uuid\unix\obguid.h ===
/* processed by mwprepro */
/***
*obguid.h
*
*  Copyright (C) 1992, Microsoft Corporation.  All Rights Reserved.
*  Information Contained Herein Is Proprietary and Confidential.
*
*Purpose:
*  Definitions of private OB owned GUIDs.
*
* [00]	26-Jan-93 gustavj: Created.
*
*Implementation Notes:
*  OLE has given OB a range of GUIDs to use for its classes.  This range
*  consists of 256 possible GUIDs.  The GUIDs for public classes
*  (such as ItypeInfo) take GUIDs starting at the low end of the range,
*  private classes(such as GEN_DTINFO), take GUIDs starting at the high
*  end.  New GUIDs that are added should maintain this convention.
*
*  GUIDs for OB public classes are defined in switches.hxx.
*
*****************************************************************************/

#ifndef obguid_HXX_INCLUDED
#define obguid_HXX_INCLUDED

#define DEFINE_OBOLEGUID(name, b) DEFINE_OLEGUID(name,(0x00020400+b), 0, 0);

DEFINE_OBOLEGUID(CLSID_GenericTypeLibOLE, 0xff)

DEFINE_OBOLEGUID(IID_TYPEINFO	      , 0xfc)
DEFINE_OBOLEGUID(IID_DYNTYPEINFO      , 0xfb)

DEFINE_OBOLEGUID(IID_CDefnTypeComp    , 0xf5)

DEFINE_OBOLEGUID(IID_TYPELIB_GEN_DTINFO  , 0xf2)

// {DD23B040-296F-101B-99A1-08002B2BD119}
DEFINE_GUID(CLSID_TypeLibCF,
    0xDD23B040L,0x296F,0x101B,0x99,0xA1,0x08,0x00,0x2B,0x2B,0xD1,0x19);
//{F5AA2660-BA14-1069-8AEE-00DD010F7D13}
DEFINE_GUID(IID_IGenericTypeLibOLE,
    0xF5AA2660L,0xBA14,0x1069,0x8A,0xEE,0x00,0xDD,0x01,0x0F,0x7D,0x13);


#endif  // !obguid_HXX_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\published\uuid\unix\guids.h ===
/*** 
*guids.h
*
*Purpose:
*  This file defines all GUIDS the Unix project could not find defined 
*  elsewhere.  If you know where the proper place for some of these 
*  GUID definitions are, remove these and use the other ones.
*
*  Actually, most of these if not all are in comdefs.h
*  Unfortunately they use __declspec(uuid), though.  We might want to 
*  run a script past those and generate this file...  (davidd)
*
*Implementation Notes:
*
*****************************************************************************/

#include <obguid.h>
#include <clsid.h>
#include <urlmon.h>
#include <oleguid.h>
#include <coguid.h>
#include <olectl.h>


DEFINE_OLEGUID(CLSID_DfMarshal,		0x0000030b, 0, 0);

DEFINE_OLEGUID(IID_IDispatch,		0x00020400L, 0, 0);
DEFINE_OLEGUID(IID_IEnumVARIANT,	0x00020404L, 0, 0);
DEFINE_OLEGUID(IID_ITypeInfo,		0x00020401L, 0, 0);
DEFINE_OLEGUID(IID_ITypeLib,		0x00020402L, 0, 0);
DEFINE_OLEGUID(IID_ITypeComp,		0x00020403L, 0, 0);
DEFINE_OLEGUID(IID_ICreateTypeInfo,	0x00020405L, 0, 0);
DEFINE_OLEGUID(IID_ICreateTypeLib,	0x00020406L, 0, 0);
DEFINE_OLEGUID(IID_ICreateTypeInfo2,    0x0002040eL, 0, 0);
DEFINE_OLEGUID(IID_ITypeInfo2,          0x00020412L, 0, 0);

DEFINE_OLEGUID(IID_StdOle,		0x00020430L, 0, 0);

DEFINE_OLEGUID(CLSID_PSRemoteTypeInfo, 	0x00020424, 0, 0);

/* Because we don't have oledb_i.c, we need this IID defined here */
/* // Begin oledb_i.c */

DEFINE_GUID(IID_IRowsetChapterMember,
  0x0c733aa8L, 0x2a1c, 0x11ce, 0xad, 0xe5, 0x00, 0xaa, 0x00, 0x44, 0x77,0x3d);

/* // End oledb_i.c */


/* // {3E42C004-6BFD-17E2-B4CC-0800208359F5} */
DEFINE_GUID(IID_IWindowStatus,
  0x3E42C004L, 0x6BFD, 0x17E2, 0xB4, 0xCC, 0x08, 0x00, 0x20, 0x83, 0x59, 0xF5);

/* // {1CF2B120-547D-101B-8E65-08002B2BD119} */
DEFINE_GUID(IID_IErrorInfo,
  0x1CF2B120L, 0x547D, 0x101B, 0x8E, 0x65, 0x08, 0x00, 0x2B, 0x2B, 0xD1, 0x19);

/* // {22F03340-547D-101B-8E65-08002B2BD119} */
DEFINE_GUID(IID_ICreateErrorInfo,
  0x22F03340L, 0x547D, 0x101B, 0x8E, 0x65, 0x08, 0x00, 0x2B, 0x2B, 0xD1, 0x19);

/* // {DF0B3D60-548F-101B-8E65-08002B2BD119} */
DEFINE_GUID(IID_ISupportErrorInfo,
  0xDF0B3D60L, 0x548F, 0x101B, 0x8E, 0x65, 0x08, 0x00, 0x2B, 0x2B, 0xD1, 0x19);

/* // {0000001d-0000-0000-c000-000000000046} */
DEFINE_GUID(IID_IMallocSpy,
  0x0000001DL, 0x0000, 0x0000, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46);

// For IE
DEFINE_GUID(CLSID_URLMoniker,
  0x79eac9e0,0xbaf9,0x11ce,0x8c,0x82,0x00,0xaa,0x00,0x4b,0xa9,0x0b);

DEFINE_GUID(CLSID_MsgBand,
  0x07B8F010,0x9E21,0x11d1,0xA8,0x2E,0x08,0x00,0x09,0xDC,0x53,0x35);

// following are added for MFC4.2
DEFINE_GUID(IID_IBoundObject,
	0x9BFBBC00,0xEFF1,0x101A,0x84,0xED,0x00,0xAA,0x00,0x34,0x1D,0x07);
DEFINE_GUID(IID_IBoundObjectSite,
	0x9BFBBC01,0xEFF1,0x101A,0x84,0xED,0x00,0xAA,0x00,0x34,0x1D,0x07);

/* {DB526CC0-D188-11cd-AD48-00AA003C9CB6} */
DEFINE_GUID(IID_INotifyDBEvents,
0xdb526cc0, 0xd188, 0x11cd, 0xad, 0x48, 0x0, 0xaa, 0x0, 0x3c, 0x9c, 0xb6);

/* {9F6AA700-D188-11cd-AD48-00AA003C9CB6} */
DEFINE_GUID(IID_ICursor,
0x9f6aa700, 0xd188, 0x11cd, 0xad, 0x48, 0x0, 0xaa, 0x0, 0x3c, 0x9c, 0xb6);

/* {ACFF0690-D188-11cd-AD48-00AA003C9CB6} */
DEFINE_GUID(IID_ICursorMove,
0xacff0690, 0xd188, 0x11cd, 0xad, 0x48, 0x0, 0xaa, 0x0, 0x3c, 0x9c, 0xb6);

/* {D14216A0-D188-11cd-AD48-00AA003C9CB6} */
DEFINE_GUID(IID_ICursorUpdateARow,
0xd14216a0, 0xd188, 0x11cd, 0xad, 0x48, 0x0, 0xaa, 0x0, 0x3c, 0x9c, 0xb6);

/* Xiao-Yu ???? I couldn't find definition for the following IIDs even on
 * the lasted 4.2 enterprise edition CD.  So just defined some dummy values 
 * here to get MFC lib linked.  All the IIDs here need to be defined
 * once we find Microsoft's definition for them.
 */
DEFINE_GUID(IID_IDefViewBrowser,
0xaddf68db, 0xca3c, 0x11cf, 0x9e, 0x84, 0x00, 0x00, 0x00, 0xf8, 0x80, 0xbf); 

// A bunch of IID's formerly in olectlid.h.
DEFINE_GUID(IID_IEnumConnections,0xB196B287,0xBAB4,0x101A,0xB6,0x9C,0x00,0xAA,0x00,0x34,0x1D,0x07);
DEFINE_GUID(IID_IConnectionPoint,0xB196B286,0xBAB4,0x101A,0xB6,0x9C,0x00,0xAA,0x00,0x34,0x1D,0x07);
DEFINE_GUID(IID_IEnumConnectionPoints,0xB196B285,0xBAB4,0x101A,0xB6,0x9C,0x00,0xAA,0x00,0x34,0x1D,0x07);
DEFINE_GUID(IID_IConnectionPointContainer,0xB196B284,0xBAB4,0x101A,0xB6,0x9C,0x00,0xAA,0x00,0x34,0x1D,0x07);
DEFINE_GUID(IID_IClassFactory2,0xB196B28F,0xBAB4,0x101A,0xB6,0x9C,0x00,0xAA,0x00,0x34,0x1D,0x07);
DEFINE_GUID(IID_IProvideClassInfo,0xB196B283,0xBAB4,0x101A,0xB6,0x9C,0x00,0xAA,0x00,0x34,0x1D,0x07);
DEFINE_GUID(IID_IProvideClassInfo2,0xA6BC3AC0,0xDBAA,0x11CE,0x9D,0xE3,0x00,0xAA,0x00,0x4B,0xB8,0x51);
DEFINE_GUID(IID_IOleControl,0xB196B288,0xBAB4,0x101A,0xB6,0x9C,0x00,0xAA,0x00,0x34,0x1D,0x07);
DEFINE_GUID(IID_IOleControlSite,0xB196B289,0xBAB4,0x101A,0xB6,0x9C,0x00,0xAA,0x00,0x34,0x1D,0x07);
DEFINE_GUID(IID_IPropertyPage,0xB196B28D,0xBAB4,0x101A,0xB6,0x9C,0x00,0xAA,0x00,0x34,0x1D,0x07);
DEFINE_GUID(IID_IPropertyPage2,0x01E44665,0x24AC,0x101B,0x84,0xED,0x08,0x00,0x2B,0x2E,0xC7,0x13);
DEFINE_GUID(IID_IPropertyPageSite,0xB196B28C,0xBAB4,0x101A,0xB6,0x9C,0x00,0xAA,0x00,0x34,0x1D,0x07);
DEFINE_GUID(IID_IPropertyNotifySink,0x9BFBBC02,0xEFF1,0x101A,0x84,0xED,0x00,0xAA,0x00,0x34,0x1D,0x07);
DEFINE_GUID(IID_ISpecifyPropertyPages,0xB196B28B,0xBAB4,0x101A,0xB6,0x9C,0x00,0xAA,0x00,0x34,0x1D,0x07);
DEFINE_GUID(IID_IPersistMemory,0xBD1AE5E0,0xA6AE,0x11CE,0xBD,0x37,0x50,0x42,0x00,0xC1,0x00,0x00);
DEFINE_GUID(IID_IPersistStreamInit,0x7FD52380,0x4E07,0x101B,0xAE,0x2D,0x08,0x00,0x2B,0x2E,0xC7,0x13);
DEFINE_GUID(IID_IPersistPropertyBag,0x37D84F60,0x42CB,0x11CE,0x81,0x35,0x00,0xAA,0x00,0x4B,0xB8,0x51);
DEFINE_GUID(IID_ISimpleFrameSite,0x742B0E01,0x14E6,0x101B,0x91,0x4E,0x00,0xAA,0x00,0x30,0x0C,0xAB);
DEFINE_GUID(IID_IFont,0xBEF6E002,0xA874,0x101A,0x8B,0xBA,0x00,0xAA,0x00,0x30,0x0C,0xAB);
DEFINE_GUID(IID_IPicture,0x7BF80980,0xBF32,0x101A,0x8B,0xBB,0x00,0xAA,0x00,0x30,0x0C,0xAB);
DEFINE_GUID(IID_IFontDisp,0xBEF6E003,0xA874,0x101A,0x8B,0xBA,0x00,0xAA,0x00,0x30,0x0C,0xAB);
DEFINE_GUID(IID_IPictureDisp,0x7BF80981,0xBF32,0x101A,0x8B,0xBB,0x00,0xAA,0x00,0x30,0x0C,0xAB);
DEFINE_GUID(IID_IAdviseSinkEx,0x3AF24290,0x0C96,0x11CE,0xA0,0xCF,0x00,0xAA,0x00,0x60,0x0A,0xB8);
DEFINE_GUID(IID_IOleInPlaceObjectWindowless,0x1C2056CC,0x5EF4,0x101B,0x8B,0xC8,0x00,0xAA,0x00,0x3E,0x3B,0x29);
DEFINE_GUID(IID_IOleInPlaceSiteEx,0x9C2CAD80,0x3424,0x11CF,0xB6,0x70,0x00,0xAA,0x00,0x4C,0xD6,0xD8);
DEFINE_GUID(IID_IOleInPlaceSiteWindowless,0x922EADA0,0x3424,0x11CF,0xB6,0x70,0x00,0xAA,0x00,0x4C,0xD6,0xD8);
DEFINE_GUID(IID_IViewObjectEx,0x3AF24292,0x0C96,0x11CE,0xA0,0xCF,0x00,0xAA,0x00,0x60,0x0A,0xB8);
DEFINE_GUID(IID_IOleUndoUnit,0x894AD3B0,0xEF97,0x11CE,0x9B,0xC9,0x00,0xAA,0x00,0x60,0x8E,0x01);
DEFINE_GUID(IID_IOleParentUndoUnit,0xA1FAF330,0xEF97,0x11CE,0x9B,0xC9,0x00,0xAA,0x00,0x60,0x8E,0x01);
DEFINE_GUID(IID_IEnumOleUndoUnits,0xB3E7C340,0xEF97,0x11CE,0x9B,0xC9,0x00,0xAA,0x00,0x60,0x8E,0x01);
DEFINE_GUID(IID_IOleUndoManager,0xD001F200,0xEF97,0x11CE,0x9B,0xC9,0x00,0xAA,0x00,0x60,0x8E,0x01);
DEFINE_GUID(IID_IQuickActivate,0xCF51ED10,0x62FE,0x11CF,0xBF,0x86,0x00,0xA0,0xC9,0x03,0x48,0x36);
DEFINE_GUID(IID_IPointerInactive,0x55980BA0,0x35AA,0x11CF,0xB6,0x71,0x00,0xAA,0x00,0x4C,0xD6,0xD8);
DEFINE_GUID(IID_IObjectWithSite,0xFC4801A3,0x2BA9,0x11CF,0xA2,0x29,0x00,0xAA,0x00,0x3D,0x73,0x52);
DEFINE_GUID(IID_IErrorLog,0x3127CA40,0x446E,0x11CE,0x81,0x35,0x00,0xAA,0x00,0x4B,0xB8,0x51);
DEFINE_GUID(IID_IPropertyBag,0x55272A00,0x42CB,0x11CE,0x81,0x35,0x00,0xAA,0x00,0x4B,0xB8,0x51);
DEFINE_GUID(IID_IPerPropertyBrowsing,0x376BD3AA,0x3845,0x101B,0x84,0xED,0x08,0x00,0x2B,0x2E,0xC7,0x13);
DEFINE_GUID(IID_IClientSecurity,     0x0000013d,0x0000,0x0000,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);
DEFINE_GUID(IID_IRichEditOleCallback,0x00020d03,0x0000,0x0000,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

// Stuff from java/common/inc/pdlgguid.h (in permdlg.lib)
DEFINE_GUID(IID_IJavaZonePermissionEditor, 0x85347F8A,0xC8B7,0x11d0,0x88,0x23,0x00,0xC0,0x4F,0xB6,0x7C,0x84);
DEFINE_GUID(CLSID_JavaRuntimeConfiguration, 0x004CE610,0xCCD1,0x11d0,0xA9,0xBA,0x00,0xA0,0xC9,0x08,0xDB,0x5E);

// Stuff for old trident 4.0


DEFINE_GUID(DIID_DispIHTMLLinkElement, 0x3050f524,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLFormElement, 0x3050f510,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLControlElement, 0x3050f53f,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLTextElement, 0x3050f537,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLTextContainer, 0x3050f53e,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLImgElement, 0x3050f51c,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLBodyElement, 0x3050f507,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLFontElement, 0x3050f512,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLAnchorElement, 0x3050f502,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLLabelElement, 0x3050f522,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLListElement, 0x3050f525,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLUListElement, 0x3050f538,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLOListElement, 0x3050f52a,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLLIElement, 0x3050f523,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLBlockElement, 0x3050f506,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLDivElement, 0x3050f50c,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLDDElement, 0x3050f50b,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLDTElement, 0x3050f50d,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLBRElement, 0x3050f53a,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLDListElement, 0x3050f53b,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLHRElement, 0x3050f53d,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLParaElement, 0x3050f52c,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLHeaderElement, 0x3050f515,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLSelectElement, 0x3050f531,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLOptionElement, 0x3050f52b,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLTextAreaElement, 0x3050f521,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLButtonElement, 0x3050f51f,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLMarqueeElement, 0x3050f527,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLTitleElement, 0x3050f516,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLMetaElement, 0x3050f517,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLBaseElement, 0x3050f518,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLIsIndexElement, 0x3050f519,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLNextIdElement, 0x3050f51a,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLBaseFontElement, 0x3050f504,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLUnknownElement, 0x3050f539,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLEmbedElement, 0x3050f52e,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLMapElement, 0x3050f526,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLAreaElement, 0x3050f503,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLTableCaption, 0x3050f508,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLCommentElement, 0x3050f50a,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLPhraseElement, 0x3050f52d,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLSpanElement, 0x3050f548,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLTable, 0x3050f532,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLTableCol, 0x3050f533,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLTableSection, 0x3050f534,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLTableRow, 0x3050f535,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLTableCell, 0x3050f536,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLScriptElement, 0x3050f530,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLNoShowElement, 0x3050f528,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLObjectElement, 0x3050f529,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLFrameBase, 0x3050f541,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLFrameElement, 0x3050f513,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLIFrameElement, 0x3050f51b,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLDivPosition, 0x3050f50f,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLFieldSetElement, 0x3050f545,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLLegendElement, 0x3050f546,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLSpanFlow, 0x3050f544,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLFrameSetElement, 0x3050f514,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLBGsound, 0x3050f53c,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLStyleElement, 0x3050f511,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);

DEFINE_GUID(CLSID_OfflineTrayAgent,
    0xE8BB6DC0,0x6B4E,0x11d0,0x92,0xDB,0x00,0xA0,0xC9,0x0C,0x2B,0xD7);
DEFINE_GUID(CLSID_ConnectionAgent,
    0xE6CC6978,0x6B6E,0x11D0,0xBE,0xCA,0x00,0xC0,0x4F,0xD9,0x40,0xBE);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\asctrls\asctlpch.h ===
#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include <commdlg.h>
#include <olectl.h>
#include <shlobj.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\active.inc ===
C_DEFINES=    \
              $(C_DEFINES)          \
              -DFLAT                \
              -DWIN32=100           \
              -D_NT1X_=100          \
              -DINC_OLE2            \
              -DNOEXCEPTIONS        \
              -DNASHVILLE

# Do this to assure we run on NT 4.0/Win95, even with
# NT5/Memphis headers.
WIN32_WINNT_VERSION=0x0400
WIN32_WIN95_VERSION=0x0400

SDSUTILS_PATH=..\..\sdslib

# For the Daytona build, we do not want statically linked compiler runtimes,
# so leave this commented out.
#
# USE_LIBCMT=   1
# USE_MSVCRT=1
USE_NOLIBS = 1

MSC_WARNING_LEVEL=/W3 /WX

USE_MAPSYM=1


#              -DUNICODE             \
#              -D_UNICODE            \
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\asctrls\asctrls.cpp ===
//=--------------------------------------------------------------------------=
// astextmn.cpp
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// various globals which the framewrk requires
//
//

#include "asctlpch.h"

#define INITOBJECTS                // define the descriptions for our objects

#include "ipserver.h"
#include "localsrv.h"

#include "ctrlobj.h"
#include "globals.h"
#include "util.h"
#include "asinsctl.h"


/// for safe scripting
#include "cathelp.h"


const IID IID_ICatRegister = {0x0002E012,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};
const CATID CATID_SafeForScripting              = {0x7dd95801,0x9882,0x11cf,{0x9f,0xa9,0x00,0xaa,0x00,0x6c,0x42,0xc4}};
const CATID CATID_SafeForInitializing   = {0x7dd95802,0x9882,0x11cf,{0x9f,0xa9,0x00,0xaa,0x00,0x6c,0x42,0xc4}};

// needed for ASSERTs and FAIL
//
SZTHISFILE

//=--------------------------------------------------------------------------=
// our Libid.  This should be the LIBID from the Type library, or NULL if you
// don't have one.
//
const CLSID *g_pLibid = &LIBID_ASControls;


//=--------------------------------------------------------------------------=
// Localization Information
//
// We need the following two pieces of information:
//    a. whether or not this DLL uses satellite DLLs for localization.  if
//       not, then the lcidLocale is ignored, and we just always get resources
//       from the server module file.
//    b. the ambient LocaleID for this in-proc server.  Controls calling
//       GetResourceHandle() will set this up automatically, but anybody
//       else will need to be sure that it's set up properly.
//
const VARIANT_BOOL g_fSatelliteLocalization =  FALSE;

LCID  g_lcidLocale = MAKELCID(LANG_USER_DEFAULT, SORT_DEFAULT);


//=--------------------------------------------------------------------------=
// your license key and where under HKEY_CLASSES_ROOT_LICENSES it's sitting
//
const WCHAR g_wszLicenseKey [] = L"";
const WCHAR g_wszLicenseLocation [] = L"";


WNDPROC g_ParkingWindowProc = NULL;

//=--------------------------------------------------------------------------=
// This Table describes all the automatible objects in your automation server.
// See AutomationObject.H for a description of what goes in this structure
// and what it's used for.
//
OBJECTINFO g_ObjectInfo[] = {
    CONTROLOBJECT(InstallEngineCtl),
    EMPTYOBJECT
};

const char g_szLibName[] = "ASControls";

//=--------------------------------------------------------------------------=
// IntializeLibrary
//=--------------------------------------------------------------------------=
// called from DllMain:DLL_PROCESS_ATTACH.  allows the user to do any sort of
// initialization they want to.
//
// Notes:
//
void InitializeLibrary(void)
{
    // TODO: initialization here.  control window class should be set up in
    // RegisterClassData.
}

//=--------------------------------------------------------------------------=
// UninitializeLibrary
//=--------------------------------------------------------------------------=
// called from DllMain:DLL_PROCESS_DETACH.  allows the user to clean up anything
// they want.
//
// Notes:
//
void UninitializeLibrary(void)
{
    // TODO: uninitialization here.  control window class will be unregistered
    // for you, but anything else needs to be cleaned up manually.
    // Please Note that the Window 95 DLL_PROCESS_DETACH isn't quite as stable
    // as NT's, and you might crash doing certain things here ...
}


//=--------------------------------------------------------------------------=
// CheckForLicense
//=--------------------------------------------------------------------------=
// users can implement this if they wish to support Licensing.  otherwise,
// they can just return TRUE all the time.
//
// Parameters:
//    none
//
// Output:
//    BOOL            - TRUE means the license exists, and we can proceed
//                      FALSE means we're not licensed and cannot proceed
//
// Notes:
//    - implementers should use g_wszLicenseKey and g_wszLicenseLocation
//      from the top of this file to define their licensing [the former
//      is necessary, the latter is recommended]
//
BOOL CheckForLicense(void)
{
    // TODO: decide whether or not your server is licensed in this function.
    // people who don't want to bother with licensing should just return
    // true here always.  g_wszLicenseKey and g_wszLicenseLocation are
    // used by IClassFactory2 to do some of the licensing work.
    //
    return TRUE;
}

//=--------------------------------------------------------------------------=
// RegisterData
//=--------------------------------------------------------------------------=
// lets the inproc server writer register any data in addition to that in
// any other objects.
//
// Output:
//    BOOL            - false means failure.
//
// Notes:
//
BOOL RegisterData(void)
{
   //=--------------------------------------------------------------------------=
// RegisterData
//=--------------------------------------------------------------------------=
// lets the inproc server writer register any data in addition to that in
// any other objects.
//
// Output:
//    BOOL            - false means failure.
//
// Notes:
//    
   /// For safe scripting
   HRESULT hr;
   hr = CreateComponentCategory(CATID_SafeForScripting, L"Controls that are safely scriptable");
   if(SUCCEEDED(hr))
      hr = CreateComponentCategory(CATID_SafeForInitializing, L"Controls safely initializable from persistent data");
 
   if(SUCCEEDED(hr))
      hr = RegisterCLSIDInCategory(CLSID_InstallEngineCtl, CATID_SafeForScripting);
   if(SUCCEEDED(hr))
      hr = RegisterCLSIDInCategory(CLSID_InstallEngineCtl, CATID_SafeForInitializing);
 

   if(FAILED(hr))
   {
      DllUnregisterServer();
   }
   
   return (SUCCEEDED(hr) ? TRUE : FALSE);
}

//=--------------------------------------------------------------------------=
// UnregisterData
//=--------------------------------------------------------------------------=
// inproc server writers should unregister anything they registered in
// RegisterData() here.
//
// Output:
//    BOOL            - false means failure.
//
// Notes:
//
BOOL UnregisterData(void)
{
           /// For safe scripting
   HRESULT hr;
   hr = UnRegisterCLSIDInCategory(CLSID_InstallEngineCtl, CATID_SafeForScripting);
   hr = UnRegisterCLSIDInCategory(CLSID_InstallEngineCtl, CATID_SafeForInitializing);
   return TRUE;
}

BOOL CheckLicenseKey(LPWSTR wszCheckme)
{
	return TRUE;
}

BSTR GetLicenseKey(void)
{
	return SysAllocString(L"");
}



LPSTR MakeAnsiStrFromAnsi(LPSTR psz)
{
   LPSTR pszTmp;
   
   if(psz == NULL)
      return NULL;

   pszTmp = (LPSTR) CoTaskMemAlloc(lstrlenA(psz) + 1);
   if(pszTmp)
      lstrcpyA(pszTmp, psz);

   return pszTmp;
}


LPSTR CopyAnsiStr(LPSTR psz)
{
   LPSTR pszTmp;
   
   if(psz == NULL)
      return NULL;

   pszTmp = (LPSTR) new char[lstrlenA(psz) + 1];
   if(pszTmp)
      lstrcpyA(pszTmp, psz);

   return pszTmp;
}

//=--------------------------------------------------------------------------=
// CRT stubs
//=--------------------------------------------------------------------------=
// these two things are here so the CRTs aren't needed. this is good.
//
// basically, the CRTs define this to pull in a bunch of stuff.  we'll just
// define them here so we don't get an unresolved external.
//
// TODO: if you are going to use the CRTs, then remove this line.
//
extern "C" int _fltused = 1;

extern "C" int _cdecl _purecall(void)
{
  FAIL("Pure virtual function called.");
  return 0;
}

#ifndef _X86_
extern "C" void _fpmath() {}
#endif



void * _cdecl malloc(size_t n)
{
#ifdef _MALLOC_ZEROINIT
        void* p = HeapAlloc(g_hHeap, 0, n);
        if (p != NULL)
                memset(p, 0, n);
        return p;
#else
        return HeapAlloc(g_hHeap, 0, n);
#endif
}

void * _cdecl calloc(size_t n, size_t s)
{
#ifdef _MALLOC_ZEROINIT
        return malloc(n * s);
#else
        void* p = malloc(n * s);
        if (p != NULL)
                memset(p, 0, n * s);
        return p;
#endif
}

void* _cdecl realloc(void* p, size_t n)
{
        if (p == NULL)
                return malloc(n);

        return HeapReAlloc(g_hHeap, 0, p, n);
}

void _cdecl free(void* p)
{
        if (p == NULL)
                return;

        HeapFree(g_hHeap, 0, p);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\asctrls\asinsctl.cpp ===
//=--------------------------------------------------------------------------=
// inseng.cpp
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
//
#include "asctlpch.h"

#include "ipserver.h"
#include <wininet.h>
#include "util.h"
#include "globals.h"
#include "asinsctl.h"
#include "dispids.h"
#include "resource.h"
#include "util2.h"
#include <mshtml.h>

// for ASSERT and FAIL
//
SZTHISFILE

WCHAR wszInsFile [] = L"InstallList";
WCHAR wszBaseUrl [] = L"BaseUrl";
WCHAR wszCabName [] = L"CabName";

#define EVENT_ONSTARTINSTALL    0
#define EVENT_ONSTARTCOMPONENT  1
#define EVENT_ONSTOPCOMPONENT   2
#define EVENT_ONSTOPINSTALL     3
#define EVENT_ONENGINESTATUSCHANGE  4
#define EVENT_ONENGINEPROBLEM  5
#define EVENT_ONCHECKFREESPACE 6
#define EVENT_ONCOMPONENTPROGRESS 7
#define EVENT_ONSTARTINSTALLEX     8

#define EVENT_CANCEL  10

static VARTYPE rgI4[] = { VT_I4 };
static VARTYPE rgI4_2[] = { VT_I4, VT_I4 };
static VARTYPE rgStartComponent[] = { VT_BSTR, VT_I4, VT_BSTR };
static VARTYPE rgStopComponent[] = { VT_BSTR, VT_I4, VT_I4, VT_BSTR, VT_I4 };
static VARTYPE rgStopInstall[] = { VT_I4, VT_BSTR, VT_I4 };
static VARTYPE rgEngineProblem[] = { VT_I4 };
static VARTYPE rgCheckFreeSpace[] = { VT_BSTR, VT_I4, VT_BSTR, VT_I4, VT_BSTR, VT_I4 };
static VARTYPE rgComponentProgress[] = { VT_BSTR, VT_I4, VT_BSTR, VT_BSTR, VT_I4, VT_I4 };


#define WM_INSENGCALLBACK  WM_USER+34

static EVENTINFO rgEvents [] = {
    { DISPID_ONSTARTINSTALL, 1, rgI4 },           // (long percentDone)
    { DISPID_ONSTARTCOMPONENT, 3, rgStartComponent },
    { DISPID_ONSTOPCOMPONENT, 5, rgStopComponent },
    { DISPID_ONSTOPINSTALL, 3, rgStopInstall },
    { DISPID_ENGINESTATUSCHANGE, 2, rgI4_2 },
    { DISPID_ONENGINEPROBLEM, 1, rgEngineProblem },
    { DISPID_ONCHECKFREESPACE, 6, rgCheckFreeSpace },
    { DISPID_ONCOMPONENTPROGRESS, 6, rgComponentProgress },
    { DISPID_ONSTARTINSTALLEX, 2, rgI4_2 },
};

UINT          g_uCDAutorunMsg;
unsigned long g_ulOldAutorunSetting;

const char g_cszIEJITInfo[] = "Software\\Microsoft\\Active Setup\\JITInfo";
const char g_cszPolicyExplorer[] = "Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer";
const char g_cszAutorunSetting[] = "NoDriveTypeAutoRun";

//=---------------------------------------------
// SetAutorunSetting
//=---------------------------------------------
unsigned long SetAutorunSetting(unsigned long ulValue)
{
    HKEY          hKey;
    unsigned long ulOldSetting;
    unsigned long ulNewSetting = ulValue;
    DWORD         dwSize = sizeof(unsigned long);

    if( RegOpenKeyEx(HKEY_CURRENT_USER, g_cszPolicyExplorer , 0, KEY_READ|KEY_WRITE, &hKey ) == ERROR_SUCCESS )
    {
        if( RegQueryValueEx(hKey, g_cszAutorunSetting, 0, NULL, (unsigned char*)&ulOldSetting,  &dwSize ) == ERROR_SUCCESS )
        {
            RegSetValueEx(hKey, g_cszAutorunSetting, 0, REG_BINARY, (const unsigned char*)&ulNewSetting, 4);
        }
        else
            ulOldSetting = WINDOWS_DEFAULT_AUTOPLAY_VALUE;

        RegFlushKey( hKey );
        RegCloseKey( hKey );
    }

    return ulOldSetting;
}


//=--------------------------------------------------------------------------=
// CInstallEngineCtl::Create
//=--------------------------------------------------------------------------=
// global static function that creates an instance of the control an returns
// an IUnknown pointer for it.
//
// Parameters:
//    IUnknown *        - [in] controlling unknown for aggregation
//
// Output:
//    IUnknown *        - new object.
//
// Notes:
//

IUnknown *CInstallEngineCtl::Create(IUnknown *pUnkOuter)
{
    // make sure we return the private unknown so that we support aggegation
    // correctly!
    //
    BOOL bSuccess;

    CInstallEngineCtl *pNew = new CInstallEngineCtl(pUnkOuter, &bSuccess);
    if(bSuccess)
       return pNew->PrivateUnknown();
    else
    {
       delete pNew;
       return NULL;
    }
}

//=--------------------------------------------------------------------------=
// CInstallEngineCtl::CInstallEngineCtl
//=--------------------------------------------------------------------------=
//
// Parameters:
//    IUnknown *        - [in]
//
// Notes:
//
#pragma warning(disable:4355)  // using 'this' in constructor, safe here
CInstallEngineCtl::CInstallEngineCtl(IUnknown *pUnkOuter, BOOL *pbSuccess)
  : COleControl(pUnkOuter, OBJECT_INSTALLENGINECTL, (IDispatch *)this)
{
   HRESULT hr;
   DWORD   dwVersion = 0;

   *pbSuccess = TRUE;
   _hIcon = NULL;

   // null out all base urls
   ZeroMemory( _rpszUrlList, sizeof(LPSTR) * MAX_URLS);
   _uCurrentUrl = 0;

   _pProgDlg = NULL;
   _pinseng = NULL;
   _pszErrorString = NULL;
   _hDone = NULL;
   _hResult = NOERROR;
   m_readyState = READYSTATE_COMPLETE;
   _uAllowGrovel = 0xffffffff;
   _fNeedReboot = FALSE;
   _szDownloadDir[0] = 0;
   _fEventToFire = FALSE;
   _dwSavedEngineStatus = 0;
   _dwSavedSubStatus = 0;
   _dwFreezeEvents = 0;
   _dwProcessComponentsFlags = 0;
   _dwMSTrustKey = (DWORD)-1;
   _uCurrentUrl = 0xffffffff;
   _fReconcileCif = FALSE;
   _fLocalCifSet = FALSE;
   _fDoingIEInstall = FALSE;
   _uInstallMode = 0;
   _uInstallPad  = 0;
   _strCurrentID = NULL;
   _strCurrentName = NULL;
   _strCurrentString = NULL;
   _fInstalling = FALSE;
   _bCancelPending = FALSE;
   _bDeleteURLList = FALSE;
   _bNewWebSites = FALSE;
   _fJITInstall = FALSE;

   // Register for the special CD Autorun message.
   g_uCDAutorunMsg = RegisterWindowMessage(TEXT("QueryCancelAutoPlay"));


   hr = CoCreateInstance(CLSID_InstallEngine, NULL, CLSCTX_INPROC_SERVER,
                         IID_IInstallEngine2,(void **) &_pinseng);

   if(_pinseng)
   {
      _pinseng->SetDownloadDir(NULL);
      _pinseng->SetInstallOptions(INSTALLOPTIONS_DOWNLOAD |
                                  INSTALLOPTIONS_INSTALL |
                                  INSTALLOPTIONS_DONTALLOWXPLATFORM);
      _pinseng->SetHWND(GetActiveWindow());
      _pinseng->RegisterInstallEngineCallback((IInstallEngineCallback *)this);
   }
   else
      *pbSuccess = FALSE;

   _dwLastPhase = 0xffffffff;

   // set up our initial size ... + 6 so we can have raised edge
   m_Size.cx = 6 + GetSystemMetrics(SM_CXICON);
   m_Size.cy = 6 + GetSystemMetrics(SM_CYICON);
#ifdef TESTCERT
   UpdateTrustState();
#endif
   SetControlFont();
}
#pragma warning(default:4355)  // using 'this' in constructor

//=--------------------------------------------------------------------------=
// CInstallEngineCtl::~CInstallEngineCtl
//=--------------------------------------------------------------------------=
//
// Notes:
//
CInstallEngineCtl::~CInstallEngineCtl()
{
   if(_pinseng)
   {
      _pinseng->SetHWND(NULL);
      _pinseng->UnregisterInstallEngineCallback();
      _pinseng->Release();
   }

   for(int i = 0; i < MAX_URLS; i++)
      if(_rpszUrlList[i])
         delete _rpszUrlList[i];

   // Is all this needed? Only in case where OnStopInstall is never called...
   if(_pProgDlg)
      delete _pProgDlg;

   if(_pszErrorString)
      free(_pszErrorString);

   if (_dwMSTrustKey != (DWORD)-1)
      WriteMSTrustKey(FALSE, _dwMSTrustKey);
#ifdef TESTCERT
   ResetTestrootCertInTrustState();
#endif

   // delete ActiveSetup value from IE4\Options
   WriteActiveSetupValue(FALSE);
   if (g_hFont)
   {
       DeleteObject(g_hFont);
       g_hFont = NULL;
   }
}

//=--------------------------------------------------------------------------=
// CInstallEngineCtl:RegisterClassData
//=--------------------------------------------------------------------------=
// register the window class information for your control here.
// this information will automatically get cleaned up for you on DLL shutdown.
//
// Output:
//    BOOL            - FALSE means fatal error.
//
// Notes:
//
BOOL CInstallEngineCtl::RegisterClassData()
{
    WNDCLASS wndclass;

    // TODO: register any additional information you find interesting here.
    //       this method is only called once for each type of control
    //
    memset(&wndclass, 0, sizeof(WNDCLASS));
    wndclass.style          = CS_VREDRAW | CS_HREDRAW | CS_DBLCLKS;
    wndclass.lpfnWndProc    = COleControl::ControlWindowProc;
    wndclass.hInstance      = g_hInstance;
    wndclass.hCursor        = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground  = (HBRUSH)(COLOR_WINDOW);
    wndclass.lpszClassName  = WNDCLASSNAMEOFCONTROL(OBJECT_INSTALLENGINECTL);

    return RegisterClass(&wndclass);
}

//=--------------------------------------------------------------------------=
// CInstallEngineCtl::BeforeCreateWindow
//=--------------------------------------------------------------------------=
// called just before the window is created.  Great place to set up the
// window title, etc, so that they're passed in to the call to CreateWindowEx.
// speeds things up slightly.
//
// Notes:
//
void CInstallEngineCtl::BeforeCreateWindow()
{

}


//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

BOOL CInstallEngineCtl::AfterCreateWindow()
{
   MarkJITInstall();
   return TRUE;
}

//=--------------------------------------------------------------------------=
// CInstallEngineCtl::InternalQueryInterface
//=--------------------------------------------------------------------------=
// qi for things only we support.
//
// Parameters:
// Parameters:
//    REFIID        - [in]  interface they want
//    void **       - [out] where they want to put the resulting object ptr.
//
// Output:
//    HRESULT       - S_OK, E_NOINTERFACE
//
// Notes:
//
HRESULT CInstallEngineCtl::InternalQueryInterface(REFIID  riid, void  **ppvObjOut)
{
    IUnknown *pUnk;

    *ppvObjOut = NULL;

    // TODO: if you want to support any additional interrfaces, then you should
    // indicate that here.  never forget to call COleControl's version in the
    // case where you don't support the given interface.
    //
    if (DO_GUIDS_MATCH(riid, IID_IInstallEngine)) {
        pUnk = (IUnknown *)(IInstallEngine *)this;
    } else{
        return COleControl::InternalQueryInterface(riid, ppvObjOut);
    }

    pUnk->AddRef();
    *ppvObjOut = (void *)pUnk;
    return S_OK;
}

//=--------------------------------------------------------------------------=
// CInstallEngineCtl::LoadTextState
//=--------------------------------------------------------------------------=
// load in our text state for this control.
//
// Parameters:
//    IPropertyBag *        - [in] property bag to read from
//    IErrorLog *           - [in] errorlog object to use with proeprty bag
//
// Output:
//    HRESULT
//
// Notes:
//    - NOTE: if you have a binary object, then you should pass an unknown
//      pointer to the property bag, and it will QI it for IPersistStream, and
//      get said object to do a Load()
//
STDMETHODIMP CInstallEngineCtl::LoadTextState(IPropertyBag *pPropertyBag, IErrorLog *pErrorLog)
{
   VARIANT v;
   VARIANT v2;
   HRESULT hr;

	VariantInit(&v);

   v.vt = VT_BSTR;
   v.bstrVal = NULL;

	VariantInit(&v2);

   v2.vt = VT_BSTR;
   v2.bstrVal = NULL;
	// try to load in the property.  if we can't get it, then leave
   // things at their default.
   //

   v.vt = VT_BSTR;
   v.bstrVal = NULL;

   hr = pPropertyBag->Read(::wszBaseUrl, &v, pErrorLog);
   if(SUCCEEDED(hr))
      hr = put_BaseUrl(v.bstrVal);

   VariantClear(&v);

   //
   // IMPORTANT: Trident no longer defaults to VT_BSTR if no variant type is specified
   //
   v.vt = VT_BSTR;
   v.bstrVal = NULL;

   hr = pPropertyBag->Read(::wszCabName, &v, pErrorLog);
   if(SUCCEEDED(hr))
      hr = pPropertyBag->Read(::wszInsFile, &v2, pErrorLog);
   if(SUCCEEDED(hr))
   {
      hr = SetCifFile(v.bstrVal, v2.bstrVal);
   }
   VariantClear(&v);
   VariantClear(&v2);

   return S_OK;
}

//=--------------------------------------------------------------------------=
// CInstallEngineCtl::LoadBinaryState
//=--------------------------------------------------------------------------=
// loads in our binary state using streams.
//
// Parameters:
//    IStream *            - [in] stream to write to.
//
// Output:
//    HRESULT
//
// Notes:
//
const DWORD STREAMHDR_MAGIC = 12345678L;

STDMETHODIMP CInstallEngineCtl::LoadBinaryState(IStream *pStream)
{
	DWORD		sh;
   HRESULT		hr;

   // first read in the streamhdr, and make sure we like what we're getting
   //
   hr = pStream->Read(&sh, sizeof(sh), NULL);
   RETURN_ON_FAILURE(hr);

   // sanity check
   //
   if (sh != STREAMHDR_MAGIC )
      return E_UNEXPECTED;

	return(S_OK);
}

//=--------------------------------------------------------------------------=
// CInstallEngineCtl::SaveTextState
//=--------------------------------------------------------------------------=
// saves out the text state for this control using a property bag.
//
// Parameters:
//    IPropertyBag *        - [in] the property bag with which to work.
//    BOOL                  - [in] if TRUE, then write out ALL properties, even
//                            if they're their the default value ...
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP CInstallEngineCtl::SaveTextState(IPropertyBag *pPropertyBag, BOOL fWriteDefaults)
{
   return S_OK;
}

//=--------------------------------------------------------------------------=
// CInstallEngineCtl::SaveBinaryState
//=--------------------------------------------------------------------------=
// save out the binary state for this control, using the given IStream object.
//
// Parameters:
//    IStream  *             - [in] save to which you should save.
//
// Output:
//    HRESULT
//
// Notes:
//    - it is important that you seek to the end of where you saved your
//      properties when you're done with the IStream.
//
STDMETHODIMP CInstallEngineCtl::SaveBinaryState(IStream *pStream)
{
   DWORD sh = STREAMHDR_MAGIC;
   HRESULT hr;

   // write out the stream hdr.
   //
   hr = pStream->Write(&sh, sizeof(sh), NULL);
   RETURN_ON_FAILURE(hr);

   // write out he control state information
   //
   return hr;
}



//=--------------------------------------------------------------------------=
// CInstallEngineCtl::OnDraw
//=--------------------------------------------------------------------------=
//
// Parameters:
//    DWORD              - [in]  drawing aspect
//    HDC                - [in]  HDC to draw to
//    LPCRECTL           - [in]  rect we're drawing to
//    LPCRECTL           - [in]  window extent and origin for meta-files
//    HDC                - [in]  HIC for target device
//    BOOL               - [in]  can we optimize dc handling?
//
// Output:
//    HRESULT
//
// Notes:
//
HRESULT CInstallEngineCtl::OnDraw(DWORD dvAspect, HDC hdcDraw, LPCRECTL prcBounds,
                         LPCRECTL prcWBounds, HDC hicTargetDevice, BOOL fOptimize)
{
   // To provide visual appearence in DESIGN MODE only
   if(DesignMode())
   {
      if(!_hIcon)
         _hIcon = LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_INSTALLENGINE));
      DrawEdge(hdcDraw, (LPRECT)(LPCRECT)prcBounds, EDGE_RAISED, BF_RECT | BF_MIDDLE);
      if(_hIcon)
         DrawIcon(hdcDraw, prcBounds->left + 3, prcBounds->top + 3, _hIcon);
   }

   return S_OK;
}




//=--------------------------------------------------------------------------=
// CInstallEngineCtl::WindowProc
//=--------------------------------------------------------------------------=
// window procedure for this control.  nothing terribly exciting.
//
// Parameters:
//     see win32sdk on window procs.
//
// Notes:
//

typedef HRESULT (WINAPI *CHECKFORVERSIONCONFLICT) ();

LRESULT CInstallEngineCtl::WindowProc(UINT msg, WPARAM wParam, LPARAM lParam)
{
    // TODO: handle any messages here, like in a normal window
    // proc.  note that for special keys, you'll want to override and
    // implement OnSpecialKey.
    //
   LRESULT lres;
   CALLBACK_PARAMS *pcbp;

   switch (msg)
   {
      case WM_ERASEBKGND:
         if (KeepTransparent(m_hwnd, msg, wParam, lParam, &lres))
            return lres;
         break;

      case WM_ACTIVATE:
      case WM_ACTIVATEAPP:
         {
            DWORD fActive = LOWORD(wParam);
            if(fActive == WA_ACTIVE || fActive == WA_CLICKACTIVE ||
                 fActive == TRUE)
            {
               CHECKFORVERSIONCONFLICT pVerCon;
               HINSTANCE hInseng= LoadLibrary("inseng.dll");
               if(hInseng)
               {
                  pVerCon = (CHECKFORVERSIONCONFLICT)
                                GetProcAddress(hInseng, "CheckForVersionConflict");
                  if(pVerCon)
                     pVerCon();
                  FreeLibrary(hInseng);

               }
            }

         }
         return TRUE;

      case WM_INSENGCALLBACK:
         pcbp = (CALLBACK_PARAMS *) lParam;
         switch(wParam)
         {
            case EVENT_ONENGINESTATUSCHANGE:
               FireEvent( &::rgEvents[EVENT_ONENGINESTATUSCHANGE],
                   pcbp->dwStatus, pcbp->dwSubstatus );
               break;

            case EVENT_ONSTARTINSTALL:
               FireEvent(&::rgEvents[EVENT_ONSTARTINSTALL], (long) pcbp->dwSize);
               break;

            case EVENT_ONSTARTCOMPONENT:
               FireEvent(&::rgEvents[EVENT_ONSTARTCOMPONENT],
                           pcbp->strID, (long) pcbp->dwSize, pcbp->strName);
               break;

            case EVENT_ONSTOPCOMPONENT:
               FireEvent(&::rgEvents[EVENT_ONSTOPCOMPONENT], pcbp->strID, (long) pcbp->dwResult,
                            (long) pcbp->dwPhase, pcbp->strName, (long) pcbp->dwStatus);
               break;

            case EVENT_ONSTOPINSTALL:
               FireEvent(&::rgEvents[EVENT_ONSTOPINSTALL], (long) pcbp->dwResult,
                              pcbp->strString, (long) pcbp->dwStatus);
               break;

            case EVENT_ONENGINEPROBLEM:
               FireEvent(&::rgEvents[EVENT_ONENGINEPROBLEM], (long) pcbp->dwStatus);
               break;

            case EVENT_ONCHECKFREESPACE:
               FireEvent(&::rgEvents[EVENT_ONCHECKFREESPACE], pcbp->chWin,
                           (long) pcbp->dwWin, pcbp->chInstall,
                     (long) pcbp->dwInstall, pcbp->chDL, (long) pcbp->dwDL);
               break;

            case EVENT_ONCOMPONENTPROGRESS:
               FireEvent(&::rgEvents[EVENT_ONCOMPONENTPROGRESS], pcbp->strID,
                         (long) pcbp->dwPhase, pcbp->strName, pcbp->strString,
                         (long)pcbp->dwDL, (long) pcbp->dwSize);
               break;

            case EVENT_CANCEL:
               Abort(0);
               break;

            case EVENT_ONSTARTINSTALLEX:
               FireEvent(&::rgEvents[EVENT_ONSTARTINSTALLEX], (long) pcbp->dwDL, (long) pcbp->dwSize);
               break;


            default:
               break;
         }
         break;

      default:
         break;
   }
   return OcxDefWindowProc(msg, wParam, lParam);
}


//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:

STDMETHODIMP CInstallEngineCtl::FreezeEvents(BOOL bFreeze)
{
   if(bFreeze)
      _dwFreezeEvents++;
   else
   {
      if(_dwFreezeEvents)
      {
         _dwFreezeEvents--;
         // if we go to zero, fire our EngineStatus change event if we have one
         if(_dwFreezeEvents == 0 && _fEventToFire)
         {
            _FireEngineStatusChange(_dwSavedEngineStatus, _dwSavedSubStatus);
            _fEventToFire = FALSE;
         }
      }
   }
   return S_OK;
}



//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngineCtl::get_EngineStatus(long * theenginestatus)
{
   if(!_pinseng)
      return E_UNEXPECTED;

   return _pinseng->GetEngineStatus((DWORD *)theenginestatus);
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngineCtl::get_ReadyState(long * thestate)
{
   CHECK_POINTER(thestate);
  *thestate = m_readyState;
   return(NOERROR);
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngineCtl::Abort(long lFlag)
{
   if(!_pinseng)
   {
      _bCancelPending = TRUE;
      return E_UNEXPECTED;
   }

   if ( _pinseng->Abort(lFlag) != NOERROR )
      _bCancelPending = TRUE;

   return NOERROR;
}

void CInstallEngineCtl::_FireCancel(DWORD dwStatus)
{
   SendMessage(m_hwnd, WM_INSENGCALLBACK, (WPARAM) EVENT_CANCEL, NULL);

}


STDMETHODIMP CInstallEngineCtl::SetLocalCif(BSTR strCif, long FAR* lResult)
{
   *lResult = E_FAIL;

   //Allow SetLocalCif only for local cif file. See windows# 541710 and winseraid #24036
   
   if (strCif[1] == L'\\')
      return E_ACCESSDENIED;

   if(!_pinseng)
      return E_UNEXPECTED;

   MAKE_ANSIPTR_FROMWIDE(pszCif, strCif);

   *lResult = _pinseng->SetLocalCif(pszCif);

   if(SUCCEEDED(*lResult))
      _fLocalCifSet = TRUE;



   return NOERROR;

}


//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngineCtl::SetCifFile(BSTR strCabName, BSTR strCifName)
{
   HRESULT hr;

   if(!_pinseng)
      return E_UNEXPECTED;

   MAKE_ANSIPTR_FROMWIDE(pszCabName, strCabName);
   MAKE_ANSIPTR_FROMWIDE(pszCifName, strCifName);


   if(_fLocalCifSet)
   {
      // if we are using a local cif, we won't get the new cif right away
      _fReconcileCif = TRUE;
      lstrcpyn(_szCifCab, pszCabName, sizeof(_szCifCab));
      lstrcpyn(_szCifFile, pszCifName, sizeof(_szCifFile));
      hr = S_OK;
   }
   else
   {
      // If we did not check yet, do it.
      if (_dwMSTrustKey == (DWORD)-1)
      {
         _dwMSTrustKey = MsTrustKeyCheck();
         // If MS is not a trusted provider.
         // Make it for the duration of the install
         if (_dwMSTrustKey != 0)
            WriteMSTrustKey(TRUE, _dwMSTrustKey);
      }
      hr = _pinseng->SetCifFile(pszCabName, pszCifName);
   }

   return hr;
}

#define IE_KEY        "Software\\Microsoft\\Internet Explorer"
#define VERSION_KEY         "Version"


LONG CInstallEngineCtl::_OpenJITKey(HKEY *phKey, REGSAM samAttr)
{
   char szTemp[MAX_PATH];
   WORD rdwVer[4] = { 0 };

   HKEY hIE;

   DWORD dwDumb;
   DWORD dwVer;
   if(RegOpenKeyExA(HKEY_LOCAL_MACHINE, IE_KEY, 0, KEY_READ, &hIE) == ERROR_SUCCESS)
   {
      dwDumb = sizeof(szTemp);
      if(RegQueryValueEx(hIE, VERSION_KEY, 0, NULL, (LPBYTE)szTemp, &dwDumb) == ERROR_SUCCESS)
      {
          ConvertVersionString(szTemp, rdwVer, '.');
      }
      RegCloseKey(hIE);
   }
   dwVer = rdwVer[0];

   wsprintf(szTemp, "%s\\%d", g_cszIEJITInfo, dwVer);
   return(RegOpenKeyEx(HKEY_LOCAL_MACHINE, szTemp, 0, samAttr, phKey));
}

void CInstallEngineCtl::_DeleteURLList()
{
    HKEY    hJITKey;

    if ( _OpenJITKey(&hJITKey, KEY_READ) == ERROR_SUCCESS )
    {
        RegDeleteKey(hJITKey, "URLList");

        RegCloseKey(hJITKey);
    }
}

void CInstallEngineCtl::_WriteURLList()
{
    HKEY    hJITKey;
    HKEY    hUrlKey;
    char    cNull = '\0';

    if ( _OpenJITKey(&hJITKey, KEY_READ) == ERROR_SUCCESS )
    {
        if (RegCreateKeyEx(hJITKey, "URLList", 0, NULL, REG_OPTION_NON_VOLATILE,
                           KEY_WRITE, NULL, &hUrlKey, NULL) == ERROR_SUCCESS)
        {
            for(UINT i=0; i < MAX_URLS; i++)
            {
                if ( _rpszUrlList[i] )
                {
                    RegSetValueEx(hUrlKey, _rpszUrlList[i], 0, REG_SZ, (const unsigned char *) &cNull, sizeof(cNull));
                }
            }
            RegCloseKey(hUrlKey);
        }
        RegCloseKey(hJITKey);
    }
}

void CInstallEngineCtl::_WriteRegionToReg(LPSTR szRegion)
{
    HKEY    hJITKey;

    if (_OpenJITKey(&hJITKey, KEY_WRITE) == ERROR_SUCCESS)
    {
        RegSetValueEx(hJITKey, "DownloadSiteRegion", 0, REG_SZ, (const unsigned char *) szRegion, strlen(szRegion)+1);
        RegCloseKey(hJITKey);
    }
}

STDMETHODIMP CInstallEngineCtl::SetSitesFile(BSTR strUrl, BSTR strRegion, BSTR strLocale, long FAR* lResult)
{
   char szBuf[INTERNET_MAX_URL_LENGTH];
   DWORD dwSize;
   HKEY hKey;
   HKEY hUrlKey;
   UINT uUrlNum = 0;

   HRESULT hr = E_FAIL;

   MAKE_ANSIPTR_FROMWIDE(pszUrl, strUrl);
   MAKE_ANSIPTR_FROMWIDE(pszRegion, strRegion);
   MAKE_ANSIPTR_FROMWIDE(pszLocale, strLocale);

   // first check to see if we should use local stuff
   if(pszUrl[0] == 0)
   {
      _fDoingIEInstall = TRUE;
      // find the ie major version, add it to JIT key

      if(_OpenJITKey(&hKey, KEY_READ) == ERROR_SUCCESS)
      {
         dwSize = sizeof(_uInstallMode);
         RegQueryValueEx(hKey, "InstallType", NULL, NULL, (BYTE *) &_uInstallMode, &dwSize);
/*
         if(_uInstallMode == WEBINSTALL)
         {
            if(RegOpenKeyEx(hKey, "URLList", 0, KEY_READ, &hUrlKey) == ERROR_SUCCESS)
            {
               // need to read out urls and put them in rpszUrlList
               for(int i = 0; uUrlNum < MAX_URLS; i++)
               {
                  dwSize = sizeof(szBuf);
                  if(RegEnumValue(hUrlKey, i, szBuf, &dwSize, NULL, NULL, NULL, NULL) == ERROR_SUCCESS)
                  {
                     _rpszUrlList[uUrlNum] = new char[dwSize + 1];
                     if(_rpszUrlList[uUrlNum])
                     {
                        lstrcpy(_rpszUrlList[uUrlNum], szBuf);
                        // we found at least one url so "NOERROR"
                        uUrlNum++;

                     }
                  }
                  else
                     break;

               }
			   RegCloseKey(hUrlKey);
            }
            if (uUrlNum > 0)
            {
                // We got atleast one URL from the registry.
                // Check if the URLs are still valid.
                hr = _PickWebSites(NULL, NULL, NULL, TRUE, TRUE);
            }
         }
         else */if(_uInstallMode == WEBINSTALL_DIFFERENTMACHINE)
         {
            hr = NOERROR;
         }

         _szDownloadDir[0] = 0;
         dwSize = sizeof(_szDownloadDir);
         if(RegQueryValueEx(hKey, "UNCDownloadDir", NULL, NULL, (BYTE *) (_szDownloadDir), &dwSize) == ERROR_SUCCESS)
         {
            // if its a web install, set download dir to UNCDownloadDir
            if(_uInstallMode == WEBINSTALL || _uInstallMode == WEBINSTALL_DIFFERENTMACHINE)
            {
               if(GetFileAttributes(_szDownloadDir) != 0xffffffff)
                  _pinseng->SetDownloadDir(_szDownloadDir);
            }
            else if(_uInstallMode == CDINSTALL ||
                    _uInstallMode == NETWORKINSTALL ||
                    _uInstallMode == LOCALINSTALL)
            {
               // setup szBuf with file:// at beginning
               lstrcpy(szBuf, "file://");
               lstrcat(szBuf, _szDownloadDir);

               _rpszUrlList[uUrlNum] = new char[lstrlen(szBuf) + 1];
               if(_rpszUrlList[uUrlNum])
               {
                  lstrcpy(_rpszUrlList[uUrlNum], szBuf);
                  // we found at least one url so "NOERROR"
                  uUrlNum++;
                  hr = NOERROR;
               }
            }
         }
         RegCloseKey(hKey);
      }
   }

   if (hr != NOERROR)
   {
      hr = _PickWebSites(pszUrl, pszRegion, pszLocale, FALSE);
   }

   if(SUCCEEDED(hr) && _rpszUrlList[0])
   {
      _uCurrentUrl = 0;
      _pinseng->SetBaseUrl(_rpszUrlList[_uCurrentUrl]);
   }
   *lResult = hr;
   return NOERROR;
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngineCtl::put_BaseUrl(BSTR strBaseUrl)
{
   if(!_pinseng)
      return E_UNEXPECTED;

   MAKE_ANSIPTR_FROMWIDE(pszBaseUrl, strBaseUrl);
   return _pinseng->SetBaseUrl(pszBaseUrl);
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngineCtl::put_DownloadDir(BSTR strDownloadDir)
{
   // Due to security issues, this method is effectively being disabled.
   return S_OK;

   if(!_pinseng)
      return E_UNEXPECTED;

   MAKE_ANSIPTR_FROMWIDE(pszDownloadDir, strDownloadDir);
   return _pinseng->SetDownloadDir(pszDownloadDir);
}


//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngineCtl::IsComponentInstalled(BSTR strComponentID, long *lResult)
{
   if(!_pinseng)
      return E_UNEXPECTED;

   // Ask about grovelling for installed apps here

    //
    // add code to automatically enable grovel if the specified event is signalled
    //
	const TCHAR szEnableGrovelEventName[] = TEXT("WindowsUpdateCriticalUpdateGrovelEnable");
    if(_uAllowGrovel == 0xffffffff)
    {
       HANDLE evAllowGrovel = OpenEvent(
									EVENT_ALL_ACCESS,
									FALSE,
									szEnableGrovelEventName
									);
	   if (evAllowGrovel != NULL)
   	   {
	     if (WaitForSingleObject(evAllowGrovel, 0) == WAIT_OBJECT_0)
		 {
			//
			// if the event is signaled, we reset the event, and set _uAllowGrovel=1 which
			// means we've already agreed on groveling
			//
			_uAllowGrovel = 1;
		 }
		 CloseHandle(evAllowGrovel);
	   }
   }


   if (_uAllowGrovel == 0xffffffff)
   {
      LPSTR pszTitle;
      char szMess[512];

      _pinseng->GetDisplayName(NULL, &pszTitle);
      LoadSz(IDS_GROVELMESSAGE, szMess, sizeof(szMess));
      ModalDialog(TRUE);
      if(MessageBox(m_hwnd, szMess, pszTitle, MB_YESNO | MB_ICONQUESTION) == IDNO)
         _uAllowGrovel = 0;
      else
         _uAllowGrovel = 1;
      ModalDialog(FALSE);

      if(pszTitle)
         CoTaskMemFree(pszTitle);
   }

   if (_uAllowGrovel != 1)
   {
      *lResult = ICI_UNKNOWN;
      return NOERROR;
   }
   else
   {

    MAKE_ANSIPTR_FROMWIDE(pszComponentID, strComponentID);
	return _pinseng->IsComponentInstalled(pszComponentID, (DWORD *)lResult);
   }
}

STDMETHODIMP CInstallEngineCtl::get_DisplayName(BSTR ComponentID, BSTR *name)
{
   LPSTR psz;

   MAKE_ANSIPTR_FROMWIDE(pszID, ComponentID);
   _pinseng->GetDisplayName(pszID, &psz);

   if(psz)
   {
      *name = BSTRFROMANSI(psz);
      CoTaskMemFree(psz);
   }

   return NOERROR;
}



//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngineCtl::get_Size(BSTR strComponentID, long *lResult)
{
   HRESULT hr;
   COMPONENT_SIZES cs;

   if(!_pinseng)
      return E_UNEXPECTED;

   cs.cbSize = sizeof(COMPONENT_SIZES);

   MAKE_ANSIPTR_FROMWIDE(pszComponentID, strComponentID);
   hr = _pinseng->GetSizes(pszComponentID, &cs);
   *lResult = cs.dwDownloadSize;
   return hr;
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngineCtl::get_TotalDownloadSize(long *totalsize)
{
   HRESULT hr;
   COMPONENT_SIZES cs;

   if(!_pinseng)
      return E_UNEXPECTED;

   cs.cbSize = sizeof(COMPONENT_SIZES);

   hr = _pinseng->GetSizes(NULL, &cs);
   *totalsize = cs.dwDownloadSize;
   return hr;
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngineCtl::get_TotalDependencySize(long *totaldepsize)
{
   HRESULT hr;
   COMPONENT_SIZES cs;

   if(!_pinseng)
      return E_UNEXPECTED;

   cs.cbSize = sizeof(COMPONENT_SIZES);

   hr = _pinseng->GetSizes(NULL, &cs);
   *totaldepsize = cs.dwDependancySize;
   return hr;
}


//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngineCtl::SetAction(BSTR strComponentID, long action, long *lResult)
{
   if(!_pinseng)
      return E_UNEXPECTED;

   MAKE_ANSIPTR_FROMWIDE(pszComponentID, strComponentID);
   *lResult = 0;
   HRESULT hr = _pinseng->SetAction(pszComponentID, action, 0xffffffff);
   if(hr == E_PENDING)
   {
      char szTitle[128];
      char szErrBuf[256];

      LoadSz(IDS_TITLE, szTitle, sizeof(szTitle));
      LoadSz(IDS_ERRDOINGINSTALL, szErrBuf, sizeof(szErrBuf));
      MsgBox(szTitle, szErrBuf);
   }
   if(hr == S_FALSE)
      *lResult = 1;

   return NOERROR;
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngineCtl::ProcessComponents(long lFlags)
{
   DWORD status;
   HANDLE hThread;

   if(!_pinseng)
      return E_UNEXPECTED;

   if(!_fInstalling)
   {
      _fInstalling = TRUE;
      // make sure engine is ready
      _pinseng->GetEngineStatus(&status);
      if(status == ENGINESTATUS_READY)
      {
         // spawn thread to do install
         _dwProcessComponentsFlags = lFlags;
         // only allow certain options thru script
         _dwProcessComponentsFlags &= 0xffffffef;
         if ((hThread = CreateThread(NULL, 0, DoInstall, (LPVOID) this, 0, &status)) != NULL)
            CloseHandle(hThread);
      }
   }

   return NOERROR;
}


void CInstallEngineCtl::_DoInstall()
{
   HRESULT hr = NOERROR;
   char szBuf[512];
   char szTitle[128];
   BOOL fNeedWebSites = FALSE;
   DWORD dwMSTrustKey = (DWORD)-1;

   AddRef();
   _hDone = CreateEvent(NULL, FALSE, FALSE, NULL);
   _dwInstallStatus = 0;

   if(!_hDone)
      hr = E_FAIL;

   // If we did not check yet, do it.
   if (dwMSTrustKey == (DWORD)-1)
   {
      dwMSTrustKey = MsTrustKeyCheck();
      // If MS is not a trusted provider. Make it for the duration of the install
      if (dwMSTrustKey != 0)
         WriteMSTrustKey(TRUE, dwMSTrustKey, _fJITInstall);
   }

   // Add reg value so that if IE4 base is installed, it would think that it
   // is being run from Active Setup.  This would prevent softboot from being
   // kicked off by IE4 base.
   WriteActiveSetupValue(TRUE);

   if(_fDoingIEInstall)
   {
      // figure out whether we need to hit the web or not
      // for beta1 we assume we never do for CD/NETWORK
      COMPONENT_SIZES Sizes;
      if(_uInstallMode == WEBINSTALL || _uInstallMode == WEBINSTALL_DIFFERENTMACHINE)
      {
         ZeroMemory(&Sizes, sizeof(COMPONENT_SIZES));
         Sizes.cbSize = sizeof(COMPONENT_SIZES);

         if(SUCCEEDED(_pinseng->GetSizes(NULL, &Sizes)))
         {
            if(Sizes.dwDownloadSize == 0)
            {
               // in webdownload case, with everything local, no need to reoncile cif
               _fReconcileCif = FALSE;
            }
            else
            {
               // if we don't have any web sites then we need them
               if(!_rpszUrlList[0])
                  fNeedWebSites = TRUE;
            }
         }
      }
      else
      {
         // for CD, NETWORK, LOCALINSTALL, here we check for path
         hr = _CheckInstallPath(&fNeedWebSites);
         // no need to reconcile the cif - it won't even be there!
         _fReconcileCif = FALSE;
      }
   }

   if(SUCCEEDED(hr))
   {
      _dwInstallStatus = 0;
      if(!(_dwProcessComponentsFlags & PROCESSCOMPONENT_NOPROGRESSUI))
      {
         _pProgDlg = new CProgressDlg(g_hInstance, m_hwnd, m_hwndParent, this);
         if(_pProgDlg)
            _pProgDlg->DisplayWindow(TRUE);
      }
   }

   if(SUCCEEDED(hr) && fNeedWebSites)
   {
       // member boolean to track whether whether websites need to
       // be written back to the URLList.
       _bNewWebSites = TRUE;

      hr = _PickWebSites(NULL, NULL, NULL, FALSE);
      if(SUCCEEDED(hr))
      {
         _pinseng->SetBaseUrl(_rpszUrlList[0]);
         _uCurrentUrl = 0;
      }
   }

   if ( SUCCEEDED(hr) && _bCancelPending )
   {
      hr = E_ABORT;
      _bCancelPending = FALSE;
   }


   if(SUCCEEDED(hr) && _fReconcileCif)
   {
      hr = _pinseng->SetCifFile(_szCifCab, _szCifFile);
      if(SUCCEEDED(hr))
      {
         WaitForEvent(_hDone, NULL);
         hr = _hResult;
         _fReconcileCif = FALSE;
      }
   }

   if ( SUCCEEDED(hr) && _bCancelPending )
   {
      hr = E_ABORT;
      _bCancelPending = FALSE;
   }

   if(SUCCEEDED(hr))
   {
      hr = _CheckForDiskSpace();
   }

   if(SUCCEEDED(hr))
   {
      COMPONENT_SIZES cs;
      cs.cbSize = sizeof(COMPONENT_SIZES);

      if(SUCCEEDED(_pinseng->GetSizes(NULL, &cs)))
      {
         _FireOnStartInstallExEvent(cs.dwDownloadSize, cs.dwInstallSize + cs.dwWinDriveSize);
      }

      if ( SUCCEEDED(hr) && _bCancelPending )
      {
          hr = E_ABORT;
          _bCancelPending = FALSE;
      }

      if ( SUCCEEDED(hr) )
      {
          hr = _pinseng->DownloadComponents(_dwProcessComponentsFlags);
          if(SUCCEEDED(hr))
          {
             WaitForEvent(_hDone, NULL);
             hr = _hResult;
          }
      }
   }

   if(SUCCEEDED(hr))
   {
      // Prepare the install
      // Create the error string
      _pszErrorString = (char *) malloc(ERROR_STRING_SIZE);
      _iErrorStringSize = ERROR_STRING_SIZE;

      if(_pszErrorString)
         LoadSz(IDS_SUMMARYHEADING, _pszErrorString, 2048);
      else
         hr = E_OUTOFMEMORY;
   }

   if(SUCCEEDED(hr))
   {
      if(_pProgDlg && (_dwProcessComponentsFlags & PROCESSCOMPONENT_NOINSTALLUI))
         _pProgDlg->DisplayWindow(FALSE);
      hr = _pinseng->InstallComponents(EXECUTEJOB_IGNORETRUST);
      if(SUCCEEDED(hr))
      {
         WaitForEvent(_hDone, NULL);
         hr = _hResult;
      }
   }

   if (dwMSTrustKey != (DWORD)-1)
   {
      WriteMSTrustKey(FALSE, dwMSTrustKey);
   }
   dwMSTrustKey = (DWORD)-1;

   // delete ActiveSetup value from IE4\Options
   WriteActiveSetupValue(FALSE);

   if(_pProgDlg)
   {
      delete _pProgDlg;
      _pProgDlg = NULL;
   }

   LoadSz(IDS_FINISH_TITLE, szTitle, sizeof(szTitle));

   // show appropriate summary ui
   if( !(_dwProcessComponentsFlags & PROCESSCOMPONENT_NOSUMMARYUI))
   {
      if(SUCCEEDED(hr))
      {
         if(_pszErrorString)
            MsgBox(szTitle, _pszErrorString);
      }
      else if(hr == E_ABORT)
      {
         LoadSz(IDS_INSTALLCANCELLED, szBuf, sizeof(szBuf));
         MsgBox(szTitle, szBuf);
      }
      else if( _pszErrorString )
      {
         MsgBox(szTitle, _pszErrorString);
      }
      else
      {
         LoadSz(IDS_ERRGENERAL, szBuf, sizeof(szBuf));
         MsgBox(szTitle, szBuf);
      }
   }

   if(SUCCEEDED(hr))
   {
      if(_dwInstallStatus & STOPINSTALL_REBOOTNEEDED)
      {
         if(!(_dwProcessComponentsFlags & PROCESSCOMPONENT_DELAYREBOOT))
         {
            if( !MyRestartDialog(m_hwnd, TRUE) )
               _dwInstallStatus |= STOPINSTALL_REBOOTREFUSED;
         }
         else
            _fNeedReboot = TRUE;
      }
   }

   _FireOnStopInstallEvent(hr, NULL, _dwInstallStatus);

   _dwProcessComponentsFlags = 0;

   if(_pszErrorString)
   {
      free(_pszErrorString);
      _pszErrorString = NULL;
   }

   if(_hDone)
   {
      CloseHandle(_hDone);
      _hDone = NULL;
   }
   _fInstalling = FALSE;
   Release();
}

HRESULT CInstallEngineCtl::_PickWebSites(LPCSTR pszSites, LPCSTR pszLocale, LPCSTR pszRegion, BOOL bKeepExisting)
{
   UINT uCurrentUrl;
   char szUrl[INTERNET_MAX_URL_LENGTH];
   char szRegion[MAX_DISPLAYNAME_LENGTH];
   char szLocale[3];
   HRESULT hr = NOERROR;
   HKEY hKey;
   DWORD dwSize;

   szRegion[0] = 0;
   szUrl[0] = 0;
   szLocale[0] = 0;

   if(!bKeepExisting)
   {
      for(uCurrentUrl = 0; uCurrentUrl < MAX_URLS; uCurrentUrl++)
      {
         if(_rpszUrlList[uCurrentUrl])
         {
            delete _rpszUrlList[uCurrentUrl];
            _rpszUrlList[uCurrentUrl] = 0;
         }
      }
   }

   // find the first empty url
   for(uCurrentUrl = 0; uCurrentUrl < MAX_URLS && _rpszUrlList[uCurrentUrl]; uCurrentUrl++);

   // fill out all our fields
   if(!pszSites || (*pszSites == '\0'))
   {
      // read info out of JIT key
      if(_OpenJITKey(&hKey, KEY_READ) == ERROR_SUCCESS)
      {
         dwSize = sizeof(szUrl);
         RegQueryValueEx(hKey, "DownloadSiteURL", NULL, NULL, (BYTE *) szUrl, &dwSize);

         if(!pszLocale ||(*pszLocale == '\0'))
         {
            dwSize = sizeof(szLocale);
            RegQueryValueEx(hKey, "Local", NULL, NULL, (BYTE *) szLocale, &dwSize);
         }
         else
            lstrcpyn(szLocale, pszLocale, sizeof(szLocale));

         if(!pszRegion||(*pszRegion == '\0'))
         {
            dwSize = sizeof(szRegion);
            RegQueryValueEx(hKey, "DownloadSiteRegion", NULL, NULL, (BYTE *) szRegion, &dwSize);
         }
         else
            lstrcpyn(szRegion, pszRegion, sizeof(szRegion));

         RegCloseKey(hKey);
      }
   }
   else
   {
      lstrcpyn(szUrl, pszSites, INTERNET_MAX_URL_LENGTH);

      if(pszLocale)
         lstrcpyn(szLocale, pszLocale, sizeof(szLocale));

      if(pszRegion)
         lstrcpyn(szRegion, pszRegion, sizeof(szRegion));
   }

   if(szUrl[0])
   {
      SITEQUERYPARAMS  SiteParam;
      IDownloadSiteMgr *pISitemgr;
      IDownloadSite    **ppISite = NULL;
      IDownloadSite    *pISite;
      DOWNLOADSITE     *psite;
      BYTE             *pPicks = NULL;
      UINT             uNumToPick;
      UINT             uFirstSite = 0xffffffff;
      UINT             j;
      UINT             uNumSites = 0;

      ZeroMemory(&SiteParam, sizeof(SITEQUERYPARAMS));
      SiteParam.cbSize = sizeof(SITEQUERYPARAMS);

      // if we have a locale, use it
      if(szLocale[0])
         SiteParam.pszLang = szLocale;

      hr = CoCreateInstance(CLSID_DownloadSiteMgr, NULL,
                            CLSCTX_INPROC_SERVER|CLSCTX_LOCAL_SERVER,
                            IID_IDownloadSiteMgr, (LPVOID *)&pISitemgr);
      if (SUCCEEDED(hr))
      {
         hr = pISitemgr->Initialize(szUrl, &SiteParam);
         if (SUCCEEDED(hr))
         {

            // assume we fail. if we add at least one url, set to OK
            hr = E_FAIL;

            while (SUCCEEDED(pISitemgr->EnumSites(uNumSites, &pISite)))
            {
               pISite->Release();
               uNumSites++;
            }
            ppISite = new IDownloadSite *[uNumSites];

            for(j=0; j < uNumSites;j++)
			{
               pISitemgr->EnumSites(j, &(ppISite[j]));
			}

            // if we don't have a region, show ui
            // NOTE: szRegion better be valid and
            // better have atleast MAX_DISPLAYNAME_LENGTH buffer size
            if(!szRegion[0])
            {
               _PickRegionAndFirstSite(ppISite, uNumSites, szRegion, &uFirstSite);
            }
            pPicks = new BYTE[uNumSites];

            // zero out picks array
            for(j=0; j < uNumSites; j++)
               pPicks[j] = 0;

            // find out number of urls we will add
            uNumToPick = MAX_URLS - uCurrentUrl;
            if(uNumToPick > uNumSites)
               uNumToPick = uNumSites;

            if(uNumToPick > 0)
            {
               if(uFirstSite != 0xffffffff)
               {
                  pPicks[uFirstSite] = 1;
                  uNumToPick--;
               }

               _PickRandomSites(ppISite, pPicks, uNumSites, uNumToPick, szRegion);
            }

            // now all sites we want are marked with one in pPicks
            for(j = 0; j < uNumSites; j++)
            {
               if(pPicks[j])
               {
                  if(SUCCEEDED(ppISite[j]->GetData(&psite)))
                  {
                     _rpszUrlList[uCurrentUrl] = new char[lstrlen(psite->pszUrl) + 1];
                     if(_rpszUrlList[uCurrentUrl])
                     {
                        lstrcpy(_rpszUrlList[uCurrentUrl], psite->pszUrl);
                        uCurrentUrl++;
                        hr = NOERROR;
                     }
                  }
               }
            }

         }
         for(j = 0; j < uNumSites; j++)
            ppISite[j]->Release();

         if(ppISite)
            delete ppISite;
         if(pPicks)
            delete pPicks;

         pISitemgr->Release();
      }
   }
   else
      hr = E_FAIL;

   return hr;
}

void CInstallEngineCtl::_PickRandomSites(IDownloadSite **ppISite, BYTE *pPicks, UINT uNumSites, UINT uNumToPick, LPSTR pszRegion)
{
   UINT uStart, uIncrement, uFirst;

   uStart = GetTickCount() % uNumSites;
   if(uNumSites > 1)
      uIncrement = GetTickCount() % (uNumSites - 1);

   while(uNumToPick)
   {
      // if already picked or not in correct region, find next
      uFirst = uStart;
      while(pPicks[uStart] || !IsSiteInRegion(ppISite[uStart], pszRegion))
      {
         uStart++;
         if(uStart >= uNumSites)
            uStart -= uNumSites;
         if(uStart == uFirst)
            break;
      }
      if(!pPicks[uStart])
      {
         pPicks[uStart] = 1;
         uStart += uIncrement;
         if(uStart >= uNumSites)
            uStart -= uNumSites;
         uNumToPick--;
      }
	   else
		   break;
   }
}

typedef struct
{
   IDownloadSite **ppISite;
   UINT            uNumSites;
   LPSTR           pszRegion;
   UINT            uFirstSite;
} SITEDLGPARAMS;

void FillRegionList(SITEDLGPARAMS *psiteparams, HWND hDlg)
{
   DOWNLOADSITE *pSite;
   HWND hRegion = GetDlgItem(hDlg, IDC_REGIONS);
   for(UINT i = 0; i < psiteparams->uNumSites; i++)
   {
      psiteparams->ppISite[i]->GetData(&pSite);
      if(ComboBox_FindStringExact(hRegion, 0, pSite->pszRegion) == CB_ERR)
         ComboBox_AddString(hRegion, pSite->pszRegion);
   }
   ComboBox_SetCurSel(hRegion, 0);
}

void FillSiteList(SITEDLGPARAMS *psiteparams, HWND hDlg)
{
    char szRegion[MAX_DISPLAYNAME_LENGTH];
   int uPos;
   DOWNLOADSITE *pSite;
   HWND hSite = GetDlgItem(hDlg, IDC_SITES);

   ListBox_ResetContent(hSite);

   ComboBox_GetText(GetDlgItem(hDlg, IDC_REGIONS), szRegion, MAX_DISPLAYNAME_LENGTH);

   // copy the new Region name into the psiteparams struct.
   if ( psiteparams->pszRegion)
       lstrcpyn(psiteparams->pszRegion, szRegion, MAX_DISPLAYNAME_LENGTH);

   for(UINT i = 0; i < psiteparams->uNumSites; i++)
   {
      if(IsSiteInRegion(psiteparams->ppISite[i], szRegion))
      {
         psiteparams->ppISite[i]->GetData(&pSite);
         uPos = ListBox_AddString(hSite, pSite->pszFriendlyName);
         if(uPos != LB_ERR)
            ListBox_SetItemData(hSite, uPos, i);
      }
   }
   ListBox_SetCurSel(hSite, 0);
}



INT_PTR CALLBACK SiteListDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
   SITEDLGPARAMS *psiteparam;
   switch (uMsg)
    {
       case WM_INITDIALOG:
          // Do some init stuff
          SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR) lParam);
          psiteparam = (SITEDLGPARAMS *) lParam;
          FillRegionList(psiteparam, hwnd);
          FillSiteList(psiteparam, hwnd);
          return FALSE;

       case WM_COMMAND:
          psiteparam = (SITEDLGPARAMS *) GetWindowLongPtr(hwnd, GWLP_USERDATA);
          switch (LOWORD(wParam))
          {
             case IDOK:
                // get the region
                ComboBox_GetText(GetDlgItem(hwnd, IDC_REGIONS), psiteparam->pszRegion, MAX_PATH);
                psiteparam->uFirstSite = (UINT)ListBox_GetItemData(GetDlgItem(hwnd, IDC_SITES),
                                   ListBox_GetCurSel(GetDlgItem(hwnd, IDC_SITES)));
                EndDialog(hwnd, IDOK);
                break;

             case IDC_REGIONS:
                if (HIWORD(wParam) == CBN_SELCHANGE)
                {
                   FillSiteList(psiteparam, hwnd);
                }
                break;

             default:
                return FALSE;
          }
          break;

       default:
          return(FALSE);
    }
    return TRUE;
}



void CInstallEngineCtl::_PickRegionAndFirstSite(IDownloadSite **ppISite, UINT uNumSites, LPSTR szRegion, UINT *puFirstSite)
{
   SITEDLGPARAMS siteparam;

   siteparam.ppISite = ppISite;
   siteparam.uNumSites = uNumSites;
   siteparam.pszRegion = szRegion;

   DialogBoxParam(g_hInstance, MAKEINTRESOURCE(IDD_SITELIST), _pProgDlg ? _pProgDlg->GetHWND() : m_hwnd,
                   SiteListDlgProc, (LPARAM)&siteparam);

   *puFirstSite = siteparam.uFirstSite;
   _WriteRegionToReg(siteparam.pszRegion);
}

HRESULT CInstallEngineCtl::_CheckInstallPath(BOOL *pfNeedWebSites)
{
   // MAX_PATH and enough to hold "file://" (if needed)
   char szBuf[MAX_PATH + 10];
   HKEY hKey = NULL;
   DWORD dwSize;
   *pfNeedWebSites = FALSE;
   HRESULT hr = NOERROR;

   if(!_PathIsIEInstallPoint(_szDownloadDir))
   {

      // If Win9x, turn-off the AutoRun thing before showing the Dlg.
      if (g_fSysWin95)
         g_ulOldAutorunSetting = SetAutorunSetting((unsigned long)WINDOWS_AUTOPLAY_OFF);

      // create and show the dialog
      INT_PTR ret = DialogBoxParam(g_hInstance, MAKEINTRESOURCE(IDD_LOCATE), m_hwnd,
                          LocationDlgProc, (LPARAM)this);

      // Now reset the AutoRun settings for Win9x
      if (g_fSysWin95)
         SetAutorunSetting(g_ulOldAutorunSetting);

      if(ret == IDCANCEL)
      {
         hr = E_ABORT;
      }
      else if(ret == IDC_INTERNET)
      {
         *pfNeedWebSites = TRUE;
      }
      else
      {
         // mike wants to copy new _szDownloadDir back into the registry...
         // take what we have and replace the current baseurl with it
         if(_rpszUrlList[0])
         {
            delete _rpszUrlList[0];
            _rpszUrlList[0] = 0;
         }

         lstrcpy(szBuf, "file://");
         lstrcat(szBuf, _szDownloadDir);

         _rpszUrlList[0] = new char[lstrlen(szBuf) + 1];
         if(_rpszUrlList[0])
         {
            lstrcpy(_rpszUrlList[0], szBuf);
		    _pinseng->SetBaseUrl(_rpszUrlList[0]);
         }
         else
            hr = E_OUTOFMEMORY;
      }
   }

   return hr;
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:  For the CD AutoSplash suppression code, the values for iHandledAutoCD are
//              iHandledAutoCD == -1  ===> no need to suppress AutoCD.
//              iHandledAutoCD == 0   ===> need to suppress but not suppressed yet
//              iHandledAutoCD == 1   ===> finished suppressing AutoCD.
//=--------------------------------------------------------------------------=

#define AUTOCD_WAIT     30
#define AUTOCD_SLEEP    500

INT_PTR CALLBACK LocationDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
   // Code to suppress the AutoRun when the CD is inserted.
   static HCURSOR  hCurOld = NULL;
   static int      iHandledAutoCD = -1;  // -1 ==> do not need to suppress AutoCD
   static int      iCount = 0;

   CInstallEngineCtl *pctl = (CInstallEngineCtl *) GetWindowLongPtr(hDlg, DWLP_USER);

   // Special case handling for the Autorun message.
   // When this dialog receives the AutoRun message, suppres it.
   if ( uMsg == g_uCDAutorunMsg)
   {
       SetWindowLongPtr(hDlg, DWLP_MSGRESULT, (LONG_PTR)1);
       iHandledAutoCD = 1;  // 1 ==> finished suppressing the AutoCD Splash
       return TRUE;
   }

   switch(uMsg)
   {
      case WM_INITDIALOG:
         {
            char szBuf[MAX_PATH];
            char szBuf2[MAX_PATH];

            UINT drvType;
            HWND hwndCb = GetDlgItem(hDlg, IDC_LOCATIONLIST);
            int defSelect = 0;
            int pos;
            LPSTR psz = NULL;

            // Setup the default behaviour for AutoCD suppression
            iHandledAutoCD = -1;  // -1 ==> do not need to suppress AutoCD

            pctl = (CInstallEngineCtl *) lParam;
            SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR) pctl);

            pctl->_pinseng->GetDisplayName(NULL, &psz);
            SetWindowText(hDlg, psz);
            szBuf2[0] = 0;

            if(pctl->_uInstallMode == CDINSTALL)
            {
               // Only if this dialog involves CD insertion, do we need to bother about
               // CDINSTALL - need to handle AutoRun suppression.
               // This method is needed only if we are running on NT.
               if ( g_fSysWinNT )
                   iHandledAutoCD = 0;  // 0 ==> we need to suppress, but not suppressed yet.

               LoadSz(IDS_CDNOTFOUND, szBuf, sizeof(szBuf));
               SetDlgItemText(hDlg, IDC_TEXT1, szBuf);

               if(LoadSz(IDS_CDPLEASEINSERT, szBuf, sizeof(szBuf)))
                  wsprintf(szBuf2, szBuf, psz);
               SetDlgItemText(hDlg, IDC_TEXT2, szBuf2);

               lstrcpy(szBuf, "x:\\");
               for(char chDir = 'A'; chDir <= 'Z'; chDir++)
               {
                  szBuf[0] = chDir;
                  drvType = GetDriveType(szBuf);
                  if(drvType != DRIVE_UNKNOWN && drvType != DRIVE_NO_ROOT_DIR)
                  {
                     pos = ComboBox_AddString(hwndCb, szBuf);
                     if(ANSIStrStrI(pctl->_szDownloadDir, szBuf))
                        defSelect = pos;
                  }
               }
            }
            else
            {
               LoadSz(IDS_NETWORKNOTFOUND, szBuf, sizeof(szBuf));
               SetDlgItemText(hDlg, IDC_TEXT1, szBuf);

               if(LoadSz(IDS_NETWORKPLEASEFIND, szBuf, sizeof(szBuf)))
                  wsprintf(szBuf2, szBuf, psz);
               SetDlgItemText(hDlg, IDC_TEXT2, szBuf2);

               ComboBox_AddString(hwndCb, pctl->_szDownloadDir);
               defSelect = 0;
            }
            // add internet to list
            // it is important that the internet is last; we depend on it later
            LoadSz(IDS_INTERNET, szBuf, sizeof(szBuf));
            ComboBox_AddString(hwndCb, szBuf);

            ComboBox_SetCurSel(hwndCb, defSelect);

            if(psz)
               CoTaskMemFree(psz);
         }
         return TRUE;

      case WM_COMMAND:
         switch (LOWORD(wParam))
         {
            case IDC_BROWSE:
               {
                  char szBuf[MAX_PATH];
                  char szBuf2[MAX_PATH];

                  HWND hwndCb = GetDlgItem(hDlg, IDC_LOCATIONLIST);
                  LPSTR psz;

                  szBuf2[0] = 0;
                  pctl->_pinseng->GetDisplayName(NULL, &psz);
                  if(LoadSz(IDS_FINDFOLDER, szBuf, sizeof(szBuf)))
                     wsprintf(szBuf2, szBuf, psz);

                  szBuf[0] = 0;
                  ComboBox_GetText(hwndCb, szBuf, sizeof(szBuf));

                  if(BrowseForDir(hDlg, szBuf, szBuf2))
                  {
                     ComboBox_SetText(hwndCb, szBuf);
                  }
                  if(psz)
                     CoTaskMemFree(psz);
               }
               break;

            case IDOK:
               {
                  HWND hwndCb = GetDlgItem(hDlg, IDC_LOCATIONLIST);
                  char szBuf[MAX_PATH];
                  char szBuf2[MAX_PATH];

                  // If User selected INTERNET, go on irresepective of CD or not.
                  // I am counting on the fact that the last item I added was internet!
                  int iSel = ComboBox_GetCurSel(hwndCb);
                  if(iSel == ComboBox_GetCount(hwndCb) - 1)
                  {
                     EndDialog(hDlg, IDC_INTERNET);
                  }
                  else
                  {
                     // If Splash suppression needs to be done, wait for it before continuing.
                     if ( iHandledAutoCD == 0 ) // i.e. need to suppress, but NOT suppressed yet.
                     {
                        // Change cursor to WAIT for the very first time only.
                        if (hCurOld == NULL)
                            hCurOld = SetCursor(LoadCursor(NULL,(IDC_WAIT)));

                        // Wait for the DlgBox to suppress the AutoCD (if possible)
                        if ( iHandledAutoCD != 1
                             && iCount < AUTOCD_WAIT )
                        {
                            Sleep(AUTOCD_SLEEP);
                            PostMessage(hDlg, uMsg, wParam, lParam);
                            iCount ++;
                        }
                        else
                        {
                            // Enough of waiting, pretend supressed and move on.
                            iHandledAutoCD = 1;
                            PostMessage(hDlg,uMsg,wParam,lParam);
                        }
                     }
                     else
                     {
                         if ( hCurOld )
                         {
                             // Now that we have finished waiting for suppression, restore cursor.
                             SetCursor(hCurOld);
                             hCurOld = NULL;
                         }

                         ComboBox_GetText(hwndCb, szBuf, sizeof(szBuf));
                         if(pctl->_uInstallMode == CDINSTALL)
                         {
                            if(lstrlen(szBuf) == 3)
                            {
                               // this is just drive letter. add dir to it
                               lstrcpy(szBuf + 3, pctl->_szDownloadDir + 3);
                            }
                         }

                         if(pctl->_PathIsIEInstallPoint(szBuf))
                         {
                            lstrcpy(pctl->_szDownloadDir, szBuf);
                            EndDialog(hDlg, IDOK);
                         }
                         else
                         {
                            // NOT VALID: Need to start again on this dialog.
                            LPSTR psz;
                            pctl->_pinseng->GetDisplayName(NULL, &psz);
                            LoadSz(IDS_NOTVALIDLOCATION, szBuf, sizeof(szBuf));
                            wsprintf(szBuf2, szBuf, psz);
                            MessageBox(hDlg, szBuf2, psz, MB_OK | MB_ICONSTOP);

                            // If there was a need for AutoSplash suppression on our way here, we need to
                            // re-initialize our need to AutoSplash suppression for the next round.
                            if ( iHandledAutoCD != -1)    // -1 ==> No suppression required.
                            {
                                iHandledAutoCD = 0;
                                hCurOld = NULL;
                                iCount = 0;
                            }

                         }
                     }
                  }
               }
               break;

            case IDCANCEL:
               EndDialog(hDlg, IDCANCEL);
               break;

            default:
               return FALSE;
         }
         break;

      default:
         return FALSE;
   }
   return TRUE;
}

BOOL CInstallEngineCtl::_PathIsIEInstallPoint(LPCSTR pszPath)
{
   // in the future this can actually check the path for the files we need
   return(GetFileAttributes(pszPath) != 0xffffffff);
}


//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngineCtl::FinalizeInstall(long lFlags)
{
   if(lFlags & FINALIZE_DOREBOOT)
   {
      if(_fNeedReboot)
      {
         MyRestartDialog(m_hwnd, !(lFlags & FINALIZE_NOREBOOTPROMPT));
      }
   }
   return NOERROR;
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngineCtl::HandleEngineProblem(long lAction)
{
   _dwAction = (DWORD) lAction;
   return NOERROR;
}


STDMETHODIMP CInstallEngineCtl::CheckFreeSpace(long lPad, long FAR* lEnough)
{
   *lEnough = 1;
   _uInstallPad = lPad;
   return NOERROR;
}


BOOL CInstallEngineCtl::_IsEnoughSpace(LPSTR szSpace1, DWORD dwSize1, LPSTR szSpace2, DWORD dwSize2,
                                       LPSTR szSpace3, DWORD dwSize3)
{
   COMPONENT_SIZES cs;
   char szRoot[5] = "?:\\";
   BOOL fEnough = TRUE;
   char szBuf[MAX_DISPLAYNAME_LENGTH];

   UINT pArgs[2];

   cs.cbSize = sizeof(COMPONENT_SIZES);

   // clear out strings
   szSpace1[0] = 0;
   szSpace2[0] = 0;
   szSpace3[0] = 0;


   if(SUCCEEDED(_pinseng->GetSizes(NULL, &cs)))
   {
      if(cs.chWinDrive)
      {
         szRoot[0] = cs.chWinDrive;
         if(GetSpace(szRoot) < (DWORD) (_uInstallPad + (long) cs.dwWinDriveReq))
         {
            LoadSz(IDS_DISKSPACE, szBuf, sizeof(szBuf));
            pArgs[0] = (UINT) cs.dwWinDriveReq + _uInstallPad;
            pArgs[1] = (UINT) szRoot[0];
            FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                    (LPCVOID) szBuf, 0, 0, szSpace1, dwSize1, (va_list *) pArgs);
            fEnough = FALSE;
         }
      }
      if(cs.chInstallDrive)
      {
         szRoot[0] = cs.chInstallDrive;
         if(GetSpace(szRoot) < cs.dwInstallDriveReq)
         {
            LoadSz(IDS_DISKSPACE, szBuf, sizeof(szBuf));
            pArgs[0] = (UINT) cs.dwInstallDriveReq;
            pArgs[1] = (UINT) szRoot[0];
            FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                    (LPCVOID) szBuf, 0, 0, szSpace2, dwSize2, (va_list *) pArgs);
            fEnough = FALSE;
         }
      }
      if(cs.chDownloadDrive)
      {
         szRoot[0] = cs.chDownloadDrive;
         if(GetSpace(szRoot) < cs.dwDownloadDriveReq)
         {
            LoadSz(IDS_DISKSPACE, szBuf, sizeof(szBuf));
            pArgs[0] = (UINT) cs.dwDownloadDriveReq;
            pArgs[1] = (UINT) szRoot[0];
            FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                    (LPCVOID) szBuf, 0, 0, szSpace3, dwSize3, (va_list *) pArgs);
            fEnough = FALSE;
         }
      }
   }
   else
      fEnough = FALSE;

   return fEnough;
}

HRESULT CInstallEngineCtl::_CheckForDiskSpace()
{
   HRESULT hr = NOERROR;
   char szBuf1[MAX_DISPLAYNAME_LENGTH];
   char szBuf2[MAX_DISPLAYNAME_LENGTH];
   char szBuf3[MAX_DISPLAYNAME_LENGTH];


   if(!_IsEnoughSpace(szBuf1, sizeof(szBuf1),szBuf2, sizeof(szBuf2), szBuf3, sizeof(szBuf3) ))
      hr = _ShowDiskSpaceDialog();

   return hr;
}

HRESULT CInstallEngineCtl::_ShowDiskSpaceDialog()
{
   HWND hwnd;

   if(_pProgDlg)
      hwnd = _pProgDlg->GetHWND();
   else
      hwnd = m_hwnd;

   // create and show the dialog
    INT_PTR ret = DialogBoxParam(g_hInstance, MAKEINTRESOURCE(IDD_DISKSPACE), hwnd,
                          DiskSpaceDlgProc, (LPARAM) this);
    if(ret == IDOK)
       return NOERROR;
    else
       return E_ABORT;
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//


//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:


INT_PTR CALLBACK DiskSpaceDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
   CInstallEngineCtl *pctl = (CInstallEngineCtl *) GetWindowLongPtr(hDlg, DWLP_USER);

   switch(uMsg)
   {
      case WM_INITDIALOG:
         {
            char szBuf1[MAX_DISPLAYNAME_LENGTH];
            char szBuf2[MAX_DISPLAYNAME_LENGTH];
            char szBuf3[MAX_DISPLAYNAME_LENGTH];

            pctl = (CInstallEngineCtl *) lParam;
            SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR) pctl);

            pctl->_IsEnoughSpace(szBuf1, sizeof(szBuf1), szBuf2, sizeof(szBuf2), szBuf3, sizeof(szBuf3));
            SetDlgItemText(hDlg, IDC_SPACE1, szBuf1);
            SetDlgItemText(hDlg, IDC_SPACE2, szBuf2);
            SetDlgItemText(hDlg, IDC_SPACE3, szBuf3);

         }
         return TRUE;

      case WM_COMMAND:
         switch (LOWORD(wParam))
         {

            case IDOK:
               {
                  char szBuf1[MAX_DISPLAYNAME_LENGTH];
                  char szBuf2[MAX_DISPLAYNAME_LENGTH];
                  char szBuf3[MAX_DISPLAYNAME_LENGTH];

                  if(!pctl->_IsEnoughSpace(szBuf1, sizeof(szBuf1), szBuf2, sizeof(szBuf2), szBuf3, sizeof(szBuf3)))
                  {
                     SetDlgItemText(hDlg, IDC_SPACE1, szBuf1);
                     SetDlgItemText(hDlg, IDC_SPACE2, szBuf2);
                     SetDlgItemText(hDlg, IDC_SPACE3, szBuf3);
                  }
                  else
                     EndDialog(hDlg, IDOK);
               }
               break;
            case IDCANCEL:
               EndDialog(hDlg, IDCANCEL);
               break;

            default:
               return FALSE;
         }
         break;

      default:
         return FALSE;
   }
   return TRUE;
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//


STDMETHODIMP CInstallEngineCtl::OnEngineStatusChange(DWORD dwEngineStatus, DWORD sub)
{
   BOOL fSetEvent = FALSE;


   if((_dwOldStatus == ENGINESTATUS_LOADING)&&(_dwOldStatus != dwEngineStatus))
   {
      if (_dwMSTrustKey != (DWORD)-1)
      {
         WriteMSTrustKey(FALSE, _dwMSTrustKey);
      }
      _dwMSTrustKey = (DWORD)-1;
   }

   if((_dwOldStatus == ENGINESTATUS_LOADING) && (_dwOldStatus != dwEngineStatus) && _hDone)
   {
      _hResult = sub;
      fSetEvent = TRUE;
   }
   else
   {
      if(_dwFreezeEvents)
      {
         _fEventToFire = TRUE;
         _dwSavedEngineStatus = dwEngineStatus;
         _dwSavedSubStatus = sub;
      }
      else
      {
         _FireEngineStatusChange(dwEngineStatus, sub);
      }
   }
   _dwOldStatus = dwEngineStatus;

   if(fSetEvent)
      SetEvent(_hDone);

   return NOERROR;
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

void CInstallEngineCtl::_FireEngineStatusChange(DWORD dwEngineStatus, DWORD sub)
{
   CALLBACK_PARAMS cbp = { 0 };

   cbp.dwStatus = dwEngineStatus;
   cbp.dwSubstatus = sub;

   SendMessage(m_hwnd, WM_INSENGCALLBACK, (WPARAM) EVENT_ONENGINESTATUSCHANGE, (LPARAM) &cbp);
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngineCtl::OnStartInstall(DWORD dwDLSize, DWORD dwTotalSize)
{
   if(_pszErrorString)
   {
      // if we get OnStartInstall and we are installing,
      // We intentionally swallow this onStartInstall
      if(_pProgDlg)
         _pProgDlg->SetInsProgGoal(dwTotalSize);
   }
   else
   {
      // this is OnStartInstall for download
      if(_pProgDlg)
         _pProgDlg->SetDownloadProgGoal(dwDLSize);


      _FireOnStartInstallEvent(dwDLSize);

   }

   return NOERROR;
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

void CInstallEngineCtl::_FireOnStartInstallEvent(DWORD dwTotalSize)
{
   CALLBACK_PARAMS cbp = { 0 };

   cbp.dwSize = dwTotalSize;

   SendMessage(m_hwnd, WM_INSENGCALLBACK, (WPARAM) EVENT_ONSTARTINSTALL, (LPARAM) &cbp);
}

void CInstallEngineCtl::_FireOnStartInstallExEvent(DWORD dwDLSize, DWORD dwInsSize)
{
   CALLBACK_PARAMS cbp = { 0 };

   cbp.dwSize = dwInsSize;
   cbp.dwDL = dwDLSize;

   SendMessage(m_hwnd, WM_INSENGCALLBACK, (WPARAM) EVENT_ONSTARTINSTALLEX, (LPARAM) &cbp);
}


//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//


STDMETHODIMP CInstallEngineCtl::OnStartComponent(LPCSTR pszID, DWORD dwDLSize,
                                            DWORD dwInstallSize, LPCSTR pszName)
{
   _strCurrentID = BSTRFROMANSI(pszID);
   _strCurrentName = BSTRFROMANSI(pszName);
   _strCurrentString = BSTRFROMANSI("");

   _FireOnStartComponentEvent(pszID, dwDLSize, pszName);
   return NOERROR;
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//


STDMETHODIMP CInstallEngineCtl::OnEngineProblem(DWORD dwProblem, LPDWORD pdwAction)
{
   HRESULT hr = S_FALSE;

   if((dwProblem == ENGINEPROBLEM_DOWNLOADFAIL) && _rpszUrlList[0])
   {
      // if we have at least one url in list, do switching ourselves
      if( ((_uCurrentUrl + 1) < MAX_URLS) && _rpszUrlList[_uCurrentUrl + 1])
      {
         _uCurrentUrl++;
         _pinseng->SetBaseUrl(_rpszUrlList[_uCurrentUrl]);
         *pdwAction = DOWNLOADFAIL_RETRY;
         hr = S_OK;
      }
   }
   else
   {
      _dwAction = 0;
      _FireOnEngineProblem(dwProblem);
      *pdwAction = _dwAction;
      if(*pdwAction != 0)
         hr = S_OK;
   }
   return hr;
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

void CInstallEngineCtl::_FireOnEngineProblem(DWORD dwProblem)
{

   CALLBACK_PARAMS cbp = { 0 };

   cbp.dwStatus = dwProblem;

   SendMessage(m_hwnd, WM_INSENGCALLBACK, (WPARAM) EVENT_ONENGINEPROBLEM, (LPARAM) &cbp);
}


//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

void CInstallEngineCtl::_FireOnStartComponentEvent(LPCSTR pszID, DWORD dwTotalSize, LPCSTR pszName)
{

   CALLBACK_PARAMS cbp = { 0 };


   cbp.strID = BSTRFROMANSI(pszID);
   cbp.strName = BSTRFROMANSI(pszName);

   cbp.dwSize = dwTotalSize;

   SendMessage(m_hwnd, WM_INSENGCALLBACK, (WPARAM) EVENT_ONSTARTCOMPONENT, (LPARAM) &cbp);

   SysFreeString(cbp.strID);
   SysFreeString(cbp.strName);
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//


STDMETHODIMP CInstallEngineCtl::OnComponentProgress(LPCSTR pszID, DWORD dwPhase, LPCSTR pszString, LPCSTR pszMsgString, ULONG ulSofar, ULONG ulMax)
{
   char szBuf[512];
   char szRes[512];

   // _FireOnComponentProgress(dwPhase, ulSofar, ulMax);

   if(!_pProgDlg)
      return NOERROR;

   if(dwPhase != _dwLastPhase)
   {

      _dwLastPhase = dwPhase;

      // Set up progress for this phase

      UINT id;

      switch(dwPhase)
      {
         case INSTALLSTATUS_INITIALIZING :
            id = IDS_PREPARE;
            break;
         case INSTALLSTATUS_DOWNLOADING :
            id = IDS_DOWNLOADING;
            break;
         case INSTALLSTATUS_EXTRACTING :
            id = IDS_EXTRACTING;
            break;
         case INSTALLSTATUS_CHECKINGTRUST :
            id = IDS_CHECKTRUST;
            break;

         case INSTALLSTATUS_RUNNING :
            id = IDS_INSTALLING;
            break;
         default :
            id = IDS_NOPHASE;
      }
      LoadSz(id, szRes, sizeof(szRes));
      wsprintf(szBuf, szRes, pszString);
      // Setup text for this phase
      _pProgDlg->SetProgText(szBuf);
   }

   if(dwPhase == INSTALLSTATUS_DOWNLOADING)
      _pProgDlg->SetDownloadProgress(ulSofar);
   else if(dwPhase == INSTALLSTATUS_RUNNING)
      _pProgDlg->SetInsProgress(ulSofar);


   return NOERROR;
}

void CInstallEngineCtl::_FireOnComponentProgress(DWORD dwPhase, DWORD dwSoFar, DWORD dwTotal)
{

   CALLBACK_PARAMS cbp = { 0 };


   cbp.strID = _strCurrentID;
   cbp.strName = _strCurrentName;
   cbp.strString = _strCurrentString;

   cbp.dwPhase = dwPhase;
   cbp.dwSize = dwTotal;
   cbp.dwDL = dwSoFar;

   SendMessage(m_hwnd, WM_INSENGCALLBACK, (WPARAM) EVENT_ONCOMPONENTPROGRESS, (LPARAM) &cbp);
}




//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngineCtl::OnStopComponent(LPCSTR pszID, HRESULT hrError, DWORD dwPhase, LPCSTR pszString, DWORD dwStatus)
{
   char szBuf[512];
   char szRes[512];
   void *pTemp;


   if(_strCurrentID)
   {
      SysFreeString(_strCurrentID);
      _strCurrentID = NULL;
   }

   if(_strCurrentName)
   {
      SysFreeString(_strCurrentName);
      _strCurrentName = NULL;
   }

   if(_strCurrentString)
   {
      SysFreeString(_strCurrentString);
      _strCurrentString = NULL;
   }

   if(_pszErrorString)
   {
      if(FAILED(hrError))
      {
         // failed AND installing
         UINT id;

         switch(dwPhase)
         {
            case INSTALLSTATUS_INITIALIZING :
               id = IDS_ERRPREPARE;
               break;
            case INSTALLSTATUS_DOWNLOADING :
            case INSTALLSTATUS_COPYING :
               id = IDS_ERRDOWNLOAD;
               break;
            case INSTALLSTATUS_DEPENDENCY :
               id = IDS_ERRDEPENDENCY;
               break;
            case INSTALLSTATUS_EXTRACTING :
               id = IDS_ERREXTRACTING;
               break;
            case INSTALLSTATUS_RUNNING :
               id = IDS_ERRINSTALLING;
               break;
            case INSTALLSTATUS_CHECKINGTRUST :
               id = IDS_ERRNOTTRUSTED;
               break;

            default :
               id = IDS_NOPHASE;
         }
         LoadSz(id, szRes, sizeof(szRes));
      }
      else
      {
         LoadSz(IDS_SUCCEEDED, szRes, sizeof(szRes));
      }

      // After loading the appropriate message into szRes, now tag it to _pszErrorString.
      // Make sure that _pszErrorString is big enough for the new data being appended
      wsprintf(szBuf, szRes, pszString);

      // This is assuming only ANSI characters. None of the  strings in this control must be UNICODE!!
      if ( lstrlen(szBuf) >= (_iErrorStringSize - lstrlen(_pszErrorString)) )
      {
          // Realloc _pszErrorString by ERROR_STRING_INCREMENT
          pTemp = realloc(_pszErrorString, _iErrorStringSize + ERROR_STRING_INCREMENT);
          if ( pTemp != NULL )
          {   // realloc succeeded. Update the string pointer and sizes.
              _pszErrorString = (char *) pTemp;
              _iErrorStringSize += ERROR_STRING_INCREMENT;
          }
          else
          {   // No memory. Abandon summary logging.
              free(_pszErrorString);
              _pszErrorString = NULL;
          }
      }

      if (_pszErrorString)
        lstrcat(_pszErrorString, szBuf);
   }

   if ( FAILED(hrError) && hrError != E_ABORT &&
        (dwPhase == INSTALLSTATUS_DOWNLOADING || dwPhase == INSTALLSTATUS_CHECKINGTRUST) )
   {
       _bDeleteURLList = TRUE;
   }

   _FireOnStopComponentEvent(pszID, hrError, dwPhase, pszString, dwStatus);

   return NOERROR;
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

void CInstallEngineCtl::_FireOnStopComponentEvent(LPCSTR pszID, HRESULT hrError, DWORD dwPhase, LPCSTR pszString, DWORD dwStatus)
{

   CALLBACK_PARAMS cbp = { 0 };


   cbp.strID = BSTRFROMANSI(pszID);
   cbp.strName = BSTRFROMANSI(pszString);
   cbp.dwResult = (DWORD) hrError;
   cbp.dwPhase = dwPhase;
   cbp.dwStatus = dwStatus;

   SendMessage(m_hwnd, WM_INSENGCALLBACK, (WPARAM) EVENT_ONSTOPCOMPONENT, (LPARAM) &cbp);


   SysFreeString(cbp.strID);
   SysFreeString(cbp.strName);
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngineCtl::OnStopInstall(HRESULT hrError, LPCSTR szError, DWORD dwStatus)
{

   _hResult = hrError;
   _dwInstallStatus = dwStatus;

   if ( _bDeleteURLList )
       _DeleteURLList();
   else
       if ( _bNewWebSites )
           _WriteURLList();

   SetEvent(_hDone);
   return NOERROR;
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

void CInstallEngineCtl::_FireOnStopInstallEvent(HRESULT hrError, LPCSTR szError, DWORD dwStatus)
{
   CALLBACK_PARAMS cbp = { 0 };

   cbp.dwResult = (DWORD) hrError;
   cbp.dwStatus = dwStatus;
   cbp.strString = BSTRFROMANSI( szError ? szError : "");

   SendMessage(m_hwnd, WM_INSENGCALLBACK, (WPARAM) EVENT_ONSTOPINSTALL, (LPARAM) &cbp);


   SysFreeString(cbp.strString);
}


void CInstallEngineCtl::MarkJITInstall()
{
    HRESULT hr = S_OK;
    IOleClientSite *pClientSite = NULL;
    IHTMLDocument2 *pDoc = NULL;
    BSTR bstrURL = NULL;
    IOleContainer *pContainer = NULL;

    hr = GetClientSite(&pClientSite);

    if (SUCCEEDED(hr))
    {
        hr = pClientSite->GetContainer(&pContainer);
        if (SUCCEEDED(hr))
        {
            hr = pContainer->QueryInterface(IID_IHTMLDocument2, (LPVOID *)&pDoc);
            if (SUCCEEDED(hr))
            {
                hr = pDoc->get_URL(&bstrURL);
                if (SUCCEEDED(hr) && bstrURL)
                {
                    HKEY hKeyActiveSetup;
                    char szJITPage[INTERNET_MAX_URL_LENGTH] = "";
                    DWORD dwSize = INTERNET_MAX_URL_LENGTH;
                    DWORD dwType;
                    BSTR bstrJITPage = NULL;

                    if (ERROR_SUCCESS == RegOpenKeyEx(
                            HKEY_LOCAL_MACHINE,
                            TEXT("Software\\Microsoft\\Active Setup"),
                            0,
                            KEY_READ,
                            &hKeyActiveSetup))
                    {
                        if (ERROR_SUCCESS == RegQueryValueEx(
                            hKeyActiveSetup,
                            TEXT("JITSetupPage"),
                            NULL,
                            &dwType,
                            (LPBYTE) szJITPage,
                            &dwSize
                            ))
                        {
                            bstrJITPage = BSTRFROMANSI(szJITPage);
                            if (bstrJITPage)
                            {
                                if (0 == lstrcmpiW(bstrJITPage, bstrURL))
                                {
                                    // If the URL points to an internal resource,
                                    // it's probably safe to assume this is a JIT install.
                                    _fJITInstall = TRUE;
                                }
                                SysFreeString(bstrJITPage);
                            }
                        }
                        RegCloseKey(hKeyActiveSetup);
                    }
                    SysFreeString(bstrURL);
                }
                pDoc->Release();
            }
            pContainer->Release();
        }
        pClientSite->Release();
    }
}


DWORD WINAPI DoInstall(LPVOID pv)
{
   CInstallEngineCtl *p = (CInstallEngineCtl *) pv;
   HRESULT hr = CoInitialize(NULL);
   p->_DoInstall();
   if(SUCCEEDED(hr))
      CoUninitialize();

   return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\asctrls\asinsctl.h ===
#ifndef _ASINSCTL_H
#define _ASINSCTL_H

#include "ipserver.h"
#include "ctrlobj.h"
#include "internet.h"
#include "iasctrls.h"
#include "inseng.h"
#include "progdlg.h"


#define RESID_TOOLBOX_BITMAP 1

#define FINALIZE_DOREBOOT         0x00000001
#define FINALIZE_NOREBOOTPROMPT   0x00000002

#define PROCESSCOMPONENT_DELAYREBOOT  0x00000001
#define PROCESSCOMPONENT_NOPROGRESSUI 0x00000002
#define PROCESSCOMPONENT_NOSUMMARYUI  0x00000004

#define PROCESSCOMPONENT_NOINSTALLUI  0x00000080

#define MAX_URLS 5
#define ERROR_STRING_SIZE       2048
#define ERROR_STRING_INCREMENT  2048

//---------------------------------------------
// AUTORUN SETTINGS FOR WIN
//---------------------------------------------
#define WINDOWS_DEFAULT_AUTOPLAY_VALUE  0x095
#define WINDOWS_AUTOPLAY_OFF            0x0FF

typedef struct
{
   DWORD dwSize;
   DWORD dwStatus;
   DWORD dwSubstatus;
   DWORD dwPhase;
   DWORD dwResult;
   BSTR  strID;
   BSTR  strName;
   BSTR  strString;
   BSTR  chWin;
   BSTR  chInstall;
   BSTR  chDL;
   DWORD dwWin;
   DWORD dwInstall;
   DWORD dwDL;
} CALLBACK_PARAMS;


// Global needed in CInstallEngine for suppressing CD Auto Splash.
extern UINT          g_uCDAutorunMsg;
extern unsigned long g_ulOldAutorunSetting;
unsigned long SetAutorunSetting(unsigned long ulNewSettting);

//=--------------------------------------------------------------------------=
// CInstallEngine
//=--------------------------------------------------------------------------=
// our control.
//
class CInstallEngineCtl : public COleControl, public IInstallEngineCtl, public IInstallEngineCallback, public ISupportErrorInfo
{

   friend class CProgressDlg;
   friend INT_PTR CALLBACK ProgressDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
   friend DWORD WINAPI DoInstall(LPVOID pv);
   friend INT_PTR CALLBACK LocationDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
   friend INT_PTR CALLBACK DiskSpaceDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

   public:
      // IUnknown methods
      //
      DECLARE_STANDARD_UNKNOWN();

      // IDispatch methods
      //
      DECLARE_STANDARD_DISPATCH();

      // ISupportErrorInfo methods
      //
      DECLARE_STANDARD_SUPPORTERRORINFO();

      // IInstallEngine methods
      //
      STDMETHOD(get_ReadyState)(THIS_ long FAR* thestate);
      STDMETHOD(SetCifFile)(THIS_ BSTR strCabName, BSTR strCifName);
      STDMETHOD(put_BaseUrl)(THIS_ BSTR strBaseUrl);
      STDMETHOD(put_DownloadDir)(THIS_ BSTR strDownloadDir);
      STDMETHOD(SetAction)(THIS_ BSTR ComponentID, long action, long *lResult);
      STDMETHOD(IsComponentInstalled)(THIS_ BSTR ComponentID, long *lResult);
      STDMETHOD(ProcessComponents)(THIS_ long lFlag);
      STDMETHOD(get_Size)(THIS_ BSTR ComponentID, long FAR* thestate);
      STDMETHOD(get_DisplayName)(THIS_ BSTR ComponentID, BSTR *name);
      STDMETHOD(Abort)(THIS_ long lFlags);
      STDMETHOD(get_TotalDownloadSize)(THIS_ long FAR* totalsize);
      STDMETHOD(get_TotalDependencySize)(THIS_ long FAR* totaldepsize);
      STDMETHOD(FinalizeInstall)(THIS_ long lFlag);
      STDMETHOD(get_EngineStatus)(THIS_ long FAR* theenginestatus);
      STDMETHOD(HandleEngineProblem)(THIS_ long lFlag);
      STDMETHOD(CheckFreeSpace)(THIS_ long lPad, long FAR* lEnough);
      STDMETHOD(SetLocalCif)(THIS_ BSTR strCif, long FAR* lResult);
      STDMETHOD(SetSitesFile)(THIS_ BSTR strUrl, BSTR strRegion, BSTR strLocale, long FAR* lResult);




      //	Install engine callbacks
      STDMETHOD(OnStartInstall)(DWORD dwDLSize, DWORD dwInstallSize);
	   STDMETHOD(OnStartComponent)(LPCSTR pszID, DWORD dwDLSize, DWORD dwInstallSize, LPCSTR pszName);
	   STDMETHOD(OnComponentProgress)(LPCSTR pszID, DWORD dwPhase, LPCSTR pszName, LPCSTR pszMsgString, ULONG progress, ULONG dwMax );
      STDMETHOD(OnStopComponent)(LPCSTR pszID, HRESULT hrError, DWORD dwPhase, LPCSTR pszString, DWORD dwStatus);
      STDMETHOD(OnStopInstall)(HRESULT hrError, LPCSTR szError, DWORD dwStatus);
      STDMETHOD(OnEngineStatusChange)(DWORD dwStatus, DWORD substatus);
      STDMETHOD(OnEngineProblem)(DWORD dwProblem, LPDWORD pdwAction);

      // OLE Control stuff follows:
      //
      CInstallEngineCtl(IUnknown *pUnkOuter, BOOL *pbSuccess);
      virtual ~CInstallEngineCtl();
      // static creation function.  all controls must have one of these!
      //
      static IUnknown *Create(IUnknown *);

      // Helper functions to fire our events
      void _FireOnStartInstallEvent(DWORD dwTotalSize);
      void _FireOnStartComponentEvent(LPCSTR pszID, DWORD dwTotalSize, LPCSTR pszName);
      void _FireOnStopComponentEvent(LPCSTR pszID, HRESULT hrError, DWORD dwPhase, LPCSTR pszString, DWORD dwStatus);
      void _FireOnStopInstallEvent(HRESULT hrError, LPCSTR szError, DWORD dwStatus);
      void _FireEngineStatusChange(DWORD dwEngineStatus, DWORD substatus);
      void _FireOnEngineProblem(DWORD dwProblem);
      void _FireOnComponentProgressEvent(LPCSTR pszID, DWORD dwPhase, LPCSTR pszString, LPCSTR pszMsgString, ULONG progress, ULONG themax);
      void _FireOnComponentProgress(DWORD lPhase, DWORD lSoFar, DWORD lTotal);
      void _FireOnStartInstallExEvent(DWORD dwDLSize, DWORD dwInsSize);

   private:
      // overridables that the control must implement.
      //
      STDMETHOD(LoadBinaryState)(IStream *pStream);
      STDMETHOD(SaveBinaryState)(IStream *pStream);
      STDMETHOD(LoadTextState)(IPropertyBag *pPropertyBag, IErrorLog *pErrorLog);
      STDMETHOD(SaveTextState)(IPropertyBag *pPropertyBag, BOOL fWriteDefault);
      STDMETHOD(OnDraw)(DWORD dvAspect, HDC hdcDraw, LPCRECTL prcBounds, LPCRECTL prcWBounds, HDC hicTargetDev, BOOL fOptimize);

      STDMETHOD(FreezeEvents)(BOOL bFreeze);

      // Window stuff
      virtual LRESULT WindowProc(UINT msg, WPARAM wParam, LPARAM lParam);
      virtual BOOL RegisterClassData(void);

      // internal QI
      virtual HRESULT InternalQueryInterface(REFIID, void **);

      // before and after window is created
      virtual void BeforeCreateWindow(void);
	   virtual BOOL AfterCreateWindow(void);


      void       _InitProgressDialog();
      void       _DoInstall();
      HRESULT    _CheckInstallPath(BOOL *pfNeedDownload);
      BOOL       _PathIsIEInstallPoint(LPCSTR pszPath);
      HRESULT    _PickWebSites(LPCSTR pszSites, LPCSTR pszLocale, LPCSTR pszRegion, BOOL bKeepExisting);
      BOOL       _IsEnoughSpace(LPSTR szSpace1, DWORD dwSize1, LPSTR szSpace2, DWORD dwSize2,
                                       LPSTR szSpace3, DWORD dwSize3);
      HRESULT    _CheckForDiskSpace();
      HRESULT    _ShowDiskSpaceDialog();
      void       _FireCancel(DWORD dwCancel);
      LONG       _OpenJITKey(HKEY *hKey, REGSAM samAttr);
      void       _DeleteURLList();
      void       _WriteURLList();
      void       _WriteRegionToReg(LPSTR szRegion);
      void       _PickRegionAndFirstSite(IDownloadSite **ppISite, UINT uNumSites, LPSTR pszRegion, UINT *puFirstSite);
      void       _PickRandomSites(IDownloadSite **ppISite, BYTE *pPicks, UINT uNumSites, UINT uNumToPick, LPSTR pszRegion);
      void       MarkJITInstall();

      BOOL             _fInOnEngineProblem:1;
      BOOL             _fEventToFire:1;
      BOOL             _fNeedReboot:1;
      BOOL             _fLocalCifSet:1;
      BOOL             _fReconcileCif:1;
      BOOL             _fDoingIEInstall:1;
      BOOL             _fInstalling:1;
      BOOL             _fJITInstall:1;


      DWORD            _dwOldStatus;
      DWORD            _dwAction;
      DWORD            _dwInstallStatus;
      UINT             _uInstallMode;
      UINT             _uInstallPad;

      HRESULT          _hResult;

      DWORD            _dwSavedEngineStatus;
      DWORD            _dwSavedSubStatus;
      DWORD            _dwFreezeEvents;
      DWORD            _uAllowGrovel;


      BSTR             _strCurrentID;
      BSTR             _strCurrentName;
      BSTR             _strCurrentString;
      DWORD            m_readyState;
      LPSTR            _pszErrorString;
      int              _iErrorStringSize;
      DWORD            _dwProcessComponentsFlags;
      HICON            _hIcon;
      DWORD            _dwLastPhase;
      CProgressDlg    *_pProgDlg;
      IInstallEngine2 *_pinseng;
      DWORD            _dwMSTrustKey;
      HANDLE           _hDone;
      UINT             _uCurrentUrl;
      LPSTR            _rpszUrlList[MAX_URLS];
      char             _szCifCab[MAX_PATH];
      char             _szCifFile[MAX_PATH];
      char             _szDownloadDir[MAX_PATH];
      BOOL             _bCancelPending;
      BOOL             _bDeleteURLList;
      BOOL             _bNewWebSites;
};

DWORD WINAPI DoInstall(LPVOID pv);

DEFINE_CONTROLOBJECT(InstallEngineCtl,     // Name of object
    &CLSID_InstallEngineCtl,               // CLSID of object
    "InstallEngineCtl",                    // ProgID
    CInstallEngineCtl::Create,             // Static create function
    1,                            // Version
    &IID_IInstallEngineCtl,                // Primary dispatch
    NULL,                         // name of help file
    &DIID_DInstallEngineCtlEvents,         // event interface
    OLEMISC_SETCLIENTSITEFIRST|OLEMISC_ACTIVATEWHENVISIBLE|OLEMISC_RECOMPOSEONRESIZE|OLEMISC_CANTLINKINSIDE|OLEMISC_INSIDEOUT,
    0,                            // Activation policy
    RESID_TOOLBOX_BITMAP,         // toolbox id
    "InstallEngineCtlWndClass",            // Window class
    0,                            // number of pages
    NULL,                         // array of property pages
    0,                            // Number of verbs
    NULL);                        // Array of verbs

#define OBJECT_INSTALLENGINECTL 0

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\asctrls\cathelp.cpp ===
#include "asctlpch.h"
#include "comcat.h"

// Helper function to create a component category and associated description
HRESULT CreateComponentCategory(CATID catid, WCHAR* catDescription)
{

    ICatRegister* pcr = NULL ;
    HRESULT hr = S_OK ;

   hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr, 
			NULL, CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&pcr);
	if (FAILED(hr))
		return hr;

    // Make sure the HKCR\Component Categories\{..catid...}
    // key is registered
    CATEGORYINFO catinfo;
    catinfo.catid = catid;
    catinfo.lcid = 0x0409 ; // english

	// Make sure the provided description is not too long.
	// Only copy the first 127 characters if it is
	int len = wcslen(catDescription);
	if (len>127)
		len = 127;
   wcsncpy(catinfo.szDescription, catDescription, len);
	// Make sure the description is null terminated
	catinfo.szDescription[len] = '\0';

    hr = pcr->RegisterCategories(1, &catinfo);
	pcr->Release();

	return hr;
}

// Helper function to register a CLSID as belonging to a component category
HRESULT RegisterCLSIDInCategory(REFCLSID clsid, CATID catid)
{
// Register your component categories information.
    ICatRegister* pcr = NULL ;
    HRESULT hr = S_OK ;
    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr, 
			NULL, CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&pcr);
    if (SUCCEEDED(hr))
    {
       // Register this category as being "implemented" by
       // the class.
       CATID rgcatid[1] ;
       rgcatid[0] = catid;
       hr = pcr->RegisterClassImplCategories(clsid, 1, rgcatid);
    }

    if (pcr != NULL)
        pcr->Release();
  
	return hr;
}

// Helper function to unregister a CLSID as belonging to a component category
HRESULT UnRegisterCLSIDInCategory(REFCLSID clsid, CATID catid)
{
    ICatRegister* pcr = NULL ;
    HRESULT hr = S_OK ;
    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr, 
			NULL, CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&pcr);
    if (SUCCEEDED(hr))
    {
       // Unregister this category as being "implemented" by
       // the class.
       CATID rgcatid[1] ;
       rgcatid[0] = catid;
       hr = pcr->UnRegisterClassImplCategories(clsid, 1, rgcatid);
    }

    if (pcr != NULL)
        pcr->Release();
  
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\asctrls\progdlg.h ===
class CInstallEngineCtl;

class CProgressDlg
{
   private:
      HWND hDlg;
      HWND hProgText;
      HWND hBigProg;
      HWND hLittleProg;

      DWORD dwLittleGoal;
      DWORD dwLittleFactor;

      DWORD dwBigGoal;
      DWORD dwBigFactor;

      DWORD dwOldBytes;
      DWORD dwOldMinutesLeft;

      void UpdateLittleTime(DWORD dwSecsLeft);


  public:
      CProgressDlg(HINSTANCE hInst, HWND hParent, HWND hGrandParent, CInstallEngineCtl *pctl);
      void DisplayWindow(BOOL fShow);
      ~CProgressDlg();
      void SetInsProgGoal(DWORD dwKBytes);
      void SetDownloadProgGoal(DWORD dwKBytes);
      void SetDownloadProgress(DWORD dwKBytes);
      void SetProgText(LPCSTR psz);
      void SetInsProgress(DWORD dwKBytes);
      HWND GetHWND() { return hDlg; }
      CInstallEngineCtl *pinsengctl;
      IInstallEngineTiming *ptimer;
};

INT_PTR CALLBACK ProgressDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\asctrls\dispids.h ===
// dispids for the listctl

#define DISPID_CIFFILE                  5000
#define DISPID_VALIDATEOPTION           5001
#define DISPID_SETACTION                5002 
#define DISPID_PROCESSCOMPONENTS        5003
#define DISPID_ISCOMPONENTINSTALLED     5004
#define DISPID_SIZE                     5005
#define DISPID_EXEFILE                  5006
#define DISPID_ABORT                    5007
#define DISPID_BASEURL                  5008
#define DISPID_TOTALSIZE                5009
#define DISPID_DEPENDENCYSIZE           5010
#define DISPID_FINALIZEINSTALL          5011
#define DISPID_ENGINESTATUS             5012
#define DISPID_ENGINESTATUSCHANGE       5013
#define DISPID_EXTRACOMMAND             5014
#define DISPID_DOWNLOADDIR              5015
#define DISPID_HANDLEENGINEPROBLEM      5016
#define DISPID_CHECKFREESPACE           5017
#define DISPID_NAME                     5018
#define DISPID_SETLOCALCIF              5019
#define DISPID_SETSITESFILE             5020


#define DISPID_ONSTARTINSTALL           5100
#define DISPID_ONSTARTCOMPONENT         5101
#define DISPID_ONSTOPCOMPONENT          5102
#define DISPID_ONSTOPINSTALL            5103
#define DISPID_ONENGINEPROBLEM          5104
#define DISPID_ONCHECKFREESPACE         5105
#define DISPID_ONCOMPONENTPROGRESS      5106
#define DISPID_ONSTARTINSTALLEX         5107
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\asctrls\iguids.cpp ===
//=--------------------------------------------------------------------------=
// iguids.cpp
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// contains the guids we will define 
//


#include "asctlpch.h"

#define INITGUID
#include <initguid.h>
#include <extobj.h>
#include "inseng.h"
#include "iasctrls.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\asctrls\progdlg.cpp ===
#include "asctlpch.h"
#include "asinsctl.h"
#include "resource.h"
#include "util2.h"


#define WM_LAUNCHCOMPLETE  WM_USER+121

CProgressDlg::CProgressDlg(HINSTANCE hInst, HWND hParent, HWND hGrandParent, CInstallEngineCtl *ctl)
{
   RECT r;
   dwBigGoal = 0;
   dwLittleGoal = 0;
   dwOldMinutesLeft = 0xffffffff;
   hProgText = NULL;
   hBigProg  = NULL;
   hLittleProg = NULL;
   dwOldBytes = 0;
   LPSTR pszTitle = NULL;

   hDlg = CreateDialog(hInst, MAKEINTRESOURCE(IDD_PROGRESS), hGrandParent, ProgressDlgProc);
      // Get the Display title from inseng
   ctl->_pinseng->GetDisplayName(NULL, &pszTitle);
   ctl->_pinseng->SetHWND(hDlg);
   if(pszTitle)
   {
      SetWindowText(hDlg, pszTitle);
      CoTaskMemFree(pszTitle);
   }
   SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR) this);
   if(hGrandParent)
   {
      GetWindowRect(hGrandParent, &r);
      SetWindowPos(hDlg, 0, r.left, r.top, 0, 0, SWP_NOZORDER | SWP_NOSIZE);
   }

   pinsengctl = ctl;
   pinsengctl->_pinseng->QueryInterface(IID_IInstallEngineTiming, (void **) &ptimer);
}

CProgressDlg::~CProgressDlg()
{
   if(ptimer)
      ptimer->Release();

   pinsengctl->_pinseng->SetHWND(GetParent(hDlg));

   DestroyWindow(hDlg);
}

void CProgressDlg::DisplayWindow(BOOL fShow)
{
   if(fShow)
      ShowWindow(hDlg, SW_SHOWNORMAL);
   else
      ShowWindow(hDlg, SW_HIDE);
}


INT_PTR CALLBACK ProgressDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
       case WM_INITDIALOG:
          // Do some init stuff
          SetFontForControl(hwnd, IDC_PROG_TEXT);
          Animate_Open( GetDlgItem( hwnd, IDC_ANIM ), MAKEINTRESOURCE(IDA_FILECOPY) );
          Animate_Play( GetDlgItem( hwnd, IDC_ANIM ), 0, -1, -1 );
          return FALSE;

       case WM_COMMAND:
          switch (wParam)
          {
             case IDCANCEL:
                {
                   char szBuf[256];
                   char szTitle[128];
                   HRESULT hr = S_FALSE;
                   int id;

                   CProgressDlg *p = (CProgressDlg *)GetWindowLongPtr(hwnd, GWLP_USERDATA);

                   LoadSz(IDS_TITLE, szTitle, sizeof(szTitle));

                   if(p->pinsengctl)
                      hr = p->pinsengctl->_pinseng->Suspend();

                   if(hr == S_FALSE)
                      id = IDS_CONFIRMCANCEL_UNSAFE;
                   else
                      id = IDS_CONFIRMCANCEL;

                   LoadSz(id, szBuf, sizeof(szBuf));

                   if(MessageBox(hwnd, szBuf, szTitle, MB_YESNO | MB_ICONQUESTION) == IDYES)
                   {
                      if(p->pinsengctl)
                         p->pinsengctl->_FireCancel(ABORTINSTALL_NORMAL);
                      EnableWindow(GetDlgItem(hwnd, IDCANCEL), FALSE);
                   }
                   if(p->pinsengctl)
                      p->pinsengctl->_pinseng->Resume();
                }
                break;

             default:
                return FALSE;
          }
          break;

       default:
          return(FALSE);
    }
    return TRUE;
}

void CProgressDlg::SetInsProgGoal(DWORD dwKBytes)
{
   dwBigFactor = dwKBytes / 65000 + 1;
   dwBigGoal = dwKBytes;

   if(dwBigGoal == 0)
      dwBigGoal = 1;

   if(hBigProg == NULL)
      hBigProg = GetDlgItem(hDlg, IDC_PROG_BIG);

   SendMessage(hBigProg, PBM_SETRANGE, 0, MAKELPARAM(0, dwKBytes/dwBigFactor));
}


void CProgressDlg::SetDownloadProgGoal(DWORD dwKBytes)
{
   dwLittleFactor = dwKBytes / 65000 + 1;
   dwLittleGoal = dwKBytes;

   if(dwLittleGoal == 0)
      dwLittleGoal = 1;

   if(hLittleProg == NULL)
      hLittleProg = GetDlgItem(hDlg, IDC_PROG_LITTLE);

   SendMessage(hLittleProg,PBM_SETRANGE,0,MAKELPARAM(0,dwKBytes/dwLittleFactor));
   SetDlgItemText(hDlg, IDC_LITTLETIMELEFT, "");
   dwOldMinutesLeft = 0xffffffff;
}

void CProgressDlg::SetInsProgress(DWORD dwKBytes)
{
   INSTALLPROGRESS pinsprog;
   DWORD progress;
   DWORD bytessofar;
   char szRes[256];
   char szBuf[256];
   DWORD remaining;

   if( (dwOldBytes == 0) && (dwKBytes != 0) )
   {
      ShowWindow(GetDlgItem(hDlg, IDC_BYTESLEFT), SW_HIDE);
      ShowWindow(GetDlgItem(hDlg, IDC_LITTLETIMELEFT), SW_HIDE);
   }

   ptimer->GetInstallProgress(&pinsprog);

   remaining = pinsprog.dwInstallKBRemaining;

   progress = (dwBigGoal - remaining)/dwBigFactor;

   // write out bytes remiaining

   if(dwBigGoal >= remaining)
      bytessofar = dwBigGoal - remaining;
   else
      bytessofar = 0;

   if(dwOldBytes != bytessofar)
   {
      LoadSz(IDS_PERCENT, szRes, sizeof(szRes));
      wsprintf(szBuf, szRes, 100*bytessofar/dwBigGoal);

      SetDlgItemText(hDlg, IDC_PERCENT, szBuf);
      dwOldBytes = bytessofar;
   }



   if(hBigProg == NULL)
      hBigProg = GetDlgItem(hDlg, IDC_PROG_BIG);

   SendMessage(hBigProg, PBM_SETPOS, progress, 0);
}

void CProgressDlg::SetDownloadProgress(DWORD dwKBytes)
{
   char szBuf[128];
   char szRes[128];
   INSTALLPROGRESS pinsprog;
   DWORD remaining;
   DWORD progress;
   DWORD bytessofar;

   ptimer->GetInstallProgress(&pinsprog);
   remaining = pinsprog.dwDownloadKBRemaining;

   progress = (dwLittleGoal - remaining)/dwLittleFactor;

   // write out bytes remiaining

   if(dwLittleGoal >= remaining)
      bytessofar = dwLittleGoal - remaining;
   else
      bytessofar = 0;

   if(dwOldBytes != bytessofar)
   {
      LoadSz(IDS_KBYTES , szRes, sizeof(szRes));
      wsprintf(szBuf, szRes, bytessofar, dwLittleGoal);

      SetDlgItemText(hDlg, IDC_BYTESLEFT, szBuf);
      dwOldBytes = bytessofar;
   }

   SendMessage(hLittleProg, PBM_SETPOS, progress, 0);

   remaining = pinsprog.dwDownloadSecsRemaining;

   if(remaining != 0xffffffff)
      UpdateLittleTime(remaining);
}

void CProgressDlg::SetProgText(LPCSTR psz)
{
   if(hProgText == NULL)
      hProgText = GetDlgItem(hDlg, IDC_PROG_TEXT);

   SetWindowText(hProgText, psz);
}


void CProgressDlg::UpdateLittleTime(DWORD dwSecsLeft)
{
   char szBuf[128];
   char szRes[128];
   szBuf[0] = 0;
   UINT id;
   UINT numParams = 2;

   DWORD dwHoursLeft = dwSecsLeft / 3600;
   DWORD dwMinutesLeft = (dwSecsLeft % 3600) / 60;
   if(dwMinutesLeft == 59)
   {
      dwHoursLeft++;
      dwMinutesLeft = 0;
   }

   // no need to update ui
   if(dwOldMinutesLeft == dwMinutesLeft)
      return;

   if(dwHoursLeft > 0)
   {
      if(dwHoursLeft > 1)
      {
         if(dwMinutesLeft == 0)
         {
            id = IDS_HOURSLEFT;
            numParams = 1;
         }
         else if(dwMinutesLeft == 1)
         {
            id = IDS_HOURSMINUTELEFT;
         }
         else
            id = IDS_HOURSMINUTESLEFT;
      }
      else
      {
         if(dwMinutesLeft == 0)
         {
            id = IDS_HOURLEFT;
            numParams = 1;
         }
         else if(dwMinutesLeft == 1)
         {
            id = IDS_HOURMINUTELEFT;
         }
         else
            id = IDS_HOURMINUTESLEFT;
      }
      LoadSz(id, szRes, sizeof(szRes));
      if(numParams == 1)
         wsprintf(szBuf, szRes, dwHoursLeft);
      else
         wsprintf(szBuf, szRes, dwHoursLeft, dwMinutesLeft);
   }
   else if(dwMinutesLeft > 0)
   {
      LoadSz(IDS_MINUTESLEFT , szRes, sizeof(szRes));
      wsprintf(szBuf, szRes, dwMinutesLeft + 1);
   }
   else
      LoadSz(IDS_SECONDSLEFT, szBuf, sizeof(szBuf));

   dwOldMinutesLeft = dwMinutesLeft;

   SetDlgItemText(hDlg, IDC_LITTLETIMELEFT, szBuf);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\asctrls\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

Author:   JordanF   07-11-96

!ENDIF

!include  ..\..\active.inc

TARGETTYPE=   DYNLINK
TARGETEXT=    ocx
TARGETPATH=   obj

DLLDEF=       ..\asctrls.def

DLLENTRY=     DllMain
USE_NOLIBS=1

DLLBASE=      @..\..\actbase.txt,asctrls

INCLUDES= ..\..\inc;.;..;..\..\..\sdslib;$(ADMIN_INC_PATH);


PASS0_HEADERDIR   = $(O)
PASS0_SOURCEDIR   = $(O)
MIDL_TLBDIR       = $(O)
MIDL_UUIDDIR      = $(O)

SOURCES= \
    ..\asctrls.cpp       \
    ..\iguids.cpp         \
    ..\cathelp.cpp         \
    ..\asinsctl.cpp         \
    ..\progdlg.cpp         \
    ..\utils2.cpp         \
    ..\asctrls.rc \
    ..\asctrls.odl

UMTYPE=       windows

MKTYPLIB_FLAGS=$(MKTYPLIB_FLAGS) -h $(O)\iasctrls.h

USE_MIDL_FOR_MKTYPLIB=1

LINKLIBS=   ..\..\basectl\$(O)\basectl.lib                          \

TARGETLIBS = \
              ..\..\..\sdslib\$(O)\sdsutils.lib     \
              $(SDK_LIB_PATH)\oleaut32.lib          \
              $(SDK_LIB_PATH)\ole32.lib             \
              $(SDK_LIB_PATH)\rpcrt4.lib            \
              $(SDK_LIB_PATH)\comdlg32.lib          \
              $(SDK_LIB_PATH)\uuid.lib              \
              $(SDK_LIB_PATH)\urlmon.lib            \
              $(SDK_LIB_PATH)\user32.lib            \
              $(SDK_LIB_PATH)\gdi32.lib             \
              $(SDK_LIB_PATH)\advapi32.lib          \
              $(SDK_LIB_PATH)\kernel32.lib          \
              $(SDK_LIB_PATH)\version.lib           \
              $(SDK_LIB_PATH)\libc.lib

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE= ..\asctlpch.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\asctrls\util2.h ===
#include "sdsutils.h"
#include "inseng.h"


#define MsgBox(title, msg)  ModalDialog(TRUE);\
                            MessageBeep(0xffffffff);\
                            MessageBox(m_hwnd, msg, title, MB_OK | MB_TASKMODAL | MB_SETFOREGROUND);\
                            ModalDialog(FALSE)

// MS trust key defines, this are bit fields to determine which one to add/delete
#define MSTRUSTKEY1     0x1
#define MSTRUSTKEY2     0x2
#define MSTRUSTKEY3     0x4
#define MSTRUSTKEY4     0x8
#define MSTRUSTKEY5     0x10
#define MSTRUSTKEY6     0x20
#define MSTRUSTKEY7     0x40
#define MSTRUSTKEY8     0x80
#define MSTRUSTKEY9     0x100
#define MSTRUSTKEY10    0x200
#define MSTRUSTKEY11    0x400

#define MSTRUST_ALL     MSTRUSTKEY1 | MSTRUSTKEY2 | MSTRUSTKEY3 | MSTRUSTKEY4 | MSTRUSTKEY5 | MSTRUSTKEY6 | MSTRUSTKEY7 | MSTRUSTKEY8 | MSTRUSTKEY9 | MSTRUSTKEY10 | MSTRUSTKEY11

extern HFONT g_hFont;

 
BOOL MyRestartDialog(HWND, BOOL);
int ErrMsgBox(LPSTR	pszText, LPCSTR	pszTitle, UINT	mbFlags);
int LoadSz(UINT id, LPSTR pszBuf, UINT cMaxSize);
BOOL KeepTransparent(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam, LRESULT *lres);
void WriteMSTrustKey(BOOL bSet, DWORD dwSetMSTrustKey, BOOL bForceMSTrust = FALSE);
DWORD MsTrustKeyCheck();
BOOL IsSiteInRegion(IDownloadSite *pISite, LPSTR pszRegion);

#ifdef TESTCERT
void UpdateTrustState();
void ResetTestrootCertInTrustState();
#endif
void WriteActiveSetupValue(BOOL bSet);
BOOL BrowseForDir( HWND hwndParent, LPSTR pszFolder, LPSTR pszTitle);

#define EVENTWAIT_QUIT  0
#define EVENTWAIT_DONE  1

DWORD WaitForEvent(HANDLE hEvent, HWND hwnd);

void SetControlFont();
void SetFontForControl(HWND hwnd, UINT uiID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\asctrls\resource.h ===
// our one lonely icon

#define IDI_INSTALLENGINE               101
#define IDI_CD                          102


// the progress dialog

#define IDD_PROGRESS                    101
#define IDC_PROG_LITTLE                 1000
#define IDC_PROG_BIG                    1001
#define IDC_PROG_TEXT                   1002
#define IDC_ANIM                        1004
#define IDC_BIGTIMELEFT                 1005
#define IDC_LITTLETIMELEFT              1006
#define IDC_LITTLESTATIC                1007
#define IDC_BYTESLEFT                   1008
#define IDC_PERCENT                     1009

//
#define IDD_LOCATE                      102
#define IDC_TEXT1                       1000
#define IDC_TEXT2                       1001
#define IDC_LOCATIONLIST                1002
#define IDC_BROWSE                      1003
#define IDC_INTERNET                    1004

#define IDD_DISKSPACE                   103
#define IDC_SPACE1                      1000
#define IDC_SPACE2                      1001
#define IDC_SPACE3                      1002

// site dlg
#define IDD_SITELIST                    104
#define IDC_REGIONS                     1000
#define IDC_SITES                       1001


#define IDC_STATIC                      -1

// misc. ids

#define IDA_FILECOPY                    1003


// String ids

#define IDS_DOWNLOADING                 3

#define IDS_INSTALLING                  5

#define IDS_TITLE                       7
#define IDS_INSTALLCANCELLED            8
#define IDS_ERRDOINGINSTALL             10
#define IDS_CONFIRMCANCEL               11
#define IDS_REBOOT                      13
#define IDS_PREPARE                     14
#define IDS_NOPHASE                     15
#define IDS_EXTRACTING                  16
#define IDS_DISPLAYNAME                 17
#define IDS_ERRGENERAL                  18
#define IDS_ERRPREPARE                  19
#define IDS_ERRDOWNLOAD                 20
#define IDS_ERREXTRACTING               21
#define IDS_ERRINSTALLING               22
#define IDS_ERRUNKNOWN                  23
#define IDS_ERRNOTTRUSTED               24
#define IDS_SUMMARYHEADING              25
#define IDS_DEPENDNAME                  26
#define IDS_ERRDEPENDENCY               27
#define IDS_CHECKTRUST                  28
#define IDS_SUCCEEDED                   29
#define IDS_TIMEUNKNOWN                 33
#define IDS_MINUTESLEFT                 34
#define IDS_SECONDSLEFT                 35
#define IDS_HOURSMINUTESLEFT            36
#define IDS_HOURSMINUTELEFT             37
#define IDS_HOURSLEFT                   38
#define IDS_HOURMINUTESLEFT             39
#define IDS_HOURMINUTELEFT              40
#define IDS_HOURLEFT                    41
#define IDS_KBYTES                      42
#define IDS_PHASE_COPYING               43
#define IDS_DOWNLOADTITLE               44
#define IDS_BYTESRECEIVED               45
#define IDS_PHASE_RETRYING              46
#define IDS_PERCENT                     47
#define IDS_GROVELMESSAGE               48
#define IDS_CONFIRMCANCEL_UNSAFE        49
#define IDS_FINISH_TITLE                50
#define IDS_CDNOTFOUND                  51
#define IDS_CDPLEASEINSERT              52
#define IDS_NETWORKNOTFOUND             53
#define IDS_NETWORKPLEASEFIND           54
#define IDS_INTERNET                    55
#define IDS_NOTVALIDLOCATION            56
#define IDS_NOTVALIDLOCATIONTITLE       57
#define IDS_DISKSPACE                   58
#define IDS_FINDFOLDER                  59
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\asctrls\asctrlex\makefile.inc ===
# rules to generate the tlb and h file


iasctrls.h $(O)\asctrls.tlb: ..\asctrls.odl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\asctrls\asctrls\makefile.inc ===
# rules to generate the tlb and h file


iasctrls.h $(O)\asctrls.tlb: ..\asctrls.odl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\asctrls\asctrl\makefile.inc ===
# rules to generate the tlb and h file


iasctrls.h $(O)\asctrls.tlb: ..\asctrls.odl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\asctrls\utils2.cpp ===
#include "asctlpch.h"
#include "globals.h"
#include "resource.h"
#include "util.h"
#include "util2.h"
#include "sdsutils.h"

#ifdef TESTCERT
#define TESTCERTVALUE 0xA0
#endif

const char c_gszMSTrustRegKey[] = "Software\\Microsoft\\Windows\\CurrentVersion\\WinTrust\\Trust Providers\\Software Publishing\\Trust Database\\0";
const char c_gszMSTrust[]      = "bhhphijojgfcdocagmhjgjbhmieinfap jpjmcfmhckkdfknkfemjikfiodeelkbd";
const char c_gszMSTrust2[]     = "bhhphijojgfcdocagmhjgjbhmieinfap immbkmbpjfdkajbkncahcedfmndgehba";
const char c_gszMSTrust3[]     = "bhhphijojgfcdocagmhjgjbhmieinfap doamnolbnlpmdlpnkcnpckgfimpaaicl";   // New MS Europe
const char c_gszMSTrust4[]     = "bhhphijojgfcdocagmhjgjbhmieinfap hbgflemajngobcablgnalaidgojggghj";
const char c_gszMSTrust5[]     = "bhhphijojgfcdocagmhjgjbhmieinfap kefdggbdmbmgbogjdcnmkoodcknmmghc";   // New MS Europe effective from 4/16/99
const char c_gszMSTrust6[]     = "bhhphijojgfcdocagmhjgjbhmieinfap debgjcefniaahdamnhbggedppfiianff";   // new MS effective from 4/16/99
const char c_gszMSTrust7[]     = "bhhphijojgfcdocagmhjgjbhmieinfap fmgfeljfbejhfcbbgnokplkipiiopchf";   // new MS effective from 4/16/2000
const char c_gszMSTrust8[]     = "bhhphijojgfcdocagmhjgjbhmieinfap jcphiillknjhbelgeadhnbgpjajjkhdh";   // New MS Europe effective from 4/16/2000
const char c_gszMSTrust9[]     = "klhfnkecpinogjmfaoamiabmhafnjldh adaaaaaaaaaahihcddgb";               // New MS effective 12/22/2000
const char c_gszMSTrust10[]    = "klhfnkecpinogjmfaoamiabmhafnjldh alaaaaaaaaaainckaggb";                  // New MS effective 3/29/2001
const char c_gszMSTrust11[]    = "klhfnkecpinogjmfaoamiabmhafnjldh aeaaaaaaaaaafpnldegb";                  // New MS Europe effective from 12/22/2000

const char c_gszMSTrustValue[] = "Microsoft Corporation";
const char c_gszMSTrustValue3[] = "Microsoft Corporation (Europe)";
#ifdef TESTCERT
const char c_gszTrustStateRegKey[]  = "Software\\Microsoft\\Windows\\CurrentVersion\\WinTrust\\Trust Providers\\Software Publishing";
const char c_gszState[]             = "State";
#endif

typedef struct _TRUSTEDPROVIDER
{
    DWORD    dwFlag;
    LPCSTR   pValue;        // Value part in the registeru
    LPCSTR   pData;         // Data part in the registry
} TRUSTEDPROVIDER;

TRUSTEDPROVIDER pTrustedProvider[] = { {MSTRUSTKEY1, c_gszMSTrust, c_gszMSTrustValue},      // MS US
                                       {MSTRUSTKEY2, c_gszMSTrust2, c_gszMSTrustValue},     // MS US
                                       {MSTRUSTKEY3, c_gszMSTrust3, c_gszMSTrustValue3},    // MS Europa
                                       {MSTRUSTKEY4, c_gszMSTrust4, c_gszMSTrustValue},     // MS US
                                       {MSTRUSTKEY5, c_gszMSTrust5, c_gszMSTrustValue3},    // New MS Europe effective from 4/16/99
                                       {MSTRUSTKEY6, c_gszMSTrust6, c_gszMSTrustValue},     // new MS effective from 4/16/99
                                       {MSTRUSTKEY7, c_gszMSTrust7, c_gszMSTrustValue},     // new MS effective from 4/16/2000
                                       {MSTRUSTKEY8, c_gszMSTrust8, c_gszMSTrustValue3},    // New MS Europe effective from 4/16/2000
                                       {MSTRUSTKEY9, c_gszMSTrust9, c_gszMSTrustValue3},    // New MS Europe effective from 4/16/2000
                                       {MSTRUSTKEY10, c_gszMSTrust10, c_gszMSTrustValue3},    // New MS Europe effective from 4/16/2000
                                       {MSTRUSTKEY11, c_gszMSTrust11, c_gszMSTrustValue3},     // New MS Europe effective from 12/22/2000
                                       {0,NULL, NULL} };                                    // Terminates the array.


HFONT g_hFont = NULL;

#define ACTIVESETUP_KEY "Software\\Microsoft\\Active Setup"
#define TRUSTKEYREG  "AllowMSTrustKey"

// NT reboot
//


BOOL MyNTReboot()
{                                                      
    HANDLE hToken;
    TOKEN_PRIVILEGES tkp;

    // get a token from this process
    if ( !OpenProcessToken( GetCurrentProcess(),
                            TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken ) )
    {
         return FALSE;
    }

    // get the LUID for the shutdown privilege
    LookupPrivilegeValue( NULL, SE_SHUTDOWN_NAME, &tkp.Privileges[0].Luid );

    tkp.PrivilegeCount = 1;
    tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    //get the shutdown privilege for this proces
    if (!AdjustTokenPrivileges(hToken, FALSE, &tkp, 0, (PTOKEN_PRIVILEGES)NULL, 0))
    {
        return FALSE;
    }

    // shutdown the system and force all applications to close
    if (!ExitWindowsEx( EWX_REBOOT, 0 ) )
    {
        return FALSE;
    }

    return TRUE;
}
//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

HRESULT LaunchProcess(LPCSTR pszCmd, HANDLE *phProc, LPCSTR pszDir, UINT uShow)
{
   STARTUPINFO startInfo;
   PROCESS_INFORMATION processInfo;
   HRESULT hr = S_OK;
   BOOL fRet;
   
   if(phProc)
      *phProc = NULL;

   // Create process on pszCmd
   ZeroMemory(&startInfo, sizeof(startInfo));
   startInfo.cb = sizeof(startInfo);
   startInfo.dwFlags |= STARTF_USESHOWWINDOW;
   startInfo.wShowWindow = (WORD)uShow;
   fRet = CreateProcess(NULL, (LPSTR)  pszCmd, NULL, NULL, FALSE, 
              NORMAL_PRIORITY_CLASS, NULL, pszDir, &startInfo, &processInfo);
   if(!fRet)
      return E_FAIL;

   if(phProc)
      *phProc = processInfo.hProcess;
   else
      CloseHandle(processInfo.hProcess);

   CloseHandle(processInfo.hThread);
   
   return S_OK;
}

#define SOFTBOOT_CMDLINE   "softboot.exe /s:,60"


// Display a dialog asking the user to restart Windows, with a button that
// will do it for them if possible.
//
BOOL MyRestartDialog(HWND hParent, BOOL bShowPrompt)
{
    char szBuf[256];
    char szTitle[256];
    UINT    id = IDYES;

    if(bShowPrompt)
    {
       LoadSz(IDS_TITLE, szTitle, sizeof(szTitle));
       LoadSz(IDS_REBOOT, szBuf, sizeof(szBuf));
       id = MessageBox(hParent, szBuf, szTitle, MB_ICONQUESTION | MB_YESNO | MB_TASKMODAL | MB_SETFOREGROUND);
    }
    
    if ( id == IDYES )
    {
       // path to softboot plus a little slop for the command line
       char szBuf[MAX_PATH + 10];
       szBuf[0] = 0;

       GetSystemDirectory(szBuf, sizeof(szBuf));
       AddPath(szBuf, SOFTBOOT_CMDLINE);
       if(FAILED(LaunchProcess(szBuf, NULL, NULL, SW_SHOWNORMAL)))
       {
          if(g_fSysWin95)
          {
             ExitWindowsEx( EWX_REBOOT , 0 );
          }
          else
          {
             MyNTReboot();
          }
       }
       
    }
    return (id == IDYES);
}


int ErrMsgBox(LPSTR	pszText, LPCSTR	pszTitle, UINT	mbFlags)
{
    HWND hwndActive;
    int  id;

    hwndActive = GetActiveWindow();

    id = MessageBox(hwndActive, pszText, pszTitle, mbFlags | MB_ICONERROR | MB_TASKMODAL);

    return id;
}

int LoadSz(UINT id, LPSTR pszBuf, UINT cMaxSize)
{
   if(cMaxSize == 0)
      return 0;

   pszBuf[0] = 0;

   return LoadString(g_hInstance, id, pszBuf, cMaxSize);
}



void WriteMSTrustKey(BOOL bSet, DWORD dwSetMSTrustKey, BOOL bForceMSTrust /*= FALSE*/)
{
    char szTmp[512];
    HKEY  hKey;
    int i = 0;
    static BOOL fAllowMSTrustKey = 42;

    if(fAllowMSTrustKey == 42)
    {
       fAllowMSTrustKey = FALSE;

       if(RegOpenKeyEx(HKEY_LOCAL_MACHINE, ACTIVESETUP_KEY,0, KEY_READ | KEY_WRITE, &hKey) == ERROR_SUCCESS)
       {
          DWORD dwSize = sizeof(DWORD);
          DWORD dwValue = 1;
          if(RegQueryValueEx(hKey, TRUSTKEYREG, NULL, NULL, (LPBYTE) &dwValue, &dwSize) == ERROR_SUCCESS)
          {
              fAllowMSTrustKey = (dwValue ? TRUE : FALSE);
          }
          RegCloseKey(hKey);
       }
    }

    if(!fAllowMSTrustKey && !bForceMSTrust && bSet)
        return;

    lstrcpy(szTmp, ".Default\\");
    lstrcat(szTmp, c_gszMSTrustRegKey);     // build the key for HKEY_USERS
    if (RegCreateKeyEx(HKEY_USERS, szTmp, 0, NULL, REG_OPTION_NON_VOLATILE, 
                    KEY_WRITE, NULL, &hKey, NULL) == ERROR_SUCCESS)
    {
        if (bSet)
        {
			while (pTrustedProvider[i].dwFlag > 0)
			{
				if (dwSetMSTrustKey & pTrustedProvider[i].dwFlag)
					RegSetValueEx( hKey, pTrustedProvider[i].pValue, 0, REG_SZ, (LPBYTE)pTrustedProvider[i].pData, lstrlen(pTrustedProvider[i].pData) + 1 );
				i++;
			}            
        }
        else
        {
			while (pTrustedProvider[i].dwFlag > 0)
			{
				if (dwSetMSTrustKey & pTrustedProvider[i].dwFlag)
					RegDeleteValue(hKey, pTrustedProvider[i].pValue);
				i++;
			}
        }
        RegCloseKey(hKey);
    }

    i = 0;
    if (RegCreateKeyEx(HKEY_CURRENT_USER, c_gszMSTrustRegKey, 0, NULL, REG_OPTION_NON_VOLATILE, 
                    KEY_WRITE, NULL, &hKey, NULL) == ERROR_SUCCESS)
    {
        if (bSet)
        {
			while (pTrustedProvider[i].dwFlag > 0)
			{
				if (dwSetMSTrustKey & pTrustedProvider[i].dwFlag)
				{
					RegSetValueEx( hKey, pTrustedProvider[i].pValue, 0, REG_SZ, (LPBYTE)pTrustedProvider[i].pData, lstrlen(pTrustedProvider[i].pData) + 1 );
				}
				i++;
			}            
        }
        else
        {
			while (pTrustedProvider[i].dwFlag > 0)
			{
				if (dwSetMSTrustKey & pTrustedProvider[i].dwFlag)
					RegDeleteValue(hKey, pTrustedProvider[i].pValue);
				i++;
			}
        }
        RegCloseKey(hKey);
    }

}

DWORD MsTrustKeyCheck()
{
    DWORD dwTmp;
    DWORD dwValue;
    HKEY  hKey;
    DWORD dwMSTrustKeyToSet = 0;
    int   i = 0;

    // Check MS Vendor trust key and set 
    if (RegOpenKeyEx(HKEY_CURRENT_USER, c_gszMSTrustRegKey, 0, KEY_READ, &hKey) == ERROR_SUCCESS)
    {
		while (pTrustedProvider[i].dwFlag > 0)
		{
			if (RegQueryValueEx( hKey, pTrustedProvider[i].pValue, 0, NULL, NULL, &dwTmp ) != ERROR_SUCCESS)
				dwMSTrustKeyToSet |= pTrustedProvider[i].dwFlag;
			i++;
		}
        RegCloseKey(hKey);
    }
    else
        dwMSTrustKeyToSet = MSTRUST_ALL;

    return dwMSTrustKeyToSet;
}

BOOL KeepTransparent(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam, LRESULT *lres)
{
   *lres = 0;
   HWND hwndParent;
   hwndParent = GetParent(hwnd);
   if (hwndParent)
   {
      POINT pt = {0,0};
      MapWindowPoints(hwnd, hwndParent, &pt, 1);
      OffsetWindowOrgEx((HDC)wParam, pt.x, pt.y, &pt);
      *lres = SendMessage(hwndParent, msg, wParam, lParam);
      SetWindowOrgEx((HDC)wParam, pt.x, pt.y, NULL);
      if (*lres)
         return TRUE; // we handled it!
   }
   return FALSE;
}

#ifdef TESTCERT
void UpdateTrustState()
{
    HKEY    hKey;
    DWORD   dwState;
    DWORD   dwType;
    DWORD   dwSize = sizeof(dwState);

    if (RegCreateKeyEx(HKEY_CURRENT_USER, c_gszTrustStateRegKey, 0, NULL, REG_OPTION_NON_VOLATILE, 
                    KEY_READ | KEY_WRITE, NULL, &hKey, NULL) == ERROR_SUCCESS)
    {
        if (RegQueryValueEx(hKey, c_gszState, 0, &dwType, (LPBYTE)&dwState, &dwSize) == ERROR_SUCCESS)
        {
            dwState |= TESTCERTVALUE;
        }
        else
            dwState = TESTCERTVALUE;

        RegSetValueEx( hKey, c_gszState, 0, REG_DWORD, (LPBYTE)&dwState, sizeof(dwState));
        RegCloseKey(hKey);
    }
}

void ResetTestrootCertInTrustState()
{
    HKEY    hKey;
    DWORD   dwState;
    DWORD   dwType;
    DWORD   dwSize = sizeof(dwState);

    if (RegOpenKeyEx(HKEY_CURRENT_USER, c_gszTrustStateRegKey, 0, 
                    KEY_READ | KEY_WRITE, &hKey) == ERROR_SUCCESS)
    {
        if (RegQueryValueEx(hKey, c_gszState, 0, &dwType, (LPBYTE)&dwState, &dwSize) == ERROR_SUCCESS)
        {
            // Clear the bits for trusting test root certs
            dwState &= (DWORD)~TESTCERTVALUE;
            RegSetValueEx( hKey, c_gszState, 0, REG_DWORD, (LPBYTE)&dwState, sizeof(dwState));
        }
        RegCloseKey(hKey);
    }
}
#endif

void WriteActiveSetupValue(BOOL bSet)
// If bSet is TRUE, add a reg value so that if IE4 base is installed, it would think that it is
// being run from Active Setup.  This would prevent softboot from being kicked off by IE4 base.
// If bSet is FALSE, delete the reg value.
{
   static const char c_szIE4Options[] = "Software\\Microsoft\\IE Setup\\Options";
   static const char c_szActiveSetup[] = "ActiveSetup";
   HKEY hk;
   LONG lErr;

   lErr = bSet ?
          RegCreateKeyEx(HKEY_LOCAL_MACHINE, c_szIE4Options, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hk, NULL) :
          RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szIE4Options, 0, KEY_WRITE, &hk);

   if (lErr == ERROR_SUCCESS)
   {
      if (bSet)
      {
         DWORD dwData = 1;

         RegSetValueEx(hk, c_szActiveSetup, 0, REG_DWORD, (CONST BYTE *) &dwData, sizeof(dwData));
      }
      else
         RegDeleteValue(hk, c_szActiveSetup);

      RegCloseKey(hk);
   }
}

DWORD WaitForEvent(HANDLE hEvent, HWND hwnd)
{
   BOOL fQuit = FALSE;
   BOOL fDone = FALSE;
   DWORD dwRet;
   while(!fQuit && !fDone)
   {
      dwRet = MsgWaitForMultipleObjects(1, &hEvent, FALSE, 
                                        INFINITE, QS_ALLINPUT);
      // Give abort the highest priority
      if(dwRet == WAIT_OBJECT_0)
      {
         fDone = TRUE;
      }
      else
      {
         MSG msg;
         // read all of the messages in this next loop 
         // removing each message as we read it 
         while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
         { 
            if(!hwnd || !IsDialogMessage(hwnd, &msg))
            {
              // if it's a quit message we're out of here 
              if (msg.message == WM_QUIT)
                fQuit = TRUE; 
              else
              {
                 // otherwise dispatch it 
                TranslateMessage(&msg);
                DispatchMessage(&msg); 
              }
            } // end of PeekMessage while loop 
         }
      }
   }
   return (fQuit ? EVENTWAIT_QUIT : EVENTWAIT_DONE);  
}

#define SHFREE_ORDINAL    195           // Required for BrowseForDir

const char achSHBrowseForFolder[]          = "SHBrowseForFolder";
const char achSHGetPathFromIDList[]        = "SHGetPathFromIDList";
const char achShell32Lib[]                 = "Shell32.dll";

//***************************************************************************
//***************************************************************************
// Required for BrowseForDir()
int CALLBACK BrowseCallback(HWND hwnd, UINT uMsg, LPARAM lParam, LPARAM lpData)
{
    switch(uMsg) 
    {
      case BFFM_INITIALIZED:
        // lpData is the path string
        SendMessage(hwnd, BFFM_SETSELECTION, TRUE, lpData);
        break;
    }
    return 0;
}

typedef WINSHELLAPI LPITEMIDLIST (WINAPI *SHBROWSEFORFOLDER)(LPBROWSEINFO);
typedef WINSHELLAPI void (WINAPI *SHFREE)(LPVOID);
typedef WINSHELLAPI BOOL (WINAPI *SHGETPATHFROMIDLIST)( LPCITEMIDLIST, LPTSTR );
//***************************************************************************
//*                                                                         *
//* NAME:       BrowseForDir                                                *
//*                                                                         *
//* SYNOPSIS:   Let user browse for a directory on their system or network. *
//*                                                                         *
//* REQUIRES:   hwndParent:                                                 *
//*                                                                         *
//* RETURNS:    BOOL:                                                       *
//*                                                                         *
//* NOTES:      It would be really cool to set the status line of the       *
//*             browse window to display "Yes, there's enough space", or    *
//*             "no there is not".                                          *
//*                                                                         *
//***************************************************************************
BOOL BrowseForDir( HWND hwndParent, LPSTR pszFolder, LPSTR pszTitle)
{
    BROWSEINFO   bi;
    LPITEMIDLIST pidl;
    HINSTANCE    hShell32Lib;
    SHFREE       pfSHFree;
    SHGETPATHFROMIDLIST        pfSHGetPathFromIDList;
    SHBROWSEFORFOLDER          pfSHBrowseForFolder;
    BOOL        fChange = FALSE;

    // Load the Shell 32 Library to get the SHBrowseForFolder() features

    if ( ( hShell32Lib = LoadLibrary( achShell32Lib ) ) != NULL )  
    {

       if ( ( !( pfSHBrowseForFolder = (SHBROWSEFORFOLDER)
                      GetProcAddress( hShell32Lib, achSHBrowseForFolder ) ) )
             || ( ! ( pfSHFree = (SHFREE) GetProcAddress( hShell32Lib,
                      MAKEINTRESOURCE(SHFREE_ORDINAL) ) ) )
             || ( ! ( pfSHGetPathFromIDList = (SHGETPATHFROMIDLIST)
                      GetProcAddress( hShell32Lib, achSHGetPathFromIDList ) ) ) )
        {
            FreeLibrary( hShell32Lib );
            return FALSE;
        }
    } 
    else  
    {
        return FALSE;
    }
 
    bi.hwndOwner      = hwndParent;
    bi.pidlRoot       = NULL;
    bi.pszDisplayName = NULL;
    bi.lpszTitle      = pszTitle;
    bi.ulFlags        = BIF_RETURNONLYFSDIRS;
    bi.lpfn           = BrowseCallback;
    bi.lParam         = (LPARAM)pszFolder;
   
    pidl              = pfSHBrowseForFolder( &bi );


    if ( pidl )  
    {
       pfSHGetPathFromIDList( pidl, pszFolder );
       pfSHFree( pidl );
       fChange = TRUE;
    }

    FreeLibrary( hShell32Lib );
    return fChange;
}

BOOL IsSiteInRegion(IDownloadSite *pISite, LPSTR pszRegion)
{
   BOOL bInRegion = FALSE;
   DOWNLOADSITE *psite;

   if(SUCCEEDED(pISite->GetData(&psite)))
   {
      if(lstrcmpi(psite->pszRegion, pszRegion) == 0)
         bInRegion = TRUE;
   }

   return bInRegion;
}

void SetControlFont()
{
   LOGFONT lFont;

   if (GetSystemMetrics(SM_DBCSENABLED) &&
       (GetObject(GetStockObject(DEFAULT_GUI_FONT), sizeof (lFont), &lFont) > 0))
   {
       g_hFont = CreateFontIndirect((LPLOGFONT)&lFont);
   }
}

void SetFontForControl(HWND hwnd, UINT uiID)
{
   if (g_hFont)
   {
      SendDlgItemMessage(hwnd, uiID, WM_SETFONT, (WPARAM)g_hFont ,0L);
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\basectl\classf.cpp ===
//=--------------------------------------------------------------------------=
// ClassF.Cpp
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains the implementation of the ClassFactory object. we support 
// IClassFactory and IClassFactory2
//
#include "IPServer.H"
#include "LocalSrv.H"

#include "ClassF.H"
#include "Globals.H"
#include "Unknown.H"                    // for CREATEFNOFOBJECT

//=--------------------------------------------------------------------------=
// private module level data
//=--------------------------------------------------------------------------=
//

// ASSERT and FAIL require this
//
SZTHISFILE

// private routines for this file
//
HRESULT   CreateOleObjectFromIndex(IUnknown *, int Index, void **, REFIID);

//=--------------------------------------------------------------------------=
// CClassFactory::CClassFactory
//=--------------------------------------------------------------------------=
// create the object and initialize the refcount
//
// Parameters:
//    int            - [in] index into our global table of objects for this guy
//
// Notes:
//
CClassFactory::CClassFactory
(
    int iIndex
)
: m_iIndex(iIndex)
{
    m_cRefs = 1;
}


//=--------------------------------------------------------------------------=
// CClassFactory::CClassFactory
//=--------------------------------------------------------------------------=
// "Life levels all men.  Death reveals the eminent."
// - George Bernard Shaw (1856 - 1950)
//
// Notes:
//
CClassFactory::~CClassFactory ()
{
    ASSERT(m_cRefs == 0, "Object being deleted with refs!");
    return;
}

//=--------------------------------------------------------------------------=
// CClassFactory::QueryInterface
//=--------------------------------------------------------------------------=
// the user wants another interface.  we won't give 'em. very many.
//
// Parameters:
//    REFIID        - [in]  interface they want
//    void **       - [out] where they want to put the resulting object ptr.
//
// Output:
//    HRESULT       - S_OK, E_NOINTERFACE
//
// Notes:
//
STDMETHODIMP CClassFactory::QueryInterface
(
    REFIID riid,
    void **ppvObjOut
)
{
    void *pv;

    CHECK_POINTER(ppvObjOut);

    // we support IUnknown, and the two CF interfaces
    //
    if (DO_GUIDS_MATCH(riid, IID_IClassFactory)) {
        pv = (void *)(IClassFactory *)this;
    } else if (DO_GUIDS_MATCH(riid, IID_IClassFactory2)) {
        pv = (void *)(IClassFactory2 *)this;
    } else if (DO_GUIDS_MATCH(riid, IID_IUnknown)) {
        pv = (void *)(IUnknown *)this;
    } else {
        *ppvObjOut = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown *)pv)->AddRef();
    *ppvObjOut = pv;
    return S_OK;
}




//=--------------------------------------------------------------------------=
// CClassFactory::AddRef
//=--------------------------------------------------------------------------=
// adds a tick to the current reference count.
//
// Output:
//    ULONG        - the new reference count
//
// Notes:
//
ULONG CClassFactory::AddRef
(
    void
)
{
    return ++m_cRefs;
}

//=--------------------------------------------------------------------------=
// CClassFactory::Release
//=--------------------------------------------------------------------------=
// removes a tick from the count, and delets the object if necessary
//
// Output:
//    ULONG         - remaining refs
//
// Notes:
//
ULONG CClassFactory::Release
(
    void
)
{
    ASSERT(m_cRefs, "No Refs, and we're being released!");
    if(--m_cRefs)
        return m_cRefs;

    delete this;
    return 0;
}

//=--------------------------------------------------------------------------=
// CClassFactory::CreateInstance
//=--------------------------------------------------------------------------=
// create an instance of some sort of object.
//
// Parameters:
//    IUnknown *        - [in]  controlling IUknonwn for aggregation
//    REFIID            - [in]  interface id for new object
//    void **           - [out] pointer to new interface object.
//
// Output:
//    HRESULT           - S_OK, E_NOINTERFACE, E_UNEXPECTED,
//                        E_OUTOFMEMORY, E_INVALIDARG
//
// Notes:
//
STDMETHODIMP CClassFactory::CreateInstance
(
    IUnknown *pUnkOuter,
    REFIID    riid,
    void    **ppvObjOut
)
{
    // check args
    //
    if (!ppvObjOut)
        return E_INVALIDARG;

    // check to see if we've done our licensing work.  we do this as late
    // as possible that people calling CreateInstanceLic don't suffer from
    // a performance hit here.
    //
    // crit sect this for apartment threading, since it's global
    //
    EnterCriticalSection(&g_CriticalSection);
    if (!g_fCheckedForLicense) {
        g_fMachineHasLicense = CheckForLicense();
        g_fCheckedForLicense = TRUE;
    }
    LeaveCriticalSection(&g_CriticalSection);

    // check to see if they have the appropriate license to create this stuff
    //
    if (!g_fMachineHasLicense)
        return CLASS_E_NOTLICENSED;

    // try to create one of the objects that we support
    //
    return CreateOleObjectFromIndex(pUnkOuter, m_iIndex, ppvObjOut, riid);
}

//=--------------------------------------------------------------------------=
// CClassFactory::LockServer
//=--------------------------------------------------------------------------=
// lock the server so we can't unload
//
// Parameters:
//    BOOL        - [in] TRUE means addref, false means release lock count.
//
// Output:
//    HRESULT     - S_OK, E_FAIL, E_OUTOFMEMORY, E_UNEXPECTED
//
// Notes:
//
STDMETHODIMP CClassFactory::LockServer
(
    BOOL fLock
)
{
    // update the lock count.  crit sect these in case of another thread.
    //
    if (fLock)  
        InterlockedIncrement(&g_cLocks);
    else {
        ASSERT(g_cLocks, "D'oh! Lock Counting Problem");
        InterlockedDecrement(&g_cLocks);
    }

    return S_OK;
}

//=--------------------------------------------------------------------------=
// CClassFactory::GetLicInfo
//=--------------------------------------------------------------------------=
// IClassFactory2 GetLicInfo
//
// Parameters:
//    LICINFO *          - unclear
//
// Output:
//    HRESULT            - unclear
//
// Notes:
//
STDMETHODIMP CClassFactory::GetLicInfo
(
    LICINFO *pLicInfo
)
{
    CHECK_POINTER(pLicInfo);

    pLicInfo->cbLicInfo = sizeof(LICINFO);

    // This says whether RequestLicKey will work
    //
    pLicInfo->fRuntimeKeyAvail = g_fMachineHasLicense;

    // This says whether the standard CreateInstance will work
    //
    pLicInfo->fLicVerified = g_fMachineHasLicense;

    return S_OK;
}


//=--------------------------------------------------------------------------=
// CClassFactory::RequestLicKey
//=--------------------------------------------------------------------------=
// IClassFactory2 RequestLicKey
//
// Parameters:
//    DWORD             - [in]  reserved
//    BSTR *            - [out] unclear
//
// Output:
//    HRESULT           - unclear
//
// Notes:
//
STDMETHODIMP CClassFactory::RequestLicKey
(
    DWORD  dwReserved,
    BSTR  *pbstr
)
{
    // if the machine isn't licensed, then we're not about to give this to them !
    //
    if (!g_fMachineHasLicense)
        return CLASS_E_NOTLICENSED;

    *pbstr = GetLicenseKey();
    return (*pbstr) ? S_OK : E_OUTOFMEMORY;
}


//=--------------------------------------------------------------------------=
// CClassFactory::CreateInstanceLic
//=--------------------------------------------------------------------------=
// create a new instance given a licensing key, etc ...
//
// Parameters:
//    IUnknown *        - [in]  controlling IUnknown for aggregation
//    IUnknown *        - [in]  reserved, must be NULL
//    REFIID            - [in]  IID We're looking for.
//    BSTR              - [in]  license key
//    void **           - [out] where to put the new object.
//
// Output:
//    HRESULT           - unclear
//
// Notes:
//
STDMETHODIMP CClassFactory::CreateInstanceLic
(
    IUnknown *pUnkOuter,
    IUnknown *pUnkReserved,
    REFIID    riid,
    BSTR      bstrKey,
    void    **ppvObjOut
)
{
    *ppvObjOut = NULL;

    // go and see if the key they gave us matches.
    //
    if (!CheckLicenseKey(bstrKey))
        return CLASS_E_NOTLICENSED;

    // if it does, then go and create the object.
    //
    return CreateOleObjectFromIndex(pUnkOuter, m_iIndex, ppvObjOut, riid);
}

//=--------------------------------------------------------------------------=
// CreateOleObjectFromIndex
//=--------------------------------------------------------------------------=
// given an index in our object table, create an object from it.
//
// Parameters:
//    IUnknown *       - [in]  Controlling Unknown, if any, for aggregation
//    int              - [in]  index into our global table
//    void **          - [out] where to put resulting object.
//    REFIID           - [in]  the interface they want resulting object to be.
//
// Output:
//    HRESULT          - S_OK, E_OUTOFMEMORY, E_NOINTERFACE
//
// Notes:
//
HRESULT CreateOleObjectFromIndex
(
    IUnknown *pUnkOuter,
    int       iIndex,
    void    **ppvObjOut,
    REFIID    riid
)
{
    IUnknown *pUnk = NULL;
    HRESULT   hr;

    // go and create the object
    //
    ASSERT(CREATEFNOFOBJECT(iIndex), "All creatable objects must have creation fn!");
    pUnk = CREATEFNOFOBJECT(iIndex)(pUnkOuter);

    // sanity check and make sure the object actually got allocated.
    //
    RETURN_ON_NULLALLOC(pUnk);

    // make sure we support aggregation here properly -- if they gave us
    // a controlling unknown, then they -must- ask for IUnknown, and we'll
    // give them the private unknown the object gave us.
    //
    if (pUnkOuter) {
        if (!DO_GUIDS_MATCH(riid, IID_IUnknown)) {
            pUnk->Release();
            return E_INVALIDARG;
        }

        *ppvObjOut = (void *)pUnk;
        hr = S_OK;
    } else {

        // QI for whatever the user wants.
        //
        hr = pUnk->QueryInterface(riid, ppvObjOut);
        pUnk->Release();
        RETURN_ON_FAILURE(hr);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\basectl\autoobj.cpp ===
//=--------------------------------------------------------------------------=
// AutoObj.Cpp
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// all of our objects will inherit from this class to share as much of the same
// code as possible.  this super-class contains the unknown, dispatch and
// error info implementations for them.
//
#include "IPServer.H"
#include "LocalSrv.H"

#include "AutoObj.H"
#include "Globals.H"
#include "Util.H"


// for ASSERT and FAIL
//
SZTHISFILE

//=--------------------------------------------------------------------------=
// CAutomationObject::CAutomationObject
//=--------------------------------------------------------------------------=
// create the object and initialize the refcount
//
// Parameters:
//    IUnknown *      - [in] controlling Unknown
//    int             - [in] the object type that we are
//    void *          - [in] the VTable of of the object we really are.
//
// Notes:
//
CAutomationObject::CAutomationObject 
(
    IUnknown *pUnkOuter,
    int   ObjType,
    void *pVTable,
	BOOL fExpandoEnabled
)
: CUnknownObject(pUnkOuter, pVTable), m_ObjectType (ObjType)
{
    m_fLoadedTypeInfo = FALSE;
	m_fExpandoEnabled = (BYTE)fExpandoEnabled;
	m_pexpando = NULL;
}


//=--------------------------------------------------------------------------=
// CAutomationObject::~CAutomationObject
//=--------------------------------------------------------------------------=
// "I have a rendezvous with Death, At some disputed barricade"
// - Alan Seeger (1888-1916)
//
// Notes:
//
CAutomationObject::~CAutomationObject ()
{
    // if we loaded up a type info, release our count on the globally stashed
    // type infos, and release if it becomes zero.
    //
    if (m_fLoadedTypeInfo) {

        // we have to crit sect this since it's possible to have more than
        // one thread partying with this object.
        //
        EnterCriticalSection(&g_CriticalSection);
        ASSERT(CTYPEINFOOFOBJECT(m_ObjectType), "Bogus ref counting on the Type Infos");
        CTYPEINFOOFOBJECT(m_ObjectType)--;

        // if we're the last one, free it!
        //
        if (!CTYPEINFOOFOBJECT(m_ObjectType)) {
            PTYPEINFOOFOBJECT(m_ObjectType)->Release();
            PTYPEINFOOFOBJECT(m_ObjectType) = NULL;
        }
        LeaveCriticalSection(&g_CriticalSection);
    }

	if (m_pexpando)
	{
		delete m_pexpando;
	}
    return;
}

//=--------------------------------------------------------------------------=
// CAutomationObject::InternalQueryInterface
//=--------------------------------------------------------------------------=
// the controlling unknown will call this for us in the case where they're
// looking for a specific interface.
//
// Parameters:
//    REFIID        - [in]  interface they want
//    void **       - [out] where they want to put the resulting object ptr.
//
// Output:
//    HRESULT       - S_OK, E_NOINTERFACE
//
// Notes:
//
HRESULT CAutomationObject::InternalQueryInterface
(
    REFIID riid,
    void **ppvObjOut
)
{
    ASSERT(ppvObjOut, "controlling Unknown should be checking this!");

    // start looking for the guids we support, namely IDispatch, and 
    // IDispatchEx

    if (DO_GUIDS_MATCH(riid, IID_IDispatch)) {
		// If expando functionality is enabled, attempt to allocate an
		// expando object and return that for the IDispatch interface.
		// If the allocation fails, we will fall back on using the regular
		// IDispatch from m_pvInterface;
		if (m_fExpandoEnabled)
		{
			if (!m_pexpando)
				m_pexpando = new CExpandoObject(m_pUnkOuter, (IDispatch*) m_pvInterface);  

			if (m_pexpando)
			{
				*ppvObjOut = (void*)(IDispatch*) m_pexpando;
				((IUnknown *)(*ppvObjOut))->AddRef();
				return S_OK;
			}
		}

        *ppvObjOut = (void*) (IDispatch*) m_pvInterface;
        ((IUnknown *)(*ppvObjOut))->AddRef();
        return S_OK;
    }
    else if (DO_GUIDS_MATCH(riid, IID_IDispatchEx) && m_fExpandoEnabled) {
		// Allocate the expando object if it hasn't been allocated already
		if (!m_pexpando)
			m_pexpando = new CExpandoObject(m_pUnkOuter, (IDispatch*) m_pvInterface);  

		// If the allocation succeeded, return the IDispatchEx interface from
		// the expando.  Otherwise fall through to CUnknownObject::InternalQueryInterface,
		// (which will most likely fail)
		if (m_pexpando)
		{
			 *ppvObjOut = (void *)(IDispatchEx *) m_pexpando;
			((IUnknown *)(*ppvObjOut))->AddRef();
			return S_OK;
		}
    }

    // just get our parent class to process it from here on out.
    //
    return CUnknownObject::InternalQueryInterface(riid, ppvObjOut);
}

//=--------------------------------------------------------------------------=
// CAutomationObject::GetTypeInfoCount
//=--------------------------------------------------------------------------=
// returns the number of type information interfaces that the object provides
//
// Parameters:
//    UINT *            - [out] the number of interfaces supported.
//
// Output:
//    HRESULT           - S_OK, E_NOTIMPL, E_INVALIDARG
//
// Notes:
//
STDMETHODIMP CAutomationObject::GetTypeInfoCount
(
    UINT *pctinfo
)
{
    // arg checking
    //
    if (!pctinfo)
        return E_INVALIDARG;

    // we support GetTypeInfo, so we need to return the count here.
    //
    *pctinfo = 1;
    return S_OK;
}

//=--------------------------------------------------------------------------=
// CAutomationObject::GetTypeInfo
//=--------------------------------------------------------------------------=
// Retrieves a type information object, which can be used to get the type
// information for an interface.
//
// Parameters:
//    UINT              - [in]  the type information they'll want returned
//    LCID              - [in]  the LCID of the type info we want
//    ITypeInfo **      - [out] the new type info object.
//
// Output:
//    HRESULT           - S_OK, E_INVALIDARG, etc.
//
// Notes:
//
STDMETHODIMP CAutomationObject::GetTypeInfo
(
    UINT        itinfo,
    LCID        lcid,
    ITypeInfo **ppTypeInfoOut
)
{
    DWORD       dwPathLen;
    char        szDllPath[MAX_PATH];
    HRESULT     hr;
    ITypeLib   *pTypeLib;
    ITypeInfo **ppTypeInfo =NULL;

    // arg checking
    //
    if (itinfo != 0)
        return DISP_E_BADINDEX;

    if (!ppTypeInfoOut)
        return E_POINTER;

    *ppTypeInfoOut = NULL;

    // ppTypeInfo will point to our global holder for this particular
    // type info.  if it's null, then we have to load it up. if it's not
    // NULL, then it's already loaded, and we're happy.
    // crit sect this entire nightmare so we're okay with multiple
    // threads trying to use this object.
    //
    EnterCriticalSection(&g_CriticalSection);
    ppTypeInfo = PPTYPEINFOOFOBJECT(m_ObjectType);

    if (*ppTypeInfo == NULL) {

        ITypeInfo *pTypeInfoTmp;
        HREFTYPE   hrefType;

        // we don't have the type info around, so go load it.
        //
        hr = LoadRegTypeLib(*g_pLibid, (USHORT)VERSIONOFOBJECT(m_ObjectType), 0,
                            LANG_NEUTRAL, &pTypeLib);

        // if, for some reason, we failed to load the type library this
        // way, we're going to try and load the type library directly out of
        // our resources.  this has the advantage of going and re-setting all
        // the registry information again for us.
        //
        if (FAILED(hr)) {

            dwPathLen = GetModuleFileName(g_hInstance, szDllPath, MAX_PATH);
            if (!dwPathLen) {
                hr = E_FAIL;
                goto CleanUp;
            }

            MAKE_WIDEPTR_FROMANSI(pwsz, szDllPath);
            hr = LoadTypeLib(pwsz, &pTypeLib);
            CLEANUP_ON_FAILURE(hr);
        }

        // we've got the Type Library now, so get the type info for the interface
        // we're interested in.
        //
        hr = pTypeLib->GetTypeInfoOfGuid((REFIID)INTERFACEOFOBJECT(m_ObjectType), &pTypeInfoTmp);
        pTypeLib->Release();
        CLEANUP_ON_FAILURE(hr);

        // the following couple of lines of code are to dereference the dual
        // interface stuff and take us right to the dispatch portion of the
        // interfaces.
        //
        hr = pTypeInfoTmp->GetRefTypeOfImplType(0xffffffff, &hrefType);
        if (FAILED(hr)) {
            pTypeInfoTmp->Release();
            goto CleanUp;
        }

        hr = pTypeInfoTmp->GetRefTypeInfo(hrefType, ppTypeInfo);
        pTypeInfoTmp->Release();
        CLEANUP_ON_FAILURE(hr);

        // add an extra reference to this object.  if it ever becomes zero, then
        // we need to release it ourselves.  crit sect this since more than
        // one thread can party on this object.
        //
        CTYPEINFOOFOBJECT(m_ObjectType)++;
        m_fLoadedTypeInfo = TRUE;
    }


    // we still have to go and addref the Type info object, however, so that
    // the people using it can release it.
    //
    (*ppTypeInfo)->AddRef();
    *ppTypeInfoOut = *ppTypeInfo;
    hr = S_OK;

  CleanUp:
    LeaveCriticalSection(&g_CriticalSection);
    return hr;
}



//=--------------------------------------------------------------------------=
// CAutomationObject::GetIDsOfNames
//=--------------------------------------------------------------------------=
// Maps a single member and an optional set of argument names to a
// corresponding set of integer DISPIDs
//
// Parameters:
//    REFIID            - [in]  must be IID_NULL
//    OLECHAR **        - [in]  array of names to map.
//    UINT              - [in]  count of names in the array.
//    LCID              - [in]  LCID on which to operate
//    DISPID *          - [in]  place to put the corresponding DISPIDs.
//
// Output:
//    HRESULT           - S_OK, E_OUTOFMEMORY, DISP_E_UNKNOWNNAME,
//                        DISP_E_UNKNOWNLCID
//
// Notes:
//    - we're just going to use DispGetIDsOfNames to save us a lot of hassle,
//      and to let this superclass handle it.
//
STDMETHODIMP CAutomationObject::GetIDsOfNames
(
    REFIID    riid,
    OLECHAR **rgszNames,
    UINT      cNames,
    LCID      lcid,
    DISPID   *rgdispid
)
{
    HRESULT     hr;
    ITypeInfo  *pTypeInfo;

    if (!DO_GUIDS_MATCH(riid, IID_NULL))
        return E_INVALIDARG;

    // get the type info for this dude!
    //
    hr = GetTypeInfo(0, lcid, &pTypeInfo);
    RETURN_ON_FAILURE(hr);

    // use the standard provided routines to do all the work for us.
    //
    hr = pTypeInfo->GetIDsOfNames(rgszNames, cNames, rgdispid);
    pTypeInfo->Release();

    return hr;
}

//=--------------------------------------------------------------------------=
// CAutomationObject::Invoke
//=--------------------------------------------------------------------------=
// provides access to the properties and methods on this object.
//
// Parameters:
//    DISPID            - [in]  identifies the member we're working with.
//    REFIID            - [in]  must be IID_NULL.
//    LCID              - [in]  language we're working under
//    USHORT            - [in]  flags, propput, get, method, etc ...
//    DISPPARAMS *      - [in]  array of arguments.
//    VARIANT *         - [out] where to put result, or NULL if they don't care.
//    EXCEPINFO *       - [out] filled in in case of exception
//    UINT *            - [out] where the first argument with an error is.
//
// Output:
//    HRESULT           - tonnes of them.
//
// Notes:
//    
STDMETHODIMP CAutomationObject::Invoke
(
    DISPID      dispid,
    REFIID      riid,
    LCID        lcid,
    WORD        wFlags,
    DISPPARAMS *pdispparams,
    VARIANT    *pvarResult,
    EXCEPINFO  *pexcepinfo,
    UINT       *puArgErr
)
{
    HRESULT    hr;
    ITypeInfo *pTypeInfo;

    if (!DO_GUIDS_MATCH(riid, IID_NULL))
        return E_INVALIDARG;

    // get our typeinfo first!
    //
    hr = GetTypeInfo(0, lcid, &pTypeInfo);
    RETURN_ON_FAILURE(hr);

    // Clear exceptions
    //
    SetErrorInfo(0L, NULL);

    // This is exactly what DispInvoke does--so skip the overhead.
    //
    hr = pTypeInfo->Invoke(m_pvInterface, dispid, wFlags,
                           pdispparams, pvarResult,
                           pexcepinfo, puArgErr);
    pTypeInfo->Release();

	return hr;

}

//=--------------------------------------------------------------------------=
// CAutomationObject::Exception
//=--------------------------------------------------------------------------=
// fills in the rich error info object so that both our vtable bound interfaces
// and calls through ITypeInfo::Invoke get the right error informaiton.
//
// Parameters:
//    HRESULT          - [in] the SCODE that should be associated with this err
//    WORD             - [in] the RESOURCE ID of the error message.
//    DWORD            - [in] helpcontextid for the error
//
// Output:
//    HRESULT          - the HRESULT that was passed in.
//
// Notes:
//
HRESULT CAutomationObject::Exception
(
    HRESULT hrExcep,
    WORD    idException,
    DWORD   dwHelpContextID
)
{
    ICreateErrorInfo *pCreateErrorInfo;
    IErrorInfo *pErrorInfo;
    WCHAR   wszTmp[256];
    char    szTmp[256];
    HRESULT hr;


    // first get the createerrorinfo object.
    //
    hr = CreateErrorInfo(&pCreateErrorInfo);
    if (FAILED(hr)) return hrExcep;

    MAKE_WIDEPTR_FROMANSI(wszHelpFile, HELPFILEOFOBJECT(m_ObjectType));

    // set up some default information on it.
    //
    pCreateErrorInfo->SetGUID((REFIID)INTERFACEOFOBJECT(m_ObjectType));
    pCreateErrorInfo->SetHelpFile(wszHelpFile);
    pCreateErrorInfo->SetHelpContext(dwHelpContextID);

    // load in the actual error string value.  max of 256.
    //
    LoadString(GetResourceHandle(), idException, szTmp, 256);
    MultiByteToWideChar(CP_ACP, 0, szTmp, -1, wszTmp, 256);
    pCreateErrorInfo->SetDescription(wszTmp);

    // load in the source
    //
    MultiByteToWideChar(CP_ACP, 0, NAMEOFOBJECT(m_ObjectType), -1, wszTmp, 256);
    pCreateErrorInfo->SetSource(wszTmp);

    // now set the Error info up with the system
    //
    hr = pCreateErrorInfo->QueryInterface(IID_IErrorInfo, (void **)&pErrorInfo);
    CLEANUP_ON_FAILURE(hr);

    SetErrorInfo(0, pErrorInfo);
    pErrorInfo->Release();

  CleanUp:
    pCreateErrorInfo->Release();
    return hrExcep;
}

//=--------------------------------------------------------------------------=
// CAutomationObject::InterfaceSupportsErrorInfo
//=--------------------------------------------------------------------------=
// indicates whether or not the given interface supports rich error information
//
// Parameters:
//    REFIID        - [in] the interface we want the answer for.
//
// Output:
//    HRESULT       - S_OK = Yes, S_FALSE = No.
//
// Notes:
//
HRESULT CAutomationObject::InterfaceSupportsErrorInfo
(
    REFIID riid
)
{
    // see if it's the interface for the type of object that we are.
    //
    if (riid == (REFIID)INTERFACEOFOBJECT(m_ObjectType))
        return S_OK;

    return S_FALSE;
}

//=--------------------------------------------------------------------------=
// CAutomationObject::GetResourceHandle    [helper]
//=--------------------------------------------------------------------------=
// virtual routine to get the resource handle.  virtual, so that inheriting
// objects, such as COleControl can use theirs instead, which goes and gets
// the Host's version ...
//
// Output:
//    HINSTANCE
//
// Notes:
//
HINSTANCE CAutomationObject::GetResourceHandle
(
    void
)
{
    return ::GetResourceHandle();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\basectl\ctlembed.cpp ===
//=--------------------------------------------------------------------------=
// CtlEmbed.Cpp
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// implementation of the interfaces required for inplace activation for
// COleControl
//

#include "IPServer.H"
#include "CtrlObj.H"

#include "CtlHelp.H"
#include "Globals.H"
#include "StdEnum.H"
#include "Util.H"

// for ASSERT and FAIL
//
SZTHISFILE


//=--------------------------------------------------------------------------=
// all controls support the following in-place verbs at an absolute minimum.
//
#define CINPLACEVERBS 4

const VERBINFO rgInPlaceVerbs [] = {
    { OLEIVERB_SHOW,            0, 0, 0},
    { OLEIVERB_HIDE,            0, 0, 0},
    { OLEIVERB_INPLACEACTIVATE, 0, 0, 0},
    { OLEIVERB_PRIMARY,         0, 0, 0}
};

// NOTE: Resource ID for Properties string must be 1000
//
const VERBINFO ovProperties =
    { CTLIVERB_PROPERTIES, 1000, 0, OLEVERBATTRIB_ONCONTAINERMENU };

const VERBINFO ovUIActivate =
    { OLEIVERB_UIACTIVATE, 0, 0, 0};


//=--------------------------------------------------------------------------=
// COleControl::GetControlInfo    (IOleControl)
//=--------------------------------------------------------------------------=
// returns some information on a control, such as an accelerator table, and
// flags.  really used for keyboard handling and mnemonics
//
// Parameters:
//    CONTROLINFO *        - [in]  where to put said information
//
// Output:
//    HRESULT              - S_OK
//
// Notes:
//
STDMETHODIMP COleControl::GetControlInfo
(
    CONTROLINFO *pControlInfo
)
{
    CHECK_POINTER(pControlInfo);

    // certain hosts have a bug in which it doesn't initialize the cb in the
    // CONTROLINFO structure, so we can only assert on that here.
    //
    ASSERT(pControlInfo->cb == sizeof(CONTROLINFO), "Host doesn't initialize CONTROLINFO structure");

    // NOTE: control writers should override this routine if they want to
    // return accelerator information in their control.
    //
    pControlInfo->hAccel = NULL;
    pControlInfo->cAccel = NULL;

    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::OnMnemonic    [IOleControl]
//=--------------------------------------------------------------------------=
// the container has decided to pass on a key that the end-user has pressed to
// us.  default implementation will be to just activate the control.  people
// looking for more functionality should override this method.
//
// Parameters:
//    LPMSG                - [in] message for this mnemonic
//
// Output:
//    HRESULT              - S_OK, E_POINTER
//
// Notes:
//
STDMETHODIMP COleControl::OnMnemonic
(
    LPMSG pMsg
)
{
    // OVERRIDE: default implementation is to just activate our control.  
    // user can override if they want more interesting behaviour.
    //
    return InPlaceActivate(OLEIVERB_UIACTIVATE);
}

//=--------------------------------------------------------------------------=
// COleControl:OnAmbientPropertyChange    [IOleControl]
//=--------------------------------------------------------------------------=
// a container calls this whenever it changes an ambient property.
//
// Parameters:
//    DISPID            - [in] dispid of the property that changed.
//
// Output:
//    HRESULT           - S_OK
//
// Notes:
//
STDMETHODIMP COleControl::OnAmbientPropertyChange
(
    DISPID dispid
)
{
    // if we're being told about a change in mode [design/run] then
    // remember that so our stashing of mode will update itself
    // correctly
    //
    if (dispid == DISPID_AMBIENT_USERMODE || dispid == DISPID_UNKNOWN)
        m_fModeFlagValid = FALSE;

    // just pass this on to the derived control and see if they want
    // to do anything with it.
    //
    AmbientPropertyChanged(dispid);
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControL::FreezeEvents    [IOleControl]
//=--------------------------------------------------------------------------=
// allows a container to freeze all of a controls events.  when events are
// frozen, a control will not fire any of them.
//
// Parameters:
//    BOOL            - [in] TRUE means FREEZE, FALSE means THAW
//
// Output:
//    HRESULT         - S_OK
//
// Notes:
//    - we maintain an internal count of freezes versus thaws.
//
STDMETHODIMP COleControl::FreezeEvents
(
    BOOL fFreeze
)
{
    // OVERRIDE: by default, we don't care.  user can override if they want to.
    //
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::SetClientSite    [IOleObject]
//=--------------------------------------------------------------------------=
// informs the embedded object [control] of it's client site [display
// location] within it's container
//
// Parameters:
//    IOleClientSite *        - [in] pointer to client site.
//
// Output:
//    HRESULT                 - S_OK, E_UNEXPECTED
//
// Notes:
//
STDMETHODIMP COleControl::SetClientSite
(
    IOleClientSite *pClientSite
)
{
    RELEASE_OBJECT(m_pClientSite);
    RELEASE_OBJECT(m_pControlSite);
    RELEASE_OBJECT(m_pSimpleFrameSite);

    // store away the new client site
    //
    m_pClientSite = pClientSite;

    // if we've actually got one, then get some other interfaces we want to keep
    // around, and keep a handle on it
    //
    if (m_pClientSite) {
        m_pClientSite->AddRef();
        m_pClientSite->QueryInterface(IID_IOleControlSite, (void **)&m_pControlSite);

        if (OLEMISCFLAGSOFCONTROL(m_ObjectType) & OLEMISC_SIMPLEFRAME)
            m_pClientSite->QueryInterface(IID_ISimpleFrameSite, (void **)&m_pSimpleFrameSite);
    }

    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::GetClientSite    [IOleObject]
//=--------------------------------------------------------------------------=
// obtains a pointer to the controls client site.
//
// Parameters:
//    IOleClientSite **        - [out]
//
// Output:
//    HRESULT                  - S_OK
//
// Notes:
//
STDMETHODIMP COleControl::GetClientSite
(
    IOleClientSite **ppClientSite
)
{
    CHECK_POINTER(ppClientSite);

    *ppClientSite = m_pClientSite;
    ADDREF_OBJECT(*ppClientSite);
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::SetHostNames    [IOleObject]
//=--------------------------------------------------------------------------=
// Provides the control with the name of its container application and the
// compound document in which it is embedded
//
// Parameters:
//    LPCOLESTR        - [in] name of container application
//    LPCOLESTR        - [in] name of container document
//
// Output:
//    HRESULT          - S_OK
//
// Notes:
//    - we don't care about this
//
STDMETHODIMP COleControl::SetHostNames
(
    LPCOLESTR szContainerApp,
    LPCOLESTR szContainerObject
)
{
    // we don't care about these
    //
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::Close    [IOleObject]
//=--------------------------------------------------------------------------=
// Changes the control from the running to the loaded state
//
// Parameters:
//    DWORD             - [in] indicates whether to save the object before closing
//
// Output:
//    HRESULT           - S_OK, OLE_E_PROMPTSAVECANCELLED
//
// Notes:
//
STDMETHODIMP COleControl::Close
(
    DWORD dwSaveOption
)
{
    HRESULT hr;

    if (m_fInPlaceActive) {
        hr = InPlaceDeactivate();
        RETURN_ON_FAILURE(hr);
    }

    // handle the save flag.
    //
    if ((dwSaveOption == OLECLOSE_SAVEIFDIRTY || dwSaveOption == OLECLOSE_PROMPTSAVE) && m_fDirty) {
        if (m_pClientSite) m_pClientSite->SaveObject();
        if (m_pOleAdviseHolder) m_pOleAdviseHolder->SendOnSave();
    }
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::SetMoniker    [IOleObject]
//=--------------------------------------------------------------------------=
// Notifies an object of its container's moniker, the object's own moniker
// relative to the container, or the object's full moniker
//
// Parameters:
//    DWORD                - [in] which moniker is being set
//    IMoniker *           - [in] the moniker
//
// Output:
//    HRESULT              - S_OK, E_FAIL
//
// Notes:
//    - we don't support monikers.
//
STDMETHODIMP COleControl::SetMoniker
(
    DWORD     dwWhichMoniker,
    IMoniker *pMoniker
)
{
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// COleControl::GetMoniker    [IOleObject]
//=--------------------------------------------------------------------------=
// Returns a embedded object's moniker, which the caller can use to link to
// the object
//
// Parameters:
//    DWORD            - [in]  how it's assigned
//    DWORD            - [in]  which moniker
//    IMoniker **      - [out] duh.
//
// Output:
//    HRESULT          - E_NOTIMPL
//
// Notes:
//    - we don't support monikers
//
STDMETHODIMP COleControl::GetMoniker
(
    DWORD      dwAssign,
    DWORD      dwWhichMoniker,
    IMoniker **ppMonikerOut
)
{
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// COleControl::InitFromData    [IOleObject]
//=--------------------------------------------------------------------------=
// Initializes a newly created object with data from a specified data object,
// which can reside either in the same container or on the Clipboard
//
// Parameters:
//    IDataObject*    - [in] data object with the data
//    BOOL            - [in] how object is created
//    DWORD           - reserved
//
// Output:
//    HRESULT         - S_OK, S_FALSE, E_NOTIMPL, OLE_E_NOTRUNNING
//
// Notes:
//    - we don't have data object support
//
STDMETHODIMP COleControl::InitFromData
(
    IDataObject *pDataObject,
    BOOL         fCreation,
    DWORD        dwReserved
)
{
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// COleControl::GetClipboardData    [IOleObject]
//=--------------------------------------------------------------------------=
// Retrieves a data object containing the current contents of the control.
// Using the pointer to this data object, it is possible to create a new control
// with the same data as the original
//
// Parameters:
//    DWORD          - reserved
//    IDataObject ** - [out] data object for this control
//
// Output:
//    HREUSLT        - S_OK, E_NOTIMPL, OLE_E_NOTRUNNING
//
// Notes:
//
STDMETHODIMP COleControl::GetClipboardData
(
    DWORD         dwReserved,
    IDataObject **ppDataObject
)
{
    *ppDataObject = NULL;        // be a good neighbour
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// COleControl::DoVerb    [IOleObject]
//=--------------------------------------------------------------------------=
// Requests an object to perform an action in response to an end-user's
// action.
//
// Parameters:
//    LONG             - [in]  verb to be performed
//    LPMSG            - [in]  event that invoked the verb
//    IOleClientSite * - [in]  the controls active client site
//    LONG             - [in]  reserved
//    HWND             - [in]  handle of window containing the object.
//    LPCRECT          - [in]  pointer to objects's display rectangle
//
// Output:
//    HRESULT          - S_OK, OLE_E_NOTINPLACEACTIVE, OLE_E_CANT_BINDTOSOURCE,
//                       DV_E_LINK, OLEOBJ_S_CANNOT_DOVERB_NOW, OLEOBJ_S_INVALIDHWND,
//                       OLEOBJ_E_NOVERBS, OLEOBJ_S_INVALIDVERB, MK_E_CONNECT,
//                       OLE_CLASSDIFF, E_NOTIMPL
//
// Notes:
//
STDMETHODIMP COleControl::DoVerb
(
    LONG            lVerb,
    LPMSG           pMsg,
    IOleClientSite *pActiveSite,
    LONG            lIndex,
    HWND            hwndParent,
    LPCRECT         prcPosRect
)
{
    HRESULT hr;

    switch (lVerb) {
      case OLEIVERB_SHOW:
      case OLEIVERB_INPLACEACTIVATE:
      case OLEIVERB_UIACTIVATE:
        hr = InPlaceActivate(lVerb);
        OnVerb(lVerb);
        return (hr);

      case OLEIVERB_HIDE:
        UIDeactivate();
        if (m_fInPlaceVisible) SetInPlaceVisible(FALSE);
        OnVerb(lVerb);
        return S_OK;

      // we used to have OLEIVERB_PRIMARY InPlaceActivate Ourselves, but it
      // turns out that the CDK and certain hosts expect this to show the
      // properties instead.  Users can change what this verb does at will.
      //
      case OLEIVERB_PRIMARY:
      case CTLIVERB_PROPERTIES:
      case OLEIVERB_PROPERTIES:
        {
        // show the frame ourselves if the hose can't.
        //
        if (m_pControlSite) {
            hr = m_pControlSite->ShowPropertyFrame();
            if (hr != E_NOTIMPL)
                return hr;
        }
        IUnknown *pUnk = (IUnknown *)(IOleObject *)this;
        MAKE_WIDEPTR_FROMANSI(pwsz, NAMEOFOBJECT(m_ObjectType));

        ModalDialog(TRUE);
        hr = OleCreatePropertyFrame(GetActiveWindow(),
                            GetSystemMetrics(SM_CXSCREEN) / 2,
                            GetSystemMetrics(SM_CYSCREEN) / 2,
                            pwsz,
                            1,
                            &pUnk,
                            CPROPPAGESOFCONTROL(m_ObjectType),
                            (LPCLSID)*(PPROPPAGESOFCONTROL(m_ObjectType)),
                            g_lcidLocale,
                            NULL, NULL);
        ModalDialog(FALSE);
        return hr;
        }

      default:
        // if it's a derived-control defined verb, pass it on to them
        //
        if (lVerb > 0) {
            hr = DoCustomVerb(lVerb);

            if (hr == OLEOBJ_S_INVALIDVERB) {
                // unrecognised verb -- just do the primary verb and
                // activate it.
                //
                hr = InPlaceActivate(OLEIVERB_PRIMARY);
                return (FAILED(hr)) ? hr : OLEOBJ_S_INVALIDVERB;
            } else
                return hr;
        } else {
            FAIL("Unrecognized Negative verb in DoVerb().  bad.");
            return E_NOTIMPL;
        }
        break;
    }

    // dead code
    FAIL("this should be dead code!");
}

//=--------------------------------------------------------------------------=
// COleControl::EnumVerbs    [IOleObject]
//=--------------------------------------------------------------------------=
// create an enumerator object for the verbs this object supports.
//
// Parameters:
//    IEnumOleVERB **    - [out] new enumerator.
//
// Output:
//    HRESULT            - S_OK, E_OUTOFMEMORY
//
// Notes:
//
STDMETHODIMP COleControl::EnumVerbs
(
    IEnumOLEVERB **ppEnumVerbs
)
{
    int cVerbs;
    OLEVERB *rgVerbs, *pVerb;

    DWORD dw = OLEMISCFLAGSOFCONTROL(m_ObjectType);
    BOOL fCanInPlace = !(dw & OLEMISC_INVISIBLEATRUNTIME) || (dw & OLEMISC_ACTIVATEWHENVISIBLE);
    BOOL fCanUIActivate = !(dw & OLEMISC_NOUIACTIVATE);
    BOOL fHasProperties = (CPROPPAGESOFCONTROL(m_ObjectType) != 0);

    int cVerbExtra = CCUSTOMVERBSOFCONTROL(m_ObjectType);

    // count up all the verbs
    //
    cVerbs = (fCanInPlace ? CINPLACEVERBS : 0) + (fCanUIActivate ? 1 : 0)
             + (fHasProperties ? 1 : 0) + cVerbExtra;

    // if there aren't any, this suddenly gets really easy !
    //
    if (cVerbs == 0)
        return OLEOBJ_E_NOVERBS;

    // HeapAlloc some storage for these dudes so that we can pass them on to
    // the standard enumerator!
    //
    if (! (rgVerbs = (OLEVERB *)HeapAlloc(g_hHeap, 0, cVerbs * sizeof(OLEVERB))))
        return E_OUTOFMEMORY;
  
    // start copying over verbs.  first, the in-place guys
    //
    pVerb = rgVerbs;
    if (fCanInPlace) {
        memcpy(pVerb, rgInPlaceVerbs, CINPLACEVERBS * sizeof(OLEVERB));
        pVerb += CINPLACEVERBS;
      }

    if (fCanUIActivate)
        memcpy(pVerb++, &ovUIActivate, sizeof(OLEVERB));

    // if their control has properties, copy that over now.
    //
    if (fHasProperties) {
        memcpy(pVerb, &ovProperties, sizeof(OLEVERB));
        pVerb++;
    }

    // finally, any custom verbs!
    //
    if (cVerbExtra) {
        memcpy(pVerb, CUSTOMVERBSOFCONTROL(m_ObjectType), sizeof(OLEVERB) * cVerbExtra);
    }

    *ppEnumVerbs = (IEnumOLEVERB *) (IEnumGeneric *) new CStandardEnum(IID_IEnumOLEVERB,
                                     cVerbs, sizeof(OLEVERB), rgVerbs, CopyOleVerb);
    if (!*ppEnumVerbs)
        return E_OUTOFMEMORY;

    // this forces us to go and look for the Localized DLLs.  This is necessary here
    // because the CopyOleVerb will get information from localized resources, but
    // will only use the global GetResourceHandle, which only uses the global value
    // for the LCID.  This turns out to not be a big performance hit, since this
    // function is typically only called in design mode, and we stash this value.
    //
    GetResourceHandle();
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::Update    [IOleObject]
//=--------------------------------------------------------------------------=
// Updates an object handler's or link object's data or view caches.
//
// Output:
//    HRESULT            - S_OK
//
// Notes:
//
STDMETHODIMP COleControl::Update
(
    void
)
{
    // nothing to do!!!
    //
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::IsUpToDate    [IOleObject]
//=--------------------------------------------------------------------------=
// Checks recursively whether or not an object is up to date.
//
// Output:
//    HRESULT        - S_OK, S_FALSE, OLE_E_UNVAILABLE
//
// Notes:
//
STDMETHODIMP COleControl::IsUpToDate
(
    void
)
{
    // we're always up to date
    //
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::GetUserClassID    [IOleObject]
//=--------------------------------------------------------------------------=
// Returns the controls class identifier, the CLSID corresponding to the
// string identifying the object to an end user.
//
// Parameters:
//    CLSID *      - [in] where to put the CLSID
//
// Output:
//    HRESULT      - S_OK, E_FAIL
//
// Notes:
//
STDMETHODIMP COleControl::GetUserClassID
(
    CLSID *pclsid
)
{
    // this is the same as IPersist::GetClassID
    //
    return GetClassID(pclsid);
}

//=--------------------------------------------------------------------------=
// COleControl::GetUserType    [IOleObject]
//=--------------------------------------------------------------------------=
// Retrieves the user-type name of the control for display in user-interface
// elements such as menus, list boxes, and dialog boxes.
//
// Parameters:
//    DWORD        - [in]  specifies the form of the type name.
//    LPOLESTR *   - [out] where to put user type
//
// Output:
//    HRESULT      - S_OK, OLE_S_USEREG, E_OUTOFMEMORY
//
// Notes:
//
STDMETHODIMP COleControl::GetUserType
(
    DWORD     dwFormOfType,
    LPOLESTR *ppszUserType
)
{
    *ppszUserType = OLESTRFROMANSI(NAMEOFOBJECT(m_ObjectType));
    return (*ppszUserType) ? S_OK : E_OUTOFMEMORY;
}

//=--------------------------------------------------------------------------=
// COleControl::SetExtent    [IOleObject]
//=--------------------------------------------------------------------------=
// Informs the control of how much display space its container has assigned it.
//
// Parameters:
//    DWORD            - [in] which form or 'aspect'  is to be displayed.
//    SIZEL *          - [in] size limit for the control.
//
// Output:
//    HRESULT          - S_OK, E_FAIL, OLE_E_NOTRUNNING
//
// Notes:
//
STDMETHODIMP COleControl::SetExtent
(
    DWORD  dwDrawAspect,
    SIZEL *psizel
)
{
    SIZEL sl;
    RECT  rect;
    BOOL  f;

    if (dwDrawAspect & DVASPECT_CONTENT) {

        // change the units to pixels, and resize the control.
        //
        HiMetricToPixel(psizel, &sl);

        // first call the user version.  if they return FALSE, they want
        // to keep their current size
        //
        f = OnSetExtent(&sl);
        if (f)
            HiMetricToPixel(psizel, &m_Size);

        // set things up with our HWND if we've got one.
        //
        if (!m_pInPlaceSiteWndless) {
            if (m_fInPlaceActive) {
    
                // theoretically, one should not need to call OnPosRectChange
                // here, but there appear to be a few host related issues that
                // will make us keep it here.  we won't, however, both with
                // windowless ole controls, since they are all new hosts who
                // should know better
                //
                GetWindowRect(m_hwnd, &rect);
                MapWindowPoints(NULL, m_hwndParent, (LPPOINT)&rect, 2);
                rect.right = rect.left + m_Size.cx;
                rect.bottom = rect.top + m_Size.cy;
                m_pInPlaceSite->OnPosRectChange(&rect);
    
                if (m_hwnd) {
                    // just go and resize
                    //
                    if (m_hwndReflect)
                        SetWindowPos(m_hwndReflect, 0, 0, 0, m_Size.cx, m_Size.cy,
                                     SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);
                    SetWindowPos(m_hwnd, 0, 0, 0, m_Size.cx, m_Size.cy,
                                 SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);
                }
            } else if (m_hwnd) {
                SetWindowPos(m_hwnd, NULL, 0, 0, m_Size.cx, m_Size.cy, SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);
            } else {
                ViewChanged();
            }
        } else
            if (m_pInPlaceSite) m_pInPlaceSite->OnPosRectChange(&rect);

        // return code depending on whether or not user accepted given
        // size
        //
        return (f) ? S_OK : E_FAIL;

    } else {
        // we don't support any other aspects.
        //
        return DV_E_DVASPECT;
    }

    // dead code
    FAIL("This should be dead code");
}

//=--------------------------------------------------------------------------=
// COleControl::GetExtent    [IOleObject]
//=--------------------------------------------------------------------------=
// Retrieves the control's current display size.
//
// Parameters:
//    DWORD            - [in] aspect
//    SIZEL *          - [in] where to put results
//
// Output:
//    S_OK, E_INVALIDARG
//
// Notes:
//
STDMETHODIMP COleControl::GetExtent
(
    DWORD  dwDrawAspect,
    SIZEL *pSizeLOut
)
{

    if (dwDrawAspect & DVASPECT_CONTENT) {
        PixelToHiMetric((const SIZEL *)&m_Size, pSizeLOut);
        return S_OK;
    } else {
        return DV_E_DVASPECT;
    }

    // dead code
}

//=--------------------------------------------------------------------------=
// COleControl::Advise    [IOleObject]
//=--------------------------------------------------------------------------=
// establishes and advisory connection between the control and the container,
// in which the control will notify the container of certain events.
//
// Parameters:
//    IAdviseSink *     - [in]  advise sink of calling object
//    DWORD             - [out] cookie
//
// Output:
//    HRESULT           - S_OK, E_OUTOFMEMORY
//
// Notes:
//
STDMETHODIMP COleControl::Advise
(
    IAdviseSink *pAdviseSink,
    DWORD       *pdwConnection
)
{
    HRESULT hr;

    // if we haven't yet created a standard advise holder object, do so
    // now
    //
    if (!m_pOleAdviseHolder) {
        hr = CreateOleAdviseHolder(&m_pOleAdviseHolder);
        RETURN_ON_FAILURE(hr);
    }

    // just get it to do the work for us!
    //
    return m_pOleAdviseHolder->Advise(pAdviseSink, pdwConnection);
}

//=--------------------------------------------------------------------------=
// COleControl::Unadvise    [IOleObject]
//=--------------------------------------------------------------------------=
// Deletes a previously established advisory connection.
//
// Parameters:
//    DWORD         - [in] connection cookie
//
// Output:
//    HRESULT       - S_OK, E_FAIL, OLE_E_NOCONNECTION
//
// Notes:
//
STDMETHODIMP COleControl::Unadvise
(
    DWORD dwConnection
)
{
    if (!m_pOleAdviseHolder) {
        FAIL("Somebody called Unadvise on IOleObject without calling Advise!");
        CONNECT_E_NOCONNECTION;
    }

    return m_pOleAdviseHolder->Unadvise(dwConnection);
}

//=--------------------------------------------------------------------------=
// COleControl::EnumAdvise    [IOleObject]
//=--------------------------------------------------------------------------=
// Enumerates the advisory connections registered for an object, so a container
// can know what to release prior to closing down.
//
// Parameters:
//    IEnumSTATDATA **    - [out] where to put enumerator
//
// Output:
//    HRESULT             - S_OK, E_FAIL, E_NOTIMPL
//
// Notes:
//
STDMETHODIMP COleControl::EnumAdvise
(
    IEnumSTATDATA **ppEnumOut
)
{
    if (!m_pOleAdviseHolder) {
        FAIL("Somebody Called EnumAdvise without setting up any connections");
        *ppEnumOut = NULL;
        return E_FAIL;
    }

    return m_pOleAdviseHolder->EnumAdvise(ppEnumOut);
}

//=--------------------------------------------------------------------------=
// COleControl::GetMiscStatus    [IOleObject]
//=--------------------------------------------------------------------------=
// Returns a value indicating the status of an object at creation and loading.
//
// Parameters:
//    DWORD         - [in]  aspect desired
//    DWORD *       - [out] where to put the bits.
//
// Output:
//    HRESULT       - S_OK, OLE_S_USEREG, CO_E_CLASSNOTREG, CO_E_READREGDB
//
// Notes:
//
STDMETHODIMP COleControl::GetMiscStatus
(
    DWORD  dwAspect,
    DWORD *pdwStatus
)
{
    CHECK_POINTER(pdwStatus);

    if (dwAspect == DVASPECT_CONTENT) {
        *pdwStatus = OLEMISCFLAGSOFCONTROL(m_ObjectType);
        return S_OK;
    } else {
        return DV_E_DVASPECT;
    }

    // dead code
}

//=--------------------------------------------------------------------------=
// COleControl::SetColorScheme    [IOleObject]
//=--------------------------------------------------------------------------=
// Specifies the color palette that the object application should use when it
// edits the specified object.
//
// Parameters:
//    LOGPALETTE *     - [in] new palette
//
// Output:
//    HRESULT          - S_OK, E_NOTIMPL, OLE_E_PALETTE, OLE_E_NOTRUNNING
//
// Notes:
//    - we don't care.
//
STDMETHODIMP COleControl::SetColorScheme
(
    LOGPALETTE *pLogpal
)
{
    // OVERRIDE: control writers can use this if they want to
    //
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::GetWindow    [IOleWindow/IOleInPlaceObject]
//=--------------------------------------------------------------------------=
// Returns the window handle to one of the windows participating in in-place
// activation (frame, document, parent, or in-place object window).
//
// Parameters:
//    HWND *        - [out] where to return window handle.
//
// Output:
//    HRESULT       - S_OK, E_INVALIDARG, E_OUTOFMEMORY, E_UNEXPECTED, E_FAIL
//
// Notes:
//    - this routine has slightly different semantics for windowless controls
//
STDMETHODIMP COleControl::GetWindow
(
    HWND *phwnd
)
{
    // if we're windowles, then we want to return E_FAIL for this so hosts
    // know we're windowless
    //
    if (m_pInPlaceSiteWndless)
        return E_FAIL;

    // otherwise, just return our outer window.
    //
    *phwnd = GetOuterWindow();

    return (*phwnd) ? S_OK : E_UNEXPECTED;
}

//=--------------------------------------------------------------------------=
// COleControl::ContextSensitiveHelp    [IOleWindow/IOleInPlaceObject]
//=--------------------------------------------------------------------------=
// Determines whether context-sensitive help mode should be entered during an
// in-place activation session.
//
// Parameters:
//    BOOL            - [in] whether or not to enter help mode.
//
// Output:
//    HRESULT         - S_OK, E_INVALIDARG, E_OUTOFMEMORY, E_UNEXPECTED
//
// Notes:
//
STDMETHODIMP COleControl::ContextSensitiveHelp
(
    BOOL fEnterMode
)
{
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// COleControl::InPlaceActivate
//=--------------------------------------------------------------------------=
// activates the control, and depending on the verb, optionally ui activates
// it as well.
//
// Parameters:
//    LONG         - [in] the verb that caused us to activate
//
// Output:
//    HRESULT
//
// Notes:
//    - this is spaghetti code at it's worst.  effectively, we have to
//      be able to handle three types of site pointers -- IOleInPlaceSIte,
//      IOleInPlaceSiteEx, and IOleInPlaceSiteWindowless.  not terribly
//      pretty.
//
HRESULT COleControl::InPlaceActivate
(
    LONG lVerb
)
{
    BOOL f;
    SIZEL sizel;
    IOleInPlaceSiteEx *pIPSEx = NULL;
    HRESULT hr;
    BOOL    fNoRedraw = FALSE;

    // if we don't have a client site, then there's not much to do.
    //
    if (!m_pClientSite)
        return S_OK;

    // get an InPlace site pointer.
    //
    if (!GetInPlaceSite()) {

        // if they want windowless support, then we want IOleInPlaceSiteWindowless
        //
        if (FCONTROLISWINDOWLESS(m_ObjectType))
            m_pClientSite->QueryInterface(IID_IOleInPlaceSiteWindowless, (void **)&m_pInPlaceSiteWndless);

        // if we're not able to do windowless siting, then we'll just get an
        // IOleInPlaceSite pointer.
        //
        if (!m_pInPlaceSiteWndless) {
            hr = m_pClientSite->QueryInterface(IID_IOleInPlaceSite, (void **)&m_pInPlaceSite);
            RETURN_ON_FAILURE(hr);
        }
    }

    // now, we want an IOleInPlaceSiteEx pointer for windowless and flicker free
    // activation.  if we're windowless, we've already got it, else we need to
    // try and get it
    //
    if (m_pInPlaceSiteWndless) {
        pIPSEx = (IOleInPlaceSiteEx *)m_pInPlaceSiteWndless;
        pIPSEx->AddRef();
    } else
        m_pClientSite->QueryInterface(IID_IOleInPlaceSiteEx, (void **)&pIPSEx);

    // if we're not already active, go and do it.
    //
    if (!m_fInPlaceActive) {
        OLEINPLACEFRAMEINFO InPlaceFrameInfo;
        RECT rcPos, rcClip;

        // if we have a windowless site, see if we can go in-place windowless
        // active
        //
        hr = S_FALSE;
        if (m_pInPlaceSiteWndless) {
            hr = m_pInPlaceSiteWndless->CanWindowlessActivate();
            CLEANUP_ON_FAILURE(hr);

            // if they refused windowless, we'll try windowed
            //
            if (S_OK != hr) {
                RELEASE_OBJECT(m_pInPlaceSiteWndless);
                hr = m_pClientSite->QueryInterface(IID_IOleInPlaceSite, (void **)&m_pInPlaceSite);
                CLEANUP_ON_FAILURE(hr);
            }
        }

        // just try regular windowed in-place activation
        //
        if (hr != S_OK) {
            hr = m_pInPlaceSite->CanInPlaceActivate();
            if (hr != S_OK) {
                hr = (FAILED(hr)) ? E_FAIL : hr;
                goto CleanUp;
            }
        }

        // if we are here, then we have permission to go in-place active.
        // now, announce our intentions to actually go ahead and do this.
        //
        hr = (pIPSEx) ? pIPSEx->OnInPlaceActivateEx(&fNoRedraw, (m_pInPlaceSiteWndless) ? ACTIVATE_WINDOWLESS : 0)
                       : m_pInPlaceSite->OnInPlaceActivate();
        CLEANUP_ON_FAILURE(hr);

        // if we're here, we're ready to go in-place active.  we just need
        // to set up some flags, and then create the window [if we have
        // one]
        //
        m_fInPlaceActive = TRUE;

        // we need to get some information about our location in the parent
        // window, as well as some information about the parent
        //
        InPlaceFrameInfo.cb = sizeof(OLEINPLACEFRAMEINFO);
        hr = GetInPlaceSite()->GetWindow(&m_hwndParent);
        if (SUCCEEDED(hr))
            hr = GetInPlaceSite()->GetWindowContext(&m_pInPlaceFrame, &m_pInPlaceUIWindow, &rcPos, &rcClip, &InPlaceFrameInfo);
        CLEANUP_ON_FAILURE(hr);

        // make sure we'll display ourselves in the correct location with the correct size
        //
        sizel.cx = rcPos.right - rcPos.left;
        sizel.cy = rcPos.bottom - rcPos.top;
        f = OnSetExtent(&sizel);
        if (f) m_Size = sizel;
        SetObjectRects(&rcPos, &rcClip);

        // finally, create our window if we have to!
        //
        if (!m_pInPlaceSiteWndless) {
    
            SetInPlaceParent(m_hwndParent);

            // create the window, and display it.  die horribly if we couldnt'
            //
            if (!CreateInPlaceWindow(rcPos.left, rcPos.top, fNoRedraw)) {
                hr = E_FAIL;
                goto CleanUp;
            }
        }
    }

    // don't need this any more
    //
    RELEASE_OBJECT(pIPSEx);

    // if we're not inplace visible yet, do so now.
    //
    if (!m_fInPlaceVisible)
        SetInPlaceVisible(TRUE);

    // if we weren't asked to UIActivate, then we're done.
    //
    if (lVerb != OLEIVERB_PRIMARY && lVerb != OLEIVERB_UIACTIVATE)
        return S_OK;

    // if we're not already UI active, do sow now.
    //
    if (!m_fUIActive) {
        m_fUIActive = TRUE;

        // inform the container of our intent
        //
        GetInPlaceSite()->OnUIActivate();

        // take the focus  [which is what UI Activation is all about !]
        //
        SetFocus(TRUE);

        // set ourselves up in the host.
        //
        m_pInPlaceFrame->SetActiveObject((IOleInPlaceActiveObject *)this, NULL);
        if (m_pInPlaceUIWindow)
            m_pInPlaceUIWindow->SetActiveObject((IOleInPlaceActiveObject *)this, NULL);

        // we have to explicitly say we don't wany any border space.
        //
        m_pInPlaceFrame->SetBorderSpace(NULL);
        if (m_pInPlaceUIWindow)
            m_pInPlaceUIWindow->SetBorderSpace(NULL);
    }

    // be-de-be-de-be-de that's all folks!
    //
    return S_OK;

  CleanUp:
    // something catastrophic happened [or, at least something bad].
    // die a horrible fiery mangled painful death.
    //
    QUICK_RELEASE(pIPSEx);
    m_fInPlaceActive = FALSE;
    return hr;

}

//=--------------------------------------------------------------------------=
// COleControl::InPlaceDeactivate    [IOleInPlaceObject]
//=--------------------------------------------------------------------------=
// Deactivates an active in-place object and discards the object's undo state.
//
// Output:
//    HRESULT        - S_OK, E_UNEXPECTED
//
// Notes:
//
STDMETHODIMP COleControl::InPlaceDeactivate
(
    void
)
{
    // if we're not in-place active yet, then this is easy.
    //
    if (!m_fInPlaceActive)
        return S_OK;

    // transition from UIActive back to active
    //
    if (m_fUIActive)
        UIDeactivate();

    m_fInPlaceActive = FALSE;
    m_fInPlaceVisible = FALSE;

    // if we have a window, tell it to go away.
    //
    if (m_hwnd) {
        ASSERT(!m_pInPlaceSiteWndless, "internal state really messed up");

        // so our window proc doesn't crash.
        //
        BeforeDestroyWindow();
        SetWindowLongPtr(m_hwnd, GWLP_USERDATA, (LONG_PTR)0xFFFFFFFF);
        DestroyWindow(m_hwnd);
        m_hwnd = NULL;

        if (m_hwndReflect) {
            SetWindowLongPtr(m_hwndReflect, GWLP_USERDATA, 0);
            DestroyWindow(m_hwndReflect);
            m_hwndReflect = NULL;
        }
    }

    RELEASE_OBJECT(m_pInPlaceFrame);
    RELEASE_OBJECT(m_pInPlaceUIWindow);
    GetInPlaceSite()->OnInPlaceDeactivate();
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::UIDeactivate    [IOleInPlaceObject]
//=--------------------------------------------------------------------------=
// transitions us from UI Active to merely being active [visible]  for
// a control, this doesn't mean all that much.
//
// Output:
//    HRESULT         - S_OK, E_UNEXPECTED
//
// Notes:
//
STDMETHODIMP COleControl::UIDeactivate
(
    void
)
{
    // if we're not UIActive, not much to do.
    //
    if (!m_fUIActive)
        return S_OK;

    m_fUIActive = FALSE;

    // notify frame windows, if appropriate, that we're no longer ui-active.
    //
    if (m_pInPlaceUIWindow) m_pInPlaceUIWindow->SetActiveObject(NULL, NULL);
    m_pInPlaceFrame->SetActiveObject(NULL, NULL);

    // we don't need to explicitly release the focus here since somebody
    // else grabbing the focus is what is likely to cause us to get lose it
    //
    GetInPlaceSite()->OnUIDeactivate(FALSE);

    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::SetObjectRects    [IOleInPlaceObject]
//=--------------------------------------------------------------------------=
// Indicates how much of the control is visible.
//
// Parameters:
//    LPCRECT        - [in] position of the control.
//    LPCRECT        - [in] clipping rectangle for the control.
//
// Output:
//    HRESULT        - S_OK, E_INVALIDARG, E_OUTOFMEMORY, E_UNEXPECTED
//
// Notes:
//
STDMETHODIMP COleControl::SetObjectRects
(
    LPCRECT prcPos,
    LPCRECT prcClip
)
{
    BOOL fRemoveWindowRgn;

    // move our window to the new location and handle clipping. not applicable
    // for windowless controls, since the container will be responsible for all
    // clipping.
    //
    if (m_hwnd) {
        fRemoveWindowRgn = m_fUsingWindowRgn;
        if (prcClip) {
            // the container wants us to clip, so figure out if we really
            // need to
            //
            RECT rcIXect;
            if ( IntersectRect(&rcIXect, prcPos, prcClip) ) {
                if (!EqualRect(&rcIXect, prcPos)) {
                    OffsetRect(&rcIXect, -(prcPos->left), -(prcPos->top));

                    HRGN tempRgn = CreateRectRgnIndirect(&rcIXect);
                    SetWindowRgn(GetOuterWindow(), tempRgn, TRUE);

                    if (m_hRgn != NULL)
                       DeleteObject(m_hRgn);
                    m_hRgn = tempRgn;

                    m_fUsingWindowRgn = TRUE;
                    fRemoveWindowRgn  = FALSE;
                }
            }
        }

        if (fRemoveWindowRgn) {
            SetWindowRgn(GetOuterWindow(), NULL, TRUE);
            if (m_hRgn != NULL)
            {
               DeleteObject(m_hRgn);
               m_hRgn = NULL;
            }
            m_fUsingWindowRgn = FALSE;
        }

        // set our control's location, but don't change it's size at all
        // [people for whom zooming is important should set that up here]
        //
        DWORD dwFlag;
        OnSetObjectRectsChangingWindowPos(&dwFlag);

        int cx, cy;
        cx = prcPos->right - prcPos->left;
        cy = prcPos->bottom - prcPos->top;
        SetWindowPos(GetOuterWindow(), NULL, prcPos->left, prcPos->top, cx, cy, dwFlag | SWP_NOZORDER | SWP_NOACTIVATE);
    }

    // save out our current location.  windowless controls want this more
    // that windowed ones do, but everybody can have it just in case
    //
    m_rcLocation = *prcPos;

    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::ReactivateAndUndo    [IOleInPlaceObject]
//=--------------------------------------------------------------------------=
// Reactivates a previously deactivated object, undoing the last state of the object.
//
// Output:
//    HRESULT        - S_OK, E_NOTUNDOABLE
//
// Notes:
//
STDMETHODIMP COleControl::ReactivateAndUndo
(
    void
)
{
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// COleControl::OnWindowMessage    [IOleInPlaceObjectWindowless]
//=--------------------------------------------------------------------------=
// this method lets the container dispatch a message to a windowless OLE
// object.
//
// Parameters:
//    UINT                - [in]  the message
//    WPARAM              - [in]  the messages wparam
//    LPARAM              - [in]  duh.
//    LRESULT *           - [out] the output value
//
// Output:
//    HRESULT             - S_OK
//
// Notes:
//    - people should call m_pInPlaceSiteWndless->OnDefWindowMessage [control
//      writers should just call OcxDefWindowProc(msg, wparam, lparam)];
//
STDMETHODIMP COleControl::OnWindowMessage
(
    UINT     msg,
    WPARAM   wParam,
    LPARAM   lParam,
    LRESULT *plResult
)
{
    // little bit of pre-processing -- we need to handle some cases here
    // before passing the messages on
    //
    switch (msg) {
        // make sure our UI Activation correctly matches the focus
        //
        case WM_KILLFOCUS:
        case WM_SETFOCUS:
            // give the control site focus notification
            //
            if (m_fInPlaceActive && m_pControlSite)
                m_pControlSite->OnFocus(msg == WM_SETFOCUS);
            break;
    }

    // just pass it to the control's window proc.
    //
    *plResult = WindowProc(msg, wParam, lParam);
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::GetDropTarget    [IOleInPlaceObjectWindowless]
//=--------------------------------------------------------------------------=
// this method returns a pointer to the objects IDropTarget interface.  since
// they do not have a window, windowless objects cannot register an IDropTarget
// interface.
//
// Parameters:
//    IDropTarget **        - [out]
//
// Output:
//    HRESULT               - S_OK, E_NOTIMPL
//
// Notes:
//
STDMETHODIMP COleControl::GetDropTarget
(
    IDropTarget **ppDropTarget
)
{
    // OVERRIDE: if you want to do drag and drop and you're windowless,
    // override me.
    //
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// COleControl::TranslateAccelerator    [IOleInPlaceActiveObject]
//=--------------------------------------------------------------------------=
// Processes menu accelerator-key messages from the container's message queue.
//
// Parameters:
//    LPMSG            - [in] the message that has the special key in it.
//
// Output:
//    HRESULT          - S_OK, S_FALSE, E_UNEXPECTED
//
// Notes:
//
STDMETHODIMP COleControl::TranslateAccelerator
(
    LPMSG    pmsg
)
{
    // see if we want it or not.
    //
    if (OnSpecialKey(pmsg))
        return S_OK;

    // if not, then we want to forward it back to the site for further processing
    //
    if (m_pControlSite)
        return m_pControlSite->TranslateAccelerator(pmsg, _SpecialKeyState());

    // we didn't want it.
    //
    return S_FALSE;
}

//=--------------------------------------------------------------------------=
// COleControl::OnFrameWindowActivate    [IOleInPlaceActiveObject]
//=--------------------------------------------------------------------------=
// Notifies the control when the container's top-level frame window is
// activated or deactivated.
//
// Parameters:
//    BOOL        - [in] state of containers top level window.
//
// Output:
//    HRESULT     - S_OK
//
// Notes:
//
STDMETHODIMP COleControl::OnFrameWindowActivate
(
    BOOL fActivate
)
{
    // we're supposed to go UI active in this case
    //
    return InPlaceActivate(OLEIVERB_UIACTIVATE);
}

//=--------------------------------------------------------------------------=
// COleControl::OnDocWindowActivate    [IOleInPlaceActiveObject]
//=--------------------------------------------------------------------------=
// Notifies the active control when the container's document window is
// activated or deactivated.
//
// Parameters:
//    BOOL            - state of mdi child window.
//
// Output:
//    HRESULT         - S_OK
//
// Notes:
//
STDMETHODIMP COleControl::OnDocWindowActivate
(
    BOOL fActivate
)
{
    // we're supposed to go UI active in this case
    //
    return InPlaceActivate(OLEIVERB_UIACTIVATE);
}

//=--------------------------------------------------------------------------=
// COleControl::ResizeBorder    [IOleInPlaceActiveObject]
//=--------------------------------------------------------------------------=
// Alerts the control that it needs to resize its border space.
//
// Parameters:
//    LPCRECT               - [in] new outer rectangle for border space
//    IOleInPlaceUIWindow * - [in] the document or frame who's border has changed
//    BOOL                  - [in] true if it was the fram window taht called.
//
// Output:
//    HRESULT               - S_OK
//
// Notes:
//
STDMETHODIMP COleControl::ResizeBorder
(
    LPCRECT              prcBorder,
    IOleInPlaceUIWindow *pInPlaceUIWindow,
    BOOL                 fFrame
)
{
    // this is largely uninteresting to us, since we have no border.
    //
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::EnableModeless    [IOleInPlaceActiveObject]
//=--------------------------------------------------------------------------=
// Enables or disables modeless dialog boxes when the container creates or
// destroys a modal dialog box.
//
// Parameters:
//    BOOL            - [in] enable or disable modeless dialogs.
//
// Output:
//    HRESULT         - S_OK
//
// Notes:
//
STDMETHODIMP COleControl::EnableModeless
(
    BOOL fEnable
)
{
    // phenomenally uninteresting
    //
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::GetClassInfo    [IProvideClassInfo]
//=--------------------------------------------------------------------------=
// returns the TypeInfo for the control's coclass.
//
// Parameters:
//    ITypeInfo **        - [out]
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::GetClassInfo
(
    ITypeInfo **ppTypeInfo
)
{
    ITypeLib *pTypeLib;
    HRESULT hr;

    CHECK_POINTER(ppTypeInfo);
    *ppTypeInfo = NULL;

    // go and get our type library.
    // CONSIDER: - go to the same sorta scheme that we use for TypeInfo caching.
    // CONSIDER: - consider trying to register our typelib if this fails.
    //
    hr = LoadRegTypeLib(*g_pLibid, (USHORT)VERSIONOFOBJECT(m_ObjectType), 0,
                        LANGIDFROMLCID(g_lcidLocale), &pTypeLib);
    RETURN_ON_FAILURE(hr);

    // got the typelib.  get typeinfo for our coclass.
    //
    hr = pTypeLib->GetTypeInfoOfGuid((REFIID)CLSIDOFOBJECT(m_ObjectType), ppTypeInfo);
    pTypeLib->Release();
    RETURN_ON_FAILURE(hr);

    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::ViewChange    [callable]
//=--------------------------------------------------------------------------=
// called whenever the view of the object has changed.
//
// Notes:
//
void COleControl::ViewChanged
(
    void
)
{
    // send the view change notification to anybody listening.
    //
    if (m_pViewAdviseSink) {
        m_pViewAdviseSink->OnViewChange(DVASPECT_CONTENT, -1);

        // if they only asked to be advised once, kill the connection
        //
        if (m_fViewAdviseOnlyOnce)
            SetAdvise(DVASPECT_CONTENT, 0, NULL);
    }
}

//=--------------------------------------------------------------------------=
// COleControl::SetInPlaceVisible    [helper]
//=--------------------------------------------------------------------------=
// controls the visibility of the control window.
//
// Parameters:
//    BOOL        - TRUE shows FALSE hides.
//
// Notes:
//
void COleControl::SetInPlaceVisible
(
    BOOL fShow
)
{
    BOOL fVisible;

    m_fInPlaceVisible = fShow;

    // don't do anything if we don't have a window.  otherwise, set it
    //
    if (m_hwnd) {
        fVisible = ((GetWindowLong(GetOuterWindow(), GWL_STYLE) & WS_VISIBLE) != 0);

        if (fVisible && !fShow)
            ShowWindow(GetOuterWindow(), SW_HIDE);
        else if (!fVisible && fShow)
            ShowWindow(GetOuterWindow(), SW_SHOWNA);
    }
}

//=--------------------------------------------------------------------------=
// COleControl::AmbientPropertyChanged    [overridable]
//=--------------------------------------------------------------------------=
// a method that derived controls can override to do whatever they want.
// we don't particularily care about this event.
//
// Parameters:
//    DISPID            - [in] dispid of prop that changed.
//
// Notes:
//
void COleControl::AmbientPropertyChanged
(
    DISPID dispid
)
{
    // do nothing
}

//=--------------------------------------------------------------------------=
// COleControl::DoCustomVerb    [overridable]
//=--------------------------------------------------------------------------=
// we were asked to execute a verb we don't know about right away.  see if
// it's a verb that the dervied-control defined.
//
// Parameters:
//    LONG            - [in] the verb.
//
// Output:
//    HRESULT         - S_OK, OLEOBJ_S_INVALIDVERB
//
// Notes:
//
HRESULT COleControl::DoCustomVerb
(
    LONG    lVerb
)
{
    return OLEOBJ_S_INVALIDVERB;
}

//=--------------------------------------------------------------------------=
// COleControl::OnSetExtent    [overridable]
//=--------------------------------------------------------------------------=
// let the user do something in the resize, if they care.
//
// Parameters:
//    SIZEL *        - [in] new values.
//
// Output:
//    BOOL           - FALSE means keep current size
//
// Notes:
//
BOOL COleControl::OnSetExtent
(
    const SIZEL *pSizeL
)
{
    return TRUE;
}

//=--------------------------------------------------------------------------=
// COleControl::OnSpecialKey    [overridable]
//=--------------------------------------------------------------------------=
// allows controls to handle special keys such as arrows, CTRL+, etc ...
//
// Parameters:
//    LPMSG        - [in] the special key msg.
//
// Output:
//    BOOL         - TRUE we processed it, FALSE we didn't.
//
// Notes:
//
BOOL COleControl::OnSpecialKey
(
    LPMSG pmsg
)
{
    // do nothing.
    //
    return FALSE;
}

//=--------------------------------------------------------------------------=
// COleControl::ModalDialog    [callable, utility]
//=--------------------------------------------------------------------------=
// should be called when the control is about to show and hide a modal dialog.
//
// Parameters:
//    BOOL        - [in] true means showing a modal dialog, false means done
//
// Notes:
//
void COleControl::ModalDialog
(
    BOOL fShow
)
{
    // notify the container of our intention to show a modal dialog...
    //
    if (m_pInPlaceFrame)
        m_pInPlaceFrame->EnableModeless(!fShow);
}

//=--------------------------------------------------------------------------=
// COleControl::BeforeDestroyWindow    [overridable]
//=--------------------------------------------------------------------------=
// called just before we destroy a window.  gives the user the opportunity to
// save information out, especially if they're a subclassed control, and this
// is an interesting thing to do.
//
// Notes:
//
void COleControl::BeforeDestroyWindow
(
    void
)
{
    // fweeee
}

//=--------------------------------------------------------------------------=
// COleControl::OnSetObjectRectsChangingWIndowPos    [overridable]
//=--------------------------------------------------------------------------=
// called just before we perform a SetWindowPos in the SetObjectRects
// function. gives a control the opportunity to change the flags.
//
// Notes:
//
void COleControl::OnSetObjectRectsChangingWindowPos(DWORD *dwFlag)
{
    *dwFlag = 0;
}

void COleControl::OnVerb(LONG lVerb)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\basectl\classf.h ===
//=--------------------------------------------------------------------------=
// ClassF.H
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// header for the ClassFactory Object.  we support IClassFactory and 
// IClassFactory2
//
#ifndef _CLASSF_H_

#include "olectl.h"

class CClassFactory : public IClassFactory2 {

  public:
    // IUnknown methods
    //
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObjOut);
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);

    // IClassFactory methods
    //
    STDMETHOD(CreateInstance)(IUnknown *pUnkOuter, REFIID riid, void **ppbObjOut);
    STDMETHOD(LockServer)(BOOL fLock);

    // IClassFactory2 methods
    //
    STDMETHOD(GetLicInfo)(LICINFO *pLicInfo);
    STDMETHOD(RequestLicKey)(DWORD dwReserved, BSTR *pbstrKey);
    STDMETHOD(CreateInstanceLic)(IUnknown *pUnkOuter, IUnknown *pUnkReserved, REFIID riid, BSTR bstrKey, void **ppvObjOut);

    CClassFactory(int iIndex);
    ~CClassFactory();

  private:
    ULONG m_cRefs;
    int   m_iIndex;
};


// global variable for Locks on our DLL
//
extern LONG g_cLocks;

#define _CLASSF_H_
#endif // _CLASSF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\basectl\ctlhelp.h ===
//=--------------------------------------------------------------------------=
// CtlHelp.H
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// routines to help out our implementation of COleControl.
//

#ifndef _CTLHELP_H_

//=--------------------------------------------------------------------------=
// these two tables are used to get information on sizes about data types
// the first is used mostly in persistence, while the second is used for
// events
//
extern const BYTE g_rgcbDataTypeSize [];
extern const BYTE g_rgcbPromotedDataTypeSize [];



//=--------------------------------------------------------------------------=
// misc functions
//
short       _SpecialKeyState(void);
void WINAPI CopyAndAddRefObject(void *, const void *, DWORD);
void WINAPI CopyOleVerb(void *, const void *, DWORD);

HWND        CreateReflectWindow(BOOL fVisible, HWND hwndParent, int, int, SIZEL *);
void        CleanupReflection();

//=--------------------------------------------------------------------------=
// little private guid we'll use to help identify our objects
// {00D97180-FCF7-11ce-A09E-00AA0062BE57}
//
#define Data1_IControlPrv	0xd97180

DEFINE_GUID(IID_IControlPrv, 0xd97180, 0xfcf7, 0x11ce, 0xa0, 0x9e, 0x0, 0xaa, 0x0, 0x62, 0xbe, 0x57);

#define _CTLHELP_H_
#endif // _CTLHELP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\basectl\ctlocx96.cpp ===
//=--------------------------------------------------------------------------=
// CtlOcx96.H
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// implementation of the OCX 96 interfaces that don't quite fit in to the
// categories covered by embedding, persistence, and ctlmisc.cpp
//
//
#include "IPServer.H"

#include "CtrlObj.H"
#include "Globals.H"


//=--------------------------------------------------------------------------=
// COleControl::GetActivationPolicy    [IPointerInactive]
//=--------------------------------------------------------------------------=
// returns the present activation policy for this object.  for non-subclassed
// windows controls, this means we can put off in-place activation for quite
// a while.
//
// Parameters:
//    DWORD *        - [out] activation policy
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::GetActivationPolicy
(
    DWORD *pdwPolicy
)
{
    CHECK_POINTER(pdwPolicy);

    // just get the policy in the global structure describing this control.
    //
    *pdwPolicy = ACTIVATIONPOLICYOFCONTROL(m_ObjectType);
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::OnInactiveMouseMove    [IPointerInactive]
//=--------------------------------------------------------------------------=
// indicates to an inactive oobject that the mouse pointer has moved over the
// object.
//
// Parameters:
//    LPCRECT            - [in]
//    long               - [in]
//    long               - [in]
//    DWORD              - [in]
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::OnInactiveMouseMove
(
    LPCRECT pRectBounds,
    long    x,
    long    y,
    DWORD   dwMouseMsg
)
{
    // OVERRIDE: end control writers should just override this if they want
    // to have a control that is never in-place active.
    //
    return S_OK;
}
    
//=--------------------------------------------------------------------------=
// COleControl::OnInactiveSetCursor    [IPointerInactive]
//=--------------------------------------------------------------------------=
// called by the container for the inactive object under the mouse pointer on
// recept of a WM_SETCURSOR message.
//
// Parameters:
//    LPCRECT            - [in]
//    long               - [in]
//    long               - [in]
//    DWORD              - [in]
//    BOOL               - [in]
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::OnInactiveSetCursor
(
    LPCRECT pRectBounds,
    long    x,
    long    y,
    DWORD   dwMouseMsg,
    BOOL    fSetAlways
)
{
    // OVERRIDE:  just get the user to override this if they want to never
    // be activated
    //
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::QuickActivate    [IQuickActivate]
//=--------------------------------------------------------------------------=
// allows the container to activate the control.
//
// Parameters:
//    QACONTAINER *        - [in]  info about the container
//    QACONTROL *          - [out] info about the control
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::QuickActivate
(
    QACONTAINER *pContainer,
    QACONTROL *pControl
)
{
    HRESULT hr;
    DWORD   dw;

    // we need these guys.
    //
    if (!pContainer) return E_UNEXPECTED;
    if (!pControl) return E_UNEXPECTED;

    // start grabbing things from the QACONTAINER structure and apply them
    // as relevant
    //
    // if (pContainer->cbSize < sizeof(QACONTAINER)) return E_UNEXPECTED;
    // if (pControl->cbSize < sizeof(QACONTROL)) return E_UNEXPECTED;

    // save out the client site, of course.
    //
    if (pContainer->pClientSite) {
        hr = SetClientSite(pContainer->pClientSite);
        RETURN_ON_FAILURE(hr);
    }

    // if the lcid is not LANG_NEUTRAL, score!
    //
    if (pContainer->lcid) {
        g_lcidLocale = pContainer->lcid;
        g_fHaveLocale = TRUE;
    }

    // pay attention to some ambients
    //
    if (pContainer->dwAmbientFlags & QACONTAINER_MESSAGEREFLECT) {
        m_fHostReflects = TRUE;
        m_fCheckedReflecting = TRUE;
    }

    // hook up some notifications.  first property notifications.
    //
    if (pContainer->pPropertyNotifySink) {
        pContainer->pPropertyNotifySink->AddRef();
        hr = m_cpPropNotify.AddSink((void *)pContainer->pPropertyNotifySink, &pControl->dwPropNotifyCookie);
        if (FAILED(hr)) {
            pContainer->pPropertyNotifySink->Release();
            return hr;
        }
    }

    // then the event sink.
    //
    if (pContainer->pUnkEventSink) {
        hr = m_cpEvents.Advise(pContainer->pUnkEventSink, &pControl->dwEventCookie);
        if (FAILED(hr)) {
            pContainer->pUnkEventSink->Release();
            return hr;
        }
    }

    // finally, the advise sink.
    //
    if (pContainer->pAdviseSink) {
        // don't need to pass the cookie back since there can only be one
        // person advising at a time.
        //
        hr = Advise(pContainer->pAdviseSink, &dw);
        RETURN_ON_FAILURE(hr);
    }

    // set up a few things in the QACONTROL structure.  we're opaque by default
    //
    pControl->dwMiscStatus = OLEMISCFLAGSOFCONTROL(m_ObjectType);
    pControl->dwViewStatus = FCONTROLISOPAQUE(m_ObjectType) ? VIEWSTATUS_OPAQUE : 0;
    pControl->dwPointerActivationPolicy = ACTIVATIONPOLICYOFCONTROL(m_ObjectType);

    // that's pretty much all we're interested in.  we will, however, pass on the
    // rest of the things to the end control writer and see if they want to do
    // anything with them. they shouldn't touch any of the above except for the
    // ambients.
    //
    return OnQuickActivate(pContainer, &(pControl->dwViewStatus));
}

//=--------------------------------------------------------------------------=
// COleControl::SetContentExtent    [IQuickActivate]
//=--------------------------------------------------------------------------=
// the container calls this to set the content extent of the control.
//
// Parameters:
//    LPSIZEL            - [in] the size of the content extent
//
// Output:
//    HRESULT            - S_OK, or E_FAIL for fixed size control
//
// Notes:
//
STDMETHODIMP COleControl::SetContentExtent
(
    LPSIZEL pSize
)
{
    return SetExtent(DVASPECT_CONTENT, pSize);
}

//=--------------------------------------------------------------------------=
// COleControl::GetContentExtent    [IQuickActivate]
//=--------------------------------------------------------------------------=
// the container calls this to get the content extent of the control
//
// Parameters:
//    LPSIZEL        - [out] returns current size
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::GetContentExtent
(
    LPSIZEL pSize
)
{
    return GetExtent(DVASPECT_CONTENT, pSize);
}

//=--------------------------------------------------------------------------=
// COleControl::OnQuickActivate    [overridable]
//=--------------------------------------------------------------------------=
// not all the of the members of the QACONTAINER need to be consumed by the
// framework, but are, at least, extremely interesting.  thus, we will pass
// on the struture to the end control writer, and let them consume these.
//
// Parameters:
//    QACONTAINER *            - [in]  contains additional information
//    DWORD *                  - [out] put ViewStatus flags here.
//
// Output:
//    HRESULT
//
// Notes:
//    - control writers should only look at/consume:
//        a. dwAmbientFlags
//        b. colorFore/colorBack
//        c. pFont
//        d. pUndoMgr
//        e. dwAppearance
//        f. hpal
//
//    - all the others are set up the for the user by the framework.
//    - control writers should set up the pdwViewStatus with flags as per
//      IViewObjectEx::GetViewStatus.  if you don't know what this is or don't
//      care, then don't touch.
//
HRESULT COleControl::OnQuickActivate
(
    QACONTAINER *pContainer,
    DWORD       *pdwViewStatus
)
{
    // by default, nuthin much to do!
    //
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\basectl\ctlhelp.cpp ===
//=--------------------------------------------------------------------------=
// CtlHelp.Cpp
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// helper routines for our COleControl implementation
//

#include "IPServer.H"
#include "CtrlObj.H"

#include "CtlHelp.H"
#include "Util.H"
#include <windows.h>

// for ASSERT and FAIL
//
SZTHISFILE

//=--------------------------------------------------------------------------=
// this is used by the window reflection code.
//
extern BYTE g_fRegisteredReflect;
extern char g_szReflectClassName [];


// define this here, since it's the only guid we really need to define in the
// framework -- the user control defines all other interesting guids.
//
static const GUID IID_IControlPrv =
{ 0xd97180, 0xfcf7, 0x11ce, { 0xa0, 0x9e, 0x0, 0xaa, 0x0, 0x62, 0xbe, 0x57 } };


// this table is used for copying data around, and persisting properties.
// basically, it contains the size of a given data type
//
const BYTE g_rgcbDataTypeSize[] = {
    0,                      // VT_EMPTY= 0,
    0,                      // VT_NULL= 1,
    sizeof(short),          // VT_I2= 2,
    sizeof(long),           // VT_I4 = 3,
    sizeof(float),          // VT_R4  = 4,
    sizeof(double),         // VT_R8= 5,
    sizeof(CURRENCY),       // VT_CY= 6,
    sizeof(DATE),           // VT_DATE = 7,
    sizeof(BSTR),           // VT_BSTR = 8,
    sizeof(IDispatch *),    // VT_DISPATCH    = 9,
    sizeof(SCODE),          // VT_ERROR    = 10,
    sizeof(VARIANT_BOOL),   // VT_BOOL    = 11,
    sizeof(VARIANT),        // VT_VARIANT= 12,
    sizeof(IUnknown *),     // VT_UNKNOWN= 13,
};

const BYTE g_rgcbPromotedDataTypeSize[] = {
    0,                      // VT_EMPTY= 0,
    0,                      // VT_NULL= 1,
    sizeof(int ),           // VT_I2= 2,
    sizeof(long),           // VT_I4 = 3,
    sizeof(double),         // VT_R4  = 4,
    sizeof(double),         // VT_R8= 5,
    sizeof(CURRENCY),       // VT_CY= 6,
    sizeof(DATE),           // VT_DATE = 7,
    sizeof(BSTR),           // VT_BSTR = 8,
    sizeof(IDispatch *),    // VT_DISPATCH    = 9,
    sizeof(SCODE),          // VT_ERROR    = 10,
    sizeof(int),            // VT_BOOL    = 11,
    sizeof(VARIANT),        // VT_VARIANT= 12,
    sizeof(IUnknown *),     // VT_UNKNOWN= 13,
};

//=--------------------------------------------------------------------------=
// _SpecialKeyState
//=--------------------------------------------------------------------------=
// returns a short with some information on which of the SHIFT, ALT, and CTRL
// keys are set.
//
// Output:
//    short        - bit 0 is shift, bit 1 is ctrl, bit 2 is ALT.
//
// Notes:
//
short _SpecialKeyState()
{
    // don't appear to be able to reduce number of calls to GetKeyState
    //
    BOOL bShift = (GetKeyState(VK_SHIFT) < 0);
    BOOL bCtrl  = (GetKeyState(VK_CONTROL) < 0);
    BOOL bAlt   = (GetKeyState(VK_MENU) < 0);

    return (short)(bShift + (bCtrl << 1) + (bAlt << 2));
}


//=--------------------------------------------------------------------------=
// CopyAndAddRefObject
//=--------------------------------------------------------------------------=
// copies an object pointer, and then addref's the object.
//
// Parameters:
//    void *        - [in] dest.
//    const void *  - [in] src
//    DWORD         - [in] size, ignored, since it's always 4
//
// Notes:
//
void WINAPI CopyAndAddRefObject
(
    void       *pDest,
    const void *pSource,
    DWORD       dwSize
)
{
    ASSERT(pDest && pSource, "Bogus Pointer(s) passed into CopyAndAddRefObject!!!!");

    *((IUnknown **)pDest) = *((IUnknown **)pSource);
    ADDREF_OBJECT(*((IUnknown **)pDest));

    return;
}

//=--------------------------------------------------------------------------=
// CopyOleVerb    [helper]
//=--------------------------------------------------------------------------=
// copies an OLEVERB structure.  used in CStandardEnum
//
// Parameters:
//    void *        - [out] where to copy to
//    const void *  - [in]  where to copy from
//    DWORD         - [in]  bytes to copy
//
// Notes:
//
void WINAPI CopyOleVerb
(
    void       *pvDest,
    const void *pvSrc,
    DWORD       cbCopy
)
{
    VERBINFO * pVerbDest = (VERBINFO *) pvDest;
    const VERBINFO * pVerbSrc = (const VERBINFO *) pvSrc;

    *pVerbDest = *pVerbSrc;
    ((OLEVERB *)pVerbDest)->lpszVerbName = OLESTRFROMRESID((WORD)((VERBINFO *)pvSrc)->idVerbName);
}

//=--------------------------------------------------------------------------=
// ControlFromUnknown    [helper, callable]
//=--------------------------------------------------------------------------=
// given an unknown, get the COleControl pointer for it.
//
// Parameters:
//    IUnknown *        - [in]
//
// Output:
//    HRESULT
//
// Notes:
//
COleControl *ControlFromUnknown
(
    IUnknown *pUnk
)
{
    COleControl *pCtl = NULL;

    if (!pUnk) return NULL;
    pUnk->QueryInterface(IID_IControlPrv, (void **)&pCtl);

    return pCtl;
}

//=--------------------------------------------------------------------------=
// CreateReflectWindow    [blech]
//=--------------------------------------------------------------------------=
// unfortunately, in certain cases, we have to create two windows, one of
// which exists strictly to reflect messages on to the control.
// Fortunately, the number of hosts which require this is quite small.
//
// Parameters:
//    BOOL        - [in] should it be created visible?
//    HWND        - [in] parent window
//    int         - [in] x pos
//    int         - [in] y pos
//    SIZEL *     - [in] size
//
// Output:
//    HWND        - reflecting hwnd or NULL if it failed.
//
// Notes:
//
HWND CreateReflectWindow
(
    BOOL   fVisible,
    HWND   hwndParent,
    int    x,
    int    y,
    SIZEL *pSize
)
{
    WNDCLASS wndclass;

    // first thing to do is register the window class.  crit sect this
    // so we don't have to move it into the control
    //
    EnterCriticalSection(&g_CriticalSection);
    if (!g_fRegisteredReflect) {

        memset(&wndclass, 0, sizeof(wndclass));
        wndclass.lpfnWndProc = COleControl::ReflectWindowProc;
        wndclass.hInstance   = g_hInstance;
        wndclass.lpszClassName = g_szReflectClassName;

        if (!RegisterClass(&wndclass)) {
            FAIL("Couldn't Register Parking Window Class!");
            LeaveCriticalSection(&g_CriticalSection);
            return NULL;
        }
        g_fRegisteredReflect = TRUE;
    }

    LeaveCriticalSection(&g_CriticalSection);

    // go and create the window.
    //
    return CreateWindowEx(0, g_szReflectClassName, NULL,
                          WS_CHILD | WS_CLIPSIBLINGS |((fVisible) ? WS_VISIBLE : 0),
                          x, y, pSize->cx, pSize->cy,
                          hwndParent,
                          NULL, g_hInstance, NULL);
}

//=--------------------------------------------------------------------------=
// in case the user doesn't want our default window proc, we support
// letting them specify one themselves. this is defined in their main ipserver
// file.
//
extern WNDPROC g_ParkingWindowProc;

//=--------------------------------------------------------------------------=
// GetParkingWindow
//=--------------------------------------------------------------------------=
// creates the global parking window that we'll use to parent things, or
// returns the already existing one
//
// Output:
//    HWND                - our parking window
//
// Notes:
//
HWND GetParkingWindow
(
    void
)
{
    WNDCLASS wndclass;

    // crit sect this creation for apartment threading support.
    //
    EnterCriticalSection(&g_CriticalSection);
    if (g_hwndParking)
        goto CleanUp;

    ZeroMemory(&wndclass, sizeof(wndclass));
    wndclass.lpfnWndProc = (g_ParkingWindowProc) ? g_ParkingWindowProc : DefWindowProc;
    wndclass.hInstance   = g_hInstance;
    wndclass.lpszClassName = "CtlFrameWork_Parking";

    if (!RegisterClass(&wndclass)) {
        FAIL("Couldn't Register Parking Window Class!");
        goto CleanUp;
    }

    g_hwndParking = CreateWindow("CtlFrameWork_Parking", NULL, WS_POPUP, 0, 0, 0, 0, NULL, NULL, g_hInstance, NULL);
    if (g_hwndParking != NULL)
       ++g_cLocks;

    ASSERT(g_hwndParking, "Couldn't Create Global parking window!!");


  CleanUp:
    LeaveCriticalSection(&g_CriticalSection);
    return g_hwndParking;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\basectl\ctlpch.cpp ===
#include "ipserver.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\basectl\ctlpsst.cpp ===
//=--------------------------------------------------------------------------=
// CtlPsst.Cpp
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// implementation of persistence interfaces for COleControl.
//
#include "IPServer.H"
#include "CtrlObj.H"

#include "CtlHelp.H"
#include "Util.H"

// this is the name of the stream we'll save our ole controls to.
//
const WCHAR wszCtlSaveStream [] = L"CONTROLSAVESTREAM";

// for ASSERT and FAIL
//
SZTHISFILE

//=--------------------------------------------------------------------------=
// to help with out stream save implementation ...
//
#define STREAMHDR_SIGNATURE 0x12344321  // Signature to identify our format (avoid crashes!)
#define IPROP_END 0xFF                  // Marker at end of property list
#define MAXAUTOBUF 3800                 // Best if < 1 page.

typedef struct tagSTREAMHDR {

    DWORD  dwSignature;     // Signature.
    size_t cbWritten;       // Number of bytes written

} STREAMHDR;

//=--------------------------------------------------------------------------=
// COleControl persistence interfaces
//=--------------------------------------------------------------------------=


//=--------------------------------------------------------------------------=
// COleControl::Load    [IPersistPropertyBag]
//=--------------------------------------------------------------------------=
// IPersistPropertyBag.  we've got a property bag, so let's load our properties
// from it.
//
// Parameters:
//    IPropertyBag *      - [in] pbag from which to read props.
//    IErrorLog *         - [in] error log to write to
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::Load
(
    IPropertyBag *pPropertyBag,
    IErrorLog    *pErrorLog
)
{
    HRESULT hr;

    // load in our standard state first.  nothing serious here ... currently,
    // we've just got two properties, for cx and cy.
    //
    hr = LoadStandardState(pPropertyBag, pErrorLog);
    RETURN_ON_FAILURE(hr);

    // now call the user text load function, and get them to load in whatever
    // they're interested in.
    //
    hr = LoadTextState(pPropertyBag, pErrorLog);

    return hr;
}

//=--------------------------------------------------------------------------=
// COleControl::Save    [IPersistPropertyBag]
//=--------------------------------------------------------------------------=
// given a property bag, save out all the relevant state information.
//
// Parameters:
//    IPropertyBag *        - [in] property to write to
//    BOOL                  - [in] do we clear the dirty bit?
//    BOOL                  - [in] do we write out default values anyhoo?
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::Save
(
    IPropertyBag *pPropertyBag,
    BOOL          fClearDirty,
    BOOL          fWriteDefault
)
{
    HRESULT hr;

    // save out standard state information
    //
    hr = SaveStandardState(pPropertyBag);
    RETURN_ON_FAILURE(hr);

    // now call the user function and get them to save out
    // all of their properties.
    //
    hr = SaveTextState(pPropertyBag, fWriteDefault);
    RETURN_ON_FAILURE(hr);

    // now clear the dirty flag and send out notification that we're
    // done.
    //
    if (fClearDirty)
        m_fDirty = FALSE;

    if (m_pOleAdviseHolder)
        m_pOleAdviseHolder->SendOnSave();

    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::GetClassID    [IPersistStreamInit]
//=--------------------------------------------------------------------------=
// returns the classid of this mamma
//
// Parameters:
//    CLSID *         - [out] where to put the clsid
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::GetClassID
(
    CLSID *pclsid
)
{
    CHECK_POINTER(pclsid);

    // copy the thing over
    //
    *pclsid = CLSIDOFOBJECT(m_ObjectType);
    return S_OK;
}


//=--------------------------------------------------------------------------=
// COleControl::IsDirty    [IPersistStreamInit]
//=--------------------------------------------------------------------------=
// asks if we're dirty or not.  duh.
//
// Output:
//    HRESULT        - S_OK: dirty, S_FALSE: not dirty
//
// Notes:
//
STDMETHODIMP COleControl::IsDirty
(
    void
)
{
    return (m_fDirty) ? S_OK : S_FALSE;
}

//=--------------------------------------------------------------------------=
// COleControl::InitNew    [IPersistStreamInit]
//=--------------------------------------------------------------------------=
// causes the control to intialize itself with a new bunch of state information
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::InitNew
(
    void
)
{
    BOOL f;

    // call the overridable function to do this work
    //
    f = InitializeNewState();
    return (f) ? S_OK : E_FAIL;
}

//=--------------------------------------------------------------------------=
// COleControl::GetSizeMax    [IPersistStreamInit]
//=--------------------------------------------------------------------------=
//
// Parameters:
//    ULARGE_INTEGER *    - [out]
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::GetSizeMax
(
    ULARGE_INTEGER *pulMaxSize
)
{
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// COleControl::Load    [IPersistStreamInit]
//=--------------------------------------------------------------------------=
// load from an IStream
//
// Parameters:
//    IStream *    - [in] stream from which to load
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::Load
(
    IStream *pStream
)
{
    HRESULT hr;

    // first thing to do is read in standard properties the user don't
    // persist themselves.
    //
    hr = LoadStandardState(pStream);
    RETURN_ON_FAILURE(hr);

    // load in the user properties.  this method is one they -have- to implement
    // themselves.
    //
    hr = LoadBinaryState(pStream);
    
    return hr;
}

//=--------------------------------------------------------------------------=
// COleControl::Save    [IPersistStreamInit]
//=--------------------------------------------------------------------------=
// saves out our state using streams
//
// Parameters:
//    IStream *        - [in]
//    BOOL             - [in] clear dirty bit?
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::Save
(
    IStream *pStream,
    BOOL     fClearDirty
)
{
    HRESULT hr;

    // use our helper routine that we share with the IStorage persistence
    // code.
    //
    hr = m_SaveToStream(pStream);
    RETURN_ON_FAILURE(hr);

    // clear out dirty flag [if appropriate] and notify that we're done
    // with save.
    //
    if (fClearDirty)
        m_fDirty = FALSE;
    if (m_pOleAdviseHolder)
        m_pOleAdviseHolder->SendOnSave();

    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::InitNew    [IPersistStorage]
//=--------------------------------------------------------------------------=
// ipersiststorage version of this.  fweee
//
// Parameters:
//    IStorage *    - [in] we don't use this
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::InitNew
(
    IStorage *pStorage
)
{
    // we already have an implementation of this [for IPersistStreamInit]
    //
    return InitNew();
}

//=--------------------------------------------------------------------------=
// COleControl::Load    [IPersistStorage]
//=--------------------------------------------------------------------------=
// Ipersiststorage version of this
//
// Parameters:
//    IStorage *    - [in] DUH.
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::Load(IStorage *pStorage)
{
    IStream *pStream;
    HRESULT  hr;

    // we're going to use IPersistStream::Load from the CONTENTS stream.
    //
    hr = pStorage->OpenStream(wszCtlSaveStream, 0, STGM_READ | STGM_SHARE_EXCLUSIVE, 0, &pStream);
    RETURN_ON_FAILURE(hr);

    // IPersistStreamInit::Load
    //
    hr = Load(pStream);
    pStream->Release();
    return hr;
}

//=--------------------------------------------------------------------------=
// COleControl::Save    [IPersistStorage]
//=--------------------------------------------------------------------------=
// save into the contents stream of the given storage object.
//
// Parameters:
//    IStorage *        - [in] 10 points if you figure it out
//    BOOL              - [in] is the storage the same as the load storage?
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::Save
(
    IStorage *pStorage,
    BOOL      fSameAsLoad
)
{
    IStream *pStream;
    HRESULT  hr;

    // we're just going to save out to the CONTENTES stream.
    //
    hr = pStorage->CreateStream(wszCtlSaveStream, STGM_WRITE | STGM_SHARE_EXCLUSIVE | STGM_CREATE,
                                0, 0, &pStream);
    RETURN_ON_FAILURE(hr);

    // use our helper routine.
    //
    hr = m_SaveToStream(pStream);
    m_fSaveSucceeded = (FAILED(hr)) ? FALSE : TRUE;
    pStream->Release();
    return hr;
}

//=--------------------------------------------------------------------------=
// COleControl::SaveCompleted    [IPersistStorage]
//=--------------------------------------------------------------------------=
// lets us clear out our flags.
//
// Parameters:
//    IStorage *    - ignored
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::SaveCompleted
(
    IStorage *pStorageNew
)
{
    // if our save succeeded, then we can do our post save work.
    //
    if (m_fSaveSucceeded) {
        m_fDirty = FALSE;
        if (m_pOleAdviseHolder)
            m_pOleAdviseHolder->SendOnSave();
    }

    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::HandsOffStorage    [IPersistStorage]
//=--------------------------------------------------------------------------=
// not interesting
//
// Output:
//    S_OK
//
// Notes:
//
STDMETHODIMP COleControl::HandsOffStorage
(
    void
)
{
    // we don't ever hold on to  a storage pointer, so this is remarkably
    // uninteresting to us.
    //
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::m_SaveToStream    [helper: IPersistStreamInit/IPersistStorage]
//=--------------------------------------------------------------------------=
// save ourselves to a stream
//
// Parameters:
//    IStream *        - figure it out
//
// Output:
//    HRESULT
//
// Notes:
//
HRESULT COleControl::m_SaveToStream
(
    IStream *pStream
)
{
    HRESULT hr;

    // save out standard state information that the user has no control
    // over
    //
    hr = SaveStandardState(pStream);
    RETURN_ON_FAILURE(hr);

    // save out user-specific satte information.  they MUST implement this
    // function
    //
    hr = SaveBinaryState(pStream);

    return hr;
}

//=--------------------------------------------------------------------------=
// COleControl::LoadStandardState    [ helper ]
//=--------------------------------------------------------------------------=
// reads in standard properties that all controls are going to have, using
// text persistence APIs.  there is another version for streams.
//
// Parameters:
//    IPropertyBag *    - [in]
//    IErrorLog *       - [in]
//
// Output:
//    HRESULT
//
// Notes:
//
HRESULT COleControl::LoadStandardState
(
    IPropertyBag *pPropertyBag,
    IErrorLog    *pErrorLog
)
{
    VARIANT v;
    HRESULT hr;
    SIZEL   slHiMetric = { 100, 50 };

    // currently, our only standard properties are related to size.
    // if we can't find them, then we'll just use some defaults.
    //
    v.vt = VT_I4;
    v.lVal = 0;
    hr = pPropertyBag->Read(L"_ExtentX", &v, pErrorLog);
    if (SUCCEEDED(hr)) slHiMetric.cx = v.lVal;

    v.lVal = 0;
    hr = pPropertyBag->Read(L"_ExtentY", &v, pErrorLog);
    if (SUCCEEDED(hr)) slHiMetric.cy = v.lVal;

    HiMetricToPixel(&slHiMetric, &m_Size);
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::LoadStandardState    [ helper ]
//=--------------------------------------------------------------------------=
// reads in standard properties that all controls are going to have, using
// stream persistence APIs.  there is another version for text.
//
// Parameters:
//    IStream *         - [in] 
//
// Output:
//    HRESULT
//
// Notes:
//
HRESULT COleControl::LoadStandardState
(
    IStream *pStream
)
{
    STREAMHDR stmhdr;
    HRESULT hr;
    SIZEL   slHiMetric;

    // look for our header structure, so we can verify stream validity.
    //
    hr = pStream->Read(&stmhdr, sizeof(STREAMHDR), NULL);
    RETURN_ON_FAILURE(hr);

    if (stmhdr.dwSignature != STREAMHDR_SIGNATURE)
        return E_UNEXPECTED;

    // currently, the only standard state we're writing out is
    // a SIZEL structure describing the control's size.
    //
    if (stmhdr.cbWritten != sizeof(m_Size))
        return E_UNEXPECTED;

    // we like the stream.  let's go load in our two properties.
    //
    hr = pStream->Read(&slHiMetric, sizeof(slHiMetric), NULL);
    RETURN_ON_FAILURE(hr);

    HiMetricToPixel(&slHiMetric, &m_Size);
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::SaveStandardState    [ helper ]
//=--------------------------------------------------------------------------=
// saves out standard properties that we're managing for a control using text
// persistence APIs.  there is another version for stream persistence.
//
// Parameters:
//    IPropertyBag *        - [in]
//
// Output:
//    HRESULT
//
// Notes:
//
HRESULT COleControl::SaveStandardState
(
    IPropertyBag *pPropertyBag
)
{
    HRESULT hr;
    VARIANT v;
    SIZEL   slHiMetric;

    // currently, the only standard proprerties we persist are Size related
    //
    PixelToHiMetric(&m_Size, &slHiMetric);

    v.vt = VT_I4;
    v.lVal = slHiMetric.cx;

    hr = pPropertyBag->Write(L"_ExtentX", &v);
    RETURN_ON_FAILURE(hr);

    v.lVal = slHiMetric.cy;

    hr = pPropertyBag->Write(L"_ExtentY", &v);

    return hr;
}

//=--------------------------------------------------------------------------=
// COleControl::SaveStandardState    [ helper ]
//=--------------------------------------------------------------------------=
// saves out standard properties that we're managing for a control using stream
// persistence APIs.  there is another version for text persistence.
//
// Parameters:
//    IStream *            - [in]
//
// Output:
//    HRESULT
//
// Notes:
//
HRESULT COleControl::SaveStandardState
(
    IStream *pStream
)
{
    STREAMHDR streamhdr = { STREAMHDR_SIGNATURE, sizeof(SIZEL) };
    HRESULT hr;
    SIZEL   slHiMetric;


    // first thing to do is write out our stream hdr structure.
    //
    hr = pStream->Write(&streamhdr, sizeof(STREAMHDR), NULL);
    RETURN_ON_FAILURE(hr);

    // the only properties we're currently persisting here are the size
    // properties for this control.  make sure we do that in HiMetric
    //
    PixelToHiMetric(&m_Size, &slHiMetric);

    hr = pStream->Write(&slHiMetric, sizeof(slHiMetric), NULL);
    return hr;
}

//=--------------------------------------------------------------------------=
// COleControl::InitializeNewState    [overridable]
//=--------------------------------------------------------------------------=
// the user can override this to initialize variables
//
// Output:
//    BOOL        - FALSE means couldn't do it.
//
// Notes:
//
BOOL COleControl::InitializeNewState
(
    void
)
{
    // we find this largely uninteresting
    //
    return TRUE;
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\basectl\ctlmisc.cpp ===
//=--------------------------------------------------------------------------=
// CtlMisc.Cpp
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// things that aren't elsewhere, such as property pages, and connection
// points.

#include "IPServer.H"
#include "CtrlObj.H"
#include "CtlHelp.H"
#include "Globals.H"
#include "StdEnum.H"
#include "Util.H"

#include <stdarg.h>

// for ASSERT and FAIL
//
SZTHISFILE

// this is used in our window proc so that we can find out who was last created
//
static COleControl *s_pLastControlCreated;

//=--------------------------------------------------------------------------=
// COleControl::COleControl
//=--------------------------------------------------------------------------=
// constructor
//
// Parameters:
//    IUnknown *          - [in] controlling Unknown
//    int                 - [in] type of primary dispatch interface OBJECT_TYPE_*
//    void *              - [in] pointer to entire object
//	  BOOL                - [in] whether to enable IDispatchEx functionality
//							to allow dynamic adding of properties
// Notes:
//
COleControl::COleControl
(
    IUnknown *pUnkOuter,
    int       iPrimaryDispatch,
    void     *pMainInterface,
	BOOL     fExpandoEnabled
)
: CAutomationObject(pUnkOuter, iPrimaryDispatch, pMainInterface, fExpandoEnabled),
  m_cpEvents(SINK_TYPE_EVENT),
  m_cpPropNotify(SINK_TYPE_PROPNOTIFY)
{
    // initialize all our variables -- we decided against using a memory-zeroing
    // memory allocator, so we sort of have to do this work now ...
    //
    m_nFreezeEvents = 0;

    m_pClientSite = NULL;
    m_pControlSite = NULL;
    m_pInPlaceSite = NULL;
    m_pInPlaceFrame = NULL;
    m_pInPlaceUIWindow = NULL;


    m_pInPlaceSiteWndless = NULL;

    // certain hosts don't like 0,0 as your initial size, so we're going to set
    // our initial size to 100,50 [so it's at least sort of visible on the screen]
    //
    m_Size.cx = 0;
    m_Size.cy = 0;
    memset(&m_rcLocation, 0, sizeof(m_rcLocation));

    m_hRgn = NULL;
    m_hwnd = NULL;
    m_hwndParent = NULL;
    m_hwndReflect = NULL;
    m_fHostReflects = TRUE;
    m_fCheckedReflecting = FALSE;

    m_nFreezeEvents = 0;
    m_pSimpleFrameSite = NULL;
    m_pOleAdviseHolder = NULL;
    m_pViewAdviseSink = NULL;
    m_pDispAmbient = NULL;

    m_fDirty = FALSE;
    m_fModeFlagValid = FALSE;
    m_fInPlaceActive = FALSE;
    m_fInPlaceVisible = FALSE;
    m_fUIActive = FALSE;
    m_fSaveSucceeded = FALSE;
    m_fViewAdvisePrimeFirst = FALSE;
    m_fViewAdviseOnlyOnce = FALSE;
    m_fRunMode = FALSE;
}

//=--------------------------------------------------------------------------=
// COleControl::~COleControl
//=--------------------------------------------------------------------------=
// "We are all of us resigned to death; it's life we aren't resigned to."
//    - Graham Greene (1904-91)
//
// Notes:
//
COleControl::~COleControl()
{
    // if we've still got a window, go and kill it now.
    //
    if (m_hwnd) {
        // so our window proc doesn't crash.
        //
        SetWindowLongPtr(m_hwnd, GWLP_USERDATA, (LONG_PTR)0xFFFFFFFF);
        DestroyWindow(m_hwnd);
    }

    if (m_hwndReflect) {
        SetWindowLongPtr(m_hwndReflect, GWLP_USERDATA, 0);
        DestroyWindow(m_hwndReflect);
    }

    if (m_hRgn != NULL)
    {
       DeleteObject(m_hRgn);
       m_hRgn = NULL;
    }

    // clean up all the pointers we're holding around.
    //
    QUICK_RELEASE(m_pClientSite);
    QUICK_RELEASE(m_pControlSite);
    QUICK_RELEASE(m_pInPlaceSite);
    QUICK_RELEASE(m_pInPlaceFrame);
    QUICK_RELEASE(m_pInPlaceUIWindow);
    QUICK_RELEASE(m_pSimpleFrameSite);
    QUICK_RELEASE(m_pOleAdviseHolder);
    QUICK_RELEASE(m_pViewAdviseSink);
    QUICK_RELEASE(m_pDispAmbient);

    QUICK_RELEASE(m_pInPlaceSiteWndless);
}

#ifndef DEBUG
#pragma optimize("t", on)
#endif // DEBUG

//=--------------------------------------------------------------------------=
// COleControl::InternalQueryInterface
//=--------------------------------------------------------------------------=
// derived-controls should delegate back to this when they decide to support
// additional interfaces
//
// Parameters:
//    REFIID        - [in]  interface they want
//    void **       - [out] where they want to put the resulting object ptr.
//
// Output:
//    HRESULT       - S_OK, E_NOINTERFACE
//
// Notes:
//    - NOTE: this function is speed critical!!!!
//
HRESULT COleControl::InternalQueryInterface
(
    REFIID riid,
    void **ppvObjOut
)
{
    switch (riid.Data1) {
        // private interface for prop page support
        case Data1_IControlPrv:
          if(DO_GUIDS_MATCH(riid, IID_IControlPrv)) {
            *ppvObjOut = (void *)this;
            ExternalAddRef();
            return S_OK;
          }
          goto NoInterface;
        QI_INHERITS(this, IOleControl);
        QI_INHERITS(this, IPointerInactive);
        QI_INHERITS(this, IQuickActivate);
        QI_INHERITS(this, IOleObject);
        QI_INHERITS((IPersistStorage *)this, IPersist);
        QI_INHERITS(this, IPersistStreamInit);
        QI_INHERITS(this, IOleInPlaceObject);
        QI_INHERITS(this, IOleInPlaceObjectWindowless);
        QI_INHERITS((IOleInPlaceActiveObject *)this, IOleWindow);
        QI_INHERITS(this, IOleInPlaceActiveObject);
        QI_INHERITS(this, IViewObject);
        QI_INHERITS(this, IViewObject2);
        QI_INHERITS(this, IViewObjectEx);
        QI_INHERITS(this, IConnectionPointContainer);
        QI_INHERITS(this, ISpecifyPropertyPages);
        QI_INHERITS(this, IPersistStorage);
        QI_INHERITS(this, IPersistPropertyBag);
        QI_INHERITS(this, IProvideClassInfo);
        default:
            goto NoInterface;
    }

    // we like the interface, so addref and return
    //
    ((IUnknown *)(*ppvObjOut))->AddRef();
    return S_OK;

  NoInterface:
    // delegate to super-class for automation interfaces, etc ...
    //
    return CAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}

#ifndef DEBUG
#pragma optimize("s", on)
#endif // DEBUG

//=--------------------------------------------------------------------------=
// COleControl::FindConnectionPoint    [IConnectionPointContainer]
//=--------------------------------------------------------------------------=
// given an IID, find a connection point sink for it.
//
// Parameters:
//    REFIID              - [in]  interfaces they want
//    IConnectionPoint ** - [out] where the cp should go
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::FindConnectionPoint
(
    REFIID             riid,
    IConnectionPoint **ppConnectionPoint
)
{
    CHECK_POINTER(ppConnectionPoint);

    // we support the event interface, and IDispatch for it, and we also
    // support IPropertyNotifySink.
    //
    if (DO_GUIDS_MATCH(riid, EVENTIIDOFCONTROL(m_ObjectType)) || DO_GUIDS_MATCH(riid, IID_IDispatch))
        *ppConnectionPoint = &m_cpEvents;
    else if (DO_GUIDS_MATCH(riid, IID_IPropertyNotifySink))
        *ppConnectionPoint = &m_cpPropNotify;
    else
        return E_NOINTERFACE;

    // generic post-processing.
    //
    (*ppConnectionPoint)->AddRef();
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::EnumConnectionPoints    [IConnectionPointContainer]
//=--------------------------------------------------------------------------=
// creates an enumerator for connection points.
//
// Parameters:
//    IEnumConnectionPoints **    - [out]
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::EnumConnectionPoints
(
    IEnumConnectionPoints **ppEnumConnectionPoints
)
{
    IConnectionPoint **rgConnectionPoints;

    CHECK_POINTER(ppEnumConnectionPoints);

    // HeapAlloc an array of connection points [since our standard enum
    // assumes this and HeapFree's it later ]
    //
    rgConnectionPoints = (IConnectionPoint **)HeapAlloc(g_hHeap, 0, sizeof(IConnectionPoint *) * 2);
    RETURN_ON_NULLALLOC(rgConnectionPoints);

    // we support the event interface for this dude as well as IPropertyNotifySink
    //
    rgConnectionPoints[0] = &m_cpEvents;
    rgConnectionPoints[1] = &m_cpPropNotify;

    *ppEnumConnectionPoints = (IEnumConnectionPoints *)(IEnumGeneric *) new CStandardEnum(IID_IEnumConnectionPoints,
                                2, sizeof(IConnectionPoint *), (void *)rgConnectionPoints,
                                CopyAndAddRefObject);
    if (!*ppEnumConnectionPoints) {
        HeapFree(g_hHeap, 0, rgConnectionPoints);
        return E_OUTOFMEMORY;
    }

    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::GetPages    [ISpecifyPropertyPages]
//=--------------------------------------------------------------------------=
// returns a counted array with the guids for our property pages.
//
// parameters:
//    CAUUID *    - [out] where to put the counted array.
//
// Output:
//    HRESULT
//
// NOtes:
//
STDMETHODIMP COleControl::GetPages
(
    CAUUID *pPages
)
{
    const GUID **pElems;
    void *pv;
    WORD  x;

    // if there are no property pages, this is actually pretty easy.
    //
    if (!CPROPPAGESOFCONTROL(m_ObjectType)) {
        pPages->cElems = 0;
        pPages->pElems = NULL;
        return S_OK;
    }

    // fill out the Counted array, using IMalloc'd memory.
    //
    pPages->cElems = CPROPPAGESOFCONTROL(m_ObjectType);
    pv = CoTaskMemAlloc(sizeof(GUID) * (pPages->cElems));
    RETURN_ON_NULLALLOC(pv);
    pPages->pElems = (GUID *)pv;

    // loop through our array of pages and get 'em.
    //
    pElems = PPROPPAGESOFCONTROL(m_ObjectType);
    for (x = 0; x < pPages->cElems; x++)
        pPages->pElems[x] = *(pElems[x]);

    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::CConnectionPoint::m_pOleControl
//=--------------------------------------------------------------------------=
// returns a pointer to the control in which we are nested.
//
// Output:
//    COleControl *
//
// Notes:
//
inline COleControl *COleControl::CConnectionPoint::m_pOleControl
(
    void
)
{
    return (COleControl *)((BYTE *)this - ((m_bType == SINK_TYPE_EVENT)
                                          ? offsetof(COleControl, m_cpEvents)
                                          : offsetof(COleControl, m_cpPropNotify)));
}

//=--------------------------------------------------------------------------=
// COleControl::CConnectionPoint::QueryInterface
//=--------------------------------------------------------------------------=
// standard qi
//
// Parameters:
//    REFIID        - [in]  interface they want
//    void **       - [out] where they want to put the resulting object ptr.
//
// Output:
//    HRESULT       - S_OK, E_NOINTERFACE
//
// Notes:
//
STDMETHODIMP COleControl::CConnectionPoint::QueryInterface
(
    REFIID riid,
    void **ppvObjOut
)
{
    if (DO_GUIDS_MATCH(riid, IID_IConnectionPoint) || DO_GUIDS_MATCH(riid, IID_IUnknown)) {
        *ppvObjOut = (IConnectionPoint *)this;
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

//=--------------------------------------------------------------------------=
// COleControl::CConnectionPoint::AddRef
//=--------------------------------------------------------------------------=
//
// Output:
//    ULONG        - the new reference count
//
// Notes:
//
ULONG COleControl::CConnectionPoint::AddRef
(
    void
)
{
    return m_pOleControl()->ExternalAddRef();
}

//=--------------------------------------------------------------------------=
// COleControl::CConnectionPoint::Release
//=--------------------------------------------------------------------------=
//
// Output:
//    ULONG         - remaining refs
//
// Notes:
//
ULONG COleControl::CConnectionPoint::Release
(
    void
)
{
    return m_pOleControl()->ExternalRelease();
}

//=--------------------------------------------------------------------------=
// COleControl::CConnectionPoint::GetConnectionInterface
//=--------------------------------------------------------------------------=
// returns the interface we support connections on.
//
// Parameters:
//    IID *        - [out] interface we support.
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::CConnectionPoint::GetConnectionInterface
(
    IID *piid
)
{
    if (m_bType == SINK_TYPE_EVENT)
        *piid = EVENTIIDOFCONTROL(m_pOleControl()->m_ObjectType);
    else
        *piid = IID_IPropertyNotifySink;

    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::CConnectionPoint::GetConnectionPointContainer
//=--------------------------------------------------------------------------=
// returns the connection point container
//
// Parameters:
//    IConnectionPointContainer **ppCPC
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::CConnectionPoint::GetConnectionPointContainer
(
    IConnectionPointContainer **ppCPC
)
{
    return m_pOleControl()->ExternalQueryInterface(IID_IConnectionPointContainer, (void **)ppCPC);
}


//=--------------------------------------------------------------------------=
// COleControl::CConnectiontPoint::Advise
//=--------------------------------------------------------------------------=
// someboyd wants to be advised when something happens.
//
// Parameters:
//    IUnknown *        - [in]  guy who wants to be advised.
//    DWORD *           - [out] cookie
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::CConnectionPoint::Advise
(
    IUnknown *pUnk,
    DWORD    *pdwCookie
)
{
    HRESULT    hr;
    void      *pv;

    CHECK_POINTER(pdwCookie);

    // first, make sure everybody's got what they thinks they got
    //
    if (m_bType == SINK_TYPE_EVENT) {

        // CONSIDER: 12.95 -- this theoretically is broken -- if they do a find
        // connection point on IDispatch, and they just happened to also support
        // the Event IID, we'd advise on that.  this is not awesome, but will
        // prove entirely acceptable short term.
        //
        hr = pUnk->QueryInterface(EVENTIIDOFCONTROL(m_pOleControl()->m_ObjectType), &pv);
        if (FAILED(hr))
            hr = pUnk->QueryInterface(IID_IDispatch, &pv);
    }
    else
        hr = pUnk->QueryInterface(IID_IPropertyNotifySink, &pv);
    RETURN_ON_FAILURE(hr);

    // finally, add the sink.  it's now been cast to the correct type and has
    // been AddRef'd.
    //
    return AddSink(pv, pdwCookie);
}

//=--------------------------------------------------------------------------=
// COleControl::CConnectionPoint::AddSink
//=--------------------------------------------------------------------------=
// in some cases, we'll already have done the QI, and won't need to do the
// work that is done in the Advise routine above.  thus, these people can
// just call this instead. [this stems really from IQuickActivate]
//
// Parameters:
//    void *        - [in]  the sink to add. it's already been addref'd
//    DWORD *       - [out] cookie
//
// Output:
//    HRESULT
//
// Notes:
//
HRESULT COleControl::CConnectionPoint::AddSink
(
    void  *pv,
    DWORD *pdwCookie
)
{
    IUnknown **rgUnkNew;
    int        i;

    // we optimize the case where there is only one sink to not allocate
    // any storage.  turns out very rarely is there more than one.
    //

    if (!m_cSinks) {
        m_SingleSink = (IUnknown *) pv;
        *pdwCookie = (DWORD) 1;
        m_cSinks = 1;
        return S_OK;
    }

    // Allocated the array yet?
    if (!m_rgSinks) {
        rgUnkNew = (IUnknown **)HeapAlloc(g_hHeap, HEAP_ZERO_MEMORY, 8 * sizeof(IUnknown *));
        RETURN_ON_NULLALLOC(rgUnkNew);
        m_cAllocatedSinks = 8;
        m_rgSinks = rgUnkNew;
        m_rgSinks[0] = m_SingleSink;
        m_rgSinks[1] = (IUnknown *)pv;
        m_SingleSink = NULL;
        m_cSinks = 2;
        *pdwCookie = 2;
        return S_OK;
    }

    // Find an empty slot.
    for (i = 0; i < m_cAllocatedSinks; i++) {
        if (!m_rgSinks[i]) {
            m_rgSinks[i] = (IUnknown *)pv;
            i++;
            *pdwCookie = i;
            m_cSinks++;
            return S_OK;
        }
    }

    // Didn't find one, grow the array.
    rgUnkNew = (IUnknown **)HeapReAlloc(g_hHeap, HEAP_ZERO_MEMORY, m_rgSinks, (m_cAllocatedSinks + 8) * sizeof(IUnknown *));
    RETURN_ON_NULLALLOC(rgUnkNew);
    m_rgSinks = rgUnkNew;
    m_rgSinks[m_cAllocatedSinks] = (IUnknown *)pv;
    i = m_cAllocatedSinks+1;
    m_cAllocatedSinks += 8;

    *pdwCookie = i;
    m_cSinks++;
    return S_OK;
}


//=--------------------------------------------------------------------------=
// COleControl::CConnectionPoint::Unadvise
//=--------------------------------------------------------------------------=
// they don't want to be told any more.
//
// Parameters:
//    DWORD        - [in]  the cookie we gave 'em.
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::CConnectionPoint::Unadvise
(
    DWORD dwCookie
)
{
    IUnknown *pUnk;

    if (!dwCookie)
        return S_OK;

    if (dwCookie == (DWORD) 1) {
		// If more than one Sinks added, m_SingleSink pointer has been shifted
		// to m_rgSinks[0].
        pUnk = (m_rgSinks) ? m_rgSinks[0] : m_SingleSink;
        m_SingleSink = NULL;
        if (m_rgSinks) {
            m_rgSinks[0] = NULL;
        }
    } else {
        if (dwCookie <= (DWORD)m_cAllocatedSinks) {
	    if (m_rgSinks) {
            	pUnk = m_rgSinks[dwCookie-1];
            	m_rgSinks[dwCookie-1] = NULL;
	    } else {
            	return CONNECT_E_NOCONNECTION;
	    }
        } else {
            return CONNECT_E_NOCONNECTION;
        }
    }

    m_cSinks--;

    if (!m_cSinks && m_rgSinks) {
        HeapFree(g_hHeap, 0, m_rgSinks);
        m_cAllocatedSinks = 0;
        m_rgSinks = NULL;
    }

    if (pUnk) {
        pUnk->Release();
        return S_OK;
    } else {
        return CONNECT_E_NOCONNECTION;
    }
}

//=--------------------------------------------------------------------------=
// COleControl::CConnectionPoint::EnumConnections
//=--------------------------------------------------------------------------=
// enumerates all current connections
//
// Paramters:
//    IEnumConnections ** - [out] new enumerator object
//
// Output:
//    HRESULT
//
// NOtes:
//
STDMETHODIMP COleControl::CConnectionPoint::EnumConnections
(
    IEnumConnections **ppEnumOut
)
{
    CONNECTDATA *rgConnectData = NULL;
    unsigned int i;

    if (m_cSinks) {
        // allocate some memory big enough to hold all of the sinks.
        //
        rgConnectData = (CONNECTDATA *)HeapAlloc(g_hHeap, 0, m_cSinks * sizeof(CONNECTDATA));
        RETURN_ON_NULLALLOC(rgConnectData);

        if ((m_cSinks == 1) && !m_rgSinks) {
            rgConnectData[0].pUnk = m_SingleSink;
            rgConnectData[0].dwCookie = (DWORD)1;
        } else {
            for (unsigned int x = 0, i=0; x < m_cAllocatedSinks; x++) {
                if (m_rgSinks[x]) {
                    rgConnectData[i].pUnk = m_rgSinks[x];
                    rgConnectData[i].dwCookie = x+1;
                    i++;
                }
            }
        }
    }

    // create yon enumerator object.
    //
    *ppEnumOut = (IEnumConnections *)(IEnumGeneric *)new CStandardEnum(IID_IEnumConnections,
                        m_cSinks, sizeof(CONNECTDATA), rgConnectData, CopyAndAddRefObject);
    if (!*ppEnumOut) {
        HeapFree(g_hHeap, 0, rgConnectData);
        return E_OUTOFMEMORY;
    }

    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::CConnectionPoint::~CConnectionPoint
//=--------------------------------------------------------------------------=
// cleans up
//
// Notes:
//
COleControl::CConnectionPoint::~CConnectionPoint ()
{
    int x;

    // clean up some memory stuff
    //
    if (!m_cSinks)
        return;
    else if (m_SingleSink)
        ((IUnknown *)m_SingleSink)->Release();
    else {
        for (x = 0; x < m_cAllocatedSinks; x++) {
	    if (m_rgSinks[x]) {
                QUICK_RELEASE(m_rgSinks[x]);
	    }
	}
        HeapFree(g_hHeap, 0, m_rgSinks);
    }
}

//=--------------------------------------------------------------------------=
// COleControl::CConnectionPiont::DoInvoke
//=--------------------------------------------------------------------------=
// fires an event to all listening on our event interface.
//
// Parameters:
//    DISPID            - [in] event to fire.
//    DISPPARAMS        - [in]
//
// Notes:
//
void COleControl::CConnectionPoint::DoInvoke
(
    DISPID      dispid,
    DISPPARAMS *pdispparams
)
{
    int iConnection;

    // if we don't have any sinks, then there's nothing to do.  we intentionally
    // ignore errors here.
    //
    if (m_cSinks == 0)
        return;
    else if (m_SingleSink) {
        ((IDispatch *)m_SingleSink)->Invoke(dispid, IID_NULL, 0, DISPATCH_METHOD, pdispparams, NULL, NULL, NULL);
    } else {
        for (iConnection = 0; iConnection < m_cAllocatedSinks; iConnection++) {
	    if (m_rgSinks[iConnection]) {
                ((IDispatch *)m_rgSinks[iConnection])->Invoke(dispid, IID_NULL, 0, DISPATCH_METHOD, pdispparams, NULL, NULL, NULL);
	    }
	}
    }
}

//=--------------------------------------------------------------------------=
// COleControl::CConnectionPoint::DoOnChanged
//=--------------------------------------------------------------------------=
// fires the OnChanged event for IPropertyNotifySink listeners.
//
// Parameters:
//    DISPID            - [in] dude that changed.
//
// Output:
//    none
//
// Notes:
//
void COleControl::CConnectionPoint::DoOnChanged
(
    DISPID dispid
)
{
    int iConnection;

    // if we don't have any sinks, then there's nothing to do.
    //
    if (m_cSinks == 0)
        return;
    else if (m_SingleSink) {
        ((IPropertyNotifySink *)m_SingleSink)->OnChanged(dispid);
    } else {
        for (iConnection = 0; iConnection < m_cAllocatedSinks; iConnection++) {
    	    if (m_rgSinks[iConnection]) {
                ((IPropertyNotifySink *)m_rgSinks[iConnection])->OnChanged(dispid);
            }
	    }
    }
}

//=--------------------------------------------------------------------------=
// COleControl::CConnectionPoint::DoOnRequestEdit
//=--------------------------------------------------------------------------=
// fires the OnRequestEdit for IPropertyNotifySinkListeners
//
// Parameters:
//    DISPID             - [in] dispid user wants to change.
//
// Output:
//    BOOL               - false means you cant
//
// Notes:
//
BOOL COleControl::CConnectionPoint::DoOnRequestEdit
(
    DISPID dispid
)
{
    HRESULT hr;
    int     iConnection;

    // if we don't have any sinks, then there's nothing to do.
    //
    if (m_cSinks == 0)
        hr = S_OK;
    else if (m_SingleSink) {
        hr =((IPropertyNotifySink *)m_SingleSink)->OnRequestEdit(dispid);
    } else {
        for (iConnection = 0; iConnection < m_cAllocatedSinks; iConnection++) {
	    if (m_rgSinks[iConnection]) {
                hr = ((IPropertyNotifySink *)m_rgSinks[iConnection])->OnRequestEdit(dispid);
                if (hr != S_OK)
		    break;
	    }
        }
    }

    return (hr == S_OK) ? TRUE : FALSE;
}

//=--------------------------------------------------------------------------=
// COleControl::CreateInPlaceWindow
//=--------------------------------------------------------------------------=
// creates the window with which we will be working.
// yay.
//
// Parameters:
//    int            - [in] left
//    int            - [in] top
//    BOOL           - [in] can we skip redrawing?
//
// Output:
//    HWND
//
// Notes:
//    - DANGER! DANGER!  this function is protected so that anybody can call it
//      from their control.  however, people should be extremely careful of when
//      and why they do this.  preferably, this function would only need to be
//      called by an end-control writer in design mode to take care of some
//      hosting/painting issues.  otherwise, the framework should be left to
//      call it when it wants.
//
HWND COleControl::CreateInPlaceWindow
(
    int  x,
    int  y,
    BOOL fNoRedraw
)
{
    BOOL    fVisible;
    HRESULT hr;
    DWORD   dwWindowStyle, dwExWindowStyle;
    char    szWindowTitle[128];

    // if we've already got a window, do nothing.
    //
    if (m_hwnd)
        return m_hwnd;

    // get the user to register the class if it's not already
    // been done.  we have to critical section this since more than one thread
    // can be trying to create this control
    //
    EnterCriticalSection(&g_CriticalSection);
    if (!CTLWNDCLASSREGISTERED(m_ObjectType)) {
        if (!RegisterClassData()) {
            LeaveCriticalSection(&g_CriticalSection);
            return NULL;
        } else
            CTLWNDCLASSREGISTERED(m_ObjectType) = TRUE;
    }
    LeaveCriticalSection(&g_CriticalSection);

    // let the user set up things like the window title, the
    // style, and anything else they feel interested in fiddling
    // with.
    //
    dwWindowStyle = dwExWindowStyle = 0;
    szWindowTitle[0] = '\0';
    if (!BeforeCreateWindow(&dwWindowStyle, &dwExWindowStyle, szWindowTitle))
        return NULL;

    dwWindowStyle |= (WS_CHILD | WS_CLIPSIBLINGS);

    // create window visible if parent hidden (common case)
    // otherwise, create hidden, then shown.  this is a little subtle, but
    // it makes sense eventually.
    //
    if (!m_hwndParent)
        m_hwndParent = GetParkingWindow();

    fVisible = IsWindowVisible(m_hwndParent);

    // if a control is subclassed, and we're in
    // a host that doesn't support Message Reflecting, we have to create
    // the user window in another window which will do all the reflecting.
    // VERY blech. [don't however, bother in design mode]
    //
    if (SUBCLASSWNDPROCOFCONTROL(m_ObjectType) && (m_hwndParent != GetParkingWindow())) {
        // determine if the host supports message reflecting.
        //
        if (!m_fCheckedReflecting) {
            VARIANT_BOOL f;
            hr = GetAmbientProperty(DISPID_AMBIENT_MESSAGEREFLECT, VT_BOOL, &f);
            if (FAILED(hr) || !f)
                m_fHostReflects = FALSE;
            m_fCheckedReflecting = TRUE;
        }

        // if the host doesn't support reflecting, then we have to create
        // an extra window around the control window, and then parent it
        // off that.
        //
        if (!m_fHostReflects) {
            ASSERT(m_hwndReflect == NULL, "Where'd this come from?");
            m_hwndReflect = CreateReflectWindow(!fVisible, m_hwndParent, x, y, &m_Size);
            if (!m_hwndReflect)
                return NULL;
            SetWindowLongPtr(m_hwndReflect, GWLP_USERDATA, (LONG_PTR)this);
            dwWindowStyle |= WS_VISIBLE;
        }
    } else {
        if (!fVisible)
            dwWindowStyle |= WS_VISIBLE;
    }

    // we have to mutex the entire create window process since we need to use
    // the s_pLastControlCreated to pass in the object pointer.  nothing too
    // serious
    //
    EnterCriticalSection(&g_CriticalSection);
    s_pLastControlCreated = this;
    m_fCreatingWindow = TRUE;

    // finally, go create the window, parenting it as appropriate.
    //
    m_hwnd = CreateWindowEx(dwExWindowStyle,
                            WNDCLASSNAMEOFCONTROL(m_ObjectType),
                            szWindowTitle,
                            dwWindowStyle,
                            (m_hwndReflect) ? 0 : x,
                            (m_hwndReflect) ? 0 : y,
                            m_Size.cx, m_Size.cy,
                            (m_hwndReflect) ? m_hwndReflect : m_hwndParent,
                            NULL, g_hInstance, NULL);

    // clean up some variables, and leave the critical section
    //
    m_fCreatingWindow = FALSE;
    s_pLastControlCreated = NULL;
    LeaveCriticalSection(&g_CriticalSection);

    if (m_hwnd) {
        // let the derived-control do something if they so desire
        //
        if (!AfterCreateWindow()) {
            BeforeDestroyWindow();
            SetWindowLongPtr(m_hwnd, GWLP_USERDATA, (LONG_PTR)0xFFFFFFFF);
            DestroyWindow(m_hwnd);
            m_hwnd = NULL;
            return m_hwnd;
        }

        // if we didn't create the window visible, show it now.
        //
		
        if (fVisible)
		{
			if (GetParent(m_hwnd) != m_hwndParent)
				// SetWindowPos fails if parent hwnd is passed in so keep
				// this behaviour in those cases without ripping.
				SetWindowPos(m_hwnd, m_hwndParent, 0, 0, 0, 0,
							 SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER | SWP_SHOWWINDOW | (fNoRedraw) ? SWP_NOREDRAW : 0);
		}
    }

    // finally, tell the host of this
    //
    if (m_pClientSite)
        m_pClientSite->ShowObject();

    return m_hwnd;
}

//=--------------------------------------------------------------------------=
// COleControl::SetInPlaceParent    [helper]
//=--------------------------------------------------------------------------=
// sets up the parent window for our control.
//
// Parameters:
//    HWND            - [in] new parent window
//
// Notes:
//
void COleControl::SetInPlaceParent
(
    HWND hwndParent
)
{
    ASSERT(!m_pInPlaceSiteWndless, "This routine should only get called for windowed OLE controls");

    if (m_hwndParent == hwndParent)
        return;

    m_hwndParent = hwndParent;
    if (m_hwnd)
        SetParent(GetOuterWindow(), hwndParent);
}

//=--------------------------------------------------------------------------=
// COleControl::ControlWindowProc
//=--------------------------------------------------------------------------=
// default window proc for an OLE Control.   controls will have their own
// window proc called from this one, after some processing is done.
//
// Parameters:
//    - see win32sdk docs.
//
// Notes:
//
LRESULT CALLBACK COleControl::ControlWindowProc
(
    HWND    hwnd,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    COleControl *pCtl = ControlFromHwnd(hwnd);
    HRESULT hr;
    LRESULT lResult;
    DWORD   dwCookie;

    // if the value isn't a positive value, then it's in some special
    // state [creation or destruction]  this is safe because under win32,
    // the upper 2GB of an address space aren't available.
    //
    if (!pCtl) {
        pCtl = s_pLastControlCreated;
        SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)pCtl);
        pCtl->m_hwnd = hwnd;
    } else if ((LONG_PTR)pCtl == (LONG_PTR)0xffffffff) {
        return DefWindowProc(hwnd, msg, wParam, lParam);
    }

    // message preprocessing
    //
    if (pCtl->m_pSimpleFrameSite) {
        hr = pCtl->m_pSimpleFrameSite->PreMessageFilter(hwnd, msg, wParam, lParam, &lResult, &dwCookie);
        if (hr == S_FALSE) return lResult;
    }

    // for certain messages, do not call the user window proc. instead,
    // we have something else we'd like to do.
    //
    switch (msg) {
      case WM_PAINT:
        {
        // call the user's OnDraw routine.
        //
        PAINTSTRUCT ps;
        RECT        rc;
        HDC         hdc;

        // if we're given an HDC, then use it
        //
        if (!wParam)
            hdc = BeginPaint(hwnd, &ps);
        else
            hdc = (HDC)wParam;

        GetClientRect(hwnd, &rc);
        pCtl->OnDraw(DVASPECT_CONTENT, hdc, (RECTL *)&rc, NULL, NULL, TRUE);

        if (!wParam)
            EndPaint(hwnd, &ps);
        }
        break;

      default:
        // call the derived-control's window proc
        //
        lResult = pCtl->WindowProc(msg, wParam, lParam);
        break;
    }

    // message postprocessing
    //
    switch (msg) {

      case WM_NCDESTROY:
        // after this point, the window doesn't exist any more
        //
        pCtl->m_hwnd = NULL;
        break;

      case WM_SETFOCUS:
        // give the control site focus notification
        //
        if (pCtl->m_fInPlaceActive && pCtl->m_pControlSite)
            pCtl->m_pControlSite->OnFocus(TRUE);

        pCtl->m_fUIActive = TRUE;
        break;

      case WM_KILLFOCUS:
        // give the control site focus notification
        //
        if (pCtl->m_fInPlaceActive && pCtl->m_pControlSite)
            pCtl->m_pControlSite->OnFocus(FALSE);

        pCtl->m_fUIActive = FALSE;
        break;

      case WM_SIZE:
        // a change in size is a change in view
        //
        if (!pCtl->m_fCreatingWindow)
            pCtl->ViewChanged();
        break;
    }

    // lastly, simple frame postmessage processing
    //
    if (pCtl->m_pSimpleFrameSite)
        pCtl->m_pSimpleFrameSite->PostMessageFilter(hwnd, msg, wParam, lParam, &lResult, dwCookie);

    return lResult;
}

//=--------------------------------------------------------------------------=
// COleControl::SetFocus
//=--------------------------------------------------------------------------=
// we have to override this routine to get UI Activation correct.
//
// Parameters:
//    BOOL              - [in] true means take, false release
//
// Output:
//    BOOL
//
// Notes:
//    - CONSIDER: this is pretty messy, and it's still not entirely clear
//      what the ole control/focus story is.
//
BOOL COleControl::SetFocus
(
    BOOL fGrab
)
{
    HRESULT hr;
    HWND    hwnd;

    // first thing to do is check out UI Activation state, and then set
    // focus [either with windows api, or via the host for windowless
    // controls]
    //
    if (m_pInPlaceSiteWndless) {
        if (!m_fUIActive && fGrab)
            if (FAILED(InPlaceActivate(OLEIVERB_UIACTIVATE))) return FALSE;

        hr = m_pInPlaceSiteWndless->SetFocus(fGrab);
        return (hr == S_OK) ? TRUE : FALSE;
    } else {

        // we've got a window.
        //
        if (m_fInPlaceActive) {
            hwnd = (fGrab) ? m_hwnd : m_hwndParent;
            if (!m_fUIActive && fGrab)
                return SUCCEEDED(InPlaceActivate(OLEIVERB_UIACTIVATE));
            else
                return SetGUIFocus(hwnd);
        } else
            return FALSE;
    }

    // dead code
}

//=--------------------------------------------------------------------------=
// COleControl::SetGUIFocus
//=--------------------------------------------------------------------------=
// does the work of setting the Windows GUI focus to the specified window
//
// Parameters:
//    HWND              - [in] window that should get focus
//
// Output:
//    BOOL              - [out] whether setting focus succeeded
//
// Notes:
//    we do this because some controls host non-ole window hierarchies, like
// the Netscape plugin ocx.  in such cases, the control may need to be UIActive
// to function properly in the document, but cannot take the windows focus
// away from one of its child windows.  such controls may override this method
// and respond as appropriate.
//
BOOL COleControl::SetGUIFocus
(
    HWND hwndSet
)
{
    return (::SetFocus(hwndSet) == hwndSet);
}


//=--------------------------------------------------------------------------=
// COleControl::ReflectWindowProc
//=--------------------------------------------------------------------------=
// reflects window messages on to the child window.
//
// Parameters and Output:
//    - see win32 sdk docs
//
// Notes:
//
LRESULT CALLBACK COleControl::ReflectWindowProc
(
    HWND    hwnd,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    COleControl *pCtl;

    switch (msg) {
        case WM_COMMAND:
        case WM_NOTIFY:
        case WM_CTLCOLORBTN:
        case WM_CTLCOLORDLG:
        case WM_CTLCOLOREDIT:
        case WM_CTLCOLORLISTBOX:
        case WM_CTLCOLORMSGBOX:
        case WM_CTLCOLORSCROLLBAR:
        case WM_CTLCOLORSTATIC:
        case WM_DRAWITEM:
        case WM_MEASUREITEM:
        case WM_DELETEITEM:
        case WM_VKEYTOITEM:
        case WM_CHARTOITEM:
        case WM_COMPAREITEM:
        case WM_HSCROLL:
        case WM_VSCROLL:
        case WM_PARENTNOTIFY:
        case WM_SETFOCUS:
        case WM_SIZE:
            pCtl = (COleControl *)GetWindowLongPtr(hwnd, GWLP_USERDATA);
            if (pCtl)
                return SendMessage(pCtl->m_hwnd, OCM__BASE + msg, wParam, lParam);
            break;
    }

    return DefWindowProc(hwnd, msg, wParam, lParam);
}

//=--------------------------------------------------------------------------=
// COleControl::GetAmbientProperty    [callable]
//=--------------------------------------------------------------------------=
// returns the value of an ambient property
//
// Parameters:
//    DISPID        - [in]  property to get
//    VARTYPE       - [in]  type of desired data
//    void *        - [out] where to put the data
//
// Output:
//    BOOL          - FALSE means didn't work.
//
// Notes:
//
BOOL COleControl::GetAmbientProperty
(
    DISPID  dispid,
    VARTYPE vt,
    void   *pData
)
{
    DISPPARAMS dispparams;
    VARIANT v, v2;
    HRESULT hr;

    v.vt = VT_EMPTY;
    v.lVal = 0;
    v2.vt = VT_EMPTY;
    v2.lVal = 0;

    // get a pointer to the source of ambient properties.
    //
    if (!m_pDispAmbient) {
        if (m_pClientSite)
            m_pClientSite->QueryInterface(IID_IDispatch, (void **)&m_pDispAmbient);

        if (!m_pDispAmbient)
            return FALSE;
    }

    // now go and get the property into a variant.
    //
    memset(&dispparams, 0, sizeof(DISPPARAMS));
    hr = m_pDispAmbient->Invoke(dispid, IID_NULL, 0, DISPATCH_PROPERTYGET, &dispparams,
                                &v, NULL, NULL);
    if (FAILED(hr)) return FALSE;

    // we've got the variant, so now go an coerce it to the type that the user
    // wants.  if the types are the same, then this will copy the stuff to
    // do appropriate ref counting ...
    //
    hr = VariantChangeType(&v2, &v, 0, vt);
    if (FAILED(hr)) {
        VariantClear(&v);
        return FALSE;
    }

    // copy the data to where the user wants it
    //
    CopyMemory(pData, &(v2.lVal), g_rgcbDataTypeSize[vt]);
    VariantClear(&v);
    return TRUE;
}

//=--------------------------------------------------------------------------=
// COleControl::GetAmbientFont    [callable]
//=--------------------------------------------------------------------------=
// gets the current font for the user.
//
// Parameters:
//    IFont **         - [out] where to put the font.
//
// Output:
//    BOOL             - FALSE means couldn't get it.
//
// Notes:
//
BOOL COleControl::GetAmbientFont
(
    IFont **ppFont
)
{
    IDispatch *pFontDisp;

    // we don't have to do much here except get the ambient property and QI
    // it for the user.
    //
    *ppFont = NULL;
    if (!GetAmbientProperty(DISPID_AMBIENT_FONT, VT_DISPATCH, &pFontDisp))
        return FALSE;

    pFontDisp->QueryInterface(IID_IFont, (void **)ppFont);
    pFontDisp->Release();
    return (*ppFont) ? TRUE : FALSE;
}

//=--------------------------------------------------------------------------=
// COleControl::DesignMode
//=--------------------------------------------------------------------------=
// returns TRUE if we're in Design mode.
//
// Output:
//    BOOL            - true is design mode, false is run mode
//
// Notes:
//
BOOL COleControl::DesignMode
(
    void
)
{
    VARIANT_BOOL f;

    // if we don't already know our run mode, go and get it.  we'll assume
    // it's true unless told otherwise [or if the operation fails ...]
    //
    if (!m_fModeFlagValid) {
        f = TRUE;
        m_fModeFlagValid = TRUE;
        GetAmbientProperty(DISPID_AMBIENT_USERMODE, VT_BOOL, &f);
        m_fRunMode = f;
    }

    return !m_fRunMode;
}


//=--------------------------------------------------------------------------=
// COleControl::FireEvent
//=--------------------------------------------------------------------------=
// fires an event.  handles arbitrary number of arguments.
//
// Parameters:
//    EVENTINFO *        - [in] struct that describes the event.
//    ...                - arguments to the event
//
// Output:
//    none
//
// Notes:
//    - use stdarg's va_* macros.
//
void __cdecl COleControl::FireEvent
(
    EVENTINFO *pEventInfo,
    ...
)
{
    va_list    valist;
    DISPPARAMS dispparams;
    VARIANT    rgvParameters[MAX_ARGS];
    VARIANT   *pv;
    VARTYPE    vt;
    int        iParameter;
    int        cbSize;

    ASSERT(pEventInfo->cParameters <= MAX_ARGS, "Don't support more than MAX_ARGS params.  sorry.");

    va_start(valist, pEventInfo);

    // copy the Parameters into the rgvParameters array.  make sure we reverse
    // them for automation
    //
    pv = &(rgvParameters[pEventInfo->cParameters - 1]);
    for (iParameter = 0; iParameter < pEventInfo->cParameters; iParameter++) {

        vt = pEventInfo->rgTypes[iParameter];

        // if it's a by value variant, then just copy the whole
        // dang thing
        //
        if (vt == VT_VARIANT)
            *pv = va_arg(valist, VARIANT);
        else {
            // copy the vt and the data value.
            //
            pv->vt = vt;
            if (vt & VT_BYREF)
                cbSize = sizeof(void *);
            else
                cbSize = g_rgcbDataTypeSize[vt];

            // small optimization -- we can copy 2/4 bytes over quite
            // quickly.
            //
            if (cbSize == sizeof(short))
                V_I2(pv) = va_arg(valist, short);
            else if (cbSize == 4)
                V_I4(pv) = va_arg(valist, long);
            else {
                // copy over 8 bytes
                //
                ASSERT(cbSize == 8, "don't recognize the type!!");
                V_CY(pv) = va_arg(valist, CURRENCY);
            }
        }

        pv--;
    }

    // fire the event
    //
    dispparams.rgvarg = rgvParameters;
    dispparams.cArgs = pEventInfo->cParameters;
    dispparams.rgdispidNamedArgs = NULL;
    dispparams.cNamedArgs = 0;

    m_cpEvents.DoInvoke(pEventInfo->dispid, &dispparams);

    va_end(valist);
}

//=--------------------------------------------------------------------------=
// COleControl::AfterCreateWindow    [overridable]
//=--------------------------------------------------------------------------=
// something the user can pay attention to
//
// Output:
//    BOOL             - false means fatal error, can't continue
// Notes:
//
BOOL COleControl::AfterCreateWindow
(
    void
)
{
    return TRUE;
}

//=--------------------------------------------------------------------------=
// COleControl::BeforeCreateWindow    [overridable]
//=--------------------------------------------------------------------------=
// called just before we create a window.  the user should register their
// window class here, and set up any other things, such as the title of
// the window, and/or sytle bits, etc ...
//
// Parameters:
//    DWORD *            - [out] dwWindowFlags
//    DWORD *            - [out] dwExWindowFlags
//    LPSTR              - [out] name of window to create
//
// Output:
//    BOOL               - false means fatal error, can't continue
//
// Notes:
//
BOOL COleControl::BeforeCreateWindow
(
    DWORD *pdwWindowStyle,
    DWORD *pdwExWindowStyle,
    LPSTR  pszWindowTitle
)
{
    return TRUE;
}

//=--------------------------------------------------------------------------=
// COleControl::InvalidateControl    [callable]
//=--------------------------------------------------------------------------=
void COleControl::InvalidateControl
(
    LPCRECT lpRect
)
{
    if (m_fInPlaceActive)
        InvalidateRect(m_hwnd, lpRect, TRUE);
    else
        ViewChanged();

    // CONSIDER: one might want to call pOleAdviseHolder->OnDataChanged() here
    // if there was support for IDataObject
}

//=--------------------------------------------------------------------------=
// COleControl::SetControlSize    [callable]
//=--------------------------------------------------------------------------=
// sets the control size. they'll give us the size in pixels.  we've got to
// convert them back to HIMETRIC before passing them on!
//
// Parameters:
//    SIZEL *        - [in] new size
//
// Output:
//    BOOL
//
// Notes:
//
BOOL COleControl::SetControlSize
(
    SIZEL *pSize
)
{
    HRESULT hr;
    SIZEL slHiMetric;

    PixelToHiMetric(pSize, &slHiMetric);
    hr = SetExtent(DVASPECT_CONTENT, &slHiMetric);
    return (FAILED(hr)) ? FALSE : TRUE;
}

//=--------------------------------------------------------------------------=
// COleControl::RecreateControlWindow    [callable]
//=--------------------------------------------------------------------------=
// called by a [subclassed, typically] control to recreate it's control
// window.
//
// Parameters:
//    none
//
// Output:
//    HRESULT
//
// Notes:
//    - NOTE: USE ME EXTREMELY SPARINGLY! THIS IS AN EXTREMELY EXPENSIVE
//      OPERATION!
//
HRESULT COleControl::RecreateControlWindow
(
    void
)
{
    HRESULT hr;
    HWND    hwndPrev;

    // we need to correctly preserve the control's position within the
    // z-order here.
    //
    if (m_hwnd)
        hwndPrev = ::GetWindow(m_hwnd, GW_HWNDPREV);

    // if we're in place active, then we have to deactivate, and reactivate
    // ourselves with the new window ...
    //
    if (m_fInPlaceActive) {

        hr = InPlaceDeactivate();
        RETURN_ON_FAILURE(hr);
        hr = InPlaceActivate((m_fUIActive) ? OLEIVERB_UIACTIVATE : OLEIVERB_INPLACEACTIVATE);
        RETURN_ON_FAILURE(hr);

    } else if (m_hwnd) {
        DestroyWindow(m_hwnd);
        m_hwnd = NULL;
        if (m_hwndReflect) {
            DestroyWindow(m_hwndReflect);
            m_hwndReflect = NULL;
        }

        CreateInPlaceWindow(0, 0, FALSE);
    }

    // restore z-order position
    //
    if (m_hwnd)
        SetWindowPos(m_hwnd, hwndPrev, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE | SWP_NOACTIVATE);

    return m_hwnd ? S_OK : E_FAIL;
}

// from Globals.C. don't need to mutex it here since we only read it.
//
extern HINSTANCE g_hInstResources;

//=--------------------------------------------------------------------------=
// COleControl::GetResourceHandle    [callable]
//=--------------------------------------------------------------------------=
// gets the HINSTANCE of the DLL where the control should get resources
// from.  implemented in such a way to support satellite DLLs.
//
// Output:
//    HINSTANCE
//
// Notes:
//
HINSTANCE COleControl::GetResourceHandle
(
    void
)
{
    if (!g_fSatelliteLocalization)
        return g_hInstance;

    // if we've already got it, then there's not all that much to do.
    // don't need to crit sect this one right here since even if they do fall
    // into the ::GetResourceHandle call, it'll properly deal with things.
    //
    if (g_hInstResources)
        return g_hInstResources;

    // we'll get the ambient localeid from the host, and pass that on to the
    // automation object.
    //
    // crit sect this for apartment threading support.
    //
    EnterCriticalSection(&g_CriticalSection);
    if (!g_fHaveLocale)
        // if we can't get the ambient locale id, then we'll just continue
        // with the globally set up value.
        //
        if (!GetAmbientProperty(DISPID_AMBIENT_LOCALEID, VT_I4, &g_lcidLocale))
            goto Done;

    g_fHaveLocale = TRUE;

  Done:
    LeaveCriticalSection(&g_CriticalSection);
    return ::GetResourceHandle();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\basectl\dwinvers.h ===
#define vszMakeDate	"April 10, 1996\0"
#define vszMakeVers	"Version 2810 - DEBUG - ntfs-f\0\0"
#define vszVersNum	"2810\0"
#define vszVersNumAll	"5.00.2810\0"
#define vusVersNuml2	10
#define vusVersNumf2	28
#define vszCopyright	"Copyright  1987-1996 Microsoft Corp.\0\0"
#define VBA_VERHI	0x50000
#define VBA_VERLO	0x183C
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\basectl\ctlwrap.cpp ===
//=--------------------------------------------------------------------------=
// CtlWrap.Cpp
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// wrappers for various routines that have slightly different implementations
// for windowed and windowless controls.
//
#include "IPServer.H"

#include "CtrlObj.H"


// for ASSERT and FAIL
//
SZTHISFILE

//=--------------------------------------------------------------------------=
// COleControl::OcxGetFocus    [wrapper]
//=--------------------------------------------------------------------------=
// indicates whether or not we have the focus.
//
// Parameters:
//    none
//
// Output:
//    TRUE if we have focus, else false
//
// Notes:
//
BOOL COleControl::OcxGetFocus
(
    void
)
{
    // if we're windowless, the site provides this functionality
    //
    if (m_pInPlaceSiteWndless) {
        return (m_pInPlaceSiteWndless->GetFocus() == S_OK);
    } else {

        // we've got a window.  just let the APIs do our work
        //
        if (m_fInPlaceActive)
            return (GetFocus() == m_hwnd);
        else
            return FALSE;
    }

    // dead code
}

//=--------------------------------------------------------------------------=
// COleControl::OcxGetWindowRect    [wrapper]
//=--------------------------------------------------------------------------=
// returns the current rectangle for this control, and correctly handles
// windowless vs windowed.
//
// Parameters:
//    LPRECT                - [out]  duh.
//
// Output:
//    BOOL                  - false means unexpected.
//
// Notes:
//
BOOL COleControl::OcxGetWindowRect
(
    LPRECT prc
)
{
    // if we're windowless, then we have this information already!
    //
    if (Windowless()) {
        *prc = m_rcLocation;
        return TRUE;
    } else
        return GetWindowRect(m_hwnd, prc);

    // dead code
}

//=--------------------------------------------------------------------------=
// COleControl::OcxDefWindowProc    [wrapper]
//=--------------------------------------------------------------------------=
// default window processing
//
// Parameters:
//    UINT           - [in] duh.
//    WPARAM         - [in] duh.
//    LPARAM         - [in] DUH.
//
// Output:
//    LRESULT
//
// Notes:
//
LRESULT COleControl::OcxDefWindowProc
(
    UINT   msg,
    WPARAM wParam,
    LPARAM lParam
)
{
    LRESULT l;

    // if we're windowless, this is a site provided pointer
    //
    if (m_pInPlaceSiteWndless)
        m_pInPlaceSiteWndless->OnDefWindowMessage(msg, wParam, lParam, &l);
    else
        // we've got a window -- just pass it along
        //
        l = DefWindowProc(m_hwnd, msg, wParam, lParam);

    return l;
}

//=--------------------------------------------------------------------------=
// COleControl::OcxGetDC    [wrapper]
//=--------------------------------------------------------------------------=
// wraps the functionality of GetDC, and correctly handles windowless controls
//
// Parameters:
//    none
//
// Output:
//    HDC            - null means we couldn't get one
//
// Notes:
//    - we don't bother with a bunch of the IOleInPlaceSiteWindowless::GetDc
//      parameters, since the windows GetDC doesn't expose these either. users
//      wanting that sort of fine tuned control can call said routine
//      explicitly
//
HDC COleControl::OcxGetDC
(
    void
)
{
    HDC hdc = NULL;

    // if we're windowless, the site provides this functionality.
    //
    if (m_pInPlaceSiteWndless)
        m_pInPlaceSiteWndless->GetDC(NULL, 0, &hdc);
    else
        hdc = GetDC(m_hwnd);

    return hdc;
}

//=--------------------------------------------------------------------------=
// COleControl::OcxReleaseDC    [wrapper]
//=--------------------------------------------------------------------------=
// releases a DC returned by OcxGetDC
//
// Parameters:
//    HDC             - [in] release me
//
// Output:
//    none
//
// Notes:
//
void COleControl::OcxReleaseDC
(
    HDC hdc
)
{
    // if we're windowless, the site does this for us
    //
    if (m_pInPlaceSiteWndless)
        m_pInPlaceSiteWndless->ReleaseDC(hdc);
    else
        ReleaseDC(m_hwnd, hdc);
}

//=--------------------------------------------------------------------------=
// COleControl::OcxSetCapture    [wrapper]
//=--------------------------------------------------------------------------=
// provides a means for the control to get or release capture.
//
// Parameters:
//    BOOL            - [in] true means take, false release
//
// Output:
//    BOOL            - true means it's yours, false nuh-uh
//
// Notes:
//
BOOL COleControl::OcxSetCapture
(
    BOOL fGrab
)
{
    HRESULT hr;

    // the host does this for us if we're windowless [i'm getting really bored
    // of typing that]
    //
    if (m_pInPlaceSiteWndless) {
        hr = m_pInPlaceSiteWndless->SetCapture(fGrab);
        return (hr == S_OK);
    } else {
        // people shouldn't call this when they're not in-place active, but
        // just in case...
        //
        if (m_fInPlaceActive) {
            SetCapture(m_hwnd);
            return TRUE;
        } else
            return FALSE;
    }

    // dead code
}

//=--------------------------------------------------------------------------=
// COleControl::OcxGetCapture    [wrapper]
//=--------------------------------------------------------------------------=
// tells you whether or not you have the capture.
//
// Parameters:
//    none
//
// Output:
//    BOOL         - true it's yours, false it's not
//
// Notes:
//
BOOL COleControl::OcxGetCapture
(
    void
)
{
    // host does this for windowless dudes
    //
    if (m_pInPlaceSiteWndless)
        return m_pInPlaceSiteWndless->GetCapture() == S_OK;
    else {
        // people shouldn't call this when they're not in-place active, but
        // just in case.
        //
        if (m_fInPlaceActive)
            return GetCapture() == m_hwnd;
        else
            return FALSE;
    }

    // dead code
}

//=--------------------------------------------------------------------------=
// COleControl::OcxInvalidateRect    [wrapper]
//=--------------------------------------------------------------------------=
// invalidates the control's rectangle
//
// Parameters:
//    LPCRECT            - [in] rectangle to invalidate
//    BOOL               - [in] do we erase background first?
//
// Output:
//    BOOL
//
// Notes:
//
BOOL COleControl::OcxInvalidateRect
(
    LPCRECT prcInvalidate,
    BOOL    fErase
)
{
    // if we're windowless, then we need to get the site to do all this for
    // us
    if (m_pInPlaceSiteWndless)
        return m_pInPlaceSiteWndless->InvalidateRect(prcInvalidate, fErase) == S_OK;
    else {
        // otherwise do something different depending on whether or not we're
        // in place active or not
        //
        if (m_fInPlaceActive)
            return InvalidateRect(m_hwnd, prcInvalidate, TRUE);
        else
            ViewChanged();
    }

    return TRUE;
}

//=--------------------------------------------------------------------------=
// COleControl::OcxScrollRect    [wrapper]
//=--------------------------------------------------------------------------=
// does some window scrolling for the control
//
// Parameters:
//    LPCRECT             - [in] region to scroll
//    LPCRECT             - [in] region to clip
//    int                 - [in] dx to scroll
//    int                 - [in] dy to scroll
//
// Output:
//    BOOL
//
// Notes:
//
BOOL COleControl::OcxScrollRect
(
    LPCRECT  prcBounds,
    LPCRECT  prcClip,
    int      dx,
    int      dy
)
{
    // if we're windowless, the site provides this functionality, otherwise
    // APIs do the job
    //
    if (m_pInPlaceSiteWndless)
        return m_pInPlaceSiteWndless->ScrollRect(dx, dy, prcBounds, prcClip) == S_OK;
    else {
        if (m_fInPlaceActive) 
            ScrollWindowEx(m_hwnd, dx, dy, prcBounds, prcClip, NULL, NULL, SW_INVALIDATE);
        else
            return FALSE;
    }

    return TRUE;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\basectl\ctlview.cpp ===
//=--------------------------------------------------------------------------=
// CtlView.Cpp
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// implementation of the IViewObjectEx interface, which is a moderately
// non-trivial bunch of code.
//
#include "IPServer.H"

#include "CtrlObj.H"
#include "Globals.H"
#include "Util.H"

// for ASSERT and FAIL
//
SZTHISFILE

// local functions we're going to find useful
//
HDC _CreateOleDC(DVTARGETDEVICE *ptd);

//=--------------------------------------------------------------------------=
// COleControl::Draw    [IViewObject2]
//=--------------------------------------------------------------------------=
// Draws a representation of an object onto the specified device context. 
//
// Parameters:
//    DWORD                - [in] draw aspect
//    LONG                 - [in] part of object to draw [not relevant]
//    void *               - NULL
//    DVTARGETDEVICE *     - [in] specifies the target device
//    HDC                  - [in] information context for target device
//    HDC                  - [in] target device context
//    LPCRECTL             - [in] rectangle in which the object is drawn
//    LPCRECTL             - [in] window extent and origin for metafiles
//    BOOL (*)(DWORD)      - [in] callback for continuing or cancelling drawing
//    DWORD                - [in] parameter to pass to callback.
//
// Output:
//    HRESULT
//
// Notes:
//    - we support the following OCX 96 extensions
//        a. flicker free drawing [multi-pass drawing]
//        b. pvAspect != NULL for optimized DC handling
//        c. prcBounds == NULL for windowless inplace active objects
//
STDMETHODIMP COleControl::Draw
(
    DWORD            dwDrawAspect,
    LONG             lIndex,
    void            *pvAspect,
    DVTARGETDEVICE  *ptd,
    HDC              hicTargetDevice,
    HDC              hdcDraw,
    LPCRECTL         prcBounds,
    LPCRECTL         prcWBounds,
    BOOL (__stdcall *pfnContinue)(ULONG_PTR dwContinue),
    ULONG_PTR        dwContinue
)
{
    HRESULT hr;
    RECTL rc;
    POINT pVp, pW;
    BOOL  fOptimize = FALSE;
    int iMode;
    BYTE fMetafile = FALSE;
    BYTE fDeleteDC = FALSE;

    // support the aspects required for multi-pass drawing
    //
    switch (dwDrawAspect) {
        case DVASPECT_CONTENT:
        case DVASPECT_OPAQUE:
        case DVASPECT_TRANSPARENT:
            break;
        default:
            return DV_E_DVASPECT;
    }

    // first, have to do a little bit to support printing.
    //
    if (GetDeviceCaps(hdcDraw, TECHNOLOGY) == DT_METAFILE) {

        // We are dealing with a metafile.
        //
        fMetafile = TRUE;

        // If attributes DC is NULL, create one, based on ptd.
        //
        if (!hicTargetDevice) {

            // Does _CreateOleDC have to return an hDC
            // or can it be flagged to return an hIC 
            // for this particular case?
            //
            hicTargetDevice = _CreateOleDC(ptd);
            fDeleteDC = TRUE;
        }
    }

    // check to see if we have any flags passed in the pvAspect parameter.
    //
    if (pvAspect && ((DVASPECTINFO *)pvAspect)->cb == sizeof(DVASPECTINFO))
        fOptimize = (((DVASPECTINFO *)pvAspect)->dwFlags & DVASPECTINFOFLAG_CANOPTIMIZE) ? TRUE : FALSE;

    // if we are windowless, then we just pass this on to the end control code.
    //
    if (m_fInPlaceActive) {

        // give them a rectangle with which to draw
        //
        //ASSERT(!m_fInPlaceActive || !prcBounds, "Inplace active and somebody passed in prcBounds!!!");
        if (prcBounds)
		memcpy(&rc, prcBounds, sizeof(rc));
	else
		memcpy(&rc, &m_rcLocation, sizeof(rc));
    } else {

        // first -- convert the DC back to MM_TEXT mapping mode so that the
        // window proc and OnDraw can share the same painting code.  save
        // some information on it, so we can restore it later [without using
        // a SaveDC/RestoreDC]
        //
        rc = *prcBounds;

        // Don't do anything to hdcDraw if it's a metafile.
        // The control's Draw method must make the appropriate
        // accomodations for drawing to a metafile
        //
        if (!fMetafile) {
            LPtoDP(hdcDraw, (POINT *)&rc, 2);
            SetViewportOrgEx(hdcDraw, 0, 0, &pVp);
            SetWindowOrgEx(hdcDraw, 0, 0, &pW);
            iMode = SetMapMode(hdcDraw, MM_TEXT);
        }
    }

    // prcWBounds is NULL and not used if we are not dealing with a metafile.
    // For metafiles, we pass on rc as *prcBounds, we should also include
    // prcWBounds
    //
    hr = OnDraw(dwDrawAspect, hdcDraw, &rc, prcWBounds, hicTargetDevice, fOptimize);

    // clean up the DC when we're done with it, if appropriate.
    //
    if (!m_fInPlaceActive) {
        SetViewportOrgEx(hdcDraw, pVp.x, pVp.y, NULL);
        SetWindowOrgEx(hdcDraw, pW.x, pW.y, NULL);
        SetMapMode(hdcDraw, iMode);
    }

    // if we created a dc, blow it away now
    //
    if (fDeleteDC) DeleteDC(hicTargetDevice);
    return hr;
}

//=--------------------------------------------------------------------------=
// COleControl::DoSuperClassPaint
//=--------------------------------------------------------------------------=
// design time painting of a subclassed control.
//
// Parameters:
//    HDC                - [in]  dc to work with
//    LPCRECTL           - [in]  rectangle to paint to.  should be in pixels
//
// Output:
//    HRESULT
//
// Notes:
//
HRESULT COleControl::DoSuperClassPaint
(
    HDC      hdc,
    LPCRECTL prcBounds
)
{
    HWND hwnd;
    RECT rcClient;
    int  iMapMode;
    POINT ptWOrg, ptVOrg;
    SIZE  sWOrg, sVOrg;

    // make sure we have a window.
    //
    hwnd = CreateInPlaceWindow(0,0, FALSE);
    if (!hwnd)
        return E_FAIL;

    GetClientRect(hwnd, &rcClient);

    // set up the DC for painting.  this code largely taken from the MFC CDK
    // DoSuperClassPaint() fn.  doesn't always get things like command
    // buttons quite right ...
    //
    // NOTE: there is a windows 95 problem in which the font instance manager
    // will leak a bunch of bytes in the global GDI pool whenever you 
    // change your extents and have an active font.  this code gets around
    // this for on-screen cases, but not for printing [which shouldn't be
    // too serious, because you're not often changing your control size and
    // printing rapidly in succession]
    //
    if ((rcClient.right - rcClient.left != prcBounds->right - prcBounds->left)
        && (rcClient.bottom - rcClient.top != prcBounds->bottom - prcBounds->top)) {

        iMapMode = SetMapMode(hdc, MM_ANISOTROPIC);
        SetWindowExtEx(hdc, rcClient.right, rcClient.bottom, &sWOrg);
        SetViewportExtEx(hdc, prcBounds->right - prcBounds->left, prcBounds->bottom - prcBounds->top, &sVOrg);
    }

    SetWindowOrgEx(hdc, 0, 0, &ptWOrg);
    SetViewportOrgEx(hdc, prcBounds->left, prcBounds->top, &ptVOrg);

#if STRICT
    CallWindowProc((WNDPROC)SUBCLASSWNDPROCOFCONTROL(m_ObjectType), hwnd, (g_fSysWin95Shell) ? WM_PRINT : WM_PAINT, (WPARAM)hdc, (LPARAM)(g_fSysWin95Shell ? PRF_CHILDREN | PRF_CLIENT : 0));
#else
    CallWindowProc((FARPROC)SUBCLASSWNDPROCOFCONTROL(m_ObjectType), hwnd, (g_fSysWin95Shell) ? WM_PRINT : WM_PAINT, (WPARAM)hdc, (LPARAM)(g_fSysWin95Shell ? PRF_CHILDREN | PRF_CLIENT : 0));
#endif // STRICT

    return S_OK;
}


//=--------------------------------------------------------------------------=
// COleControl::GetColorSet    [IViewObject2]
//=--------------------------------------------------------------------------=
// Returns the logical palette that the control will use for drawing in its
// IViewObject::Draw method with the corresponding parameters.
//
// Parameters:
//    DWORD                - [in]  how the object is to be represented
//    LONG                 - [in]  part of the object to draw [not relevant]
//    void *               - NULL
//    DVTARGETDEVICE *     - [in]  specifies the target device
//    HDC                  - [in]  information context for the target device
//    LOGPALETTE **        - [out] where to put palette
//
// Output:
//    S_OK                 - Control has a palette, and returned it through the out param.
//    S_FALSE              - Control does not currently have a palette.
//    E_NOTIMPL            - Control will never have a palette so optimize handling of this control.
//
// Notes:
//
STDMETHODIMP COleControl::GetColorSet
(
    DWORD            dwDrawAspect,
    LONG             lindex,
    void            *IgnoreMe,
    DVTARGETDEVICE  *ptd,
    HDC              hicTargetDevice,
    LOGPALETTE     **ppColorSet
)
{
    if (dwDrawAspect != DVASPECT_CONTENT)
        return DV_E_DVASPECT;

    *ppColorSet = NULL;
    return (OnGetPalette(hicTargetDevice, ppColorSet)) ? ((*ppColorSet) ? S_OK : S_FALSE) : E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// COleControl::Freeze    [IViewObject2]
//=--------------------------------------------------------------------------=
// Freezes a certain aspect of the object's presentation so that it does not
// change until the IViewObject::Unfreeze method is called.
//
// Parameters:
//    DWORD            - [in] aspect
//    LONG             - [in] part of object to draw
//    void *           - NULL
//    DWORD *          - [out] for Unfreeze
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::Freeze
(
    DWORD   dwDrawAspect,
    LONG    lIndex,
    void   *IgnoreMe,
    DWORD  *pdwFreeze
)
{
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// COleControl::Unfreeze    [IVewObject2]
//=--------------------------------------------------------------------------=
// Releases a previously frozen drawing. The most common use of this method
// is for banded printing.
//
// Parameters:
//    DWORD        - [in] cookie from freeze
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::Unfreeze
(
    DWORD dwFreeze
)
{
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// COleControl::SetAdvise    [IViewObject2]
//=--------------------------------------------------------------------------=
// Sets up a connection between the control and an advise sink so that the
// advise sink can be notified about changes in the control's view.
//
// Parameters:
//    DWORD            - [in] aspect
//    DWORD            - [in] info about the sink
//    IAdviseSink *    - [in] the sink
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::SetAdvise
(
    DWORD        dwAspects,
    DWORD        dwAdviseFlags,
    IAdviseSink *pAdviseSink
)
{
    // if it's not a content aspect, we don't support it.
    //
    if (!(dwAspects & DVASPECT_CONTENT)) {
        return DV_E_DVASPECT;
    }

    // set up some flags  [we gotta stash for GetAdvise ...]
    //
    m_fViewAdvisePrimeFirst = (dwAdviseFlags & ADVF_PRIMEFIRST) ? TRUE : FALSE;
    m_fViewAdviseOnlyOnce = (dwAdviseFlags & ADVF_ONLYONCE) ? TRUE : FALSE;

    RELEASE_OBJECT(m_pViewAdviseSink);
    m_pViewAdviseSink = pAdviseSink;
    ADDREF_OBJECT(m_pViewAdviseSink);

    // prime them if they want it [we need to store this so they can get flags later]
    //
    if (m_fViewAdvisePrimeFirst)
        ViewChanged();

    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::GetAdvise    [IViewObject2]
//=--------------------------------------------------------------------------=
// Retrieves the existing advisory connection on the control if there is one.
// This method simply returns the parameters used in the most recent call to
// the IViewObject::SetAdvise method.
//
// Parameters:
//    DWORD *            - [out]  aspects
//    DWORD *            - [out]  advise flags
//    IAdviseSink **     - [out]  the sink
//
// Output:
//    HRESULT
//
// Notes;
//
STDMETHODIMP COleControl::GetAdvise
(
    DWORD        *pdwAspects,
    DWORD        *pdwAdviseFlags,
    IAdviseSink **ppAdviseSink
)
{
    // if they want it, give it to them
    //
    if (pdwAspects)
        *pdwAspects = DVASPECT_CONTENT;

    if (pdwAdviseFlags) {
        *pdwAdviseFlags = 0;
        if (m_fViewAdviseOnlyOnce) *pdwAdviseFlags |= ADVF_ONLYONCE;
        if (m_fViewAdvisePrimeFirst) *pdwAdviseFlags |= ADVF_PRIMEFIRST;
    }

    if (ppAdviseSink) {
        *ppAdviseSink = m_pViewAdviseSink;
        ADDREF_OBJECT(*ppAdviseSink);
    }

    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::GetExtent    [IViewObject2]
//=--------------------------------------------------------------------------=
// Returns the size that the control will be drawn on the
// specified target device.
//
// Parameters:
//    DWORD            - [in] draw aspect
//    LONG             - [in] part of object to draw
//    DVTARGETDEVICE * - [in] information about target device
//    LPSIZEL          - [out] where to put the size
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::GetExtent
(
    DWORD           dwDrawAspect,
    LONG            lindex,
    DVTARGETDEVICE *ptd,
    LPSIZEL         psizel
)
{
    // we already have an implementation of this [from IOleObject]
    //
    return GetExtent(dwDrawAspect, psizel);
}


//=--------------------------------------------------------------------------=
// COleControl::OnGetPalette    [overridable]
//=--------------------------------------------------------------------------=
// called when the host wants palette information.  ideally, people should use
// this sparingly and carefully.
//
// Parameters:
//    HDC            - [in]  HIC for the target device
//    LOGPALETTE **  - [out] where to put the palette
//
// Output:
//    BOOL           - TRUE means we processed it, false means nope.
//
// Notes:
//
BOOL COleControl::OnGetPalette
(
    HDC          hicTargetDevice,
    LOGPALETTE **ppColorSet
)
{
    return FALSE;
}


//=--------------------------------------------------------------------------=
// COleControl::GetRect    [IViewObjectEx]
//=--------------------------------------------------------------------------=
// returns a rectnagle describing a given drawing aspect
//
// Parameters:
//    DWORD             - [in]  aspect
//    LPRECTL           - [out] region rectangle
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::GetRect
(
    DWORD    dvAspect,
    LPRECTL  prcRect
)
{
    RECTL rc;
    BOOL  f;

    // call the user routine and let them return the size
    //
    f = OnGetRect(dvAspect, &rc);
    if (!f) return DV_E_DVASPECT;

    // transform these dudes.
    //
    PixelToHiMetric((LPSIZEL)&rc, (LPSIZEL)prcRect);
    PixelToHiMetric((LPSIZEL)((LPBYTE)&rc + sizeof(SIZEL)), (LPSIZEL)((LPBYTE)prcRect + sizeof(SIZEL)));

    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::GetViewStatus    [IViewObjectEx]
//=--------------------------------------------------------------------------=
// returns information about the opactiy of the object and what drawing
// aspects are supported
//
// Parameters:
//    DWORD *            - [out] the status
//
/// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::GetViewStatus
(
    DWORD *pdwStatus
)
{
    // depending on the flag in the CONTROLOBJECTINFO structure, indicate our
    // transparency vs opacity.
    // OVERRIDE:  controls that wish to support multi-pass drawing should
    // override this routine and return, in addition to the flags indication
    // opacity, flags indicating what sort of drawing aspects they support.
    //
    *pdwStatus = FCONTROLISOPAQUE(m_ObjectType) ? VIEWSTATUS_OPAQUE : 0;
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::QueryHitPoint    [IViewObjectEx]
//=--------------------------------------------------------------------------=
// indicates whether a point is within a given aspect of an object.
//
// Parameters:
//    DWORD                - [in]  aspect
//    LPCRECT              - [in]  Bounds rectangle
//    POINT                - [in]  hit location client coordinates
//    LONG                 - [in]  what the container considers close
//    DWORD *              - [out] info about the hit
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::QueryHitPoint
(
    DWORD    dvAspect,
    LPCRECT  prcBounds,
    POINT    ptLocation,
    LONG     lCloseHint,
    DWORD   *pdwHitResult
)
{
    // OVERRIDE: override me if you want to provide additional [non-opaque]
    // functionality
    //
    if (dvAspect != DVASPECT_CONTENT)
        return DV_E_DVASPECT;

    *pdwHitResult = PtInRect(prcBounds, ptLocation) ? HITRESULT_HIT : HITRESULT_OUTSIDE;
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::QueryHitRect    [IViewObjectEx]
//=--------------------------------------------------------------------------=
// indicates wheter any point in a rectangle is within a given drawing aspect
// of an object.
//
// Parameters:
//    DWORD            - [in]  aspect
//    LPCRECT          - [in]  bounds
//    LPCRECT          - [in]  location
//    LONG             - [in]  what host considers close
//    DWORD *          - [out] hit result
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::QueryHitRect
(
    DWORD     dvAspect,
    LPCRECT   prcBounds,
    LPCRECT   prcLocation,
    LONG      lCloseHint,
    DWORD    *pdwHitResult
)
{
    RECT rc;

    // OVERRIDE: override this for additional behaviour
    //
    if (dvAspect != DVASPECT_CONTENT)
        return DV_E_DVASPECT;

    *pdwHitResult = IntersectRect(&rc, prcBounds, prcLocation) ? HITRESULT_HIT : HITRESULT_OUTSIDE;
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::GetNaturalExtent    [IViewObjectEx]
//=--------------------------------------------------------------------------=
// supports two types of control sizing, content and integral.
//
// Parameters:
//    DWORD            - [in]  aspect
//    LONG             - [in]  index
//    DVTARGETDEVICE * - [in]  target device information
//    HDC              - [in]  HIC
//    DVEXTENTINFO *   - [in]  sizing data
//    LPSIZEL          - [out] sizing data retunred by control
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::GetNaturalExtent
(
    DWORD           dvAspect,
    LONG            lIndex,
    DVTARGETDEVICE *ptd,
    HDC             hicTargetDevice,
    DVEXTENTINFO   *pExtentInfo,
    LPSIZEL         pSizel
)
{
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// COleControl::OnGetRect    [overridable
//=--------------------------------------------------------------------------=
// returns our rectangle
//
// Parameters:
//    DWORD              - [in]  aspect they want the rect for
//    RECTL *            - [out] the rectangle that matches this aspect
//
// Output:
//    BOOL               - false means we don't like the aspect
//
// Notes:
//
BOOL COleControl::OnGetRect
(
    DWORD   dvAspect,
    RECTL  *pRect
)
{
    // by default, we only support content drawing.
    //
    if (dvAspect != DVASPECT_CONTENT)
        return FALSE;

    // just give them our bounding rectangle
    //
    *((LPRECT)pRect) = m_rcLocation;
    return TRUE;
}

//=--------------------------------------------------------------------------=
// _CreateOleDC
//=--------------------------------------------------------------------------=
// creates an HDC given a DVTARGETDEVICE structure.
//
// Parameters:
//    DVTARGETDEVICE *              - [in] duh.
//
// Output:
//    HDC
//
// Notes:
//
HDC _CreateOleDC
(
    DVTARGETDEVICE *ptd
)
{
    LPDEVMODEW   pDevModeW;
    DEVMODEA     DevModeA, *pDevModeA;
    LPOLESTR     lpwszDriverName;
    LPOLESTR     lpwszDeviceName;
    LPOLESTR     lpwszPortName;
    HDC          hdc;

    // return screen DC for NULL target device
    //
    if (!ptd)
        return CreateDC("DISPLAY", NULL, NULL, NULL);

    if (ptd->tdExtDevmodeOffset == 0)
        pDevModeW = NULL;
    else
        pDevModeW = (LPDEVMODEW)((LPSTR)ptd + ptd->tdExtDevmodeOffset);

    lpwszDriverName = (LPOLESTR)((BYTE*)ptd + ptd->tdDriverNameOffset);
    lpwszDeviceName = (LPOLESTR)((BYTE*)ptd + ptd->tdDeviceNameOffset);
    lpwszPortName   = (LPOLESTR)((BYTE*)ptd + ptd->tdPortNameOffset);

    MAKE_ANSIPTR_FROMWIDE(pszDriverName, lpwszDriverName);
    MAKE_ANSIPTR_FROMWIDE(pszDeviceName, lpwszDeviceName);
    MAKE_ANSIPTR_FROMWIDE(pszPortName,   lpwszPortName);



    if (pDevModeW) {
        WideCharToMultiByte(CP_ACP, 0, pDevModeW->dmDeviceName, -1, (LPSTR)DevModeA.dmDeviceName, CCHDEVICENAME, NULL, NULL);
	memcpy(&DevModeA.dmSpecVersion, &pDevModeW->dmSpecVersion,
		offsetof(DEVMODEA, dmFormName) - offsetof(DEVMODEA, dmSpecVersion));
        WideCharToMultiByte(CP_ACP, 0, pDevModeW->dmFormName, -1, (LPSTR)DevModeA.dmFormName, CCHFORMNAME, NULL, NULL);
	memcpy(&DevModeA.dmLogPixels, &pDevModeW->dmLogPixels, sizeof(DEVMODEA) - offsetof(DEVMODEA, dmLogPixels));
        if (pDevModeW->dmDriverExtra) {
            pDevModeA = (DEVMODEA *)HeapAlloc(g_hHeap, 0, sizeof(DEVMODEA) + pDevModeW->dmDriverExtra);
            if (!pDevModeA) return NULL;
            memcpy(pDevModeA, &DevModeA, sizeof(DEVMODEA));
            memcpy(pDevModeA + 1, pDevModeW + 1, pDevModeW->dmDriverExtra);
        } else
            pDevModeA = &DevModeA;

	DevModeA.dmSize = sizeof(DEVMODEA);
    } else
        pDevModeA = NULL;

    hdc = CreateDC(pszDriverName, pszDeviceName, pszPortName, pDevModeA);
    if (pDevModeA != &DevModeA) HeapFree(g_hHeap, 0, pDevModeA);
    return hdc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\basectl\extobj.cpp ===
////
//
// CExpandoObject
//
// Notes:
// 1) If the LCID passed to this object changes from call to call we are in trouble. This is hard to
// create an ASSERT for because it would require memoizing the LCID at some point.
// 2) There is a maximum on the number of slots allowed (this is currently 2048)
// 3) This is not a thread safe structure.
// 4) I'm currently using malloc -- this is probably wrong for IE.
//

// for ASSERT and FAIL
//

#include "IPServer.H"
#include "LocalSrv.H"
#include "Globals.H"
#include "extobj.h"
#include "Util.H"
#define GTR_MALLOC(size)  CoTaskMemAlloc(size)
#define GTR_FREE(pv) CoTaskMemFree(pv)

SZTHISFILE
////
//
// Private Utility Functions
//
////

////
//
// Get the ID of a Name
//

HRESULT CExpandoObject::GetIDOfName(LPOLESTR name, LCID lcid, BOOL caseSensitive, DISPID* id)
{
	HRESULT hr = NOERROR;
	ULONG hash = LHashValOfName(lcid, name);
	UINT hashIndex = hash % kSlotHashTableSize;
	CExpandoObjectSlot* slot;

	for (slot=GetHashTableHead(hashIndex); slot!=NULL; slot=slot->Next(m_slots))
	{
		if (slot->CompareName(name, hash, caseSensitive))
		{
			*id = slot->DispId();
			goto Exit;
		}
	}

	// not found
	hr = DISP_E_UNKNOWNNAME;
	*id = DISPID_UNKNOWN;

Exit:
	return hr;
}

////
//
// Add a new slot to the object
//

HRESULT CExpandoObject::AddSlot(LPOLESTR name, LCID lcid, BOOL caseSensitive, VARIANT* initialValue, DISPID* id)
{
	HRESULT hr = NOERROR;
	ULONG hash = LHashValOfName(lcid, name);
	UINT hashIndex = hash % kSlotHashTableSize;
	CExpandoObjectSlot* slot;
	DISPID	dispId;

	// first check if the slot exists
	for (slot=GetHashTableHead(hashIndex); slot!=NULL; slot=slot->Next(m_slots))
	{
		// bail if the name matches
		if (slot->CompareName(name, hash, caseSensitive))
		{
			hr = E_INVALIDARG;
			goto Exit;
		}
	}

	// allocate a slot
	dispId = (DISPID) m_totalSlots;
	slot = AllocSlot();
	if (slot == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto Exit;
	}

	// Initialize it
	// BUGBUG robwell 8May96 If this fails and the initialValue is not VT_EMTPY or VT_NULL
	// there in no cleanup code.
	hr = slot->Init(name, lcid, dispId + m_dispIdBase, initialValue);
	if (FAILED(hr))
	{
		// free the slot and dispId
		m_totalSlots -= 1;
		goto Exit;
	}

	// intern the slot into the proper hash table
	slot->Insert(m_slots, m_hashTable[hashIndex]);

	// set the DISPID return value
	*id = slot->DispId();

Exit:
	return hr;
}

////
//
// Slot allocation
//
// Because slots are never freed there is no free method
//

CExpandoObjectSlot* CExpandoObject::AllocSlot()
{
	// limit on the number of slots
	if (m_totalSlots >= kMaxTotalSlots)
		return NULL;

	// do we need to realloc the array?
	if (m_totalSlots == m_slotTableSize)
	{
		UINT i;
		UINT newSize;
		CExpandoObjectSlot* newSlots;

		// allocate twice as many slots unless first time around
		if (m_slotTableSize == 0)
			newSize = kInitialSlotTableSize;
		else
			newSize = m_slotTableSize * 2;

		// allocate the space for the slots
		newSlots = (CExpandoObjectSlot*) GTR_MALLOC(sizeof(CExpandoObjectSlot)*newSize);
		if (newSlots == NULL)
			return NULL;

		// copy the old values if the old m_slots is not NULL
		if (m_slots)
		{
			// copy the slots
			memcpy(newSlots, m_slots, sizeof(CExpandoObjectSlot)*m_totalSlots);
			// free the old values
			GTR_FREE(m_slots);
		}

		// construct all of the unused slots
		for (i=m_totalSlots; i<newSize; ++i)
			newSlots[i].Construct();

		// make the new array the new table and fix the total size
		m_slots = newSlots;
		m_slotTableSize = newSize;
	}

	// return a pointer to the slot and bump the totalSlots count
	return &m_slots[m_totalSlots++];
}

////
//
// Free all of the slots
//

void CExpandoObject::FreeAllSlots()
{
	UINT i;
	UINT initedSlotCount;
	CExpandoObjectSlot* slots;

	// first clear the hash table
	ClearHashTable();

	// detach the slots
	slots = m_slots;
	initedSlotCount = m_totalSlots;

	// clear the object info
	m_totalSlots = 0;
	m_slotTableSize = 0;
	m_slots = NULL;

	// only need to destruct those slots in use
	for (i=0; i<initedSlotCount; ++i)
		slots[i].Destruct();

	// free the storage
	if (slots)
		GTR_FREE(slots);
}



////
//
// IDispatch Methods
//
////

HRESULT CExpandoObject::GetTypeInfoCount(UINT *pctinfo)
{
	*pctinfo = 0;
	return NOERROR;
}

HRESULT CExpandoObject::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo)
{
	*pptinfo = NULL;
	return E_NOTIMPL;
}

HRESULT CExpandoObject::GetIDsOfNames(
	REFIID riid,
	LPOLESTR *prgpsz,
	UINT cpsz,
	LCID lcid,
	DISPID *prgdispid
)
{
	HRESULT hr;

	if (IID_NULL != riid)
		return DISP_E_UNKNOWNINTERFACE;

	// First see if the outer object knows about the name
	if (m_pdisp)
	{
		hr = m_pdisp->GetIDsOfNames(
			riid,
			prgpsz,
			cpsz,
			lcid,
			prgdispid);

		// if so, just return
		if (SUCCEEDED(hr))
			return hr;
	}

	// Otherwise look on our expanded properties

	if (cpsz == 0)
		return NOERROR;

	// get the ids for the name
	hr = GetIDOfName(prgpsz[0], lcid, FALSE, &prgdispid[0]);

	// clear the rest of the array
	for (unsigned int i = 1; i < cpsz; i++)
	{
		if (SUCCEEDED(hr))
			hr = DISP_E_UNKNOWNNAME;
		prgdispid[i] = DISPID_UNKNOWN;
	}

	return hr;
}

HRESULT CExpandoObject::Invoke(
	DISPID dispID,
	REFIID riid,
	LCID lcid,
	WORD wFlags,
	DISPPARAMS *pdispparams,
	VARIANT *pvarRes,
	EXCEPINFO *pexcepinfo,
	UINT *puArgErr
)
{
	if (IID_NULL != riid)
		return DISP_E_UNKNOWNINTERFACE;

	HRESULT hr;

	// First try the outer object's invoke
	if (m_pdisp)
	{
		hr = m_pdisp->Invoke(
				dispID,
				riid,
				lcid,
				wFlags,
				pdispparams,
				pvarRes,
				pexcepinfo,
				puArgErr
		);

		// If that succeeded, we're done
		if (SUCCEEDED(hr))
			return hr;
	}
	
	// Otherwise, try the expando object's invoke	
	if (NULL != puArgErr)
		*puArgErr = 0;

	if (wFlags & DISPATCH_PROPERTYGET)
	{
		if (NULL == pvarRes)
			return NOERROR;

		if (NULL != pdispparams && 0 != pdispparams->cArgs)
			return E_INVALIDARG;

		// clear the result slot
		pvarRes->vt = VT_EMPTY;
		return GetSlot(dispID, pvarRes);
	}

	if (wFlags & (DISPATCH_PROPERTYPUT | DISPATCH_PROPERTYPUTREF))
	{
		if (NULL == pdispparams
		|| 1 != pdispparams->cArgs
		|| 1 != pdispparams->cNamedArgs
		|| DISPID_PROPERTYPUT != pdispparams->rgdispidNamedArgs[0]
		)
			return DISP_E_PARAMNOTOPTIONAL;

		return SetSlot(dispID, &pdispparams->rgvarg[0]);
	}

	return DISP_E_MEMBERNOTFOUND;
}

////
//
// IDispatchEx methods
//
////

// Get dispID for names, with options
HRESULT STDMETHODCALLTYPE CExpandoObject::GetIDsOfNamesEx(
	REFIID riid,
	LPOLESTR *prgpsz,
	UINT cpsz,
	LCID lcid,
	DISPID *prgid,
	DWORD grfdex
)
{
	HRESULT hr;
	BOOL caseSensitive = ((grfdex & fdexCaseSensitive) != 0);


	// First see if the outer object knows about the name
	if (m_pdisp)
	{
		hr = m_pdisp->GetIDsOfNames(
			riid,
			prgpsz,
			cpsz,
			lcid,
			prgid);

		// if so, just return
		if (SUCCEEDED(hr))
			return hr;
	}


	if (IID_NULL != riid)
		return DISP_E_UNKNOWNINTERFACE;

	if (cpsz == 0)
		return NOERROR;

	// check the array arguments
	if (prgpsz == NULL || prgid == NULL)
		return E_INVALIDARG;

	// get the id from the name
	hr = GetIDOfName(prgpsz[0], lcid, caseSensitive, &prgid[0]);

	// create the slot?
	if (hr == DISP_E_UNKNOWNNAME && (grfdex & fdexDontCreate) == 0)
	{
		VARIANT initialValue;

		if (grfdex & fdexInitNull)
			initialValue.vt = VT_NULL;
		else
			initialValue.vt = VT_EMPTY;

		hr = AddSlot(prgpsz[0], lcid, caseSensitive, &initialValue, &prgid[0]);
	}

	// clear the rest of the array
	for (unsigned int i = 1; i < cpsz; i++)
	{
		hr = DISP_E_UNKNOWNNAME;
		prgid[i] = DISPID_UNKNOWN;
	}

	return hr;
}

// Enumerate dispIDs and their associated "names".
// Returns S_FALSE if the enumeration is done, NOERROR if it's not, an
// error code if the call fails.
HRESULT STDMETHODCALLTYPE CExpandoObject::GetNextDispID(
	DISPID id,
	DISPID *pid,
	BSTR *pbstrName
)
{
	HRESULT hr;
	CExpandoObjectSlot* slot;

	// check the outgoing parameters
	if (pid == NULL || pbstrName == NULL)
		return E_INVALIDARG;

	// set to the default failure case
	*pid = DISPID_UNKNOWN;
	*pbstrName = NULL;

	// get the next slot
	hr = Next(id, slot);
	if (hr == NOERROR)
	{
		BSTR name;

		// allocate the result string
		name = SysAllocString(slot->Name());
		if (name == NULL)
			return E_OUTOFMEMORY;

		// fill in the outgoing parameters
		*pid = slot->DispId();
		*pbstrName = name;
	}

	return hr;
}

// Copy all of the expando-object properties from obj
HRESULT
CExpandoObject::CloneProperties(CExpandoObject& obj)
{
    // BUGBUG  PhilBo
    // The initialization code below is copied from the default constructor.
    // This should be factored out into a shared method.

	// Copy each of the properties from the original object
    HRESULT hr = S_OK;
    DISPID dispid = 0;
    BSTR bstrName = NULL;

    while (obj.GetNextDispID(dispid, &dispid, &bstrName) == S_OK)
    {
        // Get the value of the property from the original object
        VARIANT varResult;
        DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};
        VariantInit(&varResult);

        hr = obj.Invoke(
		        dispid,
		        IID_NULL,
		        LOCALE_SYSTEM_DEFAULT,
		        DISPATCH_PROPERTYGET,
		        &dispparamsNoArgs, &varResult, NULL, NULL);

        ASSERT(SUCCEEDED(hr), "");
        if (FAILED(hr))
            continue;

        // Set the property on the new object
        DISPID dispidNew = 0;
	    hr = GetIDsOfNamesEx(IID_NULL, &bstrName, 1, LOCALE_SYSTEM_DEFAULT,
		    &dispidNew, 0);

        ASSERT(SUCCEEDED(hr), "");
        if (FAILED(hr))
            continue;

        DISPPARAMS dispparams;
        dispparams.rgvarg = &varResult;

        DISPID rgdispid[] = {DISPID_PROPERTYPUT};
        dispparams.rgdispidNamedArgs = rgdispid;
        dispparams.cArgs = 1;
        dispparams.cNamedArgs = 1;

        hr = Invoke(
		    dispidNew,
		    IID_NULL,
		    LOCALE_SYSTEM_DEFAULT,
		    DISPATCH_PROPERTYPUT,
		    &dispparams, NULL, NULL, NULL);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\basectl\debug.cpp ===
//=--------------------------------------------------------------------------=
// Debug.Cpp
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains various methods that will only really see any use in DEBUG builds
//


#include "IPServer.H"
#include <stdlib.h>

#ifdef DEBUG

//=--------------------------------------------------------------------------=
// Private Constants
//---------------------------------------------------------------------------=
//
static const char szFormat[]  = "%s\nFile %s, Line %d";
static const char szFormat2[] = "%s\n%s\nFile %s, Line %d";

#define _SERVERNAME_ "ActiveX Framework"

static const char szTitle[]  = _SERVERNAME_ " Assertion  (Abort = UAE, Retry = INT 3, Ignore = Continue)";


//=--------------------------------------------------------------------------=
// Local functions
//=--------------------------------------------------------------------------=
int NEAR _IdMsgBox(LPSTR pszText, LPCSTR pszTitle, UINT mbFlags);

//=--------------------------------------------------------------------------=
// DisplayAssert
//=--------------------------------------------------------------------------=
// Display an assert message box with the given pszMsg, pszAssert, source
// file name, and line number. The resulting message box has Abort, Retry,
// Ignore buttons with Abort as the default.  Abort does a FatalAppExit;
// Retry does an int 3 then returns; Ignore just returns.
//
VOID DisplayAssert
(
    LPSTR	 pszMsg,
    LPSTR	 pszAssert,
    LPSTR	 pszFile,
    UINT	 line
)
{
    char	szMsg[250];
    LPSTR	lpszText;

    lpszText = pszMsg;		// Assume no file & line # info

    // If C file assert, where you've got a file name and a line #
    //
    if (pszFile) {

        // Then format the assert nicely
        //
        wsprintf(szMsg, szFormat, (pszMsg&&*pszMsg) ? pszMsg : pszAssert, pszFile, line);
        lpszText = szMsg;
    }

    // Put up a dialog box
    //
    switch (_IdMsgBox(lpszText, szTitle, MB_ICONHAND|MB_ABORTRETRYIGNORE|MB_SYSTEMMODAL)) {
        case IDABORT:
            FatalAppExit(0, lpszText);
            return;

        case IDRETRY:
            // call the win32 api to break us.
            //
            DebugBreak();
            return;
    }

    return;
}


//=---------------------------------------------------------------------------=
// Beefed-up version of WinMessageBox.
//=---------------------------------------------------------------------------=
//
int NEAR _IdMsgBox
(
    LPSTR	pszText,
    LPCSTR	pszTitle,
    UINT	mbFlags
)
{
    HWND hwndActive;
    int  id;

    hwndActive = GetActiveWindow();

    id = MessageBox(hwndActive, pszText, pszTitle, mbFlags);

    return id;
}


#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\basectl\globals.cpp ===
//=--------------------------------------------------------------------------=
// Globals.C
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains global variables and strings and the like that just don't fit
// anywhere else.
//
#include "IPServer.H"

//=--------------------------------------------------------------------------=
// support for licensing
//
BOOL g_fMachineHasLicense;
BOOL g_fCheckedForLicense;

//=--------------------------------------------------------------------------=
// does our server have a type library?
//
BOOL g_fServerHasTypeLibrary = TRUE;

//=--------------------------------------------------------------------------=
// our instance handles
//
HINSTANCE    g_hInstance;
HINSTANCE    g_hInstResources;
VARIANT_BOOL g_fHaveLocale;

//=--------------------------------------------------------------------------=
// our global memory allocator and global memory pool
//
HANDLE   g_hHeap;

//=--------------------------------------------------------------------------=
// apartment threading support.
//
CRITICAL_SECTION    g_CriticalSection;

//=--------------------------------------------------------------------------=
// global parking window for parenting various things.
//
HWND     g_hwndParking;

//=--------------------------------------------------------------------------=
// system information
//
BOOL    g_fSysWin95;                    // we're under Win95 system, not just NT SUR
BOOL    g_fSysWinNT;                    // we're under some form of Windows NT
BOOL    g_fSysWin95Shell;               // we're under Win95 or Windows NT SUR { > 3/51)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\basectl\proppage.cpp ===
//=--------------------------------------------------------------------------=
// PropPage.Cpp
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// implementation of CPropertyPage object.
//
#include "IPServer.H"
#include "PropPage.H"
#include "Util.H"
#include "Globals.H"

// for ASSERT and FAIL
//
SZTHISFILE

// this variable is used to pass the pointer to the object to the hwnd.
//
static CPropertyPage *s_pLastPageCreated;

//=--------------------------------------------------------------------------=
// CPropertyPage::CPropertyPage
//=--------------------------------------------------------------------------=
// constructor.
//
// Parameters:
//    IUnknown *          - [in] controlling unknown
//    int                 - [in] object type.
//
// Notes:
//
#pragma warning(disable:4355)  // using 'this' in constructor
CPropertyPage::CPropertyPage
(
    IUnknown         *pUnkOuter,
    int               iObjectType
)
: CUnknownObject(pUnkOuter, this), m_ObjectType(iObjectType)
{
    // initialize various dudes.
    //
    m_pPropertyPageSite = NULL;
    m_hwnd = NULL;
    m_fDirty = FALSE;
    m_fActivated = FALSE;
    m_cObjects = 0;
}
#pragma warning(default:4355)  // using 'this' in constructor


//=--------------------------------------------------------------------------=
// CPropertyPage::~CPropertyPage
//=--------------------------------------------------------------------------=
// destructor.
//
// Notes:
//
CPropertyPage::~CPropertyPage()
{
    // clean up our window.
    //
    if (m_hwnd) {
        SetWindowLongPtr(m_hwnd, GWLP_USERDATA, -1);
        DestroyWindow(m_hwnd);
    }

    // release all the objects we're holding on to.
    //
    m_ReleaseAllObjects();

    // release the site
    //
    QUICK_RELEASE(m_pPropertyPageSite);
}

//=--------------------------------------------------------------------------=
// CPropertyPage::InternalQueryInterface
//=--------------------------------------------------------------------------=
// we support IPP and IPP2.
//
// Parameters:
//    REFIID        - [in]  interface they want
//    void **       - [out] where they want to put the resulting object ptr.
//
// Output:
//    HRESULT       - S_OK, E_NOINTERFACE
//
// Notes:
//
HRESULT CPropertyPage::InternalQueryInterface
(
    REFIID  riid,
    void  **ppvObjOut
)
{
    IUnknown *pUnk;

    *ppvObjOut = NULL;

    if (DO_GUIDS_MATCH(IID_IPropertyPage, riid)) {
        pUnk = (IUnknown *)this;
    } else if (DO_GUIDS_MATCH(IID_IPropertyPage2, riid)) {
        pUnk = (IUnknown *)this;
    } else {
        return CUnknownObject::InternalQueryInterface(riid, ppvObjOut);
    }

    pUnk->AddRef();
    *ppvObjOut = (void *)pUnk;
    return S_OK;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::SetPageSite    [IPropertyPage]
//=--------------------------------------------------------------------------=
// the initialization function for a property page through which the page
// receives an IPropertyPageSite pointer.
//
// Parameters:
//    IPropertyPageSite *        - [in] new site.
//
// Output:
//    HRESULT
//
// Notes;
//
STDMETHODIMP CPropertyPage::SetPageSite
(
    IPropertyPageSite *pPropertyPageSite
)
{
    RELEASE_OBJECT(m_pPropertyPageSite);
    m_pPropertyPageSite = pPropertyPageSite;
    ADDREF_OBJECT(pPropertyPageSite);

    return S_OK;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::Activate    [IPropertyPage]
//=--------------------------------------------------------------------------=
// instructs the page to create it's display window as a child of hwndparent
// and to position it according to prc.
//
// Parameters:
//    HWND                - [in]  parent window
//    LPCRECT             - [in]  where to position ourselves
//    BOOL                - [in]  whether we're modal or not.
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP CPropertyPage::Activate
(
    HWND    hwndParent,
    LPCRECT prcBounds,
    BOOL    fModal
)
{
    HRESULT hr;

    // first make sure the dialog window is loaded and created.
    //
    hr = m_EnsureLoaded();
    RETURN_ON_FAILURE(hr);

    // set our parent window if we haven't done so yet.
    //
    if (!m_fActivated) {
        SetParent(m_hwnd, hwndParent);
        m_fActivated = TRUE;
    }

    // now move ourselves to where we're told to be and show ourselves
    //
    Move(prcBounds);
    ShowWindow(m_hwnd, SW_SHOW);

    return S_OK;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::Deactivate    [IPropertyPage]
//=--------------------------------------------------------------------------=
// instructs the page to destroy the window created in activate
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP CPropertyPage::Deactivate
(
    void
)
{
    // blow away yon window.
    //
    if (m_hwnd)
        DestroyWindow(m_hwnd);
    m_hwnd = NULL;
    m_fActivated = FALSE;

    return S_OK;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::GetPageInfo    [IPropertyPage]
//=--------------------------------------------------------------------------=
// asks the page to fill a PROPPAGEINFO structure
//
// Parameters:
//    PROPPAGEINFO *    - [out] where to put info.
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP CPropertyPage::GetPageInfo
(
    PROPPAGEINFO *pPropPageInfo
)
{
    RECT rect;

    CHECK_POINTER(pPropPageInfo);

    m_EnsureLoaded();

    // clear it out first.
    //
    memset(pPropPageInfo, 0, sizeof(PROPPAGEINFO));

    pPropPageInfo->pszTitle = OLESTRFROMRESID(TITLEIDOFPROPPAGE(m_ObjectType));
    pPropPageInfo->pszDocString = OLESTRFROMRESID(DOCSTRINGIDOFPROPPAGE(m_ObjectType));
    pPropPageInfo->pszHelpFile = OLESTRFROMANSI(HELPFILEOFPROPPAGE(m_ObjectType));
    pPropPageInfo->dwHelpContext = HELPCONTEXTOFPROPPAGE(m_ObjectType);

    if (!(pPropPageInfo->pszTitle && pPropPageInfo->pszDocString && pPropPageInfo->pszHelpFile))
        goto CleanUp;

    // if we've got a window yet, go and set up the size information they want.
    //
    if (m_hwnd) {
        GetWindowRect(m_hwnd, &rect);

        pPropPageInfo->size.cx = rect.right - rect.left;
        pPropPageInfo->size.cy = rect.bottom - rect.top;
    }

    return S_OK;

  CleanUp:
    if (pPropPageInfo->pszDocString) CoTaskMemFree(pPropPageInfo->pszDocString);
    if (pPropPageInfo->pszHelpFile) CoTaskMemFree(pPropPageInfo->pszHelpFile);
    if (pPropPageInfo->pszTitle) CoTaskMemFree(pPropPageInfo->pszTitle);

    return E_OUTOFMEMORY;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::SetObjects    [IPropertyPage]
//=--------------------------------------------------------------------------=
// provides the page with the objects being affected by the changes.
//
// Parameters:
//    ULONG            - [in] count of objects.
//    IUnknown **      - [in] objects.
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP CPropertyPage::SetObjects
(
    ULONG      cObjects,
    IUnknown **ppUnkObjects
)
{
    HRESULT hr;
    ULONG   x;

    // free up all the old objects first.
    //
    m_ReleaseAllObjects();

    if (!cObjects)
        return S_OK;

    // now go and set up the new ones.
    //
    m_ppUnkObjects = (IUnknown **)HeapAlloc(g_hHeap, 0, cObjects * sizeof(IUnknown *));
    RETURN_ON_NULLALLOC(m_ppUnkObjects);

    // loop through and copy over all the objects.
    //
    for (x = 0; x < cObjects; x++) {
        m_ppUnkObjects[x] = ppUnkObjects[x];
        ADDREF_OBJECT(m_ppUnkObjects[x]);
    }

    // go and tell the object that there are new objects
    //
    hr = S_OK;
    m_cObjects = cObjects;
    // if we've got a window, go and notify it that we've got new objects.
    //
    if (m_hwnd)
        SendMessage(m_hwnd, PPM_NEWOBJECTS, 0, (LPARAM)&hr);
    if (SUCCEEDED(hr)) m_fDirty = FALSE;

    return hr;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::Show    [IPropertyPage]
//=--------------------------------------------------------------------------=
// asks the page to show or hide its window
//
// Parameters:
//    UINT             - [in] whether to show or hide
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP CPropertyPage::Show
(
    UINT nCmdShow
)
{
    if (m_hwnd)
        ShowWindow(m_hwnd, nCmdShow);
    else
        return E_UNEXPECTED;

    return S_OK;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::Move    [IPropertyPage]
//=--------------------------------------------------------------------------=
// asks the page to relocate and resize itself to a position other than what
// was specified through Activate
//
// Parameters:
//    LPCRECT        - [in] new position and size
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP CPropertyPage::Move
(
    LPCRECT prcBounds
)
{
    // do what they sez
    //
    if (m_hwnd)
        SetWindowPos(m_hwnd, NULL, prcBounds->left, prcBounds->top,
                     prcBounds->right - prcBounds->left,
                     prcBounds->bottom - prcBounds->top,
                     SWP_NOZORDER);
    else
        return E_UNEXPECTED;

    return S_OK;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::IsPageDirty    [IPropertyPage]
//=--------------------------------------------------------------------------=
// asks the page whether it has changed its state
//
// Output
//    S_OK            - yep
//    S_FALSE         - nope
//
// Notes:
//
STDMETHODIMP CPropertyPage::IsPageDirty
(
    void
)
{
    return m_fDirty ? S_OK : S_FALSE;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::Apply    [IPropertyPage]
//=--------------------------------------------------------------------------=
// instructs the page to send its changes to all the objects passed through
// SetObjects()
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP CPropertyPage::Apply
(
    void
)
{
    HRESULT hr = S_OK;

    if (m_hwnd) {
        SendMessage(m_hwnd, PPM_APPLY, 0, (LPARAM)&hr);
        RETURN_ON_FAILURE(hr);

        if (m_fDirty) {
            m_fDirty = FALSE;
            if (m_pPropertyPageSite)
                m_pPropertyPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);
        }
    } else
        return E_UNEXPECTED;

    return S_OK;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::Help    [IPropertyPage]
//=--------------------------------------------------------------------------=
// instructs the page that the help button was clicked.
//
// Parameters:
//    LPCOLESTR        - [in] help directory
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP CPropertyPage::Help
(
    LPCOLESTR pszHelpDir
)
{
    BOOL f;

    ASSERT(m_hwnd, "How can somebody have clicked Help, but we don't have an hwnd?");

    // oblige them and show the help.
    //
    MAKE_ANSIPTR_FROMWIDE(psz, pszHelpDir);
    f = WinHelp(m_hwnd, psz, HELP_CONTEXT, HELPCONTEXTOFPROPPAGE(m_ObjectType));

    return f ? S_OK : E_FAIL;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::TranslateAccelerator    [IPropertyPage]
//=--------------------------------------------------------------------------=
// informs the page of keyboard events, allowing it to implement it's own
// keyboard interface.
//
// Parameters:
//    LPMSG            - [in] message that triggered this
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP CPropertyPage::TranslateAccelerator
(
    LPMSG pmsg
)
{
    ASSERT(m_hwnd, "How can we get a TranslateAccelerator call if we're not visible?");

    // just pass this message on to the dialog proc and see if they want it.
    //
    return IsDialogMessage(m_hwnd, pmsg) ? S_OK : S_FALSE;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::EditProperty    [IPropertyPage2]
//=--------------------------------------------------------------------------=
// instructs the page to set the focus to the property matching the dispid.
//
// Parameters:
//    DISPID            - [in] dispid of property to set focus to.
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP CPropertyPage::EditProperty
(
    DISPID dispid
)
{
    HRESULT hr = E_NOTIMPL;

    // send the message on to the control, and see what they want to do with it.
    //
    SendMessage(m_hwnd, PPM_EDITPROPERTY, (WPARAM)dispid, (LPARAM)&hr);

    return hr;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::m_EnsureLoaded
//=--------------------------------------------------------------------------=
// makes sure the dialog is actually loaded
//
// Output:
//    HRESULT
//
// Notes:
//
HRESULT CPropertyPage::m_EnsureLoaded
(
    void
)
{
    HRESULT hr = S_OK;

    // duh
    //
    if (m_hwnd)
        return S_OK;

    // set up the global variable so that when we're in the dialog proc, we can
    // stuff this in the hwnd
    //
    // crit sect this whole creation process for apartment threading support.
    //
    EnterCriticalSection(&g_CriticalSection);
    s_pLastPageCreated = this;

    // create the dialog window
    //
    CreateDialog(GetResourceHandle(), TEMPLATENAMEOFPROPPAGE(m_ObjectType), GetParkingWindow(),
                          CPropertyPage::PropPageDlgProc);
    ASSERT(m_hwnd, "Couldn't load Dialog Resource!!!");
    if (!m_hwnd) {
        LeaveCriticalSection(&g_CriticalSection);
        return HRESULT_FROM_WIN32(GetLastError());
    }

    // clean up variables and leave the critical section
    //
    s_pLastPageCreated = NULL;
    LeaveCriticalSection(&g_CriticalSection);

    // go and notify the window that it should pick up any objects that are
    // available
    //
    SendMessage(m_hwnd, PPM_NEWOBJECTS, 0, (LPARAM)&hr);

    return hr;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::m_ReleaseAllObjects
//=--------------------------------------------------------------------------=
// releases all the objects that we're working with
//
// Notes:
//
void CPropertyPage::m_ReleaseAllObjects
(
    void
)
{
    HRESULT hr;
    UINT x;

    if (!m_cObjects)
        return;

    // some people will want to stash pointers in the PPM_INITOBJECTS case, so
    // we want to tell them to release them now.
    //
    SendMessage(m_hwnd, PPM_FREEOBJECTS, 0, (LPARAM)&hr);

    // loop through and blow them all away.
    //
    for (x = 0; x < m_cObjects; x++)
        QUICK_RELEASE(m_ppUnkObjects[x]);

    HeapFree(g_hHeap, 0, m_ppUnkObjects);
    m_ppUnkObjects = NULL;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::PropPageDlgProc
//=--------------------------------------------------------------------------=
// static global helper dialog proc that gets called before we pass the message
// on to anybody ..
//
// Parameters:
//    - see win32sdk docs on DialogProc
//
// Notes:
//
INT_PTR CALLBACK CPropertyPage::PropPageDlgProc
(
    HWND    hwnd,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    CPropertyPage *pPropertyPage;

    // get the window long, and see if it's been set to the object this hwnd
    // is operating against.  if not, go and set it now.
    //
    pPropertyPage = (CPropertyPage *)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    if ((ULONG_PTR)pPropertyPage == -1)
        return FALSE;
    if (!pPropertyPage) {
        SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)s_pLastPageCreated);
        pPropertyPage = s_pLastPageCreated;
        pPropertyPage->m_hwnd = hwnd;
    }

    ASSERT(pPropertyPage, "Uh oh.  Got a window, but no CpropertyPage for it!");

    // just call the user dialog proc and see if they want to do anything.
    //
    return pPropertyPage->DialogProc(hwnd, msg, wParam, lParam);
}


//=--------------------------------------------------------------------------=
// CPropertyPage::FirstControl
//=--------------------------------------------------------------------------=
// returns the first controlish object that we are showing ourselves for.
// returns a cookie that must be passed in for Next ...
//
// Parameters:
//    DWORD *    - [out] cookie to be used for Next
//
// Output:
//    IUnknown *
//
// Notes:
//
IUnknown *CPropertyPage::FirstControl
(
    DWORD *pdwCookie
)
{
    // just use the implementation of NEXT.
    //
    *pdwCookie = 0;
    return NextControl(pdwCookie);
}

//=--------------------------------------------------------------------------=
// CPropertyPage::NextControl
//=--------------------------------------------------------------------------=
// returns the next control in the chain of people to work with given a cookie
//
// Parameters:
//    DWORD *            - [in/out] cookie to get next from, and new cookie.
//
// Output:
//    IUnknown *
//
// Notes:
//
IUnknown *CPropertyPage::NextControl
(
    DWORD *pdwCookie
)
{
    UINT      i;

    // go looking through all the objects that we've got, and find the
    // first non-null one.
    //
    for (i = *pdwCookie; i < m_cObjects; i++) {
        if (!m_ppUnkObjects[i]) continue;

        *pdwCookie = i + 1;                // + 1 so we start at next item next time
        return m_ppUnkObjects[i];
    }

    // couldn't find it .
    //
    *pdwCookie = 0xffffffff;
    return NULL;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::MakeDirty    [helper, callable]
//=--------------------------------------------------------------------------=
// marks a page as dirty.
//
// Notes:
//
void CPropertyPage::MakeDirty
(
    void
)
{
    m_fDirty = TRUE;
    if (m_pPropertyPageSite)
        m_pPropertyPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY|PROPPAGESTATUS_VALIDATE);
}


// from Globals.C
//
extern HINSTANCE g_hInstResources;


//=--------------------------------------------------------------------------=
// CPropertyPage::GetResourceHandle    [helper, callable]
//=--------------------------------------------------------------------------=
// returns current resource handle, based on pagesites ambient LCID.
//
// Output:
//    HINSTANCE
//
// Notes:
//
HINSTANCE CPropertyPage::GetResourceHandle
(
    void
)
{
    if (!g_fSatelliteLocalization)
        return g_hInstance;

    // if we've already got it, then there's not all that much to do.
    // don't need to crit sect this one right here since even if they do fall
    // into the ::GetResourceHandle call, it'll properly deal with things.
    //
    if (g_hInstResources)
        return g_hInstResources;

    // we'll get the ambient localeid from the host, and pass that on to the
    // automation object.
    //
    // enter a critical section for g_lcidLocale and g_fHavelocale
    //
    EnterCriticalSection(&g_CriticalSection);
    if (!g_fHaveLocale) {
        if (m_pPropertyPageSite) {
            m_pPropertyPageSite->GetLocaleID(&g_lcidLocale);
            g_fHaveLocale = TRUE;
        }
    }
    LeaveCriticalSection(&g_CriticalSection);

    return ::GetResourceHandle();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\basectl\ipserver.cpp ===
//=--------------------------------------------------------------------------=
// IPServer.Cpp
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// implements all exported DLL functions for the program, as well as a few
// others that will be used by same
//
#include "IPServer.H"
#include "LocalSrv.H"

#include "AutoObj.H"
#include "ClassF.H"
#include "CtrlObj.H"
#include "Globals.H"
#include "Unknown.H"
#include "Util.H"

//=--------------------------------------------------------------------------=
// Private module level data
//
// for ASSERT and FAIL
//
SZTHISFILE


//=--------------------------------------------------------------------------=
// These are used for reflection in OLE Controls.  Not that big of a hit that
// we mind defining them for all servers, including automation or generic
// COM.
//
char g_szReflectClassName [] = "CtlFrameWork_ReflectWindow";
BYTE g_fRegisteredReflect = FALSE;


//=--------------------------------------------------------------------------=
// allow controls to register for DLL_THREAD_ATTACH and DLL_THREAD_DETACH 
//
THRDNFYPROC g_pfnThreadProc = NULL;

extern "C" void SetLibraryThreadProc(THRDNFYPROC pfnThreadNotify)
{
    if ((g_pfnThreadProc = pfnThreadNotify) == NULL)
        DisableThreadLibraryCalls((HMODULE)g_hInstance);
}


// ref count for LockServer
//
LONG  g_cLocks;


// private routines for this file.
//
int       IndexOfOleObject(REFCLSID);
HRESULT   RegisterAllObjects(void);
HRESULT   UnregisterAllObjects(void);

//=--------------------------------------------------------------------------=
// DllMain
//=--------------------------------------------------------------------------=
// yon standard LibMain.
//
// Parameters and Output:
//    - see SDK Docs on DllMain
//
// Notes:
//
BOOL WINAPI DllMain
(
    HANDLE hInstance,
    DWORD  dwReason,
    void  *pvReserved
)
{
    int i;

    switch (dwReason) {
      // set up some global variables, and get some OS/Version information
      // set up.
      //
      case DLL_PROCESS_ATTACH:
        {
        DWORD dwVer = GetVersion();
        DWORD dwWinVer;

        //  swap the two lowest bytes of dwVer so that the major and minor version
        //  numbers are in a usable order.
        //  for dwWinVer: high byte = major version, low byte = minor version
        //     OS               Sys_WinVersion  (as of 5/2/95)
        //     =-------------=  =-------------=
        //     Win95            0x035F   (3.95)
        //     WinNT ProgMan    0x0333   (3.51)
        //     WinNT Win95 UI   0x0400   (4.00)
        //
        dwWinVer = (UINT)(((dwVer & 0xFF) << 8) | ((dwVer >> 8) & 0xFF));
        g_fSysWinNT = FALSE;
        g_fSysWin95 = FALSE;
        g_fSysWin95Shell = FALSE;

        if (dwVer < 0x80000000) {
            g_fSysWinNT = TRUE;
            g_fSysWin95Shell = (dwWinVer >= 0x0334);
        } else  {
            g_fSysWin95 = TRUE;
            g_fSysWin95Shell = TRUE;
        }

        // initialize a critical seciton for our apartment threading support
        //
        InitializeCriticalSection(&g_CriticalSection);

        // create an initial heap for everybody to use.
        // currently, we're going to let the system make things thread-safe,
        // which will make them a little slower, but hopefully not enough
        // to notice
        //
        g_hHeap = GetProcessHeap();
        if (!g_hHeap) {
            FAIL("Couldn't get Process Heap.  Not good!");
            return FALSE;
        }

        g_hInstance = (HINSTANCE)hInstance;

        // give the user a chance to initialize whatever
        //
        InitializeLibrary();

        // if they didn't ask for thread notifications then optimize by turning
        // them off for our DLL.
        //
        if (!g_pfnThreadProc)
            DisableThreadLibraryCalls((HMODULE)hInstance);
        }
        break;

      case DLL_THREAD_ATTACH:
      case DLL_THREAD_DETACH:
        if (g_pfnThreadProc)
            g_pfnThreadProc(hInstance, dwReason, pvReserved);
        break;

      // do  a little cleaning up!
      //
      case DLL_PROCESS_DETACH:

        // clean up our critical seciton
        //
        DeleteCriticalSection(&g_CriticalSection);

        // unregister all the registered window classes.
        //
        i = 0;

        while (!ISEMPTYOBJECT(i)) {
            if (g_ObjectInfo[i].usType == OI_CONTROL) {
                if (CTLWNDCLASSREGISTERED(i))
                    UnregisterClass(WNDCLASSNAMEOFCONTROL(i), g_hInstance);
            }
            i++;
        }

        // clean up our parking window.
        //
        if (g_hwndParking) {
            DestroyWindow(g_hwndParking);
            UnregisterClass("CtlFrameWork_Parking", g_hInstance);
            --g_cLocks;
        }

        // clean up after reflection, if appropriate.
        //
        if (g_fRegisteredReflect)
            UnregisterClass(g_szReflectClassName, g_hInstance);

        // give the user a chance to do some cleaning up
        //
        UninitializeLibrary();
        break;
    }

    return TRUE;
}



//=--------------------------------------------------------------------------=
// DllRegisterServer
//=--------------------------------------------------------------------------=
// registers the Automation server
//
// Output:
//    HRESULT
//
// Notes:
//
STDAPI DllRegisterServer
(
    void
)
{
    HRESULT hr;

    hr = RegisterAllObjects();
    RETURN_ON_FAILURE(hr);

    // call user registration function.
    //
    return (RegisterData())? S_OK : E_FAIL;
}



//=--------------------------------------------------------------------------=
// DllUnregisterServer
//=--------------------------------------------------------------------------=
// unregister's the Automation server
//
// Output:
//    HRESULT
//
// Notes:
//
STDAPI DllUnregisterServer
(
    void
)
{
    HRESULT hr;

    hr = UnregisterAllObjects();
    RETURN_ON_FAILURE(hr);

    // call user unregistration function
    //
    return (UnregisterData()) ? S_OK : E_FAIL;
}


//=--------------------------------------------------------------------------=
// DllCanUnloadNow
//=--------------------------------------------------------------------------=
// we are being asked whether or not it's okay to unload the DLL.  just check
// the lock counts on remaining objects ...
//
// Output:
//    HRESULT        - S_OK, can unload now, S_FALSE, can't.
//
// Notes:
//
STDAPI DllCanUnloadNow
(
    void
)
{
    // if there are any objects lying around, then we can't unload.  The
    // controlling CUnknownObject class that people should be inheriting from
    // takes care of this
    //
    return (g_cLocks) ? S_FALSE : S_OK;
}


//=--------------------------------------------------------------------------=
// DllGetClassObject
//=--------------------------------------------------------------------------=
// creates a ClassFactory object, and returns it.
//
// Parameters:
//    REFCLSID        - CLSID for the class object
//    REFIID          - interface we want class object to be.
//    void **         - pointer to where we should ptr to new object.
//
// Output:
//    HRESULT         - S_OK, CLASS_E_CLASSNOTAVAILABLE, E_OUTOFMEMORY,
//                      E_INVALIDARG, E_UNEXPECTED
//
// Notes:
//
STDAPI DllGetClassObject
(
    REFCLSID rclsid,
    REFIID   riid,
    void   **ppvObjOut
)
{
    HRESULT hr;
    void   *pv;
    int     iIndex;

    // arg checking
    //
    if (!ppvObjOut)
        return E_INVALIDARG;

    // first of all, make sure they're asking for something we work with.
    //
    iIndex = IndexOfOleObject(rclsid);
    if (iIndex == -1)
        return CLASS_E_CLASSNOTAVAILABLE;

    // create the blank object.
    //
    pv = (void *)new CClassFactory(iIndex);
    if (!pv)
        return E_OUTOFMEMORY;

    // QI for whatever the user has asked for.
    //
    hr = ((IUnknown *)pv)->QueryInterface(riid, ppvObjOut);
    ((IUnknown *)pv)->Release();

    return hr;
}
//=--------------------------------------------------------------------------=
// IndexOfOleObject
//=--------------------------------------------------------------------------=
// returns the index in our global table of objects of the given CLSID.  if
// it's not a supported object, then we return -1
//
// Parameters:
//    REFCLSID     - [in] duh.
//
// Output:
//    int          - >= 0 is index into global table, -1 means not supported
//
// Notes:
//
int IndexOfOleObject
(
    REFCLSID rclsid
)
{
    int x = 0;

    // an object is creatable if it's CLSID is in the table of all allowable object
    // types.
    //
    while (!ISEMPTYOBJECT(x)) {
        if (OBJECTISCREATABLE(x)) {
            if (rclsid == CLSIDOFOBJECT(x))
                return x;
        }
        x++;
    }

    return -1;
}

//=--------------------------------------------------------------------------=
// RegisterAllObjects
//=--------------------------------------------------------------------------=
// registers all the objects for the given automation server.
//
// Parameters:
//    none
//
// Output:
//    HERSULT        - S_OK, E_FAIL
//
// Notes:
//
HRESULT RegisterAllObjects
(
    void
)
{
    ITypeLib *pTypeLib;
    HRESULT hr;
    DWORD   dwPathLen;
    char    szTmp[MAX_PATH];
    int     x = 0;

    // loop through all of our creatable objects [those that have a clsid in
    // our global table] and register them.
    //
    while (!ISEMPTYOBJECT(x)) {
        if (!OBJECTISCREATABLE(x)) {
            x++;
            continue;
        }

        // depending on the object type, register different pieces of information
        //
        switch (g_ObjectInfo[x].usType) {

          // for both simple co-creatable objects and proeprty pages, do the same
          // thing
          //
          case OI_UNKNOWN:
          case OI_PROPERTYPAGE:
            RegisterUnknownObject(NAMEOFOBJECT(x), CLSIDOFOBJECT(x));
            break;

          case OI_AUTOMATION:
            RegisterAutomationObject(g_szLibName, NAMEOFOBJECT(x), VERSIONOFOBJECT(x), 
                                     *g_pLibid, CLSIDOFOBJECT(x));
            break;

          case OI_CONTROL:
            RegisterControlObject(g_szLibName, NAMEOFOBJECT(x), VERSIONOFOBJECT(x),
                                  *g_pLibid, CLSIDOFOBJECT(x), OLEMISCFLAGSOFCONTROL(x),
                                  BITMAPIDOFCONTROL(x));
            break;

        }
        x++;
    }

    // Load and register our type library.
    //
    if (g_fServerHasTypeLibrary) {
        dwPathLen = GetModuleFileName(g_hInstance, szTmp, MAX_PATH);
        MAKE_WIDEPTR_FROMANSI(pwsz, szTmp);
        hr = LoadTypeLib(pwsz, &pTypeLib);
        RETURN_ON_FAILURE(hr);
        hr = RegisterTypeLib(pTypeLib, pwsz, NULL);
        pTypeLib->Release();
        RETURN_ON_FAILURE(hr);
    }

    return S_OK;
}

//=--------------------------------------------------------------------------=
// UnregisterAllObjects
//=--------------------------------------------------------------------------=
// un-registers all the objects for the given automation server.
//
// Parameters:
//    none
//
// Output:
//    HRESULT        - S_OK
//
// Notes:
//
HRESULT UnregisterAllObjects
(
    void
)
{
    int x = 0;

    // loop through all of our creatable objects [those that have a clsid in
    // our global table] and register them.
    //
    while (!ISEMPTYOBJECT(x)) {
        if (!OBJECTISCREATABLE(x)) {
            x++;
            continue;
        }

        switch (g_ObjectInfo[x].usType) {

          case OI_UNKNOWN:
          case OI_PROPERTYPAGE:
            UnregisterUnknownObject(CLSIDOFOBJECT(x));
            break;

          case OI_CONTROL:
            UnregisterControlObject(g_szLibName, NAMEOFOBJECT(x), VERSIONOFOBJECT(x), 
                                    CLSIDOFOBJECT(x));
    
          case OI_AUTOMATION:
            UnregisterAutomationObject(g_szLibName, NAMEOFOBJECT(x), VERSIONOFOBJECT(x), 
                                       CLSIDOFOBJECT(x));
            break;

        }
        x++;
    }

    // if we've got one, unregister our type library [this isn't an API function
    // -- we've implemented this ourselves]
    //
    if (g_pLibid)
        UnregisterTypeLibrary(*g_pLibid);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\basectl\internet.cpp ===
//=--------------------------------------------------------------------------=
// Internet.Cpp
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains internet helper classes CDownloadSink and CInternetControl
//
#include "IPServer.H"
#include "Internet.H"
#include "Util.H"

// ZZ BUGBUG: BUILD-ISSUE: added following #define.
#include "idispids.h"

static VARTYPE rgI4[] = { VT_I4 };

typedef enum {
    InternetEvent_Progress = 0,
    InternetEvent_ReadyStateChange = 1
} INTERNETEVENTS;

static EVENTINFO rgEvents [] = {
    { DISPID_PROGRESS, 1, rgI4 },           // (long percentDone)
    { DISPID_READYSTATECHANGE, 1, rgI4 },       // (OLE_READYSTATE newState)
};


// local class for doing async monitoring. It's not really all that
// general purpose, but it does the job...


class CDownloadSink : public IBindStatusCallback
{
public:
    CDownloadSink(IUnknown *punkOuter,CInternetControl *,DISPID );
    ~CDownloadSink();

    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObjOut);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

        STDMETHOD(OnStartBinding)(
            /* [in] */ DWORD grfBSCOption,
            /* [in] */ IBinding *pib);

        STDMETHOD(GetPriority)(
            /* [out] */ LONG *pnPriority);

        STDMETHOD(OnLowResource)(
            /* [in] */ DWORD reserved);

        STDMETHOD(OnProgress)(
            /* [in] */ ULONG ulProgress,
            /* [in] */ ULONG ulProgressMax,
            /* [in] */ ULONG ulStatusCode,
            /* [in] */ LPCWSTR szStatusText);

        STDMETHOD(OnStopBinding)(
            /* [in] */ HRESULT hresult,
            /* [in] */ LPCWSTR szError);

        STDMETHOD(GetBindInfo)(
            /* [out] */ DWORD *grfBINDINFOF,
            /* [unique][out][in] */ BINDINFO *pbindinfo);

        STDMETHOD(OnDataAvailable)(
            /* [in] */ DWORD grfBSCF,
            /* [in] */ DWORD dwSize,
            /* [in] */ FORMATETC *pformatetc,
            /* [in] */ STGMEDIUM *pstgmed);

        STDMETHOD(OnObjectAvailable)(
            /* [in] */ REFIID riid,
            /* [iid_is][in] */ IUnknown *punk);



        CDownloadSink * Next()                  { return(m_next); }
        void            Next(CDownloadSink *n)  { m_next = n; }

        DISPID          DispId()  { return(m_propId); }
        IBinding *      Binding() { return(m_binding); }

private:

        CDownloadSink *         m_next;
        CInternetControl *      m_control;
        DISPID                  m_propId;
        IBinding *              m_binding;
        DWORD                   m_ref;
                IStream *                               m_stream;

};


CDownloadSink::CDownloadSink
(
        IUnknown *              punkOuter,
        CInternetControl *      control,
        DISPID                  propId
)
{
//      CHECK_POINTER(control);

        m_control = control;
        m_control->AddRef();

        m_propId  = propId;
        m_next    = 0;
        m_binding = 0;
        m_ref     = 0;
        m_stream  = 0;
}

CDownloadSink::~CDownloadSink()
{
        if( m_control )
                m_control->Release();
        if( m_binding )
                m_binding->Release();
        if( m_stream )
                m_stream->Release();
}

STDMETHODIMP
CDownloadSink::QueryInterface(const GUID &iid,void **ppv )
{
        if( IsEqualGUID(iid,IID_IUnknown) || IsEqualGUID(iid,IID_IBindStatusCallback) )
        {
                *ppv = this;
                AddRef();
                return(NOERROR);
        }
        return( E_NOINTERFACE );
}

STDMETHODIMP_(ULONG)
CDownloadSink::AddRef()
{
        return(++m_ref);
}

STDMETHODIMP_(ULONG)
CDownloadSink::Release()
{
        if(!--m_ref)
        {
                delete this;
                return(0);
        }
        return( m_ref );
}


STDMETHODIMP
CDownloadSink::GetBindInfo( DWORD *grfBINDF, BINDINFO *pbindInfo)
{
    *grfBINDF = BINDF_ASYNCHRONOUS | BINDF_ASYNCSTORAGE | BINDF_PULLDATA | BINDF_GETNEWESTVERSION;
        return(NOERROR);
}


STDMETHODIMP
CDownloadSink::OnStartBinding(DWORD /*grfBSCOption*/,IBinding *pib)
{
        // BUGBUG: should check to see options are what we think they are
        m_binding = pib;
        pib->AddRef();
        return(NOERROR);
}


STDMETHODIMP
CDownloadSink::GetPriority( LONG *pnPriority)
{
        return(E_NOTIMPL);
}

STDMETHODIMP
CDownloadSink::OnProgress
(
     ULONG ulProgress,
     ULONG ulProgressMax,
     ULONG ulStatusCode,
     LPCWSTR pwzStatusText
)
{
        return(m_control->OnProgress(m_propId,ulProgress,
                                                        ulProgressMax,ulStatusCode,pwzStatusText) );
}

STDMETHODIMP
CDownloadSink::OnDataAvailable
(
     DWORD                      grfBSCF,
     DWORD                      dwSize,
     FORMATETC *        pFmtetc,
         STGMEDIUM *    pstgmed
)
{
#ifdef DEBUG
        char msg[200];
        wsprintf(msg,"::OnDataAvailable(%0xd,%d,%s,%s)\n",grfBSCF,dwSize,
                pFmtetc ? "pFmtetc" : "NULL", pstgmed ? "pstgmed" : "NULL" );
        OutputDebugString(msg);
#endif

    if( !m_stream )
                m_stream = pstgmed->pstm;

        return(m_control->OnData(       m_propId,
                                                                grfBSCF,
                                                                m_stream,
                                                                dwSize ));
}

STDMETHODIMP
CDownloadSink::OnObjectAvailable
(
        REFIID riid,
    IUnknown *punk
)
{
        return(E_NOTIMPL);
}


STDMETHODIMP
CDownloadSink::OnLowResource( DWORD reserved)
{
        // BUGBUG: really should have this kind of harsh policy on this ...
        m_binding->Abort();
        return(S_OK);
}

STDMETHODIMP
CDownloadSink::OnStopBinding(HRESULT hrError, LPCWSTR szError)
{
        m_binding->Release();
        m_binding = 0;
        m_control->Release();
        m_control = 0;

        return(NOERROR);
}



//------------------------------------------------------
//
// class CInternetControl
//
//
CInternetControl::CInternetControl
(
        IUnknown *      pUnkOuter,
        int                     iPrimaryDispatch,
        void *          pMainInterface
)
        : COleControl(pUnkOuter,iPrimaryDispatch,pMainInterface)
{
        m_host = 0;
        m_readyState = READYSTATE_LOADING;
}

CInternetControl::~CInternetControl()
{
        if( m_host )
                m_host->Release();
}


HRESULT CInternetControl::InternalQueryInterface
(
    REFIID  riid,
    void  **ppvObjOut
)
{
    *ppvObjOut = NULL;
     return COleControl::InternalQueryInterface(riid, ppvObjOut);
}



HRESULT
CInternetControl::GetBindHost()
{

        if( m_host )
                return(NOERROR);

    // Try service provider first...

        IServiceProvider * serviceProvider = 0;

        HRESULT hr = m_pClientSite->QueryInterface
                                                                        (
                                                                                IID_IServiceProvider,
                                                                                (void**)&serviceProvider
                                                                        );

        if( SUCCEEDED(hr) )
    {
                hr = serviceProvider->QueryService
                                    (
                                        SID_IBindHost,
                                        IID_IBindHost,
                                        (void**)&m_host
                                    );
                serviceProvider->Release();
    }

    if( FAILED(hr) )
    {
        // Some containers put IBindHost directly on the client site

        hr = m_pClientSite->QueryInterface
                                                                        (
                                        IID_IBindHost,
                                        (void**)&m_host
                                                                        );


    }

        return(hr);

}


HRESULT CInternetControl::GetAMoniker( LPOLESTR url, IMoniker ** ppmkr )
{
        HRESULT hr = GetBindHost();

        if( SUCCEEDED(hr) )
                hr = m_host->CreateMoniker(url,NULL, ppmkr,0);

        if( FAILED(hr) )
    {
           // FUTURE: This really should be a call to MkParseDisplayNameEx!!!
       hr = ::CreateURLMoniker(0,url,ppmkr);
       // hr = ::MkParseDisplayNameEx(0, url, 0, ppmkr);
    }

        return( hr );
}


HRESULT CInternetControl::SetupDownload( LPOLESTR url, DISPID propId )
{
        CHECK_POINTER(url);

        IMoniker * pmkr;

        HRESULT hr = GetAMoniker( url, &pmkr );

        IBindCtx * pBindCtx = 0;

        if( SUCCEEDED(hr) )
    {
        hr = ::CreateBindCtx(0,&pBindCtx);
    }

        CDownloadSink * sink = 0;

        if( SUCCEEDED(hr) )
        {
                sink = new CDownloadSink(0,this,propId);
                if( sink )
                        sink->AddRef();
        }

        if( SUCCEEDED(hr) && !sink )
                hr = E_OUTOFMEMORY;

        if( SUCCEEDED(hr) )
        {
                // BUGBUG: There should be a define for 0x77
                hr = ::RegisterBindStatusCallback(pBindCtx, sink,0, 0) ;
        }

        IStream * strm = 0;

        if( SUCCEEDED(hr) )
                hr = pmkr->BindToStorage( pBindCtx, 0, IID_IStream, (void**)&strm );

        if( strm )
                strm->Release();

        if( pBindCtx )
                pBindCtx->Release();

        if( FAILED(hr) && sink )
                sink->Release();

        return(hr);

}


HRESULT CInternetControl::OnData( DISPID, DWORD,IStream *, DWORD)
{
        return(NOERROR);
}

HRESULT CInternetControl::OnProgress( DISPID, ULONG progress, ULONG themax, ULONG, LPCWSTR)
{
        return(NOERROR);
}


HRESULT CInternetControl::FireReadyStateChange( long newState )
{
        FireEvent( &::rgEvents[InternetEvent_ReadyStateChange], m_readyState = newState );
        return(S_OK);
}

HRESULT CInternetControl::FireProgress( ULONG dwAmount )
{
        FireEvent( &::rgEvents[InternetEvent_Progress], dwAmount );
        return(S_OK);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\basectl\stdenum.cpp ===
//=--------------------------------------------------------------------------=
// StdEnum.Cpp
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// implementation of a generic enumerator object.
//
#include "IPServer.H"
#include "StdEnum.H"
#include "Globals.H"

SZTHISFILE

//=--------------------------------------------------------------------------=
// CStandardEnum::CStandardEnum
//=--------------------------------------------------------------------------=
// create the object and initialize the refcount
//
// Parameters:
//    REFCLSID        - [in] type of enumerator that we are
//    int             - [in] number of elements in the enumeration
//    int             - [in] size of each element
//    void *          - [in] pointer to element data
//    void (WINAPI *pfnCopyElement)(void *, const void *, DWORD)
//                    - [in] copying function
//
// Notes:
//
#pragma warning(disable:4355)  // using 'this' in constructor
CStandardEnum::CStandardEnum
(
    REFCLSID rclsid,
    int      cElements,
    int      cbElementSize,
    void    *rgElements,
    void (WINAPI *pfnCopyElement)(void *, const void *, DWORD)
)
: CUnknownObject(NULL, (IEnumGeneric *)this),
  m_iid(rclsid),
  m_cElements(cElements),
  m_cbElementSize(cbElementSize),
  m_iCurrent(0),
  m_rgElements(rgElements),
  m_pfnCopyElement(pfnCopyElement)
{
    m_pEnumClonedFrom = NULL;
}
#pragma warning(default:4355)  // using 'this' in constructor


//=--------------------------------------------------------------------------=
// CStandardEnum::CStandardEnum
//=--------------------------------------------------------------------------=
// "it is not death, but dying, which is terrible."
//    - Henry Fielding (1707-54)
//
// Notes:
//
CStandardEnum::~CStandardEnum ()
{
    // if we're a cloned object, then just release our parent object and
    // we're done. otherwise, free up the allocated memory we were given
    //
    if (m_pEnumClonedFrom)
        m_pEnumClonedFrom->Release();
    else {
        if (m_rgElements) HeapFree(g_hHeap, 0, m_rgElements);
    }
}

//=--------------------------------------------------------------------------=
// CStandardEnum::InternalQueryInterface
//=--------------------------------------------------------------------------=
// we support our internal iid, and that's all
//
// Parameters:
//    REFIID        - [in]  interface they want
//    void **       - [out] where they want to put the resulting object ptr.
//
// Output:
//    HRESULT       - S_OK, E_NOINTERFACE
//
// Notes:
//
HRESULT CStandardEnum::InternalQueryInterface
(
    REFIID riid,
    void **ppvObjOut
)
{
    if (DO_GUIDS_MATCH(riid, m_iid)) {
        ExternalAddRef();
        *ppvObjOut = (IEnumGeneric *)this;
        return S_OK;
    }

    return E_NOINTERFACE;
}

//=--------------------------------------------------------------------------=
// CStandardEnum::Next
//=--------------------------------------------------------------------------=
// returns the next dude in our iteration
//
// Parameters:
//    unsigned long     - [in]  count of elements requested
//    void    *         - [out] array of slots to put values in.
//    unsigned long *   - [out] actual number fetched
//
// Output:
//    HRESULT           - S_OK, E_INVALIDARG, S_FALSE
//
// Notes:
//
STDMETHODIMP CStandardEnum::Next
(
    unsigned long  cElm,
    void          *rgDest,
    unsigned long *pcElmOut
)
{
    unsigned long cElementsFetched = 0;
    void         *pElementDest = rgDest;
    const void   *pElementSrc = (const BYTE *)m_rgElements + (m_cbElementSize * m_iCurrent);

    while (cElementsFetched < cElm) {

        // if we hit EOF, break out
        //
        if (m_iCurrent >= m_cElements)
            break;

        // copy the element out for them
        //
        m_pfnCopyElement(pElementDest, pElementSrc, m_cbElementSize);

        // increase the counters
        //
        pElementDest = (LPBYTE)pElementDest + m_cbElementSize;
        pElementSrc  = (const BYTE *)pElementSrc + m_cbElementSize;
        m_iCurrent++;
        cElementsFetched++;
    }

    if (pcElmOut)
        *pcElmOut = cElementsFetched;

    return (cElementsFetched < cElm)? S_FALSE : S_OK;
}

//=--------------------------------------------------------------------------=
// CStandardEnum::Skip
//=--------------------------------------------------------------------------=
// skips the requested number of rows.
//
// Parameters:
//    unsigned long     - [in] number to skip
//
// Output:
//    HRESULT           - S_OK, S_FALSE
//
// Notes:
//
STDMETHODIMP CStandardEnum::Skip
(
    unsigned long cSkip
)
{
    // handle running off the end
    //
    if (m_iCurrent + (int)cSkip > m_cElements) {
        m_iCurrent = m_cElements;
        return S_FALSE;
    }

    m_iCurrent += cSkip;
    return S_OK;
}

//=--------------------------------------------------------------------------=
// CStandardEnum::Reset
//=--------------------------------------------------------------------------=
// reset the counter.
//
// Output:
//    HRESULT        - S_OK
//
// Notes:
//
STDMETHODIMP CStandardEnum::Reset
(
    void
)
{
    m_iCurrent = 0;
    return S_OK;
}


//=--------------------------------------------------------------------------=
// CStandardEnum::Clone
//=--------------------------------------------------------------------------=
// clones the object and gives the new one the same position
//
// Parameters:
//    IEnumVARIANT **    - [out] where to put the new object.
//
// Output;
//    HRESULT            - S_OK, E_OUTOFMEMORY
//
// Notes:
//
STDMETHODIMP CStandardEnum::Clone
(
    IEnumGeneric **ppEnumClone
)
{
    CStandardEnum *pNewEnum;

    pNewEnum = new CStandardEnum(m_iid, m_cElements, m_cbElementSize, m_rgElements, m_pfnCopyElement);
    RETURN_ON_NULLALLOC(pNewEnum);

    // hold on to who we were cloned from so m_rgElements stays alive, and we don't
    // have to copy it.
    //
    pNewEnum->m_pEnumClonedFrom = this;

    // AddRef() ourselves on their behalf.
    //
    AddRef();
    *ppEnumClone = (IEnumGeneric *)pNewEnum;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\basectl\unknown.cpp ===
//=--------------------------------------------------------------------------=
// Unknown.Cpp
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// implementation for various things in the unknown object that supports
// aggregation.
//
#include "IPServer.H"
#include "Unknown.H"
#include <stddef.h>


//=--------------------------------------------------------------------------=
// CUnknownObject::CPrivateUnknownObject::m_pMainUnknown
//=--------------------------------------------------------------------------=
// this method is used when we're sitting in the private unknown object,
// and we need to get at the pointer for the main unknown.  basically, it's
// a little better to do this pointer arithmetic than have to store a pointer
// to the parent, etc.
//
inline CUnknownObject *CUnknownObject::CPrivateUnknownObject::m_pMainUnknown
(
    void
)
{
    return (CUnknownObject *)((LPBYTE)this - offsetof(CUnknownObject, m_UnkPrivate));
}

//=--------------------------------------------------------------------------=
// CUnknownObject::CPrivateUnknownObject::QueryInterface
//=--------------------------------------------------------------------------=
// this is the non-delegating internal QI routine.
//
// Parameters:
//    REFIID        - [in]  interface they want
//    void **       - [out] where they want to put the resulting object ptr.
//
// Output:
//    HRESULT       - S_OK, E_NOINTERFACE
//
// Notes:
//
STDMETHODIMP CUnknownObject::CPrivateUnknownObject::QueryInterface
(
    REFIID riid,
    void **ppvObjOut
)
{
    CHECK_POINTER(ppvObjOut);

    // if they're asking for IUnknown, then we have to pass them ourselves.
    // otherwise defer to the inheriting object's InternalQueryInterface
    //
    if (DO_GUIDS_MATCH(riid, IID_IUnknown)) {
        m_cRef++;
        *ppvObjOut = (IUnknown *)this;
        return S_OK;
    } else
        return m_pMainUnknown()->InternalQueryInterface(riid, ppvObjOut);

    // dead code    
}

//=--------------------------------------------------------------------------=
// CUnknownObject::CPrivateUnknownObject::AddRef
//=--------------------------------------------------------------------------=
// adds a tick to the current reference count.
//
// Output:
//    ULONG        - the new reference count
//
// Notes:
//
ULONG CUnknownObject::CPrivateUnknownObject::AddRef
(
    void
)
{
    return ++m_cRef;
}

//=--------------------------------------------------------------------------=
// CUnknownObject::CPrivateUnknownObject::Release
//=--------------------------------------------------------------------------=
// removes a tick from the count, and delets the object if necessary
//
// Output:
//    ULONG         - remaining refs
//
// Notes:
//
ULONG CUnknownObject::CPrivateUnknownObject::Release
(
    void
)
{
    ULONG cRef = --m_cRef;

    if (!m_cRef)
        delete m_pMainUnknown();

    return cRef;
}


//=--------------------------------------------------------------------------=
// CUnknownObject::InternalQueryInterface
//=--------------------------------------------------------------------------=
// objects that are aggregated use this to support additional interfaces.
// they should call this method on their parent so that any of it's interfaces
// are queried.
//
// Parameters:
//    REFIID        - [in]  interface they want
//    void **       - [out] where they want to put the resulting object ptr.
//
// Output:
//    HRESULT       - S_OK, E_NOINTERFACE
//
// Notes:
//
HRESULT CUnknownObject::InternalQueryInterface
(
    REFIID  riid,
    void  **ppvObjOut
)
{
    *ppvObjOut = NULL;

    return E_NOINTERFACE;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\basectl\util.cpp ===
//=--------------------------------------------------------------------------=
// Util.C
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains routines that we will find useful.
//
#include "IPServer.H"

#include "Globals.H"
#include "Util.H"

void * _cdecl operator new(size_t size);
void  _cdecl operator delete(void *ptr);


// for ASSERT and FAIL
//
SZTHISFILE


//=---------------------------------------------------------------------------=
// overloaded new
//=---------------------------------------------------------------------------=
// for the retail case, we'll just use the win32 Local* heap management
// routines for speed and size
//
// Parameters:
//    size_t         - [in] what size do we alloc
//
// Output:
//    VOID *         - new memoery.
//
// Notes:
//
void * _cdecl operator new
(
    size_t    size
)
{
    return HeapAlloc(g_hHeap, 0, size);
}

//=---------------------------------------------------------------------------=
// overloaded delete
//=---------------------------------------------------------------------------=
// retail case just uses win32 Local* heap mgmt functions
//
// Parameters:
//    void *        - [in] free me!
//
// Notes:
//
void _cdecl operator delete ( void *ptr)
{
    HeapFree(g_hHeap, 0, ptr);
}

//=--------------------------------------------------------------------------=
// MakeWideFromAnsi
//=--------------------------------------------------------------------------=
// given a string, make a BSTR out of it.
//
// Parameters:
//    LPSTR         - [in]
//    BYTE          - [in]
//
// Output:
//    LPWSTR        - needs to be cast to final desired result
//
// Notes:
//
LPWSTR MakeWideStrFromAnsi
(
    LPSTR psz,
    BYTE  bType
)
{
    LPWSTR pwsz;
    int i;

    // arg checking.
    //
    if (!psz)
        return NULL;

    // compute the length of the required BSTR
    //
    i =  MultiByteToWideChar(CP_ACP, 0, psz, -1, NULL, 0);
    if (i <= 0) return NULL;

    // allocate the widestr
    //
    switch (bType) {
      case STR_BSTR:
        // -1 since it'll add it's own space for a NULL terminator
        //
        pwsz = (LPWSTR) SysAllocStringLen(NULL, i - 1);
        break;
      case STR_OLESTR:
        pwsz = (LPWSTR) CoTaskMemAlloc(i * sizeof(WCHAR));
        break;
      default:
        FAIL("Bogus String Type.");
    }

    if (!pwsz) return NULL;
    MultiByteToWideChar(CP_ACP, 0, psz, -1, pwsz, i);
    pwsz[i - 1] = 0;
    return pwsz;
}

//=--------------------------------------------------------------------------=
// MakeWideStrFromResId
//=--------------------------------------------------------------------------=
// given a resource ID, load it, and allocate a wide string for it.
//
// Parameters:
//    WORD            - [in] resource id.
//    BYTE            - [in] type of string desired.
//
// Output:
//    LPWSTR          - needs to be cast to desired string type.
//
// Notes:
//
LPWSTR MakeWideStrFromResourceId
(
    WORD    wId,
    BYTE    bType
)
{
    int i;

    char szTmp[512];

    // load the string from the resources.
    //
    i = LoadString(GetResourceHandle(), wId, szTmp, 512);
    if (!i) return NULL;

    return MakeWideStrFromAnsi(szTmp, bType);
}

//=--------------------------------------------------------------------------=
// MakeWideStrFromWide
//=--------------------------------------------------------------------------=
// given a wide string, make a new wide string with it of the given type.
//
// Parameters:
//    LPWSTR            - [in]  current wide str.
//    BYTE              - [in]  desired type of string.
//
// Output:
//    LPWSTR
//
// Notes:
//
LPWSTR MakeWideStrFromWide
(
    LPWSTR pwsz,
    BYTE   bType
)
{
    LPWSTR pwszTmp;
    int i;

    if (!pwsz) return NULL;

    // just copy the string, depending on what type they want.
    //
    switch (bType) {
      case STR_OLESTR:
        i = lstrlenW(pwsz);
        pwszTmp = (LPWSTR)CoTaskMemAlloc((i * sizeof(WCHAR)) + sizeof(WCHAR));
        if (!pwszTmp) return NULL;
        memcpy(pwszTmp, pwsz, (sizeof(WCHAR) * i) + sizeof(WCHAR));
        break;

      case STR_BSTR:
        pwszTmp = (LPWSTR)SysAllocString(pwsz);
        break;
    }

    return pwszTmp;
}

//=--------------------------------------------------------------------------=
// StringFromGuidA
//=--------------------------------------------------------------------------=
// returns an ANSI string from a CLSID or GUID
//
// Parameters:
//    REFIID               - [in]  clsid to make string out of.
//    LPSTR                - [in]  buffer in which to place resultant GUID.
//
// Output:
//    int                  - number of chars written out.
//
// Notes:
//
int StringFromGuidA
(
    REFIID   riid,
    LPSTR    pszBuf
)
{
    return wsprintf((char *)pszBuf, "{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}", riid.Data1,
            riid.Data2, riid.Data3, riid.Data4[0], riid.Data4[1], riid.Data4[2],
            riid.Data4[3], riid.Data4[4], riid.Data4[5], riid.Data4[6], riid.Data4[7]);

}

//=--------------------------------------------------------------------------=
// RegisterUnknownObject
//=--------------------------------------------------------------------------=
// registers a simple CoCreatable object.  nothing terribly serious.
// we add the following information to the registry:
//
// HKEY_CLASSES_ROOT\CLSID\<CLSID> = <ObjectName> Object
// HKEY_CLASSES_ROOT\CLSID\<CLSID>\InprocServer32 = <path to local server>
//
// Parameters:
//    LPCSTR       - [in] Object Name
//    REFCLSID     - [in] CLSID of the object
//
// Output:
//    BOOL         - FALSE means couldn't register it all
//
// Notes:
//
BOOL RegisterUnknownObject
(
    LPCSTR   pszObjectName,
    REFCLSID riidObject
)
{
    HKEY  hk = NULL, hkSub = NULL;
    char  szGuidStr[GUID_STR_LEN];
    DWORD dwPathLen, dwDummy;
    char  szScratch[MAX_PATH];
    long  l;

    // clean out any garbage
    //
    UnregisterUnknownObject(riidObject);

    // HKEY_CLASSES_ROOT\CLSID\<CLSID> = <ObjectName> Object
    // HKEY_CLASSES_ROOT\CLSID\<CLSID>\InprocServer32 = <path to local server>
    // HKEY_CLASSES_ROOT\CLSID\<CLSID>\InprocServer32  @ThreadingModel = Apartment
    //
    if (!StringFromGuidA(riidObject, szGuidStr)) goto CleanUp;
    wsprintf(szScratch, "CLSID\\%s", szGuidStr);
    l = RegCreateKeyEx(HKEY_CLASSES_ROOT, szScratch, 0, "", REG_OPTION_NON_VOLATILE,
                       KEY_READ | KEY_WRITE, NULL, &hk, &dwDummy);
    CLEANUP_ON_ERROR(l);

    wsprintf(szScratch, "%s Object", pszObjectName);
    l = RegSetValueEx(hk, NULL, 0, REG_SZ, (BYTE *)szScratch, lstrlen(szScratch) + 1);
    CLEANUP_ON_ERROR(l);

    l = RegCreateKeyEx(hk, "InprocServer32", 0, "", REG_OPTION_NON_VOLATILE,
                       KEY_READ | KEY_WRITE, NULL, &hkSub, &dwDummy);
    CLEANUP_ON_ERROR(l);

    dwPathLen = GetModuleFileName(g_hInstance, szScratch, sizeof(szScratch));
    if (!dwPathLen) goto CleanUp;

    l = RegSetValueEx(hkSub, NULL, 0, REG_SZ, (BYTE *)szScratch, dwPathLen + 1);
    CLEANUP_ON_ERROR(l);

    l = RegSetValueEx(hkSub, "ThreadingModel", 0, REG_SZ, (BYTE *)"Apartment", sizeof("Apartment"));
    CLEANUP_ON_ERROR(l);

    RegCloseKey(hkSub);
    RegCloseKey(hk);

    return TRUE;

    // we are not very happy!
    //
  CleanUp:
    if (hk) RegCloseKey(hk);
    if (hkSub) RegCloseKey(hkSub);
    return FALSE;

}

//=--------------------------------------------------------------------------=
// RegisterAutomationObject
//=--------------------------------------------------------------------------=
// given a little bit of information about an automation object, go and put it
// in the registry.
// we add the following information in addition to that set up in
// RegisterUnknownObject:
//
//
// HKEY_CLASSES_ROOT\<LibraryName>.<ObjectName> = <ObjectName> Object
// HKEY_CLASSES_ROOT\<LibraryName>.<ObjectName>\CLSID = <CLSID>
// HKEY_CLASSES_ROOT\<LibraryName>.<ObjectName>\CurVer = <ObjectName>.Object.<VersionNumber>
//
// HKEY_CLASSES_ROOT\<LibraryName>.<ObjectName>.<VersionNumber> = <ObjectName> Object
// HKEY_CLASSES_ROOT\<LibraryName>.<ObjectName>.<VersionNumber>\CLSID = <CLSID>
//
// HKEY_CLASSES_ROOT\CLSID\<CLSID>\TypeLib = <LibidOfTypeLibrary>
// HKEY_CLASSES_ROOT\CLSID\<CLSID>\ProgID = <LibraryName>.<ObjectName>.<VersionNumber>
// HKEY_CLASSES_ROOT\CLSID\<CLSID>\VersionIndependentProgID = <LibraryName>.<ObjectName>
//
// Parameters:
//    LPCSTR       - [in] Library Name
//    LPCSTR       - [in] Object Name
//    long         - [in] Version Number
//    REFCLSID     - [in] LIBID of type library
//    REFCLSID     - [in] CLSID of the object
//
// Output:
//    BOOL         - FALSE means not all of it was registered
//
// Notes:
//
BOOL RegisterAutomationObject
(
    LPCSTR   pszLibName,
    LPCSTR   pszObjectName,
    long     lVersion,
    REFCLSID riidLibrary,
    REFCLSID riidObject
)
{
    HKEY  hk = NULL, hkSub = NULL;
    char  szGuidStr[GUID_STR_LEN];
    char  szScratch[MAX_PATH];
    long  l;
    DWORD dwDummy;

    // first register the simple Unknown stuff.
    //
    if (!RegisterUnknownObject(pszObjectName, riidObject)) return FALSE;

    // HKEY_CLASSES_ROOT\<LibraryName>.<ObjectName> = <ObjectName> Object
    // HKEY_CLASSES_ROOT\<LibraryName>.<ObjectName>\CLSID = <CLSID>
    // HKEY_CLASSES_ROOT\<LibraryName>.<ObjectName>\CurVer = <ObjectName>.Object.<VersionNumber>
    //
    lstrcpy(szScratch, pszLibName);
    lstrcat(szScratch, ".");
    lstrcat(szScratch, pszObjectName);

    l = RegCreateKeyEx(HKEY_CLASSES_ROOT, szScratch, 0L, "",
                       REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE,
                       NULL, &hk, &dwDummy);
    CLEANUP_ON_ERROR(l);

    wsprintf(szScratch, "%s Object", pszObjectName);
    l = RegSetValueEx(hk, NULL, 0L, REG_SZ, (BYTE *)szScratch, lstrlen(szScratch)+1);
    CLEANUP_ON_ERROR(l);

    l = RegCreateKeyEx(hk, "CLSID", 0L, "", REG_OPTION_NON_VOLATILE,
                       KEY_READ | KEY_WRITE, NULL, &hkSub, &dwDummy);
    CLEANUP_ON_ERROR(l);

    if (!StringFromGuidA(riidObject, szGuidStr))
        goto CleanUp;

    l = RegSetValueEx(hkSub, NULL, 0L, REG_SZ, (BYTE *)szGuidStr, lstrlen(szGuidStr) + 1);
    CLEANUP_ON_ERROR(l);

    RegCloseKey(hkSub);
    l = RegCreateKeyEx(hk, "CurVer", 0, "", REG_OPTION_NON_VOLATILE,
                       KEY_READ | KEY_WRITE, NULL, &hkSub, &dwDummy);
    CLEANUP_ON_ERROR(l);

    wsprintf(szScratch, "%s.%s.%ld", pszLibName, pszObjectName, lVersion);
    l = RegSetValueEx(hkSub, NULL, 0, REG_SZ, (BYTE *)szScratch, lstrlen(szScratch) + 1);
    CLEANUP_ON_ERROR(l);

    RegCloseKey(hkSub);
    RegCloseKey(hk);

    // HKEY_CLASSES_ROOT\<LibraryName>.<ObjectName>.<VersionNumber> = <ObjectName> Object
    // HKEY_CLASSES_ROOT\<LibraryName>.<ObjectName>.<VersionNumber>\CLSID = <CLSID>
    //
    l = RegCreateKeyEx(HKEY_CLASSES_ROOT, szScratch, 0, "", REG_OPTION_NON_VOLATILE,
                       KEY_READ | KEY_WRITE, NULL, &hk, &dwDummy);
    CLEANUP_ON_ERROR(l);

    wsprintf(szScratch, "%s Object", pszObjectName);
    l = RegSetValueEx(hk, NULL, 0, REG_SZ, (BYTE *)szScratch, lstrlen(szScratch) + 1);
    CLEANUP_ON_ERROR(l);

    l = RegCreateKeyEx(hk, "CLSID", 0, "", REG_OPTION_NON_VOLATILE,
                       KEY_READ | KEY_WRITE, NULL, &hkSub, &dwDummy);
    CLEANUP_ON_ERROR(l);

    l = RegSetValueEx(hkSub, NULL, 0, REG_SZ, (BYTE *)szGuidStr, lstrlen(szGuidStr) + 1);
    CLEANUP_ON_ERROR(l);

    RegCloseKey(hkSub);
    RegCloseKey(hk);

    // HKEY_CLASSES_ROOT\CLSID\<CLSID>\ProgID = <LibraryName>.<ObjectName>.<VersionNumber>
    // HKEY_CLASSES_ROOT\CLSID\<CLSID>\VersionIndependentProgID = <LibraryName>.<ObjectName>
    // HKEY_CLASSES_ROOT\CLSID\<CLSID>\TypeLib = <LibidOfTypeLibrary>
    //
    if (!StringFromGuidA(riidObject, szGuidStr)) goto CleanUp;
    wsprintf(szScratch, "CLSID\\%s", szGuidStr);

    l = RegCreateKeyEx(HKEY_CLASSES_ROOT, szScratch, 0, "", REG_OPTION_NON_VOLATILE,
                       KEY_READ|KEY_WRITE, NULL, &hk, &dwDummy);
    CLEANUP_ON_ERROR(l);

    l = RegCreateKeyEx(hk, "VersionIndependentProgID", 0, "", REG_OPTION_NON_VOLATILE,
                       KEY_READ | KEY_WRITE, NULL, &hkSub, &dwDummy);
    CLEANUP_ON_ERROR(l);

    wsprintf(szScratch, "%s.%s", pszLibName, pszObjectName);
    l = RegSetValueEx(hkSub, NULL, 0, REG_SZ, (BYTE *)szScratch, lstrlen(szScratch) + 1);
    CLEANUP_ON_ERROR(l);

    RegCloseKey(hkSub);

    l = RegCreateKeyEx(hk, "ProgID", 0, "", REG_OPTION_NON_VOLATILE,
                       KEY_READ | KEY_WRITE, NULL, &hkSub, &dwDummy);
    CLEANUP_ON_ERROR(l);

    wsprintf(szScratch, "%s.%s.%ld", pszLibName, pszObjectName, lVersion);
    l = RegSetValueEx(hkSub, NULL, 0, REG_SZ, (BYTE *)szScratch, lstrlen(szScratch) + 1);
    CLEANUP_ON_ERROR(l);

    RegCloseKey(hkSub);
    l = RegCreateKeyEx(hk, "TypeLib", 0, "", REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE,
                       NULL, &hkSub, &dwDummy);

    if (!StringFromGuidA(riidLibrary, szGuidStr)) goto CleanUp;

    l = RegSetValueEx(hkSub, NULL, 0, REG_SZ, (BYTE *)szGuidStr, lstrlen(szGuidStr) + 1);
    CLEANUP_ON_ERROR(l);

    RegCloseKey(hkSub);
    RegCloseKey(hk);
    return TRUE;

  CleanUp:
    if (hk) RegCloseKey(hkSub);
    if (hk) RegCloseKey(hk);
    return FALSE;
}

//=--------------------------------------------------------------------------=
// RegisterControlObject.
//=--------------------------------------------------------------------------=
// in addition to writing out automation object information, this function
// writes out some values specific to a control.
//
// What we add here:
//
// HKEY_CLASSES_ROOT\CLSID\<CLSID>\Control
// HKEY_CLASSES_ROOT\CLSID\<CLSID>\MiscStatus\1 = <MISCSTATUSBITS>
// HKEY_CLASSES_ROOT\CLSID\<CLSID>\ToolboxBitmap32 = <PATH TO BMP>
// HKEY_CLASSES_ROOT\CLSID\<CLSID>\Version = <VERSION>
//
// Parameters:
//    LPCSTR       - [in] Library Name
//    LPCSTR       - [in] Object Name
//    long         - [in] Version Number
//    REFCLSID     - [in] LIBID of type library
//    REFCLSID     - [in] CLSID of the object
//    DWORD        - [in] misc status flags for ctl
//    WORD         - [in] toolbox id for control
//
// Output:
//    BOOL
//
// Notes:
//    - not the most terribly efficient routine.
//
BOOL RegisterControlObject
(
    LPCSTR   pszLibName,
    LPCSTR   pszObjectName,
    long     lVersion,
    REFCLSID riidLibrary,
    REFCLSID riidObject,
    DWORD    dwMiscStatus,
    WORD     wToolboxBitmapId
)
{
    HKEY    hk, hkSub = NULL, hkSub2 = NULL;
    char    szTmp[MAX_PATH];
    char    szGuidStr[GUID_STR_LEN];
    DWORD   dwDummy;
    LONG    l;

    // first register all the automation information for this.
    //
    if (!RegisterAutomationObject(pszLibName, pszObjectName, lVersion, riidLibrary, riidObject)) return FALSE;

    // then go and register the control specific stuff.
    //
    StringFromGuidA(riidObject, szGuidStr);
    wsprintf(szTmp, "CLSID\\%s", szGuidStr);
    l = RegOpenKeyEx(HKEY_CLASSES_ROOT, szTmp, 0, KEY_WRITE, &hk);
    if (l != ERROR_SUCCESS) return FALSE;

    // create the control flag.
    //
    l = RegCreateKeyEx(hk, "Control", 0, "", REG_OPTION_NON_VOLATILE, KEY_READ, NULL, &hkSub, &dwDummy);
    CLEANUP_ON_ERROR(l);

    // now set up the MiscStatus Bits...
    //
    RegCloseKey(hkSub);
    hkSub = NULL;
    l = RegCreateKeyEx(hk, "MiscStatus", 0, "", REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hkSub, &dwDummy);
    CLEANUP_ON_ERROR(l);

    szTmp[0] = '0';
    szTmp[1] = '\0';
    l = RegSetValueEx(hkSub, NULL, 0, REG_SZ, (BYTE *)szTmp, 2);
    CLEANUP_ON_ERROR(l);

    l = RegCreateKeyEx(hkSub, "1", 0, "", REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hkSub2, &dwDummy);
    CLEANUP_ON_ERROR(l);

    wsprintf(szTmp, "%d", dwMiscStatus);
    l = RegSetValueEx(hkSub2, NULL, 0, REG_SZ, (BYTE *)szTmp, lstrlen(szTmp) + 1);
    RegCloseKey(hkSub2);
    CLEANUP_ON_ERROR(l);

    RegCloseKey(hkSub);

    // now set up the toolbox bitmap
    //
    GetModuleFileName(g_hInstance, szTmp, MAX_PATH);
    wsprintf(szGuidStr, ", %d", wToolboxBitmapId);
    lstrcat(szTmp, szGuidStr);

    l = RegCreateKeyEx(hk, "ToolboxBitmap32", 0, "", REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hkSub, &dwDummy);
    CLEANUP_ON_ERROR(l);

    l = RegSetValueEx(hkSub, NULL, 0, REG_SZ, (BYTE *)szTmp, lstrlen(szTmp) + 1);
    CLEANUP_ON_ERROR(l);

    // now set up the version information
    //
    RegCloseKey(hkSub);
    l = RegCreateKeyEx(hk, "Version", 0, "", REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hkSub, &dwDummy);
    CLEANUP_ON_ERROR(l);

    wsprintf(szTmp, "%ld.0", lVersion);
    l = RegSetValueEx(hkSub, NULL, 0, REG_SZ, (BYTE *)szTmp, lstrlen(szTmp) + 1);

  CleanUp:
    if (hk)
        RegCloseKey(hk);
    if (hkSub)
        RegCloseKey(hkSub);

    return (l == ERROR_SUCCESS) ? TRUE : FALSE;
}

//=--------------------------------------------------------------------------=
// UnregisterUnknownObject
//=--------------------------------------------------------------------------=
// cleans up all the stuff that RegisterUnknownObject puts in the
// registry.
//
// Parameters:
//    REFCLSID     - [in] CLSID of the object
//
// Output:
//    BOOL         - FALSE means not all of it was registered
//
// Notes:
//    - WARNING: this routine will blow away all other keys under the CLSID
//      for this object.  mildly anti-social, but likely not a problem.
//
BOOL UnregisterUnknownObject
(
    REFCLSID riidObject
)
{
    char szScratch[MAX_PATH];
    HKEY hk;
    BOOL f;
    long l;

    // delete everybody of the form
    //   HKEY_CLASSES_ROOT\CLSID\<CLSID> [\] *
    //
    if (!StringFromGuidA(riidObject, szScratch))
        return FALSE;

    l = RegOpenKeyEx(HKEY_CLASSES_ROOT, "CLSID", 0, KEY_READ | KEY_WRITE, &hk);
    if (l != ERROR_SUCCESS) return FALSE;

    f = DeleteKeyAndSubKeys(hk, szScratch);
    RegCloseKey(hk);

    return f;
}

//=--------------------------------------------------------------------------=
// UnregisterAutomationObject
//=--------------------------------------------------------------------------=
// unregisters an automation object, including all of it's unknown object
// information.
//
// Parameters:
//    LPCSTR       - [in] Library Name
//    LPCSTR       - [in] Object Name
//    long         - [in] Version Number
//    REFCLSID     - [in] CLSID of the object
//
// Output:
//    BOOL         - FALSE means couldn't get it all unregistered.
//
// Notes:
//
BOOL UnregisterAutomationObject
(
    LPCSTR   pszLibName,
    LPCSTR   pszObjectName,
    long     lVersion,
    REFCLSID riidObject
)
{
    char szScratch[MAX_PATH];
    BOOL f;

    // first thing -- unregister Unknown information
    //
    f = UnregisterUnknownObject(riidObject);
    if (!f) return FALSE;

    // delete everybody of the form:
    //   HKEY_CLASSES_ROOT\<LibraryName>.<ObjectName> [\] *
    //
    wsprintf(szScratch, "%s.%s", pszLibName, pszObjectName);
    f = DeleteKeyAndSubKeys(HKEY_CLASSES_ROOT, szScratch);
    if (!f) return FALSE;

    // delete everybody of the form
    //   HKEY_CLASSES_ROOT\<LibraryName>.<ObjectName>.<VersionNumber> [\] *
    //
    wsprintf(szScratch, "%s.%s.%ld", pszLibName, pszObjectName, lVersion);
    f = DeleteKeyAndSubKeys(HKEY_CLASSES_ROOT, szScratch);
    if (!f) return FALSE;

    return TRUE;
}

//=--------------------------------------------------------------------------=
// UnregisterTypeLibrary
//=--------------------------------------------------------------------------=
// blows away the type library keys for a given libid.
//
// Parameters:
//    REFCLSID        - [in] libid to blow away.
//
// Output:
//    BOOL            - TRUE OK, FALSE bad.
//
// Notes:
//    - WARNING: this function just blows away the entire type library section,
//      including all localized versions of the type library.  mildly anti-
//      social, but not killer.
//
BOOL UnregisterTypeLibrary
(
    REFCLSID riidLibrary
)
{
    HKEY hk;
    char szScratch[GUID_STR_LEN];
    long l;
    BOOL f;

    // convert the libid into a string.
    //
    if (!StringFromGuidA(riidLibrary, szScratch))
        return FALSE;

    l = RegOpenKeyEx(HKEY_CLASSES_ROOT, "TypeLib", 0, KEY_READ | KEY_WRITE, &hk);
    if (l != ERROR_SUCCESS) return FALSE;

    f = DeleteKeyAndSubKeys(hk, szScratch);
    RegCloseKey(hk);
    return f;
}

//=--------------------------------------------------------------------------=
// DeleteKeyAndSubKeys
//=--------------------------------------------------------------------------=
// delete's a key and all of it's subkeys.
//
// Parameters:
//    HKEY                - [in] delete the descendant specified
//    LPSTR               - [in] i'm the descendant specified
//
// Output:
//    BOOL                - TRUE OK, FALSE baaaad.
//
// Notes:
//    - I don't feel too bad about implementing this recursively, since the
//      depth isn't likely to get all the great.
//    - Despite the win32 docs claiming it does, RegDeleteKey doesn't seem to
//      work with sub-keys under windows 95.
//
BOOL DeleteKeyAndSubKeys
(
    HKEY    hkIn,
    LPSTR   pszSubKey
)
{
    HKEY  hk;
    char  szTmp[MAX_PATH];
    DWORD dwTmpSize;
    long  l;
    BOOL  f;

    l = RegOpenKeyEx(hkIn, pszSubKey, 0, KEY_READ | KEY_WRITE, &hk);
    if (l != ERROR_SUCCESS) return FALSE;

    // loop through all subkeys, blowing them away.
    //
    f = TRUE;
    while (f) {
        dwTmpSize = MAX_PATH;
        l = RegEnumKeyEx(hk, 0, szTmp, &dwTmpSize, 0, NULL, NULL, NULL);
        if (l != ERROR_SUCCESS) break;
        f = DeleteKeyAndSubKeys(hk, szTmp);
    }

    // there are no subkeys left, [or we'll just generate an error and return FALSE].
    // let's go blow this dude away.
    //
    RegCloseKey(hk);
    l = RegDeleteKey(hkIn, pszSubKey);

    return (l == ERROR_SUCCESS) ? TRUE : FALSE;
}


//=--------------------------------------------------------------------------=
// Conversion Routines
//=--------------------------------------------------------------------------=
// the following stuff is stuff used for the various conversion routines.
//
#define HIMETRIC_PER_INCH   2540
#define MAP_PIX_TO_LOGHIM(x,ppli)   ( (HIMETRIC_PER_INCH*(x) + ((ppli)>>1)) / (ppli) )
#define MAP_LOGHIM_TO_PIX(x,ppli)   ( ((ppli)*(x) + HIMETRIC_PER_INCH/2) / HIMETRIC_PER_INCH )

static  int     s_iXppli;            // Pixels per logical inch along width
static  int     s_iYppli;            // Pixels per logical inch along height
static  BYTE    s_fGotScreenMetrics; // Are above valid?

//=--------------------------------------------------------------------------=
// GetScreenMetrics
//=--------------------------------------------------------------------------=
// private function we call to set up various metrics the conversion routines
// will use.
//
// Notes:
//
static void GetScreenMetrics
(
    void
)
{
    HDC hDCScreen;

    // we have to critical section this in case two threads are converting
    // things at the same time
    //
    EnterCriticalSection(&g_CriticalSection);
    if (s_fGotScreenMetrics)
        goto Done;

    // we want the metrics for the screen
    //
    hDCScreen = GetDC(NULL);

    ASSERT(hDCScreen, "couldn't get a DC for the screen.");
    s_iXppli = GetDeviceCaps(hDCScreen, LOGPIXELSX);
    s_iYppli = GetDeviceCaps(hDCScreen, LOGPIXELSY);

    ReleaseDC(NULL, hDCScreen);
    s_fGotScreenMetrics = TRUE;

    // we're done with our critical seciton.  clean it up
    //
  Done:
    LeaveCriticalSection(&g_CriticalSection);
}

//=--------------------------------------------------------------------------=
// HiMetricToPixel
//=--------------------------------------------------------------------------=
// converts from himetric to Pixels.
//
// Parameters:
//    const SIZEL *        - [in]  dudes in himetric
//    SIZEL *              - [out] size in pixels.
//
// Notes:
//
void HiMetricToPixel(const SIZEL * lpSizeInHiMetric, LPSIZEL lpSizeInPix)
{
    GetScreenMetrics();

    // We got logical HIMETRIC along the display, convert them to pixel units
    //
    lpSizeInPix->cx = MAP_LOGHIM_TO_PIX(lpSizeInHiMetric->cx, s_iXppli);
    lpSizeInPix->cy = MAP_LOGHIM_TO_PIX(lpSizeInHiMetric->cy, s_iYppli);
}

//=--------------------------------------------------------------------------=
// PixelToHiMetric
//=--------------------------------------------------------------------------=
// converts from pixels to himetric.
//
// Parameters:
//    const SIZEL *        - [in]  size in pixels
//    SIZEL *              - [out] size in himetric
//
// Notes:
//
void PixelToHiMetric(const SIZEL * lpSizeInPix, LPSIZEL lpSizeInHiMetric)
{
    GetScreenMetrics();

    // We got pixel units, convert them to logical HIMETRIC along the display
    //
    lpSizeInHiMetric->cx = MAP_PIX_TO_LOGHIM(lpSizeInPix->cx, s_iXppli);
    lpSizeInHiMetric->cy = MAP_PIX_TO_LOGHIM(lpSizeInPix->cy, s_iYppli);
}

//=--------------------------------------------------------------------------=
// _MakePath
//=--------------------------------------------------------------------------=
// little helper routine for RegisterLocalizedTypeLibs and GetResourceHandle.
// not terrilby efficient or smart, but it's registration code, so we don't
// really care.
//
// Notes:
//
void _MakePath
(
    LPSTR pszFull,
    const char * pszName,
    LPSTR pszOut
)
{
    LPSTR psz;
    LPSTR pszLast;

    lstrcpy(pszOut, pszFull);
    psz = pszLast = pszOut;
    while (*psz) {
        if (*psz == '\\')
            pszLast = AnsiNext(psz);
        psz = AnsiNext(psz);
    }

    // got the last \ character, so just go and replace the name.
    //
    lstrcpy(pszLast, pszName);
}

// from Globals.C
//
extern HINSTANCE    g_hInstResources;

//=--------------------------------------------------------------------------=
// GetResourceHandle
//=--------------------------------------------------------------------------=
// returns the resource handle.  we use the host's ambient Locale ID to
// determine, from a table in the DLL, which satellite DLL to load for
// localized resources.
//
// Output:
//    HINSTANCE
//
// Notes:
//
HINSTANCE GetResourceHandle
(
    void
)
{
    int i;
    char szExtension[5], szTmp[MAX_PATH];
    char szDllName[MAX_PATH], szFinalName[MAX_PATH];

    // crit sect this so that we don't mess anything up.
    //
    EnterCriticalSection(&g_CriticalSection);

    // don't do anything if we don't have to
    //
    if (g_hInstResources || !g_fSatelliteLocalization)
        goto CleanUp;

    // we're going to call GetLocaleInfo to get the abbreviated name for the
    // LCID we've got.
    //
    i = GetLocaleInfo(g_lcidLocale, LOCALE_SABBREVLANGNAME, szExtension, sizeof(szExtension));
    if (!i) goto CleanUp;

    // we've got the language extension.  go and load the DLL name from the
    // resources and then tack on the extension.
    // please note that all inproc sers -must- have the string resource 1001
    // defined to the base name of the server if they wish to support satellite
    // localization.
    //
    i = LoadString(g_hInstance, 1001, szTmp, sizeof(szTmp));
    ASSERT(i, "This server doesn't have IDS_SERVERBASENAME defined in their resources!");
    if (!i) goto CleanUp;

    // got the basename and the extention. go and combine them, and then add
    // on the .DLL for them.
    //
    wsprintf(szDllName, "%s%s.DLL", szTmp, szExtension);

    // try to load in the DLL
    //
    GetModuleFileName(g_hInstance, szTmp, MAX_PATH);
    _MakePath(szTmp, szDllName, szFinalName);

    g_hInstResources = LoadLibrary(szFinalName);

    // if we couldn't find it with the entire LCID, try it with just the primary
    // langid
    //
    if (!g_hInstResources) {
        LPSTR psz;
        LCID lcid;
        lcid = MAKELCID(MAKELANGID(PRIMARYLANGID(LANGIDFROMLCID(g_lcidLocale)), SUBLANG_DEFAULT), SORT_DEFAULT);
        i = GetLocaleInfo(lcid, LOCALE_SABBREVLANGNAME, szExtension, sizeof(szExtension));
        if (!i) goto CleanUp;

        // reconstruct the DLL name.  the -7 is the length of XXX.DLL. mildly
        // hacky, but it should be fine.  there are no DBCS lang identifiers.
        // finally, retry the load
        //
        psz = szFinalName + lstrlen(szFinalName);
        memcpy((LPBYTE)psz - 7, szExtension, 3);
        g_hInstResources = LoadLibrary(szFinalName);
    }

  CleanUp:
    // if we couldn't load the DLL for some reason, then just return the
    // current resource handle, which is good enough.
    //
    if (!g_hInstResources) g_hInstResources = g_hInstance;
    LeaveCriticalSection(&g_CriticalSection);

    return g_hInstResources;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\ie40\html\ieverdef.h ===
#define VER_JAVAVM        "5,0,3802,0"
#define VER_JAVAVM_AXP    "5,0,3229,0"
#define VER_MPLAYER       "6,04,07,1119"
#define VER_MPLAYER_W2K   "6,04,09,1119"
#define VER_WMPCODEC      "6,04,07,1028"
#define VER_GSETUP        "5,0,0,1"
#define VER_AOLSUPP       "5,0,0,2"
#define VER_CORE          "TOK_BUILDNUM,TOK_CIFNUM"
#define VER_DOT_CORE      "TOK_PERIODNUM.TOK_CIFNUM"
#define VER_SHELL         "4,72,3612,1706"
#define VER_MAILNEWS	  "TOK_BUILDNUM,TOK_CIFNUM"
#define VER_ADDRESSBK 	  "TOK_BUILDNUM,TOK_CIFNUM"
#define VER_NETMEETING    "4,4,0,3388"
#define VER_IAMUSIC       "2,5,1,487"
#define VER_MINI_IAMUSIC  "2,5,1,488"
#define VER_DIRECTXMINI   "4,02,00,1054"
#define VER_DIRECTDRAWEX  "4,71,1113,0"
#define VER_DIRECTDR_AXP  "4,71,1112,0"
#define VER_TRIDATA       "5,5000,3130,0"
#define VER_TRIJAVA       "4,7,0,0320"
#define VER_DANIMATION    "6,01,09,727"
#define VER_DANIMATION_AXP "6,01,09,727"
#define VER_DAJAVA        "6,00,01,0223"
#define VER_FONTCORE      "1,00,0000,6"
#define VER_FONTSUP       "1,00,0000,6"
#define VER_MFC40         "4,0,0,0"
#define VER_128UPDATE     "4,87,1959,1877"
#define VER_MSTASK        "4,71,1968,1"
#define VER_HTMLHELP      "4,74,9273,0"
#define VER_MSNAUTH       "4,9,9,2"
#define VER_USP10         "1,400,2411,1"
#define VER_DCOM95        "4,71,2900,7"
#define VER_IELPKAD       "5,00,2000,5"
#define VER_IELPKJA       "5,00,2000,6"
#define VER_JAAIME        "5,1,3106,0"
#define VER_IELPKKO       "5,00,2000,6"
#define VER_KOAIME        "5,1,3106,0"
#define VER_IELPKPE       "5,00,2000,8"
#define VER_IELPKZHT      "5,00,2000,9"
#define VER_TCAIME        "5,1,3106,0"
#define VER_IELPKZHC      "5,00,2000,9"
#define VER_SCAIME        "5,1,3106,1"
#define VER_IELPKIW       "5,00,2000,9"
#define VER_IELPKVI       "5,00,2000,10"
#define VER_IELPKAR       "5,00,2000,8"
#define VER_IELPKTH       "5,00,2000,10"
#define VER_MSGOTHIC      "1,0,0,0"
#define VER_OEMINSTALL    "4,71,0,1105"
#define VER_MSVBSCRIPT    "5,6,0,6509"
#define VER_MSVML         "TOK_BUILDNUM,TOK_CIFNUM"
#define VER_KORSPELLPatch "1,22,2042,0"
#define VER_OAINST        "2,40,4518,0"
#define VER_FLASH         "5,0,42,0"
#define VER_DIRECTOR      "8,0,0,196"
#define VER_MDAC          "2,10,3711,9"
#define VER_SMARTTAGS     "1,0,86,7"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\ie4uinit\makefile.inc ===
$(O)\ieuinit.inf : ..\..\ie40\inf\ieuinit.inx
    @type <<$(ECHO_RSP)
$(ECHO_MSG_P) /EP $**
<<NOKEEP
!if "$(BUILD_PRODUCT)" == "NT"
    @$(C_PREPROCESSOR_NAME) /DNT5 @<<$(CL_RSP) /Tc$** > $@
!else
    @$(C_PREPROCESSOR_NAME)       @<<$(CL_RSP) /Tc$** > $@
!endif
$(CPPXX: =
)
<<NOKEEP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\ie4uinit\convert.h ===
/************************************************************\
	FILE: convert.h

	DATE: Apr 1, 1996

	AUTHOR: Bryan Starbuck (bryanst)

	DESCRIPTION:
		This file will handle the logic to convert Netscape
	bookmarks to Microsoft Internet Explorer favorites.  This 
	will happen by finding the location of the Netscape bookmarks
	file and the Microsoft Internet Explorer favorites directory
	from the registry.  Then it will parse the bookmarks file to
	extract the URLs, which will finally be added to the favorites
	directory.

  NOTES:
	This was developed with Netscape 2.0 and IE 2.0.  Future notes
	will be made about compatibility with different versions of
	these browsers.
	
\************************************************************/

#ifndef _CONVERT_H
#define _CONVERT_H



// ItemType is going to be the type of entry found in the bookmarks
// file.
typedef enum MYENTRYTYPE
{
    ET_OPEN_DIR     = 531,  // New level in heirarchy
    ET_CLOSE_DIR,           // Close level in heirarchy
    ET_BOOKMARK,            // Bookmark entry.
    ET_NONE,                // End of File
    ET_ERROR                // Bail, we encountered an error
} MyEntryType;


//////////////////////////////////////////////////////////////////
//	Exprted Functions
//////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////
//  Internal Functions
//////////////////////////////////////////////////////////////////
BOOL    ImportNetscapeProxy(void);		// Import Netscape Proxy Setting
BOOL    UpdateHomePage(void);			// Upgrade IE v1.0 Home URL to v3.0
BOOL    ImportBookmarks(HINSTANCE hInstWithStr);			//  Import Netscape Bookmarks to IE Favorites

BOOL    RegStrValueEmpty(HKEY hTheKey, char * szPath, char * szKey);
BOOL    GetNSProxyValue(char * szProxyValue, DWORD * pdwSize);

BOOL        VerifyBookmarksFile(HANDLE hFile);
BOOL        ConvertBookmarks(char * szFavoritesDir, HANDLE hFile, HINSTANCE hInstWithStr);
MyEntryType   NextFileEntry(char ** ppStr, char ** ppToken);
BOOL        GetData(char ** ppData, HANDLE hFile);
void        RemoveInvalidFileNameChars(char * pBuf);
BOOL        CreateDir(char *pDirName);
BOOL        CloseDir(void);
BOOL        CreateBookmark(char *pBookmarkName);
BOOL        GetPathFromRegistry(LPSTR szPath, UINT cbPath, HKEY theHKEY, LPSTR szKey, LPSTR szVName);
BOOL        GetNavBkMkDir( LPSTR lpszDir, int isize );


#endif // _CONVERT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\ie4uinit\priv.h ===
#ifndef _PRIV_H_
#define _PRIV_H_

#include <windows.h>
#include <shellapi.h>
#include <shlobj.h>
#include <shlguid.h>
#include "resource.h"

#ifndef ARRAYSIZE
#define ARRAYSIZE(a)                (sizeof(a)/sizeof(a[0]))
#endif

#endif // _PRIV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\ie4uinit\resource.h ===
#define IDS_CSIDL_PERSONAL_L    1
#define IDS_CSIDL_FAVORITES_L   2
#define IDS_CSIDL_APPDATA_L     3
#define IDS_CSIDL_CACHE_L       4
#define IDS_CSIDL_COOKIES_L     5
#define IDS_CSIDL_HISTORY_L     6
#define IDS_CSIDL_DESKTOP_L     7
#define IDS_CSIDL_RECENT_L      8
#define IDS_CSIDL_NETHOOD_L     9

#define IDS_NS_BOOKMARKS_DIR	10
#define IDS_ERR_NOFOUNDINF	11
#define	IDS_APPNAME		12
#define IDS_IE20_STR		13
#define IDS_IE_LNK		14
#define IDS_IE_APPNAME		15

#define IDS_MYDOCS_SHORTCUT     20
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\ie4uinit\reg.cpp ===
#include "priv.h"
#include "advpub.h"
#include "sdsutils.h"
#include "utils.h"

#ifndef ARRAYSIZE
#define ARRAYSIZE(a)                (sizeof(a)/sizeof(a[0]))
#endif

/*----------------------------------------------------------
Purpose: Behaves just like RegQueryValueEx, except if the
         data type is REG_EXPAND_SZ, then this goes ahead
         and expands out the string.  *pdwType will always
         be massaged to REG_SZ if this happens.

Returns: 
Cond:    --
*/
DWORD
SDSQueryValueExA(
    IN     HKEY    hkey,
    IN     LPCSTR  pszValue,
    IN     LPDWORD lpReserved,
    OUT    LPDWORD pdwType,
    OUT    LPVOID  pvData,
    IN OUT LPDWORD pcbData)
{
    DWORD dwRet;
    DWORD cbSize;
    DWORD dwType;
    LPSTR lpsz;

    if (pvData) 
    {
        // Trying to get back data

        cbSize = *pcbData;     // Size of output buffer
        dwRet = RegQueryValueExA(hkey, pszValue, lpReserved, &dwType,
                                 (LPBYTE)pvData, &cbSize);

        // Normally, we'd be done with this.  But do some extra work
        // if this is an expandable string (something that has system
        // variables in it), or if we need to pad the buffer.

        if (NO_ERROR == dwRet)
        {
            // Note: on Win95, RegSetValueEx will always write the 
            // full string out, including the null terminator.  On NT,
            // it won't unless the write length was specified.  
            // Hence, we have the following check.

            // Pad the buffer, in case the string didn't have a null
            // terminator when it was stored?
            if (REG_SZ == dwType)
            {
                // Yes
                if (cbSize < *pcbData) 
                {
                    LPSTR lpszData = (LPSTR)pvData;
                    lpszData[cbSize] = '\0';
                }
            }
            // Expand the string?
            else if (REG_EXPAND_SZ == dwType)
            {
                // Yes

                // Use a temporary buffer to expand
                lpsz = (LPSTR)LocalAlloc(LPTR, *pcbData);    
                if ( !lpsz )
                    return ERROR_OUTOFMEMORY;

                cbSize = ExpandEnvironmentStringsA((LPSTR)pvData, lpsz, *pcbData);

                // BUGBUG:: NT screws up the cbSize returned...
                if (cbSize > 0)
                    cbSize = lstrlen(lpsz) + 1;
                if (cbSize > 0 && cbSize <= *pcbData) 
                    lstrcpynA((LPSTR)pvData, lpsz, *pcbData);
                else
                    dwRet = GetLastError();

                LocalFree(lpsz);

                // Massage dwType so that callers always see REG_SZ
                dwType = REG_SZ;
            }
        }
    } 
    else 
    {
        // Trying to find out how big of a buffer to use

        cbSize = 0;
        dwRet = RegQueryValueExA(hkey, pszValue, lpReserved, &dwType,
                                 NULL, &cbSize);
        if (NO_ERROR == dwRet && REG_EXPAND_SZ == dwType)
        {
            CHAR szBuff[1];

            // Find out the length of the expanded string
            //
            lpsz = (LPSTR)LocalAlloc(LPTR, cbSize);
            if (!lpsz)
                return ERROR_OUTOFMEMORY;

            dwRet = RegQueryValueExA(hkey, pszValue, lpReserved, NULL,
                                     (LPBYTE)lpsz, &cbSize);

            if (NO_ERROR == dwRet)
            {
                cbSize = ExpandEnvironmentStringsA(lpsz, szBuff, ARRAYSIZE(szBuff));

                // BUGBUG:: NT screws up the cbSize returned...
                if (cbSize > 0)
                    cbSize = lstrlen(lpsz) + 1;
            }

            LocalFree(lpsz);

            // Massage dwType so that callers always see REG_SZ
            dwType = REG_SZ;
        }
    }

    if (pdwType)
        *pdwType = dwType;

    if (pcbData)
        *pcbData = cbSize;

    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\iedetect\pch.cpp ===
#include "pch.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\ie4uinit\convert.cpp ===
/************************************************************\
    FILE: convert.c

    DATE: April 1, 1996

    AUTHOR(S):  Bryan Starbuck (bryanst)

    DESCRIPTION:
    This file contains functions that can be used to upgrade
    settings from the Microsoft Internet Explorer v2.0 to v3.0,
    and some features to import Netscape features into Internet
    Explorer.

    This file will handle the logic to convert Netscape
    bookmarks to Microsoft Internet Explorer favorites.  This
    will happen by finding the location of the Netscape bookmarks
    file and the Microsoft Internet Explorer favorites directory
    from the registry.  Then it will parse the bookmarks file to
    extract the URLs, which will finally be added to the favorites
    directory.

    USAGE:
    This code is designed to be called when the user may
    want Netscape bookmarks imported into system level Favorites
    usable by programs such as Internet Explorer.  External
    users should call ImportBookmarks().  If this is done during
    setup, it should be done after setup specifies the Favorites
    registry entry and directory.  If Netscape is not installed,
    then the ImportBookmarks() is just a big no-op.

  NOTE:
    If this file is being compiled into something other
    than infnist.exe, it will be necessary to include the
    following String Resource:

    #define     IDS_NS_BOOKMARKS_DIR    137
    STRINGTABLE DISCARDABLE
    BEGIN
    ...
    IDS_NS_BOOKMARKS_DIR    "\\Imported Bookmarks"
    END


  UPDATES:  I adopted this file to allow IE4.0 having the abilities
    to upgrade from NetScape's setting.  Two CustomActions will be added
    to call in functions in this file. (inateeg)

\************************************************************/
#include "priv.h"
#include "advpub.h"
#include "sdsutils.h"
#include "utils.h"
#include "convert.h"
#include <regstr.h>

//////////////////////////////////////////////////////////////////
//  TYPES:
//////////////////////////////////////////////////////////////////

//typedef enum MYENTRYTYPE MyEntryType;

extern HINSTANCE g_hinst;

//////////////////////////////////////////////////////////////////
//  Constants:
//////////////////////////////////////////////////////////////////
#define MAX_URL 2048
#define FILE_EXT 4          // For ".url" at the end of favorite filenames
#define REASONABLE_NAME_LEN     100

#define BEGIN_DIR_TOKEN         "<DT><H"
#define MID_DIR_TOKEN           "\">"
#define END_DIR_TOKEN           "</H"
#define BEGIN_EXITDIR_TOKEN     "</DL><p>"
#define BEGIN_URL_TOKEN         "<DT><A HREF=\""
#define END_URL_TOKEN           "\" A"
#define BEGIN_BOOKMARK_TOKEN    ">"
#define END_BOOKMARK_TOKEN      "</A>"

#define VALIDATION_STR "<!DOCTYPE NETSCAPE-Bookmark-file-"

//////////////////////////////////////////////////////////////////
//  GLOBALS:
//////////////////////////////////////////////////////////////////
char    * szNetscapeBMRegSub        = "SOFTWARE\\Netscape\\Netscape Navigator\\Bookmark List";
char    * szNetscapeBMRegKey        = "File Location";
char    * szIEFavoritesRegSub       = "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders";
char    * szIEFavoritesRegKey       = "Favorites";
char    * szInvalidFolderCharacters = "\\/:*?\"<>|";

BOOL    gfValidNetscapeFile = FALSE;
BOOL    gfValidIEDirFile = FALSE;



#define _FAT_   1
#define _HPFS_  0
#define _NTFS_  0
#define _WILD_  0
#define _OFS_   0
#define _OLE_   0

#define AnsiMaxChar     128                 // The array below only indicates the lower 7 bits of the byte.

static UCHAR LocalLegalAnsiCharacterArray[AnsiMaxChar] = {

    0,                                                // 0x00 ^@
                          _OLE_,  // 0x01 ^A
                          _OLE_,  // 0x02 ^B
                          _OLE_,  // 0x03 ^C
                          _OLE_,  // 0x04 ^D
                          _OLE_,  // 0x05 ^E
                          _OLE_,  // 0x06 ^F
                          _OLE_,  // 0x07 ^G
                          _OLE_,  // 0x08 ^H
                          _OLE_,  // 0x09 ^I
                          _OLE_,  // 0x0A ^J
                          _OLE_,  // 0x0B ^K
                          _OLE_,  // 0x0C ^L
                          _OLE_,  // 0x0D ^M
                          _OLE_,  // 0x0E ^N
                          _OLE_,  // 0x0F ^O
                          _OLE_,  // 0x10 ^P
                          _OLE_,  // 0x11 ^Q
                          _OLE_,  // 0x12 ^R
                          _OLE_,  // 0x13 ^S
                          _OLE_,  // 0x14 ^T
                          _OLE_,  // 0x15 ^U
                          _OLE_,  // 0x16 ^V
                          _OLE_,  // 0x17 ^W
                          _OLE_,  // 0x18 ^X
                          _OLE_,  // 0x19 ^Y
                          _OLE_,  // 0x1A ^Z
                          _OLE_,  // 0x1B ESC
                          _OLE_,  // 0x1C FS
                          _OLE_,  // 0x1D GS
                          _OLE_,  // 0x1E RS
                          _OLE_,  // 0x1F US
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x20 space
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_,          // 0x21 !
                  _WILD_,                 // 0x22 "
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x23 #
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x24 $
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x25 %
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x26 &
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x27 '
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x28 (
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x29 )
                  _WILD_,                 // 0x2A *
        _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x2B +
        _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x2C ,
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x2D -
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x2E .
    0,                                                // 0x2F /
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x30 0
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x31 1
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x32 2
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x33 3
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x34 4
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x35 5
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x36 6
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x37 7
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x38 8
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x39 9
             _NTFS_ |         _OFS_,          // 0x3A :
        _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x3B ;
                  _WILD_,                 // 0x3C <
        _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x3D =
                  _WILD_,                 // 0x3E >
                  _WILD_,                 // 0x3F ?
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x40 @
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x41 A
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x42 B
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x43 C
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x44 D
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x45 E
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x46 F
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x47 G
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x48 H
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x49 I
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x4A J
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x4B K
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x4C L
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x4D M
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x4E N
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x4F O
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x50 P
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x51 Q
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x52 R
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x53 S
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x54 T
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x55 U
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x56 V
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x57 W
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x58 X
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x59 Y
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x5A Z
        _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x5B [
    0,                                                // 0x5C backslash
        _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x5D ]
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x5E ^
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x5F _
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x60 `
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x61 a
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x62 b
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x63 c
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x64 d
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x65 e
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x66 f
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x67 g
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x68 h
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x69 i
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x6A j
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x6B k
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x6C l
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x6D m
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x6E n
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x6F o
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x70 p
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x71 q
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x72 r
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x73 s
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x74 t
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x75 u
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x76 v
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x77 w
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x78 x
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x79 y
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x7A z
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x7B {
                          _OLE_,  // 0x7C |
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x7D }
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x7E ~
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x7F 
};



///////////////////////////////////////////////////////
//  Import Netscape Bookmarks to Microsoft
//  Internet Explorer's Favorites
///////////////////////////////////////////////////////

/************************************************************\
    FUNCTION: ImportBookmarks

    PARAMETERS:
    HINSTANCE hInstWithStr - Location of String Resources.
    BOOL return - If an error occurs importing the bookmarks, FALSE is returned.

    DESCRIPTION:
    This function will see if it can find a IE Favorite's
    registry entry and a Netscape bookmarks registry entry.  If
    both are found, then the conversion can happen.  It will
    attempt to open the verify that the bookmarks file is
    valid and then convert the entries to favorite entries.
    If an error occures, ImportBookmarks() will return FALSE,
    otherwise it will return TRUE.
\*************************************************************/

BOOL ImportBookmarks(HINSTANCE hInstWithStr)
{
    char    szFavoritesDir[MAX_PATH];
    char    szBookmarksDir[MAX_PATH];
    HANDLE  hBookmarksFile        = INVALID_HANDLE_VALUE;
    BOOL    fSuccess                = FALSE;


    // Initialize Variables
    szFavoritesDir[0] = '\0';
    szBookmarksDir[0] = '\0';

    // Get Bookmarks Dir
    if (TRUE == GetNavBkMkDir( szBookmarksDir, sizeof(szBookmarksDir) ) )
    {
        if ((NULL != szBookmarksDir) && (szBookmarksDir[0] != '\0'))
        {
            hBookmarksFile = CreateFile(szBookmarksDir, GENERIC_READ, FILE_SHARE_READ, NULL,
                                        OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );

            if ( hBookmarksFile != INVALID_HANDLE_VALUE )
            {
                // Get Favorites Dir
                if (TRUE == GetPathFromRegistry(szFavoritesDir, MAX_PATH, HKEY_CURRENT_USER,
                    szIEFavoritesRegSub, szIEFavoritesRegKey))
                {
                    if ((NULL != szFavoritesDir) && (szFavoritesDir[0] != '\0'))
                    {
                        // Verify it's a valid Bookmarks file
                        if (TRUE == VerifyBookmarksFile( hBookmarksFile ))
                        {
                            // Do the importing...
                            fSuccess = ConvertBookmarks(szFavoritesDir, hBookmarksFile, hInstWithStr);
                        }
                    }
                }
            }
        }
    }

    if (INVALID_HANDLE_VALUE != hBookmarksFile)
    {
        CloseHandle(hBookmarksFile);
    }

    return(fSuccess);
}


/************************************************************\
    FUNCTION: ConvertBookmarks

    PARAMETERS:
    char * szFavoritesDir - String containing the path to
            the IE Favorites directory
    BOOL return - If an error occurs importing the bookmarks, FALSE is returned.

    DESCRIPTION:
    This function will continue in a loop converting each
    entry in the bookmark file.  There are three types of
    entries in the bookmark file, 1) a bookmark, 2) start of
    new level in heirarchy, 3) end of current level in heirarchy.
    The function NextFileEntry() will return these values until
    the file is empty, at which point, this function will end.

    NOTE:
    In order to prevent an infinite loop, it's assumed
    that NextFileEntry() will eventually return ET_NONE or ET_ERROR.
\************************************************************/

BOOL ConvertBookmarks(char * szFavoritesDir, HANDLE hFile, HINSTANCE hInstWithStr)
{
    BOOL    fDone       = FALSE;
    BOOL    fSuccess    = TRUE;
    BOOL    fIsEmpty    = TRUE;
    char    * szData    = NULL;
    char    * szCurrent = NULL;
    char    * szToken   = NULL;
    char    szSubDir[MAX_PATH];

    fSuccess = GetData(&szData, hFile);
    if (NULL == szData)
        fSuccess = FALSE;

    szCurrent = szData;

    // Verify directory exists or that we can make it.
    if ((TRUE == fSuccess) && ( !SetCurrentDirectory(szFavoritesDir)))
    {
        // If the directory doesn't exist, make it...
        if ( !CreateDirectory(szFavoritesDir, NULL))
            fSuccess = FALSE;
        else
            if (!SetCurrentDirectory(szFavoritesDir))
                fSuccess = FALSE;
    }

    // We don't want to install Other Popular Browser's bookmarks on our top level of our
    // favorites, so we create a sub director to put them in.
    if (0 != LoadString(hInstWithStr, IDS_NS_BOOKMARKS_DIR, szSubDir, sizeof(szSubDir)))
    {
        lstrcat(szFavoritesDir, szSubDir);

        if ((TRUE == fSuccess) && (!SetCurrentDirectory(szFavoritesDir)))
        {
            // If the directory doesn't exist, make it...
            if (!CreateDirectory(szFavoritesDir, NULL))
                fSuccess = FALSE;
            else
                if (!SetCurrentDirectory(szFavoritesDir))
                    fSuccess = FALSE;
        }
    }
    else
        fSuccess = FALSE;

    while ((FALSE == fDone) && (TRUE == fSuccess))
    {
        switch(NextFileEntry(&szCurrent, &szToken))
        {
            case ET_OPEN_DIR:
                fSuccess = CreateDir(szToken);
                break;
            case ET_CLOSE_DIR:
                fSuccess = CloseDir();
                break;
            case ET_BOOKMARK:
                fSuccess = CreateBookmark(szToken);
                fIsEmpty = FALSE;
                break;
            case ET_ERROR:
                fSuccess = FALSE;
                break;
            case ET_NONE:
            default:
                fDone = TRUE;
                break;
        }
    }

    if ( fIsEmpty )
    {
        // nothing to import, delete the dir created earlier
        DelNode(szFavoritesDir, 0);
    }

    if (NULL != szData)
    {
        LocalFree(szData);
        szData = NULL;
        szCurrent = NULL;       // szCurrent no longer points to valid data.
        szToken = NULL;     // szCurrent no longer points to valid data.
    }

    return(fSuccess);
}

/************************************************************\
    FUNCTION: NextFileEntry

    PARAMETERS:
    char ** ppStr   - The data to parse.
    char ** ppToken - The token pointer.
    EntryType return- See below.

    DESCRIPTION:
    This function will look for the next entry in the
    bookmark file to create or act on.  The return value
    will indicate this response:
    ET_OPEN_DIR             Create a new level in heirarchy
    ET_CLOSE_DIR,           Close level in heirarchy
    ET_BOOKMARK,            Create Bookmark entry.
    ET_NONE,                End of File
    ET_ERROR                Error encountered

    Errors will be detected by finding the start of a token,
    but in not finding other parts of the token that are needed
    to parse the data.
\************************************************************/

MyEntryType NextFileEntry(char ** ppStr, char ** ppToken)
{
    MyEntryType   returnVal       = ET_NONE;
    char *      pCurrentToken   = NULL;         // The current token to check if valid.
    char *      pTheToken       = NULL;         // The next valid token.
    char *      pszTemp         = NULL;

    //ASSERTSZ(NULL != ppStr, "It's an error to pass NULL for ppStr");
    //ASSERTSZ(NULL != *ppStr, "It's an error to pass NULL for *ppStr");
    //ASSERTSZ(NULL != ppToken, "It's an error to pass NULL for ppToken");

    if ((NULL != ppStr) && (NULL != *ppStr) && (NULL != ppToken))
    {
        // Check for begin dir token
        if (NULL != (pCurrentToken = ANSIStrStr(*ppStr, BEGIN_DIR_TOKEN)))
        {
            // Begin dir token found
            // Verify that other needed tokens exist or it's an error
            if ((NULL == (pszTemp = ANSIStrStr(pCurrentToken, MID_DIR_TOKEN))) ||
                (NULL == ANSIStrStr(pszTemp, END_DIR_TOKEN)))
            {
                returnVal = ET_ERROR;       // We can't find all the tokens needed.
            }
            else
            {
                // This function has to set *ppToken to the name of the directory to create
                *ppToken =  ANSIStrStr(pCurrentToken, MID_DIR_TOKEN) + sizeof(MID_DIR_TOKEN)-1;
                pTheToken = pCurrentToken;
                returnVal = ET_OPEN_DIR;
            }
        }
        // Check for exit dir token
        if ((ET_ERROR != returnVal) &&
            (NULL != (pCurrentToken = ANSIStrStr(*ppStr, BEGIN_EXITDIR_TOKEN))))
        {
            // Exit dir token found
            // See if this token comes before TheToken.
            if ((NULL == pTheToken) || (pCurrentToken < pTheToken))
            {
                // ppToken is not used for Exit Dir
                *ppToken = NULL;
                pTheToken = pCurrentToken;
                returnVal = ET_CLOSE_DIR;
            }
        }
        // Check for begin dir token
        if ((ET_ERROR != returnVal) &&
            (NULL != (pCurrentToken = ANSIStrStr(*ppStr, BEGIN_URL_TOKEN))))
        {
            // Bookmark token found
            // Verify that other needed tokens exist or it's an error
            if ((NULL == (pszTemp = ANSIStrStr(pCurrentToken, END_URL_TOKEN))) ||
                (NULL == (pszTemp = ANSIStrStr(pszTemp, BEGIN_BOOKMARK_TOKEN))) ||
                (NULL == ANSIStrStr(pszTemp, END_BOOKMARK_TOKEN)))
            {
                returnVal = ET_ERROR;       // We can't find all the tokens needed.
            }
            else
            {
                // See if this token comes before TheToken.
                if ((NULL == pTheToken) || (pCurrentToken < pTheToken))
                {
                    // This function has to set *ppToken to the name of the bookmark
                    *ppToken =  pCurrentToken + sizeof(BEGIN_URL_TOKEN)-1;
                    pTheToken = pCurrentToken;
                    returnVal = ET_BOOKMARK;
                }
            }
        }
    }
    else
        returnVal = ET_ERROR;               // We should never get here.

    if (NULL == pTheToken)
        returnVal = ET_NONE;
    else
    {
        // Next time we will start parsing where we left off.
        switch(returnVal)
        {
            case ET_OPEN_DIR:
                *ppStr = ANSIStrStr(pTheToken, MID_DIR_TOKEN) + sizeof(MID_DIR_TOKEN);
                break;
            case ET_CLOSE_DIR:
                *ppStr = pTheToken + sizeof(BEGIN_EXITDIR_TOKEN);
                break;
            case ET_BOOKMARK:
                *ppStr = ANSIStrStr(pTheToken, END_BOOKMARK_TOKEN) + sizeof(END_BOOKMARK_TOKEN);
                break;
            default:
                break;
    }
    }

    return(returnVal);
}


/************************************************************\
    FUNCTION: GetPathFromRegistry

    PARAMETERS:
    LPSTR szPath    - The value found in the registry. (Result of function)
    UINT cbPath     - Size of szPath.
    HKEY theHKEY    - The HKEY to look into (HKEY_CURRENT_USER)
    LPSTR szKey     - Path in Registry (Software\...\Explore\Shell Folders)
    LPSTR szVName   - Value to query (Favorites)
    BOOL return     - TRUE if succeeded, FALSE if Error.
    EXAMPLE:
    HKEY_CURRENT_USER\Software\Microsoft\CurrentVersion\Explore\Shell Folders
    Favorites = "C:\WINDOWS\Favorites"

    DESCRIPTION:
    This function will look in the registry for the value
    to look up.  The caller specifies the HKEY, subkey (szKey),
    value to query (szVName).  The caller also sets a side memory
    for the result and passes a pointer to that memory in szPath
    with it's size in cbPath.  The BOOL return value will indicate
    success or failure of this function.
\************************************************************/

BOOL GetPathFromRegistry(LPSTR szPath, UINT cbPath, HKEY theHKEY,
                LPSTR szKey, LPSTR szVName)
{
    HKEY    hkPath  = NULL;
    DWORD   dwType;
    DWORD   dwSize;

    /*
     * Get Path to program
     *      from the registry
     */
    if (ERROR_SUCCESS != RegOpenKeyEx(theHKEY, szKey, 0, KEY_READ, &hkPath))
    {
    return(FALSE);
    }
    dwSize = cbPath;
    if (ERROR_SUCCESS != RegQueryValueEx(hkPath, szVName, NULL, &dwType, (LPBYTE) szPath, &dwSize))
    {
    RegCloseKey(hkPath);
    hkPath = NULL;
    return(FALSE);
    }
    RegCloseKey(hkPath);
    hkPath = NULL;

    /*
     * If we got nothing or it wasn't a string then
     * we bail out
     */
    if ((dwSize == 0) || (dwType != REG_SZ))
    return(FALSE);

    return(TRUE);
}


/************************************************************\
    FUNCTION: RemoveInvalidFileNameChars

    PARAMETERS:
    char * pBuf     - The data to search.

    DESCRIPTION:
    This function will search pBuf until it encounters
    a character that is not allowed in a file name.  It will
    then replace that character with a SPACE and continue looking
    for more invalid chars until they have all been removed.
\************************************************************/

void RemoveInvalidFileNameChars(char * pBuf)
{
    //ASSERTSZ(NULL != pBuf, "Invalid function parameter");

    // Go through the array of chars, replacing offending characters with a space
    if (NULL != pBuf)
    {
    if (REASONABLE_NAME_LEN < strlen(pBuf))
        pBuf[REASONABLE_NAME_LEN] = '\0';   // String too long. Terminate it.

    while ('\0' != *pBuf)
    {
        // Check if the character is invalid
        if (!IsDBCSLeadByte(*pBuf))
        {
        if  (ANSIStrChr(szInvalidFolderCharacters, *pBuf) != NULL)
            *pBuf = '_';
        }
#if 0
// Old code
        // We look in the array to see if the character is supported by FAT.
        // The array only includes the first 128 values, so we need to fail
        // on the other 128 values that have the high bit set.
        if (((AnsiMaxChar <= *pBuf) && (FALSE == IsDBCSLeadByte(*pBuf))) ||
        (0 == LocalLegalAnsiCharacterArray[*pBuf]))
        *pBuf = '$';
#endif
        pBuf = CharNext(pBuf);
    }
    }
}



/************************************************************\
    FUNCTION: CreateBookmark

    PARAMETERS:
    char * pBookmarkName- This is a pointer that contains
              the name of the bookmark to create.
              Note that it is not NULL terminated.
    BOOL return     - Return TRUE if successful.

    DESCRIPTION:
    This function will take the data that is passed to
    it and extract the name of the bookmark and it's value to create.
    If the name is too long, it will be truncated.  Then,
    the directory will be created.  Any errors encountered
    will cause the function to return FALSE to indicate
    failure.
\************************************************************/

BOOL CreateBookmark(char *pBookmarkName)
{
    BOOL    fSuccess                = FALSE;
    char    szNameOfBM[REASONABLE_NAME_LEN];
    char    szURL[MAX_URL];
    char    * pstrEndOfStr          = NULL;
    char    * pstrBeginOfName       = NULL;
    long    lStrLen                 = 0;
    HANDLE  hFile                   = NULL;
    DWORD   dwSize;
    char    szBuf[MAX_URL];

    //ASSERTSZ(NULL != pBookmarkName, "Bad input parameter");
    if (NULL != pBookmarkName)
    {
    pstrEndOfStr = ANSIStrStr(pBookmarkName, END_URL_TOKEN);
    if (NULL != pstrEndOfStr)
    {
        lStrLen = (long)(pstrEndOfStr-pBookmarkName);
        if (MAX_URL < lStrLen)
        lStrLen = MAX_URL-1;

        // Create the name of the Bookmark
        lstrcpyn(szURL, pBookmarkName, MAX_URL);
        szURL[lStrLen] = '\0';

        pstrBeginOfName = ANSIStrStr(pstrEndOfStr, BEGIN_BOOKMARK_TOKEN);
        if (NULL != pstrBeginOfName)
        {
        pstrBeginOfName += sizeof(BEGIN_BOOKMARK_TOKEN) - 1;            // Start at beginning of Name

        pstrEndOfStr = ANSIStrStr(pstrBeginOfName, END_BOOKMARK_TOKEN); // Find end of name
        if (NULL != pstrEndOfStr)
        {
            lStrLen = (long)(pstrEndOfStr-pstrBeginOfName);
            if (REASONABLE_NAME_LEN-FILE_EXT < lStrLen)
            lStrLen = REASONABLE_NAME_LEN-FILE_EXT-1;

            // Generate the URL
            lstrcpyn(szNameOfBM, pstrBeginOfName, lStrLen+1);
            //szNameOfBM[lStrLen] = '\0';
            lstrcat(szNameOfBM, ".url");
            RemoveInvalidFileNameChars(szNameOfBM);


            // Check to see if Favorite w/same name exists
            if (INVALID_HANDLE_VALUE != (hFile = CreateFile(szNameOfBM, GENERIC_WRITE, FILE_SHARE_READ, NULL,
                                 CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL )))
            {
                WriteFile(hFile, "[InternetShortcut]\n", lstrlen( "[InternetShortcut]\n" ), &dwSize, NULL);
                wsprintf( szBuf, "URL=%s\n", szURL);
                WriteFile(hFile, szBuf, lstrlen(szBuf), &dwSize, NULL );
                fSuccess = TRUE;
            }
            else
            {
                fSuccess = TRUE;
            }

            if (NULL != hFile)
            {
                CloseHandle( hFile );
                hFile = NULL;
            }

        }
        }
    }
    }

    return(fSuccess);
}


/************************************************************\
    FUNCTION: CreateDir

    PARAMETERS:
    char * pDirName - This is a pointer that contains
              the name of the directory to create.
              Note that it is not NULL terminated.
    BOOL return     - Return TRUE if successful.

    DESCRIPTION:
    This function will take the data that is passed to
    it and extract the name of the directory to create.
    If the name is too long, it will be truncated.  Then,
    the directory will be created.  Any errors encountered
    will cause the function to return FALSE to indicate
    failure.
\************************************************************/
BOOL CreateDir(char *pDirName)
{
    BOOL    fSuccess                = FALSE;
    char    szNameOfDir[REASONABLE_NAME_LEN];
    char    * pstrEndOfName         = NULL;
    long    lStrLen                 = 0;

    //ASSERTSZ(NULL != pDirName, "Bad input parameter");
    if (NULL != pDirName)
    {
        pstrEndOfName = ANSIStrStr(pDirName, END_DIR_TOKEN);
        if (NULL != pstrEndOfName)
        {
            lStrLen = (long)(pstrEndOfName-pDirName);
            if (REASONABLE_NAME_LEN < lStrLen)
            lStrLen = REASONABLE_NAME_LEN-1;

            lstrcpyn(szNameOfDir, pDirName, lStrLen+1);
            //szNameOfDir[lStrLen] = '\0';
            RemoveInvalidFileNameChars(szNameOfDir);

            // BUGBUG : Try to CD into existing dir first
            if ( !SetCurrentDirectory(szNameOfDir) )
            {
                if ( CreateDirectory(szNameOfDir, NULL) )
                {
                    if ( SetCurrentDirectory(szNameOfDir) )
                    {
                        fSuccess = TRUE;// It didn't exist, but now it does.
                    }
                }
            }
            else
                fSuccess = TRUE;        // It exists already.
        }
    }

    return(fSuccess);
}


/************************************************************\
    FUNCTION: CloseDir

    PARAMETERS:
    BOOL return     - Return TRUE if successful.

    DESCRIPTION:
    This function will back out of the current directory.
\************************************************************/
BOOL CloseDir(void)
{
    return( SetCurrentDirectory("..") );
}


/************************************************************\
    FUNCTION: VerifyBookmarksFile

    PARAMETERS:
    FILE * pFile    - Pointer to Netscape Bookmarks file.
    BOOL return     - TRUE if No Error and Valid Bookmark file

    DESCRIPTION:
    This function needs to be passed with a valid pointer
    that points to an open file.  Upon return, the file will
    still be open and is guarenteed to have the file pointer
    point to the beginning of the file.
    This function will return TRUE if the file contains
    text that indicates it's a valid Netscape bookmarks file.
\************************************************************/

BOOL VerifyBookmarksFile(HANDLE hFile)
{
    BOOL    fSuccess            = FALSE;
    char    szFileHeader[sizeof(VALIDATION_STR)+1] = "";
    DWORD   dwSize;

    //ASSERTSZ(NULL != pFile, "You can't pass me a NULL File Pointer");
    if (INVALID_HANDLE_VALUE == hFile)
        return(FALSE);

    // Reading the first part of the file.  If the file isn't this long, then
    // it can't possibly be a Bookmarks file.
    if ( ReadFile( hFile, szFileHeader, sizeof(VALIDATION_STR)-1, &dwSize, NULL ) && (dwSize == sizeof(VALIDATION_STR)-1) )
    {
        szFileHeader[sizeof(VALIDATION_STR)] = '\0';            // Terminate String.
        if (0 == lstrcmp(szFileHeader, VALIDATION_STR))          // See if header is the same as the Validation string.
            fSuccess = TRUE;
    }

    // Reset the point to point to the beginning of the file.
    dwSize = SetFilePointer( hFile, 0, NULL, FILE_BEGIN );
    if ( dwSize == 0xFFFFFFFF )
         fSuccess = FALSE;

    return(fSuccess);
}



/************************************************************\
    FUNCTION: GetData

    PARAMETERS:
    char ** ppData  - Where to put the data
    FILE * pFile    - Pointer to Netscape Bookmarks file.
    BOOL return     - Return TRUE is successful.

    DESCRIPTION:
    This function will find the size of the bookmarks file,
    malloc that much memory, and put the file's contents in
    that buffer.  ppData will be invalid when the function
    is called and will return with malloced memory that
    needs to be freed by the falling function.
\************************************************************/

BOOL GetData(char ** ppData, HANDLE hFile)
{
    DWORD  dwlength, dwRead;
    BOOL   fSuccess = FALSE;

    //ASSERTSZ(NULL != ppData, "Invalid input parameter");

    if (NULL != ppData)
    {
        *ppData = NULL;

        // Find the size of the data
        if ( dwlength = GetFileSize(hFile, NULL))
        {
            *ppData = (PSTR)LocalAlloc(LPTR, dwlength+1 );
            if (NULL != *ppData)
            {
                if ( ReadFile( hFile, *ppData, dwlength+1, &dwRead, NULL ) &&
                     ( dwlength == dwRead ) )
                {
                    fSuccess = TRUE;
                }

                (*ppData)[dwlength] = '\0';
            }
        }
    }

    return(fSuccess);
}


BOOL GetNavBkMkDir( LPSTR lpszDir, int isize )
{
    char    szDir[MAX_PATH];
    HKEY    hKey;
    HKEY    hKeyUser;
    char    szUser[MAX_PATH];
    DWORD   dwSize;
    BOOL    bDirFound = FALSE;

    lstrcpy( szUser, REGSTR_PATH_APPPATHS );
    AddPath( szUser, "NetScape.exe" );
    if ( GetPathFromRegistry( szDir, MAX_PATH, HKEY_LOCAL_MACHINE, szUser, "" ) &&
         lstrlen(szDir) )
    {
        DWORD dwMV, dwLV;

        if ( SUCCEEDED(GetVersionFromFile( szDir, &dwMV, &dwLV, TRUE)) )
        {
            if ( dwMV < 0x00040000 )
            {
                bDirFound = GetPathFromRegistry( lpszDir, isize, HKEY_CURRENT_USER,
                                                 szNetscapeBMRegSub, szNetscapeBMRegKey);
            }
            else
            {
                if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, "Software\\Netscape\\Netscape Navigator\\Users", 0, KEY_READ, &hKey) == ERROR_SUCCESS)
                {
                    dwSize = sizeof(szUser);
                    if (RegQueryValueEx(hKey, "CurrentUser", NULL, NULL, (LPBYTE)szUser, &dwSize) == ERROR_SUCCESS)
                    {
                        if (RegOpenKeyEx(hKey, szUser, 0, KEY_READ, &hKeyUser) == ERROR_SUCCESS)
                        {
                            dwSize = sizeof(szDir);
                            if (RegQueryValueEx(hKeyUser, "DirRoot", NULL, NULL, (LPBYTE)szDir, &dwSize) == ERROR_SUCCESS)
                            {
                                // Found the directory for the current user.
                                lstrcpy( lpszDir, szDir);
                                AddPath( lpszDir, "bookmark.htm" );
                                bDirFound = TRUE;
                            }
                            RegCloseKey(hKeyUser);
                        }
                    }
                    RegCloseKey(hKey);
                }

                if (!bDirFound)
                {
                    szUser[0] = '\0';
                    // NAV 4.5 is not writing the above keys. there is a different way of finding the user dir.
                    if (RegOpenKeyEx(HKEY_CURRENT_USER, "Software\\Netscape\\Netscape Navigator\\biff", 0, KEY_QUERY_VALUE, &hKey) == ERROR_SUCCESS)
                    {
                        dwSize = sizeof(szUser);
                        if (RegQueryValueEx(hKey, "CurrentUser", NULL, NULL, (LPBYTE)szUser, &dwSize) == ERROR_SUCCESS)
                        {
                            // Have the current user name. Now get the root folder where the user folder are.
                            if (RegOpenKeyEx(HKEY_CURRENT_USER, "Software\\Netscape\\Netscape Navigator\\Main", 0, KEY_QUERY_VALUE, &hKeyUser) == ERROR_SUCCESS)
                            {
                                dwSize = sizeof(szDir);
                                if (RegQueryValueEx(hKeyUser, "Install Directory", NULL, NULL, (LPBYTE)szDir, &dwSize) == ERROR_SUCCESS)
                                {
                                    // Got the install folder.
                                    // Need to the the parent folder and then append users\%s , %s gets replaced with
                                    // the CurrentUser name.
                                    if (GetParentDir(szDir))
                                    {
                                        AddPath(szDir, "Users");
                                        AddPath(szDir, szUser);
                                        AddPath(szDir, "bookmark.htm" );
                                        bDirFound = TRUE;
                                        lstrcpy(lpszDir, szDir);
                                    }

                                }
                                RegCloseKey(hKeyUser);
                            }

                        }
                        RegCloseKey(hKey);
                    }
                }
            }
        }
    }
    else
        bDirFound = GetPathFromRegistry( lpszDir, isize, HKEY_CURRENT_USER,
                                         szNetscapeBMRegSub, szNetscapeBMRegKey);

    return bDirFound;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\ie4uinit\path.cpp ===
#include "priv.h"
#include "advpub.h"
#include "sdsutils.h"
#include "utils.h"

#ifdef WINNT_ENV
#include <winnlsp.h>    // Get private NORM_ flag for StrEqIntl()
#endif

#ifndef NORM_STOP_ON_NULL     // Until we sync up with nt headers again...
#define NORM_STOP_ON_NULL         0x10000000   /* stop at the null termination */
#endif

#define StrIntlEqNI( s1, s2, nChar) StrIsIntlEqualA( TRUE, s1, s2, nChar)

static const TCHAR c_szPATH[] = TEXT("PATH");
static const TCHAR c_szEllipses[] = TEXT("...");
static const TCHAR c_szColonSlash[] = TEXT(":\\");
//
// Inline function to check for a double-backslash at the
// beginning of a string
//

static __inline BOOL DBL_BSLASH(LPCTSTR psz)
{
    return (psz[0] == TEXT('\\') && psz[1] == TEXT('\\'));
}

BOOL RunningOnNT(void)
{
    OSVERSIONINFO VerInfo;

    VerInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    GetVersionEx(&VerInfo);

    return (VerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT);
}

// rips the last part of the path off including the backslash
//      C:\foo      -> C:\      ;
//      C:\foo\bar  -> C:\foo
//      C:\foo\     -> C:\foo
//      \\x\y\x     -> \\x\y
//      \\x\y       -> \\x
//      \\x         -> ?? (test this)
//      \foo        -> \  (Just the slash!)
//
// in/out:
//      pFile   fully qualified path name
// returns:
//      TRUE    we stripped something
//      FALSE   didn't strip anything (root directory case)
//

BOOL PathRemoveFileSpec(LPTSTR pFile)
{
    LPTSTR pT;
    LPTSTR pT2 = pFile;

    for (pT = pT2; *pT2; pT2 = CharNext(pT2)) {
        if (*pT2 == TEXT('\\'))
            pT = pT2;             // last "\" found, (we will strip here)
        else if (*pT2 == TEXT(':')) {   // skip ":\" so we don't
            if (pT2[1] ==TEXT('\\'))    // strip the "\" from "C:\"
                pT2++;
            pT = pT2 + 1;
        }
    }
    if (*pT == 0)
        return FALSE;   // didn't strip anything

    //
    // handle the \foo case
    //
    else if ((pT == pFile) && (*pT == TEXT('\\'))) {
        // Is it just a '\'?
        if (*(pT+1) != TEXT('\0')) {
            // Nope.
            *(pT+1) = TEXT('\0');
            return TRUE;        // stripped something
        }
        else        {
            // Yep.
            return FALSE;
        }
    }
    else {
        *pT = 0;
        return TRUE;    // stripped something
    }
}


// Returns a pointer to the last component of a path string.
//
// in:
//      path name, either fully qualified or not
//
// returns:
//      pointer into the path where the path is.  if none is found
//      returns a poiter to the start of the path
//
//  c:\foo\bar  -> bar
//  c:\foo      -> foo
//  c:\foo\     -> c:\foo\      (REVIEW: is this case busted?)
//  c:\         -> c:\          (REVIEW: this case is strange)
//  c:          -> c:
//  foo         -> foo


LPTSTR PathFindFileName(LPCTSTR pPath)
{
    LPCTSTR pT;

    for (pT = pPath; *pPath; pPath = CharNext(pPath)) {
        if ((pPath[0] == TEXT('\\') || pPath[0] == TEXT(':') || pPath[0] == TEXT('/'))
            && pPath[1] &&  pPath[1] != TEXT('\\')  &&   pPath[1] != TEXT('/'))
            pT = pPath + 1;
    }

    return (LPTSTR)pT;   // const -> non const
}

//---------------------------------------------------------------------------
// Returns TRUE if the given string is a UNC path.
//
// TRUE
//      "\\foo\bar"
//      "\\foo"         <- careful
//      "\\"
// FALSE
//      "\foo"
//      "foo"
//      "c:\foo"
//
// Cond:    Note that SHELL32 implements its own copy of this
//          function.

BOOL PathIsUNC(LPCTSTR pszPath)
{
    return DBL_BSLASH(pszPath);
}



//---------------------------------------------------------------------------
// Returns 0 through 25 (corresponding to 'A' through 'Z') if the path has
// a drive letter, otherwise returns -1.
//
//
// Cond:    Note that SHELL32 implements its own copy of this
//          function.

int PathGetDriveNumber(LPCTSTR lpsz)
{
    if (!IsDBCSLeadByte(lpsz[0]) && lpsz[1] == TEXT(':'))
    {
        if (lpsz[0] >= TEXT('a') && lpsz[0] <= TEXT('z'))
            return (lpsz[0] - TEXT('a'));
        else if (lpsz[0] >= TEXT('A') && lpsz[0] <= TEXT('Z'))
            return (lpsz[0] - TEXT('A'));
    }
    return -1;
}

//---------------------------------------------------------------------------
// Returns TRUE if the given string is a UNC path to a server only (no share name).
//
// TRUE
//      "\\foo"         <- careful
//      "\\"
// FALSE
//      "\\foo\bar"
//      "\foo"
//      "foo"
//      "c:\foo"

BOOL PathIsUNCServer(LPCTSTR pszPath)
{
    if (DBL_BSLASH(pszPath))
    {
        int i = 0;
        LPTSTR szTmp;

        for (szTmp = (LPTSTR)pszPath; szTmp && *szTmp; szTmp = CharNext(szTmp) )
        {
            if (*szTmp==TEXT('\\'))
            {
                i++;
            }
        }

       return (i == 2);
    }

    return FALSE;
}



/*----------------------------------------------------------
Purpose: Determines if pszPath is a directory.  "C:\" is
         considered a directory too.

Returns: TRUE if it is

Cond:    Note that SHELL32 implements its own copy of this
         function.
*/
BOOL PathIsDirectory(LPCTSTR pszPath)
{
    DWORD dwAttribs;

    // SHELL32's PathIsDirectory also handles server/share
    // paths, but calls WNet APIs, which we cannot call.

    if (PathIsUNCServer(pszPath))
    {
        return FALSE;
    }
    else
    {
        dwAttribs = GetFileAttributes(pszPath);
        if (dwAttribs != (DWORD)-1)
            return (BOOL)(dwAttribs & FILE_ATTRIBUTE_DIRECTORY);
    }

    return FALSE;
}

// check if a path is a root
//
// returns:
//  TRUE for "\" "X:\" "\\foo\asdf" "\\foo\"
//  FALSE for others

BOOL PathIsRoot(LPCTSTR pPath)
{
    if (!IsDBCSLeadByte(*pPath))
    {
        if (!lstrcmpi(pPath + 1, c_szColonSlash))                  // "X:\" case
            return TRUE;
    }

    if ((*pPath == TEXT('\\')) && (*(pPath + 1) == 0))        // "\" case
        return TRUE;

    if (DBL_BSLASH(pPath))      // smells like UNC name
    {
        LPCTSTR p;
        int cBackslashes = 0;

        for (p = pPath + 2; *p; p = CharNext(p)) {
            if (*p == TEXT('\\') && (++cBackslashes > 1))
               return FALSE;   /* not a bare UNC name, therefore not a root dir */
        }
        return TRUE;    /* end of string with only 1 more backslash */
                        /* must be a bare UNC, which looks like a root dir */
    }
    return FALSE;
}

// Removes a trailing backslash from a path
//
// in:
//  lpszPath    (A:\, C:\foo\, etc)
//
// out:
//  lpszPath    (A:\, C:\foo, etc)
//
// returns:
//  ponter to NULL that replaced the backslash
//  or the pointer to the last character if it isn't a backslash.

LPTSTR PathRemoveBackslash( LPTSTR lpszPath )
{
    int len = lstrlen(lpszPath)-1;
    if (IsDBCSLeadByte(*CharPrev(lpszPath,lpszPath+len+1)))
        len--;

    if (!PathIsRoot(lpszPath) && lpszPath[len] == TEXT('\\'))
        lpszPath[len] = TEXT('\0');

    return lpszPath + len;

}

// find the next slash or null terminator

static LPCTSTR StrSlash(LPCTSTR psz)
{
    for (; *psz && *psz != TEXT('\\'); psz = CharNext(psz));

    return psz;
}


/*
 * IntlStrEq
 *
 * returns TRUE if strings are equal, FALSE if not
 */
BOOL StrIsIntlEqualA(BOOL fCaseSens, LPCSTR lpString1, LPCSTR lpString2, int nChar) {
    int retval;
    DWORD dwFlags = fCaseSens ? LOCALE_USE_CP_ACP : (NORM_IGNORECASE | LOCALE_USE_CP_ACP);

    if ( RunningOnNT() )
    {
        // On NT we can tell CompareString to stop at a '\0' if one is found before nChar chars
        //
        dwFlags |= NORM_STOP_ON_NULL;
    }
    else if (nChar != -1)
    {
        // On Win9x we have to do the check manually
        //
        LPCSTR psz1, psz2;
        int cch = 0;

        psz1 = lpString1;
        psz2 = lpString2;

        while( *psz1 != '\0' && *psz2 != '\0' && cch < nChar) {
            psz1 = CharNextA(psz1);
            psz2 = CharNextA(psz2);

            cch = min((int)(psz1 - lpString1), (int)(psz2 - lpString2));
        }

        // add one in for terminating '\0'
        cch++;

        if (cch < nChar) {
            nChar = cch;
        }
    }

    retval = CompareStringA( GetThreadLocale(),
                             dwFlags,
                             lpString1,
                             nChar,
                             lpString2,
                             nChar );
    if (retval == 0)
    {
        //
        // The caller is not expecting failure.  Try the system
        // default locale id.
        //
        retval = CompareStringA( LOCALE_SYSTEM_DEFAULT,
                                 dwFlags,
                                 lpString1,
                                 nChar,
                                 lpString2,
                                 nChar );
    }

    return (retval == 2);

}


//
// in:
//      pszFile1 -- fully qualified path name to file #1.
//      pszFile2 -- fully qualified path name to file #2.
//
// out:
//      pszPath  -- pointer to a string buffer (may be NULL)
//
// returns:
//      length of output buffer not including the NULL
//
// examples:
//      c:\win\desktop\foo.txt
//      c:\win\tray\bar.txt
//      -> c:\win
//
//      c:\                                ;
//      c:\                                ;
//      -> c:\  NOTE, includes slash
//
// Returns:
//      Length of the common prefix string usually does NOT include
//      trailing slash, BUT for roots it does.
//

int
PathCommonPrefix(
    LPCTSTR pszFile1,
    LPCTSTR pszFile2,
    LPTSTR  pszPath)
{
    LPCTSTR psz1, psz2, pszNext1, pszNext2, pszCommon;
    int cch;

    pszCommon = NULL;
    if (pszPath)
        *pszPath = TEXT('\0');

    psz1 = pszFile1;
    psz2 = pszFile2;

    // special cases for UNC, don't allow "\\" to be a common prefix

    if (DBL_BSLASH(pszFile1))
    {
        if (!DBL_BSLASH(pszFile2))
            return 0;

        psz1 = pszFile1 + 2;
    }
    if (DBL_BSLASH(pszFile2))
    {
        if (!DBL_BSLASH(pszFile1))
            return 0;

        psz2 = pszFile2 + 2;
    }

    while (1)
    {
        //ASSERT(*psz1 != TEXT('\\') && *psz2 != TEXT('\\'));

        pszNext1 = StrSlash(psz1);
        pszNext2 = StrSlash(psz2);

        cch = (int)(pszNext1 - psz1);

        if (cch != (pszNext2 - psz2))
            break;      // lengths of segments not equal

        if (StrIntlEqNI(psz1, psz2, cch))
            pszCommon = pszNext1;
        else
            break;

        //ASSERT(*pszNext1 == TEXT('\0') || *pszNext1 == TEXT('\\'));
        //ASSERT(*pszNext2 == TEXT('\0') || *pszNext2 == TEXT('\\'));

        if (*pszNext1 == TEXT('\0'))
            break;

        psz1 = pszNext1 + 1;

        if (*pszNext2 == TEXT('\0'))
            break;

        psz2 = pszNext2 + 1;
    }

    if (pszCommon)
    {
        cch = (int)(pszCommon - pszFile1);

        // special case the root to include the slash
        if (cch == 2)
        {
            //ASSERT(pszFile1[1] == TEXT(':'));
            cch++;
        }
    }
    else
        cch = 0;

    if (pszPath)
    {
        CopyMemory(pszPath, pszFile1, cch * sizeof(TCHAR));
        pszPath[cch] = TEXT('\0');
    }

    return cch;
}


/*----------------------------------------------------------
Purpose: Returns TRUE if pszPrefix is the full prefix of pszPath.

Returns:
Cond:    --
*/
BOOL PathIsPrefix( LPCTSTR  pszPrefix, LPCTSTR  pszPath)
{
    int cch = PathCommonPrefix(pszPath, pszPrefix, NULL);

    return (lstrlen(pszPrefix) == cch);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\ie4uinit\utils.h ===
//////////////////////////////////////////////////////////////////////////////////////////////////
//
//  utils.h
//
//      This file contains most commonly used string operation.  ALl the setup project should link here
//  or add the common utility here to avoid duplicating code everywhere or using CRT runtime.
//
//  Created             4\15\997        inateeg
//
///////////////////////////////////////////////////////////////////////////////////////////////////
#ifndef _UTILS_H_
#define _UTILS_H_



#define IsSpace(c)  ((c) == ' '  ||  (c) == '\t'  ||  (c) == '\r'  ||  (c) == '\n'  ||  (c) == '\v'  ||  (c) == '\f')
#define IsDigit(c)  ((c) >= '0'  &&  (c) <= '9')
#define IsAlpha(c)  ( ((c) >= 'A'  &&  (c) <= 'Z') || ((c) >= 'a'  &&  (c) <= 'z'))

BOOL PathRemoveFileSpec(LPTSTR pFile);
LPTSTR PathFindFileName(LPCTSTR pPath);
BOOL PathIsUNC(LPCTSTR pszPath);
int PathGetDriveNumber(LPCTSTR lpsz);
BOOL PathIsUNCServer(LPCTSTR pszPath);
BOOL PathIsDirectory(LPCTSTR pszPath);
BOOL PathIsRoot(LPCTSTR pPath);
LPTSTR PathRemoveBackslash( LPTSTR lpszPath );
BOOL PathIsPrefix( LPCTSTR  pszPrefix, LPCTSTR  pszPath);

DWORD
SDSQueryValueExA(
    IN     HKEY    hkey,
    IN     LPCSTR  pszValue,
    IN     LPDWORD lpReserved,
    OUT    LPDWORD pdwType,
    OUT    LPVOID  pvData,
    IN OUT LPDWORD pcbData);


#endif //  _UTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\iedetect\iedetect.h ===
#ifndef _IEDETECT_H
#define _IEDETECT_H
#include <inseng.h> 

extern HINSTANCE g_hInstance;
extern HANDLE g_hHeap;

// from inseng, cifcomp.h
#define ISINSTALLED_YES      1
#define ISINSTALLED_NO       0

#define COMPONENT_KEY "Software\\Microsoft\\Active Setup\\Installed Components"
#define IEXPLORE_APPPATH_KEY REGSTR_PATH_APPPATHS "\\iexplore.exe"

#define IE_KEY        "Software\\Microsoft\\Internet Explorer"


#define DEFAULT_LOCALE      "en"
#define ISINSTALLED_KEY     "IsInstalled"
#define LOCALE_KEY          "Locale"
#define VERSION_KEY         "Version"
#define BUILD_KEY           "Build"
#define QFE_VERSION_KEY     "QFEVersion"


#define IE_3_MS_VERSION 0x00040046
#define IE_4_MS_VERSION 0x00040047
// Build number 1712.0 (IE4.0 RTW)
#define IE_4_LS_VERSION 0x06B00000

// Version numver 5.0
#define IE_5_MS_VERSION 0x00050000
#define IE_5_LS_VERSION 0x00000000

// Version numver 6.0
#define IE_6_MS_VERSION 0x00060000
#define IE_6_LS_VERSION 0x00000000

// Note: for now we only allow 10 characters in the cPath part of the structure.
// If more characters are needed change the amount below.
typedef struct _DETECT_FILES
{
    char    cPath[10];
    char    szFilename[13];
    DWORD   dwMSVer;
    DWORD   dwLSVer;
} DETECT_FILES;

// From utils.cpp
int CompareLocales(LPCSTR pcszLoc1, LPCSTR pcszLoc2);
void ConvertVersionStrToDwords(LPSTR pszVer, char cDelimiter, LPDWORD pdwVer, LPDWORD pdwBuild);
DWORD GetStringField(LPSTR szStr, UINT uField, char cDelimiter, LPSTR szBuf, UINT cBufSize);
DWORD GetIntField(LPSTR szStr, char cDelimiter, UINT uField, DWORD dwDefault);
LPSTR FindChar(LPSTR pszStr, char ch);
BOOL FRunningOnNT(void);
DWORD CompareVersions(DWORD dwAskVer, DWORD dwAskBuild, DWORD dwInstalledVer, DWORD dwInstalledBuild);
BOOL GetVersionFromGuid(LPSTR pszGuid, LPDWORD pdwVer, LPDWORD pdwBuild);
BOOL CompareLocal(LPCSTR pszGuid, LPCSTR pszLocal);
VOID ReadFromWininitOrPFRO(PCSTR pcszKey, PSTR pszValue);
DWORD CheckFile(DETECT_FILES Detect_Files);
DWORD WINAPI DetectFile(DETECTION_STRUCT *pDet, LPSTR pszFilename);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\iedetect\ime.cpp ===
#include "pch.h"
#include "iedetect.h"

DWORD WINAPI DetectPrimaryLang(DETECTION_STRUCT *pDet, UINT cpID);
DWORD WINAPI DetectLCID(DETECTION_STRUCT *pDet, LCID lcid);
BOOL DetectCicero();

DWORD WINAPI DetectKoreanIME(DETECTION_STRUCT *pDet)
{
    if(DetectCicero())
        return DET_NEWVERSIONINSTALLED;
    else
        return DetectLCID(pDet, 1042);
}

DWORD WINAPI DetectJapaneseIME(DETECTION_STRUCT *pDet)
{
    if (DetectCicero())
        return DET_NEWVERSIONINSTALLED;
    else
        return DetectLCID(pDet, 1041);
}

DWORD WINAPI DetectTraditionalChineseIME(DETECTION_STRUCT *pDet)
{
    if (DetectCicero())
        return DET_NEWVERSIONINSTALLED;
    else
        return DetectLCID(pDet, 1028);
}

DWORD WINAPI DetectSimplifiedChineseIME(DETECTION_STRUCT *pDet)
{
    if (DetectCicero())
        return DET_NEWVERSIONINSTALLED;
    else
        return DetectLCID(pDet, 2052);
}

// Returns true if msctf.dll is installed on system
BOOL DetectCicero()
{
    char szFile[MAX_PATH] = {0};
    char szRenameFile[MAX_PATH] = {0}; 
    DWORD dwInstalledVer, dwInstalledBuild;

    GetSystemDirectory(szFile, sizeof(szFile));
    AddPath(szFile, "msctf.dll");
    ReadFromWininitOrPFRO(szFile, szRenameFile);
    if (*szRenameFile != '\0')
        GetVersionFromFile(szRenameFile, &dwInstalledVer, &dwInstalledBuild, TRUE);
    else
        GetVersionFromFile(szFile, &dwInstalledVer, &dwInstalledBuild, TRUE);
   
    return (dwInstalledVer != 0);
}

DWORD WINAPI DetectLCID(DETECTION_STRUCT *pDet, LCID lcid)
{
    DWORD   dwRet = DET_NOTINSTALLED;
    DWORD   dwInstalledVer, dwInstalledBuild;

    dwInstalledVer = dwInstalledBuild = (DWORD)-1;
    if (GetSystemDefaultLCID() == lcid)
    {
        dwRet = DET_NEWVERSIONINSTALLED;
    }
    else
    {
        if (GetVersionFromGuid(pDet->pszGUID, &dwInstalledVer, &dwInstalledBuild))
            dwRet = CompareVersions(pDet->dwAskVer, pDet->dwAskBuild, dwInstalledVer, dwInstalledBuild);
    }
    if (pDet->pdwInstalledVer && pDet->pdwInstalledBuild)
    {
        *(pDet->pdwInstalledVer) = dwInstalledVer;
        *(pDet->pdwInstalledBuild) = dwInstalledBuild;
    }

    return dwRet;
}

DWORD WINAPI DetectKoreanLangPack(DETECTION_STRUCT *pDet)
{
    return DetectPrimaryLang(pDet, 949);
}

DWORD WINAPI DetectJapaneseLangPack(DETECTION_STRUCT *pDet)
{
    return DetectPrimaryLang(pDet, 932);
}

DWORD WINAPI DetectSimpChineseLangPack(DETECTION_STRUCT *pDet)
{
    return DetectPrimaryLang(pDet, 936);
}

DWORD WINAPI DetectTradChineseLangPack(DETECTION_STRUCT *pDet)
{
    return DetectPrimaryLang(pDet, 950);
}


DWORD WINAPI DetectPrimaryLang(DETECTION_STRUCT *pDet, UINT cpID)
{
    DWORD   dwRet = DET_NOTINSTALLED;
    DWORD   dwInstalledVer, dwInstalledBuild;

    dwInstalledVer = dwInstalledBuild = (DWORD)-1;
    if (GetACP() == cpID)
    {
        dwRet = DET_NEWVERSIONINSTALLED;
    }
    else
    {
        if (GetVersionFromGuid(pDet->pszGUID, &dwInstalledVer, &dwInstalledBuild))
            dwRet = CompareVersions(pDet->dwAskVer, pDet->dwAskBuild, dwInstalledVer, dwInstalledBuild);
    }
    if (pDet->pdwInstalledVer && pDet->pdwInstalledBuild)
    {
        *(pDet->pdwInstalledVer) = dwInstalledVer;
        *(pDet->pdwInstalledBuild) = dwInstalledBuild;
    }

    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\ie4uinit\ie4uinit.cpp ===
#include "priv.h"
#include "advpub.h"
#include "sdsutils.h"
#include "utils.h"
#include "convert.h"
#include "regstr.h"


const TCHAR c_szAppName[]   = TEXT("ie4uinit");
const TCHAR c_szProfRecKey[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\ProfileReconciliation");
const TCHAR c_szHomeDirValue[] = TEXT("ProfileDirectory");
const TCHAR c_szExplorerKey[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders");
const TCHAR c_szIExploreMain[] = TEXT( "Software\\microsoft\\Internet Explorer\\Main" );
const TCHAR c_szIExplorerSearchUrl[] = TEXT( "Software\\microsoft\\Internet Explorer\\SearchUrl" );
const TCHAR c_szIExplorer[] = TEXT( "Software\\microsoft\\Internet Explorer" );

const TCHAR c_szCentralFile[] = TEXT("CentralFile");
const TCHAR c_szLocalFile[] = TEXT("LocalFile");
const TCHAR c_szName[] = TEXT("Name");
const TCHAR c_szRegKey[] = TEXT("RegKey");
const TCHAR c_szRegValue[] = TEXT("RegValue");
const TCHAR c_szMustBeRelative[] = TEXT("MustBeRelative");
const TCHAR c_szDefault[] = TEXT("Default");
const TCHAR c_szDefaultDir[] = TEXT("DefaultDir");
const TCHAR c_szIExploreLnk[] = TEXT("Internet Explorer.lnk" );
const TCHAR c_szIExploreBackLnk[] = TEXT("Internet Explorer Lnk.bak" );
const TCHAR c_szIExploreBackLnkIni[] = TEXT("IELnkbak.ini" );
const TCHAR c_szIESetupPath[] = TEXT( "software\\microsoft\\IE Setup\\setup" );
const TCHAR c_szIE4Path[] = TEXT( "software\\microsoft\\IE4" );
const TCHAR c_szAdvINFSetup[] = TEXT( "software\\microsoft\\Advanced INF Setup" );
const TCHAR c_szIEModRollback[] = TEXT( "IE CompList" );
const TCHAR c_szRegBackup[] = TEXT( "RegBackup" );
const TCHAR c_szInstallMode[]  = TEXT("InstallMode");
const TCHAR c_szStarDotStar[] = "*.*";
const TCHAR c_szSearchUrl[] = TEXT("CleanSearchUrl");

const TCHAR c_szPrevStubINF[] = TEXT("ie4uinit.inf");
const TCHAR c_szStubINFFile[] = TEXT("ieuinit.inf");
const TCHAR c_szActInstalledIEGUID[] = TEXT( "SOFTWARE\\Microsoft\\Active Setup\\Installed Components\\{89820200-ECBD-11cf-8B85-00AA005B4383}");
const TCHAR c_szActInstalledIEGUIDRestore[] = TEXT( "SOFTWARE\\Microsoft\\Active Setup\\Installed Components\\{89820200-ECBD-11cf-8B85-00AA005B4383}.Restore");
const TCHAR c_szMyDocsDLL[] = TEXT("\\mydocs.dll");

const TCHAR c_szIE4Setup[]= TEXT("Software\\Microsoft\\IE Setup\\Setup");
const TCHAR c_szPreIEVer[]= TEXT("PreviousIESysFile");
const TCHAR c_szPreShellVer[]= TEXT("PreviousShellFile");


typedef VOID (*LPFNMYDOCSINIT)(VOID);

// used only at install stub time
BOOL IsPrevIE4();
BOOL IsPrevIE4WebShell();
UINT CheckIEVersion();
void RemoveOldMouseException();
void ProcessMouseException();

// used at uninstall stub time
UINT CheckUninstIEVersion();

//
//====== DllGetVersion  =======================================================
//

typedef struct _DllVersionInfo
{
        DWORD cbSize;
        DWORD dwMajorVersion;                   // Major version
        DWORD dwMinorVersion;                   // Minor version
        DWORD dwBuildNumber;                    // Build number
        DWORD dwPlatformID;                     // DLLVER_PLATFORM_*
} DLLVERSIONINFO;

// Platform IDs for DLLVERSIONINFO
//#define DLLVER_PLATFORM_WINDOWS         0x00000001      // Windows 95
//#define DLLVER_PLATFORM_NT              0x00000002      // Windows NT

//
// The caller should always GetProcAddress("DllGetVersion"), not
// implicitly link to it.
//

typedef HRESULT (CALLBACK* DLLGETVERSIONPROC)(DLLVERSIONINFO *);
//
//====== DllGetVersion  =from shlwapi.h==========================================
//


HINSTANCE g_hinst;

BOOL g_fRunningOnNT = FALSE;
BOOL g_fRunningOnNT5 = FALSE;
BOOL g_fRunningOnWinXP = FALSE;
BOOL g_fRunningOnWin95 = FALSE;

// shlwapi.dll api
typedef void (* PFNSHFLUSHSFCACHEWRAP)();
PFNSHFLUSHSFCACHEWRAP pfnSHFlushSFCacheWrap = NULL;

// old shell32.dll api
typedef void (* PFNSHFLUSHSFCACHE)();
PFNSHFLUSHSFCACHE pfnSHFlushSFCache = NULL;


struct FolderDescriptor;
typedef void (* PFNINITFOLDER)(FolderDescriptor *pFolder, LPTSTR pszBaseName, LPTSTR pszUserDirectory);

void InitFolderFromDefault(FolderDescriptor *pFolder, LPTSTR pszBaseName, LPTSTR pszUserDirectory);
void InitFolderMyDocs(FolderDescriptor *pFolder, LPTSTR pszBaseName, LPTSTR pszUserDirectory);

struct FolderDescriptor {
    UINT idsDirName;        /* Resource ID for directory name */
    LPCTSTR pszRegKey;      /* Name of reg key under which to set path */
    LPCTSTR pszRegValue;    /* Name of reg value to set path in */
    LPCTSTR pszStaticName;  /* Static name for ProfileReconciliation subkey */
    LPCTSTR pszFiles;       /* Spec for which files should roam */
    PFNINITFOLDER InitFolder;   /* Function to init contents */
    DWORD dwAttribs;            /* Desired directory attributes */
    BOOL fIntShellOnly : 1;     /* TRUE if should not do this in browser only mode */
    BOOL fMustBePerUser : 1;    /* TRUE if should always be forced per-user on all platforms */
    BOOL fDefaultInRoot : 1;    /* TRUE if default location is root of drive, not windows dir */
    BOOL fWriteToUSF : 1;       /* TRUE if we should write to User Shell Folders to work around Win95 bug */
} aFolders[] = {
    { IDS_CSIDL_DESKTOP_L, c_szExplorerKey, TEXT("Desktop"), TEXT("Desktop"), c_szStarDotStar, InitFolderFromDefault, FILE_ATTRIBUTE_DIRECTORY, TRUE, FALSE, FALSE, FALSE } ,
    { IDS_CSIDL_RECENT_L, c_szExplorerKey, TEXT("Recent"), TEXT("Recent"), c_szStarDotStar, InitFolderFromDefault, FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_DIRECTORY, TRUE, FALSE, FALSE, FALSE } ,
    { IDS_CSIDL_NETHOOD_L, c_szExplorerKey, TEXT("NetHood"), TEXT("NetHood"), c_szStarDotStar, InitFolderFromDefault, FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_DIRECTORY, TRUE, FALSE, FALSE, FALSE } ,
    { IDS_CSIDL_PERSONAL_L, c_szExplorerKey, TEXT("Personal"), TEXT("Personal"), c_szStarDotStar, InitFolderMyDocs, FILE_ATTRIBUTE_DIRECTORY, TRUE, FALSE, TRUE, FALSE } ,
    { IDS_CSIDL_FAVORITES_L, c_szExplorerKey, TEXT("Favorites"), TEXT("Favorites"), c_szStarDotStar, InitFolderFromDefault, FILE_ATTRIBUTE_DIRECTORY, FALSE, FALSE, FALSE, TRUE },
    { IDS_CSIDL_APPDATA_L, c_szExplorerKey, TEXT("AppData"), TEXT("AppData"), c_szStarDotStar, InitFolderFromDefault, FILE_ATTRIBUTE_DIRECTORY, FALSE, TRUE, FALSE, FALSE },
    { IDS_CSIDL_CACHE_L, c_szExplorerKey, TEXT("Cache"), TEXT("Cache"), TEXT(""), NULL, FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_DIRECTORY, FALSE, FALSE, FALSE, FALSE },
    { IDS_CSIDL_COOKIES_L, c_szExplorerKey, TEXT("Cookies"), TEXT("Cookies"), c_szStarDotStar, NULL, FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_DIRECTORY, FALSE, TRUE, FALSE, FALSE },
    { IDS_CSIDL_HISTORY_L, c_szExplorerKey, TEXT("History"), TEXT("History"), c_szStarDotStar, NULL, FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_DIRECTORY, FALSE, TRUE, FALSE, FALSE },
};

// Verion number 4.71
#define IE_4_MS_VERSION 0x00040047
// Build number 1712.0 (IE4.0 RTW)
#define IE_4_LS_VERSION 0x06B00000
// IE5 Major version
#define IE_5_MS_VERSION 0x00050000
// IE5.5 Major version
#define IE_55_MS_VERSION 0x00050032
// IE6 (Whistler) Major version
#define IE_6_MS_VERSION 0x00060000

// check IE version return code
#define     LESSIE4 0
#define     IE4     1
#define     IE5     2
#define     IE55    3
#define     IE6     4   // Whistler


BOOL CheckWebViewShell(UINT *puiShell32)
{
    HINSTANCE           hInstShell32;
    DLLGETVERSIONPROC   fpGetDllVersion;
    char                szShell32[MAX_PATH];
    BOOL                bRet = FALSE;

    GetSystemDirectory(szShell32, sizeof(szShell32));
    AddPath(szShell32,"Shell32.dll");
    hInstShell32 = LoadLibrary(szShell32);
    if ( hInstShell32 )
    {
        DLLVERSIONINFO dllinfo;

        fpGetDllVersion = (DLLGETVERSIONPROC)GetProcAddress(hInstShell32, "DllGetVersion");
        bRet = (fpGetDllVersion != NULL);
        if (puiShell32 && fpGetDllVersion)
        {
            dllinfo.cbSize = sizeof(DLLVERSIONINFO);
            if ( fpGetDllVersion(&dllinfo) == NOERROR )
                *puiShell32 = dllinfo.dwMajorVersion;
            else
                *puiShell32 = 0;  // error case, should never be here
        }
        FreeLibrary(hInstShell32);
    }

    return bRet;
}

// this code need to be updated whenever the new major version is released!!
UINT CheckIEVersion()
{
    char szIE[MAX_PATH] = { 0 };
    DWORD   dwMSVer, dwLSVer;

    GetSystemDirectory(szIE, sizeof(szIE));
    AddPath(szIE, "shdocvw.dll");
    GetVersionFromFile(szIE, &dwMSVer, &dwLSVer, TRUE);

    if (dwMSVer < IE_4_MS_VERSION)
    {
        return LESSIE4;
    }

    if ((dwMSVer >= IE_4_MS_VERSION) && (dwMSVer < IE_5_MS_VERSION))
    {
        return IE4;
    }

    if ((dwMSVer >= IE_5_MS_VERSION) && (dwMSVer < IE_55_MS_VERSION))
    {
        return IE5;
    }

    if ((dwMSVer >= IE_55_MS_VERSION) && (dwMSVer < IE_6_MS_VERSION))
    {
        return IE55;
    }

    if (dwMSVer == IE_6_MS_VERSION)
    {
        return IE6;
    }

#ifdef DEBUG
    OutputDebugStringA("CheckIEVersion - unknown shdocvw.dll version# ! Need to add new IE_XX_MS_VERSION id\n");
    DebugBreak();
#endif

    return IE6;
}



void InitFolderFromDefault(FolderDescriptor *pFolder, LPTSTR pszBaseName, LPTSTR pszUserDirectory)
{
    SHFILEOPSTRUCT fos;
    TCHAR szFrom[MAX_PATH];

    lstrcpy(szFrom, pszBaseName);

    /* Before we build the complete source filespec, check to see if the
     * directory exists.  In the case of lesser-used folders such as
     * "Application Data", the default may not have ever been created.
     * In that case, we have no contents to copy.
     */
    DWORD dwAttr = GetFileAttributes(szFrom);
    if (dwAttr == 0xffffffff || !(dwAttr & FILE_ATTRIBUTE_DIRECTORY))
        return;

    AddPath(szFrom,"");
    lstrcat(szFrom, pFolder->pszFiles);
    szFrom[lstrlen(szFrom)+1] = '\0';   /* double null terminate from string */
    pszUserDirectory[lstrlen(pszUserDirectory)+1] = '\0';   /* and to string */

    fos.hwnd = NULL;
    fos.wFunc = FO_COPY;
    fos.pFrom = szFrom;
    fos.pTo = pszUserDirectory;
    fos.fFlags = FOF_NOCONFIRMATION | FOF_NOCONFIRMMKDIR | FOF_NOERRORUI;
    fos.fAnyOperationsAborted = FALSE;
    fos.hNameMappings = NULL;
    fos.lpszProgressTitle = NULL;

    SHFileOperation(&fos);
}

void InitFolderMyDocs(FolderDescriptor *pFolder, LPTSTR pszBaseName, LPTSTR pszUserDirectory)
{
    HRESULT hres = E_FAIL;
    TCHAR szFrom[MAX_PATH];
    TCHAR szPathDest[MAX_PATH];
    BOOL fCopyLnk;

    lstrcpy(szFrom, pszBaseName);

    /* Before we build the complete source filespec, check to see if the
     * directory exists.  In the case of lesser-used folders such as
     * "Application Data", the default may not have ever been created.
     * In that case, we have no contents to copy.
     */
    DWORD dwAttr = GetFileAttributes(szFrom);
    if (dwAttr == 0xffffffff || !(dwAttr & FILE_ATTRIBUTE_DIRECTORY))
        return;

    IShellLink *psl;
    if (FAILED(CoCreateInstance(CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER,
                                IID_IShellLink, (void **)&psl)))
        return;

    if (SHGetNewLinkInfo(szFrom,
                         pszUserDirectory, szPathDest, &fCopyLnk,
                         SHGNLI_PREFIXNAME)) {

        if (fCopyLnk) {
            if (GetFileAttributes(szPathDest) == 0xffffffff &&
                CopyFile(szFrom, szPathDest, TRUE)) {
                hres = S_OK;
                SHChangeNotify(SHCNE_CREATE, SHCNF_PATH, szPathDest, NULL);
                SHChangeNotify(SHCNE_FREESPACE, SHCNF_PATH, szPathDest, NULL);
            } else {
//                DebugMsg(TF_ERROR, TEXT("****copy failed (%d)"),GetLastError());
            }
        } else {
            IPersistFile *ppf;

            psl->SetPath(szFrom);

            //
            // make sure the working directory is set to the same
            // directory as the app (or document).
            //
            // dont do this for non-FS pidls (ie control panel)
            //
            // what about a UNC directory? we go ahead and set
            // it, wont work for a WIn16 app.
            //
            if (!PathIsDirectory(szFrom)) {
                PathRemoveFileSpec(szFrom);
                psl->SetWorkingDirectory(szFrom);
            }

            /* We only did the SHGetNewLinkInfo for the fCopyLnk flag;
             * load a resource string to get a more descriptive name
             * for the shortcut.
             */
            LPTSTR pszPathEnd = PathFindFileName(szPathDest);
            LoadString(g_hinst, IDS_MYDOCS_SHORTCUT, pszPathEnd, ARRAYSIZE(szPathDest) - (int)(pszPathEnd - szPathDest));

            if (GetFileAttributes(szPathDest) == 0xffffffff) {
                hres = psl->QueryInterface(IID_IPersistFile, (void **)&ppf);
                if (SUCCEEDED(hres)) {
#ifdef UNICODE
                    hres = ppf->Save(szPathDest, TRUE);
#else
                    WCHAR wszPath[MAX_PATH];
                    MultiByteToWideChar(CP_ACP, 0, szPathDest, -1, wszPath, ARRAYSIZE(wszPath));
                    hres = ppf->Save(wszPath, TRUE);
#endif
                    ppf->Release();
                }
            }
        }
    }

    psl->Release();


}


HRESULT SetupFolder(HKEY hkeyProfRec, LPTSTR pszHomeDir, LPTSTR pszHomeDirEnd,
                    int cchHomeDir, FolderDescriptor *pFolder, BOOL fDefaultProfile,
                    HKEY hkeyFolderPolicies)
{
    DWORD dwType, cbData;
    BOOL fMakeFolderPerUser;
    BOOL fGotFromPolicy = FALSE;

    /* Figure out whether to make this folder be per-user or not.  On NT we
     * make everything per-user.  Some folders (notably Application Data)
     * are also always per-user.  The default for everything else is to not
     * make it per-user here unless a policy is set to force it.  If we do
     * not want to make it per-user here, we'll just leave it the way it is;
     * of course, the folder could have already been made per-user by some
     * other means.
     *
     * "Make per-user" means set a profile-relative path if we're not operating
     * on the default profile, plus adding a ProfileReconciliation key on win95
     * (any profile, including default).
     */
    if (hkeyFolderPolicies != NULL) {
        DWORD dwFlag;
        cbData = sizeof(dwFlag);
        if (RegQueryValueEx(hkeyFolderPolicies, pFolder->pszStaticName, NULL,
                            &dwType, (LPBYTE)&dwFlag, &cbData) == ERROR_SUCCESS &&
            (dwType == REG_DWORD || (dwType == REG_BINARY && cbData == sizeof(dwFlag)))) {
            fMakeFolderPerUser = dwFlag;
            fGotFromPolicy = TRUE;
        }
    }
    if (!fGotFromPolicy)
        fMakeFolderPerUser = (g_fRunningOnNT || pFolder->fMustBePerUser);

    TCHAR szUserHomeDir[MAX_PATH];

    *pszHomeDirEnd = '\0';          /* strip off dir name from last time through */
    lstrcpy(szUserHomeDir, pszHomeDir);
    PathRemoveBackslash(szUserHomeDir);

    /* Get the localized name for the directory, as it should appear in
     * the file system.
     */
    int cchDir = LoadString(g_hinst, pFolder->idsDirName, pszHomeDirEnd, cchHomeDir);
    if (!cchDir)
        return HRESULT_FROM_WIN32(GetLastError());
    cchDir++;   /* count null character */

    /* Create the reg key where a pointer to the new directory is supposed to
     * be stored, and write the path there.
     */
    HKEY hkeyFolder;

    LONG err = RegCreateKeyEx(HKEY_CURRENT_USER, pFolder->pszRegKey,0, NULL, REG_OPTION_NON_VOLATILE,
                    KEY_READ|KEY_WRITE, NULL, &hkeyFolder, NULL);

    if (err != ERROR_SUCCESS)
        return HRESULT_FROM_WIN32(err);

    /* Build the default location for this directory (usually just under the
     * Windows directory, except for My Documents).  We'll use this as the
     * location to create if nothing is in the registry, and also to compare
     * the registry-set location to see if we should move it or leave it
     * alone.
     */

    TCHAR szDefaultDir[MAX_PATH];
    GetWindowsDirectory(szDefaultDir, ARRAYSIZE(szDefaultDir));

    if (pFolder->fDefaultInRoot) {
        LPTSTR pszRoot;
        if (PathIsUNC(szDefaultDir)) {
            pszRoot = ANSIStrChr(szDefaultDir, (WORD)'\\');
            if (pszRoot != NULL)
                pszRoot = ANSIStrChr(pszRoot+1, (WORD)'\\');
            if (pszRoot != NULL)
                *(pszRoot+1) = '\0';
        }
        else {
            pszRoot = CharNext(szDefaultDir);
            if (*pszRoot == ':')
                pszRoot++;
            if (*pszRoot == '\\')
                pszRoot++;
            *pszRoot = '\0';
        }
    }
    else {
        AddPath(szDefaultDir, "");
    }
    lstrcat(szDefaultDir, pszHomeDirEnd);

    /* Get the path that was recorded for this folder before we ran.  We will
     * use it as the default for migrating contents, unless it's not there or
     * it's already set to the new directory.  In either of those cases we use
     * the localized name, relative to the Windows directory.
     */
    TCHAR szOldDir[MAX_PATH];
    BOOL fDefaultLocation = FALSE;
    cbData = sizeof(szOldDir);
    szOldDir[0] = '\0';
    err = SDSQueryValueExA(hkeyFolder, pFolder->pszRegValue, 0, &dwType,
                         (LPBYTE)szOldDir, &cbData);

    BOOL fGotPathFromRegistry = (err == ERROR_SUCCESS);

    if (!fGotPathFromRegistry) {
        lstrcpy(szOldDir, szDefaultDir);
        if (!pFolder->fDefaultInRoot)
            fDefaultLocation = TRUE;
    }
    else {
        /* Previous path is present in the registry.  If it's a net path,
         * it's probably been set by system policies and we want to leave
         * it the way it is.
         */
        BOOL fIsNet = FALSE;
        if (PathIsUNC(szOldDir))
            fIsNet = TRUE;
        else {
            int nDriveNumber = PathGetDriveNumber(szOldDir);
            if (nDriveNumber != -1) {
                TCHAR szRootPath[4] = TEXT("X:\\");
                szRootPath[0] = nDriveNumber + TEXT('A');
                if (::GetDriveType(szRootPath) == DRIVE_REMOTE)
                    fIsNet = TRUE;
            }
        }
        if (fIsNet) {
            RegCloseKey(hkeyFolder);
            return S_OK;
        }
    }

    LPSTR pszDirToCreate;
    BOOL fInit = TRUE;

    if (fDefaultProfile || !fMakeFolderPerUser) {
        /* On the default profile, the directory path we want is the one we
         * read from the registry (or the default windir-based path we built).
         * Also, most folders we want to keep as the user has them already
         * configured.  In either case, we do not initialize the contents
         * because there's no place to initialize them from in the first case,
         * and we want the contents undisturbed in the second case.
         */
        pszDirToCreate = szOldDir;
        fInit = FALSE;
    }
    else {
        /* We want to give this user a profile-relative path for this folder.
         * However, if they already have an explicit non-default path set for
         * this folder, we don't bother initializing it since they already have
         * it set up someplace where they want it.
         */
        if (fGotPathFromRegistry &&
            ::GetFileAttributes(szOldDir) != 0xffffffff &&
            lstrcmpi(szOldDir, szDefaultDir)) {
            pszDirToCreate = szOldDir;
            fInit = FALSE;
        }
        else {
            pszDirToCreate = pszHomeDir;
        }
    }

    /* Only write the path out to the registry if we didn't originally get it
     * from the registry.
     */
    if (!fGotPathFromRegistry) {
        /* If we're writing to the User Shell Folders key, only write non-
         * default paths there.
         */
        /* There are some applications (German Corel Office 7) which
         * depend on the entry being in User Shell Folders for some shell
         * folders.  This dependency is due to the fact that the entry use
         * to be created always by down level browsers (IE30).
         *
         * We do not do this generically because no value under
         * USF is supposed to mean "use the one in the Windows
         * directory", whereas an absolute path means "use that
         * path";  if there's a path under USF, it will be used
         * literally, which is a problem if the folder is set up
         * to use the shared folder location but roams to a machine
         * with Windows installed in a different directory.
         */
        if ((pFolder->pszRegKey != c_szExplorerKey) ||
            pszDirToCreate != szOldDir ||
            !fDefaultLocation ||
            pFolder->fWriteToUSF) {

            if (g_fRunningOnNT) {
                TCHAR szRegPath[MAX_PATH];

                lstrcpy(szRegPath, TEXT("%USERPROFILE%\\"));
                lstrcat(szRegPath, pszHomeDirEnd);
                RegSetValueEx( hkeyFolder, pFolder->pszRegValue, 0, REG_EXPAND_SZ,
                               (LPBYTE)szRegPath, (lstrlen(szRegPath)+1) * sizeof(TCHAR));
            }
            else {
                if (!pFolder->fWriteToUSF || g_fRunningOnWin95)
                {
                    RegSetValueEx(hkeyFolder, pFolder->pszRegValue, 0, REG_SZ,
                                  (LPBYTE)pszDirToCreate, (lstrlen(pszDirToCreate)+1) * sizeof(TCHAR));
                }
                else
                {

//  98/12/30 #238093 (IE#50598 / Office#188177) vtan: There exists a
//  case where HKCU\..\Explorer\User Shell Folders\Favorites does NOT
//  exist on Win98 (unknown cause). This case simulates a Windows95
//  bug which the fWriteToUSF flag is designed to get around. In the
//  German Win9x this replaces the Favorites folder in User Shell
//  Folders key with the english name and this is propogated below to
//  Shell Folders which destroys the localization.

//  In this case we want to write the value of the key in Shell Folders
//  (if that points to a valid directory) to the User Shell Folders key
//  and just let the code below write the same value back to the Shell
//  Folders key. A little bit of wasted effort.

                    HKEY    hkeySF;

                    if (RegCreateKeyEx(HKEY_CURRENT_USER,
                                       "Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders",
                                       0,
                                       NULL,
                                       REG_OPTION_NON_VOLATILE,
                                       KEY_READ,
                                       NULL,
                                       &hkeySF,
                                       NULL) == ERROR_SUCCESS)
                    {
                        DWORD   dwRegDataType, dwRegDataSize;
                        TCHAR   szRegValue[MAX_PATH];

                        dwRegDataSize = sizeof(szRegValue);
                        if (RegQueryValueEx(hkeySF,
                                            pFolder->pszRegValue,
                                            0,
                                            &dwRegDataType,
                                            reinterpret_cast<LPBYTE>(szRegValue),
                                            &dwRegDataSize) == ERROR_SUCCESS)
                        {
                            if (GetFileAttributes(szRegValue) != 0xFFFFFFFF)
                            {
                                lstrcpy(pszDirToCreate, szRegValue);
                                RegSetValueEx(hkeyFolder,
                                              pFolder->pszRegValue,
                                              0,
                                              REG_SZ,
                                              (LPBYTE)pszDirToCreate,
                                              (lstrlen(pszDirToCreate)+1) * sizeof(TCHAR));
                            }
                        }
                        RegCloseKey(hkeySF);
                    }
                }
            }
        }

        /* The User Shell Folders key has a near-twin: Shell Folders, which
         * (a) should always contain the path to a folder, even if the folder
         * is in its default location, and (b) should contain the expanded
         * path on NT.
         */
        if (pFolder->pszRegKey == c_szExplorerKey) {
            HKEY hkeySF;
            if (RegCreateKeyEx(HKEY_CURRENT_USER,
                               "Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders",
                               0, NULL, REG_OPTION_NON_VOLATILE,
                               KEY_READ|KEY_WRITE, NULL, &hkeySF, NULL) == ERROR_SUCCESS) {
                RegSetValueEx(hkeySF, pFolder->pszRegValue, 0, REG_SZ,
                              (LPBYTE)pszDirToCreate, (lstrlen(pszDirToCreate)+1) * sizeof(TCHAR));
                RegCloseKey(hkeySF);
            }
        }

        /* Initialize default contents of the folder.
         */
        if (fInit && pFolder->InitFolder != NULL)
            pFolder->InitFolder(pFolder, szOldDir, pszHomeDir);
    }

    /* Always try to create the directory we want, if it doesn't already
     * exist.
     */

    if (::GetFileAttributes(pszDirToCreate) == 0xffffffff) {
        CreateDirectory(pszDirToCreate, NULL);
        if (pFolder->dwAttribs != FILE_ATTRIBUTE_DIRECTORY)
            SetFileAttributes(pszDirToCreate, pFolder->dwAttribs);
    }

    RegCloseKey(hkeyFolder);

    /*
     * If it's the My Documents folder, there is some per-user initialization
     * to do regardless of whether we set the values or they already existed.
     */
    if (pFolder->InitFolder == InitFolderMyDocs)
    {
        TCHAR szMyDocs[ MAX_PATH ];

        if (GetSystemDirectory( szMyDocs, ARRAYSIZE(szMyDocs) ))
        {
            HINSTANCE hMyDocs;

            lstrcat( szMyDocs, c_szMyDocsDLL );

            hMyDocs = LoadLibrary( szMyDocs );

            if (hMyDocs)
            {

                LPFNMYDOCSINIT pMyDocsInit =
                        (LPFNMYDOCSINIT)GetProcAddress( hMyDocs, "PerUserInit" );

                if (pMyDocsInit)
                {
                    pMyDocsInit();
                }

                FreeLibrary( hMyDocs );
            }
        }
    }


    /* Now, for Windows 95 systems, create a ProfileReconciliation subkey
     * which will make this folder roam.  Only if we want to make this folder
     * per-user, of course.
     */
    if (fMakeFolderPerUser && !g_fRunningOnNT) {
        TCHAR szDefaultPath[MAX_PATH];
        lstrcpy(szDefaultPath, TEXT("*windir\\"));
        lstrcat(szDefaultPath, pszHomeDirEnd);

        HKEY hSubKey;

        LONG err = RegCreateKeyEx(hkeyProfRec, pFolder->pszStaticName, 0, NULL, REG_OPTION_NON_VOLATILE,
                                  KEY_WRITE, NULL, &hSubKey, NULL);
        if (err == ERROR_SUCCESS)
            err = RegSetValueEx(hSubKey, c_szCentralFile, 0, REG_SZ, (LPBYTE)pszHomeDirEnd,
                                cchDir);
        if (err == ERROR_SUCCESS)
            err = RegSetValueEx(hSubKey, c_szLocalFile, 0, REG_SZ, (LPBYTE)pszHomeDirEnd,
                                cchDir);
        if (err == ERROR_SUCCESS)
            err = RegSetValueEx(hSubKey, c_szName, 0, REG_SZ, (LPBYTE)pFolder->pszFiles,
                                lstrlen(pFolder->pszFiles) + 1);
        if (err == ERROR_SUCCESS)
            err = RegSetValueEx(hSubKey, c_szDefaultDir, 0, REG_SZ, (LPBYTE)szDefaultPath,
                                lstrlen(szDefaultPath) + 1);

        DWORD dwOne = 1;
        if (err == ERROR_SUCCESS)
            err = RegSetValueEx(hSubKey, c_szMustBeRelative, 0, REG_DWORD, (LPBYTE)&dwOne,
                                sizeof(dwOne));
        if (err == ERROR_SUCCESS)
            err = RegSetValueEx(hSubKey, c_szDefault, 0, REG_DWORD, (LPBYTE)&dwOne,
                                sizeof(dwOne));

        if (err == ERROR_SUCCESS)
            err = RegSetValueEx(hSubKey, c_szRegKey, 0, REG_SZ, (LPBYTE)pFolder->pszRegKey,
                                lstrlen(pFolder->pszRegKey) + 1);
        if (err == ERROR_SUCCESS)
            err = RegSetValueEx(hSubKey, c_szRegValue, 0, REG_SZ, (LPBYTE)pFolder->pszRegValue,
                                lstrlen(pFolder->pszRegValue) + 1);

        RegCloseKey(hSubKey);

        if (err != ERROR_SUCCESS)
            return HRESULT_FROM_WIN32(err);
    }
    return S_OK;
}


BOOL GetModulePath( LPTSTR szPath, UINT cbPath )
{
    PSTR pszTmp;

    if (GetModuleFileName(g_hinst, szPath, cbPath ) == 0)
    {
        szPath[0] = '\0';
        return FALSE;
    }
    else
    {
        pszTmp = ANSIStrRChr( szPath, '\\' );
        if ( pszTmp )
            *pszTmp = '\0';
    }
    return TRUE ;
}


int DoMsgBoxParam(HWND hwnd, UINT TextString, UINT TitleString, UINT style, PTSTR param )
{
    TCHAR szTitle[MAX_PATH];
    TCHAR szMsg[2*MAX_PATH];

    if (!LoadString(g_hinst, TextString, szMsg, sizeof(szMsg)))
        szMsg[0] = '\0';

    if ( param )
    {
        TCHAR szBuf[2*MAX_PATH];

        wsprintf( szBuf, szMsg, param );
        lstrcpy( szMsg, szBuf );
    }

    if (!LoadString(g_hinst, TitleString, szTitle, sizeof(szTitle)))
        szTitle[0] = '\0';

    return MessageBox(hwnd, szMsg, szTitle, style);
}

void InstINFFile( LPCTSTR pcszInf, LPTSTR pszSec, BOOL bInstall, BOOL bSaveRollback, DWORD dwFlag )
{
    TCHAR szPath[MAX_PATH];
    CABINFO   cabInfo;


    if ( GetModulePath( szPath, sizeof(szPath) ) )
    {
        if ( bSaveRollback )
        {
            ZeroMemory( &cabInfo, sizeof(CABINFO) );
            // install IE4Uinit.INF
            lstrcpy( cabInfo.szSrcPath, szPath );
            AddPath( szPath, pcszInf );

            if ( FileExists( szPath ) )
            {
                cabInfo.pszInf = szPath;
                cabInfo.pszSection = pszSec;
                cabInfo.dwFlags = (bInstall ? ALINF_BKINSTALL : ALINF_ROLLBACK);
                cabInfo.dwFlags |= ALINF_QUIET;
                ExecuteCab( NULL, &cabInfo, NULL );
            }
            else if (!(dwFlag & RSC_FLAG_QUIET))
            {
                DoMsgBoxParam( NULL, IDS_ERR_NOFOUNDINF, IDS_APPNAME, MB_OK|MB_ICONINFORMATION, szPath );
            }
        }
        else
        {
            char szInfFile[MAX_PATH];

            lstrcpy( szInfFile, szPath);
            AddPath( szInfFile, pcszInf);
            RunSetupCommand(NULL, szInfFile, pszSec, szPath,
                            NULL, NULL, dwFlag, NULL);
        }

    }
}


void DoRollback()
{
    HKEY hLMkey;
    HKEY hSubkey1, hSubkey2;
    TCHAR szBuf[MAX_PATH];
    DWORD dwSize;
    DWORD dwIndex = 0;
    int   ilen;

    // rollback all the components listed in c_szIEModRollback key
    //
    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE, c_szAdvINFSetup, 0, KEY_READ , &hLMkey) == ERROR_SUCCESS )
    {
        if ( RegOpenKeyEx(hLMkey, c_szIEModRollback, 0, KEY_READ , &hSubkey1) == ERROR_SUCCESS )
        {
            lstrcpy( szBuf, c_szAdvINFSetup );
            AddPath( szBuf, "" );
            ilen = lstrlen(szBuf);
            dwSize = ARRAYSIZE(szBuf) - ilen;
            while ( RegEnumValue( hSubkey1, dwIndex, &szBuf[ilen], &dwSize,
                                  NULL, NULL, NULL, NULL ) == ERROR_SUCCESS  )
            {
                if ( RegOpenKeyEx(hLMkey, &szBuf[ilen], 0, KEY_READ | KEY_WRITE, &hSubkey2) == ERROR_SUCCESS )
                {
                    RegSetValueEx( hSubkey2, TEXT("BackupRegistry"), 0, REG_SZ, (LPBYTE)TEXT("n"), (lstrlen(TEXT("n"))+1)*sizeof(TCHAR) );
                    RegCloseKey( hSubkey2 );
                }

                AddPath( szBuf, c_szRegBackup );

                ///////////////////////////////////////////////////////////////////////////
                // ShabbirS  - 8/17/98
                // Bug# 26774 : Found that this restoring of backup reg data undoes our
                // dll registering done during the RunOnceEx phase.
                ///////////////////////////////////////////////////////////////////////////
                // restore HKLM if there
                //if ( RegOpenKeyEx(hLMkey, &szBuf[ilen], 0, KEY_READ | KEY_WRITE, &hSubkey2) == ERROR_SUCCESS )
                //{
                //    RegRestoreAll( NULL, NULL, hSubkey2 );
                //    RegCloseKey( hSubkey2 );
                //}

                // restore HKCU if there
                if ( RegOpenKeyEx( HKEY_CURRENT_USER, szBuf, 0, KEY_READ | KEY_WRITE, &hSubkey2) == ERROR_SUCCESS )
                {
                    RegRestoreAll( NULL, NULL, hSubkey2 );
                    RegCloseKey( hSubkey2 );
                }

                dwIndex++;
                dwSize = ARRAYSIZE( szBuf ) - ilen;
            }

            RegCloseKey( hSubkey1 );
        }

        RegCloseKey( hLMkey );
    }
}

#define NT_MEMORYLIMIT      0x03f00000
#define WIN9X_MEMORYLIMIT   0x01f00000

void DoINFWork( BOOL bInstall, LPCTSTR pcszInfFile, LPTSTR pszInfSec, DWORD dwFlag )
{
    HKEY    hkey;
    TCHAR   szBuf[MAX_PATH] = { 0 };
    DWORD   dwSize;
    DWORD   dwRedist = 0;
    BOOL    bRedistMode = FALSE;

    // check the InstallMode and determin if make the desktop icon and StartMenu item.
    if ( bInstall && (RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szIESetupPath, 0, KEY_READ, &hkey) == ERROR_SUCCESS) )
    {
        dwSize = sizeof(dwRedist);
        // If we can read the Installmode and bit 0 is set, assume redist (Remove short cuts)
        if ( (RegQueryValueEx( hkey, c_szInstallMode, 0, NULL, (LPBYTE)&dwRedist, &dwSize) == ERROR_SUCCESS) &&
             (dwRedist & 1) )
        {
            bRedistMode = TRUE;
        }
        RegCloseKey( hkey );
    }

    // if not installed over SP4 level crypto, then backup/restore the crypto keys.
    // NOTE that bInstall is passed in the 4th argument, so during install bSaveRollback is TRUE.  During
    // uninstall, the reg backup data should be restored when the DefaultInstall section is processed, so
    // set bSaveRollback to FALSE
    if (!FSP4LevelCryptoInstalled())
        InstINFFile( pcszInfFile, bInstall ? "BackupCryptoKeys" : "DelCryptoKeys", bInstall, bInstall, dwFlag );
    else
    {
        // BUGBUG: if bInstall is FALSE, need to delete the reg backup data for the crypto keys
    }

    // install the WinXP specific section
    if(g_fRunningOnWinXP && !pszInfSec ) {
        InstINFFile( pcszInfFile, TEXT("DefaultInstall.WinXP"), bInstall, TRUE, dwFlag);
    }
    else {
        // install the current shortcut and HKCU settings by stub INF
        InstINFFile( pcszInfFile, pszInfSec, bInstall, TRUE, dwFlag );
    }

    //  Even though IE5.0 does not install channelband, if the channelband exists on IE4.0, it should works in
    //  IE5.0.  Therefore if there is channelbar link exists(PrevIE Version is IE4.0 browser only), IE5 will update
    //  the channelbar link to the current browser.  Otherwise, do nothing.
    if (bInstall && IsPrevIE4() && !IsPrevIE4WebShell())
    {
        InstINFFile( pcszInfFile, TEXT("Shell.UserStub.Uninstall"), bInstall, FALSE, RSC_FLAG_INF | RSC_FLAG_QUIET );
    }

    if ( bRedistMode )
    {
        LPTSTR lpszSection;

        if ( g_fRunningOnNT )
            lpszSection = TEXT("RedistIE.NT");
        else
            lpszSection = TEXT("RedistIE.Win");

        InstINFFile( pcszInfFile, lpszSection, bInstall, TRUE, dwFlag );
    }

    // On uninstall, check what the current browser version and determin if we need to cleanup the
    // Channel and quick launch folders
    if ( !bInstall && ( CheckIEVersion() == LESSIE4))
    {
        LPTSTR lpszSection;

        if ( g_fRunningOnNT )
            lpszSection = TEXT("CleanFolders.NT");
        else
            lpszSection = TEXT("CleanFolders.Win");

        InstINFFile( pcszInfFile, lpszSection, bInstall, FALSE, RSC_FLAG_INF | RSC_FLAG_QUIET | RSC_FLAG_NGCONV );
    }

    // Enable sounds if user has a big enough machine
    // NT - 64MB, Win9x - 32MB
    if(bInstall)
    {
        LPTSTR lpszSection = NULL;
        MEMORYSTATUS ms;

        ms.dwLength = sizeof(MEMORYSTATUS);
        GlobalMemoryStatus(&ms);

        if ( g_fRunningOnNT)
        {
           if(ms.dwTotalPhys >= NT_MEMORYLIMIT)
           {
              lpszSection = TEXT("SoundInstall.NT");
           }
        }
        else
        {
           if(ms.dwTotalPhys >= WIN9X_MEMORYLIMIT)
           {
              lpszSection = TEXT("SoundInstall");
           }
        }

        if(lpszSection)
           InstINFFile( pcszInfFile, lpszSection, bInstall, TRUE, RSC_FLAG_INF | RSC_FLAG_QUIET | RSC_FLAG_NGCONV );
    }

    if (bInstall)
    {
        // in fact this is only true for IE5 install inf, but IE4 inf is called ok too since there is no
        // such section in IE4 stub inf.
        if (CheckWebViewShell(NULL)) {
            LPSTR lpszSection = NULL;
            if(g_fRunningOnWinXP)
                lpszSection = TEXT("IE5onIE4Shell.WinXP");
            else
                lpszSection = TEXT("IE5onIE4Shell");
                
            InstINFFile( pcszInfFile, lpszSection, bInstall, FALSE, RSC_FLAG_INF | RSC_FLAG_QUIET );
        }
    }

    // check if the user's home page is bogus one
    if ( bInstall && (RegOpenKeyEx( HKEY_CURRENT_USER, c_szIExploreMain, 0, KEY_READ, &hkey ) == ERROR_SUCCESS) )
    {
        DWORD dwSize;

        dwSize = sizeof(szBuf);
        if ( RegQueryValueEx( hkey, TEXT("Start Page"), NULL, NULL, (LPBYTE)szBuf, &dwSize ) == ERROR_SUCCESS )
        {
            if ( (g_fRunningOnNT && ANSIStrStrI(szBuf, "Plus!") && ANSIStrStrI(szBuf, "File:")) ||
                 (!lstrcmpi(szBuf, TEXT("http://home.microsoft.com"))) ||
                 (!lstrcmpi(szBuf, TEXT("http://home.microsoft.com/"))) )
            {
                InstINFFile( pcszInfFile, TEXT("OverrideHomePage.NT"), bInstall, TRUE, dwFlag );
            }
        }

        RegCloseKey( hkey );
    }

    if ( !bRedistMode )
    {
        typedef void (*PFSetFirstHomepage)();
        PFSetFirstHomepage pfSetFirstHomepage;

        HMODULE hMod = LoadLibrary("iesetup.dll");
        
        if (hMod)
        {
            pfSetFirstHomepage = (PFSetFirstHomepage)GetProcAddress(hMod, "SetFirstHomepage");
            if (pfSetFirstHomepage)
            {
                pfSetFirstHomepage();
            }
            FreeLibrary(hMod);
        }
    }
        
    // DoRollback if needed
    if ( !bInstall )
    {
        DoRollback();
    }
}


/*----------------------------------------------------------
Purpose: Detect if it is run on Russian LangID
*/

//DWORD dwLangList[] = { 0x0419, 0xFFFF };
#define RUSSIANLANG     0x0419

BOOL IsBrokenLang()
{
    char    szTmp[MAX_PATH] = { 0 };
    DWORD   dwLangKernel32;
    DWORD   dwTmp;
    BOOL    bBadLang = FALSE;

    GetSystemDirectory(szTmp, sizeof(szTmp));
    AddPath(szTmp,"kernel32.dll" );
    GetVersionFromFile(szTmp, &dwLangKernel32, &dwTmp, FALSE);

    if ( dwLangKernel32 == RUSSIANLANG )
    {
        bBadLang = TRUE;
    }
    return bBadLang;
}

BOOL IsPrevStubRun()
{
    HKEY hLMKey, hCUKey;
    BOOL bRet = FALSE;
    char szStubVer[50], szPreIEVer[50];
    DWORD dwSize;
    WORD wStubVer[4]={0}, wPreIEVer[4]={0};

    // check if the pre-version iestub is run
    if ( RegOpenKeyEx( HKEY_CURRENT_USER, c_szActInstalledIEGUID, 0, KEY_READ, &hCUKey ) == ERROR_SUCCESS )
    {
        dwSize = sizeof(szStubVer);
        if ( RegQueryValueEx( hCUKey, TEXT("Version"), NULL, NULL, (LPBYTE)szStubVer, &dwSize ) == ERROR_SUCCESS )
        {
            ConvertVersionString( szStubVer, wStubVer, ',' );
        }
        RegCloseKey(hCUKey);
    }

    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE, c_szIESetupPath, 0, KEY_READ, &hLMKey ) == ERROR_SUCCESS )
    {
        dwSize = sizeof(szPreIEVer);
        if ( RegQueryValueEx( hLMKey, TEXT("PreviousIESysFile"), NULL, NULL, (LPBYTE)szPreIEVer, &dwSize ) == ERROR_SUCCESS )
        {
            ConvertVersionString( szPreIEVer, wPreIEVer, '.' );

            if ( (MAKELONG(wPreIEVer[1],wPreIEVer[0])<IE_4_MS_VERSION) ||
                 (wStubVer[0] > wPreIEVer[0]) ||
                 ((wStubVer[0] == wPreIEVer[0]) && (wStubVer[1] >= wPreIEVer[1])) )
            {
                bRet = TRUE;
            }
        }
        else //should never be here. OW
            bRet = TRUE; //not forcing rerun the prev-stub

        RegCloseKey(hLMKey);
    }
    else //should never be here. OW
        bRet = TRUE; //not forcing rerun the prev-stub


    return bRet;
}

/*----------------------------------------------------------
Purpose: Stripping off the trailing spaces for the registry data in the list
*/

typedef struct _REGDATACHECK
{
    HKEY    hRootKey;
    LPSTR   lpszSubKey;
    LPSTR   lpszValueName;
} REGDATACHECK;

REGDATACHECK chkList[] = {
    { HKEY_CURRENT_USER, "Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders", "AppData" },
    { HKEY_CURRENT_USER, "Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders", "Start Menu" },
    { HKEY_CURRENT_USER, "Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders", "AppData" },
    { HKEY_CURRENT_USER, "Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders", "Start Menu" },
    { HKEY_USERS, ".DEFAULT\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders", "AppData" },
    { HKEY_USERS, ".DEFAULT\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders", "Start Menu" },
    { HKEY_USERS, ".DEFAULT\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders", "AppData" },
    { HKEY_USERS, ".DEFAULT\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders", "Start Menu" },
};

void FixRegData()
{
    int     iList, i;
    LPSTR   pszTmp;
    char   szBuf[MAX_PATH];
    DWORD   dwSize, dwType;
    HKEY    hKey;

    iList = ARRAYSIZE( chkList );
    for ( i = 0; i < iList; i++ )
    {
        if ( RegOpenKeyEx(chkList[i].hRootKey, chkList[i].lpszSubKey, 0, KEY_READ|KEY_WRITE,
                          &hKey) == ERROR_SUCCESS )
        {
            dwSize = sizeof(szBuf);
            if ( RegQueryValueEx(hKey, chkList[i].lpszValueName, 0, &dwType, (LPBYTE)szBuf,
                                 &dwSize) == ERROR_SUCCESS )
            {
                // strip off the trailing blanks
                pszTmp = szBuf;
                pszTmp += lstrlen(szBuf) - 1;

                while ( (pszTmp >= szBuf) && (*pszTmp == ' ') )
                {
                    *pszTmp = '\0';
                    pszTmp--;
                }

                RegSetValueEx( hKey, chkList[i].lpszValueName, 0, dwType, (LPBYTE)szBuf, lstrlen(szBuf)+1 );
            }
            RegCloseKey( hKey );
        }
    }
}


void FixSearchUrl()
{
    HKEY hkey, hIEKey;
    TCHAR szBuf[MAX_PATH];
    DWORD dwSize;

    // if HKCU, software\microsoft\internet explorer\SearchUrl, "default" value is ""
    // Delete the "" default value.
    //
    if ( RegOpenKeyEx(HKEY_CURRENT_USER, c_szIExplorerSearchUrl, 0, KEY_READ|KEY_WRITE, &hkey) == ERROR_SUCCESS )
    {
        dwSize = 0;
        if ( RegQueryValueEx( hkey, TEXT(""), 0, NULL, (LPBYTE)szBuf, &dwSize ) != ERROR_SUCCESS )
        {
            dwSize = sizeof(szBuf);
            if ( (RegQueryValueEx( hkey, TEXT(""), 0, NULL, (LPBYTE)szBuf, &dwSize ) == ERROR_SUCCESS) &&
                 (szBuf[0] == TEXT('\0')) )
            {
                // found "" empty string as default value, check if we have cleaned up before.
                // If not, clean it now, otherwise do nothing.
                if ( RegCreateKeyEx( HKEY_CURRENT_USER, c_szIE4Path,0, NULL, REG_OPTION_NON_VOLATILE,
                                     KEY_READ|KEY_WRITE, NULL, &hIEKey, NULL) == ERROR_SUCCESS )
                {
                    dwSize = sizeof(szBuf);
                    if ( (RegQueryValueEx( hIEKey, c_szSearchUrl, 0, NULL, (LPBYTE)szBuf, &dwSize ) != ERROR_SUCCESS) ||
                         (*CharUpper(szBuf) != TEXT('Y')) )
                    {
                        RegDeleteValue( hkey, TEXT("") );
                        lstrcpy( szBuf, TEXT("Y") );
                        RegSetValueEx( hIEKey, c_szSearchUrl, 0, REG_SZ, (LPBYTE)szBuf, (lstrlen(szBuf)+1)*sizeof(TCHAR) );
                    }

                    RegCloseKey( hIEKey );
                }
            }
        }
        RegCloseKey( hkey );
    }
}



/*----------------------------------------------------------
 * Helper function to check if the Channels folder exists in
 * the current user profile.
 *----------------------------------------------------------
 */

// "Channels" resid from CdfView. (Need to use this, b'cos could be localized
#define CHANNEL_FOLDER_RESID 0x1200

// SHGetSpecialFolderPath function from Shell32.dll
typedef BOOL (WINAPI *SH_GSFP_PROC) (HWND, LPTSTR, int, BOOL);

BOOL DoesChannelFolderExist()
{
    char szChannelName[MAX_PATH];
    char szSysPath[MAX_PATH] = { 0 };
    char szChannelPath[MAX_PATH];
    BOOL  bRet = FALSE;
    BOOL  bGetRC = TRUE;
    HMODULE hShell32 = NULL;
    SH_GSFP_PROC fpSH_GSFP = NULL;
    DWORD dwAttr = 0;
    
    GetSystemDirectory( szSysPath,sizeof(szSysPath));

    lstrcpy(szChannelPath, szSysPath);
    AddPath( szChannelPath, "shell32.dll" );
    hShell32 = LoadLibrary(szChannelPath);

    // This stubs runs on IE4 or IE5 systems. Hence shell32 is garunteed
    // to have the SHGetSpecialFolderPath API.
    if (hShell32)
    {
        fpSH_GSFP = (SH_GSFP_PROC)GetProcAddress(hShell32,"SHGetSpecialFolderPathA");

        *szChannelPath = '\0';
        if (fpSH_GSFP && fpSH_GSFP(NULL, szChannelPath, CSIDL_FAVORITES, FALSE))
        {
            HKEY hKey;
            DWORD cbSize = sizeof(szChannelName);

            // Get the potentially localized name of the Channel folder from the
            // registry if it is there.  Otherwise use "Channels"
            // Then tack this on the favorites path.
            //
    
            if ( RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_SETUP, 0, KEY_READ, &hKey) == ERROR_SUCCESS)
            {
                if (RegQueryValueEx(hKey,"ChannelFolderName", NULL, NULL, (LPBYTE)szChannelName,&cbSize) == ERROR_SUCCESS)
                {
                    bGetRC = FALSE;
                }
                RegCloseKey(hKey);
            }

            if (bGetRC)
            {
                HMODULE hLib;

                // Get the default name for Channels folder from the
                // CdfView.dll
                AddPath(szSysPath,"cdfview.dll");

                hLib = LoadLibraryEx(szSysPath,NULL,LOAD_LIBRARY_AS_DATAFILE);
                if (hLib)
                {
                    if (LoadString(hLib, CHANNEL_FOLDER_RESID,szChannelName,sizeof(szChannelName)) == 0)
                    {
                        // Fail to read the resource, default to English
                        lstrcpy(szChannelName,"Channels");
                    }

                    FreeLibrary(hLib);
                }
                        
            }
    
            AddPath(szChannelPath, szChannelName);
    
            // Check if the folder exists...
            dwAttr = GetFileAttributes(szChannelPath);
            if ((dwAttr != 0xffffffff) && (dwAttr & FILE_ATTRIBUTE_DIRECTORY))
                bRet = TRUE;
        }

        FreeLibrary(hShell32);
    }    


    return bRet;
}

HRESULT IEAccessHideExplorerIcon()
{
    const TCHAR *szKeyComponent = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\CLSID\\{871C5380-42A0-1069-A2EA-08002B30309D}");
    const TCHAR *szShellFolder = TEXT("ShellFolder");
    const TCHAR *szAttribute = TEXT("Attributes");
    DWORD dwValue, dwSize, dwDisposition;
    HKEY hKeyComponent, hKeyShellFolder;
    HRESULT hResult = ERROR_SUCCESS;

    hResult = RegCreateKeyEx(HKEY_CURRENT_USER, szKeyComponent, NULL, NULL, REG_OPTION_NON_VOLATILE, 
        KEY_CREATE_SUB_KEY, NULL, &hKeyComponent, &dwDisposition);

    if (hResult != ERROR_SUCCESS)
        return hResult;

    hResult = RegCreateKeyEx(hKeyComponent, szShellFolder, NULL, NULL, REG_OPTION_NON_VOLATILE, 
        KEY_QUERY_VALUE | KEY_SET_VALUE, NULL, &hKeyShellFolder, &dwDisposition);

    RegCloseKey(hKeyComponent);
    
    if (hResult == ERROR_SUCCESS)
    {
        dwSize = sizeof(dwValue);
        hResult = RegQueryValueEx( hKeyShellFolder, szAttribute, NULL, NULL, (LPBYTE)&dwValue, &dwSize);

        if (hResult != ERROR_SUCCESS)
            dwValue = 0;

        dwValue |= SFGAO_NONENUMERATED;

        hResult = RegSetValueEx(hKeyShellFolder, szAttribute, NULL, REG_DWORD, (LPBYTE)&dwValue, sizeof(dwValue));

        RegCloseKey(hKeyShellFolder);
    }

    return hResult;
}

#define REGVAL_SHOW_CHANNELBAND "Show_ChannelBand"
#define REGVAL_SOURCE           "Source"
#define REGVAL_FLAGS            "Flags"

#define REG_IE_MAIN      "Software\\Microsoft\\Internet Explorer\\Main"
#define REG_DESKTOP_COMP "Software\\Microsoft\\Internet Explorer\\Desktop\\Components"

#define GUID_CHNLBAND "131A6951-7F78-11D0-A979-00C04FD705A2"
#define FLAG_ENABLE_CHNLBAND 0x00002000

/*----------------------------------------------------------
Purpose: Worker function to do the work
*/

void DoWork( BOOL bInstall )
{
    TCHAR szHomeDir[MAX_PATH] = { 0 };
    HKEY  hkeyProfRec = NULL;
    HKEY  hkeyFolderPolicies;
    BOOL  fIntShellMode = FALSE;
    HMODULE hmodShell = NULL;
//    HINSTANCE hlib;
    TCHAR szPath[MAX_PATH] = { 0 };
    DWORD dwMV, dwLV;
    BOOL  fUseShell32 = FALSE;

    if ( bInstall )
    {
        if (g_fRunningOnNT) {
            ExpandEnvironmentStrings("%USERPROFILE%", szHomeDir, ARRAYSIZE(szHomeDir));
        }
        else {
            szHomeDir[0] = '\0';
            LONG err = RegCreateKeyEx(HKEY_CURRENT_USER, c_szProfRecKey, 0, NULL,
                                      REG_OPTION_NON_VOLATILE, KEY_READ|KEY_WRITE,
                                      NULL, &hkeyProfRec, NULL);
            if (err == ERROR_SUCCESS) {
                DWORD dwType;
                DWORD cbData = sizeof(szHomeDir);
                RegQueryValueEx(hkeyProfRec, c_szHomeDirValue, 0, &dwType,
                                (LPBYTE)szHomeDir, &cbData);
            }
        }

        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, "Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Per User Folders",
                         0, KEY_QUERY_VALUE, &hkeyFolderPolicies) != ERROR_SUCCESS)
            hkeyFolderPolicies = NULL;

        /* Dynamically link to the SHFlushSFCache API in SHELL32.DLL.  Its ordinal
         * is 526.  This API tells the shell to reinitialize the shell folder cache
         * in all processes.
         */

        // due to the buggy in the old shell32 of this api function.  We are advised to use the new wrap
        // which is in shlwapi.dll.  Its ordinal is 419.
        fIntShellMode = FALSE;
        GetSystemDirectory( szPath,sizeof( szPath ) );
        AddPath( szPath, "shlwapi.dll" );
        GetVersionFromFile( szPath, &dwMV, &dwLV, TRUE );

        // if major version >= 5.0
        //
        if ( (dwMV >= 0x00050000))
        {
            hmodShell = ::LoadLibrary(szPath);
        }
        else
        {
            hmodShell = ::LoadLibrary("shell32.dll");
            fUseShell32 = TRUE;
        }

        if (hmodShell != NULL)
        {
            if ( !fUseShell32 )
            {
                ::pfnSHFlushSFCacheWrap = (PFNSHFLUSHSFCACHEWRAP)::GetProcAddress(hmodShell, (LPCTSTR)419);
                if (::pfnSHFlushSFCacheWrap != NULL)
                {
                    fIntShellMode = TRUE;
                }
            }
            else
            {
                ::pfnSHFlushSFCache = (PFNSHFLUSHSFCACHE)::GetProcAddress(hmodShell, (LPCTSTR)526);
                if (::pfnSHFlushSFCache != NULL)
                {
                    fIntShellMode = TRUE;
                }
            }
        }

        BOOL fDefaultProfile;
        LPTSTR pchHomeDirEnd = szHomeDir;
        int cchHomeDir = 0;

        if (szHomeDir[0] != '\0') {
            fDefaultProfile = FALSE;
        }
        else {
            GetWindowsDirectory(szHomeDir, ARRAYSIZE(szHomeDir));
            fDefaultProfile = TRUE;
        }
        AddPath(szHomeDir,"");
        pchHomeDirEnd = szHomeDir + lstrlen(szHomeDir);
        cchHomeDir = ARRAYSIZE(szHomeDir) - (int)(pchHomeDirEnd - szHomeDir);

        for (UINT i=0; i<ARRAYSIZE(aFolders); i++) {
            if (aFolders[i].fIntShellOnly && !fIntShellMode)
                continue;

            if (FAILED(SetupFolder(hkeyProfRec, szHomeDir, pchHomeDirEnd,
                                   cchHomeDir, &aFolders[i], fDefaultProfile,
                                   hkeyFolderPolicies)))
                break;
        }

        if (hkeyProfRec != NULL)
            RegCloseKey(hkeyProfRec);

        if (hkeyFolderPolicies != NULL)
            RegCloseKey(hkeyFolderPolicies);

        // import NS stuff if there
        ImportNetscapeProxySettings( IMPTPROXY_CALLAFTIE4 );
        ImportBookmarks(g_hinst);

        if ( !fUseShell32 )
        {
            if (::pfnSHFlushSFCacheWrap != NULL)
            {
                (*::pfnSHFlushSFCacheWrap)();
            }
        }
        else
        {
            if (::pfnSHFlushSFCache != NULL)
            {
                (*::pfnSHFlushSFCache)();
            }
        }

        if (hmodShell != NULL) {
            ::FreeLibrary(hmodShell);
        }
    }

    /* BUGBUG - add code to populate the default IE4 favorites, channels, and
     * shortcuts here
     */

    // #75346: Upgrade from Win9x to NT5, new users have no Channels folder
    // and the ChannelBand pops-up with Fav. entries in it. This hack will
    // ensure that the Ch.Band does not pop-up when the new user logs in for
    // the first time.
    if (bInstall && g_fRunningOnNT5)
    {
        if (!DoesChannelFolderExist())
        {   
            HKEY hKey;
            char szNo[] = "No";

            // Turn off the Show_ChannelBand for this user.
            if (RegOpenKeyEx(HKEY_CURRENT_USER,REG_IE_MAIN, 0, KEY_READ|KEY_WRITE, &hKey) == ERROR_SUCCESS)
            {
                RegSetValueEx(hKey, REGVAL_SHOW_CHANNELBAND,0, REG_SZ,(LPBYTE)szNo,sizeof(szNo));
                RegCloseKey(hKey);
            }

            // Also turn off the Desktop\Components(ChannelBand)
            // Open HKCU\S\M\InternetExplorer\Desktop\Coomponents and enum for
            // the ChannelBand GUID. Disable the show flag.
            if (RegOpenKeyEx(HKEY_CURRENT_USER, REG_DESKTOP_COMP, 0, KEY_READ|KEY_WRITE, &hKey) == ERROR_SUCCESS)
            {
                HKEY hSubKey = NULL;
                char szSubKey[MAX_PATH];
                char szSourceID[130];
                DWORD dwSize = sizeof(szSubKey);

                for (int i = 0; 
                     RegEnumKeyEx(hKey,i, szSubKey, &dwSize, NULL, NULL, NULL, NULL) == ERROR_SUCCESS; 
                     i++, dwSize = sizeof(szSubKey))
                {
                    // Open this subkey and checks its SourceID.
                    if (RegOpenKeyEx(hKey,szSubKey,0, KEY_READ|KEY_WRITE, &hSubKey) == ERROR_SUCCESS)
                    {
                        dwSize = sizeof(szSourceID);
                        if ((RegQueryValueEx(hSubKey, REGVAL_SOURCE, NULL, NULL, (LPBYTE)szSourceID,&dwSize) == ERROR_SUCCESS)
                           && (lstrcmpi(szSourceID, GUID_CHNLBAND) == 0))
                        {
                            // Read the current Flags setting.
                            DWORD dwFlags = 0;

                            dwSize = sizeof(dwFlags);
                            RegQueryValueEx(hSubKey,REGVAL_FLAGS, NULL, NULL, (LPBYTE)&dwFlags, &dwSize);

                            dwFlags &= ~(FLAG_ENABLE_CHNLBAND);
                            dwSize = sizeof(dwFlags);
                            RegSetValueEx(hSubKey, REGVAL_FLAGS, 0, REG_DWORD, (LPBYTE)&dwFlags, dwSize);

                            // close the key since we have a match and are therefore going to break out
                            RegCloseKey(hSubKey);
                            break;
                        }
                        
                        RegCloseKey(hSubKey);
                    }

                }  // end of RegEnum loop

                RegCloseKey(hKey);
            }


        }
    }


    // before we do the INF work, we have to run the following function which is
    // hack way to fix Russian NT 4.0 localization problem.  This only apply to Russian NT box.
    if (g_fRunningOnNT && IsBrokenLang() )
    {
        FixRegData();
    }

    // On win95, due to the RegSave/Restore problem on default valuename, and valuename is space,
    // we will do a specific fix for SearchUrl subkey.  The generic registry operation fix will in advpack.dll.
    if ( (!g_fRunningOnNT) && bInstall )
    {
        FixSearchUrl();
    }

    // because this stub code is left after uninstall IE5 to do both IE4 and IE5 work, we need the smartness to
    // know when to run IE4 inf and when only needed to run IE5 inf
    // BUGBUG:  this portion of code is very version specific and need to be updated whenever the new Major
    // version is shipped. Bud pain!! Most likely, in IE6 time we need to stub EXE to get around the problem!!

    if (bInstall)
    {
        UINT uIEVer = CheckIEVersion();

        // install stub case:
        if (uIEVer == IE4)
        {
            DoINFWork(bInstall, c_szPrevStubINF, NULL, 0); // NULL means DefaultInstall section
        }
        else if (uIEVer >= IE5)
        {
            if (!IsPrevStubRun() )
            {
                // Simulate a pre-installation of IE4. So run IE4 browser stub
                // first, then followed by the IE4 Shell stub (if required).
                DoINFWork( bInstall, c_szPrevStubINF, NULL, RSC_FLAG_INF | RSC_FLAG_QUIET );

                if (IsPrevIE4WebShell())
                {
                    DoINFWork( bInstall, c_szPrevStubINF, g_fRunningOnNT ? TEXT("Shell.UserStubNT") : TEXT("Shell.UserStub"), RSC_FLAG_INF | RSC_FLAG_QUIET);
                }

            }

            DoINFWork( bInstall, c_szStubINFFile, NULL, 0 );
            ProcessMouseException();
        }
    }
    else
    {
        // uninstall stub case:  use HKCU value to make sure which version it is uninstalling
        UINT uUninstIEVer = CheckUninstIEVersion();

        if (uUninstIEVer == IE4)
        {
            DoINFWork(bInstall, c_szPrevStubINF, NULL, 0);
        }
        else if (uUninstIEVer == IE5)
        {
            DoINFWork(bInstall, c_szStubINFFile, NULL, 0);
        }
        else if (uUninstIEVer == IE55 || uUninstIEVer == IE6)
        {
            DoINFWork(bInstall, c_szStubINFFile, NULL, 0);
        }

    }

    if (bInstall && g_fRunningOnWinXP)
        IEAccessHideExplorerIcon();
    
}


INT WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance,
                    LPTSTR lpszCmdLine, INT nCmdShow )
{
    BOOL bInstall;

    if ( !lpszCmdLine || !*lpszCmdLine )
        bInstall = TRUE;
    else
        bInstall = FALSE;

    DoWork( bInstall );

    TCHAR szCmdLine[MAX_PATH];

    GetSystemDirectory(szCmdLine, ARRAYSIZE(szCmdLine));
    AddPath(szCmdLine, TEXT("shmgrate.exe"));
    ShellExecute(NULL, NULL, szCmdLine, TEXT("OCInstallUserConfigIE"), NULL, SW_SHOWDEFAULT);

    return 0;
}

// stolen from the CRT, used to shrink our code

int
_stdcall
ModuleEntry(void)
{
    STARTUPINFO si;
    LPSTR pszCmdLine = GetCommandLine();

    g_hinst = GetModuleHandle(NULL);

#ifdef DEBUG

    CcshellGetDebugFlags();

    if (IsFlagSet(g_dwBreakFlags, BF_ONOPEN))
        DebugBreak();

#endif

    if (FAILED(OleInitialize(NULL)))
        return 0;

    OSVERSIONINFO osvi;

    osvi.dwOSVersionInfoSize = sizeof(osvi);
    GetVersionEx(&osvi);
    if (VER_PLATFORM_WIN32_NT == osvi.dwPlatformId)
    {
        g_fRunningOnNT = TRUE;

        if (osvi.dwMajorVersion >= 5) {
            g_fRunningOnNT5 = TRUE;
            if (osvi.dwMinorVersion >= 1)
                g_fRunningOnWinXP = TRUE;
        }
    }
    else if ((VER_PLATFORM_WIN32_WINDOWS == osvi.dwPlatformId) && (0 == osvi.dwMinorVersion))
    {
        g_fRunningOnWin95 = TRUE;
    }

    // turn off critical error stuff
    SetErrorMode(SEM_NOOPENFILEERRORBOX | SEM_FAILCRITICALERRORS);

    if ( *pszCmdLine == '\"' ) {
        /*
         * Scan, and skip over, subsequent characters until
         * another double-quote or a null is encountered.
         */
        while ( *++pszCmdLine && (*pszCmdLine != '\"') );
        /*
         * If we stopped on a double-quote (usual case), skip
         * over it.
         */
        if ( *pszCmdLine == '\"' )
            pszCmdLine++;
    }
    else {
        while (*pszCmdLine > ' ')
            pszCmdLine++;
    }

    /*
     * Skip past any white space preceeding the second token.
     */
    while (*pszCmdLine && (*pszCmdLine <= ' ')) {
        pszCmdLine++;
    }

    si.dwFlags = 0;
    GetStartupInfoA(&si);

    WinMain(GetModuleHandle(NULL), NULL, pszCmdLine,
                   si.dwFlags & STARTF_USESHOWWINDOW ? si.wShowWindow : SW_SHOWDEFAULT);

    OleUninitialize();

    ExitProcess(0);
    return 0;           // We never come here
}

UINT CheckUninstIEVersion()
{
    HKEY hKey;
    DWORD dwSize;
    TCHAR szPreIEVer[50];
    WORD wPreIEVer[4];
    UINT uRet = LESSIE4;

    if ( RegOpenKeyEx( HKEY_CURRENT_USER, c_szActInstalledIEGUIDRestore, 0, KEY_READ, &hKey) != ERROR_SUCCESS )
    {
        if ( RegOpenKeyEx( HKEY_CURRENT_USER, c_szActInstalledIEGUID, 0, KEY_READ, &hKey) != ERROR_SUCCESS )
        {
            return uRet;
        }
    }

    dwSize = sizeof( szPreIEVer );
    if ( RegQueryValueEx(hKey, TEXT("Version"), NULL, NULL, (LPBYTE)szPreIEVer, &dwSize) == ERROR_SUCCESS )
    {
        ConvertVersionString( szPreIEVer, wPreIEVer, ',' );
        if ((wPreIEVer[0] == 0x0004) && (wPreIEVer[1]>=0x0047))
            uRet = IE4;
        else if (wPreIEVer[0] == 0x0005)
        {
            if (wPreIEVer[1] >= 0x0032)
                uRet = IE55;
            else
                uRet = IE5;
        } 
        else if (wPreIEVer[0] == 0x0006)
            uRet = IE6; 
    }
    RegCloseKey(hKey);

    return uRet;
}

BOOL IsPrevIE4()
{
    HKEY hKey;
    DWORD dwSize;
    TCHAR szPreIEVer[50];
    WORD wPreIEVer[4];
    BOOL bRet = FALSE;

    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE, c_szIE4Setup, 0, KEY_READ, &hKey) == ERROR_SUCCESS )
    {
        dwSize = sizeof( szPreIEVer );
        if ( RegQueryValueEx(hKey, c_szPreIEVer, NULL, NULL, (LPBYTE)szPreIEVer, &dwSize) == ERROR_SUCCESS )
        {
            ConvertVersionString( szPreIEVer, wPreIEVer, '.' );
            if ( (wPreIEVer[0] == 0x0004) && (wPreIEVer[1]>=0x0047) )
            {
                bRet = TRUE;
            }
        }
        RegCloseKey(hKey);
    }
    return bRet;
}

BOOL IsPrevIE4WebShell()
{
    HKEY hKey;
    DWORD dwSize;
    TCHAR szPreShellVer[50];
    WORD wPreShellVer[4];
    BOOL bRet = FALSE;

    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE, c_szIE4Setup, 0, KEY_READ, &hKey) == ERROR_SUCCESS )
    {
        dwSize = sizeof( szPreShellVer );
        if ( RegQueryValueEx(hKey, c_szPreShellVer, NULL, NULL, (LPBYTE)szPreShellVer, &dwSize) == ERROR_SUCCESS )
        {
            ConvertVersionString( szPreShellVer, wPreShellVer, '.' );
            if ((wPreShellVer[0] == 0x0004) && (wPreShellVer[1]>=0x0047) )
            {
                bRet = TRUE;
            }
        }
        RegCloseKey(hKey);
    }
    return bRet;
}

const TCHAR c_szMouseExceptions[]   = TEXT("Control Panel\\Microsoft Input Devices\\Mouse\\Exceptions");
// This gets written to the registry 
const TCHAR c_szFilename[] = TEXT("FileName");
const TCHAR c_szInternetExplorer[] = TEXT("Internet Explorer");
const TCHAR c_szDescription[] = TEXT("Description");
const TCHAR c_szVersion[] = TEXT("Version");
const TCHAR c_szIE[] = TEXT("IEXPLORE.EXE");
#define IE_VERSION 0x50000

void ProcessMouseException()
{
    HKEY hKey;
    HKEY hSubKey;
    DWORD dwIndex = 1001;   // start with 1001.
    TCHAR szSubKey[16];
    BOOL  bCannotUse = TRUE;
    TCHAR szData[MAX_PATH];

    RemoveOldMouseException();
    if (RegCreateKeyEx(HKEY_CURRENT_USER, c_szMouseExceptions, 0, NULL, 0, KEY_WRITE|KEY_READ, NULL, &hKey, NULL) == ERROR_SUCCESS)
    {
        while (bCannotUse)
        {
            wsprintf(szSubKey, "%d", dwIndex);
            if (RegOpenKeyEx(hKey, szSubKey, 0, KEY_READ, &hSubKey) == ERROR_SUCCESS)
            {
                RegCloseKey(hSubKey);
                dwIndex++;
            }
            else
                bCannotUse = FALSE;
        }
        if (RegCreateKeyEx(hKey, szSubKey, 0, NULL, 0, KEY_WRITE, NULL, &hSubKey, NULL) == ERROR_SUCCESS)
        {
            if (!LoadString(g_hinst, IDS_IE_APPNAME, szData, sizeof(szData)))
                lstrcpy(szData, c_szInternetExplorer);
            RegSetValueEx(hSubKey, c_szDescription, 0, REG_SZ, (LPBYTE)szData, (lstrlen(szData)+1) * sizeof(TCHAR));
            RegSetValueEx(hSubKey, c_szFilename, 0, REG_SZ, (LPBYTE)c_szIE, (lstrlen(c_szIE)+1) * sizeof(TCHAR));
            dwIndex = IE_VERSION;
            RegSetValueEx(hSubKey, c_szVersion, 0, REG_DWORD, (LPBYTE)&dwIndex , sizeof(DWORD));
            RegCloseKey(hSubKey);
        }
        RegCloseKey(hKey);
    }
}

void RemoveOldMouseException()
{
    HKEY hKey;
    HKEY hSubKey;
    DWORD dwIndex = 0;
    BOOL  bFound = FALSE;
    LONG  lRet = ERROR_SUCCESS;
    TCHAR szSubKey[MAX_PATH];
    DWORD dwSize;
    TCHAR szData[MAX_PATH];

    if (RegOpenKeyEx(HKEY_CURRENT_USER, c_szMouseExceptions, 0, KEY_READ|KEY_WRITE, &hKey) == ERROR_SUCCESS)
    {
        while (!bFound && (lRet == ERROR_SUCCESS))    
        {
            dwSize = sizeof(szSubKey);
            lRet = RegEnumKeyEx(hKey, dwIndex, szSubKey, &dwSize, NULL, NULL, NULL, NULL);
            if (lRet == ERROR_SUCCESS)
            {
                if (RegOpenKeyEx(hKey, szSubKey, 0, KEY_READ, &hSubKey) == ERROR_SUCCESS)
                {
                    dwSize = sizeof(szData);
                    if (RegQueryValueEx(hSubKey, c_szFilename,NULL, NULL, (LPBYTE)szData, &dwSize) == ERROR_SUCCESS)
                    {
                        bFound = (lstrcmpi(szData, c_szIE) == 0);
                    }
                    RegCloseKey(hSubKey);
                }
                if (bFound)
                {
                    RegDeleteKey(hKey, szSubKey);
                }
                else
                    dwIndex++;
            }
        }
        RegCloseKey(hKey);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\iedetect\pch.h ===
#include <Windows.h>
#include <Windowsx.h>
#include <shlobj.h>
#include <prsht.h>
#include <commctrl.h>
#include <regstr.h>
#include <wininet.h>
#include <objbase.h>
#include <shlwapi.h>
#include <urlmon.h>
#include <advpub.h>
#include "sdsutils.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\iedetect\iedetect.cpp ===
#include "pch.h"
#include "iedetect.h"
#include "sdsutils.h"

HINSTANCE g_hInstance = NULL;
HANDLE g_hHeap = NULL;


DWORD MyDetectInternetExplorer(LPSTR guid, LPSTR pLocal, 
                               DWORD dwAskVer, DWORD dwAskBuild, 
                               LPDWORD pdwInstalledVer, LPDWORD pdwInstalledBuild)
{
    DWORD   dwRet = DET_NOTINSTALLED;
    char    szValue[MAX_PATH];
    HKEY    hKey = NULL;
    DWORD   dwSize;
    DWORD   dwInstalledVer, dwInstalledBuild;

    dwInstalledVer = (DWORD)-1;
    dwInstalledBuild  = (DWORD)-1;
    if(RegOpenKeyExA(HKEY_LOCAL_MACHINE, IE_KEY, 0, KEY_READ, &hKey) == ERROR_SUCCESS)
    {
        dwSize = sizeof(szValue);
        if(RegQueryValueEx(hKey, VERSION_KEY, 0, NULL, (LPBYTE)szValue, &dwSize) == ERROR_SUCCESS)
        {
            // Everything is fine. This should be IE4 or greater.
            ConvertVersionStrToDwords(szValue, '.', &dwInstalledVer, &dwInstalledBuild);
            dwRet = CompareVersions(dwAskVer, dwAskBuild, dwInstalledVer, dwInstalledBuild);
        }
        else if(RegQueryValueEx(hKey, BUILD_KEY, 0, NULL, (LPBYTE)szValue, &dwSize) == ERROR_SUCCESS)
        {
            // See if we find a IE3 entry.
            ConvertVersionStrToDwords(szValue, '.', &dwInstalledVer, &dwInstalledBuild);
            // Now generate a IE3 version number.
            dwInstalledBuild = (DWORD)HIWORD(dwInstalledVer);
            dwInstalledVer = IE_3_MS_VERSION;        // 4.70 IE3 major version
            dwRet = CompareVersions(dwAskVer, dwAskBuild, dwInstalledVer, dwInstalledBuild);
        }
        RegCloseKey(hKey);
    }
    // If we could not find anything, check the AppPath for Iexplore.exe
    if (dwInstalledVer == (DWORD)-1)
    {
        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, IEXPLORE_APPPATH_KEY, 0, KEY_QUERY_VALUE, &hKey) == ERROR_SUCCESS)
        {
            dwSize = sizeof(szValue);
            if (RegQueryValueEx(hKey, NULL, 0, NULL, (LPBYTE)szValue, &dwSize) == ERROR_SUCCESS)
            {
                GetVersionFromFile(szValue, &dwInstalledVer, &dwInstalledBuild, TRUE);
                if ((dwInstalledVer != 0) && (dwInstalledBuild != 0))
                    dwRet = CompareVersions(dwAskVer, dwAskBuild, dwInstalledVer, dwInstalledBuild);
            }
            RegCloseKey(hKey);
        }
    }
    if (pdwInstalledVer && pdwInstalledBuild)
    {
        *pdwInstalledVer = dwInstalledVer;
        *pdwInstalledBuild = dwInstalledBuild;
    }
    return dwRet;
}


DWORD WINAPI DetectInternetExplorer(DETECTION_STRUCT *pDet)
{
   return(MyDetectInternetExplorer(pDet->pszGUID, pDet->pszLocale, pDet->dwAskVer, pDet->dwAskBuild,
                                   pDet->pdwInstalledVer, pDet->pdwInstalledBuild));
}


DWORD WINAPI DetectDCOM(DETECTION_STRUCT *pDet)
{
    DWORD dwRet = DET_NOTINSTALLED;
    DWORD dwInstalledVer, dwInstalledBuild;

    dwInstalledVer = (DWORD) -1;
    dwInstalledBuild = (DWORD) -1;
    if (FRunningOnNT())
    {
        // On NT assume DCOM is installed;
        dwRet = DET_NEWVERSIONINSTALLED;
    }
    else
    {
        char szFile[MAX_PATH];
        char szRenameFile[MAX_PATH];
        GetSystemDirectory(szFile, sizeof(szFile));
        AddPath(szFile, "ole32.dll");
        ReadFromWininitOrPFRO(szFile, szRenameFile);
        if (*szRenameFile != '\0')
            GetVersionFromFile(szRenameFile, &dwInstalledVer, &dwInstalledBuild, TRUE);
        else
            GetVersionFromFile(szFile, &dwInstalledVer, &dwInstalledBuild, TRUE);

        if (dwInstalledVer != 0)
            dwRet = CompareVersions(pDet->dwAskVer, pDet->dwAskBuild, dwInstalledVer, dwInstalledBuild);
    }

    if (pDet->pdwInstalledVer && pDet->pdwInstalledBuild)
    {
        *(pDet->pdwInstalledVer) = dwInstalledVer;
        *(pDet->pdwInstalledBuild) = dwInstalledBuild;
    }
    return dwRet;
}

LPSTR g_szMFCFiles[] = { "MFC40.DLL", "MSVCRT40.DLL", "OLEPRO32.DLL", NULL}; 

DWORD WINAPI DetectMFC(DETECTION_STRUCT *pDet)
{
    DWORD   dwRet = DET_NOTINSTALLED;
    LPSTR   lpTmp;
    char    szFile[MAX_PATH];
    BOOL    bInstallMFC = FALSE;
    UINT    uiIndex = 0;

    lpTmp = g_szMFCFiles[uiIndex];
    while (!bInstallMFC && lpTmp)
    {
        GetSystemDirectory(szFile, sizeof(szFile));
        AddPath(szFile, lpTmp);

        if (GetFileAttributes(szFile) == 0xFFFFFFFF)
            bInstallMFC = TRUE;
        uiIndex++;
        lpTmp = g_szMFCFiles[uiIndex];
    }
    if (bInstallMFC)
        dwRet = DET_NOTINSTALLED;
    else
        dwRet = DET_INSTALLED;

    if (pDet->pdwInstalledVer && pDet->pdwInstalledBuild)
    {
        *(pDet->pdwInstalledVer) = (DWORD)-1;
        *(pDet->pdwInstalledBuild) = (DWORD)-1;
    }
    return dwRet;
}

// Detection for MediaPlayer, called DirectShow in IE4
//
// For IE lite we want to ask for DirectShow version 2.0. Unfortunatly
// the version in the registry and the versino of the files don't reflect this.
// Also the version in the CIF and the version of the files don't fit anymore 
// in IE5.Therefore the code below spezial cases the 2.0 case, which ie lite
// should ask for. All other modes are asking for the version of the CIF and
// the detection code has to get the version from the registry.
//
#define DIRECTSHOW_IE4_VER   0x00050001
#define DIRECTSHOW_IE4_BUILD 0x00120400

DWORD WINAPI DetectDirectShow(DETECTION_STRUCT *pDet)
{
    DWORD   dwRet = DET_NOTINSTALLED;
    DWORD   dwVerDevenum, dwBuildDevenum;
    DWORD   dwVerQuartz, dwBuildQuartz;
    DWORD   dwInstalledVer, dwInstalledBuild;
    char    szFile[MAX_PATH];

    dwInstalledVer = dwInstalledBuild = (DWORD)-1;
    if (pDet->dwAskVer == 0x00020000)
    {
        // Called for ie-lite
        GetSystemDirectory( szFile, sizeof(szFile) );
        AddPath(szFile, "quartz.dll");
        if (SUCCEEDED(GetVersionFromFile(szFile, &dwVerQuartz, &dwBuildQuartz, TRUE)))
        {
            GetSystemDirectory( szFile, sizeof(szFile) );
            AddPath(szFile, "devenum.dll");
            if (SUCCEEDED(GetVersionFromFile(szFile, &dwVerDevenum, &dwBuildDevenum, TRUE)))
            {
                // Both files found.
                if ((dwVerQuartz == dwVerDevenum) &&
                    (dwBuildQuartz == dwBuildDevenum) &&
                    ((dwVerQuartz > DIRECTSHOW_IE4_VER) ||
                     ((dwVerQuartz == DIRECTSHOW_IE4_VER) && (dwBuildQuartz >= DIRECTSHOW_IE4_BUILD))) )
                {
                    dwRet = DET_INSTALLED;
                }
            }
        }
    }
    else
    {
        // If we got a version number passed in, check against the installed version from
        // the 'Installed component' branch for that GUID.
        
        if (GetVersionFromGuid(pDet->pszGUID, &dwInstalledVer, &dwInstalledBuild))
            dwRet = CompareVersions(pDet->dwAskVer, pDet->dwAskBuild, dwInstalledVer, dwInstalledBuild);
    }
    if (pDet->pdwInstalledVer && pDet->pdwInstalledBuild)
    {
        *(pDet->pdwInstalledVer) = dwInstalledVer;
        *(pDet->pdwInstalledBuild) = dwInstalledBuild;
    }
    return dwRet;
}

#define DIRECTXD3_MSVER 0x00040002
#define DIRECTXD3_LSVER 0x0000041E
#define DIRECTXDD_MSVER 0x00040004
#define DIRECTXDD_LSVER 0x00000044

DETECT_FILES DirectX_Win[] = 
        { {"S", "d3dim.dll", DIRECTXD3_MSVER, DIRECTXD3_LSVER},
          {"S", "d3drg16f.dll", DIRECTXD3_MSVER, DIRECTXD3_LSVER},
          {"S", "d3drgbf.dll", DIRECTXD3_MSVER, DIRECTXD3_LSVER},
          {"S", "d3drm.dll", DIRECTXD3_MSVER, DIRECTXD3_LSVER},
          {"S", "d3dxof.dll", DIRECTXD3_MSVER, DIRECTXD3_LSVER},
          {"S", "ddhelp.exe", DIRECTXDD_MSVER, DIRECTXDD_LSVER},
          {"S", "ddraw.dll", DIRECTXDD_MSVER, DIRECTXDD_LSVER},
          {"S", "ddraw16.dll", DIRECTXDD_MSVER, DIRECTXDD_LSVER},
          {"S", "dsound.dll", DIRECTXDD_MSVER, DIRECTXDD_LSVER},
          {"\0", "", 0, 0} };

DWORD WINAPI DetectDirectX(DETECTION_STRUCT *pDet)
{
    int     iIndex = 0;
    DWORD   dwRet = DET_NOTINSTALLED;
    DWORD   dwInstalledVer, dwInstalledBuild;
    
    dwInstalledVer = dwInstalledBuild = (DWORD)-1;
    if (FRunningOnNT())
    {
        // On NT assume DirectXMini is newer.
        dwRet = DET_NEWVERSIONINSTALLED;
    }
    else
    {
        if (pDet->dwAskVer == 0)
        {
            // Call for ie-lite,
            // just check if IE4 is installed.
            dwRet = MyDetectInternetExplorer(pDet->pszGUID, pDet->pszLocale, 
                                            IE_4_MS_VERSION, 0, 
                                            &dwInstalledVer, &dwInstalledBuild);
            if (dwRet == DET_OLDVERSIONINSTALLED)
                dwRet = DET_NOTINSTALLED;
            if (dwRet == DET_NEWVERSIONINSTALLED)
                dwRet = DET_INSTALLED;
        }
        else
        {
            do 
            {
                if (DirectX_Win[iIndex].cPath[0])
                    dwRet = CheckFile(DirectX_Win[iIndex]);
                iIndex++;
            } while (((dwRet == DET_INSTALLED) || (dwRet == DET_NEWVERSIONINSTALLED)) && (DirectX_Win[iIndex].cPath[0] != '\0'));
        }
    }
    if (pDet->pdwInstalledVer && pDet->pdwInstalledBuild)
    {
        *(pDet->pdwInstalledVer) = dwInstalledVer;
        *(pDet->pdwInstalledBuild) = dwInstalledBuild;
    }
    return dwRet;
}

#define DDRAWEX_MSVER 0x00040047
#define DDRAWEX_LSVER 0x04580000
DETECT_FILES DDrawEx[] = 
        { {"S", "ddrawex.dll", DDRAWEX_MSVER, DDRAWEX_LSVER },
          {"\0", "", 0, 0} };
DWORD WINAPI DetectDirectDraw(DETECTION_STRUCT *pDet)
{
    int     iIndex = 0;
    DWORD   dwRet = DET_NOTINSTALLED;
    DWORD   dwInstalledVer, dwInstalledBuild;
    
    do 
    {
        if (DDrawEx[iIndex].cPath[0])
            dwRet = CheckFile(DDrawEx[iIndex]);
        iIndex++;
    } while (((dwRet == DET_INSTALLED) || (dwRet == DET_NEWVERSIONINSTALLED)) && (DDrawEx[iIndex].cPath[0] != '\0'));

    dwInstalledVer = dwInstalledBuild = (DWORD)-1;
    if (pDet->pdwInstalledVer && pDet->pdwInstalledBuild)
    {
        *(pDet->pdwInstalledVer) = dwInstalledVer;
        *(pDet->pdwInstalledBuild) = dwInstalledBuild;
    }
    return dwRet;
}

DWORD WINAPI DetectICW(DETECTION_STRUCT *pDet)
{
    DWORD   dwRet = DET_NOTINSTALLED;
    DWORD   dwInstalledVer, dwInstalledBuild;

    dwInstalledVer = dwInstalledBuild = (DWORD)-1;
    if (pDet->dwAskVer == 0)
    {
        // Call for ie-lite,
        // just check if IE4 is installed.
        // If we don't get a version number pass in, assume we only check for default browser
        if (IsIEDefaultBrowser())
            dwRet = DET_INSTALLED;
    }
    else
    {
        // If we got a version number passed in, check against the installed version from
        // the 'Installed component' branch for that GUID.
        if (GetVersionFromGuid(pDet->pszGUID, &dwInstalledVer, &dwInstalledBuild))
            dwRet = CompareVersions(pDet->dwAskVer, pDet->dwAskBuild, dwInstalledVer, dwInstalledBuild);
    }
    if (pDet->pdwInstalledVer && pDet->pdwInstalledBuild)
    {
        *(pDet->pdwInstalledVer) = dwInstalledVer;
        *(pDet->pdwInstalledBuild) = dwInstalledBuild;
    }

    return dwRet;
}

// NT version of setupapi.dll (4.0.1381.10)
#define SETUPAPI_NT_MSVER   0x00040000
#define SETUPAPI_NT_LSVER   0x0565000A
// Win9x version of setupapi.dll (5.0.1453.7)
#define SETUPAPI_WIN_MSVER   0x00050000
#define SETUPAPI_WIN_LSVER   0x05AD0007    
// Win9x version of cfgmgr32.dll (4.10.0.1422)
#define CFGMGR32_WIN_MSVER   0x0004000a
#define CFGMGR32_WIN_LSVER   0x0000058e
// minimal Cabinet.dll version (1.0.601.4)
#define CABINET_MSVER   0x00010000
#define CABINET_LSVER   0x02590004
// Version of w95inf16.dll
#define W95INF16_MSVER  0x00040047
#define W95INF16_LSVER  0x02c00000
// Version of w95inf32.dll
#define W95INF32_MSVER  0x00040047
#define W95INF32_LSVER  0x00100000
// Version of regsvr32.exe
#define REGSVR32_MSVER  0x00050000
#define REGSVR32_LSVER  0x06310001

// Note: for now we only allow 10 characters in the cPath part of the structure.
// If more characters are needed change the amount below.
//
DETECT_FILES Gensetup_W95[] = 
        { {"S", "cabinet.dll", CABINET_MSVER, CABINET_LSVER },
          {"S", "setupapi.dll", SETUPAPI_WIN_MSVER, SETUPAPI_WIN_LSVER}, 
          {"S", "cfgmgr32.dll", CFGMGR32_WIN_MSVER, CFGMGR32_WIN_LSVER}, 
          {"S", "regsvr32.exe", REGSVR32_MSVER, REGSVR32_LSVER }, 
          {"S", "w95inf16.dll", W95INF16_MSVER, W95INF16_LSVER }, 
          {"S", "w95inf32.dll", W95INF32_MSVER, W95INF32_LSVER }, 
          {"W,C", "extract.exe", -1, -1 }, 
          {"W,C", "iextract.exe", -1, -1 }, 
          {"\0", "", 0, 0} };

DETECT_FILES Gensetup_NT[] = 
        { {"S", "cabinet.dll", CABINET_MSVER, CABINET_LSVER },
          {"S", "setupapi.dll", SETUPAPI_NT_MSVER, SETUPAPI_NT_LSVER}, 
          {"S", "regsvr32.exe", REGSVR32_MSVER, REGSVR32_LSVER }, 
          {"W", "extract.exe", -1, -1 }, 
          {"W", "iextract.exe", -1, -1 }, 
          {"\0", "", 0, 0} };

DWORD WINAPI DetectGenSetup(DETECTION_STRUCT *pDet)
{
    DWORD   dwRet = DET_NOTINSTALLED;
    int     iIndex = 0;
    DETECT_FILES *Detect_Files;
    if (FRunningOnNT())
        Detect_Files = Gensetup_NT;
    else
        Detect_Files = Gensetup_W95;

    do 
    {
        if (Detect_Files[iIndex].cPath[0])
            dwRet = CheckFile(Detect_Files[iIndex]);
        iIndex++;
    } while (((dwRet == DET_INSTALLED) || (dwRet == DET_NEWVERSIONINSTALLED)) && (Detect_Files[iIndex].cPath[0] != '\0'));

    return dwRet;
}


DWORD WINAPI DetectOfflinePkg(DETECTION_STRUCT *pDet)
{
    DWORD   dwRet = DET_NOTINSTALLED;
    DWORD   dwInstalledVer, dwInstalledBuild;
    char szFile[MAX_PATH];
    char szRenameFile[MAX_PATH];
    
    dwInstalledVer = dwInstalledBuild = (DWORD)-1;

    // If we got a version number passed in, check against the installed version from
    // the 'Installed component' branch for that GUID.
    if (GetVersionFromGuid(pDet->pszGUID, &dwInstalledVer, &dwInstalledBuild))
        dwRet = CompareVersions(pDet->dwAskVer, pDet->dwAskBuild, dwInstalledVer, dwInstalledBuild);

    if (dwRet == DET_NOTINSTALLED)
    {
        // check if webcheck.dll is on the users machine, we should update it.
        GetSystemDirectory( szFile, sizeof(szFile) );
        AddPath(szFile, "webcheck.dll");
        ReadFromWininitOrPFRO(szFile, szRenameFile);
        if (*szRenameFile != '\0')
            GetVersionFromFile(szRenameFile, &dwInstalledVer, &dwInstalledBuild, TRUE);
        else
            GetVersionFromFile(szFile, &dwInstalledVer, &dwInstalledBuild, TRUE);

        if (dwInstalledVer != 0)
            dwRet = CompareVersions(pDet->dwAskVer, pDet->dwAskBuild, dwInstalledVer, dwInstalledBuild);
    }

    if (pDet->pdwInstalledVer && pDet->pdwInstalledBuild)
    {
        *(pDet->pdwInstalledVer) = dwInstalledVer;
        *(pDet->pdwInstalledBuild) = dwInstalledBuild;
    }

    return dwRet;
}


DWORD WINAPI DetectJapaneseFontPatch(DETECTION_STRUCT *pDet)
{
    DWORD   dwInstalledVer, dwInstalledBuild;
    DWORD   dwRet = DET_NEWVERSIONINSTALLED;
    if (pDet->pdwInstalledVer && pDet->pdwInstalledBuild)
    {
        *(pDet->pdwInstalledVer) = -1;
        *(pDet->pdwInstalledBuild) = -1;
    }
    if (GetSystemDefaultLCID() == 1041)
    {
        // If we are running locale Japanese, Install the font.
        dwRet = DET_NOTINSTALLED;
    }
    // If we are running on a Japanese system, see if the component is installed using the GUID
    if (dwRet == DET_NOTINSTALLED)
    {
        if (GetVersionFromGuid(pDet->pszGUID, pDet->pdwInstalledVer, pDet->pdwInstalledBuild))
        {
            dwRet = CompareVersions(pDet->dwAskVer, pDet->dwAskBuild, *(pDet->pdwInstalledVer), *(pDet->pdwInstalledBuild));
        }
    }
    return dwRet;
}

DWORD WINAPI DetectAOLSupport(DETECTION_STRUCT *pDet)
{
    DWORD   dwRet = DET_NOTINSTALLED;
    DWORD   dwInstalledVer, dwInstalledBuild;
    
    dwInstalledVer = dwInstalledBuild = (DWORD)-1;
    if (pDet->dwAskVer == 0)
    {
        // Call for ie-lite,
        char szFile[MAX_PATH];

        GetSystemDirectory( szFile, sizeof(szFile) );
        AddPath(szFile, "jgaw400.dll");
        // See if one of the AOL support files exist.
        if (GetFileAttributes(szFile) == 0xFFFFFFFF)
        {
            dwRet = DET_NOTINSTALLED;
        }
        else
        {
            dwRet = DET_INSTALLED;
        }
    }
    else
    {
        // If we got a version number passed in, check against the installed version from
        // the 'Installed component' branch for that GUID.
        if (GetVersionFromGuid(pDet->pszGUID, &dwInstalledVer, &dwInstalledBuild))
            dwRet = CompareVersions(pDet->dwAskVer, pDet->dwAskBuild, dwInstalledVer, dwInstalledBuild);
    }
    if (pDet->pdwInstalledVer && pDet->pdwInstalledBuild)
    {
        *(pDet->pdwInstalledVer) = dwInstalledVer;
        *(pDet->pdwInstalledBuild) = dwInstalledBuild;
    }
    return dwRet;
}


DWORD WINAPI DetectHTMLHelp(DETECTION_STRUCT *pDet)
{
    return DetectFile(pDet, "hhctrl.ocx");
}


DWORD WINAPI DetectOLEAutomation(DETECTION_STRUCT *pDet)
{
    return DetectFile(pDet, "oleaut32.dll");
}

DWORD WINAPI DetectJavaVM(DETECTION_STRUCT *pDet)
{
    HKEY hKey;
    DWORD   dwRet = DET_NOTINSTALLED;
    char    szValue[MAX_PATH];
    DWORD   dwValue = 0;
    DWORD   dwSize;

    lstrcpy(szValue, COMPONENT_KEY);
    AddPath(szValue, pDet->pszGUID);
    if(RegOpenKeyExA(HKEY_LOCAL_MACHINE, szValue, 0, KEY_READ, &hKey) == ERROR_SUCCESS)
    {
        dwSize = sizeof(dwValue);
        if(RegQueryValueEx(hKey, "IgnoreFile", 0, NULL, (LPBYTE)&dwValue, &dwSize) == ERROR_SUCCESS)
        {
            if (dwValue != 0)
            {
                dwRet = DET_INSTALLED;
                if (pDet->pdwInstalledVer && pDet->pdwInstalledBuild)
                {
                    *(pDet->pdwInstalledVer) = (DWORD)-1;
                    *(pDet->pdwInstalledBuild) = (DWORD)-1;
                }
            }
        }
        else
            dwValue = 0;
        RegCloseKey(hKey);
    }

    if (dwValue == 0)
        dwRet = DetectFile(pDet, "msjava.dll");
    return dwRet;
}

#define MSAPSSPC_MSVER 0x00050000
#define MSAPSSPC_LSVER 0x00001E31 
DETECT_FILES msn_auth[] = 
        { {"S", "MSAPSSPC.dll", MSAPSSPC_MSVER, MSAPSSPC_LSVER },
          {"\0", "", 0, 0} };

DWORD WINAPI DetectMsn_Auth(DETECTION_STRUCT *pDet)
{
    int     iIndex = 0;
    DWORD   dwRet = DET_NOTINSTALLED;
    DWORD   dwInstalledVer, dwInstalledBuild;
    
    do 
    {
        if (msn_auth[iIndex].cPath[0])
            dwRet = CheckFile(msn_auth[iIndex]);
        iIndex++;
    } while (((dwRet == DET_INSTALLED) || (dwRet == DET_NEWVERSIONINSTALLED)) && (msn_auth[iIndex].cPath[0] != '\0'));

    dwInstalledVer = dwInstalledBuild = (DWORD)-1;
    if (pDet->pdwInstalledVer && pDet->pdwInstalledBuild)
    {
        *(pDet->pdwInstalledVer) = dwInstalledVer;
        *(pDet->pdwInstalledBuild) = dwInstalledBuild;
    }
    return dwRet;
}

DWORD WINAPI DetectTdc(DETECTION_STRUCT *pDet)
{
    return DetectFile(pDet, "tdc.ocx");
}

DWORD WINAPI DetectMDAC(DETECTION_STRUCT *pDet)
{
    char    szValue[MAX_PATH];
    HKEY    hKey = NULL;
    DWORD   dwSize;
    DWORD   dwRet = DET_NOTINSTALLED;
    DWORD   dwInstalledVer, dwInstalledBuild;

    dwInstalledVer = (DWORD)-1;
    dwInstalledBuild  = (DWORD)-1;
    if(RegOpenKeyExA(HKEY_LOCAL_MACHINE, "Software\\Microsoft\\DataAccess", 0, KEY_READ, &hKey) == ERROR_SUCCESS)
    {
        dwSize = sizeof(szValue);
        if (RegQueryValueEx(hKey, "FullInstallVer", NULL, NULL, (LPBYTE)szValue, &dwSize) == ERROR_SUCCESS)
        {
            ConvertVersionStrToDwords(szValue, '.', &dwInstalledVer, &dwInstalledBuild);
            dwRet = CompareVersions(pDet->dwAskVer, pDet->dwAskBuild, dwInstalledVer, dwInstalledBuild);
        }
        RegCloseKey(hKey);
    }

    // Did not find the registry key or entry,
    // need to do file comparison to detect MDAC version 2.1
    if (dwRet == DET_NOTINSTALLED)
    {
        char    szRenameFile[MAX_PATH];
        if(RegOpenKeyExA(HKEY_LOCAL_MACHINE, REGSTR_PATH_SETUP, 0, KEY_READ, &hKey) == ERROR_SUCCESS)
        {
            dwSize = sizeof(szValue);
            if (RegQueryValueEx(hKey, "CommonFilesDir", NULL, NULL, (LPBYTE)szValue, &dwSize) == ERROR_SUCCESS)
            {
                AddPath(szValue, "system\\ado\\msado15.dll");
                ReadFromWininitOrPFRO(szValue, szRenameFile);
                if (*szRenameFile != '\0')
                    GetVersionFromFile(szRenameFile, &dwInstalledVer, &dwInstalledBuild, TRUE);
                else
                    GetVersionFromFile(szValue, &dwInstalledVer, &dwInstalledBuild, TRUE);
                dwRet = CompareVersions(pDet->dwAskVer, pDet->dwAskBuild, dwInstalledVer, dwInstalledBuild);
            }
            RegCloseKey(hKey);
        }


    }
    return dwRet;
}


STDAPI_(BOOL) DllMain(HANDLE hDll, DWORD dwReason, void *lpReserved)
{
   DWORD dwThreadID;

   switch(dwReason)
   {
      case DLL_PROCESS_ATTACH:
         g_hInstance = (HINSTANCE)hDll;
         g_hHeap = GetProcessHeap();
         DisableThreadLibraryCalls(g_hInstance);
         break;

      case DLL_PROCESS_DETACH:
         break;

      default:
         break;
   }
   return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\iedetect\utils.cpp ===
#include "pch.h"
#include "iedetect.h"

#define VALID_SIGNATURE     0x5c3f3f5c              // string "\??\"
#define REMOVE_QUOTES       0x01
#define IGNORE_QUOTES       0x02

CONST CHAR g_cszWininit[]           = "wininit.ini";
CONST CHAR g_cszRenameSec[]         = "Rename";
CONST CHAR g_cszPFROKey[]           = REGSTR_PATH_CURRENT_CONTROL_SET "\\SESSION MANAGER";
CONST CHAR g_cszPFRO[]              = "PendingFileRenameOperations";

DWORD CheckFileEx(LPSTR szDir, DETECT_FILES Detect_Files);

DWORD GetStringField(LPSTR szStr, UINT uField, char cDelimiter, LPSTR szBuf, UINT cBufSize)
{
   LPSTR pszBegin = szStr;
   LPSTR pszEnd;
   UINT i = 0;
   DWORD dwToCopy;

   if(cBufSize == 0)
       return 0;

   szBuf[0] = 0;

   if(szStr == NULL)
      return 0;

   while(*pszBegin != 0 && i < uField)
   {
      pszBegin = FindChar(pszBegin, cDelimiter);
      if(*pszBegin != 0)
         pszBegin++;
      i++;
   }

   // we reached end of string, no field
   if(*pszBegin == 0)
   {
      return 0;
   }


   pszEnd = FindChar(pszBegin, cDelimiter);
   while(pszBegin <= pszEnd && *pszBegin == ' ')
      pszBegin++;

   while(pszEnd > pszBegin && *(pszEnd - 1) == ' ')
      pszEnd--;

   if(pszEnd > (pszBegin + 1) && *pszBegin == '"' && *(pszEnd-1) == '"')
   {
      pszBegin++;
      pszEnd--;
   }

   dwToCopy = (DWORD)(pszEnd - pszBegin + 1);

   if(dwToCopy > cBufSize)
      dwToCopy = cBufSize;

   lstrcpynA(szBuf, pszBegin, dwToCopy);

   return dwToCopy - 1;
}

DWORD GetIntField(LPSTR szStr, char cDelimiter, UINT uField, DWORD dwDefault)
{
   char szNumBuf[16];

   if(GetStringField(szStr, uField, cDelimiter, szNumBuf, sizeof(szNumBuf)) == 0)
      return dwDefault;
   else
      return AtoL(szNumBuf);
}

int CompareLocales(LPCSTR pcszLoc1, LPCSTR pcszLoc2)
{
   int ret;

   if(pcszLoc1[0] == '*' || pcszLoc2[0] == '*')
      ret = 0;
   else
      ret = lstrcmpi(pcszLoc1, pcszLoc2);

   return ret;
}


void ConvertVersionStrToDwords(LPSTR pszVer, char cDelimiter, LPDWORD pdwVer, LPDWORD pdwBuild)
{
   DWORD dwTemp1,dwTemp2;

   dwTemp1 = GetIntField(pszVer, cDelimiter, 0, 0);
   dwTemp2 = GetIntField(pszVer, cDelimiter, 1, 0);

   *pdwVer = (dwTemp1 << 16) + dwTemp2;

   dwTemp1 = GetIntField(pszVer, cDelimiter, 2, 0);
   dwTemp2 = GetIntField(pszVer, cDelimiter, 3, 0);

   *pdwBuild = (dwTemp1 << 16) + dwTemp2;
}

LPSTR FindChar(LPSTR pszStr, char ch)
{
   while( *pszStr != 0 && *pszStr != ch )
      pszStr++;
   return pszStr;
}

DWORD CompareVersions(DWORD dwAskVer, DWORD dwAskBuild, DWORD dwInstalledVer, DWORD dwInstalledBuild)
{
    DWORD dwRet = DET_NOTINSTALLED;
    if((dwInstalledVer == dwAskVer) && (dwInstalledBuild == dwAskBuild))
    {
        dwRet = DET_INSTALLED;
    }
    else if( (dwInstalledVer >  dwAskVer) ||
            ((dwInstalledVer == dwAskVer) && (dwInstalledBuild > dwAskBuild)) )

    {
        dwRet = DET_NEWVERSIONINSTALLED;
    }
    else if( (dwInstalledVer <  dwAskVer) ||
            ((dwInstalledVer == dwAskVer) && (dwInstalledBuild < dwAskBuild)) )

    {
        dwRet = DET_OLDVERSIONINSTALLED;
    }
    return dwRet;
}


BOOL FRunningOnNT(void)
{
    static BOOL fIsNT = 2 ;
    OSVERSIONINFO VerInfo;

    // If we have calculated this before just pass that back.
    // else find it now.
    //
    if (fIsNT == 2)
    {
        VerInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

        GetVersionEx(&VerInfo);

        // Note: We don't check for Win32S on Win 3.1 here -- that should
        // have been a blocking check earlier in fn CheckWinVer().
        // Also, we don't check for failure on the above call as it
        // should succeed if we are on NT 4.0 or Win 9X!
        //
        fIsNT = (VerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT);
    }

    return fIsNT;
}

BOOL GetVersionFromGuid(LPSTR pszGuid, LPDWORD pdwVer, LPDWORD pdwBuild)
{
    HKEY hKey;
    char    szValue[MAX_PATH];
    DWORD   dwValue = 0;
    DWORD   dwSize;
    BOOL    bVersion = FALSE;

    if (pdwVer && pdwBuild)
    {
        *pdwVer = 0;
        *pdwBuild = 0;
        lstrcpy(szValue, COMPONENT_KEY);
        AddPath(szValue, pszGuid);
        if(RegOpenKeyExA(HKEY_LOCAL_MACHINE, szValue, 0, KEY_READ, &hKey) == ERROR_SUCCESS)
        {
            dwSize = sizeof(dwValue);
            if(RegQueryValueEx(hKey, ISINSTALLED_KEY, 0, NULL, (LPBYTE)&dwValue, &dwSize) == ERROR_SUCCESS)
            {
                if (dwValue != 0)
                {
                    dwSize = sizeof(szValue);
                    if(RegQueryValueEx(hKey, VERSION_KEY, 0, NULL, (LPBYTE)szValue, &dwSize) == ERROR_SUCCESS)
                    {
                        ConvertVersionStrToDwords(szValue, ',', pdwVer, pdwBuild);
                        bVersion = TRUE;
                    }
                }
            }
            RegCloseKey(hKey);
        }
    }
    return bVersion;
}

BOOL CompareLocal(LPCSTR pszGuid, LPCSTR pszLocal)
{
    HKEY hKey;
    char    szValue[MAX_PATH];
    DWORD   dwSize;
    BOOL    bLocal = FALSE;
    if (lstrcmpi(pszLocal, "*") == 0)
    {
        bLocal = TRUE;
    }
    else
    {
        lstrcpy(szValue, COMPONENT_KEY);
        AddPath(szValue, pszGuid);
        if(RegOpenKeyExA(HKEY_LOCAL_MACHINE, szValue, 0, KEY_READ, &hKey) == ERROR_SUCCESS)
        {
            dwSize = sizeof(szValue);
            if(RegQueryValueEx(hKey, LOCALE_KEY, 0, NULL, (LPBYTE)szValue, &dwSize) == ERROR_SUCCESS)
            {
                bLocal = (lstrcmpi(szValue, pszLocal) == 0);
            }

            RegCloseKey(hKey);
        }
    }
    return bLocal;
}

PSTR GetNextField(PSTR *ppszData, PCSTR pcszDeLims, DWORD dwFlags)
// If (dwFlags & IGNORE_QUOTES) is TRUE, then look for any char in pcszDeLims in *ppszData.  If found,
// replace it with the '\0' char and set *ppszData to point to the beginning of the next field and return
// pointer to current field.
//
// If (dwFlags & IGNORE_QUOTES) is FALSE, then look for any char in pcszDeLims outside of balanced quoted sub-strings
// in *ppszData.  If found, replace it with the '\0' char and set *ppszData to point to the beginning of
// the next field and return pointer to current field.
//
// If (dwFlags & REMOVE_QUOTES) is TRUE, then remove the surrounding quotes and replace two consecutive quotes by one.
//
// NOTE: If IGNORE_QUOTES and REMOVE_QUOTES are both specified, then IGNORE_QUOTES takes precedence over REMOVE_QUOTES.
//
// If you just want to remove the quotes from a string, call this function as
// GetNextField(&pszData, "\"" or "'" or "", REMOVE_QUOTES).
//
// If you call this function as GetNextField(&pszData, "\"" or "'" or "", 0), you will get back the
// entire pszData as the field.
//
{
    PSTR pszRetPtr, pszPtr;
    BOOL fWithinQuotes = FALSE, fRemoveQuote;
    CHAR chQuote;

    if (ppszData == NULL  ||  *ppszData == NULL  ||  **ppszData == '\0')
        return NULL;

    for (pszRetPtr = pszPtr = *ppszData;  *pszPtr;  pszPtr = CharNext(pszPtr))
    {
        if (!(dwFlags & IGNORE_QUOTES)  &&  (*pszPtr == '"'  ||  *pszPtr == '\''))
        {
            fRemoveQuote = FALSE;

            if (*pszPtr == *(pszPtr + 1))           // two consecutive quotes become one
            {
                pszPtr++;

                if (dwFlags & REMOVE_QUOTES)
                    fRemoveQuote = TRUE;
                else
                {
                    // if pcszDeLims is '"' or '\'', then *pszPtr == pcszDeLims would
                    // be TRUE and we would break out of the loop against the design specs;
                    // to prevent this just continue
                    continue;
                }
            }
            else if (!fWithinQuotes)
            {
                fWithinQuotes = TRUE;
                chQuote = *pszPtr;                  // save the quote char

                fRemoveQuote = dwFlags & REMOVE_QUOTES;
            }
            else
            {
                if (*pszPtr == chQuote)             // match the correct quote char
                {
                    fWithinQuotes = FALSE;
                    fRemoveQuote = dwFlags & REMOVE_QUOTES;
                }
            }

            if (fRemoveQuote)
            {
                // shift the entire string one char to the left to get rid of the quote char
                MoveMemory(pszPtr, pszPtr + 1, lstrlen(pszPtr));
            }
        }

        // BUGBUG: Is type casting pszPtr to UNALIGNED necessary? -- copied it from ANSIStrChr
        // check if pszPtr is pointing to one of the chars in pcszDeLims
        if (!fWithinQuotes  &&
            ANSIStrChr(pcszDeLims, (WORD) (IsDBCSLeadByte(*pszPtr) ? *((UNALIGNED WORD *) pszPtr) : *pszPtr)) != NULL)
            break;
    }

    // NOTE: if fWithinQuotes is TRUE here, then we have an unbalanced quoted string; but we don't care!
    //       the entire string after the beginning quote becomes the field

    if (*pszPtr)                                    // pszPtr is pointing to a char in pcszDeLims
    {
        *ppszData = CharNext(pszPtr);               // save the pointer to the beginning of next field in *ppszData
        *pszPtr = '\0';                             // replace the DeLim char with the '\0' char
    }
    else
        *ppszData = pszPtr;                         // we have reached the end of the string; next call to this function
                                                    // would return NULL

    return pszRetPtr;
}

PSTR GetDataFromWininitOrPFRO(PCSTR pcszWininit, HKEY hkPFROKey, PDWORD pdwLen)
{
    PSTR pszData, pszPtr;

    *pdwLen = 0;

    if (!FRunningOnNT())
    {
        HANDLE hFile;
        WIN32_FIND_DATA FileData;

        // find the size of pcszWininit
        if ((hFile = FindFirstFile(pcszWininit, &FileData)) != INVALID_HANDLE_VALUE)
        {
            *pdwLen = FileData.nFileSizeLow;
            FindClose(hFile);
        }

        if (*pdwLen == 0  ||  (pszData = (PSTR) LocalAlloc(LPTR, *pdwLen)) == NULL)
            return NULL;

        GetPrivateProfileSection(g_cszRenameSec, pszData, *pdwLen, pcszWininit);

        // replace the ='s by \0's
        // BUGBUG: assuming that all the lines in wininit.ini have the correct format, i.e., to=from
        for (pszPtr = pszData;  *pszPtr;  pszPtr += lstrlen(pszPtr) + 1)
            GetNextField(&pszPtr, "=", IGNORE_QUOTES);
    }
    else
    {
        if (hkPFROKey == NULL)
            return NULL;

        // get the length of value data
        RegQueryValueEx(hkPFROKey, g_cszPFRO, NULL, NULL, NULL, pdwLen);

        if (*pdwLen == 0  ||  (pszData = (PSTR) LocalAlloc(LPTR, *pdwLen)) == NULL)
            return NULL;

        // get the data
        RegQueryValueEx(hkPFROKey, g_cszPFRO, NULL, NULL, (PBYTE) pszData, pdwLen);
    }

    return pszData;
}

VOID ReadFromWininitOrPFRO(PCSTR pcszKey, PSTR pszValue)
{
    CHAR szShortName[MAX_PATH];
    CHAR szWininit[MAX_PATH];
    PSTR pszData, pszLine, pszFrom, pszTo;
    DWORD dwLen;
    HKEY hkPFROKey = NULL;

    if (!FRunningOnNT())
    {
        GetWindowsDirectory(szWininit, sizeof(szWininit));
        AddPath(szWininit, g_cszWininit);
    }
    else
        RegOpenKeyEx(HKEY_LOCAL_MACHINE, g_cszPFROKey, 0, KEY_READ, &hkPFROKey);

    // return empty string if pcszKey could not be found
    *pszValue = '\0';

    if ((pszData = GetDataFromWininitOrPFRO(szWininit, hkPFROKey, &dwLen)) == NULL)
    {
        if (hkPFROKey != NULL)
            RegCloseKey(hkPFROKey);

        return;
    }

    if (!FRunningOnNT())
    {
        GetShortPathName(pcszKey, szShortName, sizeof(szShortName));
        pcszKey = szShortName;
    }

    pszLine = pszData;
    while (*pszLine)
    {
        // NOTE: On Win95, the format is (To, From) but on NT4.0, the format is (From, To)
        if (!FRunningOnNT())
        {
            // format of GetPrivateProfileSection data is:
            //
            // to1=from1\0                      ; from1 is the Value and to1 is the Key
            // to2=from2\0
            // NUL=del1\0                       ; del1 is the Key
            // NUL=del2\0
            //    .
            //    .
            //    .
            // to<n>=from<n>\0\0

            pszTo = pszLine;                            // key
            pszFrom = pszLine + lstrlen(pszLine) + 1;
            pszLine = pszFrom + lstrlen(pszFrom) + 1;   // point to the next line
        }
        else
        {
            // format of the value data for PFRO value name is:
            //
            // from1\0to1\0                     ; from1 is the Value and to1 is the Key
            // from2\0to2\0
            // del1\0\0                         ; del1 is the Key
            // del2\0\0
            //    .
            //    .
            //    .
            // from<n>\0to<n>\0\0

            pszFrom = pszLine;
            pszTo = pszLine + lstrlen(pszLine) + 1;     // key
            pszLine = pszTo + lstrlen(pszTo) + 1;       // point to the next line

            // skip over "\??\"
            if (*pszFrom == '\\')                       // '\\' is not a Leading DBCS byte
            {
                if (*((PDWORD) pszFrom) == VALID_SIGNATURE)
                    pszFrom += 4;
                else
                    continue;
            }

            if (*pszTo == '!')                          // '!' is neither a Leading nor a Trailing DBCS byte
                pszTo++;

            if (*pszTo == '\\')
            {
                if (*((PDWORD) pszTo) == VALID_SIGNATURE)
                    pszTo += 4;
                else
                    continue;
            }
        }

        if (lstrcmpi(pcszKey, pszTo) == 0)              // if there is more than one entry, return the last one
            lstrcpy(pszValue, pszFrom);
    }

    LocalFree(pszData);

    if (hkPFROKey != NULL)
        RegCloseKey(hkPFROKey);
}

DWORD CheckFile(DETECT_FILES Detect_Files)
{
    char    szFile[MAX_PATH] = { 0 };
    DWORD   dwRet = DET_NOTINSTALLED;
    DWORD   dwRetLast = DET_NOTINSTALLED;
    int     i =0;

    while (Detect_Files.cPath[i])
    {
        switch (Detect_Files.cPath[i])
        {
            case 'S':
            case 's':
                GetSystemDirectory( szFile, sizeof(szFile) );
                break;

            case 'W':
            case 'w':
                GetWindowsDirectory( szFile, sizeof(szFile) );
                break;

                // Windows command folder
            case 'C':
            case 'c':
                GetWindowsDirectory( szFile, sizeof(szFile) );
                AddPath(szFile, "Command");
                break;

            default:
                *szFile = '\0';
        }
        if (*szFile)
        {
            dwRet = CheckFileEx(szFile, Detect_Files);
            switch (dwRet)
            {
                case DET_NOTINSTALLED:
                    break;
                case DET_OLDVERSIONINSTALLED:
                    if (dwRetLast == DET_NOTINSTALLED)
                        dwRetLast = dwRet;
                    break;

                case DET_INSTALLED:
                    if ((dwRetLast == DET_NOTINSTALLED) ||
                        (dwRetLast == DET_OLDVERSIONINSTALLED))
                        dwRetLast = dwRet;
                    break;

                case DET_NEWVERSIONINSTALLED:
                    if ((dwRetLast == DET_NOTINSTALLED) ||
                        (dwRetLast == DET_OLDVERSIONINSTALLED) ||
                        (dwRetLast == DET_INSTALLED))
                    dwRetLast = dwRet;
                    break;
            }
        }

        // go to the next directory letter.
        while ((Detect_Files.cPath[i]) && (Detect_Files.cPath[i] != ','))
            i++;
        if (Detect_Files.cPath[i] == ',')
            i++;
    }
    return dwRetLast;
}

DWORD CheckFileEx(LPSTR szDir, DETECT_FILES Detect_Files)
{
    char    szFile[MAX_PATH];
    char    szRenameFile[MAX_PATH];
    DWORD   dwInstalledVer, dwInstalledBuild;
    DWORD   dwRet = DET_NOTINSTALLED;

    if (*szDir)
    {
        lstrcpy(szFile, szDir);
        AddPath(szFile, Detect_Files.szFilename);
        if (Detect_Files.dwMSVer == (DWORD)-1)
        {
            if (GetFileAttributes(szFile) != 0xFFFFFFFF)
                dwRet = DET_INSTALLED;
        }
        else
        {
            ReadFromWininitOrPFRO(szFile, szRenameFile);
            if (*szRenameFile != '\0')
                GetVersionFromFile(szRenameFile, &dwInstalledVer, &dwInstalledBuild, TRUE);
            else
                GetVersionFromFile(szFile, &dwInstalledVer, &dwInstalledBuild, TRUE);

            if (dwInstalledVer != 0)
                dwRet = CompareVersions(Detect_Files.dwMSVer, Detect_Files.dwLSVer, dwInstalledVer, dwInstalledBuild);
        }
    }
    return dwRet;
}

DWORD WINAPI DetectFile(DETECTION_STRUCT *pDet, LPSTR pszFilename)
{
    DWORD dwRet = DET_NOTINSTALLED;
    DWORD dwInstalledVer, dwInstalledBuild;
    char szFile[MAX_PATH];
    char szRenameFile[MAX_PATH];

    dwInstalledVer = (DWORD) -1;
    dwInstalledBuild = (DWORD) -1;
    GetSystemDirectory(szFile, sizeof(szFile));
    AddPath(szFile, pszFilename);
    ReadFromWininitOrPFRO(szFile, szRenameFile);
    if (*szRenameFile != '\0')
        GetVersionFromFile(szRenameFile, &dwInstalledVer, &dwInstalledBuild, TRUE);
    else
        GetVersionFromFile(szFile, &dwInstalledVer, &dwInstalledBuild, TRUE);

    if (dwInstalledVer != 0)
        dwRet = CompareVersions(pDet->dwAskVer, pDet->dwAskBuild, dwInstalledVer, dwInstalledBuild);

    if (pDet->pdwInstalledVer && pDet->pdwInstalledBuild)
    {
        *(pDet->pdwInstalledVer) = dwInstalledVer;
        *(pDet->pdwInstalledBuild) = dwInstalledBuild;
    }
    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\iedetect\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by iedetect.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\iernonce\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by iernonce.rc
//
#define IDS_RUNONCEEX_BAD_FUNCTIONNAME  100
#define IDS_RUNONCEEX_CANNOT_LOAD_DLL   101
#define IDS_RUNONCEEX_EXCEPTION         102
#define IDS_RUNONCEEX_BAD_SHELLEXEC_CMD 103
#define IDS_RUNONCEEX_CANNOT_FIND_FUNCTION 104
#define IDS_RUNONCEEX_EXE_EXCEPTION     105
#define IDS_RUNONCEEX_FIND_FUNC_FAILED  106
#define IDS_RUNONCEEX_LOAD_DEPEND_FAILED 107
#define IDS_RUNONCEEX_REGISTER_ERROR    108
#define IDS_RUNONCEEX_NOT_NT_ADMIN      109
#define IDS_RUNONCEEX_TITLE             110
#define IDS_RUNONCEEX_SERVICE_REQUIRES_REBOOT 111
#define IDI_SETUP                       132
#define IDD_RUNONCE                     1999
#define IDC_LIST2                       2009
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        114
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\iernonce\iernonce.h ===
#define OEMRESOURCE
#include <windows.h>
#include <windowsx.h>
#include <objidl.h>
#include <commctrl.h>
#include <comctrlp.h>
#include <regstr.h>
#include <shlobj.h>
#include <shellapi.h>
#include <advpub.h>


#define MAX_ENTRYNAME           256
#define WM_FINISHED             (WM_USER + 0x123)

// taken from \\trango\slmadd\src\shell\inc\shellp.h
#define ARRAYSIZE(a)            (sizeof(a)/sizeof(a[0]))

#define IsSpace(c)              ((c) == ' '  ||  (c) == '\t'  ||  (c) == '\r'  ||  (c) == '\n'  ||  (c) == '\v'  ||  (c) == '\f')
#define IsDigit(c)              ((c) >= '0'  &&  (c) <= '9')

// Callback proc stuff for RunOnceExProcess

typedef VOID (*RUNONCEEXPROCESSCALLBACK)
(
 int nCurrent,
 int nMax,
 LPSTR pszError
 );

//////////////////////////////////////////////////////////////////
//  TYPES:
//////////////////////////////////////////////////////////////////

typedef enum {
    RRA_DEFAULT = 0x0000,
    RRA_DELETE  = 0x0001,
    RRA_WAIT    = 0x0002,
} RRA_FLAGS;

typedef enum {
    RRAEX_NO_ERROR_DIALOGS      =   0x0008,
    RRAEX_ERRORFILE             =   0x0010,
    RRAEX_LOG_FILE              =   0x0020,
    RRAEX_NO_EXCEPTION_TRAPPING =   0x0040,
    RRAEX_NO_STATUS_DIALOG      =   0x0080,
    RRAEX_IGNORE_REG_FLAGS      =   0x0100,
    RRAEX_CHECK_NT_ADMIN        =   0x0200,
    RRAEX_SHOW_SOFTBOOT_UI      =   0x0400,
    RRAEX_QUIT_IF_REBOOT_NEEDED =   0x0800,
    RRAEX_BACKUP_SYSTEM_DAT     =   0x1000,
#if 0
    /****
    RRAEX_DELETE_SYSTEM_IE4     =   0x2000,
    ****/
#endif
#if 0
    /**** enable this when explorer.exe is fixed (bug #30866)
    RRAEX_CREATE_REGFILE        =   0x4000,
    ****/
#endif
} RRAEX_FLAGS;

typedef struct tagArgsInfo
{
    HKEY hkeyParent;
    LPCTSTR pszSubkey;
    DWORD dwFlags;
    HDPA hdpaSections;
    int iNumberOfSections;
} ARGSINFO;

enum eRunOnceExAction
{
    eRO_Unknown,                                // This indicates that we don't yet know the action
    eRO_Register,
    eRO_Unregister,
    eRO_Install,
    eRO_WinMainFunction,
    eRO_Exe
};


//////////////////////////////////////////////////////////////////
//  Class Definitions
//////////////////////////////////////////////////////////////////

/****************************************************\
    CLASS: RunOnceExEntry

    DESCRIPTION:
        This class will contain one command that needs
    to be executed.
\***************************************************/
class RunOnceExEntry
{
public:
    // Member Variables
    TCHAR               m_szRunOnceExEntryName[MAX_ENTRYNAME];
    TCHAR               m_szFileName[MAX_PATH];
    TCHAR               m_szFunctionName[MAX_ENTRYNAME];
    TCHAR               m_szCmdLineArgs[MAX_PATH];
    eRunOnceExAction    m_ROAction;

    // Member Functions
    RunOnceExEntry(LPTSTR lpszNewEntryName, LPTSTR lpszNewCmd, DWORD dwFlags);
    ~RunOnceExEntry();
    void                Process(HKEY hkeyParent, LPCTSTR szSubkey, LPCTSTR szSectionName, DWORD dwFlags);
};

/****************************************************\
    CLASS: RunOnceExSection

    DESCRIPTION:
        This class will contain one grouping of 
    commands that will need to be executed.
\***************************************************/
class RunOnceExSection
{
public:
    // Member Variables
    TCHAR               m_szRunOnceExSectionName[MAX_ENTRYNAME];
    TCHAR               m_szDisplayName[MAX_ENTRYNAME];
    HDPA                m_hEntryArray;
    int                 m_NumberOfEntries;

    // Member Functions
    RunOnceExSection(LPTSTR lpszNewSectionName, LPTSTR lpszNewDisplayName);
    ~RunOnceExSection();
    void                Process(HKEY hkeyParent, LPCTSTR szSubkey, DWORD dwFlags);
};


INT_PTR CALLBACK DlgProcRunOnceEx(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
void ProcessSections(HKEY hkeyParent, LPCTSTR pszSubkey, DWORD dwFlags, HDPA hdpaSections, int iNumberOfSections, HWND hWnd);

extern const TCHAR *g_c_szTitleRegValue;
extern TCHAR g_szTitleString[256];
extern BOOL g_bRunningOnNT;
extern HINSTANCE g_hinst;
extern HANDLE g_hHeap;
extern HANDLE g_hLogFile;

extern RUNONCEEXPROCESSCALLBACK g_pCallbackProc;

// internal functions defined in utils.cpp
void            AddPath(LPTSTR szPath, LPCTSTR szName);
BOOL            GetParentDir(LPTSTR szPath);
BOOL            RunningOnIE4();
DWORD           MsgWaitForMultipleObjectsLoop(HANDLE hEvent, DWORD dwTimeout);
void            LogOff(BOOL bRestart);
void            ReportError(DWORD dwFlags, UINT uiResourceNum, ...);
long            AtoL(const char *nptr);

#ifdef UNICODE
#define     LocalStrChr             LocalStrChrW
#define     LocalSHDeleteKey        LocalSHDeleteKeyW
#define     LocalSHDeleteValue      LocalSHDeleteValueW
#else
#define     LocalStrChr             LocalStrChrA
#define     LocalSHDeleteKey        LocalSHDeleteKeyA
#define     LocalSHDeleteValue      LocalSHDeleteValueA
#endif

// following copied from \\trango\slmadd\src\shell\shlwapi\path.c
STDAPI_(LPTSTR) LocalPathGetArgs(LPCTSTR pszPath);
STDAPI_(void) LocalPathUnquoteSpaces(LPTSTR lpsz);

// following copied from \\trango\slmadd\src\shell\shlwapi\strings.c
#ifdef UNICODE
LPWSTR FAR PASCAL LocalStrChrW(LPCWSTR lpStart, WORD wMatch);
__inline BOOL ChrCmpW_inline(WORD w1, WORD wMatch);
#else
LPSTR FAR PASCAL LocalStrChrA(LPCSTR lpStart, WORD wMatch);
__inline BOOL ChrCmpA_inline(WORD w1, WORD wMatch);
#endif

// following copied from \\trango\slmadd\src\shell\shlwapi\reg.c
#ifdef UNICODE
STDAPI_(DWORD) LocalSHDeleteKeyW(HKEY hkey, LPCWSTR pwszSubKey);
#else
STDAPI_(DWORD) LocalSHDeleteKeyA(HKEY hkey, LPCSTR pszSubKey);
#endif
DWORD DeleteKeyRecursively(HKEY hkey, LPCSTR pszSubKey);

#ifdef UNICODE
STDAPI_(DWORD) LocalSHDeleteValueW(HKEY hkey, LPCWSTR pwszSubKey, LPCWSTR pwszValue);
#endif
STDAPI_(DWORD) LocalSHDeleteValueA(HKEY hkey, LPCSTR pszSubKey, LPCSTR pszValue);

// related to logging
LPTSTR GetLogFileName(LPCTSTR pcszLogFileKeyName, LPTSTR pszLogFileName, DWORD dwSizeInChars);
VOID StartLogging(LPCTSTR pcszLogFileName, DWORD dwCreationFlags);
VOID WriteToLog(LPCTSTR pcszFormatString, ...);
VOID StopLogging();
VOID LogDateAndTime();
VOID LogFlags(DWORD dwFlags);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\iernonce\roexui.cpp ===
// **************************************************************************
//
// RunOnce.Cpp
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1992-1993
//  All rights reserved
//
//  RunOnce wrapper. This encapsulates all applications that would like
//  to run the first time we re-boot. It lists these apps for the user
//  and allows the user to launce the apps (like apple at ease).
//
//  5 June 1994 FelixA  Started
//  8 June  Felix   Defined registry strings and functionality.
//                  Got small buttons displayed, but not working.
//  9 June  Felix   Both big and small buttons. Nice UI.
//                  Got single click app launching.
//
// 23 June  Felix   Moving it to a Chicago make thingy not Dolphin
//
// *************************************************************************/
//
#include "iernonce.h"
#include "resource.h"


#define CXBORDER 3


// globals
HDC g_hdcMem = NULL;            // Run time can be set for big or small buttons.
int g_cxSmIcon = 0;             // Icon sizes.
SIZE g_SizeTextExt;             // Extent of text in buttons.
HFONT g_hfont = NULL;
HFONT g_hBoldFont = NULL;
HBRUSH g_hbrBkGnd = NULL;
ARGSINFO g_aiArgs;


// prototypes
BOOL CreateGlobals(HWND hwndCtl);
BOOL RunOnceFill(HWND hWndLB);
void ShrinkToFit(HWND hWnd, HWND hLb);
DWORD RunAppsInList(LPVOID lp);
LRESULT HandleLBMeasureItem(HWND hwndLB, MEASUREITEMSTRUCT *lpmi);
LRESULT HandleLBDrawItem(HWND hwndLB, DRAWITEMSTRUCT *lpdi);
void DestroyGlobals(void);


INT_PTR CALLBACK DlgProcRunOnceEx(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static HANDLE s_hThread = NULL;
    DWORD dwThread;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        g_aiArgs = *((ARGSINFO *) lParam);
        CreateGlobals(hWnd);
        SetWindowPos(hWnd, NULL, 32, 32, 0, 0, SWP_NOSIZE | SWP_NOZORDER);
        RunOnceFill(GetDlgItem(hWnd, IDC_LIST2));
        // Now calculate the size needed for the LB and resize LB and parent.
        ShrinkToFit(hWnd, GetDlgItem(hWnd, IDC_LIST2));
        if ((s_hThread = CreateThread(NULL, 0, RunAppsInList, (LPVOID) GetDlgItem(hWnd, IDC_LIST2), 0, &dwThread)) == NULL)
            PostMessage(hWnd, WM_FINISHED, 0, 0L);
        break;

    case WM_SETCURSOR:
        if (g_aiArgs.dwFlags & RRA_WAIT)
            SetCursor(LoadCursor(NULL, IDC_WAIT));
        return TRUE;

    case WM_MEASUREITEM:
        if (((MEASUREITEMSTRUCT *) lParam)->CtlType == ODT_LISTBOX)
            return HandleLBMeasureItem(hWnd, (MEASUREITEMSTRUCT *) lParam);
        else
            return FALSE;

    case WM_DRAWITEM:
        if (((DRAWITEMSTRUCT *) lParam)->CtlType == ODT_LISTBOX)
            return HandleLBDrawItem(hWnd, (DRAWITEMSTRUCT *) lParam);
        else
            return FALSE;

    case WM_CTLCOLORLISTBOX:
        SetTextColor((HDC) wParam, GetSysColor(COLOR_BTNTEXT));
        SetBkColor((HDC) wParam, GetSysColor(COLOR_BTNFACE));
        return (LRESULT) g_hbrBkGnd;

    case WM_FINISHED:
        if (s_hThread != NULL)
        {
            while (MsgWaitForMultipleObjects(1, &s_hThread, FALSE, INFINITE, QS_ALLINPUT) != WAIT_OBJECT_0)
            {
                MSG msg;

                while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
                {
                    TranslateMessage(&msg);
                    DispatchMessage(&msg);
                }
            }

            CloseHandle(s_hThread);
            s_hThread = NULL;
        }
        DestroyGlobals();
        EndDialog(hWnd, 0);
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

LPSTR MakeAnsiStrFromWide(LPWSTR pwsz)
{
    LPSTR psz;
    int i;

    // arg checking.
    //
    if (!pwsz)
        return NULL;

    // compute the length
    //
    i =  WideCharToMultiByte(CP_ACP, 0, pwsz, -1, NULL, 0, NULL, NULL);
    if (i <= 0) return NULL;

    psz = (LPSTR) CoTaskMemAlloc(i * sizeof(CHAR));

    if (!psz) return NULL;
    WideCharToMultiByte(CP_ACP, 0, pwsz, -1, psz, i, NULL, NULL);
    psz[i - 1] = 0;
    return psz;
}


BOOL CreateGlobals(HWND hwndCtl)
{

    LOGFONT lf;
    HDC hdc;
    HFONT hfontOld;

    g_cxSmIcon = GetSystemMetrics(SM_CXSMICON);
    g_hbrBkGnd = CreateSolidBrush(GetSysColor(COLOR_BTNFACE));

    if ((hfontOld = (HFONT) (WORD) SendMessage(hwndCtl, WM_GETFONT, 0, 0L)) != NULL)
    {
        if (GetObject(hfontOld, sizeof(LOGFONT), (LPSTR) &lf))
        {
            // The CreateFontIndirect calls in IESetup Wzd works correctly on
            // all platforms... and they convert the Font name to Ansi
            // Hence to solve the Thai NT/Thai Win9x problem, we also convert
            // the font name to Ansi before calling CreateFontIndirect.

            // #58923: Now the FaceName returned by GetObject is not UNICODE on all
            // platforms. On Win9x, it is Ansi and this screws up things when
            // we call MakeAnsiStrFromWide on it. Hence to avoid problems, check
            // if returned FaceName is Wide <asumming FaceName always has more
            // than 2 chars in it.>
            if (lf.lfFaceName[1] == '\0')
            {
                LPSTR pszAnsiName;

                pszAnsiName = MakeAnsiStrFromWide((unsigned short *)lf.lfFaceName);
                lstrcpy((char *)lf.lfFaceName, pszAnsiName);
                CoTaskMemFree((LPVOID)pszAnsiName);
            }

            lf.lfWeight = 400;
            g_hfont = CreateFontIndirect(&lf);

            lf.lfWeight = 700;
            g_hBoldFont = CreateFontIndirect(&lf);
        }
    }

    if (g_hfont)
    {
        TCHAR *szLotsaWs = TEXT("WWWWWWWWWW");

        // Calc sensible size for text in buttons.
        hdc = GetDC(NULL);
        hfontOld = (HFONT) SelectObject(hdc, g_hfont);
        GetTextExtentPoint(hdc, szLotsaWs, lstrlen(szLotsaWs), &g_SizeTextExt);
        SelectObject(hdc, hfontOld);
        ReleaseDC(NULL, hdc);

        return TRUE;
    }

    return FALSE;
}


//***************************************************************************
//
// RunOnceFill()
//   Fills the List box in the run-once dlg.
//
// ENTRY:
//  HWND of the thing to fill.
//
// EXIT:
//  <Params>
//
//***************************************************************************
BOOL RunOnceFill(HWND hWndLB)
{
    RunOnceExSection *pCurrentRunOnceExSection;
    int iSectionIndex;

    // if Title value is present, display it
    if (*g_szTitleString)
        SetWindowText(GetParent(hWndLB), g_szTitleString);

    for (iSectionIndex = 0;  iSectionIndex < g_aiArgs.iNumberOfSections;  iSectionIndex++)
    {
        pCurrentRunOnceExSection = (RunOnceExSection *) DPA_GetPtr(g_aiArgs.hdpaSections, iSectionIndex);

        if (*pCurrentRunOnceExSection->m_szDisplayName != TEXT('\0'))
            SendMessage(hWndLB, LB_ADDSTRING, 0, (LPARAM) pCurrentRunOnceExSection->m_szDisplayName);
    }

    return TRUE;
}


//***************************************************************************
//
// ShrinkToFit()
//     Makes the List box no bigger then it has to be
//     makes the parent window rsize to the LB size.
//
// ENTRY:
//     hwnd Parent
//     hwnd List box
//
// EXIT:
//
//***************************************************************************
void ShrinkToFit(HWND hWnd, HWND hLb)
{
    LONG lCount;
    LONG lNumItems;
    LONG lTotalHeight;
    LONG lHeight;
    RECT rWnd;
    LONG lChange;

    lTotalHeight = 0;
    lNumItems = (LONG)SendMessage(hLb, LB_GETCOUNT, 0, 0L);

    for (lCount = 0;  lCount < lNumItems;  lCount++)
    {
         lHeight = (LONG)SendMessage(hLb, LB_GETITEMHEIGHT, lCount, 0L);
         lTotalHeight += lHeight;
    }

    // Set the height of the ListBox to the number of items in it.
    GetWindowRect(hLb, &rWnd);
    SetWindowPos(hLb, hWnd, 0, 0, rWnd.right - rWnd.left - (CXBORDER * 2 + g_cxSmIcon), lTotalHeight, SWP_NOMOVE | SWP_SHOWWINDOW | SWP_NOZORDER);

    // Work out how much it changed in height
    lChange = lTotalHeight - (rWnd.bottom - rWnd.top);

    // Size the parent to fit around the child.
    GetWindowRect(hWnd, &rWnd);
    SetWindowPos(hWnd, 0, 0, 0, rWnd.right - rWnd.left, rWnd.bottom - rWnd.top + lChange, SWP_NOMOVE | SWP_SHOWWINDOW | SWP_NOZORDER);
}


//***************************************************************************
//
// RunAppsInList()
// Enumerates all the items in the list box, spawning each in turn.
//
// ENTRY:
//  HWND of Parent.
//
// EXIT:
//  <Params>
//
//***************************************************************************
DWORD RunAppsInList(LPVOID lp)
{
    ProcessSections(g_aiArgs.hkeyParent, g_aiArgs.pszSubkey, g_aiArgs.dwFlags, g_aiArgs.hdpaSections, g_aiArgs.iNumberOfSections, (HWND) lp);

    // terminate the dialog box
    PostMessage(GetParent((HWND) lp), WM_FINISHED, 0, 0L);

    return 0;
}


LRESULT HandleLBMeasureItem(HWND hDlg, MEASUREITEMSTRUCT *lpmi)
{
    RECT    rWnd;
    int     wWnd;
    HDC     hDC;
    HFONT   hfontOld;
    TCHAR   szText[MAX_ENTRYNAME];

    // Get the Height and Width of the child window
    GetWindowRect(hDlg, &rWnd);
    wWnd = rWnd.right - rWnd.left;

    lpmi->itemWidth = wWnd;

    hDC = GetDC(NULL);

    if ((hfontOld = (HFONT) SelectObject(hDC, g_hBoldFont)) != 0)
    {
        rWnd.top    = 0;
        rWnd.left   = CXBORDER * 2 + g_cxSmIcon;
        rWnd.right  = lpmi->itemWidth - rWnd.left - CXBORDER * 2 - g_cxSmIcon;
        rWnd.bottom = 0;

        *szText = TEXT('\0');
        SendMessage(GetDlgItem(hDlg, IDC_LIST2), LB_GETTEXT, (WPARAM) lpmi->itemID, (LPARAM) szText);
        DrawText(hDC, szText, lstrlen(szText), &rWnd, DT_CALCRECT | DT_WORDBREAK);

        SelectObject(hDC, hfontOld);
    }

    ReleaseDC(NULL, hDC);

    lpmi->itemHeight = rWnd.bottom + CXBORDER * 2;

    return TRUE;
}


//***************************************************************************
//
// HandleLBDrawItem()
//  Draws the Title, Text, and icon for an entry.
//
// ENTRY:
//  HWND and the Item to draw.
//
// EXIT:
//  <Params>
//
//***************************************************************************
LRESULT HandleLBDrawItem(HWND hDlg, DRAWITEMSTRUCT *lpdi)
{
    RECT rc;
    HFONT hfontOld;
    int xArrow,y;
    BITMAP bm;
    HGDIOBJ hbmArrow, hbmOld;
    TCHAR   szText[MAX_ENTRYNAME];

    // Don't draw anything for an empty list.
    if ((int) lpdi->itemID < 0)
        return TRUE;

    if ((lpdi->itemAction & ODA_SELECT) || (lpdi->itemAction & ODA_DRAWENTIRE))
    {
        // Put in the Title text
        hfontOld  = (HFONT) SelectObject(lpdi->hDC, (lpdi->itemState & ODS_SELECTED) ? g_hBoldFont : g_hfont);

        ExtTextOut(lpdi->hDC, lpdi->rcItem.left + CXBORDER * 2 + g_cxSmIcon, lpdi->rcItem.top + CXBORDER,
                   ETO_OPAQUE, &lpdi->rcItem, NULL, 0, NULL);

        rc.top    = lpdi->rcItem.top    + CXBORDER;
        rc.left   = lpdi->rcItem.left   + CXBORDER * 2 + g_cxSmIcon;
        rc.right  = lpdi->rcItem.right;
        rc.bottom = lpdi->rcItem.bottom;

        *szText = TEXT('\0');
        SendMessage(GetDlgItem(hDlg, IDC_LIST2), LB_GETTEXT, (WPARAM) lpdi->itemID, (LPARAM) szText);
        DrawText(lpdi->hDC, szText, lstrlen(szText), &rc, DT_WORDBREAK);

        SelectObject(lpdi->hDC, hfontOld);

        // Draw the little triangle thingies.
        if (lpdi->itemState & ODS_SELECTED)
        {
            if (!g_hdcMem)
            {
                g_hdcMem = CreateCompatibleDC(lpdi->hDC);
            }

            if (g_hdcMem)
            {
                hbmArrow = LoadBitmap(NULL, MAKEINTRESOURCE(OBM_MNARROW));
                GetObject(hbmArrow, sizeof(bm), &bm);

                hbmOld = SelectObject(g_hdcMem, hbmArrow);

                xArrow = lpdi->rcItem.left + CXBORDER;
                y = ((g_SizeTextExt.cy - bm.bmHeight) / 2) + CXBORDER + lpdi->rcItem.top;
                BitBlt(lpdi->hDC, xArrow, y, bm.bmWidth, bm.bmHeight, g_hdcMem, 0, 0, SRCAND);

                SelectObject(g_hdcMem, hbmOld);

                DeleteObject(hbmArrow);
            }
        }
    }

    return TRUE;
}


void DestroyGlobals(void)
{
    if (g_hfont)
    {
        DeleteObject(g_hfont);
        g_hfont = NULL;
    }

    if (g_hBoldFont)
    {
        DeleteObject(g_hBoldFont);
        g_hBoldFont = NULL;
    }

    if (g_hbrBkGnd)
    {
        DeleteObject(g_hbrBkGnd);
        g_hbrBkGnd = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\iernonce\iernonce.cpp ===
/************************************************************\
    FILE: iernonce.cpp

    CREATED: October 16, 1996

  HISTORY:
        Initial version from BryanSt.
        Modified extensively for UI, root dependencies, bug fixes, etc. by PritObla.

    COPYRIGHT:
        Copyright (c) 1996 Microsoft Coporation.


    DEFINITIONS:
        SECTION - The old RunOnce API is in a flat section.  The RunOnceEx
            API groups entries into sections for managability.  If the
            Status dialog is displayed, it will display each section
            name while it's being processed.  Example sections for
            Internet Explorer would be: ActiveX, Java, Internet Explorer.
        ENTRY   - Entries are listed in a section.  These are commands
            that need to be carried out.  The commands can be a string
            to execute, a DLL to register (regsvr32), a DLL to unregister (regsvr32 -u),
            or to call a function in a DLL that has WinMain parameters (rundll32).

    DESCRIPTION:
    1.0 Goal
        Currently the "Run" and "RunOnce" feature in Explorer.exe will shell
        execute commands when the shell starts up.  Several features are
        needed for this to be more robust for Internet Explorer 4.0.

        The replacements are RunEx for Run and RunOnceEx for RunOnce.  The
        main features are:
         Status - A dialog will be displayed while the items are being
          processed.  Internet Explorer 4.0 adds at least 30 items which
          take more than a minute on 486 machines.  The entries to be
          processed will be grouped into sections and the dialog will
          highlight the current section being processed.  The status dialog
          feature can be turned off by using a flag.
         Performance - The majority of the Run and RunOnce commands are
          calls to regsvr32.exe and runonce32.exe.  These create separate
          processes which is very inefficient.  This API will not create
          separate processes for DLLs that need to be called in the same way
          that regsvr32.exe or rundll32.exe calls DLLs.  This API also supports
          a dependency list of DLLs that should remain loaded while either all
          the sections or some of the sections are being processed.
         Error Handling - If an exception occurs while calling a function in
          a DLL, the exception will be caught and error dialog will be
          displayed to the user.  This error dialog can be suppressed using a
          flag in the API, but this is recommended only for cases where a
          debug is installed because it will crash explorer.exe.  If a flag is
          set, an error and/or logging file can be generated in %WinDir% for
          debugging purposes.
         Deterministic - Currently the order that the entries are processed
          is not deterministic.  This new API will sort the entries and
          sections alphabetically to force a deterministic order.  The current
          API will not wait until one entry is finished before starting the
          next entry, except for RunOnce items in Local_Machine.  In order to
          be deterministic, this API will process command synchronously unless
          a flag is set to turned off this functionality.
         Export Functionality - This API will be added to shell32.dll and
          called from explorer.exe.  API functions will be exported so other
          applications can use this functionality if needed.

    2.0 Registry Structure
    2.1 RegistryFormat
        Text in italics are strings generated by the user.

        [Local_Machine] or [Current_User]
        SOFTWARE\Microsoft\Windows\CurrentVersion\RunEx (same as RunOnceEx below)
        SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnceEx
            Flags = [DWORD] 0x0000000
            Title = [STR] "Status Dialog Title"  (Example, "Installing Internet Explorer 4.0")
            Depend\
                <PlaceHolder1> = [STR] "<DLL/OCX Filename>" (filename with or without the path)
                <PlaceHolder...> = [STR] "<DLL/OCX Filename>" (filename with or without the path)
            <SectionPlaceHolder1>\
                @="SectionName1"
                <Entry1> = [STR] "<EntryFormat>" (See Entry Format description below)
                <Entry...> = [STR] "<EntryFormat >"
            Depend\
                <PlaceHolder1> = [STR] "<DLL/OCX Filename>"
                <PlaceHolder...> = [STR] "<DLL/OCX Filename>"
            < SectionPlaceHolder2>\

    2.1.1 Flags
        // Old RunOnce Flags
        #define    RRA_DEFAULT          0x0000
        #define    RRA_DELETE               0x0001
        #define    RRA_WAIT             0x0002
        #define    RRA_SHELLSERVICEOBJECTS  0x0004

        // New RunOnceEx Flags
        #define    RRAEX_NO_ERROR_DIALOGS   0x0008
        #define    RRAEX_ERRORFILE          0x0010
        #define    RRAEX_LOG_FILE           0x0020
        #define    RRAEX_NO_EXCEPTION_TRAPPING  0x0040
        #define    RRAEX_NO_STATUS_DIALOG       0x0080
        #define    RRAEX_IGNORE_REG_FLAGS       0x0100


        RRA_DEFAULT - All features are off but can be turned on by the flags
            in the Flags registry key.
        RRA_DELETE - Delete the registry entries after processing them.
            Normally used for RunOnceEx and not used for RunEx.
        RRA_WAIT - If the entry is a command to be executed, this flag causes
            the items to be processed synchronously.
        RRA_SHELLSERVICEOBJECTS - If this flag is set, we load inproc dlls
            from the registry key and QI them for IOleCommandTarget.
            CGID_ShellServiceObject notifications are sent to these objects
            letting them know about shell status.
        RRAEX_NO_STATUS_DIALOG - Use this flag to cause the Status dialog to
            not be displayed while processing the entries.
        RRAEX_ NO_ERROR_DIALOGS - This flag will turn off error dialogs from
            being displayed.
        RRAEX_ERRORFILE - This flag will cause the file "C:\Windows\RunOnceEx.err"
            to be created if errors occur.
        RRAEX_LOG_FILE - This flag will cause the file "C:\Windows\RunOnceEx.log"
            to be created giving the status of commands being executed.  (For debugging)
        RRAEX_ NO_EXCEPTION_TRAPPING - If this flag is set, exceptions will
            not be caught when registering DLLs.  This should only be used when a
            debug is setup or buggy DLLs will cause explorer.exe to crash.
        RRAEX_IGNORE_REG_FLAGS - If this flag is set, then the Flags registry
            entry will be ignored.

        The Flags registry key will be deleted if the RRAEX_DELETE flag was
        set.

    2.1.2 Title
        The Status Dialogs title will be set to Title registry key if it
        exists.  This key will be deleted if the RRAEX_DELETE flag was set.
    2.1.3 Top Level Depend Entries
        Each entry under the Depend branch will be read.  These registry
        entries need to be type STR and the data needs to be a valid filename
        with or without a path.  The registry value will be ignored.
        LoadLibrary() will be called on each entry and they will remain loaded
        until all the sections have been processed.  This key will be deleted
        if the RRA_DELETE flag was set.

        Example:
        SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnceEx\Depend
            "Should stay loaded" = [STR] "shell32.dll"
    2.1.4 Sections
        Each non-"Depend" keys under RunEx and RunOnceEx is considered a
        section.  The names of the Sections are read into memory, sorted
        alphabetically.  The key name is displayed in the Status Dialog if
        the key doesnt have data to specify the Display Name.  The sections
        will be processed in alphabetic order.  The Sections branch in the
        registry will be deleted after being processed if the RRAEX_DELETE
        flag was set.

        Each Section will contain "entries" which are string registry keys.
        The registry entry value is only used to sort the entries.  The
        registry entry data will be in the format specified in 2.2 Entry
        Format.

        Example:
        SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnceEx\IE4 03 Java
            @="Java"
            "IE4 01 Java" = [STR] "||my.exe -quiet -url http://www.microsft.com/"
            "IE4 02 Main Java File" = [STR] "msjava.dll|DllRegisterServer"

        If the Section has a Display Name, then the key name should contain
        an abbreviation of the product followed by a number that specifies
        the order that this section should be processed in.  Because the
        section names are sorted alphabetically, this will make sure that
        all entries for one product are processed together and that the number
        makes the order obvious.

        An Example:
        SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnceEx\IE4 03 Java
            @="Java"
        SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnceEx\IE4 04 Scripting
            @="ActiveX Scripting"

    2.1.4.1 Section Dependencies
        The list off DLLs in the sections Depend key are loaded before a
        sections entries are executed and then unloaded after they have
        been executed.  This key will be deleted if the RRA_DELETE flag was
        set.

        Example:
        SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnceEx\Java
            "IE4 01 Java" = [STR] "||my.exe -quiet -url http://www.microsft.com/"
            "IE4 02 Java" = [STR] "shdocvw.dll|DllRegisterServer"
        SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnceEx\Java\Depend
            "Keep Loaded" = [STR] "urlmon.dll"

    2.2 Entry Format
        "<DllFileName>|<FunctionName>|<CmdLineArgs>"

        The Entry Format will fall into one of three categories,
        1) Shell Execute (same as old RunOnce method),
        2) Call DllRegisterServer or DllUnregisterServer in the
        specified DLL (same as regsvr32.exe), and 3) Call a function
        in the specified DLL with WinMain parameters (same as rundll32.exe)
        and the <CmdLineArgs> will be passed in the CmdLine parameter.
         Register DLL - The <DllFileName> is required to be non-empty.  The
          <FunctionName> sections must equal "DllRegisterServer" or
          "DllUnregisterServer".  The <CmdLineArgs> must be empty and there
          must not be a semicolon after <FunctionName>.
          Example: "shdocvw.dll|DllRegisterServer".
         Calling a Function - The <DllFileName> and <FunctionName> sections
          are required to be non-empty. The <CmdLineArgs> can be empty and there
          must be a semicolon after <FunctionName>.
          Example: "C:\winnt\system32\my.dll|MyWinMain|-Start".
         Shell Execute - The <DllFileName> and <FunctionName> sections are
          required to be empty.  The <DllFileName> string will be executed in
          same way the old RunOnce items where executed.
          Example: "||iexplore.exe http://www.microsoft.com/".

    3.0 Function Calls
        void ProcessRunOnceEx(DWORD dwFlags);
        This function will call RunRegAppsAndObjectsEx() with the RunEx and
        RunOnceEx registry keys in both Local_Machine and Current_User
        sections of the registry with the Flags passed in. RRA_WAIT will be
        passed because its on be default. RRA_DELETE will be passed for
        RunOnceEx.

        void RunRegAppsAndObjectsEx(HKEY hkeyParent, LPCTSTR szSubkey, DWORD dwFlags);
        This function will process the entries in this section of the registry.
        The szSubKey cannot point to a section of the registry that has the
        old Run or RunOnce format.


\************************************************************/

/*Includes---------------------------------------------------------*/

#include "iernonce.h"
#include "resource.h"

#ifdef WX86
#include <wx86ofl.h>
#endif // WX86

//////////////////////////////////////////////////////////////////
//  Constants:
//////////////////////////////////////////////////////////////////
#define MAX_REG_PATH            256             // Registry paths should not get much longer than this or there is a major perf hit
#define MAX_REG_VALUE           80              // Registry values should not get much longer than this or there is a major perf hit
#define ARRAY_GROW_RATE         32              // This should be large enough to cover most applications
#define SEPERATOR_CHAR          TEXT('|')

//////////////////////////////////////////////////////////////////
//  TYPES:
//////////////////////////////////////////////////////////////////

typedef enum
{
    eHDL_Load,
    eHDL_Unload
} HDL_Type;

typedef int (*WINMAIN_PARAMS)(HINSTANCE, HINSTANCE, LPSTR, int);
typedef LONG (*DLLREGISTERSERVER_PARAMS)();
typedef HRESULT (*DLLINSTALL_PARAMS)(BOOL bInstall, LPCWSTR pszCmdLine);


//////////////////////////////////////////////////////////////////
//  GLOBALS:
//////////////////////////////////////////////////////////////////

const TCHAR   * c_szDependencyName          = TEXT("Depend");
const TCHAR   * c_szFlagsRegValue           = TEXT("Flags");
const TCHAR   * g_c_szTitleRegValue         = TEXT("Title");
const TCHAR   * g_c_szSystemDat             = TEXT("system.dat");
const TCHAR   * g_c_szSystem1st             = TEXT("system.1st");
const TCHAR   * g_c_szSetupKey              = TEXT("Software\\Microsoft\\IE Setup\\Setup");
const TCHAR   * g_c_szRegBackupPath         = TEXT("RegistryBackup");
const TCHAR   * g_c_szServicesRegValue      = TEXT("Services");


HINSTANCE       g_hinst                     = NULL;
HANDLE          g_hHeap                     = NULL;

RUNONCEEXPROCESSCALLBACK g_pCallbackProc    = NULL;
BOOL                     g_bQuiet           = FALSE;
int                      g_nTotal           = 0;
int                      g_nCurrent         = 0;

BOOL            g_bRunningOnNT              = FALSE;
BOOL            g_bBackupSystemDat          = FALSE;
#if 0
BOOL            g_bDeleteSystemIE4          = FALSE;
#endif
int             g_iNDisplaySections         = 0;
TCHAR           g_szTitleString[256]        = TEXT("");

// related to logging
HANDLE          g_hLogFile                  = INVALID_HANDLE_VALUE;

#ifdef WX86
//  If Wx86 has to be loaded we use this flag to make sure it is unloaded
//  at the end of RunOnceExProcess.
BOOL            g_fWx86Loaded               = FALSE;
#endif

//////////////////////////////////////////////////////////////////
//  Internal Functions
//////////////////////////////////////////////////////////////////
void    WINAPI  RunOnceExProcess(HWND hWnd, HINSTANCE hInstance, LPSTR lpCmdLine, int nCmdShow);
void            RunOnceExProcessReg(HKEY hkeyParent, LPCTSTR pszSubkey, DWORD dwFlags);
HDPA            GetSections(HKEY hkeyParent, LPCTSTR szSubkey, DWORD dwFlags, int * pNumberOfSections);
HDPA            GetEntries(HKEY hRootKey, LPCTSTR szSectionName, DWORD dwFlags, int * pNumberOfEntries);
void            HandleDependencyDLLs(HKEY hkeyParent, LPCTSTR szRegPath, LPCTSTR szRegSubPath, DWORD dwFlags, HDL_Type hdlDirection);
DWORD           GetFlagsInRegistry(HKEY hkeyParent, LPCTSTR szSubkey);
void            ShellExecuteRegApp(LPTSTR pszCmdLine, DWORD dwFlags);
BOOL            HaveDependServices(SC_HANDLE hService);
void            CheckServices(DWORD dwFlags);

BOOL WINAPI DllMain(HINSTANCE hDLLInst, DWORD fdwReason, LPVOID lpvReserved)
{
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        OSVERSIONINFO osvi;

        DisableThreadLibraryCalls(hDLLInst);

        // The DLL is being loaded for the first time by a given process.
        // Perform per-process initialization here.  If the initialization
        // is successful, return TRUE; if unsuccessful, return FALSE.

        // Initialize the global variable holding the hinstance:
        g_hinst = hDLLInst;
        g_hHeap = GetProcessHeap();

        osvi.dwOSVersionInfoSize = sizeof(osvi);
        GetVersionEx(&osvi);
        if (VER_PLATFORM_WIN32_NT == osvi.dwPlatformId)
            g_bRunningOnNT = TRUE;
    }
    return TRUE;
}

#ifdef WX86

/****************************************************\
    FUNCTION: RunOnceLoadLibrary

    PARAMETERS:
        LPCTSTR lpszFileName - DLL to load

        BOOL* pfWx86DLL - Ptr to a BOOL that we set to
            TRUE if the DLL is x86.            

    DESCRIPTION:
        This function will is a wrapper for LoadLibraryEx()
        that will also load x86 DLLs on RISC.
\***************************************************/

HINSTANCE RunOnceLoadLibrary( LPCTSTR lpszFileName, BOOL* pfWx86DLL )
{
    HINSTANCE hInstance = LoadLibraryEx(lpszFileName, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);
    if ( (hInstance == NULL) && (GetLastError() == ERROR_BAD_EXE_FORMAT) )
    {
        WCHAR achDllToLoad[ MAX_PATH ];
#ifdef UNICODE
        lstrcpy(achDllToLoad, lpszFileName);
#else // UNICODE
        MultiByteToWideChar(CP_ACP, 0, lpszFileName, -1,
                            achDllToLoad, ARRAYSIZE(achDllToLoad));
#endif // UNICODE
        if ( !g_fWx86Loaded )
        {
            g_fWx86Loaded = Wx86Load();
        }

        if ( g_fWx86Loaded )
        {
            hInstance = Wx86LoadX86Dll(achDllToLoad, LOAD_WITH_ALTERED_SEARCH_PATH);
            if ( hInstance != NULL )
            {
                *pfWx86DLL = TRUE;
            }
        }
    }
    return hInstance;
}

#else // WX86

//  If we're on x86 then a simple macro works...
#define RunOnceLoadLibrary(_arg1, _arg2) LoadLibraryEx(_arg1, NULL, LOAD_WITH_ALTERED_SEARCH_PATH)

#endif // WX86

void BackupRegistry()
{
   HKEY hkSetup = NULL;
   DWORD unused;
   TCHAR szSystemDatPath[MAX_PATH]         = TEXT("");
   TCHAR szSystemIE4Path[MAX_PATH]         = TEXT("");

   // flush the registry and copy system.dat to system.ie4;
   // this is for the PSS folks; if the registry gets corrupt after IE4 has been installed, user can copy system.ie4 to system.dat
   // quite an expensive operation!
   RegFlushKey(HKEY_CLASSES_ROOT);
   RegFlushKey(HKEY_CURRENT_USER);
   RegFlushKey(HKEY_LOCAL_MACHINE);
   RegFlushKey(HKEY_USERS);

   GetWindowsDirectory(szSystemDatPath, ARRAYSIZE(szSystemDatPath));
   if(RegCreateKeyEx(HKEY_LOCAL_MACHINE, g_c_szSetupKey, 0, NULL,
                     REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE,
                     NULL, &hkSetup, &unused) == ERROR_SUCCESS)
   {
      unused = sizeof(szSystemIE4Path);
      RegQueryValueEx(hkSetup, g_c_szRegBackupPath, 0, NULL, (BYTE *)szSystemIE4Path, &unused);
   }
   // if we don't have a path yet default to root of windows drive
   if(szSystemIE4Path[0] == TEXT('\0'))
   {
      lstrcpy(szSystemIE4Path, szSystemDatPath);
      GetParentDir(szSystemIE4Path);
      AddPath(szSystemIE4Path, g_c_szSystem1st);
   }

   AddPath(szSystemDatPath, g_c_szSystemDat);

   SetFileAttributes(szSystemDatPath, FILE_ATTRIBUTE_NORMAL);
   SetFileAttributes(szSystemIE4Path, FILE_ATTRIBUTE_NORMAL);

   if(CopyFile(szSystemDatPath, szSystemIE4Path, FALSE))
   {
      // Record where we put it in the registry
      if(hkSetup)
         RegSetValueEx(hkSetup, g_c_szRegBackupPath, 0, REG_SZ,
                       (BYTE *)szSystemIE4Path, sizeof(TCHAR) * (lstrlen(szSystemIE4Path) + 1));

      // Write something to the active setup log


   }

   if(hkSetup)
      RegCloseKey(hkSetup);

   SetFileAttributes(szSystemDatPath, FILE_ATTRIBUTE_ARCHIVE | FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM);
   SetFileAttributes(szSystemIE4Path, FILE_ATTRIBUTE_ARCHIVE | FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM);
}

VOID InitCallback(RUNONCEEXPROCESSCALLBACK pCallbackProc, BOOL bQuiet)
{
    g_pCallbackProc = pCallbackProc;
    g_bQuiet = bQuiet;
}

/****************************************************\
    FUNCTION: RunOnceExProcess

    PARAMETERS:
        DWORD dwFlags - Caller can specify behavior
                with flags.

    DESCRIPTION:
        This function will run the RunEx API.  It will
    process RunOnceEx and RunEx in both Current_User
    and Local_Machine
\***************************************************/
void WINAPI RunOnceExProcess(HWND hWnd, HINSTANCE hInstance, LPSTR lpCmdLine, int nCmdShow)
{
    const TCHAR    * szRunOnceExPath            = REGSTR_PATH_RUNONCEEX;
    //const TCHAR    * szRunExPath                = TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunEx");
    DWORD           dwFlags                     = RRA_DEFAULT;

    if (lpCmdLine != NULL)
        dwFlags |= AtoL(lpCmdLine);

    if (g_bQuiet)
        dwFlags |= RRAEX_NO_STATUS_DIALOG | RRAEX_NO_ERROR_DIALOGS;

    RunOnceExProcessReg(HKEY_LOCAL_MACHINE, szRunOnceExPath, dwFlags | RRA_DELETE | RRA_WAIT);
    RunOnceExProcessReg(HKEY_CURRENT_USER, szRunOnceExPath, dwFlags | RRA_DELETE | RRA_WAIT);

#ifdef WX86
    if ( g_fWx86Loaded )
    {
        Wx86Unload();
    }
#endif

    //RunOnceExProcessReg(HKEY_LOCAL_MACHINE, szRunExPath, dwFlags);
    //RunOnceExProcessReg(HKEY_CURRENT_USER, szRunExPath, dwFlags);

    if (!g_bRunningOnNT  &&  g_bBackupSystemDat)
    {
        BackupRegistry();
    }
    if (g_bRunningOnNT)
    {
        CheckServices(dwFlags);
    }
}


/****************************************************\
    FUNCTION: RunOnceExProcessReg

    PARAMETERS:
        HKEY hkeyParent - Registry Branch to process.
        LPCTSTR pszSubkey - Registry Path to process.
        DWORD dwFlags - Registry Entry to modify.

    DESCRIPTION:
        This function will run the API on one part of
    the registry.
\***************************************************/
void RunOnceExProcessReg(HKEY hkeyParent, LPCTSTR pszSubkey, DWORD dwFlags)
{
    HDPA                hdpaSections            = NULL;
    HKEY                hRunExKey               = NULL;
    RunOnceExSection    * pCurrentSection       = NULL;
    int                 iNumberOfSections       = 0;
    int                 iIndex;
    ARGSINFO            aiArgs;
    static DWORD        dwCreationFlags         = CREATE_ALWAYS;    // first time the log file is opened, the contents should be truncated
    static TCHAR        szLogFileName[MAX_PATH] = TEXT("");

    if (!(RRAEX_IGNORE_REG_FLAGS & dwFlags))
        dwFlags |= GetFlagsInRegistry(hkeyParent, pszSubkey);

    *g_szTitleString = TEXT('\0');
    if (RegOpenKeyEx(hkeyParent, pszSubkey, NULL, KEY_READ, &hRunExKey) == ERROR_SUCCESS)
    {
        DWORD dwTitleSize = sizeof(g_szTitleString);

        // if a value for Title is specified, read it in
        RegQueryValueEx(hRunExKey, g_c_szTitleRegValue, NULL, NULL, (LPBYTE) g_szTitleString, &dwTitleSize);
        RegCloseKey(hRunExKey);
    }

    // don't process if there are entries in wininit.ini or PendingFileRenameOperations
    if ((dwFlags & RRAEX_QUIT_IF_REBOOT_NEEDED)  &&  NeedReboot(0))
        return;

    if (g_bRunningOnNT  &&  (dwFlags & RRAEX_CHECK_NT_ADMIN)  &&  !IsNTAdmin(0, NULL))
    {
        // user has no NT Admin privileges; we cannot process the RunOnceEx items

        // make sure that the msg box is displayed
        ReportError((dwFlags & ~RRAEX_NO_ERROR_DIALOGS), IDS_RUNONCEEX_NOT_NT_ADMIN);
        LogOff(FALSE);

        // won't reach here
        return;
    }

    if (dwFlags & RRAEX_BACKUP_SYSTEM_DAT)
        g_bBackupSystemDat = TRUE;

    if (dwFlags & RRAEX_LOG_FILE)
    {
        if (*szLogFileName == TEXT('\0'))
            GetLogFileName(TEXT("RunOnceExLogFile"), szLogFileName, ARRAYSIZE(szLogFileName));

        if (*szLogFileName)
        {
            if (hkeyParent == HKEY_LOCAL_MACHINE)
            {
                TCHAR szBuf[MAX_PATH + MAX_REG_PATH + 16];

                // dump the registry entries before we process them so that if some error occurs,
                // it is easy to cut and paste the entries to a reg file and import it.
                wsprintf(szBuf, TEXT("regedit /e \"%s\" HKEY_LOCAL_MACHINE\\%s"), szLogFileName, pszSubkey);
                ShellExecuteRegApp(szBuf, RRA_WAIT);
                dwCreationFlags = OPEN_ALWAYS;      // from now on, the log file should be opened in append mode
            }

            StartLogging(szLogFileName, dwCreationFlags);
            dwCreationFlags = OPEN_ALWAYS;      // from now on, the log file should be opened in append mode
        }
    }

    // Log that we are starting to process these commands.
    WriteToLog(TEXT("[%1:%2]\r\n"), (HKEY_LOCAL_MACHINE == hkeyParent) ? TEXT("HKLM"):TEXT("HKCU"), pszSubkey);
    LogFlags(dwFlags);

    g_iNDisplaySections = 0;
    hdpaSections = GetSections(hkeyParent, pszSubkey, dwFlags, &iNumberOfSections);

    // Load the dependency DLLs that are common to all sections
    HandleDependencyDLLs(hkeyParent, pszSubkey, "", dwFlags, eHDL_Load);

    if (iNumberOfSections)          // call ProcessSections only if there is atleast one section to process
    {
        // show UI if the NO_STATUS_DIALOG flag is NOT specified, and
        // there is atleast one section that has display text
        if (0 == (RRAEX_NO_STATUS_DIALOG & dwFlags)  &&  g_iNDisplaySections)
        {
            // pack the args of ProcessSections into aiArgs
            aiArgs.hkeyParent = hkeyParent;
            aiArgs.pszSubkey = pszSubkey;
            aiArgs.dwFlags = dwFlags;
            aiArgs.hdpaSections = hdpaSections;
            aiArgs.iNumberOfSections = iNumberOfSections;

            DialogBoxParam(g_hinst, MAKEINTRESOURCE(IDD_RUNONCE), NULL, DlgProcRunOnceEx, (LPARAM) &aiArgs);
        }
        else
            ProcessSections(hkeyParent, pszSubkey, dwFlags, hdpaSections, iNumberOfSections, NULL);
    }

    // Unload the dependency DLLs that are common to all sections
    HandleDependencyDLLs(hkeyParent, pszSubkey, "", dwFlags, eHDL_Unload);

    // We iterate twice.  Once to process all the entries, and the second time to delete
    // the entries.  We do this because some code (like Dialog Status drawing) might want
    // to access previously processed entries.
    for (iIndex = 0; iIndex < iNumberOfSections; iIndex++)
    {
        pCurrentSection = (RunOnceExSection *) DPA_GetPtr(hdpaSections, iIndex);
        if (pCurrentSection)
        {
            delete pCurrentSection;
        }
    }

    if (hdpaSections)
    {
        DPA_Destroy(hdpaSections);
        hdpaSections = NULL;
    }

    // Delete the Flags and Title registry entry if the Delete flag is set.
    if (RRA_DELETE & dwFlags)
    {
        if (ERROR_SUCCESS == RegOpenKeyEx(hkeyParent, pszSubkey, NULL, KEY_READ | KEY_WRITE, &hRunExKey))
        {
            // Delete this key if the Delete key is set anywhere.
            RegDeleteValue(hRunExKey, c_szFlagsRegValue);
            RegDeleteValue(hRunExKey, g_c_szTitleRegValue);
            RegCloseKey(hRunExKey);
        }
    }

    WriteToLog(TEXT("\r\n"));

    if (dwFlags & RRAEX_LOG_FILE)
        StopLogging();
}


/****************************************************\
    FUNCTION: ProcessSections

    PARAMETERS:
        HKEY hkeyParent - Registry Branch to process.
        LPCTSTR pszSubkey - Registry Path to process.
        DWORD dwFlags - Registry Entry to modify.
        HDPA hdpaSections - Array of Sections
        int iNumberOfSections - Number of Sections in the Array

    DESCRIPTION:
        This function will call to have each Section
    processed.
\***************************************************/
void ProcessSections(HKEY hkeyParent, LPCTSTR pszSubkey, DWORD dwFlags, HDPA hdpaSections, int iNumberOfSections, HWND hWnd)
{
    RunOnceExSection    * pCurrentSection         = NULL;
    int                 iIndex, iDisplayIndex;
    BOOL                fOleInitialized           = TRUE;

    // Got to initialize it here; if it's done in RunOnceExProcess, i.e., process level initialization,
    // registration of asctrls.ocx fails -- looks like OleInitialize needs to be done per thread
    if (FAILED(OleInitialize(NULL)))
        fOleInitialized = FALSE;

    iDisplayIndex = -1;

    // If there's a callback, count total things to do...
    if (g_pCallbackProc)
    {
        g_nTotal = 0;
        g_nCurrent = 0;
        for (iIndex = 0; iIndex < iNumberOfSections; iIndex++)
        {
            if ((pCurrentSection = (RunOnceExSection *) DPA_GetPtr(hdpaSections, iIndex)) == NULL)
                continue;
            g_nTotal += pCurrentSection->m_NumberOfEntries;
        }
    }

    for (iIndex = 0; iIndex < iNumberOfSections; iIndex++)
    {
        if ((pCurrentSection = (RunOnceExSection *) DPA_GetPtr(hdpaSections, iIndex)) == NULL)
            continue;

        if (hWnd != NULL)
        {
            if (*pCurrentSection->m_szDisplayName != TEXT('\0'))
                SendMessage(hWnd, LB_SETCURSEL, ++iDisplayIndex, 0);
            else if (iDisplayIndex == -1)
                SendMessage(hWnd, LB_SETCURSEL, 0, 0);
        }

        pCurrentSection->Process(hkeyParent, pszSubkey, dwFlags);
    }

    if (fOleInitialized)
        OleUninitialize();
}


/****************************************************\
    FUNCTION: GetFlagsInRegistry

    PARAMETERS:
        HKEY hkeyParent - What branch of the registry to look.
        LPCTSTR szSubkey - What path in the registry to look.
        DWORD return - Flags that were found in the registry

    DESCRIPTION:
        Return with the Flags found in the registry
    or RRA_DEFAULT if none where found.
\***************************************************/
DWORD GetFlagsInRegistry(HKEY hkeyParent, LPCTSTR szSubkey)
{
    DWORD           dwFlagsInRegistry           = RRA_DEFAULT;
    HKEY            hFlagsKey                   = NULL;
    DWORD           dwKeySize                   = sizeof(dwFlagsInRegistry);

    if (ERROR_SUCCESS == RegOpenKeyEx(hkeyParent, szSubkey, NULL, KEY_QUERY_VALUE, &hFlagsKey))
    {
        RegQueryValueEx(hFlagsKey, c_szFlagsRegValue, NULL, NULL, (LPBYTE) &dwFlagsInRegistry, &dwKeySize);
        RegCloseKey(hFlagsKey);
    }

    return(dwFlagsInRegistry);
}


/****************************************************\
    FUNCTION: HandleDependencyDLLs

    PARAMETERS:
        HKEY hkeyParent - Registry Branch to process.
        LPCTSTR szRegPath - Registry Path to process.
        LPCTSTR szRegSubPath - Registry Path to process.
        DWORD dwFlags - Flags.  Do we want to delete after Unload?
        HDL_Type hdlDirection - Load or Unload?

    DESCRIPTION:
        This function will be passed a "Depend" section
    of the registry that will contain registry keys.
    These STR registry keys have filenames and data.
    These filenames need to be loaded (LoadLibrary())
    or freed (FreeLibrary()) depending on the HDL_Type
    parameter to this function.
\***************************************************/
void HandleDependencyDLLs(HKEY hkeyParent, LPCTSTR szRegPath, LPCTSTR szRegSubPath, DWORD dwFlags, HDL_Type hdlDirection)
{
    TCHAR           szBasePath[MAX_REG_PATH];
    TCHAR           szValueName[MAX_REG_VALUE];
    TCHAR           szDLLFileName[MAX_PATH];
    HKEY            hBaseKey                        = NULL;
    HKEY            hDependKey                      = NULL;
    DWORD           dwCurrDLL                       = 0;
    DWORD           dwKeyType                       = 0;
    DWORD           dwValueSize                     = ARRAYSIZE(szValueName);
    DWORD           dwDLLNameSize                   = sizeof(szDLLFileName);
    long            lEnumError;

    if ((NULL != szRegSubPath) && (TEXT('\0') != *szRegSubPath))      // If the szRegSubPath isn't empty, we concatonate the two strings.
        wsprintf(szBasePath, TEXT("%s\\%s"), szRegPath, szRegSubPath);
    else
        lstrcpy(szBasePath, szRegPath);

    // Open the key for Read only if we are doing a load or an unload where the registry does not need to be deleted.
    // If we are unloading and we need to remove the registry entry, this function will fail if the user doesn't have
    // permission.

    if (ERROR_SUCCESS == RegOpenKeyEx(hkeyParent, szBasePath, NULL,
                                (KEY_READ | (((eHDL_Unload == hdlDirection) && (dwFlags & RRA_DELETE)) ? KEY_WRITE:0)), &hBaseKey))
    {
        if (ERROR_SUCCESS == RegOpenKeyEx(hBaseKey, c_szDependencyName, NULL,
                                (KEY_READ | (((eHDL_Unload == hdlDirection) && (dwFlags & RRA_DELETE)) ? KEY_WRITE:0)), &hDependKey))
        {
            // Iterate through each value
            for (dwCurrDLL = 0;
                 ERROR_NO_MORE_ITEMS != (lEnumError = RegEnumValue(hDependKey, dwCurrDLL, szValueName, &dwValueSize, NULL, &dwKeyType, (LPBYTE) szDLLFileName, &dwDLLNameSize));
                 dwCurrDLL++)
            {
                if ((REG_SZ == dwKeyType) && (ERROR_SUCCESS == lEnumError))
                {
                    if (eHDL_Load == hdlDirection)
                    {
                        // We need to load this library to keep it in memory.
                        BOOL fWx86DLL;
                        if (NULL == RunOnceLoadLibrary( szDLLFileName, &fWx86DLL ))
                            ReportError(dwFlags, IDS_RUNONCEEX_LOAD_DEPEND_FAILED, szDLLFileName);
                        else
                            WriteToLog(TEXT("Dependency DLL loaded: %1\r\n"), szDLLFileName);
                    }
                    else        // Else Unload
                    {
                        // We need to unload this library
                        HINSTANCE   hInst   = GetModuleHandle(szDLLFileName);
                        if (NULL != hInst)
                        {
                            if (FreeLibrary(hInst))
                                WriteToLog(TEXT("Dependency DLL unloaded: %1\r\n"), szDLLFileName);
                        }
                    }
                }

                dwValueSize = ARRAYSIZE(szValueName);
                dwDLLNameSize = sizeof(szDLLFileName);
            }

            RegCloseKey(hDependKey);

            if ((eHDL_Unload == hdlDirection) && (dwFlags & RRA_DELETE))
            {
                // We need to remove the registry key so we don't process this again next time.
                RegDeleteKey(hBaseKey, c_szDependencyName);
            }
        }

        RegCloseKey(hBaseKey);
    }
}


/////////////////////////////////////////////////////////////////////
//  CLASS: RunOnceExEntry
/////////////////////////////////////////////////////////////////////

/****************************************************\
    FUNCTION: RunOnceExEntry

    PARAMETERS:
        LPTSTR lpszNewEntryName - Name of Entry
        LPTSTR lpszNewCmd       - Entry Command
        DWORD dwFlags           - Flags

    DESCRIPTION:
        This function will create a RunOnceEx Entry
    and set it's Name, Cmd, and section.
\***************************************************/
RunOnceExEntry::RunOnceExEntry(LPTSTR lpszNewEntryName, LPTSTR lpszNewCmd, DWORD dwFlags)
{
    const TCHAR * szRegisterFunctionName    = TEXT("DllRegisterServer");
    const TCHAR * szUnregisterFunctionName  = TEXT("DllUnregisterServer");
    const TCHAR * szInstallFunctionName     = TEXT("DllInstall");
    LPTSTR      lpszFileName                = lpszNewCmd;
    LPTSTR      lpszFunctionName            = NULL;
    LPTSTR      lpszCmdLineArgs             = NULL;
    LPTSTR      lpszCurrentChar             = lpszNewCmd;

    lstrcpy(m_szRunOnceExEntryName, lpszNewEntryName);
    m_ROAction = eRO_Unknown;
    *m_szFileName = TEXT('\0');
    *m_szFunctionName = TEXT('\0');
    *m_szCmdLineArgs = TEXT('\0');

    // These entries come in this format "<FileName>|<FunctionName>|<CmdLineArgs>".
    // We first need to find the end of the <FileName>.

    // Find the end of the filename.
    if (NULL == (lpszCurrentChar = LocalStrChr(lpszCurrentChar, SEPERATOR_CHAR)))
    {
        // It must be an EXE (or something that is executable) because it doesn't have a function name.
        lstrcpy(m_szCmdLineArgs, lpszNewCmd);
        m_ROAction = eRO_Exe;                           // Remember that we will need to ShellExec this later.
    }
    else
    {
        // We found a '|' so we have the <FileName>.
        *lpszCurrentChar = TEXT('\0');                  // Terminate the filename.
        lstrcpy(m_szFileName, lpszNewCmd);
        *lpszCurrentChar = SEPERATOR_CHAR;              // Remove the temporary termination.
        lpszCurrentChar = CharNext(lpszCurrentChar);

        // Now lets work on Getting the <FunctionName>.

        lpszFunctionName = lpszCurrentChar;             // Remember the beginning of the FunctionName before iterating.

        if (NULL == (lpszCurrentChar = LocalStrChr(lpszCurrentChar, SEPERATOR_CHAR)))
        {
            // If we have found the end of the string without the second '|', then
            // this needs to be a DllRegisterServer or DllUnregisterServer.

            lstrcpy(m_szFunctionName, lpszFunctionName);
            if (2 == CompareString(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE, lpszFunctionName, -1, szRegisterFunctionName, -1))
            {
                m_ROAction = eRO_Register;
            }
            else
            {
                if (2 == CompareString(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE, lpszFunctionName, -1, szUnregisterFunctionName, -1))
                {
                    m_ROAction = eRO_Unregister;
                }
                else
                {
                    m_ROAction = eRO_Unknown;
                    // An error has occured.  The user didn't specify a valid FunctionName.
                    ReportError(dwFlags, IDS_RUNONCEEX_BAD_FUNCTIONNAME, m_szFunctionName);
                }
            }
        }
        else
        {
            // We have enountered the second '|' which delemites the <CmdLineArgs> section.  By this point, the function we
            // are calling needs WinMain() parameters.or it's a DllInstall function

            *lpszCurrentChar = TEXT('\0');
            lstrcpy(m_szFunctionName, lpszFunctionName);
            *lpszCurrentChar = SEPERATOR_CHAR;            // Remove the temporary termination.
            lpszCurrentChar = CharNext(lpszCurrentChar);
            lstrcpy(m_szCmdLineArgs, lpszCurrentChar);

            if (TEXT('\0') == *m_szFunctionName)
            {
                if (TEXT('\0') == *m_szFileName)
                {
                    m_ROAction = eRO_Exe;
                }
                else
                {
                    // This command is invalid because commands to be shell execed need to start
                    // Need to have the <FileName> and <FunctionName> parameters empty.
                    m_ROAction = eRO_Unknown;
                    ReportError(dwFlags, IDS_RUNONCEEX_BAD_SHELLEXEC_CMD, lpszNewCmd);
                }
            }
            else
            {
                // check if it's DllInstall
                if (2 == CompareString(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE, m_szFunctionName, -1, szInstallFunctionName, -1))
                {
                    m_ROAction = eRO_Install;
                }
                else
                {
                    m_ROAction = eRO_WinMainFunction;
                }
            }
        }
    }
}


/****************************************************\
    FUNCTION: ~RunOnceExEntry

    PARAMETERS:
        none

    DESCRIPTION:
        This destructor will free memory that it used.
\***************************************************/
RunOnceExEntry::~RunOnceExEntry()
{
}


/****************************************************\
    FUNCTION: RunOnceExEntry::Process

    PARAMETERS:
        HKEY hkeyParent - Section of the registry being processed.
        LPCTSTR szSubkey - Path to the registry entries being processed.
        LPCTSTR szSectonName - Only used for logging purposes.
        DWORD dwFlags - Flags to determine if we delete command after executing it.

    DESCRIPTION:
        This function will Processes the entry.
    This means it will execute the command or
    call a function in a DLL.  After it finishes,
    it will delete the registry entry if appropriate.
\***************************************************/
void RunOnceExEntry::Process(HKEY hkeyParent, LPCTSTR szSubkey, LPCTSTR szSectionName, DWORD dwFlags)
{
    HINSTANCE       hInstance                       = NULL;
    WINMAIN_PARAMS  pfWinMainFunction               = NULL;
    DLLREGISTERSERVER_PARAMS    pfDllRegisterServer = NULL;
    DLLINSTALL_PARAMS           pfDllInstall        = NULL;

    TCHAR           szRegKeyPath[MAX_REG_PATH]      = TEXT("");
    HKEY            hCurrentSectionKey              = NULL;

    BOOL            fWx86DLL                        = FALSE;

    // Delete Registry Entry
    if ((NULL != szSectionName) && (RRA_DELETE & dwFlags))
    {
        wsprintf(szRegKeyPath, TEXT("%s\\%s"), szSubkey, szSectionName);
        LocalSHDeleteValue(hkeyParent, szRegKeyPath, m_szRunOnceExEntryName);
    }

    WriteToLog(TEXT("File:%1; Function:%2; Args:%3; Action:"), m_szFileName, m_szFunctionName, m_szCmdLineArgs);

    switch(m_ROAction)
    {
        case eRO_Register:
        case eRO_Unregister:
            WriteToLog(m_ROAction == eRO_Register ? TEXT("DllRegisterServer()\r\n") : TEXT("DllUnRegisterServer()\r\n"));
            hInstance = RunOnceLoadLibrary( m_szFileName, &fWx86DLL );
            if (NULL != hInstance)
            {
                HRESULT hResult = S_OK;
                char    pcstrDLLToLoad[MAX_PATH];

#ifdef UNICODE
                WideCharToMultiByte(CP_ACP, 0, m_szFunctionName, -1,
                                    pcstrDLLToLoad, ARRAYSIZE(pcstrDLLToLoad), NULL, NULL);
#else // UNICODE
                lstrcpy(pcstrDLLToLoad, m_szFunctionName);
#endif // UNICODE

                if (NULL != (pfDllRegisterServer = (DLLREGISTERSERVER_PARAMS) GetProcAddress(hInstance, pcstrDLLToLoad)))
                {
                    if (RRAEX_NO_EXCEPTION_TRAPPING & dwFlags)      // Don't trap exceptions if that's what the user wants.
                    {
                        // This flag is off be default because you better have a debugger installed if you don't catch
                        // these exceptions
#ifdef WX86
                        if ( fWx86DLL )
                        {
                            hResult = Wx86EmulateX86(pfDllRegisterServer, 0, NULL );
                        }
                        else
#endif
                            hResult = (*pfDllRegisterServer)();
                    }
                    else
                    {
                        _try
                        {
#ifdef WX86
                            if ( fWx86DLL )
                            {
                                hResult = Wx86EmulateX86(pfDllRegisterServer, 0, NULL );
                            }
                            else
#endif
                                hResult = (*pfDllRegisterServer)();
                        }
                        _except(EXCEPTION_EXECUTE_HANDLER)      // Catch all exceptions.
                        {
                            ReportError(dwFlags, IDS_RUNONCEEX_EXCEPTION, m_szFunctionName, m_szFileName);
                        }
                    }
                    if (FAILED(hResult))
                    {
                        WriteToLog(TEXT("An error occurred calling ""%1"" in ""%2"".  (HRESULT = %3!lx!)\r\n"), m_szFunctionName, m_szFileName, hResult);
                        ReportError(dwFlags, IDS_RUNONCEEX_REGISTER_ERROR, m_szFileName);
                    }
                }
                else
                {
                    ReportError(dwFlags, IDS_RUNONCEEX_FIND_FUNC_FAILED, m_szFunctionName, m_szFileName);
                }
                FreeLibrary(hInstance);
            }
            else
            {
                ReportError(dwFlags, IDS_RUNONCEEX_CANNOT_LOAD_DLL, m_szFileName);
            }

            break;

        case eRO_Install:
            WriteToLog(TEXT("DllInstall()\r\n"));
            hInstance = RunOnceLoadLibrary( m_szFileName, &fWx86DLL );
            if (NULL != hInstance)
            {
                char    pcstrDLLToLoad[MAX_PATH];
                WCHAR   pwstrDLLCmdLineArgs[MAX_PATH];
                HRESULT hResult = S_OK;

#ifdef UNICODE
                WideCharToMultiByte(CP_ACP, 0, m_szFunctionName, -1,
                                    pcstrDLLToLoad, ARRAYSIZE(pcstrDLLToLoad), NULL, NULL);
                lstrcpy(pwstrDLLCmdLineArgs, m_szCmdLineArgs);
#else // UNICODE
                lstrcpy(pcstrDLLToLoad, m_szFunctionName);
                MultiByteToWideChar(CP_ACP, 0, m_szCmdLineArgs, -1, pwstrDLLCmdLineArgs, ARRAYSIZE(pwstrDLLCmdLineArgs));
#endif // UNICODE

                if (NULL != (pfDllInstall = (DLLINSTALL_PARAMS) GetProcAddress(hInstance, pcstrDLLToLoad)))
                {
                    BOOL    bInstall;
                    WCHAR   *pwszArgs;

                    // parse the command line
                    for (pwszArgs = pwstrDLLCmdLineArgs;  *pwszArgs != L',' && *pwszArgs != L'\0';  pwszArgs++)
                        ;
                    if (*pwszArgs == L',')
                        *pwszArgs++ = L'\0';

                    // args to DllInstall is (BOOL, LPWSTR)
                    bInstall = (*pwstrDLLCmdLineArgs != L'u')  &&  (*pwstrDLLCmdLineArgs != L'U');

                    if (RRAEX_NO_EXCEPTION_TRAPPING & dwFlags)  // Don't trap exceptions if that's what the caller wants.
                    {
                        // This flag is off by default because you better have a debugger installed if you don't catch
                        // these exceptions

#ifdef WX86
                        if ( fWx86DLL )
                        {
                            DWORD dwArgs[ 2 ];
                            dwArgs[ 0 ] = (DWORD) bInstall;
                            dwArgs[ 1 ] = (DWORD) pwszArgs;
                            hResult = Wx86EmulateX86(pfDllInstall, ARRAYSIZE(dwArgs), dwArgs);
                        }
                        else
#endif
                            hResult = (*pfDllInstall)(bInstall, pwszArgs);
                    }
                    else
                    {
                        _try
                        {
#ifdef WX86
                            if ( fWx86DLL )
                            {
                                DWORD dwArgs[ 2 ];
                                dwArgs[ 0 ] = (DWORD) bInstall;
                                dwArgs[ 1 ] = (DWORD) pwszArgs;
                                hResult = Wx86EmulateX86(pfDllInstall, ARRAYSIZE(dwArgs), dwArgs);
                            }
                            else
#endif
                                hResult = (*pfDllInstall)(bInstall, pwszArgs);
                        }
                        _except(EXCEPTION_EXECUTE_HANDLER)      // Catch all exceptions.
                        {
                            ReportError(dwFlags, IDS_RUNONCEEX_EXCEPTION, m_szFunctionName, m_szFileName);
                        }
                    }
                    if (FAILED(hResult))
                    {
                        WriteToLog(TEXT("An error occurred calling ""%1"" in ""%2"".  (HRESULT = %3!lx!)\r\n"), m_szFunctionName, m_szFileName, hResult);
                        ReportError(dwFlags, IDS_RUNONCEEX_REGISTER_ERROR, m_szFileName);
                    }
                }
                else
                {
                    ReportError(dwFlags, IDS_RUNONCEEX_CANNOT_FIND_FUNCTION, m_szFunctionName, m_szFileName);
                }
                FreeLibrary(hInstance);
            }
            else
            {
                ReportError(dwFlags, IDS_RUNONCEEX_CANNOT_LOAD_DLL, m_szFileName);
            }
            break;

        case eRO_WinMainFunction:
            WriteToLog(TEXT("WinMain type function\r\n"));
            hInstance = RunOnceLoadLibrary( m_szFileName, &fWx86DLL );
            if (NULL != hInstance)
            {
                char    pcstrDLLToLoad[MAX_PATH];
                char    pcstrDLLCmdLineArgs[MAX_PATH];

#ifdef UNICODE
                WideCharToMultiByte(CP_ACP, 0, m_szFunctionName, -1,
                                    pcstrDLLToLoad, ARRAYSIZE(pcstrDLLToLoad), NULL, NULL);
                WideCharToMultiByte(CP_ACP, 0, m_szCmdLineArgs, -1,
                                    pcstrDLLCmdLineArgs, ARRAYSIZE(pcstrDLLCmdLineArgs), NULL, NULL);
#else // UNICODE
                lstrcpy(pcstrDLLToLoad, m_szFunctionName);
                lstrcpy(pcstrDLLCmdLineArgs, m_szCmdLineArgs);
#endif // UNICODE

                if (NULL != (pfWinMainFunction = (WINMAIN_PARAMS) GetProcAddress(hInstance, pcstrDLLToLoad)))
                {
                    if (RRAEX_NO_EXCEPTION_TRAPPING & dwFlags)  // Don't trap exceptions if that's what the caller wants.
                    {
                        // This flag is off be default because you better have a debugger installed if you don't catch
                        // these exceptions

#ifdef WX86
                        if ( fWx86DLL )
                        {
                            DWORD dwArgs[ 4 ];
                            dwArgs[ 0 ] = (DWORD) NULL;
                            dwArgs[ 1 ] = (DWORD) NULL;
                            dwArgs[ 2 ] = (DWORD) pcstrDLLCmdLineArgs;
                            dwArgs[ 3 ] = (DWORD) 0;
                            Wx86EmulateX86(pfWinMainFunction, ARRAYSIZE(dwArgs), dwArgs);
                        }
                        else
#endif
                            (*pfWinMainFunction)(NULL, NULL, pcstrDLLCmdLineArgs, 0);
                    }
                    else
                    {
                        _try
                        {
#ifdef WX86
                            if ( fWx86DLL )
                            {
                                DWORD dwArgs[ 4 ];
                                dwArgs[ 0 ] = (DWORD) NULL;
                                dwArgs[ 1 ] = (DWORD) NULL;
                                dwArgs[ 2 ] = (DWORD) pcstrDLLCmdLineArgs;
                                dwArgs[ 3 ] = (DWORD) 0;
                                Wx86EmulateX86(pfWinMainFunction, ARRAYSIZE(dwArgs), dwArgs);
                            }
                            else
#endif
                                (*pfWinMainFunction)(NULL, NULL, pcstrDLLCmdLineArgs, 0);
                        }
                        _except(EXCEPTION_EXECUTE_HANDLER)      // Catch all exceptions.
                        {
                            ReportError(dwFlags, IDS_RUNONCEEX_EXCEPTION, m_szFunctionName, m_szFileName);
                        }
                    }
                }
                else
                {
                    ReportError(dwFlags, IDS_RUNONCEEX_CANNOT_FIND_FUNCTION, m_szFunctionName, m_szFileName);
                }
                FreeLibrary(hInstance);
            }
            else
            {
                ReportError(dwFlags, IDS_RUNONCEEX_CANNOT_LOAD_DLL, m_szFileName);
            }
            break;

        case eRO_Exe:
            WriteToLog(TEXT("ShellExec Command\r\n"));
            {
                if (RRAEX_NO_EXCEPTION_TRAPPING & dwFlags)      // Don't trap exceptions if that's what the caller wants.
                {
                    // This flag is off be default because you better have a debugger installed if you don't catch
                    // these exceptions
                    ShellExecuteRegApp(m_szCmdLineArgs, dwFlags);
                }
                else
                {
                    _try
                    {
                        ShellExecuteRegApp(m_szCmdLineArgs, dwFlags);
                    }
                    _except(EXCEPTION_EXECUTE_HANDLER)      // Catch all exceptions.
                    {
                        ReportError(dwFlags, IDS_RUNONCEEX_EXE_EXCEPTION, m_szCmdLineArgs);
                    }
                }
            }
            break;

        case eRO_Unknown:
        default:
            WriteToLog(TEXT("Unknown\r\n"));
            break;
    }
}


/////////////////////////////////////////////////////////////////////
//  CLASS: RunOnceExSection
/////////////////////////////////////////////////////////////////////

/****************************************************\
    FUNCTION: RunOnceExSection

    PARAMETERS:
        LPTSTR lpszNewSectionName - The name of the new section
        LPTSTR lpszNewDisplayName - The display name of the new section

    DESCRIPTION:
        This constructor will set the name of the newly
    created section.
\***************************************************/
RunOnceExSection::RunOnceExSection(LPTSTR lpszNewSectionName, LPTSTR lpszNewDisplayName)
{
    lstrcpy(m_szRunOnceExSectionName, lpszNewSectionName);

    if ((NULL != lpszNewDisplayName) && (TEXT('\0') != *lpszNewDisplayName))
    {
        // Set the DisplayName as long as it was valid.
        lstrcpy(m_szDisplayName, lpszNewDisplayName);
    }
    else
    {
        // It was invalid, so we use the SectionName for the DisplayName.
        //lstrcpy(m_szDisplayName, lpszNewSectionName);
        *m_szDisplayName = TEXT('\0');              // just don't display anything
    }
    m_hEntryArray = NULL;
    m_NumberOfEntries = 0;
}


/****************************************************\
    FUNCTION: ~RunOnceExSection

    PARAMETERS:
        none

    DESCRIPTION:
        This destructor will free memory that it used.
\***************************************************/
RunOnceExSection::~RunOnceExSection()
{
    if (NULL != m_hEntryArray)
    {
        RunOnceExEntry * pFirstSection;

        for (int iIndex = 0; iIndex < m_NumberOfEntries; iIndex++)
        {
            pFirstSection = (RunOnceExEntry *) DPA_GetPtr(m_hEntryArray, iIndex);
            delete pFirstSection;
        }

        DPA_Destroy(m_hEntryArray);
    }
}


/****************************************************\
    FUNCTION: RunOnceExSection::Process

    PARAMETERS:
        HKEY hkeyParent - Section of the registry being processed.
        LPCTSTR szSubkey - Path to the registry entries being processed.
        DWORD dwFlags - Flags to determine if we delete command after executing it.

    DESCRIPTION:
        This function will process each entry in it,
    delete the registry key it used, and then
    repeat the process with the next section.
\***************************************************/
void RunOnceExSection::Process(HKEY hkeyParent, LPCTSTR szSubkey, DWORD dwFlags)
{
    RunOnceExEntry      * pCurrentEntry     = NULL;
    HKEY                hSectionKey         = NULL;
    int                 iEntryIndex;

    WriteToLog(TEXT("\r\n"));
    LogDateAndTime();
    WriteToLog(TEXT("Section:%1\r\n"), m_szRunOnceExSectionName);

    // Load the dependency DLLs for this sections
    HandleDependencyDLLs(hkeyParent, szSubkey, m_szRunOnceExSectionName, dwFlags, eHDL_Load);

    if (NULL != m_hEntryArray)
    {
        for (iEntryIndex = 0; iEntryIndex < m_NumberOfEntries; iEntryIndex++)
        {
            pCurrentEntry = (RunOnceExEntry *) DPA_GetPtr(m_hEntryArray, iEntryIndex);
            if (pCurrentEntry)
                pCurrentEntry->Process(hkeyParent, szSubkey, m_szRunOnceExSectionName, dwFlags);

            // If there is a call back, send back information
            if (g_pCallbackProc)
            {
                g_nCurrent++;
                g_pCallbackProc(g_nCurrent, g_nTotal, NULL);
            }
        }
    }

    // Unload the dependency DLLs for this sections
    HandleDependencyDLLs(hkeyParent, szSubkey, m_szRunOnceExSectionName, dwFlags, eHDL_Unload);

    LogDateAndTime();

    if (RRA_DELETE & dwFlags)
    {
        TCHAR   szKeyToDelete[MAX_REG_PATH];
        wsprintf(szKeyToDelete, TEXT("%s\\%s"), szSubkey, m_szRunOnceExSectionName);
        LocalSHDeleteKey(hkeyParent, szKeyToDelete);
    }

}


/****************************************************\
    FUNCTION: CompareSection

    PARAMETERS:
        RunOnceExSection * pSection1    - The first Section to be compared
        RunOnceExSection * pSection2    - The second Section to be compared
        LPARAM lpNotUsed                - Not used.
        int return                      - (-1) if the first is smaller.

    DESCRIPTION:
        The following function will determine which
    comes first when sorted.
\***************************************************/
INT CALLBACK CompareSection(RunOnceExSection * pSection1, RunOnceExSection * pSection2, LPARAM lpNotUsed)
{
    if (1 == CompareString(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE, pSection1->m_szRunOnceExSectionName, -1, pSection2->m_szRunOnceExSectionName, -1))
        return(-1);

    return(1);
}


/****************************************************\
    FUNCTION: CompareEntries

    PARAMETERS:
        RunOnceExEntry * pEntry1    - The first Entry to be compared
        RunOnceExEntry * pEntry2    - The second Entry to be compared
        LPARAM lpNotUsed            - Not used.
        int return                  - (-1) if the first is smaller.

    DESCRIPTION:
        The following function will determine which
    comes first when sorted.
\***************************************************/
INT CALLBACK CompareEntries(RunOnceExEntry * pEntry1, RunOnceExEntry * pEntry2, LPARAM lpNotUsed)
{
    if (1 == CompareString(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE, pEntry1->m_szRunOnceExEntryName, -1, pEntry2->m_szRunOnceExEntryName, -1))
        return(-1);

    return(1);
}


/****************************************************\
    FUNCTION: GetSections

    PARAMETERS:
        HKEY hkeyParent - Section of the registry being processed.
        LPCTSTR szSubkey - Path to the registry entries being processed.
        DWORD dwFlags - Flags.

    DESCRIPTION:
        This function will open the RunOnceEx registry
    key and read all the sections and entries.  It will
    read these into memory and set *ppFirstSection to
    the first (root) section.
\***************************************************/
HDPA GetSections(HKEY hkeyParent, LPCTSTR szSubkey, DWORD dwFlags, int * pNumberOfSections)
{
    TCHAR           szCurrentSectionName[MAX_ENTRYNAME] = TEXT("");
    TCHAR           szCurrSectionDisplayName[MAX_ENTRYNAME] = TEXT("");
    HKEY            hRootKey                            = NULL;
    DWORD           dwCurrentSection                    = 0;

    DWORD           dwRegType                           = 0;
    long            lDisplayNameSize                    = ARRAYSIZE(szCurrSectionDisplayName);
    long            lEnumError;
    HDPA            hDPA_Sections                       = DPA_Create(ARRAY_GROW_RATE);
    RunOnceExSection    * pNewSection                   = NULL;

    *pNumberOfSections = 0;

    if (NULL != hDPA_Sections)
    {
        // Do we have any RegOpenKeyEx sections to process/read?
        if (ERROR_SUCCESS == RegOpenKeyEx(hkeyParent, szSubkey, NULL, KEY_READ, &hRootKey))
        {
            // IthkeyParenterate through each section
            for (dwCurrentSection = 0;
                 ERROR_NO_MORE_ITEMS != (lEnumError = RegEnumKey(hRootKey, dwCurrentSection, szCurrentSectionName, ARRAYSIZE(szCurrentSectionName)));
                 dwCurrentSection++)
            {
                if (ERROR_SUCCESS == lEnumError)
                {
                    lDisplayNameSize = sizeof(szCurrSectionDisplayName);
                    if (RegQueryValue(hRootKey, szCurrentSectionName, szCurrSectionDisplayName, &lDisplayNameSize) != ERROR_SUCCESS)
                        *szCurrSectionDisplayName = TEXT('\0');

                    //  Only Process non-"Depend" entries.
                    if (2 != CompareString(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE, szCurrentSectionName, -1, c_szDependencyName, -1))
                    {
                        pNewSection = new RunOnceExSection(szCurrentSectionName, szCurrSectionDisplayName);
                        if (NULL != pNewSection)
                        {
                            if (*szCurrSectionDisplayName)
                                g_iNDisplaySections++;
                            DPA_SetPtr(hDPA_Sections, *pNumberOfSections, (void *) pNewSection);
                            pNewSection->m_hEntryArray = GetEntries(hRootKey, szCurrentSectionName, dwFlags, &(pNewSection->m_NumberOfEntries));
                            (*pNumberOfSections)++;
                        }
                    }
                }
            }

            RegCloseKey(hRootKey);
        }

        DPA_Sort(hDPA_Sections, (PFNDPACOMPARE) CompareSection, 0);
    }

    return(hDPA_Sections);
}


/****************************************************\
    FUNCTION: GetEntries

    PARAMETERS:
        HKEY hkeyParent - Section of the registry being processed.
        LPCTSTR szSubkey - Path to the registry entries being processed.
        DWORD dwFlags - Flags.
        int * pNumberOfEntries - OUT: Number of sections read.

    DESCRIPTION:
        This function will open the RunOnceEx registry
    section key and read all the entries.
\***************************************************/
HDPA GetEntries(HKEY hRootKey, LPCTSTR szSectionName, DWORD dwFlags, int * pNumberOfEntries)
{
    HKEY            hCurrentSectionKey                  = NULL;

    TCHAR           szCurrentEntryName[MAX_ENTRYNAME]   = TEXT("");
    TCHAR           szCurrentEntryCmd[MAX_PATH]         = TEXT("");
    DWORD           dwEntrySize                         = 0;
    DWORD           dwEntryCmdSize                      = 0;

    DWORD           dwCurrentEntry                      = 0;
    DWORD           dwRegType                           = 0;
    long            lEnumError;
    HDPA            hDPA_Entries                        = DPA_Create(ARRAY_GROW_RATE);
    RunOnceExEntry  * pNewEntry                         = NULL;

    *pNumberOfEntries = 0;

    if (NULL != hDPA_Entries)
    {
        if (ERROR_SUCCESS == RegOpenKeyEx(hRootKey, szSectionName, NULL, KEY_READ, &hCurrentSectionKey))
        {
            DWORD   dwKeyType;

            // Iterate through each value
            dwEntrySize = ARRAYSIZE(szCurrentEntryName);
            dwEntryCmdSize = sizeof(szCurrentEntryCmd);

            for (dwCurrentEntry = 0;
                ERROR_NO_MORE_ITEMS != (lEnumError = RegEnumValue(hCurrentSectionKey, dwCurrentEntry, szCurrentEntryName, &dwEntrySize, NULL, &dwKeyType, (LPBYTE) szCurrentEntryCmd, &dwEntryCmdSize));
                dwCurrentEntry++)
            {
                if (ERROR_SUCCESS == lEnumError)
                {
                    // An empty Entry Name is not acceptable because that is the Display Name for the section.
                    if ((REG_SZ == dwKeyType) && (TEXT('\0') != *szCurrentEntryName))
                    {
                        pNewEntry = new RunOnceExEntry(szCurrentEntryName, szCurrentEntryCmd, dwFlags);
                        if (NULL != pNewEntry)
                        {
                            if (eRO_Unknown != pNewEntry->m_ROAction)
                            {
                                DPA_SetPtr(hDPA_Entries, *pNumberOfEntries, (void *) pNewEntry);
                                (*pNumberOfEntries)++;
                            }
                            else
                                delete pNewEntry;
                        }
                    }
                }

                dwEntrySize = ARRAYSIZE(szCurrentEntryName);
                dwEntryCmdSize = sizeof(szCurrentEntryCmd);
            }

            RegCloseKey(hCurrentSectionKey);
        }

        DPA_Sort(hDPA_Entries, (PFNDPACOMPARE) CompareEntries, 0);
    }

    return(hDPA_Entries);
}


// taken from \\trango\slmadd\src\shell\shell32\shellprv.h
#define FillExecInfo(_info, _hwnd, _verb, _file, _params, _dir, _show) \
        (_info).hwnd            = _hwnd;        \
        (_info).lpVerb          = _verb;        \
        (_info).lpFile          = _file;        \
        (_info).lpParameters    = _params;      \
        (_info).lpDirectory     = _dir;         \
        (_info).nShow           = _show;        \
        (_info).fMask           = 0;            \
        (_info).cbSize          = sizeof(SHELLEXECUTEINFO);

//
// Path processing function
//
#define PPCF_ADDQUOTES               0x00000001        // return a quoted name if required
#define PPCF_ADDARGUMENTS            0x00000003        // appends arguments (and wraps in quotes if required)
#define PPCF_NODIRECTORIES           0x00000010        // don't match to directories
#define PPCF_NORELATIVEOBJECTQUALIFY 0x00000020        // don't return fully qualified relative objects
#define PPCF_FORCEQUALIFY            0x00000040        // qualify even non-relative names

typedef LONG WINSHELLAPI (WINAPI * LPPATHPROCESSCOMMAND)(LPCTSTR, LPTSTR, int, DWORD);

/****************************************************\
    FUNCTION: ShellExecuteRegApp

    PARAMETERS:
        LPCTSTR pszCmdLine      - Cmd line to execute
        DWORD dwFlags            - Flags to specify if we need to wait for command to finish.

    DESCRIPTION:
        The following handles running an application
    and optionally waiting for it to terminate.
\***************************************************/
void ShellExecuteRegApp(LPTSTR pszCmdLine, DWORD dwFlags)
{
    TCHAR szBuf[MAX_PATH];

    GetSystemDirectory(szBuf, ARRAYSIZE(szBuf));

    if (RunningOnIE4())
    {
        HINSTANCE               hShell32DLL = NULL;
        LPPATHPROCESSCOMMAND    pfnPathProcessCommand;
        TCHAR                   szQuotedCmdLine[MAX_PATH+2];
        SHELLEXECUTEINFO        ExecInfo;
        LPTSTR                  lpszArgs;
        BOOL                    fPPCSuccess = FALSE;                    // PathProcessCommand succeeded

        AddPath(szBuf, TEXT("shell32.dll"));

        if ((hShell32DLL = LoadLibraryEx(szBuf, NULL, LOAD_WITH_ALTERED_SEARCH_PATH)) != NULL)
        {
            if ((pfnPathProcessCommand = (LPPATHPROCESSCOMMAND) GetProcAddress(hShell32DLL, (LPCSTR) 653)) != NULL)
            {
                //
                // We used to call CreateProcess( NULL, szCmdLine, ...) here,
                // but thats not useful for people with apppaths stuff.
                //

                // Gross, but if the process command fails, copy the command line to let
                // shell execute report the errors

                if ((pfnPathProcessCommand)(pszCmdLine, szQuotedCmdLine, ARRAYSIZE(szQuotedCmdLine), PPCF_ADDARGUMENTS|PPCF_FORCEQUALIFY) != -1)
                    fPPCSuccess = TRUE;
            }

            FreeLibrary(hShell32DLL);
        }

        if (!fPPCSuccess)
            lstrcpy(szQuotedCmdLine, pszCmdLine);

        lpszArgs = LocalPathGetArgs(szQuotedCmdLine);
        if (*lpszArgs)
            *(lpszArgs-1) = TEXT('\0');                                 // Strip args

        LocalPathUnquoteSpaces(szQuotedCmdLine);

        FillExecInfo(ExecInfo, NULL, NULL, szQuotedCmdLine, lpszArgs, szBuf, SW_SHOWNORMAL);
        ExecInfo.fMask |= SEE_MASK_NOCLOSEPROCESS;
        if (dwFlags & RRAEX_NO_ERROR_DIALOGS)                           // Don't display Error dialog
            ExecInfo.fMask |= SEE_MASK_FLAG_NO_UI;

        if (ShellExecuteEx(&ExecInfo))
        {
            if ((dwFlags & RRA_WAIT) && (ExecInfo.hProcess != NULL))
            {
                MsgWaitForMultipleObjectsLoop(ExecInfo.hProcess, INFINITE);
            }

            CloseHandle(ExecInfo.hProcess);
        }
    }
    else                                                                // old Win95 logic -- just call CreateProcess
    {
        STARTUPINFO startup;
        PROCESS_INFORMATION pi;

        ZeroMemory(&startup, sizeof(startup));
        startup.cb = sizeof(startup);

        if (CreateProcess(NULL, pszCmdLine, NULL, NULL, FALSE, CREATE_NEW_PROCESS_GROUP, NULL, szBuf, &startup, &pi))
        {
            if (dwFlags & RRA_WAIT)
            {
                MsgWaitForMultipleObjectsLoop(pi.hProcess, INFINITE);
            }

            CloseHandle(pi.hProcess);
            CloseHandle(pi.hThread);
        }
    }
}

#define BUFFER_SIZE 1024
BOOL HaveDependServices(SC_HANDLE hService)
{
    HRESULT hr = S_OK;
    LPBYTE  lpBuffer = NULL;
    DWORD   dwSize   = BUFFER_SIZE;    // Start with 1k
    DWORD   dwBytesNeeded;
    DWORD   dwNumServices;
    BOOL    bDependServices = FALSE;

    lpBuffer = (LPBYTE) LocalAlloc(LPTR, dwSize);
    if (lpBuffer)
    {
        if (!EnumDependentServices(hService, SERVICE_STATE_ALL,
                                   (LPENUM_SERVICE_STATUS)lpBuffer, dwSize,
                                   &dwBytesNeeded, &dwNumServices))
        {
            if (GetLastError() == ERROR_MORE_DATA)
            {
                dwSize = dwBytesNeeded + 32;
                LocalFree(lpBuffer);
                lpBuffer = (LPBYTE) LocalAlloc(LPTR, dwSize);
                if (lpBuffer)
                {
                    if (!EnumDependentServices(hService, SERVICE_STATE_ALL,
                                               (LPENUM_SERVICE_STATUS)lpBuffer, dwSize,
                                               &dwBytesNeeded, &dwNumServices))
                    {
                        hr = HRESULT_FROM_WIN32(GetLastError());
                    }
                }
                else
                    hr = HRESULT_FROM_WIN32(GetLastError());
            }
            else
                hr = HRESULT_FROM_WIN32(GetLastError());

        }
        if (SUCCEEDED(hr))
        {
            // If at least one service depends on this one?
            bDependServices = (dwNumServices != 0);
        }
        if (lpBuffer)
            LocalFree(lpBuffer);
    }
    return bDependServices;
}

void CheckServices(DWORD dwFlags)
{
    SC_HANDLE hSCM = NULL;
    SC_HANDLE hService = NULL;
    BOOL    bRebootNeeded = FALSE;
    HKEY    hKey = NULL;
    LPSTR   pServices = NULL;
    LPSTR   pCheckService = NULL;
    LONG    lRet = 0;
    DWORD   dwSize;

    pServices = (LPSTR)LocalAlloc(LPTR, BUFFER_SIZE);
    if (pServices)
    {
        // Get the services to check for from the registry.
        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_RUNONCEEX, NULL, KEY_READ|KEY_WRITE, &hKey) == ERROR_SUCCESS)
        {
            dwSize = BUFFER_SIZE - 1;
            lRet = RegQueryValueEx(hKey, g_c_szServicesRegValue, NULL, NULL, (LPBYTE)pServices, &dwSize);
            if (lRet == ERROR_MORE_DATA)
            {
                dwSize += 32;
                LocalFree(pServices);
                pServices = (LPSTR)LocalAlloc(LPTR, dwSize);

                if (pServices)
                {
                    lRet = RegQueryValueEx(hKey, g_c_szServicesRegValue, NULL, NULL, (LPBYTE)pServices, &dwSize);
                }
            }
            if (lRet != ERROR_SUCCESS)
            {
                if (pServices)
                {
                    LocalFree(pServices);
                    pServices = NULL;
                }
            }
            RegDeleteValue(hKey, g_c_szServicesRegValue);
            RegCloseKey(hKey);
        }

        if ((pServices) && (*pServices))
        {
            hSCM = OpenSCManager (NULL, NULL, SC_MANAGER_ALL_ACCESS);
            if (hSCM)
            {
                pCheckService = pServices;
                // zero out all forward slashes to get the services terminated
                while (*pCheckService)
                {
                    if (*pCheckService == '/')
                    {
                        *pCheckService = '\0';
                        pCheckService++;
                    }
                    else
                        pCheckService = CharNext(pCheckService);
                }
                // RegQueryValueExA is using the same buffer to convert the UNICODE
                // string to a ANSI string. This will leave some UNICODE characters
                // after the ANSI strings and the services are not realy double 0
                // terminated anymore. This will ensure that the list is still
                // double 0 terminated
                pCheckService++;
                *pCheckService = '\0';

                pCheckService = pServices;
                while (!bRebootNeeded && (*pCheckService))
                {
                    hService = OpenService(hSCM,
                                           (LPCSTR)pCheckService,
                                           STANDARD_RIGHTS_REQUIRED | SERVICE_ENUMERATE_DEPENDENTS);
                    if (hService)
                    {
                        bRebootNeeded = HaveDependServices(hService);
                        CloseServiceHandle(hService);
                    }

                    pCheckService += lstrlen(pCheckService) + 1;
                }
                CloseServiceHandle(hSCM);
            }
        }
        if (pServices)
            LocalFree(pServices);
    }
    if (bRebootNeeded)
    {
        ReportError((dwFlags & ~RRAEX_NO_ERROR_DIALOGS), IDS_RUNONCEEX_SERVICE_REQUIRES_REBOOT);
        LogOff(TRUE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\iernonce\utils.cpp ===
#include "iernonce.h"
#include "resource.h"


//==================================================================
// AddPath()
//
void AddPath(LPTSTR szPath, LPCTSTR szName)
{
    LPTSTR szTmp;

    // Find end of the string
    szTmp = szPath + lstrlen(szPath);

    // If no trailing backslash then add one
    if (szTmp > szPath  &&  *(CharPrev(szPath, szTmp)) != TEXT('\\'))
        *szTmp++ = TEXT('\\');

    // Add new name to existing path string
    while (*szName == TEXT(' '))
        szName = CharNext(szName);

    lstrcpy(szTmp, szName);
}

// function will upated the given buffer to parent dir
//
BOOL GetParentDir( LPTSTR szFolder )
{
    LPTSTR lpTmp;
    BOOL  bRet = FALSE;

    // remove the trailing '\\'
    lpTmp = CharPrev( szFolder, (szFolder + lstrlen(szFolder)) );
    lpTmp = CharPrev( szFolder, lpTmp );

    while ( (lpTmp > szFolder) && (*lpTmp != TEXT('\\') ) )
    {
       lpTmp = CharPrev( szFolder, lpTmp );
    }

    if ( *lpTmp == TEXT('\\') )
    {
        if ( (lpTmp == szFolder) || (*CharPrev(szFolder, lpTmp)==TEXT(':') ) )
            lpTmp = CharNext( lpTmp );
        *lpTmp = TEXT('\0');
        bRet = TRUE;
    }

    return bRet;
}

// This is the value for the major version 4.71
#define IE4_MS_VER   0x00040047

BOOL RunningOnIE4()
{
    static BOOL fIsIE4 = 2;
    TCHAR   szFile[MAX_PATH];
#ifdef UNICODE
    char    szANSIFile[MAX_PATH];
#endif
    DWORD   dwMSVer;
    DWORD   dwLSVer;

    if (fIsIE4 != 2)
        return fIsIE4;

    GetSystemDirectory(szFile, ARRAYSIZE(szFile));
    AddPath(szFile, TEXT("shell32.dll"));

#ifdef UNICODE
    WideCharToMultiByte(CP_ACP, 0, szFile, -1, szANSIFile, sizeof(szANSIFile), NULL, NULL);
#endif

    GetVersionFromFile(
#ifdef UNICODE
                        szANSIFile,
#else
                        szFile,
#endif
                        &dwMSVer, &dwLSVer, TRUE);

    fIsIE4 = dwMSVer >= IE4_MS_VER;

    return fIsIE4;
}


/****************************************************\
    FUNCTION: MsgWaitForMultipleObjectsLoop

    PARAMETERS:
        HANDLE hEvent       - Pointer to the object-handle array of Objects
        DWORD dwTimeout     - Time out duration
        DWORD return        - Return is WAIT_FAILED or WAIT_OBJECT_0

    DESCRIPTION:
        Waits for the object (Process) to complete.
\***************************************************/
DWORD MsgWaitForMultipleObjectsLoop(HANDLE hEvent, DWORD dwTimeout)
{
    MSG msg;
    DWORD dwObject;
    while (1)
    {
        // NB We need to let the run dialog become active so we have to half handle sent
        // messages but we don't want to handle any input events or we'll swallow the
        // type-ahead.
        dwObject = MsgWaitForMultipleObjects(1, &hEvent, FALSE, dwTimeout, QS_ALLINPUT);
        // Are we done waiting?
        switch (dwObject) {
        case WAIT_OBJECT_0:
        case WAIT_FAILED:
            return dwObject;

        case WAIT_OBJECT_0 + 1:
            while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
                DispatchMessage(&msg);
            break;
        }
    }
    // never gets here
    // return dwObject;
}


void LogOff(BOOL bRestart)
{
    if (g_bRunningOnNT)
    {
        HANDLE hToken;
        TOKEN_PRIVILEGES tkp;

        // get a token from this process
        if (OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken))
        {
            // get the LUID for the shutdown privilege
            LookupPrivilegeValue(NULL, SE_SHUTDOWN_NAME, &tkp.Privileges[0].Luid);

            tkp.PrivilegeCount = 1;
            tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

            //get the shutdown privilege for this proces
            AdjustTokenPrivileges(hToken, FALSE, &tkp, 0, (PTOKEN_PRIVILEGES)NULL, 0);
        }
    }

    ExitWindowsEx(bRestart?EWX_REBOOT|EWX_FORCE:EWX_LOGOFF, 0);
    // this is a hack to prevent explorer from continue starting (In Integrated Shell)
    // and runonce from continue processing other items.
    // If we use a timer wait (which contains a messageloop), in browser only mode our 
    // process gets terminated before explorer and explorer would try and continue 
    // processing runonce items. With the while loop below this seem to not happen.
    if (bRestart)
        while (true) ;
}


//
//  Performs a message box with the text and title string loaded from the string table.
void ReportError(DWORD dwFlags, UINT uiResourceNum, ...)
{
    TCHAR           szResourceStr[1024]     = TEXT("");
    va_list         vaListOfMessages;
    LPTSTR          pszErrorString = NULL;

    LoadString(g_hinst, uiResourceNum, szResourceStr, ARRAYSIZE(szResourceStr));

    va_start(vaListOfMessages, uiResourceNum);          // Initialize variable arguments.
    FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_STRING,
                      (LPCVOID) szResourceStr, 0, 0, (LPTSTR) &pszErrorString, 0, &vaListOfMessages);
    va_end(vaListOfMessages);

    if (pszErrorString != NULL)
    {
        if (!(RRAEX_NO_ERROR_DIALOGS & dwFlags))        // Display Error dialog
        {
            if (*g_szTitleString == TEXT('\0'))         // Initialize this only once
                LoadString(g_hinst, IDS_RUNONCEEX_TITLE, g_szTitleString, ARRAYSIZE(g_szTitleString));
            MessageBox(NULL, pszErrorString, g_szTitleString, MB_OK | MB_ICONERROR | MB_SETFOREGROUND);
        }

        // If there is a cllback then callback with error string
        if (g_pCallbackProc)
            g_pCallbackProc(0, 0, pszErrorString);

        WriteToLog(pszErrorString);
        WriteToLog(TEXT("\r\n"));

        LocalFree(pszErrorString);
    }
}


// copied from msdev\crt\src\atox.c
/***
*long AtoL(char *nptr) - Convert string to long
*
*Purpose:
*       Converts ASCII string pointed to by nptr to binary.
*       Overflow is not detected.
*
*Entry:
*       nptr = ptr to string to convert
*
*Exit:
*       return long int value of the string
*
*Exceptions:
*       None - overflow is not detected.
*
*******************************************************************************/

long AtoL(const char *nptr)
{
        int c;                  /* current char */
        long total;             /* current total */
        int sign;               /* if '-', then negative, otherwise positive */

        // NOTE: no need to worry about DBCS chars here because IsSpace(c), IsDigit(c),
        // '+' and '-' are "pure" ASCII chars, i.e., they are neither DBCS Leading nor
        // DBCS Trailing bytes -- pritvi

        /* skip whitespace */
        while ( IsSpace((int)(unsigned char)*nptr) )
                ++nptr;

        c = (int)(unsigned char)*nptr++;
        sign = c;               /* save sign indication */
        if (c == '-' || c == '+')
                c = (int)(unsigned char)*nptr++;        /* skip sign */

        total = 0;

        while (IsDigit(c)) {
                total = 10 * total + (c - '0');         /* accumulate digit */
                c = (int)(unsigned char)*nptr++;        /* get next char */
        }

        if (sign == '-')
                return -total;
        else
                return total;   /* return result, negated if necessary */
}


// returns a pointer to the arguments in a cmd type path or pointer to
// NULL if no args exist
//
// "foo.exe bar.txt"    -> "bar.txt"
// "foo.exe"            -> ""
//
// Spaces in filenames must be quoted.
// " "A long name.txt" bar.txt " -> "bar.txt"
STDAPI_(LPTSTR)
LocalPathGetArgs(
    LPCTSTR pszPath)                        // copied from \\trango\slmadd\src\shell\shlwapi\path.c
{
    BOOL fInQuotes = FALSE;

    if (!pszPath)
            return NULL;

    while (*pszPath)
    {
        if (*pszPath == TEXT('"'))
            fInQuotes = !fInQuotes;
        else if (!fInQuotes && *pszPath == TEXT(' '))
            return (LPTSTR)pszPath+1;
        pszPath = CharNext(pszPath);
    }

    return (LPTSTR)pszPath;
}


/*----------------------------------------------------------
Purpose: If a path is contained in quotes then remove them.

Returns: --
Cond:    --
*/
STDAPI_(void)
LocalPathUnquoteSpaces(
    LPTSTR lpsz)                            // copied from \\trango\slmadd\src\shell\shlwapi\path.c
{
    int cch;

    cch = lstrlen(lpsz);

    // Are the first and last chars quotes?
    if (lpsz[0] == TEXT('"') && lpsz[cch-1] == TEXT('"'))
    {
        // Yep, remove them.
        lpsz[cch-1] = TEXT('\0');
        hmemcpy(lpsz, lpsz+1, (cch-1) * sizeof(TCHAR));
    }
}


#ifdef UNICODE
LPWSTR FAR PASCAL LocalStrChrW(LPCWSTR lpStart, WORD wMatch)
// copied from \\trango\slmadd\src\shell\shlwapi\strings.c
{
    for ( ; *lpStart; lpStart++)
    {
        // Need a tmp word since casting ptr to WORD * will
        // fault on MIPS, ALPHA

        WORD wTmp;
        memcpy(&wTmp, lpStart, sizeof(WORD));

        if (!ChrCmpW_inline(wTmp, wMatch))
        {
            return((LPWSTR)lpStart);
        }
    }
    return (NULL);
}


__inline BOOL ChrCmpW_inline(WORD w1, WORD wMatch)
// copied from \\trango\slmadd\src\shell\shlwapi\strings.c
{
    return(!(w1 == wMatch));
}
#else
/*
 * StrChr - Find first occurrence of character in string
 * Assumes   lpStart points to start of null terminated string
 *           wMatch  is the character to match
 * returns ptr to the first occurrence of ch in str, NULL if not found.
 */
LPSTR FAR PASCAL LocalStrChrA(LPCSTR lpStart, WORD wMatch)
// copied from \\trango\slmadd\src\shell\shlwapi\strings.c
{
    for ( ; *lpStart; lpStart = AnsiNext(lpStart))
    {
        if (!ChrCmpA_inline(*(UNALIGNED WORD FAR *)lpStart, wMatch))
            return((LPSTR)lpStart);
    }
    return (NULL);
}


/*
 * ChrCmp -  Case sensitive character comparison for DBCS
 * Assumes   w1, wMatch are characters to be compared
 * Return    FALSE if they match, TRUE if no match
 */
__inline BOOL ChrCmpA_inline(WORD w1, WORD wMatch)
// copied from \\trango\slmadd\src\shell\shlwapi\strings.c
{
    /* Most of the time this won't match, so test it first for speed.
    */
    if (LOBYTE(w1) == LOBYTE(wMatch))
    {
        if (IsDBCSLeadByte(LOBYTE(w1)))
        {
            return(w1 != wMatch);
        }
        return FALSE;
    }
    return TRUE;
}
#endif


#ifdef UNICODE
/*----------------------------------------------------------
Purpose: Recursively delete the key, including all child values
         and keys.

Returns: 
Cond:    --
*/
STDAPI_(DWORD)
LocalSHDeleteKeyW(
    HKEY    hkey, 
    LPCWSTR pwszSubKey)                     // copied from \\trango\slmadd\src\shell\shlwapi\reg.c
{
    DWORD dwRet;
    CHAR sz[MAX_PATH];

    WideCharToMultiByte(CP_ACP, 0, pwszSubKey, -1, sz, ARRAYSIZE(sz), NULL, NULL);

    if (g_bRunningOnNT)
    {
        dwRet = DeleteKeyRecursively(hkey, sz);
    }
    else
    {
        // On Win95, RegDeleteKey does what we want
        dwRet = RegDeleteKeyA(hkey, sz);
    }

    RegFlushKey(hkey);

    return dwRet;
}
#else
/*----------------------------------------------------------
Purpose: Recursively delete the key, including all child values
         and keys.

Returns: 
Cond:    --
*/
STDAPI_(DWORD)
LocalSHDeleteKeyA(
    HKEY   hkey, 
    LPCSTR pszSubKey)                       // copied from \\trango\slmadd\src\shell\shlwapi\reg.c
{
    DWORD dwRet;

    if (g_bRunningOnNT)
    {
        dwRet = DeleteKeyRecursively(hkey, pszSubKey);
    }
    else
    {
        // On Win95, RegDeleteKey does what we want
        dwRet = RegDeleteKeyA(hkey, pszSubKey);
    }

    RegFlushKey(hkey);

    return dwRet;
}
#endif


/*----------------------------------------------------------
Purpose: Recursively delete the key, including all child values
         and keys.  Mimics what RegDeleteKey does in Win95.

Returns: 
Cond:    --
*/
DWORD
DeleteKeyRecursively(
    HKEY   hkey, 
    LPCSTR pszSubKey)                       // copied from \\trango\slmadd\src\shell\shlwapi\reg.c
{
    DWORD dwRet;
    HKEY hkSubKey;

    // Open the subkey so we can enumerate any children
    dwRet = RegOpenKeyExA(hkey, pszSubKey, 0, KEY_READ | KEY_WRITE, &hkSubKey);
    if (ERROR_SUCCESS == dwRet)
    {
        DWORD   dwIndex;
        CHAR    szSubKeyName[MAX_PATH + 1];
        DWORD   cchSubKeyName = ARRAYSIZE(szSubKeyName);
        CHAR    szClass[MAX_PATH];
        DWORD   cbClass = ARRAYSIZE(szClass);

        // I can't just call RegEnumKey with an ever-increasing index, because
        // I'm deleting the subkeys as I go, which alters the indices of the
        // remaining subkeys in an implementation-dependent way.  In order to
        // be safe, I have to count backwards while deleting the subkeys.

        // Find out how many subkeys there are
        dwRet = RegQueryInfoKeyA(hkSubKey,
                                 szClass,
                                 &cbClass,
                                 NULL,
                                 &dwIndex, // The # of subkeys -- all we need
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL);

        if (NO_ERROR == dwRet)
        {
            // dwIndex is now the count of subkeys, but it needs to be
            // zero-based for RegEnumKey, so I'll pre-decrement, rather
            // than post-decrement.
            while (ERROR_SUCCESS == RegEnumKeyA(hkSubKey, --dwIndex, szSubKeyName, cchSubKeyName))
            {
                DeleteKeyRecursively(hkSubKey, szSubKeyName);
            }
        }

        RegCloseKey(hkSubKey);

        dwRet = RegDeleteKeyA(hkey, pszSubKey);
    }

    return dwRet;
}


#ifdef UNICODE
/*----------------------------------------------------------
Purpose: Deletes a registry value.  This opens and closes the
         key in which the value resides.  

         On Win95, this function thunks and calls the ansi
         version.  On NT, this function calls the unicode
         registry APIs directly.

         Perf:  if your code involves setting/getting a series
         of values in the same key, it is better to open
         the key once and set/get the values with the regular
         Win32 registry functions, rather than using this 
         function repeatedly.

Returns:
Cond:    --
*/
LocalSHDeleteValueW(
    HKEY    hkey,
    LPCWSTR pwszSubKey,
    LPCWSTR pwszValue)                       // copied from \\trango\slmadd\src\shell\shlwapi\reg.c
{
    DWORD dwRet;
    HKEY hkeyNew;

    if (g_bRunningOnNT)
    {
        dwRet = RegOpenKeyExW(hkey, pwszSubKey, 0, KEY_SET_VALUE, &hkeyNew);
        if (NO_ERROR == dwRet)
        {
            dwRet = RegDeleteValueW(hkeyNew, pwszValue);
            RegFlushKey(hkeyNew);
            RegCloseKey(hkeyNew);
        }
    }
    else
    {
        CHAR szSubKey[MAX_PATH];
        CHAR szValue[MAX_PATH];
        LPSTR pszSubKey = NULL;
        LPSTR pszValue = NULL;

        if (pwszSubKey)
        {
            WideCharToMultiByte(CP_ACP, 0, pwszSubKey, -1, szSubKey, ARRAYSIZE(szSubKey), NULL, NULL);
            pszSubKey = szSubKey;    
        }
        
        if (pwszValue)
        {
            WideCharToMultiByte(CP_ACP, 0, pwszValue, -1, szValue, ARRAYSIZE(szValue), NULL, NULL);
            pszValue = szValue;
        }

        dwRet = LocalSHDeleteValueA(hkey, pszSubKey, pszValue);
    }

    return dwRet;
}
#endif


/*----------------------------------------------------------
Purpose: Deletes a registry value.  This opens and closes the
         key in which the value resides.  

         Perf:  if your code involves setting/getting a series
         of values in the same key, it is better to open
         the key once and set/get the values with the regular
         Win32 registry functions, rather than using this 
         function repeatedly.

Returns:
Cond:    --
*/
STDAPI_(DWORD)
LocalSHDeleteValueA(
    HKEY    hkey,
    LPCSTR  pszSubKey,
    LPCSTR  pszValue)                       // copied from \\trango\slmadd\src\shell\shlwapi\reg.c
{
    DWORD dwRet;
    HKEY hkeyNew;

    dwRet = RegOpenKeyExA(hkey, pszSubKey, 0, KEY_SET_VALUE, &hkeyNew);
    if (NO_ERROR == dwRet)
    {
        dwRet = RegDeleteValueA(hkeyNew, pszValue);
        RegFlushKey(hkeyNew);
        RegCloseKey(hkeyNew);
    }
    return dwRet;
}


LPTSTR GetLogFileName(LPCTSTR pcszLogFileKeyName, LPTSTR pszLogFileName, DWORD dwSizeInChars)
{
    TCHAR szBuf[MAX_PATH];

    *pszLogFileName = TEXT('\0');
    szBuf[0] = TEXT('\0');

    // get the name for the log file
    GetProfileString(TEXT("IE4Setup"), pcszLogFileKeyName, TEXT(""), szBuf, ARRAYSIZE(szBuf));
    if (*szBuf == TEXT('\0'))                                       // check in the registry
    {
        HKEY hkSubKey;

        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\IE Setup\\Setup"), 0, KEY_READ, &hkSubKey) == ERROR_SUCCESS)
        {
            DWORD dwDataLen = sizeof(szBuf);

            RegQueryValueEx(hkSubKey, pcszLogFileKeyName, NULL, NULL, (LPBYTE) szBuf, &dwDataLen);
            RegCloseKey(hkSubKey);
        }
    }

    if (*szBuf)
    {
        // crude way of determining if fully qualified path is specified or not.
        if (szBuf[1] != TEXT(':'))
        {
            GetWindowsDirectory(pszLogFileName, dwSizeInChars);     // default to windows dir
            AddPath(pszLogFileName, szBuf);
        }
        else
            lstrcpy(pszLogFileName, szBuf);
    }

    return pszLogFileName;
}


VOID StartLogging(LPCTSTR pcszLogFileName, DWORD dwCreationFlags)
{
    if (*pcszLogFileName  &&  (g_hLogFile = CreateFile(pcszLogFileName, GENERIC_WRITE, FILE_SHARE_READ, NULL, dwCreationFlags, FILE_ATTRIBUTE_NORMAL, NULL)) != INVALID_HANDLE_VALUE)
    {
        SetFilePointer(g_hLogFile, 0, NULL, FILE_END);
        WriteToLog(TEXT("\r\n"));
        WriteToLog(TEXT("************************"));
        WriteToLog(TEXT(" Begin logging "));
        WriteToLog(TEXT("************************"));
        WriteToLog(TEXT("\r\n"));
        LogDateAndTime();
        WriteToLog(TEXT("\r\n"));
    }
}


VOID WriteToLog(LPCTSTR pcszFormatString, ...)
{
    if (g_hLogFile != INVALID_HANDLE_VALUE)
    {
        va_list vaArgs;
        LPTSTR pszFullErrMsg = NULL;
        LPSTR pszANSIFullErrMsg;
        DWORD dwBytesWritten;
#ifdef UNICODE
        DWORD dwANSILen;
#endif

        va_start(vaArgs, pcszFormatString);
        FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_STRING,
                      (LPCVOID) pcszFormatString, 0, 0, (LPTSTR) &pszFullErrMsg, 0, &vaArgs);
        va_end(vaArgs);

        if (pszFullErrMsg != NULL)
        {
#ifdef UNICODE
            dwANSILen = lstrlen(pszFullErrMsg) + 1;
            if ((pszANSIFullErrMsg = (LPSTR) LocalAlloc(LPTR, dwANSILen)) != NULL)
                WideCharToMultiByte(CP_ACP, 0, pszFullErrMsg, -1, pszANSIFullErrMsg, dwANSILen, NULL, NULL);
#else
            pszANSIFullErrMsg = pszFullErrMsg;
#endif

            if (pszANSIFullErrMsg != NULL)
            {
                WriteFile(g_hLogFile, pszANSIFullErrMsg, lstrlen(pszANSIFullErrMsg), &dwBytesWritten, NULL);
#ifdef UNICODE
                LocalFree(pszANSIFullErrMsg);
#endif
            }

            LocalFree(pszFullErrMsg);
        }
    }
}


VOID StopLogging()
{
    LogDateAndTime();
    WriteToLog(TEXT("************************"));
    WriteToLog(TEXT(" End logging "));
    WriteToLog(TEXT("************************"));
    WriteToLog(TEXT("\r\n"));

    if (g_hLogFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(g_hLogFile);
        g_hLogFile = INVALID_HANDLE_VALUE;
    }
}


VOID LogDateAndTime()
{
    if (g_hLogFile != INVALID_HANDLE_VALUE)
    {
        SYSTEMTIME SystemTime;

        GetLocalTime(&SystemTime);

        WriteToLog(TEXT("Date: %1!02d!/%2!02d!/%3!04d! (mm/dd/yyyy)\tTime: %4!02d!:%5!02d!:%6!02d! (hh:mm:ss)\r\n"),
                                        SystemTime.wMonth, SystemTime.wDay, SystemTime.wYear,
                                        SystemTime.wHour, SystemTime.wMinute, SystemTime.wSecond);
    }
}


VOID LogFlags(DWORD dwFlags)
{
    if (g_hLogFile != INVALID_HANDLE_VALUE)
    {
        WriteToLog(TEXT("RRA_DELETE = %1!lu!\r\n"), (dwFlags & RRA_DELETE) ? 1 : 0);
        WriteToLog(TEXT("RRA_WAIT = %1!lu!\r\n"), (dwFlags & RRA_WAIT) ? 1 : 0);
        WriteToLog(TEXT("RRAEX_NO_ERROR_DIALOGS = %1!lu!\r\n"), (dwFlags & RRAEX_NO_ERROR_DIALOGS) ? 1 : 0);
        WriteToLog(TEXT("RRAEX_ERRORFILE = %1!lu!\r\n"), (dwFlags & RRAEX_ERRORFILE) ? 1 : 0);
        WriteToLog(TEXT("RRAEX_LOG_FILE = %1!lu!\r\n"), (dwFlags & RRAEX_LOG_FILE) ? 1 : 0);
        WriteToLog(TEXT("RRAEX_NO_EXCEPTION_TRAPPING = %1!lu!\r\n"), (dwFlags & RRAEX_NO_EXCEPTION_TRAPPING) ? 1 : 0);
        WriteToLog(TEXT("RRAEX_NO_STATUS_DIALOG = %1!lu!\r\n"), (dwFlags & RRAEX_NO_STATUS_DIALOG) ? 1 : 0);
        WriteToLog(TEXT("RRAEX_IGNORE_REG_FLAGS = %1!lu!\r\n"), (dwFlags & RRAEX_IGNORE_REG_FLAGS) ? 1 : 0);
        WriteToLog(TEXT("RRAEX_CHECK_NT_ADMIN = %1!lu!\r\n"), (dwFlags & RRAEX_CHECK_NT_ADMIN) ? 1 : 0);
        WriteToLog(TEXT("RRAEX_QUIT_IF_REBOOT_NEEDED = %1!lu!\r\n"), (dwFlags & RRAEX_QUIT_IF_REBOOT_NEEDED) ? 1 : 0);
#if 0
        /****
        WriteToLog(TEXT("RRAEX_BACKUP_SYSTEM_DAT = %1!lu!\r\n"), (dwFlags & RRAEX_BACKUP_SYSTEM_DAT) ? 1 : 0);
        WriteToLog(TEXT("RRAEX_DELETE_SYSTEM_IE4 = %1!lu!\r\n"), (dwFlags & RRAEX_DELETE_SYSTEM_IE4) ? 1 : 0);
        ****/
#endif
#if 0
        /**** enable this when explorer.exe is fixed (bug #30866)
        WriteToLog(TEXT("RRAEX_CREATE_REGFILE = %1!lu!\r\n"), (dwFlags & RRAEX_CREATE_REGFILE) ? 1 : 0);
        ****/
#endif
    }
}



// CRT stubs
//=--------------------------------------------------------------------------=
// these two things are here so the CRTs aren't needed. this is good.
//
// basically, the CRTs define this to pull in a bunch of stuff.  we'll just
// define them here so we don't get an unresolved external.
//
// TODO: if you are going to use the CRTs, then remove this line.
//
extern "C" int _fltused = 1;

extern "C" int _cdecl _purecall(void)
{
//  FAIL("Pure virtual function called.");
  return 0;
}

void * _cdecl operator new
(
    size_t    size
)
{
    return HeapAlloc(g_hHeap, 0, size);
}

//=---------------------------------------------------------------------------=
// overloaded delete
//=---------------------------------------------------------------------------=
// retail case just uses win32 Local* heap mgmt functions
//
// Parameters:
//    void *        - [in] free me!
//
// Notes:
//
void _cdecl operator delete ( void *ptr)
{
    HeapFree(g_hHeap, 0, ptr);
}


void * _cdecl malloc(size_t n)
{
#ifdef _MALLOC_ZEROINIT
        return HeapAlloc(g_hHeap, HEAP_ZERO_MEMORY, n);
#else
        return HeapAlloc(g_hHeap, 0, n);
#endif
}

void * _cdecl calloc(size_t n, size_t s)
{
   return HeapAlloc(g_hHeap, HEAP_ZERO_MEMORY, n * s);
}

void* _cdecl realloc(void* p, size_t n)
{
        if (p == NULL)
                return malloc(n);

        return HeapReAlloc(g_hHeap, 0, p, n);
}

void _cdecl free(void* p)
{
        if (p == NULL)
                return;

        HeapFree(g_hHeap, 0, p);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\iesetup\pch.cpp ===
#include "pch.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\iesetup\fixie.cpp ===
#include "pch.h"
#include "fixie.h"

HANDLE g_hHeap                  = NULL;
HWND g_hWnd                     = NULL;
HWND g_hProgress                = NULL;
int g_nNumGuids                 = 0;
HRESULT g_hr                    = E_FAIL;
char g_szLogFileName[MAX_PATH];
LPSTORAGE     g_pIStorage       = NULL;
LPSTREAM      g_pIStream        = NULL;
DWORD g_dwPlatform              = NULL;
LCIFCOMPONENT g_pLinkCif        = NULL;

// #40352 - always repair the Icons. g_bRestoreIcons does not get changed anywhere else.
BOOL g_bRestoreIcons            = TRUE;
BOOL g_bQuiet                   = FALSE;
BOOL g_bRunningWin95;
BOOL g_bNeedReboot              = FALSE;

LPSTR g_pszError                = NULL;

// Used for the progress bar
// start and end for each section (out of 100)
int g_nVerifyAllFilesStart             =   0;
int g_nVerifyAllFilesEnd               =  10;
int g_nRunSetupCommandPreROEXStart     =  10;
int g_nRunSetupCommandPreROEXEnd       =  11;
int g_nRunSetupCommandAllROEXStart     =  11;
int g_nRunSetupCommandAllROEXEnd       =  21;
int g_nDoRunOnceExProcessStart         =  21;
int g_nDoRunOnceExProcessEnd           =  80;
int g_nRunSetupCommandAllPostROEXStart =  80;
int g_nRunSetupCommandAllPostROEXEnd   =  90;
int g_nRestoreIconsStart               =  90;
int g_nRestoreIconsEnd                 = 100;

int g_nProgressStart                   =   0;
int g_nProgressEnd                     = 100;

const char c_gszRegstrPathIExplore[]    = REGSTR_PATH_APPPATHS "\\iexplore.exe";
const char c_gszLogFileName[]           = "Fix IE Log.txt";
char g_szFixIEInf[MAX_STRING];
const char c_gszFixIEInfName[]          = "fixie.inf";
const char c_gszIERnOnceDLL[]           = "iernonce.dll";
const char c_gszMainSectionName[]       = "FixIE";
const char c_gszPreSectionName[]        = "PreROEX";

const char c_gszRegRestoreIcons[]     = "Software\\Microsoft\\Active Setup\\Installed Components";

char g_szModifiedMainSectionName[MAX_STRING];
char g_szCryptoSectionName[MAX_STRING];
const char c_gszWin95[]                 = "";
const char c_gszMillen[]                = ".Millen";
const char c_gszNTx86[]                 = ".NT";
const char c_gszW2K[]                   = ".W2K";
const char c_gszNTalpha[]               = ".Alpha";
const char c_gszCrypto[]                = ".Crypto";

LPSTR MakeAnsiStrFromWide(LPWSTR pwsz);
LPWSTR MakeWideStrFromAnsi(LPSTR psz);
void ConvertIStreamToFile(LPSTORAGE *pIStorage, LPSTREAM *pIStream);
void MakePath(LPSTR lpPath);
void LogTimeDate();
HRESULT MyRunSetupCommand(HWND hwnd, LPCSTR lpszInfFile, LPCSTR lpszSection, DWORD dwFlags);
DWORD GetStringField(LPSTR szStr, UINT uField, LPSTR szBuf, UINT cBufSize);
LPSTR FindChar(LPSTR pszStr, char ch);

// Reboot stuff
BOOL MyNTReboot();
HRESULT LaunchProcess(LPCSTR pszCmd, HANDLE *phProc, LPCSTR pszDir, UINT uShow);
BOOL MyRestartDialog(HWND hParent, BOOL bShowPrompt, UINT nIdMessage);

VOID MyConvertVersionString(LPSTR lpszVersion, LPDWORD pdwMSVer, LPDWORD pdwLSVer);
VOID MyGetVersionFromFile(LPSTR lpszFilename, LPDWORD pdwMSVer, LPDWORD pdwLSVer);
int DisplayMessage(char* pszMessage, UINT uStyle);
int LoadSz(UINT id, LPSTR pszBuf, UINT cMaxSize);
VOID GetPlatform();
BOOL CheckForNT4_SP4();
VOID GetInfFile();
VOID AddComponent(ICifComponent *pCifComp);
VOID WriteToLog(char *pszFormatString, ...);
HRESULT InitComponentList();
HRESULT VerifyAllFiles();
HRESULT RunSetupCommandPreROEX();
HRESULT RunSetupCommandAllROEX();
HRESULT RunSetupCommandAllPostROEX();
HRESULT DoRunOnceExProcess();
HRESULT RestoreIcons();
HRESULT Process();
void    AddRegMunger();

DWORD RunProcess(LPVOID lp);
INT_PTR CALLBACK DlgProcFixIE(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK DlgProcConfirm(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK DlgProcReinstall(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
void uiCenterDialog( HWND hwndDlg );
void RunOnceExProcessCallback(int nCurrent, int nMax, LPSTR pszError);
void LogError(char *pszFormatString, ...);
void VersionToString(DWORD dwMSVer, DWORD dwLSVer, LPSTR pszVersion);

HRESULT FixIE(BOOL bConfirm, DWORD dwFlags)
{
    HRESULT hr = S_OK;
    HANDLE  hMutex ;
    OSVERSIONINFO VerInfo;

    // allow only one instance running at a time
    // ALSO : mutex wrt to IESetup.EXE. Hence use specific named mutex only
    hMutex = CreateMutex(NULL, TRUE, "Ie4Setup.Mutext");
    if ((hMutex != NULL) && (GetLastError() == ERROR_ALREADY_EXISTS))
    {
        CloseHandle(hMutex);
        return S_FALSE;
    }

    VerInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&VerInfo);
    if (VerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
    {
        // If the user does not have Admin rights, bail out.
        if ( !IsNTAdmin(0, NULL))
        {
            char szMsg[MAX_STRING];

            LoadSz(IDS_NEED_ADMIN, szMsg, sizeof(szMsg));
            DisplayMessage(szMsg, MB_OK|MB_ICONEXCLAMATION);

            if (hMutex)
                CloseHandle(hMutex);

            return S_OK;
        }
    }

    if (bConfirm)
    {
        if (DialogBox(g_hInstance, MAKEINTRESOURCE(IDD_CONFIRM), NULL, DlgProcConfirm) == IDNO)
        {
            WriteToLog("\r\nUser selected not to repair.\r\n");
            if (g_pIStream)
                ConvertIStreamToFile(&g_pIStorage, &g_pIStream);

            if (hMutex)
                CloseHandle(hMutex);

            return S_OK;
        }
    }

    // #40352 - always repair Icons. No need to check if flag is set for it.
    ////////////////////////////////////////////////////////////////
    // else
    // {
    //     g_bRestoreIcons = dwFlags & FIXIE_ICONS;
    // }
    ////////////////////////////////////////////////////////////////

    if (g_bRestoreIcons)
    {
        WriteToLog("Restore icon set to true.\r\n");
    }
    else
    {
        WriteToLog("Restore icon set to false.\r\n");
    }

    if (dwFlags & FIXIE_QUIET)
    {
        g_bQuiet = TRUE;
        WriteToLog("Quiet mode on.\r\n");
    }
    else
    {
        WriteToLog("Quiet mode off.\r\n");
    }

    // Get the heap - used for HeapAlloc and HeapReAlloc
    g_hHeap = GetProcessHeap();
    InitCommonControls();

    GetPlatform();
    WriteToLog("Main section name: %1\r\n",g_szModifiedMainSectionName);

    // if running on NT5 or Millennium or
    // If NT4-SP4, don't process the Crypto files else process them too.
    if ( (g_dwPlatform == PLATFORM_MILLEN) || (g_dwPlatform == PLATFORM_NT5) ||
         ((g_dwPlatform == PLATFORM_NT4 || g_dwPlatform == PLATFORM_NT4ALPHA) && CheckForNT4_SP4()))
        
    {
        // Null string the Crypto section name
        *g_szCryptoSectionName = '\0';
        WriteToLog("No Crypto section to be processed!\r\n");
    }
    else
    {
        lstrcpy(g_szCryptoSectionName, c_gszMainSectionName);
        lstrcat(g_szCryptoSectionName, c_gszCrypto);
        WriteToLog("Crypto section name: %1\r\n",g_szCryptoSectionName);
    }

    GetInfFile();
    WriteToLog("Inf file used: %1\r\n",g_szFixIEInf);

    WriteToLog("\r\nFixIE started.\r\n\r\n");

    if (!g_bQuiet)
    {

        if (DialogBox(g_hInstance, MAKEINTRESOURCE(IDD_FIXIE), NULL, DlgProcFixIE) == -1)
        {
            WriteToLog("\r\nERROR - Display dialog failed!\r\n\r\n");
            hr = E_FAIL;
        }
        else
        {
            hr = g_hr;
        }
    }
    else
    {
        hr = Process();
    }

    if (SUCCEEDED(hr))
    {
        WriteToLog("\r\nFixIE successful!\r\n");

        // Success, so ask user to reboot
        MyRestartDialog(g_hWnd, !g_bQuiet, IDS_REBOOT);
    }
    else
    {
        WriteToLog("\r\nERROR - FixIE failed!\r\n\r\n");

        if (g_bNeedReboot)
        {
            MyRestartDialog(g_hWnd, !g_bQuiet, IDS_REBOOTFILE);
        }
        else
        {
            DialogBox(g_hInstance, MAKEINTRESOURCE(IDD_REINSTALL), NULL, DlgProcReinstall);
        }
    }

    if (g_pszError)
        HeapFree(g_hHeap,0,g_pszError);

    if (g_pIStream)
        ConvertIStreamToFile(&g_pIStorage, &g_pIStream);

    if (hMutex)
        CloseHandle(hMutex);

    return hr;
}

HRESULT Process()
{
    HRESULT hr = S_OK;

    WriteToLog("\r\nInside Process.\r\n");

    // Get all the components that are successfully installed for the current platform
    if (SUCCEEDED(hr))
    {
        hr = InitComponentList();
        if (SUCCEEDED(hr))
        {
            WriteToLog("\r\nInitComponentList succeeded!\r\n\r\n");
            WriteToLog("There are a total of %1!ld! installed components.\r\n\r\n",g_nNumGuids);
        }
        else
        {
            WriteToLog("\r\nERROR - InitComponentList failed!\r\n\r\n");
        }
    }

    // Verify all the files in the VFS sections exists and have valid version #s
    if (SUCCEEDED(hr))
    {
        hr = VerifyAllFiles();
        if (SUCCEEDED(hr))
        {
            WriteToLog("\r\nVerifyAllFiles succeeded!\r\n\r\n");
        }
        else
        {
            WriteToLog("\r\nERROR - VerifyAllFiles failed!\r\n\r\n");
        }
    }

    // Run RunSetupCommand on the PreROEX section
    if (SUCCEEDED(hr))
    {
        hr = RunSetupCommandPreROEX();
        if (SUCCEEDED(hr))
        {
            WriteToLog("\r\nRunSetupCommandPreROEX succeeded!\r\n\r\n");
        }
        else
        {
            WriteToLog("\r\nERROR - RunSetupCommandPreROEX failed!\r\n\r\n");
        }
    }

    // Run RunSetupCommand on all the ROEX sections
    if (SUCCEEDED(hr))
    {
        hr = RunSetupCommandAllROEX();
        if (SUCCEEDED(hr))
        {
            WriteToLog("\r\nRunSetupCommandAllROEX succeeded!\r\n\r\n");
        }
        else
        {
            WriteToLog("\r\nERROR - RunSetupCommandAllROEX failed!\r\n\r\n");
        }
    }

    // Call runonceexprocess
    if (SUCCEEDED(hr))
    {
        hr = DoRunOnceExProcess();
        if (SUCCEEDED(hr))
        {
            WriteToLog("\r\nDoRunOnceExProcess succeeded!\r\n\r\n");
        }
        else
        {
            WriteToLog("\r\nERROR - DoRunOnceExProcess failed!\r\n\r\n");
        }
    }

    // If there are any errors, then set hr to E_FAIL
    if (g_pszError)
        hr = E_FAIL;

    // Run RunSetupCommand on all the PostROEX sections
    if (SUCCEEDED(hr))
    {
        hr = RunSetupCommandAllPostROEX();
        if (SUCCEEDED(hr))
        {
            WriteToLog("\r\nRunSetupCommandAllPostROEX succeeded!\r\n\r\n");
        }
        else
        {
            WriteToLog("\r\nERROR - RunSetupCommandAllPostROEX failed!\r\n\r\n");
        }
    }

    // Restore icons
    if (SUCCEEDED(hr) && g_bRestoreIcons)
    {
        hr = RestoreIcons();
        if (SUCCEEDED(hr))
        {
            WriteToLog("\r\nRestoreIcons succeeded!\r\n\r\n");
        }
        else
        {
            WriteToLog("\r\nERROR - RestoreIcons failed!\r\n\r\n");
        }
    }

    return hr;
}

DWORD RunProcess(LPVOID lp)
{
    WriteToLog("\r\nInside RunProcess.\r\n");

    SendMessage(g_hProgress, PBM_SETRANGE, 0, MAKELPARAM(g_nProgressStart, g_nProgressEnd));
    SendMessage(g_hProgress, PBM_SETPOS, g_nProgressStart, 0);

    g_hr = Process();

    SendMessage(g_hProgress, PBM_SETPOS, g_nProgressEnd, 0);

    // terminate the dialog box
    PostMessage((HWND) lp, WM_FINISHED, 0, 0L);

    return 0;
}

INT_PTR CALLBACK DlgProcConfirm(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        uiCenterDialog(hWnd);
        g_hWnd = hWnd;
        break;

    case WM_COMMAND:
        switch( wParam )
        {
        case IDYES:
        case IDNO:
            // #40352 - Icon check box no longer exists. Always repair icons.
            // g_bRestoreIcons = (IsDlgButtonChecked(hWnd, IDC_REPAIR_ICONS) == BST_CHECKED);
            g_hWnd = NULL;
            EndDialog(hWnd, wParam);
            break;

        case IDCANCEL:
            g_hWnd = NULL;
            EndDialog(hWnd, IDNO);
            break;

        default:
            return FALSE;
        }
        break;

    default:
        return(FALSE);
    }
    return(TRUE);
}

INT_PTR CALLBACK DlgProcReinstall(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static LPSTR pszMessage;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        uiCenterDialog(hWnd);
        if (!g_pszError)
        {
            EnableWindow(GetDlgItem(hWnd, IDC_DETAILS), FALSE);
        }
        else
        {
            char szString[MAX_STRING];

            LoadSz(IDS_FOLLOWINGERROR, szString, sizeof(szString));
            pszMessage = (LPSTR)HeapAlloc(g_hHeap, 0, lstrlen(g_pszError) + sizeof(szString) + 1);

            lstrcpy(pszMessage, szString);
            lstrcat(pszMessage, g_pszError);
        }
        g_hWnd = hWnd;
        break;

    case WM_COMMAND:
        switch( wParam )
        {
        case IDOK:
        case IDCANCEL:
            g_hWnd = NULL;
            HeapFree(g_hHeap, 0, pszMessage);
            EndDialog(hWnd, wParam);
            break;

        case IDC_DETAILS:
            // Display failure messages.
            char szTitle[MAX_STRING];
            GetWindowText(hWnd, szTitle, sizeof(szTitle));
            MessageBox(hWnd, pszMessage, szTitle, MB_OK);
            break;

        default:
            return FALSE;
        }
        break;

    default:
        return(FALSE);
    }
    return(TRUE);
}

INT_PTR CALLBACK DlgProcFixIE(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static HANDLE s_hThread = NULL;
    DWORD dwThread;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        uiCenterDialog(hWnd);
        g_hWnd = hWnd;
        g_hProgress = GetDlgItem(hWnd, IDC_PROGRESS);

        if ((s_hThread = CreateThread(NULL, 0, RunProcess, (LPVOID) hWnd, 0, &dwThread)) == NULL)
            PostMessage(hWnd, WM_FINISHED, 0, 0L);

        break;

    case WM_FINISHED:
        if (s_hThread != NULL)
        {
            while (MsgWaitForMultipleObjects(1, &s_hThread, FALSE, INFINITE, QS_ALLINPUT) != WAIT_OBJECT_0)
            {
                MSG msg;

                while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
                {
                    TranslateMessage(&msg);
                    DispatchMessage(&msg);
                }
            }

            CloseHandle(s_hThread);
            s_hThread = NULL;
        }
        g_hWnd = NULL;
        EndDialog(hWnd, 0);
        break;

    default:
        return(FALSE);
    }
    return(TRUE);
}

void RunOnceExProcessCallback(int nCurrent, int nMax, LPSTR pszError)
{
    int nStart = g_nDoRunOnceExProcessStart;
    int nEnd = g_nDoRunOnceExProcessEnd;

    WriteToLog("Current=%1!ld! ; Max=%2!ld! ; Error=%3\r\n", nCurrent, nMax, pszError);

    if (g_hProgress && nMax)
    {
        SendMessage(g_hProgress, PBM_SETPOS, nStart+(nEnd-nStart)*nCurrent/nMax, 0);
    }

    if (pszError)
    {
        LogError(pszError);
    }
}

void LogError(char *pszFormatString, ...)
{
    va_list args;
    char *pszFullErrMsg   = NULL;
    LPSTR pszErrorPreFail = NULL;

    // If error string does not exist, then malloc it
    if (!g_pszError)
    {
        g_pszError = (LPSTR)HeapAlloc(g_hHeap, 0, BUFFERSIZE);
		if ( ! g_pszError )
			return; // Is it OK to fail quietly here ?
        *g_pszError = '\0';
    }

    va_start(args, pszFormatString);
    FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_STRING,
        (LPCVOID) pszFormatString, 0, 0, (LPTSTR) &pszFullErrMsg, 0, &args);
    if (pszFullErrMsg)
    {
        // Make room for new string and newline
        while (lstrlen(g_pszError)+lstrlen(pszFullErrMsg)+2>(int)HeapSize(g_hHeap, 0, g_pszError))
        {
            WriteToLog("Error string size is %1!ld!", HeapSize(g_hHeap, 0, g_pszError));
            pszErrorPreFail = g_pszError;
#pragma prefast(suppress: 308, "PREfast noise - pointer was saved")
            g_pszError = (LPSTR)HeapReAlloc(g_hHeap, 0, g_pszError, HeapSize(g_hHeap, 0, g_pszError)+BUFFERSIZE);
            if(!g_pszError)
            {
                if (pszErrorPreFail)
                    HeapFree(g_hHeap, 0, pszErrorPreFail);
                break;
            }

            WriteToLog(", increasing it to %1!ld!\r\n", HeapSize(g_hHeap, 0, g_pszError));
        }

		if ( g_pszError )
		{
			// Add string and then add newline
			lstrcat(g_pszError, pszFullErrMsg);
			lstrcat(g_pszError, "\n");
		}

        LocalFree(pszFullErrMsg);
    }
}

HRESULT RestoreIcons()
{
    HRESULT hr = S_OK;

    const char szIEAccess[] = "Software\\Microsoft\\Active Setup\\Installed Components\\>{26923b43-4d38-484f-9b9e-de460746276c}";
    int nStart = g_nRestoreIconsStart;
    int nEnd = g_nRestoreIconsEnd;

    int nCurGuid = 0;

    LCIFCOMPONENT pComp = g_pLinkCif;

    char szKey[MAX_PATH];
    lstrcpy(szKey, c_gszRegRestoreIcons);
    char* pszEnd = szKey + lstrlen(szKey);

    while (pComp && SUCCEEDED(hr))
    {
        // Add guid to end
        AddPath(szKey, pComp->szGuid);

        // Delete key
        if (RegDeleteKey(HKEY_CURRENT_USER, szKey) == ERROR_SUCCESS)
        {
            WriteToLog("Reg key HKCU\\%1 deleted\r\n", szKey);
        }
        else
        {
            WriteToLog("Reg key HKCU\\%1 cannot be deleted\r\n", szKey);
        }

        // Remove the guid
        *pszEnd = '\0';

        nCurGuid++;
        if (g_hProgress)
            SendMessage(g_hProgress, PBM_SETPOS, nStart+(nEnd-nStart)*nCurGuid/g_nNumGuids, 0);

        pComp = pComp->next;
    }

    RegDeleteKey(HKEY_CURRENT_USER, szIEAccess);

    return hr;
}

HRESULT DoRunOnceExProcess()
{
    HRESULT hr = E_FAIL;

    int nStart = g_nDoRunOnceExProcessStart;
    int nEnd = g_nDoRunOnceExProcessEnd;

    // Load iernonce.dll
    HINSTANCE hIERnOnceDLL;
    char szDLLPath[MAX_PATH];
    GetSystemDirectory(szDLLPath, sizeof(szDLLPath));
    AddPath(szDLLPath, c_gszIERnOnceDLL);
    hIERnOnceDLL = LoadLibrary(szDLLPath);

    if (hIERnOnceDLL)
    {
        RUNONCEEXPROCESS fpRunOnceExProcess;
        INITCALLBACK fpInitCallback;

        // Add callback and set to quiet
        if (fpInitCallback = (INITCALLBACK)GetProcAddress(hIERnOnceDLL, achInitCallback))
        {
            fpInitCallback(&RunOnceExProcessCallback, TRUE);
        }
        else
        {
            WriteToLog("\r\nERROR - GetProcAddress on %1 failed!\r\n\r\n", achInitCallback);
        }

        // Run RunOnceExProcess
        if (fpRunOnceExProcess = (RUNONCEEXPROCESS)GetProcAddress(hIERnOnceDLL, achRunOnceExProcess))
        {
            hr = fpRunOnceExProcess(g_hWnd, NULL, NULL, 1);
        }
        else
        {
            WriteToLog("\r\nERROR - GetProcAddress on %1 failed!\r\n\r\n", achRunOnceExProcess);
        }

        FreeLibrary(hIERnOnceDLL);
    }
    else
    {
        WriteToLog("\r\nERROR - %1 cannot be loaded!\r\n\r\n", szDLLPath);
    }

    if (g_hProgress)
        SendMessage(g_hProgress, PBM_SETPOS, nEnd, 0);

    return hr;
}

HRESULT RunSetupCommandPreROEX()
{
    HRESULT hr = S_OK;

    int nStart = g_nRunSetupCommandPreROEXStart;
    int nEnd = g_nRunSetupCommandPreROEXEnd;

    hr = MyRunSetupCommand(g_hWnd, g_szFixIEInf, c_gszPreSectionName, 0);

    if (g_hProgress)
        SendMessage(g_hProgress, PBM_SETPOS, nEnd, 0);

    return hr;
}

HRESULT RunSetupCommandAllPostROEX()
{
    HRESULT hr = S_OK;

    int nStart = g_nRunSetupCommandAllPostROEXStart;
    int nEnd = g_nRunSetupCommandAllPostROEXEnd;

    int nCurGuid = 0;

    LCIFCOMPONENT pComp = g_pLinkCif;

    while (pComp && SUCCEEDED(hr))
    {
        if ( *(pComp->szPostROEX) != '\0')
            hr = MyRunSetupCommand(g_hWnd, g_szFixIEInf, pComp->szPostROEX, 0);

        nCurGuid++;
        if (g_hProgress)
            SendMessage(g_hProgress, PBM_SETPOS, nStart+(nEnd-nStart)*nCurGuid/g_nNumGuids, 0);

        pComp = pComp->next;
    }

    return hr;
}

HRESULT RunSetupCommandAllROEX()
{
    HRESULT hr = S_OK;

    int nStart = g_nRunSetupCommandAllROEXStart;
    int nEnd = g_nRunSetupCommandAllROEXEnd;

    int nCurGuid = 0;

    LCIFCOMPONENT pComp = g_pLinkCif;

    while (pComp && SUCCEEDED(hr))
    {
        if ( *(pComp->szROEX) != '\0')
            hr = MyRunSetupCommand(g_hWnd, g_szFixIEInf, pComp->szROEX, 0);

        nCurGuid++;
        if (g_hProgress)
            SendMessage(g_hProgress, PBM_SETPOS, nStart+(nEnd-nStart)*nCurGuid/g_nNumGuids, 0);

        pComp = pComp->next;
    }

    return hr;
}

HRESULT VerifyAllFiles()
{
    HRESULT hr = S_OK;
    char szError[MAX_STRING];

    int nStart = g_nVerifyAllFilesStart;
    int nEnd = g_nVerifyAllFilesEnd;

    int nCurGuid = 0;

    LCIFCOMPONENT pComp = g_pLinkCif;

    char szMessage[MAX_STRING];
    char  szLocation[MAX_PATH];
    GetSystemDirectory(szLocation, sizeof(szLocation));
    char *pTmp = szLocation + lstrlen(szLocation);

    LPSTR lpVFSSection = NULL;
    while (pComp)
    {
        lpVFSSection = (LPSTR)LocalAlloc(LPTR, MAX_CONTENT);

        if(!lpVFSSection) {
            return E_FAIL;
        }

        WriteToLog("Looking up %1...\r\n", pComp->szVFS);

        if (GetPrivateProfileSection(pComp->szVFS, lpVFSSection, MAX_CONTENT, g_szFixIEInf))
        {
            LPSTR lpVFSLine = lpVFSSection;
            while (*lpVFSLine)
            {
                int nLength = lstrlen(lpVFSLine);

                // Need to allow new-line comments.
                if ( *lpVFSLine == ';' )
                {
                    lpVFSLine += nLength + 1;
                    continue;    // Go on with next iteration of the WHILE loop
                }

                WriteToLog("  Verifying %1\r\n", lpVFSLine);

                char szFile[MAX_STRING];

                // Find '=' so that file and versions can be seperated
                char* pChar;
                pChar = ANSIStrChr(lpVFSLine, '=');

                // if can't find '=' or '=' is last character then make sure file exists
                if (!pChar || (*(pChar+1)=='\0'))
                {
                    // Kill the '=' if it exists
                    if (pChar)
                        *pChar = '\0';

                    // Get the filename
                    lstrcpy(szFile, lpVFSLine);

                    // Add the filename to the path
                    AddPath(szLocation, szFile);

                    // If can't find file, then set error
                    if (GetFileAttributes(szLocation) == 0xFFFFFFFF)
                    {
                        hr = E_FAIL;

                        if (GetLastError() == ERROR_FILE_NOT_FOUND)
                        {
                            WriteToLog("   ERROR - File %1 does not exist.\r\n", szFile);
                            LoadSz(IDS_FILEMISSING, szError, sizeof(szError));
                            LogError(szError, szFile);
                        }
                        else
                        {
                            WriteToLog("   ERROR - File %1 exists but cannot be accessed.\r\n", szFile);
                            LoadSz(IDS_FILELOCKED, szError, sizeof(szError));
                            LogError(szError, szFile);
                            g_bNeedReboot = TRUE;
                        }
                    }
                    else
                    {
                        WriteToLog("   File %1 exists.\r\n", szFile);
                    }

                    // Reset the location to just the path again
                    *pTmp = '\0';
                }
                else // Make sure version in the given limits
                {
                    *pChar = '\0';
                    pChar++;

                    // Get the filename
                    lstrcpy(szFile, lpVFSLine);

                    DWORD   dwMSVer;
                    DWORD   dwLSVer;

                    // Add the filename to the path
                    AddPath(szLocation, szFile);
                    // Get the version of that file
                    MyGetVersionFromFile(szLocation, &dwMSVer, &dwLSVer);

                    // If file cannot be read then report error
                    if (dwMSVer==0 && dwLSVer==0 && GetFileAttributes(szLocation) == 0xFFFFFFFF)
                    {
                        hr = E_FAIL;

                        if (GetLastError() == ERROR_FILE_NOT_FOUND)
                        {
                            WriteToLog("   ERROR - File %1 does not exist.\r\n", szFile);
                            LoadSz(IDS_FILEMISSING, szError, sizeof(szError));
                            LogError(szError, szFile);
                        }
                        else
                        {
                            WriteToLog("   ERROR - File %1 exists but cannot be accessed.\r\n", szFile);
                            LoadSz(IDS_FILELOCKED, szError, sizeof(szError));
                            LogError(szError, szFile);
                            g_bNeedReboot = TRUE;
                        }
                    }
                    else
                    {
                        // Find '-' so that if there are more than one versions then they are seperated
                        char* pChar2;
                        pChar2 = ANSIStrChr(pChar, '-');
                        if (pChar2)
                        {
                            BOOL bVerifyError = FALSE;
                            char szVersionFound[MAX_VER];
                            char szVersionLow[MAX_VER];
                            char szVersionHigh[MAX_VER];
                            VersionToString(dwMSVer, dwLSVer, szVersionFound);

                            *pChar2 = '\0';
                            pChar2++;

                            // pChar points to first version
                            // pChar2 points to second version

                            // '-' found
                            // so it's one of: xxxx- ; -xxxx ; xxxx-xxxx
                            if (lstrlen(pChar)) // Low version exists
                            {
                                DWORD   dwMSVerLow = 0;
                                DWORD   dwLSVerLow = 0;
                                MyConvertVersionString(pChar, &dwMSVerLow, &dwLSVerLow);
                                VersionToString(dwMSVerLow, dwLSVerLow, szVersionLow);

                                // Make sure this version is greater than low version
                                if ((dwMSVerLow<dwMSVer) || ((dwMSVerLow==dwMSVer) && (dwLSVerLow<=dwLSVer)))
                                {
                                }
                                else
                                {
                                    bVerifyError = TRUE;
                                }
                            }

                            if (lstrlen(pChar2)) // High version exists
                            {
                                DWORD   dwMSVerHigh = 0;
                                DWORD   dwLSVerHigh = 0;
                                MyConvertVersionString(pChar2, &dwMSVerHigh, &dwLSVerHigh);
                                VersionToString(dwMSVerHigh, dwLSVerHigh, szVersionHigh);

                                // Make sure this version is lesser than high version
                                if ((dwMSVerHigh>dwMSVer) || ((dwMSVerHigh==dwMSVer) && (dwLSVerHigh>=dwLSVer)))
                                {
                                }
                                else
                                {
                                    bVerifyError = TRUE;
                                }
                            }

                            if (bVerifyError)
                            {
                                WriteToLog("   ERROR - File %1 (version %2) version check failed.\r\n", szFile, szVersionFound);
                                hr = E_FAIL;

                                if (lstrlen(pChar)&&lstrlen(pChar2))
                                {
                                    LoadSz(IDS_VERSIONINBETWEEN, szError, sizeof(szError));
                                    LogError(szError, szVersionFound, szFile, szVersionLow, szVersionHigh);
                                }
                                else if (lstrlen(pChar))
                                {
                                    LoadSz(IDS_VERSIONGREATER, szError, sizeof(szError));
                                    LogError(szError, szVersionFound, szFile, szVersionLow);
                                }
                                else if (lstrlen(pChar2))
                                {
                                    LoadSz(IDS_VERSIONLESS, szError, sizeof(szError));
                                    LogError(szError, szVersionFound, szFile, szVersionHigh);
                                }
                            }
                            else
                            {
                                WriteToLog("   File %1 version checked.\r\n", szFile);
                            }
                        }
                        else // no '-' is found
                        {
                            // so it's a unique version
                            // the current version must be exact
                            DWORD   dwMSVerExact = 0;
                            DWORD   dwLSVerExact = 0;
                            MyConvertVersionString(pChar, &dwMSVerExact, &dwLSVerExact);

                            char szVersionFound[MAX_VER];
                            char szVersionRequired[MAX_VER];
                            VersionToString(dwMSVer, dwLSVer, szVersionFound);
                            VersionToString(dwMSVerExact, dwLSVerExact, szVersionRequired);

                            // If it is not an exact match then signal error occured
                            if ((dwMSVerExact==dwMSVer) && (dwLSVerExact==dwLSVer))
                            {
                                WriteToLog("   File %1 version checked.\r\n", szFile);
                            }
                            else
                            {
                                WriteToLog("   ERROR - File %1 (version %2) version check failed.\r\n", szFile, szVersionFound);
                                LoadSz(IDS_VERSIONEXACT, szError, sizeof(szError));
                                LogError(szError, szVersionFound, szFile, szVersionRequired);
                                hr = E_FAIL;
                            }
                        }
                    }
                    // Reset the location to just the path again
                    *pTmp = '\0';
                }
                lpVFSLine += nLength + 1;
            }
        }

        nCurGuid++;
        if (g_hProgress)
            SendMessage(g_hProgress, PBM_SETPOS, nStart+(nEnd-nStart)*nCurGuid/g_nNumGuids, 0);

        pComp = pComp->next;
    }

    if (lpVFSSection)
        LocalFree(lpVFSSection);

    return hr;
}

void VersionToString(DWORD dwMSVer, DWORD dwLSVer, LPSTR pszVersion)
{
    wsprintf(pszVersion, "%d.%d.%d.%d", HIWORD(dwMSVer), LOWORD(dwMSVer), HIWORD(dwLSVer), LOWORD(dwLSVer));
}


VOID GetInfFile()
{
    DWORD dwType;
    DWORD dwSize = sizeof(g_szFixIEInf);
    HKEY hKey;

    *g_szFixIEInf = '\0';
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_gszRegstrPathIExplore, 0, KEY_QUERY_VALUE, &hKey) == ERROR_SUCCESS)
    {
        if ((RegQueryValueEx(hKey, NULL, 0, &dwType, (LPBYTE)g_szFixIEInf, &dwSize) == ERROR_SUCCESS) && (dwType == REG_SZ))
        {
            GetParentDir(g_szFixIEInf);
        }
        RegCloseKey(hKey);
    }

    AddPath(g_szFixIEInf, c_gszFixIEInfName);
}

VOID GetPlatform()
{
    LPCSTR        pTemp = NULL;
    OSVERSIONINFO VerInfo;
    VerInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&VerInfo);

    lstrcpy(g_szModifiedMainSectionName, c_gszMainSectionName);

    if (VerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
    {
        // Running NT
        g_bRunningWin95 = FALSE;

        SYSTEM_INFO System_info;
        GetSystemInfo(&System_info);
        if (System_info.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_ALPHA)
        {
            g_dwPlatform = PLATFORM_NT5ALPHA;
            if (VerInfo.dwMajorVersion == 4)
                g_dwPlatform = PLATFORM_NT4ALPHA;
            pTemp = c_gszNTalpha;
        }
        else
        {
            g_dwPlatform = PLATFORM_NT5;
            pTemp = c_gszW2K;
            if (VerInfo.dwMajorVersion == 4)
            {
                g_dwPlatform = PLATFORM_NT4;
                pTemp = c_gszNTx86;
            }
        }
    }
    else
    {
        // Running Windows 9x
        // Assume Win98
        g_bRunningWin95 = TRUE;

        g_dwPlatform = PLATFORM_WIN98;
        pTemp = c_gszWin95;
        if (VerInfo.dwMinorVersion == 0)
        {
            g_dwPlatform = PLATFORM_WIN95;
        }
        else if (VerInfo.dwMinorVersion == 90)
        {
            pTemp = c_gszMillen;
            g_dwPlatform = PLATFORM_MILLEN;
        }
    }
    if (pTemp)
        lstrcat(g_szModifiedMainSectionName, pTemp);
}

#define REGSTR_CCS_CONTROL_WINDOWS  REGSTR_PATH_CURRENT_CONTROL_SET "\\WINDOWS"
#define CSDVERSION      "CSDVersion"
#define NTSP4_VERSION   0x0600
// version updated to SP6!

BOOL CheckForNT4_SP4()
{
    HKEY    hKey;
    DWORD   dwCSDVersion;
    DWORD   dwSize;
    BOOL    bNTSP4 = -1;

    if ( bNTSP4 == -1)
    {
        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_CCS_CONTROL_WINDOWS, 0, KEY_QUERY_VALUE, &hKey) == ERROR_SUCCESS)
        {
            // assign the default
            bNTSP4 = FALSE;
            dwSize = sizeof(dwCSDVersion);
            if (RegQueryValueEx(hKey, CSDVERSION, NULL, NULL, (unsigned char*)&dwCSDVersion, &dwSize) == ERROR_SUCCESS)
            {
                bNTSP4 = (LOWORD(dwCSDVersion) >= NTSP4_VERSION);
            }
            RegCloseKey(hKey);
        }
    }
    return bNTSP4;
}


HRESULT InitComponentList()
{
    HRESULT hr = E_FAIL;

    ICifFile *pCifFile = NULL;
    IEnumCifComponents *pEnumCifComponents = NULL;
    ICifComponent *pCifComponent = NULL;

    hr = GetICifFileFromFile(&pCifFile, "iesetup.cif");
    if (SUCCEEDED(hr))
    {
        hr = pCifFile->EnumComponents(&pEnumCifComponents, g_dwPlatform , NULL);
        if (SUCCEEDED(hr))
        {
            while (pEnumCifComponents->Next(&pCifComponent) == S_OK)
            {
                if (pCifComponent->IsComponentInstalled() == ICI_INSTALLED)
                    AddComponent(pCifComponent);
            }
            pEnumCifComponents->Release();
        }
        else
        {
            WriteToLog("\r\nERROR - Cannot pCifFile->EnumComponents!\r\n\r\n");
        }
        pCifFile->Release();
    }
    else
    {
        WriteToLog("\r\nERROR - Cannot GetICifFileFromFile!\r\n\r\n");
    }

    return hr;
}


VOID AddLink(LPSTR szGuid, ICifComponent *pCifComp, LPSTR szGuidProfileString)
{
    char            szID[MAX_STRING];
    LCIFCOMPONENT   pComp;
    char            *pStart = szGuidProfileString;
    char            *pChar;
    LCIFCOMPONENT   pTemp = g_pLinkCif;
    LCIFCOMPONENT   pLast = NULL;

    pCifComp->GetID(szID, sizeof(szID));
    WriteToLog("Add component %1 with GUID %2\r\n", szID, szGuid);

    // Initialize all the members of the new LCIFCOMPONENT link.
    pComp = (LCIFCOMPONENT)LocalAlloc(LPTR, sizeof(LINKEDCIFCOMPONENT));
    pComp->pCifComponent = pCifComp;
    lstrcpy(pComp->szGuid, szGuid);
    *(pComp->szVFS) = '\0';
    *(pComp->szROEX) = '\0';
    *(pComp->szPostROEX) = '\0';
    pComp->next = NULL;


    GetStringField(szGuidProfileString, 0, pComp->szVFS, sizeof(pComp->szVFS));
    GetStringField(szGuidProfileString, 1, pComp->szROEX, sizeof(pComp->szROEX));
    GetStringField(szGuidProfileString, 2, pComp->szPostROEX, sizeof(pComp->szPostROEX));

    WriteToLog("   VFS = %1\r\n",pComp->szVFS);
    WriteToLog("   ROEX = %1\r\n", pComp->szROEX);
    WriteToLog("   PostROEX = %1\r\n", pComp->szPostROEX);

    // Add the new link to the linklist pointed to be g_pLinkCif
    while (pTemp)
    {
        pLast = pTemp;
        pTemp = pTemp->next;
    }

    if (pLast)
        pLast->next = pComp;
    else
        g_pLinkCif = pComp;

    // Increment global count of number of guids
    g_nNumGuids++;

    if (pTemp)
    {
        pComp->next = pTemp;
    }
}


VOID AddComponent(ICifComponent *pCifComp)
{
    char szGuid[MAX_STRING];
    if (SUCCEEDED(pCifComp->GetGUID(szGuid, sizeof(szGuid))))
    {
        char szGuidProfileString[MAX_STRING];
        if (GetPrivateProfileString(g_szModifiedMainSectionName, szGuid, "", szGuidProfileString, sizeof(szGuidProfileString), g_szFixIEInf))
        {
            AddLink(szGuid, pCifComp, szGuidProfileString);
        }

        // If a valid Crypto section exists, process this GUID entry under it too.
        if ( *g_szCryptoSectionName )
        {
            if (GetPrivateProfileString(g_szCryptoSectionName, szGuid, "", szGuidProfileString, sizeof(szGuidProfileString), g_szFixIEInf))
            {
                AddLink(szGuid, pCifComp, szGuidProfileString);
            }
        }
    }
}

VOID MyConvertVersionString(LPSTR lpszVersion, LPDWORD pdwMSVer, LPDWORD pdwLSVer)
{
    WORD wVer[4];

    ConvertVersionString(lpszVersion, wVer, '.' );
    *pdwMSVer = (DWORD)wVer[0] << 16;    // Make hi word of MS version
    *pdwMSVer += (DWORD)wVer[1];         // Make lo word of MS version
    *pdwLSVer = (DWORD)wVer[2] << 16;    // Make hi word of LS version
    *pdwLSVer += (DWORD)wVer[3];         // Make lo word of LS version

}

VOID MyGetVersionFromFile(LPSTR lpszFilename, LPDWORD pdwMSVer, LPDWORD pdwLSVer)
{
    unsigned    uiSize;
    DWORD       dwVerInfoSize;
    DWORD       dwHandle;
    VS_FIXEDFILEINFO * lpVSFixedFileInfo;
    void FAR   *lpBuffer;
    LPVOID      lpVerBuffer;

    *pdwMSVer = *pdwLSVer = 0L;

    dwVerInfoSize = GetFileVersionInfoSize(lpszFilename, &dwHandle);
    if (dwVerInfoSize)
    {
        // Alloc the memory for the version stamping
        lpBuffer = LocalAlloc(LPTR, dwVerInfoSize);
        if (lpBuffer)
        {
            // Read version stamping info
            if (GetFileVersionInfo(lpszFilename, dwHandle, dwVerInfoSize, lpBuffer))
            {
                // Get the value for Translation
                if (VerQueryValue(lpBuffer, "\\", (LPVOID*)&lpVSFixedFileInfo, &uiSize) &&
                    (uiSize))

                {
                    *pdwMSVer = lpVSFixedFileInfo->dwFileVersionMS;
                    *pdwLSVer = lpVSFixedFileInfo->dwFileVersionLS;
                }
            }
            LocalFree(lpBuffer);
        }
    }
    return ;
}

VOID WriteToLog(char *pszFormatString, ...)
{
    va_list args;
    char *pszFullErrMsg = NULL;
    DWORD dwBytesWritten;

    if (!g_pIStream)
    {
        char szTmp[MAX_PATH];
        LPWSTR  pwsz = NULL;

        if (GetWindowsDirectory(g_szLogFileName, sizeof(g_szLogFileName)))
        {
            AddPath(g_szLogFileName, c_gszLogFileName);
            if (GetFileAttributes(g_szLogFileName) != 0xFFFFFFFF)
            {
                // Make a backup of the current log file
                lstrcpyn(szTmp, g_szLogFileName, lstrlen(g_szLogFileName) - 2 );    // don't copy extension
                lstrcat(szTmp, "BAK");
                SetFileAttributes(szTmp, FILE_ATTRIBUTE_NORMAL);
                DeleteFile(szTmp);
                MoveFile(g_szLogFileName, szTmp);
            }

            pwsz = MakeWideStrFromAnsi(g_szLogFileName);

            if ((pwsz) &&
                (!FAILED(StgCreateDocfile(pwsz,
                STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                0, &g_pIStorage))) )
            {
                g_pIStorage->CreateStream( L"CONTENTS",
                    STGM_READWRITE| STGM_SHARE_EXCLUSIVE,
                    0, 0, &g_pIStream );

                if (g_pIStream == NULL)
                {
                    // Could not open the stream, close the storage and delete the file
                    g_pIStorage->Release();
                    g_pIStorage = NULL;
                    DeleteFile(g_szLogFileName);
                }
            }

            if (pwsz)
                CoTaskMemFree(pwsz);

            WriteToLog("Logging information for FixIE ...\r\n");
            LogTimeDate();
            WriteToLog("\r\n");
        }
    }

    if (g_pIStream)
    {
        va_start(args, pszFormatString);
        FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_STRING,
            (LPCVOID) pszFormatString, 0, 0, (LPTSTR) &pszFullErrMsg, 0, &args);
        if (pszFullErrMsg)
        {
            g_pIStream->Write(pszFullErrMsg, lstrlen(pszFullErrMsg), &dwBytesWritten);
            LocalFree(pszFullErrMsg);
        }
    }
}

void ConvertIStreamToFile(LPSTORAGE *pIStorage, LPSTREAM *pIStream)
{
    HANDLE  fh;
    char szTempFile[MAX_PATH];      // Should use the logfilename
    LPVOID lpv = NULL;
    LARGE_INTEGER li;
    DWORD   dwl;
    ULONG   ul;
    HRESULT hr;

    lstrcpy (szTempFile, g_szLogFileName);
    MakePath(szTempFile);
    if (GetTempFileName(szTempFile, "~VS", 0, szTempFile) != 0)
    {
        fh = CreateFile(szTempFile, GENERIC_READ|GENERIC_WRITE,
            0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if (fh != INVALID_HANDLE_VALUE)
        {
            lpv = (LPSTR)LocalAlloc(LPTR, BUFFERSIZE);
            if (lpv)
            {
                LISet32(li, 0);
                (*pIStream)->Seek(li, STREAM_SEEK_SET, NULL); // Set the seek pointer to the beginning
                do
                {
                    hr = (*pIStream)->Read(lpv, BUFFERSIZE, &ul);
                    if(SUCCEEDED(hr))
                    {
                        if (!WriteFile(fh, lpv, ul, &dwl, NULL))
                            hr = E_FAIL;
                    }
                }
                while ((SUCCEEDED(hr)) && (ul == BUFFERSIZE));
                LocalFree(lpv);
            }
            CloseHandle(fh);
            // Need to release stream and storage to close the storage file.
            (*pIStream)->Release();
            (*pIStorage)->Release();
            *pIStream = NULL;
            *pIStorage = NULL;

            if (SUCCEEDED(hr))
            {
                DeleteFile(g_szLogFileName);
                MoveFile(szTempFile, g_szLogFileName);
            }
        }
    }
    if (*pIStream)
    {
        // If we did not manage to convert the file to a text file
        (*pIStream)->Release();
        (*pIStorage)->Release();
        *pIStream = NULL;
        *pIStorage = NULL;
    }

    return ;
}

LPWSTR MakeWideStrFromAnsi(LPSTR psz)
{
    LPWSTR pwsz;
    int i;

    // arg checking.
    //
    if (!psz)
        return NULL;

    // compute the length
    //
    i =  MultiByteToWideChar(CP_ACP, 0, psz, -1, NULL, 0);
    if (i <= 0) return NULL;

    pwsz = (LPWSTR) CoTaskMemAlloc(i * sizeof(WCHAR));

    if (!pwsz) return NULL;
    MultiByteToWideChar(CP_ACP, 0, psz, -1, pwsz, i);
    pwsz[i - 1] = 0;
    return pwsz;
}

LPSTR MakeAnsiStrFromWide(LPWSTR pwsz)
{
    LPSTR psz;
    int i;

    // arg checking.
    //
    if (!pwsz)
        return NULL;

    // compute the length
    //
    i =  WideCharToMultiByte(CP_ACP, 0, pwsz, -1, NULL, 0, NULL, NULL);
    if (i <= 0) return NULL;

    psz = (LPSTR) CoTaskMemAlloc(i * sizeof(CHAR));

    if (!psz) return NULL;
    WideCharToMultiByte(CP_ACP, 0, pwsz, -1, psz, i, NULL, NULL);
    psz[i - 1] = 0;
    return psz;
}

void MakePath(LPSTR lpPath)
{
    LPSTR lpTmp;
    lpTmp = CharPrev( lpPath, lpPath+lstrlen(lpPath));

    // chop filename off
    //
    while ( (lpTmp > lpPath) && *lpTmp && (*lpTmp != '\\') )
        lpTmp = CharPrev( lpPath, lpTmp );

    if ( *CharPrev( lpPath, lpTmp ) != ':' )
        *lpTmp = '\0';
    else
        *CharNext( lpTmp ) = '\0';
    return;
}

void LogTimeDate()
{
    SYSTEMTIME  SystemTime;
    GetLocalTime(&SystemTime);

    WriteToLog("Date:%1!d!/%2!d!/%3!d! (M/D/Y) Time:%4!d!:%5!d!:%6!d!\r\n",
        SystemTime.wMonth, SystemTime.wDay, SystemTime.wYear,
        SystemTime.wHour, SystemTime.wMinute, SystemTime.wSecond);
}

HRESULT MyRunSetupCommand(HWND hwnd, LPCSTR lpszInfFile, LPCSTR lpszSection, DWORD dwFlags)
{
    HRESULT hr = E_FAIL;

    char szSourceDir[MAX_PATH];
    lstrcpy(szSourceDir, lpszInfFile);
    GetParentDir(szSourceDir);

    WriteToLog("Run setup command. File:%1: Section:%2:\r\n",lpszInfFile, lpszSection);

    dwFlags |= (RSC_FLAG_INF | RSC_FLAG_NGCONV | RSC_FLAG_QUIET);

    hr = RunSetupCommand(hwnd, lpszInfFile, lpszSection, szSourceDir, NULL, NULL, dwFlags, NULL);

    WriteToLog("RunSetupCommand returned :%1!lx!:\r\n", hr);

    if (!SUCCEEDED(hr))
        WriteToLog("\r\nERROR - RunSetupCommand failed\r\n\r\n");

    return hr;
}

void uiCenterDialog( HWND hwndDlg )
{
    RECT    rc;
    RECT    rcScreen;
    int     x, y;
    int     cxDlg, cyDlg;
    int     cxScreen;
    int     cyScreen;

    SystemParametersInfo(SPI_GETWORKAREA, 0, &rcScreen, 0);

    cxScreen = rcScreen.right - rcScreen.left;
    cyScreen = rcScreen.bottom - rcScreen.top;

    GetWindowRect(hwndDlg,&rc);

    x = rc.left;    // Default is to leave the dialog where the template
    y = rc.top;     //  was going to place it.

    cxDlg = rc.right - rc.left;
    cyDlg = rc.bottom - rc.top;

    y = rcScreen.top + ((cyScreen - cyDlg) / 2);
    x = rcScreen.left + ((cxScreen - cxDlg) / 2);

    // Position the dialog.
    //
    SetWindowPos(hwndDlg, NULL, x, y, 0, 0, SWP_NOSIZE | SWP_NOACTIVATE);
}

BOOL MyNTReboot()
{
    HANDLE hToken;
    TOKEN_PRIVILEGES tkp;

    // get a token from this process
    if ( !OpenProcessToken( GetCurrentProcess(),
        TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken ) )
    {
        return FALSE;
    }

    // get the LUID for the shutdown privilege
    LookupPrivilegeValue( NULL, SE_SHUTDOWN_NAME, &tkp.Privileges[0].Luid );

    tkp.PrivilegeCount = 1;
    tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    //get the shutdown privilege for this proces
    if (!AdjustTokenPrivileges(hToken, FALSE, &tkp, 0, (PTOKEN_PRIVILEGES)NULL, 0))
    {
        return FALSE;
    }

    // shutdown the system and force all applications to close
    if (!ExitWindowsEx( EWX_REBOOT, 0 ) )
    {
        return FALSE;
    }

    return TRUE;
}

HRESULT LaunchProcess(LPCSTR pszCmd, HANDLE *phProc, LPCSTR pszDir, UINT uShow)
{
    STARTUPINFO startInfo;
    PROCESS_INFORMATION processInfo;
    HRESULT hr = S_OK;
    BOOL fRet;

    if(phProc)
        *phProc = NULL;

    // Create process on pszCmd
    ZeroMemory(&startInfo, sizeof(startInfo));
    startInfo.cb = sizeof(startInfo);
    startInfo.dwFlags |= STARTF_USESHOWWINDOW;
    startInfo.wShowWindow = (USHORT)uShow;
    fRet = CreateProcess(NULL, (LPSTR)  pszCmd, NULL, NULL, FALSE,
        NORMAL_PRIORITY_CLASS, NULL, pszDir, &startInfo, &processInfo);
    if(!fRet)
        return E_FAIL;

    if(phProc)
        *phProc = processInfo.hProcess;
    else
        CloseHandle(processInfo.hProcess);

    CloseHandle(processInfo.hThread);

    return S_OK;
}

#define SOFTBOOT_CMDLINE   "softboot.exe /s:,60"

// Display a dialog asking the user to restart Windows, with a button that
// will do it for them if possible.
//
BOOL MyRestartDialog(HWND hParent, BOOL bShowPrompt, UINT nIdMessage)
{
    char szBuf[MAX_STRING];
    char szTitle[MAX_STRING];
    UINT    id = IDYES;

    if(bShowPrompt)
    {
        LoadSz(IDS_TITLE, szTitle, sizeof(szTitle));
        LoadSz(nIdMessage, szBuf, sizeof(szBuf));
        id = MessageBox(hParent, szBuf, szTitle, MB_ICONQUESTION | MB_YESNO | MB_TASKMODAL | MB_SETFOREGROUND);
    }

    if ( id == IDYES )
    {
        // path to softboot plus a little slop for the command line
        char szBuf[MAX_PATH + 10];
        szBuf[0] = 0;

        GetSystemDirectory(szBuf, sizeof(szBuf));
        AddPath(szBuf, SOFTBOOT_CMDLINE);
        if(FAILED(LaunchProcess(szBuf, NULL, NULL, SW_SHOWNORMAL)))
        {
            if(g_bRunningWin95)
            {
                ExitWindowsEx( EWX_REBOOT , 0 );
            }
            else
            {
                MyNTReboot();
            }
        }

    }
    return (id == IDYES);
}

int LoadSz(UINT id, LPSTR pszBuf, UINT cMaxSize)
{
    if(cMaxSize == 0)
        return 0;

    pszBuf[0] = 0;

    return LoadString(g_hInstance, id, pszBuf, cMaxSize);
}

DWORD GetStringField(LPSTR szStr, UINT uField, LPSTR szBuf, UINT cBufSize)
{
   LPSTR pszBegin = szStr;
   LPSTR pszEnd;
   UINT i = 0;
   DWORD dwToCopy;

   if(cBufSize == 0)
       return 0;

   szBuf[0] = 0;

   if(szStr == NULL)
      return 0;

   while(*pszBegin != 0 && i < uField)
   {
      pszBegin = FindChar(pszBegin, ',');
      if(*pszBegin != 0)
         pszBegin++;
      i++;
   }

   // we reached end of string, no field
   if(*pszBegin == 0)
   {
      return 0;
   }


   pszEnd = FindChar(pszBegin, ',');
   while(pszBegin <= pszEnd && *pszBegin == ' ')
      pszBegin++;

   while(pszEnd > pszBegin && *(pszEnd - 1) == ' ')
      pszEnd--;

   if(pszEnd > (pszBegin + 1) && *pszBegin == '"' && *(pszEnd-1) == '"')
   {
      pszBegin++;
      pszEnd--;
   }

   dwToCopy = (DWORD)(pszEnd - pszBegin + 1);

   if(dwToCopy > cBufSize)
      dwToCopy = cBufSize;

   lstrcpynA(szBuf, pszBegin, dwToCopy);

   return dwToCopy - 1;
}

LPSTR FindChar(LPSTR pszStr, char ch)
{
   while( *pszStr != 0 && *pszStr != ch )
      pszStr++;
   return pszStr;
}

int DisplayMessage(char* pszMessage, UINT uStyle)
{
    int iReturn = 0;
    if (!g_bQuiet)
    {
        char szTitle[MAX_STRING];
        LoadSz(IDS_TITLE, szTitle, sizeof(szTitle));
        iReturn = MessageBox(g_hWnd, pszMessage, szTitle, uStyle);
    }

    return iReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\iesetup\iesetup.h ===
extern HINSTANCE g_hInstance;

void AddRegMunger();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\iesetup\guids.cpp ===
#include "pch.h"

#define INITGUID
#include <initguid.h>

#include "inseng.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\iesetup\makefile.inc ===
clean:
    -del /F /Q $(O)\selfreg_iesetup.inf


!if "$(BUILD_PRODUCT)" == "NT"
$(O)\selfreg_iesetup.inf: selfreg.inx
    cl -nologo -D_MSC_VER=1000  -DNASHVILLE=1 -DBUILD_PRODUCT=1 -I $(SDK_INC_PATH) -FI $(SDK_INC_PATH)\ntverp.h -FI ..\ie40\html\ieverdef.h -EP -Tc$** > $@
!else
$(O)\selfreg_iesetup.inf: selfreg.inx
    cl -nologo -D_MSC_VER=1000  -DNASHVILLE=1 -I $(SDK_INC_PATH) -FI $(SDK_INC_PATH)\ntverp.h -FI ..\ie40\html\ieverdef.h -EP -Tc$** > $@
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\iesetup\fixie.h ===
#include "inseng.h"
#include "advpub.h"
#include "iesetup.h"
#include "resource.h"
#include <regstr.h>

extern HINSTANCE g_hInstance;

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */
HRESULT FixIE(BOOL bConfirm, DWORD dwFlags);
#ifdef __cplusplus
}
#endif /* __cplusplus */

#define WM_FINISHED             (WM_USER + 0x123)

#define MAX_STRING      1024
#define MAX_VER           64
#define MAX_CONTENT   0x7fff
#define BUFFERSIZE      1024

#define FIXIE_NORMAL    0x00000000
#define FIXIE_QUIET     0x00000001
#define FIXIE_ICONS     0x00000002

typedef struct _LINKEDCIFCOMPONENT
{
    ICifComponent *pCifComponent;
    char szGuid[MAX_STRING];
    char szVFS[MAX_STRING];
    char szROEX[MAX_STRING];
    char szPostROEX[MAX_STRING];
    struct _LINKEDCIFCOMPONENT *next;
} LINKEDCIFCOMPONENT, *LCIFCOMPONENT;

// ENTRY POINT FOR IERNONCE.DLL

#define achRunOnceExProcess "RunOnceExProcess"

void WINAPI RunOnceExProcess(HWND hWnd, HINSTANCE hInstance, LPSTR lpCmdLine, int nCmdShow);

typedef HRESULT (WINAPI *RUNONCEEXPROCESS)
(
 HWND hWnd,
 HINSTANCE hInstance,
 LPSTR lpCmdLine,
 int nCmdShow
 );


typedef VOID (*RUNONCEEXPROCESSCALLBACK)
(
 int nCurrent,
 int nMax,
 LPSTR pszError
 );

#define achInitCallback "InitCallback"

void WINAPI InitCallback(RUNONCEEXPROCESSCALLBACK pCallbackProc, BOOL bQuiet);

typedef VOID (WINAPI *INITCALLBACK)
(
 RUNONCEEXPROCESSCALLBACK pCallbackProc,
 BOOL bQuiet
 );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\iesetup\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by iesetup.rc
//
#define IDD_FIXIE                       1
#define IDS_TITLE                       1
#define IDD_CONFIRM                     2
#define IDS_REBOOT                      2
#define IDS_FOLLOWINGERROR              3
#define IDD_REINSTALL                   3
#define IDS_CANTFIX                     4
#define IDS_REINSTALL                   5
#define IDS_REBOOTFILE                  6
#define IDS_FILEMISSING                 7
#define IDC_PROGRESS                    8
#define IDS_FILELOCKED                  8
#define IDC_REPAIR_ICONS                9
#define IDS_VERSIONINBETWEEN            9
#define IDS_VERSIONGREATER              10
#define IDS_VERSIONLESS                 11
#define IDS_VERSIONEXACT                12
#define IDS_NEED_ADMIN                  13
#define IDI_INETCPL                     102
#define IDC_DETAILS                     1001
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1002
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\iesetup\pch.h ===
#include <windows.h>
#include <commctrl.h>
#include "sdsutils.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\iesetup\iodver.cpp ===
//=--------------------------------------------------------------------------=
// iodver.cpp
//=--------------------------------------------------------------------------=
// Copyright 1997-1998 Microsoft Corporation.  All Rights Reserved.
//
//
//

#include "string.h"
#include "pch.h"
#include "advpub.h"
#include "iesetup.h"
#include <inetreg.h>
#include <shlwapi.h>
#include <wininet.h>

WINUSERAPI HWND    WINAPI  GetShellWindow(void);

HINSTANCE g_hInstance = NULL;

STDAPI_(BOOL) DllMain(HANDLE hDll, DWORD dwReason, void *lpReserved)
{
   DWORD dwThreadID;

   switch(dwReason)
   {
      case DLL_PROCESS_ATTACH:
         g_hInstance = (HINSTANCE)hDll;
         break;

      case DLL_PROCESS_DETACH:
         break;

      default:
         break;
   }
   return TRUE;
}

STDAPI DllRegisterServer(void)
{
    // BUGBUG: pass back return from RegInstall ?
    RegInstall(g_hInstance, "DllReg", NULL);

    return S_OK;
}

STDAPI DllUnregisterServer(void)
{
    RegInstall(g_hInstance, "DllUnreg", NULL);

    return S_OK;
}

BOOL IsWinNT4()
{
    OSVERSIONINFO VerInfo;
    VerInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&VerInfo);

    if (VerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
    {
         return (VerInfo.dwMajorVersion == 4) ;
    }

    return FALSE;
}

BOOL IsWinXP()
{
    OSVERSIONINFO VerInfo;
    VerInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&VerInfo);

    if (VerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
    {
         return (VerInfo.dwMajorVersion > 5) || 
            (VerInfo.dwMajorVersion == 5 && VerInfo.dwMinorVersion >= 1);
    }

    return FALSE;
}

STDAPI DllInstall(BOOL bInstall, LPCWSTR lpCmdLine)
{
    // BUGBUG: pass back return from RegInstall ?
    if (bInstall)
    {
        RegInstall(g_hInstance, "DllUninstall", NULL);
        if(IsWinNT4())
            RegInstall(g_hInstance, "DllInstall.NT4Only", NULL);
        else if(IsWinXP())
            RegInstall(g_hInstance, "DllInstall.WinXP", NULL);
        else
            RegInstall(g_hInstance, "DllInstall", NULL);
    }
    else
        RegInstall(g_hInstance, "DllUninstall", NULL);

    return S_OK;
}

const TCHAR * const szAdvPack = TEXT("advpack.dll");
const TCHAR * const szExecuteCab = TEXT("ExecuteCab");
const TCHAR * const szKeyComponentAdmin = TEXT("Software\\Microsoft\\Active Setup\\Installed Components\\{A509B1A7-37EF-4b3f-8CFC-4F3A74704073}");
const TCHAR * const szKeyComponentUser  = TEXT("Software\\Microsoft\\Active Setup\\Installed Components\\{A509B1A8-37EF-4b3f-8CFC-4F3A74704073}");
char szSectionHardenAdmin[]   = "IEHardenAdmin";
char szSectionSoftenAdmin[]   = "IESoftenAdmin";
char szSectionHardenUser[]   = "IEHardenUser";
char szSectionSoftenUser[]   = "IESoftenUser";
char szSectionHardenMachine[]   = "IEHardenMachine";
char szSectionSoftenMachine[]   = "IESoftenMachine";
const TCHAR * const szLocale = TEXT("Locale");
const TCHAR * const szVersion = TEXT("Version");

//Copy data from HKLM to HKCU
HRESULT CopyRegValue(LPCTSTR szSubKey, LPCTSTR szValue)
{
    BYTE buffer[128];
    HKEY hKeyDst = NULL, hKeySrc = NULL;
    HRESULT hResult;
    DWORD dwSize = sizeof(buffer);
    
    hResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szSubKey, 0, KEY_QUERY_VALUE, &hKeySrc);
    if (FAILED(hResult))
        goto Cleanup;

    hResult = RegQueryValueEx(hKeySrc, szValue, NULL, NULL, (LPBYTE)buffer, &dwSize);
    if (FAILED(hResult))
        goto Cleanup;

    hResult = RegCreateKeyEx(HKEY_CURRENT_USER, szSubKey, 0, NULL, 
            REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hKeyDst, NULL);
    if (FAILED(hResult))
        goto Cleanup;

    hResult = RegSetValueEx(hKeyDst, szValue, NULL, REG_SZ, (CONST BYTE *)buffer, dwSize);

Cleanup:
    if (hKeySrc)
        RegCloseKey(hKeySrc);
    
    if (hKeyDst)
        RegCloseKey(hKeyDst);

    return hResult;
}

BOOL IsNtSetupRunning()
{
    HKEY hKey;
    long lRes = RegOpenKeyExW(HKEY_LOCAL_MACHINE, L"system\\Setup",
                    0, KEY_READ, &hKey);
    if(lRes)
        return false;

    DWORD dwSetupRunning;
    DWORD dwLen = sizeof(DWORD);
    lRes = RegQueryValueExW(hKey, L"SystemSetupInProgress", NULL, NULL,
                (LPBYTE)&dwSetupRunning, &dwLen);
    RegCloseKey(hKey);

    if(lRes == ERROR_SUCCESS && (dwSetupRunning == 1))
    {
        return true;
    }
    return false;
}

// Return value: 1: Installed. 0: Uninstalled. -1: Not installed (component does not exist in registry)
int IsInstalled(const TCHAR * const szKeyComponent)
{
    const TCHAR *szIsInstalled = TEXT("IsInstalled");
    int bInstalled = -1;
    DWORD dwValue, dwSize;
    HKEY hKey;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, szKeyComponent, 0, KEY_READ, &hKey) == ERROR_SUCCESS)
    {
        dwSize = sizeof(dwValue);
        if (RegQueryValueEx( hKey, szIsInstalled, NULL, NULL, (LPBYTE)&dwValue, &dwSize) != ERROR_SUCCESS)
        {
            dwValue = 0;
        }
        bInstalled = (dwValue != 0);

        RegCloseKey(hKey);
    }
    //else Not installed.

    return bInstalled;
}

//Get the inf file from system32 and run this section
HRESULT RunInfSection(const char * const szInfFile, const char * const szSection)
{
    CABINFO CabInfo;
    char szInfPathName[MAX_PATH];
    HRESULT hResult;
    
    memset(&CabInfo, 0, sizeof(CabInfo));

    GetSystemDirectory(szInfPathName, sizeof(szInfPathName));
    AddPath(szInfPathName, szInfFile);
    CabInfo.pszInf = szInfPathName;
    CabInfo.dwFlags = ALINF_QUIET;
    CabInfo.pszSection = (PSTR)szSection;

    hResult = ExecuteCab(NULL, &CabInfo, NULL);

    return hResult;
}

HRESULT RunPerUserInfSection(char * szSection)
{
    HRESULT hResult;

    hResult = RunInfSection("ieuinit.inf", szSection);

    return hResult;
}

const char * const szRegValueDefaultHomepage = "Default_Page_URL";

void GetOEMDefaultPageURL(LPTSTR szURL, DWORD cbData)
{
    const TCHAR * const szIEDefaultPageURL = "http://www.microsoft.com/isapi/redir.dll?prd=ie&pver=6&ar=msnhome";
    const TCHAR * const szIEStartPage = "http://www.microsoft.com/isapi/redir.dll?prd={SUB_PRD}&clcid={SUB_CLSID}&pver={SUB_PVER}&ar=home";

    szURL[0] = 0;
    if (ERROR_SUCCESS == SHRegGetUSValue(REGSTR_PATH_MAIN, szRegValueDefaultHomepage, NULL, 
                (LPVOID)szURL, &cbData, TRUE, NULL, NULL))
    {
        if (0 == StrCmpI(szURL, szIEDefaultPageURL))
        {
            //Ignore the default page url set by in.inf
            szURL[0] = 0;
        }
    }

    if (szURL[0] == 0)
    {
        if (ERROR_SUCCESS == SHRegGetUSValue(REGSTR_PATH_MAIN, REGSTR_VAL_STARTPAGE, NULL, 
                    (LPVOID)szURL, &cbData, TRUE, NULL, NULL))
        {
            if (0 == StrCmpI(szURL, szIEStartPage))
            {
                //Ignore the start page url set by shdocvw.dll selfreg.inf
                szURL[0] = 0;
            }
        }
    }

}

//Set IE Hardening hompage, when there is no OEM customized default homepage URL.
HRESULT SetIEHardeningHomepage()
{
    const char * const szHomePageFileName = "homepage.inf";
    HRESULT hResult = S_OK;
    TCHAR szOEMHomepage[INTERNET_MAX_URL_LENGTH] = "";
    DWORD cbOEMHomepage;

    cbOEMHomepage = sizeof(szOEMHomepage);
    GetOEMDefaultPageURL(szOEMHomepage, cbOEMHomepage);

    if (szOEMHomepage[0])
    {
        return hResult;
    }

    if (IsNTAdmin(0, NULL))
    {
        switch (IsInstalled(szKeyComponentAdmin))
        {
            case 1:
                hResult = RunInfSection(szHomePageFileName, "Install.HardenAdmin");
                break;
            case 0:
                hResult = RunInfSection(szHomePageFileName, "Install.SoftenAdmin");
                break;
        }
    }
    else
    {
        switch (IsInstalled(szKeyComponentUser))
        {
            case 1:
                hResult = RunInfSection(szHomePageFileName, "Install.HardenUser");
                break;
            case 0:
                hResult = RunInfSection(szHomePageFileName, "Install.SoftenUser");
                break;
        }
    }

    return hResult;
}

//Set the homepage for IE peruser stub
HRESULT WINAPI SetFirstHomepage()
{
    HRESULT hResult = S_OK;
    TCHAR szOEMHomepage[INTERNET_MAX_URL_LENGTH] = "";
    DWORD cbOEMHomepage;
    HKEY hKey;

    cbOEMHomepage = sizeof(szOEMHomepage);
    GetOEMDefaultPageURL(szOEMHomepage, cbOEMHomepage);

    if (szOEMHomepage[0])
    {
        //Delete the Default_Page_URL in HKCU
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, REGSTR_PATH_MAIN, 0, KEY_SET_VALUE, &hKey))
        {
            RegDeleteValue(hKey, szRegValueDefaultHomepage);
            RegCloseKey(hKey);
        }

        hResult = S_OK;
    }
    else
    {
        hResult = SetIEHardeningHomepage();
    }

    return hResult;
}

// Forward declaration:
HRESULT WINAPI IEHardenMachineNow(HWND, HINSTANCE, PSTR pszCmd, INT);

HRESULT WINAPI IEHardenAdmin(HWND, HINSTANCE, PSTR pszCmd, INT)
{
    HRESULT hr = S_OK;
    
    if (IsNTAdmin(0, NULL))
    {
        switch (IsInstalled(szKeyComponentAdmin))
        {
            case 1:
                if(SUCCEEDED(hr = RunPerUserInfSection(szSectionHardenAdmin)))
                {
                    // Harden the machine:
                    hr = IEHardenMachineNow(NULL, NULL, "i", 0);
                }
                break;
            case 0:
                if(SUCCEEDED(hr = RunPerUserInfSection(szSectionSoftenAdmin)))
                {
                    // Soften the machine only if both user and admin are softened:
                    hr = IEHardenMachineNow(NULL, NULL, "u", 0);
                }

                break;
            default:
                hr = E_FAIL;
        }

        if (SUCCEEDED(hr))
        {
            hr = SetIEHardeningHomepage();
        }
    }

    return hr;
}

HRESULT WINAPI IEHardenAdminNow(HWND, HINSTANCE, PSTR, INT)
{
    HRESULT hr = S_OK;
    if (!IsNtSetupRunning())
    {
        hr = IEHardenAdmin(NULL, NULL, NULL, 0);
        if (SUCCEEDED(hr))
        {
            CopyRegValue(szKeyComponentAdmin, szLocale);
            CopyRegValue(szKeyComponentAdmin, szVersion);
        }
    }

    return hr;
}

HRESULT WINAPI IEHardenUser(HWND, HINSTANCE, PSTR pszCmd, INT)
{
    HRESULT hr = S_OK;
    
    if (!IsNTAdmin(0, NULL))
    {
        switch (IsInstalled(szKeyComponentUser))
        {
            case 1:
                hr = RunPerUserInfSection(szSectionHardenUser);
                break;
            case 0:
                hr = RunPerUserInfSection(szSectionSoftenUser);
                break;
            default:
                hr = E_FAIL;
        }

        if (SUCCEEDED(hr))
        {
            hr = SetIEHardeningHomepage();
        }
    }

    return hr;
}

HRESULT WINAPI IEHardenMachineNow(HWND, HINSTANCE, PSTR pszCmd, INT)
{
    HRESULT hr = E_INVALIDARG;

    // Set per-machine inetcpl default settings according to user, not admin
    // Requires the command line because this may run during NT setup.
    
    if (pszCmd)
    {
        //Install or Uninstall
        if (pszCmd[0] == 'i' || pszCmd[0] == 'I')
            hr = RunPerUserInfSection(szSectionHardenMachine);
        else if (pszCmd[0] == 'u' || pszCmd[0] == 'U')
        {
            // Soften the machine only if both user and admin are softened:
            if (1 != IsInstalled(szKeyComponentAdmin) && 1 != IsInstalled(szKeyComponentUser))
                hr = RunPerUserInfSection(szSectionSoftenMachine);
            else
                hr = S_OK;
        }
    }
    
    return hr;
}

//=--------------------------------------------------------------------------=
// CRT stubs
//=--------------------------------------------------------------------------=
// these two things are here so the CRTs aren't needed. this is good.
//
// basically, the CRTs define this to pull in a bunch of stuff.  we'll just
// define them here so we don't get an unresolved external.
//
// TODO: if you are going to use the CRTs, then remove this line.
//
extern "C" int _fltused = 1;

extern "C" int _cdecl _purecall(void)
{
//  FAIL("Pure virtual function called.");
  return 0;
}

#ifndef _X86_
extern "C" void _fpmath() {}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\inc\autoobj.h ===
//=--------------------------------------------------------------------------=
// AutoObj.H
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// all of our objects will inherit from this class to share as much of the same
// code as possible.  this super-class contains the unknown and dispatch
// implementations for them.
//
#ifndef _AUTOOBJ_H_

// all automation objects will use the Unknown object that supports aggegation.
//
#include "Unknown.H"

//=--------------------------------------------------------------------------=
// the constants in this header file uniquely identify your automation objects.
// make sure that for each object you have in the g_ObjectInfo table, you have
// a constant in this header file.
//
#include "LocalSrv.H"
#include "extobj.h"

//=--------------------------------------------------------------------------=
// AUTOMATIONOBJECTINFO
//=--------------------------------------------------------------------------=
// for each automation object type you wish to expose to the programmer/user
// that is not a control, you must fill out one of these structures.  if the
// object isn't CoCreatable, then the first four fields should be empty.
// otherwise, they should be filled in with the appropriate information.
// use the macro DEFINE_AUTOMATIONOBJECT to both declare and define your object.
// make sure you have an entry in the global table of objects, g_ObjectInfo
// in the main .Cpp file for your InProc server.
//
typedef struct {

    UNKNOWNOBJECTINFO unknowninfo;               // fill in with 0's if we're not CoCreatable
    long         lVersion;                       // Version number of Object.  ONLY USE IF YOU'RE CoCreatable!
    const IID   *riid;                           // object's type
    LPCSTR       pszHelpFile;                    // the helpfile for this automation object.
    ITypeInfo   *pTypeInfo;                      // typeinfo for this object
    UINT         cTypeInfo;                      // number of refs to the type info

} AUTOMATIONOBJECTINFO;

// macros to manipulate the AUTOMATIONOBJECTINFO in the global table table.
//
#define VERSIONOFOBJECT(index)         ((AUTOMATIONOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)->lVersion
#define INTERFACEOFOBJECT(index)       *(((AUTOMATIONOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)->riid)
#define PPTYPEINFOOFOBJECT(index)      &((((AUTOMATIONOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)->pTypeInfo))
#define PTYPEINFOOFOBJECT(index)       ((AUTOMATIONOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)->pTypeInfo
#define CTYPEINFOOFOBJECT(index)       ((AUTOMATIONOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)->cTypeInfo
#define HELPFILEOFOBJECT(index)        ((AUTOMATIONOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)->pszHelpFile


#ifndef INITOBJECTS

#define DEFINE_AUTOMATIONOBJECT(name, clsid, objname, fn, ver, riid, pszh) \
extern AUTOMATIONOBJECTINFO name##Object \

#else
#define DEFINE_AUTOMATIONOBJECT(name, clsid, objname, fn, ver, riid, pszh) \
    AUTOMATIONOBJECTINFO name##Object = { { clsid, objname, fn }, ver, riid, pszh, NULL, 0} \

#endif // INITOBJECTS

//=--------------------------------------------------------------------------=
// Standard Dispatch and SupportErrorInfo
//=--------------------------------------------------------------------------=
// all objects should declare these in their class definitions so that they
// get standard implementations of IDispatch and ISupportErrorInfo.
//
#define DECLARE_STANDARD_DISPATCH() \
    STDMETHOD(GetTypeInfoCount)(UINT *pctinfo) { \
        return CAutomationObject::GetTypeInfoCount(pctinfo); \
    } \
    STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo **ppTypeInfoOut) { \
        return CAutomationObject::GetTypeInfo(itinfo, lcid, ppTypeInfoOut); \
    } \
    STDMETHOD(GetIDsOfNames)(REFIID riid, OLECHAR **rgszNames, UINT cnames, LCID lcid, DISPID *rgdispid) { \
        return CAutomationObject::GetIDsOfNames(riid, rgszNames, cnames, lcid, rgdispid); \
    } \
    STDMETHOD(Invoke)(DISPID dispid, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pVarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr) { \
        return CAutomationObject::Invoke(dispid, riid, lcid, wFlags, pdispparams, pVarResult, pexcepinfo, puArgErr); \
    } \


#define DECLARE_STANDARD_SUPPORTERRORINFO() \
    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid) { \
        return CAutomationObject::InterfaceSupportsErrorInfo(riid); \
    } \

enum {EXPANDO_DISABLED=FALSE, EXPANDO_ENABLED=TRUE};

//=--------------------------------------------------------------------------=
// CAutomationObject
//=--------------------------------------------------------------------------=
// global class that all automation objects can inherit from to give them a
// bunch of implementation for free, namely IDispatch and ISupportsErrorInfo
//
//
class CAutomationObject : public CUnknownObject {

  public:
    // aggreation query interface support
    //
    virtual HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    // IDispatch methods
    //
    STDMETHOD(GetTypeInfoCount)(UINT *);
    STDMETHOD(GetTypeInfo)(UINT, LCID, ITypeInfo **);
    STDMETHOD(GetIDsOfNames)(REFIID, OLECHAR **, UINT, LCID, DISPID *);
    STDMETHOD(Invoke)(DISPID, REFIID, LCID, WORD, DISPPARAMS *, VARIANT *, EXCEPINFO *, UINT *);

    //  ISupportErrorInfo methods
    //
    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID);

    CAutomationObject(IUnknown *, int , void *, BOOL fExpandoEnabled=FALSE);
    virtual ~CAutomationObject();

    // callable functions -- things that most people will find useful.
    //
    virtual HINSTANCE GetResourceHandle(void);
    HRESULT Exception(HRESULT hr, WORD idException, DWORD dwHelpContextID);

  protected:
    // member variables that derived objects might need to get at information in the
    // global object table
    //
    int   m_ObjectType;

  private:
    // member variables we don't share.
    //
    BYTE  m_fLoadedTypeInfo;
	BYTE  m_fExpandoEnabled;
	CExpandoObject* m_pexpando;
};


#define _AUTOOBJ_H_
#endif // _AUTOOBJ_H_



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\inc\debug.h ===
//=--------------------------------------------------------------------------=
// Debug.H
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains the various macros and the like which are only useful in DEBUG
// builds
//
#ifndef _DEBUG_H_

//=---------------------------------------------------------------------------=
// all the things required to handle our ASSERT mechanism
//=---------------------------------------------------------------------------=
//
#if DEBUG

// Function Prototypes
//
VOID DisplayAssert(LPSTR pszMsg, LPSTR pszAssert, LPSTR pszFile, UINT line);

// Macros
//
// *** Include this macro at the top of any source file using *ASSERT*() macros ***
//
#define SZTHISFILE	static char _szThisFile[] = __FILE__;


// our versions of the ASSERT and FAIL macros.
//
#define ASSERT(fTest, szMsg)                                \
    if (!(fTest))  {                                        \
        static char szMsgCode[] = szMsg;                    \
        static char szAssert[] = #fTest;                    \
        DisplayAssert(szMsgCode, szAssert, _szThisFile, __LINE__); \
    }

#define FAIL(szMsg)                                         \
        { static char szMsgCode[] = szMsg;                    \
        DisplayAssert(szMsgCode, "FAIL", _szThisFile, __LINE__); }



// macro that checks a pointer for validity on input
//
#define CHECK_POINTER(val) if (!(val) || IsBadWritePtr((void *)(val), sizeof(void *))) return E_POINTER

#else  // DEBUG

#define SZTHISFILE
#define ASSERT(fTest, err)
#define FAIL(err)

#define CHECK_POINTER(val)
#endif	// DEBUG




#define _DEBUG_H_
#endif // _DEBUG_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\inc\ctrlobj.h ===
//=--------------------------------------------------------------------------=
// CtrlObj.H
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// class declaration for the COleControl object
//
#ifndef _CTRLOBJ_H_

// we need the automation object and ctlole.h
//
#include "AutoObj.H"
#include <olectl.h>

// forward declaration
//
class COleControl;

//=--------------------------------------------------------------------------=
// Misc Helper Functions
//=--------------------------------------------------------------------------=
//
// given an Unknown pointer, get the COleControl * for it.  used typically
// in property page code.
//
COleControl *ControlFromUnknown(IUnknown *);


//=--------------------------------------------------------------------------=
// Misc Constants
//=--------------------------------------------------------------------------=
// maximum number of arguments that can be sent to FireEvent()
//
#define MAX_ARGS    32

// for the types of sinks that the COleControl class has.  you shouldn't ever
// need to use these
//
#define SINK_TYPE_EVENT      0
#define SINK_TYPE_PROPNOTIFY 1

// superclass window support.  you can pass this in to DoSuperClassPaint
//
#define DRAW_SENDERASEBACKGROUND        1

//=--------------------------------------------------------------------------=
// Various Hosts don't handle OLEIVERB_PROPERTIES correctly, so we can't use
// that as our Properties verb number.  Instead, we're going to define
// CTLIVERB_PROPERTIES as 1, and return that one in IOleObject::EnumVerbs,
// but we'll still handle OLEIVERB_PROPERTIES correctly in DoVerb.
//
#define CTLIVERB_PROPERTIES     1


//=--------------------------------------------------------------------------=
// this structure is like the OLEVERB structure, except that it has a resource ID
// instead of a string for the verb's name.  better support for localization.
//
typedef struct tagVERBINFO {

    LONG    lVerb;                // verb id
    ULONG   idVerbName;           // resource ID of verb name
    DWORD   fuFlags;              // verb flags
    DWORD   grfAttribs;           // Specifies some combination of the verb attributes in the OLEVERBATTRIB enumeration.

} VERBINFO;

// describes an event
//
typedef struct tagEVENTINFO {

    DISPID    dispid;                    // dispid of the event
    int       cParameters;               // number of arguments to the event
    VARTYPE  *rgTypes;                   // type of each argument

} EVENTINFO;

//=--------------------------------------------------------------------------=
// CONTROLOBJECTINFO
//=--------------------------------------------------------------------------=
// for each control you wish to expose to the programmer/user, you need to
// declare and define one of the following structures.  the first part should
// follow the rules of the AUTOMATIONOBJECTINFO structure.  it's pretty hard,
// however, to imagine a scenario where the control isn't CoCreatable ...
// once this structre is declared/defined, an entry should be put in the
// global g_ObjectInfo table.
//
typedef struct {

    AUTOMATIONOBJECTINFO AutomationInfo;           // automation and creation information
    const IID      *piidEvents;                    // IID of primary event interface
    DWORD           dwOleMiscFlags;                // control flags
    DWORD           dwActivationPolicy;            // IPointerInactive support
    VARIANT_BOOL    fOpaque;                       // is your control 100% opaque?
    VARIANT_BOOL    fWindowless;                   // do we do windowless if we can?
    WORD            wToolboxId;                    // resource ID of Toolbox Bitmap
    LPCSTR          szWndClass;                    // name of window control class
    VARIANT_BOOL    fWindowClassRegistered;        // has the window class been registered yet?
    WORD            cPropPages;                    // number of property pages
    const GUID    **rgPropPageGuids;               // array of the property page GUIDs
    WORD            cCustomVerbs;                  // number of custom verbs
    const VERBINFO *rgCustomVerbs;                 // description of custom verbs
    WNDPROC         pfnSubClass;                   // for subclassed controls.

} CONTROLOBJECTINFO;


#ifndef INITOBJECTS

#define DEFINE_CONTROLOBJECT(name, clsid, progid, fn, ver, riid, pszh, piide, dwcf, dwap, w, szwc, cpp, rgppg, ccv, rgcv) \
extern CONTROLOBJECTINFO name##Control \

#define DEFINE_WINDOWLESSCONTROLOBJECT(name, clsid, progid, fn, ver, riid, pszh, piide, dwcf, dwap, fo,  w, szwc, cpp, rgppg, ccv, rgcv) \
extern CONTROLOBJECTINFO name##Control \


#else
#define DEFINE_CONTROLOBJECT(name, clsid, progid, fn, ver, riid, pszh, piide, dwcf, dwap, w, szwc, cpp, rgppg, ccv, rgcv) \
CONTROLOBJECTINFO name##Control = { { {clsid, progid, fn}, ver, riid, pszh, NULL, 0}, piide, dwcf, dwap, TRUE, FALSE, w, szwc, FALSE, cpp, rgppg, ccv, rgcv, NULL } \

#define DEFINE_WINDOWLESSCONTROLOBJECT(name, clsid, progid, fn, ver, riid, pszh, piide, dwcf, dwap, fo, w, szwc, cpp, rgppg, ccv, rgcv) \
CONTROLOBJECTINFO name##Control = { { {clsid, progid, fn}, ver, riid, pszh, NULL, 0}, piide, dwcf, dwap, fo, TRUE, w, szwc, FALSE, cpp, rgppg, ccv, rgcv, NULL } \

#endif // !INITOBJECTS

#define OLEMISCFLAGSOFCONTROL(index)     ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))->dwOleMiscFlags
#define FCONTROLISWINDOWLESS(index)      ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))->fWindowless
#define FCONTROLISOPAQUE(index)          ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))->fOpaque
#define ACTIVATIONPOLICYOFCONTROL(index) ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))->dwActivationPolicy
#define EVENTIIDOFCONTROL(index)         (*(((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))->piidEvents))
#define WNDCLASSNAMEOFCONTROL(index)     ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))->szWndClass
#define CPROPPAGESOFCONTROL(index)       ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))->cPropPages
#define PPROPPAGESOFCONTROL(index)       ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))->rgPropPageGuids
#define CCUSTOMVERBSOFCONTROL(index)     ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))->cCustomVerbs
#define CUSTOMVERBSOFCONTROL(index)      ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))->rgCustomVerbs
#define BITMAPIDOFCONTROL(index)         ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))->wToolboxId
#define CTLWNDCLASSREGISTERED(index)     ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))->fWindowClassRegistered
#define SUBCLASSWNDPROCOFCONTROL(index)  ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))->pfnSubClass


//=--------------------------------------------------------------------------=
// COleControl
//=--------------------------------------------------------------------------=
// the mother of all C++ objects
//
class COleControl : public CAutomationObject,
                    public IOleObject, public IOleControl,
                    public IOleInPlaceObjectWindowless, public IOleInPlaceActiveObject,
                    public IViewObjectEx, public IPersistPropertyBag,
                    public IPersistStreamInit, public IPersistStorage,
                    public IConnectionPointContainer, public ISpecifyPropertyPages,
                    public IProvideClassInfo, public IPointerInactive,
                    public IQuickActivate
{
  public:
    // IUnknown methods -- there are required since we inherit from variuos
    // people who themselves inherit from IUnknown.  just delegate to controlling
    // unknown
    //
    DECLARE_STANDARD_UNKNOWN();

    //=--------------------------------------------------------------------------=
    // IPersist methods.  used by IPersistStream and IPersistStorage
    //
    STDMETHOD(GetClassID)(THIS_ LPCLSID lpClassID);

    // IPersistStreamInit methods
    //
    STDMETHOD(IsDirty)(THIS);
    STDMETHOD(Load)(LPSTREAM pStm);
    STDMETHOD(Save)(LPSTREAM pStm, BOOL fClearDirty);
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER FAR* pcbSize);
    STDMETHOD(InitNew)();

    // IPersistStorage
    //
    STDMETHOD(InitNew)(IStorage  *pStg);
    STDMETHOD(Load)(IStorage  *pStg);
    STDMETHOD(Save)(IStorage  *pStgSave, BOOL fSameAsLoad);
    STDMETHOD(SaveCompleted)(IStorage  *pStgNew);
    STDMETHOD(HandsOffStorage)(void);

    // IPersistPropertyBag
    //
    STDMETHOD(Load)(LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog);
    STDMETHOD(Save)(LPPROPERTYBAG pPropBag, BOOL fClearDirty,
                    BOOL fSaveAllProperties);

    // IOleControl methods
    //
    STDMETHOD(GetControlInfo)(LPCONTROLINFO pCI);
    STDMETHOD(OnMnemonic)(LPMSG pMsg);
    STDMETHOD(OnAmbientPropertyChange)(DISPID dispid);
    STDMETHOD(FreezeEvents)(BOOL bFreeze);

    // IOleObject methods
    //
    STDMETHOD(SetClientSite)(IOleClientSite  *pClientSite);
    STDMETHOD(GetClientSite)(IOleClientSite  * *ppClientSite);
    STDMETHOD(SetHostNames)(LPCOLESTR szContainerApp, LPCOLESTR szContainerObj);
    STDMETHOD(Close)(DWORD dwSaveOption);
    STDMETHOD(SetMoniker)(DWORD dwWhichMoniker, IMoniker  *pmk);
    STDMETHOD(GetMoniker)(DWORD dwAssign, DWORD dwWhichMoniker, IMoniker  * *ppmk);
    STDMETHOD(InitFromData)(IDataObject  *pDataObject, BOOL fCreation, DWORD dwReserved);
    STDMETHOD(GetClipboardData)(DWORD dwReserved, IDataObject  * *ppDataObject);
    STDMETHOD(DoVerb)(LONG iVerb, LPMSG lpmsg, IOleClientSite  *pActiveSite, LONG lindex,
                                     HWND hwndParent, LPCRECT lprcPosRect);
    STDMETHOD(EnumVerbs)(IEnumOLEVERB  * *ppEnumOleVerb);
    STDMETHOD(Update)(void);
    STDMETHOD(IsUpToDate)(void);
    STDMETHOD(GetUserClassID)(CLSID  *pClsid);
    STDMETHOD(GetUserType)(DWORD dwFormOfType, LPOLESTR  *pszUserType);
    STDMETHOD(SetExtent)(DWORD dwDrawAspect,SIZEL  *psizel);
    STDMETHOD(GetExtent)(DWORD dwDrawAspect, SIZEL  *psizel);
    STDMETHOD(Advise)(IAdviseSink  *pAdvSink, DWORD  *pdwConnection);
    STDMETHOD(Unadvise)(DWORD dwConnection);
    STDMETHOD(EnumAdvise)(IEnumSTATDATA  * *ppenumAdvise);
    STDMETHOD(GetMiscStatus)(DWORD dwAspect, DWORD  *pdwStatus);
    STDMETHOD(SetColorScheme)(LOGPALETTE  *pLogpal);

    // IOleWindow.  required for IOleInPlaceObject and IOleInPlaceActiveObject
    //
    STDMETHOD(GetWindow)(HWND *phwnd);
    STDMETHOD(ContextSensitiveHelp)(BOOL fEnterMode);

    // IOleInPlaceObject/IOleInPlaceObjectWindowless
    //
    STDMETHOD(InPlaceDeactivate)(void);
    STDMETHOD(UIDeactivate)(void);
    STDMETHOD(SetObjectRects)(LPCRECT lprcPosRect,LPCRECT lprcClipRect) ;
    STDMETHOD(ReactivateAndUndo)(void);
    STDMETHOD(OnWindowMessage)(UINT msg, WPARAM wParam, LPARAM lParam, LRESULT *plResult);
    STDMETHOD(GetDropTarget)(IDropTarget **ppDropTarget);

    // IOleInPlaceActiveObject
    //
    STDMETHOD(TranslateAccelerator)(LPMSG lpmsg);
    STDMETHOD(OnFrameWindowActivate)(BOOL fActivate);
    STDMETHOD(OnDocWindowActivate)(BOOL fActivate);
    STDMETHOD(ResizeBorder)(LPCRECT prcBorder,
                            IOleInPlaceUIWindow  *pUIWindow,
                            BOOL fFrameWindow);
    STDMETHOD(EnableModeless)(BOOL fEnable);

    // IViewObject2/IViewObjectEx
    //
    STDMETHOD(Draw)(DWORD dwDrawAspect, LONG lindex, void  *pvAspect,
                    DVTARGETDEVICE  *ptd, HDC hdcTargetDev, HDC hdcDraw,
                    LPCRECTL lprcBounds, LPCRECTL lprcWBounds,
                    BOOL ( __stdcall  *pfnContinue )(ULONG_PTR dwContinue),
                    ULONG_PTR dwContinue);
    STDMETHOD(GetColorSet)(DWORD dwDrawAspect,LONG lindex, void  *pvAspect,
                           DVTARGETDEVICE  *ptd, HDC hicTargetDev,
                           LOGPALETTE  * *ppColorSet);
    STDMETHOD(Freeze)(DWORD dwDrawAspect, LONG lindex,
                      void  *pvAspect,DWORD  *pdwFreeze);
    STDMETHOD(Unfreeze)(DWORD dwFreeze);
    STDMETHOD(SetAdvise)(DWORD aspects, DWORD advf, IAdviseSink  *pAdvSink);
    STDMETHOD(GetAdvise)(DWORD *pAspects, DWORD  *pAdvf, IAdviseSink  * *ppAdvSink);
    STDMETHOD(GetExtent)(DWORD dwDrawAspect, LONG lindex, DVTARGETDEVICE __RPC_FAR *ptd, LPSIZEL lpsizel);
    STDMETHOD(GetRect)(DWORD dwAspect, LPRECTL pRect);
    STDMETHOD(GetViewStatus)(DWORD *pdwStatus);
    STDMETHOD(QueryHitPoint)(DWORD dwAspect, LPCRECT pRectBounds, POINT ptlLoc, LONG lCloseHint, DWORD *pHitResult);
    STDMETHOD(QueryHitRect)(DWORD dwAspect, LPCRECT pRectBounds, LPCRECT prcLoc, LONG lCloseHint, DWORD *pHitResult);
    STDMETHOD(GetNaturalExtent)(DWORD dwAspect, LONG lindex, DVTARGETDEVICE *ptd, HDC hicTargetDev, DVEXTENTINFO *pExtentInfo, LPSIZEL psizel);

    // IConnectionPointContainer methods
    //
    STDMETHOD(EnumConnectionPoints)(LPENUMCONNECTIONPOINTS FAR* ppEnum);
    STDMETHOD(FindConnectionPoint)(REFIID iid, LPCONNECTIONPOINT FAR* ppCP);

    // ISpecifyPropertyPages
    //
    STDMETHOD(GetPages)(CAUUID * pPages);

    // IProvideClassInfo methods
    //
    STDMETHOD(GetClassInfo)(LPTYPEINFO * ppTI);

    // IPointerInactive methods
    //
    STDMETHOD(GetActivationPolicy)(DWORD *pdwPolicy);
    STDMETHOD(OnInactiveMouseMove)(LPCRECT pRectBounds, long x, long y, DWORD dwMouseMsg);
    STDMETHOD(OnInactiveSetCursor)(LPCRECT pRectBounds, long x, long y, DWORD dwMouseMsg, BOOL fSetAlways);

    // IQuickActivate methods
    //
    STDMETHOD(QuickActivate)(QACONTAINER *pqacontainer, QACONTROL *pqacontrol);
    STDMETHOD(SetContentExtent)(LPSIZEL);
    STDMETHOD(GetContentExtent)(LPSIZEL);

    // constructor and destructor
    //
    COleControl(IUnknown *pUnkOuter, int iPrimaryDispatch, void *pMainInterface,
		BOOL fExpandoEnabled=FALSE);
    virtual ~COleControl();

    //=--------------------------------------------------------------------------=
    // callable by anybody
    //
    static LRESULT CALLBACK ControlWindowProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp);
    static LRESULT CALLBACK ReflectWindowProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp);
    static COleControl * ControlFromHwnd(HWND hwnd) {
        return (COleControl *) GetWindowLongPtr(hwnd, GWLP_USERDATA);
    }

    void __cdecl FireEvent(EVENTINFO * pEventInfo, ...);
    HINSTANCE    GetResourceHandle(void);


    //=--------------------------------------------------------------------------=
    // ole controls that want to support both windowed and windowless operations
    // should use these wrappers instead of the appropriate win32 api routine.
    // controls that don't care and just want to be windowed all the time can
    // just go ahead and use the api routines.
    //
    BOOL    SetFocus(BOOL fGrab);                       // SetFocus API
    BOOL    OcxGetFocus(void);                          // GetFocus() == m_hwnd
    BOOL    OcxGetWindowRect(LPRECT);                   // gets your current window rect
    LRESULT OcxDefWindowProc(UINT, WPARAM, LPARAM);     // DefWindowProc
    HDC     OcxGetDC(void);                             // GetDC(m_hwnd);
    void    OcxReleaseDC(HDC hdc);                      // ReleaseDC(m_hwnd, hdc);
    BOOL    OcxSetCapture(BOOL fGrab);                  // SetCapture(fGrab ? m_hwnd : NULL);
    BOOL    OcxGetCapture(void);                        // GetCapture() == m_hwnd
    BOOL    OcxInvalidateRect(LPCRECT, BOOL);           // InvalidateRect(m_hwnd, prc, f);
    BOOL    OcxScrollRect(LPCRECT, LPCRECT, int, int);  // ScrollWindowEx(...);

  protected:

    //=--------------------------------------------------------------------------=
    // member variables that derived controls can get at.
    //
    // derived controls Should NOT modify the following.
    //
    IOleClientSite     *m_pClientSite;             // client site
    IOleControlSite    *m_pControlSite;            // IOleControlSite ptr on client site
    IOleInPlaceSite    *m_pInPlaceSite;            // IOleInPlaceSite for managing activation
    IOleInPlaceFrame   *m_pInPlaceFrame;           // IOleInPlaceFrame ptr on client site
    IOleInPlaceUIWindow *m_pInPlaceUIWindow;       // for negotiating border space with client
    ISimpleFrameSite   *m_pSimpleFrameSite;        // simple frame site
    IDispatch          *m_pDispAmbient;            // ambient dispatch pointer
    SIZEL               m_Size;                    // the size of this control
    RECT                m_rcLocation;              // where we at
    HWND                m_hwnd;                    // our window
    HWND                m_hwndParent;              // our parent window
    HRGN                m_hRgn;

    // Windowless OLE controls support
    //
    IOleInPlaceSiteWindowless *m_pInPlaceSiteWndless; // IOleInPlaceSiteWindowless pointer

    // flags indicating internal state.  do not modify.
    //
    unsigned m_fDirty:1;                           // does the control need to be resaved?
    unsigned m_fInPlaceActive:1;                   // are we in place active or not?
    unsigned m_fInPlaceVisible:1;                  // we are in place visible or not?
    unsigned m_fUIActive:1;                        // are we UI active or not.
    unsigned m_fCreatingWindow:1;                  // indicates if we're in CreateWindowEx or not

    //=--------------------------------------------------------------------------=
    // methods that derived controls can override, but may need to be called
    // from their versions.
    //
    virtual void      ViewChanged(void);
    virtual HRESULT   InternalQueryInterface(REFIID riid, void **ppvObjOut);
    virtual BOOL      SetGUIFocus(HWND hwndSet);

    //=--------------------------------------------------------------------------=
    // member functions that provide for derived controls, or that we use, but
    // derived controls might still find useful.
    //
    HRESULT      DoSuperClassPaint(HDC, LPCRECTL);
    HRESULT      RecreateControlWindow(void);
    BOOL         DesignMode(void);
    BOOL         GetAmbientProperty(DISPID, VARTYPE, void *);
    BOOL         GetAmbientFont(IFont **ppFontOut);
    void         ModalDialog(BOOL fShow);
    void         InvalidateControl(LPCRECT prc);
    BOOL         SetControlSize(SIZEL *pSizel);

    HWND         CreateInPlaceWindow(int x, int y, BOOL fNoRedraw);
    HRESULT      InPlaceActivate(LONG lVerb);
    void         SetInPlaceVisible(BOOL);
    void         SetInPlaceParent(HWND);

    // IPropertyNotifySink stuff.
    //
    inline void  PropertyChanged(DISPID dispid) {
        m_cpPropNotify.DoOnChanged(dispid);
    }
    inline BOOL  RequestPropertyEdit(DISPID dispid) {
        return m_cpPropNotify.DoOnRequestEdit(dispid);
    }

    // subclassed windows controls support ...
    //
    inline HWND  GetOuterWindow(void) {
        return (m_hwndReflect) ? m_hwndReflect : m_hwnd;
    }

    // little routine for people to tell if they are windowless or not
    //
    inline BOOL  Windowless(void) {
        return !m_fInPlaceActive || m_pInPlaceSiteWndless;
    }

    // some people don't care if they're windowed or not -- they just need
    // a site pointer.  this makes it a little easier.
    //
    inline IOleInPlaceSite    *GetInPlaceSite(void) {
        return (IOleInPlaceSite *)(m_pInPlaceSiteWndless ? m_pInPlaceSiteWndless : m_pInPlaceSite);
    }

  private:
    //=--------------------------------------------------------------------------=
    // the following are methods that ALL control writers must override and implement
    //
    STDMETHOD(LoadBinaryState)(IStream *pStream) PURE;
    STDMETHOD(SaveBinaryState)(IStream *pStream) PURE;
    STDMETHOD(LoadTextState)(IPropertyBag *pPropertyBag, IErrorLog *pErrorLog) PURE;
    STDMETHOD(SaveTextState)(IPropertyBag *pPropertyBag, BOOL fWriteDefault) PURE;
    STDMETHOD(OnDraw)(DWORD dvAspect, HDC hdcDraw, LPCRECTL prcBounds, LPCRECTL prcWBounds, HDC hicTargetDev, BOOL fOptimize) PURE;
    virtual LRESULT WindowProc(UINT msg, WPARAM wParam, LPARAM lParam) PURE;
    virtual BOOL    RegisterClassData(void) PURE;

    //=--------------------------------------------------------------------------=
    // OVERRIDABLES -- methods controls can implement for customized functionality
    //
    virtual void    AmbientPropertyChanged(DISPID dispid);
    virtual BOOL    BeforeCreateWindow(DWORD *, DWORD *, LPSTR);
    virtual void    BeforeDestroyWindow(void);
    virtual HRESULT DoCustomVerb(LONG lVerb);
    virtual BOOL    OnSetExtent(const SIZEL *pSizeL);
    virtual BOOL    OnSpecialKey(LPMSG);
    virtual BOOL    OnGetPalette(HDC, LOGPALETTE **);
    virtual HRESULT OnQuickActivate(QACONTAINER *, DWORD *);
    virtual BOOL    InitializeNewState();
    virtual BOOL    AfterCreateWindow(void);
    virtual BOOL    OnGetRect(DWORD dvAspect, LPRECTL prcRect);
    virtual void    OnSetObjectRectsChangingWindowPos(DWORD *dwFlag);
    virtual void    OnVerb(LONG lVerb);

    //=--------------------------------------------------------------------------=
    // methods that various people internally will share.  not needed, however, by
    // any inherting classes.
    //
    HRESULT         m_SaveToStream(IStream *pStream);
    HRESULT         LoadStandardState(IPropertyBag *pPropertyBag, IErrorLog *pErrorLog);
    HRESULT         LoadStandardState(IStream *pStream);
    HRESULT         SaveStandardState(IPropertyBag *pPropertyBag);
    HRESULT         SaveStandardState(IStream *pStream);

    //=--------------------------------------------------------------------------=
    // member variables we don't want anybody to get their hands on, including
    // inheriting classes
    //
    HWND              m_hwndReflect;               // for subclassed windows
    IOleAdviseHolder *m_pOleAdviseHolder;          // IOleObject::Advise holder object
    IAdviseSink      *m_pViewAdviseSink;           // IViewAdvise sink for IViewObject2
    unsigned short    m_nFreezeEvents;             // count of freezes versus thaws
    unsigned          m_fHostReflects:1;           // does the host reflect messages?
    unsigned          m_fCheckedReflecting:1;      // have we checked above yet?

    // internal flags.  various other flags are visible to the end control class.
    //
    unsigned m_fModeFlagValid:1;                   // we stash the mode as much as possible
    unsigned m_fSaveSucceeded:1;                   // did an IStorage save work correctly?
    unsigned m_fViewAdvisePrimeFirst: 1;           // for IViewobject2::setadvise
    unsigned m_fViewAdviseOnlyOnce: 1;             // for iviewobject2::setadvise
    unsigned m_fUsingWindowRgn:1;                  // for SetObjectRects and clipping
    unsigned m_fRunMode:1;                         // are we in run mode or not?

    class CConnectionPoint : public IConnectionPoint {
      public:
        IUnknown **m_rgSinks;

        // IUnknown methods
        //
        STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) ;
        STDMETHOD_(ULONG,AddRef)(THIS) ;
        STDMETHOD_(ULONG,Release)(THIS) ;

        // IConnectionPoint methods
        //
        STDMETHOD(GetConnectionInterface)(IID FAR* pIID);
        STDMETHOD(GetConnectionPointContainer)(IConnectionPointContainer FAR* FAR* ppCPC);
        STDMETHOD(Advise)(LPUNKNOWN pUnkSink, DWORD FAR* pdwCookie);
        STDMETHOD(Unadvise)(DWORD dwCookie);
        STDMETHOD(EnumConnections)(LPENUMCONNECTIONS FAR* ppEnum);

        void    DoInvoke(DISPID dispid, DISPPARAMS * pdispparam);
        void    DoOnChanged(DISPID dispid);
        BOOL    DoOnRequestEdit(DISPID dispid);
        HRESULT AddSink(void *, DWORD *);

        COleControl *m_pOleControl();
        CConnectionPoint(BYTE b){
            m_bType = b;
            m_rgSinks = NULL;
            m_cSinks = 0;
            m_cAllocatedSinks = 0;
            m_SingleSink = NULL;
        }
        ~CConnectionPoint();

      private:
        BYTE   m_bType;
        unsigned short m_cSinks;
        IUnknown *m_SingleSink;
        unsigned short m_cAllocatedSinks;

    } m_cpEvents, m_cpPropNotify;

    // so they can get at some of our protected things, like AddRef, QI, etc.
    //
    friend CConnectionPoint;
};

#define _CTRLOBJ_H_
#endif // _CTRLOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\inc\globals.h ===
//=--------------------------------------------------------------------------=
// Globals.H
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains externs and stuff for Global variables, etc ..
//
#ifndef _GLOBALS_H_

// the library that we are
//
extern const CLSID *g_pLibid;

//=--------------------------------------------------------------------------=
// support for licensing
//
extern BOOL   g_fMachineHasLicense;
extern BOOL   g_fCheckedForLicense;

//=--------------------------------------------------------------------------=
// does our server have a type library?
//
extern BOOL   g_fServerHasTypeLibrary;

//=--------------------------------------------------------------------------=
// our instance handle, and various pieces of information interesting to
// localization
//
extern HINSTANCE    g_hInstance;

extern const VARIANT_BOOL g_fSatelliteLocalization;
extern VARIANT_BOOL       g_fHaveLocale;
extern LCID               g_lcidLocale;

//=--------------------------------------------------------------------------=
// apartment threading support.
//
extern CRITICAL_SECTION g_CriticalSection;

//=--------------------------------------------------------------------------=
// our global memory allocator and global memory pool
//
extern HANDLE   g_hHeap;

//=--------------------------------------------------------------------------=
// global parking window for parenting various things.
//
extern HWND     g_hwndParking;

//=--------------------------------------------------------------------------=
// system information
//
extern BOOL g_fSysWin95;                    // we're under Win95 system, not just NT SUR
extern BOOL g_fSysWinNT;                    // we're under some form of Windows NT
extern BOOL g_fSysWin95Shell;               // we're under Win95 or Windows NT SUR { > 3/51)

#define _GLOBALS_H_
#endif // _GLOBALS_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\inc\extobj.h ===
#ifndef __EXTOBJ_H
#define __EXTOBJ_H
////
//
// ExpandoObject header file
//
//
//
#include "IPServer.H"

////
//
// IDispatchEx
//
////

////
//
// the GUID
//

// {A0AAC450-A77B-11cf-91D0-00AA00C14A7C}
DEFINE_GUID(IID_IDispatchEx, 0xa0aac450, 0xa77b, 0x11cf, 0x91, 0xd0, 0x0, 0xaa, 0x0, 0xc1, 0x4a, 0x7c);

////
//
// IDispatchEx flags:
//

enum
{
	fdexNil = 0x00,				// empty
	fdexDontCreate = 0x01,		// don't create slot if non-existant otherwise do
	fdexInitNull = 0x02,		// init a new slot to VT_NULL as opposed to VT_EMPTY
	fdexCaseSensitive = 0x04,	// match names as case sensitive
};

////
//
// This is the interface for extensible IDispatch objects.
//

class IDispatchEx : public IDispatch
{
public:
	// Get dispID for names, with options
	virtual HRESULT STDMETHODCALLTYPE GetIDsOfNamesEx(
		REFIID riid,
		LPOLESTR *prgpsz,
		UINT cpsz,
		LCID lcid,
		DISPID *prgid,
		DWORD grfdex
	) = 0;

	// Enumerate dispIDs and their associated "names".
	// Returns S_FALSE if the enumeration is done, NOERROR if it's not, an
	// error code if the call fails.
	virtual HRESULT STDMETHODCALLTYPE GetNextDispID(
		DISPID id,
		DISPID *pid,
		BSTR *pbstrName
	) = 0;
};

////
//
// Globals and definitions
//
////

#define NUM_EXPANDO_DISPIDS		250
#define	NUM_CORE_DISPIDS		250
#define NUM_RESERVED_EXTENDER_DISPIDS (NUM_CORE_DISPIDS + NUM_EXPANDO_DISPIDS)
#define EXTENDER_DISPID_BASE ((ULONG)(0x80010000))
#define IS_EXTENDER_DISPID(x) ( ( (ULONG)(x) & 0xFFFF0000 ) == EXTENDER_DISPID_BASE )

////
//
// Slot: the state of a value slot
//

inline WCHAR ToUpper(WCHAR ch)
{
	if (ch>='a' && ch <= 'z')
		return ch - 'a' + 'A';
	else
		return ch;

}

class CExpandoObjectSlot
{
public:
	////
	//
	// Constructor/Destructor
	//

	// because these monsters are malloc'ed, we need a manual constructor and destructor methods
	void Construct()
	{
		m_name = NULL;
		m_next = -1;
		VariantInit(&m_value);
		// set hash and dispId to dummy values
		m_hash = 0;
		m_dispId = DISPID_UNKNOWN;
	}

	void Destruct()
	{
		if (m_name)
			SysFreeString(m_name);
		VariantClear(&m_value);
	}

private:
	// the constructors and destructors are private because they should never be called ...
	// we could use in-place construction if we wanted to be clever ...
	CExpandoObjectSlot()
	{
	}

	~CExpandoObjectSlot()
	{
	}

public:
	////
	//
	// Init the slot
	//

	HRESULT Init(LPOLESTR name, LCID lcid, DISPID dispId, VARIANT* value)
	{
		// allocate the string
		m_name = SysAllocString(name);
		if (m_name == NULL)
			return E_OUTOFMEMORY;

		// compute the hash: uses the standard OLE string hashing function
		// note that this function is case insensitive
		m_hash = LHashValOfName(lcid, name);

		// set the dispId
		m_dispId = dispId;

		// Copy the variant value
		return VariantCopy(&m_value, value);
	}

	////
	//
	// Name information
	//

	// get the name
	BSTR Name()
	{ return m_name; }

	// compare two names
	BOOL CompareName(LPOLESTR name, ULONG hash, BOOL caseSensitive)
	{
		unsigned int strLen;

		// hash should be the same, length should be the same, and strings should compare
		// BUGBUG robwell 8May96 These functions are probably verboten.
		if (hash != m_hash)
			return FALSE;

		if (!name)
			return !m_name;

		WCHAR *c1 = name;
		WCHAR *c2 = m_name;

		// Travel down both strings until we reach a mismatched character
		// or the end of one (or both) of the strings

		if (caseSensitive)
			while (*c1 && *c2 && *c1++==*c2++);
		else
			while (*c1 && *c2 && ToUpper(*c1++)==ToUpper(*c2++));

		// The strings match if we reached the end of both without a mismatch
		return !*c1 && !*c2;
 	}

	////
	//
	// DispId information
	//

	// get the dispatch id
	DISPID DispId()
	{ return m_dispId; }

	////
	//
	// Get and set the property values
	//

	HRESULT Get(VARIANT* result)
	{ return VariantCopy(result, &m_value); }

	HRESULT Set(VARIANT* value)
	{ return VariantCopy(&m_value, value); }

	////
	//
	// List management
	//

	CExpandoObjectSlot* Next(CExpandoObjectSlot* base)
	{ return m_next == -1? NULL: &base[m_next]; }

	CExpandoObjectSlot* Insert(CExpandoObjectSlot* base, LONG& prev)
	{
		m_next = prev;
		prev = (LONG)(this - base);
		return this;
	}

private:
	// the DispId
	DISPID		m_dispId;
	// the name
	LPOLESTR	m_name;
	// the name hash
	ULONG		m_hash;
	// the property value
	VARIANT		m_value;
	// the hash bucket link (index based)
	LONG		m_next;
};

// NB: CExpandoObject implements a crippled version of aggegation.
// It delegates all IUnknown calls to its controlling IUnknown, and has no
// private IUnknown interface.
// If you want the CExpandoObject to go away, simply call delete on it.
class CExpandoObject: public IDispatchEx
{
public:

	////
	//
	// Constructor/Destructor
	//

	CExpandoObject(IUnknown *punkOuter, IDispatch *pdisp, ULONG dispIdBase = EXTENDER_DISPID_BASE + NUM_CORE_DISPIDS)
	{
		// remember our controlling outer
		m_punkOuter = punkOuter;

		// remember the IDispatch to try first for IDispatch functionality
		m_pdisp = pdisp;
		
		// clear the name hash table
		ClearHashTable();
		// set the total slots and the table of slots to 0 and empty respectively)
		m_totalSlots = 0;
		m_slotTableSize = 0;
		m_slots = NULL;
		m_dispIdBase = dispIdBase;
	}

	STDMETHODIMP_(ULONG) AddRef()
	{
		return m_punkOuter->AddRef();
	}

	STDMETHODIMP_(ULONG)Release()
	{
		return m_punkOuter->Release();
	}

    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObjOut)
	{
		return m_punkOuter->QueryInterface(riid, ppvObjOut);
	}

    virtual ~CExpandoObject(void)
	{
		FreeAllSlots();
	}


    // Copy all of the properties from obj
   	HRESULT CloneProperties(CExpandoObject& obj);

	////
	//
	//
	// Utility functions
	//

	// free all slots
	void FreeAllSlots();

	// IDispatch methods
	virtual HRESULT STDMETHODCALLTYPE GetTypeInfoCount(UINT *pctinfo);
	virtual HRESULT STDMETHODCALLTYPE GetTypeInfo(
		UINT itinfo,
		LCID lcid,
		ITypeInfo **pptinfo
	);
	virtual HRESULT STDMETHODCALLTYPE GetIDsOfNames(
		REFIID riid,
		LPOLESTR *prgpsz,
		UINT cpsz,
		LCID lcid,
		DISPID *prgdispID
	);
	virtual HRESULT STDMETHODCALLTYPE Invoke(
		DISPID dispID,
		REFIID riid,
		LCID lcid,
		WORD wFlags,
		DISPPARAMS *pdispparams,
		VARIANT *pvarRes,
		EXCEPINFO *pexcepinfo,
		UINT *puArgErr
	);

	// IDispatchEx methods

	// Get dispID for names, with options
	virtual HRESULT STDMETHODCALLTYPE GetIDsOfNamesEx(
		REFIID riid,
		LPOLESTR *prgpsz,
		UINT cpsz,
		LCID lcid,
		DISPID *prgid,
		DWORD grfdex
	);

	// Enumerate dispIDs and their associated "names".
	// Returns S_FALSE if the enumeration is done, NOERROR if it's not, an
	// error code if the call fails.
	virtual HRESULT STDMETHODCALLTYPE GetNextDispID(
		DISPID id,
		DISPID *pid,
		BSTR *pbstrName
	);

private:
	////
	//
	// Implementation constants
	//

	enum
	{
		kSlotHashTableSize = 10,
		kInitialSlotTableSize = 4,
		kMaxTotalSlots = NUM_EXPANDO_DISPIDS
	};

	////
	//
	// Utility functions
	//

	//
	CExpandoObjectSlot* GetHashTableHead(UINT hashIndex)
	{
		LONG index;

		return (index = m_hashTable[hashIndex]) == -1? NULL: &m_slots[index];
	}

	// get the ID of from a slot name
	HRESULT GetIDOfName(LPOLESTR name, LCID lcid, BOOL caseSensitive, DISPID* id);
	// add a slot to the object
	HRESULT AddSlot(LPOLESTR name, LCID lcid, BOOL caseSensitive, VARIANT* initialValue, DISPID* id);
	// allocate a slot from the slot table
	CExpandoObjectSlot* AllocSlot();
	// clear the hash table
	void ClearHashTable()
	{
		UINT i;

		for (i=0; i<kSlotHashTableSize; ++i)
			m_hashTable[i] = -1;
	}

	////
	//
	// Slot operations
	//
	// DISPIDS start at kInitialDispId so we need to offset them by that amount
	// in this code.
	//

	HRESULT GetSlot(DISPID id, VARIANT* result)
	{
		if ((ULONG) id < m_dispIdBase || (ULONG) id >= (m_totalSlots+m_dispIdBase))
			return DISP_E_MEMBERNOTFOUND;

		return m_slots[id-m_dispIdBase].Get(result);
	}

	HRESULT SetSlot(DISPID id, VARIANT* result)
	{
		if ((ULONG) id < m_dispIdBase || (ULONG) id >= (m_totalSlots+m_dispIdBase))
			return DISP_E_MEMBERNOTFOUND;

		return m_slots[id-m_dispIdBase].Set(result);
	}

	////
	//
	// Iteration operations
	//

	UINT	NumDispIds()
	{ return m_totalSlots; }

	DISPID	First()
	{ return m_dispIdBase; }

	DISPID	Last()
	{ return m_totalSlots + m_dispIdBase - 1; }

	BOOL	ValidDispId(DISPID id)
	{ return id >= First() && id <= Last(); }

	HRESULT	Next(DISPID key, CExpandoObjectSlot*& slot)
	{
		// zero restarts the enumerator
		if (key == 0)
		{
			// if there are no slots we are done
			if (NumDispIds() == 0)
				return S_FALSE;

			// return the first slot
			slot = &m_slots[0];
			return NOERROR;
		}
		else
		if (key == Last())
		{
			// the key was the last slot so we are done
			return S_FALSE;
		}
		else
		if (ValidDispId(key))
		{
			// return the next slot
			slot = &m_slots[key-m_dispIdBase+1];
			return NOERROR;
		}
		else
			// the key must be invalid
			return E_INVALIDARG;
	}

	////
	//
	// The local state of the object
	//

	// the objects reference count
	ULONG	m_ref;

	// the base of objectIds
	ULONG	m_dispIdBase;

	// the hash table of slots - for fast GetIDSofNames lookup
	LONG	m_hashTable[kSlotHashTableSize];

	// the number of slots (and the next dispId to allocate)
	UINT	m_totalSlots;

	// the size of the allocated array of slots
	UINT	m_slotTableSize;

	// a pointer to the allocated array of slots
	CExpandoObjectSlot* m_slots;

	// controlling unknown
	IUnknown *m_punkOuter;

	// controlling IDispatch
	IDispatch *m_pdisp;
};

#endif // __EXTOBJ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\inc\ipserver.h ===
//=--------------------------------------------------------------------------=
// IPServer.H
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// global header file that contains all the windows stuff, etc ...  should
// be pre-compiled to speed things up a little bit.
//
#ifndef _IPSERVER_H_

//#define INC_OLE2
#include <windows.h>
#include <stddef.h>                    // for offsetof()
#include <olectl.h>

// things that -everybody- wants [read: is going to get]
//
#include "Debug.H"

//=--------------------------------------------------------------------------=
// controls can register for thread notifications in their InitializeLibrary()
//
#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

typedef void (CALLBACK *THRDNFYPROC)(HANDLE, DWORD, void *);
void SetLibraryThreadProc(THRDNFYPROC pfnThreadNotify);

#ifdef __cplusplus
}
#endif // __cplusplus
//=--------------------------------------------------------------------------=

//=--------------------------------------------------------------------------=
// we don't want to use the CRTs, and would like some memory tracking in the
// debug case, so we'll override these guys
//=--------------------------------------------------------------------------=
//
//void * _cdecl operator new(size_t size);
//void  _cdecl operator delete(void *ptr);


//=--------------------------------------------------------------------------=
// Useful macros
//=--------------------------------------------------------------------------=
//
// handy error macros, randing from cleaning up, to returning to clearing
// rich error information as well.
//
#define RETURN_ON_FAILURE(hr) if (FAILED(hr)) return hr
#define RETURN_ON_NULLALLOC(ptr) if (!(ptr)) return E_OUTOFMEMORY
#define CLEANUP_ON_FAILURE(hr) if (FAILED(hr)) goto CleanUp
#define CLEARERRORINFORET(hr) { SetErrorInfo(0, NULL); return hr; }
#define CLEARERRORINFORET_ON_FAILURE(hr) if (FAILED(hr)) { SetErrorInfo(0, NULL); return hr; }

#define CLEANUP_ON_ERROR(l)    if (l != ERROR_SUCCESS) goto CleanUp

// conversions
//
#define BOOL_TO_VARIANTBOOL(f) (f) ? VARIANT_TRUE : VARIANT_FALSE

// Reference counting help.
//
#define RELEASE_OBJECT(ptr)    if (ptr) { IUnknown *pUnk = (ptr); (ptr) = NULL; pUnk->Release(); }
#define QUICK_RELEASE(ptr)     if (ptr) ((IUnknown *)ptr)->Release();
#define ADDREF_OBJECT(ptr)     if (ptr) (ptr)->AddRef()



//=--------------------------------------------------------------------------=
// QueryInterface Optimizations
//=--------------------------------------------------------------------------=
// for optimizing QI's
//
#define DO_GUIDS_MATCH(riid1, riid2) ((riid1.Data1 == riid2.Data1) && (riid1 == riid2))

// Data1_*
//
// the first dword of GUIDs for most of the interesting interfaces.  these are
// used by speed critical versions of QueryInterface
//
#define Data1_IAdviseSink                  0x0000010f
#define Data1_IAdviseSink2                 0x00000125
#define Data1_IAdviseSinkEx                0x3af24290
#define Data1_IBindCtx                     0x0000000e
#define Data1_ICDataDoc                    0xF413E4C0
#define Data1_IClassFactory                0x00000001
#define Data1_IClassFactory2               0xb196b28f
#define Data1_IConnectionPoint             0xb196b286
#define Data1_IConnectionPointContainer    0xb196b284
#define Data1_IControl_95                  0x9a4bbfb5
#define Data1_IControl                     0xa7fddba0
#define Data1_ICreateErrorInfo             0x22f03340
#define Data1_ICreateTypeInfo              0x00020405
#define Data1_ICreateTypeLib               0x00020406
#define Data1_IDataAdviseHolder            0x00000110
#define Data1_IDataFrame                   0x97F254E0
#define Data1_IDataFrameExpert             0x73687490
#define Data1_IDataObject                  0x0000010e
#define Data1_IDispatch                    0x00020400
#define Data1_IDropSource                  0x00000121
#define Data1_IDropTarget                  0x00000122
#define Data1_IEnumCallback                0x00000108
#define Data1_IEnumConnectionPoints        0xb196b285
#define Data1_IEnumConnections             0xb196b287
#define Data1_IEnumFORMATETC               0x00000103
#define Data1_IEnumGeneric                 0x00000106
#define Data1_IEnumHolder                  0x00000107
#define Data1_IEnumMoniker                 0x00000102
#define Data1_IEnumOLEVERB                 0x00000104
#define Data1_IEnumSTATDATA                0x00000105
#define Data1_IEnumSTATSTG                 0x0000000d
#define Data1_IEnumString                  0x00000101
#define Data1_IEnumOleUndoActions          0xb3e7c340
#define Data1_IEnumUnknown                 0x00000100
#define Data1_IEnumVARIANT                 0x00020404
#define Data1_IErrorInfo                   0x1cf2b120
#define Data1_IExternalConnection          0x00000019
#define Data1_IFont                        0xbef6e002
#define Data1_IFontDisp                    0xbef6e003
#define Data1_IFormExpert                  0x5aac7f70
#define Data1_IGangConnectWithDefault      0x6d5140c0
#define Data1_IInternalMoniker             0x00000011
#define Data1_ILockBytes                   0x0000000a
#define Data1_IMalloc                      0x00000002
#define Data1_IMarshal                     0x00000003
#define Data1_IMessageFilter               0x00000016
#define Data1_IMoniker                     0x0000000f
#define Data1_IMsoCommandTarget            0xb722bccb
#define Data1_IMsoDocument                 0xb722bcc5
#define Data1_IOleInPlaceComponent         0x5efc7970
#define Data1_IMsoView                     0xb722bcc6
#define Data1_IOleAdviseHolder             0x00000111
#define Data1_IOleCache                    0x0000011e
#define Data1_IOleCache2                   0x00000128
#define Data1_IOleCacheControl             0x00000129
#define Data1_IOleClientSite               0x00000118
#define Data1_IOleCompoundUndoAction       0xa1faf330
#define Data1_IOleContainer                0x0000011b
#define Data1_IOleControl                  0xb196b288
#define Data1_IOleControlSite              0xb196b289
#define Data1_IOleInPlaceActiveObject      0x00000117
#define Data1_IOleInPlaceFrame             0x00000116
#define Data1_IOleInPlaceObject            0x00000113
#define Data1_IOleInPlaceObjectWindowless  0x1c2056cc
#define Data1_IOleInPlaceSite              0x00000119
#define Data1_IOleInPlaceSiteEx            0x9c2cad80
#define Data1_IOleInPlaceSiteWindowless    0x922eada0
#define Data1_IOleInPlaceUIWindow          0x00000115
#define Data1_IOleItemContainer            0x0000011c
#define Data1_IOleLink                     0x0000011d
#define Data1_IOleManager                  0x0000011f
#define Data1_IOleObject                   0x00000112
#define Data1_IOlePresObj                  0x00000120
#define Data1_IOlePropertyFrame            0xb83bb801
#define Data1_IOleStandardTool             0xd97877c4
#define Data1_IOleUndoAction               0x894ad3b0
#define Data1_IOleUndoActionManager        0xd001f200
#define Data1_IOleWindow                   0x00000114
#define Data1_IPSFactory                   0x00000009
#define Data1_IPSFactoryBuffer             0xd5f569d0
#define Data1_IParseDisplayName            0x0000011a
#define Data1_IPerPropertyBrowsing         0x376bd3aa
#define Data1_IPersist                     0x0000010c
#define Data1_IPersistFile                 0x0000010b
#define Data1_IPersistPropertyBag          0x37D84F60
#define Data1_IPersistStorage              0x0000010a
#define Data1_IPersistStream               0x00000109
#define Data1_IPersistStreamInit           0x7fd52380
#define Data1_IPicture                     0x7bf80980
#define Data1_IPictureDisp                 0x7bf80981
#define Data1_IPointerInactive             0x55980ba0
#define Data1_IPropertyNotifySink          0x9bfbbc02
#define Data1_IPropertyPage                0xb196b28d
#define Data1_IPropertyPage2               0x01e44665
#define Data1_IPropertyPage3               0xb83bb803
#define Data1_IPropertyPageInPlace         0xb83bb802
#define Data1_IPropertyPageSite            0xb196b28c
#define Data1_IPropertyPageSite2           0xb83bb804
#define Data1_IProvideClassInfo            0xb196b283
#define Data1_IProvideDynamicClassInfo     0x6d5140d1
#define Data1_IQuickActivate               0xcf51ed10
#define Data1_IRequireClasses              0x6d5140d0
#define Data1_IRootStorage                 0x00000012
#define Data1_IRunnableObject              0x00000126
#define Data1_IRunningObjectTable          0x00000010
#define Data1_ISelectionContainer          0x6d5140c6
#define Data1_IServiceProvider             0x6d5140c1
#define Data1_ISimpleFrameSite             0x742b0e01
#define Data1_ISpecifyPropertyPages        0xb196b28b
#define Data1_IStdMarshalInfo              0x00000018
#define Data1_IStorage                     0x0000000b
#define Data1_IStream                      0x0000000c
#define Data1_ISupportErrorInfo            0xdf0b3d60
#define Data1_ITypeComp                    0x00020403
#define Data1_ITypeInfo                    0x00020401
#define Data1_ITypeLib                     0x00020402
#define Data1_IUnknown                     0x00000000
#define Data1_IViewObject                  0x0000010d
#define Data1_IViewObject2                 0x00000127
#define Data1_IViewObjectEx                0x3af24292
#define Data1_IWeakRef                     0x0000001a
#define Data1_ICategorizeProperties        0x4d07fc10


#define QI_INHERITS(pObj, itf)              \
    case Data1_##itf:                       \
      if(DO_GUIDS_MATCH(riid, IID_##itf))    \
      {                                     \
        *ppvObjOut = (void *)(itf *)pObj;   \
      }                                     \
      break;

#include "extobj.h"


#define _IPSERVER_H_
#endif // _IPSERVER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\inc\localsrv.h ===
//=--------------------------------------------------------------------------=
// LocalSrv.H
//=--------------------------------------------------------------------------=
// Copyright 1995-1995 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// global routines that are specific to the inproc server itself, such as
// registration, object creation, object specification, etc...
//
#ifndef _LOCALSRV_H_

void      InitializeLibrary(void);
void      UninitializeLibrary(void);
BOOL      RegisterData(void);
BOOL      UnregisterData(void);
BOOL      CheckForLicense();
BOOL      CheckLicenseKey(LPWSTR wszCheckme);
BSTR      GetLicenseKey(void);

// global variables that various people use to get information about the control.
//
extern const char g_szLibName [];
extern const CLSID *g_pLibid;

//=--------------------------------------------------------------------------=
// Global object information table
//=--------------------------------------------------------------------------=
// for each object in your application, you have an entry in this table.  they
// do not necessarily have to be CoCreatable, but if they are used, then they
// should reside here.  use the macros to fill in this table.
//
typedef struct tagOBJECTINFO {

    unsigned short usType;
    void          *pInfo;

} OBJECTINFO;

extern OBJECTINFO g_ObjectInfo[];

//=--------------------------------------------------------------------------=
// these things are used to set up our objects in our global object table
//
#define OI_UNKNOWN       0
#define OI_AUTOMATION    1
#define OI_CONTROL       2
#define OI_PROPERTYPAGE  3
#define OI_BOGUS         0xffff

#define OBJECTISCREATABLE(index)  (((UNKNOWNOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)->rclsid != NULL)
#define ISEMPTYOBJECT(index)      (g_ObjectInfo[index].usType == OI_BOGUS)

// these are the macros you should use to fill in the table.  Note that the name
// must be exactly the same as that used in the global structure you created
// for this object.
//
#define UNKNOWNOBJECT(name)    { OI_UNKNOWN,      (void *)&(name##Object) }
#define AUTOMATIONOBJECT(name) { OI_AUTOMATION,   (void *)&(name##Object) }
#define CONTROLOBJECT(name)    { OI_CONTROL,      (void *)&(name##Control) }
#define PROPERTYPAGE(name)     { OI_PROPERTYPAGE, (void *)&(name##Page) }
#define EMPTYOBJECT            { OI_BOGUS, NULL }

#define _LOCALSRV_H_
#endif // _LOCALSRV_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\inc\internet.h ===
//=--------------------------------------------------------------------------=
// Internet.H
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// class declaration for the URLDib2 control.
//
#ifndef _INTERNET_H
#define _INTERNET_H

#define DISPID_PROGRESS 1958

#ifndef __MKTYPLIB__

#include "urlmon.H"
// ZZ BUGBUG: BUILD-ISSUE: changed from <ocidl.h> to this.
// ZZ Also removed datapath.h as all it had was myocidl.h and enum
// for the READYSTATE_ stuff.
//
#include "myocidl.h"
#include "docobj.h"   // for IServiceProvider

#include "IPServer.H"
#include "CtrlObj.H"



class CInternetControl : public COleControl
{
public:
	CInternetControl(IUnknown *     pUnkOuter, 
					int                     iPrimaryDispatch, 
					void *          pMainInterface);

	virtual ~CInternetControl();

    // IUnknown methods
    //
    DECLARE_STANDARD_UNKNOWN();

	// Call this method to start the download of a URL. 'propId' will 
	//      be passed back to you OnData below.
	HRESULT SetupDownload( LPOLESTR url, DISPID propId);


	//      Derived classes implement this method. It will be called when
	//      data has arrived for a given dispid.
	virtual HRESULT OnData( DISPID id, DWORD grfBSCF,
					IStream * bitstrm, DWORD amount );


	//      Derived classes can implement this method. It will be
	//      called at various times during the download.
	virtual HRESULT OnProgress( DISPID id, ULONG ulProgress,
					ULONG ulProgressMax,
					ULONG ulStatusCode,
					LPCWSTR pwzStatusText);

	//      Call this method to turn a URL into a Moniker.
	HRESULT GetAMoniker( LPOLESTR   url, IMoniker ** );


    HRESULT FireReadyStateChange( long newState );
	HRESULT FireProgress( ULONG dwAmount );


	// Override base class implementation...

    virtual HRESULT InternalQueryInterface(REFIID, void **);

protected:
	HRESULT GetBindHost();

    IBindHost *             m_host;
    long                    m_readyState;

    // BUGBUG: We should track all the downloads

};

#endif __MKTYPLIB__

#endif _INTERNET_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\inc\myocidl.h ===
// BUGBUG: Following is a hack to get around the re-definitions of these
// interfaces in ocidl.h
//
#define __IEnumConnections_INTERFACE_DEFINED__
#define __IOleControlTypes_INTERFACE_DEFINED__
#define __IConnectionPoint_INTERFACE_DEFINED__
#define __IEnumConnectionPoints_INTERFACE_DEFINED__
#define __IConnectionPointContainer_INTERFACE_DEFINED__
#define __IClassFactory2_INTERFACE_DEFINED__
#define __IProvideClassInfo_INTERFACE_DEFINED__
#define __IOleControl_INTERFACE_DEFINED__
#define __IProvideClassInfo2_INTERFACE_DEFINED__
#define __IOleControlSite_INTERFACE_DEFINED__
#define __IPropertyPage_INTERFACE_DEFINED__
#define __IPropertyPage2_INTERFACE_DEFINED__
#define __IPropertyPageSite_INTERFACE_DEFINED__
#define __IPropertyNotifySink_INTERFACE_DEFINED__
#define __ISpecifyPropertyPages_INTERFACE_DEFINED__
#define __IPersistMemory_INTERFACE_DEFINED__
#define __IPersistStreamInit_INTERFACE_DEFINED__
#define __IPersistPropertyBag_INTERFACE_DEFINED__
#define __ISimpleFrameSite_INTERFACE_DEFINED__
#define __IFont_INTERFACE_DEFINED__
#define __IPicture_INTERFACE_DEFINED__
#define __IFontDisp_INTERFACE_DEFINED__
#define __IPictureDisp_INTERFACE_DEFINED__
#define __IErrorLog_INTERFACE_DEFINED__
#define __IPropertyBag_INTERFACE_DEFINED__
#define __IPerPropertyBrowsing_INTERFACE_DEFINED__

#include <ocidl.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\inc\strcoll.h ===
//=--------------------------------------------------------------------------=
// StrColl.H
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains the definitions for the various string collections we'll use
//
#ifndef _STRCOLL_H_

#include "CommDlgInterfaces.H"



//=--------------------------------------------------------------------------=
// the CStringsCollection class basically works with a safearray to expose the
// collection, and uses the safearray functions to maniplate it.
//=--------------------------------------------------------------------------=
// NOTES: 9.95 - this collection assumes that the safearray lbound is
//        zero!
//=--------------------------------------------------------------------------=
//
class CStringCollection {

  public:
    // a couple of methods that are common
    //
    STDMETHOD(get_Count)(THIS_ long FAR* pcStrings);
    STDMETHOD(get_Item)(THIS_ long lIndex, BSTR FAR* pbstrItem);
    STDMETHOD(get__NewEnum)(THIS_ IUnknown * FAR* ppUnkNewEnum);

    CStringCollection(SAFEARRAY *);
    virtual ~CStringCollection();

  protected:
    // what the collection will work with.
    //
    SAFEARRAY *m_psa;
};

class CStringDynaCollection : public CStringCollection {

  public:
    // in addition to the CStringCollection methods, we'll have
    //
    STDMETHOD(put_Item)(THIS_ long lIndex, BSTR bstrItem);
    STDMETHOD(Add)(THIS_ BSTR bstrNew);
    STDMETHOD(Remove)(THIS_ long lIndex);

    CStringDynaCollection(SAFEARRAY *);
    virtual ~CStringDynaCollection();

};


#define _STRCOLL_H_
#endif // _STRCOLL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\inc\stdenum.h ===
//=--------------------------------------------------------------------------=
// StdEnum.H
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// object definition for a generic enumerator object.
//
#ifndef _STDENUM_H_

#include "Unknown.H"

// to support a generic Enumerator object, we'll just define this
// interface.  it can be safely cast to any other enumerator, since all
// they differ in is their pointer type in Next().
//
class IEnumGeneric: public IUnknown {

  public:
    virtual HRESULT __stdcall Next(ULONG celt, LPVOID rgelt, ULONG *pceltFetched) = 0;
    virtual HRESULT __stdcall Skip(ULONG celt) = 0;
    virtual HRESULT __stdcall Reset(void) = 0;
    virtual HRESULT __stdcall Clone(IEnumGeneric **ppenum) = 0;
};

//=--------------------------------------------------------------------------=
// StandardEnum
//=--------------------------------------------------------------------------=
// a generic enumerator object.  given a pointer to generic data, some
// information about the elements, and a function to copy the elements,
// we can implement a generic enumerator.
//
// NOTE: this class assumes that rgElements is HeapAlloc'd, and will free it
//       in it's destructor [although it IS valid for this to be NULL if there
//       are no elements to enumerate over.]
//
class CStandardEnum: public CUnknownObject, public IEnumGeneric {

public:
    // IUnknown methods
    //
    DECLARE_STANDARD_UNKNOWN();

    // IEnumVariant methods
    //
    STDMETHOD(Next)(unsigned long celt, void * rgvar, unsigned long * pceltFetched); 
    STDMETHOD(Skip)(unsigned long celt); 
    STDMETHOD(Reset)(); 
    STDMETHOD(Clone)(IEnumGeneric **ppEnumOut); 

    CStandardEnum(REFIID riid, int cElement, int cbElement, void *rgElements,
                 void (WINAPI * pfnCopyElement)(void *, const void *, DWORD));
    ~CStandardEnum();

private:
    virtual HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    IID m_iid;                        // type of enumerator that we are
    int m_cElements;                  // Total number of elements
    int m_cbElementSize;              // Size of each element
    int m_iCurrent;                   // Current position: 0 = front, m_cElt = end
    VOID * m_rgElements;              // Array of elements  
    CStandardEnum *m_pEnumClonedFrom; // If we were cloned, from whom?
    void  (WINAPI * m_pfnCopyElement)(void *, const void *, DWORD);
};



#define _STDENUM_H_
#endif // _STDENUM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\inc\proppage.h ===
//=--------------------------------------------------------------------------=
// PropPage.H
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// class declaration for CPropertyPage.
//
#ifndef _PROPPAGE_H_

// things we really need
//
#include "Unknown.H"
#include <olectl.h>
#include "LocalSrv.H"

//=--------------------------------------------------------------------------=
// messages that we'll send to property pages to instruct them to accomplish
// tasks.
//
#define PPM_NEWOBJECTS    (WM_USER + 100)
#define PPM_APPLY         (WM_USER + 101)
#define PPM_EDITPROPERTY  (WM_USER + 102)
#define PPM_FREEOBJECTS   (WM_USER + 103)

//=--------------------------------------------------------------------------=
// structure that control writers will use to define property pages.
//
typedef struct tagPROPERTYPAGEINFO {

    UNKNOWNOBJECTINFO unknowninfo;
    WORD    wDlgResourceId;
    WORD    wTitleId;
    WORD    wDocStringId;
    LPCSTR  szHelpFile;
    DWORD   dwHelpContextId;

} PROPERTYPAGEINFO;

#ifndef INITOBJECTS

#define DEFINE_PROPERTYPAGEOBJECT(name, pclsid, pszon, pfn, wr, wt, wd, pszhf, dwhci) \
    extern PROPERTYPAGEINFO name##Page \

#else // INITOBJECTS

#define DEFINE_PROPERTYPAGEOBJECT(name, pclsid, pszon, pfn, wr, wt, wd, pszhf, dwhci) \
    PROPERTYPAGEINFO name##Page = { {pclsid, pszon, pfn }, wr, wt, wd, pszhf, dwhci } \

#endif // INITOBJECTS


#define TEMPLATENAMEOFPROPPAGE(index)    MAKEINTRESOURCE(((PROPERTYPAGEINFO *)(g_ObjectInfo[index].pInfo))->wDlgResourceId)
#define TITLEIDOFPROPPAGE(index)         (((PROPERTYPAGEINFO *)(g_ObjectInfo[index].pInfo))->wTitleId)
#define DOCSTRINGIDOFPROPPAGE(index)     (((PROPERTYPAGEINFO *)(g_ObjectInfo[index].pInfo))->wDocStringId)
#define HELPCONTEXTOFPROPPAGE(index)     (((PROPERTYPAGEINFO *)(g_ObjectInfo[index].pInfo))->dwHelpContextId)
#define HELPFILEOFPROPPAGE(index)        (((PROPERTYPAGEINFO *)(g_ObjectInfo[index].pInfo))->szHelpFile)

//=--------------------------------------------------------------------------=
//
class CPropertyPage : public CUnknownObject, public IPropertyPage2 {

  public:
    // IUnknown methods
    //
    DECLARE_STANDARD_UNKNOWN();

    // IPropertyPage methods
    //
    STDMETHOD(SetPageSite)(LPPROPERTYPAGESITE pPageSite);
    STDMETHOD(Activate)(HWND hwndParent, LPCRECT lprc, BOOL bModal);
    STDMETHOD(Deactivate)(void);
    STDMETHOD(GetPageInfo)(LPPROPPAGEINFO pPageInfo);
    STDMETHOD(SetObjects)(ULONG cObjects, LPUNKNOWN FAR* ppunk);
    STDMETHOD(Show)(UINT nCmdShow);
    STDMETHOD(Move)(LPCRECT prect);
    STDMETHOD(IsPageDirty)(void);
    STDMETHOD(Apply)(void);
    STDMETHOD(Help)(LPCOLESTR lpszHelpDir);
    STDMETHOD(TranslateAccelerator)(LPMSG lpMsg);

    // IPropertyPage2 methods
    //
    STDMETHOD(EditProperty)(THIS_ DISPID dispid);

    // constructor destructor
    //
    CPropertyPage(IUnknown *pUnkOuter, int iObjectType);
    virtual ~CPropertyPage();

    HINSTANCE GetResourceHandle(void);            // returns current resource handle.

  protected:
    IPropertyPageSite *m_pPropertyPageSite;       // pointer to our ppage site.
    void     MakeDirty();                         // makes the property page dirty.
    HWND     m_hwnd;                              // our hwnd.

    // the following two methods allow a property page implementer to get at all the
    // objects that we need to set here.
    //
    IUnknown *FirstControl(DWORD *dwCookie);
    IUnknown *NextControl(DWORD *dwCookie);

  private:
    IUnknown **m_ppUnkObjects;                    // objects that we're working with.

    unsigned m_fActivated:1;
    unsigned m_fDirty:1;
    int      m_ObjectType;                        // what type of object we are
    UINT     m_cObjects;                          // how many objects we're holding on to

    void     m_ReleaseAllObjects(void);           // clears out all objects we've got.
    HRESULT  m_EnsureLoaded(void);                // forces the load of the page.

    virtual HRESULT InternalQueryInterface(REFIID, void **);

    // default dialog proc for a page.
    //
    static INT_PTR CALLBACK PropPageDlgProc(HWND, UINT, WPARAM, LPARAM);

    // all page implementers MUST implement the following function.
    //
    virtual INT_PTR CALLBACK DialogProc(HWND, UINT, WPARAM, LPARAM) PURE;
};

#define _PROPPAGE_H_
#endif // _PROPPAGE_H_



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\inc\prsht.h ===
/*****************************************************************************\
*                                                                             *
* prsht.h - - Interface for the Windows Property Sheet Pages                  *
*                                                                             *
* Version 1.0                                                                 *
*                                                                             *
* Copyright (c) 1991-1996, Microsoft Corp.      All rights reserved.          *
*                                                                             *
\*****************************************************************************/

#ifndef _PRSHT_H_
#define _PRSHT_H_

//
// Define API decoration for direct importing of DLL references.
//
#ifndef WINCOMMCTRLAPI
#if !defined(_COMCTL32_) && defined(_WIN32)
#define WINCOMMCTRLAPI DECLSPEC_IMPORT
#else
#define WINCOMMCTRLAPI
#endif
#endif // WINCOMMCTRLAPI

//
// For compilers that don't support nameless unions
//
#ifndef DUMMYUNIONNAME
#ifdef NONAMELESSUNION
#define DUMMYUNIONNAME   u
#define DUMMYUNIONNAME2  u2
#define DUMMYUNIONNAME3  u3
#else
#define DUMMYUNIONNAME
#define DUMMYUNIONNAME2
#define DUMMYUNIONNAME3
#endif
#endif // DUMMYUNIONNAME

#ifdef __cplusplus
extern "C" {
#endif


#ifdef __cplusplus
#define SNDMSG ::SendMessage
#else
#define SNDMSG SendMessage
#endif


#define MAXPROPPAGES            100

struct _PSP;
typedef struct _PSP FAR* HPROPSHEETPAGE;

#ifndef MIDL_PASS
struct _PROPSHEETPAGEA;
struct _PROPSHEETPAGEW;
#endif

typedef UINT (CALLBACK FAR * LPFNPSPCALLBACKA)(HWND hwnd, UINT uMsg, struct _PROPSHEETPAGEA FAR *ppsp);
typedef UINT (CALLBACK FAR * LPFNPSPCALLBACKW)(HWND hwnd, UINT uMsg, struct _PROPSHEETPAGEW FAR *ppsp);

#ifdef UNICODE
#define LPFNPSPCALLBACK         LPFNPSPCALLBACKW
#else
#define LPFNPSPCALLBACK         LPFNPSPCALLBACKA
#endif

#define PSP_DEFAULT             0x0000
#define PSP_DLGINDIRECT         0x0001
#define PSP_USEHICON            0x0002
#define PSP_USEICONID           0x0004
#define PSP_USETITLE            0x0008
#define PSP_RTLREADING          0x0010

#define PSP_HASHELP             0x0020
#define PSP_USEREFPARENT        0x0040
#define PSP_USECALLBACK         0x0080

#define PSPCB_RELEASE           1
#define PSPCB_CREATE            2


typedef struct _PROPSHEETPAGEA {
        DWORD           dwSize;
        DWORD           dwFlags;
        HINSTANCE       hInstance;
        union {
            LPCSTR          pszTemplate;
#ifdef _WIN32
            LPCDLGTEMPLATE  pResource;
#else
            const VOID FAR *pResource;
#endif
        } DUMMYUNIONNAME;
        union {
            HICON       hIcon;
            LPCSTR      pszIcon;
        } DUMMYUNIONNAME2;
        LPCSTR          pszTitle;
        DLGPROC         pfnDlgProc;
        LPARAM          lParam;
        LPFNPSPCALLBACKA pfnCallback;
        UINT FAR * pcRefParent;
} PROPSHEETPAGEA, FAR *LPPROPSHEETPAGEA;
typedef const PROPSHEETPAGEA FAR *LPCPROPSHEETPAGEA;

typedef struct _PROPSHEETPAGEW {
        DWORD           dwSize;
        DWORD           dwFlags;
        HINSTANCE       hInstance;
        union {
            LPCWSTR          pszTemplate;
#ifdef _WIN32
            LPCDLGTEMPLATE  pResource;
#else
            const VOID FAR *pResource;
#endif
        }DUMMYUNIONNAME;
        union {
            HICON       hIcon;
            LPCWSTR      pszIcon;
        }DUMMYUNIONNAME2;
        LPCWSTR          pszTitle;
        DLGPROC         pfnDlgProc;
        LPARAM          lParam;
        LPFNPSPCALLBACKW pfnCallback;
        UINT FAR * pcRefParent;
} PROPSHEETPAGEW, FAR *LPPROPSHEETPAGEW;
typedef const PROPSHEETPAGEW FAR *LPCPROPSHEETPAGEW;

#ifdef UNICODE
#define PROPSHEETPAGE           PROPSHEETPAGEW
#define LPPROPSHEETPAGE         LPPROPSHEETPAGEW
#define LPCPROPSHEETPAGE        LPCPROPSHEETPAGEW
#else
#define PROPSHEETPAGE           PROPSHEETPAGEA
#define LPPROPSHEETPAGE         LPPROPSHEETPAGEA
#define LPCPROPSHEETPAGE        LPCPROPSHEETPAGEA
#endif


#define PSH_DEFAULT             0x0000
#define PSH_PROPTITLE           0x0001
#define PSH_USEHICON            0x0002
#define PSH_USEICONID           0x0004
#define PSH_PROPSHEETPAGE       0x0008
#define PSH_WIZARD              0x0020
#define PSH_USEPSTARTPAGE       0x0040
#define PSH_NOAPPLYNOW          0x0080
#define PSH_USECALLBACK         0x0100
#define PSH_HASHELP             0x0200
#define PSH_MODELESS            0x0400
#define PSH_RTLREADING          0x0800

typedef int (CALLBACK *PFNPROPSHEETCALLBACK)(HWND, UINT, LPARAM);

typedef struct _PROPSHEETHEADERA {
        DWORD           dwSize;
        DWORD           dwFlags;
        HWND            hwndParent;
        HINSTANCE       hInstance;
        union {
            HICON       hIcon;
            LPCSTR      pszIcon;
        }DUMMYUNIONNAME;
        LPCSTR          pszCaption;


        UINT            nPages;
        union {
            UINT        nStartPage;
            LPCSTR      pStartPage;
        }DUMMYUNIONNAME2;
        union {
            LPCPROPSHEETPAGEA ppsp;
            HPROPSHEETPAGE FAR *phpage;
        }DUMMYUNIONNAME3;
        PFNPROPSHEETCALLBACK pfnCallback;
} PROPSHEETHEADERA, FAR *LPPROPSHEETHEADERA;
typedef const PROPSHEETHEADERA FAR *LPCPROPSHEETHEADERA;

typedef struct _PROPSHEETHEADERW {
        DWORD           dwSize;
        DWORD           dwFlags;
        HWND            hwndParent;
        HINSTANCE       hInstance;
        union {
            HICON       hIcon;
            LPCWSTR     pszIcon;
        }DUMMYUNIONNAME;
        LPCWSTR         pszCaption;


        UINT            nPages;
        union {
            UINT        nStartPage;
            LPCWSTR     pStartPage;
        }DUMMYUNIONNAME2;
        union {
            LPCPROPSHEETPAGEW ppsp;
            HPROPSHEETPAGE FAR *phpage;
        }DUMMYUNIONNAME3;
        PFNPROPSHEETCALLBACK pfnCallback;
} PROPSHEETHEADERW, FAR *LPPROPSHEETHEADERW;
typedef const PROPSHEETHEADERW FAR *LPCPROPSHEETHEADERW;

#ifdef UNICODE
#define PROPSHEETHEADER         PROPSHEETHEADERW
#define LPPROPSHEETHEADER       LPPROPSHEETHEADERW
#define LPCPROPSHEETHEADER      LPCPROPSHEETHEADERW
#else
#define PROPSHEETHEADER         PROPSHEETHEADERA
#define LPPROPSHEETHEADER       LPPROPSHEETHEADERA
#define LPCPROPSHEETHEADER      LPCPROPSHEETHEADERA
#endif


#define PSCB_INITIALIZED  1
#define PSCB_PRECREATE    2

WINCOMMCTRLAPI HPROPSHEETPAGE WINAPI CreatePropertySheetPageA(LPCPROPSHEETPAGEA);
WINCOMMCTRLAPI HPROPSHEETPAGE WINAPI CreatePropertySheetPageW(LPCPROPSHEETPAGEW);
WINCOMMCTRLAPI BOOL           WINAPI DestroyPropertySheetPage(HPROPSHEETPAGE);
WINCOMMCTRLAPI int            WINAPI PropertySheetA(LPCPROPSHEETHEADERA);
WINCOMMCTRLAPI int            WINAPI PropertySheetW(LPCPROPSHEETHEADERW);

#ifdef UNICODE
#define CreatePropertySheetPage  CreatePropertySheetPageW
#define PropertySheet            PropertySheetW
#else
#define CreatePropertySheetPage  CreatePropertySheetPageA
#define PropertySheet            PropertySheetA
#endif



typedef BOOL (CALLBACK FAR * LPFNADDPROPSHEETPAGE)(HPROPSHEETPAGE, LPARAM);
typedef BOOL (CALLBACK FAR * LPFNADDPROPSHEETPAGES)(LPVOID, LPFNADDPROPSHEETPAGE, LPARAM);


typedef struct _PSHNOTIFY
{
    NMHDR hdr;
    LPARAM lParam;
} PSHNOTIFY, FAR *LPPSHNOTIFY;


#define PSN_FIRST               (0U-200U)
#define PSN_LAST                (0U-299U)


#define PSN_SETACTIVE           (PSN_FIRST-0)
#define PSN_KILLACTIVE          (PSN_FIRST-1)
// #define PSN_VALIDATE            (PSN_FIRST-1)
#define PSN_APPLY               (PSN_FIRST-2)
#define PSN_RESET               (PSN_FIRST-3)
// #define PSN_CANCEL              (PSN_FIRST-3)
#define PSN_HELP                (PSN_FIRST-5)
#define PSN_WIZBACK             (PSN_FIRST-6)
#define PSN_WIZNEXT             (PSN_FIRST-7)
#define PSN_WIZFINISH           (PSN_FIRST-8)
#define PSN_QUERYCANCEL         (PSN_FIRST-9)


#define PSNRET_NOERROR              0
#define PSNRET_INVALID              1
#define PSNRET_INVALID_NOCHANGEPAGE 2


#define PSM_SETCURSEL           (WM_USER + 101)
#define PropSheet_SetCurSel(hDlg, hpage, index) \
        SNDMSG(hDlg, PSM_SETCURSEL, (WPARAM)index, (LPARAM)hpage)


#define PSM_REMOVEPAGE          (WM_USER + 102)
#define PropSheet_RemovePage(hDlg, index, hpage) \
        SNDMSG(hDlg, PSM_REMOVEPAGE, index, (LPARAM)hpage)


#define PSM_ADDPAGE             (WM_USER + 103)
#define PropSheet_AddPage(hDlg, hpage) \
        SNDMSG(hDlg, PSM_ADDPAGE, 0, (LPARAM)hpage)


#define PSM_CHANGED             (WM_USER + 104)
#define PropSheet_Changed(hDlg, hwnd) \
        SNDMSG(hDlg, PSM_CHANGED, (WPARAM)hwnd, 0L)


#define PSM_RESTARTWINDOWS      (WM_USER + 105)
#define PropSheet_RestartWindows(hDlg) \
        SNDMSG(hDlg, PSM_RESTARTWINDOWS, 0, 0L)


#define PSM_REBOOTSYSTEM        (WM_USER + 106)
#define PropSheet_RebootSystem(hDlg) \
        SNDMSG(hDlg, PSM_REBOOTSYSTEM, 0, 0L)


#define PSM_CANCELTOCLOSE       (WM_USER + 107)
#define PropSheet_CancelToClose(hDlg) \
        SNDMSG(hDlg, PSM_CANCELTOCLOSE, 0, 0L)


#define PSM_QUERYSIBLINGS       (WM_USER + 108)
#define PropSheet_QuerySiblings(hDlg, wParam, lParam) \
        SNDMSG(hDlg, PSM_QUERYSIBLINGS, wParam, lParam)


#define PSM_UNCHANGED           (WM_USER + 109)
#define PropSheet_UnChanged(hDlg, hwnd) \
        SNDMSG(hDlg, PSM_UNCHANGED, (WPARAM)hwnd, 0L)


#define PSM_APPLY               (WM_USER + 110)
#define PropSheet_Apply(hDlg) \
        SNDMSG(hDlg, PSM_APPLY, 0, 0L)


#define PSM_SETTITLEA           (WM_USER + 111)
#define PSM_SETTITLEW           (WM_USER + 120)

#ifdef UNICODE
#define PSM_SETTITLE            PSM_SETTITLEW
#else
#define PSM_SETTITLE            PSM_SETTITLEA
#endif

#define PropSheet_SetTitle(hDlg, wStyle, lpszText)\
        SNDMSG(hDlg, PSM_SETTITLE, wStyle, (LPARAM)(LPCTSTR)lpszText)


#define PSM_SETWIZBUTTONS       (WM_USER + 112)
#define PropSheet_SetWizButtons(hDlg, dwFlags) \
        PostMessage(hDlg, PSM_SETWIZBUTTONS, 0, (LPARAM)dwFlags)



#define PSWIZB_BACK             0x00000001
#define PSWIZB_NEXT             0x00000002
#define PSWIZB_FINISH           0x00000004
#define PSWIZB_DISABLEDFINISH   0x00000008


#define PSM_PRESSBUTTON         (WM_USER + 113)
#define PropSheet_PressButton(hDlg, iButton) \
        SNDMSG(hDlg, PSM_PRESSBUTTON, (WPARAM)iButton, 0)


#define PSBTN_BACK              0
#define PSBTN_NEXT              1
#define PSBTN_FINISH            2
#define PSBTN_OK                3
#define PSBTN_APPLYNOW          4
#define PSBTN_CANCEL            5
#define PSBTN_HELP              6
#define PSBTN_MAX               6



#define PSM_SETCURSELID         (WM_USER + 114)
#define PropSheet_SetCurSelByID(hDlg, id) \
        SNDMSG(hDlg, PSM_SETCURSELID, 0, (LPARAM)id)


#define PSM_SETFINISHTEXTA      (WM_USER + 115)
#define PSM_SETFINISHTEXTW      (WM_USER + 121)

#ifdef UNICODE
#define PSM_SETFINISHTEXT       PSM_SETFINISHTEXTW
#else
#define PSM_SETFINISHTEXT       PSM_SETFINISHTEXTA
#endif

#define PropSheet_SetFinishText(hDlg, lpszText) \
        SNDMSG(hDlg, PSM_SETFINISHTEXT, 0, (LPARAM)lpszText)


#define PSM_GETTABCONTROL       (WM_USER + 116)
#define PropSheet_GetTabControl(hDlg) \
        (HWND)SNDMSG(hDlg, PSM_GETTABCONTROL, 0, 0)

#define PSM_ISDIALOGMESSAGE     (WM_USER + 117)
#define PropSheet_IsDialogMessage(hDlg, pMsg) \
        (BOOL)SNDMSG(hDlg, PSM_ISDIALOGMESSAGE, 0, (LPARAM)pMsg)

#define PSM_GETCURRENTPAGEHWND  (WM_USER + 118)
#define PropSheet_GetCurrentPageHwnd(hDlg) \
        (HWND)SNDMSG(hDlg, PSM_GETCURRENTPAGEHWND, 0, 0L)

#define ID_PSRESTARTWINDOWS     0x2
#define ID_PSREBOOTSYSTEM       (ID_PSRESTARTWINDOWS | 0x1)


#define WIZ_CXDLG               276
#define WIZ_CYDLG               140

#define WIZ_CXBMP               80

#define WIZ_BODYX               92
#define WIZ_BODYCX              184

#define PROP_SM_CXDLG           212
#define PROP_SM_CYDLG           188

#define PROP_MED_CXDLG          227
#define PROP_MED_CYDLG          215

#define PROP_LG_CXDLG           252
#define PROP_LG_CYDLG           218


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\inc\vc41warn.h ===
//=--------------------------------------------------------------------------=
// VC41Warn.h
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// disables several new VC4.1 warnings that trip standard headers
//

// VC4.1 warning about bool
#pragma warning(disable:4237)

// VC4.1 warning - anachronism used
#pragma warning(disable:4229)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\inc\util.h ===
//=--------------------------------------------------------------------------=
// Util.H
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains utilities that we will find useful.
//
#ifndef _UTIL_H_

#include "Globals.H"


//=--------------------------------------------------------------------------=
// Misc Helper Routines
//=--------------------------------------------------------------------------=
//
HWND      GetParkingWindow(void);
HINSTANCE GetResourceHandle(void);

//=--------------------------------------------------------------------------=
// miscellaneous [useful] numerical constants
//=--------------------------------------------------------------------------=
// the length of a guid once printed out with -'s, leading and trailing bracket,
// plus 1 for NULL
//
#define GUID_STR_LEN    40


//=--------------------------------------------------------------------------=
// allocates a temporary buffer that will disappear when it goes out of scope
// NOTE: be careful of that -- make sure you use the string in the same or
// nested scope in which you created this buffer. people should not use this
// class directly.  use the macro(s) below.
//
class TempBuffer {
  public:
    TempBuffer(ULONG cBytes) {
        m_pBuf = (cBytes <= 120) ? &m_szTmpBuf : HeapAlloc(g_hHeap, 0, cBytes);
        m_fHeapAlloc = (cBytes > 120);
    }
    ~TempBuffer() {
        if (m_pBuf && m_fHeapAlloc) HeapFree(g_hHeap, 0, m_pBuf);
    }
    void *GetBuffer() {
        return m_pBuf;
    }

  private:
    void *m_pBuf;
    // we'll use this temp buffer for small cases.
    //
    char  m_szTmpBuf[120];
    unsigned m_fHeapAlloc:1;
};

//=--------------------------------------------------------------------------=
// string helpers.
//
// given and ANSI String, copy it into a wide buffer.
// be careful about scoping when using this macro!
//
// how to use the below two macros:
//
//  ...
//  LPSTR pszA;
//  pszA = MyGetAnsiStringRoutine();
//  MAKE_WIDEPTR_FROMANSI(pwsz, pszA);
//  MyUseWideStringRoutine(pwsz);
//  ...
//
// similarily for MAKE_ANSIPTR_FROMWIDE.  note that the first param does not
// have to be declared, and no clean up must be done.
//
#define MAKE_WIDEPTR_FROMANSI(ptrname, ansistr) \
    long __l##ptrname = (lstrlen(ansistr) + 1) * sizeof(WCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    MultiByteToWideChar(CP_ACP, 0, ansistr, -1, (LPWSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname); \
    LPWSTR ptrname = (LPWSTR)__TempBuffer##ptrname.GetBuffer()

//
// Note: allocate lstrlenW(widestr) * 2 because its possible for a UNICODE 
// character to map to 2 ansi characters this is a quick guarantee that enough
// space will be allocated.
//
#define MAKE_ANSIPTR_FROMWIDE(ptrname, widestr) \
    long __l##ptrname = (lstrlenW(widestr) + 1) * 2 * sizeof(char); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    WideCharToMultiByte(CP_ACP, 0, widestr, -1, (LPSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname, NULL, NULL); \
    LPSTR ptrname = (LPSTR)__TempBuffer##ptrname.GetBuffer()

#define STR_BSTR   0
#define STR_OLESTR 1
#define BSTRFROMANSI(x)    (BSTR)MakeWideStrFromAnsi((LPSTR)(x), STR_BSTR)
#define OLESTRFROMANSI(x)  (LPOLESTR)MakeWideStrFromAnsi((LPSTR)(x), STR_OLESTR)
#define BSTRFROMRESID(x)   (BSTR)MakeWideStrFromResourceId(x, STR_BSTR)
#define OLESTRFROMRESID(x) (LPOLESTR)MakeWideStrFromResourceId(x, STR_OLESTR)
#define COPYOLESTR(x)      (LPOLESTR)MakeWideStrFromWide(x, STR_OLESTR)
#define COPYBSTR(x)        (BSTR)MakeWideStrFromWide(x, STR_BSTR)

LPWSTR MakeWideStrFromAnsi(LPSTR, BYTE bType);
LPWSTR MakeWideStrFromResourceId(WORD, BYTE bType);
LPWSTR MakeWideStrFromWide(LPWSTR, BYTE bType);


// takes a GUID, and a pointer to a buffer, and places the string form of the
// GUID in said buffer.
//
int StringFromGuidA(REFIID, LPSTR);


//=--------------------------------------------------------------------------=
// registry helpers.
//
// takes some information about an Automation Object, and places all the
// relevant information about it in the registry.
//
BOOL RegSetMultipleValues(HKEY hkey, ...);
BOOL RegisterUnknownObject(LPCSTR pszObjectName, REFCLSID riidObject);
BOOL RegisterAutomationObject(LPCSTR pszLibName, LPCSTR pszObjectName, long lVersion, REFCLSID riidLibrary, REFCLSID riidObject);
BOOL RegisterControlObject(LPCSTR pszLibName, LPCSTR pszObjectName, long lVersion, REFCLSID riidLibrary, REFCLSID riidObject, DWORD dwMiscStatus, WORD wToolboxBitmapId);
BOOL UnregisterUnknownObject(REFCLSID riidObject);
BOOL UnregisterAutomationObject(LPCSTR pszLibName, LPCSTR pszObjectName, long lVersion, REFCLSID riidObject);
#define UnregisterControlObject UnregisterAutomationObject
BOOL UnregisterTypeLibrary(REFCLSID riidLibrary);

// deletes a key in the registr and all of it's subkeys
//
BOOL DeleteKeyAndSubKeys(HKEY hk, LPSTR pszSubKey);


//=--------------------------------------------------------------------------=
// conversion helpers.
//
void        HiMetricToPixel(const SIZEL *pSizeInHiMetric, SIZEL *pSizeinPixels);
void        PixelToHiMetric(const SIZEL *pSizeInPixels, SIZEL *pSizeInHiMetric);


#define _UTIL_H_
#endif // _UTIL_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\inc\urlhlink.h ===
#ifndef __URLHLINK_H
#define __URLHLINK_H

#include "urlmon.h"

#ifdef __cplusplus
extern "C" {
#endif


// Flags for the UrlDownloadToCacheFile
#define	URLOSTRM_USECACHEDCOPY_ONLY		0x1								// Only get from cache
#define	URLOSTRM_USECACHEDCOPY			URLOSTRM_USECACHEDCOPY_ONLY	+1	// Get from cache if available else download
#define	URLOSTRM_GETNEWESTVERSION		URLOSTRM_USECACHEDCOPY		+1	// Get new version only. But put it in cache too


typedef HRESULT (STDAPICALLTYPE *LPFNUOSCALLBACK)(LPBINDSTATUSCALLBACK);


STDAPI URLOpenStreamA(LPUNKNOWN,LPCSTR,DWORD,LPBINDSTATUSCALLBACK);
STDAPI URLOpenStreamW(LPUNKNOWN,LPCWSTR,DWORD,LPBINDSTATUSCALLBACK);
#ifdef UNICODE
#define URLOpenStream  URLOpenStreamW
#else
#define URLOpenStream  URLOpenStreamA
#endif // !UNICODE
STDAPI URLOpenPullStreamA(LPUNKNOWN,LPCSTR,DWORD,LPBINDSTATUSCALLBACK);
STDAPI URLOpenPullStreamW(LPUNKNOWN,LPCWSTR,DWORD,LPBINDSTATUSCALLBACK);
#ifdef UNICODE
#define URLOpenPullStream  URLOpenPullStreamW
#else
#define URLOpenPullStream  URLOpenPullStreamA
#endif // !UNICODE
STDAPI URLDownloadToFileA(LPUNKNOWN,LPCSTR,LPCSTR,DWORD,LPBINDSTATUSCALLBACK);
STDAPI URLDownloadToFileW(LPUNKNOWN,LPCWSTR,LPCWSTR,DWORD,LPBINDSTATUSCALLBACK);
#ifdef UNICODE
#define URLDownloadToFile  URLDownloadToFileW
#else
#define URLDownloadToFile  URLDownloadToFileA
#endif // !UNICODE

STDAPI URLDownloadToCacheFileA(LPUNKNOWN,LPCSTR,LPTSTR,DWORD,DWORD,LPBINDSTATUSCALLBACK);
STDAPI URLDownloadToCacheFileW(LPUNKNOWN,LPCWSTR,LPWSTR,DWORD,DWORD,LPBINDSTATUSCALLBACK);
#ifdef UNICODE
#define URLDownloadToCacheFile  URLDownloadToCacheFileW
#else
#define URLDownloadToCacheFile  URLDownloadToCacheFileA
#endif // !UNICODE

STDAPI URLOpenBlockingStreamA(LPUNKNOWN,LPCSTR,LPSTREAM*,DWORD,LPBINDSTATUSCALLBACK);
STDAPI URLOpenBlockingStreamW(LPUNKNOWN,LPCWSTR,LPSTREAM*,DWORD,LPBINDSTATUSCALLBACK);
#ifdef UNICODE
#define URLOpenBlockingStream  URLOpenBlockingStreamW
#else
#define URLOpenBlockingStream  URLOpenBlockingStreamA
#endif // !UNICODE

#define UOSM_PUSH  0
#define UOSM_PULL  1
#define UOSM_BLOCK 2
#define UOSM_FILE  3

#define UOS_URLENCODEPOSTDATA BINDINFOF_URLENCODESTGMEDDATA
#define UOS_URLENCODEURL      BINDINFOF_URLENCODEDEXTRAINFO

typedef struct _UOSHTTPINFOA
{
	ULONG		ulSize;
	LPUNKNOWN	punkCaller;
	LPCSTR  	szURL;
	LPCSTR  	szVerb;
	LPCSTR  	szHeaders;
	LPBYTE		pbPostData;
	ULONG		ulPostDataLen;
	ULONG		fURLEncode;
	ULONG		ulResv;
	ULONG		ulMode;
	LPCSTR  	szFileName;
	LPSTREAM *	ppStream;
	LPBINDSTATUSCALLBACK	pbscb;
} UOSHTTPINFOA, * LPUOSHTTPINFOA; 
typedef struct _UOSHTTPINFOW
{
	ULONG		ulSize;
	LPUNKNOWN	punkCaller;
	LPCWSTR 	szURL;
	LPCWSTR 	szVerb;
	LPCWSTR 	szHeaders;
	LPBYTE		pbPostData;
	ULONG		ulPostDataLen;
	ULONG		fURLEncode;
	ULONG		ulResv;
	ULONG		ulMode;
	LPCWSTR 	szFileName;
	LPSTREAM *	ppStream;
	LPBINDSTATUSCALLBACK	pbscb;
} UOSHTTPINFOW, * LPUOSHTTPINFOW; 
#ifdef UNICODE
typedef UOSHTTPINFOW UOSHTTPINFO;
typedef LPUOSHTTPINFOW LPUOSHTTPINFO;
#else
typedef UOSHTTPINFOA UOSHTTPINFO;
typedef LPUOSHTTPINFOA LPUOSHTTPINFO;
#endif // UNICODE

STDAPI URLOpenHttpStreamA(LPUOSHTTPINFOA);
STDAPI URLOpenHttpStreamW(LPUOSHTTPINFOW);
#ifdef UNICODE
#define URLOpenHttpStream  URLOpenHttpStreamW
#else
#define URLOpenHttpStream  URLOpenHttpStreamA
#endif // !UNICODE

struct IBindStatusCallback;

STDAPI HlinkSimpleNavigateToString(
    /* [in] */ LPCWSTR szTarget,      // required - target document - null if local jump w/in doc
    /* [in] */ LPCWSTR szLocation,    // optional, for navigation into middle of a doc
    /* [in] */ LPCWSTR szTargetFrameName,   // optional, for targeting frame-sets
    /* [in] */ IUnknown *pUnk,        // required - we'll search this for other necessary interfaces
    /* [in] */ IBindCtx *pbc,         // optional. caller may register an IBSC in this
	/* [in] */ IBindStatusCallback *,
    /* [in] */ DWORD grfHLNF,         // flags (TBD - HadiP needs to define this correctly?)
    /* [in] */ DWORD dwReserved       // for future use, must be NULL
);

STDAPI HlinkSimpleNavigateToMoniker(
    /* [in] */ IMoniker *pmkTarget,   // required - target document - (may be null if local jump w/in doc)
    /* [in] */ LPCWSTR szLocation,    // optional, for navigation into middle of a doc
    /* [in] */ LPCWSTR szTargetFrameName,   // optional, for targeting frame-sets
    /* [in] */ IUnknown *pUnk,        // required - we'll search this for other necessary interfaces
    /* [in] */ IBindCtx *pbc,         // optional. caller may register an IBSC in this
	/* [in] */ IBindStatusCallback *,
    /* [in] */ DWORD grfHLNF,         // flags (TBD - HadiP needs to define this correctly?)
    /* [in] */ DWORD dwReserved       // for future use, must be NULL
);

STDAPI HlinkGoBack(IUnknown *pUnk);
STDAPI HlinkGoForward(IUnknown *pUnk);
STDAPI HlinkNavigateString(IUnknown *pUnk, LPCWSTR szTarget);
STDAPI HlinkNavigateMoniker(IUnknown *pUnk, IMoniker *pmkTarget);


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\inc\unknown.h ===
//=--------------------------------------------------------------------------=
// Unknown.H
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// a class definition for an IUnknown super-class that will support
// aggregation.
//
#ifndef _UNKNOWN_H_

//=--------------------------------------------------------------------------=
// UNKNOWNOBJECTINFO
//
// if you want a simple co-creatable object, with no other guarantees about
// it, then you need to put the following entry in the global table of objects.
// other object types that are more complex, such as automation objects, and
// controls, will also use this information...
//
typedef struct {

    const CLSID *rclsid;                    // CLSID of your object.      ONLY USE IF YOU'RE CoCreatable!
    LPCSTR       pszObjectName;             // Name of your object.       ONLY USE IF YOU'RE CoCreatable!
    IUnknown    *(*pfnCreate)(IUnknown *);  // pointer to creation fn.    ONLY USE IF YOU'RE CoCreatable!

} UNKNOWNOBJECTINFO;

#define NAMEOFOBJECT(index)       (((UNKNOWNOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)->pszObjectName)
#define CLSIDOFOBJECT(index)      (*(((UNKNOWNOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)->rclsid))
#define CREATEFNOFOBJECT(index)   (((UNKNOWNOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)->pfnCreate)

#ifndef INITOBJECTS

#define DEFINE_UNKNOWNOBJECT(name, clsid, objname, fn) \
extern UNKNOWNOBJECTINFO name##Object \

#else
#define DEFINE_UNKNOWNOBJECT(name, clsid, objname, fn) \
    UNKNOWNOBJECTINFO name##Object = { clsid, objname, fn } \

#endif // INITOBJECTS


//=--------------------------------------------------------------------------=
// DECLARE_STANDARD_UNKNOWN
//
// All objects that are going to inherit from CUnknown for their IUnknown
// implementation should put this in their class declaration instead of the
// three IUnknown methods.
//
#define DECLARE_STANDARD_UNKNOWN() \
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObjOut) { \
        return ExternalQueryInterface(riid, ppvObjOut); \
    } \
    STDMETHOD_(ULONG, AddRef)(void) { \
        return ExternalAddRef(); \
    } \
    STDMETHOD_(ULONG, Release)(void) { \
        return ExternalRelease(); \
    } \

// global variable where we store the current lock count on our DLL.  This resides
// in InProcServer.Cpp
//
extern LONG g_cLocks;



//=--------------------------------------------------------------------------=
// this class doesn't inherit from IUnknown since people inheriting from it
// are going to do so, and just delegate their IUnknown calls to the External*
// member functions on this object.  the internal private unknown object does
// need to inherit from IUnknown, since it will be used directly as an IUnknown
// object.
//
class CUnknownObject {

  public:
    CUnknownObject(IUnknown *pUnkOuter, void *pvInterface)
        : m_pvInterface(pvInterface),
          m_pUnkOuter((pUnkOuter) ? pUnkOuter : &m_UnkPrivate)
        {  InterlockedIncrement(&g_cLocks); }

    virtual ~CUnknownObject() { InterlockedDecrement(&g_cLocks); }

    // these are all protected so that classes that inherit from this can
    // at get at them.
    //
  protected:
    // IUnknown methods.  these just delegate to the controlling
    // unknown.
    //
    HRESULT ExternalQueryInterface(REFIID riid, void **ppvObjOut) {
        return m_pUnkOuter->QueryInterface(riid, ppvObjOut);
    }
    ULONG ExternalAddRef(void) {
        return m_pUnkOuter->AddRef();
    }
    ULONG ExternalRelease(void) {
        return m_pUnkOuter->Release();
    }

    // people should use this during creation to return their private
    // unknown
    //
    inline IUnknown *PrivateUnknown (void) {
        return &m_UnkPrivate;
    }

    virtual HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    IUnknown *m_pUnkOuter;            // outer controlling Unknown
    void     *m_pvInterface;          // the real interface we're working with.

  private:
    // the inner, private unknown implementation is for the aggregator
    // to control the lifetime of this object, and for those cases where
    // this object isn't aggregated.
    //
    class CPrivateUnknownObject : public IUnknown {
      public:
        STDMETHOD(QueryInterface)(REFIID riid, void **ppvObjOut);
        STDMETHOD_(ULONG, AddRef)(void);
        STDMETHOD_(ULONG, Release)(void);

        // constructor is remarkably trivial
        //
        CPrivateUnknownObject() : m_cRef(1) {}

      private:
        CUnknownObject *m_pMainUnknown();
        ULONG m_cRef;
    } m_UnkPrivate;

    // so they can reference themselves in CUnknownObject from pMainUnknown()
    //
    friend class CPrivateUnknownObject;

    // by overriding this, people inheriting from this unknown can implement
    // additional interfaces.  declared as private here so they have to use their
    // own version.
    //
};




#define _UNKNOWN_H_
#endif // _UNKNOWN_H_



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\inseng\cifcomp.h ===
// Keys in cif file
#include "download.h"

#define URL_KEY             "URL"
#define GUID_KEY            "GUID"
#define ARGS_KEY            "Switches"
#define CMD_KEY             "Command"
#define SIZE_KEY            "Size"
#define INSTALLSIZE_KEY     "InstalledSize"
#define DISPLAYNAME_KEY     "DisplayName"
#define VERSION_KEY         "Version"
#define QFE_VERSION_KEY     "QFEVersion"
#define TYPE_KEY            "Type"
#define UNINSTALL_KEY       "Uninstall"
#define DEPENDENCY_KEY      "Dependencies"
#define UNINSTALLSTRING_KEY "UninstallKey"
#define SUCCESS_KEY         "SuccessKey"
#define REBOOT_KEY          "Reboot"
#define ADMIN_KEY           "AdminCheck"
#define LOCALE_KEY          "Locale"
#define MUTEX_KEY           "CancelMutex"
#define ISINSTALLED_KEY     "IsInstalled"
#define ACTSETUPAWARE_KEY   "ActiveSetupAware"
#define PRIORITY            "Priority"
#define PROGRESS_KEY        "ProgressKey"
#define COMPID_KEY          "ComponentID"
#define STUBPATH_KEY        "StubPath"
#define PARENTID_KEY        "ParentID"
#define PATCHID_KEY         "PatchID"
#define APPLIESTO_KEY       "AppliesTo"
#define MINFILESIZE_KEY     "MinFileSize"
#define URLSIZE_KEY         "Size"
#define DETAILS_KEY         "Details"
#define MODES_KEY           "Modes"
#define UIVISIBLE_KEY       "UIVisible"
#define PLATFORM_KEY        "Platform"
#define GROUP_KEY           "Group"
#define ENTRYTYPE_KEY       "SectionType"
#define DETVERSION_KEY      "DetectVersion"
#define TREATAS_KEY         "TreatAsOne"
#define BUDDY_KEY           "Buddies"

#define DETDLLS_KEY         "DetectDlls"

#define ENTRYTYPE_COMP      "Component"
#define ENTRYTYPE_GROUP     "Group"
#define ENTRYTYPE_MODE      "Mode"


#define REGSTR_PROGRESS_KEY "Software\\Microsoft\\Active Setup\\Component Progress\\"
#define COMPONENT_KEY "Software\\Microsoft\\Active Setup\\Installed Components"
#define ACTIVESETUP_KEY "Software\\Microsoft\\Active Setup"
#define COMPONENTBLOCK_KEY "Software\\Microsoft\\Active Setup\\Component Block"

#define CANCEL_VALUENAME     "Cancel"
#define SAFE_VALUENAME       "Safe"
#define PROGRESS_DISPLAY     "DisplayString"

#define DEP_NEVER_INSTALL   'N'
#define DEP_INSTALL         'I'
#define DEP_BUDDY           'B'

#define DEFAULT_LOCALE    "en"

#define ISINSTALLED_YES      1
#define ISINSTALLED_NO       0

// Default command type
#define CMDF_DEFAULT        0


#define STR_WIN95     "win95"
#define STR_WIN98     "win98"
#define STR_NT4       "nt4"
#define STR_NT5       "nt5"
#define STR_NT4ALPHA  "nt4alpha"
#define STR_NT5ALPHA  "nt5alpha"
#define STR_MILLEN    "millen"

#define SETACTION_DEPENDENCYINSTALL  0x00010000
#define SETACTION_DEPENDENCYNONE     0x00020000

#define BUFFERSIZE 4096

class CCifFile;

class CCifEntry 
{
   public:
      BOOL    IsID(LPCSTR pszID)  { return (lstrcmpi(_szID, pszID) == 0); }
      virtual void  ClearCachedInfo()  { _uPriority = 0xffffffff; }
  
      
   protected:
      CCifEntry(LPCSTR pszID, CCifFile *pCif) { lstrcpyn(_szID, pszID, sizeof(_szID)); _pCif = pCif; _uPriority = 0xffffffff; }
      ~CCifEntry() {}
      
      CCifFile   *_pCif;
      char        _szID[MAX_ID_LENGTH];
      UINT        _uPriority;
};

class CCifComponent : public ICifComponent, public CCifEntry, public IMyDownloadCallback
{
   public:
      CCifComponent(LPCSTR pszID, CCifFile *pCif);
      ~CCifComponent();

      HRESULT Download();
      HRESULT Install();
      void    ClearQueueState()  { _uInstallCount = 0; }
      void    ClearCachedInfo()  { CCifEntry::ClearCachedInfo(); _dwPlatform = 0xffffffff; _uInstallStatus = 0xffffffff; }
      
      // IMyDownloadCallback
      HRESULT OnProgress(ULONG progress, LPCSTR pszStatus);
      

      // ICifComponent interface
      STDMETHOD(GetID)(LPSTR pszID, DWORD dwSize);
      STDMETHOD(GetGUID)(LPSTR pszGUID, DWORD dwSize);
      STDMETHOD(GetDescription)(LPSTR pszDesc, DWORD dwSize);
      STDMETHOD(GetDetails)(LPSTR pszDetails, DWORD dwSize);
      STDMETHOD(GetUrl)(UINT uUrlNum, LPSTR pszUrl, DWORD dwSize, LPDWORD pdwUrlFlags);
      STDMETHOD(GetFileExtractList)(UINT uUrlNum, LPSTR pszExtract, DWORD dwSize);
      STDMETHOD(GetUrlCheckRange)(UINT uUrlNum, LPDWORD pdwMin, LPDWORD pdwMax);
      STDMETHOD(GetCommand)(UINT uCmdNum, LPSTR pszCmd, DWORD dwCmdSize, LPSTR pszSwitches, 
         DWORD dwSwitchSize, LPDWORD pdwType);
      STDMETHOD(GetVersion)(LPDWORD pdwVersion, LPDWORD pdwBuild);
      STDMETHOD(GetLocale)(LPSTR pszLocale, DWORD dwSize);
      STDMETHOD(GetUninstallKey)(LPSTR pszKey, DWORD dwSize);
      STDMETHOD(GetInstalledSize)(LPDWORD pdwWin, LPDWORD pdwApp);
      STDMETHOD_(DWORD, GetDownloadSize)();
      STDMETHOD_(DWORD, GetExtractSize)();
      STDMETHOD(GetSuccessKey)(LPSTR pszKey, DWORD dwSize);
      STDMETHOD(GetProgressKeys)(LPSTR pszProgress, DWORD dwProgSize, 
         LPSTR pszCancel, DWORD dwCancelSize);
      STDMETHOD(IsActiveSetupAware)();
      STDMETHOD(IsRebootRequired)();
      STDMETHOD(RequiresAdminRights)();
      STDMETHOD_(DWORD, GetPriority)();
      STDMETHOD(GetDependency)(UINT uDepNum, LPSTR pszID, DWORD dwBuf, char *pchType, LPDWORD pdwVer, LPDWORD pdwBuild);
      STDMETHOD_(DWORD, GetPlatform)();
      STDMETHODIMP_(BOOL) DisableComponent();
      STDMETHOD(GetMode)(UINT uModeNum, LPSTR pszModes, DWORD dwSize);
      STDMETHOD(GetGroup)(LPSTR pszID, DWORD dwSize);
      STDMETHOD(IsUIVisible)();
      STDMETHOD(GetPatchID)(LPSTR pszID, DWORD dwSize);
      STDMETHOD(GetDetVersion)(LPSTR pszDLL, DWORD dwdllSize, LPSTR pszEntry, DWORD dwentSize);
      STDMETHOD(GetTreatAsOneComponents)(UINT uNum, LPSTR pszID, DWORD dwBuf);
      STDMETHOD(GetCustomData)(LPSTR pszKey, LPSTR pszData, DWORD dwSize);


      // access to state
      STDMETHOD_(DWORD, IsComponentInstalled)();
      STDMETHOD(IsComponentDownloaded)();
      STDMETHOD_(DWORD, IsThisVersionInstalled)(DWORD dwAskVer, DWORD dwAskBld, LPDWORD pdwVersion, LPDWORD pdwBuild);
      STDMETHOD_(DWORD, GetInstallQueueState)();
      STDMETHOD(SetInstallQueueState)(DWORD dwState);
      STDMETHOD_(DWORD, GetActualDownloadSize)();
      STDMETHOD_(DWORD, GetCurrentPriority)();
      STDMETHOD(SetCurrentPriority)(DWORD dwPriority);


   protected:
      static char _szDetDllName[MAX_PATH];
      static HINSTANCE _hDetLib;
      char _szDesc[MAX_DISPLAYNAME_LENGTH];
      char _szDLDir[MAX_PATH];
      UINT _dwPlatform;
      UINT _uInstallStatus;
      UINT _uInstallCount;    // refcount of dependendant installs, 0x80000000 if directly installed
      UINT _uTotalProgress;
      UINT _uIndivProgress;
      UINT _uTotalGoal;
      UINT _uPhase;
      BOOL _fDependenciesQueued:1;
      BOOL _fUseSRLite:1;
      BOOL _fBeforeInstall:1;
  
      HRESULT _DownloadUrl(UINT uUrlNum, LPCSTR pszUrl, UINT dwType);
      BOOL    _FileIsDownloaded(LPCSTR pszFile, UINT i, DWORD *pdwSize);
      BOOL    _CompareDownloadInfo();
      void    _MarkAsInstalled();
      void    _MarkDownloadStarted();
      void    _MarkFileDownloadStarted(UINT i);
      void    _MarkFileDownloadFinished(LPCSTR pszFilePath, UINT i, LPCSTR pszFilename);
      HRESULT _CheckForTrust(LPCSTR pszURL, LPCSTR pszFilename);
      HRESULT _CopyAllUrls(LPCSTR pszTemp);
      void    _MarkComponentInstallStarted();
      HRESULT _RunAllCommands(LPCSTR psDir, DWORD *pdwStatus);
      HRESULT _ExtractFiles(UINT i, LPCSTR pszFile, DWORD dwType);
      HRESULT _CheckForDependencies(); 
      HRESULT _GetDetVerResult(LPCSTR pszDll, LPCSTR pszEntry, DETECTION_STRUCT *pDet, UINT *uStatus);
      HRESULT _SRLiteDownloadFiles();
      LPCSTR  GetDownloadDir() { return _szDLDir; }
      void    SetDownloadDir(LPCSTR pszDownloadDir);
};    

class CCifRWComponent : public ICifRWComponent, public CCifComponent
{
   public:
      // ICifComponent interface
      STDMETHOD(GetID)(LPSTR pszID, DWORD dwSize);
      STDMETHOD(GetGUID)(LPSTR pszGUID, DWORD dwSize);
      STDMETHOD(GetDescription)(LPSTR pszDesc, DWORD dwSize);
      STDMETHOD(GetDetails)(LPSTR pszDetails, DWORD dwSize);
      STDMETHOD(GetUrl)(UINT uUrlNum, LPSTR pszUrl, DWORD dwSize, LPDWORD pdwUrlFlags);
      STDMETHOD(GetFileExtractList)(UINT uUrlNum, LPSTR pszExtract, DWORD dwSize);
      STDMETHOD(GetUrlCheckRange)(UINT uUrlNum, LPDWORD pdwMin, LPDWORD pdwMax);
      STDMETHOD(GetCommand)(UINT uCmdNum, LPSTR pszCmd, DWORD dwCmdSize, LPSTR pszSwitches, 
                            DWORD dwSwitchSize, LPDWORD pdwType);
      STDMETHOD(GetVersion)(LPDWORD pdwVersion, LPDWORD pdwBuild);
      STDMETHOD(GetLocale)(LPSTR pszLocale, DWORD dwSize);
      STDMETHOD(GetUninstallKey)(LPSTR pszKey, DWORD dwSize);
      STDMETHOD(GetInstalledSize)(LPDWORD pdwWin, LPDWORD pdwApp);
      STDMETHOD_(DWORD, GetDownloadSize)();
      STDMETHOD_(DWORD, GetExtractSize)();
      STDMETHOD(GetSuccessKey)(LPSTR pszKey, DWORD dwSize);
      STDMETHOD(GetProgressKeys)(LPSTR pszProgress, DWORD dwProgSize, 
                                 LPSTR pszCancel, DWORD dwCancelSize);
      STDMETHOD(IsActiveSetupAware)();
      STDMETHOD(IsRebootRequired)();
      STDMETHOD(RequiresAdminRights)();
      STDMETHOD_(DWORD, GetPriority)();
      STDMETHOD(GetDependency)(UINT uDepNum, LPSTR pszID, DWORD dwBuf, char *pchType, LPDWORD pdwVer, LPDWORD pdwBuild);
      STDMETHOD_(DWORD, GetPlatform)();
      STDMETHOD(GetMode)(UINT uModeNum, LPSTR pszModes, DWORD dwSize);
      STDMETHOD(GetGroup)(LPSTR pszID, DWORD dwSize);
      STDMETHOD(IsUIVisible)();
      STDMETHOD(GetPatchID)(LPSTR pszID, DWORD dwSize);      
      STDMETHOD(GetDetVersion)(LPSTR pszDLL, DWORD dwdllSize, LPSTR pszEntry, DWORD dwentSize);
      STDMETHOD(GetTreatAsOneComponents)(UINT uNum, LPSTR pszID, DWORD dwBuf);
      STDMETHOD(GetCustomData)(LPSTR pszKey, LPSTR pszData, DWORD dwSize);

      // access to state
      STDMETHOD_(DWORD, IsComponentInstalled)();
      STDMETHOD(IsComponentDownloaded)();
      STDMETHOD_(DWORD, IsThisVersionInstalled)(DWORD dwAskVer, DWORD dwAskBld, LPDWORD pdwVersion, LPDWORD pdwBuild);
      STDMETHOD_(DWORD, GetInstallQueueState)();
      STDMETHOD(SetInstallQueueState)(DWORD dwState);
      STDMETHOD_(DWORD, GetActualDownloadSize)();
      STDMETHOD_(DWORD, GetCurrentPriority)();
      STDMETHOD(SetCurrentPriority)(DWORD dwPriority);

      // ICifRWComponent interface
      CCifRWComponent(LPCSTR pszID, CCifFile *pCif);
      ~CCifRWComponent();

      STDMETHOD(SetGUID)(THIS_ LPCSTR pszGUID);
      STDMETHOD(SetDescription)(THIS_ LPCSTR pszDesc);
      STDMETHOD(SetCommand)(THIS_ UINT uCmdNum, LPCSTR pszCmd, LPCSTR pszSwitches, DWORD dwType);
      STDMETHOD(SetVersion)(THIS_ LPCSTR pszVersion);
      STDMETHOD(SetUninstallKey)(THIS_ LPCSTR pszKey);
      STDMETHOD(SetInstalledSize)(THIS_ DWORD dwWin, DWORD dwApp);
      STDMETHOD(SetDownloadSize)(THIS_ DWORD);
      STDMETHOD(SetExtractSize)(THIS_ DWORD);
      STDMETHOD(DeleteDependency)(THIS_ LPCSTR pszID, char chType);
      STDMETHOD(AddDependency)(THIS_ LPCSTR pszID, char chType);
      STDMETHOD(SetUIVisible)(THIS_ BOOL);
      STDMETHOD(SetGroup)(THIS_ LPCSTR pszID);
      STDMETHOD(SetPlatform)(THIS_ DWORD);
      STDMETHOD(SetPriority)(THIS_ DWORD);
      STDMETHOD(SetReboot)(THIS_ BOOL);
      STDMETHOD(SetUrl)(THIS_ UINT uUrlNum, LPCSTR pszUrl, DWORD dwUrlFlags);   

      STDMETHOD(DeleteFromModes)(THIS_ LPCSTR pszMode);
      STDMETHOD(AddToMode)(THIS_ LPCSTR pszMode);
      STDMETHOD(SetModes)(THIS_ LPCSTR pszMode);
      STDMETHOD(CopyComponent)(THIS_ LPCSTR pszCifFile);
      STDMETHOD(AddToTreatAsOne)(THIS_ LPCSTR pszCompID);
      STDMETHOD(SetDetails)(THIS_ LPCSTR pszDesc);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\inseng\cifcomp.cpp ===
#include "inspch.h"
#include "inseng.h"
#include "insobj.h"
#include "util2.h"


#define MAX_VALUE_LEN 256
#define MAX_SMALL_BUF 64
#define NO_ENTRY ""

#define UNINSTALL_BRANCH  "Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall"

char g_pBuffer[BUFFERSIZE];

#define NUM_RETRIES 2
 

HINSTANCE CCifComponent::_hDetLib = NULL;
char      CCifComponent::_szDetDllName[] = "";

const char c_gszSRLiteOffset[] = "patch/";
char         gszIsPatchable[]  = "IsPatchable";


//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//


CCifComponent::CCifComponent(LPCSTR pszCompID, CCifFile *pCif) : CCifEntry(pszCompID, pCif) 
{
   _dwPlatform = 0xffffffff;
   _uInstallStatus = 0xffffffff;
   _uInstallCount = 0;
   _fDependenciesQueued = FALSE;
   _fUseSRLite = FALSE;
   _fBeforeInstall = TRUE;
   SetDownloadDir("");
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

CCifComponent::~CCifComponent()
{
   if(_hDetLib)
   {
      FreeLibrary(_hDetLib);
      _hDetLib = NULL;
   }
}



STDMETHODIMP CCifComponent::GetID(LPSTR pszID, DWORD dwSize)
{
   lstrcpyn(pszID, _szID, dwSize);
   return NOERROR;
}

STDMETHODIMP CCifComponent::GetGUID(LPSTR pszGUID, DWORD dwSize)
{
   return(GetPrivateProfileString(_szID, GUID_KEY, "", pszGUID, dwSize, _pCif->GetCifPath()) ? NOERROR : E_FAIL);      
}

STDMETHODIMP CCifComponent::GetDescription(LPSTR pszDesc, DWORD dwSize)
{
   return(MyTranslateString(_pCif->GetCifPath(), _szID, DISPLAYNAME_KEY, pszDesc, dwSize));
}

STDMETHODIMP CCifComponent::GetDetails(LPSTR pszDetails, DWORD dwSize)
{
   return(MyTranslateString(_pCif->GetCifPath(), _szID, DETAILS_KEY, pszDetails, dwSize));   
}

STDMETHODIMP CCifComponent::GetUrl(UINT uUrlNum, LPSTR pszUrl, DWORD dwSize, LPDWORD pdwUrlFlags)
{
   char szKey[16];
   char szBuf[MAX_VALUE_LEN];
   HRESULT hr = E_FAIL;

   // in cif, these things start at 1. we want to start at 0 when handing them out
   uUrlNum++;

   // Build up the key
   wsprintf(szKey, "%s%lu", URL_KEY, uUrlNum);
   GetPrivateProfileString(_szID, szKey, NO_ENTRY, szBuf, sizeof(szBuf), _pCif->GetCifPath());
   
   // See if there is any such entry
   if(lstrcmp(szBuf, NO_ENTRY) != 0)
   {
      // snatch the url name
      if(GetStringField(szBuf, 0, pszUrl, dwSize) != 0)
      {
         // This url looks ok
         hr = NOERROR;
      
         *pdwUrlFlags = GetIntField(szBuf, 1, URLF_DEFAULT);
      }
   }
   return hr;
}

STDMETHODIMP CCifComponent::GetFileExtractList(UINT uUrlNum, LPSTR pszExtract, DWORD dwSize)
{
   char szKey[16];
   char szBuf[MAX_VALUE_LEN];
   HRESULT hr = E_FAIL;

   uUrlNum++;

   // Build up the key
   wsprintf(szKey, "%s%lu", URL_KEY, uUrlNum);
   GetPrivateProfileString(_szID, szKey, NO_ENTRY, szBuf, sizeof(szBuf), _pCif->GetCifPath());
   
   // See if there is any such entry
   if(lstrcmp(szBuf, NO_ENTRY) != 0)
   {
      // snatch the extract list
      if(GetStringField(szBuf, 2, pszExtract, dwSize))
      hr = NOERROR;
   }
   return hr;
}

STDMETHODIMP CCifComponent::GetUrlCheckRange(UINT uUrlNum, LPDWORD pdwMin, LPDWORD pdwMax)
{
   char szKey[16];
   char szBuf[MAX_VALUE_LEN];
   HRESULT hr = E_FAIL;

   uUrlNum++;
   *pdwMin = *pdwMax = 0;

   // Build up the key
   wsprintf(szKey, "%s%lu", URLSIZE_KEY, uUrlNum);
   GetPrivateProfileString(_szID, szKey, NO_ENTRY, szBuf, sizeof(szBuf), _pCif->GetCifPath());
   
   // See if there is any such entry
   if(lstrcmp(szBuf, NO_ENTRY) != 0)
   {
      // snatch the extract list
      *pdwMin = GetIntField(szBuf, 0, 0);
      *pdwMax = GetIntField(szBuf, 1, *pdwMin);
   }
   return hr;
}

STDMETHODIMP CCifComponent::GetCommand(UINT uCmdNum, LPSTR pszCmd, DWORD dwCmdSize, 
                                       LPSTR pszSwitches, DWORD dwSwitchSize, LPDWORD pdwType)
{
   char szKey[16];
   HRESULT hr = E_FAIL;
 
   uCmdNum++;
   // Build up the key
   wsprintf(szKey, "%s%lu", CMD_KEY, uCmdNum);
   GetPrivateProfileString(_szID, szKey, NO_ENTRY, pszCmd, dwCmdSize, _pCif->GetCifPath());
   if(lstrcmp(pszCmd, NO_ENTRY) != 0)
   {
      // Build up the key
      wsprintf(szKey, "%s%d", ARGS_KEY, uCmdNum);
      GetPrivateProfileString(_szID, szKey, NO_ENTRY, pszSwitches, dwSwitchSize, _pCif->GetCifPath());
      // expand #W (or #w) to windows directory
      ExpandString( pszSwitches, dwSwitchSize );
   
      // Build up the key
      wsprintf(szKey, "%s%d", TYPE_KEY, uCmdNum);
   
      *pdwType = GetPrivateProfileInt(_szID, szKey, CMDF_DEFAULT, _pCif->GetCifPath());

      hr = NOERROR;
   }
   return hr;
}

STDMETHODIMP CCifComponent::GetVersion(LPDWORD pdwVersion, LPDWORD pdwBuild)
{
   char szBuf[MAX_VALUE_LEN];

   szBuf[0] = '\0';

   // Version
   GetPrivateProfileString(_szID, VERSION_KEY, "", szBuf, sizeof(szBuf), _pCif->GetCifPath());
   ConvertVersionStrToDwords(szBuf, pdwVersion, pdwBuild);
   return NOERROR;
}
      
STDMETHODIMP CCifComponent::GetLocale(LPSTR pszLocale, DWORD dwSize)
{
   if(FAILED(MyTranslateString(_pCif->GetCifPath(), _szID, LOCALE_KEY, pszLocale, dwSize)))
      lstrcpyn(pszLocale, DEFAULT_LOCALE, dwSize);

   return NOERROR;
}

STDMETHODIMP CCifComponent::GetUninstallKey(LPSTR pszKey, DWORD dwSize)
{
   return(GetPrivateProfileString(_szID, UNINSTALLSTRING_KEY, "", pszKey, dwSize, _pCif->GetCifPath()) ? NOERROR : E_FAIL);      
}

STDMETHODIMP CCifComponent::GetInstalledSize(LPDWORD pdwWin, LPDWORD pdwApp)
{
   char szBuf[MAX_VALUE_LEN];

   if(GetPrivateProfileString(_szID, INSTALLSIZE_KEY, "", szBuf, sizeof(szBuf), _pCif->GetCifPath()))
   {
      *pdwApp = GetIntField(szBuf, 0, 0);
      *pdwWin = GetIntField(szBuf, 1, 0);
   }
   else
   {
      *pdwWin = 0;
      *pdwApp = 2 * GetDownloadSize();
   }
   return NOERROR;
}

STDMETHODIMP_(DWORD) CCifComponent::GetDownloadSize()
{
   char szBuf[MAX_VALUE_LEN];

   szBuf[0] = '\0';

   // Read in size
   GetPrivateProfileString(_szID, SIZE_KEY, "0,0", szBuf, sizeof(szBuf), _pCif->GetCifPath());   
   return(GetIntField(szBuf, 0, 0));
}   

STDMETHODIMP_(DWORD) CCifComponent::GetExtractSize()
{
   char szBuf[MAX_VALUE_LEN];
   DWORD dwSize;

   szBuf[0] = '\0'; 

   // Read in size
   GetPrivateProfileString(_szID, SIZE_KEY, "0,0", szBuf, sizeof(szBuf), _pCif->GetCifPath());   
   dwSize = GetIntField(szBuf, 1, 2 * GetIntField(szBuf, 0, 0));
   
   return dwSize;
}   

STDMETHODIMP CCifComponent::GetSuccessKey(LPSTR pszKey, DWORD dwSize)
{
   return(GetPrivateProfileString(_szID, SUCCESS_KEY, "", pszKey, dwSize, _pCif->GetCifPath()) ? NOERROR : E_FAIL);      
}

STDMETHODIMP CCifComponent::GetProgressKeys(LPSTR pszProgress, DWORD dwProgSize, LPSTR pszCancel, DWORD dwCancelSize)
{
   GetPrivateProfileString(_szID, PROGRESS_KEY, "", pszProgress, dwProgSize, _pCif->GetCifPath());
   GetPrivateProfileString(_szID, MUTEX_KEY, "", pszCancel, dwCancelSize, _pCif->GetCifPath());
   if(*pszProgress != 0 || *pszCancel != 0)
      return NOERROR;
   else
      return E_FAIL;
}

STDMETHODIMP CCifComponent::IsActiveSetupAware()
{
   return(GetPrivateProfileInt(_szID, ACTSETUPAWARE_KEY, 0, _pCif->GetCifPath()) ? S_OK : S_FALSE);
}

STDMETHODIMP CCifComponent::IsRebootRequired()
{
   return(GetPrivateProfileInt(_szID, REBOOT_KEY, 0, _pCif->GetCifPath()) ? S_OK : S_FALSE);
}

STDMETHODIMP CCifComponent::RequiresAdminRights()
{
   return(GetPrivateProfileInt(_szID, ADMIN_KEY, 0, _pCif->GetCifPath()) ? S_OK : S_FALSE);
}

STDMETHODIMP_(DWORD) CCifComponent::GetPriority()
{
   return(GetPrivateProfileInt(_szID, PRIORITY, 0, _pCif->GetCifPath()));
}

STDMETHODIMP CCifComponent::GetDependency(UINT uDepNum, LPSTR pszID, DWORD dwBuf, char *pchType, LPDWORD pdwVer, LPDWORD pdwBuild)
{
   char szBuf[MAX_VALUE_LEN];
   char szBuf2[MAX_VALUE_LEN];
   HRESULT hr = E_FAIL;
   DWORD dwLen;
   LPSTR pszTemp;
   DWORD dwV, dwBld;

   dwV = dwBld = 0xffffffff;

   if(GetPrivateProfileString(_szID, DEPENDENCY_KEY, NO_ENTRY, szBuf2, sizeof(szBuf2), _pCif->GetCifPath()))
   {
      if(GetStringField(szBuf2, uDepNum, szBuf, sizeof(szBuf)))
      {
         // Do some funky parsing 
         dwLen = lstrlen(szBuf);
         *pchType = DEP_INSTALL;

         pszTemp = FindChar(szBuf, ':');
         if(*pszTemp)
         {
            *pszTemp = 0;
            lstrcpyn(pszID, szBuf, dwBuf);
            pszTemp++;
            *pchType = *pszTemp;
            // see if we have a version
            pszTemp = FindChar(pszTemp, ':');
            if(*pszTemp)
            {
               pszTemp++;
               // wierdness - scan the string, convert . to , for parsing
               LPSTR pszTemp2 = pszTemp;
               while(*pszTemp2 != 0)
               {
                  if(*pszTemp2 == '.')
                     *pszTemp2 = ',';
                  pszTemp2++;
               }
               
               ConvertVersionStrToDwords(pszTemp, &dwV, &dwBld);
               
            }
         }
         else
            lstrcpyn(pszID, szBuf, dwBuf);
      
         if(dwV == 0xffffffff && dwBld == 0xffffffff)
         {
            // get version of dependency from cif
            ICifComponent *pcomp;
              
            if(SUCCEEDED(_pCif->FindComponent(pszID, &pcomp)))
               pcomp->GetVersion(&dwV, &dwBld);
         }
         hr = NOERROR;
      }
           
   }
   if(pdwVer)
      *pdwVer = dwV;

   if(pdwBuild)
      *pdwBuild = dwBld;

   return hr;
}

LPSTR g_pszComp[] = { "Branding.cab", 
                      "desktop.cab", 
                      "custom0", 
                      "custom1",
                      "custom2",
                      "custom3",
                      "custom4",
                      "custom5",
                      "custom6",
                      "custom7",
                      "custom8",
                      "custom9",
                      "CustIcmPro",
                      NULL};

STDMETHODIMP_(DWORD) CCifComponent::GetPlatform()
{
   if(_dwPlatform == 0xffffffff)
   {
      char *rszPlatforms[7] = { STR_WIN95, STR_WIN98, STR_NT4, STR_NT5, STR_NT4ALPHA, STR_NT5ALPHA,STR_MILLEN };
      DWORD rdwPlatforms[] = { PLATFORM_WIN95, PLATFORM_WIN98, PLATFORM_NT4, PLATFORM_NT5, 
         PLATFORM_NT4ALPHA, PLATFORM_NT5ALPHA, PLATFORM_MILLEN };
      char szBuf[MAX_VALUE_LEN];
      char szPlatBuf[MAX_VALUE_LEN];
      BOOL  bFound = FALSE;
      int i = 0;

      while (!bFound && g_pszComp[i])
      {
          bFound = (lstrcmpi(g_pszComp[i], _szID) == 0);
          i++;
      }
      
      _dwPlatform = 0;

      if(!bFound && GetPrivateProfileString(_szID, PLATFORM_KEY, NO_ENTRY, szBuf, sizeof(szBuf), _pCif->GetCifPath()))
      {
         int j = 0;
         while(GetStringField(szBuf, j++, szPlatBuf, sizeof(szPlatBuf)))
         {
            for(int i = 0; i < 7; i++)
            {
               if(lstrcmpi(szPlatBuf, rszPlatforms[i]) == 0)
               {
                  // check if we should add this platform for this component.
                  if ((GetCurrentPlatform() != rdwPlatforms[i])  ||
                       !DisableComponent())
                    _dwPlatform |= rdwPlatforms[i];
               }
            }
         }
      }
      else
         _dwPlatform = PLATFORM_WIN95 | PLATFORM_WIN98 | PLATFORM_NT4 | PLATFORM_NT5 | PLATFORM_NT4ALPHA | PLATFORM_NT5ALPHA | PLATFORM_MILLEN;
   }
   return _dwPlatform;
}

STDMETHODIMP_(BOOL) CCifComponent::DisableComponent()
{
   BOOL bDisableComp = FALSE;
   BOOL bGuidMatch = FALSE;
   HKEY hKey;
   DWORD dwIndex = 0;
   CHAR szGUIDComp[MAX_VALUE_LEN];
   CHAR szGUID[MAX_VALUE_LEN];
   DWORD dwGUIDSize = sizeof(szGUID);
   CHAR szData[MAX_VALUE_LEN];
   DWORD dwDataSize = sizeof(szData);
   LPSTR pTmp;
   DWORD dwVersion , dwBuild;
   DWORD dwInstallVer, dwInstallBuild;

   if(RegOpenKeyExA(HKEY_LOCAL_MACHINE, COMPONENTBLOCK_KEY, 0, KEY_READ, &hKey) == ERROR_SUCCESS)
   {
      while (!bDisableComp &&
             (RegEnumValue(hKey, dwIndex, szGUID, &dwGUIDSize, NULL, NULL,
                         (LPBYTE)szData, &dwDataSize) == ERROR_SUCCESS) )
      {
         GetGUID(szGUIDComp, sizeof(szGUIDComp));
         pTmp = ANSIStrChr( szGUID, '*' );
         if (pTmp)
         {
            // If there is a * assume it is at the end
            *pTmp = '\0';
            szGUIDComp[lstrlen(szGUID)] = '\0';
         }
         bGuidMatch = (lstrcmpi(szGUID, szGUIDComp) == 0);
         // Did the Guids match?
         if (bGuidMatch)
         {
            // now see if we have version info.
            if (dwDataSize == 0)
               bDisableComp = TRUE;
            else
            {
               // Convert the versin number for the registry
               ConvertVersionStrToDwords(szData, &dwVersion, &dwBuild);
               if (dwVersion == 0)
                  bDisableComp = TRUE;
               else
               {
                  // Get the versin we would install.
                  GetVersion(&dwInstallVer, &dwInstallBuild);
                  // If the version we would install is equal or less, disable the component.
                  if ((dwInstallVer < dwVersion) ||
                      ((dwInstallVer == dwVersion) && (dwInstallBuild <= dwBuild)) )
                     bDisableComp = TRUE;
               }
            }
         }
         dwGUIDSize = sizeof(szGUID);
         dwDataSize = sizeof(szData);
         dwIndex++;
      }
      RegCloseKey(hKey);
   }
   return bDisableComp;
}

STDMETHODIMP CCifComponent::GetMode(UINT uModeNum, LPSTR pszMode, DWORD dwSize)
{
   char szBuf[MAX_VALUE_LEN];

   if(FAILED(MyTranslateString(_pCif->GetCifPath(), _szID, MODES_KEY, szBuf, sizeof(szBuf))))
      return E_FAIL;
   return(GetStringField(szBuf, uModeNum, pszMode, dwSize) ? NOERROR : E_FAIL);
   
}

STDMETHODIMP CCifComponent::GetGroup(LPSTR pszID, DWORD dwSize)
{
   return(GetPrivateProfileString(_szID, GROUP_KEY, "", pszID, dwSize, _pCif->GetCifPath()) ? NOERROR : E_FAIL); 
}

STDMETHODIMP CCifComponent::IsUIVisible()
{
   return(GetPrivateProfileInt(_szID, UIVISIBLE_KEY, 1, _pCif->GetCifPath()) ? S_OK : S_FALSE);
}


STDMETHODIMP CCifComponent::GetPatchID(LPSTR pszID, DWORD dwSize)
{
   return(GetPrivateProfileString(_szID, PATCHID_KEY, "", pszID, dwSize, _pCif->GetCifPath()) ? NOERROR : E_FAIL); 
}

STDMETHODIMP CCifComponent::GetTreatAsOneComponents(UINT uNum, LPSTR pszID, DWORD dwBuf)
{
   char szBuf[MAX_VALUE_LEN];

   szBuf[0] = '\0';

   GetPrivateProfileString(_szID, TREATAS_KEY, "", szBuf, sizeof(szBuf), _pCif->GetCifPath());
   return(GetStringField(szBuf, uNum, pszID, dwBuf) ? NOERROR : E_FAIL);
}

STDMETHODIMP CCifComponent::GetCustomData(LPSTR pszKey, LPSTR pszData, DWORD dwSize)
{
   char szNewKey[MAX_VALUE_LEN];

   wsprintf(szNewKey, "_%s", pszKey);

   return(MyTranslateString(_pCif->GetCifPath(), _szID, szNewKey, pszData, dwSize));
}


STDMETHODIMP_(DWORD) CCifComponent::IsComponentInstalled()
{
   CHAR szCifBuf[512];
   CHAR szCompBuf[512];
   CHAR szGUID[MAX_VALUE_LEN];
   CHAR szLocale[8];
   HKEY hComponentKey = NULL;
   DETECTION_STRUCT Det;
   
   DWORD dwCifVer, dwCifBuild, dwInstalledVer, dwInstalledBuild;
   DWORD dwUnused, dwType, dwIsInstalled;
   BOOL bVersionFound = FALSE;
   
   if(_uInstallStatus  != ICI_NOTINITIALIZED)
      return _uInstallStatus;

   _uInstallStatus = ICI_NOTINSTALLED;

   // use detection dll first if it is available
   if ( SUCCEEDED(GetDetVersion(szCifBuf, sizeof(szCifBuf), szCompBuf, sizeof(szCompBuf))))
   {
      GetVersion(&dwCifVer, &dwCifBuild);
      Det.dwSize = sizeof(DETECTION_STRUCT);
      Det.pdwInstalledVer = &dwInstalledVer;
      Det.pdwInstalledBuild = &dwInstalledBuild;
      GetLocale(szLocale, sizeof(szLocale));
      Det.pszLocale = szLocale;
      GetGUID(szGUID, sizeof(szGUID));
      Det.pszGUID = szGUID;
      Det.dwAskVer = dwCifVer;
      Det.dwAskBuild = dwCifBuild;
      Det.pCifFile = (ICifFile *) _pCif;
      Det.pCifComp = (ICifComponent *) this; 
      if (SUCCEEDED(_GetDetVerResult(szCifBuf, szCompBuf, &Det, &_uInstallStatus)))
      {
         // only wizard want to know this status, if the newer version is installed, means Installed.
         if (_uInstallStatus == ICI_OLDVERSIONAVAILABLE)
            _uInstallStatus = ICI_INSTALLED;
         return _uInstallStatus;
      }
   }
   
   // Build GUID Key
   lstrcpy(szCompBuf, COMPONENT_KEY);
   lstrcat(szCompBuf, "\\");
   GetGUID(szCifBuf, sizeof(szCifBuf));
   lstrcat(szCompBuf, szCifBuf);

   if(RegOpenKeyExA(HKEY_LOCAL_MACHINE, szCompBuf, 0, KEY_READ, &hComponentKey) == ERROR_SUCCESS)
   {
      // first check for the IsInstalled valuename
      // if the valuename is there AND equals zero, we say not installed.
      // otherwise continue.
      // NOTE: We default to ISINSTALLED_YES if valuename not present to be Back-compatible
      // with when we didn't write this valuename at all.....

      dwUnused = sizeof(dwIsInstalled);
      if(RegQueryValueEx(hComponentKey, ISINSTALLED_KEY, 0, NULL, (LPBYTE) (&dwIsInstalled), &dwUnused) != ERROR_SUCCESS)
         dwIsInstalled = ISINSTALLED_YES;
           
      if(dwIsInstalled == ISINSTALLED_YES)
      {

         // next check for a locale match (no locale entry use default)
         dwUnused = sizeof(szCompBuf);
         if(RegQueryValueEx(hComponentKey, LOCALE_KEY, 0, NULL, (LPBYTE) szCompBuf, &dwUnused) != ERROR_SUCCESS)
            lstrcpy(szCompBuf, DEFAULT_LOCALE);

         GetLocale(szCifBuf, sizeof(szCifBuf));
         
         if(_fBeforeInstall || (CompareLocales(szCompBuf, szCifBuf) == 0))
         {
            // locales match so go check the version
                 
            // first check for updated version key
            dwUnused = sizeof(szCompBuf);
            bVersionFound = (RegQueryValueEx(hComponentKey, QFE_VERSION_KEY, 
                    0, &dwType, (LPBYTE) szCompBuf, &dwUnused) == ERROR_SUCCESS);
            
              // if QFEVersion doesn't exist, look for version
            if(!bVersionFound)
            {
               dwUnused = sizeof(szCompBuf);
               bVersionFound = (RegQueryValueEx(hComponentKey, VERSION_KEY, 
                    0, &dwType, (LPBYTE) szCompBuf, &dwUnused) == ERROR_SUCCESS);
            }

            // figure out if we have REG_STR 
            if(bVersionFound)
            {
               // if we have a string convert to ver, if we have binary directly copy into version struct
               if(dwType == REG_SZ)
               {
                  ConvertVersionStrToDwords(szCompBuf, &dwInstalledVer, &dwInstalledBuild);
               
                  GetVersion(&dwCifVer, &dwCifBuild);
               
                  if( (dwInstalledVer >  dwCifVer) ||
                     ((dwInstalledVer == dwCifVer) && (dwInstalledBuild >= dwCifBuild)) )
                  {
                     _uInstallStatus = ICI_INSTALLED;
                  }
                  else
                  {
                     _uInstallStatus = ICI_NEWVERSIONAVAILABLE;
                  }
               }
               else
                  _uInstallStatus = ICI_NEWVERSIONAVAILABLE;
            }
         }
      }
   }
   if(hComponentKey)
      RegCloseKey(hComponentKey);
   
   // We think its installed, now check 
   if(_uInstallStatus != ICI_NOTINSTALLED)
   {
      // if there is an uninstall key to check do it
      if(SUCCEEDED(GetUninstallKey(szCompBuf, sizeof(szCompBuf))))
      {
         
         if(!UninstallKeyExists(szCompBuf))
         {   
            _uInstallStatus = ICI_NOTINSTALLED;
         }
         else
         {
            // if there is a success key to check do it
            if(SUCCEEDED(GetSuccessKey(szCompBuf, sizeof(szCompBuf))))
            {
               if(!SuccessCheck(szCompBuf))
               {   
                  _uInstallStatus = ICI_NOTINSTALLED;
               }
            }
         }
      }
   }
   return _uInstallStatus;
}

   

STDMETHODIMP CCifComponent::IsComponentDownloaded()
{
   if(GetActualDownloadSize() == 0)
      return S_OK;
   else
      return S_FALSE;
}

STDMETHODIMP_(DWORD) CCifComponent::IsThisVersionInstalled(DWORD dwAskVer, DWORD dwAskBld, LPDWORD pdwVersion, LPDWORD pdwBuild)
{
   CHAR szCifBuf[512];
   CHAR szCompBuf[512];
   CHAR szLocale[8];
   CHAR szGUID[MAX_VALUE_LEN];
   DETECTION_STRUCT Det;
   HKEY hComponentKey = NULL;
   UINT uStatus = ICI_NOTINSTALLED;

   *pdwVersion = 0;
   *pdwBuild = 0;
   
   // use detection dll first if it is available
   if ( SUCCEEDED(GetDetVersion(szCifBuf, sizeof(szCifBuf), szCompBuf, sizeof(szCompBuf))))
   {
      Det.dwSize = sizeof(DETECTION_STRUCT);
      Det.pdwInstalledVer = pdwVersion;
      Det.pdwInstalledBuild = pdwBuild;
      GetLocale(szLocale, sizeof(szLocale));
      Det.pszLocale = szLocale;
      GetGUID(szGUID, sizeof(szGUID));
      Det.pszGUID = szGUID;
      Det.dwAskVer = dwAskVer;
      Det.dwAskBuild = dwAskBld;
      Det.pCifFile = (ICifFile *) _pCif;
      Det.pCifComp = (ICifComponent *) this; 
      if (SUCCEEDED(_GetDetVerResult(szCifBuf, szCompBuf, &Det, &uStatus)))
      {
         return uStatus;
      }
   }

   if(IsComponentInstalled() == ICI_NOTINSTALLED)
      return uStatus;

   DWORD dwUnused, dwType;
   BOOL bVersionFound = FALSE;

    // Build GUID Key
   lstrcpy(szCompBuf, COMPONENT_KEY);
   lstrcat(szCompBuf, "\\");
   GetGUID(szCifBuf, sizeof(szCifBuf));
   lstrcat(szCompBuf, szCifBuf);

   if(RegOpenKeyExA(HKEY_LOCAL_MACHINE, szCompBuf, 0, KEY_READ, &hComponentKey) == ERROR_SUCCESS)
   {
      // first check for updated version key
      dwUnused = sizeof(szCompBuf);
      bVersionFound = (RegQueryValueEx(hComponentKey, QFE_VERSION_KEY, 
                0, &dwType, (LPBYTE) szCompBuf, &dwUnused) == ERROR_SUCCESS);
            
      // if QFEVersion doesn't exist, look for version
      if(!bVersionFound)
      {
         dwUnused = sizeof(szCompBuf);
         bVersionFound = (RegQueryValueEx(hComponentKey, VERSION_KEY, 
                  0, &dwType, (LPBYTE) szCompBuf, &dwUnused) == ERROR_SUCCESS);
      }

      //figure out if we have REG_STR 
      if(bVersionFound)
      {
         // if we have a string convert to ver, if we have binary directly copy into version struct
         if(dwType == REG_SZ)
         {
            ConvertVersionStrToDwords(szCompBuf, pdwVersion, pdwBuild);

            if((*pdwVersion == dwAskVer) && (*pdwBuild == dwAskBld) )
            {
               uStatus = ICI_INSTALLED;
            }
            else if ((*pdwVersion >  dwAskVer) ||
                     (*pdwVersion == dwAskVer) && (*pdwBuild > dwAskBld) )
            {
               uStatus = ICI_OLDVERSIONAVAILABLE;
            }
            else
            {
               uStatus = ICI_NEWVERSIONAVAILABLE;
            }            
         }
         else
            uStatus = ICI_NEWVERSIONAVAILABLE;
      }
      RegCloseKey(hComponentKey);
   }
   return uStatus;
}
 
STDMETHODIMP_(DWORD) CCifComponent::GetInstallQueueState()
{
   if(_uInstallCount)
      return SETACTION_INSTALL;
   else
      return SETACTION_NONE;
}

STDMETHODIMP CCifComponent::SetInstallQueueState(DWORD dwState)
{
   HRESULT hr = NOERROR;
   DWORD  uDependencyAction; 
   char szCompBuf[MAX_ID_LENGTH];
   char chType;
   ICifComponent *pcomp;
   BOOL fProcessDependencies = TRUE;

   // check to see if we allow install on this platform
   if((dwState != SETACTION_NONE) && (dwState != SETACTION_DEPENDENCYNONE) && 
      !_pCif->GetInstallEngine()->AllowCrossPlatform())
   {
      if(!(GetPlatform() & GetCurrentPlatform()))
         return S_FALSE;
   }

   switch(dwState)
   {
      case SETACTION_INSTALL:
         // check if it was already on. If so, don't process dependencies
         if(_uInstallCount & 0x80000000)
            fProcessDependencies = FALSE;
         
         _uInstallCount |= 0x80000000;
         uDependencyAction = SETACTION_DEPENDENCYINSTALL;
         break;
      case SETACTION_DEPENDENCYINSTALL:
         _uInstallCount++;
         uDependencyAction = SETACTION_DEPENDENCYINSTALL;
         break;
      case SETACTION_NONE:
         // check if it was not on to begin with. If not, don't process dependencies
         if(!(_uInstallCount & 0x80000000))
            fProcessDependencies = FALSE;

         _uInstallCount &= 0x7fffffff;
         uDependencyAction = SETACTION_DEPENDENCYNONE;
         break;
      case SETACTION_DEPENDENCYNONE:
         // if our depdency refcount is greater than zero, decrement it.
         // this allows us to unconditionally call this when an item is "unqueued"
         if(_uInstallCount & 0x7fffffff) _uInstallCount--;
         uDependencyAction = SETACTION_DEPENDENCYNONE;
         break;
      default:
         hr = E_INVALIDARG;
         break;
   }
   
   // now set each dependency, if needed
   if(SUCCEEDED(hr) && fProcessDependencies)
   {
      if(!_fDependenciesQueued)
      {
         _fDependenciesQueued = TRUE;
         DWORD dwNeedVer, dwNeedBuild, dwInsVer, dwInsBuild;
         for(int i = 0; SUCCEEDED(GetDependency(i, szCompBuf, sizeof(szCompBuf), &chType, &dwNeedVer, &dwNeedBuild)); i++)
         {
            if(chType == DEP_INSTALL || chType == DEP_BUDDY)
            {
               if(SUCCEEDED(_pCif->FindComponent(szCompBuf, &pcomp)))
               {
                  // queue for install if
                  //  1. Not installed
                  //  2. Not a good enough version
                  //  3. FORCEDEPENDIECIES is set
                  UINT uStatus = pcomp->IsThisVersionInstalled(dwNeedVer, dwNeedBuild, &dwInsVer, &dwInsBuild);
                  if( (uStatus == ICI_NOTINSTALLED) || 
                      (uStatus == ICI_NEWVERSIONAVAILABLE) ||
                      (_pCif->GetInstallEngine()->ForceDependencies()) )
                     pcomp->SetInstallQueueState(uDependencyAction);
               }

            }
         }
            
         _fDependenciesQueued = FALSE;
      }
   }
   
   
   return hr;
}
 

STDMETHODIMP_(DWORD) CCifComponent::GetActualDownloadSize()
{
   char szCompBuf[MAX_PATH];
   LPSTR pszFilename = NULL;
   LPSTR pszPathEnd = NULL;
   DWORD dwUrlSize, dwFlags;
   DWORD dwTotalSize = 0;
   BOOL alldownloaded = TRUE;

   if (_fUseSRLite)
   {
       // Let the patching engine determine the correct value
       dwTotalSize = 0;
   }
   else
   {

       if(_CompareDownloadInfo())
       {
          // so our versions match correctly, check each file
          for(UINT i = 0; SUCCEEDED(GetUrl(i, szCompBuf, sizeof(szCompBuf), &dwFlags)); i++)  
          {
             pszFilename = ParseURLA(szCompBuf);

             if(_FileIsDownloaded(pszFilename, i, &dwUrlSize))
                dwTotalSize += dwUrlSize;
             else
                alldownloaded = FALSE;
          }
       }
       else
          alldownloaded = FALSE;

       if(alldownloaded)
          dwTotalSize = 0;
       else
          dwTotalSize = GetDownloadSize() - (dwTotalSize >> 10);
   }

   return dwTotalSize;
}

HRESULT CCifComponent::OnProgress(ULONG uProgSoFar, LPCSTR pszStatus)
{
   _uIndivProgress = uProgSoFar;
   if(_uTotalProgress + _uIndivProgress > _uTotalGoal)
      _uIndivProgress = _uTotalGoal - _uTotalProgress;

   _pCif->GetInstallEngine()->OnComponentProgress(_szID, _uPhase, _szDesc, 
                               pszStatus, _uTotalProgress + _uIndivProgress, _uTotalGoal); 

   return NOERROR;
}
 


STDMETHODIMP_(DWORD) CCifComponent::GetCurrentPriority()
{
   if(_uPriority == 0xffffffff)
   {
      char szID[MAX_ID_LENGTH];
      ICifGroup *pgrp;

      _uPriority = 0;
      GetGroup(szID, sizeof(szID));
      
      if(SUCCEEDED(_pCif->FindGroup(szID, &pgrp)))
      {
         _uPriority = pgrp->GetCurrentPriority();
      }
      _uPriority += GetPriority();
   }
   return _uPriority;
}

STDMETHODIMP CCifComponent::SetCurrentPriority(DWORD dwPriority)
{
   _uPriority = dwPriority;

   // priorities may have changed need to resort
   _pCif->ReinsertComponent(this);
   return NOERROR;
}

HRESULT CCifComponent::Download()
{
   char szBuf[INTERNET_MAX_URL_LENGTH];
   HRESULT hr = NOERROR;
   DWORD uType;

   GetDescription(_szDesc, sizeof(_szDesc));
   // BUGBUG:  Download size isn't accurate for SR lite and patching
   _uTotalGoal = GetActualDownloadSize();

   // Engage SR lite behavior only if we're going to install the component,
   // and the new advpack extension is available.
   DWORD dwOptions = 0;
   BOOL fRetryClassic = TRUE;
   CHAR szCompBuf[MAX_VALUE_LEN];
   CHAR szDir[MAX_PATH];
   LPSTR pszSubDir = NULL;
   CHAR szCanPatch[MAX_VALUE_LEN];

   lstrcpyn(szDir, _pCif->GetDownloadDir(), sizeof(szDir));
   SetDownloadDir(szDir);

   if (IsPatchableIEVersion() &&
       SUCCEEDED(_pCif->GetInstallEngine()->GetInstallOptions(&dwOptions)) &&
       (dwOptions & INSTALLOPTIONS_INSTALL) &&
       (dwOptions & INSTALLOPTIONS_DOWNLOAD) &&
       _pCif->GetInstallEngine()->IsAdvpackExtAvailable() &&
       _pCif->GetInstallEngine()->GetPatchDownloader()->IsEnabled() &&
       SUCCEEDED(GetCustomData(gszIsPatchable, szCanPatch, sizeof(szCanPatch))) &&
       lstrcmp(szCanPatch, "1") == 0)
   {
       _fUseSRLite = TRUE;
       // Adjust the download directory
       // The idea here is that the download directory will contain
       // subdirectories which will contain the empty cabs + inf +
       // the downloaded files.
       //
       GetID(szCompBuf, sizeof(szCompBuf));

       wsprintf(szLogBuf, "Attempting to download empty cabs for %s\r\n", szCompBuf);
       _pCif->GetInstallEngine()->WriteToLog(szLogBuf, FALSE);

       AddPath(szDir, szCompBuf);
       SetDownloadDir(szDir);

       if (GetFileAttributes(szDir) == 0xFFFFFFFF)
           CreateDirectory(szDir, NULL);
   }
   
   _pCif->GetInstallEngine()->OnStartComponent(_szID, _uTotalGoal, 0 , _szDesc);

   _MarkDownloadStarted();

   // check for disk space
   _uPhase = INSTALLSTATUS_INITIALIZING;
   _pCif->GetInstallEngine()->OnComponentProgress(_szID, _uPhase, _szDesc, NULL, 0, 0); 

   if(!IsEnoughSpace(GetDownloadDir(), _uTotalGoal))
      hr = E_FAIL;
   
   _uTotalProgress = 0;
   for(int i = 0; SUCCEEDED(hr) && SUCCEEDED(GetUrl(i, szBuf, sizeof(szBuf), &uType)); i++)
   {
      // Change the download loc to point to the special
      // "empty cab" location, so we can download the empty
      // cabs + the INF that will contain instructions for
      // generating the file list for this type of installation.
      //
      // Assume the new download loc to be in the "patch" subdirectory
      // relative to the passed in URL
      //
      // BUGBUG... only handle the case for relative URLs
      if (_fUseSRLite && (uType & URLF_RELATIVEURL) && lstrlen(c_gszSRLiteOffset) + lstrlen(szBuf) < INTERNET_MAX_URL_LENGTH)
      {
          char szBuf2[INTERNET_MAX_URL_LENGTH];
          lstrcpy(szBuf2, c_gszSRLiteOffset);
          lstrcat(szBuf2, szBuf);
          
          hr = _DownloadUrl(i, szBuf2, uType);

          wsprintf(szLogBuf, "Empty cab download of %s returned 0x%lx\r\n", szBuf2, hr);
          _pCif->GetInstallEngine()->WriteToLog(szLogBuf, FALSE);
      }
      else
      {
          wsprintf(szLogBuf, "Initial download attempt will be tried as a full download.\r\n");
          _pCif->GetInstallEngine()->WriteToLog(szLogBuf, FALSE);
          // No need to retry because the first attempt will be the old way...
          fRetryClassic = FALSE;

          // Restore the download dir to the same state as a normal
          // full download.
          if (_fUseSRLite)
          {
              SetDownloadDir(_pCif->GetDownloadDir());

              // Ensure we're set to false...just in case there was a problem
              // with obtaining the URL for the SR Lite download.
              _fUseSRLite = FALSE;
          }
          hr = _DownloadUrl(i, szBuf, uType);
      }
   }

   if (_fUseSRLite && SUCCEEDED(hr))
   {
       // Ok...time for the real action of using advpext.dll to
       // download the needed files.
       hr = _SRLiteDownloadFiles();
   }

   if (_fUseSRLite && !SUCCEEDED(hr))
   {
       DelNode(szDir, 0);
       // Restore the download dir
       SetDownloadDir(_pCif->GetDownloadDir());
   }

   if(SUCCEEDED(hr))
      _uPhase = INSTALLSTATUS_DOWNLOADFINISHED;
   else if (_fUseSRLite && fRetryClassic)
   {
       // Fall back to downloading the full cabs.
       _fUseSRLite = FALSE;

       _pCif->GetInstallEngine()->WriteToLog("Retrying via full download\r\n", FALSE);

       hr = S_OK;
       // this re-sets the progress for the retry 
       _uPhase = INSTALLSTATUS_DOWNLOADING;
       _pCif->GetInstallEngine()->OnComponentProgress(_szID, _uPhase, _szDesc, NULL, 0, 0); 
       _uTotalProgress = 0;

       for(int i = 0; SUCCEEDED(hr) && SUCCEEDED(GetUrl(i, szBuf, sizeof(szBuf), &uType)); i++)
       {
          hr = _DownloadUrl(i, szBuf, uType);
       }
       if(SUCCEEDED(hr))
          _uPhase = INSTALLSTATUS_DOWNLOADFINISHED;
   }
   
   _pCif->GetInstallEngine()->OnStopComponent(_szID, hr, _uPhase, _szDesc, 0);
   return hr;
}

HRESULT CCifComponent::_DownloadUrl(UINT uUrlNum, LPCSTR pszUrl, UINT uType)
{
   // call the downloader
   // check the file
   // if good
   //     move to download dir
   // else
   //     redo
   HRESULT hr;
   char szTempfile[MAX_PATH];
   char szFullUrl[INTERNET_MAX_URL_LENGTH];
   UINT uStartProgress;
   char szDest[MAX_PATH];
   char szTimeStamp[MAX_PATH*2];


   _uPhase = INSTALLSTATUS_DOWNLOADING;
      
   if(_FileIsDownloaded(ParseURLA(pszUrl), uUrlNum, NULL))
      return NOERROR;

   
   CDownloader *pDL = _pCif->GetInstallEngine()->GetDownloader();
   
   
   
   uStartProgress = _uTotalProgress;

   
   // retry until success
   // save starting progress in case we retry
   hr = E_FAIL;
   for(int i = 1; i <= NUM_RETRIES && FAILED(hr) && (hr != E_ABORT); i++)
   {
      _uTotalProgress = uStartProgress;
      
      if(uType & URLF_RELATIVEURL)
      {
         lstrcpyn(szFullUrl, _pCif->GetInstallEngine()->GetBaseUrl(),
                  INTERNET_MAX_URL_LENGTH - (lstrlen(pszUrl) + 2));
         lstrcat(szFullUrl, "/");
         lstrcat(szFullUrl, pszUrl);
      }
      else
         lstrcpy(szFullUrl, pszUrl);
	  
	   if(SUCCEEDED(_pCif->GetInstallEngine()->CheckForContinue()))
      {
         DWORD dwFlags = 0;

         if(_pCif->GetInstallEngine()->UseCache())
            dwFlags |= DOWNLOADFLAGS_USEWRITECACHE;

         hr = pDL->SetupDownload(szFullUrl, (IMyDownloadCallback *) this, dwFlags, NULL);
         szTempfile[0] = 0;
         if(SUCCEEDED(hr))
		 {
			// Log the start time.
			wsprintf(szLogBuf, "     Downloading : %s\r\n", szFullUrl);
			_pCif->GetInstallEngine()->WriteToLog(szLogBuf, FALSE);
			GetTimeDateStamp(szTimeStamp);
			wsprintf(szLogBuf, "       Start : %s\r\n", szTimeStamp);
			_pCif->GetInstallEngine()->WriteToLog(szLogBuf, FALSE);

            hr = pDL->DoDownload(szTempfile, sizeof(szTempfile));
			
			// Log the stop time.
			GetTimeDateStamp(szTimeStamp);
			wsprintf(szLogBuf, "       Stop  : %s\r\n", szTimeStamp);
			_pCif->GetInstallEngine()->WriteToLog(szLogBuf, FALSE);
			wsprintf(szLogBuf, "       Result: %x (%s)\r\n", hr, SUCCEEDED(hr) ? STR_OK : STR_FAILED);
			_pCif->GetInstallEngine()->WriteToLog(szLogBuf, FALSE);
		 }
      }
      else
         hr = E_ABORT;
      
      if(SUCCEEDED(hr))
      {
         // Check if it is save to download from this URL
         _uPhase = INSTALLSTATUS_CHECKINGTRUST;
         
         hr = _pCif->GetInstallEngine()->CheckForContinue();
         
         if(SUCCEEDED(hr))
            hr = _CheckForTrust(szFullUrl, szTempfile);

         if(SUCCEEDED(hr) && (hr == S_FALSE) )
         {
            DWORD dwMin, dwMax;
            DWORD dwFileSize = 0;
            dwFileSize = MyGetFileSize(szTempfile);
            dwFileSize = dwFileSize >> 10;
/*
            // Open the file
            HANDLE h = CreateFile(szTempfile, GENERIC_READ, 0, NULL, 
               OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);  
            
            if(h != INVALID_HANDLE_VALUE)
            {
               dwFileSize = GetFileSize(h, NULL);
               CloseHandle(h);
            }
*/
            GetUrlCheckRange(uUrlNum, &dwMin, &dwMax);
            if(dwMin != 0)
            {
               if(dwMin > dwFileSize || dwMax < dwFileSize)
                  hr = E_FAIL;
               else
                  hr = S_OK;
            }
         }
         
         if(SUCCEEDED(hr))
            hr = _pCif->GetInstallEngine()->CheckForContinue();
         
      
         // so now we downloaded and checked
         // if it is OK, move to download dir
         if(SUCCEEDED(hr))
         {
            lstrcpy(szDest, GetDownloadDir());
            AddPath(szDest, ParseURLA(pszUrl));
          
            if(!CopyFile(szTempfile, szDest, FALSE))
            {
                wsprintf(szLogBuf, "CopyFile FAILED, szTempfile=%s, szDest=%s\r\n", szTempfile, szDest);
                _pCif->GetInstallEngine()->WriteToLog(szLogBuf, FALSE);
                hr = E_FAIL;
            }

            _uTotalProgress += _uIndivProgress;
         }
      
         // delete the temp download copy
         if(szTempfile[0] != 0)
         {
            GetParentDir(szTempfile);
            DelNode(szTempfile, 0);
         }
      
      }    
         
         
      if(FAILED(hr) && (hr != E_ABORT))
      {
         // we failed 
         // if this is last retry, call EngineProblem
         // else just retry
         if(i == NUM_RETRIES)
         {
            HRESULT hEngProb;
            DWORD dwResult = 0;
            
            hEngProb = _pCif->GetInstallEngine()->OnEngineProblem(ENGINEPROBLEM_DOWNLOADFAIL, &dwResult);
            if(hEngProb == S_OK)
            {
               if(dwResult == DOWNLOADFAIL_RETRY)
                  i = 0;
            }
         }
      }   
   }   
   if(SUCCEEDED(hr))
      _MarkFileDownloadFinished(szDest, uUrlNum, ParseURLA(pszUrl));
   
   return hr;
}

HRESULT CCifComponent::Install()
{
   CHAR szCompBuf[MAX_PATH];
   HKEY hKey;
   DWORD dwWin, dwApp;
   HRESULT hr = NOERROR;
   DWORD dwStatus = 0;

   GetTimeDateStamp(szCompBuf);
   wsprintf(szLogBuf, "       Start : %s\r\n", szCompBuf);
   _pCif->GetInstallEngine()->WriteToLog(szLogBuf, FALSE);

   szCompBuf[0] = 0;
    
   _uInstallStatus = ICI_NOTINITIALIZED;

   GetDescription(_szDesc, sizeof(_szDesc));
   
   GetInstalledSize(&dwWin, &dwApp);
   _uTotalGoal = dwWin + dwApp;
   _pCif->GetInstallEngine()->OnStartComponent(_szID, 0, _uTotalGoal, _szDesc);

   _uPhase = INSTALLSTATUS_DEPENDENCY;
   hr = _CheckForDependencies();
   
   // check for disk space here
   if(SUCCEEDED(hr))
   {
      _uPhase = INSTALLSTATUS_INITIALIZING;
      _pCif->GetInstallEngine()->OnComponentProgress(_szID, _uPhase, _szDesc, NULL, 0, 0); 
      hr = CreateTempDir(GetDownloadSize(), GetExtractSize(), _pCif->GetInstallEngine()->GetInstallDrive(),
                         dwApp, dwWin, szCompBuf, sizeof(szCompBuf), 0); 
   }

   if(SUCCEEDED(hr))
   {
      if( IsNT() && (RequiresAdminRights() == S_OK) && !IsNTAdmin(0,NULL))
      {
         hr = E_ACCESSDENIED;
         _pCif->GetInstallEngine()->WriteToLog("Admin Check failed\n", TRUE);
      }
   }

   _uTotalProgress = 0;
      
   // BUGBUG:  ie6wzd sets the download directory for non web-based
   //          installs at a later time.  Make sure it's set here
   //          if we weren't successful with installing via SR Lite.
   if (lstrlen(GetDownloadDir()) == 0)
   {
       SetDownloadDir(_pCif->GetDownloadDir());
   }

   if(SUCCEEDED(hr))
   {
      hr = _CopyAllUrls(szCompBuf);
   
      if(SUCCEEDED(hr))
      {
         // The new PerUser method requires to leave the IsInstalled flag & StubPath as it was
         //_MarkComponentInstallStarted();

         _pCif->GetInstallEngine()->GetInstaller()->StartClock();

         hr = _RunAllCommands(szCompBuf, &dwStatus);
      }
   }
 
   if(szCompBuf[0] != 0)
      DelNode(szCompBuf, 0);

   if(SUCCEEDED(hr))
   {
      _fBeforeInstall = FALSE;
      // we think it made it, now double check
      if(IsActiveSetupAware() == S_OK)
      {
         if(IsComponentInstalled() != ICI_INSTALLED)
         {
               // we think they made it but they didn't write their key ...
            _pCif->GetInstallEngine()->WriteToLog("Component did not write to InstalledComponent branch\r\n", TRUE);
            hr = E_FAIL;
         }
      }
      else
      {
         char szCompBuf[MAX_VALUE_LEN];
         // if there is an uninstall key to check do it
         if(SUCCEEDED(GetUninstallKey(szCompBuf, sizeof(szCompBuf))))
         {
            if(!UninstallKeyExists(szCompBuf))
            {
               _pCif->GetInstallEngine()->WriteToLog("UninstallKey check failed\r\n", TRUE);
               hr = E_FAIL;
            }
            else
            {
               // if there is a success key to check do it
               if(SUCCEEDED(GetSuccessKey(szCompBuf, sizeof(szCompBuf))))
               {
                  if(!SuccessCheck(szCompBuf))
                  {   
                     _pCif->GetInstallEngine()->WriteToLog("Success key check failed\r\n", TRUE);
                     hr = E_FAIL;
                  }
               }
            }
         }
      }
   }    
   
   _pCif->RemoveFromCriticalComponents(this);

   if(SUCCEEDED(hr))
   {
      _MarkAsInstalled();
   
      _pCif->MarkCriticalComponents(this);
   
      _uPhase = INSTALLSTATUS_FINISHED;
      _pCif->GetInstallEngine()->GetInstaller()->SetBytes((dwWin + dwApp) << 10, TRUE);
      if(IsRebootRequired() == S_OK)
      {
         dwStatus |= STOPINSTALL_REBOOTNEEDED;
      }
      _pCif->GetInstallEngine()->SetStatus(dwStatus);
   }
   _pCif->GetInstallEngine()->GetInstaller()->StopClock();
   _pCif->GetInstallEngine()->OnStopComponent(_szID, hr, _uPhase, _szDesc, dwStatus);
   GetTimeDateStamp(szCompBuf);
   wsprintf(szLogBuf, "       Stop  : %s\r\n", szCompBuf);
   _pCif->GetInstallEngine()->WriteToLog(szLogBuf, FALSE);
   return hr;
}

HRESULT CCifComponent::_RunAllCommands(LPCSTR pszDir, DWORD *pdwStatus)
{
   char szCmd[MAX_PATH];
   char szArg[MAX_VALUE_LEN];
   char szProg[MAX_VALUE_LEN];
   char szCancel[MAX_VALUE_LEN];
   char szPath[] = "X:\\";
   DWORD dwWinSpace, dwInstallSpace;
   
   DWORD dwType;
   HRESULT hr = NOERROR;
   
   // Save the widows space and install drive space
   szPath[0] = g_szWindowsDir[0];
   dwWinSpace = GetSpace(szPath);
   if(szPath[0] != _pCif->GetInstallEngine()->GetInstallDrive())
   {
      szPath[0] = _pCif->GetInstallEngine()->GetInstallDrive();
      dwInstallSpace = GetSpace(szPath);
   }
   else
   {
      dwInstallSpace = 0;
   }

   

   _uTotalProgress = 0;
   _uPhase = INSTALLSTATUS_RUNNING;
   _pCif->GetInstallEngine()->OnComponentProgress(_szID, INSTALLSTATUS_RUNNING,
                                _szDesc, NULL, _uTotalProgress, _uTotalGoal); 

   
   hr = _pCif->GetInstallEngine()->CheckForContinue();
            
   for(UINT i = 0; SUCCEEDED(hr) && SUCCEEDED(GetCommand(i, szCmd, sizeof(szCmd), szArg, sizeof(szArg), &dwType)); i++)
   {
      _uIndivProgress = 0;
      GetProgressKeys(szProg, sizeof(szProg), szCancel, sizeof(szCancel));
      hr = _pCif->GetInstallEngine()->GetInstaller()->DoInstall(pszDir, szCmd, szArg, 
                          lstrlen(szProg) ? szProg : NULL, lstrlen(szCancel) ? szCancel : NULL,
                          dwType, pdwStatus, (IMyDownloadCallback *) this) ;
      _uTotalProgress += _uIndivProgress;
   }
   
   _pCif->GetInstallEngine()->OnComponentProgress(_szID, _uPhase, _szDesc, NULL, _uTotalGoal,_uTotalGoal); 

   // figure how much we used, and log it
   szPath[0] = g_szWindowsDir[0];
   dwWinSpace = dwWinSpace - GetSpace(szPath);
   if(szPath[0] != _pCif->GetInstallEngine()->GetInstallDrive())
   {
      szPath[0] = _pCif->GetInstallEngine()->GetInstallDrive();
      dwInstallSpace = dwInstallSpace - GetSpace(szPath);
   }
   
   // log the space used
   wsprintf(szCmd, "SpaceUsed: Windows drive: %d   InstallDrive: %d\r\n", dwWinSpace, dwInstallSpace);
   _pCif->GetInstallEngine()->WriteToLog(szCmd, FALSE);
   
   
   return hr;
}




HRESULT CCifComponent::_CopyAllUrls(LPCSTR pszTemp)
{
   char szCompBuf[MAX_VALUE_LEN];
   char szDest[MAX_PATH];
   char szSource[MAX_PATH];
   DWORD dwType;
   HRESULT hr = NOERROR;
   HANDLE hFind;
   WIN32_FIND_DATA ffd;
   char szBuf[MAX_PATH];
    
   
   for(UINT i = 0; SUCCEEDED(hr) && SUCCEEDED(GetUrl(i, szCompBuf, sizeof(szCompBuf), &dwType)) ; i++)
   {
       _uPhase = INSTALLSTATUS_COPYING;
       _pCif->GetInstallEngine()->OnComponentProgress(_szID, _uPhase, _szDesc, NULL, 0, 0); 
       
       lstrcpy(szSource, GetDownloadDir());
       AddPath(szSource, ParseURLA(szCompBuf));

       lstrcpy(szDest, pszTemp);
       AddPath(szDest, ParseURLA(szCompBuf));

       // Copy the file
       if(!CopyFile(szSource, szDest, FALSE))
       {
          wsprintf(szLogBuf, "CopyFile failed for szSource=%s, szDest=%s, DLDir=%s\r\n", szSource, szDest, GetDownloadDir());
          _pCif->GetInstallEngine()->WriteToLog(szLogBuf, FALSE);
          hr = E_FILESMISSING;
       } 
       
       if(SUCCEEDED(hr))
          hr = _pCif->GetInstallEngine()->CheckForContinue();
       
       if(SUCCEEDED(hr)) 
       {
          _uPhase = INSTALLSTATUS_CHECKINGTRUST;
          
          hr = _CheckForTrust(szSource, szDest);
          if (hr == S_FALSE && !_pCif->GetInstallEngine()->IgnoreTrustCheck())
              hr = TRUST_E_FAIL;
          
          if(FAILED(hr))
          {
             DeleteFile(szSource);
          }
       }
       
       if(SUCCEEDED(hr))
          hr = _pCif->GetInstallEngine()->CheckForContinue();
       
       if(SUCCEEDED(hr)) 
          hr = _ExtractFiles(i, szDest, dwType);
       
       if(SUCCEEDED(hr))
          hr = _pCif->GetInstallEngine()->CheckForContinue();
       

   }

   // Now, if we're attempting an SR Lite install, then after
   // extracting cab files to the temp directory...copy all of
   // downloaded files to the temp directory.
   if (_fUseSRLite)
   {
       lstrcpy(szSource, GetDownloadDir());
       AddPath(szSource, "*.*");

       if ( (hFind = FindFirstFile(szSource, &ffd)) != INVALID_HANDLE_VALUE)
       {
           do
           {
               if (ffd.dwFileAttributes != FILE_ATTRIBUTE_DIRECTORY)
               {
                   lstrcpyn(szSource, GetDownloadDir(), sizeof(szSource));
                   SafeAddPath(szSource, ffd.cFileName, sizeof(szSource) - lstrlen(szSource));

                   lstrcpy(szDest, pszTemp);
                   AddPath(szDest, ffd.cFileName);
                   MoveFile(szSource, szDest);
               }
           } while (SUCCEEDED(hr) && FindNextFile(hFind, &ffd));
           FindClose(hFind);
       }
   }

   return hr;
}

STDMETHODIMP CCifComponent::GetDetVersion(LPSTR pszDll, DWORD dwdllSize, LPSTR pszEntry, DWORD dwentSize)
{
   char szBuf[MAX_VALUE_LEN];
   HRESULT hr = E_FAIL;

   if(pszDll && pszEntry)
      *pszDll = *pszEntry = 0;
   else
      return hr;

   if(GetPrivateProfileString(_szID, DETVERSION_KEY, "", szBuf, sizeof(szBuf), _pCif->GetCifPath()))
   {
      if((GetStringField(szBuf, 0, pszDll, dwdllSize) != 0) && (GetStringField(szBuf, 1, pszEntry, dwentSize) != 0))
      {                       
         hr = NOERROR;
      }
   }
   return hr;
}

HRESULT CCifComponent::_GetDetVerResult(LPCSTR pszDll, LPCSTR pszEntry, DETECTION_STRUCT *pDet, UINT *puStatus)
{
   char szBuf[MAX_PATH];
   HRESULT hr = E_FAIL;
   HINSTANCE hLib;
   DETECTVERSION fpDetVer;

   *puStatus = ICI_NOTINSTALLED;

   if (pszDll && pszEntry)
   {
      if(_hDetLib && (lstrcmpi(pszDll, _szDetDllName) == 0))
      {
         hLib = _hDetLib;
      }
      else
      {
         lstrcpy(szBuf, _pCif->GetCifPath());
         GetParentDir(szBuf);
         AddPath(szBuf, pszDll);

         hLib = LoadLibrary(szBuf);
         if (hLib == NULL)
         {
            // if Cif folder failed try IE folder before using searching path
            if (SUCCEEDED(GetIEPath(szBuf, sizeof(szBuf))))
            {
               AddPath(szBuf, pszDll);
               hLib = LoadLibrary(szBuf);
            }
         }
         if(hLib)
         {
            lstrcpy(_szDetDllName, pszDll);
            _hDetLib = hLib;
         }         
      }

      if (hLib)
      {
         fpDetVer = (DETECTVERSION)GetProcAddress(hLib, pszEntry);
         if (fpDetVer)
         {
            switch(fpDetVer(pDet))
            {
               case DET_NOTINSTALLED:
                  *puStatus = ICI_NOTINSTALLED;
                  break;

               case DET_INSTALLED:
                  *puStatus = ICI_INSTALLED;
                  break;

               case DET_NEWVERSIONINSTALLED:
                  *puStatus = ICI_OLDVERSIONAVAILABLE;
                  break;
                                  
               case DET_OLDVERSIONINSTALLED:
                  *puStatus = ICI_NEWVERSIONAVAILABLE;
                  break;

            }
            hr = NOERROR;
         }
      
      }
   }
   
   return hr;
}






//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

HRESULT CCifComponent::_CheckForTrust(LPCSTR pszURL, LPCSTR pszFilename)
{
   HRESULT hr = S_FALSE;

   // BUGBUG: Our internal workaround for non signed stuff
//   if(rdwUrlFlags[i] & URLF_NOCHECKTRUST)
//      return S_OK;
   _uPhase = INSTALLSTATUS_CHECKINGTRUST;

   _pCif->GetInstallEngine()->OnComponentProgress(_szID, _uPhase, _szDesc, NULL,  0, 0);
   
  if(!_pCif->GetInstallEngine()->IgnoreTrustCheck())
      hr = ::CheckTrustEx(pszURL, pszFilename, _pCif->GetInstallEngine()->GetHWND(), FALSE, NULL);
   
   wsprintf(szLogBuf, "       CheckTrust: %s, Result: %x (%s)\r\n", pszFilename, hr, SUCCEEDED(hr) ? STR_OK : STR_FAILED);
   _pCif->GetInstallEngine()->WriteToLog(szLogBuf, TRUE);

   return hr;
}


//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

HRESULT CCifComponent::_ExtractFiles(UINT i, LPCSTR pszFile, DWORD dwType)
{
   HRESULT hr = NOERROR;
   char szPath[MAX_PATH];
   char szExtractList[MAX_VALUE_LEN];

   // Need to pay attention to rdwUrlFlags[i] to see if there is anything to do
   if(dwType & URLF_EXTRACT)
   {
      _uPhase = INSTALLSTATUS_EXTRACTING;

      _pCif->GetInstallEngine()->OnComponentProgress(_szID, _uPhase, _szDesc, NULL, 0, 0);
     
      lstrcpy(szPath, pszFile);
      GetParentDir(szPath);
      
      GetFileExtractList(i, szExtractList, sizeof(szExtractList));
      hr=ExtractFiles(pszFile, szPath, 0, lstrlen(szExtractList) ? szExtractList : NULL, NULL, 0);
      
      wsprintf(szLogBuf, "File extraction: %s, Result: %x (%s)\r\n", pszFile, hr, SUCCEEDED(hr) ? STR_OK : STR_FAILED);
      _pCif->GetInstallEngine()->WriteToLog(szLogBuf, TRUE);

      // if the flag is set to delte the cab after an extract, do it
      // I don't really care too much if this fails, at least not 
      // enough to fail this component

      if(dwType & URLF_DELETE_AFTER_EXTRACT)
         DeleteFile(pszFile);
   }
   return hr;
}





void CCifComponent::_MarkComponentInstallStarted()
{
   char szReg[MAX_PATH];
   char szCompBuf[MAX_DISPLAYNAME_LENGTH];
   HKEY hKey;
   DWORD dwDumb;

   lstrcpy(szReg, COMPONENT_KEY);
   lstrcat(szReg, "\\");
   
   GetGUID(szCompBuf, sizeof(szCompBuf));
   lstrcat(szReg, szCompBuf);
   if(RegOpenKeyEx( HKEY_LOCAL_MACHINE, szReg, 0, 
                       KEY_READ | KEY_WRITE, &hKey) == ERROR_SUCCESS)
   {
      // Set IsInstalled=0
      dwDumb = ISINSTALLED_NO;
      RegSetValueExA(hKey, ISINSTALLED_KEY, 0, REG_DWORD, 
                       (BYTE *) &dwDumb , sizeof(dwDumb));

      // Delete StubPath so peruser isn't confused
      RegDeleteValue(hKey, STUBPATH_KEY);
      RegCloseKey(hKey);
   }
}


BOOL CCifComponent::_CompareDownloadInfo()
{
   char szCompBuf[MAX_VALUE_LEN];
   char szInfoBuf[128];
   DWORD dwCompVer, dwCompBuild, dwDLVer, dwDLBuild;

   // first check this is the same language
   GetPrivateProfileString(_szID, LOCALE_KEY, "", szInfoBuf, sizeof(szInfoBuf), _pCif->GetFilelist());
   GetLocale(szCompBuf, sizeof(szCompBuf));
   if(CompareLocales(szInfoBuf, szCompBuf) == 0)
   {
      // compare guids
      GetPrivateProfileString(_szID, GUID_KEY, "", szInfoBuf, sizeof(szInfoBuf), _pCif->GetFilelist());
      GetGUID(szCompBuf, sizeof(szCompBuf));
      // intentionally let blank guid match to be backward compatible
      if(lstrcmpi(szCompBuf, szInfoBuf) == 0)
      {

         GetPrivateProfileString(_szID, VERSION_KEY,"",szInfoBuf, 
                           sizeof(szInfoBuf), _pCif->GetFilelist()); 
         ConvertVersionStrToDwords(szInfoBuf, &dwDLVer, &dwDLBuild);
         GetVersion(&dwCompVer, &dwCompBuild);

         if((dwDLVer == dwCompVer) && (dwDLBuild == dwCompBuild))
            return TRUE;
      }
   }
   return FALSE;
}

BOOL CCifComponent::_FileIsDownloaded(LPCSTR pszFile, UINT i, DWORD *pdwSize)
{
   HANDLE h;
   DWORD dwSize, dwFileSize;
   char szKey[16];
   char szBuf[MAX_PATH];
 
   szBuf[0] = '\0'; 

   if(pdwSize)
      *pdwSize = 0;
   
   wsprintf(szKey, "URL%d", i);
   GetPrivateProfileString(_szID, szKey,"0",szBuf, 
                           sizeof(szBuf), _pCif->GetFilelist()); 
   dwSize = GetIntField(szBuf, 0, 0);
   
   if(dwSize == 0)
      return FALSE;

    if (_fUseSRLite && lstrlen(GetDownloadDir()) != 0)
       lstrcpy(szBuf, GetDownloadDir());
   else
       lstrcpy(szBuf, _pCif->GetDownloadDir());

   AddPath(szBuf, pszFile);
   dwFileSize = MyGetFileSize(szBuf);
/*
      // Open the file
   h = CreateFile(pszFile, GENERIC_READ, 0, NULL, 
                 OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);  
   
   if(h == INVALID_HANDLE_VALUE)
      return FALSE;

   // dont worry about files over 4 gig
   dwFileSize = GetFileSize(h, NULL);
   CloseHandle(h);
*/
   if(dwFileSize == dwSize)
   {
      if(pdwSize)
         *pdwSize = dwFileSize;
      return TRUE;   
   }

   return FALSE;
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

void CCifComponent::_MarkAsInstalled()
{
   CHAR szCompBuf[MAX_VALUE_LEN];
   HKEY hComponentKey = NULL;
   HKEY hGUIDKey = NULL;
   DWORD dwDumb, dwVer, dwBuild;
   LPSTR psz;
   
   if(RegCreateKeyExA(HKEY_LOCAL_MACHINE, COMPONENT_KEY, 0, 0, 0, 
                  KEY_WRITE, NULL, &hComponentKey, &dwDumb) == ERROR_SUCCESS)
   {
      GetGUID(szCompBuf, sizeof(szCompBuf));
      if(RegCreateKeyExA(hComponentKey, szCompBuf, 0, 0, 0, KEY_WRITE, NULL, &hGUIDKey, &dwDumb) == ERROR_SUCCESS)
      {
         // we only write to the key if this guy is NOT active setup aware
         if(IsActiveSetupAware() == S_FALSE)
         {
            // write Display name to Default
            GetDescription(szCompBuf, sizeof(szCompBuf));
            RegSetValueExA(hGUIDKey, NULL, 0, REG_SZ, (BYTE *)szCompBuf , lstrlen(szCompBuf) + 1 );
            
            // write component ID
            GetID(szCompBuf, sizeof(szCompBuf));
            RegSetValueExA(hGUIDKey, "ComponentID", 0, REG_SZ, (BYTE *)szCompBuf , lstrlen(szCompBuf) + 1 );
   
            // write out version
            GetVersion(&dwVer, &dwBuild);
            wsprintf(szCompBuf, "%d,%d,%d,%d", HIWORD(dwVer),LOWORD(dwVer),HIWORD(dwBuild),LOWORD(dwBuild));
            RegSetValueExA(hGUIDKey, VERSION_KEY, 0, REG_SZ, (BYTE *)szCompBuf , lstrlen(szCompBuf) + 1);

            // write out locale
            GetLocale(szCompBuf, sizeof(szCompBuf));
            RegSetValueExA(hGUIDKey, LOCALE_KEY, 0, REG_SZ, (BYTE *)szCompBuf , lstrlen(szCompBuf) + 1);

            // Write out "IsInstalled=1"
            dwDumb = ISINSTALLED_YES;
            RegSetValueExA(hGUIDKey, ISINSTALLED_KEY, 0, REG_DWORD, (BYTE *) &dwDumb , sizeof(dwDumb));
         }
      }
   }

   if(hComponentKey)
      RegCloseKey(hComponentKey);

   if(hGUIDKey)
      RegCloseKey(hGUIDKey);
}


void CCifComponent::_MarkFileDownloadFinished(LPCSTR pszFilePath, UINT i, LPCSTR pszFilename)
{
   char szSize[MAX_PATH];
   char szKey[16];
   DWORD dwFileSize;
   HANDLE h;

   // put any entry in filelist.dat
   // [CompID]
   // URLi=Filesize

   dwFileSize = MyGetFileSize(pszFilePath);
/*
      // Create the file
   h = CreateFile(pszFilePath, GENERIC_READ, 0, NULL, 
                 OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);  
   
   if(h == INVALID_HANDLE_VALUE)
      return;

   // dont worry about files over 4 gig
   dwFileSize = GetFileSize(h, NULL);
   CloseHandle(h);
*/
   if(dwFileSize != 0xffffffff)
   {
      wsprintf(szKey, "URL%d", i);
      wsprintf(szSize, "%d,%s", dwFileSize, pszFilename);

      WritePrivateProfileString(_szID, szKey, szSize, _pCif->GetFilelist());

      // need to flush the pszFileList file; otherwise, with Stacker installed,
      // it GPFs when trying to open the file in another thread (bug #13041)
      WritePrivateProfileString(NULL, NULL, NULL, _pCif->GetFilelist());
   }
}

void CCifComponent::_MarkFileDownloadStarted(UINT i)
{
   char szKey[10];
  
   wsprintf(szKey, "URL%d", i);
  
   WritePrivateProfileString(_szID, szKey, NULL, _pCif->GetFilelist());

   // flush -- fixes the Stacker bug #13041
   WritePrivateProfileString(NULL, NULL, NULL, _pCif->GetFilelist());
}


void CCifComponent::_MarkDownloadStarted()
{
   char szCompBuf[MAX_VALUE_LEN];
   DWORD dwVer, dwBuild;

   // if the section doesn't match what we expect, we kill
   // section so we will redownload everything
   if(!_CompareDownloadInfo())
      WritePrivateProfileSection(_szID, NULL, _pCif->GetFilelist());   

   // write the version
   GetVersion(&dwVer, &dwBuild);
   wsprintf(szCompBuf, "%d,%d,%d,%d", HIWORD(dwVer),LOWORD(dwVer),HIWORD(dwBuild),LOWORD(dwBuild));
   WritePrivateProfileString(_szID, VERSION_KEY, szCompBuf, _pCif->GetFilelist());

   // write locale
   GetLocale(szCompBuf, sizeof(szCompBuf));
   WritePrivateProfileString(_szID, LOCALE_KEY, szCompBuf, _pCif->GetFilelist());
   
   // write the guid
   GetGUID(szCompBuf, sizeof(szCompBuf));
   WritePrivateProfileString(_szID, GUID_KEY, szCompBuf, _pCif->GetFilelist());
   
   // flush -- fixes the Stacker bug #13041
   WritePrivateProfileString(NULL, NULL, NULL, _pCif->GetFilelist());
}

HRESULT CCifComponent::_CheckForDependencies()
{
   char szCompBuf[MAX_ID_LENGTH];
   char chType;
   ICifComponent *pcomp;
   HRESULT hr = NOERROR;
   DWORD dwNeedVer, dwNeedBuild, dwInsVer, dwInsBuild;

   for(int i = 0; SUCCEEDED(GetDependency(i, szCompBuf, sizeof(szCompBuf), &chType, &dwNeedVer, &dwNeedBuild)); i++)
   {
      if(SUCCEEDED(_pCif->FindComponent(szCompBuf, &pcomp)))
      {
         if(chType != DEP_BUDDY)
         {
            UINT uStatus = pcomp->IsThisVersionInstalled(dwNeedVer, dwNeedBuild, &dwInsVer, &dwInsBuild);
            if( (uStatus == ICI_NOTINSTALLED) || (uStatus == ICI_NEWVERSIONAVAILABLE) )
            {
               hr = E_FAIL;
               break;
            }
         }
      }
   }
   return hr;
}

HRESULT CCifComponent::_SRLiteDownloadFiles()
{
    HANDLE hFile;
    WIN32_FIND_DATA ffd = {0};
    CHAR szFile[MAX_PATH];
    LPSTR pszFile = NULL;
    HRESULT hr = S_OK;
    CHAR szCompBuf[INTERNET_MAX_URL_LENGTH];
    DWORD dwType;
    BOOL fRet;
    UINT uPatchCount = 0;

    _uPhase = INSTALLSTATUS_DOWNLOADING;

    // Look for presence of [DownloadFileSection] in a single
    // .inf file extracted from the cabs.
    for(UINT i = 0; SUCCEEDED(hr) && SUCCEEDED(GetUrl(i, szCompBuf, sizeof(szCompBuf), &dwType)) ; i++)
    {
        TCHAR szShortPath[MAX_PATH] = "";
        GetShortPathName(GetDownloadDir(), szShortPath, sizeof(szShortPath));
        // If all goes well, we should just get a single INF file extracted
        lstrcpyn(szFile, GetDownloadDir(), sizeof(szFile));
        SafeAddPath(szFile, szCompBuf, sizeof(szCompBuf));

        hr = ExtractFiles(szFile, szShortPath, 0, NULL, NULL, 0);
       wsprintf(szLogBuf, "Extracting empty cabs for %s in %s returned 0x%lx\r\n", szCompBuf, szShortPath, hr);
       _pCif->GetInstallEngine()->WriteToLog(szLogBuf, FALSE);
    }

    lstrcpyn(szFile, GetDownloadDir(), sizeof(szFile));
    SafeAddPath(szFile, "*.inf", sizeof(szFile));

    // Get the file count because we're going to hack the
    // progress bar UI since we don't know the real download sizes
    // for the patch INFs upfront.
    hFile = FindFirstFile(szFile, &ffd);
    if (hFile != INVALID_HANDLE_VALUE)
    {
        do
        {
            // Strip filename from path
            lstrcpyn(szFile, GetDownloadDir(), sizeof(szFile));
            SafeAddPath(szFile, ffd.cFileName, sizeof(szFile) - lstrlen(szFile));

            if (IsPatchableINF(szFile))
            {
                uPatchCount++;
            }
        } while (FindNextFile(hFile, &ffd));
        FindClose(hFile);
    }

    lstrcpyn(szFile, GetDownloadDir(), sizeof(szFile));
    SafeAddPath(szFile, "*.inf", sizeof(szFile));

    hFile = FindFirstFile(szFile, &ffd);

    // No need to keep the grep pattern...
    lstrcpyn(szFile, GetDownloadDir(), sizeof(szFile));
    pszFile = szFile + lstrlen(szFile);

    if (hFile != INVALID_HANDLE_VALUE)
    {
        do
        {
            // Strip filename from path
            lstrcpyn(szFile, GetDownloadDir(), sizeof(szFile));
            SafeAddPath(szFile, ffd.cFileName, sizeof(szFile) - lstrlen(szFile));

            if (IsPatchableINF(szFile))
            {
                fRet = TRUE;
                // Found an inf that supports SR Lite.  Try downloading the patch files.
                // Use our downloader wrapper for the advpack extension to do the
                // downloading.
                hr = _pCif->GetInstallEngine()->GetPatchDownloader()->SetupDownload(_uTotalGoal, uPatchCount, (IMyDownloadCallback *) this, GetDownloadDir());
                hr = _pCif->GetInstallEngine()->GetPatchDownloader()->DoDownload(szFile);
            }
            else
            {
                wsprintf(szLogBuf, "%s INF found with no DownloadFileSection\r\n", szFile);
                _pCif->GetInstallEngine()->WriteToLog(szLogBuf, FALSE);
            }

            _uTotalProgress += _uIndivProgress;

        } while (SUCCEEDED(hr) && FindNextFile(hFile, &ffd));
        FindClose(hFile);
    }

    if (!fRet || !SUCCEEDED(hr))
    {
       wsprintf(szLogBuf, "Either no INF was found with a DownloadFileSection or an error occured during processing\r\n");
       _pCif->GetInstallEngine()->WriteToLog(szLogBuf, FALSE);
        return E_FAIL;
    }

    return hr;
}

void CCifComponent::SetDownloadDir(LPCSTR pszDownloadDir)
{
    if (pszDownloadDir)
        lstrcpyn(_szDLDir, pszDownloadDir, MAX_PATH);
}

//========= ICifRWComponent implementation ================================================
//
CCifRWComponent::CCifRWComponent(LPCSTR pszID, CCifFile *pCif) : CCifComponent(pszID, pCif)
{
}

CCifRWComponent::~CCifRWComponent()
{
}

STDMETHODIMP CCifRWComponent::GetID(LPSTR pszID, DWORD dwSize)
{
   return(CCifComponent::GetID(pszID, dwSize));
}
   
STDMETHODIMP CCifRWComponent::GetGUID(LPSTR pszGUID, DWORD dwSize)
{
   return(CCifComponent::GetGUID(pszGUID, dwSize));
}

STDMETHODIMP CCifRWComponent::GetDescription(LPSTR pszDesc, DWORD dwSize)
{
   return(CCifComponent::GetDescription(pszDesc, dwSize));
}

STDMETHODIMP CCifRWComponent::GetDetails(LPSTR pszDetails, DWORD dwSize)
{
   return(CCifComponent::GetDetails(pszDetails, dwSize));
}

STDMETHODIMP CCifRWComponent::GetUrl(UINT uUrlNum, LPSTR pszUrl, DWORD dwSize, LPDWORD pdwUrlFlags)
{
   return(CCifComponent::GetUrl(uUrlNum, pszUrl, dwSize, pdwUrlFlags));
}

STDMETHODIMP CCifRWComponent::GetFileExtractList(UINT uUrlNum, LPSTR pszExtract, DWORD dwSize)
{
   return(CCifComponent::GetFileExtractList(uUrlNum, pszExtract, dwSize));
}

STDMETHODIMP CCifRWComponent::GetUrlCheckRange(UINT uUrlNum, LPDWORD pdwMin, LPDWORD pdwMax)
{
   return(CCifComponent::GetUrlCheckRange(uUrlNum, pdwMin, pdwMax));
}

STDMETHODIMP CCifRWComponent::GetCommand(UINT uCmdNum, LPSTR pszCmd, DWORD dwCmdSize, LPSTR pszSwitches, 
                                         DWORD dwSwitchSize, LPDWORD pdwType)
{
   return(CCifComponent::GetCommand(uCmdNum, pszCmd, dwCmdSize, pszSwitches, dwSwitchSize, pdwType));
}

STDMETHODIMP CCifRWComponent::GetVersion(LPDWORD pdwVersion, LPDWORD pdwBuild)
{
   return(CCifComponent::GetVersion(pdwVersion, pdwBuild));
}

STDMETHODIMP CCifRWComponent::GetLocale(LPSTR pszLocale, DWORD dwSize)
{
   return(CCifComponent::GetLocale(pszLocale, dwSize));
}

STDMETHODIMP CCifRWComponent::GetUninstallKey(LPSTR pszKey, DWORD dwSize)
{
   return(CCifComponent::GetUninstallKey(pszKey, dwSize));
}

STDMETHODIMP CCifRWComponent::GetInstalledSize(LPDWORD pdwWin, LPDWORD pdwApp)
{
   return(CCifComponent::GetInstalledSize(pdwWin, pdwApp));
}

STDMETHODIMP_(DWORD) CCifRWComponent::GetDownloadSize()
{
   return(CCifComponent::GetDownloadSize());
}

STDMETHODIMP_(DWORD) CCifRWComponent::GetExtractSize()
{
   return(CCifComponent::GetExtractSize());
}

STDMETHODIMP CCifRWComponent::GetSuccessKey(LPSTR pszKey, DWORD dwSize)
{
   return(CCifComponent::GetSuccessKey(pszKey, dwSize));
}

STDMETHODIMP CCifRWComponent::GetProgressKeys(LPSTR pszProgress, DWORD dwProgSize, 
                                               LPSTR pszCancel, DWORD dwCancelSize)
{
   return(CCifComponent::GetProgressKeys(pszProgress, dwProgSize, pszCancel, dwCancelSize));
}

STDMETHODIMP CCifRWComponent::IsActiveSetupAware()
{
   return(CCifComponent::IsActiveSetupAware());
}

STDMETHODIMP CCifRWComponent::IsRebootRequired()
{
   return(CCifComponent::IsActiveSetupAware());
}

STDMETHODIMP CCifRWComponent::RequiresAdminRights()
{
   return(CCifComponent::RequiresAdminRights());
}

STDMETHODIMP_(DWORD) CCifRWComponent::GetPriority()
{
   return(CCifComponent::GetPriority());
}

STDMETHODIMP CCifRWComponent::GetDependency(UINT uDepNum, LPSTR pszID, DWORD dwBuf, char *pchType, LPDWORD pdwVer, LPDWORD pdwBuild)
{
   return(CCifComponent::GetDependency(uDepNum, pszID, dwBuf, pchType, pdwVer, pdwBuild));
}

STDMETHODIMP_(DWORD) CCifRWComponent::GetPlatform()
{
   return(CCifComponent::GetPlatform());
}

STDMETHODIMP CCifRWComponent::GetMode(UINT uModeNum, LPSTR pszModes, DWORD dwSize)
{
   return(CCifComponent::GetMode(uModeNum, pszModes, dwSize));
}

STDMETHODIMP CCifRWComponent::GetTreatAsOneComponents(UINT uNum, LPSTR pszID, DWORD dwBuf)
{
   return(CCifComponent::GetTreatAsOneComponents(uNum, pszID, dwBuf));
}

STDMETHODIMP CCifRWComponent::GetCustomData(LPSTR pszKey, LPSTR pszData, DWORD dwSize)
{
   return(CCifComponent::GetCustomData(pszKey, pszData, dwSize));
}

STDMETHODIMP CCifRWComponent::GetGroup(LPSTR pszID, DWORD dwSize)
{
   return(CCifComponent::GetGroup(pszID, dwSize));
}

STDMETHODIMP CCifRWComponent::IsUIVisible()
{
   return(CCifComponent::IsUIVisible());
}

STDMETHODIMP CCifRWComponent::GetPatchID(LPSTR pszID, DWORD dwSize)
{
   return(CCifComponent::GetPatchID(pszID, dwSize));
}

STDMETHODIMP_(DWORD) CCifRWComponent::IsComponentInstalled()
{
   return(CCifComponent::IsComponentInstalled());
}

STDMETHODIMP CCifRWComponent::IsComponentDownloaded()
{
   return(CCifComponent::IsComponentDownloaded());
}

STDMETHODIMP_(DWORD) CCifRWComponent::IsThisVersionInstalled(DWORD dwAskVer, DWORD dwAskBld, LPDWORD pdwVersion, LPDWORD pdwBuild)
{
   return(CCifComponent::IsThisVersionInstalled(dwAskVer, dwAskBld, pdwVersion, pdwBuild));
}

STDMETHODIMP_(DWORD) CCifRWComponent::GetInstallQueueState()
{
   return(CCifComponent::GetInstallQueueState());
}

STDMETHODIMP CCifRWComponent::SetInstallQueueState(DWORD dwState)
{
   return(CCifComponent::SetInstallQueueState(dwState));
}

STDMETHODIMP_(DWORD) CCifRWComponent::GetActualDownloadSize()
{
   return(CCifComponent::GetActualDownloadSize());
}

STDMETHODIMP_(DWORD) CCifRWComponent::GetCurrentPriority()
{
   return(CCifComponent::GetCurrentPriority());
}

STDMETHODIMP CCifRWComponent::SetCurrentPriority(DWORD dwPriority)
{
   return(CCifComponent::SetCurrentPriority(dwPriority));
}


STDMETHODIMP CCifRWComponent:: GetDetVersion(LPSTR pszDLL, DWORD dwdllSize, LPSTR pszEntry, DWORD dwentSize)
{
   return(CCifComponent::GetDetVersion(pszDLL, dwdllSize, pszEntry, dwentSize));
}


STDMETHODIMP CCifRWComponent::SetGUID(LPCSTR pszGUID)
{
   return (WritePrivateProfileString(_szID, GUID_KEY, pszGUID, _pCif->GetCifPath())? NOERROR:E_FAIL);
}

STDMETHODIMP CCifRWComponent::SetDescription(LPCSTR pszDesc)
{
   return (WriteTokenizeString(_pCif->GetCifPath(), _szID, DISPLAYNAME_KEY, pszDesc));   
}

STDMETHODIMP CCifRWComponent::SetDetails(LPCSTR pszDesc)
{
   return (WriteTokenizeString(_pCif->GetCifPath(), _szID, DETAILS_KEY, pszDesc));   
}

STDMETHODIMP CCifRWComponent::SetVersion(LPCSTR pszVersion)
{
   return (WritePrivateProfileString(_szID, VERSION_KEY, pszVersion, _pCif->GetCifPath())? NOERROR:E_FAIL);
}

STDMETHODIMP CCifRWComponent::SetUninstallKey(LPCSTR pszKey)
{
   return (MyWritePrivateProfileString(_szID, UNINSTALLSTRING_KEY, pszKey, _pCif->GetCifPath())? NOERROR:E_FAIL);
}

STDMETHODIMP CCifRWComponent::SetInstalledSize(DWORD dwWin, DWORD dwApp)
{
   char szBuf[50];

   wsprintf(szBuf,"%d,%d", dwWin, dwApp);
   return (WritePrivateProfileString(_szID, INSTALLSIZE_KEY, szBuf, _pCif->GetCifPath())? NOERROR:E_FAIL);
}

STDMETHODIMP CCifRWComponent::SetDownloadSize(DWORD dwSize)
{
   char szBuf1[MAX_VALUE_LEN];
   char szBuf2[MAX_VALUE_LEN];
   DWORD dwExtractSize;

   szBuf1[0] = '\0';

   // Read in size
   GetPrivateProfileString(_szID, SIZE_KEY, "0", szBuf1, sizeof(szBuf1), _pCif->GetCifPath());   
   dwExtractSize = GetIntField(szBuf1, 1, (DWORD)-1);
   if (dwExtractSize == (DWORD)-1)
      wsprintf(szBuf2,"%d", dwSize);
   else
      wsprintf(szBuf2,"%d,%d", dwSize, dwExtractSize);
   return (WritePrivateProfileString(_szID, SIZE_KEY, szBuf2, _pCif->GetCifPath())? NOERROR:E_FAIL);
}

STDMETHODIMP CCifRWComponent::SetExtractSize(DWORD dwSize)
{
   char szBuf1[MAX_VALUE_LEN];
   char szBuf2[MAX_VALUE_LEN];

   szBuf1[0] = '\0';

   // Read in size
   GetPrivateProfileString(_szID, SIZE_KEY, "0,0", szBuf1, sizeof(szBuf1), _pCif->GetCifPath());   
   wsprintf(szBuf2,"%d,%d", GetIntField(szBuf1, 0, 0), dwSize);
   return (WritePrivateProfileString(_szID, SIZE_KEY, szBuf2, _pCif->GetCifPath())? NOERROR:E_FAIL);
}

STDMETHODIMP CCifRWComponent::DeleteDependency(LPCSTR pszID, char chType)
{
   HRESULT hr;

   if (pszID ==  NULL) //delete all from all modes
      hr = WritePrivateProfileString(_szID, DEPENDENCY_KEY, NULL, _pCif->GetCifPath())?NOERROR:E_FAIL;
   else
   {
      // delete only the given ones
      char szBuf[MAX_VALUE_LEN];
      char szBufIn[MAX_VALUE_LEN];
      char szBufOut[MAX_VALUE_LEN];
      char szOne[MAX_ID_LENGTH];
      LPSTR pszTmp;
      UINT i = 0;
      
      szBufOut[0] =0;
      wsprintf( szBuf, "%s:%c", pszID, chType);
      if (GetPrivateProfileString(_szID, DEPENDENCY_KEY, "", szBufIn, sizeof(szBufIn), _pCif->GetCifPath()))
      {
         pszTmp = szBufOut;
         while(GetStringField(szBufIn, i++, szOne, sizeof(szOne)))
         {
            if (lstrcmpi(szOne, szBuf))
            {
               if ( i != 1)
               {
                  lstrcpy(pszTmp,",");
                  pszTmp++;
               }
               lstrcpy(pszTmp, szOne);
               pszTmp = pszTmp + lstrlen(szOne);
            }
         }
         hr = WritePrivateProfileString(_szID, DEPENDENCY_KEY, szBufOut, _pCif->GetCifPath())? NOERROR:E_FAIL;
      }                         
   }   
   return hr;

}

STDMETHODIMP CCifRWComponent::AddDependency(LPCSTR pszID, char chType)
{
   char szBuf[MAX_VALUE_LEN];   
   char szBuf1[MAX_VALUE_LEN];   
   char szOne[MAX_ID_LENGTH];
   LPSTR pszTmp;
   UINT i = 0;
   BOOL bFound = FALSE;
   HRESULT hr = NOERROR;

   if (pszID==NULL)
      return hr;

   if (chType == '\\')
       wsprintf( szBuf1, "%s:N:6.0.0.0", pszID, chType);
   else
       wsprintf( szBuf1, "%s:%c", pszID, chType);

   if (GetPrivateProfileString(_szID, DEPENDENCY_KEY, "", szBuf, sizeof(szBuf), _pCif->GetCifPath()))
   {          
      while(GetStringField(szBuf, i++, szOne, sizeof(szOne)))
      {
         if (lstrcmpi(szOne, szBuf1) == 0)
         {
            // found it, no need to add
            bFound = TRUE;
            break;
         }
      }
      if (!bFound)
      {
         LPSTR pszTmp = szBuf + lstrlen(szBuf);
         lstrcpy(pszTmp, ",");
         pszTmp++;
         lstrcpy(pszTmp, szBuf1);         
         hr = WritePrivateProfileString(_szID, DEPENDENCY_KEY, szBuf, _pCif->GetCifPath())? NOERROR:E_FAIL;
      }
   }
   else
      hr = WritePrivateProfileString(_szID, DEPENDENCY_KEY, szBuf1, _pCif->GetCifPath())? NOERROR:E_FAIL;

   return hr;
}

STDMETHODIMP CCifRWComponent::SetUIVisible(BOOL bFlag)
{
   return (WritePrivateProfileString(_szID, UIVISIBLE_KEY, bFlag? "1" : "0", _pCif->GetCifPath())? NOERROR:E_FAIL);
}

STDMETHODIMP CCifRWComponent::SetGroup(LPCSTR pszID)
{
   return (WritePrivateProfileString(_szID, GROUP_KEY, pszID, _pCif->GetCifPath())? NOERROR:E_FAIL);
}

STDMETHODIMP CCifRWComponent::SetPlatform(DWORD dwPlatform)
{
   char szBuf[MAX_VALUE_LEN];
   char *rszPlatforms[7] = { STR_WIN95, STR_WIN98, STR_NT4, STR_NT5, STR_NT4ALPHA, STR_NT5ALPHA, STR_MILLEN };
   DWORD rdwPlatforms[] = { PLATFORM_WIN95, PLATFORM_WIN98, PLATFORM_NT4, PLATFORM_NT5, 
                            PLATFORM_NT4ALPHA, PLATFORM_NT5ALPHA, PLATFORM_MILLEN };

   _dwPlatform = dwPlatform;
   szBuf[0] = 0;

   for(int i = 0; i < 7; i++)
   {
      if(dwPlatform & rdwPlatforms[i]) 
      {
         lstrcat(szBuf, rszPlatforms[i]);
         lstrcat(szBuf, ",");
      }            
   }   

   return (WritePrivateProfileString(_szID, PLATFORM_KEY, szBuf, _pCif->GetCifPath())? NOERROR:E_FAIL);   
}

STDMETHODIMP CCifRWComponent::SetPriority(DWORD dwPri)
{
   char szBuf[MAX_SMALL_BUF];

   wsprintf(szBuf, "%d", dwPri);
   return (WritePrivateProfileString(_szID, PRIORITY, szBuf, _pCif->GetCifPath())? NOERROR:E_FAIL);   
}

STDMETHODIMP CCifRWComponent::SetReboot(BOOL bReboot)
{
   return (WritePrivateProfileString(_szID, REBOOT_KEY, bReboot? "1":"0", _pCif->GetCifPath())? NOERROR:E_FAIL);   
}

STDMETHODIMP CCifRWComponent::SetCommand(UINT uCmdNum, LPCSTR pszCmd, LPCSTR pszSwitches, DWORD dwType)
{
   char szKey[16];
   char szType[10];
   HRESULT hr = NOERROR;
 
   uCmdNum++;
   wsprintf(szKey, "%s%lu", CMD_KEY, uCmdNum);
   if (!MyWritePrivateProfileString(_szID, szKey, pszCmd, _pCif->GetCifPath()))
      hr = E_FAIL;
   wsprintf(szKey, "%s%lu", ARGS_KEY, uCmdNum);
   if(!MyWritePrivateProfileString(_szID, szKey, (pszCmd==NULL)?NULL:pszSwitches, _pCif->GetCifPath()))
      hr = E_FAIL;
   wsprintf(szKey, "%s%lu", TYPE_KEY, uCmdNum);
   wsprintf(szType,"%d", dwType);
   if(!WritePrivateProfileString(_szID, szKey, (pszCmd==NULL)? NULL:szType, _pCif->GetCifPath()))
      hr = E_FAIL;

   return hr;
}

STDMETHODIMP CCifRWComponent::SetUrl(UINT uUrlNum, LPCSTR pszUrl, DWORD dwUrlFlags)
{
   char szKey[16];
   char szBuf[MAX_VALUE_LEN];
   HRESULT hr = NOERROR;

   uUrlNum++;
   wsprintf(szKey, "%s%lu", URL_KEY, uUrlNum);
   wsprintf(szBuf, "\"%s\",%d", pszUrl, dwUrlFlags);
   if (!WritePrivateProfileString(_szID, szKey, szBuf, _pCif->GetCifPath()))
      hr = E_FAIL;
   wsprintf(szKey, "%s%lu", SIZE_KEY, uUrlNum);
   if(!WritePrivateProfileString(_szID, szKey, NULL, _pCif->GetCifPath()))
      hr = E_FAIL;

   return hr;   
}

STDMETHODIMP CCifRWComponent::DeleteFromModes(LPCSTR pszMode)
{
   HRESULT hr;

   if (pszMode ==  NULL) //delete all from all modes
      hr = WritePrivateProfileString(_szID, MODES_KEY, pszMode, _pCif->GetCifPath())?NOERROR:E_FAIL;
   else
   {
      // delete only the given ones
      char szBufIn[MAX_VALUE_LEN];
      char szBufOut[MAX_VALUE_LEN];
      char szOneMode[MAX_ID_LENGTH];
      LPSTR pszTmp;
      UINT i = 0;
      
      szBufOut[0] =0;
      if (SUCCEEDED(MyTranslateString(_pCif->GetCifPath(), _szID, MODES_KEY, szBufIn, sizeof(szBufIn))))
      {
         pszTmp = szBufOut;
         while(GetStringField(szBufIn, i++, szOneMode, sizeof(szOneMode)))
         {
            if (lstrcmpi(szOneMode, pszMode))
            {
               if ( i != 1)
               {
                  lstrcpy(pszTmp,",");
                  pszTmp++;
               }
               lstrcpy(pszTmp, szOneMode);
               pszTmp = pszTmp + lstrlen(szOneMode);
            }
         }
         hr = WriteTokenizeString(_pCif->GetCifPath(), _szID, MODES_KEY, szBufOut);
      }                         
   }   
   return hr;
}

STDMETHODIMP CCifRWComponent::AddToMode(LPCSTR pszMode)
{
   char szBuf[MAX_VALUE_LEN];   
   char szOneMode[MAX_ID_LENGTH];
   LPSTR pszTmp;
   UINT i = 0;
   BOOL bFound = FALSE;
   HRESULT hr = NOERROR;

   if (SUCCEEDED(MyTranslateString(_pCif->GetCifPath(), _szID, MODES_KEY, szBuf, sizeof(szBuf))))
   {    
      while(GetStringField(szBuf, i++, szOneMode, sizeof(szOneMode)))
      {
         if (lstrcmpi(szOneMode, pszMode) == 0)
         {
            // found it, no need to add
            bFound = TRUE;
            break;
         }
      }
      if (!bFound)
      {
         LPSTR pszTmp = szBuf + lstrlen(szBuf);
         lstrcpy(pszTmp, ",");
         pszTmp++;
         lstrcpy(pszTmp, pszMode);         
         hr = WriteTokenizeString(_pCif->GetCifPath(), _szID, MODES_KEY, szBuf);
      }
   }
   else
      hr = WritePrivateProfileString(_szID, MODES_KEY, pszMode, _pCif->GetCifPath()) ? NOERROR : E_FAIL;

   return hr;
}

STDMETHODIMP CCifRWComponent::SetModes(LPCSTR pszMode)
{
    return (WriteTokenizeString(_pCif->GetCifPath(), _szID, MODES_KEY, pszMode)?NOERROR:E_FAIL);
}

STDMETHODIMP CCifRWComponent::CopyComponent(LPCSTR pszCifFile)
{
   LPSTR pszSec;
   DWORD dwSize;
   HRESULT hr = NOERROR;

   dwSize = MAX_VALUE_LEN*4*4;
   pszSec = (LPSTR)LocalAlloc(LPTR, dwSize);  //allocate 4K buffer to read section
   while(pszSec && GetPrivateProfileSection(_szID, pszSec, dwSize, pszCifFile)==(dwSize-2))
   {
      LocalFree(pszSec);
      dwSize = dwSize*2;
      pszSec = (LPSTR)LocalAlloc(LPTR, dwSize);
   }

   if (pszSec)
   {
      // first clean the Old section if there
      WritePrivateProfileString(_szID, NULL, NULL, _pCif->GetCifPath());
      // write out the copied section
      WritePrivateProfileSection(_szID, pszSec, _pCif->GetCifPath());

      LocalFree(pszSec);
   }
   else
      hr = E_OUTOFMEMORY;

   // need to check to see if we need to get strings out of the Strings section

   CopyCifString(_szID, DISPLAYNAME_KEY, pszCifFile, _pCif->GetCifPath());
   CopyCifString(_szID, DETAILS_KEY, pszCifFile, _pCif->GetCifPath());
   CopyCifString(_szID, MODES_KEY, pszCifFile, _pCif->GetCifPath());
   CopyCifString(_szID, LOCALE_KEY, pszCifFile, _pCif->GetCifPath());

   return hr;
}

STDMETHODIMP CCifRWComponent::AddToTreatAsOne(LPCSTR pszCompID)
{
   char szBuf[MAX_VALUE_LEN];   
   char szOneID[MAX_ID_LENGTH];
   LPSTR pszTmp;
   UINT i = 0;
   BOOL bFound = FALSE;
   HRESULT hr = NOERROR;

   if (SUCCEEDED(MyTranslateString(_pCif->GetCifPath(), _szID, TREATAS_KEY, szBuf, sizeof(szBuf))))
   {    
      while(GetStringField(szBuf, i++, szOneID, sizeof(szOneID)))
      {
         if (lstrcmpi(szOneID, pszCompID) == 0)
         {
            // found it, no need to add
            bFound = TRUE;
            break;
         }
      }
      if (!bFound)
      {
         LPSTR pszTmp = szBuf + lstrlen(szBuf);
         lstrcpy(pszTmp, ",");
         pszTmp++;
         lstrcpy(pszTmp, pszCompID);         
         hr = WriteTokenizeString(_pCif->GetCifPath(), _szID, TREATAS_KEY, szBuf);
      }
   }
   else
      hr = WritePrivateProfileString(_szID, TREATAS_KEY, pszCompID, _pCif->GetCifPath()) ? NOERROR : E_FAIL;

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\inseng\ciffile.cpp ===
#include "inspch.h"
#include <regstr.h>
#include "resource.h"
#include "insobj.h"


#define STR_FILELIST "filelist.dat"
#define GENERAL_SECTION "General"
#define MIN_SUPPORTED_FILELIST_VER 1
#define CURRENT_FILELIST_VER "1"

HRESULT GetICifFileFromFile(ICifFile **p, LPCSTR pszPath)
{
   HRESULT hr;
   CCifFile *pcif;

   *p = 0;
   pcif = new CCifFile();
   if(pcif)
   {
      hr = pcif->SetCifFile(pszPath, FALSE); // FALSE: Read version
      if(FAILED(hr))
         delete pcif;
      else
      {
         pcif->AddRef();
         *p = (ICifFile *)pcif;
      }
   }   
   else
      hr = E_OUTOFMEMORY;

   return hr;
}

HRESULT GetICifRWFileFromFile(ICifRWFile **p, LPCSTR pszPath)
{
   HRESULT hr;
   CCifRWFile *pcifrw;

   *p = 0;
   pcifrw = new CCifRWFile();
   if(pcifrw)
   {
      hr = pcifrw->SetCifFile(pszPath, TRUE);  // TRUE: ReadWrite version
      if(FAILED(hr))
         delete pcifrw;
      else
      {
         pcifrw->AddRef();
         *p = (ICifRWFile *)pcifrw;
      }
   }   
   else
      hr = E_OUTOFMEMORY;

   return hr;
}


CCifFile::CCifFile()
{
   _cRef = 0;
   _cComp = 0;
   _cGroup = 0;
   _cMode = 0;
   _rpGroup = 0;
   _rpComp = 0;
   _rpMode = 0;
   _rpRWGroup = 0;
   _rpRWComp = 0;
   _rpRWMode = 0;   
   _fCleanDir = FALSE;
   _pLastCriticalComp = NULL;
}

CCifFile::~CCifFile()
{
   UINT i;
   if(_rpGroup)
   {
      CCifGroup *pgrp;

      i = 0;
      for(pgrp = _rpGroup[i]; pgrp != 0; pgrp = _rpGroup[++i])
         delete pgrp;
   
      free(_rpGroup);
   }
   
   
   if(_rpComp)
   {
      CCifComponent *pcomp;

      i = 0;
      for(pcomp = _rpComp[i]; pcomp != 0; pcomp = _rpComp[++i])
          delete pcomp;
   
      free(_rpComp);
   }

   if(_rpMode)
   {

      CCifMode *pmode;

      i = 0;
      for(pmode = _rpMode[i]; pmode != 0; pmode = _rpMode[++i])
         delete pmode;
   
      free(_rpMode);
   }

   if(_fCleanDir)
   {
      GetParentDir(_szCifPath);
      CleanUpTempDir(_szCifPath);
   }

}

//************ IUnknown implementation ***************


STDMETHODIMP_(ULONG) CCifFile::AddRef()                      
{
   return(_cRef++);
}


STDMETHODIMP_(ULONG) CCifFile::Release()
{
   ULONG temp = --_cRef;

   if(temp == 0)
      delete this;
   return temp;
}


STDMETHODIMP CCifFile::QueryInterface(REFIID riid, void **ppv)
{
   *ppv = 0;

   if((riid == IID_IUnknown) || (riid == IID_ICifFile))
      *ppv = (ICifFile *)this;
   
   if(*ppv == NULL)
      return E_NOINTERFACE;
   
   AddRef();
   return NOERROR;
}

// ICifFile implementation

STDMETHODIMP CCifFile::EnumComponents(IEnumCifComponents **pp, DWORD dwFilter, LPVOID pv)
{
   CCifComponentEnum *pce;
   HRESULT hr = E_FAIL;

   *pp = 0;

   pce = new CCifComponentEnum(_rpComp, dwFilter, PARENTTYPE_CIF, NULL);
   if(pce)
   {
      *pp = (IEnumCifComponents *) pce;
      (*pp)->AddRef();
      hr = NOERROR;
   }
   
   return hr;
}
 
STDMETHODIMP CCifFile::FindComponent(LPCSTR pszID, ICifComponent **p)
{
   CCifComponent *pcomp;
   UINT i = 0;
   
   *p = 0;
   if(_rpComp)
   {
      for(pcomp = _rpComp[i]; pcomp != 0; pcomp = _rpComp[++i])
         if(pcomp->IsID(pszID))
         {
            *p = (ICifComponent *) pcomp;
            return NOERROR;
         }
   }

   return E_FAIL;
}

STDMETHODIMP CCifFile::EnumGroups(IEnumCifGroups **pp, DWORD dwFilter, LPVOID pv)
{
   CCifGroupEnum *pge;
   HRESULT hr = E_FAIL;

   *pp = 0;

   pge = new CCifGroupEnum(_rpGroup, dwFilter);
   if(pge)
   {
      *pp = (IEnumCifGroups *) pge;
      (*pp)->AddRef();
      hr = NOERROR;
   }
   
   return hr;
}

STDMETHODIMP CCifFile::FindGroup(LPCSTR pszID, ICifGroup **p)
{
   CCifGroup *pgrp;
   UINT i = 0;
   
   *p = 0;
   if(_rpGroup)
   {
      for(pgrp = _rpGroup[i]; pgrp != 0; pgrp = _rpGroup[++i])
         if(pgrp->IsID(pszID))
         {
            *p = (ICifGroup *) pgrp;
            return NOERROR;
         }
   }
   return E_FAIL;

}

STDMETHODIMP CCifFile::EnumModes(IEnumCifModes **pp, DWORD dwFilter, LPVOID pv)
{
   CCifModeEnum *pme;
   HRESULT hr = E_FAIL;

   *pp = 0;

   pme = new CCifModeEnum(_rpMode, dwFilter);
   if(pme)
   {
      *pp = (IEnumCifModes *) pme;
      (*pp)->AddRef();
      hr = NOERROR;
   }
   
   return hr;

}

STDMETHODIMP CCifFile::FindMode(LPCSTR pszID, ICifMode **p)
{
   CCifMode *pmode;
   UINT i = 0;
   
   *p = 0;
   if(_rpMode)
   {
      for(pmode = _rpMode[i]; pmode != 0; pmode = _rpMode[++i])
         if(pmode->IsID(pszID))
         {
            *p = (ICifMode *) pmode;
            return NOERROR;
         }
   }
   return E_FAIL;
}

STDMETHODIMP CCifFile::GetDescription(LPSTR pszDesc, DWORD dwSize)
{
   // Get display title out of version section
   if(FAILED(MyTranslateString(_szCifPath, "Version", DISPLAYNAME_KEY, pszDesc, dwSize)))
      LoadSz(IDS_DEFAULTTITLE, pszDesc, dwSize);
   return NOERROR;
}

STDMETHODIMP CCifFile::GetDetDlls(LPSTR pszDlls, DWORD dwSize)
{
   return(GetPrivateProfileString("Version", DETDLLS_KEY, "", pszDlls, dwSize, _szCifPath)?NOERROR:E_FAIL);
}

//const char c_gszRegstrPathIExplore[] = REGSTR_PATH_APPPATHS "\\iexplore.exe";

HRESULT CCifFile::SetCifFile(LPCSTR pszCifPath, BOOL bRWFlag)
{
   HRESULT hr = NOERROR;
   UINT i;

   // if it is not quallified, start from ie
   if(PathIsFileSpec(pszCifPath))
   {
      DWORD dwSize, dwType;
      char szTmp[MAX_PATH];

      if ( SUCCEEDED(hr=GetIEPath(szTmp, sizeof(szTmp))))
      {
         lstrcpy(_szCifPath, szTmp);
         SafeAddPath(_szCifPath, pszCifPath, sizeof(_szCifPath));
      }
   }
   else   // we were given a full path
      lstrcpyn(_szCifPath, pszCifPath, MAX_PATH);
   
   if(SUCCEEDED(hr))
   {
      if(_rpComp)
      {
         // we already have a cif, so just reset cached stuff, and pray...
         for(i = 0; i < _cComp; i++)
         {
            _rpComp[i]->ClearCachedInfo();            
         }
         for(i = 0; i < _cGroup; i++)
         {
            _rpGroup[i]->ClearCachedInfo();
         }
         for(i = 0; i < _cMode; i++)
         {
            _rpMode[i]->ClearCachedInfo();
         }
         
         // Sort all again, in case priorities changed
         SortEntries();
      }
      else
         hr = _ParseCifFile(bRWFlag);
   }

   return(hr);
}

HRESULT CCifFile::_ParseCifFile(BOOL bRWFlag)
{
   LPSTR pszSections;
   LPSTR pszSectionsPreFail = NULL;
   DWORD dwSize = ALLOC_CHUNK_SIZE;
   LPSTR pszTemp;
   char szEntryBuf[MAX_DISPLAYNAME_LENGTH];
   
   pszSections = (LPSTR) malloc(dwSize);
   // when the buffer is too small, GPPS returns bufsize - 2
   while(pszSections && 
        (GetPrivateProfileStringA(NULL, NULL, "", pszSections, dwSize, _szCifPath) == (dwSize - 2)))
   {
      dwSize += ALLOC_CHUNK_SIZE;
      pszSectionsPreFail = pszSections;
#pragma prefast(suppress: 308, "PREfast noise - pointer was saved before")
      pszSections = (LPSTR) realloc(pszSections, dwSize);
   }

   if(!pszSections)
   {
      if(pszSectionsPreFail)
         free(pszSectionsPreFail);
      return E_OUTOFMEMORY;
   }

   if(lstrlen(pszSections) == 0)
      return E_FAIL;

   // whip thru the sections, and find counts for modes, groups, and components
   _cComp = _cGroup = _cMode = 0;

   for(pszTemp = pszSections; *pszTemp != 0; pszTemp += (lstrlen(pszTemp) + 1))
   {
      // skip String section and Version section
      if( (lstrcmpi(pszTemp, "Strings") != 0)
              && (lstrcmpi(pszTemp, "Version") != 0) )
      {
         GetPrivateProfileString(pszTemp, ENTRYTYPE_KEY, ENTRYTYPE_COMP, szEntryBuf, sizeof(szEntryBuf), _szCifPath);
         // see if this is a comp, group, or mode
         if(lstrcmpi(szEntryBuf, ENTRYTYPE_COMP) == 0)
            _cComp++;
         else if(lstrcmpi(szEntryBuf, ENTRYTYPE_GROUP) == 0)
            _cGroup++;
         else if(lstrcmpi(szEntryBuf, ENTRYTYPE_MODE) == 0)
            _cMode++;
      }
   }

   // alloc arrays to hold each type (1 more than count - last entry null)
   if (bRWFlag)
   {
      _rpRWComp  = (CCifRWComponent **) calloc(sizeof(CCifRWComponent *), _cComp + 1);
      _rpRWGroup = (CCifRWGroup **) calloc(sizeof(CCifRWGroup *), _cGroup + 1);
      _rpRWMode  = (CCifRWMode **) calloc(sizeof(CCifRWMode *), _cMode + 1);
   }
   else
   {
      _rpComp  = (CCifComponent **) calloc(sizeof(CCifComponent *), _cComp + 1);
      _rpGroup = (CCifGroup **) calloc(sizeof(CCifGroup *), _cGroup + 1);
      _rpMode  = (CCifMode **) calloc(sizeof(CCifMode *), _cMode + 1);
   }
   _cComp = _cGroup = _cMode = 0;

   if((!bRWFlag && _rpComp && _rpGroup && _rpMode) || (bRWFlag && _rpRWComp && _rpRWGroup && _rpRWMode))
   {   
      // pass thru sections again, adding to lists
      for(pszTemp = pszSections; *pszTemp != 0; pszTemp += (lstrlen(pszTemp) + 1))
      {
         // skip String section and Version section
         if( (lstrcmpi(pszTemp, "Strings") != 0)
            && (lstrcmpi(pszTemp, "Version") != 0) )
         {
            GetPrivateProfileString(pszTemp, ENTRYTYPE_KEY, ENTRYTYPE_COMP, szEntryBuf, sizeof(szEntryBuf), _szCifPath);
            // see if this is a comp, group, or mode
            if(lstrcmpi(szEntryBuf, ENTRYTYPE_COMP) == 0)
            {
               if (bRWFlag)
                  _rpRWComp[_cComp++] = new CCifRWComponent(pszTemp, this);
               else
                  _rpComp[_cComp++] = new CCifComponent(pszTemp, this);
            }
            else if(lstrcmpi(szEntryBuf, ENTRYTYPE_GROUP) == 0)
            {
               if (bRWFlag)
                  _rpRWGroup[_cGroup++] = new CCifRWGroup(pszTemp, _cGroup, this);
               else
                  _rpGroup[_cGroup++] = new CCifGroup(pszTemp, _cGroup, this);
            }
            else if(lstrcmpi(szEntryBuf, ENTRYTYPE_MODE) == 0)
            {
               if (bRWFlag)
                  _rpRWMode[_cMode++] = new CCifRWMode(pszTemp, this);
               else
                  _rpMode[_cMode++] = new CCifMode(pszTemp, this);
            }
         }
      }
   }
   if(_cComp) _cComp--;
   if(_cGroup) _cGroup--;
   if(_cMode)  _cMode--;


   if (!bRWFlag)
      SortEntries();
   free(pszSections);
   return NOERROR;
}

void CCifFile::ReinsertComponent(CCifComponent *pComp)
{
   int i,j;

   // find it in list
   for(i = 0; i <= (int) _cComp; i++)
   {
      if(pComp == _rpComp[i])
      {
         // once found, move everything under it up
         for(j = i + 1; j <=(int) (_cComp + 1); j++)
            _rpComp[j-1] = _rpComp[j];

         break;
      }
   }

   // now find where we should insert it
   for(i = 0; _rpComp[i] != 0; i++)
   {
      if(_rpComp[i]->GetCurrentPriority() < pComp->GetCurrentPriority())
         break;
   }
   
   // we want to isert new guy at i
   // move everyone down first
   for(j = _cComp; j >= i; j--)
      _rpComp[j+1] = _rpComp[j];

      // reinsert at i
   _rpComp[i] = pComp;
   

	// Now check that the dependencies are maintained.
	_CheckDependencyPriority();
}





void CCifFile::SortEntries()
{
   _SortComponents(_rpComp, 0, _cComp);
   _SortGroups(_rpGroup, 0, _cGroup);
   _CheckDependencyPriority();
}

void CCifFile::_CheckDependencyPriority()
{
   char szCompBuf[MAX_ID_LENGTH];
   CCifComponent *pCompxkokr;
   CCifComponent *pCompxenus;
   DWORD ixkokr = 0xffffffff;
   DWORD ixenus = 0xffffffff;
   
   // this is a complete hack for Outlook 98 Korean, which has bugs
   //  in prorities.
   
   for(int i = 0; _rpComp[i] != 0; i++)
   {
      if(_rpComp[i]->IsID("Outlook98_xkokr"))
      {
         pCompxkokr = _rpComp[i];
         ixkokr = i;
      }
      else if(_rpComp[i]->IsID("Outlook98_xenus")) 
      {
         pCompxenus = _rpComp[i];
         ixenus = i;
      }
   }
   if(ixkokr != 0xffffffff && ixenus != 0xffffffff)
   {
      if(ixenus > ixkokr)
      {
         _rpComp[ixenus] = pCompxkokr;
         _rpComp[ixkokr] = pCompxenus;
      }
   }
   
}

void CCifFile::ClearQueueState()
{
   for(int i = 0; _rpComp[i] != 0; i++)
   {
      _rpComp[i]->ClearQueueState();
   }

}

void CCifFile::_SortComponents(CCifComponent * a[], UINT p, UINT r)
{
   UINT i, j, x;
   CCifComponent *t;

   if(p < r)
   {
      i = p - 1;
      j = r + 1;
      x = a[p]->GetCurrentPriority();
      for(;;)
      {
         while(a[++i]->GetCurrentPriority() > x);
         while(a[--j]->GetCurrentPriority() < x);
         if(i >= j) break;
         t = a[i]; a[i] = a[j]; a[j] = t;
      }
      _SortComponents(a, p, j);
      _SortComponents(a, j + 1, r);
   }
}

void CCifFile::_SortGroups(CCifGroup * a[], UINT p, UINT r)
{
   UINT i, j, x;
   CCifGroup *t;

   if(p < r)
   {
      i = p - 1;
      j = r + 1;
      x = a[p]->GetCurrentPriority();
      for(;;)
      {
         while(a[++i]->GetCurrentPriority() > x);
         while(a[--j]->GetCurrentPriority() < x);
         if(i >= j) break;
         t = a[i]; a[i] = a[j]; a[j] = t;
      }
      _SortGroups(a, p, j);
      _SortGroups(a, j + 1, r);
   }   
}


void CCifFile::SetDownloadDir(LPCSTR pszDownloadDir)
{
   char szBuf[MAX_PATH];
   DWORD dwLen;
   DWORD dwVer;
   
   lstrcpyn(_szDLDir, pszDownloadDir, MAX_PATH);

   if(_szDLDir[0] >= 'a' && _szDLDir[0] <= 'z')
      _szDLDir[0] -= 32;


   lstrcpyn(_szFilelist, pszDownloadDir, MAX_PATH);
   SafeAddPath(_szFilelist, STR_FILELIST, MAX_PATH);
   
   // check to see if the download list has a version we like
   dwVer = GetPrivateProfileInt(GENERAL_SECTION, VERSION_KEY, 0, _szFilelist); 
   if(dwVer < MIN_SUPPORTED_FILELIST_VER)
      DeleteFilelist(_szFilelist);
      
   WritePrivateProfileString(GENERAL_SECTION, VERSION_KEY, CURRENT_FILELIST_VER, _szFilelist);

   // flush due to wierd stacker bug
   WritePrivateProfileString(NULL, NULL, NULL, _szFilelist);
}

HRESULT CCifFile::Download()
{
   CCifComponent *pcomp;
   UINT i = 0;
   HRESULT hr = NOERROR;

   for(pcomp = _rpComp[i]; pcomp != 0 && SUCCEEDED(hr); pcomp = _rpComp[++i])
   {
      // if it is queued up and not downloded, download it 
      if((pcomp->GetInstallQueueState() == SETACTION_INSTALL) && 
         (pcomp->IsComponentDownloaded() == S_FALSE) )
      {
         hr = pcomp->Download();
         if(FAILED(hr) && _pInsEng->IgnoreDownloadError() && hr != E_ABORT)
            hr = NOERROR;
         
         if(SUCCEEDED(hr))
            hr = _pInsEng->CheckForContinue();
       
      }
   }

   return hr;
}

HRESULT CCifFile::Install(BOOL *pfOneInstalled)
{
   CCifComponent *pcomp;
   UINT i = 0;
   *pfOneInstalled = FALSE;
   HRESULT hr = NOERROR;

   for(pcomp = _rpComp[i]; (pcomp != 0) && SUCCEEDED(hr); pcomp = _rpComp[++i])
   {
      // if it is queued up and not downloded, download it 
      if(pcomp->GetInstallQueueState() == SETACTION_INSTALL)
      {
         hr = pcomp->Install();
         
         if(SUCCEEDED(hr))
            *pfOneInstalled = TRUE;
         
         if(hr != E_ABORT)
            hr = NOERROR;

         if(SUCCEEDED(hr))
            hr = _pInsEng->CheckForContinue();
      }
   }
 
   return hr;
}

HRESULT CCifFile::_ExtractDetDlls( LPCSTR pszCab, LPCSTR pszPath )
{
   char szDetDlls[MAX_PATH];
   char szLogBuf[MAX_PATH*2];
   char szBuf[64];
   UINT i = 0;
   LPSTR pszTmp;
   HRESULT hr = NOERROR;

      // check if we need to extract & copy the detection dlls
   if (SUCCEEDED(GetDetDlls(szDetDlls, sizeof(szDetDlls))))
   {      
      while(SUCCEEDED(hr) && GetStringField(szDetDlls, i++, szBuf, sizeof(szBuf)))
      {
         if(SUCCEEDED(ExtractFiles(pszCab, pszPath, 0, szBuf, NULL, 0)))
         {
            wsprintf(szLogBuf, "Extract DetDll path:%s file:%s\r\n",pszPath, szBuf ); 
            _pInsEng->WriteToLog(szLogBuf, TRUE);
         }
         else
         {
            wsprintf(szLogBuf, "Extract DetDll:%s from: %s\r\n", szBuf, pszCab); 
            _pInsEng->WriteToLog(szLogBuf, TRUE);
            hr = E_FAIL;
         }
      }     
   }

   return hr;
}

HRESULT CCifFile::_CopyDetDlls( LPCSTR pszPath )
{
   char szDetDlls[MAX_PATH];
   char szSrcFile[MAX_PATH];
   char szDestFile[MAX_PATH];
   char szLogBuf[MAX_PATH*2];
   char szBuf[64];
   UINT i = 0;
   LPSTR pszTmp;

      // check if we need to extract & copy the detection dlls
   if (SUCCEEDED(GetDetDlls(szDetDlls, sizeof(szDetDlls))))
   {
      lstrcpy(szDestFile, _szCifPath);
      GetParentDir(szDestFile);
      pszTmp = szDestFile + lstrlen(szDestFile);
      
      while(GetStringField(szDetDlls, i++, szBuf, sizeof(szBuf)))
      {
        lstrcpy(szSrcFile, pszPath);
        AddPath(szSrcFile, szBuf);
        
        *pszTmp = 0;
        AddPath(szDestFile, szBuf);
        CopyFile(szSrcFile, szDestFile, FALSE);

        wsprintf(szLogBuf, "Copy DetDll fr:%s to:%s\r\n", szSrcFile, szDestFile); 
        _pInsEng->WriteToLog(szLogBuf, TRUE);
      }
      return NOERROR;
   }
   else
      return E_FAIL;   
}


HRESULT CCifFile::DownloadCifFile(LPCSTR pszUrl, LPCSTR pszCif)
{
   HRESULT hr;
   char szTempfile[MAX_PATH];
   char szDownldfile[MAX_PATH];
   char szPath[MAX_PATH];
    
   _pInsEng->AddRef();
   _pInsEng->OnEngineStatusChange(ENGINESTATUS_LOADING, 0);
   CDownloader *pDL = _pInsEng->GetDownloader();
   if(!pDL)
      return E_UNEXPECTED;
   
   hr = pDL->SetupDownload(pszUrl, NULL, 0, NULL);
   
   szPath[0] = 0;
   if(SUCCEEDED(hr))
      hr = pDL->DoDownload(szDownldfile, sizeof(szDownldfile));
   
   if(SUCCEEDED(hr))
   {
      hr = ::CheckTrustEx(pszUrl, szDownldfile, _pInsEng->GetHWND(), FALSE, NULL);
      if (hr == S_FALSE)
          hr = TRUST_E_FAIL;
      
      // For compat reasons, we need to copy the cif cab into the download dir
      if(SUCCEEDED(hr))
      {
         lstrcpy(szPath, _szDLDir);
         SafeAddPath(szPath, ParseURLA(pszUrl), sizeof(szPath));
         CopyFile(szDownldfile, szPath, FALSE);
      }
      
      lstrcpy(szPath, szDownldfile);
      GetParentDir(szPath);
   }
   
   if(SUCCEEDED(hr))
      hr=ExtractFiles(szDownldfile, szPath, 0, pszCif, NULL, 0);
    
   if(SUCCEEDED(hr))
   {
      //BUGBUG: we should validate cif we got somehow!
   
      
      // if we already have a cif, copy what we need over old cif, delete temp now
      if(_rpComp)
      {
         // Dest
         lstrcpy(szTempfile, _szCifPath);
         GetParentDir(szTempfile);
         AddPath(szTempfile, pszCif);
      
         // source
         SafeAddPath(szPath, pszCif, sizeof(szPath));
     
         // copy to old one
         CopyFile(szPath, szTempfile, FALSE);
         hr = SetCifFile(szTempfile, FALSE);  // read only version

         GetParentDir(szPath);
         
         // check if we need to extract & copy the detection dlls
         if (SUCCEEDED(hr))
         {
            if(SUCCEEDED(hr =_ExtractDetDlls(szDownldfile,szPath)))
                _CopyDetDlls(szPath);
         }

         DelNode(szPath, 0);
      }
      else
      {
         // new cif, use it in place in temp dir, mark temp dir to clean up
         _fCleanDir = TRUE;
         SafeAddPath(szPath, pszCif, sizeof(szPath)); 
         hr = SetCifFile(szPath, FALSE);  // read only version
         if (SUCCEEDED(hr))
         {
            GetParentDir(szPath);
            hr =_ExtractDetDlls(szDownldfile,szPath);
         }
      }      
   } 
   else
   {
      // cleanup now
      if(szPath[0] != 0)
         DelNode(szPath, 0);
   }
    
   _pInsEng->OnEngineStatusChange(SUCCEEDED(hr) ? ENGINESTATUS_READY : ENGINESTATUS_NOTREADY, hr);

    // we are done; release the install engine
   _pInsEng->Release();

   return hr;
}

HRESULT CCifFile::_FindCifComponent(LPCSTR pszID, CCifComponent **p)
{
   CCifComponent *pcomp;
   UINT i = 0;
   
   *p = 0;
   if(_rpComp)
   {
      for(pcomp = _rpComp[i]; pcomp != 0; pcomp = _rpComp[++i])
         if(pcomp->IsID(pszID))
         {
            *p = pcomp;
            return NOERROR;
         } 
   }
   return E_FAIL;
}

void CCifFile::MarkCriticalComponents(CCifComponent *pOwner)
{
   char szID[MAX_ID_LENGTH];
   UINT j;
   CCifComponent *pComp;
   
   for(j = 0;SUCCEEDED(pOwner->GetTreatAsOneComponents(j, szID, sizeof(szID))); j++)
   {
      if(SUCCEEDED(_FindCifComponent(szID, &pComp)))
      {
         if(pComp->GetInstallQueueState() == SETACTION_INSTALL)
         {
            if(_pLastCriticalComp == NULL)
               _pLastCriticalComp = pComp;
            else
            {
               UINT i = 0;

               CCifComponent *ptemp;
               for(ptemp = _rpComp[i]; ptemp != 0 && ptemp != _pLastCriticalComp && ptemp != pComp ; ptemp = _rpComp[++i]);
      
               if(ptemp == _pLastCriticalComp)
                  _pLastCriticalComp = pComp;
            }
         }
      }
   }
}

void CCifFile::RemoveFromCriticalComponents(CCifComponent *pComp)
{
   if(_pLastCriticalComp == pComp)
      _pLastCriticalComp = NULL;
}
     

DWORD WINAPI DownloadCifFile(LPVOID pv)
{
   SETCIFARGS *p = (SETCIFARGS *) pv;

   p->pCif->DownloadCifFile(p->szUrl, p->szCif);

   delete p;

   return 0;
}

CCifRWFile::CCifRWFile() : CCifFile()
{
   _cCompUnused = 0;
   _cGroupUnused = 0;
   _cModeUnused = 0;   
}

CCifRWFile::~CCifRWFile()
{
   // flus out the cif file
   WritePrivateProfileString( NULL, NULL, NULL, _szCifPath );

   if(_rpRWGroup)
   {
      for ( UINT i=0; i<=_cGroup; i++)
         delete(_rpRWGroup[i]);
      free(_rpRWGroup);
   }

   if(_rpRWComp)
   {
      for ( UINT i=0; i<=_cComp; i++)
         delete(_rpRWComp[i]);
      free(_rpRWComp);
   }

   if(_rpRWMode)
   {
      for ( UINT i=0; i<=_cMode; i++)
         delete(_rpRWMode[i]);
      free(_rpRWMode);
   }
}


// ICifRWFile implementation

// wrapper of the CCifFile functions
STDMETHODIMP CCifRWFile::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
   return (CCifFile::QueryInterface(riid, ppvObj));
}

STDMETHODIMP_(ULONG) CCifRWFile::AddRef()                      
{
   return(_cRef++);
}

STDMETHODIMP_(ULONG) CCifRWFile::Release()
{
   ULONG temp = --_cRef;

   if(temp == 0)
      delete this;
   return temp;
}
 
STDMETHODIMP CCifRWFile::EnumComponents(IEnumCifComponents **pp, DWORD dwFilter, LPVOID pv)
{
   CCifComponentEnum *pce;
   HRESULT hr = E_FAIL;

   *pp = 0;

   pce = new CCifComponentEnum((CCifComponent **)_rpRWComp, dwFilter, PARENTTYPE_CIF, NULL);
   if(pce)
   {
      *pp = (IEnumCifComponents *) pce;
      (*pp)->AddRef();
      hr = NOERROR;
   }
   
   return hr;
}

STDMETHODIMP CCifRWFile::FindComponent(LPCSTR pszID, ICifComponent **p)
{
   CCifRWComponent *pcomp;
   UINT i = 0;
   
   *p = 0;
   if(_rpRWComp)
   {
      for(pcomp = _rpRWComp[i]; pcomp != 0; pcomp = _rpRWComp[++i])
         if(pcomp->IsID(pszID))
         {
            CCifComponent *ptmp;

            ptmp = (CCifComponent *)pcomp;
            *p = (ICifComponent *) ptmp;
            return NOERROR;
         }
   }
   return E_FAIL;
}

STDMETHODIMP CCifRWFile::EnumGroups(IEnumCifGroups **pp, DWORD dwFilter, LPVOID pv)
{
   CCifGroupEnum *pge;
   HRESULT hr = E_FAIL;

   *pp = 0;

   pge = new CCifGroupEnum((CCifGroup **)_rpRWGroup, dwFilter);
   if(pge)
   {
      *pp = (IEnumCifGroups *) pge;
      (*pp)->AddRef();
      hr = NOERROR;
   }
   
   return hr;
}

STDMETHODIMP CCifRWFile::FindGroup(LPCSTR pszID, ICifGroup **p)
{
   CCifRWGroup *pgrp;
   UINT i = 0;
   
   *p = 0;
   if(_rpRWGroup)
   {
      for(pgrp = _rpRWGroup[i]; pgrp != 0; pgrp = _rpRWGroup[++i])
         if(pgrp->IsID(pszID))
         {
            CCifGroup *ptmp;

            ptmp = (CCifGroup *)pgrp;

            *p = (ICifGroup *) ptmp;
            return NOERROR;
         }
   }
   return E_FAIL;

}

STDMETHODIMP CCifRWFile::EnumModes(IEnumCifModes **pp, DWORD dwFilter, LPVOID pv)
{
   CCifModeEnum *pme;
   HRESULT hr = E_FAIL;

   *pp = 0;

   pme = new CCifModeEnum((CCifMode **)_rpRWMode, dwFilter);
   if(pme)
   {
      *pp = (IEnumCifModes *) pme;
      (*pp)->AddRef();
      hr = NOERROR;
   }
   
   return hr;
}

STDMETHODIMP CCifRWFile::FindMode(LPCSTR pszID, ICifMode **p)
{
   CCifRWMode *pmode;
   UINT i = 0;
   
   *p = 0;
   if(_rpRWMode)
   {
      for(pmode = _rpRWMode[i]; pmode != 0; pmode = _rpRWMode[++i])
         if(pmode->IsID(pszID))
         {
            CCifMode *ptmp;

            ptmp = (CCifMode *)pmode;

            *p = (ICifMode *) ptmp;
            return NOERROR;
         }
   }

   return E_FAIL;
}

STDMETHODIMP CCifRWFile::GetDescription(LPSTR pszDesc, DWORD dwSize)
{
   return(CCifFile::GetDescription(pszDesc, dwSize));
}

STDMETHODIMP CCifRWFile::GetDetDlls(LPSTR pszDlls, DWORD dwSize)
{
   return(CCifFile::GetDetDlls(pszDlls, dwSize));
}


STDMETHODIMP CCifRWFile::SetDescription(LPCSTR pszDesc)
{
   return(WriteTokenizeString(_szCifPath, "Version", DISPLAYNAME_KEY, pszDesc));   
}

STDMETHODIMP CCifRWFile::CreateComponent(LPCSTR pszID, ICifRWComponent **p)
{
   CCifRWComponent *prwcomp;
   CCifRWComponent **ppRWCompPreFail;
   BOOL  bFound = FALSE;
   UINT i = 0;
   
   *p = 0;
   for(prwcomp = _rpRWComp[i]; prwcomp != 0; prwcomp = _rpRWComp[++i])
   {
      if(prwcomp->IsID(pszID))
      {
         *p = (ICifRWComponent*)prwcomp;
         bFound = TRUE;
         break;
      }
   }
   
   // create the new component
   if (!bFound)
   {
      prwcomp = new CCifRWComponent(pszID, this);
      if (!prwcomp)
         return E_OUTOFMEMORY;

      // check to see if we need to grow the array size
      if (_cCompUnused <= 0)
      {
         // growing the array size to acomdate the new component
         ppRWCompPreFail = _rpRWComp;
#pragma prefast(suppress: 308, "PREfast noise - pointer was saved before")
         _rpRWComp = (CCifRWComponent **) realloc(_rpRWComp, sizeof(CCifRWComponent **)*(i+10));
         if (_rpRWComp)
         {
            _cCompUnused = 9;  // terminator used up one slot and the new comp use the one, s
         }
         else
         {
            if(ppRWCompPreFail)
            {
               for ( UINT i=0; i<=_cComp; i++)
                  delete(ppRWCompPreFail[i]);
               free(ppRWCompPreFail);
            }
            return E_OUTOFMEMORY;
         }
      }
      _rpRWComp[i] = prwcomp;
      _rpRWComp[i+1] = 0;
      _cCompUnused--;
      _cComp++;
      *p = (ICifRWComponent*)prwcomp;
      WritePrivateProfileString(pszID, ENTRYTYPE_KEY, ENTRYTYPE_COMP, _szCifPath);

   }
   
   return NOERROR;
}

STDMETHODIMP CCifRWFile::CreateGroup(LPCSTR pszID, ICifRWGroup **p)
{
   CCifRWGroup *prwgroup;
   CCifRWGroup **ppwgroupPreFail;
   BOOL  bFound = FALSE;
   UINT i = 0;
   
   *p = 0;
   for(prwgroup = _rpRWGroup[i]; prwgroup != 0; prwgroup = _rpRWGroup[++i])
   {
      if(prwgroup->IsID(pszID))
      {
         *p = (ICifRWGroup *)prwgroup;
         bFound = TRUE;
         break;
      }
   }
   
   // create the new component
   if (!bFound)
   {
      prwgroup = new CCifRWGroup(pszID, i+1, this);
      if (!prwgroup)
         return E_OUTOFMEMORY;

      // check to see if we need to grow the array size
      if (_cGroupUnused <= 0)
      {
         ppwgroupPreFail = _rpRWGroup;
         // growing the array size to acomdate the new component
#pragma prefast(suppress: 308, "PREfast noise - pointer was saved before")
         _rpRWGroup = (CCifRWGroup **) realloc(_rpRWGroup, sizeof(CCifRWGroup **)*(i+10));
         if (_rpRWGroup)
         {
            _cGroupUnused = 9;
         }
         else
         {
            if(ppwgroupPreFail)
            {
               for ( UINT i=0; i<=_cGroup; i++)
                  delete(ppwgroupPreFail[i]);
               free(ppwgroupPreFail);
            }
            return E_OUTOFMEMORY;
         }
      }
      _rpRWGroup[i] = prwgroup;
      _rpRWGroup[i+1] = 0;
      _cGroupUnused--;
      _cGroup++;
      *p = (ICifRWGroup *)prwgroup;
      WritePrivateProfileString(pszID, ENTRYTYPE_KEY, ENTRYTYPE_GROUP, _szCifPath);

   }      
   return NOERROR;

}
      
STDMETHODIMP CCifRWFile::CreateMode(LPCSTR pszID, ICifRWMode **p)
{
   CCifRWMode *prwmode;
   CCifRWMode **prwmodePreFail;
   BOOL  bFound = FALSE;
   UINT i = 0;
   
   *p = 0;
   for(prwmode = _rpRWMode[i]; prwmode != 0; prwmode = _rpRWMode[++i])
   {
      if(prwmode->IsID(pszID))
      {
         *p = (ICifRWMode *)prwmode;
         bFound = TRUE;
         break;
      }
   }
   
   // create the new component
   if (!bFound)
   {
      prwmode = new CCifRWMode(pszID, this);
      if (!prwmode)
         return E_OUTOFMEMORY;

      // check to see if we need to grow the array size
      if (_cModeUnused <= 0)
      {
         prwmodePreFail = _rpRWMode;
         // growing the array size to acomdate the new component
#pragma prefast(suppress: 308, "PREfast noise - pointer was saved before")
         _rpRWMode = (CCifRWMode **) realloc(_rpRWMode, sizeof(CCifRWMode **)*(i+10));
         if (_rpRWMode)
         {
            _cModeUnused = 9;
         }
         else
         {
            if(prwmodePreFail)
            {
               for ( UINT i=0; i<=_cMode; i++)
                  delete(prwmodePreFail[i]);
               free(prwmodePreFail);
            }
            return E_OUTOFMEMORY;
         }
      }
      _rpRWMode[i] = prwmode;
      _rpRWMode[i+1] = 0;
      _cModeUnused--;
      _cMode++;
      *p = (ICifRWMode *)prwmode;
      WritePrivateProfileString(pszID, ENTRYTYPE_KEY, ENTRYTYPE_MODE, _szCifPath);         

   }

   return NOERROR;
}
      
STDMETHODIMP CCifRWFile::DeleteComponent(LPCSTR pszID)
{
   CCifRWComponent *prwcomp;
   BOOL  bFound = FALSE;
   UINT i = 0;
   
   for(prwcomp = _rpRWComp[i]; prwcomp != 0; prwcomp = _rpRWComp[++i])
   {
      if(prwcomp->IsID(pszID))
      {
         bFound = TRUE;
         break;
      }
   }
   
   // Delete the component
   if (bFound)
   {
      delete(prwcomp);
      for ( UINT j=i+1; j<=_cComp; j++)
      {
         _rpRWComp[i] = _rpRWComp[j];
         i= j;
      }
      _rpRWComp[i] = 0;
      _cCompUnused++;
      _cComp--;
      
   }

   return (WritePrivateProfileString(pszID, NULL, NULL, _szCifPath)?NOERROR:E_FAIL);
}

STDMETHODIMP CCifRWFile::DeleteGroup(LPCSTR pszID)
{
   CCifRWGroup *prwgroup;
   BOOL  bFound = FALSE;
   UINT i = 0;
   
   for(prwgroup = _rpRWGroup[i]; prwgroup != 0; prwgroup = _rpRWGroup[++i])
   {
      if(prwgroup->IsID(pszID))
      {
         bFound = TRUE;
         break;
      }
   }
   
   // Delete the Group
   if (bFound)
   {
      delete(prwgroup);
      for (UINT j=i+1; j<=_cGroup; j++)
      {
         _rpRWGroup[i] = _rpRWGroup[j];
         i= j;
      }
      _rpRWGroup[i] = 0;      
      _cGroupUnused++;
      _cGroup--;
   }

   return (WritePrivateProfileString(pszID, NULL, NULL, _szCifPath)?NOERROR:E_FAIL);
}
      
STDMETHODIMP CCifRWFile::DeleteMode(LPCSTR pszID)
{
   CCifRWMode *prwmode;
   BOOL  bFound = FALSE;
   UINT i = 0;
   
   for(prwmode = _rpRWMode[i]; prwmode != 0; prwmode = _rpRWMode[++i])
   {
      if(prwmode->IsID(pszID))
      {
         bFound = TRUE;
         break;
      }
   }
   
   // Delete the Mode
   if (bFound)
   {
      delete(prwmode);
      for (UINT j=i+1; j<=_cMode; j++)
      {
         _rpRWMode[i] = _rpRWMode[j];
         i= j;
      }
      _rpRWMode[i] = 0;      
      _cModeUnused++;
      _cMode--;
   }

   return (WritePrivateProfileString(pszID, NULL, NULL, _szCifPath)?NOERROR:E_FAIL);      
}

STDMETHODIMP CCifRWFile::Flush()
{
    WritePrivateProfileString(NULL, NULL, NULL, _szCifPath);
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\inseng\ciffile.h ===
#include <wininet.h>
#include "cifcomp.h"
#include "cifmode.h"
#include "cifgroup.h"
#include "enum.h"

class CInstallEngine;


class CCifFile : public ICifFile
{
   public:
      CCifFile();
      ~CCifFile();

      HRESULT Download();
      HRESULT Install(BOOL *pfOneInstalled);
      void    SortEntries();     // sort the arrays
      void    ReinsertComponent(CCifComponent *pComp);


      HRESULT DownloadCifFile(LPCSTR pszUrl, LPCSTR pszCif);
      HRESULT SetCifFile(LPCSTR pszCifPath, BOOL bRWFlag);
      void    MarkCriticalComponents(CCifComponent *);
      void    RemoveFromCriticalComponents(CCifComponent *);
      LPCSTR  GetCifPath()     { return _szCifPath; }
      LPCSTR  GetDownloadDir() { return _szDLDir; }
      LPCSTR  GetFilelist()    { return _szFilelist; }
      void    SetDownloadDir(LPCSTR pszDir);
      void    SetInstallEngine(CInstallEngine *p)  {  _pInsEng = p; }
      BOOL    CanCancel()      { return ( _pLastCriticalComp == NULL); }
      void    ClearQueueState();
      CInstallEngine *GetInstallEngine()  { return _pInsEng; }
      CCifComponent **GetComponentList() { return _rpComp ? _rpComp:(CCifComponent **)_rpRWComp; }

      // *** IUnknown methods ***
      STDMETHOD(QueryInterface) (REFIID riid, LPVOID * ppvObj);
      STDMETHOD_(ULONG,AddRef) ();
      STDMETHOD_(ULONG,Release) ();
 
      // *** ICifFile methods ***
      STDMETHOD(EnumComponents)(IEnumCifComponents **, DWORD dwFilter, LPVOID pv);
      STDMETHOD(FindComponent)(LPCSTR pszID, ICifComponent **p);

      STDMETHOD(EnumGroups)(IEnumCifGroups **, DWORD dwFilter, LPVOID pv);
      STDMETHOD(FindGroup)(LPCSTR pszID, ICifGroup **p);

      STDMETHOD(EnumModes)(IEnumCifModes **, DWORD dwFilter, LPVOID pv);
      STDMETHOD(FindMode)(LPCSTR pszID, ICifMode **p);

      STDMETHOD(GetDescription)(LPSTR pszDesc, DWORD dwSize);  
      STDMETHOD(GetDetDlls)(LPSTR pszDlls, DWORD dwSize);

   protected:
      // private data
      UINT            _cRef;                 // ref count
      char            _szCifPath[MAX_PATH];  // local path to cif
      char            _szFilelist[MAX_PATH]; // filelist.dat
      char            _szDLDir[MAX_PATH];    // download directory
      CInstallEngine  *_pInsEng;
      CCifComponent **_rpComp;               // array of components
      CCifGroup     **_rpGroup;              // array of groups
      CCifMode      **_rpMode;               // array of modes
      UINT            _cComp;
      UINT            _cGroup;
      UINT            _cMode;
      CCifComponent   *_pLastCriticalComp;

      // for read write arrays
      CCifRWComponent **_rpRWComp;               // array of components
      CCifRWGroup     **_rpRWGroup;              // array of groups
      CCifRWMode      **_rpRWMode;               // array of modes
      
      BOOL            _fCleanDir:1;

      // private methods
      HRESULT         _ParseCifFile(BOOL bRWFlag);       // parse cif into arrays
      void            _SortComponents(CCifComponent **, UINT start, UINT finish);
      void            _SortGroups(CCifGroup **, UINT start, UINT finish);
      HRESULT         _ExtractDetDlls(LPCSTR pszCab, LPCSTR pszPath);
      HRESULT         _CopyDetDlls(LPCSTR pszPath);
      HRESULT         _FindCifComponent(LPCSTR pszID, CCifComponent **p);
      void            _CheckDependencyPriority();

};


class CCifRWFile : public ICifRWFile, public CCifFile
{
   public:
      // *** IUnknown methods ***
      STDMETHOD(QueryInterface) (REFIID riid, LPVOID * ppvObj);
      STDMETHOD_(ULONG,AddRef) ();
      STDMETHOD_(ULONG,Release) ();
 
      // *** ICifFile methods ***
      STDMETHOD(EnumComponents)(IEnumCifComponents **, DWORD dwFilter, LPVOID pv);
      STDMETHOD(FindComponent)(LPCSTR pszID, ICifComponent **p);

      STDMETHOD(EnumGroups)(IEnumCifGroups **, DWORD dwFilter, LPVOID pv);
      STDMETHOD(FindGroup)(LPCSTR pszID, ICifGroup **p);

      STDMETHOD(EnumModes)(IEnumCifModes **, DWORD dwFilter, LPVOID pv);
      STDMETHOD(FindMode)(LPCSTR pszID, ICifMode **p);

      STDMETHOD(GetDescription)(LPSTR pszDesc, DWORD dwSize);      
      STDMETHOD(GetDetDlls)(LPSTR pszDlls, DWORD dwSize);

      // 
      CCifRWFile();
      ~CCifRWFile();

      // ICifRWFile methods
      STDMETHOD(SetDescription)(THIS_ LPCSTR pszDesc);
      STDMETHOD(CreateComponent)(THIS_ LPCSTR pszID, ICifRWComponent **p);
      STDMETHOD(CreateGroup)(THIS_ LPCSTR pszID, ICifRWGroup **p);
      STDMETHOD(CreateMode)(THIS_ LPCSTR pszID, ICifRWMode **p);
      STDMETHOD(DeleteComponent)(THIS_ LPCSTR pszID);
      STDMETHOD(DeleteGroup)(THIS_ LPCSTR pszID);
      STDMETHOD(DeleteMode)(THIS_ LPCSTR pszID);
      STDMETHOD(Flush)();

   private:
      UINT _cCompUnused;
      UINT _cGroupUnused;
      UINT _cModeUnused;
};


typedef struct _SetCifArgs
{
   char szUrl[INTERNET_MAX_URL_LENGTH];
   char szCif[MAX_PATH];
   CCifFile *pCif;
} SETCIFARGS;


DWORD WINAPI DownloadCifFile(LPVOID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\inseng\cifgroup.cpp ===
#include "inspch.h"
#include "util2.h"
#include "inseng.h"
#include "ciffile.h"


//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

CCifGroup::CCifGroup(LPCSTR pszCompID, UINT uGrpNum, CCifFile *pCif) : CCifEntry(pszCompID, pCif) 
{
   _uGrpNum = uGrpNum;
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

CCifGroup::~CCifGroup()
{
}


STDMETHODIMP CCifGroup::GetID(LPSTR pszID, DWORD dwSize)
{
   lstrcpyn(pszID, _szID, dwSize);
   return NOERROR;
}


STDMETHODIMP CCifGroup::GetDescription(LPSTR pszDesc, DWORD dwSize)
{
   return(MyTranslateString(_pCif->GetCifPath(), _szID, DISPLAYNAME_KEY, pszDesc, dwSize));   
}

STDMETHODIMP_(DWORD) CCifGroup::GetPriority()
{
   return(GetPrivateProfileInt(_szID, PRIORITY, 0, _pCif->GetCifPath()));
}

STDMETHODIMP CCifGroup::EnumComponents(IEnumCifComponents **pp, DWORD dwFilter, LPVOID pv)
{
   CCifComponentEnum *pce;
   HRESULT hr = E_FAIL;

   *pp = 0;

   pce = new CCifComponentEnum(_pCif->GetComponentList(), dwFilter, PARENTTYPE_GROUP, _szID);
   if(pce)
   {
      *pp = (IEnumCifComponents *) pce;
      (*pp)->AddRef();
      hr = NOERROR;
   }
   
   return hr;
}

STDMETHODIMP_(DWORD) CCifGroup::GetInstallQueueState()
{
   return E_NOTIMPL;
}


STDMETHODIMP_(DWORD) CCifGroup::GetCurrentPriority()
{
   if(_uPriority == 0xffffffff)
      _uPriority = ((GetPriority() << 10) + _uGrpNum) << 10;
   
   return _uPriority;
}

//=========== ICifRWGroup implementation ============================================
//
CCifRWGroup::CCifRWGroup(LPCSTR pszID, UINT uGrpNum, CCifFile *pCif) : CCifGroup(pszID, uGrpNum, pCif)
{
}

CCifRWGroup::~CCifRWGroup()
{

}

STDMETHODIMP CCifRWGroup::GetID(LPSTR pszID, DWORD dwSize)
{
   return(CCifGroup::GetID(pszID, dwSize));
}

STDMETHODIMP CCifRWGroup::GetDescription(LPSTR pszDesc, DWORD dwSize)
{
   return(CCifGroup::GetDescription(pszDesc, dwSize));
}

STDMETHODIMP_(DWORD) CCifRWGroup::GetPriority()
{
   return(CCifGroup::GetPriority());
}

STDMETHODIMP CCifRWGroup::EnumComponents(IEnumCifComponents **pp, DWORD dwFilter, LPVOID pv)
{
   CCifComponentEnum *pce;
   HRESULT hr = E_FAIL;

   *pp = 0;

   pce = new CCifComponentEnum((CCifComponent**)_pCif->GetComponentList(), dwFilter, PARENTTYPE_GROUP, _szID);
   if(pce)
   {
      *pp = (IEnumCifComponents *) pce;
      (*pp)->AddRef();
      hr = NOERROR;
   }
   
   return hr;

}

// access to state
STDMETHODIMP_(DWORD) CCifRWGroup::GetCurrentPriority()
{
   return(CCifGroup::GetCurrentPriority());
}

STDMETHODIMP CCifRWGroup::SetDescription(LPCSTR pszDesc)
{
   return(WriteTokenizeString(_pCif->GetCifPath(), _szID, DISPLAYNAME_KEY, pszDesc));   
}

STDMETHODIMP CCifRWGroup::SetPriority(DWORD dwPri)
{
   char szbuf[20];

   return(WritePrivateProfileString(_szID, PRIORITY, ULtoA(dwPri, szbuf, 10), _pCif->GetCifPath()));
}   
   
STDMETHODIMP CCifRWGroup::SetDetails(LPCSTR pszDetails)
{
   return(WriteTokenizeString(_pCif->GetCifPath(), _szID, DETAILS_KEY, pszDetails));   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\inseng\diskspac.h ===
class DriveInfo
{
   public:
      DriveInfo();
      void InitDrive(char chDrive);

      DWORD Free()   { if(m_dwUsed < m_dwStart) return m_dwStart - m_dwUsed; else return 0; }
      void UseSpace(DWORD dwAmt, BOOL bCompressed);
      void FreeSpace(DWORD dwAmt, BOOL bCompressed);
      UINT CompressFactor() { return m_uCompressFactor; }

      DWORD MaxUsed()  { return m_dwMaxUsed; }
      char  Drive()    { return m_chDrive; }

   private:
      DWORD m_dwUsed;
      DWORD m_dwMaxUsed;
      DWORD m_dwStart;
      char  m_chDrive;
      UINT  m_uCompressFactor;
};

void AddTempSpace(DWORD dwDownloadSize, DWORD dwExtractSize, DriveInfo drvinfo[]);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\inseng\cifmode.h ===
class CCifMode : public ICifMode, public CCifEntry
{
   public:
      CCifMode(LPCSTR pszID, CCifFile *);
      ~CCifMode();
 
      DWORD GetCurrentPriority() { return 0; }
      // ICifMode interface
        // for properties
        // for properties
      STDMETHOD(GetID)(THIS_ LPSTR pszID, DWORD dwSize);
      STDMETHOD(GetDescription)(THIS_ LPSTR pszDesc, DWORD dwSize);
      STDMETHOD(GetDetails)(THIS_ LPSTR pszDetails, DWORD dwSize);
  
      STDMETHOD(EnumComponents)(THIS_ IEnumCifComponents **, DWORD dwFilter, LPVOID pv);

};

class CCifRWMode : public ICifRWMode, public CCifMode
{
   public:
      STDMETHOD(GetID)(THIS_ LPSTR pszID, DWORD dwSize);
      STDMETHOD(GetDescription)(THIS_ LPSTR pszDesc, DWORD dwSize);
      STDMETHOD(GetDetails)(THIS_ LPSTR pszDetails, DWORD dwSize);
  
      STDMETHOD(EnumComponents)(THIS_ IEnumCifComponents **, DWORD dwFilter, LPVOID pv);
      
      // ICifRWMode interface
      CCifRWMode(LPCSTR pszID, CCifFile *);
      ~CCifRWMode();

      STDMETHOD(SetDescription)(THIS_ LPCSTR pszDesc);
      STDMETHOD(SetDetails)(THIS_ LPCSTR pszDetails);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\inseng\diskspac.cpp ===
#include "inspch.h"
#include "diskspac.h"
#include "util2.h"

void AddTempSpace(DWORD dwDownloadSize, DWORD dwExtractSize, DriveInfo drvinfo[])
{
   DWORD uTempDrive = 0xffffffff;
   char szRoot[5] = { "A:\\" };
   BOOL bEnoughSpaceFound = FALSE;
   DWORD dwNeededSize;

   while ( szRoot[0] <= 'Z' && !bEnoughSpaceFound)
   {
      UINT uType;

      uType = GetDriveType(szRoot);

      // even the drive type is OK, verify the drive has valid connection
      //
      if ( ( ( uType != DRIVE_RAMDISK) && (uType != DRIVE_FIXED) ) ||
             ( GetFileAttributes( szRoot ) == -1) )
      {
         szRoot[0]++;
         continue;
      }
      // see if this drive is one of our "special drives" and use our own disk space
      BOOL bFoundDrive = FALSE;
      for(UINT i = 0; i < 3 && !bFoundDrive ; i++)
      {
         if(szRoot[0] == drvinfo[i].Drive())
         {
            bFoundDrive = TRUE;
            dwNeededSize = dwDownloadSize * drvinfo[i].CompressFactor() / 10 + dwExtractSize;
            if(dwNeededSize < drvinfo[i].Free())
            {   
               uTempDrive = i;
               bEnoughSpaceFound = TRUE;
            }
         }
      }
      // if !bFoundDrive, this is not a special drive, do old check
      if(!bFoundDrive)
      {
         DWORD dwVolFlags, dwCompressFactor;
         if(!GetVolumeInformation(szRoot, NULL, 0, NULL, NULL, &dwVolFlags, NULL, 0))
         {
            szRoot[0]++;
            continue;
         }
         if(dwVolFlags & FS_VOL_IS_COMPRESSED)
            dwCompressFactor = 19;
         else
            dwCompressFactor = 10;
         // Decide how much we need if we extract to this drive
         dwNeededSize = dwDownloadSize * dwCompressFactor / 10 + dwExtractSize;;
       
         // if this drive has enough bump Req if appropiate
         if(IsEnoughSpace(szRoot, dwNeededSize ))
         {
            bEnoughSpaceFound = TRUE;
         }
      
      }

      szRoot[0]++;
   }

   // ok, if we haven't found enough space anywhere, add it to install drive or win drive
   if(!bEnoughSpaceFound)
   {
      if(drvinfo[1].Drive() != 0)
         uTempDrive = 1;
      else
         uTempDrive = 0;
   }   
   
   if(uTempDrive != 0xffffffff)
   {
      drvinfo[uTempDrive].UseSpace(dwDownloadSize, TRUE);
      drvinfo[uTempDrive].UseSpace(dwExtractSize, FALSE);
      // now free up what we used
      drvinfo[uTempDrive].FreeSpace(dwDownloadSize, TRUE);
      drvinfo[uTempDrive].FreeSpace(dwExtractSize, FALSE);
   }
}



DriveInfo::DriveInfo() : m_dwUsed(0), m_dwMaxUsed(0), 
                         m_dwStart(0xffffffff), m_chDrive(0),
                         m_uCompressFactor(10)
{
    
}

void DriveInfo::InitDrive(char chDrive)
{
   char szPath[5] = { "?:\\" };
   DWORD dwVolFlags = 0;

   m_chDrive = chDrive;
   szPath[0] = chDrive;
   m_dwStart = GetSpace(szPath);
   GetVolumeInformation(szPath,NULL,0,NULL,NULL, &dwVolFlags,NULL,0);
   if(dwVolFlags & FS_VOL_IS_COMPRESSED)
      m_uCompressFactor = 19;
   else
      m_uCompressFactor = 10;
}

void DriveInfo::UseSpace(DWORD dwAmt, BOOL bCompressed)
{ 
   if(bCompressed)
      dwAmt = dwAmt * m_uCompressFactor/10;

   m_dwUsed += dwAmt;
   if(m_dwUsed > m_dwMaxUsed) 
      m_dwMaxUsed = m_dwUsed; 
}

void DriveInfo::FreeSpace(DWORD dwAmt, BOOL bCompressed)
{ 
   if(bCompressed)
      dwAmt = dwAmt * m_uCompressFactor/10;

   m_dwUsed -= dwAmt; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\inseng\cifgroup.h ===
class CCifGroup : public ICifGroup, public CCifEntry
{
   public:
      CCifGroup(LPCSTR pszID, UINT uGrpNum, CCifFile *);
      ~CCifGroup();
      
      // ICifGroup interface
        // for properties
      STDMETHOD(GetID)(LPSTR pszID, DWORD dwSize);
      STDMETHOD(GetDescription)(LPSTR pszDesc, DWORD dwSize);
      STDMETHOD_(DWORD, GetPriority)();
  
      STDMETHOD(EnumComponents)(IEnumCifComponents **, DWORD dwFilter, LPVOID pv);

      // access to state
      STDMETHOD_(DWORD, GetInstallQueueState)();
      STDMETHOD_(DWORD, GetCurrentPriority)();

   protected:
      UINT            _uGrpNum;
};

class CCifRWGroup : public ICifRWGroup, public CCifGroup
{
   public:
      CCifRWGroup(LPCSTR pszID, UINT uGrpNum, CCifFile *);
      ~CCifRWGroup();

      // ICifGroup interface
      // for properties
      STDMETHOD(GetID)(LPSTR pszID, DWORD dwSize);
      STDMETHOD(GetDescription)(LPSTR pszDesc, DWORD dwSize);
      STDMETHOD_(DWORD, GetPriority)();
      STDMETHOD(EnumComponents)(IEnumCifComponents **, DWORD dwFilter, LPVOID pv);
      // access to state
      STDMETHOD_(DWORD, GetCurrentPriority)();
      
      STDMETHOD(SetDescription)(THIS_ LPCSTR pszDesc);
      STDMETHOD(SetPriority)(THIS_ DWORD);
      STDMETHOD(SetDetails)(THIS_ LPCSTR pszDetails);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\inseng\cifmode.cpp ===
#include "inspch.h"
#include "util2.h"
#include "inseng.h"
#include "ciffile.h"


//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

CCifMode::CCifMode(LPCSTR pszCompID, CCifFile *pCif) : CCifEntry(pszCompID, pCif) 
{
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

CCifMode::~CCifMode()
{
}



STDMETHODIMP CCifMode::GetID(LPSTR pszID, DWORD dwSize)
{
   lstrcpyn(pszID, _szID, dwSize);
   return NOERROR;
}

STDMETHODIMP CCifMode::GetDescription(LPSTR pszDesc, DWORD dwSize)
{
   return(MyTranslateString(_pCif->GetCifPath(), _szID, DISPLAYNAME_KEY, pszDesc, dwSize));   
}

STDMETHODIMP CCifMode::GetDetails(LPSTR pszDetails, DWORD dwSize)
{
   return(MyTranslateString(_pCif->GetCifPath(), _szID, DETAILS_KEY, pszDetails, dwSize));   
}

STDMETHODIMP CCifMode::EnumComponents(IEnumCifComponents **pp, DWORD dwFilter, LPVOID pv)
{
   CCifComponentEnum *pce;
   HRESULT hr = E_FAIL;

   *pp = 0;

   pce = new CCifComponentEnum(_pCif->GetComponentList(), dwFilter, PARENTTYPE_MODE, _szID);
   if(pce)
   {
      *pp = (IEnumCifComponents *) pce;
      (*pp)->AddRef();
      hr = NOERROR;
   }
   
   return hr;
}

//================= ICifRWMode Implementation =============================
//
CCifRWMode::CCifRWMode(LPCSTR pszID, CCifFile *pCif) : CCifMode(pszID, pCif)
{
}

CCifRWMode::~CCifRWMode()
{
}

STDMETHODIMP CCifRWMode::GetID(LPSTR pszID, DWORD dwSize)
{
   return(CCifMode::GetID(pszID, dwSize));
}

STDMETHODIMP CCifRWMode::GetDescription(LPSTR pszDesc, DWORD dwSize)
{
   return(CCifMode::GetDescription(pszDesc, dwSize));
}

STDMETHODIMP CCifRWMode::GetDetails(LPSTR pszDetails, DWORD dwSize)
{
   return(CCifMode::GetDetails(pszDetails, dwSize));
}

STDMETHODIMP CCifRWMode::EnumComponents(IEnumCifComponents **pp, DWORD dwFilter, LPVOID pv)
{
   CCifComponentEnum *pce;
   HRESULT hr = E_FAIL;

   *pp = 0;

   pce = new CCifComponentEnum((CCifComponent**)_pCif->GetComponentList(), dwFilter, PARENTTYPE_MODE, _szID);
   if(pce)
   {
      *pp = (IEnumCifComponents *) pce;
      (*pp)->AddRef();
      hr = NOERROR;
   }
   
   return hr;
}

STDMETHODIMP CCifRWMode::SetDescription(LPCSTR pszDesc)
{
   return(WriteTokenizeString(_pCif->GetCifPath(), _szID, DISPLAYNAME_KEY, pszDesc));   
}

STDMETHODIMP CCifRWMode::SetDetails(LPCSTR pszDetails)
{
   return(WriteTokenizeString(_pCif->GetCifPath(), _szID, DETAILS_KEY, pszDetails));   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\inseng\dialmon.cpp ===
/*
 * Dialmon.cpp
 *
 * Stuff to deal with the autodial monitor
 *
 * Copyright (c) 1996 Microsoft Corporation
 */
#include "inspch.h"
#include "util2.h"

// class name for window to receive Winsock activity messages
#define AUTODIAL_MONITOR_CLASS_NAME "MS_AutodialMonitor"
#define WEBCHECK_MONITOR_CLASS_NAME "MS_WebcheckMonitor"

static const CHAR szAutodialMonitorClass[] = AUTODIAL_MONITOR_CLASS_NAME;
static const CHAR szWebcheckMonitorClass[] = WEBCHECK_MONITOR_CLASS_NAME;

#define WM_DIALMON_FIRST    WM_USER+100

// message sent to dial monitor app window indicating that there has been
// winsock activity and dial monitor should reset its idle timer
#define WM_WINSOCK_ACTIVITY     WM_DIALMON_FIRST + 0


#define MIN_ACTIVITY_MSG_INTERVAL	15000

VOID IndicateWinsockActivity(VOID)
{
	// if there is an autodisconnect monitor, send it an activity message
	// so that we don't get disconnected during long downloads.  For perf's sake,
	// don't send a message any more often than once every MIN_ACTIVITY_MSG_INTERVAL
	// milliseconds (15 seconds).  Use GetTickCount to determine interval;
	// GetTickCount is very cheap.
	DWORD dwTickCount = GetTickCount();
	static DWORD dwLastActivityMsgTickCount = 0;
	DWORD dwElapsed = dwTickCount - dwLastActivityMsgTickCount;

	// have we sent an activity message recently?
	if (dwElapsed > MIN_ACTIVITY_MSG_INTERVAL) 
    {
		HWND hwndMonitorApp = FindWindow(szAutodialMonitorClass,NULL);
        if(!hwndMonitorApp)
           hwndMonitorApp = FindWindow(szWebcheckMonitorClass,NULL);
		if (hwndMonitorApp) 
        {
			SendNotifyMessage(hwndMonitorApp,WM_WINSOCK_ACTIVITY,0,0);
		}	
					
		// record the tick count of the last time we sent an
		// activity message
			dwLastActivityMsgTickCount = dwTickCount;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\inseng\download.h ===
#include <wininet.h>
#include <urlmon.h>
#include "timetrak.h"
#include "util2.h"

// Our download sink. Works with out IMyDownloadCallback class. Consider making generic
// so you can pass any class that implements the OnData and OnProgress and OnStop

extern CRITICAL_SECTION g_cs;

#define DOWNLOADFLAGS_USEWRITECACHE   0x00000001

class CInstallEngine;

struct IMyDownloadCallback
{
	   //	OnProgess is called to allow you to present progess indication UI
	   virtual HRESULT OnProgress(ULONG progress, LPCSTR pszStatus) = 0;
};



class CDownloader
        : public IBindStatusCallback,
          public IAuthenticate,
          public CTimeTracker
   
{
   public:
      CDownloader();
      ~CDownloader();
    
      HRESULT SetupDownload(LPCSTR pszUrl, IMyDownloadCallback *, DWORD dwFlags, LPCSTR szFilename);
      HRESULT DoDownload(LPSTR szPath, DWORD dwBufSize);
      HRESULT Abort();
      HRESULT Suspend();
      HRESULT Resume();

      
      STDMETHOD(QueryInterface)(REFIID riid, void **ppvObjOut);
      STDMETHOD_(ULONG, AddRef)();
      STDMETHOD_(ULONG, Release)();

      STDMETHOD(OnStartBinding)(
            /* [in] */ DWORD grfBSCOption,
            /* [in] */ IBinding *pib);

      STDMETHOD(GetPriority)(
            /* [out] */ LONG *pnPriority);

      STDMETHOD(OnLowResource)(
            /* [in] */ DWORD reserved);

      STDMETHOD(OnProgress)(
            /* [in] */ ULONG ulProgress,
            /* [in] */ ULONG ulProgressMax,
            /* [in] */ ULONG ulStatusCode,
            /* [in] */ LPCWSTR szStatusText);

      STDMETHOD(OnStopBinding)(
            /* [in] */ HRESULT hresult,
            /* [in] */ LPCWSTR szError);

      STDMETHOD(GetBindInfo)(
            /* [out] */ DWORD *grfBINDINFOF,
            /* [unique][out][in] */ BINDINFO *pbindinfo);

      STDMETHOD(OnDataAvailable)(
            /* [in] */ DWORD grfBSCF,
            /* [in] */ DWORD dwSize,
            /* [in] */ FORMATETC *pformatetc,
            /* [in] */ STGMEDIUM *pstgmed);

      STDMETHOD(OnObjectAvailable)(
            /* [in] */ REFIID riid,
            /* [iid_is][in] */ IUnknown *punk);

              // IAuthenticate methods
      STDMETHOD(Authenticate)(HWND *phwnd,
                              LPWSTR *pszUserName, LPWSTR *pszPassword);

   private:
      char                 _szURL[INTERNET_MAX_URL_LENGTH];
      char                 _szDest[MAX_PATH];
      IBinding            *_pBnd;
      IMyDownloadCallback *_pCb;
      IMoniker            *_pMkr;

      UINT                 _uFlags;
      DWORD                _cRef;
      IStream             *_pStm;
      BOOL                 _fTimeout;
      BOOL                 _fTimeoutValid;
      UINT                 _uBytesSoFar;
      HANDLE               _hFile;
      HANDLE               _hDL;
      HRESULT              _hDLResult;
      UINT                 _uTickCount;
      IBindCtx            *_pBndContext;
};

HRESULT GetAMoniker( LPOLESTR url, IMoniker ** ppmkr );

class CInstaller : public CTimeTracker
{
   public:
      CInstaller(CInstallEngine *);
      ~CInstaller();
    
      HRESULT DoInstall(LPCSTR pszDir, LPSTR pszCmd, LPSTR pszArgs, LPCSTR pszProg, LPCSTR pszCancel, 
                        UINT uType, LPDWORD pdwStatus, IMyDownloadCallback *);
      HRESULT Abort();
      HRESULT Suspend();
      HRESULT Resume();
      
      STDMETHOD_(ULONG, AddRef)();
      STDMETHOD_(ULONG, Release)();
      
   private:
      DWORD                _cRef;
      UINT                 _uTotalProgress;
      CInstallEngine      *_pInsEng;
      HKEY                _hkProg;
      HANDLE              _hMutex;
      HANDLE              _hStatus;

      void _WaitAndPumpProgress(HANDLE hProc, IMyDownloadCallback *pcb);
};

class CPatchDownloader : public CTimeTracker
{
   public:
      CPatchDownloader(BOOL fEnable);
      ~CPatchDownloader();

      HRESULT SetupDownload(DWORD dwFullTotalSize, UINT uPatchCount, IMyDownloadCallback *pcb, LPCSTR pszDLDir);
      HRESULT DoDownload(LPCSTR szFile);

      BOOL IsEnabled()                     { return _fEnable; }
      DWORD GetFullDownloadSize()          { return _dwFullTotalSize; }
      UINT GetDownloadCount()              { return _uNumDownloads; }
      LPSTR GetPath()                      { return _szPath; }
      IMyDownloadCallback *GetCallback()   { return _pCb; }

      static BOOL Callback(PATCH_DOWNLOAD_REASON Reason, PVOID lpvInfo, PVOID pvContext);
   private:
      IMyDownloadCallback *_pCb;
      BOOL                 _fEnable;
      DWORD                _dwFullTotalSize;
      UINT                 _uNumDownloads;
      char                 _szPath[MAX_PATH];
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\inseng\download.cpp ===
#include "inspch.h"
#include "util2.h"
#include "download.h"

#define BUFFERSIZE 4096
char g_szBuffer[BUFFERSIZE];

#define TIMEOUT_PERIOD   120
#define PATCHWIN9xKEY "SOFTWARE\\Microsoft\\Advanced INF Setup"


//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

CDownloader::CDownloader() : CTimeTracker(0)
{
   _pCb    = NULL;
   _pBnd   = NULL;
   _cRef   = 1;
   _pStm   = NULL;
   _pMkr   = NULL;
   _uFlags = NULL;
   _hDL    = CreateEvent(NULL, TRUE, FALSE, NULL);
   DllAddRef();
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

CDownloader::~CDownloader()
{
   if(_hDL)
      CloseHandle(_hDL);

   DllRelease();
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

STDMETHODIMP CDownloader::QueryInterface(const GUID &riid,void **ppv )
{
   *ppv = NULL ;
    if( IsEqualGUID(riid,IID_IUnknown) ) {
        *ppv = (IUnknown *) (IBindStatusCallback *)this;
    } else if (IsEqualGUID(riid,IID_IBindStatusCallback) ) {
        *ppv = (IBindStatusCallback *) this;
    } else if (IsEqualGUID(riid, IID_IAuthenticate))
        *ppv = (IAuthenticate *) this;

    if (*ppv)
    {
        // increment our reference count before we hand out our interface
        ((LPUNKNOWN)*ppv)->AddRef();
        return(NOERROR);
    }

    return( E_NOINTERFACE );
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

STDMETHODIMP_(ULONG) CDownloader::AddRef()
{
   return(++_cRef);
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

STDMETHODIMP_(ULONG) CDownloader::Release()
{
   if(!--_cRef)
   {
      delete this;
      return(0);
   }
   return( _cRef );
}


//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

STDMETHODIMP CDownloader::GetBindInfo( DWORD *grfBINDF, BINDINFO *pbindInfo)
{
   // clear BINDINFO but keep its size
   DWORD cbSize = pbindInfo->cbSize;
   ZeroMemory( pbindInfo, cbSize );
   pbindInfo->cbSize = cbSize;
   
   *grfBINDF = BINDF_ASYNCHRONOUS | BINDF_ASYNCSTORAGE | BINDF_PULLDATA | BINDF_RESYNCHRONIZE | BINDF_PREFERDEFAULTHANDLER;
   pbindInfo->dwBindVerb = BINDVERB_GET;
   return(NOERROR);
}


//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

STDMETHODIMP CDownloader::OnStartBinding(DWORD /*grfBSCOption*/,IBinding *p)
{
        // BUGBUG: should check to see options are what we think they are
   EnterCriticalSection(&g_cs);
   _pBnd = p;
   _pBnd->AddRef();
   LeaveCriticalSection(&g_cs);
   return(NOERROR);
}


//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

STDMETHODIMP CDownloader::GetPriority(LONG *pnPriority)
{
   return(E_NOTIMPL);
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

STDMETHODIMP CDownloader::OnProgress(ULONG ulProgress, ULONG ulProgressMax, ULONG ulStatusCode, LPCWSTR pwzStatusText)
{
   IndicateWinsockActivity();
   return NOERROR;
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

STDMETHODIMP CDownloader::OnDataAvailable(DWORD grfBSCF, DWORD dwSize, FORMATETC *pFmtetc, STGMEDIUM *pstgmed)
{
   // bring in major changes here
   HRESULT hr = NOERROR;

   DWORD dwRead = 0;
   DWORD dwReadThisCall = 0;
   DWORD dwWritten = 0;
   
   if(!_pStm)
   {
      _pStm = pstgmed->pstm;
      _pStm->AddRef();
   }
 
   
   // should ignore WAIT_TIMEOUT while getting bytes from urlmon
   _fTimeoutValid = FALSE;

   do
   {
      hr = _pStm->Read(g_szBuffer, BUFFERSIZE, &dwRead);
      if( SUCCEEDED(hr) || ( (hr == E_PENDING) && (dwRead > 0) ) )
      {
         if(_hFile)
            if(WriteFile(_hFile, g_szBuffer, dwRead, &dwWritten, NULL)) 
            {
               _uBytesSoFar += dwRead;
               dwReadThisCall += dwRead;
               if(_pCb)
                  _pCb->OnProgress(_uBytesSoFar >> 10, NULL);
            }
            else
            {
               hr = E_FAIL;
               Abort();
            }
      }     
   }  while (hr == NOERROR);
   // SetInstallBytes 
   SetBytes(dwReadThisCall, TRUE);

   _uTickCount = 0;
   _fTimeoutValid = TRUE;            // should increment dwTickCount if WAIT_TIMEOUT occurs now
           
	return NOERROR;
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//


STDMETHODIMP CDownloader::OnObjectAvailable(REFIID riid, IUnknown *punk)
{
   return(E_NOTIMPL);
}


//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

STDMETHODIMP CDownloader::OnLowResource(DWORD reserved)
{
   // BUGBUG: really should have this kind of harsh policy on this ...
   _pBnd->Abort();
   return(S_OK);
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

STDMETHODIMP CDownloader::OnStopBinding(HRESULT hrError, LPCWSTR szError)
{
   _fTimeoutValid = FALSE;
   StopClock(); 
  
   if((hrError == E_ABORT) && _fTimeout)
   {
      // This is the timeout case
      _hDLResult = INET_E_CONNECTION_TIMEOUT;
   }
   else
   {
      // this is all other cases
      _hDLResult = hrError;
   }
  
   SetEvent(_hDL);
   return(NOERROR);
}

/* IAuthenticate::Authenticate
*/

STDMETHODIMP CDownloader::Authenticate(HWND *phwnd,
                          LPWSTR *pszUserName, LPWSTR *pszPassword)
{
    if (!phwnd || !pszUserName || !pszPassword)
        return E_POINTER;

    *pszUserName = NULL;
    *pszPassword = NULL;

    // BUGBUG: Need to have our own window! NULL does not work!
    // *phwnd = NULL;
    *phwnd = GetDesktopWindow() ;

    return S_OK;
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

HRESULT GetAMoniker( LPOLESTR url, IMoniker ** ppmkr )
{
   // FUTURE: This really should be a call to MkParseDisplayNameEx!!!
   HRESULT hr = CreateURLMoniker(0,url,ppmkr);
   // hr = ::MkParseDisplayNameEx(0, url, 0, ppmkr);
   return( hr );
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

HRESULT CDownloader::SetupDownload(LPCSTR pszUrl, IMyDownloadCallback *pcb, DWORD dwFlags, LPCSTR pszFilenameToUse)
{
   LPOLESTR pwszUrl;
   LPSTR pszFilename;

   if(!pszUrl) return E_INVALIDARG;

   lstrcpyn(_szURL, pszUrl, INTERNET_MAX_URL_LENGTH);
   
   pwszUrl = OLESTRFROMANSI(pszUrl);
   if(!pwszUrl) return E_OUTOFMEMORY;

   IMoniker *ptmpmkr;
   
   HRESULT hr = GetAMoniker( pwszUrl, &ptmpmkr );

   IBindCtx * pBindCtx = 0;

   if( SUCCEEDED(hr) )
   {
      if(SUCCEEDED(::CreateBindCtx(0,&pBindCtx)))
         hr = ::RegisterBindStatusCallback(pBindCtx, (IBindStatusCallback *) this, 0, 0) ;
   }

     
   if( SUCCEEDED(hr) )
   {
      AddRef();
   
      // setup path for download
      if(FAILED( CreateTempDirOnMaxDrive(_szDest, sizeof(_szDest))))
         goto GetOut;
      if(pszFilenameToUse)
      {
         SafeAddPath(_szDest, pszFilenameToUse, sizeof(_szDest));
      }
      else
      {
         pszFilename = ParseURLA(pszUrl);
         SafeAddPath(_szDest, pszFilename, sizeof(_szDest));
      }
   
      _pMkr = ptmpmkr;
      _pCb = pcb;
      _uFlags = dwFlags;
      _pBndContext = pBindCtx;
      _fTimeout = FALSE;
      _fTimeoutValid = TRUE;
      _uBytesSoFar = 0;
      _uTickCount = 0;
      _pStm = 0;
   }

GetOut:
   if(pwszUrl)
      CoTaskMemFree(pwszUrl);
   return hr;
}

HRESULT CDownloader::DoDownload(LPSTR pszPath, DWORD dwBufSize)
{
   HRESULT hr = NOERROR;
   BOOL fQuit = FALSE;
   DWORD dwRet;
   
   if(!_pMkr)
      return E_UNEXPECTED;
   
   pszPath[0] = 0;
   
   StartClock(); 

   // Create the file
   _hFile = CreateFile(_szDest, GENERIC_READ | GENERIC_WRITE, 0, NULL, 
                 CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);  
   
   if(_hFile == INVALID_HANDLE_VALUE)
      hr = E_FAIL;
    
         
   if( SUCCEEDED(hr) )
      hr = _pMkr->BindToStorage( _pBndContext, 0, IID_IStream, (void**)&_pStm );

   // we need this here because it synchronus *FAIL* case, 
   // we Set the event in onstopbinding, but we skip the loop below so it
   // never gets reset.
   // If BindToStorage fails without even sending onstopbinding, we are resetting
   // an unsignalled event, which is OK.
   if(FAILED(hr))
      ResetEvent(_hDL);

   _pBndContext->Release();
   _pBndContext = 0;

   // here we wait for Bind to complete
   //Wait for download event or abort
   while(SUCCEEDED(hr) && !fQuit)
   {
      dwRet = MsgWaitForMultipleObjects(1, &_hDL, FALSE, 1000, QS_ALLINPUT);
      if(dwRet == WAIT_OBJECT_0)
      {
         // Download is finished
         hr = _hDLResult;
         ResetEvent(_hDL);
         break;
      }      
      else if(dwRet == WAIT_TIMEOUT)  // our wait has expired
      {
         if(_fTimeoutValid)
            _uTickCount++;

          // if our tick count is past threshold, abort the download
          // BUGBUG: What about synch. case? We can't time out
          if(_uTickCount >= TIMEOUT_PERIOD)
          {
             _fTimeout = TRUE;
             Abort();
          }
      }  
      else
      {
         MSG msg;
         // read all of the messages in this next loop 
         // removing each message as we read it 
         while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
         { 
             // if it's a quit message we're out of here 
            if (msg.message == WM_QUIT)
               fQuit = TRUE; 
            else
            {
               // otherwise dispatch it 
              DispatchMessage(&msg); 
            } // end of PeekMessage while loop 
         }
      }
   }
   
   // clean up all our stuff
   if(_hFile != INVALID_HANDLE_VALUE)
      CloseHandle(_hFile);
   _hFile = INVALID_HANDLE_VALUE;

   // if we are not using cache and download succeeded, delete from cache
   if(SUCCEEDED(hr) && !(_uFlags & DOWNLOADFLAGS_USEWRITECACHE))
      DeleteUrlCacheEntry(_szURL);


   if(FAILED(hr))
   {
      GetParentDir(_szDest);
      DelNode(_szDest,0);
   }

   EnterCriticalSection(&g_cs);
   if(_pBnd)
   {
      _pBnd->Release();
      _pBnd = 0;
   }
   LeaveCriticalSection(&g_cs);

   _pCb = 0;
   
   if(_pStm)
   {
      _pStm->Release();
      _pStm = 0;
   }

   if(SUCCEEDED(hr))
      lstrcpyn(pszPath, _szDest, dwBufSize);

   _szDest[0] = 0;
   _szURL[0] = 0;
   Release();
   return hr;
}

HRESULT CDownloader::Suspend()
{

   // in theory, we could call _pBnd->Suspend here

   return NOERROR;
}

HRESULT CDownloader::Resume()
{

   // in theory, we could call _pBnd->Resume here

   return NOERROR;
}


HRESULT CDownloader::Abort()
{
   EnterCriticalSection(&g_cs);
   if(_pBnd) 
   {
      _pBnd->Abort();
   }
   LeaveCriticalSection(&g_cs);

   return NOERROR;
}


//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//
/*
HRESULT GetAMoniker( LPOLESTR url, IMoniker ** ppmkr )
{
   // FUTURE: This really should be a call to MkParseDisplayNameEx!!!
   HRESULT hr = CreateURLMoniker(0,url,ppmkr);
   // hr = ::MkParseDisplayNameEx(0, url, 0, ppmkr);
   return( hr );
}
*/

CPatchDownloader::CPatchDownloader(BOOL fEnable=FALSE) : CTimeTracker(0), _fEnable(fEnable)
{
}

CPatchDownloader::~CPatchDownloader()
{
    ;
}

HRESULT CPatchDownloader::SetupDownload(DWORD dwFullTotalSize, UINT uPatchCount, IMyDownloadCallback *pcb, LPCSTR pszDLDir)
{
    _dwFullTotalSize = dwFullTotalSize;
    _pCb             = pcb;
    _uNumDownloads   = uPatchCount;
    if (pszDLDir)
        lstrcpyn(_szPath, pszDLDir, sizeof(_szPath));
    else
        lstrcpy(_szPath, "");

    return S_OK;
}

HRESULT CPatchDownloader::DoDownload(LPCTSTR szFile)
{
    HINF hInf = NULL;
    HRESULT hr = S_OK;

    // We shouldn't be called if patching isn't available.
    if (!IsEnabled())
        return E_FAIL;

    // TODO: Advpext currently behaves as a synchronous call, so
    //       right now we can't do timeouts and progress bar ticks.
    StartClock(); 
   
    if(!IsNT())
    {
        DWORD fWin9x = 1;
        HKEY hKey;
        
        if(RegOpenKeyEx(HKEY_LOCAL_MACHINE, PATCHWIN9xKEY,
                            0, KEY_READ | KEY_WRITE, &hKey) == ERROR_SUCCESS)
        {
            RegSetValueEx(hKey, "Usewin9xDirectory", 0, REG_DWORD, 
                            (LPBYTE)&fWin9x, sizeof(DWORD));
            RegCloseKey(hKey);
        }
    }



    if (SUCCEEDED(hr = OpenINFEngine(szFile, NULL, 0, &hInf, NULL)))
    {
        hr = g_pfnProcessFileSection(hInf, NULL, TRUE, "DefaultInstall", _szPath, CPatchDownloader::Callback, (LPVOID) this);
        CloseINFEngine(hInf);
    }

    _pCb = NULL;

    return hr;
}


BOOL CPatchDownloader::Callback(PATCH_DOWNLOAD_REASON Reason, PVOID lpvInfo, PVOID pvContext)
{
    if (!pvContext)
    {
        return FALSE;
    }

    CPatchDownloader *pPatchInst = (CPatchDownloader *) pvContext;

    switch (Reason) 
    {
        case PATCH_DOWNLOAD_ENDDOWNLOADINGDATA:
            break;

        case PATCH_DOWNLOAD_CONNECTING:   
        case PATCH_DOWNLOAD_FINDINGSITE:
        case PATCH_DOWNLOAD_DOWNLOADINGDATA:
            // Not interesting here...
            break;

        case PATCH_DOWNLOAD_PROGRESS:
            {
                PDOWNLOAD_INFO ProgressInfo = (PDOWNLOAD_INFO)lpvInfo;
                DWORD dwBytesDownloaded = ProgressInfo->dwBytesToDownload - ProgressInfo->dwBytesRemaining;

                // Convert to KB
                dwBytesDownloaded = dwBytesDownloaded >> 10;

                // Adjust because the progress needs to be reflected as if
                // it was a full download.
                dwBytesDownloaded *= pPatchInst->GetFullDownloadSize();
                if (ProgressInfo->dwBytesToDownload != 0)
                    dwBytesDownloaded /= ProgressInfo->dwBytesToDownload >> 10;
                
                // BUGBUG:  We have to handle more than 1 patching INF.
                //          This hack divides up the progress across
                //          multiple downloads.
                if (pPatchInst->GetDownloadCount() > 0)
                    dwBytesDownloaded /= pPatchInst->GetDownloadCount();

                pPatchInst->GetCallback()->OnProgress(dwBytesDownloaded, NULL);

                break;
            }


        case PATCH_DOWNLOAD_FILE_COMPLETED:     // AdditionalInfo is Source file downloaded
            {
                TCHAR szDstFile[MAX_PATH+1];

                lstrcpyn(szDstFile, pPatchInst->GetPath(), MAX_PATH);
                SafeAddPath(szDstFile, ParseURLA((LPCTSTR) lpvInfo), sizeof(szDstFile));

                // advpext cleans up for us when it's finished downloading all the files.
                CopyFile((LPCTSTR)lpvInfo, szDstFile, FALSE);
            }

            break;
        case PATCH_DOWNLOAD_FILE_FAILED:
            // advpext automatically retries failures 3 times
            return PATCH_DOWNLOAD_FLAG_RETRY;
        default:
            break;
        }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\inseng\enum.h ===
#define PARENTTYPE_CIF      0
#define PARENTTYPE_GROUP    1
#define PARENTTYPE_MODE     2

// 0 = CCifCile, 1 = CCifGroup, 2 = CCifMode


class CCifEntryEnum
{
   public:
      CCifEntryEnum(UINT dwFilter, UINT dwParentType, LPSTR pszParentID);
      ~CCifEntryEnum();

   protected:
      UINT    _cRef;
      UINT    _uIndex;
      char    _szParentID[MAX_ID_LENGTH];
      UINT    _uFilter;
      UINT    _uParentType;   // 0 = CCifCile, 1 = CCifGroup, 2 = CCifMode

};

class CCifComponentEnum : public CCifEntryEnum, public IEnumCifComponents
{
   public:
      CCifComponentEnum(CCifComponent **pp, UINT dwFilter, UINT dwParentType, LPSTR pszParentID);
      ~CCifComponentEnum();


      // *** IUnknown methods ***
      STDMETHOD(QueryInterface) (REFIID riid, LPVOID * ppvObj);
      STDMETHOD_(ULONG,AddRef) ();
      STDMETHOD_(ULONG,Release) ();

      // enum methods
      STDMETHOD(Next)(ICifComponent **);
      STDMETHOD(Reset)();
   private:
       CCifComponent **_rpComp;
};

class CCifGroupEnum : public CCifEntryEnum, public IEnumCifGroups
{
public:
      CCifGroupEnum(CCifGroup **pp, UINT dwFilter);
      ~CCifGroupEnum();


      // *** IUnknown methods ***
      STDMETHOD(QueryInterface) (REFIID riid, LPVOID * ppvObj);
      STDMETHOD_(ULONG,AddRef) ();
      STDMETHOD_(ULONG,Release) ();

      // enum methods
      STDMETHOD(Next)(ICifGroup **);
      STDMETHOD(Reset)();
   private:
       CCifGroup **_rpGroup;
};

class CCifModeEnum : public CCifEntryEnum, public IEnumCifModes
{
   public:
      CCifModeEnum(CCifMode **pp, UINT dwFilter);
      ~CCifModeEnum();


      // *** IUnknown methods ***
      STDMETHOD(QueryInterface) (REFIID riid, LPVOID * ppvObj);
      STDMETHOD_(ULONG,AddRef) ();
      STDMETHOD_(ULONG,Release) ();

      // enum methods
      STDMETHOD(Next)(ICifMode **);
      STDMETHOD(Reset)();
   private:
       CCifMode **_rpMode;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\inseng\enum.cpp ===
#include "inspch.h"
#include "util2.h"
#include "inseng.h"
#include "ciffile.h"

CCifEntryEnum::CCifEntryEnum(UINT dwFilter, UINT dwParentType, LPSTR pszParentID)
{
   _cRef = 0;
   _uIndex = 0;
   _uFilter = dwFilter;
   if(_uFilter == 0)
      _uFilter = PLATFORM_ALL;
   _uParentType = dwParentType;
   if(_uParentType != PARENTTYPE_CIF)
      lstrcpyn(_szParentID, pszParentID, MAX_ID_LENGTH);
}

CCifEntryEnum::~CCifEntryEnum()
{
}

CCifComponentEnum::CCifComponentEnum(CCifComponent **rpcomp, UINT dwFilter, UINT dwParentType, LPSTR pszParentID)
                         :  CCifEntryEnum(dwFilter, dwParentType, pszParentID)
{
   _rpComp = rpcomp;
}

CCifComponentEnum::~CCifComponentEnum()
{
}



//************ IUnknown implementation ***************


STDMETHODIMP_(ULONG) CCifComponentEnum::AddRef()                      
{
   return(_cRef++);
}


STDMETHODIMP_(ULONG) CCifComponentEnum::Release()
{
   ULONG temp = --_cRef;

   if(temp == 0)
      delete this;
   return temp;
}


STDMETHODIMP CCifComponentEnum::QueryInterface(REFIID riid, void **ppv)
{
   *ppv = NULL;

   if(riid == IID_IUnknown)
      *ppv = (IEnumCifComponents *)this;
   
   if(*ppv == NULL)
      return E_NOINTERFACE;
   
   AddRef();
   return NOERROR;
}

STDMETHODIMP CCifComponentEnum::Next(ICifComponent **pp)
{
   *pp = NULL;
   HRESULT hr = E_FAIL;
   CCifComponent *pcomp;

   for(pcomp = _rpComp[_uIndex]; pcomp != 0; pcomp = _rpComp[++_uIndex]) 
   {
      // check filters
      if(_rpComp[_uIndex]->GetPlatform() & _uFilter)
      {
         char szID[MAX_ID_LENGTH];
         BOOL bParentOK = FALSE;

         // platform is ok
         if(_uParentType == PARENTTYPE_GROUP)
         {
            pcomp->GetGroup(szID, sizeof(szID));
            if(lstrcmpi(_szParentID, szID) == 0)
               bParentOK = TRUE;
         }
         else if(_uParentType == PARENTTYPE_MODE)
         {
            // look though the modes for one that matches
            for(int i = 0; SUCCEEDED(pcomp->GetMode(i, szID, sizeof(szID))); i++)
            {
               if(lstrcmpi(szID, _szParentID) == 0)
                  bParentOK = TRUE;
            }
         }
         else
            bParentOK = TRUE;

         if(bParentOK)
         {
            hr = NOERROR;
            *pp = (ICifComponent *) pcomp;
            _uIndex++;   // increment _uIndex so next call to Next keeps moving
            break;
         }
      }
   }
   return hr;
}

STDMETHODIMP CCifComponentEnum::Reset()
{
   _uIndex = 0;
   return NOERROR;
}




//***************** CCifGroupEnum *****************************

CCifGroupEnum::CCifGroupEnum(CCifGroup **rpgrp, UINT dwFilter)
                         :  CCifEntryEnum(dwFilter, PARENTTYPE_CIF, NULL)
{
   _rpGroup = rpgrp;
}

CCifGroupEnum::~CCifGroupEnum()
{
}



//************ IUnknown implementation ***************


STDMETHODIMP_(ULONG) CCifGroupEnum::AddRef()                      
{
   return(_cRef++);
}


STDMETHODIMP_(ULONG) CCifGroupEnum::Release()
{
   ULONG temp = --_cRef;

   if(temp == 0)
      delete this;
   return temp;
}


STDMETHODIMP CCifGroupEnum::QueryInterface(REFIID riid, void **ppv)
{
   *ppv = NULL;

   if(riid == IID_IUnknown)
      *ppv = (IEnumCifGroups *)this;
   
   if(*ppv == NULL)
      return E_NOINTERFACE;
   
   AddRef();
   return NOERROR;
}

STDMETHODIMP CCifGroupEnum::Next(ICifGroup **pp)
{
   HRESULT hr = E_FAIL;
   CCifGroup *pgrp;

   *pp = NULL;

   for(pgrp = _rpGroup[_uIndex]; pgrp != 0; pgrp = _rpGroup[++_uIndex]) 
   {
      hr = NOERROR;
      *pp = (ICifGroup *) pgrp;
      _uIndex++;   // increment _uIndex so next call to Next keeps moving
      break;
   }
   return hr;
}

STDMETHODIMP CCifGroupEnum::Reset()
{
   _uIndex = 0;
   return NOERROR;
}


//***************** CCifModeEnum *****************************

CCifModeEnum::CCifModeEnum(CCifMode **rpmode, UINT dwFilter)
                         :  CCifEntryEnum(dwFilter, PARENTTYPE_CIF, NULL)
{
   _rpMode = rpmode;
}

CCifModeEnum::~CCifModeEnum()
{
}



//************ IUnknown implementation ***************


STDMETHODIMP_(ULONG) CCifModeEnum::AddRef()                      
{
   return(_cRef++);
}


STDMETHODIMP_(ULONG) CCifModeEnum::Release()
{
   ULONG temp = --_cRef;

   if(temp == 0)
      delete this;
   return temp;
}


STDMETHODIMP CCifModeEnum::QueryInterface(REFIID riid, void **ppv)
{
   *ppv = NULL;

   if(riid == IID_IUnknown)
      *ppv = (IEnumCifModes *)this;
   
   if(*ppv == NULL)
      return E_NOINTERFACE;
   
   AddRef();
   return NOERROR;
}

STDMETHODIMP CCifModeEnum::Next(ICifMode **pp)
{
   HRESULT hr = E_FAIL;
   CCifMode *pmode;

   *pp = NULL;

   for(pmode = _rpMode[_uIndex]; pmode != 0; pmode = _rpMode[++_uIndex]) 
   {
      hr = NOERROR;
      *pp = (ICifMode *) pmode;
      _uIndex++;   // increment _uIndex so next call to Next keeps moving
      break;
   }
   return hr;
}

STDMETHODIMP CCifModeEnum::Reset()
{
   _uIndex = 0;
   return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\inseng\iguids.cpp ===
//=--------------------------------------------------------------------------=
// iguids.cpp
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// contains the guids we will define 
//


#include "inspch.h"

#define INITGUID
#include <initguid.h>
#include "inseng.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\inseng\extract.cpp ===
#include "inspch.h"
#include "debug.h"
#include "extract.h"

// for ASSERT and FAIL
//
SZTHISFILE

//
//
//  THIS FILE IS NOT USED ANYMORE -- EXTRACT FUNCGIONALITY IS NOW IN ADVPACK
//  AND IT TALKS TO CABINET.DLL/URLMON.DLL AS APPROPRIATE. THIS WILL BE
//  DELFILE-D
//
//
typedef HRESULT (WINAPI *EXTRACT) (PSESSION psess, LPCSTR lpCabName);

VOID FreeFileList(PSESSION psess);
VOID FreeFileNode(PFNAME pfname);
BOOL IsFileInList(LPSTR pszFile, LPSTR pszFileList);
int PrepareFileList(LPSTR pszOutFileList, LPCSTR pszInFileList);


//=--------------------------------------------------------------------------=
// ExtractFiles
//=--------------------------------------------------------------------------=
//
// Parameters:
//    LPCSTR	pszCabName	- [in]  full qualified filename to the .CAB file
//    LPCSTR	pszExpandDir- [in]  full qualified path to where to extract the file(s)
//    DWORD     dwFlags		- [in]  Flags, currently not used
//    LPCSTR    pszFileList - [in]  colon separated list of files to extract from pszCabName
//                                  or NULL for all files
//    LPVOID    lpReserved  - [in]  currently not used
//    DWORD		dwReserved	- [in]  currently not used
//
// Return HRESULT:
//      E_INVALIDARG    - if pszCabName or pszExpandDir == NULL
//      E_OUTOFMEMORY   - if we could not allocate our memory
//      E_FAIL          - if no files in pszFileList and pszFileList!=NULL
//                        if not all files from pszFileList are in the .CAB file
//                        if Extract return S_FALSE
//      any E_ code Extract returns
//
// Note: This function would not extract any file from the pszFileList, if not all
//       of them are in the .CAB file. If one or more are not in the .CAB file
//       the function does not extract any and returns E_FAIL
//
HRESULT ExtractFiles(LPCSTR pszCabName, LPCSTR pszExpandDir, DWORD dwFlags,
                     LPCSTR pszFileList, LPVOID lpReserved, DWORD dwReserved)
{
    HINSTANCE hinst;
    PSESSION  psess = NULL;
    PFNAME    pf = NULL;
    PFNAME    pfPriv = NULL;
    HRESULT   hr = E_FAIL;          // Return error
    LPSTR     pszMyFileList = NULL;
    EXTRACT   fpExtract = NULL;
    int       iFiles = 0;                // number of files in list

    // Do checking for valid values??
    if ((!pszCabName) || (!pszExpandDir))
        return E_INVALIDARG;

    hinst = LoadLibrary("URLMON.DLL");
    if (hinst)
    {
        fpExtract = (EXTRACT)GetProcAddress(hinst, "Extract");
        if (fpExtract)
        {
            psess = (PSESSION)LocalAlloc(LPTR, sizeof(SESSION));
            if (psess) 
            {
                lstrcpy(psess->achLocation, pszExpandDir);
                // Initialize the structure
                if (pszFileList == NULL)
                {
                    // Extract all
                    psess->flags = SESSION_FLAG_EXTRACT_ALL|SESSION_FLAG_ENUMERATE;
                    hr = fpExtract(psess, pszCabName);
                    // BUGBUG: What if psess->erf reports an error??
                }
                else
                {
                    // I append a '/0' therefor +2
                    pszMyFileList = (LPSTR)LocalAlloc(LPTR, lstrlen(pszFileList)+2);
                    if (pszMyFileList)
                    {
                        iFiles = PrepareFileList(pszMyFileList, pszFileList);
                        psess->flags = SESSION_FLAG_ENUMERATE;

                        if  ((iFiles > 0) &&
                             ( !FAILED(hr = fpExtract(psess, pszCabName)) ))
                            // What if psess->erf reports an error??
                        {
                        // If there are files in the list and we enumarated files
                        
                            // Got the list of files in the cab
                            pfPriv = NULL;
                            pf = psess->pFileList;
                            while (pf != NULL )
                            {
                                if (!IsFileInList(pf->pszFilename, pszMyFileList))
                                {
                                    // Delete the node from the list
                                    if (pfPriv == NULL)
                                    {
                                        // Delete the head
                                        psess->pFileList = pf->pNextName;
                                        FreeFileNode(pf);
                                        pf = psess->pFileList;
                                    }
                                    else
                                    {
                                        pfPriv->pNextName = pf->pNextName;
                                        FreeFileNode(pf);
                                        pf = pfPriv->pNextName;
                                    }
                                }
                                else
                                {
                                    // Just go to the next one
                                    pfPriv = pf;
                                    pf = pf->pNextName;
                                    iFiles--;
                                }
                            }

                            if ((psess->pFileList) && (iFiles == 0))
                            {
                                // Reset the error flag
                                psess->erf.fError = FALSE;
                                psess->erf.erfOper = 0;

                                psess->pFilesToExtract = psess->pFileList;
                                psess->flags &= ~SESSION_FLAG_ENUMERATE; // already enumerated
                                hr = fpExtract(psess, pszCabName);
                                // BUGBUG: What if psess->erf reports an error??
                            }
                            else
                                hr = E_FAIL;    // File(s) is not in cab.
                        }

                        LocalFree(pszMyFileList);
                        pszMyFileList = NULL;

                    }
                    else
                        hr = E_OUTOFMEMORY;
                }
                FreeFileList(psess);
                LocalFree(psess);
                psess = NULL;
            }
            else
                hr = E_OUTOFMEMORY;

        }
        FreeLibrary(hinst);
    }

    // Extract may only return S_FALSE in a failure case.
    if (!FAILED(hr) && (hr == S_FALSE))
        hr = E_FAIL;
    return (hr);
}


VOID FreeFileList(PSESSION psess)
{
    PFNAME      rover = psess->pFileList;
    PFNAME      roverprev;

    while (rover != NULL)  
    {

        roverprev = rover;  // save for free'ing current rover below
        rover = rover->pNextName;

        FreeFileNode(roverprev);
    }

    psess->pFileList = NULL; // prevent use after deletion!
}

VOID FreeFileNode(PFNAME pfname)
{
    CoTaskMemFree(pfname->pszFilename);
    CoTaskMemFree(pfname);
}


BOOL IsFileInList(LPSTR pszFile, LPSTR pszFileList)
{
    char *p;
    int  iLenFile = lstrlen(pszFile);
    BOOL bFound = FALSE;

    p = pszFileList;
    while ((*p != '\0') && (!bFound))
    {
        if (lstrlen(p) == iLenFile)
            bFound = (lstrcmpi(p, pszFile) == 0);
        if (!bFound)
            p += lstrlen(p) + 1;
    }
    return (bFound);
}

int PrepareFileList(LPSTR pszOutFileList, LPCSTR pszInFileList)
{
    int  iFiles = 0;                // number of files in list
    char *p;
    p = (LPSTR)pszInFileList;       // p is used to point into both arrays 

    // trim leading spaces, tabs or : 
    while ((*p == ' ') || (*p == '\t') || (*p == ':'))
        p++;
    lstrcpy(pszOutFileList, p);

    p = pszOutFileList;
    if (lstrlen(pszOutFileList) > 0)
    {
        // Only if we have atleast one character left.
        // This cannot be a space of tab, because we 
        // would have removed this above.
        p += (lstrlen(pszOutFileList) - 1);

        // trim railing spaces, tabs or :
        while ((*p == ' ') || (*p == '\t') || (*p == ':'))
            p--;

        // Put a '\0' for the last space/tab
        *(++p) = '\0';
    }

    if (*pszOutFileList)
    {
        iFiles++;
        // Now replace ':' with '\0'
        p = pszOutFileList;
        while (*p != '\0')
        {
            if (*p == ':')
            {
                *p = '\0';
                iFiles++;
            }
            p++;
        }
        // Make sure we have a double '\0' at the end.
        *(++p) = '\0';
    }
    return iFiles;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\inseng\extract.h ===
#ifndef _CDL_H_
#define _CDL_H_

// #define  USE_BINDHOST    1


// CDL.h
// Code Downloader header file
//
// Read "class descriptions" first for understanding how the
// code downloader works.

#ifdef __cplusplus
extern "C" {
#endif

/***    ERF - Error structure
 *
 *  This structure returns error information from FCI/FDI.  The caller should
 *  not modify this structure.
 */
typedef struct {
    int     erfOper;            // FCI/FDI error code -- see FDIERROR_XXX
                                //  and FCIERR_XXX equates for details.

    int     erfType;            // Optional error value filled in by FCI/FDI.
                                // For FCI, this is usually the C run-time
                                // *errno* value.

    BOOL    fError;             // TRUE => error present
} ERF;      /* erf */
typedef ERF FAR *PERF;  /* perf */


// buffer size for downloads in CBSC::m_cbuffer
#define BUFFERMAX 2048

// File Name List
//
// used as pFilesToExtract to track files in the CAB we need extracted
//
// or a pFileList in PSESSION
//
// We keep track of all files that are in a cabinet
// keeping their names in a list and when the download
// is complete we use this list to delete temp files

struct sFNAME {
    LPSTR               pszFilename;
    struct sFNAME       *pNextName;
    DWORD               status; /* out */
};

typedef struct sFNAME FNAME;
typedef FNAME *PFNAME;

// SFNAME.status: success is 0 or non-zero error code in extraction
#define SFNAME_INIT         1
#define SFNAME_EXTRACTED    0

// FILE extentions we know about
typedef enum {
    FILEXTN_NONE,
    FILEXTN_UNKNOWN,
    FILEXTN_CAB,
    FILEXTN_DLL,
    FILEXTN_OCX,
    FILEXTN_INF,
    FILEXTN_EXE,
} FILEXTN;


//
// Master State Information for File Extraction: used by extract.c
//

typedef struct {
    UINT        cbCabSize;
    ERF         erf;
    PFNAME      pFileList;              // List of Files in CAB
    UINT        cFiles;
    DWORD       flags;                  // flags: see below for list
    char        achLocation[MAX_PATH];  // Dest Dir
    char        achFile[MAX_PATH];      // Current File
    char        achCabPath[MAX_PATH];   // Current Path to cabs
    PFNAME      pFilesToExtract;        // files to extract;null=enumerate only

} SESSION, *PSESSION;

typedef enum {
    SESSION_FLAG_NONE           = 0x0,
    SESSION_FLAG_ENUMERATE      = 0x1,
    SESSION_FLAG_EXTRACT_ALL    = 0x2,
    SESSION_FLAG_EXTRACTED_ALL  = 0x4
} SESSION_FLAGS;



#ifdef __cplusplus
}
#endif
#endif // _CDL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\inseng\insdown.cpp ===
//=--------------------------------------------------------------------------=
// inseng.cpp
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
//
#include "inspch.h"
#include "regstr.h"
#include "globals.h"
#include "insobj.h"
#include "resource.h"
#include "diskspac.h"

#define GRPCONV  "grpconv -o"

#define BUFFERSIZE 4096



//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

CInstallEngine::CInstallEngine(IUnknown **punk)
{
   DWORD dwThreadID;
   HANDLE hThread;
   HKEY hKey = NULL;
   char szBuf[16];
   DWORD dwType;

   GetWindowsDirectory(g_szWindowsDir, sizeof(g_szWindowsDir));
   if(g_szWindowsDir[0] >= 'a' && g_szWindowsDir[0] <= 'z')
      g_szWindowsDir[0] -= 32;

   hThread = CreateThread(NULL, 0, CleanUpAllDirs, NULL, 0, &dwThreadID);
   CloseHandle(hThread);
   _chInsDrive = g_szWindowsDir[0];
   
   // Decide whether we are in stepping mode or not
   _uCommandMode = 0;
   _fSteppingMode = FALSE;
   _fResetTrust = TRUE;
   _fIgnoreTrust = FALSE;
   if(RegOpenKeyEx(HKEY_LOCAL_MACHINE, ACTIVESETUP_KEY,0, KEY_READ | KEY_WRITE, &hKey) == ERROR_SUCCESS)
   {
      // Get Steeping mode value. OK if not present
      DWORD dwSize = sizeof(szBuf);
      if(RegQueryValueEx(hKey, STEPPING_VALUE, NULL, &dwType, (LPBYTE) szBuf, &dwSize) == ERROR_SUCCESS)
      {
         if(szBuf[0] == 'y' || szBuf[0] == 'Y')
            _fSteppingMode = TRUE;
      }
 
      // Get CommandMode value. OK if not present
      dwSize = sizeof(szBuf);
      if(RegQueryValueEx(hKey, COMMAND_VALUE, NULL, &dwType, (LPBYTE) szBuf, &dwSize) == ERROR_SUCCESS)
      {
         _uCommandMode = AtoL(szBuf);
         // Once we read it, set it to zero
         // BUGBUG: beware of hardcoded "0" and 2 below (2 includes null terminator)
         RegSetValueEx(hKey, COMMAND_VALUE, 0, REG_SZ, (BYTE *) "0", 2 ); 
      }

      if(RegQueryValueEx(hKey, CHECKTRUST_VALUE, NULL, &dwType, (LPBYTE) szBuf, &dwSize) == ERROR_SUCCESS)
      {
         if(szBuf[0] == 'Y' || szBuf[0] == 'y')
         {
            _fIgnoreTrust = TRUE;
            _fResetTrust = FALSE;
         }
         // Once we read it, set it to zero
         // BUGBUG: beware of hardcoded "0" and 2 below (2 includes null terminator)
         RegDeleteValue(hKey, CHECKTRUST_VALUE); 
      }
 
 
      RegCloseKey(hKey);
   }
    
   _hwndForUI = NULL;
   _pStmLog = NULL;
   _fIgnoreDownloadError = FALSE;
   _enginestatus = ENGINESTATUS_NOTREADY;
   _dwStatus = 0;
   _pcb = NULL;
   _cRef = 0;
   _dwDLRemaining = 0;
   _dwInstallRemaining = 0;
   _dwInstallOld = 0;
   _dwDLOld = 0;
   _fUseCache = FALSE;
   _dwInstallOptions = INSTALLOPTIONS_DOWNLOAD | INSTALLOPTIONS_INSTALL;
   _hContinue = NULL;
   _hAbort = NULL;
   _fCleanUpDir = FALSE;
   //init CCifFile
   _pCif = new CCifFile();
   _pCif->AddRef();
   _pCif->SetInstallEngine(this);
   // init downloader
   _pDL = new CDownloader();
   _pIns = new CInstaller(this);

   _szBaseUrl[0] = 0;

   _fSRLiteAvailable = IsPatchableIEVersion() && IsCorrectAdvpExt() && InitSRLiteLibs();
   if (!_fSRLiteAvailable)
       WriteToLog("Install engine failed to initialize the advpack extension DLL\r\n", FALSE);
   
   _pPDL = new CPatchDownloader(_fSRLiteAvailable);

   AddRef();
   *punk = (IInstallEngine *) this;
}

//=--------------------------------------------------------------------------=
// CInstallEngine::~CInstallEngine
//=--------------------------------------------------------------------------=
// Destructor for InstallEngine class
//
// Parameters:
//   
// Returns:
//
// Notes:
//

CInstallEngine::~CInstallEngine()
{
   char szBuf[MAX_PATH];

   WriteToLog("Install Engine - object destroyed\r\n", TRUE);
   
   if(_fCleanUpDir)
   {
      lstrcpy(szBuf, _pCif->GetDownloadDir());
   }

   if(_hAbort)
      CloseHandle(_hAbort);
   
   if(_hContinue)
      CloseHandle(_hContinue);
      
   if(_pStmLog)
      _pStmLog->Release();

   _pcb = NULL;
                               
   _pCif->Release();

   _pDL->Release();

   delete _pPDL;

   _pIns->Release();

   if(_fCleanUpDir)
   {
      CleanUpTempDir(szBuf);
   }

   FreeSRLiteLibs();

   DllRelease();
}

//************ IUnknown implementation ***************

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

STDMETHODIMP_(ULONG) CInstallEngine::AddRef()                      
{
   return(_cRef++);
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

STDMETHODIMP_(ULONG) CInstallEngine::Release()
{
   ULONG temp = --_cRef;

   if(temp == 0)
      delete this;
   return temp;
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngine::QueryInterface(REFIID riid, void **ppv)
{
   *ppv = NULL;

   if((riid == IID_IUnknown) || (riid == IID_IInstallEngine))
      *ppv = (IInstallEngine *)this;
   else if(riid == IID_IInstallEngineTiming)
      *ppv = (IInstallEngineTiming *)this;
   else if(riid == IID_IInstallEngine2)
      *ppv = (IInstallEngine2 *)this;

   
   if(*ppv == NULL)
      return E_NOINTERFACE;
   
   AddRef();
   return NOERROR;
}

//************* IInstallEngine interface ************

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngine::SetLocalCif(LPCSTR pszCifPath)
{
   HCURSOR hNew = NULL;
   HCURSOR hOld = NULL;
   
   OnEngineStatusChange(ENGINESTATUS_LOADING, 0);
   
   hNew = LoadCursor(NULL, IDC_WAIT);
   hOld = SetCursor(hNew);
   
   HRESULT hr = _pCif->SetCifFile(pszCifPath, FALSE);
   if(SUCCEEDED(hr))
      OnEngineStatusChange(ENGINESTATUS_READY, 0);
   else 
      OnEngineStatusChange(ENGINESTATUS_NOTREADY, hr);
   
   SetCursor(hOld);
   
   return hr;
}

STDMETHODIMP CInstallEngine::GetICifFile(ICifFile **pic)
{
   *pic = (ICifFile *) _pCif;
   (*pic)->AddRef();
   return NOERROR;
}

STDMETHODIMP CInstallEngine::GetEngineStatus(DWORD * theenginestatus)
{
  *theenginestatus = _enginestatus;
   return(NOERROR);
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngine::Abort(DWORD lFlag)
{
   // If we are NOT downLOADING or INSTALLING, an abort command makes no sense.
   if( !(_enginestatus == ENGINESTATUS_INSTALLING || _enginestatus == ENGINESTATUS_LOADING) )
      return E_UNEXPECTED;

   // if we are downloading, this will cause the abort to filter thru
   _pDL->Abort();

   // this will abort an install if possible
   _pIns->Abort();
   
   // any other time, we will pick this up just as soon as we can
   SetEvent(_hAbort);

   WriteToLog("Install Engine - Abort called\r\n", FALSE);
   
   return(NOERROR);
}


//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngine::Suspend()
{
   HRESULT hr;

   if(_enginestatus != ENGINESTATUS_INSTALLING)
      return E_UNEXPECTED;

   WriteToLog("Install Engine - Suspend called\r\n", FALSE);
   
 
   _pDL->Suspend();

   // we only catch suspend return, because it tells us "zsafe to cancel or not"
   hr = _pIns->Suspend();
   
   ResetEvent(_hContinue);
 
   // If we cant create the resume event, we will fail this call and not pause
        
   return hr;
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngine::Resume()
{
   if(_enginestatus != ENGINESTATUS_INSTALLING)
      return E_UNEXPECTED;

   WriteToLog("Install Engine - Resume called\r\n", FALSE);
   
   _pDL->Resume();

   _pIns->Resume();

   SetEvent(_hContinue);
   
   return NOERROR;
}
//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngine::SetCifFile(LPCSTR pszCabName, LPCSTR pszCifName)
{
   HRESULT hr = NOERROR;
   HANDLE hThread;
   DWORD dwThreadID;

   if(_enginestatus == ENGINESTATUS_LOADING || _enginestatus == ENGINESTATUS_INSTALLING)
      return E_UNEXPECTED;

   SETCIFARGS *p = new SETCIFARGS;

   if (p == NULL)
   {
       hr = E_OUTOFMEMORY;
       goto Cleanup;
   }

   if(_szBaseUrl[0] != 0)
   {
      if (lstrlen(_szBaseUrl) + lstrlen(pszCabName) + 2 > INTERNET_MAX_URL_LENGTH)
      {
          hr = E_INVALIDARG;
          goto Cleanup;
      }

      p->szUrl[0] = '\0';
      lstrcpy(p->szUrl, _szBaseUrl);
      lstrcat(p->szUrl, "/");
      lstrcat(p->szUrl, pszCabName);
   }
   else
   {
      lstrcpy(p->szUrl, "file://");
      lstrcat(p->szUrl, _pCif->GetDownloadDir());
      SafeAddPath(p->szUrl, pszCabName, sizeof(p->szUrl));
   }

   lstrcpyn(p->szCif, pszCifName, MAX_PATH);

   p->pCif = _pCif;
    
   // do the actual downloading of the CIF file in a separate thread
   if ((hThread = CreateThread(NULL, 0, DownloadCifFile, (LPVOID) p, 0, &dwThreadID)) != NULL)
      CloseHandle(hThread);
   else
   {
      hr = HRESULT_FROM_WIN32(GetLastError());
   }
   
Cleanup:

   if (FAILED(hr) && p != NULL)
       delete p;

   return hr;
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngine::SetBaseUrl(LPCSTR pszBaseName)
{
   DWORD dwLen;

   if(_enginestatus == ENGINESTATUS_INSTALLING)
      if(!_IsValidBaseUrl(pszBaseName))
         return E_UNEXPECTED;
   
   lstrcpyn(_szBaseUrl, pszBaseName, INTERNET_MAX_URL_LENGTH);

   wsprintf(szLogBuf,"Install Engine - base url set to %s\r\n", pszBaseName);
   WriteToLog(szLogBuf, FALSE);

   return NOERROR;
}


//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngine::SetDownloadDir(LPCSTR pszDLDir)
{
   char szBuf[MAX_PATH];
   DWORD dwLen;
   DWORD dwVer;
   
   if(_enginestatus == ENGINESTATUS_INSTALLING)
      return E_UNEXPECTED;
   
   if(pszDLDir != NULL && lstrlen(pszDLDir) > (MAX_PATH - 20))
      return E_FAIL;

   // clean up what we have
   if(_fCleanUpDir)
   {
      DelNode(_pCif->GetDownloadDir(), 0);
      _fCleanUpDir = FALSE;
   }

   if(pszDLDir == NULL)
   {
      _fCleanUpDir = TRUE;
      if(FAILED(CreateTempDirOnMaxDrive(szBuf, sizeof(szBuf))))
         return E_FAIL;
   }
   else
   {
      _fCleanUpDir = FALSE;
      // Make sure the directory exists
      if(GetFileAttributes(pszDLDir) == 0xffffffff)
         CreateDirectory(pszDLDir, NULL);
   }

   _pCif->SetDownloadDir(pszDLDir ? pszDLDir : szBuf);

   wsprintf(szLogBuf,"Install Engine - download directory set to %s\r\n", _pCif->GetDownloadDir());
   WriteToLog(szLogBuf, FALSE);

   return NOERROR;
}



//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngine::IsComponentInstalled(LPCSTR pszComponentID, DWORD *lResult)
{
   DWORD dwResult = ICI_NOTINSTALLED;
   
   ICifComponent *pComp = NULL;
   
   if(SUCCEEDED(_pCif->FindComponent(pszComponentID, &pComp)))
   {
      dwResult = pComp->IsComponentInstalled();
   }
      
   *lResult = dwResult;

   return(pComp ? NOERROR : E_INVALIDARG);
}


STDMETHODIMP CInstallEngine::SetInstallDrive(CHAR chDrive)
{
   HRESULT hr = E_INVALIDARG;

   if(chDrive >= 'a' && chDrive <= 'z')
      chDrive -= 32;

   if(chDrive >= 'A' && chDrive <= 'Z')
   {
      hr = NOERROR;
      _chInsDrive = chDrive;
   }   
   return hr;
}

//=---------------------------------------------------------------------------=
// Function name here
//=---------------------------------------------------------------------------=
// Function description
//
// Parameters
//
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngine::SetInstallOptions(DWORD dwOptions)
{
   _fUseCache = !(dwOptions & INSTALLOPTIONS_NOCACHE);
   _dwInstallOptions = dwOptions;
   return NOERROR;
}

//=---------------------------------------------------------------------------=
// Function name here
//=---------------------------------------------------------------------------=
// Function description
//
// Parameters
//
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngine::GetInstallOptions(DWORD *pdwOptions)
{
    if (!pdwOptions)
        return E_POINTER;
    else
    {
        *pdwOptions = _dwInstallOptions;
        return NOERROR;
    }
}

//=---------------------------------------------------------------------------=
// Function name here
//=---------------------------------------------------------------------------=
// Function description
//
// Parameters
//
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngine::GetSizes(LPCSTR pszID, COMPONENT_SIZES *p) 
{
   if(!p)
      return E_POINTER;

   // work around bug in old versions of jobexec where it didn't init
   // this field properly

   if(p->cbSize > sizeof(COMPONENT_SIZES))
      p->cbSize = COMPONENTSIZES_SIZE_V1;

   DWORD dwSize = p->cbSize; 
   ZeroMemory(p, p->cbSize);
   p->cbSize = dwSize;
   
   if(_enginestatus != ENGINESTATUS_READY)
      return E_UNEXPECTED;
  
   if(pszID != NULL)
   {
      ICifComponent *pComp = NULL;

      if(SUCCEEDED(_pCif->FindComponent(pszID, &pComp)))
      {
         DWORD dwWin, dwApp;
         p->dwDownloadSize = pComp->GetDownloadSize();
         pComp->GetInstalledSize(&dwWin, &dwApp);
         p->dwInstallSize = dwApp;
         p->dwWinDriveSize = dwWin;
      }
      else
         return E_INVALIDARG;
   }
   else
      _GetTotalSizes(p);
   
   return NOERROR;
}

//=---------------------------------------------------------------------------=
// Function name here
//=---------------------------------------------------------------------------=
// Function description
//
// Parameters
//
// Returns:
//
// Notes:
//


void CInstallEngine::_GetTotalSizes(COMPONENT_SIZES *pSizes)
{
   ICifComponent *pComp;
   DriveInfo drvinfo[3];
   LPSTR pszDep = NULL;
   UINT uTempDrive;
   UINT uWinDrive = 0;
   UINT uInstallDrive = 1;
   UINT uDownloadDrive = 2;
   LPCSTR pszDownloadDir = _pCif->GetDownloadDir();
   COMPONENT_SIZES   Sizes;

   ZeroMemory(&Sizes, sizeof(COMPONENT_SIZES));
   
   // Fill in all arrays to start
   
   drvinfo[uWinDrive].InitDrive(g_szWindowsDir[0]);
   
   if(_dwInstallOptions & INSTALLOPTIONS_INSTALL)
   {
      // We know we can do a compare because these are always uppcase
      if(_chInsDrive != drvinfo[uWinDrive].Drive())
      {
         drvinfo[uInstallDrive].InitDrive(_chInsDrive);
      }
      else 
         uInstallDrive = uWinDrive;
   }

   if(_dwInstallOptions & INSTALLOPTIONS_DOWNLOAD)
   {
      if(pszDownloadDir[0] == drvinfo[uWinDrive].Drive())
         uDownloadDrive = uWinDrive;
      else if(pszDownloadDir[0] == drvinfo[uInstallDrive].Drive())
         uDownloadDrive = uInstallDrive;
      else
         drvinfo[uDownloadDrive].InitDrive(pszDownloadDir[0]);
   }

   // do space for download phase (easy part)
   if(_dwInstallOptions & INSTALLOPTIONS_DOWNLOAD)
   {
      Sizes.dwDownloadSize = _GetActualDownloadSize(FALSE);
      Sizes.dwTotalDownloadSize = _GetTotalDownloadSize();
      Sizes.dwDependancySize = 0;

      // add download to download drive
      drvinfo[uDownloadDrive].UseSpace(Sizes.dwDownloadSize + Sizes.dwDependancySize, TRUE);
   
      // if going to cache
      // BUGBUG: we still assume cache is on windows drive
      if(_fUseCache)
      {
         drvinfo[uWinDrive].UseSpace(Sizes.dwDownloadSize + Sizes.dwDependancySize, TRUE);
      }
   }

   // do space for install (hard part)
   if(_dwInstallOptions & INSTALLOPTIONS_INSTALL)
   {
      // walk the install list in order (very important)
      // do any dependancy, then original
      IEnumCifComponents *penum;
      ICifComponent *pComp = NULL;

      _pCif->EnumComponents(&penum, 0, NULL);
      for(penum->Next(&pComp); pComp; penum->Next(&pComp))
      {
         if(pComp->GetInstallQueueState() == SETACTION_INSTALL)
         {
            DWORD dwWin, dwApp;
            
            pComp->GetInstalledSize(&dwWin, &dwApp);
            // add install
            // add the install size
            Sizes.dwInstallSize += dwApp;
            // size that goes to windows dir
            Sizes.dwWinDriveSize += dwWin;
                           
            drvinfo[uInstallDrive].UseSpace(dwApp, FALSE);
            drvinfo[uWinDrive].UseSpace(dwWin, FALSE);
            // Add (and then remove) temp space
            AddTempSpace(pComp->GetDownloadSize(), pComp->GetExtractSize(), drvinfo);
                           
          
         }
      }
      penum->Release();
   }
    
   // fill in the required amounts
   Sizes.dwWinDriveReq = drvinfo[uWinDrive].MaxUsed();
   Sizes.chWinDrive = drvinfo[uWinDrive].Drive();

   if(uWinDrive != uInstallDrive)
   {
      Sizes.dwInstallDriveReq = drvinfo[uInstallDrive].MaxUsed();
      Sizes.chInstallDrive = drvinfo[uInstallDrive].Drive();
   }
   if((uDownloadDrive != uWinDrive) && (uDownloadDrive != uInstallDrive))
   {
      Sizes.dwDownloadDriveReq = drvinfo[uDownloadDrive].MaxUsed();
      Sizes.chDownloadDrive = drvinfo[uDownloadDrive].Drive();
   }

   CopyMemory((LPVOID)(&(pSizes->dwInstallSize)), (LPVOID)(&(Sizes.dwInstallSize)), 
      pSizes->cbSize - sizeof(DWORD)); 
}


//=---------------------------------------------------------------------------=
// Function name here
//=---------------------------------------------------------------------------=
// Function description
//
// Parameters
//
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngine::SetAction(LPCSTR pszComponentID, DWORD action, DWORD dwPriority)
{
   HRESULT hr = NOERROR;

   if(_enginestatus != ENGINESTATUS_READY)
      return E_UNEXPECTED;
  
   ICifComponent *pComp = NULL;  
   
   if(pszComponentID == NULL || lstrlen(pszComponentID) == 0)
   {
      _pCif->ClearQueueState();
   }
   else
   {
      if(SUCCEEDED(_pCif->FindComponent(pszComponentID, &pComp)))
      {
         if(dwPriority != 0xffffffff)
            pComp->SetCurrentPriority(dwPriority);
         hr = pComp->SetInstallQueueState(action);
      }
      else
         hr = E_INVALIDARG;
   }
   return hr;
}

// the following two are now ridiculously inefficient. New clients should use the enumerators

STDMETHODIMP CInstallEngine::EnumInstallIDs(UINT uIndex, LPSTR *ppszID)
{
   HRESULT hr;
   UINT i = 0;
   *ppszID = NULL;

   IEnumCifComponents *penum;
   ICifComponent *pComp;
   
   _pCif->EnumComponents(&penum, 0, NULL);
   for(penum->Next(&pComp); pComp; penum->Next(&pComp))
   {
      if(pComp->GetInstallQueueState())
      {
         if(uIndex == i)
            break;
         i++;
      }
   }
   penum->Release();
   if(pComp)
   {
      char szID[MAX_ID_LENGTH];
      pComp->GetID(szID, sizeof(szID));
      *ppszID = COPYANSISTR(szID);
      hr = NOERROR;
   }
   else
      hr = E_FAIL;

   return hr;
}


STDMETHODIMP CInstallEngine::EnumDownloadIDs(UINT uIndex, LPSTR *ppszID)
{
   HRESULT hr;
   UINT i = 0;
   *ppszID = NULL;

   IEnumCifComponents *penum;
   ICifComponent *pComp;
   
   _pCif->EnumComponents(&penum, 0, NULL);
   for(penum->Next(&pComp); pComp; penum->Next(&pComp))
   {
      if(pComp->GetInstallQueueState() && (pComp->IsComponentDownloaded() == S_FALSE))
      {
         if(uIndex == i)
            break;
         i++;
      }
   }
   penum->Release();
   if(pComp)
   {
      char szID[MAX_ID_LENGTH];
      pComp->GetID(szID, sizeof(szID));
      *ppszID = COPYANSISTR(szID);
      hr = NOERROR;
   }
   else
      hr = E_FAIL;

   return hr;
   
}

 
//=---------------------------------------------------------------------------=
// Function name here
//=---------------------------------------------------------------------------=
// Function description
//
// Parameters
//
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngine::DownloadComponents(DWORD lFlags)
{
   DWORD dwThreadID;
   HRESULT hr = NOERROR;
   
   WriteToLog("Install Engine - Starting download phase\r\n", TRUE);
   if(_enginestatus == ENGINESTATUS_NOTREADY || _enginestatus == ENGINESTATUS_LOADING)
      hr = E_UNEXPECTED;

   // BUGBUG - add a downloading status? it really just a "busy" indication
   if(_enginestatus == ENGINESTATUS_INSTALLING)
      hr = E_PENDING;


   if(SUCCEEDED(hr))
   {   
      OnEngineStatusChange(ENGINESTATUS_INSTALLING, 0);

      // since trust may be set globally, only turn it on, not off
      if(EXECUTEJOB_IGNORETRUST & lFlags)
         _fIgnoreTrust = TRUE;

      if(EXECUTEJOB_IGNOREDOWNLOADERROR & lFlags)
         _fIgnoreDownloadError = TRUE;
      else
         _fIgnoreDownloadError = FALSE;

      HANDLE h = CreateThread(NULL, 0, InitDownloader, this, 0, &dwThreadID);
      if(h == NULL)
      {
         // Won't be doing any downloading today.....
         hr = E_FAIL;
      }
      else
         CloseHandle(h);
   }

   return hr;
} 

//=---------------------------------------------------------------------------=
// Function name here
//=---------------------------------------------------------------------------=
// Function description
//
// Parameters
//
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngine::InstallComponents(DWORD lFlags)
{
   DWORD dwThreadID;
   HRESULT hr = NOERROR;

   WriteToLog("Install Engine - Starting install phase\r\n", TRUE);

   EnterCriticalSection(&g_cs);
   if(_enginestatus == ENGINESTATUS_NOTREADY || _enginestatus == ENGINESTATUS_LOADING)
      hr = E_UNEXPECTED;

   if(_enginestatus == ENGINESTATUS_INSTALLING)
      hr = E_PENDING;
   LeaveCriticalSection(&g_cs);

   if(SUCCEEDED(hr))
   {   
      // We first check to see if all files are present
      // by seeing if we would download anything!!!
      //
      if(EXECUTEJOB_VERIFYFILES & lFlags)
      {
         WriteToLog("Checking for missing files\r\n", FALSE);
         if(_GetActualDownloadSize(TRUE) != 0)
           return E_FILESMISSING;
      }
         
      OnEngineStatusChange(ENGINESTATUS_INSTALLING, 0);

      // since trust may be set globally, only turn it on, not off
      if(EXECUTEJOB_IGNORETRUST & lFlags)
         _fIgnoreTrust = TRUE;

      HANDLE h = CreateThread(NULL, 0, InitInstaller, this, 0, &dwThreadID);
      if(h == NULL)
      {
         // Won't be doing any installing today.....
         hr = E_FAIL;
      }
      else
         CloseHandle(h);
   }

   return hr;
} 


//=---------------------------------------------------------------------------=
// Function name here
//=---------------------------------------------------------------------------=
// Function description
//
// Parameters
//
// Returns:
//
// Notes:
//

DWORD WINAPI InitInstaller(LPVOID pv)
{
   CInstallEngine *pInsEng = (CInstallEngine *) pv;
   HRESULT hr = S_OK;
   BOOL fOneInstalled = FALSE;
   
   ICifComponent *pComp;

   EnableSage(FALSE);
   EnableScreenSaver(FALSE);
   EnableDiskCleaner(FALSE);

   pInsEng->_dwStatus = 0;
   
   pInsEng->_hAbort = CreateEvent(NULL, FALSE, FALSE, NULL);
   pInsEng->_hContinue = CreateEvent(NULL, TRUE, TRUE, NULL);
   
   //BUGBUG check for failure
   
   pInsEng->AddRef();

   pInsEng->OnStartInstall(0, pInsEng->_GetTotalInstallSize());

   // check trust the Cif cab if it has not been done so
   hr = pInsEng->CheckForContinue();
  
   // this is the install pass
   if(SUCCEEDED(hr))
      hr = pInsEng->_pCif->Install(&fOneInstalled);
      
   if(fOneInstalled && FNeedGrpConv())
   {
      if(!(pInsEng->GetStatus() & STOPINSTALL_REBOOTNEEDED))
      {
         // if we dont need a reboot launch grpconv immeadiatly
         HANDLE h = NULL;
         pInsEng->WriteToLog("Install Engine - No reboot required\r\n", FALSE);
         LaunchAndWait(GRPCONV, NULL, &h, NULL, SW_SHOWMINIMIZED);
         if(h)
            CloseHandle(h);
      }
      else
      {
         HKEY hKey;
         DWORD dumb;
         // otherwise put grpconv into runonce
         if(RegCreateKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_RUNONCE,
            0,0,0, KEY_SET_VALUE, NULL, &hKey, &dumb) == ERROR_SUCCESS)
         {
            RegSetValueEx(hKey, "GrpConv", 0, REG_SZ, 
               (BYTE *) GRPCONV, sizeof(GRPCONV));
            RegCloseKey(hKey);
         }
      }
   }
   
   
   // reset to checking trust
   if(pInsEng->_fResetTrust)
      pInsEng->_fIgnoreTrust = FALSE;
   // Send a install all done message

   if(!(pInsEng->GetStatus() & STOPINSTALL_REBOOTNEEDED))
   {
       // If we don't need a reboot, enable the screen saver and sage.
       EnableScreenSaver(TRUE);
       EnableSage(TRUE);
   }
   EnableDiskCleaner(TRUE);

   CloseHandle(pInsEng->_hAbort);
   pInsEng->_hAbort = NULL;
   
   CloseHandle(pInsEng->_hContinue);
   pInsEng->_hContinue = NULL;
      
   
   pInsEng->OnStopInstall(hr, NULL, pInsEng->GetStatus());
   pInsEng->OnEngineStatusChange(ENGINESTATUS_READY, 0);
   
   pInsEng->Release();


   return 0;
}   

//=---------------------------------------------------------------------------=
// Function name here
//=---------------------------------------------------------------------------=
// Function description
//
// Parameters
//
// Returns:
//
// Notes:
//

DWORD WINAPI InitDownloader(LPVOID pv)
{
   CInstallEngine *pInsEng = (CInstallEngine *) pv;
   HRESULT hr = S_OK;
  
   EnableSage(FALSE);
   EnableScreenSaver(FALSE);
   EnableDiskCleaner(FALSE);

   pInsEng->_hAbort = CreateEvent(NULL, FALSE, FALSE, NULL);
   pInsEng->_hContinue = CreateEvent(NULL, TRUE, TRUE, NULL);
   
   //BUGBUG check for failure
   
   pInsEng->AddRef();

   pInsEng->OnStartInstall(pInsEng->_GetActualDownloadSize(FALSE), 0);

   // check trust the Cif cab if it has not been done so
   hr = pInsEng->CheckForContinue();
  
   // this is the download pass
   if(SUCCEEDED(hr))
   {
      hr = pInsEng->_pCif->Download();
   }

   if(SUCCEEDED(hr))
   {
      pInsEng->WriteToLog("Install Engine - Download complete\r\n", FALSE);
   }
   
   // reset to checking trust
   if(pInsEng->_fResetTrust)
      pInsEng->_fIgnoreTrust = FALSE;
   

   CloseHandle(pInsEng->_hAbort);
   pInsEng->_hAbort = NULL;
   
   CloseHandle(pInsEng->_hContinue);
   pInsEng->_hContinue = NULL;
   
   EnableScreenSaver(TRUE);
   EnableSage(TRUE);
   EnableDiskCleaner(TRUE);
   // Send a install all done message
   EnterCriticalSection(&g_cs);
   pInsEng->OnStopInstall(hr, NULL, 0);
   pInsEng->OnEngineStatusChange(ENGINESTATUS_READY, 0);
   LeaveCriticalSection(&g_cs);
   
   pInsEng->Release();
   return 0;
}   


//=---------------------------------------------------------------------------=
// Function name here
//=---------------------------------------------------------------------------=
// Function description
//
// Parameters
//
// Returns:
//
// Notes:
//

DWORD CInstallEngine::_GetTotalDownloadSize()
{
   DWORD dwTotalSize = 0;
   IEnumCifComponents *penum;
   ICifComponent *pComp = NULL;

   _pCif->EnumComponents(&penum, 0, NULL);
   for(penum->Next(&pComp); pComp; penum->Next(&pComp))
   {
      if(pComp->GetInstallQueueState() == SETACTION_INSTALL)
      dwTotalSize += pComp->GetDownloadSize();
   }
   penum->Release();
   return dwTotalSize;
}

//=---------------------------------------------------------------------------=
// Function name here
//=---------------------------------------------------------------------------=
// Function description
//
// Parameters
//
// Returns:
//
// Notes:
//

DWORD CInstallEngine::_GetActualDownloadSize(BOOL bLogMissing)
{
   DWORD dwTotalSize = 0;
   IEnumCifComponents *penum;
   ICifComponent *pComp = NULL;

   _pCif->EnumComponents(&penum, 0, NULL);
   for( penum->Next(&pComp); pComp; penum->Next(&pComp))
   {
      if(pComp->GetInstallQueueState() == SETACTION_INSTALL)
         dwTotalSize += pComp->GetActualDownloadSize();
   }
   penum->Release();
   return dwTotalSize;
}


//=---------------------------------------------------------------------------=
// Function name here
//=---------------------------------------------------------------------------=
// Function description
//
// Parameters
//
// Returns:
//
// Notes:
//

DWORD CInstallEngine::_GetTotalInstallSize()
{
   DWORD dwTotalSize = 0;
   DWORD dwWin, dwApp;
   IEnumCifComponents *penum;
   ICifComponent *pComp = NULL;

   _pCif->EnumComponents(&penum, 0, NULL);
   for(penum->Next(&pComp); pComp; penum->Next(&pComp))
   {
      if(pComp->GetInstallQueueState() == SETACTION_INSTALL)
      {
         pComp->GetInstalledSize(&dwWin, &dwApp);
         dwTotalSize += (dwWin + dwApp);
      }
   }
   penum->Release();
   return dwTotalSize;
}
   

//=---------------------------------------------------------------------------=
// Function name here
//=---------------------------------------------------------------------------=
// Function description
//
// Parameters
//
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngine::LaunchExtraCommand(LPCSTR pszInfName, LPCSTR pszSection)
{
   return E_NOTIMPL;
}

//=---------------------------------------------------------------------------=
// RegisterInstallEngineCallback
//=---------------------------------------------------------------------------=
// Register the callback interface
//
// Parameters:
//    IInstallEngineCallback *  - the callback interface
//    HWND - For ui
//
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngine::RegisterInstallEngineCallback(IInstallEngineCallback *pcb)
{ 
   _pcb = pcb;
   return NOERROR;
}

//=---------------------------------------------------------------------------=
// Function name here
//=---------------------------------------------------------------------------=
// Function description
//
// Parameters
//
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngine::UnregisterInstallEngineCallback()
{ 
   _pcb = NULL;
   return NOERROR;
}

//=---------------------------------------------------------------------------=
// Function name here
//=---------------------------------------------------------------------------=
// Function description
//
// Parameters
//
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngine::SetHWND(HWND h)
{
   _hwndForUI = h;
   return NOERROR;
}

//***********  IInstallEngineCallback implementation ************

//=---------------------------------------------------------------------------=
// Function name here
//=---------------------------------------------------------------------------=
// Function description
//
// Parameters
//
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngine::OnEngineStatusChange(DWORD status,DWORD substatus)
{
   _enginestatus = status; 
   if(_pcb)
      _pcb->OnEngineStatusChange(_enginestatus, substatus);
   return NOERROR;
}

//=---------------------------------------------------------------------------=
// Function name here
//=---------------------------------------------------------------------------=
// Function description
//
// Parameters
//
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngine::OnStartInstall(DWORD dwDLSize, DWORD dwInstallSize) 
{
   _dwDLRemaining = dwDLSize;
   _dwInstallRemaining = dwInstallSize;
   
   wsprintf(szLogBuf, "\r\nOnStartInstall:\r\n   Download: %d KB\r\n   Install %d KB\r\n", dwDLSize, dwInstallSize);
   WriteToLog(szLogBuf, TRUE);

   if(_pcb)
      _pcb->OnStartInstall(dwDLSize, dwInstallSize);

   return NOERROR;
}

//=---------------------------------------------------------------------------=
// Function name here
//=---------------------------------------------------------------------------=
// Function description
//
// Parameters
//
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngine::OnStartComponent(LPCSTR pszID, DWORD dwDLSize, 
                                   DWORD dwInstallSize, LPCSTR pszString)
{
   wsprintf(szLogBuf, "OnStartComponent:\r\n   ID: %s\r\n   Download: %d KB\r\n   Install %d KB\r\n", 
                         pszID, dwDLSize, dwInstallSize);
   WriteToLog(szLogBuf, TRUE);

   _dwDLOld = 0;
   _dwInstallOld = 0;
   if(_pcb)
      _pcb->OnStartComponent(pszID, dwDLSize, dwInstallSize, pszString);

   return NOERROR;
}

//=---------------------------------------------------------------------------=
// Function name here
//=---------------------------------------------------------------------------=
// Function description
//
// Parameters
//
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngine::OnEngineProblem(DWORD dwProblem, LPDWORD pdwAction)
{
   HRESULT hr = S_FALSE;

   if(_pcb)
      hr = _pcb->OnEngineProblem(dwProblem, pdwAction);

   return hr;
}


//=---------------------------------------------------------------------------=
// Function name here
//=---------------------------------------------------------------------------=
// Function description
//
// Parameters
//
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngine::OnComponentProgress(LPCSTR pszID, DWORD dwPhase,
                        LPCSTR pszString, LPCSTR pszMsgString,  ULONG prog, ULONG max)
{
   DWORD dwNew;
   
   if(dwPhase == INSTALLSTATUS_DOWNLOADING)
   {
      _dwDLOld = prog;
   }
   else if(dwPhase == INSTALLSTATUS_RUNNING)
   {
      _dwInstallOld = prog;
   }
   
   if(_pcb)
      _pcb->OnComponentProgress(pszID, dwPhase, pszString, pszMsgString, prog, max);

   return NOERROR;
}

//=---------------------------------------------------------------------------=
// Function name here
//=---------------------------------------------------------------------------=
// Function description
//
// Parameters
//
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngine::OnStopComponent(LPCSTR pszID, HRESULT hError,
                        DWORD dwPhase, LPCSTR pszString, DWORD dwStatus)
{
   // adjust remaining
   if(_dwDLRemaining > _dwDLOld)
      _dwDLRemaining -= _dwDLOld;
   else
      _dwDLRemaining = 0;
   
   // adjust remaining
   if(_dwInstallRemaining > _dwInstallOld)
      _dwInstallRemaining -= _dwInstallOld;
   else
      _dwInstallRemaining = 0;
   

   wsprintf(szLogBuf, "Timing rates: Download: %d, Install %d\r\n", 
                _pDL->GetBytesPerSecond(), _pIns->GetBytesPerSecond());
   WriteToLog(szLogBuf, TRUE);

   
   wsprintf(szLogBuf, "OnStopComponent:\r\n   ID: %s\r\n   HRESULT: %x (%s)\r\n   Phase: %d\r\n   Status: %d\r\n", 
                         pszID, hError, SUCCEEDED(hError) ? STR_OK : STR_FAILED, dwPhase, dwStatus);
   WriteToLog(szLogBuf, TRUE);
   
   if(_pcb)
      _pcb->OnStopComponent(pszID, hError, dwPhase, pszString, dwStatus);

   return NOERROR;
}

//=---------------------------------------------------------------------------=
// Function name here
//=---------------------------------------------------------------------------=
// Function description
//
// Parameters
//
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngine::OnStopInstall(HRESULT hrError, LPCSTR szError,
                        DWORD dwStatus)
{
   _dwDLRemaining = 0;
   _dwInstallRemaining = 0;
   
   wsprintf(szLogBuf, "\r\nOnStopInstall:\r\n   HRESULT: %x (%s)\r\n   Status: %d\r\n", 
                         hrError, SUCCEEDED(hrError) ? STR_OK : STR_FAILED, dwStatus);
   WriteToLog(szLogBuf, TRUE);

   
   if(_pcb)
      _pcb->OnStopInstall(hrError, szError, dwStatus);

   return NOERROR;
}


//=---------------------------------------------------------------------------=
// Function name here
//=---------------------------------------------------------------------------=
// Function description
//
// Parameters
//
// Returns:
//
// Notes:
//


STDMETHODIMP CInstallEngine::SetIStream(IStream *pstm)
{
   if(_pStmLog)
      _pStmLog->Release();

   _pStmLog = pstm;
   if(_pStmLog)
      _pStmLog->AddRef();

   return NOERROR;
}

//=---------------------------------------------------------------------------=
// Function name here
//=---------------------------------------------------------------------------=
// Function description
//
// Parameters
//
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngine::GetDisplayName(LPCSTR pszComponentID, LPSTR *ppszName)
{ 
   HRESULT hr = E_INVALIDARG;
   char szTitle[MAX_DISPLAYNAME_LENGTH];
   
   if(!ppszName)
      return E_POINTER;

   *ppszName = 0;

   ICifComponent *pComp = NULL;

   if(pszComponentID)
   {
      if(SUCCEEDED(_pCif->FindComponent(pszComponentID, &pComp)))
      {
         pComp->GetDescription(szTitle, sizeof(szTitle));
         *ppszName = COPYANSISTR(szTitle);
         if(!(*ppszName))
            hr = E_OUTOFMEMORY;
         else
            hr = NOERROR;
      }
   }
   else
   {
      _pCif->GetDescription(szTitle, sizeof(szTitle));
      *ppszName = COPYANSISTR(szTitle);
      if(!(*ppszName))
         hr = E_OUTOFMEMORY;
      else
         hr = NOERROR;
   }
   return hr;
}

//************** IInstallEngineTiming **********************

//=---------------------------------------------------------------------------=
// Function name here
//=---------------------------------------------------------------------------=
// Function description
//
// Parameters
//
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngine::GetRates(DWORD *pdwDownload, DWORD *pdwInstall)
{ 
   *pdwDownload = _pDL->GetBytesPerSecond();
   *pdwInstall = _pIns->GetBytesPerSecond();
   return NOERROR;
}

STDMETHODIMP CInstallEngine::GetInstallProgress(INSTALLPROGRESS *pinsprog)
{
   if(!pinsprog)
      return E_POINTER;

   DWORD dwTemp;

   pinsprog->dwDownloadKBRemaining = _dwDLRemaining - _dwDLOld;
   pinsprog->dwInstallKBRemaining = _dwInstallRemaining - _dwInstallOld;

   dwTemp = _pDL->GetBytesPerSecond();
   if(dwTemp == 0)
      pinsprog->dwDownloadSecsRemaining = 0xffffffff;
   else
      pinsprog->dwDownloadSecsRemaining = (pinsprog->dwDownloadKBRemaining << 10)/dwTemp;

   dwTemp = _pIns->GetBytesPerSecond();
   if(dwTemp == 0)
      pinsprog->dwInstallSecsRemaining = 0xffffffff;
   else
      pinsprog->dwInstallSecsRemaining = (pinsprog->dwInstallKBRemaining << 10)/dwTemp;

   return NOERROR;
}


HRESULT CInstallEngine::CheckForContinue()
{
   HRESULT hr = S_OK;

   // Need to check Abort before AND after check for pause...
   if(_pCif->CanCancel() && (WaitForSingleObject(_hAbort, 0) == WAIT_OBJECT_0))
   {
      hr = E_ABORT;
   }
   
   if(SUCCEEDED(hr))
   {
      WaitForEvent(_hContinue, NULL);
   }

   if(_pCif->CanCancel() && (WaitForSingleObject(_hAbort, 0) == WAIT_OBJECT_0))
   {
      hr = E_ABORT;
   }
 
   return hr;
}

#define STEPPINGMODE_NO "n"

void CInstallEngine::WriteToLog(char *sz, BOOL pause)
{
   ULONG foo;
   UINT ret;
   HKEY hKey;
   
   if(_fSteppingMode && pause)
   {
      ret = MessageBox(_hwndForUI, sz, "Stepping Mode Message", MB_OKCANCEL | MB_ICONINFORMATION); 
      if(ret == IDCANCEL)
      {
         // turn off stepping mode
         _fSteppingMode = FALSE;
         // Whack the key
         if(RegOpenKeyEx(HKEY_LOCAL_MACHINE, ACTIVESETUP_KEY,0, 
                     KEY_WRITE, &hKey) == ERROR_SUCCESS)
         {
            // I don't check for failure of delete - what would I do anyways?
            RegSetValueEx(hKey, STEPPING_VALUE, 0, REG_SZ, 
                        (BYTE *) STEPPINGMODE_NO, lstrlen(STEPPINGMODE_NO) + 1);
            RegCloseKey(hKey);
         }
      }
   }
      
   if(_pStmLog)
      _pStmLog->Write(sz, lstrlen(sz), &foo);
}

BOOL CInstallEngine::_IsValidBaseUrl(LPCSTR pszUrl)
{
   BOOL bValid = TRUE;

   if(!pszUrl)
      bValid = FALSE;

   return bValid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\inseng\insengmn.cpp ===
//=--------------------------------------------------------------------------=
// insengmn.cpp
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// various globals which the framewrk requires
//
//

#include "inspch.h"
#include "insobj.h"
#include "insfact.h"
#include "sitefact.h"
#include "insengmn.h"
#include "resource.h"
#include "advpub.h"


LONG g_cLocks = 0;
HINSTANCE g_hInstance = NULL;
HANDLE g_hHeap = NULL;
CRITICAL_SECTION    g_cs = {0};     // per-instance

#define GUID_STR_LEN 40
//
// helper macros
//


OBJECTINFO g_ObjectInfo[] =
{
   { NULL, &CLSID_InstallEngine, NULL, OI_COCREATEABLE, "InstallEngine", 
       MAKEINTRESOURCE(IDS_INSTALLENGINE), NULL, NULL, VERSION_0, 0, 0 },
   { NULL, &CLSID_DownloadSiteMgr, NULL, OI_COCREATEABLE, "DownloadSiteMgr", 
       MAKEINTRESOURCE(IDS_DOWNLOADSITEMGR), NULL, NULL, VERSION_0, 0, 0 },
   { NULL, NULL, NULL, 0, NULL, NULL, NULL, NULL, 0, 0, 0 },
} ;


STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, void **ppv)
{
    if((riid == IID_IClassFactory) || (riid == IID_IUnknown))
    {
        const OBJECTINFO *pcls;
        for (pcls = g_ObjectInfo; pcls->pclsid; pcls++)
        {
            if(rclsid == *pcls->pclsid)
            {
                *ppv = pcls->cf;
                ((IUnknown *)*ppv)->AddRef();
                return NOERROR;
            }
        }
    }

    *ppv = NULL;
    return CLASS_E_CLASSNOTAVAILABLE;
}

STDAPI DllCanUnloadNow(void)
{
    if (g_cLocks)
        return S_FALSE;

    return S_OK;
}


void InitClassFactories()
{
   g_ObjectInfo[0].cf = (void *) new CInstallEngineFactory();
   g_ObjectInfo[1].cf = (void *) new CSiteManagerFactory();
}


void DeleteClassFactories()
{
   delete g_ObjectInfo[0].cf;
   delete g_ObjectInfo[1].cf;
}



STDAPI_(BOOL) DllMain(HANDLE hDll, DWORD dwReason, void *lpReserved)
{
   DWORD dwThreadID;

   switch(dwReason)
   {
      case DLL_PROCESS_ATTACH:
         g_hInstance = (HINSTANCE)hDll;
         g_hHeap = GetProcessHeap();
         InitializeCriticalSection(&g_cs);
         DisableThreadLibraryCalls(g_hInstance);
         InitClassFactories();
         break;

      case DLL_PROCESS_DETACH:
         DeleteCriticalSection(&g_cs);
         DeleteClassFactories();
         break;

      default:
         break;
   }
   return TRUE;
}

void DllAddRef(void)
{
    InterlockedIncrement(&g_cLocks);
}

void DllRelease(void)
{
    InterlockedDecrement(&g_cLocks);
}

HRESULT PurgeDownloadDirectory(LPCSTR pszDownloadDir)
{
   return DelNode(pszDownloadDir, ADN_DONT_DEL_DIR);  
}


STDAPI DllRegisterServer(void)
{
    // BUGBUG: pass back return from RegInstall ?
    RegInstall(g_hInstance, "DllReg", NULL);

    return S_OK;
}

STDAPI DllUnregisterServer(void)
{
    RegInstall(g_hInstance, "DllUnreg", NULL);

    return S_OK;
}

STDAPI DllInstall(BOOL bInstall, LPCSTR lpCmdLine)
{
    // BUGBUG: pass back return from RegInstall ?
    if (bInstall)
        RegInstall(g_hInstance, "DllInstall", NULL);
    else
        RegInstall(g_hInstance, "DllUninstall", NULL);

    return S_OK;
}




//=--------------------------------------------------------------------------=
// CRT stubs
//=--------------------------------------------------------------------------=
// these two things are here so the CRTs aren't needed. this is good.
//
// basically, the CRTs define this to pull in a bunch of stuff.  we'll just
// define them here so we don't get an unresolved external.
//
// TODO: if you are going to use the CRTs, then remove this line.
//
extern "C" int _fltused = 1;

extern "C" int _cdecl _purecall(void)
{
//  FAIL("Pure virtual function called.");
  return 0;
}

void * _cdecl operator new
(
    size_t    size
)
{
    return HeapAlloc(g_hHeap, 0, size);
}

//=---------------------------------------------------------------------------=
// overloaded delete
//=---------------------------------------------------------------------------=
// retail case just uses win32 Local* heap mgmt functions
//
// Parameters:
//    void *        - [in] free me!
//
// Notes:
//
void _cdecl operator delete ( void *ptr)
{
    HeapFree(g_hHeap, 0, ptr);
}

#ifndef _X86_
extern "C" void _fpmath() {}
#endif


void * _cdecl malloc(size_t n)
{
#ifdef _MALLOC_ZEROINIT
        void* p = HeapAlloc(g_hHeap, 0, n);
        if (p != NULL)
                ZeroMemory(p, n);
        return p;
#else
        return HeapAlloc(g_hHeap, 0, n);
#endif
}

void * _cdecl calloc(size_t n, size_t s)
{
#ifdef _MALLOC_ZEROINIT
        return malloc(n * s);
#else
        void* p = malloc(n * s);
        if (p != NULL)
                ZeroMemory(p, n * s);
        return p;
#endif
}

void* _cdecl realloc(void* p, size_t n)
{
        if (p == NULL)
                return malloc(n);

        return HeapReAlloc(g_hHeap, 0, p, n);
}

void _cdecl free(void* p)
{
        if (p == NULL)
                return;

        HeapFree(g_hHeap, 0, p);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\inseng\install.h ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\inseng\inspch.cpp ===
#include "inspch.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\inseng\insobj.h ===
#include "inseng.h"
#include <wininet.h>
#include "util2.h"
#include "ciffile.h"

#define CMDLINE  "\"%s%s\" %s"

#define COMPONENT_KEY "Software\\Microsoft\\Active Setup\\Installed Components"
#define ACTIVESETUP_KEY "Software\\Microsoft\\Active Setup"
#define STEPPING_VALUE  "SteppingMode"
#define COMMAND_VALUE   "CommandMode"
#define CHECKTRUST_VALUE "DisableCheckTrust"
#define VERSION_KEY  "Version"

#define STR_FAILED "Failed"
#define STR_OK     "OK"

#define COMPONENTSIZES_SIZE_V1   32
#define COMPONENTSIZES_SIZE_V2   35
#define COMPONENTSIZES_SIZE_V3   39

class CInstallEngine : public IInstallEngine2, public IInstallEngineTiming,
                       public IInstallEngineCallback
{
   friend DWORD WINAPI InitInstaller(LPVOID pv);
   friend DWORD WINAPI InitDownloader(LPVOID pv);

   public:
      CInstallEngine(IUnknown **punk);
      ~CInstallEngine();

      // the usual IUnknown members
      STDMETHOD_(ULONG, AddRef)(void);
      STDMETHOD_(ULONG, Release)(void);
      STDMETHOD(QueryInterface)(REFIID, void **); 
      
      // IInstallEngine methods
      //
      STDMETHOD(GetEngineStatus)(THIS_ DWORD *theenginestatus);
      STDMETHOD(GetSizes)(THIS_ LPCSTR pszID, COMPONENT_SIZES *p);
      STDMETHOD(SetAction)(THIS_ LPCSTR pszID,DWORD dwAction,DWORD dwPriority);
      STDMETHOD(EnumInstallIDs)(THIS_ UINT uIndex, LPSTR *ppszID);
      STDMETHOD(EnumDownloadIDs)(THIS_ UINT uIndex, LPSTR *ppszID);
      STDMETHOD(IsComponentInstalled)(THIS_ LPCSTR pszID, DWORD *pdwStatus);
      STDMETHOD(DownloadComponents)(THIS_ DWORD dwFlags);
      STDMETHOD(InstallComponents)(THIS_ DWORD dwFlags);
      STDMETHOD(LaunchExtraCommand)(THIS_ LPCSTR pszInfName, LPCSTR pszSection);
      STDMETHOD(RegisterInstallEngineCallback)(THIS_ IInstallEngineCallback *pcb);
      STDMETHOD(UnregisterInstallEngineCallback)(THIS);
      STDMETHOD(GetDisplayName)(THIS_ LPCSTR pszComponentID, LPSTR *ppszName);

      // Intall info stuff
      STDMETHOD(SetCifFile)(THIS_ LPCSTR pszCabName, LPCSTR pszCifName);
      STDMETHOD(SetBaseUrl)(THIS_ LPCSTR pszBaseName);
      STDMETHOD(SetDownloadDir)(THIS_ LPCSTR pszDownloadDir);
      STDMETHOD(SetInstallDrive)(THIS_ char chDrive);
      STDMETHOD(SetInstallOptions)(THIS_ DWORD dwInsFlag);
      STDMETHOD(GetInstallOptions)(THIS_ DWORD *pdwInsFlag);

      STDMETHOD(SetHWND)(THIS_ HWND hForUI);
      STDMETHOD(SetIStream)(THIS_ IStream *pstm);

      // Engine Control
      STDMETHOD(Abort)(THIS_ DWORD dwFlags);
      STDMETHOD(Suspend)(THIS);
      STDMETHOD(Resume)(THIS);


      // IInstallEngineTiming
      STDMETHOD(GetRates)(THIS_ DWORD *pdwDownload, DWORD *pdwInstall);
      STDMETHOD(GetInstallProgress)(THIS_ INSTALLPROGRESS *pinsprog);      

      // IInstallEngine2
      STDMETHOD(SetLocalCif)(THIS_ LPCSTR pszLocalCif);
      STDMETHOD(GetICifFile)(THIS_ ICifFile **pcif);



      // IInstallEngineCallback
      STDMETHOD(OnEngineStatusChange)(THIS_ DWORD dwEngStatus, DWORD substatus);
      STDMETHOD(OnStartInstall)(THIS_ DWORD dwDLSize, DWORD dwInstallSize);
      STDMETHOD(OnStartComponent)(THIS_ LPCSTR pszID, DWORD dwDLSize, 
                                  DWORD dwInstallSize, LPCSTR pszString);
      STDMETHOD(OnComponentProgress)(THIS_ LPCSTR pszID, DWORD dwPhase, 
                              LPCSTR pszString, LPCSTR pszMsgString, ULONG progress, ULONG themax);
      STDMETHOD(OnStopComponent)(THIS_ LPCSTR pszID, HRESULT hError, 
                              DWORD dwPhase, LPCSTR pszString, DWORD dwStatus);
      STDMETHOD(OnStopInstall)(THIS_ HRESULT hrError, LPCSTR szError, 
                              DWORD dwStatus); 
      STDMETHOD(OnEngineProblem)(THIS_ DWORD dwProblem, LPDWORD dwAction); 

      void WriteToLog(char *sz, BOOL pause);
      CDownloader   *GetDownloader()            {  return _pDL; }
      CInstaller    *GetInstaller()             {  return _pIns; }
      CPatchDownloader *GetPatchDownloader()    {  return _pPDL; }
    
      LPCSTR         GetBaseUrl()               {  return _szBaseUrl; }
      void           SetStatus(DWORD dwStatus)  {  _dwStatus |= dwStatus; }
      UINT           GetStatus()                {  return _dwStatus; }
      UINT           GetCommandMode()           {  return _uCommandMode; }
      HWND           GetHWND()                  {  return _hwndForUI; }
      BOOL           IgnoreTrustCheck()         {  return _fIgnoreTrust; }
      BOOL           IgnoreDownloadError()      {  return _fIgnoreDownloadError; }
      char           GetInstallDrive()          {  return _chInsDrive; }
      HRESULT        CheckForContinue();
      BOOL           UseCache()                 {  return  _fUseCache; }
      BOOL           AllowCrossPlatform()       {  return !(_dwInstallOptions & INSTALLOPTIONS_DONTALLOWXPLATFORM); }  
      BOOL           ForceDependencies()        {  return (_dwInstallOptions & INSTALLOPTIONS_FORCEDEPENDENCIES); }
      BOOL           IsAdvpackExtAvailable()    {  return _fSRLiteAvailable; }

   private:
      char           _szBaseUrl[INTERNET_MAX_URL_LENGTH];
      HWND           _hwndForUI;
      IStream       *_pStmLog;
      UINT           _uCommandMode;      
      char           _chInsDrive;
      DWORD          _dwDLRemaining;
      DWORD          _dwInstallRemaining;
      DWORD          _dwDLOld;
      DWORD          _dwInstallOptions;
      DWORD          _dwInstallOld;
      DWORD          _enginestatus;
      DWORD          _dwStatus;
      ULONG          _cRef;
      HANDLE         _hAbort;
      HANDLE         _hContinue;
      IInstallEngineCallback *_pcb;
      CDownloader    *_pDL;
      CInstaller     *_pIns;
      CPatchDownloader *_pPDL;

      BOOL           _fUseCache:1;
      BOOL           _fSteppingMode:1;
      BOOL           _fIgnoreTrust:1;
      BOOL           _fIgnoreDownloadError:1;
      BOOL           _fResetTrust:1;
      BOOL           _fCleanUpDir:1;
    
      BOOL           _fSRLiteAvailable:1;
      CCifFile       *_pCif;
  
      void    _GetTotalSizes(COMPONENT_SIZES *p);
      DWORD   _GetTotalDownloadSize();
      DWORD   _GetActualDownloadSize(BOOL bLogMissing);
      DWORD   _GetTotalDependencySize();
      DWORD   _GetTotalInstallSize();
      BOOL    _IsValidBaseUrl(LPCSTR pszUrl);
};



DWORD WINAPI InitInstaller(LPVOID);
DWORD WINAPI InitDownloader(LPVOID);

extern CRITICAL_SECTION g_cs;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\inseng\insengmn.h ===
typedef struct tagOBJECTINFO
{
    void *cf;
    CLSID const* pclsid;
    HRESULT (*pfnCreateInstance)(IUnknown* pUnkOuter, IUnknown** ppunk, const struct tagOBJECTINFO *);

    // for automatic registration, type library searching, etc
    int nObjectType;        // OI_ flag
    LPTSTR pszName;       
    LPTSTR pszFriendlyName; 
    IID const* piid;
    IID const* piidEvents;
    long lVersion;
    DWORD dwOleMiscFlags;
    int nidToolbarBitmap;
} OBJECTINFO;
typedef OBJECTINFO const* LPCOBJECTINFO;

#define VERSION_1 1 // so we don't get confused by too many integers
#define VERSION_0 0

#define OI_NONE          0
#define OI_UNKNOWN       1
#define OI_COCREATEABLE  1
#define OI_AUTOMATION    2
#define OI_CONTROL       3


// to save some typing:
#define CLSIDOFOBJECT(p)          (*((p)->_pObjectInfo->pclsid))
#define NAMEOFOBJECT(p)             ((p)->_pObjectInfo->pszName)
#define INTERFACEOFOBJECT(p)      (*((p)->_pObjectInfo->piid))
#define VERSIONOFOBJECT(p)          ((p)->_pObjectInfo->lVersion)
#define EVENTIIDOFCONTROL(p)      (*((p)->_pObjectInfo->piidEvents))
#define OLEMISCFLAGSOFCONTROL(p)    ((p)->_pObjectInfo->dwOleMiscFlags)
#define BITMAPIDOFCONTROL(p)        ((p)->_pObjectInfo->nidToolbarBitmap)

extern OBJECTINFO g_ObjectInfo[];

#ifdef __cplusplus
extern "C" {
#endif

HRESULT PurgeDownloadDirectory(LPCSTR pszDownloadDir);

#ifdef __cplusplus
} // end of extern "C"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\inseng\insfact.h ===
class CInstallEngineFactory : IClassFactory
{
   public:
      CInstallEngineFactory() { cRef = 0; };

      //IUnknown things
      STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
      STDMETHODIMP_(ULONG) AddRef(void);
      STDMETHODIMP_(ULONG) Release(void);

      //IClassFactory Things
      STDMETHODIMP CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppv);
      STDMETHODIMP LockServer(BOOL fLock);

   private:
      UINT cRef;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\inseng\inspch.h ===
#include <windows.h>
#include <commctrl.h>
#include <olectl.h>
#include <setupapi.h>
#include <wintrust.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\inseng\insfact.cpp ===
#include "inspch.h"
#include "insobj.h"
#include "insfact.h"


//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngineFactory::QueryInterface(REFIID riid, void **ppv)
{
   if((riid == IID_IClassFactory) || (riid == IID_IUnknown))
   {
      cRef++;
      *ppv = (void *)this;
      return NOERROR;
   }

   *ppv = NULL;
   return E_NOINTERFACE;
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

STDMETHODIMP_(ULONG) CInstallEngineFactory::AddRef()
{
   return(++cRef);
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

STDMETHODIMP_(ULONG) CInstallEngineFactory::Release()
{
   return(--cRef);
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngineFactory::CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppv)
{
   CInstallEngine *pinseng = NULL;
   IUnknown *punk;
   HRESULT hr;

   if(pUnkOuter != NULL)
      return CLASS_E_NOAGGREGATION;
   
   pinseng = new CInstallEngine(&punk);
   if(!pinseng)
      return (E_OUTOFMEMORY);

   hr = punk->QueryInterface(riid, ppv);
   if(FAILED(hr))
      delete pinseng;
   else
      DllAddRef();
   
   punk->Release();
   return hr;
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngineFactory::LockServer(BOOL fLock)
{
   if(fLock)
      DllAddRef();
   else
      DllRelease();
   return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\inseng\makefile.inc ===
clean:
    -del /F /Q $(O)\selfreg_inseng.inf

$(O)\selfreg_inseng.inf: selfreg.inx
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\inseng\resource.h ===
#define IDS_DEPENDNAME        1001
#define IDS_DISPLAYNAME       1002
#define IDS_INSTALLENGINE     1003
#define IDS_SECURITYTITLE     1004
#define IDS_SECURITY          1005
#define IDS_DOWNLOADSITEMGR   1006
#define IDS_DEFAULTTITLE      1007
#define IDS_VERSIONCONFLICT   1008
#define IDS_VERSIONCONFLICTNT 1009
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\inseng\install.cpp ===
#include "inspch.h"
#include "insobj.h"

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

CInstaller::CInstaller(CInstallEngine *p) : CTimeTracker(60000)
{
   _pInsEng = p;
   _hkProg  = NULL;
   _hMutex  = NULL;
   _hStatus = NULL;
   _cRef    = 1;

   DllAddRef();
}

CInstaller::~CInstaller()
{
   DllRelease();
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

STDMETHODIMP_(ULONG) CInstaller::AddRef()
{
   return(++_cRef);
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

STDMETHODIMP_(ULONG) CInstaller::Release()
{
   if(!--_cRef)
   {
      delete this;
      return(0);
   }
   return( _cRef );
}

HRESULT CInstaller::Abort()
{
   if(_hMutex)
   {
      WaitForMutex(_hMutex);
      if(_hkProg)
      {
         DWORD dwCancel = 1;
         RegSetValueEx(_hkProg, CANCEL_VALUENAME, 0, REG_DWORD, (BYTE *) &dwCancel, sizeof(dwCancel));
      }
      ReleaseMutex(_hMutex);
   }
   return NOERROR;
}

HRESULT CInstaller::Suspend()
{
   // assume no install going on
   HRESULT hr = S_OK;
   
   // if we have a mutex grab it and check for safe
   if(_hMutex)
   {
      // there is an install, assume it isn't safe to cancel it
      hr = S_FALSE;
      WaitForMutex(_hMutex);
      if(_hkProg)
      {
         DWORD dwSafe = 0; 
         DWORD dwSize = sizeof(dwSafe);
         if(RegQueryValueEx(_hkProg, SAFE_VALUENAME, NULL, NULL, (BYTE *) &dwSafe, &dwSize) == ERROR_SUCCESS)
         {
            if(dwSafe == 1)
               hr = S_OK;
         }
         
      }
   }
   return hr;
}

HRESULT CInstaller::Resume()
{
   // if we have a mutex release it
   if(_hMutex)
      ReleaseMutex(_hMutex);

   return NOERROR;
}



HRESULT CInstaller::DoInstall(LPCSTR pszDir, LPSTR pszCmd, LPSTR pszArgs, LPCSTR pszProg, LPCSTR pszCancel, 
                                    UINT uType, LPDWORD pdwStatus, IMyDownloadCallback *pcb)
{
   char szFileName[MAX_PATH + 128];
   char szBuf[MAX_PATH];
   HANDLE hProc = NULL;
   HMODULE hAdvpack;
   HRESULT hr = S_OK;
   DWORD dwTemp;
   INF_ARGUEMENTS InsArgs;
       
   _uTotalProgress = 0;

   // create progress key if we need to
   if(pszProg && pszCancel)
   {
      lstrcpy(szBuf, REGSTR_PROGRESS_KEY);
      lstrcat(szBuf, pszProg);
      RegCreateKeyEx(HKEY_LOCAL_MACHINE, szBuf, 0, NULL,0, KEY_READ | KEY_WRITE,NULL, &_hkProg, &dwTemp); 
   
      lstrcpy(szBuf, pszCancel);
      lstrcat(szBuf, "Mutex");
      _hMutex = CreateMutex(NULL, FALSE, szBuf); 
  
      lstrcpy(szBuf, pszCancel);
      lstrcat(szBuf, "Event");
      _hStatus = CreateEvent(NULL, FALSE, FALSE, szBuf); 

   }

   // copy the advpack we are using into the temp dir of what we want to launch
   // this insures that we always get a "good" copy of advpack
   hAdvpack = GetModuleHandle("advpack.dll");
   if(hAdvpack)
   {
      if(GetModuleFileName(hAdvpack, szBuf, sizeof(szBuf)))
      {
         lstrcpy(szFileName, pszDir);
         AddPath(szFileName, "advpack.dll");

         CopyFile(szBuf, szFileName, TRUE);

         szBuf[0] = 0;
         szFileName[0] = 0;
      }
   }

   
   switch(uType)
   {
      case InfCommand:
      case InfExCommand:         
         GetStringField(pszCmd, 0, szBuf, sizeof(szBuf)); 
         
         // ParseURLA below is to ensure we only run inf out of our temp dir
         lstrcpy(szFileName, pszDir); 
         AddPath(szFileName, ParseURLA(szBuf));

         GetStringField(pszCmd, 1, szBuf, sizeof(szBuf));
        
         lstrcpy(InsArgs.szInfname, szFileName);
         lstrcpy(InsArgs.szSection, szBuf);
         lstrcpy(InsArgs.szDir, pszDir);
         InsArgs.dwType = uType;
         if(uType == InfCommand)
         {
            InsArgs.dwFlags = RSC_FLAG_INF |  RSC_FLAG_NGCONV;
            
            if(_pInsEng->GetCommandMode() == 0)
               InsArgs.dwFlags |= RSC_FLAG_QUIET;
            
         }
              
         if(uType == InfExCommand)
         {
            // add cab name
            lstrcpy(InsArgs.szCab, ""); 
            InsArgs.dwFlags = AtoL(pszArgs);
         }

         if(_pInsEng->GetStatus() & STOPINSTALL_REBOOTNEEDED)
            InsArgs.dwFlags |= RSC_FLAG_DELAYREGISTEROCX;
              
         wsprintf(szLogBuf, "Launching Inf - inf: %s, section: %s\r\n", szFileName, lstrlen(szBuf) ? szBuf : "Default");
         _pInsEng->WriteToLog(szLogBuf, TRUE);

         hProc = CreateThread(NULL, 0, LaunchInfCommand, &InsArgs, 0, &dwTemp);
               
         hr = E_FAIL;
         if(hProc)
         {
            _WaitAndPumpProgress(hProc, pcb);
            DWORD dwRet;
            if(GetExitCodeThread(hProc, &dwRet))
            {
               hr = dwRet;
               if(SUCCEEDED(hr))
               {
                  if(hr == ERROR_SUCCESS_REBOOT_REQUIRED)
                     *pdwStatus |= STOPINSTALL_REBOOTNEEDED;    
               }
               else
               {
                  wsprintf(szLogBuf, "Inf failed - return code %x\r\n", dwRet);
                  _pInsEng->WriteToLog(szLogBuf, TRUE);
               }
                      
            }
            else
               _pInsEng->WriteToLog("Failed to get exit code\r\n", TRUE);
         }
         else
            _pInsEng->WriteToLog("Create thread failed\r\n", TRUE);
         
         break;

      case WExtractExe:
      case Win32Exe:
      case HRESULTWin32Exe:
         
         // ParseURLA below is to ensure we only run exe out of our temp dir
         wsprintf(szFileName, CMDLINE, pszDir, ParseURLA(pszCmd), pszArgs);

         wsprintf(szLogBuf, "Launching exe: command: %s\r\n", szFileName);
         _pInsEng->WriteToLog(szLogBuf, TRUE);

         hr = LaunchProcess(szFileName, &hProc, pszDir, SW_SHOWNORMAL);
         if(SUCCEEDED(hr))
            _WaitAndPumpProgress(hProc, pcb);
         if(SUCCEEDED(hr))
         {
            // BUGBUG: Trace this path with WEXTRACT > 1140
            if ( (uType == WExtractExe) || (uType == HRESULTWin32Exe) )
            {
               DWORD dwRet;
               hr = E_FAIL;
               if(GetExitCodeProcess(hProc, &dwRet))
               {
                  wsprintf(szLogBuf, "Exe return code: %x\r\n", dwRet);
                  _pInsEng->WriteToLog(szLogBuf, TRUE);
                  hr = (HRESULT) dwRet;
                    
                  if (uType == WExtractExe)
                  {
                     if(SUCCEEDED(hr))
                     {
                        if(hr == ERROR_SUCCESS_REBOOT_REQUIRED)
                           *pdwStatus |= STOPINSTALL_REBOOTNEEDED;    
                     }
                  }
               
               }
               else
                  _pInsEng->WriteToLog("Failed to get exit code\r\n", TRUE);
            }
         }
         else
            _pInsEng->WriteToLog("Create process failed\r\n", TRUE);
                          
         break;

      default:
         // whatever
         hr = E_INVALIDARG;
   }

   if (_hkProg)
   {
       RegCloseKey(_hkProg);
       _hkProg = NULL;
   }

   if (_hMutex)
   {
       CloseHandle(_hMutex);
       _hMutex = NULL;
   }

   if (_hStatus)
   {
       CloseHandle(_hStatus);
       _hStatus = NULL;
   }

   return hr;
}

#define PROGRESS_INTERVAL 1000
#define SEARCHFORCONFLICT_INTERVAL   3


void CInstaller::_WaitAndPumpProgress(HANDLE hProc, IMyDownloadCallback *pcb)
{
   HANDLE pHandles[2] = {hProc, _hStatus};
   DWORD dwStartTick = GetTickCount();
   DWORD dwOldTick = dwStartTick;
   DWORD dwTickChange = 0;
   DWORD dwProgress;
   DWORD dwCurrentTick;
   BOOL fQuit = FALSE;
   DWORD dwRet;
   DWORD dwSearchCount = 0;
   HWND  hLastVersionConflict = NULL;
   HWND  hVersionConflict = NULL;

   while(!fQuit)
   {
      dwRet = MsgWaitForMultipleObjects(_hStatus ? 2 : 1, pHandles, FALSE, 1000, QS_ALLINPUT);
      
      dwCurrentTick = GetTickCount();
      dwTickChange = dwCurrentTick - dwOldTick;
      if(dwOldTick > dwCurrentTick)
         dwTickChange = ~dwTickChange;

      if(dwTickChange > PROGRESS_INTERVAL)
      {
         dwSearchCount++;
         if(dwSearchCount > SEARCHFORCONFLICT_INTERVAL || hLastVersionConflict)
         {
            hVersionConflict = GetVersionConflictHWND();
            if(hVersionConflict)
            {
               if(hVersionConflict != hLastVersionConflict)
               {
                  if(GetForegroundWindow() == _pInsEng->GetHWND())
                     SetForegroundWindow(hVersionConflict);
               
                  BOOL foo = MessageBeep(MB_ICONASTERISK);
               }
            }
            hLastVersionConflict = hVersionConflict;
          
            dwSearchCount = 0;
         }

         // if there is a version conflict, we assume you made no progress during the last time period
         if(!hLastVersionConflict)
         {
            dwProgress = (dwTickChange / 1000) * GetBytesPerSecond();
            dwProgress >>= 10;
            _uTotalProgress += dwProgress;

            pcb->OnProgress(_uTotalProgress, NULL); 
         }
         dwOldTick = dwCurrentTick;
      }

      // Handle Message or done
      if(dwRet == WAIT_OBJECT_0)
      {
         
         
         fQuit = TRUE;
      }
      else if ( (dwRet == WAIT_OBJECT_0 + 1) && (_hStatus != 0))      // update jobexec's status msg
      {
          if (!(fQuit = WaitForMutex(_hMutex)))
          {
              if (_hkProg != NULL)
              {
                  char szBuf[MAX_PATH];
                  DWORD dwSize = sizeof(szBuf);

                  if (RegQueryValueEx(_hkProg, PROGRESS_DISPLAY, NULL, NULL, (LPBYTE) szBuf, &dwSize) == ERROR_SUCCESS)
                     pcb->OnProgress(_uTotalProgress, szBuf); 
              }

              ReleaseMutex(_hMutex);
          }
      }
      else
      {
         MSG msg;
         while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
         {

            // if it's a quit message we're out of here
            if (msg.message == WM_QUIT)
               fQuit = TRUE;
            else
            {
               // otherwise dispatch it
              DispatchMessage(&msg);
            } // end of PeekMessage while loop
         }
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\inseng\site.h ===
IDownloadSite *CopyDownloadSite(DOWNLOADSITE *pdls);
DOWNLOADSITE *AllocateDownloadSite(LPCSTR pszUrl, LPCSTR pszName, LPCSTR pszLang, LPCSTR pszRegion);
void DeleteDownloadSite(DOWNLOADSITE *pdls);
void FreeDownloadSite(DOWNLOADSITE *pdls);

class CDownloadSite  : public IDownloadSite
{
   public:
      CDownloadSite(DOWNLOADSITE *pds);
      ~CDownloadSite();

      // IUnknown
      STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj);
      STDMETHOD_(ULONG,AddRef) (THIS);
      STDMETHOD_(ULONG,Release) (THIS);

      // IDownloadSite
      STDMETHOD(GetData)(THIS_ DOWNLOADSITE **pds);

   private:
      DWORD  m_cRef;
      DOWNLOADSITE *m_pdls;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\inseng\site.cpp ===
#include "inspch.h"
#include "inseng.h"
#include "download.h"
#include "site.h"
#include "util2.h"

CDownloadSite::CDownloadSite(DOWNLOADSITE *p)
{
   m_cRef = 0;
   m_pdls = p;
   DllAddRef();
}

CDownloadSite::~CDownloadSite()
{
   if(m_pdls)
      FreeDownloadSite(m_pdls);
   DllRelease();
}   

//************ IUnknown implementation ***************

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

STDMETHODIMP_(ULONG) CDownloadSite::AddRef()                      
{
   return(m_cRef++);
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

STDMETHODIMP_(ULONG) CDownloadSite::Release()
{
   ULONG temp = --m_cRef;

   if(temp == 0)
      delete this;
   return temp;
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

STDMETHODIMP CDownloadSite::QueryInterface(REFIID riid, void **ppv)
{
   *ppv = NULL;

   if((riid == IID_IUnknown) || (riid == IID_IDownloadSite))
      *ppv = (IDownloadSite *)this;
   
   if(*ppv == NULL)
      return E_NOINTERFACE;
   
   AddRef();
   return NOERROR;
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

STDMETHODIMP CDownloadSite::GetData(DOWNLOADSITE **ppdls)
{
   if(ppdls)
      *ppdls = m_pdls;
   else
      return E_POINTER;

   return NOERROR;
}

// BUGBUG: I have two versions - one allocating using new (HeapAlloc)
//    for internal use, one using CoTaskMem... that I give away.
//    I am using new internally because I suspect it may be faster/less 
//    expensive. but this makes code more complex. Good choice?

// BUGBUG: Allow null url or friendly name?

IDownloadSite *CopyDownloadSite(DOWNLOADSITE *pdls)
{
   DOWNLOADSITE *p;
   IDownloadSite *psite = NULL; 

   p = (DOWNLOADSITE *) CoTaskMemAlloc(sizeof(DOWNLOADSITE));
   if(p)
   {
      p->cbSize = sizeof(DOWNLOADSITE);
      p->pszUrl = COPYANSISTR(pdls->pszUrl);
      p->pszFriendlyName = COPYANSISTR(pdls->pszFriendlyName);
      p->pszLang = COPYANSISTR(pdls->pszLang);
      p->pszRegion = COPYANSISTR(pdls->pszRegion);
      if(!p->pszUrl || !p->pszFriendlyName || !p->pszLang || !p->pszRegion)
      {
         FreeDownloadSite(p);
         p = NULL;
      }
   }
   if(p)
   {
      //allocate the interface wrapper
      CDownloadSite *site = new CDownloadSite(p);
      if(site)
      {
         psite = (IDownloadSite *)site;
         psite->AddRef();
      }
   
   }
   
   return psite;
}


DOWNLOADSITE *AllocateDownloadSite(LPCSTR pszUrl, LPCSTR pszName, LPCSTR pszLang, LPCSTR pszRegion)
{
   DOWNLOADSITE *p = new DOWNLOADSITE;
   if(p)
   {
      p->cbSize = sizeof(DOWNLOADSITE);
      p->pszUrl = CopyAnsiStr(pszUrl);
      p->pszFriendlyName = CopyAnsiStr(pszName);
      p->pszLang = CopyAnsiStr(pszLang);
      p->pszRegion = CopyAnsiStr(pszRegion);
      if(!p->pszUrl || !p->pszFriendlyName || !p->pszLang || !p->pszRegion)
      {
         DeleteDownloadSite(p);
         p = NULL;
      }
   }
   return p;
}

// this version deletes a DOWNLOADSITE allocated from the heap

void DeleteDownloadSite(DOWNLOADSITE *pdls)
{
   if(pdls)
   {
      if(pdls->pszUrl) 
         delete pdls->pszUrl;
      if(pdls->pszFriendlyName)
         delete pdls->pszFriendlyName;
      if(pdls->pszLang) 
         delete pdls->pszLang;
      if(pdls->pszRegion) 
         delete pdls->pszRegion;
      

      delete pdls;
   }
}

// this version deletes a DOWNLOADSITE allocated thru CoTaskMemAlloc

void FreeDownloadSite(DOWNLOADSITE *pdls)
{
   if(pdls)
   {
      if(pdls->pszUrl) 
         CoTaskMemFree(pdls->pszUrl);
      if(pdls->pszFriendlyName)
         CoTaskMemFree(pdls->pszFriendlyName);
      if(pdls->pszLang) 
         CoTaskMemFree(pdls->pszLang);
      if(pdls->pszRegion) 
         CoTaskMemFree(pdls->pszRegion);

      CoTaskMemFree(pdls);
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\inseng\sitefact.cpp ===
#include "inspch.h"
#include "insengmn.h"
#include "inseng.h"
#include "download.h"
#include "sitemgr.h"
#include "sitefact.h"
#include "util2.h"

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

STDMETHODIMP CSiteManagerFactory::QueryInterface(REFIID riid, void **ppv)
{
   if((riid == IID_IClassFactory) || (riid == IID_IUnknown))
   {
      cRef++;
      *ppv = (void *)this;
      return NOERROR;
   }

   *ppv = NULL;
   return E_NOINTERFACE;
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

STDMETHODIMP_(ULONG) CSiteManagerFactory::AddRef()
{
   return(++cRef);
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

STDMETHODIMP_(ULONG) CSiteManagerFactory::Release()
{
   return(--cRef);
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

STDMETHODIMP CSiteManagerFactory::CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppv)
{
   CDownloadSiteMgr *pdsm = NULL;
   IUnknown *punk;
   HRESULT hr;

   if(pUnkOuter != NULL)
      return CLASS_E_NOAGGREGATION;
   
   pdsm = new CDownloadSiteMgr(&punk);
   if(!pdsm)
      return (E_OUTOFMEMORY);

   hr = punk->QueryInterface(riid, ppv);
   if(FAILED(hr))
      delete pdsm;
   else
      DllAddRef();
   
   punk->Release();
   return hr;
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

STDMETHODIMP CSiteManagerFactory::LockServer(BOOL fLock)
{
   if(fLock)
      DllAddRef();
   else
      DllRelease();
   return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\inseng\timetrak.h ===
class CTimeTracker
{
   public:
      CTimeTracker(DWORD dwDefaultRate);
      ~CTimeTracker();
      
      void StartClock();
      void StopClock();
      void SetBytes(DWORD dwBytes, BOOL bAccumulate);
      DWORD GetBytesPerSecond();

   private:
      DWORD m_dwBytesSoFar;
      DWORD m_dwTicksSoFar;
      DWORD m_dwStartTick;
      DWORD m_defaultrate;
      DWORD m_ave;
      BOOL  m_bTiming;
      UINT  m_hasave;
      void AddEntry(DWORD dwmSec, DWORD dwBytes, BOOL bAccumulate);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\inseng\timetrak.cpp ===
#include "inspch.h"
#include "timetrak.h"

#define NUMBYTESFORUPDATE  200000
#define DECAY_FACTOR       85

CTimeTracker::CTimeTracker(DWORD dwDefaultRate)
{
   m_hasave = FALSE;
   m_defaultrate = dwDefaultRate;
   m_bTiming = FALSE;
   m_dwBytesSoFar = 0;
   m_dwTicksSoFar = 0;
}

CTimeTracker::~CTimeTracker()
{
}

void CTimeTracker::AddEntry(DWORD dwTime, DWORD dwBytes, BOOL bAccumulate)
{
   DWORD dwBPS;

   m_dwBytesSoFar += dwBytes;
   m_dwTicksSoFar += dwTime;
   
   if(m_dwBytesSoFar > NUMBYTESFORUPDATE || !bAccumulate)
   {
      if(m_dwBytesSoFar < 4000000)
         dwBPS = (m_dwBytesSoFar * 1000) / m_dwTicksSoFar;
      else if (m_dwTicksSoFar > 20000)
         dwBPS = m_dwBytesSoFar / (m_dwTicksSoFar / 1000);
      else
         dwBPS = (m_dwBytesSoFar/m_dwTicksSoFar)*1000;

      if(!m_hasave)
      {
         m_ave = dwBPS;
         m_hasave = TRUE;
      }
      else
      {
         m_ave = ((dwBPS * (100 - DECAY_FACTOR)) + (m_ave * DECAY_FACTOR))/100;
      }

      m_dwBytesSoFar = 0;
      m_dwTicksSoFar = 0;
   }
}

DWORD CTimeTracker::GetBytesPerSecond()
{
   if(!m_hasave)
      return m_defaultrate;
   else
      return m_ave;
}

void CTimeTracker::StartClock()
{
   m_dwStartTick = GetTickCount();
   m_bTiming = TRUE;
}

void CTimeTracker::StopClock()
{
   m_bTiming = FALSE;
}

void CTimeTracker::SetBytes(DWORD dwBytes, BOOL bAccumulate)
{
   DWORD dwTickChange;
   DWORD dwCurrentTick;

   if(!m_bTiming)
      return;

   dwCurrentTick = GetTickCount();
   dwTickChange = dwCurrentTick - m_dwStartTick;
   if(m_dwStartTick > dwCurrentTick)
      dwTickChange -= 0xffffffff;
   

   if(dwTickChange != 0)
      AddEntry(dwTickChange, dwBytes, bAccumulate);

   m_dwStartTick = dwCurrentTick;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\inseng\sitefact.h ===
class CSiteManagerFactory : IClassFactory
{
   public:
      CSiteManagerFactory() { cRef = 0; };

      //IUnknown things
      STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
      STDMETHODIMP_(ULONG) AddRef(void);
      STDMETHODIMP_(ULONG) Release(void);

      //IClassFactory Things
      STDMETHODIMP CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppv);
      STDMETHODIMP LockServer(BOOL fLock);

   private:
      UINT cRef;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\inseng\sitemgr.h ===
#define MAX_RETRIES             2

// a small class that handles downloading ins and building component list
class CDownloadSiteMgr  : public IMyDownloadCallback, public IDownloadSiteMgr
{
   public:
      CDownloadSiteMgr(IUnknown **punk);
      ~CDownloadSiteMgr();

      // IMyDownloadCallback
      HRESULT OnProgress(ULONG progress, LPCSTR pszStatus);

      // IUnknown
      STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj);
      STDMETHOD_(ULONG,AddRef) (THIS);
      STDMETHOD_(ULONG,Release) (THIS);

      // IDownloadSiteMgr
      STDMETHOD(Initialize)(THIS_ LPCSTR pszUrl, SITEQUERYPARAMS *pqp);
      STDMETHOD(EnumSites)(THIS_ DWORD dwIndex, IDownloadSite **pds);
      
   private:
      DWORD  m_cRef;
      LPSTR  m_pszUrl;
      SITEQUERYPARAMS *m_pquery;
      DOWNLOADSITE **m_ppdls;
      UINT m_arraysize;
      UINT m_numsites;
      BOOL m_onegoodsite;
      
      HRESULT ParseSiteFile(LPCSTR psz);
      HRESULT AddSite(DOWNLOADSITE *);
      DOWNLOADSITE *ParseAndAllocateDownloadSite(LPSTR psz);
      DWORD TranslateLanguage(LPSTR szLang);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\inseng\util2.h ===
#ifndef _UTIL2_H_

#include "sdsutils.h"
#include "advpub.h"
#include "util.h"

// TODO: advpext.h needs to move to a public location
#include "..\\..\\iexpress\\advpext\\advpext.h"

#define COPYANSISTR(x) MakeAnsiStrFromAnsi(x)

#define ALLOC_CHUNK_SIZE 1024

#define SEARCHFORCONFLICT_CLASS   32770

// Copied from sage.h
#define ENABLE_AGENT            1
#define DISABLE_AGENT           2
#define GET_AGENT_STATUS        3


extern char szLogBuf[];

void EnableSage(BOOL bRestore);
void EnableScreenSaver(BOOL bRestore);
void EnableDiskCleaner(BOOL bRestore);
BOOL PathIsFileSpec(LPCSTR lpszPath);
BOOL IsNT();

LPWSTR ParseURLW(BSTR str);
LPSTR ParseURLA(LPCSTR str);
LPSTR MakeAnsiStrFromAnsi(LPSTR psz);
LPSTR CopyAnsiStr(LPCSTR); 
HWND GetVersionConflictHWND();
HRESULT CreateTempDir(DWORD dwDownloadSize, DWORD dwExtractSize, 
                    char chInstallDrive, DWORD dwInstallSize, 
                    DWORD dwWindowsDriveSize, 
                    LPSTR pszPath, DWORD cbPathSize, 
                    DWORD dwFlags);
 
void AddTempToLikelyExtractDrive(DWORD dwTempDLSpace, DWORD dwTempEXSpace,
                                 char chInstallDrive, char chDownloadDrive,
                                 DWORD *pdwWinDirReq, DWORD *pdwInsDirReq,
                                 DWORD *pdwDownloadDirReq);
int CompareLocales(LPCSTR pcszLoc1, LPCSTR pcszLoc2);

BOOL IsEnoughSpace( LPCSTR szPath, DWORD dwInstNeedSize );
HRESULT LaunchProcess(LPCSTR pszCmdLine, HANDLE *hProc, LPCSTR pszDir, UINT uShow);
HRESULT LaunchAndWait(LPSTR pszCommandLine, HANDLE hAbort, HANDLE *hProc, LPSTR pszDir, UINT uShow);
int  VersionCmp(WORD rwVer1[], WORD rwVer2[]);
void ConvertVersionStr(LPSTR pszVer, WORD rwVer[]);
void ConvertVersionStrToDwords(LPSTR pszVer, LPDWORD pdwVer, LPDWORD pdwBuild);
int ErrMsgBox(LPSTR	pszText, LPCSTR	pszTitle, UINT	mbFlags);
int LoadSz(UINT id, LPSTR pszBuf, UINT cMaxSize);
void DeleteFilelist(LPCSTR pszFilelist);
BOOL FNeedGrpConv();

// Function is in extract.cpp
LPSTR FindChar(LPSTR, char);
LPSTR StripQuotes(LPSTR pszStr);

typedef struct 
{
   char  szInfname[MAX_PATH];
   char  szSection[MAX_PATH];
   char  szDir[MAX_PATH];
   char  szCab[MAX_PATH];
   DWORD dwFlags;
   DWORD dwType;
} INF_ARGUEMENTS;

DWORD WINAPI LaunchInfCommand(void *p);
DWORD GetStringField(LPSTR szStr, UINT uField, LPSTR szBuf, UINT cBufSize);
DWORD GetIntField(LPSTR szStr, UINT uField, DWORD dwDefault);
LPSTR BuildDependencyString(LPSTR pszName,LPSTR pszOwner);
int StringFromGuid(const CLSID* piid, LPTSTR   pszBuf);
BOOL DeleteKeyAndSubKeys(HKEY hkIn, LPSTR pszSubKey);
DWORD WINAPI CleanUpAllDirs(LPVOID pv);
BOOL UninstallKeyExists(LPCSTR pszUninstallKey);
BOOL SuccessCheck(LPSTR pszSuccessKey);
void SafeAddPath(LPSTR szPath, LPCSTR szName, DWORD dwPathSize );
void ExpandString( LPSTR lpBuf, DWORD dwSize );
VOID IndicateWinsockActivity(VOID);
HRESULT MyTranslateString( LPCSTR pszCif, LPCSTR pszID, LPCSTR pszTranslateKey,
                              LPSTR pszBuffer, DWORD dwBufferSize);

HRESULT MyTranslateInfString( PCSTR pszInfFilename, PCSTR pszInstallSection,
                              PCSTR pszTranslateSection, PCSTR pszTranslateKey,
                              PSTR pszBuffer, DWORD dwBufferSize,
                              PDWORD pdwRequiredSize, HINF hInf );

HRESULT WriteTokenizeString(LPCSTR pszCif, LPCSTR pszID, LPCSTR pszTranslateKey, LPCSTR pszBuffer);
DWORD MyWritePrivateProfileString( LPCSTR pszSec, LPCSTR pszKey, LPCSTR pszData, LPCSTR pszFile);
void CopyCifString(LPCSTR pszSect, LPCSTR pszKey, LPCSTR pszCifSrc, LPCSTR pszCifDest);

HRESULT CreateTempDirOnMaxDrive(LPSTR pszDir, DWORD dwBufSize);

HINSTANCE InitSetupLib(LPCSTR pszInfName, HINF *phinf);
void FreeSetupLib(HINSTANCE hInst, HINF hInf);

HRESULT GetIEPath(LPSTR pszPath, DWORD dwSize);
DWORD MyGetFileSize(LPCSTR pszFilename);

void CleanUpTempDir(LPCSTR pszTemp);

typedef HRESULT (WINAPI *PFNGETFILELIST)(HINF, PDOWNLOAD_FILEINFO*, DWORD*);
typedef HRESULT (WINAPI *PFNDOWNLOADANDPATCHFILES)(HWND, DWORD, DOWNLOAD_FILEINFO*,
                                                   LPCSTR, LPCSTR, PATCH_DOWNLOAD_CALLBACK, LPVOID); 
typedef HRESULT (WINAPI *PFNPROCESSFILESECTION)(HINF, HWND, BOOL, LPCSTR, LPCSTR, PATCH_DOWNLOAD_CALLBACK, LPVOID);

BOOL IsPatchableINF(LPTSTR pszInf);
BOOL InitSRLiteLibs();
BOOL IsCorrectAdvpExt();
void FreeSRLiteLibs();
BOOL IsPatchableIEVersion();

extern PFNGETFILELIST g_pfnGetFileList;
extern PFNDOWNLOADANDPATCHFILES g_pfnDownloadAndPatchFiles;
extern PFNPROCESSFILESECTION g_pfnProcessFileSection;


#define EVENTWAIT_QUIT  0
#define EVENTWAIT_DONE  1

DWORD WaitForEvent(HANDLE hEvent, HWND hwnd);
BOOL WaitForMutex(HANDLE hMutex);

DWORD GetCurrentPlatform();

void DllAddRef(void);
void DllRelease(void);
void * _cdecl malloc(size_t n);
void * _cdecl calloc(size_t n, size_t s);
void * _cdecl realloc(void* p, size_t n);
void   _cdecl free(void* p);

extern char g_szWindowsDir[MAX_PATH];

void GetTimeDateStamp(LPSTR lpLogBuf);

#ifdef __cplusplus
extern "C" {
#endif

HRESULT WINAPI DownloadFile(LPCSTR szURL, LPCSTR szFilename, HWND hwnd, BOOL bCheckTrust, BOOL bShowBadUI);

#ifdef __cplusplus
}      // end of extern "C"
#endif

#define _UTIL2_H_
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\inseng\sitemgr.cpp ===
#include "inspch.h"
#include "inseng.h"
#include "download.h"
#include "advpub.h"
#include "site.h"
#include "sitemgr.h"
#include "util2.h"
#include "util.h"

#define SITEFILENAME  "sites.dat"
#define SITEARRAY_GROWTHFACTOR 100

#define NUM_RETRIES 2

#define SITEQUERYSIZE_V1    8
#define SITEQUERYSIZE_V2   12

CDownloadSiteMgr::CDownloadSiteMgr(IUnknown **punk)
{
   m_cRef = 0;
   m_pszUrl = 0;
 
   m_pquery = NULL;
   m_ppdls = (DOWNLOADSITE **) malloc(SITEARRAY_GROWTHFACTOR * sizeof(DOWNLOADSITE *));
   m_numsites = 0;
   m_arraysize = SITEARRAY_GROWTHFACTOR;
   
   AddRef();
   *punk = (IDownloadSiteMgr *) this;
}

CDownloadSiteMgr::~CDownloadSiteMgr()
{
   if(m_ppdls)
   {
      for(UINT i=0; i < m_numsites; i++)
         DeleteDownloadSite(m_ppdls[i]);

      free(m_ppdls);
   }

   // Delete the query structure
   if(m_pquery)
   {
      if(m_pquery->pszLang)
         delete m_pquery->pszLang;

      delete m_pquery;
   }

   if(m_pszUrl)
      delete m_pszUrl;

   DllRelease();
}   

//************ IUnknown implementation ***************

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

STDMETHODIMP_(ULONG) CDownloadSiteMgr::AddRef()                      
{
   return(m_cRef++);
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

STDMETHODIMP_(ULONG) CDownloadSiteMgr::Release()
{
   ULONG temp = --m_cRef;

   if(temp == 0)
      delete this;
   return temp;
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

STDMETHODIMP CDownloadSiteMgr::QueryInterface(REFIID riid, void **ppv)
{
   *ppv = NULL;

   if((riid == IID_IUnknown) || (riid == IID_IDownloadSiteMgr))
      *ppv = (IDownloadSiteMgr *)this;
   
   if(*ppv == NULL)
      return E_NOINTERFACE;
   
   AddRef();
   return NOERROR;
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

STDMETHODIMP CDownloadSiteMgr::Initialize(LPCSTR pszUrl, SITEQUERYPARAMS *psqp)
{
   HRESULT hr = S_OK;
   char szPath[MAX_PATH];
      
   if(!pszUrl)
      return E_INVALIDARG; 

   if(!m_ppdls)
      return E_OUTOFMEMORY;

   m_pszUrl = CopyAnsiStr(pszUrl);
   if(!m_pszUrl)
      return E_OUTOFMEMORY;
    
   if(psqp != NULL)
   {
      m_pquery = new SITEQUERYPARAMS;
      if(!m_pquery)
         return E_OUTOFMEMORY;

      ZeroMemory(m_pquery, sizeof(SITEQUERYPARAMS));
      
      if(psqp->pszLang)
      {   
         m_pquery->pszLang = CopyAnsiStr(psqp->pszLang);
         if(!m_pquery->pszLang)
            return E_OUTOFMEMORY;
      }
      if((psqp->cbSize >= SITEQUERYSIZE_V2) && psqp->pszRegion)
      {
         m_pquery->pszRegion = CopyAnsiStr(psqp->pszRegion);
         if(!m_pquery->pszRegion)
            return E_OUTOFMEMORY;
      }
   }

   CDownloader *pDownloader = new CDownloader();
   if(pDownloader)
   {
      hr = E_FAIL;
      for(int i = 0; (i < NUM_RETRIES) && FAILED(hr) ; i++)
      {
         hr = pDownloader->SetupDownload(m_pszUrl, (IMyDownloadCallback *) this, DOWNLOADFLAGS_USEWRITECACHE, SITEFILENAME);
         if(FAILED(hr))
            break;
         hr = pDownloader->DoDownload(szPath, sizeof(szPath));
      }
      pDownloader->Release();
     
   }
      
   // Parse the file
   if(SUCCEEDED(hr))
   {
      hr = ParseSiteFile(szPath);
   }

   // delete the dir we downloaded to

   if(GetParentDir(szPath))
      DelNode(szPath, 0);
   
   return hr;
}


STDMETHODIMP CDownloadSiteMgr::EnumSites(DWORD dwIndex, IDownloadSite **pds)
{
   HRESULT hr = NOERROR;
   
   if(!pds)
      return E_POINTER;

   *pds = NULL;
   
   if(dwIndex < m_numsites)
   {
      *pds = CopyDownloadSite(m_ppdls[dwIndex]);
      if(! (*pds) )
         hr = E_OUTOFMEMORY;
   }
   else
      hr = E_FAIL;
   
   return hr;
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

HRESULT CDownloadSiteMgr::OnProgress(ULONG progress, LPCSTR pszStatus)
{
   // Not interesting
   return NOERROR;
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

// This probably changes after beta1

HRESULT CDownloadSiteMgr::ParseSiteFile(LPCSTR pszPath)
{
   HANDLE hfile;
   DWORD dwSize;
   DOWNLOADSITE *p;
   LPSTR pBuf, pCurrent, pEnd;

   m_onegoodsite = FALSE;

   hfile = CreateFile(pszPath, GENERIC_READ, 0, NULL, 
                 OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);  

   if(hfile == INVALID_HANDLE_VALUE)
      return E_FAIL;

   
   dwSize = GetFileSize(hfile, NULL);
   if(dwSize == DWORD(-1)) {
      CloseHandle(hfile);
      return E_UNEXPECTED;
   }

   pBuf = new char[dwSize + 1];

   if(!pBuf)
   {
      CloseHandle(hfile);
      return E_OUTOFMEMORY;
   }
   // Copy contents of file to our buffer
   
   if(!ReadFile(hfile, pBuf, dwSize, &dwSize, NULL)) {
      delete pBuf;
      CloseHandle(hfile);
      return E_UNEXPECTED;
   }
   
   pCurrent = pBuf;
   pEnd = pBuf + dwSize;
   *pEnd = 0;

   // One pass thru replacing \n or \r with \0
   while(pCurrent <= pEnd)
   {
      if(*pCurrent == '\r' || *pCurrent == '\n')
         *pCurrent = 0;
      pCurrent++;
   }

   pCurrent = pBuf;
   while(1)
   {
      while(pCurrent <= pEnd && *pCurrent == 0)
         pCurrent++;

      // we are now pointing at begginning of line or pCurrent > pBuf
      if(pCurrent > pEnd)
         break;

      p = ParseAndAllocateDownloadSite(pCurrent);
      if(p)
         AddSite(p);
      
      pCurrent += lstrlen(pCurrent);
   }

   delete pBuf;
   CloseHandle(hfile);

   if(!m_onegoodsite)
      return E_UNEXPECTED;
   else
      return NOERROR;
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

// BUGBUG: Stack is getting large here - consider writing with
//   only one buffer that is reused. Have to break up the nice Allocate
//   call
DOWNLOADSITE *CDownloadSiteMgr::ParseAndAllocateDownloadSite(LPSTR psz)
{
   char szUrl[1024];
   char szName[256];
   char szlang[256];
   char szregion[256];
   BOOL bQueryTrue = TRUE;
   DOWNLOADSITE *p = NULL;

   GetStringField(psz, 0, szUrl, sizeof(szUrl)); 
   GetStringField(psz,1, szName, sizeof(szName));
   GetStringField(psz, 2, szlang, sizeof(szlang));
   GetStringField(psz, 3, szregion, sizeof(szregion));

   if(szUrl[0] == 0 || szName[0] == 0 || szlang[0] == 0 || szregion[0] == 0)
      return NULL;

   m_onegoodsite = TRUE;
   
   // Hack - Check language against what is in our query params
   //    a) this query should have already been performed on the server
   //    b) or it should be more generic/its own function

   if(m_pquery)
   {
      if(m_pquery->pszLang && (lstrcmpi(m_pquery->pszLang, szlang) != 0))
         bQueryTrue = FALSE;

      // query for region
      if(bQueryTrue && m_pquery->pszRegion && (lstrcmpi(m_pquery->pszRegion, szregion) != 0))
         bQueryTrue = FALSE;
   }

   if(bQueryTrue)
      p = AllocateDownloadSite(szUrl, szName, szlang, szregion);

   return p;
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

DWORD CDownloadSiteMgr::TranslateLanguage(LPSTR psz)
{
   return ( (DWORD) AtoL(psz) );
}


//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

HRESULT CDownloadSiteMgr::AddSite(DOWNLOADSITE *pdls)
{
   if((m_numsites % m_arraysize == 0) && m_numsites != 0)
   {
      m_arraysize += SITEARRAY_GROWTHFACTOR;
      DOWNLOADSITE **pp = (DOWNLOADSITE **) realloc( m_ppdls, m_arraysize * sizeof(DOWNLOADSITE *));
      if(pp)
         m_ppdls = pp;
      else
      {
         m_arraysize -= SITEARRAY_GROWTHFACTOR;
         return E_OUTOFMEMORY;
      }
   }

   if(!m_ppdls)
   {
       return E_OUTOFMEMORY;
   }
   
   m_ppdls[m_numsites++] = pdls;
   return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\ntmigrat\dllmain.cpp ===
#include "pch.h"
#include "migrate.h"

HINSTANCE g_hInstance = NULL;

STDAPI_(BOOL) DllMain(HANDLE hDll, DWORD dwReason, void *lpReserved)
{

    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
		// Open log; FALSE means do not delete existing log
		SetupOpenLog(FALSE);
        g_hInstance = (HINSTANCE)hDll;
        break;

    case DLL_PROCESS_DETACH:
        if (g_lpNameBuf)
            LocalFree(g_lpNameBuf);
        if (g_lpWorkingDir)
            LocalFree(g_lpWorkingDir);
        if (g_lpSourceDirs)
            LocalFree(g_lpSourceDirs);

		SetupCloseLog();
        break;

    default:
        break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\ntmigrat\pch.h ===
#include <windows.h>
#include <winbase.h>
#include <setupapi.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\ntmigrat\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by migrate.rc
//
#define IDS_FRIENDLYNAME                1
#define IDS_INCOMPAT_MSG                2
#define IDS_COMPANY                     3
#define IDS_SUPPORTNUMBER               4
#define IDS_SUPPORTURL                  5
#define IDS_INSTRUCTIONS                6

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\ntmigrat\migrate.h ===
#ifndef _IE_NT5_MIGRATION_MIGRATE_H_
#define _IE_NT5_MIGRATION_MIGRATE_H_


// Constants:
///////////////////////////
#define CP_USASCII            1252
#define END_OF_CODEPAGES    -1

#define REGKEY_RATING  "Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Ratings"
#define cszRATINGSFILE "ratings.pol"
#define cszIEXPLOREFILE "iexplore.exe"

#define cszMIGRATEINF  "migrate.inf"
#define cszPRIVATEINF  "private.inf"

// MIGRATE.INF section names.
#define cszMIGINF_VERSION          "Version"
#define cszMIGINF_MIGRATION_PATHS  "Migration Paths"
#define cszMIGINF_EXCLUDED_PATHS   "Excluded Paths"
#define cszMIGINF_HANDLED          "Handled"
#define cszMIGINF_MOVED            "Moved"
#define cszMIGINF_INCOMPAT_MSG     "Incompatible Messages"
#define cszMIGINF_NTDISK_SPACE_REQ "NT Disk Space Requirements"

// PRIVATE.INF values:
#define cszIEPRIVATE             "IE Private"
#define cszRATINGS               "Ratings"

typedef struct _VendorInfo {
    CHAR    CompanyName[256];
    CHAR    SupportNumber[256];
    CHAR    SupportUrl[256];
    CHAR    InstructionsToUser[1024];
} VENDORINFO, *PVENDORINFO;


// Global variables:
///////////////////////////

extern HINSTANCE g_hInstance;
// Vendor Info:
extern VENDORINFO g_VendorInfo;

// Product ID:
extern char g_cszProductID[];

// Version number of this Migration Dll
extern UINT g_uVersion;

// Array of integers specifying the CodePages we use. (Terminated with -1)
extern int  g_rCodePages[];

// Multi-SZ ie double Null terminated list of strings.
extern char  *g_lpNameBuf;
extern DWORD  g_dwNameBufSize;
extern char  *g_lpWorkingDir;
extern char  *g_lpSourceDirs;

extern char g_szMigrateInf[];
extern char g_szPrivateInf[];

// Function Prototypes:
////////////////////////////

//BOOL NeedToMigrateIE();


#endif //_IE_NT5_MIGRATION_MIGRATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\inseng\utils2.cpp ===
#include "inspch.h"
#include "inseng.h"
#include "resource.h"
#include "insobj.h"
#include "advpub.h"
#include "capi.h"
#include "util.h"
#include "util2.h"
#include <regstr.h>

TCHAR c_gszSetupAPI[] = "setupapi.dll";
TCHAR c_gszAdvpext[]   = "advpext.dll";

// A reusable buffer for logging. Note there is a possible threading
// issue here as two threads may use this at the same time! I am choosing
// not to protect it for performance reasons but be careful!!
char szLogBuf[512];



// NT reboot
//



#define MSDOWNLOAD  "msdownld.tmp"
#define DOWNLDSUB   "download"

// functions
BOOL IfNotExistCreateDir( LPTSTR lpDir, BOOL bHidden, BOOL bRemoveFileIfExist );
BOOL CheckImageHlp_dll();

char g_szWindowsDir[MAX_PATH] = { 0 };

#define MAXRETRIES 100
BOOL GetUniqueFileName(LPCSTR pszRoot, LPCSTR pszPrefix, UINT uStartIndex, LPSTR pszBuffer)
{
   char pszTemp[MAX_PATH];
   char pszTempname[16];
   // we now ignore the uStartIndex parameter, and create something random.
   uStartIndex = GetTickCount() % 0xFFFF9A;
   UINT uEndIndex = uStartIndex + MAXRETRIES;
   LPSTR pszEnd;

   pszBuffer[0] = 0;
   lstrcpy(pszTemp, pszRoot);
   pszEnd = pszTemp + lstrlen(pszTemp);

   do
   {
      wsprintf(pszTempname, "%s%06X.tmp", pszPrefix, uStartIndex);
      AddPath(pszTemp, pszTempname);
      if(GetFileAttributes(pszTemp) == 0xFFFFFFFF)
         break;
      uStartIndex++;
      *pszEnd = 0;
   } while (uStartIndex < uEndIndex);

   if(uStartIndex != uEndIndex)
      lstrcpy(pszBuffer, pszTemp);

   return ( pszBuffer[0] != 0 );
}

#define MIN_DISKSIZE_FOR_EXTRACT 1024 * 100
#define MAX_DRIVES 26

BOOL IsUsableDrive(LPSTR szRoot)
{
   static BYTE bDrives[MAX_DRIVES] = { 0 };
   static UINT uUseRemovable = 0xffffffff;
   BOOL fUsable;
   UINT uType;
   DWORD dwOldErrorMode;

   if(uUseRemovable == 0xffffffff)
   {
      char sztemp[] = "X:\\";
      for(char ch = 'A'; ch <= 'Z'; ch++)
      {
         sztemp[0] = ch;
         if(GetDriveType(sztemp) == DRIVE_FIXED)
         {
            uUseRemovable = FALSE;
            break;
         }
      }
      if(uUseRemovable == 0xffffffff)
         uUseRemovable = TRUE;
   }

   dwOldErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS);
   uType = GetDriveType(szRoot);

   // the drive type is OK, if
   // it is fixed or removable AND
   // it is bigger than MIN_DISKSIZE_FOR_EXTRACT AND
   // GetFileAttributes succeeds
   //
   if ( (!bDrives[szRoot[0] - 'A']) &&
        ((uType == DRIVE_REMOVABLE && uUseRemovable) || (uType == DRIVE_FIXED))  &&
        ( GetFileAttributes( szRoot ) != 0xffffffff) &&
        ( GetDriveSize(szRoot) >= MIN_DISKSIZE_FOR_EXTRACT ) )
   {
        fUsable = TRUE;
   }
   else
   {
      bDrives[szRoot[0] - 'A'] = 1;
      fUsable = FALSE;
   }
   SetErrorMode(dwOldErrorMode);
   return fUsable;
}

BOOL IsDirWriteable(LPSTR lpDir)
{
    char szFile[MAX_PATH];
    HANDLE  hFile;
    BOOL    bWriteAccess = FALSE;

    lstrcpy(szFile, lpDir);
    AddPath(szFile, "~!~ie6.~!~");
    hFile = CreateFile(szFile, GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile != INVALID_HANDLE_VALUE)
    {
        bWriteAccess = TRUE;
        CloseHandle(hFile);
        DeleteFile(szFile);
    }
    return bWriteAccess;
}


//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

// BUGBUG: Currently we have two problems :
//     1. Always assume cache drive == win drive
//     2. Compression isn't accounted for on stuff going to cache

HRESULT CreateTempDir( DWORD dwDownloadSize,
                     DWORD dwExtractSize,
                     char chInstallDrive, DWORD dwInstallSize,
                     DWORD dwWindowsDriveSize,
                     LPSTR pszBuf,  DWORD dwBufSize, DWORD dwFlag )
{
    char  szRoot[MAX_PATH];
    char  szUnique[MAX_PATH];
    DWORD dwReqSize;
    DWORD dwReqSizeWin = 0;
    DWORD dwReqSizeOther = 0;
    DWORD dwVolFlags;
    DWORD dwCompressFactor;

    if ( !pszBuf || (dwBufSize==0) )
    {
        return ( E_INVALIDARG );
    }

    if(g_szWindowsDir[0] == 0)
    {
       GetWindowsDirectory(g_szWindowsDir, sizeof(g_szWindowsDir));
    }
    // Make sure there is enough install space on drive
    dwReqSizeWin = dwWindowsDriveSize;
    if(chInstallDrive == g_szWindowsDir[0])
       dwReqSizeWin += dwInstallSize;
    else
       dwReqSizeOther = dwInstallSize;

    if(dwReqSizeWin > 0)
    {
       lstrcpyn(szRoot, g_szWindowsDir, 4);
       if(!IsEnoughSpace(szRoot, dwReqSizeWin))
          return E_FAIL;
    }

    if(dwReqSizeOther > 0)
    {
       lstrcpyn(szRoot, g_szWindowsDir, 4);
       szRoot[0] = chInstallDrive;
       if(!IsEnoughSpace(szRoot, dwReqSizeOther))
          return E_FAIL;
    }

    lstrcpy( szRoot, "A:\\" );

    while ( szRoot[0] <= 'Z' )
    {
        UINT uType;

        uType = GetDriveType(szRoot);

        // even the drive type is OK, verify the drive has valid connection
        //
        if ( !IsUsableDrive(szRoot) )
        {
            szRoot[0]++;
            continue;
        }

        if(!IsDirWriteable(szRoot))
        {
            szRoot[0]++;
            continue;
        }

        if(!GetVolumeInformation(szRoot, NULL, 0, NULL, NULL, &dwVolFlags, NULL, 0))
        {
            szRoot[0]++;
            continue;
        }
        if(dwVolFlags & FS_VOL_IS_COMPRESSED)
           dwCompressFactor = 19;
        else
           dwCompressFactor = 10;


        // suitable drive:
        dwReqSize = (dwDownloadSize * dwCompressFactor)/10;
        dwReqSize += dwExtractSize;
        if(g_szWindowsDir[0] == szRoot[0])
           dwReqSize += dwReqSizeWin;
        else if(chInstallDrive == szRoot[0])
           dwReqSize += dwReqSizeOther;

        if ( !IsEnoughSpace( szRoot, dwReqSize  ) )
        {
            szRoot[0]++;
            continue;
        }

        // if our suitable drive happens also to be the windows drive,
        // create msdownld.tmp of of it.
        if(szRoot[0] == g_szWindowsDir[0])
              lstrcpy(szRoot, g_szWindowsDir);

        AddPath( szRoot, MSDOWNLOAD );

        if ( !IfNotExistCreateDir( szRoot, TRUE, TRUE ) )
        {
TryNextDrive:
            szRoot[0]++;
            szRoot[3] = '\0';
            continue;
        }

        // BUGBUG: On NT, it always tries with sequential numbers ASE1.TMP, ASE2.TMP
        // ASE3.TMP, etc. and if there is already a directory by this name
        // it fails the call instead of trying again with next number!
        //
        if ( !GetUniqueFileName(szRoot,"AS", 0, szUnique) )
           goto TryNextDrive ;

        lstrcpy(szRoot, szUnique);

        if ( !IfNotExistCreateDir( szRoot, FALSE, FALSE) )
        {
            goto TryNextDrive;
        }

        // you got the good dir
        AddPath( szRoot, "" );

        if ( (DWORD) lstrlen(szRoot)+1 >  dwBufSize )
        {
            return ( E_INVALIDARG );
        }

        // success
        lstrcpy( pszBuf, szRoot );
        return S_OK;
    }

    // no drive has enough space
    return( E_FAIL );
}

void CleanUpTempDir(LPCSTR szTemp)
{
   char szBuf[MAX_PATH];
   char szWinDir[MAX_PATH];


   lstrcpy(szBuf, szTemp);

   DelNode(szBuf, 0);

   // clean up msdownld.tmp if its not the windows drive
   GetWindowsDirectory(szWinDir, sizeof(szWinDir));
   if(!ANSIStrStrI(szBuf, szWinDir))
   {
      GetParentDir(szBuf);
      DelNode(szBuf, ADN_DEL_IF_EMPTY);
   }
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//
// Checks the install destination dir free disk space
//
BOOL IsEnoughSpace( LPCSTR szPath, DWORD dwInstNeedSize )
{
   char szRoot[4];

   lstrcpyn(szRoot, szPath, 4);
   if( szRoot[0] == 0)
      return FALSE;

   if ( dwInstNeedSize + 1 > GetSpace(szRoot) )
      return FALSE;
   else
      return TRUE;
}


void SafeAddPath(LPSTR szPath, LPCSTR szName, DWORD dwPathSize)
{
    LPSTR szTmp;
    DWORD dwLen = lstrlen(szPath);

    if(dwLen + 1 >= dwPathSize)
       return;

        // Find end of the string
    szTmp = szPath + dwLen;

        // If no trailing backslash then add one
    if ( szTmp > szPath && *(AnsiPrev( szPath, szTmp )) != '\\' )
        *(szTmp++) = '\\';
    *szTmp = 0;

        // Add new name to existing path string
    while ( *szName == ' ' ) szName++;
    lstrcpyn( szTmp, szName, dwPathSize - lstrlen(szPath) );
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

BOOL IfNotExistCreateDir( LPTSTR lpDir, BOOL bHidden, BOOL bRemoveFileIfExist)
{
    DWORD attr;

    attr = GetFileAttributes( lpDir );
    if ((attr != -1) && !(attr & FILE_ATTRIBUTE_DIRECTORY))
    {
        // lpDir does not have a directory attribute
        // If we are allowed to delete the file, try do that.
        if (bRemoveFileIfExist)
        {
            SetFileAttributes(lpDir, FILE_ATTRIBUTE_NORMAL);
            DeleteFile(lpDir);
            attr = GetFileAttributes( lpDir );
        }
    }
    if (attr == -1)
    {
        if ( CreateDirectory( lpDir, NULL ) )
        {
           if(bHidden)
              return (SetFileAttributes( lpDir, FILE_ATTRIBUTE_HIDDEN ) );
           else
              return TRUE;
        }
        else
           return FALSE;
    }

    return (attr & FILE_ATTRIBUTE_DIRECTORY);
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

HRESULT LaunchProcess(LPCSTR pszCmd, HANDLE *phProc, LPCSTR pszDir, UINT uShow)
{
   STARTUPINFO startInfo;
   PROCESS_INFORMATION processInfo;
   HRESULT hr = S_OK;
   BOOL fRet;

   if(phProc)
      *phProc = NULL;

   // Create process on pszCmd
   ZeroMemory(&startInfo, sizeof(startInfo));
   startInfo.cb = sizeof(startInfo);
   startInfo.dwFlags |= STARTF_USESHOWWINDOW;
   startInfo.wShowWindow = (USHORT)uShow;
   fRet = CreateProcess(NULL, (LPSTR)  pszCmd, NULL, NULL, FALSE,
              NORMAL_PRIORITY_CLASS, NULL, pszDir, &startInfo, &processInfo);
   if(!fRet)
      return E_FAIL;

   if(phProc)
      *phProc = processInfo.hProcess;
   else
      CloseHandle(processInfo.hProcess);

   CloseHandle(processInfo.hThread);

   return S_OK;
}


//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

HRESULT LaunchAndWait(LPSTR pszCmd, HANDLE hAbort, HANDLE *phProc, LPSTR pszDir, UINT uShow)
{
   HRESULT hr = S_OK;

   hr = LaunchProcess(pszCmd, phProc, pszDir, uShow);

   if(SUCCEEDED(hr))
   {
      HANDLE pHandles[2];
      BOOL fQuit = FALSE;
      pHandles[0] = *phProc;

      if(hAbort)
         pHandles[1] = hAbort;

      DWORD dwRet;

      while(!fQuit)
      {
         dwRet = MsgWaitForMultipleObjects(hAbort ? 2 : 1, pHandles, FALSE, INFINITE, QS_ALLINPUT);
         // Give abort the highest priority
         if(dwRet == WAIT_OBJECT_0)
         {
            fQuit = TRUE;
         }
         else if((dwRet == WAIT_OBJECT_0 + 1) && hAbort)
         {
            // Any abort work?
            hr = E_ABORT;
            fQuit = TRUE;
         }
         else
         {
            MSG msg;
            // read all of the messages in this next loop
            // removing each message as we read it
            while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
            {

               // if it's a quit message we're out of here
               if (msg.message == WM_QUIT)
                  fQuit = TRUE;
               else
               {
                  // otherwise dispatch it
                 DispatchMessage(&msg);
               } // end of PeekMessage while loop
            }
         }
      }
   }

   return hr;
}


//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

void ConvertVersionStrToDwords(LPSTR pszVer, LPDWORD pdwVer, LPDWORD pdwBuild)
{
   DWORD dwTemp1,dwTemp2;

   dwTemp1 = GetIntField(pszVer, 0, 0);
   dwTemp2 = GetIntField(pszVer, 1, 0);

   *pdwVer = (dwTemp1 << 16) + dwTemp2;

   dwTemp1 = GetIntField(pszVer, 2, 0);
   dwTemp2 = GetIntField(pszVer, 3, 0);

   *pdwBuild = (dwTemp1 << 16) + dwTemp2;
}

/*
void ConvertVersionStr(LPSTR pszVer, WORD rwVer[])
{
   LPSTR pszMyVer = MakeAnsiStrFromAnsi(pszVer);
   LPSTR pszEnd = pszMyVer + lstrlen(pszMyVer);
   LPSTR pszTemp = pszMyVer;
   LPSTR pszBegin;

   for(int i = 0; i < NUM_VERSION_ENTRIES; i++)
      rwVer[i] = 0;

   for(i = 0; i < 4 && pszTemp < pszEnd; i++)
   {
      pszBegin = pszTemp;
      while(pszTemp < pszEnd && *pszTemp != ',')
         pszTemp++;

      *pszTemp = 0;
      rwVer[i] = (WORD) AtoL(pszBegin);
      pszTemp++;
   }
   CoTaskMemFree(pszMyVer);
}

*/
//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//    -1   Ver1 < Ver2
//     0   Ver1 == Ver2
//     1   Ver1 > Ver2
// Notes:

int VersionCmp(WORD rwVer1[], WORD rwVer2[])
{
/*
   for(int i = 0; i < NUM_VERSION_ENTRIES; i++)
   {
      if(rwVer1[i] < rwVer2[i])
         return -1;
      if(rwVer1[i] > rwVer2[i])
         return 1;
   }
*/
  return 0;

}


//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

int ErrMsgBox(LPSTR	pszText, LPCSTR	pszTitle, UINT	mbFlags)
{
    HWND hwndActive;
    int  id;

    hwndActive = GetActiveWindow();

    id = MessageBox(hwndActive, pszText, pszTitle, mbFlags | MB_ICONERROR | MB_TASKMODAL);

    return id;
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

int LoadSz(UINT id, LPSTR pszBuf, UINT cMaxSize)
{

   if(cMaxSize == 0)
      return 0;

   pszBuf[0] = 0;

   return LoadString(g_hInstance, id, pszBuf, cMaxSize);
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

LPSTR FindChar(LPSTR pszStr, char ch)
{
   while( *pszStr != 0 && *pszStr != ch )
   {
      if (*pszStr == '\"')
      {
          // Move past the first "
          pszStr++;

          // Now keep scanning till find the closing ". After that return to scanning
          // for the user-given delimiter 'ch'.
          while( *pszStr != 0 && *pszStr != '\"' )
              pszStr++;

          // Have reached end of string without finding closing ", return now.
          if (*pszStr == 0)
              break;
      }

      pszStr++;
   }

   return pszStr;
}


//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//    This is a very hacky function that will strip quotes.
//    Note it chages the contents of the buffer passed to it!!
LPSTR StripQuotes(LPSTR pszStr)
{
   if(!pszStr)
      return NULL;

   UINT uEnd = lstrlenA(pszStr);
   if(uEnd > 0 && pszStr[uEnd-1] == '"' && *pszStr == '"')
   {
      pszStr[uEnd-1] = 0;
      pszStr++;
   }

   return pszStr;
}


//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//


DWORD WINAPI LaunchInfCommand(void *p)
{
   HRESULT hr = S_OK;

   INF_ARGUEMENTS *pinfArgs = (INF_ARGUEMENTS *)p;

   if(pinfArgs->dwType == InfExCommand)
   {
      CABINFO cabinfo;
      cabinfo.pszCab = pinfArgs->szCab;
      cabinfo.pszInf = pinfArgs->szInfname;
      cabinfo.pszSection = pinfArgs->szSection;

      lstrcpy(cabinfo.szSrcPath, pinfArgs->szDir);
      cabinfo.dwFlags = pinfArgs->dwFlags;

      hr = ExecuteCab(NULL, &cabinfo, 0);
   }
   else
   {
      hr = RunSetupCommand(NULL, pinfArgs->szInfname,
                   lstrlen(pinfArgs->szSection) ? pinfArgs->szSection : NULL,
                   pinfArgs->szDir, NULL, NULL, pinfArgs->dwFlags, NULL );
   }
   return hr;
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

#define ABOUTTWODAYSTIME  0x000000C9

void CleanupDir(LPSTR lpDir)
{
    char szFile[MAX_PATH];
    WIN32_FIND_DATA fileData;
    HANDLE hFindFile;
    FILETIME currenttime;

    if ( lpDir == NULL  ||  *lpDir == '\0' )
        return;

    lstrcpy( szFile, lpDir );
    if ( szFile[ lstrlen(szFile)-1 ] != '\\' )
        lstrcat( szFile, "\\" );
    lstrcat( szFile, "*.tmp" );
    hFindFile = FindFirstFile( szFile, &fileData );
    if ( hFindFile == INVALID_HANDLE_VALUE )
        return;

    do
    {

        if ( fileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
        {
            if ( lstrcmp( fileData.cFileName, "." ) == 0  ||
                 lstrcmp( fileData.cFileName, ".." ) == 0 )
                continue;

            GetSystemTimeAsFileTime(&currenttime);
            if( ( currenttime.dwHighDateTime  >
                   fileData.ftLastWriteTime.dwHighDateTime ) &&
                ( currenttime.dwHighDateTime -
                   fileData.ftLastWriteTime.dwHighDateTime > ABOUTTWODAYSTIME))
            {
               lstrcpy( szFile, lpDir );
               if ( szFile[ lstrlen(szFile)-1 ] != '\\' )
                  lstrcat( szFile, "\\" );
               // delete the sub-dir
               lstrcat( szFile, fileData.cFileName );
               SetFileAttributes(szFile, FILE_ATTRIBUTE_NORMAL );
               DelNode( szFile, 0 );
            }
        }
        else
           continue;

    } while ( FindNextFile( hFindFile, &fileData ) );

    FindClose( hFindFile  );
}



//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

DWORD WINAPI CleanUpAllDirs(LPVOID pv)
{
   char szDir[MAX_PATH];
   UINT uType;

   DllAddRef();
   if(g_szWindowsDir[0] == 0)
   {
      GetWindowsDirectory(g_szWindowsDir, sizeof(g_szWindowsDir));
   }

   lstrcpy( szDir, "X:\\" );
   for(char chDrive = 'A'; chDrive <= 'Z'; chDrive++)
   {
      szDir[0] = chDrive;

      if (IsUsableDrive(szDir))
      {
         if(chDrive == g_szWindowsDir[0])
            lstrcpy(szDir, g_szWindowsDir);

         AddPath(szDir, MSDOWNLOAD);
         CleanupDir(szDir);
         szDir[3] = 0;
      }
   }
   DllRelease();
   return 0;
}


//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

BOOL IsCabFile(LPCSTR pszFile)
{

   DWORD dwLen = lstrlenA(pszFile);
   if(dwLen <= 3)
      return FALSE;

   LPCSTR pszExt = pszFile + (dwLen - 4);

   if(lstrcmpiA(pszExt, ".cab") == 0)
   {
      return TRUE;
   }

   return FALSE;
}

typedef HRESULT (WINAPI *WINVERIFYTRUST) (HWND hwnd, GUID *pgActionID, LPVOID pWintrustData);

// BUGBUG: get rid of this once moved to winbase.h!!!
// #define WIN_TRUST_SUBJTYPE_CABINET                               \
//            { 0xd17c5374,                                        \
//              0xa392,                                            \
//              0x11cf,                                            \
//              { 0x9d, 0xf5, 0x0, 0xaa, 0x0, 0xc1, 0x84, 0xe0 }   \
//            }

// PublishedSoftwareNoBad {C6B2E8D0-E005-11cf-A134-00C04FD7BF43}
#define WIN_SPUB_ACTION_PUBLISHED_SOFTWARE_NOBADUI              \
            { 0xc6b2e8d0,                                       \
              0xe005,                                           \
              0x11cf,                                           \
              { 0xa1, 0x34, 0x0, 0xc0, 0x4f, 0xd7, 0xbf, 0x43 } \
            }

#define WINTRUST "wintrust.dll"

// Verion number 5.0
#define AUTHENTICODE2_MS_VERSION 0x00050000
// Build number 1542.32
#define AUTHENTICODE2_LS_VERSION  0x06050020
//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//
HRESULT CheckTrustIE3(LPCSTR szFilename, HWND hwndForUI, BOOL bShowBadUI, WINVERIFYTRUST pwvt);
HRESULT CheckTrustIE4(LPCSTR szURL, LPCSTR szFilename, HWND hwndForUI, BOOL bShowBadUI, WINVERIFYTRUST pwvt);


HRESULT WINAPI CheckTrustEx(LPCSTR szURL, LPCSTR szFilename, HWND hwndForUI, BOOL bShowBadUI, DWORD dwReserved)
{
   WINVERIFYTRUST pwvt;
   HINSTANCE hinst;
   char szPath[MAX_PATH] = { 0 };
   DWORD   dwVerMS = 0;
   DWORD   dwVerLS = 0;
   HRESULT hr = S_OK;
   static BOOL st_CheckTrust = TRUE ;
   static BOOL st_Auth2Checked = FALSE;


   if (!st_CheckTrust)
        return S_FALSE ;

   if (!CheckImageHlp_dll())
   {
       st_CheckTrust = FALSE;
       return S_FALSE ;
   }

   hinst = LoadLibrary(WINTRUST);
   if(!hinst)
   {
      //
      st_CheckTrust = FALSE ;

      return S_FALSE;
   }

   if (!st_Auth2Checked)
   {
       // If we get here, we know we can load Wintrust.dll
       GetSystemDirectory(szPath, sizeof(szPath));
       AddPath(szPath, "Softpub.dll");
       GetVersionFromFile(szPath, &dwVerMS, &dwVerLS, TRUE);

       // If softpubs version is less then the  authenticode2 version don't call WinverifyTrust.
       if ((dwVerMS < AUTHENTICODE2_MS_VERSION) ||
           ((dwVerMS == AUTHENTICODE2_MS_VERSION) && (dwVerLS < AUTHENTICODE2_LS_VERSION)) )
       {
          hr = S_FALSE;
          st_CheckTrust = FALSE;
       }
       st_Auth2Checked = TRUE;
   }

   if (st_CheckTrust)
   {

      pwvt = (WINVERIFYTRUST) GetProcAddress(hinst, "WinVerifyTrust");
      if(!pwvt)
      {
         FreeLibrary(hinst);
         st_CheckTrust = FALSE ;

         return S_FALSE;
      }
      // If we don't have a URL, use the IE3 methode of CheckTrust.
      hr = TRUST_E_PROVIDER_UNKNOWN;
      if (szURL)
      {
         // The new way of calling into WinVerifyTrust wll return TRUST_E_PROVIDER_UNKNOWN
         // if the new methode is not implemented on the system.
         __try
         {
             hr = CheckTrustIE4(szURL, szFilename, hwndForUI, bShowBadUI, pwvt);
         }
         __except(EXCEPTION_EXECUTE_HANDLER)
         {
             //Corrupted Java.
             hr = TRUST_E_FAIL;             
         }   
         
      }

      if (hr == TRUST_E_PROVIDER_UNKNOWN || hr == E_FAIL)
      {
          hr = CheckTrustIE3(szFilename, hwndForUI, bShowBadUI, pwvt);
          if (hr == S_FALSE)
             st_CheckTrust = FALSE;
      }
   }

   FreeLibrary(hinst);
   return hr;
}


HRESULT CheckTrustIE3(LPCSTR szFilename, HWND hwndForUI, BOOL bShowBadUI, WINVERIFYTRUST pwvt)
{
    HRESULT hr;
    LPWSTR pwszFilename = NULL;

    GUID PublishedSoftware = WIN_SPUB_ACTION_PUBLISHED_SOFTWARE;
    GUID PublishedSoftwareNoBadUI = WIN_SPUB_ACTION_PUBLISHED_SOFTWARE_NOBADUI;

    GUID * ActionGUID;

    if(bShowBadUI)
        ActionGUID = &PublishedSoftware;
    else
        ActionGUID = &PublishedSoftwareNoBadUI;

    GUID SubjectPeImage = WIN_TRUST_SUBJTYPE_PE_IMAGE;
    GUID SubjectCAB = WIN_TRUST_SUBJTYPE_CABINET;
    WIN_TRUST_ACTDATA_CONTEXT_WITH_SUBJECT ActionData;
    WIN_TRUST_SUBJECT_FILE Subject;

    Subject.hFile = INVALID_HANDLE_VALUE;
    pwszFilename = OLESTRFROMANSI(szFilename);
    Subject.lpPath = pwszFilename;

    if (IsCabFile(szFilename))
    {
        ActionData.SubjectType = &SubjectCAB;
    }
    else
    {
        ActionData.SubjectType = &SubjectPeImage;
    }

    ActionData.Subject = &Subject;
    ActionData.hClientToken = NULL;

    hr =  pwvt( hwndForUI, ActionGUID, &ActionData);

    if(hr == E_FAIL)
    {
        // Hopefully, this is a general "trust is screwy" error. We will put
        //   up our own ui to see if we can continue
        // Is this UI OK

        char szTitle[128];
        char szMess[256];

        LoadSz(IDS_SECURITYTITLE, szTitle, 128);
        LoadSz(IDS_SECURITY, szMess, 256);
        if(MessageBox(hwndForUI, szMess, szTitle, MB_YESNO | MB_ICONQUESTION) == IDYES)
        {
            hr = S_FALSE;
        }

    }

    if(pwszFilename)
        CoTaskMemFree(pwszFilename);
    return hr;
}


// {D41E4F1D-A407-11d1-8BC9-00C04FA30A41}
#define COR_POLICY_PROVIDER_DOWNLOAD \
{ 0xd41e4f1d, 0xa407, 0x11d1, {0x8b, 0xc9, 0x0, 0xc0, 0x4f, 0xa3, 0xa, 0x41 } }

typedef HRESULT (WINAPI *COINTERNETCREATESECURITYMANAGER) ( IServiceProvider *pSP, IInternetSecurityManager **ppSM, DWORD dwReserved);

HRESULT CheckTrustIE4(LPCSTR szURL, LPCSTR szFilename, HWND hwndForUI, BOOL bShowBadUI, WINVERIFYTRUST pwvt)
{
    GUID     guidCor = COR_POLICY_PROVIDER_DOWNLOAD;
    GUID    *pguidActionIDCor = &guidCor;

    LPWSTR pwszURL = NULL;
    GUID guidJava = JAVA_POLICY_PROVIDER_DOWNLOAD;
    GUID    *pguidActionIDJava = &guidJava;

    WINTRUST_DATA            wintrustData;
    WINTRUST_FILE_INFO       fileData;
    JAVA_POLICY_PROVIDER     javaPolicyData;

    HRESULT hr = S_OK;
    HANDLE  hFile = INVALID_HANDLE_VALUE;

    HINSTANCE hUrlmon = NULL;
    IInternetSecurityManager *pSecMgr = NULL;
    DWORD dwZone;

    hFile = CreateFile(szFilename, GENERIC_READ, FILE_SHARE_READ|FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile == INVALID_HANDLE_VALUE)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    else
    {
        if (hwndForUI == INVALID_HANDLE_VALUE)
            bShowBadUI = FALSE;

        pwszURL = OLESTRFROMANSI(szURL);

        memset(&wintrustData, 0, sizeof(wintrustData));
        memset(&fileData, 0, sizeof(fileData));
        memset(&javaPolicyData, 0, sizeof(javaPolicyData));

        javaPolicyData.cbSize = sizeof(JAVA_POLICY_PROVIDER);
        javaPolicyData.VMBased = FALSE;

        // obsolete: noone pays attention to this
        javaPolicyData.fNoBadUI = !bShowBadUI;

        javaPolicyData.pwszZone = pwszURL;
        javaPolicyData.pZoneManager = NULL;

        // Use a file handle, so that in case trust has to put up UI the path
        // to the local file does not show in hte UI if we actually downloaded the
        // file from a URL.
        fileData.cbStruct = sizeof(WINTRUST_FILE_INFO);
        fileData.pcwszFilePath = pwszURL;
        fileData.hFile = hFile;

        wintrustData.cbStruct = sizeof(WINTRUST_DATA);
        wintrustData.pPolicyCallbackData = &javaPolicyData;
        if (hwndForUI == INVALID_HANDLE_VALUE)
            wintrustData.dwUIChoice = WTD_UI_NONE;
        else if(bShowBadUI)
            wintrustData.dwUIChoice = WTD_UI_ALL;
        else
            wintrustData.dwUIChoice = WTD_UI_NOBAD;

        wintrustData.dwUnionChoice = WTD_CHOICE_FILE;
        wintrustData.pFile = &fileData;


        hr =  pwvt( hwndForUI, pguidActionIDCor, &wintrustData);
        if (hr == TRUST_E_PROVIDER_UNKNOWN)
        {
            hr =  pwvt( hwndForUI, pguidActionIDJava, &wintrustData);
        }

        // BUGBUG: Check with Vatsan about this bugbug.
        // this works around a wvt bug that returns 0x57 (success) when
        // you hit No to an unsigned control
        if (SUCCEEDED(hr) && hr != S_OK)
        {
            hr = TRUST_E_FAIL;
        }

        if (SUCCEEDED(hr))
        {
            hUrlmon = LoadLibrary("urlmon.dll");
            if (hUrlmon)
            {
                COINTERNETCREATESECURITYMANAGER pcicsm;

                pcicsm = (COINTERNETCREATESECURITYMANAGER) GetProcAddress(hUrlmon, "CoInternetCreateSecurityManager");
                if (pcicsm)
                    pcicsm(NULL, &pSecMgr, NULL);
            }

            if ((javaPolicyData.pbJavaTrust == NULL) ||
                (!javaPolicyData.pbJavaTrust->fAllActiveXPermissions) ||
                (pSecMgr && SUCCEEDED(pSecMgr->MapUrlToZone(pwszURL, &dwZone, 0)) && dwZone == URLZONE_LOCAL_MACHINE && FAILED(javaPolicyData.pbJavaTrust->hVerify)))
                hr = TRUST_E_FAIL;

            if (hUrlmon)
                FreeLibrary(hUrlmon);
        }

        if (javaPolicyData.pbJavaTrust)
            CoTaskMemFree(javaPolicyData.pbJavaTrust);

        if(pwszURL)
            CoTaskMemFree(pwszURL);

        CloseHandle(hFile);

        if (pSecMgr)
            pSecMgr->Release();
    }
    return hr;
}

HRESULT WINAPI CheckTrust(LPCSTR szFilename, HWND hwndForUI, BOOL bShowBadUI)
{
    return CheckTrustEx(NULL, szFilename, hwndForUI, bShowBadUI, NULL);
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

DWORD GetStringField(LPSTR szStr, UINT uField, LPSTR szBuf, UINT cBufSize)
{
   LPSTR pszBegin = szStr;
   LPSTR pszEnd;
   UINT i = 0;
   DWORD dwToCopy;

   if(cBufSize == 0)
       return 0;

   szBuf[0] = 0;

   if(szStr == NULL)
      return 0;

   while(*pszBegin != 0 && i < uField)
   {
      pszBegin = FindChar(pszBegin, ',');
      if(*pszBegin != 0)
         pszBegin++;
      i++;
   }

   // we reached end of string, no field
   if(*pszBegin == 0)
   {
      return 0;
   }


   pszEnd = FindChar(pszBegin, ',');
   while(pszBegin <= pszEnd && *pszBegin == ' ')
      pszBegin++;

   while(pszEnd > pszBegin && *(pszEnd - 1) == ' ')
      pszEnd--;

   if(pszEnd > (pszBegin + 1) && *pszBegin == '"' && *(pszEnd-1) == '"')
   {
      pszBegin++;
      pszEnd--;
   }

   dwToCopy = (DWORD)(pszEnd - pszBegin + 1);

   if(dwToCopy > cBufSize)
      dwToCopy = cBufSize;

   lstrcpynA(szBuf, pszBegin, dwToCopy);

   return dwToCopy - 1;
}

DWORD GetIntField(LPSTR szStr, UINT uField, DWORD dwDefault)
{
   char szNumBuf[16];

   if(GetStringField(szStr, uField, szNumBuf, sizeof(szNumBuf)) == 0)
      return dwDefault;
   else
      return AtoL(szNumBuf);
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

LPSTR BuildDependencyString(LPSTR pszName,LPSTR pszOwner)
{
   LPSTR pszRet = NULL;

   if(pszOwner)
   {
       char szBuf[128];
       LoadSz(IDS_DEPENDNAME, szBuf, sizeof(szBuf));
       pszRet = new char[lstrlenA(pszName) + lstrlenA(szBuf) + lstrlenA(pszOwner) + 25];
       if(pszRet)
          wsprintf(pszRet, szBuf, pszName, pszOwner);
   }
   else
   {
      pszRet = new char[lstrlenA(pszName) + 1];
      if(pszRet)
         lstrcpyA(pszRet, pszName);
   }

   return pszRet;
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

LPWSTR ParseURLW(BSTR str)
{
   LPWSTR pwszTemp;

   if(str == NULL || *str == '\0')
      return NULL;

   pwszTemp = str + SysStringLen(str) - 1;
   while(pwszTemp >= str && *pwszTemp != '\\' && *pwszTemp != '/')
      pwszTemp--;

   return pwszTemp + 1;
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

LPSTR ParseURLA(LPCSTR str)
{
   LPSTR pszTemp;

   if(str == NULL || *str == '\0')
      return NULL;

   pszTemp = (LPSTR)str + lstrlen(str) - 1;
   while(pszTemp >= str && *pszTemp != '\\' && *pszTemp != '/')
      pszTemp--;

   return pszTemp + 1;
}


//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

LPSTR MakeAnsiStrFromAnsi(LPSTR psz)
{
   LPSTR pszTmp;

   if(psz == NULL)
      return NULL;

   pszTmp = (LPSTR) CoTaskMemAlloc(lstrlenA(psz) + 1);
   if(pszTmp)
      lstrcpyA(pszTmp, psz);

   return pszTmp;
}


//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

LPSTR CopyAnsiStr(LPCSTR psz)
{
   LPSTR pszTmp;

   if(psz == NULL)
      return NULL;

   pszTmp = (LPSTR) new char[lstrlenA(psz) + 1];
   if(pszTmp)
      lstrcpyA(pszTmp, psz);

   return pszTmp;
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

BOOL DeleteKeyAndSubKeys(HKEY hkIn, LPSTR pszSubKey)
{
    HKEY  hk;
    TCHAR szTmp[MAX_PATH];
    DWORD dwTmpSize;
    long  l;
    BOOL  f;

    l = RegOpenKeyEx(hkIn, pszSubKey, 0, KEY_READ | KEY_WRITE, &hk);
    if (l != ERROR_SUCCESS) return FALSE;

    // loop through all subkeys, blowing them away.
    //
    f = TRUE;
    while (f) {
        dwTmpSize = MAX_PATH;
        l = RegEnumKeyEx(hk, 0, szTmp, &dwTmpSize, 0, NULL, NULL, NULL);
        if (l != ERROR_SUCCESS) break;
        f = DeleteKeyAndSubKeys(hk, szTmp);
    }

    // there are no subkeys left, [or we'll just generate an error and return FALSE].
    // let's go blow this dude away.
    //
    RegCloseKey(hk);
    l = RegDeleteKey(hkIn, pszSubKey);

    return (l == ERROR_SUCCESS) ? TRUE : FALSE;
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

int StringFromGuid(const CLSID* piid, LPTSTR   pszBuf)
{
    return wsprintf(pszBuf, TEXT("{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}"),
                    piid->Data1, piid->Data2, piid->Data3, piid->Data4[0], piid->Data4[1],
                    piid->Data4[2],piid->Data4[3], piid->Data4[4], piid->Data4[5],
                    piid->Data4[6], piid->Data4[7]);
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

LPWSTR MakeWideStrFromAnsi(LPSTR psz, BYTE  bType)
{
    LPWSTR pwsz;
    int i;

    // arg checking.
    //
    if (!psz)
        return NULL;

    // compute the length of the required BSTR
    //
    i =  MultiByteToWideChar(CP_ACP, 0, psz, -1, NULL, 0);
    if (i <= 0) return NULL;

    // allocate the widestr
    //
    switch (bType) {
      case STR_BSTR:
        // -1 since it'll add it's own space for a NULL terminator
        //
        pwsz = (LPWSTR) SysAllocStringLen(NULL, i - 1);
        break;
      case STR_OLESTR:
        pwsz = (LPWSTR) CoTaskMemAlloc(i * sizeof(WCHAR));
        break;
      default:
        break;
    }

    if (!pwsz) return NULL;
    MultiByteToWideChar(CP_ACP, 0, psz, -1, pwsz, i);
    pwsz[i - 1] = 0;
    return pwsz;
}

#define UNINSTALL_BRANCH "Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall"


BOOL UninstallKeyExists(LPCSTR pszUninstallKey)
{
   HKEY hUninstallKey = NULL;
   char szUninstallStr[512];

   if (!pszUninstallKey)    // If the pointer is NULL, assume installed
       return TRUE;

   lstrcpyA(szUninstallStr, UNINSTALL_BRANCH);
   lstrcatA(szUninstallStr, "\\");
   lstrcatA(szUninstallStr, pszUninstallKey);

   if(RegOpenKeyExA(HKEY_LOCAL_MACHINE, szUninstallStr, 0, KEY_READ,
                     &hUninstallKey) == ERROR_SUCCESS)
   {
      RegCloseKey(hUninstallKey);
      return TRUE;
   }
   else
      return FALSE;

}

void AddTempToLikelyExtractDrive(DWORD dwTempDLSpace, DWORD dwTempExSpace,
                                 char chInstallDrive, char chDownloadDrive,
                                 DWORD *pdwWinDirReq, DWORD *pdwInsDirReq,
                                 DWORD *pdwDownloadDirReq)
{
    DWORD dwExNeeded, dwNeeded;
    DWORD dwVolFlags, dwCompressFactor;
    char szRoot[4];
    DWORD dwInsDirNeeded = dwTempDLSpace + dwTempExSpace;
    DWORD dwInstallDriveCompress = 10;

    lstrcpy(szRoot, "A:\\");
    while ( szRoot[0] <= 'Z' )
    {
       if (!IsUsableDrive( szRoot ) )
       {
           szRoot[0]++;
           continue;
       }
       if(!GetVolumeInformation(szRoot, NULL, 0, NULL, NULL, &dwVolFlags, NULL, 0))
       {
           szRoot[0]++;
           continue;
       }
       if(dwVolFlags & FS_VOL_IS_COMPRESSED)
       {
          dwCompressFactor = 19;
          if(szRoot[0] == chInstallDrive)
             dwInstallDriveCompress = 19;
       }
       else
          dwCompressFactor = 10;
       // Decide how much we need if we extract to this drive
       dwExNeeded = (dwTempDLSpace * dwCompressFactor)/10 + dwTempExSpace;

       dwNeeded = 0;
       // if the install dir, add what is going to install dir
       if(szRoot[0] == chInstallDrive)
          dwNeeded += *pdwInsDirReq;
       // if it is the windows dir, add what goes to win dir
       if(szRoot[0] == g_szWindowsDir[0])
          dwNeeded += *pdwWinDirReq;

       // BUGBUG: compression on this guy?
       if(szRoot[0] == chDownloadDrive)
          dwNeeded += ((*pdwDownloadDirReq * dwCompressFactor)/10);

       dwNeeded += dwExNeeded;
       // if this drive has enough bump Req if appropiate
       if(IsEnoughSpace(szRoot, dwNeeded ))
       {
          if(szRoot[0] == chInstallDrive)
          {
             *pdwInsDirReq += dwExNeeded;
          }
          else if(szRoot[0] == chDownloadDrive)
             *pdwDownloadDirReq += dwExNeeded;
          else if(szRoot[0] == g_szWindowsDir[0])
             *pdwWinDirReq += dwExNeeded;

          return;
       }
       szRoot[0]++;
    }
    // if we get here, NO drive has enough space.
    // Add to install dir here
    *pdwInsDirReq += (dwTempDLSpace * dwCompressFactor)/10 + dwTempExSpace;
}


#define INSTALLCHECK_VALUE 0
#define INSTALLCHECK_DATA  1
#define INSTALLCHECK_NOTSUPPORTED 2
// If you change the string below you also have to tell all clients which use this feature to change.
// The clients are writing there success values under this key.
#define REGSTR_SUCCESS_KEY "Software\\Microsoft\\Active Setup\\Install Check"
BOOL SuccessCheck(LPSTR pszSuccessKey)
{
   HKEY hKey = NULL;
   char szRegKey[512];
   char szRegData[512];
   DWORD dwSize;
   BOOL  bInstalledSuccessfull = FALSE;

   if (!pszSuccessKey)      // If the pointer is NULL, assume installed
       return TRUE;

   if (GetStringField(pszSuccessKey, INSTALLCHECK_NOTSUPPORTED, szRegKey, sizeof(szRegKey)))
       return FALSE;        // This format is not yet supported

   if (GetStringField(pszSuccessKey, INSTALLCHECK_VALUE, szRegKey, sizeof(szRegKey)) == 0)
       return TRUE;        // There is not Registry value to check for. Assume OK

   if(RegOpenKeyExA(HKEY_LOCAL_MACHINE, REGSTR_SUCCESS_KEY, 0, KEY_READ,
                     &hKey) == ERROR_SUCCESS)
   {
      dwSize = sizeof(szRegData);
      if (RegQueryValueEx(hKey, szRegKey, NULL, NULL, (LPBYTE)szRegData, &dwSize) == ERROR_SUCCESS)
      {
         bInstalledSuccessfull = TRUE;
         // If a data filed is specified, check if the value data compare
         if (GetStringField(pszSuccessKey, INSTALLCHECK_DATA, szRegKey, sizeof(szRegKey)))
         {
             bInstalledSuccessfull = (lstrcmpi(szRegKey, szRegData) == 0);
         }
      }
      RegCloseKey(hKey);
   }
   return bInstalledSuccessfull;
}


DWORD WaitForEvent(HANDLE hEvent, HWND hwnd)
{
   BOOL fQuit = FALSE;
   BOOL fDone = FALSE;
   DWORD dwRet;
   while(!fQuit && !fDone)
   {
      dwRet = MsgWaitForMultipleObjects(1, &hEvent, FALSE,
                                        INFINITE, QS_ALLINPUT);
      // Give abort the highest priority
      if(dwRet == WAIT_OBJECT_0)
      {
         fDone = TRUE;
      }
      else
      {
         MSG msg;
         // read all of the messages in this next loop
         // removing each message as we read it
         while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
         {
            if(!hwnd || !IsDialogMessage(hwnd, &msg))
            {
              // if it's a quit message we're out of here
              if (msg.message == WM_QUIT)
                fQuit = TRUE;
              else
              {
                 // otherwise dispatch it
                TranslateMessage(&msg);
                DispatchMessage(&msg);
              }
            } // end of PeekMessage while loop
         }
      }
   }
   return (fQuit ? EVENTWAIT_QUIT : EVENTWAIT_DONE);
}





// If .CIF command switch has #W or #w, expand it to Windows directory. Otherwise, do nothing.
// Input: lpBuf : the original switches
//        dwSize : buffer size
// Outout: lpBuf : expanded switches
//
void ExpandString( LPSTR lpBuf, DWORD dwSize )
{
    LPSTR pTmp, pTmp1;
    char ch;

    if ( !lpBuf || !*lpBuf || !dwSize )
        return;

    pTmp = ANSIStrChr( lpBuf, '#' );
    if ( pTmp )
    {
        pTmp1 = CharNext( pTmp );
        ch = (char)CharUpper((LPSTR) *pTmp1);
        if ( ch == 'W' )
        {
            PSTR pTmpBuf;

            // #W... => <WindowsDir>...
            if ( dwSize < (DWORD)( lstrlen(lpBuf) + lstrlen(g_szWindowsDir) - 1 ) )
                return;  // should never be here

            pTmpBuf = (LPSTR)LocalAlloc( LPTR, dwSize );
            if ( pTmpBuf )
            {
                *pTmp = '\0';
                lstrcpy( pTmpBuf, lpBuf );
                lstrcat( pTmpBuf, g_szWindowsDir );
                lstrcat( pTmpBuf, CharNext(pTmp1) );
                // re-set the output string
                lstrcpy( lpBuf, pTmpBuf );

                LocalFree( pTmpBuf );
            }
        }
        else if ( ch == '#' )
        {
            //  ##... => #...
            MoveMemory( pTmp, pTmp1, lstrlen(pTmp1)+1 );
        }
    }
}


void DeleteFilelist(LPCSTR pszFilelist)
{
   LPSTR pszSections, pszSectionsPreFail, pszTemp;
   DWORD dwSize = ALLOC_CHUNK_SIZE;
   DWORD dwRead;
   // Get a list of all sections
   //
   // BUGBUG: Write this so only one call to GetPrivateProfile exists
   pszSections = (LPSTR) malloc(dwSize);

   // Bail out if no memory
   if(!pszSections)
      return;

   dwRead = GetPrivateProfileStringA(NULL, NULL, "", pszSections, dwSize, pszFilelist);
   while( dwRead >= (dwSize - 2) )
   {
      dwSize += ALLOC_CHUNK_SIZE;
      pszSectionsPreFail = pszSections;
#pragma prefast(suppress: 308, "Noise - pointer was saved")
      pszSections = (LPSTR) realloc(pszSections, dwSize);
      if(!pszSections)
      {
         free(pszSectionsPreFail);
         dwRead = 0;
         break;
      }
      dwRead = GetPrivateProfileStringA(NULL, NULL, "", pszSections, dwSize, pszFilelist);
   }

   pszTemp = pszSections;
   dwSize = lstrlenA(pszTemp);
   while(dwSize != 0)
   {
      WritePrivateProfileSection(pszTemp, NULL, pszFilelist);

      pszTemp += (dwSize + 1);
      dwSize = lstrlenA(pszTemp);
   }

   free(pszSections);
}


BOOL WaitForMutex(HANDLE hMutex)
{
    BOOL fQuit = FALSE;

    while (MsgWaitForMultipleObjects(1, &hMutex, FALSE, INFINITE, QS_ALLINPUT) != WAIT_OBJECT_0)
    {
        MSG msg;

        while (!fQuit  &&  PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
        {
            if (msg.message == WM_QUIT)
               fQuit = TRUE;
            else
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }
    }

    return fQuit;
}

BOOL IsNT()
{
   static int st_IsNT = 0xffff;

   if(st_IsNT == 0xffff)
   {
      OSVERSIONINFO verinfo;        // Version Check

      verinfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
      if ( GetVersionEx( &verinfo ) != FALSE )
      {
          if( verinfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS )
             st_IsNT = 0;
          else if ( verinfo.dwPlatformId == VER_PLATFORM_WIN32_NT )
             st_IsNT = 1;
      }
   }

   return (st_IsNT == 1) ? TRUE : FALSE;

}

HINSTANCE InitSetupLib(LPCSTR pszInfName, HINF *phinf)
{
    HINSTANCE hInst = NULL;
    *phinf = NULL;

    if( IsNT() )
    {
       hInst = LoadLibrary("setupapi.dll");
       OpenINFEngine(  pszInfName, NULL, 0, phinf, NULL );
    }
    else
    {
       hInst = LoadLibrary("w95inf32.dll");
    }
    return hInst;
}

void FreeSetupLib(HINSTANCE hInst, HINF hInf)
{
   if(hInf)
      CloseINFEngine(hInf);
   if(hInst)
      FreeLibrary(hInst);
}

HRESULT MyTranslateInfString( PCSTR pszInfFilename, PCSTR pszInstallSection,
                              PCSTR pszTranslateSection, PCSTR pszTranslateKey,
                              PSTR pszBuffer, DWORD dwBufferSize,
                              PDWORD pdwRequiredSize, HINF hInf )
{
   HRESULT hr;
   if(IsNT() && hInf)
   {
      hr = TranslateInfStringEx( hInf, pszInfFilename, pszTranslateSection, pszTranslateKey,
                                     		pszBuffer, dwBufferSize,
                                     		pdwRequiredSize, NULL );
   }
   else
   {
      hr = TranslateInfString( pszInfFilename, pszInstallSection, pszTranslateSection, pszTranslateKey,
                                   pszBuffer, dwBufferSize,
                                   pdwRequiredSize, NULL);
   }
   return hr;
}

#define UNUSED_STRING   "xxx"

HRESULT MyTranslateString( LPCSTR pszCif, LPCSTR pszID, LPCSTR pszTranslateKey,
                            LPSTR pszBuffer, DWORD dwBufferSize)
{
   HRESULT hr = E_FAIL;
   char szTemp[512];

   if(GetPrivateProfileString(pszID, pszTranslateKey, "", pszBuffer, dwBufferSize, pszCif))
   {
      //bad code
      DWORD dwLen = lstrlen(pszBuffer);
      if(dwLen > 2)
      {
         // Cut the last %, and then look up in string section
         if(pszBuffer[0] == '%' && pszBuffer[dwLen - 1] == '%')
         {
            pszBuffer[dwLen - 1] = 0;
            GetPrivateProfileString("Strings", pszBuffer + 1, UNUSED_STRING, szTemp, sizeof(szTemp), pszCif);
            if(lstrcmp(UNUSED_STRING, szTemp) != 0)
               lstrcpyn(pszBuffer, szTemp, dwBufferSize);
            else
               pszBuffer[dwLen - 1] = '%';
         }
      }
      hr = NOERROR;
   }

   return hr;
}

// add the quotes around the string
DWORD MyWritePrivateProfileString( LPCSTR pszSec, LPCSTR pszKey, LPCSTR pszData, LPCSTR pszFile)
{
   LPSTR pszBuf;
   DWORD dwOut = 0;

   pszBuf = (LPSTR)LocalAlloc( LPTR, lstrlen(pszData)+8 );
   if ( !pszBuf )
      return dwOut;

   lstrcpy( pszBuf, "\"" );
   lstrcat( pszBuf, pszData );
   lstrcat( pszBuf, "\"" );

   dwOut = WritePrivateProfileString(pszSec, pszKey, pszBuf, pszFile);

   LocalFree(pszBuf);
   return dwOut;
}

HRESULT WriteTokenizeString(LPCSTR pszCif, LPCSTR pszID, LPCSTR pszTranslateKey, LPCSTR pszBuffer)
{
   HRESULT hr = E_FAIL;
   char szTemp[MAX_PATH];
   LPCSTR pszKeyname, pszSecname;

   pszKeyname = pszTranslateKey;
   pszSecname = pszID;
   if(GetPrivateProfileString(pszID, pszTranslateKey, "", szTemp, sizeof(szTemp), pszCif))
   {
      //bad code
      DWORD dwLen = lstrlen(szTemp);
      if(dwLen > 2)
      {
         // Cut the last %, and then look up in string section
         if(szTemp[0] == '%' && szTemp[dwLen - 1] == '%')
         {
            szTemp[dwLen - 1] = 0;
            pszKeyname = &szTemp[1];
            pszSecname = "strings";
         }
      }
   }

   if (MyWritePrivateProfileString(pszSecname, pszKeyname, pszBuffer, pszCif))
      hr = NOERROR;

   return hr;
}


HWND GetVersionConflictHWND()
{
   char szBuf[256];

   LoadSz(IDS_VERSIONCONFLICT, szBuf, sizeof(szBuf));
   HWND hVersionConflict = FindWindowEx(NULL, NULL, (LPCSTR)
                SEARCHFORCONFLICT_CLASS, szBuf );
   if(!hVersionConflict)
   {
      LoadSz(IDS_VERSIONCONFLICTNT, szBuf, sizeof(szBuf));
      hVersionConflict = FindWindowEx(NULL, NULL, (LPCSTR)
               SEARCHFORCONFLICT_CLASS, szBuf );
   }
   return hVersionConflict;
}

HRESULT WINAPI CheckForVersionConflict()
{
   HWND hVersionConflict = GetVersionConflictHWND();

   if(hVersionConflict)
      BOOL foo = SetForegroundWindow(hVersionConflict);
   return S_OK;
}

int CompareLocales(LPCSTR pcszLoc1, LPCSTR pcszLoc2)
{
   int ret;

   if(pcszLoc1[0] == '*' || pcszLoc2[0] == '*')
      ret = 0;
   else
      ret = lstrcmpi(pcszLoc1, pcszLoc2);

   return ret;
}

HRESULT CreateTempDirOnMaxDrive(LPSTR pszDir, DWORD dwBufSize)
{
    char szRoot[] = "A:\\";
    char szDownloadDrive[] = "?:\\";
    char szDir[MAX_PATH];
    char szUnique[MAX_PATH];
    DWORD dwMaxFree = 0;
    DWORD dwDriveFree;

   if(pszDir)
      pszDir[0] = 0;

        // Check all loacle drives for diskspace and take the one with the most.
   while ( szRoot[0] <= 'Z' )
   {

       // even the drive type is OK, verify the drive has valid connection
       //
       if (!IsUsableDrive( szRoot ) )
       {
           szRoot[0]++;
           continue;
       }


       if(!IsDirWriteable(szRoot))
       {
           szRoot[0]++;
           continue;
       }

       dwDriveFree = GetSpace(szRoot);

       if (dwDriveFree > dwMaxFree)
       {
           dwMaxFree = dwDriveFree;
           szDownloadDrive[0] = szRoot[0];
       }
       szRoot[0]++;

   }
   if(szDownloadDrive[0] == '?')
      return E_FAIL;

   lstrcpy(szDir, szDownloadDrive);

   // if our suitable drive happens also to be the windows drive,
   // create msdownld.tmp of of it.
   if(szDownloadDrive[0] == g_szWindowsDir[0])
      lstrcpy(szDir, g_szWindowsDir);

   AddPath( szDir, MSDOWNLOAD );

   if ( !IfNotExistCreateDir( szDir, TRUE, TRUE) )
      return E_FAIL;

   //
   if ( !GetUniqueFileName(szDir,"AS", 0, szUnique) )
      return E_FAIL;

   lstrcpy(szDir, szUnique);

   if ( !IfNotExistCreateDir( szDir, FALSE, FALSE) )
       return E_FAIL;

   AddPath( szDir, "" );

   if ( (DWORD) lstrlen(szDir)+1 >  dwBufSize )
       return ( E_INVALIDARG );

   // success
   lstrcpy( pszDir, szDir );
   return S_OK;
}


/*
 * enabled or restores Sage
 * bRestore TRUE means restore, otherwise disable
 */
void EnableSage(BOOL bRestore)
{
//MBD 6-22: MUST USE stdcall convention when accessing sage.dll
typedef long (__stdcall *PFNDLL)(int);

    HINSTANCE hSageAPI;
    PFNDLL  pfnSageEnable;
    static int restore = ENABLE_AGENT; //initialize to valid value...

    hSageAPI = LoadLibrary("SAGE.DLL");
    if (hSageAPI != NULL)
    {
        pfnSageEnable = (PFNDLL) GetProcAddress(hSageAPI,"System_Agent_Enable");
        if(pfnSageEnable)
        {
            if(bRestore)
            {
                (pfnSageEnable)(restore);
            }
            else
            {
                if(ENABLE_AGENT == (restore = (pfnSageEnable)(GET_AGENT_STATUS)))
                {
                    (pfnSageEnable)(DISABLE_AGENT);
                }
            }
        }
        FreeLibrary(hSageAPI);
    }
}

void EnableScreenSaver(BOOL bRestore)
{
    static BOOL bScreenSaver = FALSE;
    if (bRestore)
    {
        SystemParametersInfo( SPI_SETSCREENSAVEACTIVE, bScreenSaver, 0 , 0);
        bScreenSaver = FALSE;   // reset the static to be able to disable the screensaver again.
    }
    else
    {
        // Only if the static is false call this again,
        // otherwise we did call this function already.
        if (!bScreenSaver)
        {
            SystemParametersInfo( SPI_GETSCREENSAVEACTIVE, FALSE, &bScreenSaver, 0);
            SystemParametersInfo( SPI_SETSCREENSAVEACTIVE, FALSE, 0 , 0);
        }
    }
}

void EnableDiskCleaner(BOOL bRestore)
{
   static HANDLE hDiskCleaner = NULL;
   if (bRestore)
   {
      if (hDiskCleaner)
      {
         CloseHandle(hDiskCleaner);
         hDiskCleaner = NULL;
      }
   }
   else
   {
      hDiskCleaner = CreateEvent(NULL, FALSE, FALSE, "DisableLowDiskWarning");
   }
}

#if 0
typedef HRESULT (WINAPI *COINTERNETCREATESECURITYMANAGER) ( IServiceProvider *pSP, IInternetSecurityManager **ppSM, DWORD dwReserved);

DWORD IsUrlSaveToDownloadFrom(LPSTR lpszURL)
{
    HRESULT hr;
    BOOL    bOK = FALSE;
    DWORD   dwPolicy = URLPOLICY_QUERY;     // In the default case we do checktrust
    HINSTANCE   hUrlmon;
    COINTERNETCREATESECURITYMANAGER pcicsm;

    hUrlmon = LoadLibrary("urlmon.dll");
    if (hUrlmon)
    {
        pcicsm = (COINTERNETCREATESECURITYMANAGER) GetProcAddress(hUrlmon, "CoInternetCreateSecurityManager");
        if (pcicsm)
        {
            IInternetSecurityManager    *InternetSecurityManager;
            LPWSTR  lpwszURL = NULL;
            DWORD   dwSize;
            hr = pcicsm(NULL, &InternetSecurityManager, NULL);
            if (SUCCEEDED(hr))
            {
                dwSize = sizeof(dwPolicy);
                lpwszURL = MakeWideStrFromAnsi(lpszURL, STR_OLESTR);
                hr = InternetSecurityManager->ProcessUrlAction(lpwszURL,
                                                                URLACTION_DOWNLOAD_SIGNED_ACTIVEX,
                                                               (BYTE*)&dwPolicy, dwSize, NULL, NULL, PUAF_NOUI, NULL);
                wsprintf(szLogBuf, "InternetSecurityManager->ProcessUrlAction on :%s: Policy :%ld:", lpszURL, dwPolicy);
                MessageBox(NULL, szLogBuf, "TEST", MB_OK| MB_SETFOREGROUND);
                if (GetUrlPolicyPermissions(dwPolicy) != URLPOLICY_ALLOW)
                {
                    hr = InternetSecurityManager->ProcessUrlAction(lpwszURL,
                                                                    URLACTION_DOWNLOAD_UNSIGNED_ACTIVEX,
                                                                   (BYTE*)&dwPolicy, dwSize, NULL, NULL, PUAF_NOUI, NULL);
                    wsprintf(szLogBuf, "InternetSecurityManager->ProcessUrlAction on :%s: Policy :%ld:", lpszURL, dwPolicy);
                    MessageBox(NULL, szLogBuf, "TEST", MB_OK| MB_SETFOREGROUND);
                }
                if (lpwszURL)
                    CoTaskMemFree(lpwszURL);
                InternetSecurityManager->Release();
            }
        }
        FreeLibrary(hUrlmon);
    }
    return dwPolicy;
}
#endif

BOOL PathIsFileSpec(LPCSTR lpszPath)
{
    for (; *lpszPath; lpszPath = CharNext(lpszPath)) {
        if (*lpszPath == '\\' || *lpszPath == ':')
            return FALSE;
    }
    return TRUE;
}

const char c_gszRegstrPathIExplore[] = REGSTR_PATH_APPPATHS "\\iexplore.exe";

HRESULT GetIEPath(LPSTR pszPath, DWORD dwSize)
{
   HRESULT hr = NOERROR;
   UINT i;
   DWORD dwType;
   HKEY hKey;

   // findout where ie is, append on cif name
   if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_gszRegstrPathIExplore, 0, KEY_QUERY_VALUE, &hKey) == ERROR_SUCCESS)
   {
      if ((RegQueryValueEx(hKey, NULL, 0, &dwType, (LPBYTE)pszPath, &dwSize) == ERROR_SUCCESS) &&
           (dwType == REG_SZ))
      {
         GetParentDir(pszPath);
      }
      else
         hr = E_INVALIDARG;

      RegCloseKey(hKey);
   }
   else
      hr = E_FAIL;

   return hr;
}

DWORD MyGetFileSize(LPCSTR pszFilename)
{
    DWORD dwSize;
    WIN32_FIND_DATA fileData;
    HANDLE hFindFile;
    dwSize = 0;
    hFindFile = FindFirstFile( pszFilename, &fileData );

    if ( hFindFile != INVALID_HANDLE_VALUE )
    {
        if (fileData.nFileSizeHigh == 0)
            dwSize = fileData.nFileSizeLow;
        else
            dwSize = (DWORD)-1;
        FindClose( hFindFile  );
    }
    return dwSize;
}

WORD GetNTProcessorArchitecture(void)
{
    static WORD wNTProcArch = -1 ;
    SYSTEM_INFO System_info;

    // If we have calculated this before just pass that back.
    // else find it now.
    //
    if (wNTProcArch == (WORD)-1)
    {
        GetSystemInfo(&System_info);
        wNTProcArch = System_info.wProcessorArchitecture;
    }

    return wNTProcArch;
}

DWORD GetCurrentPlatform()
{
   static DWORD dwPlatform = 0xffffffff;

   if(dwPlatform != 0xffffffff)
      return dwPlatform;

   OSVERSIONINFO VerInfo;

   VerInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
   GetVersionEx(&VerInfo);

   if (VerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
   {
      // Running NT
      if (GetNTProcessorArchitecture() == PROCESSOR_ARCHITECTURE_ALPHA)
      {
         dwPlatform = PLATFORM_NT5ALPHA;
         if (VerInfo.dwMajorVersion == 4)
            dwPlatform = PLATFORM_NT4ALPHA;
      }
      else
      {
         dwPlatform = PLATFORM_NT5;
         if (VerInfo.dwMajorVersion == 4)
            dwPlatform = PLATFORM_NT4;
      }
   }
   else
   {         // Running Windows 9x
      dwPlatform = PLATFORM_WIN98;
      if (VerInfo.dwMinorVersion == 0)
         dwPlatform = PLATFORM_WIN95;
      else if (VerInfo.dwMinorVersion == 90)
        dwPlatform = PLATFORM_MILLEN;
   }
   return dwPlatform;
}

BOOL FNeedGrpConv()
{
   char szSetupIni[MAX_PATH];

   if(GetWindowsDirectory(szSetupIni, sizeof(szSetupIni)))
   {
      AddPath(szSetupIni, "setup.ini");
      return(GetFileAttributes(szSetupIni) != 0xffffffff);
   }

   return FALSE;
}

void CopyCifString(LPCSTR pcszSect, LPCSTR pcszKey, LPCSTR pcszCifSrc, LPCSTR pcszCifDest)
{
    char szField[MAX_PATH];
    char szString[MAX_PATH];
    LPSTR pszPercent;

    if (GetPrivateProfileString(pcszSect, pcszKey, "", szField, sizeof(szField), pcszCifSrc)
        && (szField[0] == '%'))
    {
        pszPercent = ANSIStrChr(&szField[1], '%');
        if (pszPercent)
        {
            *pszPercent = '\0';
            GetPrivateProfileString("Strings", &szField[1], "", szString, sizeof(szString), pcszCifSrc);
            WritePrivateProfileString("Strings", &szField[1], szString, pcszCifDest);
        }
    }
}

//---------------------------------------------------------
// Function to log the Date/Time stamp for each Component.
//---------------------------------------------------------
void GetTimeDateStamp(LPSTR lpLogBuf)
{
    SYSTEMTIME  SystemTime;

    GetLocalTime(&SystemTime);
    wsprintf(lpLogBuf, "Date:%d/%d/%d (M/D/Y) Time:%d:%d:%d",
                SystemTime.wMonth, SystemTime.wDay, SystemTime.wYear,
                SystemTime.wHour, SystemTime.wMinute, SystemTime.wSecond);
	
}


HRESULT WINAPI DownloadFile(LPCSTR szURL, LPCSTR szFilename, HWND hwnd, BOOL bCheckTrust, BOOL bShowBadUI)
{
    HRESULT hr;
    char szTempfile[MAX_PATH];
    char szTemp[MAX_PATH];

    CDownloader *pDL = new CDownloader();
    
    if(!pDL)
        return E_OUTOFMEMORY;
    
    hr = pDL->SetupDownload(szURL, NULL, 0, NULL);
    szTempfile[0] = 0;
    if(SUCCEEDED(hr))
    {
        hr = pDL->DoDownload(szTempfile, sizeof(szTempfile));
    }
    
    pDL->Release();
    
    if(SUCCEEDED(hr))
    {
        if (bCheckTrust)
        {
            hr = ::CheckTrustEx(szURL, szTempfile, bShowBadUI?hwnd:(HWND)INVALID_HANDLE_VALUE, bShowBadUI, NULL);
        }

        if(!CopyFile(szTempfile, szFilename, FALSE))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }

    if(szTempfile[0] != 0)
    {
        GetParentDir(szTempfile);
        CleanUpTempDir(szTempfile);
    }
    return hr;
}


BOOL IsPatchableINF(LPTSTR pszInf)
{
    TCHAR szBuf[MAX_PATH];

    if (GetPrivateProfileInt("DefaultInstall", "Patching", 0, pszInf) ||
        GetPrivateProfileString("DownloadFileSection", NULL, "", szBuf, sizeof(szBuf), pszInf))
        return TRUE;
    else
        return FALSE;
}




PFNGETFILELIST g_pfnGetFileList                     = NULL;
PFNDOWNLOADANDPATCHFILES g_pfnDownloadAndPatchFiles = NULL;
PFNPROCESSFILESECTION g_pfnProcessFileSection       = NULL;

BOOL InitSRLiteLibs()
{
    HINSTANCE hAdvpext = LoadLibrary(c_gszAdvpext);

    if (hAdvpext == NULL)
        return FALSE;
    g_pfnGetFileList           = (PFNGETFILELIST) GetProcAddress(hAdvpext, "GetFileList");
    g_pfnDownloadAndPatchFiles = (PFNDOWNLOADANDPATCHFILES) GetProcAddress(hAdvpext, "DownloadAndPatchFiles");
    g_pfnProcessFileSection    = (PFNPROCESSFILESECTION) GetProcAddress(hAdvpext, "ProcessFileSection");

    if (g_pfnGetFileList == NULL ||
        g_pfnDownloadAndPatchFiles == NULL ||
        g_pfnProcessFileSection == NULL
       )
    {
        FreeLibrary(hAdvpext);
        return FALSE;
    }
    else
        return TRUE;
}

void FreeSRLiteLibs()
{
    HMODULE hMod;

    hMod = GetModuleHandle(c_gszAdvpext);
    if (hMod)
        FreeLibrary(hMod);
}

// For now, we're patching on any IE5 version, so we might
// as well perform a check similar to ie5wzd
BOOL IsPatchableIEVersion()
{
    char szIE[MAX_PATH] = { 0 };
    DWORD   dwMSVer, dwLSVer;

    GetSystemDirectory(szIE, sizeof(szIE));
    AddPath(szIE, "shdocvw.dll");
    GetVersionFromFile(szIE, &dwMSVer, &dwLSVer, TRUE);

    return (dwMSVer >= 0x00050000);
}

BOOL IsCorrectAdvpExt()
{
    DWORD   dwMSVer, dwLSVer;

    GetVersionFromFile(c_gszAdvpext, &dwMSVer, &dwLSVer, TRUE);

    return (dwMSVer >= 0x00050032);
}

BOOL CheckImageHlp_dll()
{
    char szFile[MAX_PATH] = { 0 };
    DWORD   dwMSVer, dwLSVer;

    GetSystemDirectory(szFile, sizeof(szFile));
    AddPath(szFile, "imagehlp.dll");
    GetVersionFromFile(szFile, &dwMSVer, &dwLSVer, TRUE);

    return (!(dwMSVer == 0x00040000) || !(dwLSVer == 0x04C90001));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\ntmigrat\migrate.cpp ===
// This is the migration dll for NT5 upgrades.
// As per the Migration Extension Interface of NT5 Setup, this DLL needs to
// implement the folowing six functions:
//        QueryVersion
//        Initialize9x
//         MigrateUser9x     (called once for every user)
//        MigrateSystem9x
//        InitializeNT
//        MigrateUserNT     (called once for every user)
//        MigrateSystemNT
//
// Written : ShabbirS (5/7/99)
// Revision:
//


#include "pch.h"
#include <ole2.h>
#ifdef __cplusplus
extern "C" {
#endif
#include <excppkg.h>
#ifdef __cplusplus
}
#endif  /* __cplusplus */

#include "sdsutils.h"
#include "advpub.h"
#include "migrate.h"
#include "utils.h"
#include "resource.h"

// Constants:
#define CP_USASCII            1252
#define END_OF_CODEPAGES    -1

// Globals that are passed back to Setup.
//////////////////////////////////////////
// Vendor Info:
VENDORINFO g_VendorInfo = { "Microsoft Corporation", 
                            " ", 
                            "http://www.microsoft.com/support",
                            "Please contact Microsoft Technical Support for assistance with this problem.  "};

// Product ID:
char g_cszProductID[] = "Microsoft Internet Explorer";

// Version number of this Migration Dll
UINT g_uVersion = 3;

// Array of integers specifying the CodePages we use. (Terminated with -1)
int  g_rCodePages[] = {CP_USASCII, END_OF_CODEPAGES};

// Multi-SZ ie double Null terminated list of strings.
char  *g_lpNameBuf = NULL;
DWORD  g_dwNameBufSize = 0;
char  *g_lpWorkingDir = NULL;
char  *g_lpSourceDirs = NULL;
char  *g_lpMediaDir = NULL;

char g_szMigrateInf[MAX_PATH];
char g_szPrivateInf[MAX_PATH];

LONG
CALLBACK
QueryVersion(   OUT LPCSTR *ProductID,
                OUT LPUINT DllVersion,
                OUT LPINT  *CodePageArray, OPTIONAL
                OUT LPCSTR *ExeNameBuf,    OPTIONAL
                OUT PVENDORINFO *VendorInfo
            )
{
    // NOTE: There is timing restriction on the return from this function
    //       So keep this as short and sweet as possible.
    VENDORINFO myVendorInfo;
    LONG lRet = ERROR_SUCCESS;

    AppendString(&g_lpNameBuf, &g_dwNameBufSize, cszRATINGSFILE);
    AppendString(&g_lpNameBuf, &g_dwNameBufSize, cszIEXPLOREFILE);

    // Pass back to Setup the product name.
    *ProductID = g_cszProductID;

    // Pass back to Setup the version number of this DLL.
    *DllVersion = g_uVersion;

    // We will use English messages only but don't specify a code page or 
    // the migration dll won't run on alternate code pages.
    *CodePageArray = NULL;

    // Pass back to Setup the list of files we want detected on this system.
    *ExeNameBuf = g_lpNameBuf;

    // Pass back the VendorInfo.
    if (LoadString(g_hInstance, IDS_COMPANY, myVendorInfo.CompanyName, sizeof(myVendorInfo.CompanyName)) == 0)
        lstrcpy(myVendorInfo.CompanyName, "Microsoft Corporation");

    if (LoadString(g_hInstance, IDS_SUPPORTNUMBER, myVendorInfo.SupportNumber, sizeof(myVendorInfo.SupportNumber)) == 0)
        lstrcpy(myVendorInfo.SupportNumber, " ");

    if (LoadString(g_hInstance, IDS_SUPPORTURL, myVendorInfo.SupportUrl, sizeof(myVendorInfo.SupportUrl)) == 0)
        lstrcpy(myVendorInfo.SupportUrl, "http://www.microsoft.com/support");

    if (LoadString(g_hInstance, IDS_INSTRUCTIONS, myVendorInfo.InstructionsToUser, sizeof(myVendorInfo.InstructionsToUser)) == 0)
        lstrcpy(myVendorInfo.InstructionsToUser, "Please contact Microsoft Technical Support for assistance with this problem.  ");

    *VendorInfo = &myVendorInfo;

#ifdef DEBUG
    char szDebugMsg[MAX_PATH*3];
    wsprintf(szDebugMsg,"IE6:ProductID: %s \r\n", *ProductID);
    SetupLogError(szDebugMsg, LogSevInformation);
#endif

    return lRet;

}

LONG
CALLBACK
Initialize9x(   IN    LPCSTR WorkingDir,
                IN    LPCSTR SourceDirs,
                IN    LPCSTR MediaDirs
            )
{
    // Called by NT Setup if QUeryVersion returned SUCCESS
    // At this point we have been relocated to some specific location
    // on the local drive by the Setup process.

    INT    len;

    // Keep track of our new location (ie. the Working Directory).
    // NT Setup will create the "MIGRATE.INF" file in this dir and use that
    // to exchange info with us.
    // Also we can use this Dir for saving our private stuff. NT Setup will 
    // ensure this folder stays till end of NT Migration. After that it will
    // be cleaned.
    len = lstrlen(WorkingDir) + 1;
    g_lpWorkingDir = (char *) LocalAlloc(LPTR,sizeof(char)*len);

    if (!g_lpWorkingDir)
    {
        return GetLastError();
    }

    CopyMemory(g_lpWorkingDir, WorkingDir, len);


    len = lstrlen(MediaDirs) + 1;
    g_lpMediaDir = (char *) LocalAlloc(LPTR,sizeof(char)*len);

    if (!g_lpMediaDir)
    {
        return GetLastError();
    }

    CopyMemory(g_lpMediaDir, MediaDirs, len);

    // Also keep track of the NT installation files path (ie Sources Dir).
    // NOTE: Right now we don't need it, so skip doing it.

    // Generate the path names to Migrate.inf and the private files
    // (private.inf) that we need
    GenerateFilePaths();
    
    // If NT Setup has succeeded in getting path to Ratings.Pol, it implies
    // Ratings information exists. Enable our private marker to do the right
    // thing in MigrateSystemNT phase.
    if (GetRatingsPathFromMigInf(NULL))
    {    // Put a marker in PRIVATE.INF so that MigrateSystemNT phase knows 
        // that it has to munge the Rating.

        // Private.Inf does not exist at this point so why this check!!!
        // if (GetFileAttributes(g_szPrivateInf) != 0xffffffff)
        WritePrivateProfileString(cszIEPRIVATE, cszRATINGS, "Yes", g_szPrivateInf);
        // Flush the cached entries to disk.
        WritePrivateProfileString(NULL,NULL,NULL,g_szPrivateInf);

#ifdef DEBUG
    SetupLogError("IE6: Created PRIVATE.INF\r\n", LogSevInformation);
#endif
    }

    return ERROR_SUCCESS;
}


LONG
CALLBACK
MigrateUser9x(  IN HWND      ParentWnd,
                IN LPCSTR    UnattendFile,
                IN HKEY      UserRegKey,
                IN LPCSTR    UserName,
                   LPVOID    Reserved
            )
{
    // This function is called by NT Setup for each user.
    // Currently for the Ratings scenario, we don't need any PerUser action.
#ifdef DEBUG
    SetupLogError("IE6: Skipping MigrateUser9x \r\n", LogSevInformation);
#endif
    return ERROR_SUCCESS;

}


LONG
CALLBACK
MigrateSystem9x(    IN HWND      ParentWnd,
                    IN LPCSTR    AnswerFile,
                    LPVOID       Reserved
                )
{
    // This function is called once by NT Setup to let us save System wide info.
    //
    // we are writing the "incompatibility report here if IE5.5 is installed and 
    // the user does not have the full migration pack installed.
    //

    char    szCab[MAX_PATH];
    WORD  wVer[4];
    char szBuf[MAX_PATH];

    // Check if we have the full exception pack which re-installs IE5.5

    // NOTE: g_lpMediaDir is the location where the migration dll was installed/registered
    // This is the same location where the INF is.
    lstrcpy(szCab, g_lpMediaDir);
    AddPath(szCab, "ieexinst.inf");
    if (GetPrivateProfileString("Info", "Version", "", szBuf , MAX_PATH, szCab) != 0) 
    {
        // Convert version
        ConvertVersionString( szBuf, wVer, '.' );

        if ((wVer[0] == 5) && (wVer[1] == 50))
        {
            // We don't have the full exception pack.
            // generate the "incompatibility report"
            // g_szMigrateInf
            lstrcpy(szBuf, g_lpMediaDir);
            GetParentDir(szBuf);

            if (LoadString(g_hInstance, IDS_INCOMPAT_MSG, szCab, sizeof(szCab)))
            {
                WritePrivateProfileString(cszMIGINF_INCOMPAT_MSG, g_cszProductID, szCab, g_szMigrateInf);
                WritePrivateProfileString(g_cszProductID, szBuf, "Report", g_szMigrateInf);
                WritePrivateProfileString(NULL,NULL,NULL,g_szMigrateInf);
            }
        }
    }

    WritePrivateProfileString(cszMIGINF_HANDLED, "HKLM\\Software\\Microsoft\\Active Setup\\ClsidFeature", "Registry", g_szMigrateInf);
    WritePrivateProfileString(cszMIGINF_HANDLED, "HKLM\\Software\\Microsoft\\Active Setup\\FeatureComponentID", "Registry", g_szMigrateInf);
    WritePrivateProfileString(cszMIGINF_HANDLED, "HKLM\\Software\\Microsoft\\Active Setup\\MimeFeature", "Registry", g_szMigrateInf);
    WritePrivateProfileString(NULL,NULL,NULL,g_szMigrateInf);
#ifdef DEBUG
    SetupLogError("IE6: MigrateSystem9x \r\n", LogSevInformation);
#endif
    
    return ERROR_SUCCESS;
}



LONG
CALLBACK 
InitializeNT (
    IN      LPCWSTR WorkingDirectory,
    IN      LPCWSTR SourceDirectories,
            LPVOID  Reserved
    )
{
    INT Length;
    LPCWSTR p;

    //
    // Save our working directory and source directory.  We
    // convert UNICODE to ANSI, and we use the system code page.
    //

    //
    // Compute length of source directories
    //

    p = SourceDirectories;
    while (*p) {
        p = wcschr (p, 0) + 1;
    }
    p++;
    Length = (p - SourceDirectories) / sizeof (WCHAR);

    //
    // Convert the directories from UNICODE to DBCS.  This DLL is
    // compiled in ANSI.
    //

    g_lpWorkingDir = (LPSTR) LocalAlloc(LPTR, MAX_PATH);
    if (!g_lpWorkingDir) {
        return GetLastError();
    }

    WideCharToMultiByte (
        CP_ACP, 
        0, 
        WorkingDirectory, 
        -1,
        g_lpWorkingDir,
        MAX_PATH,
        NULL,
        NULL
        );

    //  Also save the SourceDirectories that points to the Windows
    //  NT media (i.e. e:\i386) and optional directories specified on
    //  the WINNT32 command line. Not used currently, so skip.

    // Now generate the derived file names
    GenerateFilePaths();

#ifdef DEBUG
    SetupLogError("IE6: Done InitializeNT \r\n", LogSevInformation);
#endif

    return ERROR_SUCCESS;
}

LONG
CALLBACK 
MigrateUserNT (
    IN      HINF UnattendInfHandle,
    IN      HKEY UserRegKey,
    IN      LPCWSTR UserName,
            LPVOID Reserved
    )
{
    // No per-user settings for Ratings upgrade.
#ifdef DEBUG
    SetupLogError("IE6: Skipping MigrateUserNT \r\n", LogSevInformation);
#endif
    
    return ERROR_SUCCESS;
}


#define PACKAGE_GUID       "{89820200-ECBD-11cf-8B85-00AA005B4383}"
#define PACKAGE_DIRECTORY    "%windir%\\RegisteredPackages\\"


LONG
CALLBACK 
MigrateSystemNT (
    IN      HINF UnattendInfHandle,
            LPVOID Reserved
    )
{    // NOTE: This phase MUST finish in 60 seconds or will be terminated.
    
    // Check if our PRIVATE.INF exists and perform relevant actions based on its contents.
    CHAR szBuffer[3+10];

    if (GetFileAttributes(g_szPrivateInf) != 0xffffffff)
    {
        GetPrivateProfileString(cszIEPRIVATE, cszRATINGS, "", szBuffer, sizeof(szBuffer), g_szPrivateInf);
        if (lstrcmpi(szBuffer,"Yes")==0)
        {
            UpgradeRatings();
            SetupLogError("IE Migration: Upgraded Ratings info.\r\n", LogSevInformation);
        }
    }
    else
    {
        SetupLogError("IE Migration: No Rating migration. Private.Inf does not exist.\r\n",LogSevInformation);
    }

#if 0
    // Do the W2K IE5.5 migration work here.
    // 1. Copy all files from the IE location to the registered migration pack location
    // 2. Register the migration pack
    SETUP_OS_COMPONENT_DATA ComponentData,cd;
    SETUP_OS_EXCEPTION_DATA ExceptionData,ed;
    GUID MyGuid;
    PWSTR GuidString;
    PSTR  t;
    BOOL  bContinue = FALSE;
    WCHAR szMsg[1024];
    char  szPath[MAX_PATH];
    LPWSTR pszwPath;
    WORD  wVer[4];
    char szBuf[MAX_PATH];
    char szInf[MAX_PATH];
    char szGUID[MAX_PATH];
    char szCab[MAX_PATH];
    char szDir[MAX_PATH];
#ifdef DEBUG
    char sz[1024];
#endif
    HRESULT hr;

    char szCabs[1024];
    LPSTR pCab = NULL;

    // Get the INF which is installed in the W2K folder.
    // This INF tells us the info about the IE exception pack.
    // g_lpWorkingDir contains all fiels and sub folders which are in the same place 
    // as the registerd migration dll. Since we install the files in the same folder, we can use it.
    lstrcpy(szInf, g_lpWorkingDir);
    AddPath(szInf, "ieexinst.inf");
#ifdef DEBUG
    wsprintf(sz, "IE exception INF :%s:\r\n", szInf);
    SetupLogError(sz,LogSevInformation);
#endif
    if (GetFileAttributes(szInf) != (DWORD)-1)
    {
        // Get the GUID
        if (GetPrivateProfileString("Info", "ComponentId", "", szGUID, sizeof(szGUID), szInf) == 0)
            lstrcpy(szGUID, PACKAGE_GUID);
        
        ExpandEnvironmentStrings( PACKAGE_DIRECTORY, szDir, sizeof(szDir));
        if (GetFileAttributes(szDir) == (DWORD)-1)
            CreateDirectory( szDir, NULL );
        AddPath(szDir, szGUID);
        if (GetFileAttributes(szDir) == (DWORD)-1)
            CreateDirectory( szDir, NULL );
        
        // BUGBUG:
        // The extraction of the CAB file(s) should be done after we found out
        // If the user has already a newer exception pack registered.
        // This check is done below. Could not change it anymore, because of
        // time constrains. Found this in the code review
        //
        // Extract all CABs into the package fodler.
#ifdef DEBUG
        wsprintf(sz, "cab folder :%s:\r\n", g_lpWorkingDir);
        SetupLogError(sz,LogSevInformation);
        wsprintf(sz, "extract folder :%s:\r\n", szDir);
        SetupLogError(sz,LogSevInformation);
#endif
        if (GetPrivateProfileSection("Cab.List", szCabs, sizeof(szCabs), szInf) != 0)
        {
            pCab = szCabs;
            while (*pCab != '\0')
            {
                lstrcpy(szCab, g_lpWorkingDir);
                AddPath(szCab, pCab);
#ifdef DEBUG
                wsprintf(sz, "Extract :%s: to :%s:\r\n", szCab, szDir);
                SetupLogError(sz,LogSevInformation);
#endif
                
                hr = ExtractFiles(szCab, szDir, 0, NULL, NULL, 0);
                pCab += (lstrlen(pCab) + 1);
            }
            bContinue = TRUE;
        }
    }

    if (bContinue)
    {
        if (GetPrivateProfileString("Info", "Version", "", szBuf , MAX_PATH, szInf) != 0) 
        {
            // Convert version
            ConvertVersionString( szBuf, wVer, '.' );

            ComponentData.SizeOfStruct = sizeof(SETUP_OS_COMPONENT_DATA);
            ExceptionData.SizeOfStruct = sizeof(SETUP_OS_EXCEPTION_DATA);
            pszwPath = MakeWideStrFromAnsi(szGUID);
            if (pszwPath)
            {
                IIDFromString( pszwPath, &MyGuid);
                CoTaskMemFree(pszwPath);

                if (SetupQueryRegisteredOsComponent(
                                            &MyGuid,
                                            &ComponentData,
                                            &ExceptionData)) 
                {
                    if ((ComponentData.VersionMajor < wVer[0]) ||
                        ((ComponentData.VersionMajor == wVer[0]) && (ComponentData.VersionMinor <= wVer[1])) )
                    {
                        bContinue = SetupUnRegisterOsComponent(&MyGuid);
                        SetupLogError("IE6: SetupUnRegisterOsComponent.\r\n",LogSevInformation);
                    }
                    // BUGBUG: Missing the below else. Found in code review
                    // else
                    //     bContinue = FALSE;
                }
            }
            else
                bContinue = FALSE;
        }
        else
            bContinue = FALSE;
    }
    if (bContinue)
    {
        SetupLogError("IE6: Preparing SetupRegisterOsComponent.\r\n",LogSevInformation);
        ExpandEnvironmentStrings( PACKAGE_DIRECTORY, szPath, sizeof(szPath));
        AddPath( szPath, szGUID );

        ComponentData.VersionMajor = wVer[0];
        ComponentData.VersionMinor = wVer[1];
        RtlMoveMemory(&ComponentData.ComponentGuid, &MyGuid,sizeof(GUID));

        t = szPath + lstrlen(szPath);
        *t = '\0';
        GetPrivateProfileString("Info", "InfFile", "", szBuf, MAX_PATH, szInf);
        AddPath( szPath, szBuf);

        pszwPath = MakeWideStrFromAnsi(szPath);
        if (pszwPath)
        {
            wcscpy(ExceptionData.ExceptionInfName, pszwPath);
            CoTaskMemFree(pszwPath);
        }

        *t = '\0';
        GetPrivateProfileString("Info", "CatalogFile", "", szBuf, MAX_PATH, szInf);
        AddPath( szPath, szBuf);

        pszwPath = MakeWideStrFromAnsi(szPath);
        if (pszwPath)
        {
            wcscpy(ExceptionData.CatalogFileName, pszwPath);
            CoTaskMemFree(pszwPath);
        }

        LoadString(g_hInstance, IDS_FRIENDLYNAME, szPath, sizeof(szPath));
        pszwPath = MakeWideStrFromAnsi(szPath);
        if (pszwPath)
        {
            wcscpy(ComponentData.FriendlyName, pszwPath);
            CoTaskMemFree(pszwPath);
        }

        wsprintfW(szMsg, L"IE6: ExceptionData\r\n\tInf: %ws\r\n\tCatalog: %ws\r\n",
                 ExceptionData.ExceptionInfName,ExceptionData.CatalogFileName);
        SetupLogErrorW(szMsg,LogSevInformation);

        if (SetupRegisterOsComponent(&ComponentData, &ExceptionData)) 
        {
            SetupLogError("IE6: SetupRegisterOsComponent succeeded.\r\n",LogSevInformation);
#ifdef DEBUG
            cd.SizeOfStruct = sizeof(SETUP_OS_COMPONENT_DATA);
            ed.SizeOfStruct = sizeof(SETUP_OS_EXCEPTION_DATA);
            if (SetupQueryRegisteredOsComponent( &MyGuid, &cd, &ed)) 
            {
                StringFromIID(cd.ComponentGuid, &GuidString);
                wsprintfW(szMsg, L"IE6: Component Data\r\n\tName: %ws\r\n\tGuid: %ws\r\n\tVersionMajor: %d\r\n\tVersionMinor: %d\r\n",
                         cd.FriendlyName,GuidString,cd.VersionMajor,cd.VersionMinor);
                SetupLogErrorW(szMsg,LogSevInformation);

                wsprintfW(szMsg, L"IE6: ExceptionData\r\n\tInf: %ws\r\n\tCatalog: %ws\r\n",
                         ed.ExceptionInfName,ed.CatalogFileName);
                SetupLogErrorW(szMsg,LogSevInformation);

                CoTaskMemFree( GuidString );
            }
#endif
        }
    }
    // In future, check for other settings here and perform necessary upgrade actions.
#endif
#ifdef DEBUG
    SetupLogError("IE6: Done MigrateSystemNT \r\n", LogSevInformation);
#endif
    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\ntmigrat\utils.cpp ===
#include "pch.h"
#include <ole2.h>
#include "advpub.h"
#include "sdsutils.h"
#include "migrate.h"
#include "utils.h"


BOOL AppendString(LPSTR *lpBuffer, DWORD *lpdwSize, LPCSTR lpStr)
{
    DWORD cbBufferUsed = 0;
    DWORD dwNewSize = 0;
    LPSTR lpTmp = NULL;
    DWORD dwLen = 0;

    // Sanity check
    if (lpStr == NULL || *lpStr == '\0')
        return FALSE;
        
    if (*lpBuffer == NULL)
    {
        // Allocate the buffer.
        *lpdwSize = sizeof(char) * MAX_PATH;
        *lpBuffer = (char *) LocalAlloc(LPTR, *lpdwSize);
        if (*lpBuffer == NULL)
        {
#ifdef DEBUG
            SetupLogError("IE6: AppendString memory failure\r\n",LogSevInformation);
#endif
            return FALSE;
        }
    }

    dwNewSize = lstrlen(lpStr);

    // Get the number of bytes used up, excluding the second terminating NULL (-1)
    cbBufferUsed = CountMultiStringBytes((LPCSTR)*lpBuffer) - 1;

    if ( (*lpdwSize - cbBufferUsed) < (dwNewSize + 2))
    {
        LPSTR lpNewBuffer = NULL;
        DWORD dwTemp = 0;

        // Need to reallocate.
        dwTemp = *lpdwSize + (max((sizeof(char) * MAX_PATH), dwNewSize+2));
        lpNewBuffer = (char *) LocalAlloc(LPTR,dwTemp);

        if ( lpNewBuffer == NULL)
        {
#ifdef DEBUG
            SetupLogError("IE6: AppendString memory failure\r\n",LogSevInformation);
#endif
            return FALSE;
        }
        else
        {   
            // Rearrange the IN pointer to point to the new block.
            // Copy over the old info to the new allocated block.
            //    +1 for the one that we subtracted above.
            CopyMemory(lpNewBuffer, *lpBuffer, cbBufferUsed+1);

            // Free the old buffer.
            LocalFree(*lpBuffer);

            // Point to the new buffer.
            *lpBuffer = (char *) lpNewBuffer;
            *lpdwSize = dwTemp;
        }
    }

    // Append the new string now.
    lpTmp = *lpBuffer + cbBufferUsed;
    lstrcpy(lpTmp,lpStr);

    // Add the second terminating NULL to it now.
    lpTmp += (dwNewSize + 1);
    *lpTmp = '\0';

    return TRUE;
}

// NOTE NOTE: This function is called during the QueryVersion phase. Hence it needs to be small and fast
// So we just do the check for the presence of the "HKLM\S\M\W\CV\Policies\Ratings" key and don't try to 
// verify using MSRating API.

#define REGVAL_KEY   "Key"

BOOL IsRatingsEnabled()
{
    HKEY hKey;
    BOOL bRet = FALSE;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,REGKEY_RATING,KEY_READ,NULL,&hKey) == ERROR_SUCCESS)
    {
        DWORD dwType;
        if (RegQueryValueEx(hKey,REGVAL_KEY,NULL,&dwType, NULL, NULL) == ERROR_SUCCESS 
            && dwType == REG_BINARY)
        {
#ifdef DEBUG
            SetupLogError("IE6: Located RATINGS\Key", LogSevInformation);
#endif
            // The Ratings key exists and Password has been set. Means Ratings
            // is enabled.
            bRet = TRUE;
        }
        RegCloseKey(hKey);
    }

    return bRet;
}

// Returns the number of used bytes in a double NULL terminated string, including the two NULLS.
DWORD CountMultiStringBytes (LPCSTR lpString)
{
    DWORD cbBytes;
    LPSTR lpTmp;
    DWORD dwLen;
    
    // Sanity check
    if (lpString == NULL)
        return 0;

    // Get to the double \0 termination of lpBuffer
    lpTmp = (LPSTR)lpString;
    cbBytes = 1;
    while (lpTmp && *lpTmp != '\0')
    {
        dwLen = lstrlen(lpTmp) + 1;
        lpTmp = lpTmp + dwLen;
        cbBytes += dwLen;
    }

    return cbBytes;
}

BOOL PathEndsInFile(LPSTR lpPath, LPCSTR lpFile)
{
    LPSTR pTmp = lpPath;

    // Sanity check
    if (lpPath == NULL || lpFile == NULL)
        return FALSE;
 
#ifdef DEBUG
    char szDebug[MAX_PATH*3];
    wsprintf(szDebug,"IE5 (PathEndsInFile): %s :: %s \r\n", lpPath, lpFile);
    SetupLogError(szDebug,LogSevInformation);
#endif

    // Point pTmp to the terminating NULL
    pTmp = lpPath + lstrlen(lpPath);

    while (*pTmp != '\\' && pTmp != lpPath)
    {
        pTmp = CharPrev(lpPath, pTmp);
    }

    pTmp = CharNext(pTmp);

#ifdef DEBUG
    wsprintf(szDebug,"IE5 (PathEndsInFile): %s :: %s \r\n", pTmp, lpFile);
    SetupLogError(szDebug,LogSevInformation);
#endif

    return (lstrcmpi(pTmp, lpFile) == 0);
}
        

// Helper function to get the path for "Ratings.pol" from the MIGRATE.INF
// The path is returned in a buffer allocated by the function.
// **********************************************************************
// *** NOTE *** : It is the caller function responsibilty to free memory.
// **********************************************************************
// Parameters:
//    lpOutBuffer: Ptr to variable to hold the new string allocated.
//    User can pass in NULL if only interested in existance of Ratings.pol
//    and not the actual path to it.
BOOL GetRatingsPathFromMigInf( LPSTR *lpOutBuffer)
{
    INFCONTEXT ic;
    HINF       hInf;
    BOOL       bFound = FALSE;
    LPSTR      lpBuf = NULL;
    DWORD      dwSize, dwNewSize;

    if (lpOutBuffer)
        *lpOutBuffer = NULL;

    dwSize = MAX_PATH;
    lpBuf = (char *) LocalAlloc(LPTR, sizeof(char)*dwSize);
    if (lpBuf == NULL)
        return FALSE;
                
    // Before calling the migration DLL, Setup sets the CurrentDirectory to
    // the directory assigned to that migration DLL. Hence can use this.
    //hInf = SetupOpenInfFile(cszMIGRATEINF, NULL, INF_STYLE_WIN4, NULL);
    hInf = SetupOpenInfFile(g_szMigrateInf, NULL, INF_STYLE_WIN4, NULL);
    if (hInf)
    {
#ifdef DEBUG
        SetupLogError("IE6: Opened Miginf.inf \r\n", LogSevInformation);
#endif
        if (SetupFindFirstLine(hInf,cszMIGINF_MIGRATION_PATHS,NULL,&ic))
        {
            do 
            {
                dwNewSize = 0;
                if( SetupGetLineTextA(&ic,hInf,NULL,NULL,lpBuf,dwSize,&dwNewSize) == 0 && dwNewSize > dwSize)
                {   // Need more buffer space
                    // Free the old buffer space.
                    LocalFree(lpBuf);

                    // Try and allocate a new buffer.
                    dwSize = dwNewSize;
                    lpBuf = (char *) LocalAlloc(LPTR, sizeof(char)*dwSize);

                    if (lpBuf == NULL)
                    {
                        // Memory Error - break out.
                        break;
                    }

                    if (!SetupGetLineTextA(&ic,hInf,NULL,NULL,lpBuf,dwSize,&dwNewSize))
                    {
                        // The bFound check below takes care of LocalFree(lpBuf);
#ifdef DEBUG
                        SetupLogError("IE6: Error doing SetupGetTextLineA \r\n", LogSevInformation);
#endif
                        break; // Failure can't help it.
                    }
                }

                // So managed to read out the line. Check if it contains .pol
                if (PathEndsInFile(lpBuf,cszRATINGSFILE))
                {
                    if (lpOutBuffer)
                    {
                        *lpOutBuffer = lpBuf;
                    }
                    else
                    {   // User is not interested in Path. Free the block.
                        LocalFree(lpBuf);
                    }
                    bFound = TRUE;
#ifdef DEBUG
                    SetupLogError("IE6: Found Ratings.Pol in Migrate.Inf \r\n", LogSevInformation);
#endif
                }
            }
            while (!bFound && SetupFindNextLine(&ic,&ic));

        }

        SetupCloseInfFile(hInf);
    }

    if (!bFound)
    {
        // Free the local buffer.
        LocalFree(lpBuf);
    }

    return bFound;
}
                

//******************************************************************************
// GenerateFilePaths:
// NOTE NOTE NOTE: The migration DLL remains loaded from the "Initialize9x" phase
// right till the end of the "MigrateSystem9x" phase. And again from "InitializeNT" phase
// right till the end of the "MigrateSystemNT" phase. Hence these paths are usable 
// through out.
//*******************************************************************************
void GenerateFilePaths()
{

    *g_szMigrateInf = '\0';
    *g_szPrivateInf = '\0';

    if (g_lpWorkingDir)
    {
    // generate the path to the Migrate.Inf file
        wsprintf(g_szMigrateInf, "%s\\%s", g_lpWorkingDir, cszMIGRATEINF);
#ifdef DEBUG
        char szDebug[MAX_PATH];
        wsprintf(szDebug,"IE6: g_szMigrateInf: %s \r\n",g_szMigrateInf);

        SetupLogError(szDebug,LogSevInformation);
#endif

    // generate the path to the Private.Inf file
        wsprintf(g_szPrivateInf, "%s\\%s", g_lpWorkingDir, cszPRIVATEINF);
#ifdef DEBUG
        wsprintf(szDebug,"IE6: g_szPrivateInf: %s \r\n",g_szPrivateInf);

        SetupLogError(szDebug,LogSevInformation);
#endif

    }
}

#define IE_KEY        "Software\\Microsoft\\Internet Explorer"
#define VERSION_KEY         "Version"

BOOL NeedToMigrateIE()
{
    BOOL bRet = FALSE;
    char szPath[MAX_PATH];
    DWORD   dwInstalledVer, dwInstalledBuild;

    // Currently, the only thing we are interested in are the Ratings settings.
    if (IsRatingsEnabled())
    {
        // Append the "ratings.pol" filename to the list of files needed.
        // NOTE: AppendString allocates memory for the 1st parameter. User
        // must remember to free it.
        bRet |= AppendString(&g_lpNameBuf, &g_dwNameBufSize, cszRATINGSFILE);
    }

    if (!bRet)
    {
        GetSystemDirectory(szPath, sizeof(szPath));
        AddPath(szPath, "shdocvw.dll");
        GetVersionFromFile(szPath, &dwInstalledVer, &dwInstalledBuild, TRUE);
        // are running with IE5.5 installed.
        bRet = (dwInstalledVer == 0x00050032);
    }
    // Can add other modules that need to be migrated over here.
    // use bRet |= (....) so that you don't stomp previous bRet settings.

    return bRet;
}

void MyDelRegTree(HKEY hRoot, LPSTR szSubKey)
{
    char szName[MAX_PATH];
    DWORD dwIndex;
    DWORD dwNameSize;
    HKEY  hKey;

    dwIndex = 0;
    dwNameSize = sizeof(szName);
    if (RegOpenKeyEx(hRoot, szSubKey, 0, KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS)
    {
        while (RegEnumKey(hKey, dwIndex, szName, dwNameSize) == ERROR_SUCCESS)
        {
            MyDelRegTree(hKey,szName);
    
            // dwIndex++;  DONT INCR. SINCE WE HAVE DELETED A SUBKEY.
            dwNameSize = sizeof(szName);
        }

        RegCloseKey(hKey);

        //Finally delete the named subkey supplied above.
        RegDeleteKey(hRoot, szSubKey);
    }

}



// Recursively Enum values and subkey and copy them over. And then
// delete all subkeys of the Source key.
void MoveRegBranch(HKEY hFromKey, HKEY hToKey)
{
    
    char szName[MAX_PATH];
    char szValue[MAX_PATH];
    DWORD dwNameSize;
    DWORD dwValueSize;
    DWORD dwType;
    DWORD dwIndex;

    // Enumerate all the values here and copy them over to the right
    // location. 
    dwIndex = 0;
    dwNameSize = sizeof(szName);
    dwValueSize = sizeof(szValue);
    while (RegEnumValue(hFromKey,dwIndex, szName, &dwNameSize, NULL,
    &dwType, (LPBYTE)szValue, &dwValueSize) == ERROR_SUCCESS)
    {
        RegSetValueEx(hToKey,szName,0,dwType,(LPBYTE)szValue, dwValueSize);

        // Get ready for the next round.
        dwIndex++;
        dwNameSize = sizeof(szName);
        dwValueSize = sizeof(szValue);
    }

    // Next Enum all the subkeys under source and move them over.
    dwIndex = 0;
    dwNameSize = sizeof(szName);
    while (RegEnumKey(hFromKey, dwIndex, szName, dwNameSize) == ERROR_SUCCESS)
    {
        HKEY hFromSubKey = NULL;
        HKEY hToSubKey = NULL;

        // Open this SubKey that we enumerated.
        if (RegOpenKeyEx(hFromKey, szName, 0, KEY_ALL_ACCESS, &hFromSubKey) == ERROR_SUCCESS)
        {
            // Create the destination subkey.
            if (RegCreateKeyEx(hToKey, szName, 0, NULL,REG_OPTION_NON_VOLATILE,
                KEY_ALL_ACCESS, NULL, &hToSubKey, NULL) == ERROR_SUCCESS)
            {
                // Move the subkeys...
                MoveRegBranch(hFromSubKey, hToSubKey);
                RegCloseKey(hToSubKey);
            }
            RegCloseKey(hFromSubKey);
        }

        // Get ready for the next round
        dwIndex++;
        dwNameSize = sizeof(szName);
    }


    // Now Delete all the SubKeys. The above recursive call ensures that
    // the Subkeys are one-level deep and hence deletable.
    dwIndex = 0;
    dwNameSize = sizeof(szName);
    while (RegEnumKey(hFromKey, dwIndex, szName, dwNameSize) == ERROR_SUCCESS)
    {
        RegDeleteKey(hFromKey,szName);

        // dwIndex++;  DONT INCR. SINCE WE HAVE DELETED A SUBKEY.
        dwNameSize = sizeof(szName);
    }
}


#define REGKEY_DEFAULT  ".Default"
#define REGKEY_MIGRATE_HIVE "Software\\Microsoft\\Policies\\Users"
#define REGKEY_MIGRATE_PICSRULES "Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Ratings\\PICSRules"
#define REGKEY_RATING_PICSRULES "PICSRules"

BOOL UpgradeRatings()
{
    // Real Ratings locations...
    //     HKLM\S\M\W\CV\Policies\Ratings (called RATING)
    // Open HKLM\software\Microsoft\Policies\Users.. This is where NT Setup puts
    // the migrated Ratings HIVE.
    //  Users [FileNamex] gets copied to RATING [FileNamex] 
    //      NOTE: Need to take care of SYSTEM/SYSTEM32.
    //  Users\.Default branch gets moved to RATING
    //  Users\S\M\W\CV\Policies\Ratings\PICSRules branch gets moved to RATING.

    HKEY  hRealRatings = NULL;
    HKEY  hRealDefault = NULL;
    HKEY  hRealPicsRules = NULL;
    HKEY  hMigratedRoot = NULL;
    BOOL  bRet = FALSE;

    // Open the RegKey to the real location of Ratings.
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGKEY_RATING, 0, KEY_ALL_ACCESS,
        &hRealRatings) != ERROR_SUCCESS)
        goto Done;
    // Open the RegKey to the real location of .Default
    if (RegCreateKeyEx(hRealRatings, REGKEY_DEFAULT, 0,
        NULL,REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hRealDefault, NULL) != ERROR_SUCCESS)
        goto Done;
    // Open the RegKey to the real location of PICSRules
    if (RegCreateKeyEx(hRealRatings, REGKEY_RATING_PICSRULES, 0,
        NULL,REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hRealPicsRules, NULL) != ERROR_SUCCESS)
        goto Done;


    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGKEY_MIGRATE_HIVE, 0, KEY_ALL_ACCESS, &hMigratedRoot) == ERROR_SUCCESS)
    {
        HKEY hMigrateSubKey = NULL;
        char szName[MAX_PATH];
        char szValue[MAX_PATH];
        DWORD dwNameSize;
        DWORD dwValueSize;
        DWORD dwType;
        char  szNewPath[MAX_PATH];
        DWORD dwNewPathSize;
        DWORD dwIndex;

        // Enumerate all the values here and copy them over to the right
        // location. Make sure to replace 'System' with 'System32'
        dwIndex = 0;
        dwNameSize = sizeof(szName);
        dwValueSize = sizeof(szValue);
        while (RegEnumValue(hMigratedRoot,dwIndex, szName, &dwNameSize, NULL,
        &dwType, (LPBYTE)szValue, &dwValueSize) == ERROR_SUCCESS)
        {
            // Munge the Value and replace 'System' with System32.
            // Return value includes the terminating NULL char, which is
            // need by the RegSetValueEx API.
            dwNewPathSize = GetFixedPath(szNewPath, MAX_PATH, szValue);

            // Set the correct Ratings setting.
            RegSetValueEx(hRealRatings,szName,0,dwType,(LPBYTE)szNewPath, dwNewPathSize);
            // Get ready for the next round.
            dwIndex++;
            dwNameSize = sizeof(szName);
            dwValueSize = sizeof(szValue);
        }

        // Now grab Users\.Default and move it to the right location.
        if (RegOpenKeyEx(hMigratedRoot, REGKEY_DEFAULT, 0, KEY_ALL_ACCESS, &hMigrateSubKey) == ERROR_SUCCESS)
        {
            MoveRegBranch(hMigrateSubKey,hRealDefault);
            RegCloseKey(hMigrateSubKey);
        }

        // Now grab Users\...\PICSRules and move it to the right location.
        if (RegOpenKeyEx(hMigratedRoot, REGKEY_MIGRATE_PICSRULES, 0, KEY_ALL_ACCESS, &hMigrateSubKey) == ERROR_SUCCESS)
        {
            MoveRegBranch(hMigrateSubKey,hRealPicsRules);
            RegCloseKey(hMigrateSubKey);
        }

        RegCloseKey(hMigratedRoot);

        bRet = TRUE;
    }

    // Now clean the Migrated Hive.
    MyDelRegTree(HKEY_LOCAL_MACHINE, REGKEY_MIGRATE_HIVE);

Done:
    if (hRealRatings)
        RegCloseKey(hRealRatings);
    if (hRealDefault)
        RegCloseKey(hRealDefault);
    if (hRealPicsRules)
        RegCloseKey(hRealPicsRules);

    return bRet;
}


// Returns the size of NewPath including the terminating NULL.
DWORD GetFixedPath(LPSTR lpBuf, DWORD dwSize, LPCSTR lpPath)
{
    char lpLocalCopy[MAX_PATH], szTemp[5];
    char chSave;
    DWORD dwCount = 0;
    LPSTR pTmp, pTmp2;

    if (lpBuf == NULL || lpPath == NULL)
        return 0;

    // Create a local copy to party on.
    lstrcpy(lpLocalCopy, lpPath);

    pTmp = lpLocalCopy;
    *lpBuf = '\0';

    while (*pTmp && dwCount < dwSize)
    {
        pTmp2 = pTmp;
        while(*pTmp2 && *pTmp2 != '\\')
            pTmp2 = CharNext(pTmp2);

        chSave = *pTmp2;
        *pTmp2 = '\0';

        if (lstrcmpi(pTmp,"system")==0)
        {
            dwCount += 8;
            if (dwSize <= dwCount)
            {    //Error
                *lpBuf = '\0';
                return 0;
            }
            lstrcat(lpBuf,"system32");
        }
        else
        {
            dwCount += lstrlen(pTmp);
            if (dwSize <= dwCount)
            {    // Error
                *lpBuf = '\0';
                return 0;
            }
            lstrcat(lpBuf,pTmp);
        }

        // Append the saved character to Output buffer also.
        wsprintf(szTemp,"%c",chSave);
        dwCount += lstrlen(szTemp);
        if (dwSize <= dwCount)
        {    // Error
            *lpBuf = '\0';
            return 0;
        }
        lstrcat(lpBuf, szTemp);

        *pTmp2 = chSave;
        pTmp = CharNext(pTmp2);
    }

    return dwCount;
}

LPWSTR MakeWideStrFromAnsi(LPSTR psz)
{
    LPWSTR pwsz;
    int i;

    // arg checking.
    //
    if (!psz)
        return NULL;

    // compute the length of the required BSTR
    //
    i =  MultiByteToWideChar(CP_ACP, 0, psz, -1, NULL, 0);
    if (i <= 0) return NULL;

    // allocate the widestr
    //
    pwsz = (LPWSTR) CoTaskMemAlloc(i * sizeof(WCHAR));

    if (!pwsz) 
        return NULL;

    MultiByteToWideChar(CP_ACP, 0, psz, -1, pwsz, i);
    pwsz[i - 1] = 0;
    return pwsz;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\active\ntmigrat\utils.h ===
#ifndef _IE_NT5_MIGRATION_UTILS_H_
#define _IE_NT5_MIGRATION_UTILS_H_


// Function Prototypes :
//////////////////////////
BOOL  IsRatingsEnabled();
DWORD CountMultiStringBytes(LPCSTR lpString);
BOOL  AppendString(LPSTR *lpBuffer, DWORD *lpdwSize, LPCSTR lpStr);
void  GenerateFilePaths();
//BOOL  NeedToMigrateIE();
BOOL  GetRatingsPathFromMigInf( LPSTR *lpOutBuffer);

void  MoveRegBranch(HKEY hFrom, HKEY hTo);
BOOL  PathEndsInFile(LPSTR lpPath, LPCSTR szFile);
BOOL  UpgradeRatings();
DWORD GetFixedPath(LPSTR, DWORD, LPCSTR);  
LPWSTR MakeWideStrFromAnsi(LPSTR psz);

#endif //_IE_NT5_MIGRATION_UTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\common\inc\excppkg.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    excppkg.h

Abstract:

    Header file for migration of exception packages.

Author:

    Andrew Ritz (andrewr) 21-Oct-1999

Revision History:

    Andrew Ritz (andrewr) 21-Oct-1999 : Created It.

--*/


typedef struct _SETUP_OS_COMPONENT_DATA {
    DWORD SizeOfStruct;
    GUID  ComponentGuid;
    WCHAR FriendlyName[64];
    WORD  VersionMajor;
    WORD  VersionMinor;
    WORD  BuildNumber;
    WORD  QFENumber;
    DWORD Reserved[16];
} SETUP_OS_COMPONENT_DATA, *PSETUP_OS_COMPONENT_DATA;

typedef struct _SETUP_OS_EXCEPTION_DATA {
    DWORD SizeOfStruct;
    WCHAR ExceptionInfName[MAX_PATH];
    WCHAR CatalogFileName[MAX_PATH];
    DWORD Reserved[16];
} SETUP_OS_EXCEPTION_DATA, *PSETUP_OS_EXCEPTION_DATA;

BOOL
WINAPI
SetupRegisterOsComponent (
    IN const PSETUP_OS_COMPONENT_DATA ComponentData,
    IN const PSETUP_OS_EXCEPTION_DATA ExceptionData
    );

BOOL
WINAPI
SetupUnRegisterOsComponent (
    IN const LPGUID ComponentGuid
    );

typedef BOOL
(CALLBACK *PSETUPCOMPONENTCALLBACK) (
    IN const PSETUP_OS_COMPONENT_DATA SetupOsComponentData,
    IN const PSETUP_OS_EXCEPTION_DATA SetupOsExceptionData,
    IN OUT DWORD_PTR Context
    );

BOOL
WINAPI
SetupEnumerateRegisteredOsComponents(
    IN PSETUPCOMPONENTCALLBACK SetupOsComponentCallback,
    IN DWORD_PTR Context
    );

BOOL
WINAPI
SetupQueryRegisteredOsComponent(
    IN  LPGUID ComponentGuid,
    OUT PSETUP_OS_COMPONENT_DATA SetupOsComponentData,
    OUT PSETUP_OS_EXCEPTION_DATA SetupOsExceptionData
    );

BOOL
WINAPI
SetupQueryRegisteredOsComponentsOrder(
     OUT PDWORD   ComponentCount,
     OUT LPGUID    ComponentList OPTIONAL
    );

BOOL
WINAPI
SetupSetRegisteredOsComponentsOrder(
     IN  DWORD    ComponentCount,
     IN  const LPGUID    ComponentList
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\brandll\apply.h ===
#ifndef _APPLY_H_
#define _APPLY_H_

BOOL ApplyClearBranding();
BOOL ApplyMigrateOldSettings();
BOOL ApplyWininetSetup();
BOOL ApplyConnectionSettingsDeletion();
BOOL ApplyZonesReset();
BOOL ApplyExtRegInfHKLM();
BOOL ApplyExtRegInfHKCU();
BOOL lcy50_ApplyExtRegInf();
BOOL ApplyCustomHelpVersion();
BOOL ApplyToolbarButtons();
BOOL ApplyRootCert();
BOOL ApplyFavoritesDeletion();
BOOL ApplyFavorites();
BOOL ApplyFavoritesOrdering();
BOOL ApplyQuickLinks();
BOOL ApplyQuickLinksOrdering();
BOOL ApplyConnectionSettings();
BOOL ApplyTrustedPublisherLockdown();
BOOL ApplyLinksDeletion();
BOOL ApplyBrowserRefresh();
BOOL lcy4x_ApplyActiveDesktop();
BOOL lcy4x_ApplyChannels();
BOOL lcy4x_ApplyWebcheck();
BOOL lcy4x_ApplyChannelBar();
BOOL lcy4x_ApplySubscriptions();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\common.inc ===
#----- Definition of the common paths -----
!ifndef IEAK_PATH
IEAK_PATH = $(PROJECT_ROOT)\setup\ieak5
!endif

!ifndef IEAK_INC_PATH
IEAK_INC_PATH = $(IEAK_PATH)\inc
!endif

!ifndef IEAK_UTIL_PATH
IEAK_UTIL_PATH  = $(IEAK_PATH)\ieakutil
!endif
IEAK_UTIL_PATHA = $(IEAK_UTIL_PATH)\srca
IEAK_UTIL_PATHW = $(IEAK_UTIL_PATH)\srcw

!ifndef IEAK_UI_PATH
IEAK_UI_PATH = $(IEAK_PATH)\ieakui
!endif

!ifndef IEAK_ENG_PATH
IEAK_ENG_PATH = $(IEAK_PATH)\ieakeng
!endif

!ifndef IEAK_ADMPARSE_PATH
IEAK_ADMPARSE_PATH = $(IEAK_PATH)\parser
!endif

#----- Standard macros setup -----
TARGETPATH = $(_OBJ_DIR)
UMTYPE     = windows


#----- C/C++ compilation settings -----
# (pritobla) should define NASHVILLE so that the version number remains the same whether it's
# built under IE or NT environment
# NOTE: All the binaries that include common.inc will be compiled UNICODE !
C_DEFINES         = $(C_DEFINES) -D_WIN32_DCOM -DNASHVILLE
!ifndef NO_UNICODE
C_DEFINES         = $(C_DEFINES) -DUNICODE -D_UNICODE
!endif
MSC_WARNING_LEVEL = -W4 -WX
COMPILER_WARNINGS = -FI$(IEAK_INC_PATH)\warning.h
USE_STATIC_ATL    = 1
ATL_VER           = 21

# (andrewgu) disable for now, since browser_info story is not clear in the source depot
# !if !$(FREEBUILD)
# BROWSER_INFO      = 1
# !endif


#   _____ Precompiled header settings _____
PRECOMPILED_CXX     = 1
PRECOMPILED_INCLUDE = precomp.h

#   _____ Include search paths _____
INCLUDES = \
    $(IEAK_INC_PATH);  \
    $(IEAK_UTIL_PATH); \
    $(IEAK_ENG_PATH);  \
    $(IEAK_UI_PATH);   \
    $(DS_INC_PATH);    \
    $(SHELL_INC_PATH)

CONDITIONAL_INCLUDES = \
    atlbase.h   \
    atlcom.h    \
    atlconv.h   \
    atlwin.h    \
    statreg.h   \
    statreg.cpp \
    atlimpl.cpp \
    atlsnap.h   \
    dlgs.h      \
    rpcerr.h    \
    rpcmac.h    \
    macname1.h  \
    macpub.h    \
    macapi.h    \
    macname2.h  \
    macwin32.h  \
    macodidl.h  \
    macocidl.h  \
    winwlm.h    \
    thunk.h

#----- Libraries -----
USE_NOLIBS = 1
USE_PDB    = 1

TARGETLIBS = \
    $(SDK_LIB_PATH)\kernel32.lib \
    $(SDK_LIB_PATH)\user32.lib   \
    $(SDK_LIB_PATH)\gdi32.lib    \
    $(SDK_LIB_PATH)\advapi32.lib \
    $(SHELL_LIB_PATH)\shlwapip.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\brandll\apply.cpp ===
#include "precomp.h"
#include <rashelp.h>
#include "apply.h"

// BUGBUG: (andrewgu) no need to say how bad this is!
#undef   WINVER
#define  WINVER 0x0500
#include <userenv.h>

// REVIEW: (andrewgu) currently, some utility ProcessXXX apis
// (eg. ProcessActiveSetupSites) will execute unconditionally. i.e. there is no way to turn them
// off. what needs to be done is in respective ApplyXXX apis to check if there is need to perform
// this utility functionality and skip it if this service is not going to be needed.

BOOL ApplyClearBranding()
{
    TCHAR szValue[16];
    BOOL  fResult;

    // in autoconfig or GP context, shouldn't call the Clear function
    if (g_CtxIs(CTX_AUTOCONFIG | CTX_GP))
        return FALSE;

    // take care of MS IE4.x ins's which didn't have the NoClear flag set
    fResult = !InsGetBool(IS_BRANDING, IK_NOCLEAR, FALSE, g_GetIns());
    if (fResult) 
    {
        GetPrivateProfileString(IS_BRANDING, IK_CUSTOMKEY, TEXT(""), szValue, countof(szValue), g_GetIns());
        fResult = (0 != StrCmpI(szValue, TEXT("MICROSO")));
    }

    return fResult;
}

BOOL ApplyMigrateOldSettings()
{
    return (g_CtxIsCorp() || g_CtxIsIsp() || g_CtxIsIcp());
}

BOOL ApplyWininetSetup()
{
    if (g_CtxIs(CTX_MISC_PERUSERSTUB) || (g_CtxIsGp() && !g_CtxIs(CTX_MISC_CHILDPROCESS)))
        return ApplyConnectionSettings();

    return FALSE;
}

BOOL ApplyConnectionSettingsDeletion()
{   MACRO_LI_PrologEx_C(PIF_STD_C, ApplyConnectionSettingsDeletion)

    if (!InsGetBool(IS_CONNECTSET, IK_DELETECONN, FALSE, g_GetIns())) {
        Out(LI0(TEXT("Existing connection settings weren't specified to be deleted!")));
        return FALSE;
    }

    if (!RasIsInstalled()) {
        Out(LI0(TEXT("RAS support is not installed. There are no connection settings to delete!")));
        return FALSE;
    }

    return TRUE;
}

BOOL ApplyZonesReset()
{
    return g_CtxIs(CTX_GP) && g_CtxIs(CTX_MISC_CHILDPROCESS);
}

BOOL ApplyExtRegInfHKLM()
{   MACRO_LI_PrologEx_C(PIF_STD_C, ApplyExtRegInfHKLM)

    if (InsIsSectionEmpty(IS_EXTREGINF_HKLM, g_GetIns()) &&
        InsIsSectionEmpty(IS_EXTREGINF_ESC_HKLM, g_GetIns())) {
        Out(LI0(TEXT("There are no local machine *.inf files to process!")));
        return FALSE;
    }

    return TRUE;
}

BOOL ApplyExtRegInfHKCU()
{   MACRO_LI_PrologEx_C(PIF_STD_C, ApplyExtRegInfHKCU)

    if (InsIsSectionEmpty(IS_EXTREGINF_HKCU, g_GetIns()) &&
        InsIsSectionEmpty(IS_EXTREGINF_ESC_HKCU, g_GetIns())) {
        Out(LI0(TEXT("There are no current user *.inf files to process!")));
        return FALSE;
    }

    return TRUE;
}

BOOL lcy50_ApplyExtRegInf()
{   MACRO_LI_PrologEx_C(PIF_STD_C, lcy50_ApplyExtRegInf)

    if (ApplyExtRegInfHKLM() || ApplyExtRegInfHKCU() ||
        (InsIsSectionEmpty(IS_EXTREGINF, g_GetIns()) &&
        InsIsSectionEmpty(IS_EXTREGINF_ESC, g_GetIns()))) {
        Out(LI0(TEXT("There are no legacy *.inf files to process!")));
        return FALSE;
    }

    ASSERT(!g_CtxIsGp());

    return TRUE;
}

BOOL ApplyCustomHelpVersion()
{
    if (!HasFlag(g_GetContext(), CTX_MISC_PERUSERSTUB))
        return FALSE;

    return ApplyClearBranding();
}

BOOL ApplyToolbarButtons()
{   MACRO_LI_PrologEx_C(PIF_STD_C, ApplyToolbarButtons)

    if (InsIsSectionEmpty(IS_BTOOLBARS, g_GetIns())) {
        Out(LI0(TEXT("There are no toolbar buttons to process!")));
        return FALSE;
    }

    return TRUE;
}

BOOL ApplyRootCert()
{   MACRO_LI_PrologEx_C(PIF_STD_C, ApplyRootCert)

    BOOL fResult;

    if (!HasFlag(g_GetContext(), CTX_ISP)) {
        Out(LI0(TEXT("This feature is for ISPs only!")));
        return FALSE;
    }

    fResult = !InsIsKeyEmpty(IS_ISPSECURITY, IK_ROOTCERT, g_GetIns());
    if (!fResult)
        Out(LI0(TEXT("No ISP Root Cert to add!")));

    return fResult;
}

BOOL ApplyFavoritesDeletion()
{   MACRO_LI_PrologEx_C(PIF_STD_C, ApplyFavoritesDeletion)

    DWORD dwFlags;

    dwFlags = InsGetInt(IS_BRANDING, IK_FAVORITES_DELETE, FD_DEFAULT, g_GetIns());
    if (!HasFlag(dwFlags, FD_FOLDERS)) {
        Out(LI0(TEXT("None of the favorites folders were specified to be deleted!")));
        return FALSE;
    }

    return TRUE;
}

BOOL ApplyFavorites()
{   MACRO_LI_PrologEx_C(PIF_STD_C, ApplyFavorites)

    TCHAR szKey[32];
    BOOL  fNewFormat;

    wnsprintf(szKey, countof(szKey), IK_TITLE_FMT, 1);
    fNewFormat = !InsIsKeyEmpty(IS_FAVORITESEX, szKey, g_GetIns());
    if (!fNewFormat) {
        if (InsIsSectionEmpty(IS_FAVORITES, g_GetIns())) {
            Out(LI0(TEXT("There are no favorites to add!")));
            return FALSE;
        }
    }

    return TRUE;
}

BOOL ApplyFavoritesOrdering()
{   MACRO_LI_PrologEx_C(PIF_STD_C, ApplyFavoritesOrdering)

    if (!InsGetBool(IS_BRANDING, IK_FAVORITES_ONTOP, FALSE, g_GetIns())) {
        Out(LI0(TEXT("Favorites will be put into the default position!")));
        return FALSE;
    }

    return TRUE;
}

BOOL ApplyQuickLinks()
{   MACRO_LI_PrologEx_C(PIF_STD_C, ApplyQuickLinks)

    TCHAR szKey[32];

    wnsprintf(szKey, countof(szKey), IK_QUICKLINK_NAME, 1);
    if (InsIsKeyEmpty(IS_URL, szKey, g_GetIns())) {
        Out(LI0(TEXT("There are no quick links to add!")));
        return FALSE;
    }

    return TRUE;
}

BOOL ApplyQuickLinksOrdering()
{   MACRO_LI_PrologEx_C(PIF_STD_C, ApplyQuickLinksOrdering)

    if (!InsGetBool(IS_BRANDING, IK_FAVORITES_ONTOP, FALSE, g_GetIns())) {
        Out(LI0(TEXT("Quick Links will be put into the default position!")));
        return FALSE;
    }

    return TRUE;
}

BOOL ApplyConnectionSettings()
{   MACRO_LI_PrologEx_C(PIF_STD_C, ApplyConnectionSettings)

    if (!InsGetBool(IS_CONNECTSET, IK_OPTION, FALSE, g_GetIns()) &&
        !(InsKeyExists(IS_URL, IK_DETECTCONFIG, g_GetIns()) || InsKeyExists(IS_URL, IK_USEAUTOCONF, g_GetIns())) &&
        InsIsSectionEmpty(IS_PROXY, g_GetIns())) {
        Out(LI0(TEXT("There are no connection settings to process!")));
        return FALSE;
    }

    return TRUE;
}

BOOL ApplyTrustedPublisherLockdown()
{   MACRO_LI_PrologEx_C(PIF_STD_C, ApplyTrustedPublisherLockdown)

    // need to check both current location and legacy location here

    if ((S_OK != SHValueExists(HKEY_LOCAL_MACHINE, RK_POLICES_RESTRICTIONS, RV_TPL)) &&
        (!InsKeyExists(IS_SITECERTS, IK_TRUSTPUBLOCK, g_GetIns())))
    {
        Out(LI0(TEXT("This restriction is not set!")));
        return FALSE;
    }

    return TRUE;
}

BOOL ApplyLinksDeletion()
{   MACRO_LI_PrologEx_C(PIF_STD_C, ApplyLinksDeletion)

    if (!InsGetBool(IS_OUTLKEXP,    IK_DELETELINKS, FALSE, g_GetIns()) &&
        !InsGetBool(IS_DESKTOPOBJS, IK_DELETELINKS, FALSE, g_GetIns()))
    {
        Out(LI0(TEXT("No links to delete!")));
        return FALSE;
    }

    return TRUE;
}

BOOL ApplyBrowserRefresh()
{   MACRO_LI_PrologEx_C(PIF_STD_C, ApplyBrowserRefresh)

    // do not do global refresh if this is running under the GP context at login time;
    // for child process, apply browser refresh is controlled via cmdline (child process never has GPO flags)

    if (g_CtxIs(CTX_GP) && !g_CtxIs(CTX_MISC_CHILDPROCESS) && !HasFlag(g_GetGPOFlags(), GPO_INFO_FLAG_BACKGROUND))
    {
        Out(LI0(TEXT("Skipping browser refresh at login time!")));
        return FALSE;
    }

    return TRUE;
}

BOOL lcy4x_ApplyActiveDesktop()
{   MACRO_LI_PrologEx_C(PIF_STD_C, lcy4x_ApplyActiveDesktop)

    BOOL fEnable;

    fEnable = InsGetBool(IS_DESKTOPOBJS, IK_OPTION, FALSE, g_GetIns());
    if (!fEnable || IsOS(OS_NT5)) {
        if (!fEnable)
            Out(LI0(TEXT("No desktop customizations to process!")));
        else
            Out(LI0(TEXT("Skipping desktop customizations on Windows 2000!")));

        return FALSE;
    }

    if (!HasFlag(WhichPlatform(), PLATFORM_INTEGRATED)) {
        Out(LI0(TEXT("Nothing to apply without IE4 Desktop Update!")));
        return FALSE;
    }

    return TRUE;
}

BOOL lcy4x_ApplyChannels()
{   MACRO_LI_PrologEx_C(PIF_STD_C, lcy4x_ApplyChannels)

    if (InsIsSectionEmpty(IS_CHANNEL_ADD, g_GetIns()) &&
        !InsGetBool(IS_DESKTOPOBJS, IK_DELETECHANNELS, FALSE, g_GetIns()))
    {
        Out(LI0(TEXT("There are no channels to process!")));
        return FALSE;
    }

    return TRUE;
}

BOOL lcy4x_ApplyWebcheck()
{   MACRO_LI_PrologEx_C(PIF_STD_C, lcy4x_ApplyWebcheck)

    // NOTE: (pritobla) bail out if the infodelivery\modifications key doesn't exist. this is the
    // same logic that is used in ProcessInfodeliveryPolicies() in shell\ext\webcheck\admin.cpp
    // to quickly determine whether there are any channels to process or not.
    if (S_OK != SHKeyExists(g_GetHKCU(), RK_POLICES_MODIFICATIONS)) {
        Out(LI0(TEXT("There is no webcheck processing necessary!")));
        return FALSE;
    }

    return TRUE;
}

BOOL lcy4x_ApplyChannelBar()
{
    return InsGetBool(IS_DESKTOPOBJS, IK_SHOWCHLBAR, FALSE, g_GetIns());
}

BOOL lcy4x_ApplySubscriptions()
{   MACRO_LI_PrologEx_C(PIF_STD_C, lcy4x_ApplySubscriptions)

    if (InsIsSectionEmpty(IS_SUBSCRIPTIONS, g_GetIns())) {
        Out(LI0(TEXT("There are no subscriptions to process!")));
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\brandll\brand.cpp ===
#include "precomp.h"
#include <cryptui.h>
#include <rashelp.h>
#include "exports.h"

// External declarations
// BUGBUG: (andrewgu) we should really clean this up. when ras reg stuff goes through the file as
// well, this will go back to where it belongs, i.e. brandcs.cpp.
BOOL raBackup();                                // ra stands for "remote access"

// Private forward decalarations
#define BTOOLBAR_GUID TEXT("{1FBA04EE-3024-11d2-8F1F-0000F87ABD16}")

static HRESULT processExtRegInfSection(LPCTSTR pcszExtRegInfSect);
static HRESULT eriPreHook (LPCTSTR pszInf, LPCTSTR pszSection, LPARAM lParam = NULL);
static HRESULT eriPostHook(LPCTSTR pszInf, LPCTSTR pszSection, LPARAM lParam = NULL);

typedef struct
{
    TCHAR   szTarget[MAX_PATH];
    union {
        IShellLinkW*    pShellLinkW;
        IShellLinkA*    pShellLinkA;
    };
    IPersistFile*   pPersistFile;
    BOOL fUnicode;
} LINKINFO, *PLINKINFO;

HRESULT pepDeleteLinksEnumProc(LPCTSTR pszPath, PWIN32_FIND_DATA pfd, LPARAM lParam, PDWORD *prgdwControl = NULL);
static HRESULT deleteLinks(LPCTSTR pcszTarget, DWORD dwFolders);
static void deleteLink(DWORD dwFolder, PLINKINFO pLinkInfo);

// Download of cabs in the autoconfig case
HRESULT ProcessAutoconfigDownload()
{   MACRO_LI_PrologEx_C(PIF_STD_C, ProcessAutoconfigDownload)

    INTERNET_PER_CONN_OPTION_LIST list;
    INTERNET_PER_CONN_OPTION      option;
    LPCTSTR pszNew;
    HKEY    hk;
    DWORD   dwSize;
    BOOL    fUpdateAutocfgURL,
            fUpdateCabs;

    Out(LI0(TEXT("Processing download of the cab files...")));
    fUpdateAutocfgURL = TRUE;

    ZeroMemory(&list, sizeof(list));
    list.dwSize        = sizeof(list);
    list.dwOptionCount = 1;
    list.pOptions      = &option;

    ZeroMemory(&option, sizeof(option));
    option.dwOption = INTERNET_PER_CONN_AUTOCONFIG_URL;

    // BUGBUG: (pritobla) assumption here is that PROXY_TYPE_AUTO_PROXY_URL flag is set. what if
    // PROXY_TYPE_AUTO_PROXY_URL is not set but INTERNET_PER_CONN_AUTOCONFIG_URL is and via
    // autodiscovery, wininet calls into us (via InternetInitializeAutoProxyDll)?
    pszNew = NULL;
    dwSize = list.dwSize;
    if (TRUE == InternetQueryOption(NULL, INTERNET_OPTION_PER_CONNECTION_OPTION, &list, &dwSize))
        pszNew = option.Value.pszValue;

    hk = NULL;
    SHCreateKeyHKLM(RK_IEAK_CABVER, KEY_QUERY_VALUE | KEY_SET_VALUE, &hk);

    fUpdateCabs = InsGetBool(IS_BRANDING, IK_AC_DONTMIGRATEVERSIONS, FALSE, g_GetIns());
    if (fUpdateCabs) {
        SHDeleteKey(g_GetHKCU(), RK_IEAK_CABVER);
        SHDeleteEmptyKey(g_GetHKCU(), RK_IEAK);

        Out(LI0(TEXT("Cabs version information will not be migrated. Updating all existing cabs!")));
    }
    else {
        HRESULT hr;

        hr = MoveCabVersionsToHKLM(g_GetIns());
        if (hr != S_OK) {
            fUpdateCabs = !InsGetBool(IS_BRANDING, IK_AC_NOUPDATEONINSCHANGE, FALSE, g_GetIns());
            if (!fUpdateCabs)
                Out(LI0(TEXT("Autoconfig URL is excluded from cabs updating logic!")));

            else
                if (hr == S_FALSE && hk != NULL) {
                    TCHAR szOld[INTERNET_MAX_URL_LENGTH];

                    szOld[0] = TEXT('\0');
                    dwSize   = sizeof(szOld);
                    RegQueryValueEx(hk, RV_LAST_AUTOCNF_URL, 0, NULL, (LPBYTE)szOld, &dwSize);

                    fUpdateCabs = (StrCmpI(pszNew, szOld) != 0);
                    if (fUpdateCabs)
                        Out(LI0(TEXT("Autoconfig URL has changed. Updating all existing cabs!")));

                    else
                        fUpdateAutocfgURL = FALSE;  // identical -> no need to update
                }
                else {
                    ASSERT(FAILED(hr) || hk == NULL);
                    Out(LI0(TEXT("Due to internal failure it's safer to update all existing cabs!")));
                }
        }
    }

    UpdateBrandingCab(fUpdateCabs);
    UpdateDesktopCab (fUpdateCabs);

    if (hk != NULL) {
        if (fUpdateAutocfgURL)
            RegSetValueEx(hk, RV_LAST_AUTOCNF_URL, 0, REG_SZ, (LPBYTE)pszNew, (DWORD)StrCbFromSz(pszNew));

        SHCloseKey(hk);
    }

    if (option.Value.pszValue != NULL)
        GlobalFree(option.Value.pszValue);

    Out(LI0(TEXT("Done.")));
    return S_OK;
}

// Server-based signup optional custom branding cab download
HRESULT ProcessIcwDownload()
{   MACRO_LI_PrologEx_C(PIF_STD_C, ProcessIcwDownload)

    TCHAR   szCustomCab[MAX_PATH],
            szTargetFile[MAX_PATH];
    HRESULT hr;

    Out(LI0(TEXT("Processing optional custom cab file...")));

    hr = S_OK;
    GetPrivateProfileString(IS_CUSTOMBRANDING, IK_BRANDING, TEXT(""), szCustomCab, countof(szCustomCab), g_GetIns());
    if (szCustomCab[0] == TEXT('\0')) {
        Out(LI0(TEXT("There is no custom branding cab!")));
        hr = S_FALSE;
        goto Exit;                              // there is no custom branding cab
    }
    ASSERT(!PathIsFileSpec(szCustomCab));       // should not be a file name only

    CreateCustomBrandingCabUI(TRUE);

    StrCpy(szTargetFile, g_GetTargetPath());
    hr = DownloadSourceFile(szCustomCab, szTargetFile, countof(szTargetFile), FALSE);
    if (FAILED(hr)) {
        Out(LI2(TEXT("! Downloading custom cab \"%s\" failed with %s."), szCustomCab, GetHrSz(hr)));
        goto Cleanup;
    }

    hr = ExtractFilesWrap(szTargetFile, g_GetTargetPath(), 0, NULL, NULL, 0);
    DeleteFile(szTargetFile);
    if (FAILED(hr))
        Out(LI2(TEXT("! Extracting files out of \"%s\" failed with %s."), szTargetFile, GetHrSz(hr)));

Cleanup:
    CreateCustomBrandingCabUI(FALSE);

Exit:
    Out(LI0(TEXT("Done.")));
    return hr;
}


HRESULT ProcessClearBranding()
{
    Clear(NULL, NULL, NULL, 0);
    return S_OK;
}

HRESULT ProcessMigrateOldSettings()
{
    TCHAR szData[MAX_PATH];
    DWORD cbSize, dwType;
    HKEY  hkHklmMain,
          hkHkcuToolbar;

    hkHklmMain        = NULL;
    hkHkcuToolbar     = NULL;

    SHOpenKeyHKLM(RK_IE_MAIN, KEY_QUERY_VALUE, &hkHklmMain);
    
    if (hkHklmMain != NULL)
    {
        dwType = REG_SZ;

        cbSize = sizeof(szData);
        if (ERROR_SUCCESS == RegQueryValueEx(hkHklmMain, RV_WINDOWTITLE, NULL, &dwType, (LPBYTE)&szData, &cbSize))
            SHSetValue(g_GetHKCU(), RK_IE_MAIN, RV_WINDOWTITLE, dwType, szData, cbSize);
        
        SHCreateKey(g_GetHKCU(), RK_TOOLBAR, KEY_SET_VALUE, &hkHkcuToolbar);

        if (hkHkcuToolbar != NULL)
        {
            cbSize = sizeof(szData);
            if (ERROR_SUCCESS == RegQueryValueEx(hkHklmMain, RV_LARGEBITMAP, NULL, &dwType, (LPBYTE)&szData, &cbSize))
                RegSetValueEx(hkHkcuToolbar, RV_LARGEBITMAP, NULL, dwType, (LPBYTE)szData, cbSize);

            cbSize = sizeof(szData);
            if (ERROR_SUCCESS == RegQueryValueEx(hkHklmMain, RV_SMALLBITMAP, NULL, &dwType, (LPBYTE)&szData, &cbSize))
                RegSetValueEx(hkHkcuToolbar, RV_SMALLBITMAP, NULL, dwType, (LPBYTE)szData, cbSize);

            SHCloseKey(hkHkcuToolbar);
        }

        SHCloseKey(hkHklmMain);
    }
    
    return S_OK;
}

// ExtRegInf section

HRESULT ProcessExtRegInfSectionHKLM()
{   MACRO_LI_PrologEx_C(PIF_STD_C, ProcessExtRegInfSectionHKLM)
    
    if(g_CtxIs(CTX_GP))
    {
        Out(LI0(TEXT("GP context. Not processing the HKLM sections.!")));
        return S_OK;
    }

    return processExtRegInfSection(IS_EXTREGINF_HKLM);
}

HRESULT ProcessExtRegInfSectionHKCU()
{   MACRO_LI_PrologEx_C(PIF_STD_C, ProcessExtRegInfSectionHKCU)
    
    return processExtRegInfSection(IS_EXTREGINF_HKCU);
}

HRESULT lcy50_ProcessExtRegInfSection()
{   MACRO_LI_PrologEx_C(PIF_STD_C, lcy50_ProcessExtRegInfSection)
    
    return processExtRegInfSection(IS_EXTREGINF);
}

HRESULT ProcessGeneral()
{   MACRO_LI_PrologEx_C(PIF_STD_C, ProcessGeneral)

    TCHAR szValue[MAX_PATH],
          szTargetFile[MAX_PATH],
          szCompany[MAX_PATH];
    HKEY  hkHklmMain,
          hkHkcuMain,
          hkHkcuHelpMenuUrl,
          hkHkcuToolbar,
          hkHklmUAString;
    DWORD dwFlags,
          dwBrandedFlags;
    BOOL  fCustomize;

    //----- Initialization -----
    // REVIEW: (andrewgu) i can think of several ways to implement this function. this approach
    // seems to resemble the closest to how it would be if CReg2Ins was used.
    hkHklmMain        = NULL;
    hkHkcuMain        = NULL;
    hkHkcuHelpMenuUrl = NULL;
    hkHkcuToolbar     = NULL;
    hkHklmUAString    = NULL;

    SHCreateKeyHKLM(         RK_IE_MAIN,         KEY_SET_VALUE,      &hkHklmMain);
    SHCreateKey(g_GetHKCU(), RK_IE_MAIN,         KEY_SET_VALUE,      &hkHkcuMain);
    SHCreateKey(g_GetHKCU(), RK_HELPMENUURL,     KEY_SET_VALUE,      &hkHkcuHelpMenuUrl);
    SHCreateKey(g_GetHKCU(), RK_TOOLBAR,         KEY_SET_VALUE,      &hkHkcuToolbar);
    SHCreateKeyHKLM(         RK_UA_POSTPLATFORM, KEY_DEFAULT_ACCESS, &hkHklmUAString);

    if (hkHkcuMain        == NULL ||
        hkHkcuHelpMenuUrl == NULL ||
        hkHkcuToolbar     == NULL ||
        hkHklmUAString    == NULL) {
        Out(LI0(TEXT("! Internal failure. Some of the settings may not get applied.")));
    }

    dwFlags        = g_GetFeature(FID_GENERAL)->dwFlags;
    dwBrandedFlags = GetFeatureBranded(FID_GENERAL);
    fCustomize     = FALSE;

    //----- Company Name, Custom Key, Wizard Version -----
    GetPrivateProfileString(IS_BRANDING, IK_COMPANYNAME, TEXT(""), szValue, countof(szValue), g_GetIns());
    StrCpy(szCompany, szValue);                 // szCompany is set here

    if (NULL != hkHklmMain) {
        if (TEXT('\0') != szValue[0]) {
            RegSetValueEx(hkHklmMain, RV_COMPANYNAME, 0, REG_SZ, (PBYTE)szValue, (DWORD)StrCbFromSz(szValue));
            Out(LI1(TEXT("Company name is set to \"%s\"."), szValue));
        }

        GetPrivateProfileString(IS_BRANDING, IK_CUSTOMKEY, TEXT(""), szValue, countof(szValue), g_GetIns());
        if (TEXT('\0') != szValue[0]) {
            RegSetValueEx(hkHklmMain, RV_CUSTOMKEY,   0, REG_SZ, (PBYTE)szValue, (DWORD)StrCbFromSz(szValue));
            Out(LI1(TEXT("Custom key is set to \"%s\"."), szValue));
        }

        GetPrivateProfileString(IS_BRANDING, IK_WIZVERSION,  TEXT(""), szValue, countof(szValue), g_GetIns());
        if (TEXT('\0') != szValue[0]) {
            RegSetValueEx(hkHklmMain, RV_WIZVERSION,  0, REG_SZ, (PBYTE)szValue, (DWORD)StrCbFromSz(szValue));
            Out(LI1(TEXT("Wizard version is set to \"%s\"."), szValue));
        }
    }

    //----- Window Title -----
    if ((NULL != hkHkcuMain && !HasFlag(dwFlags, FF_GEN_TITLE)) &&
        !(g_CtxIs(CTX_GP) && g_CtxIs(CTX_MISC_PREFERENCES) && HasFlag(dwBrandedFlags, FF_GEN_TITLE))) {
        InsGetString(IS_BRANDING, IK_WINDOWTITLE, szValue, countof(szValue), g_GetIns(), NULL, &fCustomize);
        if (fCustomize) 
            if (TEXT('\0') != szValue[0]) {
                RegSetValueEx(hkHkcuMain, RV_WINDOWTITLE, 0, REG_SZ, (PBYTE)szValue, (DWORD)StrCbFromSz(szValue));

                // Note: we need to write to the HKLM so that if the user goes back from
                // IE 5.01 to IE 4.0, the last customization should be reflected.
                if (!IsOS(OS_NT5) && NULL != hkHklmMain)
                    RegSetValueEx(hkHklmMain, RV_WINDOWTITLE, 0, REG_SZ, (PBYTE)szValue, (DWORD)StrCbFromSz(szValue));

                Out(LI1(TEXT("Browser title is set to \"%s\"."), szValue));
                SetFeatureBranded(FID_GENERAL, FF_GEN_TITLE);
            }
            else
                if (g_CtxIs(CTX_GP)) {
                    RegDeleteValue(hkHkcuMain, RV_WINDOWTITLE);

                    if (NULL != hkHklmMain)
                        RegDeleteValue(hkHklmMain, RV_WINDOWTITLE);

                    Out(LI0(TEXT("Browser title was deleted.")));
                }
    }

    //----- Home Page -----
    // REVIEW: (andrewgu) if it's not set, what is the deal with iereset.inf. do we need to clear
    // it out of there or perhaps set to some new default.
    if (!HasFlag(dwFlags, FF_GEN_HOMEPAGE) &&
        !(g_CtxIs(CTX_GP) && g_CtxIs(CTX_MISC_PREFERENCES) && HasFlag(dwBrandedFlags, FF_GEN_HOMEPAGE))) {
        InsGetString(IS_URL, IK_HOMEPAGE, szValue, countof(szValue), g_GetIns(), NULL, &fCustomize);
        if (fCustomize) {
            TCHAR szIEResetInf[MAX_PATH];

            if (TEXT('\0') != szValue[0]) {
                if (NULL != hkHkcuMain)
                    RegSetValueEx(hkHkcuMain, RV_HOMEPAGE, 0, REG_SZ, (PBYTE)szValue, (DWORD)StrCbFromSz(szValue));

                // for a preference GPO, shouldn't update RV_DEFAULTPAGE in HKLM and also
                // the default START_PAGE_URL in iereset.inf
                if (!g_CtxIs(CTX_MISC_PREFERENCES)) {
                    if (NULL != hkHklmMain)
                        RegSetValueEx(hkHklmMain, RV_DEFAULTPAGE, 0, REG_SZ, (PBYTE)szValue, (DWORD)StrCbFromSz(szValue));

                    // update the START_PAGE_URL in %windir%\inf\iereset.inf
                    GetWindowsDirectory(szIEResetInf, countof(szIEResetInf));
                    PathAppend(szIEResetInf, TEXT("inf\\iereset.inf"));
                    if (PathFileExists(szIEResetInf))
                        WritePrivateProfileString(IS_STRINGS, TEXT("START_PAGE_URL"), szValue, szIEResetInf);
                }

                SetFeatureBranded(FID_GENERAL, FF_GEN_HOMEPAGE);
                Out(LI1(TEXT("Home page is set to \"%s\"."), szValue));
            }
            else
                if (g_CtxIs(CTX_GP)) {
                    if (NULL != hkHkcuMain)
                        RegDeleteValue(hkHkcuMain, RV_HOMEPAGE);

                    // restore RV_DEFAULTPAGE and START_PAGE_URL to the default MS value
                    GetWindowsDirectory(szIEResetInf, countof(szIEResetInf));
                    PathAppend(szIEResetInf, TEXT("inf\\iereset.inf"));
                    if (PathFileExists(szIEResetInf)) {
                        TCHAR szDefHomePage[MAX_PATH];

                        GetPrivateProfileString(IS_STRINGS, TEXT("MS_START_PAGE_URL"), TEXT(""), szDefHomePage, countof(szDefHomePage), szIEResetInf);
                        WritePrivateProfileString(IS_STRINGS, TEXT("START_PAGE_URL"), szDefHomePage, szIEResetInf);

                        if (NULL != hkHklmMain)
                            RegSetValueEx(hkHklmMain, RV_DEFAULTPAGE, 0, REG_SZ, (PBYTE)szDefHomePage, (DWORD)StrCbFromSz(szDefHomePage));

                    }

                    Out(LI0(TEXT("Home page was deleted.")));
                }
        }
    }
    
    //----- Search URL -----
    if ((NULL != hkHkcuMain && !HasFlag(dwFlags, FF_GEN_SEARCHPAGE)) &&
        !(g_CtxIs(CTX_GP) && g_CtxIs(CTX_MISC_PREFERENCES) && HasFlag(dwBrandedFlags, FF_GEN_SEARCHPAGE))) {
        InsGetString(IS_URL, IK_SEARCHPAGE, szValue, countof(szValue), g_GetIns(), NULL, &fCustomize);
        if (fCustomize) {
            DWORD dwVal;

            if (TEXT('\0') != szValue[0]) {
                dwVal = 1;
                RegSetValueEx(hkHkcuMain, RV_SEARCHBAR,         0, REG_SZ,    (PBYTE)szValue, (DWORD)StrCbFromSz(szValue));
                RegSetValueEx(hkHkcuMain, RV_USE_CUST_SRCH_URL, 0, REG_DWORD, (PBYTE)&dwVal,  (DWORD)sizeof(dwVal));

                Out(LI1(TEXT("Search page is set to \"%s\"."), szValue));
                SetFeatureBranded(FID_GENERAL, FF_GEN_SEARCHPAGE);
            }
            else
                if (g_CtxIs(CTX_GP)) {
                    RegDeleteValue(hkHkcuMain, RV_SEARCHBAR);
                    RegDeleteValue(hkHkcuMain, RV_USE_CUST_SRCH_URL);

                    Out(LI0(TEXT("Search page was deleted.")));
                }
        }
    }

    //----- Help Page URL -----
    if ((NULL != hkHkcuHelpMenuUrl && !HasFlag(dwFlags, FF_GEN_HELPPAGE)) &&
        !(g_CtxIs(CTX_GP) && g_CtxIs(CTX_MISC_PREFERENCES) && HasFlag(dwBrandedFlags, FF_GEN_HELPPAGE))) {

        InsGetString(IS_URL, IK_HELPPAGE, szValue, countof(szValue), g_GetIns(), NULL, &fCustomize);
        if (fCustomize) {
            if (TEXT('\0') != szValue[0]) {
                RegSetValueEx(hkHkcuHelpMenuUrl, RV_ONLINESUPPORT, 0, REG_SZ, (PBYTE)szValue, (DWORD)StrCbFromSz(szValue));
                Out(LI1(TEXT("Help page URL is set to \"%s\"."), szValue));
                SetFeatureBranded(FID_GENERAL, FF_GEN_HELPPAGE);
            }
            else
                if (g_CtxIs(CTX_GP)) {
                    RegDeleteValue(hkHkcuHelpMenuUrl, RV_ONLINESUPPORT);
                    Out(LI0(TEXT("Help page URL was deleted.")));
                }
        }
    }
    
    //----- User Agent String -----
    if ((NULL != hkHklmUAString && !HasFlag(dwFlags, FF_GEN_UASTRING)) &&
        !(g_CtxIs(CTX_GP) && g_CtxIs(CTX_MISC_PREFERENCES) && HasFlag(dwBrandedFlags, FF_GEN_UASTRING))) {

        InsGetString(IS_BRANDING, IK_UASTR, szValue, countof(szValue), g_GetIns(), NULL, &fCustomize);
        if (fCustomize) {
            if (TEXT('\0') != szValue[0]) {
                TCHAR szID[32];                 // BUGBUG: (andrewgu) buffer overrun?

                wnsprintf(szID, countof(szID), TEXT("IEAK%s"), szCompany);
                RegSetValueEx(hkHklmUAString, szValue, 0, REG_SZ, (PBYTE)szID, (DWORD)StrCbFromSz(szID));

                Out(LI1(TEXT("User agent string is set to \"%s\"."), szValue));
                SetFeatureBranded(FID_GENERAL, FF_GEN_UASTRING);
            }
            else
                if (g_CtxIs(CTX_GP)) {
                    TCHAR szUAVal[MAX_PATH],
                          szUAData[32];
                    DWORD cchUAVal,
                          cbUAData;
                    int   iUAValue;

                    cchUAVal = countof(szUAVal),
                    cbUAData = sizeof(szUAData);
                    iUAValue = 0;
                    while (ERROR_SUCCESS == RegEnumValue(hkHklmUAString, iUAValue, szUAVal, &cchUAVal, NULL, NULL,
                        (LPBYTE)szUAData, &cbUAData)) {

                        cchUAVal = countof(szUAVal);
                        cbUAData = sizeof(szUAData);

                        if (0 == StrCmpN(szUAData, TEXT("IEAK"), 4)) {
                            RegDeleteValue(hkHklmUAString, szUAVal);
                            Out(LI1(TEXT("Deleted User Agent Key %s."), szUAVal));
                            continue;
                        }

                        iUAValue++;
                    }
                }
        }
    }

    //----- Toolbar Background Bitmap -----
    if ((NULL != hkHkcuToolbar && !HasFlag(dwFlags, FF_GEN_TOOLBARBMP)) &&
        !(g_CtxIs(CTX_GP) && g_CtxIs(CTX_MISC_PREFERENCES) && HasFlag(dwBrandedFlags, FF_GEN_TOOLBARBMP))) {
        InsGetString(IS_BRANDING, IK_TOOLBARBMP, szValue, countof(szValue), g_GetIns(), NULL, &fCustomize);
        if (fCustomize) {
            if (TEXT('\0') != szValue[0]) {
                PathCombine(szTargetFile, g_GetTargetPath(), PathFindFileName(szValue));
                ASSERT(PathFileExists(szTargetFile));

                RegSetValueEx(hkHkcuToolbar, RV_BACKGROUNDBMP50, 0, REG_SZ, (PBYTE)szTargetFile, (DWORD)StrCbFromSz(szTargetFile));

                Out(LI1(TEXT("Toolbar background bitmap is set to \"%s\"."), szTargetFile));
                SetFeatureBranded(FID_GENERAL, FF_GEN_TOOLBARBMP);
            }
            else
                if (g_CtxIs(CTX_GP)) {
                    RegDeleteValue(hkHkcuToolbar, RV_BACKGROUNDBMP50);
                    RegDeleteValue(hkHkcuToolbar, RV_BACKGROUNDBMP);

                    Out(LI0(TEXT("Toolbar background bitmap was deleted.")));
                }
        }
    }

    //----- Static Logos (large and small) -----
    if ((NULL != hkHkcuToolbar && !HasFlag(dwFlags, FF_GEN_STATICLOGO)) &&
        !(g_CtxIs(CTX_GP) && g_CtxIs(CTX_MISC_PREFERENCES) && HasFlag(dwBrandedFlags, FF_GEN_STATICLOGO))) {

        InsGetString(IS_LARGELOGO, IK_NAME, szValue, countof(szValue), g_GetIns(), NULL, &fCustomize);
        // large
        if (fCustomize)
        {
            if (TEXT('\0') != szValue[0]) {
                PathCombine(szTargetFile, g_GetTargetPath(), PathFindFileName(szValue));
                ASSERT(PathFileExists(szTargetFile));

                RegSetValueEx(hkHkcuToolbar, RV_LARGEBITMAP, 0, REG_SZ, (PBYTE)szTargetFile, (DWORD)StrCbFromSz(szTargetFile));

                Out(LI1(TEXT("Large static logo is set to \"%s\"."), szTargetFile));
                // Note: we need to write to the HKLM so that if the user goes back from
                // IE 5.01 to IE 4.0, the last customization should be reflected.
                if (!IsOS(OS_NT5) && hkHklmMain != NULL)
                    RegSetValueEx(hkHklmMain, RV_LARGEBITMAP, 0, REG_SZ, (PBYTE)szTargetFile, (DWORD)StrCbFromSz(szTargetFile));

                SetFeatureBranded(FID_GENERAL, FF_GEN_STATICLOGO);
            }
            else
            {
                if (g_CtxIs(CTX_GP)) {
                    RegDeleteValue(hkHkcuToolbar, RV_LARGEBITMAP);

                    if (hkHklmMain != NULL)
                        RegDeleteValue(hkHklmMain, RV_LARGEBITMAP);

                    Out(LI0(TEXT("Large static logo was deleted.")));
                }
            }
        }

        InsGetString(IS_SMALLLOGO, IK_NAME, szValue, countof(szValue), g_GetIns(), NULL, &fCustomize);
        // small
        if (fCustomize)
        {
            if (TEXT('\0') != szValue[0]) {
                PathCombine(szTargetFile, g_GetTargetPath(), PathFindFileName(szValue));
                ASSERT(PathFileExists(szTargetFile));

                RegSetValueEx(hkHkcuToolbar, RV_SMALLBITMAP, 0, REG_SZ, (PBYTE)szTargetFile, (DWORD)StrCbFromSz(szTargetFile));

                Out(LI1(TEXT("Small static logo is set to \"%s\"."), szTargetFile));
                // Note: we need to write to the HKLM so that if the user goes back from
                // IE 5.01 to IE 4.0, the last customization should be reflected.
                if (!IsOS(OS_NT5) && hkHklmMain != NULL)
                    RegSetValueEx(hkHklmMain, RV_SMALLBITMAP, 0, REG_SZ, (PBYTE)szTargetFile, (DWORD)StrCbFromSz(szTargetFile));

                SetFeatureBranded(FID_GENERAL, FF_GEN_STATICLOGO);
            }
            else
            {
                if (g_CtxIs(CTX_GP)) {
                    RegDeleteValue(hkHkcuToolbar, RV_SMALLBITMAP);

                    if (hkHklmMain != NULL)
                        RegDeleteValue(hkHklmMain, RV_SMALLBITMAP);

                    Out(LI0(TEXT("Small static logo was deleted.")));
                }
            }
        }
    }

    //----- Animated Logos (large and small) -----
    if ((hkHkcuToolbar != NULL && !HasFlag(dwFlags, FF_GEN_ANIMATEDLOGO) &&
            InsGetBool(IS_ANIMATION, IK_DOANIMATION, FALSE, g_GetIns())) &&
        !(g_CtxIs(CTX_GP) && g_CtxIs(CTX_MISC_PREFERENCES) && HasFlag(dwBrandedFlags, FF_GEN_ANIMATEDLOGO))) {

        InsGetString(IS_ANIMATION, IK_LARGEBITMAP, szValue, countof(szValue), g_GetIns(), NULL, &fCustomize);
        // large
        if (fCustomize)
        {
            if (TEXT('\0') != szValue[0]) {
                PathCombine(szTargetFile, g_GetTargetPath(), PathFindFileName(szValue));
                ASSERT(PathFileExists(szTargetFile));

                RegSetValueEx(hkHkcuToolbar, RV_BRANDBMP, 0, REG_SZ, (PBYTE)szTargetFile, (DWORD)StrCbFromSz(szTargetFile));

                Out(LI1(TEXT("Large animated logo is set to \"%s\"."), szTargetFile));
                SetFeatureBranded(FID_GENERAL, FF_GEN_ANIMATEDLOGO);
            }
            else
            {
                if (g_CtxIs(CTX_GP)) {
                    RegDeleteValue(hkHkcuToolbar, RV_BRANDBMP);
                    Out(LI0(TEXT("Large animated logo was deleted.")));
                }
            }
        }

        InsGetString(IS_ANIMATION, IK_SMALLBITMAP, szValue, countof(szValue), g_GetIns(), NULL, &fCustomize);
        // small
        if (fCustomize)
        {
            if (TEXT('\0') != szValue[0]) {
                PathCombine(szTargetFile, g_GetTargetPath(), PathFindFileName(szValue));
                ASSERT(PathFileExists(szTargetFile));

                RegSetValueEx(hkHkcuToolbar, RV_SMALLBRANDBMP, 0, REG_SZ, (PBYTE)szTargetFile, (DWORD)StrCbFromSz(szTargetFile));

                Out(LI1(TEXT("Small animated logo is set to \"%s\"."), szTargetFile));
                SetFeatureBranded(FID_GENERAL, FF_GEN_ANIMATEDLOGO);
            }
            else
            {
                if (g_CtxIs(CTX_GP)) {
                    RegDeleteValue(hkHkcuToolbar, RV_SMALLBRANDBMP);
                    Out(LI0(TEXT("Small animated logo was deleted.")));
                }
            }
        }
    }

    //----- First Home Page -----
    // Brand the First Home Page only if we're called via BrandIE4
    if (NULL != hkHkcuMain && !HasFlag(dwFlags, FF_GEN_FIRSTHOMEPAGE) &&
        g_CtxIs(CTX_CORP | CTX_ISP | CTX_ICP))
    {
        // A custom first home page url is present if and only if:
        //   1) NoWelcome=1 in the [URL] section AND
        //   2) FirstHomePage=<a non-empty value> in the [URL] section
        InsGetString(IS_URL, IK_FIRSTHOMEPAGE, szValue, countof(szValue), g_GetIns());
        if (*szValue  &&  InsGetBool(IS_URL, IK_NO_WELCOME_URL, FALSE, g_GetIns()))
        {
            RegSetValueEx(hkHkcuMain, RV_FIRSTHOMEPAGE, 0, REG_SZ, (PBYTE)szValue, (DWORD)StrCbFromSz(szValue));

            Out(LI1(TEXT("First Home Page is set to \"%s\"."), szValue));
        }
    }

    SHCloseKey(hkHklmMain);
    SHCloseKey(hkHkcuMain);
    SHCloseKey(hkHkcuHelpMenuUrl);
    SHCloseKey(hkHkcuToolbar);
    SHCloseKey(hkHklmUAString);

    return S_OK;
}

// write customize version in registry to denote ICP, ISP or corp install
HRESULT ProcessCustomHelpVersion()
{
    TCHAR  szHelpStr[MAX_PATH];
    PCTSTR pszCustomVer;

    pszCustomVer = NULL;
    if (HasFlag(g_GetContext(), CTX_CORP))
        pszCustomVer = TEXT("CO");

    else if (HasFlag(g_GetContext(), CTX_ISP))
        pszCustomVer = TEXT("IS");

    else {
        ASSERT(HasFlag(g_GetContext(), CTX_ICP));
        pszCustomVer = TEXT("IC");
    }

    SHSetValue(HKEY_LOCAL_MACHINE, RK_IE, RV_CUSTOMVER, REG_SZ, pszCustomVer, (DWORD)StrCbFromSz(pszCustomVer));

    // set custom string for Help About dialog (default taken from resource)
    if (0 == GetPrivateProfileString(IS_BRANDING, IK_HELPSTR, TEXT(""), szHelpStr, countof(szHelpStr), g_GetIns()))
        LoadString(g_GetHinst(), IDS_HELPSTRING, szHelpStr, countof(szHelpStr));

    SHSetValue(HKEY_LOCAL_MACHINE,
        IsOS(OS_NT) ? RK_NT_WINDOWS: RP_WINDOWS, RV_IEAK_HELPSTR, REG_SZ, szHelpStr, (DWORD)StrCbFromSz(szHelpStr));

    return S_OK;
}

void ProcessDeleteToolbarButtons(BOOL fGPOCleanup)
{
    HKEY hkToolbar;

    if (SHOpenKey(g_GetHKCU(), RK_BTOOLBAR, KEY_DEFAULT_ACCESS, &hkToolbar) == ERROR_SUCCESS)
    {
        DWORD dwIndex = 0;
        DWORD dwSub;
        TCHAR szSubKey[MAX_PATH];

        dwSub = countof(szSubKey);
        while (RegEnumKeyEx(hkToolbar, dwIndex, szSubKey, &dwSub, NULL, NULL, NULL, NULL) == ERROR_SUCCESS) 
        {
            if ((!fGPOCleanup || 
                (SHGetValue(hkToolbar, szSubKey, IEAK_GP_MANDATE, NULL, NULL, NULL) == ERROR_SUCCESS)) &&
                (SHGetValue(hkToolbar, szSubKey, TEXT("ButtonText"), NULL, NULL, NULL) == ERROR_SUCCESS))
            {
                Out(LI1(TEXT("Deleting toolbar button \"%s\"..."), szSubKey));
                SHDeleteKey(hkToolbar, szSubKey);
            }
            else
                dwIndex++;
            dwSub = countof(szSubKey);
        }
        SHCloseKey(hkToolbar);
    }
}

HRESULT ProcessToolbarButtons()
{   MACRO_LI_PrologEx_C(PIF_STD_C, ProcessToolbarButtons)

    TCHAR szCaption[MAX_BTOOLBAR_TEXT_LENGTH + 1],
          szValue[INTERNET_MAX_URL_LENGTH],
          szTargetFile[MAX_PATH],
          szBToolbarTextParam[32],
          szBToolbarIcoParam[32],
          szBToolbarActionParam[32],
          szBToolbarHotIcoParam[32],
//        szBToolbarToolTextParam[32],
          szBToolbarShowParam[32],
          szKey[128];
    DWORD dwIndex,
          dwSize;
    HKEY  hkBToolbar,
          hkSubkey;
    UINT  i;
    BOOL  fReplace, fSkip;

    if (HasFlag(g_GetContext(), (CTX_CORP | CTX_AUTOCONFIG | CTX_GP))) {
        if (InsGetBool(IS_BTOOLBARS, IK_BTDELETE, FALSE, g_GetIns())) {
            Out(LI0(TEXT("Deleting old custom toolbar buttons.")));
            ProcessDeleteToolbarButtons(FALSE);
        }
    }

    hkBToolbar = NULL;
    if (SHCreateKey(g_GetHKCU(), RK_BTOOLBAR, KEY_WRITE | KEY_READ, &hkBToolbar) == ERROR_SUCCESS)
    {
        for (i = 0; i < MAX_BTOOLBARS; i++, dwIndex++)
        {
            wnsprintf(szBToolbarTextParam,     countof(szBToolbarTextParam),     TEXT("%s%i"), IK_BTCAPTION, i);
            wnsprintf(szBToolbarIcoParam,      countof(szBToolbarIcoParam),      TEXT("%s%i"), IK_BTICON,    i);
            wnsprintf(szBToolbarActionParam,   countof(szBToolbarActionParam),   TEXT("%s%i"), IK_BTACTION,  i);
            wnsprintf(szBToolbarHotIcoParam,   countof(szBToolbarHotIcoParam),   TEXT("%s%i"), IK_BTHOTICO,  i);
//          wnsprintf(szBToolbarToolTextParam, countof(szBToolbarToolTextParam), TEXT("%s%i"), IK_BTTOOLTIP, i);
            wnsprintf(szBToolbarShowParam,     countof(szBToolbarShowParam),     TEXT("%s%i"), IK_BTSHOW,    i);
            
            if (!GetPrivateProfileString(IS_BTOOLBARS, szBToolbarTextParam, TEXT(""), szCaption, countof(szCaption), g_GetIns()))
                break;
            
            Out(LI1(TEXT("Adding toolbar button \"%s\"..."), szCaption));
            
            dwIndex = 0;
            fReplace = FALSE;
            fSkip = FALSE;

            dwSize = countof(szKey);
            while (RegEnumKeyEx(hkBToolbar, dwIndex, szKey, &dwSize, NULL, NULL, NULL, NULL) == ERROR_SUCCESS)
            {
                TCHAR szOld[128];
                
                dwSize = sizeof(szOld);
                if (SHGetValue(hkBToolbar, szKey, TEXT("ButtonText"), NULL, 
                    (LPVOID)szOld, &dwSize) == ERROR_SUCCESS)
                {
                    if (StrCmpI(szOld, szCaption) == 0)
                    {
                        // check to see if this is a mandate key

                        if (g_CtxIs(CTX_MISC_PREFERENCES) &&
                            (SHValueExists(hkBToolbar, szKey, IEAK_GP_MANDATE) == S_OK))
                            fSkip = TRUE;
                        else
                            fReplace = TRUE;

                        break;
                    }
                }
                
                dwIndex++;
                dwSize = countof(szKey);
            }
            
            if (fSkip)
                continue;

            if (!fReplace)
            {
                GUID guid;
                
                if (CoCreateGuid(&guid) == NOERROR)
                    CoStringFromGUID(guid, szKey, countof(szKey));
            }

            Out(LI1(TEXT("Using reg key \"%s\"..."), szKey));
            
            if (SHCreateKey(hkBToolbar, szKey, KEY_WRITE, &hkSubkey) == ERROR_SUCCESS)
            {
                LPCTSTR pszValue;

                pszValue = InsGetBool(IS_BTOOLBARS, szBToolbarShowParam, TRUE, g_GetIns()) ? TEXT("Yes") : TEXT("No");

                RegSetValueEx(hkSubkey, TEXT("Default Visible"), 0, REG_SZ, (LPBYTE)pszValue, (DWORD)StrCbFromSz(pszValue));

                Out(LI1(TEXT("Default State is \"%s\","), pszValue));

                RegSetValueEx(hkSubkey, TEXT("ButtonText"), 0, REG_SZ, (LPBYTE)szCaption, (DWORD)StrCbFromSz(szCaption));
                Out(LI1(TEXT("Setting caption to \"%s\","), szCaption));

                RegSetValueEx(hkSubkey, TEXT("CLSID"), 0, REG_SZ, (LPBYTE)BTOOLBAR_GUID, sizeof(BTOOLBAR_GUID));
                
                if (GetPrivateProfileString(IS_BTOOLBARS, szBToolbarIcoParam, TEXT(""), szValue, countof(szValue), g_GetIns()))
                {
                    PathCombine(szTargetFile, g_GetTargetPath(), PathFindFileName(szValue));
                    ASSERT(PathFileExists(szTargetFile));

                    RegSetValueEx(hkSubkey, TEXT("Icon"), 0, REG_SZ, (LPBYTE)szTargetFile, (DWORD)StrCbFromSz(szTargetFile));
                    Out(LI1(TEXT("Setting icon to \"%s\","), PathFindFileName(szTargetFile)));
                }
                
                if (GetPrivateProfileString(IS_BTOOLBARS, szBToolbarHotIcoParam, TEXT(""), szValue, countof(szValue), g_GetIns()))
                {
                    PathCombine(szTargetFile, g_GetTargetPath(), PathFindFileName(szValue));
                    ASSERT(PathFileExists(szTargetFile));

                    RegSetValueEx(hkSubkey, TEXT("HotIcon"), 0, REG_SZ, (LPBYTE)szTargetFile, (DWORD)StrCbFromSz(szTargetFile));
                    Out(LI1(TEXT("Setting hot icon to \"%s\","), PathFindFileName(szTargetFile)));
                }
                
/*              if (GetPrivateProfileString(IS_BTOOLBARS, szBToolbarToolTextParam, TEXT(""), szValue, countof(szValue), g_GetIns()))
                {
                    RegSetValueEx(hkSubkey, TEXT("ToolTip"), 0, REG_SZ, (LPBYTE)szValue, (DWORD)StrCbFromSz(szValue));
                    Out(LI1(TEXT("Setting tool tip to \"%s\","), szValue));
                }
*/

                // set a special key not to delete if this is not a preference GPO

                if (g_CtxIsGp() && !g_CtxIs(CTX_MISC_PREFERENCES))
                    RegSetValueEx(hkSubkey, IEAK_GP_MANDATE, 0, REG_SZ, (LPBYTE)TEXT(""), StrCbFromCch(2));

                if (GetPrivateProfileString(IS_BTOOLBARS, szBToolbarActionParam, TEXT(""), szValue, countof(szValue), g_GetIns()))
                {
                    RegSetValueEx(hkSubkey, TEXT("Exec"), 0, REG_SZ, (LPBYTE)szValue, (DWORD)StrCbFromSz(szValue));
                    Out(LI1(TEXT("Setting script/action to \"%s\""), szValue));
                }

                SHCloseKey(hkSubkey);
            }
            else
                Out(LI0(TEXT("Could not create reg key")));
        }

        SHCloseKey(hkBToolbar);
    }

    SetFeatureBranded(FID_TOOLBARBUTTONS);
    return S_OK;
}

// ISP Root Cert
HRESULT ProcessRootCert()
{   MACRO_LI_PrologEx_C(PIF_STD_C, ProcessRootCert)

    USES_CONVERSION;

    typedef DWORD (WINAPI* CRYPTUIWIZIMPORT) (DWORD, HWND, LPCWSTR, PCCRYPTUI_WIZ_IMPORT_SRC_INFO, HCERTSTORE);

    CRYPTUI_WIZ_IMPORT_SRC_INFO certInfo;
    TCHAR            szValue[MAX_PATH],
                     szTargetFile[MAX_PATH];
    PCTSTR           pszFilename;
    CRYPTUIWIZIMPORT pfnCryptUIWizImport;
    HCERTSTORE       hSystemStore;
    HINSTANCE        hCryptuiLib;
    HRESULT          hr;

    pfnCryptUIWizImport = NULL;
    hr = S_OK;

    GetPrivateProfileString(IS_ISPSECURITY, IK_ROOTCERT, TEXT(""), szValue, countof(szValue), g_GetIns());

    pszFilename = PathFindFileName(szValue);
    Out(LI1(TEXT("Adding root cert \"%s\"..."), pszFilename));
    PathCombine(szTargetFile, g_GetTargetPath(), pszFilename);

    hCryptuiLib = LoadLibrary(TEXT("cryptui.dll"));
    if (hCryptuiLib == NULL) {
        Out(LI0(TEXT("cryptui.dll load lib failed")));
        return E_FAIL;
    }

    pfnCryptUIWizImport = (CRYPTUIWIZIMPORT)GetProcAddress(hCryptuiLib, "CryptUIWizImport");
    if (pfnCryptUIWizImport == NULL) {
        FreeLibrary(hCryptuiLib);
        Out(LI0(TEXT("Could not find entry point CryptUIWizImport")));
        return E_FAIL;
    }

    hSystemStore = CertOpenStore(CERT_STORE_PROV_SYSTEM_W, 0, 0, CERT_SYSTEM_STORE_LOCAL_MACHINE, L"ROOT");
    if (hSystemStore != NULL) {
        ZeroMemory(&certInfo, sizeof(certInfo));
        certInfo.dwSize          = sizeof(certInfo);
        certInfo.pwszFileName    = T2CW(szTargetFile);
        certInfo.dwSubjectChoice = CRYPTUI_WIZ_IMPORT_SUBJECT_FILE;

        if (!pfnCryptUIWizImport(CRYPTUI_WIZ_NO_UI, NULL, NULL, &certInfo, hSystemStore)) {
            Out(LI0(TEXT("Unable to add root cert.")));
            hr = E_FAIL;
        }
        else
            DeleteFile(szTargetFile);

        CertCloseStore(hSystemStore, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    else {
        Out(LI0(TEXT("Unable to open system store.")));
        hr = E_FAIL;
    }

    FreeLibrary(hCryptuiLib);
    return hr;
}

// Register download URLs as safe for updating IE
HRESULT ProcessActiveSetupSites()
{   MACRO_LI_PrologEx_C(PIF_STD_C, ProcessActiveSetupSites)

    URL_COMPONENTS uc;
    TCHAR  szUrl[INTERNET_MAX_URL_LENGTH],
           szRegKey[MAX_PATH],
           szTitle[MAX_PATH],
           szGuid[128],
           szInsKey[32];
    HKEY   hk;
    LPTSTR pszBuf;
    DWORD  dwUrlLen;
    LONG   lResult;
    int    i;

    W2Tbuf(awchMSIE4GUID, szGuid, countof(szGuid));
    wnsprintf(szRegKey, countof(szRegKey), RK_IE_UPDATE, szGuid);

    lResult = SHCreateKeyHKLM(szRegKey, KEY_SET_VALUE, &hk);
    if (lResult != ERROR_SUCCESS)
        return HRESULT_FROM_WIN32(lResult);

    for (i = 0; TRUE; i++) {
        wnsprintf(szInsKey, countof(szInsKey), IK_SITENAME, i);
        GetPrivateProfileString(IS_ACTIVESETUP_SITES, szInsKey, TEXT(""), szTitle, countof(szTitle), g_GetIns());

        wnsprintf(szInsKey, countof(szInsKey), IK_SITEURL, i);
        dwUrlLen = GetPrivateProfileString(IS_ACTIVESETUP_SITES, szInsKey, TEXT(""), szUrl, countof(szUrl), g_GetIns());

        if (szTitle[0] == TEXT('\0') || szUrl[0] == TEXT('\0'))
            break;

        //----- Figure out Protocol/Host pair in the URL -----
        ZeroMemory(&uc, sizeof(uc));
        uc.dwStructSize      = sizeof(uc);
        uc.dwSchemeLength    = 1;
        uc.dwHostNameLength  = 1;
        uc.dwUrlPathLength   = 1;

        if (InternetCrackUrl(szUrl, dwUrlLen, 0, &uc)) {
            if (uc.nScheme == INTERNET_SCHEME_FILE) {
                // the below ASSERT explains the case we got here
                ASSERT(uc.lpszHostName     == NULL &&
                       uc.dwHostNameLength == 0);

                if (PathIsUNC(uc.lpszUrlPath)) {
                    // Note. The following code is ported from shlwapi's
                    //       PathSkipRoot which doesn't work here.

                    ASSERT(uc.dwUrlPathLength >= 2);
                    pszBuf = uc.lpszUrlPath;
                    if (StrCmpN(pszBuf, TEXT("\\\\"), 2) == 0) {
                        pszBuf = StrChr(pszBuf + 2, TEXT('\\'));
                        if (pszBuf != NULL)
                            pszBuf = StrPBrk(pszBuf + 1, TEXT("\\/"));
                    }

                    if (pszBuf != NULL) {   // better be safe than sorry
                        *pszBuf = TEXT('\0');
                        uc.dwUrlPathLength = DWORD(pszBuf - uc.lpszUrlPath);
                        ASSERT(PathIsUNCServerShare(uc.lpszUrlPath));
                    }
                }
                else                        // whatever it is,
                    ;                       // use the whole thing
            }
            else if (uc.nScheme == INTERNET_SCHEME_DEFAULT ||
                     uc.nScheme == INTERNET_SCHEME_FTP     ||
                     uc.nScheme == INTERNET_SCHEME_GOPHER  ||
                     uc.nScheme == INTERNET_SCHEME_HTTP    ||
                     uc.nScheme == INTERNET_SCHEME_HTTPS) {
                // the below ASSERT explains the case we got here
                ASSERT(uc.lpszHostName     != NULL &&
                       uc.dwHostNameLength >= 0);

                uc.lpszUrlPath = NULL;      // only need the host
                uc.dwUrlPathLength = 0;
            }
            else                            // wierdo,
                ;                           // use the whole thing

            if (InternetCreateUrl(&uc, 0, szUrl, &dwUrlLen))
                RegSetValueEx(hk, szUrl, 0, REG_SZ, (LPBYTE)TEXT(""), StrCbFromCch(1));
        }
    }

    SHCloseKey(hk);
    return S_OK;
}

// Removes links
HRESULT ProcessLinksDeletion()
{   MACRO_LI_PrologEx_C(PIF_STD_C, ProcessLinksDeletion)
    
    // OE
    if (InsGetBool(IS_OUTLKEXP, IK_DELETELINKS, FALSE, g_GetIns()))
        deleteLinks(MSIMN_EXE, DESKTOP_FOLDER | PROGRAMS_FOLDER | QUICKLAUNCH_FOLDER | PROGRAMS_IE_FOLDER);

    // Channel
    if (InsGetBool(IS_DESKTOPOBJS, IK_DELETELINKS, FALSE, g_GetIns()))
    {
        TCHAR szViewChannels[MAX_PATH];

        if (0 == LoadString(g_GetHinst(), IDS_FILE_VIEWCHANNELS, szViewChannels, countof(szViewChannels)))
            StrCpy(szViewChannels, VIEWCHANNELS_SCF);

        deleteLinks(szViewChannels, QUICKLAUNCH_FOLDER);
    }

    return S_OK;
}

// Configure paths to branding files for Outlook Express
HRESULT ProcessOutlookExpress()
{   MACRO_LI_PrologEx_C(PIF_STD_C, ProcessOutlookExpress)

    USES_CONVERSION;

    TCHAR   szTargetFile[MAX_PATH],
            szFile[MAX_PATH];
    LPCTSTR pszFileName;
    HRESULT hr;
    UINT    nLen, nTargetPathLen;
    BOOL    fHTTP, fBrandOE;

    // no OE branding for GP
    // BUGBUG: <oliverl> this should be moved to an apply function along with some stuff below

    if (g_CtxIsGp())
        return S_OK;

    hr = S_OK;

    StrCpy(szTargetFile, g_GetTargetPath());
    nTargetPathLen = StrLen(szTargetFile);

    // initialize fBrandOE to FALSE; it will be set to TRUE if and only if there is atleast one OE setting to brand
    fBrandOE = FALSE;

    // Infopane
    nLen  = GetPrivateProfileString(IS_INTERNETMAIL, IK_INFOPANE, TEXT(""), szFile, countof(szFile), g_GetIns());
    fHTTP = PathIsURL(szFile);
    if (!fHTTP && nLen > 0) {
        pszFileName = PathFindFileName(szFile);

        PathAppend(szTargetFile, pszFileName);
        WritePrivateProfileString(IS_INTERNETMAIL, IK_INFOPANE, szTargetFile, g_GetIns());
        szTargetFile[nTargetPathLen] = TEXT('\0');

        fBrandOE = TRUE;
    }

    // Infopane bitmap
    if (!fHTTP) {
        nLen = GetPrivateProfileString(IS_INTERNETMAIL, IK_INFOPANEBMP, TEXT(""), szFile, countof(szFile), g_GetIns());
        if (nLen > 0) {
            pszFileName = PathFindFileName(szFile);

            PathAppend(szTargetFile, pszFileName);
            WritePrivateProfileString(IS_INTERNETMAIL, IK_INFOPANEBMP, szTargetFile, g_GetIns());
            szTargetFile[nTargetPathLen] = TEXT('\0');

            fBrandOE = TRUE;
        }
    }

    // Welcome message HTML file
    nLen = GetPrivateProfileString(IS_INTERNETMAIL, IK_WELCOMEMESSAGE, TEXT(""), szFile, countof(szFile), g_GetIns());
    if (nLen > 0) {
        pszFileName = PathFindFileName(szFile);

        PathAppend(szTargetFile, pszFileName);
        WritePrivateProfileString(IS_INTERNETMAIL, IK_WELCOMEMESSAGE, szTargetFile, g_GetIns());
        szTargetFile[nTargetPathLen] = TEXT('\0');

        fBrandOE = TRUE;
    }

    nLen = GetPrivateProfileString(IS_LDAP, IK_BITMAP, TEXT(""), szFile, countof(szFile), g_GetIns());
    if (nLen > 0) {
        pszFileName = PathFindFileName(szFile);

        PathAppend(szTargetFile, pszFileName);
        WritePrivateProfileString(IS_LDAP, IK_BITMAP, szTargetFile, g_GetIns());

        fBrandOE = TRUE;
    }

    // Note. Need to flush the *.ini file before calling into OE branding DLL.
    //WritePrivateProfileString(NULL, NULL, NULL, g_GetIns());

    //----- Call into OE branding DLL for branding of Outlook Express -----
    // Note. In the ISP mode the actual branding will happen during the signup
    //       process and not here.
    if (!HasFlag(g_GetContext(), CTX_SIGNUP_ALL)) {
        TCHAR     szOEBrandDLL[MAX_PATH];
        HINSTANCE hDLL;
        HKEY      hk;
        DWORD     dwSize;
        LONG      lResult;
        BOOL      fLoadedDLL;

        // apszOESections lists all the sections which contain only OE branding information;
        // if a new section is added or an existing one is deleted, pls update the array.
        LPCTSTR apszOESections[] = {
            IS_IDENTITIES,          // [Identities]
            IS_INTERNETMAIL,        // [Internet_Mail]
            IS_INTERNETNEWS,        // [Internet_News]
            IS_LDAP,                // [LDAP]
            IS_MAILSIG,             // [Mail_Signature]
            IS_SIG,                 // [Signature]
            IS_OUTLKEXP,            // [Outlook_Express]
            IS_OEGLOBAL             // [Outlook_Express_Global]
        };

        // perf: Do a LoadLibrary on msoeacct.dll to brand OE settings only if:
        // (1) fBrandOE is already set to TRUE, or
        // (2) there is atleast one non-empty OE section, or
        // (3) Help_Page is non-empty in the [URL] section

        if (!fBrandOE)
        {
            // set fBrandOE to TRUE if atleast one of the OE sections (apszOESections[]) is non-empty
            for (INT i = 0;  i < countof(apszOESections);  i++)
                if (!InsIsSectionEmpty(apszOESections[i], g_GetIns()))
                {
                    fBrandOE = TRUE;
                    break;
                }
        }

        if (!fBrandOE)
        {
            // set fBrandOE to TRUE if Help_Page is non-empty in the [URL] section
            if (!InsIsKeyEmpty(IS_URL, IK_HELPPAGE, g_GetIns()))
                fBrandOE = TRUE;
        }

        if (!fBrandOE)
        {
            Out(LI0(TEXT("There are no Outlook Express settings to brand!")));
            goto Exit;
        }

        lResult = SHOpenKeyHKLM(RK_OE_ACCOUNTMGR, KEY_QUERY_VALUE, &hk);
        if (lResult != ERROR_SUCCESS)
            goto Exit;

        szOEBrandDLL[0] = TEXT('\0');
        dwSize          = sizeof(szOEBrandDLL);
        SHQueryValueEx(hk, RV_DLLPATH, NULL, NULL, (LPVOID)&szOEBrandDLL, &dwSize);
        SHCloseKey(hk);

        if (szOEBrandDLL[0] == TEXT('\0'))
            goto Exit;

        hDLL = LoadLibrary(szOEBrandDLL);
        fLoadedDLL = (hDLL != NULL);

        if (fLoadedDLL) {
            typedef HRESULT (CALLBACK *PFNCREATEACCT)(LPCSTR, DWORD);

            PFNCREATEACCT pfnCreateAcct;

            pfnCreateAcct = (PFNCREATEACCT)GetProcAddress(hDLL, "CreateAccountsFromFile");
            if (pfnCreateAcct != NULL) {
                hr = pfnCreateAcct(T2CA(g_GetIns()), 0);
                if (SUCCEEDED(hr))
                    Out(LI0(TEXT("OE branding was successful!")));
                else
                    Out(LI1(TEXT("! OE branding failed with %s"), GetHrSz(hr)));
            }
            else
                Out(LI1(TEXT("! Branding API for OE \"CreateAccountsFromFile\" is missing from \"%s\"."), szOEBrandDLL));

            FreeLibrary(hDLL);
        }
        else
            Out(LI1(TEXT("! OE branding dll \"%s\" was not found."), szOEBrandDLL));
    }
    else
        Out(LI0(TEXT("Ins file is set up. Actual OE branding will happen during signup process!")));

Exit:
    return hr;
}

#define SZDELAYLISTKEY  RP_IEAK_GPOS TEXT("\\PendingGPOs")

void WriteToDelayList(LPCTSTR szTargetFile, LPCTSTR szSection)
{
    HKEY hKey;
    DWORD dwCount = 0;
    DWORD dwData = 0;
    DWORD dwSize = sizeof(DWORD);

    OutD(LI2(TEXT("WriteToDelayList called with %s and %s\n"), szTargetFile, szSection));
    
    if(ERROR_SUCCESS != RegCreateKeyExW(g_GetHKCU(), SZDELAYLISTKEY, 0, 0, 
        REG_OPTION_VOLATILE, KEY_SET_VALUE | KEY_QUERY_VALUE, NULL, &hKey, NULL))
    {
        OutD(LI0(TEXT("RegCreateKeyExW failed\n")));
        return;
    }

    if(ERROR_SUCCESS == RegQueryValueEx(hKey, TEXT("Count"), 0, NULL, (LPBYTE)&dwData, &dwSize))
    {
        dwCount = dwData;
    }

    dwCount++;

    TCHAR szPath[100];

    wnsprintf(szPath, countof(szPath), TEXT("Path%d"), dwCount);
    OutD(LI1(TEXT("Path is %s\n"), szPath));

    if(ERROR_SUCCESS != RegSetValueExW(hKey, szPath, 0, REG_SZ, (LPBYTE)szTargetFile, (lstrlen(szTargetFile) + 1) * sizeof(TCHAR)))
    {
        OutD(LI0(TEXT("RegSetValueEx for Path failed\n")));
    }

    wnsprintf(szPath, countof(szPath), TEXT("Section%d"), dwCount);

    if(ERROR_SUCCESS != RegSetValueExW(hKey, szPath, 0, REG_SZ, (LPBYTE)szSection, (lstrlen(szSection) + 1) * sizeof(TCHAR)))
    {
        OutD(LI0(TEXT("RegSetValueEx for Section failed\n")));
    }

    if(ERROR_SUCCESS != RegSetValueExW(hKey, TEXT("Count"), 0, REG_DWORD, (LPBYTE)&dwCount, sizeof(DWORD)))
    {
        OutD(LI0(TEXT("RegSetValueEx for Count failed\n")));
    }

    RegCloseKey(hKey);
}

static HRESULT processExtRegInfSectionHelper(LPCTSTR pcszExtRegInfSect)
{
    TCHAR     szKeys[512], szValue[MAX_PATH],
              szTargetFile[MAX_PATH],
              szSection[MAX_PATH];
    LPCTSTR   pszCurKey,
              pszInfName;
    LPTSTR    pszValue,
              pszInf, pszSection;
    HRESULT   hr = S_OK;
    
    Out(LI1(TEXT("! processExtRegInfSectionHelper for section\"%s\"."), pcszExtRegInfSect));

    GetPrivateProfileString(pcszExtRegInfSect, NULL, TEXT(""), szKeys, countof(szKeys), g_GetIns());
    for (pszCurKey = szKeys; *pszCurKey != TEXT('\0'); pszCurKey += StrLen(pszCurKey) + 1) {

        if(!StrCmpI(pszCurKey, TEXT("SecZones")) && 
            IsIEHardened() && 
            StrCmpNI(IS_EXTREGINF_ESC, pcszExtRegInfSect, ARRAYSIZE(IS_EXTREGINF_ESC)-1))
        {
            Out(LI0(TEXT("Not processing SecZones inf on this machine because of Enhanced Security Configuration\n")));
            continue;
        }


        GetPrivateProfileString(pcszExtRegInfSect, pszCurKey, TEXT(""), szValue, countof(szValue), g_GetIns());
        if (*szValue == TEXT('\0'))
            continue;

        pszValue = szValue;

        //----- Inf file -----
        pszInf = StrGetNextField(&pszValue, TEXT(","), 0);
        if (pszInf != NULL && *pszInf != TEXT('\0')) {
            StrRemoveWhitespace(pszInf);

            if (*pszInf == TEXT('*')) {         // skip this, read the inf name again
                pszInf = StrGetNextField(&pszValue, TEXT(","), 0);
                if (pszInf != NULL && *pszInf != TEXT('\0'))
                    StrRemoveWhitespace(pszInf);
            }
        }

        if (pszInf == NULL || *pszInf == TEXT('\0')) {
            Out(LI1(TEXT("! Format of key \"%s\" is corrupt."), pszCurKey));
            hr = S_FALSE;
            continue;
        }

        //----- Section to execute -----
        pszSection = StrGetNextField(&pszValue, TEXT(","), 0);
        if (pszSection != NULL && *pszSection != TEXT('\0'))
            StrRemoveWhitespace(pszSection);

        if (pszSection == NULL || *pszSection == TEXT('\0'))
            pszSection = TEXT("DefaultInstall");

        StrCpy(szSection, pszSection);

        // run only the HKCU settings in the *.inf file for the per user stuff
        ASSERT(szSection[0] != TEXT('\0'));
        if (HasFlag(g_GetContext(), CTX_MISC_PERUSERSTUB))
            StrCat(szSection, TEXT(".HKCU"));

        //----- Execute *.inf file -----
        pszInfName = PathFindFileName(pszInf);
        PathCombine(szTargetFile, g_GetTargetPath(), pszInfName);
        PathAddExtension(szTargetFile, TEXT(".inf"));

        if (!PathFileExists(szTargetFile)) {
            Out(LI1(TEXT("! File \"%s\" doesn't exist."), pszInfName));
            hr = S_FALSE;
            continue;
        }

        // preprocessing hook
        if (S_OK != eriPreHook(szTargetFile, szSection, (LPARAM)pcszExtRegInfSect))
            continue;

        // BUGBUG: (pritobla) we should avoid writing to target files. if  needed, the creator of
        // the inf file can use custom ldid's.
        WritePrivateProfileString(IS_STRINGS, IK_49100, GetIEPath(), szTargetFile);
        WritePrivateProfileString(NULL, NULL, NULL, szTargetFile);

        // if HKCU section specific settings not found, revert back to the original section.
        if (HasFlag(g_GetContext(), CTX_MISC_PERUSERSTUB) &&
            InsIsSectionEmpty(szSection, szTargetFile)) {
            LPTSTR pszPerUser;                  // there is no specific HKCU section

            pszPerUser  = StrRChr(szSection, NULL, TEXT('.'));
            ASSERT(pszPerUser != NULL);
            *pszPerUser = TEXT('\0');
        }

        if(!StrCmpI(pszCurKey, TEXT("SecZones")) &&
           g_CtxIsGp() && 
           g_CtxIs(CTX_MISC_CHILDPROCESS) && 
           IsFirstTimeLogon())
        {
            Out(LI1(TEXT("Delaying execution of %s."), szTargetFile));
            WriteToDelayList(szTargetFile, szSection);
            hr = S_OK;            
        }
        else
        {
            Out(LI1(TEXT("Not Delaying executing %s."), szTargetFile));
            hr = RunSetupCommandWrap(NULL, szTargetFile, szSection, g_GetTargetPath(), NULL, NULL,
                RSC_FLAG_INF | RSC_FLAG_QUIET, 0);
        }

        if (FAILED(hr)) {
            Out(LI3(TEXT("! Execution of section [%s] in \"%s\" failed with %s."), szSection, pszInfName, GetHrSz(hr)));
            hr = S_FALSE;
            continue;
        }
        Out(LI1(TEXT("\"%s\" processed successfully."), pszInf));

        // postprocessing hook
        eriPostHook(szTargetFile, szSection, (LPARAM)pcszExtRegInfSect);
    }

    return hr;

}

/////////////////////////////////////////////////////////////////////////////
// Implementation helper routines

static HRESULT processExtRegInfSection(LPCTSTR pcszExtRegInfSect)
{   MACRO_LI_PrologEx_C(PIF_STD_C, processExtRegInfSection)

    HINSTANCE hSetupapiDll;
    HRESULT   hr;

    hSetupapiDll = NULL;
    hr           = S_OK;

    // NOTE: (pritobla) load setupapi.dll so that if there is more than one inf to process, we can
    // avoid multiple loads and unloads.
    hSetupapiDll = LoadLibrary(TEXT("setupapi.dll"));

    hr = processExtRegInfSectionHelper(pcszExtRegInfSect);

    if(IsIEHardened())
    {
        Out(LI0(TEXT("Machine has Enhanced Security Configuration\n")));
        TCHAR szSection[MAX_PATH] = IS_EXTREGINF_ESC;
        
        if (PathIsExtension(pcszExtRegInfSect, TEXT(".Hklm")))
        {
            StrCat(szSection, TEXT(".HKLM"));
        }
        else if (PathIsExtension(pcszExtRegInfSect, TEXT(".Hkcu")))
        {
            StrCat(szSection, TEXT(".HKCU"));
        }

        hr = processExtRegInfSectionHelper(szSection);
    }
    else
    {
        Out(LI0(TEXT("Machine is not hardened\n")));

    }


    if (hSetupapiDll != NULL)
        FreeLibrary(hSetupapiDll);

    // set adms as being done in the registry so we don't apply same preferences again

    TCHAR szAdmGuid[128];

    if (g_CtxIs(CTX_GP) &&
        InsGetString(IS_BRANDING, IK_GPE_ADM_GUID, szAdmGuid, countof(szAdmGuid), g_GetIns()))
    {
        TCHAR szKey[MAX_PATH];
        HKEY  hkAdm = NULL;

        PathCombine(szKey, RK_IEAK_GPOS, g_GetGPOGuid());
        PathAppend(szKey, RK_IEAK_ADM);
        PathAppend(szKey, szAdmGuid);
        PathAppend(szKey, g_CtxIs(CTX_MISC_CHILDPROCESS) ? IS_EXTREGINF_HKCU : IS_EXTREGINF_HKLM);
        SHCreateKey(g_GetHKCU(), szKey, KEY_DEFAULT_ACCESS, &hkAdm);
        SHCloseKey(hkAdm);
    }
        
    return hr;
}

static HRESULT eriPreHook(LPCTSTR pszInf, LPCTSTR pszSection, LPARAM lParam /*= NULL*/)
{
    UNREFERENCED_PARAMETER(pszSection);

    LPCTSTR pszInfName;

    ASSERT(PathFileExists(pszInf) && pszSection != NULL && *pszSection != TEXT('\0'));
    pszInfName = PathFindFileName(pszInf);

    if (0 == StrCmpI(pszInfName, TEXT("ie4chnls.inf")))
    {
        // NOTE: (oliverl) this is done for compatibility with ie4 style channels. this inf should
        // only be run by ie4 branding dll since ie5 branding dll processes channels from ins.
        Out(LI1(TEXT("Skipping legacy inf \"%s\"..."), pszInfName));
        return S_FALSE;
    }

    else if (0 == StrCmpI(pszInfName, CONNECT_INF)) {
    // BUGBUG: (andrewgu, pritobla) a cool suggestion by pritvi. we can delay load the main ras
    // dll and in the failure hooks fall back to that crappy win95 gold thing we have to do. right
    // now this is expansive and is a perf regression. pritvi will make investigation to do this
    // ala imagehlp.dll.
        LPRASDEVINFOW prdiW;
        DWORD         cDevices;
        BOOL          fSkip,
                      fRasApisLoaded;

        prdiW          = NULL;
        fSkip          = !RasIsInstalled();
        fRasApisLoaded = FALSE;

        if (!fSkip) {
            fRasApisLoaded = (RasPrepareApis(RPA_RASSETENTRYPROPERTIESA) && NULL != g_pfnRasSetEntryPropertiesA);
            fSkip          = !fRasApisLoaded;
        }

        if (!fSkip) {
            RasEnumDevicesExW(&prdiW, NULL, &cDevices);
            fSkip = (0 == cDevices);
        }

        if (NULL != prdiW)
            CoTaskMemFree(prdiW);

        if (fRasApisLoaded)
            RasPrepareApis(RPA_UNLOAD, FALSE);

        if (fSkip) {
            Out(LI1(TEXT("Skipping \"%s\" due to RAS configuration on the system..."), pszInfName));
            return S_FALSE;
        }

        if ((g_CtxIs(CTX_GP) && !g_CtxIs(CTX_MISC_PREFERENCES)) &&
            FF_DISABLE == GetFeatureBranded(FID_CS_MAIN))
            raBackup();
    }
    else if (0 == StrCmpI(pszInfName, TEXT("desktop.inf")) ||
             0 == StrCmpI(pszInfName, TEXT("toolbar.inf")))
    {
        if (IsOS(OS_NT5))
        {
            Out(LI1(TEXT("Skipping inf \"%s\" on Windows 2000..."), pszInfName));
            return S_FALSE;
        }
    }
    else if (0 == StrCmpI(pszInfName, TEXT("seczones.inf")))
    {
        if (g_CtxIsGp())
        {
            if (g_CtxIs(CTX_MISC_PREFERENCES) &&
                FF_DISABLE != GetFeatureBranded(g_CtxIs(CTX_MISC_CHILDPROCESS) ?
                                                FID_ZONES_HKCU :
                                                FID_ZONES_HKLM))
                return S_FALSE;
        }
        else
        {
            ASSERT(g_CtxIs(CTX_CORP | CTX_AUTOCONFIG | CTX_W2K_UNATTEND));

            ASSERT(lParam != NULL);
            // delete ZONES and ZONESMAP keys before applying them

            if (PathIsExtension((LPCTSTR)lParam, TEXT(".Hklm")))
            {
                SHDeleteKey(HKEY_LOCAL_MACHINE, REG_KEY_ZONES);
                SHDeleteKey(HKEY_LOCAL_MACHINE, REG_KEY_ZONEMAP);
            }
            else if (PathIsExtension((LPCTSTR)lParam, TEXT(".Hkcu")))
            {
                SHDeleteKey(g_GetHKCU(), REG_KEY_ZONES);
                SHDeleteKey(g_GetHKCU(), REG_KEY_ZONEMAP);
            }
            else    // legacy ExtRegInf section
            {
                if (!InsIsSectionEmpty(IS_IEAKADDREG_HKLM, pszInf))
                {
                    SHDeleteKey(HKEY_LOCAL_MACHINE, REG_KEY_ZONES);
                    SHDeleteKey(HKEY_LOCAL_MACHINE, REG_KEY_ZONEMAP);
                }

                if (!InsIsSectionEmpty(IS_IEAKADDREG_HKCU, pszInf))
                {
                    SHDeleteKey(g_GetHKCU(), REG_KEY_ZONES);
                    SHDeleteKey(g_GetHKCU(), REG_KEY_ZONEMAP);
                }
            }
        }
    }
    else if (0 == StrCmpI(pszInfName, TEXT("ratings.inf")))
    {
        if (g_CtxIs(CTX_GP) && g_CtxIs(CTX_MISC_PREFERENCES) && FF_DISABLE != GetFeatureBranded(FID_RATINGS))
            return S_FALSE;
    }
    else if (0 == StrCmpI(pszInfName, TEXT("authcode.inf")))
    {
        if (g_CtxIs(CTX_GP) && g_CtxIs(CTX_MISC_PREFERENCES) && FF_DISABLE != GetFeatureBranded(FID_AUTHCODE))
            return S_FALSE;
    }
    else if (0 == StrCmpI(pszInfName, TEXT("programs.inf")))
    {
        if (g_CtxIs(CTX_GP) && g_CtxIs(CTX_MISC_PREFERENCES) && FF_DISABLE != GetFeatureBranded(FID_PROGRAMS))
            return S_FALSE;
    }
    else if (0 == StrCmpI(pszInfName, TEXT("sitecert.inf")))
    {
        // do nothing
    }
    else
    {
        // check to see if our adms have been applied before since they're always treated as
        // preferences(only adms have these extra legacy sections)

        // only ADM inf's have IS_DEFAULTINSTALL_HKCU and/or IS_DEFAULTINSTALL_HKLM sections
        if (g_CtxIs(CTX_GP) &&
            (!InsIsSectionEmpty(IS_DEFAULTINSTALL_HKCU, pszInf) ||
             !InsIsSectionEmpty(IS_DEFAULTINSTALL_HKLM, pszInf)))
        {
            TCHAR szAdmGuid[128];
            TCHAR szKey[MAX_PATH];

            InsGetString(IS_BRANDING, IK_GPE_ADM_GUID, szAdmGuid, countof(szAdmGuid), g_GetIns());
            PathCombine(szKey, RK_IEAK_GPOS, g_GetGPOGuid());
            PathAppend(szKey, RK_IEAK_ADM);
            PathAppend(szKey, szAdmGuid);
            PathAppend(szKey, g_CtxIs(CTX_MISC_CHILDPROCESS) ? IS_EXTREGINF_HKCU : IS_EXTREGINF_HKLM);
            if (SHKeyExists(g_GetHKCU(), szKey) == S_OK)
                return S_FALSE;
        }
    }

    return S_OK;
}

static HRESULT eriPostHook(LPCTSTR pszInf, LPCTSTR pszSection, LPARAM lParam /*= NULL*/)
{
    UNREFERENCED_PARAMETER(pszSection);

    LPCTSTR pszInfName;
    HRESULT hr;

    ASSERT(PathFileExists(pszInf) && pszSection != NULL && *pszSection != TEXT('\0'));
    pszInfName = PathFindFileName(pszInf);
    hr         = S_OK;

    if (0 == StrCmpI(pszInfName, TEXT("ratings.inf")))
    {
        hr = ProcessRatingsPol();
        if (SUCCEEDED(hr))
            SetFeatureBranded(FID_RATINGS);
    }
    else if (0 == StrCmpI(pszInfName, TEXT("seczones.inf")))
    {
        ASSERT(lParam != NULL);
        if (PathIsExtension((LPCTSTR)lParam, TEXT(".Hklm")))
            SetFeatureBranded(FID_ZONES_HKLM);
        else if (PathIsExtension((LPCTSTR)lParam, TEXT(".Hkcu")))
            SetFeatureBranded(FID_ZONES_HKCU);
    }
    else if (0 == StrCmpI(pszInfName, TEXT("authcode.inf")))
        SetFeatureBranded(FID_AUTHCODE);

    else if (0 == StrCmpI(pszInfName, TEXT("programs.inf")))
        SetFeatureBranded(FID_PROGRAMS);

    return hr;
}

// Removes links for the specified Target file from the specified Links path
static HRESULT deleteLinks(LPCTSTR pcszTarget, DWORD dwFolders)
{   MACRO_LI_PrologEx_C(PIF_STD_C, deleteLinks)

    HRESULT hr = S_OK;
    IShellLinkW* pShellLinkW = NULL;
    IShellLinkA* pShellLinkA = NULL;
    IPersistFile* pPersistFile = NULL;
    BOOL fUnicode = TRUE;
    LINKINFO linkInfo;

    if (pcszTarget == NULL || *pcszTarget == TEXT('\0') || dwFolders == 0)
        return E_INVALIDARG;

    // get the interfaces we need for cracking open shortcuts
    // Get a pointer to the IPersistFile interface.
    hr = CoCreateInstance(CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER, IID_IPersistFile, (LPVOID *)&pPersistFile);
    if (FAILED(hr))
    {
        Out(LI1(TEXT("! Internal Error : %s."), GetHrSz(hr)));
        goto Exit;
    }

    // Get a pointer to the IShellLink interface
    hr = pPersistFile->QueryInterface(IID_IShellLinkW, (void**)&pShellLinkW);
    if (FAILED(hr))
    {
        fUnicode = FALSE;

        hr = pPersistFile->QueryInterface(IID_IShellLinkA, (void**)&pShellLinkA);
        if (FAILED(hr))
        {
            Out(LI1(TEXT("! Internal Error : %s."), GetHrSz(hr)));
            goto Exit;
        }
    }

    StrCpy(linkInfo.szTarget, pcszTarget);
    linkInfo.pPersistFile = pPersistFile;
    linkInfo.fUnicode = fUnicode;

    if (fUnicode)
        linkInfo.pShellLinkW = pShellLinkW;
    else
        linkInfo.pShellLinkA = pShellLinkA;

    if (HasFlag(dwFolders, DESKTOP_FOLDER))
        deleteLink(DESKTOP_FOLDER, &linkInfo);
    if (HasFlag(dwFolders, PROGRAMS_FOLDER))
        deleteLink(PROGRAMS_FOLDER, &linkInfo);
    if (HasFlag(dwFolders, QUICKLAUNCH_FOLDER))
        deleteLink(QUICKLAUNCH_FOLDER, &linkInfo);
    if (HasFlag(dwFolders, PROGRAMS_IE_FOLDER))
        deleteLink(PROGRAMS_IE_FOLDER, &linkInfo);
        
Exit:
    if (pPersistFile != NULL)
        pPersistFile->Release();

    if (pShellLinkW != NULL)
        pShellLinkW->Release();

    if (pShellLinkA != NULL)
        pShellLinkA->Release();

    return hr;
}

static void deleteLink(DWORD dwFolder, PLINKINFO pLinkInfo)
{   MACRO_LI_PrologEx_C(PIF_STD_C, deleteLink)

    HRESULT         hr = S_OK;
    int             nFolder;
    TCHAR           szPath[MAX_PATH];

    if (pLinkInfo == NULL || *(pLinkInfo->szTarget) == TEXT('\0'))
        return;

    if (dwFolder == QUICKLAUNCH_FOLDER)
        GetQuickLaunchPath(szPath, countof(szPath));        
    else
    {
        if (dwFolder == DESKTOP_FOLDER)
            nFolder = CSIDL_DESKTOPDIRECTORY;
        else if (dwFolder == PROGRAMS_FOLDER || dwFolder == PROGRAMS_IE_FOLDER)
            nFolder = CSIDL_PROGRAMS;
        else
            return;

        hr = SHGetFolderPathSimple(nFolder, szPath);
        if (FAILED(hr))
        {
            Out(LI2(TEXT("! SHGetFolderPath for Link %d failed with %s"), dwFolder, GetHrSz(hr)));
            return;
        }

        if (dwFolder == PROGRAMS_IE_FOLDER)
            PathAppend(szPath, TEXT("Internet Explorer"));
    }
    
    ASSERT(szPath[0] != TEXT('\0'));
    
    PathEnumeratePath(szPath, PEP_SCPE_NOFOLDERS, pepDeleteLinksEnumProc, (LPARAM)pLinkInfo);
}

HRESULT pepDeleteLinksEnumProc(LPCTSTR pszPath, PWIN32_FIND_DATA pfd, LPARAM lParam, PDWORD *prgdwControl /*= NULL*/)
{
    PLINKINFO pLinkInfo = (PLINKINFO) lParam;
    BOOL fDelete = FALSE;

    USES_CONVERSION;
    
    UNREFERENCED_PARAMETER(prgdwControl);

    if (pLinkInfo == NULL || pLinkInfo->pPersistFile == NULL)
        return E_INVALIDARG;

    if (pLinkInfo->fUnicode)
    {
        WCHAR wszTarget[MAX_PATH];
        WIN32_FIND_DATAW fdW;

        if (pLinkInfo->pShellLinkW == NULL)
            return E_INVALIDARG;

        fdW.dwFileAttributes = pfd->dwFileAttributes;
        fdW.ftCreationTime   = pfd->ftCreationTime;
        fdW.ftLastAccessTime = pfd->ftLastAccessTime;
        fdW.ftLastWriteTime  = pfd->ftLastWriteTime;
        fdW.nFileSizeHigh    = pfd->nFileSizeHigh;
        fdW.nFileSizeLow     = pfd->nFileSizeLow;
        fdW.dwReserved0      = pfd->dwReserved0;
        fdW.dwReserved1      = pfd->dwReserved1;
        T2Wbuf(pfd->cFileName, fdW.cFileName, countof(fdW.cFileName));
        T2Wbuf(pfd->cAlternateFileName, fdW.cAlternateFileName, countof(fdW.cAlternateFileName));

        // Load the shell link and get the path to the link target.
        if (SUCCEEDED(pLinkInfo->pPersistFile->Load(pszPath, STGM_READ)) &&
            SUCCEEDED(pLinkInfo->pShellLinkW->GetPath(wszTarget, MAX_PATH, &fdW, SLGP_SHORTPATH)))
        {
            if (StrCmpIW(fdW.cFileName, T2W(pLinkInfo->szTarget)) == 0)
                fDelete = TRUE;
        }
    }
    else
    {
        CHAR aszTarget[MAX_PATH];
        WIN32_FIND_DATAA fdA;

        if (pLinkInfo->pShellLinkA == NULL)
            return E_INVALIDARG;

        fdA.dwFileAttributes = pfd->dwFileAttributes;
        fdA.ftCreationTime   = pfd->ftCreationTime;
        fdA.ftLastAccessTime = pfd->ftLastAccessTime;
        fdA.ftLastWriteTime  = pfd->ftLastWriteTime;
        fdA.nFileSizeHigh    = pfd->nFileSizeHigh;
        fdA.nFileSizeLow     = pfd->nFileSizeLow;
        fdA.dwReserved0      = pfd->dwReserved0;
        fdA.dwReserved1      = pfd->dwReserved1;
        T2Abuf(pfd->cFileName, fdA.cFileName, countof(fdA.cFileName));
        T2Abuf(pfd->cAlternateFileName, fdA.cAlternateFileName, countof(fdA.cAlternateFileName));

        // Load the shell link and get the path to the link target.
        if (SUCCEEDED(pLinkInfo->pPersistFile->Load(pszPath, STGM_READ)) &&
            SUCCEEDED(pLinkInfo->pShellLinkA->GetPath(aszTarget, MAX_PATH, &fdA, SLGP_SHORTPATH)))
        {
            if (StrCmpIA(fdA.cFileName, T2A(pLinkInfo->szTarget)) == 0)
                fDelete = TRUE;
        }
    }

    // also delete if the filename and the target name match (this case is for files that are not link files.. ex: .scf)
    if (fDelete || StrCmpI(pfd->cFileName, pLinkInfo->szTarget) == 0)
    {
        Out(LI1(TEXT("Deleting Link File: %s"), pszPath));

        SetFileAttributes(pszPath, FILE_ATTRIBUTE_NORMAL);
        DeleteFile(pszPath);
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\brandll\brand.h ===
#ifndef _BRAND_H_
#define _BRAND_H_

// brand.cpp
HRESULT ProcessAutoconfigDownload();
HRESULT ProcessIcwDownload();

HRESULT ProcessClearBranding();
HRESULT ProcessMigrateOldSettings();
HRESULT ProcessExtRegInfSectionHKLM();
HRESULT ProcessExtRegInfSectionHKCU();
HRESULT lcy50_ProcessExtRegInfSection();
HRESULT ProcessGeneral();
HRESULT ProcessCustomHelpVersion();
HRESULT ProcessToolbarButtons();
HRESULT ProcessRootCert();
HRESULT ProcessActiveSetupSites();
HRESULT ProcessLinksDeletion();
HRESULT ProcessOutlookExpress();

void ProcessDeleteToolbarButtons(BOOL fGPOCleanup);

// brandfav.cpp
HRESULT ProcessFavoritesDeletion();
HRESULT ProcessFavorites();
HRESULT ProcessFavoritesOrdering();
HRESULT ProcessQuickLinks();
HRESULT ProcessQuickLinksOrdering();
#define FSWP_KEY       0x00000001
#define FSWP_VALUE     0x00000002
#define FSWP_KEYLDID   0x00000010
#define FSWP_VALUELDID 0x00000020
#define FSWP_DEFAULT   (FSWP_KEY | FSWP_VALUE | FSWP_VALUELDID)
HRESULT formStrWithoutPlaceholders(LPCTSTR pszSection, LPCTSTR pszKey, LPCTSTR pszIns,
    LPTSTR pszBuffer, UINT cchBuffer, DWORD dwFlags = FSWP_DEFAULT);


//brandbar.cpp
HRESULT ProcessExplorerBars();

// brandcs.cpp
HRESULT ProcessWininetSetup();
HRESULT ProcessConnectionSettingsDeletion();
HRESULT ProcessConnectionSettings();
HRESULT lcy50_ProcessConnectionSettings();

// brandaux.cpp
HRESULT ProcessZonesReset();
HRESULT ProcessRatingsPol();
HRESULT ProcessTrustedPublisherLockdown();
HRESULT ProcessCDWelcome();
HRESULT ProcessBrowserRefresh();

// brandchl.cpp
HRESULT lcy4x_ProcessChannels();
HRESULT lcy4x_ProcessSoftwareUpdateChannels();
HRESULT lcy4x_ProcessWebcheck();
HRESULT lcy4x_ProcessChannelBar();
HRESULT lcy4x_ProcessSubscriptions();

void ProcessRemoveAllChannels(BOOL fGPOCleanup);

// brandad4.cpp
HRESULT lcy4x_ProcessActiveDesktop();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\brandll\brandchl.cpp ===
#include "precomp.h"
#include <chanmgr.h>
#include <intshcut.h>                           // for IUniformResourceLocator only

// Private forward decalarations
WORD s_rgwSubGroupIDs[] = {
    0, IDS_SCHED_AUTO, IDS_SCHED_DAILY, IDS_SCHED_WEEKLY, IDS_SCHED_MONTHLY
};

#define CHLBAR_GUID TEXT("131A6951-7F78-11D0-A979-00C04FD705A2")

#ifndef SAFERELEASE
#define SAFERELEASE(p) if ((p) != NULL) { (p)->Release(); (p) = NULL; } else
#endif

// private forward declarations

static HRESULT pepDeleteChanEnumProc(LPCTSTR pszPath, PWIN32_FIND_DATA pfd, LPARAM lParam, PDWORD *prgdwControl /*= NULL */);
static void processAddChannel(LPWSTR pwszTitle, LPWSTR pwszUrl, LPWSTR pwszPreloadUrl, 
                              LPWSTR pwszLogo, LPWSTR pwszWideLogo, LPWSTR pwszIcon, 
                              BOOL fOffline, BOOL fCategory);

void ProcessRemoveAllChannels(BOOL fGPOCleanup)
{
    TCHAR szChannelFolder[MAX_PATH];

    USES_CONVERSION;

    GetChannelsPath(szChannelFolder, countof(szChannelFolder));
    
    // BUGBUG: <oliverl> we really should preserve the desktop.ini in the channels folder here
    //         however webcheck never did and we don't want the code churn right now

    if (ISNONNULL(szChannelFolder) && !fGPOCleanup)
        PathRemovePath(szChannelFolder, ADN_DONT_DEL_DIR);
    else
    {
        if (ISNULL(szChannelFolder))
            GetFavoritesPath(szChannelFolder, countof(szChannelFolder));
        
        if (ISNONNULL(szChannelFolder))
            PathEnumeratePath(szChannelFolder, PEP_SCPE_NOFILES, pepDeleteChanEnumProc, (LPARAM)fGPOCleanup);
    }
}

// Channels the whole mess, can be one of the following:
// one channel, or category with many channels, or many channels, or many categories and channels
HRESULT lcy4x_ProcessChannels()
{   MACRO_LI_PrologEx_C(PIF_STD_C, lcy4x_ProcessChannels)

    TCHAR   szUrl[INTERNET_MAX_URL_LENGTH],
            szBuf[MAX_PATH + countof(FILEPREFIX)],
            szLogo[MAX_PATH + countof(FILEPREFIX)],
            szWideLogo[MAX_PATH + countof(FILEPREFIX)],
            szIcon[MAX_PATH + countof(FILEPREFIX)],
            szPreloadUrl[MAX_PATH + countof(FILEPREFIX)],
            szTitle[MAX_PATH],
            szEntry[32],
            szIndex[17],
            szCustomKey[16];
    LPCTSTR pszWebPath,
            pszPrefix, pszFormat,
            pszFileName;
    LPTSTR  pszTitle;
    HKEY    hk;
    HRESULT hr;
    DWORD   dwVal;
    LONG    lResult;
    UINT    nCategoryLen,
            nTitleLen, nUrlLen, nLen;
    int     i,
            iMode;
    BOOL    fCategory, 
            fOffline = FALSE;

    USES_CONVERSION;

    CreateWebFolder();
    GetPrivateProfileString(IS_BRANDING, IK_CUSTOMKEY, TEXT(""), szCustomKey, countof(szCustomKey), g_GetIns());

    // BUGBUG: (andrewgu) Is this needed at all?
    wnsprintf(szEntry, countof(szEntry), TEXT("Channel%s"), szCustomKey);
    SHDeleteValue(g_GetHKCU(), RK_COMPLETED_MODIFICATIONS, szEntry);

    if (InsGetBool(IS_DESKTOPOBJS, IK_DELETECHANNELS, FALSE, g_GetIns())) 
    {
       Out(LI0(TEXT("Deleting regular old channels...\r\n")));
       ProcessRemoveAllChannels(FALSE);
    }

    pszWebPath = GetWebPath();

    hr    = S_OK;
    dwVal = 1;

    fCategory    = InsGetBool(IS_CHANNEL_ADD, IK_CATEGORY, FALSE, g_GetIns());
    pszTitle     = szTitle;
    nCategoryLen = 0;
    if (fCategory) {
        nCategoryLen = GetPrivateProfileString(IS_CHANNEL_ADD, IK_CAT_TITLE, TEXT(""), szTitle, sizeof(szTitle), g_GetIns());
        ASSERT(nCategoryLen > 0);

        PathAddBackslash(szTitle);
        pszTitle = &szTitle[++nCategoryLen];
    }

    //----- Initialize the mode -----
    // NOTE: (andrewgu) These are the possible modes:
    // 0 - not clear or has not been determined yet;
    // 1 - there will be only one channel (no channel tag indeces);
    // 2 - there will be one category (no category indeces) and mulitple channels;
    // 3 - interim state to process the single category, mentioned in mode 2.
    // 4 - (new) mulitple channels with or without categories;
    // 5 - (new) mulitple categories, processed after all channels in mode 4.

    iMode = 0;
    if (fCategory) {
        iMode = 2;

#ifdef _DEBUG                                   // confirm the mode
        StrCpy(szEntry, IK_CHL_TITLE); StrCpy(&szEntry[countof(IK_CHL_TITLE) - 1], TEXT("0"));
        ASSERT(!InsIsKeyEmpty(IS_CHANNEL_ADD, szEntry, g_GetIns()));
#endif
    }
    else /* if (!fCategory) */
        if (!InsIsKeyEmpty(IS_CHANNEL_ADD, IK_CHL_TITLE, g_GetIns()))
            iMode = 1;

        else { /* if (blah == 0) */
            StrCpy(szEntry, IK_CHL_TITLE); StrCpy(&szEntry[countof(IK_CHL_TITLE) - 1], TEXT("0"));
            if (InsIsKeyEmpty(IS_CHANNEL_ADD, szEntry, g_GetIns())) {
                Out(LI0(TEXT("There are no channels to add!")));
                goto Exit;                      // there are no channels at all
            }

            iMode = 4;
        }
    Out(LI1(TEXT("Initial processing mode is %i."), iMode));

    //----- Channel bar size processing -----
    // NOTE: (andrewgu) the following block is a fix for bug 63410 in IE 4.01 db.
    DWORD dwChannelBarSize,
          dwSize;

    lResult = SHCreateKey(g_GetHKCU(), RK_IE_DESKTOP, KEY_QUERY_VALUE | KEY_SET_VALUE, &hk);
    if (lResult == ERROR_SUCCESS) {
        dwChannelBarSize = 13;                  // if registry call fails
        dwSize = sizeof(dwChannelBarSize);
        RegQueryValueEx(hk, RV_CHLBAR_SIZE, NULL, NULL, (LPBYTE)&dwChannelBarSize, &dwSize);

        dwChannelBarSize++;
        RegSetValueEx(hk, RV_CHLBAR_SIZE, 0, REG_DWORD, (LPBYTE)&dwChannelBarSize, dwSize);
        SHCloseKey(hk);
    }

    //----- Main processing loop -----
    for (i = 0; i < MAX_CHAN; i++) 
    {
        ASSERT(iMode > 0);
        if (iMode == 1) {
            szIndex[0] = TEXT('\0');

            if (i > 0)
                break;                          // only one channel is allowed
        }
        else if (iMode == 2) {
            wnsprintf(szIndex, countof(szIndex), TEXT("%u"), i);

            StrCpy(szEntry, IK_CHL_TITLE); StrCpy(&szEntry[countof(IK_CHL_TITLE) - 1], szIndex);
            if (InsIsKeyEmpty(IS_CHANNEL_ADD, szEntry, g_GetIns())) {
                iMode = 3;
                szIndex[0] = TEXT('\0');
            }
        }
        else if (iMode == 3)
            break;                              // there can be only one category

        else if (iMode == 4) {
            wnsprintf(szIndex, countof(szIndex), TEXT("%u"), i);

            StrCpy(szEntry, IK_CHL_TITLE); StrCpy(&szEntry[countof(IK_CHL_TITLE) - 1], szIndex);
            if (InsIsKeyEmpty(IS_CHANNEL_ADD, szEntry, g_GetIns())) {
                iMode =  5;
                i     = -1;
                continue;
            }

        }
        else if (iMode == 5) {
            wnsprintf(szIndex, countof(szIndex), TEXT("%u"), i);

            StrCpy(szEntry, IK_CAT_TITLE); StrCpy(&szEntry[countof(IK_CAT_TITLE) - 1], szIndex);
            if (InsIsKeyEmpty(IS_CHANNEL_ADD, szEntry, g_GetIns()))
                break;                          // the end
        }

        MACRO_LI_Offset(1);
        Out(LI1(TEXT("\r\nMain processing loop with mode %d."), iMode));

        // Note. This is kind of hacky, but mode 5. is the only one when index in the *.ins is not
        // equal to the index that will be used in the registry.
        if (iMode == 5)
            wnsprintf(szIndex, countof(szIndex), TEXT("%u"), i + MAX_CHAN);
        if (iMode == 5)
            wnsprintf(szIndex, countof(szIndex), TEXT("%u"), i);

        if (iMode == 1 || iMode == 2 || iMode == 4) 
        {
            Out(LI0(TEXT("Adding channel with the following attributes:")));
            pszPrefix = FILEPREFIX;
        }
        else {
            ASSERT(iMode == 3 || iMode == 5);
            Out(LI0(TEXT("Adding category with the following attributes:")));
            pszPrefix = NULL;
        }

        { MACRO_LI_Offset(1);                   // need a new scope

        // Title
        pszFormat = NULL;
        nLen      = 0;

        if (iMode == 1 || iMode == 2 || iMode == 4) {
            pszFormat = IK_CHL_TITLE;
            nLen      = countof(IK_CHL_TITLE) - 1;
        }
        else if (iMode == 5) {
            pszFormat = IK_CAT_TITLE;
            nLen      = countof(IK_CAT_TITLE) - 1;
        }
        else
            ASSERT(iMode == 3);

        if (iMode != 3) 
        {
            StrCpy(szEntry, pszFormat); StrCpy(&szEntry[nLen], szIndex);
            nLen       = MAX_PATH - (fCategory ? nCategoryLen + 1: 0);
            nTitleLen  = GetPrivateProfileString(IS_CHANNEL_ADD, szEntry, TEXT(""), pszTitle, nLen, g_GetIns());
            nTitleLen += fCategory ? nCategoryLen + 1 : 0;
        }
        else { /* if (iMode == 3) */
            ASSERT(fCategory);

            pszTitle  = szTitle;                  // change to category name
            szTitle[--nCategoryLen] = TEXT('\0'); // properly zero-terminate
            nTitleLen = nCategoryLen;
        }
        Out(LI1(TEXT("Title          - \"%s\","), pszTitle));

        // URL
        if (iMode == 1 || iMode == 2 || iMode == 4) 
        {
            pszFormat = IK_CHL_URL;
            nLen      = countof(IK_CHL_URL) - 1;
        }
        else 
        { /* if (iMode == 3 || iMode == 5) */
            pszFormat = IK_CAT_URL;
            nLen      = countof(IK_CAT_URL) - 1;
        }

        StrCpy(szEntry, pszFormat); StrCpy(&szEntry[nLen], szIndex);
        nUrlLen = GetPrivateProfileString(IS_CHANNEL_ADD, szEntry, TEXT(""), szUrl, countof(szUrl), g_GetIns());
        if (iMode == 3 || iMode == 5) 
        {
            ASSERT(nUrlLen > 0 && nUrlLen < MAX_PATH);
            pszFileName = PathFindFileName(szUrl);
           
            PathCombine(szBuf, pszWebPath, pszFileName);
            ASSERT(PathFileExists(szBuf));

            StrCpy(szUrl, szBuf);
            nUrlLen = StrLen(szUrl);
        }
        Out(LI1(TEXT("URL            - \"%s\","), szUrl));

        // Preload URL
        *szPreloadUrl = TEXT('\0');
        if (iMode == 1 || iMode == 2 || iMode == 4) 
        {
            StrCpy(szEntry, IK_CHL_PRELOADURL); StrCpy(&szEntry[countof(IK_CHL_PRELOADURL) - 1], szIndex);
            nLen = GetPrivateProfileString(IS_CHANNEL_ADD, szEntry, TEXT(""), szBuf, countof(szBuf), g_GetIns());
            if (nLen > 0) {
                pszFileName = PathFindFileName(szBuf);

                PathCombine(szPreloadUrl, pszWebPath, pszFileName);
                ASSERT(PathFileExists(szPreloadUrl));

                nLen = StrPrepend(szPreloadUrl, countof(szPreloadUrl), pszPrefix);
                Out(LI1(TEXT("Preload URL    - \"%s\","), szPreloadUrl));
            }
            else
                Out(LI0(TEXT("- Without a Preload URL,")));
        }

        // Logo
        *szLogo = TEXT('\0');
        if (iMode == 1 || iMode == 2 || iMode == 4) 
        {
            pszFormat = IK_CHL_LOGO;
            nLen      = countof(IK_CHL_LOGO) - 1;
        }
        else 
        { /* if (iMode == 3 || iMode == 5) */
            pszFormat = IK_CAT_LOGO;
            nLen      = countof(IK_CAT_LOGO) - 1;
        }

        StrCpy(szEntry, pszFormat); StrCpy(&szEntry[nLen], szIndex);
        nLen = GetPrivateProfileString(IS_CHANNEL_ADD, szEntry, TEXT(""), szBuf, countof(szBuf), g_GetIns());
        if (nLen > 0) 
        {
            pszFileName = PathFindFileName(szBuf);
            
            PathCombine(szLogo, pszWebPath, pszFileName);
            ASSERT(PathFileExists(szLogo));

            nLen = StrPrepend(szLogo, countof(szLogo), pszPrefix);
            Out(LI1(TEXT("Logo file      - \"%s\","), szLogo));
        }
        else
            Out(LI0(TEXT("- Without a Logo file,")));

        // Wide Logo
        *szWideLogo = TEXT('\0');
        if (iMode == 1 || iMode == 2 || iMode == 4)
        {
            pszFormat = IK_CHL_WIDELOGO;
            nLen      = countof(IK_CHL_WIDELOGO) - 1;
        }
        else 
        { /* if (iMode == 3 || iMode == 5) */
            pszFormat = IK_CAT_WIDELOGO;
            nLen      = countof(IK_CAT_WIDELOGO) - 1;
        }

        StrCpy(szEntry, pszFormat); StrCpy(&szEntry[nLen], szIndex);
        nLen = GetPrivateProfileString(IS_CHANNEL_ADD, szEntry, TEXT(""), szBuf, countof(szBuf), g_GetIns());
        if (nLen > 0) 
        {
            pszFileName = PathFindFileName(szBuf);

            PathCombine(szWideLogo, pszWebPath, pszFileName);
            ASSERT(PathFileExists(szWideLogo));

            nLen = StrPrepend(szWideLogo, countof(szWideLogo), pszPrefix);
            Out(LI1(TEXT("Wide Logo file - \"%s\","), szWideLogo));
        }
        else
            Out(LI0(TEXT("- Without a Wide Logo file,")));

        // Icon
        *szIcon = TEXT('\0');
        if (iMode == 1 || iMode == 2 || iMode == 4) 
        {
            pszFormat = IK_CHL_ICON;
            nLen      = countof(IK_CHL_ICON) - 1;
        }
        else 
        { /* if (iMode == 3 || iMode == 5) */
            pszFormat = IK_CAT_ICON;
            nLen      = countof(IK_CAT_ICON) - 1;
        }

        StrCpy(szEntry, pszFormat); StrCpy(&szEntry[nLen], szIndex);
        nLen = GetPrivateProfileString(IS_CHANNEL_ADD, szEntry, TEXT(""), szBuf, countof(szBuf), g_GetIns());
        if (nLen > 0) 
        {
            pszFileName = PathFindFileName(szBuf);

            PathCombine(szIcon, pszWebPath, pszFileName);
            ASSERT(PathFileExists(szIcon));

            nLen = StrPrepend(szIcon, countof(szIcon), pszPrefix);

            if (iMode == 1 || iMode == 2 || iMode == 4)
                Out(LI1(TEXT("Icon file      - \"%s\","), szIcon));
            else /* if (iMode == 3 || iMode == 5) */
                Out(LI1(TEXT("Icon file      - \"%s\"."), szIcon));
        }
        else
            if (iMode == 1 || iMode == 2 || iMode == 4)
                Out(LI0(TEXT("- Without an Icon file,")));
            else /* if (iMode == 3 || iMode == 5) */
                Out(LI0(TEXT("- Without an Icon file.")));

        // Make available offline flag (will be made available offline right away)
        if (iMode == 1 || iMode == 2 || iMode == 4) 
        {
            StrCpy(szEntry, IK_CHL_OFFLINE); StrCpy(&szEntry[countof(IK_CHL_OFFLINE) - 1], szIndex);

            fOffline = InsGetBool(IS_CHANNEL_ADD, szEntry, FALSE, g_GetIns());
            if (fOffline) 
                Out(LI0(TEXT("Avaliable offline.")));
            else
                Out(LI0(TEXT("NOT made avaliable offline.")));
        }

        // Subscription state(this is only for legacy IE4 format)

        if (iMode == 1 || iMode == 2 || iMode == 4) {
            int iIndex;

            iIndex = GetPrivateProfileInt(IS_CHANNEL_ADD, IK_CHL_SBN_INDEX, 0, g_GetIns());
            if (iIndex > 0) {
                TCHAR szGroup[80];
                TCHAR szKey[MAX_PATH];
                HKEY  hkSbn;

                nLen = LoadString(g_GetHinst(), s_rgwSubGroupIDs[iIndex], szGroup, countof(szGroup));
                wnsprintf(szKey, countof(szKey), RK_SUBSCRIPTION_ADD, szCustomKey, szIndex);

                lResult = SHCreateKey(g_GetHKCU(), szKey, KEY_SET_VALUE, &hkSbn);
                if (lResult == ERROR_SUCCESS) {
                    RegSetValueEx(hkSbn, RV_URL,              0, REG_SZ,    (LPBYTE)szUrl,   StrCbFromCch(nUrlLen+1));
                    RegSetValueEx(hkSbn, RV_TITLE,            0, REG_SZ,    (LPBYTE)szTitle, StrCbFromCch(nTitleLen+1));
                    RegSetValueEx(hkSbn, RV_SUBSCRIPTIONTYPE, 0, REG_DWORD, (LPBYTE)&dwVal,  sizeof(dwVal));
                    RegSetValueEx(hkSbn, RV_SCHEDULEGROUP,    0, REG_SZ,    (LPBYTE)szGroup, StrCbFromCch(nLen+1));
                    SHCloseKey(hkSbn);

                    Out(LI1(TEXT("Subscription is based on \"%s\" schedule..."), szGroup));
                }
            }
        }

        // add this channel/category

        processAddChannel(T2W(pszTitle), T2W(szUrl), T2W(szPreloadUrl), T2W(szLogo), 
            T2W(szWideLogo), T2W(szIcon), fOffline, !(iMode == 1 || iMode == 2 || iMode == 4));
        

        }  // end offset scope

        Out(LI0(TEXT("Done.")));
    }

Exit:
    if (SUCCEEDED(hr))
        SetFeatureBranded(FID_LCY4X_CHANNELS);
    return hr;
}

HRESULT lcy4x_ProcessSoftwareUpdateChannels()
{   MACRO_LI_PrologEx_C(PIF_STD_C, lcy4x_ProcessSoftwareUpdateChannels)

    TCHAR   szUrl[INTERNET_MAX_URL_LENGTH],
            szBuf[MAX_PATH + countof(FILEPREFIX)],
            szSourceFile[MAX_PATH + countof(FILEPREFIX)], szTargetFile[MAX_PATH + countof(FILEPREFIX)],
            szKey[MAX_PATH],
            szTitle[MAX_PATH],
            szEntry[32],
            szIndex[17],
            szCustomKey[16];
    LPCTSTR pszTargetPath,
            pszWebPath,
            pszFileName;
    HKEY    hk;
    HRESULT hr;
    DWORD   dwVal;
    LONG    lResult;
    UINT    nTitleLen, nUrlLen, nLen;
    int     i, iNumChannels,
            iIndex;

    CreateWebFolder();

    pszTargetPath = g_GetTargetPath();
    pszWebPath    = GetWebPath();
    GetPrivateProfileString(IS_BRANDING, IK_CUSTOMKEY, TEXT(""), szCustomKey, countof(szCustomKey), g_GetIns());

    hr = S_OK;

    if (InsGetBool(IS_SOFTWAREUPDATES, IK_DELETECHANNELS, FALSE, g_GetIns())) {
        wnsprintf(szKey, countof(szKey), RK_CHANNEL_DEL TEXT("\\IEAKCleanUp"), szCustomKey);
        dwVal = 1;
        SHSetValue(g_GetHKCU(), szKey, RV_CHANNELGUIDE, REG_DWORD, (LPBYTE)&dwVal, sizeof(dwVal));
        Out(LI0(TEXT("Deleting old software updates channels...\r\n")));
    }

    dwVal = 0;
    iNumChannels = GetPrivateProfileInt(IS_SOFTWAREUPDATES, IK_NUMFILES, 0, g_GetIns());
    for (i = 0; i < iNumChannels; i++) {
        MACRO_LI_Offset(1);
        if (i > 0)
            Out(LI0(TEXT("\r\n")));
        Out(LI0(TEXT("Adding software update channel with the following attributes:")));

        // Note. Needed to make sure that channels and software updates don't step on each other toes.
        wnsprintf(szIndex, countof(szIndex), TEXT("%u"), i + 2*MAX_CHAN);
        wnsprintf(szKey, countof(szKey), RK_CHANNEL_ADD, szCustomKey, szIndex);

        lResult = SHCreateKey(g_GetHKCU(), szKey, KEY_SET_VALUE, &hk);
        if (lResult != ERROR_SUCCESS) {
            hr = S_FALSE;                       // at least one failed
            continue;
        }

        // Title
        wnsprintf(szEntry, countof(szEntry), IK_TITLE_FMT, i);
        nTitleLen = GetPrivateProfileString(IS_SOFTWAREUPDATES, szEntry, TEXT(""), szTitle, countof(szTitle), g_GetIns());
        RegSetValueEx(hk, RV_TITLE, 0, REG_SZ, (LPBYTE)szTitle, StrCbFromCch(nTitleLen+1));
        Out(LI1(TEXT("Title          - \"%s\","), szTitle));

        // URL
        wnsprintf(szEntry, countof(szEntry), IK_URL_FMT, i);
        nUrlLen = GetPrivateProfileString(IS_SOFTWAREUPDATES, szEntry, TEXT(""), szUrl, countof(szUrl), g_GetIns());
        RegSetValueEx(hk, RV_URL, 0, REG_SZ, (LPBYTE)szUrl, StrCbFromCch(nUrlLen+1));
        Out(LI1(TEXT("URL            - \"%s\","), szUrl));

        // Preload URL
        wnsprintf(szEntry, countof(szEntry), IK_PRELOADURL_FMT, i);
        nLen = GetPrivateProfileString(IS_SOFTWAREUPDATES, szEntry, TEXT(""), szBuf, countof(szBuf), g_GetIns());
        if (nLen > 0) {
            pszFileName = PathFindFileName(szBuf);
            PathCombine(szSourceFile, pszTargetPath, pszFileName);
            ASSERT(PathFileExists(szSourceFile));

            PathCombine(szTargetFile, pszWebPath, pszFileName);
            ASSERT(!PathFileExists(szTargetFile));

            MoveFile(szSourceFile, szTargetFile);
            nLen = StrPrepend(szTargetFile, countof(szTargetFile), FILEPREFIX);
            RegSetValueEx(hk, RV_PRELOADURL, 0, REG_SZ, (LPBYTE)szTargetFile, StrCbFromCch(nLen+1));
            Out(LI1(TEXT("Preload URL    - \"%s\","), szTargetFile));
        }
        else
            Out(LI0(TEXT("- Without a Preload URL,")));

        // Logo
        wnsprintf(szEntry, countof(szEntry), IK_LOGO_FMT, i);
        nLen = GetPrivateProfileString(IS_SOFTWAREUPDATES, szEntry, TEXT(""), szBuf, countof(szBuf), g_GetIns());
        if (nLen > 0) {
            pszFileName = PathFindFileName(szBuf);
            PathCombine(szSourceFile, pszTargetPath, pszFileName);
            ASSERT(PathFileExists(szSourceFile));

            PathCombine(szTargetFile, pszWebPath, pszFileName);
            ASSERT(!PathFileExists(szTargetFile));

            MoveFile(szSourceFile, szTargetFile);
            nLen = StrPrepend(szTargetFile, countof(szTargetFile), FILEPREFIX);
            RegSetValueEx(hk, RV_LOGO, 0, REG_SZ, (LPBYTE)szTargetFile, StrCbFromCch(nLen+1));
            Out(LI1(TEXT("Logo file      - \"%s\","), szTargetFile));
        }
        else
            Out(LI0(TEXT("- Without a Logo file,")));

        // Wide Logo
        wnsprintf(szEntry, countof(szEntry), IK_WIDELOGO_FMT, i);
        nLen = GetPrivateProfileString(IS_SOFTWAREUPDATES, szEntry, TEXT(""), szBuf, countof(szBuf), g_GetIns());
        if (nLen > 0) {
            pszFileName = PathFindFileName(szBuf);
            PathCombine(szSourceFile, pszTargetPath, pszFileName);
            ASSERT(PathFileExists(szSourceFile));

            PathCombine(szTargetFile, pszWebPath, pszFileName);
            ASSERT(!PathFileExists(szTargetFile));

            MoveFile(szSourceFile, szTargetFile);
            nLen = StrPrepend(szTargetFile, countof(szTargetFile), FILEPREFIX);
            RegSetValueEx(hk, RV_LOGO, 0, REG_SZ, (LPBYTE)szTargetFile, StrCbFromCch(nLen+1));
            Out(LI1(TEXT("Wide Logo file - \"%s\","), szTargetFile));
        }
        else
            Out(LI0(TEXT("- Without a Wide Logo file,")));

        // Icon
        wnsprintf(szEntry, countof(szEntry), IK_ICON_FMT, i);
        nLen = GetPrivateProfileString(IS_SOFTWAREUPDATES, szEntry, TEXT(""), szBuf, countof(szBuf), g_GetIns());
        if (nLen > 0) {
            pszFileName = PathFindFileName(szBuf);
            PathCombine(szSourceFile, pszTargetPath, pszFileName);
            ASSERT(PathFileExists(szSourceFile));

            PathCombine(szTargetFile, pszWebPath, pszFileName);
            ASSERT(!PathFileExists(szTargetFile));

            MoveFile(szSourceFile, szTargetFile);
            nLen = StrPrepend(szTargetFile, countof(szTargetFile), FILEPREFIX);
            RegSetValueEx(hk, RV_ICON, 0, REG_SZ, (LPBYTE)szTargetFile, StrCbFromCch(nLen+1));
            Out(LI1(TEXT("Icon file      - \"%s\"."), szTargetFile));
        }
        else
            Out(LI0(TEXT("- Without an Icon file.")));

        // Subscription state
        iIndex = GetPrivateProfileInt(IS_SOFTWAREUPDATES, IK_SBN_INDEX, 0, g_GetIns());
        if (iIndex > 0) {
            TCHAR szGroup[80];
            HKEY  hkSbn;

            nLen = LoadString(g_GetHinst(), s_rgwSubGroupIDs[iIndex], szGroup, countof(szGroup));
            wnsprintf(szKey, countof(szKey), RK_SUBSCRIPTION_ADD, szKey, szIndex);

            lResult = SHCreateKey(g_GetHKCU(), szKey, KEY_SET_VALUE, &hkSbn);
            if (lResult == ERROR_SUCCESS) {
                RegSetValueEx(hkSbn, RV_URL,              0, REG_SZ,    (LPBYTE)szUrl,   StrCbFromCch(nUrlLen+1));
                RegSetValueEx(hkSbn, RV_TITLE,            0, REG_SZ,    (LPBYTE)szTitle, StrCbFromCch(nTitleLen+1));
                RegSetValueEx(hkSbn, RV_SUBSCRIPTIONTYPE, 0, REG_DWORD, (LPBYTE)&dwVal,  sizeof(dwVal));
                RegSetValueEx(hkSbn, RV_SCHEDULEGROUP,    0, REG_SZ,    (LPBYTE)szGroup, StrCbFromCch(nLen+1));
                SHCloseKey(hkSbn);

                Out(LI1(TEXT("Subscription is based on \"%s\" schedule..."), szGroup));
            }
        }

        // the most important one
        RegSetValueEx(hk, RV_SOFTWARE, 0, REG_DWORD, (LPBYTE)&dwVal, sizeof(dwVal));
        SHCloseKey(hk);

        Out(LI0(TEXT("Done.")));
    }

    if (iNumChannels == 0)
        Out(LI0(TEXT("There are no software update channels to add!")));

    return hr;
}


// Execute actual processing of channels by calling Webcheck DllInstall
HRESULT lcy4x_ProcessWebcheck()
{   MACRO_LI_PrologEx_C(PIF_STD_C, lcy4x_ProcessWebcheck)

    typedef HRESULT (WINAPI *DLLINSTALL)(BOOL, LPCWSTR);

    DLLINSTALL pfnDllInstall;
    HINSTANCE  hWebcheckDll;
    HRESULT    hr;

    hWebcheckDll = NULL;
    hr           = E_FAIL;

    hWebcheckDll = LoadLibrary(TEXT("webcheck.dll"));
    if (hWebcheckDll == NULL) {
        Out(LI0(TEXT("! \"webcheck.dll\" could not be loaded.")));
        goto Exit;
    }

    pfnDllInstall = (DLLINSTALL)GetProcAddress(hWebcheckDll, "DllInstall");
    if (pfnDllInstall == NULL) {
        Out(LI0(TEXT("! \"DllInstall\" in webcheck.dll was not found.")));
        goto Exit;
    }

    hr = pfnDllInstall(TRUE, L"policy");
    Out(LI1(TEXT("\"DllInstall\" in webcheck.dll returned %s."), GetHrSz(hr)));

Exit:
    if (hWebcheckDll != NULL)
        FreeLibrary(hWebcheckDll);

    return S_OK;
}

// Show channel bar on the desktop (used for NT mainly)
HRESULT lcy4x_ProcessChannelBar()
{   MACRO_LI_PrologEx_C(PIF_STD_C, lcy4x_ProcessChannelBar)

    HRESULT hr;
    BOOL    fActiveDesktop;

    hr = E_FAIL;

    fActiveDesktop = FALSE;
    SHGetSetActiveDesktop(FALSE, &fActiveDesktop);

    if (!(fActiveDesktop && HasFlag(WhichPlatform(), PLATFORM_INTEGRATED))) {
        SHSetValue(g_GetHKCU(), RK_IE_MAIN, RV_SHOWCHANNELBAND, REG_SZ, TEXT("yes"), StrCbFromCch(4));
        Out(LI0(TEXT("Channel bar on the desktop in now enabled!")));
    }
    else {
        TCHAR szSubkey[MAX_PATH],
              szGuid[128];
        HKEY  hk, hkSubkey;
        DWORD dwSize,
              dwSubkey;
        BOOL  fFound;

        fFound = FALSE;

        if (ERROR_SUCCESS != SHOpenKey(g_GetHKCU(), RK_DT_COMPONENTS, KEY_ENUMERATE_SUB_KEYS, &hk)) {
            Out(LI0(TEXT("! Internal failure.")));
            goto Exit;
        }

        for (dwSubkey = 0, dwSize = countof(szSubkey);
             ERROR_SUCCESS == RegEnumKeyEx(hk, dwSubkey, szSubkey, &dwSize, NULL, NULL, NULL, NULL);
             dwSubkey++,   dwSize = countof(szSubkey)) {

            if (ERROR_SUCCESS != SHOpenKey(hk, szSubkey, KEY_READ | KEY_SET_VALUE, &hkSubkey))
                continue;

            dwSize = sizeof(szGuid);
            if (ERROR_SUCCESS == RegQueryValueEx(hkSubkey, RV_SOURCE, NULL, NULL, (LPBYTE)szGuid, &dwSize))
                if (0 == StrCmpI(szGuid, CHLBAR_GUID)) {
                    DWORD dwFlags;

                    dwFlags = 0;
                    dwSize  = sizeof(dwFlags);
                    RegQueryValueEx(hkSubkey, RV_FLAGS, NULL, NULL, (LPBYTE)&dwFlags, &dwSize);

                    dwFlags |= RD_CHLBAR_ENABLE;
                    RegSetValueEx(hkSubkey, RV_FLAGS, 0, REG_DWORD, (LPBYTE)&dwFlags, dwSize);

                    fFound = TRUE;
                    break;
                }

            SHCloseKey(hkSubkey);
        }

        SHCloseKey(hk);

        if (fFound)
            Out(LI0(TEXT("Channel bar on the desktop in now enabled!")));
        else
            Out(LI0(TEXT("! Channel bar is not found in the list of Active Desktop components.")));
            
    }

    hr = S_OK;

Exit:
    return hr;
}

HRESULT lcy4x_ProcessSubscriptions()
{   MACRO_LI_PrologEx_C(PIF_STD_C, lcy4x_ProcessSubscriptions)

    const PROPSPEC c_PropSub = { PRSPEC_PROPID, PID_INTSITE_SUBSCRIPTION};

    IUniformResourceLocator *purl;
    IPropertySetStorage     *ppss;
    IPropertyStorage        *pps;
    PROPVARIANT             pvGuid;
    TCHAR   szUrl[INTERNET_MAX_URL_LENGTH],
            szBuf[1024],
            szSchedKey[MAX_PATH];
    WCHAR   wszGuid[128];
    LPTSTR  pszGuid;
    HRESULT hr;

    ppss = NULL;
    pps  = NULL;

    GetPrivateProfileString(IS_SUBSCRIPTIONS, NULL, NULL, szBuf, countof(szBuf), g_GetIns());
    for (pszGuid = szBuf; *pszGuid != TEXT('\0'); pszGuid += StrLen(pszGuid) + 1) {
        wnsprintf(szSchedKey, countof(szSchedKey), RK_SCHEDITEMS, pszGuid);
        if (S_OK != SHKeyExists(g_GetHKCU(), szSchedKey))
            continue;

        GetPrivateProfileString(IS_SUBSCRIPTIONS, pszGuid, TEXT(""), szUrl, countof(szUrl), g_GetIns());
        if (szUrl[0] == TEXT('\0'))
            continue;

        hr = CoCreateInstance(CLSID_InternetShortcut, NULL, CLSCTX_INPROC_SERVER,
                IID_IUniformResourceLocator, (LPVOID *)&purl);

        if (SUCCEEDED(hr)) {
            ASSERT(purl != NULL);
            hr = purl->SetURL(szUrl, 0);
        }

        if (SUCCEEDED(hr)) {
            hr = purl->QueryInterface(IID_IPropertySetStorage, (LPVOID *)&ppss);
            purl->Release();
        }

        if (SUCCEEDED(hr)) {
            ASSERT(ppss != NULL);
            hr = ppss->Open(FMTID_InternetSite, STGM_READWRITE, &pps);
            ppss->Release();
        }

        if (SUCCEEDED(hr)) {
            T2Wbuf(pszGuid, wszGuid, countof(wszGuid));

            pvGuid.vt      = VT_LPWSTR;
            pvGuid.pwszVal = wszGuid;

            ASSERT(pps != NULL);
            hr = pps->WriteMultiple(1, &c_PropSub, &pvGuid, 0);
            pps->Commit(STGC_DEFAULT);
            pps->Release();
        }
    }

    return S_OK;
}

// private helper functions
static HRESULT pepDeleteChanEnumProc(LPCTSTR pszPath, PWIN32_FIND_DATA pfd, LPARAM lParam, PDWORD *prgdwControl /*= NULL */)
{
    TCHAR szDesktopIni[MAX_PATH];

    UNREFERENCED_PARAMETER(prgdwControl);
    UNREFERENCED_PARAMETER(pfd);

    PathCombine(szDesktopIni, pszPath, TEXT("desktop.ini"));

    // only remove the path if this is a channel and we're deleting channels or if this
    // is a GP created channel and we're cleaning. lParam is flag to determine whether or
    // not we're cleaning GP channels(TRUE if we are)

    if ((!InsIsSectionEmpty(CHANNEL_SECT, szDesktopIni) || 
        !InsIsKeyEmpty(SHELLCLASSINFO, WIDELOGO, szDesktopIni)) &&
        (!(BOOL)lParam || !InsIsKeyEmpty(IS_BRANDING, IEAK_GP_MANDATE, szDesktopIni)))
        PathRemovePath(pszPath);

    return S_OK;
}


static void processAddChannel(LPWSTR pwszTitle, LPWSTR pwszUrl, LPWSTR pwszPreloadUrl, 
                              LPWSTR pwszLogo, LPWSTR pwszWideLogo, LPWSTR pwszIcon, 
                              BOOL fOffline, BOOL fCategory)
{
    IChannelMgr *pChannelMgr = NULL;
    HRESULT hr;
    
    hr = CoCreateInstance(CLSID_ChannelMgr, NULL, CLSCTX_INPROC_SERVER, IID_IChannelMgr, (void**)&pChannelMgr);
    if (SUCCEEDED(hr))
    {
        // See if channel already exists - do nothing if it does (62976)
        // this takes care of preference channels in group policy as well
        IEnumChannels *pEnumChannels = NULL;
        if (SUCCEEDED(pChannelMgr->EnumChannels(CHANENUM_ALLFOLDERS, pwszUrl, &pEnumChannels)))
        {
            CHANNELENUMINFO Bogus={0};
            ULONG cFetched=0;
            
            if ((S_OK == pEnumChannels->Next(1, &Bogus, &cFetched)) && cFetched)
            {
                // Oops. It exists. Skip all this goo.
                hr = E_FAIL;
            }
        }
        SAFERELEASE(pEnumChannels);
    }
    if (SUCCEEDED(hr))
    {
        if (fCategory)
        {
            // create a category 
            CHANNELCATEGORYINFO csi = {0};
            csi.cbSize   = sizeof(csi);
            csi.pszURL   = pwszUrl;
            csi.pszTitle = pwszTitle;
            csi.pszLogo  = ISNONNULL(pwszLogo) ? T2W(pwszLogo) : NULL;
            csi.pszIcon  = ISNONNULL(pwszIcon) ? T2W(pwszIcon) : NULL;
            csi.pszWideLogo = ISNONNULL(pwszWideLogo) ? T2W(pwszWideLogo) : NULL;
            hr = pChannelMgr->AddCategory(&csi);
        }
        else 
        {
            // tell wininet if there's preload content
            if (ISNONNULL(pwszPreloadUrl))
            {
                SHSetValue(g_GetHKCU(), RK_INETSETTINGS TEXT("\\Cache\\Preload"), pwszUrl,
                    REG_SZ, (LPBYTE)pwszPreloadUrl, (DWORD)StrCbFromSzW(pwszPreloadUrl));
            }
            // create a channel (use URL instead of Title if code page doesn't match)
            CHANNELSHORTCUTINFO csi = {0};
            csi.cbSize   = sizeof(csi);
            csi.pszURL   = pwszUrl;
            csi.pszTitle = pwszTitle;
            csi.pszLogo  = ISNONNULL(pwszLogo) ? T2W(pwszLogo) : NULL;
            csi.pszIcon  = ISNONNULL(pwszIcon) ? T2W(pwszIcon) : NULL;
            csi.pszWideLogo = ISNONNULL(pwszWideLogo) ? T2W(pwszWideLogo) : NULL;
            hr = pChannelMgr->AddChannelShortcut(&csi);
        }

        // mark this channel/category if it's from a mandate GPO
        
        if (g_CtxIsGp() && !g_CtxIs(CTX_MISC_PREFERENCES))
        {
            static TCHAR s_szChannelIni[MAX_PATH];
            static LPTSTR pszChan = NULL;
            static DWORD s_dwMaxChanLen;

            if (pszChan == NULL)
            {
                GetChannelsPath(s_szChannelIni, countof(s_szChannelIni));
                if (ISNULL(s_szChannelIni))
                    GetFavoritesPath(s_szChannelIni, countof(s_szChannelIni));
                if (ISNONNULL(s_szChannelIni))
                {
                    pszChan = PathAddBackslash(s_szChannelIni);
                    s_dwMaxChanLen = countof(s_szChannelIni) - StrLen(s_szChannelIni);
                }
            }
            
            if (pszChan != NULL)
            {
                DWORD dwAttrib;

                PathRemoveBackslashW(pwszTitle);
                wnsprintf(pszChan, s_dwMaxChanLen, TEXT("%s\\desktop.ini"), W2CT(pwszTitle));
                dwAttrib = GetFileAttributes(s_szChannelIni);
                SetFileAttributes(s_szChannelIni, FILE_ATTRIBUTE_NORMAL);
                InsWriteBool(IS_BRANDING, IEAK_GP_MANDATE, TRUE, s_szChannelIni);
                InsFlushChanges(s_szChannelIni);
                SetFileAttributes(s_szChannelIni, dwAttrib);
            }
        }
    }
    SAFERELEASE(pChannelMgr);
    
    if (fOffline)
    {
        ISubscriptionMgr2 *pSubMgr2 = NULL;
        hr = CoCreateInstance(CLSID_SubscriptionMgr, 
            NULL, 
            CLSCTX_INPROC_SERVER, 
            IID_ISubscriptionMgr2, 
            (void**)&pSubMgr2);
        if (SUCCEEDED(hr))
        {
            SUBSCRIPTIONINFO si;
            
            ZeroMemory(&si, sizeof(si));
            si.cbSize       = sizeof(SUBSCRIPTIONINFO);
            si.fUpdateFlags = SUBSINFO_SCHEDULE;
            si.schedule     = SUBSSCHED_MANUAL;

            hr = pSubMgr2->CreateSubscription(NULL, 
                pwszUrl, 
                pwszTitle, 
                CREATESUBS_NOUI,
                SUBSTYPE_CHANNEL, 
                &si);
            
            if (SUCCEEDED(hr))
            {
                ISubscriptionItem *pSubItem = NULL;
                
                hr = pSubMgr2->GetItemFromURL(pwszUrl, &pSubItem);
                if (SUCCEEDED(hr))
                {
                    SUBSCRIPTIONCOOKIE cookie;
                    
                    hr = pSubItem->GetCookie(&cookie);
                    if (SUCCEEDED(hr))
                        pSubMgr2->UpdateItems(SUBSMGRUPDATE_MINIMIZE, 1, &cookie);
                }
            }
            
            pSubMgr2->Release();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\brandll\brandcs.cpp ===
#include "precomp.h"
#include <rashelp.h>

#pragma warning(disable: 4201)                  // nonstandard extension used : nameless struct/union
#include <winineti.h>

// Private forward decalarations
PCTSTR getPhonebookFile(PTSTR pszPhonebook = NULL, UINT cchPhonebook = 0);
PCTSTR getConnectToInternetFile(PTSTR pszFile = NULL, UINT cchFile = 0);

//----- ClearConnectionSettings() and ProcessConnectionSettingsDeletion() helpers -----
BOOL    deleteConnection (PCTSTR pszPhonebook, PCTSTR pszName);
BOOL    rasDeleteEnumProc(PCWSTR pszNameW, LPARAM lParam);

// cnl stands for "connection names list"
BOOL    cnlAppendNameToList(PCTSTR  pszName, HKEY   hkCached = NULL);
HRESULT cnlIsNameInList    (PCTSTR  pszName, PTSTR  pszList  = NULL, HKEY hkCached = NULL);
BOOL    cnlGetList         (PTSTR *ppszList, PDWORD pcchList = NULL, HKEY hkCached = NULL);

// lb stands for "lan backup"
BOOL    lbBackup ();
BOOL    lbRestore();
void    lbCopySzToBlobW(PBYTE *ppBlob, PCWSTR pszStrW);

// ra stands for "remote access"
BOOL    raBackup();
BOOL    raRestore();


//----- ProcessConnectionSettings() and lcy50_ProcessConnectionSettings() helpers -----
HRESULT importRasSettings           (PCWSTR pszNameW, PBYTE *ppBlob, LPRASDEVINFOW prdiW, UINT cDevices);
HRESULT importRasCredentialsSettings(PCWSTR pszNameW, PBYTE *ppBlob);
HRESULT importWininetSettings       (PCWSTR pszNameW, PBYTE *ppBlob);

void setSzFromBlobA(PBYTE *ppBlob, UNALIGNED CHAR  **ppszStrA);
void setSzFromBlobW(PBYTE *ppBlob, UNALIGNED WCHAR **ppszStrW);

HRESULT insProcessAutoconfig(PCTSTR pszName);
HRESULT insProcessProxy     (PCTSTR pszName);

//----- Miscellaneous -----
DWORD getWininetFlagsSetting(PCTSTR pszName = NULL);
BOOL  mergeProxyBypass      (PCTSTR pszName, PCTSTR pszProxyBypass, PTSTR pszResult, UINT cchResult);
void  trimProxyBypass       (PTSTR pszProxyBypass);

TCHAR g_szConnectoidName[RAS_MaxEntryName + 1];

void ClearConnectionSettings(DWORD dwFlags /*= FF_ENABLE*/)
{   MACRO_LI_PrologEx_C(PIF_STD_C, ClearConnectionSettings)

    UNREFERENCED_PARAMETER(dwFlags);

    PTSTR  pszList;
    PCTSTR pszPhonebook,
           pszCur;
    BOOL   fRasApisLoaded,
           fResult,
           fImpersonate;

    fImpersonate = FALSE;
    if (g_CtxIsGp())
        fImpersonate = ImpersonateLoggedOnUser(g_GetUserToken());

    Out(LI0(TEXT("Clearing connection settings...")));
    pszList        = NULL;
    fRasApisLoaded = FALSE;

    pszPhonebook = getPhonebookFile();
    if (NULL == pszPhonebook)
        goto Exit;

    fResult = cnlGetList(&pszList);
    if (!fResult || NULL == pszList)
        goto Exit;

    fRasApisLoaded = (RasPrepareApis(RPA_RASDELETEENTRYA) && NULL != g_pfnRasDeleteEntryA);
    if (!fRasApisLoaded)
        goto Exit;

    for (pszCur = pszList; NULL != pszCur && TEXT('\0') != *pszCur; pszCur += StrLen(pszCur)+1) {
        fResult = deleteConnection(pszPhonebook, pszCur);
        if (fResult)
            Out(LI1(TEXT("Connection \"%s\" was deleted successfully."), pszCur));
        else
            Out(LI1(TEXT("! Deleting connection \"%s\" failed."), pszCur));
    }

Exit:
// removed per bug 28282--lanbackup has performance problems and is really not 
// accomplishing much anyway--we don't do this for other features, why shoudl we do it for 
// connection settings?
//  lbRestore();

    Out(LI0(TEXT("\r\n")));
    raRestore();

    if (fRasApisLoaded)
        RasPrepareApis(RPA_UNLOAD, FALSE);

    if (NULL != pszList)
        CoTaskMemFree((PVOID)pszList);

    Out(LI0(TEXT("Done.")));
    if (fImpersonate)
        RevertToSelf();
}


HRESULT ProcessWininetSetup()
{
    BOOL fResult = FALSE;

    if (g_CtxIsGp()) {
        ASSERT(!g_CtxIs(CTX_MISC_CHILDPROCESS));
        ASSERT(NULL != g_GetUserToken() && IsOS(OS_NT5));

        InternetSetOption(NULL, INTERNET_OPTION_SETTINGS_CHANGED, NULL, 0);

        fResult = ImpersonateLoggedOnUser(g_GetUserToken());
    }

    getWininetFlagsSetting();

    if (g_CtxIsGp() && fResult)
        RevertToSelf();

    return S_OK;
}

HRESULT ProcessConnectionSettingsDeletion()
{   MACRO_LI_PrologEx_C(PIF_STD_C, ProcessConnectionSettingsDeletion)

    HRESULT hr;

    hr = (TRUE == RasEnumEntriesCallback(NULL, rasDeleteEnumProc, 0, RWM_RUNTIME)) ? S_OK : E_FAIL;
    if (FAILED(hr))
        Out(LI0(TEXT("! Enumeration of RAS connections failed with E_FAIL.")));

    return hr;
}

HRESULT ProcessConnectionSettings()
{   MACRO_LI_PrologEx_C(PIF_STD_C, ProcessConnectionSettings)

    USES_CONVERSION;

    LPRASDEVINFOW prdiW;
    TCHAR   szTargetFile[MAX_PATH],
            szApplyToName[RAS_MaxEntryName + 1];
    PCWSTR  pszCurNameW;
    PWSTR   pszNameW;
    PBYTE   pBuf, pCur;
    HANDLE  hFile;
    HRESULT hr;
    DWORD   dwVersion,
            cbBuffer, cbFile,
            dwAux,
            cDevices;
    BOOL    fRasApisLoaded,
            fSkipBlob;

    prdiW          = NULL;
    pszNameW       = NULL;
    pBuf           = NULL;
    hFile          = NULL;
    hr             = E_FAIL;
    cDevices       = 0;
    fRasApisLoaded = FALSE;

    //----- Global settings processing -----
    HKEY  hkHkcu, hkHkcc;
    BOOL  fAux;

    hkHkcu = NULL;
    hkHkcc = NULL;

    dwAux = 0;
    if (InsKeyExists(IS_CONNECTSET, IK_ENABLEAUTODIAL, g_GetIns()))
        dwAux |= 1;

    if (InsKeyExists(IS_CONNECTSET, IK_NONETAUTODIAL,  g_GetIns()))
        dwAux |= 2;

    if (0 < dwAux) {
        SHOpenKey(g_GetHKCU(), RK_INETSETTINGS, KEY_SET_VALUE, &hkHkcu);

        // NOTE: (andrewgu) according to darrenmi no need to do hkcc work on w2k shell.
        if (!IsOS(OS_NT5))
            SHOpenKeyHKCC(RK_INETSETTINGS, KEY_SET_VALUE, &hkHkcc);
    }

    if (HasFlag(dwAux, 1)) {
        fAux = InsGetBool(IS_CONNECTSET, IK_ENABLEAUTODIAL, FALSE, g_GetIns());

        if (NULL != hkHkcu)
            RegSetValueEx(hkHkcu, RV_ENABLEAUTODIAL, 0, REG_DWORD, (LPBYTE)&fAux, sizeof(fAux));
        if (NULL != hkHkcc)
            RegSetValueEx(hkHkcc, RV_ENABLEAUTODIAL, 0, REG_DWORD, (LPBYTE)&fAux, sizeof(fAux));
    }

    if (HasFlag(dwAux, 2)) {
        fAux = InsGetBool(IS_CONNECTSET, IK_NONETAUTODIAL, FALSE, g_GetIns());

        if (NULL != hkHkcu)
            RegSetValueEx(hkHkcu, RV_NONETAUTODIAL, 0, REG_DWORD, (LPBYTE)&fAux, sizeof(fAux));
        if (NULL != hkHkcc)
            RegSetValueEx(hkHkcc, RV_NONETAUTODIAL, 0, REG_DWORD, (LPBYTE)&fAux, sizeof(fAux));
    }

    SHCloseKey(hkHkcu);
    SHCloseKey(hkHkcc);

    // removed per bug 28282--lanbackup has performance problems and is really not 
    // accomplishing much anyway--we don't do this for other features, why shoudl we do it for 
    // connection settings?


    //----- Backup LAN settings (in GP context) -----
   // if ((g_CtxIs(CTX_GP) && !g_CtxIs(CTX_MISC_PREFERENCES)) &&
   //    InsIsKeyEmpty(IS_CONNECTSET, IK_APPLYTONAME, g_GetIns()) &&
   //   FF_DISABLE == GetFeatureBranded(FID_CS_MAIN)) {

	//ASSERT(S_OK != SHValueExists(g_GetHKCU(), RK_BRND_CS, RV_LANBACKUP));
        
        //lbBackup();
        
    //}

    //----- Process version information -----
    if (!InsGetBool(IS_CONNECTSET, IK_OPTION, FALSE, g_GetIns())) {
        hr = S_FALSE;
        goto PartTwo;
    }

    dwAux = 0;

    PathCombine(szTargetFile, g_GetTargetPath(), CS_DAT);
    if (PathFileExists(szTargetFile))
        dwAux = CS_VERSION_5X;

    if (0 == dwAux) {
        PathCombine(szTargetFile, g_GetTargetPath(), CONNECT_SET);
        if (PathFileExists(szTargetFile))
            dwAux = CS_VERSION_50;

        else {
            Out(LI0(TEXT("Connection settings file(s) is absent!")));
            goto PartTwo;
        }
    }
    ASSERT(0 != dwAux);

    hFile = CreateFile(szTargetFile, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
    if (hFile == INVALID_HANDLE_VALUE) {
        Out(LI0(TEXT("! Connections settings file(s) can't be opened.")));
        hr = STG_E_ACCESSDENIED;
        goto PartTwo;
    }

    SetFilePointer(hFile, 0, NULL, FILE_BEGIN);
    if (ReadFile(hFile, &dwVersion, sizeof(dwVersion), &cbFile, NULL) != TRUE)
    {
        Out(LI0(TEXT("! Error reading version information in connection settings file(s).")));
        goto PartTwo;
    }

    if (CS_VERSION_50 == dwVersion) {
        if (CS_VERSION_50 != dwAux) {
            Out(LI0(TEXT("! Version of connections settings file(s) is mismatched.")));
            goto PartTwo;
        }

        CloseFile(hFile);
        hFile = NULL;

        hr = lcy50_ProcessConnectionSettings();
        goto PartTwo;
    }
    else if (CS_VERSION_5X <= dwVersion && CS_VERSION_5X_MAX >= dwVersion) {
        if (CS_VERSION_5X != dwAux) {
            Out(LI0(TEXT("! Version of connections settings file(s) is mismatched.")));
            goto PartTwo;
        }
    }
    else {
        Out(LI0(TEXT("! Version information in connection settings file(s) is corrupted.")));
        goto PartTwo;
    }

    Out(LI1(TEXT("Connection settings file is \"%s\"."), CS_DAT));
    Out(LI1(TEXT("The version of connection settings file is 0x%lX.\r\n"), dwVersion));

    //----- Read CS file into internal memory buffer -----
    cbBuffer = GetFileSize(hFile, NULL);
    if (cbBuffer == 0xFFFFFFFF) {
        Out(LI0(TEXT("! Internal processing error.")));
        goto PartTwo;
    }
    cbBuffer -= sizeof(dwVersion);

    pBuf = (PBYTE)CoTaskMemAlloc(cbBuffer);
    if (pBuf == NULL) {
        Out(LI0(TEXT("! Internal processing ran out of memory.")));
        hr = E_OUTOFMEMORY;
        goto PartTwo;
    }
    ZeroMemory(pBuf, cbBuffer);

    ReadFile (hFile, pBuf, cbBuffer, &cbFile, NULL);
    CloseFile(hFile);
    hFile = NULL;

    pCur = pBuf;

    //----- Get information about RAS devices on the local system -----
    if (!RasIsInstalled())
        Out(LI0(TEXT("RAS support is not installed. Only LAN settings will be processed!\r\n")));

    else {
        fRasApisLoaded = (RasPrepareApis(RPA_RASSETENTRYPROPERTIESA) && g_pfnRasSetEntryPropertiesA != NULL);
        if (!fRasApisLoaded)
            Out(LI0(TEXT("! Required RAS APIs failed to load. Only LAN settings will be processed.\r\n")));
    }

    if (fRasApisLoaded) {
        RasEnumDevicesExW(&prdiW, NULL, &cDevices);
        if (cDevices == 0)
            Out(LI0(TEXT("There are no RAS devices to connect to. Only LAN settings will be processed!\r\n")));
    }

    //----- Main loop -----
    pszCurNameW = L"";
    hr          = S_OK;
    fSkipBlob   = FALSE;

    while (pCur < pBuf + cbBuffer) {

        //_____ Determine connection name _____
        if (*((PDWORD)pCur) == CS_STRUCT_HEADER) {
            pCur += 2*sizeof(DWORD);
            setSzFromBlobW(&pCur, &pszNameW);
        }

        //_____ Special case no RAS or no RAS devices _____
        // NOTE: (andrewgu) in this case it makes sense to process wininet settings for LAN only.
        if (!fRasApisLoaded || cDevices == 0) {
            if (pszNameW != NULL || *((PDWORD)pCur) != CS_STRUCT_WININET) {
                pCur += *((PDWORD)(pCur + sizeof(DWORD)));
                continue;
            }

            ASSERT(pszNameW == NULL && *((PDWORD)pCur) == CS_STRUCT_WININET);
        }

        //_____ Main processing _____
        if (pszCurNameW != pszNameW) {
            fSkipBlob = FALSE;

            if (TEXT('\0') != *pszCurNameW)     // tricky: empty string is an invalid name
                Out(LI0(TEXT("Done.")));        // if not that, there were connections before

            if (NULL != pszNameW) {
                PCTSTR pszName;

                pszName = W2CT(pszNameW);
                Out(LI1(TEXT("Proccessing settings for \"%s\" connection..."), pszName));

                //- - - GP context - - -
                if (g_CtxIs(CTX_GP))
                    // policies gpo special processing:
                    // builds a list of all connection settings names branded in the current gpo
                    // list and stores it in HKCU\RK_BRND_CS, RV_NAMESLIST.
                    if (!g_CtxIs(CTX_MISC_PREFERENCES))
                        cnlAppendNameToList(pszName);

                    // preferences gpo special processing
                    else { /* g_CtxIs(CTX_MISC_PREFERENCES) */
                        fSkipBlob = (S_OK == cnlIsNameInList(pszName));
                        if (fSkipBlob)
                            Out(LI0(TEXT("Connection with this name has been enforced through policies!\r\n")));
                    }
            }
            else {
                Out(LI0(TEXT("Proccessing settings for LAN connection...")));

                // ASSUMPTION: (andrewgu) if connection settings marked branded in the registry -
                // LAN settings have already been enforced. (note, that technically it may not be
                // true - if there is no cs.dat and *.ins customized ras connection through
                // IK_APPLYTONAME)
                fSkipBlob = (g_CtxIs(CTX_GP) && g_CtxIs(CTX_MISC_PREFERENCES)) && FF_DISABLE != GetFeatureBranded(FID_CS_MAIN);
                if (fSkipBlob)
                    Out(LI0(TEXT("These settings have been enforced through policies!\r\n")));
            }

            pszCurNameW = pszNameW;
        }

        if (fSkipBlob) {
            pCur += *((PDWORD)(pCur + sizeof(DWORD)));
            continue;
        }

        switch (*((PDWORD)pCur)) {
        case CS_STRUCT_RAS:
            hr = importRasSettings(pszNameW, &pCur, prdiW, cDevices);
            break;

        case CS_STRUCT_RAS_CREADENTIALS:
            hr = importRasCredentialsSettings(pszNameW, &pCur);
            break;

        case CS_STRUCT_WININET:
            hr = importWininetSettings(pszNameW, &pCur);
            break;

        default:
            pCur += *((PDWORD)(pCur + sizeof(DWORD)));
            hr    = S_FALSE;
        }

        if (hr == E_UNEXPECTED) {
            Out(LI0(TEXT("! The settings file is corrupted beyond recovery.")));
            goto PartTwo;
        }
    }
    Out(LI0(TEXT("Done.")));                    // to indicate end for the last connection
    // HaitaoLi: #16682[WinSE]:Connection settings lost with IE Maintenance GPO even 
    // when "Do not customize Connection Settings" is checked
    // I moved the following line from within the Exit block to here. Otherwise If
    // GPO has "Do not customize connection settings" checked, but the .ins file
    // has any connnection settings (e.g. proxy) customized, then we call
    // SetFeatureBranded() and mark the connection settings as branded.
    // So the next time branding is run, it will clear all the connection settings,
    // including dial-up settings.
    SetFeatureBranded(FID_CS_MAIN);

PartTwo:
    //_____ Ins proxy and autoconfig information _____
    { MACRO_LI_Offset(1);                       // need a new scope

    InsGetString(IS_CONNECTSET, IK_APPLYTONAME, szApplyToName, countof(szApplyToName), g_GetIns());
    if (szApplyToName[0] == TEXT('\0') && g_szConnectoidName[0] != TEXT('\0'))
        StrCpy(szApplyToName, g_szConnectoidName);

    Out(LI0(TEXT("\r\n")));
    if (szApplyToName[0] == TEXT('\0'))
        Out(LI0(TEXT("Settings from the *.ins file will be applied to LAN connection!")));
    else
        Out(LI1(TEXT("Settings from the *.ins file will be applied to \"%s\" connection!"), szApplyToName));

    }                                           // end offset scope

    // ASSUMPTION: (andrewgu) if connection settings marked branded in the registry - LAN
    // settings have already been enforced. (note, that technically it may not be true - if there
    // is no cs.dat and *.ins customized ras connection through IK_APPLYTONAME)
    if ((g_CtxIs(CTX_GP) && g_CtxIs(CTX_MISC_PREFERENCES)) &&
        FF_DISABLE != GetFeatureBranded(FID_CS_MAIN)) {

        ASSERT(TEXT('\0') == szApplyToName[0]);
        Out(LI0(TEXT("These settings have been enforced through policies!\r\n")));
    }
    else {
        HRESULT hrAutoconfig, hrProxy;

        Out(LI0(TEXT("\r\n")));
        hrAutoconfig = insProcessAutoconfig(szApplyToName);

        Out(LI0(TEXT("\r\n")));
        hrProxy = insProcessProxy(szApplyToName);

        if (S_OK != hr)
            if (S_OK == hrAutoconfig || S_OK == hrProxy)
                hr = S_FALSE;                   // partial success

            else
                hr = E_FAIL;                    // nothing really worked
    }

    if (SUCCEEDED(hr)) {
        // NOTE: (andrewgu) ie5 b#81989. this whole thing is a mess. first of all when i ported
        // getConnectToInternetFile from icw i found something like 3 bugs in the code, plus the
        // code in general does the wrong thing on win9x. i talked to oliverl a bit, and we
        // decided that what's below is the best course of action at this point.
        // it's self-explanatory.
        if (!((g_CtxIs(CTX_ISP) && g_CtxIs(CTX_SIGNUP_ALL)) || g_CtxIs(CTX_ICW))) {
            BOOL fImpersonate = FALSE;

            if (g_CtxIsGp())
                fImpersonate = ImpersonateLoggedOnUser(g_GetUserToken());

            getConnectToInternetFile(szTargetFile);
            if (TEXT('\0') != szTargetFile[0] && PathFileExists(szTargetFile)) {
                SetFileAttributes(szTargetFile, FILE_ATTRIBUTE_NORMAL);
                DeleteFile(szTargetFile);
            }

            if (fImpersonate)
                RevertToSelf();
            dwAux = 1;
            SHSetValue(g_GetHKCU(), RK_ICW, RV_COMPLETED, REG_DWORD, (LPBYTE)&dwAux, sizeof(dwAux));

            Out(LI0(TEXT("Notified ICW that connection to the Internet is configured.")));
        }

    }

    //_____ Flush wininet, so settings take effect on next access _____
    if (!HasFlag(g_GetContext(), CTX_AUTOCONFIG))
        InternetSetOption(NULL, INTERNET_OPTION_SETTINGS_CHANGED, NULL, 0);

    if (prdiW != NULL) {
        CoTaskMemFree(prdiW);
        prdiW = NULL;
    }

    if (fRasApisLoaded)
        RasPrepareApis(RPA_UNLOAD, FALSE);

    if (pBuf != NULL) {
        CoTaskMemFree(pBuf);
        pBuf = NULL;
    }

    if (hFile != NULL && hFile != INVALID_HANDLE_VALUE) {
        CloseFile(hFile);
        hFile = NULL;
    }

    return hr;
}

HRESULT lcy50_ProcessConnectionSettings()
{   MACRO_LI_PrologEx_C(PIF_STD_C, lcy50_ProcessConnectionSettings)

    USES_CONVERSION;

    TCHAR  szTargetFile[MAX_PATH];
    HANDLE hFile;
    PBYTE  pBuf, pCur;
    DWORD  cbBuffer, cbAux,
           dwResult,
           cDevices;
    UINT   i;

    Out(LI0(TEXT("Connection settings are in IE5 format...")));

    hFile    = NULL;
    pBuf     = NULL;
    cbBuffer = 0;
    cbAux    = 0;
    cDevices = 0;

    //----- Connect.ras processing -----
    Out(LI1(TEXT("Processing RAS connections information from \"%s\"."), CONNECT_RAS));

    PathCombine(szTargetFile, g_GetTargetPath(), CONNECT_RAS);
    if (!PathFileExists(szTargetFile))
        Out(LI0(TEXT("This file doesn't exist!")));

    else {
        LPRASDEVINFOA prdiA;
        LPRASENTRYA   preA;
        TCHAR szName[RAS_MaxEntryName + 1],
              szScript[MAX_PATH],
              szDeviceName[RAS_MaxDeviceName + 1],
              szKey[16];
        CHAR  szNameA[RAS_MaxEntryName + 1];
        PSTR  pszScriptA;
        DWORD cbRasEntry;
        UINT  j;
        BOOL  fRasApisLoaded;

        prdiA          = NULL;
        hFile          = NULL;
        fRasApisLoaded = FALSE;

        if (!RasIsInstalled()) {
            Out(LI0(TEXT("RAS support is not installed. Only LAN settings will be processed!")));
            goto RasExit;
        }

        //_____ Read Connect.ras into internal memory buffer _____
        hFile = CreateFile(szTargetFile, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
        if (hFile == INVALID_HANDLE_VALUE) {
            Out(LI0(TEXT("! This file can't be opened.")));
            goto RasExit;
        }

        SetFilePointer(hFile, 0, NULL, FILE_BEGIN);
        cbBuffer = GetFileSize(hFile, NULL);
        if (cbBuffer == 0xFFFFFFFF) {
            Out(LI0(TEXT("! Internal processing error.")));
            goto RasExit;
        }

        pBuf = (PBYTE)CoTaskMemAlloc(cbBuffer);
        if (pBuf == NULL) {
            Out(LI0(TEXT("! Internal processing ran out of memory.")));
            goto RasExit;
        }
        ZeroMemory(pBuf, cbBuffer);

        ReadFile(hFile, pBuf, cbBuffer, &cbAux, NULL);
        if (*((PDWORD)pBuf) != CS_VERSION_50) {
            Out(LI0(TEXT("! The version information in this file is corrupted.")));
            goto RasExit;
        }

        //_____ Preload RAS dlls _____
        if (!RasPrepareApis(RPA_RASSETENTRYPROPERTIESA) || g_pfnRasSetEntryPropertiesA == NULL) {
            Out(LI0(TEXT("! Required RAS APIs failed to load. Only LAN settings will be processed!\r\n")));
            goto RasExit;
        }
        fRasApisLoaded = TRUE;

        //_____ Get information about RAS devices on the local system _____
        RasEnumDevicesExA(&prdiA, NULL, &cDevices);
        if (cDevices == 0) {
            Out(LI0(TEXT("There are no RAS devices to connect to. Only LAN settings will be processed!\r\n")));
            goto RasExit;
        }

        //_____ Parse through RAS connections information _____
        for (i = cbAux = 0, pCur = pBuf + sizeof(DWORD); TRUE; i++, pCur += cbAux) {

            //- - - Initialization - - -
            MACRO_LI_Offset(1);
            if (i > 0)
                Out(LI0(TEXT("\r\n")));

            wnsprintf(szKey, countof(szKey), IK_CONNECTNAME, i);
            InsGetString(IS_CONNECTSET, szKey, szName, countof(szName), g_GetIns());
            if (szName[0] == TEXT('\0')) {
                Out(LI2(TEXT("[%s], \"%s\" doesn't exist. There are no more RAS connections!"), IS_CONNECTSET, szKey));
                break;
            }

            wnsprintf(szKey, countof(szKey), IK_CONNECTSIZE, i);
            cbAux = InsGetInt(IS_CONNECTSET, szKey, 0, g_GetIns());
            if (cbAux == 0) {
                Out(LI0(TEXT("! The ins file is corrupt. No more RAS connections can be processed.")));
                break;
            }

            //- - - Main processing - - -
            Out(LI1(TEXT("Processing RAS connection \"%s\"..."), szName));

            preA = (LPRASENTRYA)pCur;

            // NOTE: (andrewgu) the is a remote possibility that sizes of RASENTRYA structure are
            // different on the server and client machines. there is nothing bad with server
            // structure being smaller than the client structure (all RAS apis are
            // backward-compatible). it's bad though when server structure is bigger than client
            // can handle, hence the trancation.
            // (something else to have in mind) this truncation should not affect alternate phone
            // numbers support on winnt. for more special cases also check out NOTE: below.
            if (preA->dwSize > sizeof(RASENTRYA))
                preA->dwSize = sizeof(RASENTRYA);

            // preA->szScript
            if (preA->szScript[0] != '\0') {
                pszScriptA = preA->szScript;
                if (preA->szScript[0] == '[')
                    pszScriptA = &preA->szScript[1];

                A2Tbuf(pszScriptA, szScript, countof(szScript));
                StrCpy(PathFindFileName(szTargetFile), PathFindFileName(szScript));
                if (PathFileExists(szTargetFile))
                    T2Abuf(szTargetFile, preA->szScript, MAX_PATH);

                else
                    preA->szScript[0] = '\0';
            }

            // preA->szDeviceName
            for (j = 0; j < cDevices; j++)
                if (0 == StrCmpIA(preA->szDeviceType, prdiA[j].szDeviceType)) {
                    StrCpyA(preA->szDeviceName, prdiA[j].szDeviceName);
                    break;
                }
            if (j >= cDevices)
                StrCpyA(preA->szDeviceName, prdiA[0].szDeviceName);

            A2Tbuf(preA->szDeviceName, szDeviceName, countof(szDeviceName));
            Out(LI1(TEXT("Set the device name to \"%s\"."), szDeviceName));

            // NOTE: (andrewgu) on win9x if there are alternate phone numbers (i.e. the package
            // installed on win9x machine was generated on winnt machine), cbAux will be larger
            // than preA->dwSize. this will fail with ERROR_INVALID_PARAMETER on win9x. hence on
            // this platform cbAux is reset so api has a chance of succeeding.
            cbRasEntry = cbAux;
            if (IsOS(OS_WINDOWS)) {
                preA->dwAlternateOffset = 0;
                cbRasEntry = preA->dwSize;
            }

            //BUGBUG: this is casting a dword result to an hresult!  that gethrsz is never going to return anything useful. 
            T2Abuf(szName, szNameA, countof(szNameA));
            dwResult = g_pfnRasSetEntryPropertiesA(NULL, szNameA, preA, cbRasEntry, NULL, 0);
            if (dwResult != ERROR_SUCCESS) {
                Out(LI1(TEXT("! Creating this RAS connection failed with %s."), GetHrSz(dwResult)));
                continue;
            }

            Out(LI0(TEXT("Done.")));
        }
        Out(LI0(TEXT("Done.")));

        //_____ Cleanup _____
RasExit:
        if (fRasApisLoaded)
            RasPrepareApis(RPA_UNLOAD, FALSE);

        if (prdiA != NULL)
            CoTaskMemFree(prdiA);

        if (hFile != NULL && hFile != INVALID_HANDLE_VALUE) {
            CloseFile(hFile);
            hFile = NULL;
        }
    }

    //----- Connect.set processing -----
    Out(LI1(TEXT("\r\nProcessing Wininet.dll connections information from \"%s\"."), CONNECT_SET));
    StrCpy(PathFindFileName(szTargetFile), CONNECT_SET);

    if (!PathFileExists(szTargetFile))
        Out(LI0(TEXT("This file doesn't exist!")));

    else {
        INTERNET_PER_CONN_OPTION_LISTA listA;
        INTERNET_PER_CONN_OPTIONA      rgOptionsA[7];
        PBYTE pAux;

        //_____ Read Connect.set into internal memory buffer _____
        hFile = CreateFile(szTargetFile, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
        if (hFile == INVALID_HANDLE_VALUE) {
            Out(LI0(TEXT("! This file can't be opened.")));
            goto WininetExit;
        }

        SetFilePointer(hFile, 0, NULL, FILE_BEGIN);
        cbAux = GetFileSize(hFile, NULL);
        if (cbAux == 0xFFFFFFFF) {
            Out(LI0(TEXT("! Internal processing error.")));
            goto WininetExit;
        }

        if (cbAux > cbBuffer) {
            pBuf = (PBYTE)CoTaskMemRealloc(pBuf, cbAux);
            if (pBuf == NULL) {
                Out(LI0(TEXT("! Internal processing ran out of memory.")));
                goto WininetExit;
            }
        }
        cbBuffer = cbAux;
        ZeroMemory(pBuf, cbBuffer);

        ReadFile(hFile, pBuf, cbBuffer, &cbAux, NULL);
        ASSERT(*((PDWORD)pBuf) == CS_VERSION_50);

        //_____ Parse through Wininet.dll connections information _____
        for (pCur = pBuf + sizeof(DWORD), cbAux = 0; pCur < (pBuf + cbBuffer); pCur += cbAux) {

            //- - - Initialization - - -
            MACRO_LI_Offset(1);
            if (pCur > (pBuf + sizeof(DWORD)))
                Out(LI0(TEXT("\r\n")));

            //- - - Main processing - - -
            pAux = pCur;

            cbAux = *((PDWORD)pAux);
            pAux += sizeof(DWORD);

            ZeroMemory(&listA, sizeof(listA));
            listA.dwSize   = sizeof(listA);     // listA.dwSize
            listA.pOptions = rgOptionsA;        // listA.pOptions

            // listA.pszConnection
            if (*pAux == NULL) {
                listA.pszConnection = NULL;
                pAux += sizeof(DWORD);
            }
            else {
                listA.pszConnection = (PSTR)pAux;
                pAux += StrCbFromSzA(listA.pszConnection);
            }

            // skip all but LAN settings if no RAS devices
            if (cDevices == 0 && listA.pszConnection != NULL)
                continue;

            if (listA.pszConnection == NULL)
                Out(LI0(TEXT("Proccessing Wininet.dll settings for LAN connection...")));
            else
                Out(LI1(TEXT("Proccessing Wininet.dll settings for \"%s\" connection..."),
                    A2CT(listA.pszConnection)));

            // listA.dwOptionCount
            listA.dwOptionCount = *((PDWORD)pAux);
            pAux += sizeof(DWORD);

            // listA.pOptions
            for (i = 0; i < min(listA.dwOptionCount, countof(rgOptionsA)); i++) {
                listA.pOptions[i].dwOption = *((PDWORD)pAux);
                pAux += sizeof(DWORD);

                switch (listA.pOptions[i].dwOption) {
                case INTERNET_PER_CONN_PROXY_SERVER:
                case INTERNET_PER_CONN_PROXY_BYPASS:
                case INTERNET_PER_CONN_AUTOCONFIG_URL:
                case INTERNET_PER_CONN_AUTOCONFIG_SECONDARY_URL:
                    setSzFromBlobA(&pAux, &listA.pOptions[i].Value.pszValue);
                    break;

                case INTERNET_PER_CONN_FLAGS:
                case INTERNET_PER_CONN_AUTOCONFIG_RELOAD_DELAY_MINS:
                case INTERNET_PER_CONN_AUTODISCOVERY_FLAGS:
                default:                        // everything else is also DWORD
                    listA.pOptions[i].Value.dwValue = *((PDWORD)pAux);
                    pAux += sizeof(DWORD);
                    break;
                }
            }
            ASSERT(pAux == pCur + cbAux);

            if (HasFlag(g_GetContext(), (CTX_ISP | CTX_ICP))) {
                ASSERT(listA.pOptions[0].dwOption == INTERNET_PER_CONN_FLAGS);

                if (HasFlag(listA.pOptions[0].Value.dwValue, PROXY_TYPE_PROXY)) {
                    DWORD dwFlags;

                    dwFlags  = getWininetFlagsSetting(A2CT(listA.pszConnection));
                    dwFlags |= listA.pOptions[0].Value.dwValue;
                    listA.pOptions[0].Value.dwValue = dwFlags;
                }
                else {
                    Out(LI0(TEXT("No customizations!"))); // nothing to do since had only proxy
                    continue;                             // stuff to begin with. and now even
                }                                         // that is not there.
            }

            //- - - Merge new LAN's ProxyBypass settings with the existing ones - - -
            // NOTE: (andrewgu) since ieakeng.dll will always save the proxy information into the
            // ins file as well, it makes no sense to do this here because what's in the ins
            // should overwrite what's in the imported connections settings.

            //- - - Call into Wininet.dll - - -
            if (FALSE == InternetSetOptionA(NULL, INTERNET_OPTION_PER_CONNECTION_OPTION, &listA, listA.dwSize)) {
                Out(LI0(TEXT("! Processing of this Wininet.dll connection settings failed.")));
                continue;
            }

            Out(LI0(TEXT("Done.")));
        }
        Out(LI0(TEXT("Done.")));

        //_____ Cleanup _____
WininetExit:
        if (hFile != NULL && hFile != INVALID_HANDLE_VALUE) {
            CloseFile(hFile);
            hFile = NULL;
        }

        if (pBuf != NULL) {
            CoTaskMemFree(pBuf);
            pBuf = NULL;
        }
    }

    ASSERT(hFile == NULL);
    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// Implementation helper routines

PCTSTR getPhonebookFile(PTSTR pszPhonebook /*= NULL*/, UINT cchPhonebook /*= 0*/)
{   MACRO_LI_PrologEx_C(PIF_STD_C, getPhonebookFile)

    static TCHAR s_szFile[MAX_PATH];
    static UINT  s_cchFile;

    if (NULL != pszPhonebook)
        *pszPhonebook = TEXT('\0');

    if (!IsOS(OS_NT5))
        return NULL;

    if (TEXT('\0') == s_szFile[0]) {
        HRESULT hr;

        hr = SHGetFolderPathSimple(CSIDL_APPDATA, s_szFile);
        if (FAILED(hr))
            return NULL;

        PathAppend(s_szFile, TEXT("Microsoft\\Network\\Connections\\Pbk\\rasphone.pbk"));
        if (!PathFileExists(s_szFile))
            return NULL;

        s_cchFile = StrLen(s_szFile);
        Out(LI1(TEXT("Default phone book file is \"%s\"."), s_szFile));
    }
    else
        ASSERT(0 < s_cchFile);

    if (NULL == pszPhonebook || cchPhonebook <= s_cchFile)
        return s_szFile;

    StrCpy(pszPhonebook, s_szFile);
    return pszPhonebook;
}

// NOTE: (andrewgu) this code is stolen from \getconn\icwconn1\desktop.cpp. it should always
// repeat the functionality of GetDesktopDirectory no matter how many bugs.
PCTSTR getConnectToInternetFile(PTSTR pszFile /*= NULL*/, UINT cchFile /*= 0*/)
{
    TCHAR szFile[MAX_PATH],
          szAux [MAX_PATH];

    if (NULL == pszFile)
        return NULL;
    *pszFile = TEXT('\0');

    szFile[0] = TEXT('\0');

    if (IsOS(OS_NT5))
        SHGetFolderPathSimple(CSIDL_DESKTOPDIRECTORY, szFile);

    else if (IsOS(OS_NT))
        SHGetFolderPathSimple(CSIDL_COMMON_DESKTOPDIRECTORY, szFile);

    else {
        FARPROC pfnDllGetVersion;
        HMODULE hShell32Dll;

        pfnDllGetVersion = NULL;

        hShell32Dll = LoadLibrary(TEXT("shell32.dll"));
        if (NULL != hShell32Dll) {
            pfnDllGetVersion = GetProcAddress(hShell32Dll, "DllGetVersion");

            FreeLibrary(hShell32Dll);
        }

        if (NULL != pfnDllGetVersion) {
            TCHAR szFolder[MAX_PATH];

            szFolder[0] = TEXT('\0');
            GetWindowsDirectory(szFolder, countof(szFolder));
            if (TEXT('\0') != szFolder[0]) {
                PathAppend(szFolder, FOLDER_ALLUSERS);

                szAux[0] = TEXT('\0');
                LoadString(g_GetHinst(), IDS_FOLDER_DESKTOP, szAux, countof(szAux));
                if (TEXT('\0') != szAux[0]) {
                    PathAppend(szFolder, szAux);

                    StrCpy(szFile, szFolder);
                }
            }
        }
        else
            SHGetFolderPathSimple(CSIDL_DESKTOPDIRECTORY, szFile);
    }

    if (TEXT('\0') == szFile[0])
        return NULL;

    szAux[0] = TEXT('\0');
    LoadString(g_GetHinst(), IDS_ICW_CONNECTTOINTERNET, szAux, countof(szAux));
    if (TEXT('\0') == szAux[0])
        return NULL;

    PathAddExtension(szAux, TEXT(".lnk"));
    PathAppend(szFile, szAux);

    if (0 < cchFile && cchFile <= (UINT)StrLen(szFile))
        return NULL;

    StrCpy(pszFile, szFile);
    return pszFile;
}


BOOL deleteConnection(PCTSTR pszPhonebook, PCTSTR pszName)
{
    USES_CONVERSION;

    TCHAR szAux[MAX_PATH];
    DWORD cbAux;

    ASSERT(NULL != pszName);

    // delete ras stuff
    if (IsOS(OS_NT)) {
        if (!RasPrepareApis(RPA_RASDELETEENTRYW) || NULL == g_pfnRasDeleteEntryW)
            return FALSE;

        g_pfnRasDeleteEntryW(T2CW(pszPhonebook), T2CW(pszName));
    }
    else {
        if (!RasPrepareApis(RPA_RASDELETEENTRYA) || NULL == g_pfnRasDeleteEntryA)
            return FALSE;

        g_pfnRasDeleteEntryA(T2CA(pszPhonebook), T2CA(pszName));
    }
    RasPrepareApis(RPA_UNLOAD, FALSE);

    // delete wininet stream and advanced wininet stuff
    wnsprintf(szAux, countof(szAux), RK_REMOTEACCESS_PROFILES TEXT("\\%s"), pszName);
    SHDeleteValue(g_GetHKCU(), RK_CONNECTIONS, pszName);
    SHDeleteKey  (g_GetHKCU(), szAux);

    // only do this if deleted connection was set as the default
    // NOTE: (andrewgu) according to darrenmi... we don't even have to do this. ie will handle the
    // situation when default connection name is bogus and will properly fall back to the first
    // one in the phone book;
    szAux[0] = TEXT('\0');
    cbAux    = sizeof(szAux);
    SHGetValue(g_GetHKCU(), RK_REMOTEACCESS, RV_INTERNETPROFILE, NULL, szAux, &cbAux);
    if (0 == StrCmpI(pszName, szAux))
        SHDeleteValue(g_GetHKCU(), RK_REMOTEACCESS, RV_INTERNETPROFILE);

    return TRUE;
}

BOOL rasDeleteEnumProc(PCWSTR pszNameW, LPARAM lParam)
{
    UNREFERENCED_PARAMETER(lParam);

    USES_CONVERSION;

    PCTSTR pszName;
    BOOL   fResult;

    if (NULL == pszNameW)
        return TRUE;                            // nothing to do for LAN

    pszName = W2CT(pszNameW);
    fResult = deleteConnection(NULL, pszName);
    if (fResult)
        Out(LI1(TEXT("Connection \"%s\" was deleted successfully."), pszName));
    else
        Out(LI1(TEXT("! Deleting connection \"%s\" failed."), pszName));

    return TRUE;
}


BOOL cnlAppendNameToList(PCTSTR pszName, HKEY hkCached /*= NULL*/)
{
    PTSTR pszList;
    DWORD cchList, cchName,
          dwResult;
    BOOL  fOwnHk,
          fResult;

    ASSERT(NULL != pszName && TEXT('\0') != *pszName);
    fOwnHk  = FALSE;
    fResult = FALSE;
    pszList = NULL;

    if (NULL == hkCached) {
        dwResult = SHCreateKey(g_GetHKCU(), RK_BRND_CS, KEY_QUERY_VALUE | KEY_SET_VALUE, &hkCached);
        if (ERROR_SUCCESS != dwResult)
            goto Exit;

        fOwnHk = TRUE;
    }

    fResult = cnlGetList(&pszList, &cchList, hkCached);
    if (!fResult)
        goto Exit;

    if (NULL == pszList)                        // the value is not there yet
        cchList = 1;                            // need this for double zero-termination

    else
        if (S_OK == cnlIsNameInList(pszName, pszList)) {
            fResult = TRUE;                     // this name is already in the list
            goto Exit;
        }

    cchName  = StrLen(pszName)+1;
    cchList += cchName;
    pszList  = (PTSTR)CoTaskMemRealloc(pszList, StrCbFromCch(cchList));
    if (NULL == pszList)
        goto Exit;

    ASSERT(cchList-1 >= cchName);
    StrCpy(pszList + cchList-1 - cchName, pszName);
    *(pszList + cchList-1) = TEXT('\0');        // double-zero terminate
    fResult = (ERROR_SUCCESS == RegSetValueEx(hkCached, RV_NAMESLIST, 0, REG_MULTI_SZ, (PBYTE)pszList, StrCbFromCch(cchList)));

Exit:
    if (NULL != pszList)
        CoTaskMemFree(pszList);

    if (fOwnHk)
        SHCloseKey(hkCached);

    return fResult;
}

HRESULT cnlIsNameInList(PCTSTR pszName, PTSTR pszList /*= NULL*/, HKEY hkCached /*= NULL*/)
{
    PCTSTR  pszCur;
    HRESULT hr;
    BOOL    fOwnList;

    ASSERT(NULL != pszName && TEXT('\0') != *pszName);

    fOwnList = (NULL == pszList);
    if (fOwnList) {
        if (!cnlGetList(&pszList, NULL, hkCached))
            return E_FAIL;

        if (NULL == pszList)                    // shortcut:
            return S_FALSE;                     // the value is not there yet
    }

    for (pszCur = pszList; NULL != pszCur && TEXT('\0') != *pszCur; pszCur += StrLen(pszCur)+1)
        if (0 == StrCmpI(pszName, pszCur))
            break;
    hr = (NULL != pszCur && TEXT('\0') != *pszCur) ? S_OK : S_FALSE;

    if (fOwnList && NULL != pszList)
        CoTaskMemFree(pszList);

    return hr;
}

BOOL cnlGetList(PTSTR *ppszList, PDWORD pcchList /*= NULL*/, HKEY hkCached /*= NULL*/)
{
    DWORD cbList,
          dwType, dwResult;
    BOOL  fOwnHk,
          fResult;

    ASSERT(NULL != ppszList);

    *ppszList = NULL;
    if (NULL != pcchList)
        *pcchList = 0;

    fResult = FALSE;
    fOwnHk  = FALSE;

    if (NULL == hkCached) {
        dwResult = SHOpenKey(g_GetHKCU(), RK_BRND_CS, KEY_QUERY_VALUE, &hkCached);
        if (ERROR_SUCCESS != dwResult) {
            fResult = (ERROR_FILE_NOT_FOUND == dwResult);
            goto Exit;
        }

        fOwnHk = TRUE;
    }

    cbList   = 0;
    dwResult = SHQueryValueEx(hkCached, RV_NAMESLIST, NULL, &dwType, NULL, &cbList);
    if (ERROR_SUCCESS != dwResult) {
        fResult = (ERROR_FILE_NOT_FOUND == dwResult);
        goto Exit;
    }
    ASSERT(REG_MULTI_SZ == dwType);

    *ppszList = (PTSTR)CoTaskMemAlloc(cbList);
    if (NULL == *ppszList)
        goto Exit;

    dwResult = SHQueryValueEx(hkCached, RV_NAMESLIST, NULL, NULL, (PBYTE)*ppszList, &cbList);
    ASSERT(ERROR_SUCCESS == dwResult);

    if (NULL != pcchList)
        *pcchList = StrCchFromCb(cbList);

    fResult = TRUE;

Exit:
    if (!fResult && NULL != *ppszList) {
        CoTaskMemFree(*ppszList);
        *ppszList = NULL;
    }

    if (fOwnHk)
        SHCloseKey(hkCached);

    return fResult;
}


BOOL lbBackup()
{   MACRO_LI_PrologEx_C(PIF_STD_C, lbBackup)

    INTERNET_PER_CONN_OPTION_LISTW listW;
    INTERNET_PER_CONN_OPTIONW      rgOptionsW[7];
    PCWSTR pszAuxW;
    PBYTE  pBlob, pCur;
    DWORD  cbBlob;
    UINT   i;

    Out(LI0(TEXT("Creating a backup copy of LAN settings...")));
    pBlob = NULL;

    ZeroMemory(&listW, sizeof(listW));
    listW.dwSize = sizeof(listW);

    ZeroMemory(rgOptionsW, sizeof(rgOptionsW));
    listW.dwOptionCount = countof(rgOptionsW);
    listW.pOptions      = rgOptionsW;

    listW.pOptions[0].dwOption = INTERNET_PER_CONN_FLAGS;
    listW.pOptions[1].dwOption = INTERNET_PER_CONN_PROXY_SERVER;
    listW.pOptions[2].dwOption = INTERNET_PER_CONN_PROXY_BYPASS;
    listW.pOptions[3].dwOption = INTERNET_PER_CONN_AUTOCONFIG_URL;
    listW.pOptions[4].dwOption = INTERNET_PER_CONN_AUTODISCOVERY_FLAGS;
    listW.pOptions[5].dwOption = INTERNET_PER_CONN_AUTOCONFIG_SECONDARY_URL;
    listW.pOptions[6].dwOption = INTERNET_PER_CONN_AUTOCONFIG_RELOAD_DELAY_MINS;

    cbBlob = listW.dwSize;
    if (FALSE == InternetQueryOptionW(NULL, INTERNET_OPTION_PER_CONNECTION_OPTION, &listW, &cbBlob))
        goto Exit;

    //----- Figure out the size of the blob -----
    // size of INTERNET_PER_CONN_OPTION_LIST header
    cbBlob = sizeof(DWORD);                     // listW.dwOptionCount

    // size of INTERNET_PER_CONN_xxx - all of listW.pOptions
    for (i = 0; i < min(listW.dwOptionCount, countof(rgOptionsW)); i++) {
        cbBlob += sizeof(DWORD);

        switch (listW.pOptions[i].dwOption) {
        case INTERNET_PER_CONN_PROXY_SERVER:
        case INTERNET_PER_CONN_PROXY_BYPASS:
        case INTERNET_PER_CONN_AUTOCONFIG_URL:
        case INTERNET_PER_CONN_AUTOCONFIG_SECONDARY_URL:
            pszAuxW  = listW.pOptions[i].Value.pszValue;
            cbBlob += (DWORD)((NULL != pszAuxW) ? StrCbFromSzW(pszAuxW) : sizeof(DWORD));
            break;

        case INTERNET_PER_CONN_FLAGS:
        case INTERNET_PER_CONN_AUTOCONFIG_RELOAD_DELAY_MINS:
        case INTERNET_PER_CONN_AUTODISCOVERY_FLAGS:
            cbBlob += sizeof(DWORD);
            break;

        default:                        // everything else is also DWORD
            cbBlob += sizeof(DWORD);
        }
    }

    pBlob = (PBYTE)CoTaskMemAlloc(cbBlob);
    if (NULL == pBlob)
        goto Exit;
    ZeroMemory(pBlob, cbBlob);

    //----- Copy information into the blob -----
    pCur = pBlob;

    // INTERNET_PER_CONN_OPTION_LISTW header
    *((PDWORD)pCur) = listW.dwOptionCount;      // listW.dwOptionCount
    pCur += sizeof(DWORD);

    // INTERNET_PER_CONN_xxx - all of listW.pOptions
    for (i = 0; i < min(listW.dwOptionCount, countof(rgOptionsW)); i++) {
        *((PDWORD)pCur) = listW.pOptions[i].dwOption;
        pCur += sizeof(DWORD);

        switch (listW.pOptions[i].dwOption) {
        case INTERNET_PER_CONN_PROXY_SERVER:
        case INTERNET_PER_CONN_PROXY_BYPASS:
        case INTERNET_PER_CONN_AUTOCONFIG_URL:
        case INTERNET_PER_CONN_AUTOCONFIG_SECONDARY_URL:
            lbCopySzToBlobW(&pCur, listW.pOptions[i].Value.pszValue);
            break;

        case INTERNET_PER_CONN_FLAGS:
        case INTERNET_PER_CONN_AUTOCONFIG_RELOAD_DELAY_MINS:
        case INTERNET_PER_CONN_AUTODISCOVERY_FLAGS:
            *((PDWORD)pCur) = listW.pOptions[i].Value.dwValue;
            pCur += sizeof(DWORD);
            break;

        default:                        // everything else is also DWORD
            *((PDWORD)pCur) = listW.pOptions[i].Value.dwValue;
            pCur += sizeof(DWORD);
            break;
        }
    }
    ASSERT(pCur == pBlob + cbBlob);

    SHSetValue(g_GetHKCU(), RK_BRND_CS, RV_LANBACKUP, REG_BINARY, pBlob, cbBlob);

Exit:
    if (NULL != pBlob)
        CoTaskMemFree(pBlob);

    if (NULL != listW.pOptions[1].Value.pszValue) // INTERNET_PER_CONN_PROXY_SERVER
        GlobalFree(listW.pOptions[1].Value.pszValue);

    if (NULL != listW.pOptions[2].Value.pszValue) // INTERNET_PER_CONN_PROXY_BYPASS
        GlobalFree(listW.pOptions[2].Value.pszValue);

    if (NULL != listW.pOptions[3].Value.pszValue) // INTERNET_PER_CONN_AUTOCONFIG_URL
        GlobalFree(listW.pOptions[3].Value.pszValue);

    if (NULL != listW.pOptions[5].Value.pszValue) // INTERNET_PER_CONN_AUTOCONFIG_SECONDARY_URL
        GlobalFree(listW.pOptions[5].Value.pszValue);

    Out(LI0(TEXT("Done.\r\n")));
    return TRUE;
}

BOOL lbRestore()
{   MACRO_LI_PrologEx_C(PIF_STD_C, lbRestore)

    INTERNET_PER_CONN_OPTION_LISTW listW;
    INTERNET_PER_CONN_OPTIONW      rgOptionsW[7];
    PBYTE pBlob, pCur;
    HKEY  hk;
    DWORD cbBlob,
          dwResult;
    UINT  i;
    BOOL  fResult;

    Out(LI0(TEXT("Re-setting LAN settings from a backup copy...")));
    pBlob   = NULL;
    fResult = FALSE;

    hk       = NULL;
    dwResult = SHOpenKey(g_GetHKCU(), RK_BRND_CS, KEY_QUERY_VALUE, &hk);
    if (ERROR_SUCCESS != dwResult) {
        fResult = (ERROR_FILE_NOT_FOUND == dwResult);
        goto Exit;
    }

    cbBlob   = 0;
    dwResult = RegQueryValueEx(hk, RV_LANBACKUP, NULL, NULL, NULL, &cbBlob);
    if (ERROR_SUCCESS != dwResult)
        goto Exit;

    pBlob = (PBYTE)CoTaskMemAlloc(cbBlob);
    if (NULL == pBlob)
        goto Exit;
    ZeroMemory(pBlob, cbBlob);

    dwResult = RegQueryValueEx(hk, RV_LANBACKUP, NULL, NULL, pBlob, &cbBlob);
    ASSERT(ERROR_SUCCESS == dwResult);

    pCur = pBlob;

    //----- Main processing -----
    ZeroMemory(&listW, sizeof(listW));
    listW.dwSize   = sizeof(listW);             // listW.dwSize
    listW.pOptions = rgOptionsW;                // listW.pOptions

    // listW.dwOptionCount
    listW.dwOptionCount = *((PDWORD)pCur);
    pCur += sizeof(DWORD);

    // listW.pOptions
    for (i = 0; i < min(listW.dwOptionCount, countof(rgOptionsW)); i++) {
        listW.pOptions[i].dwOption = *((PDWORD)pCur);
        pCur += sizeof(DWORD);

        switch (listW.pOptions[i].dwOption) {
        case INTERNET_PER_CONN_PROXY_SERVER:
        case INTERNET_PER_CONN_PROXY_BYPASS:
        case INTERNET_PER_CONN_AUTOCONFIG_URL:
        case INTERNET_PER_CONN_AUTOCONFIG_SECONDARY_URL:
            setSzFromBlobW(&pCur, &listW.pOptions[i].Value.pszValue);
            break;

        case INTERNET_PER_CONN_FLAGS:
        case INTERNET_PER_CONN_AUTOCONFIG_RELOAD_DELAY_MINS:
        case INTERNET_PER_CONN_AUTODISCOVERY_FLAGS:
            listW.pOptions[i].Value.dwValue = *((PDWORD)pCur);
            pCur += sizeof(DWORD);
            break;

        default:                                // everything else is also DWORD
            listW.pOptions[i].Value.dwValue = *((PDWORD)pCur);
            pCur += sizeof(DWORD);
        }
    }
    ASSERT(pCur == pBlob + cbBlob);

    fResult = InternetSetOptionW(NULL, INTERNET_OPTION_PER_CONNECTION_OPTION, &listW, listW.dwSize);

Exit:
    if (NULL != pBlob)
        CoTaskMemFree(pBlob);

    SHCloseKey(hk);

    Out(LI0(TEXT("Done.")));
    return fResult;
}

inline void lbCopySzToBlobW(PBYTE *ppBlob, PCWSTR pszStrW)
{
    ASSERT(NULL != ppBlob && NULL != *ppBlob);

    if (NULL == pszStrW) {
        *((PDWORD)(*ppBlob)) = (DWORD)NULL;
        *ppBlob += sizeof(DWORD);
    }
    else {
        StrCpyW((PWSTR)(*ppBlob), pszStrW);
        *ppBlob += StrCbFromSzW(pszStrW);
    }
}


BOOL raBackup()
{   MACRO_LI_PrologEx_C(PIF_STD_C, raBackup)

    HRESULT hr;
    BOOL    fResult;

    Out(LI0(TEXT("Creating a backup copy of Dial-Up settings...")));
    fResult = TRUE;

    hr = SHCopyValue(g_GetHKCU(), RK_INETSETTINGS, g_GetHKCU(), RK_BRND_CS, RV_ENABLESECURITYCHECK);
    fResult = fResult ? SUCCEEDED(hr) : FALSE;

    hr = SHCopyValue(g_GetHKCU(), RK_INETSETTINGS, g_GetHKCU(), RK_BRND_CS, RV_ENABLEAUTODIAL);
    fResult = fResult ? SUCCEEDED(hr) : FALSE;

    hr = SHCopyValue(g_GetHKCU(), RK_INETSETTINGS, g_GetHKCU(), RK_BRND_CS, RV_NONETAUTODIAL);
    fResult = fResult ? SUCCEEDED(hr) : FALSE;

    Out(LI0(TEXT("Done.")));
    return fResult;
}

BOOL raRestore()
{   MACRO_LI_PrologEx_C(PIF_STD_C, raRestore)

    HRESULT hr;
    BOOL    fResult;

    // NOTE: (andrewgu) oliverl wanted me to note that we don't need to do anything about HKCC
    // stuff as per darrenmi win2000 shell doesn't care much for it.
    Out(LI0(TEXT("Re-setting Dial-Up settings from a backup copy...")));
    fResult = TRUE;

    hr = SHCopyValue(g_GetHKCU(), RK_BRND_CS, g_GetHKCU(), RK_INETSETTINGS, RV_ENABLESECURITYCHECK);
    if (STG_E_FILENOTFOUND == hr) {
        SHDeleteValue(g_GetHKCU(), RK_INETSETTINGS, RV_ENABLESECURITYCHECK);
        hr = S_OK;
    }
    fResult = fResult ? SUCCEEDED(hr) : FALSE;

    hr = SHCopyValue(g_GetHKCU(), RK_BRND_CS, g_GetHKCU(), RK_INETSETTINGS, RV_ENABLEAUTODIAL);
    if (STG_E_FILENOTFOUND == hr) {
        SHDeleteValue(g_GetHKCU(), RK_INETSETTINGS, RV_ENABLEAUTODIAL);
        hr = S_OK;
    }
    fResult = fResult ? SUCCEEDED(hr) : FALSE;

    hr = SHCopyValue(g_GetHKCU(), RK_BRND_CS, g_GetHKCU(), RK_INETSETTINGS, RV_NONETAUTODIAL);
    if (STG_E_FILENOTFOUND == hr) {
        SHDeleteValue(g_GetHKCU(), RK_INETSETTINGS, RV_NONETAUTODIAL);
        hr = S_OK;
    }
    fResult = fResult ? SUCCEEDED(hr) : FALSE;

    Out(LI0(TEXT("Done.")));
    return fResult;
}


HRESULT importRasSettings(PCWSTR pszNameW, PBYTE *ppBlob, LPRASDEVINFOW prdiW, UINT cDevices)
{   MACRO_LI_PrologEx_C(PIF_STD_C, importRasSettings)

    USES_CONVERSION;

    LPRASENTRYW preW;
    TCHAR   szTargetScript[MAX_PATH];
    PWSTR   pszScriptW;
    PBYTE   pCur;
    HRESULT hr;
    DWORD   dwSize, cbRasEntry,
            dwResult;
    UINT    i;
    BOOL    fImpersonate;

    ASSERT(RasIsInstalled());
    ASSERT(pszNameW != NULL && ppBlob != NULL && *ppBlob != NULL && prdiW != NULL && cDevices >= 1);

    //----- Validate the header -----
    pCur = *ppBlob;
    if (*((PDWORD)pCur) != CS_STRUCT_RAS)
        return E_UNEXPECTED;
    pCur += sizeof(DWORD);

    fImpersonate = FALSE;
    if (g_CtxIsGp())
        fImpersonate = ImpersonateLoggedOnUser(g_GetUserToken());

    Out(LI0(TEXT("Processing RAS settings...")));
    hr = E_FAIL;

    dwSize = *((PDWORD)pCur);
    pCur  += sizeof(DWORD);

    //----- Main processing -----
    preW = (LPRASENTRYW)pCur;

    // NOTE: (andrewgu) the is a remote possibility that sizes of RASENTRYW structure are
    // different on the server and client machines. there is nothing bad with server structure
    // being smaller than the client structure (all RAS apis are backward-compatible). it's bad
    // though when server structure is bigger than client can handle, hence the trancation.
    // (something else to have in mind) this truncation should not affect alternate phone numbers
    // support on winnt.
    if (preW->dwSize > sizeof(RASENTRYW))
        preW->dwSize = sizeof(RASENTRYW);

    // preW->szScript
    if (preW->szScript[0] != L'\0') {
        pszScriptW = preW->szScript;
        if (preW->szScript[0] == L'[')
            pszScriptW = &preW->szScript[1];

        PathCombine(szTargetScript, g_GetTargetPath(), PathFindFileName(W2CT(pszScriptW)));
        if (PathFileExists(szTargetScript))
            StrCpyW(preW->szScript, T2CW(szTargetScript));
        else
            preW->szScript[0] = L'\0';
    }

    // preW->szDeviceName
    for (i = 0; i < cDevices; i++) {
        if (0 == StrCmpIW(preW->szDeviceType, prdiW[i].szDeviceType)) {
            StrCpyW(preW->szDeviceName, prdiW[i].szDeviceName);
            break;
        }
    }
    if (i >= cDevices)
        StrCpyW(preW->szDeviceName, prdiW[0].szDeviceName);

    Out(LI1(TEXT("Set the device name to \"%s\"."), W2CT(preW->szDeviceName)));

    //----- Call into the RAS dll -----
    cbRasEntry = dwSize - 2*sizeof(DWORD);
    dwResult   = RasSetEntryPropertiesWrap(getPhonebookFile(), pszNameW, preW, cbRasEntry);
    if (dwResult != ERROR_SUCCESS) {
        Out(LI1(TEXT("! Creating this RAS connection failed with %s."), GetHrSz(dwResult)));
        goto Exit;
    }

    hr = S_OK;

Exit:
    *ppBlob += dwSize;

    Out(LI0(TEXT("Done.")));
    if (fImpersonate)
        RevertToSelf();

    return hr;
}

HRESULT importRasCredentialsSettings(PCWSTR pszNameW, PBYTE *ppBlob)
{   MACRO_LI_PrologEx_C(PIF_STD_C, importRasCredentialsSettings)

    USES_CONVERSION;

    RASDIALPARAMSW rdpW;
    PWSTR   pszAuxW;
    PBYTE   pCur;
    HRESULT hr;
    DWORD   dwSize,
            dwResult;
    BOOL    fDeletePassword,
            fImpersonate;

    ASSERT(RasIsInstalled());
    ASSERT(pszNameW != NULL && ppBlob != NULL && *ppBlob != NULL);

    //----- Validate the header -----
    pCur = *ppBlob;
    if (*((PDWORD)pCur) != CS_STRUCT_RAS_CREADENTIALS)
        return E_UNEXPECTED;
    pCur += sizeof(DWORD);

    fImpersonate = FALSE;
    if (g_CtxIsGp())
        fImpersonate = ImpersonateLoggedOnUser(g_GetUserToken());

    Out(LI0(TEXT("Processing RAS credentials settings...")));
    hr              = E_FAIL;
    fDeletePassword = FALSE;

    dwSize = *((PDWORD)pCur);
    pCur  += sizeof(DWORD);

    //----- Main processing -----
    ZeroMemory(&rdpW, sizeof(rdpW));
    rdpW.dwSize = sizeof(rdpW);

    StrCpyW(rdpW.szEntryName, pszNameW);

    setSzFromBlobW(&pCur, &pszAuxW);
    if (NULL != pszAuxW)
        StrCpyW(rdpW.szUserName, pszAuxW);

    setSzFromBlobW(&pCur, &pszAuxW);
    if (NULL != pszAuxW)
        StrCpyW(rdpW.szPassword, pszAuxW);

    setSzFromBlobW(&pCur, &pszAuxW);
    if (NULL != pszAuxW)
        StrCpyW(rdpW.szDomain, pszAuxW);

    if (rdpW.szPassword[0] == L'\0')
        fDeletePassword = TRUE;

    if (rdpW.szDomain[0] == L'\0') {
        rdpW.szDomain[0]  = L' ';
        ASSERT(rdpW.szDomain[1] == L'\0');
    }

    //----- Call into the RAS dll -----
    dwResult = RasSetEntryDialParamsWrap(getPhonebookFile(), &rdpW, fDeletePassword);
    if (dwResult != ERROR_SUCCESS) {
        Out(LI1(TEXT("! Setting RAS credentials for this connection failed with %s."), GetHrSz(dwResult)));
        goto Exit;
    }

    hr = S_OK;

Exit:
    Out(LI0(TEXT("Done.")));
    *ppBlob += dwSize;
    if (fImpersonate)
        RevertToSelf();

    return hr;
}

HRESULT importWininetSettings(PCWSTR pszNameW, PBYTE *ppBlob)
{   MACRO_LI_PrologEx_C(PIF_STD_C, importWininetSettings)

    USES_CONVERSION;

    INTERNET_PER_CONN_OPTION_LISTW listW;
    INTERNET_PER_CONN_OPTIONW      rgOptionsW[7];
    PBYTE   pCur;
    HRESULT hr;
    DWORD   dwSize;
    UINT    i;

    ASSERT(ppBlob != NULL && *ppBlob != NULL);

    //----- Validate the header -----
    pCur = *ppBlob;
    if (*((PDWORD)pCur) != CS_STRUCT_WININET)
        return E_UNEXPECTED;
    pCur += sizeof(DWORD);

    Out(LI0(TEXT("Processing Wininet.dll settings...")));
    hr = E_FAIL;

    dwSize = *((PDWORD)pCur);
    pCur  += sizeof(DWORD);

    //----- Main processing -----
    ZeroMemory(&listW, sizeof(listW));
    listW.dwSize   = sizeof(listW);             // listW.dwSize
    listW.pOptions = rgOptionsW;                // listW.pOptions

    // listW.pszConnection
    listW.pszConnection = (PWSTR)pszNameW;

    // listW.dwOptionCount
    listW.dwOptionCount = *((PDWORD)pCur);
    pCur += sizeof(DWORD);

    // listW.pOptions
    for (i = 0; i < min(listW.dwOptionCount, countof(rgOptionsW)); i++) {
        listW.pOptions[i].dwOption = *((PDWORD)pCur);
        pCur += sizeof(DWORD);

        switch (listW.pOptions[i].dwOption) {
        case INTERNET_PER_CONN_PROXY_SERVER:
        case INTERNET_PER_CONN_PROXY_BYPASS:
        case INTERNET_PER_CONN_AUTOCONFIG_URL:
        case INTERNET_PER_CONN_AUTOCONFIG_SECONDARY_URL:
            setSzFromBlobW(&pCur, &listW.pOptions[i].Value.pszValue);
            break;

        case INTERNET_PER_CONN_FLAGS:
        case INTERNET_PER_CONN_AUTOCONFIG_RELOAD_DELAY_MINS:
        case INTERNET_PER_CONN_AUTODISCOVERY_FLAGS:
        default:                        // everything else is also DWORD
            listW.pOptions[i].Value.dwValue = *((PDWORD)pCur);
            pCur += sizeof(DWORD);
            break;
        }
    }
    ASSERT(pCur == *ppBlob + dwSize);

    if (HasFlag(g_GetContext(), (CTX_ISP | CTX_ICP))) {
        ASSERT(listW.pOptions[0].dwOption == INTERNET_PER_CONN_FLAGS);

        if (HasFlag(listW.pOptions[0].Value.dwValue, PROXY_TYPE_PROXY)) {
            DWORD dwFlags;

            dwFlags  = getWininetFlagsSetting(W2CT(listW.pszConnection));
            dwFlags |= listW.pOptions[0].Value.dwValue;
            listW.pOptions[0].Value.dwValue = dwFlags;
        }
        else {
            hr = S_OK;                            // nothing to do since had only proxy stuff to
            Out(LI0(TEXT("No customizations!"))); // begin with. and now even that is not there
            goto Exit;
        }
    }

    //----- Merge new LAN's ProxyBypass settings with the existing ones -----
    // NOTE: (andrewgu) since ieakeng.dll will always save the proxy information into the
    // ins file as well, it makes no sense to do this here because what's in the ins
    // should overwrite what's in the imported connections settings.

    //----- Call into Wininet.dll -----
    if (FALSE == InternetSetOptionW(NULL, INTERNET_OPTION_PER_CONNECTION_OPTION, &listW, listW.dwSize)) {
        Out(LI0(TEXT("! Processing of this Wininet.dll connection settings failed.")));
        goto Exit;
    }

    hr = S_OK;

Exit:
    Out(LI0(TEXT("Done.")));
    *ppBlob += dwSize;
    return hr;
}


inline void setSzFromBlobA(PBYTE *ppBlob, UNALIGNED CHAR **ppszStrA)
{
    ASSERT(ppBlob != NULL && *ppBlob != NULL && ppszStrA != NULL);

    if ((**ppBlob) == NULL) {
        (*ppszStrA) = NULL;
        (*ppBlob)  += sizeof(DWORD);
    }
    else {
        (*ppszStrA) = (PSTR)(*ppBlob);
        (*ppBlob)  += StrCbFromSzA(*ppszStrA);
    }
}

inline void setSzFromBlobW(PBYTE *ppBlob, UNALIGNED WCHAR **ppszStrW)
{
    ASSERT(ppBlob != NULL && *ppBlob != NULL && ppszStrW != NULL);

    if ((**ppBlob) == NULL) {
        (*ppszStrW) = NULL;
        (*ppBlob)  += sizeof(DWORD);
    }
    else {
        (*ppszStrW) = (PWSTR)(*ppBlob);
        (*ppBlob)  += StrCbFromSzUAW(*ppszStrW);
    }
}


HRESULT insProcessAutoconfig(PCTSTR pszName)
{   MACRO_LI_PrologEx_C(PIF_STD_C, insProcessAutoconfig)

    INTERNET_PER_CONN_OPTION_LIST list;
    INTERNET_PER_CONN_OPTION      rgOptions[4];
    TCHAR   szAutoConfigURL[INTERNET_MAX_URL_LENGTH],
            szAutoProxyURL [INTERNET_MAX_URL_LENGTH];
    HRESULT hr;
    DWORD   dwTime;
    int     iDetectConfig,
            iAutoConfig;

    Out(LI0(TEXT("Processing autoconfig settings from the ins file...")));

    szAutoConfigURL[0] = TEXT('\0');
    szAutoProxyURL [0] = TEXT('\0');
    hr                 = S_OK;
    dwTime             = 0;
    iDetectConfig      = InsGetInt(IS_URL, IK_DETECTCONFIG, -1, g_GetIns());
    iAutoConfig        = InsGetInt(IS_URL, IK_USEAUTOCONF,  -1, g_GetIns());

    if (iDetectConfig == -1 && iAutoConfig == -1) {
        Out(LI0(TEXT("Autoconfiguration settings are not customized!")));
        hr = S_FALSE;
        goto Exit;
    }

    if (iAutoConfig == (int)TRUE) {
        if (InsGetBool(IS_URL, IK_LOCALAUTOCONFIG, FALSE, g_GetIns())) {
            StrCpy(szAutoConfigURL, FILEPREFIX);
            StrCat(szAutoConfigURL, g_GetIns());
        }
        else
            InsGetString(IS_URL, IK_AUTOCONFURL, szAutoConfigURL, countof(szAutoConfigURL), g_GetIns());

        InsGetString(IS_URL, IK_AUTOCONFURLJS, szAutoProxyURL, countof(szAutoProxyURL), g_GetIns());
        dwTime = InsGetInt(IS_URL, IK_AUTOCONFTIME, 0, g_GetIns());
    }

    ZeroMemory(&list, sizeof(list));
    list.dwSize = sizeof(list);

    list.pszConnection = NULL;
    if (pszName != NULL && *pszName != TEXT('\0'))
        list.pszConnection = (PTSTR)pszName;

    list.pOptions = rgOptions;

    ZeroMemory(rgOptions, sizeof(rgOptions));

    if (iAutoConfig == -1) {
        ASSERT(iDetectConfig == (int)FALSE || iDetectConfig == (int)TRUE);
        list.dwOptionCount = 1;

        rgOptions[0].dwOption      = INTERNET_PER_CONN_FLAGS;
        rgOptions[0].Value.dwValue = getWininetFlagsSetting();
        SetFlag(&rgOptions[0].Value.dwValue, PROXY_TYPE_AUTO_DETECT, FALSE);
        SetFlag(&rgOptions[0].Value.dwValue, ((iDetectConfig == (int)TRUE) ? PROXY_TYPE_AUTO_DETECT : 0));
        Out(LI1(TEXT("\"Flags\" is set to 0x%lX."), rgOptions[0].Value.dwValue));
    }
    else {
        list.dwOptionCount = countof(rgOptions);

        rgOptions[0].dwOption      = INTERNET_PER_CONN_FLAGS;
        rgOptions[0].Value.dwValue = getWininetFlagsSetting();
        SetFlag(&rgOptions[0].Value.dwValue, PROXY_TYPE_AUTO_PROXY_URL, FALSE);
        SetFlag(&rgOptions[0].Value.dwValue, ((iAutoConfig == (int)TRUE) ? PROXY_TYPE_AUTO_PROXY_URL : 0));
        if (iDetectConfig != -1) {
            ASSERT(iDetectConfig == (int)FALSE || iDetectConfig == (int)TRUE);

            SetFlag(&rgOptions[0].Value.dwValue, PROXY_TYPE_AUTO_DETECT, FALSE);
            SetFlag(&rgOptions[0].Value.dwValue, ((iDetectConfig == (int)TRUE) ? PROXY_TYPE_AUTO_DETECT : 0));
        }
        Out(LI1(TEXT("\"Flags\" is set to 0x%lX."), rgOptions[0].Value.dwValue));

        rgOptions[1].dwOption       = INTERNET_PER_CONN_AUTOCONFIG_URL;
        rgOptions[1].Value.pszValue = szAutoConfigURL;

        rgOptions[2].dwOption       = INTERNET_PER_CONN_AUTOCONFIG_SECONDARY_URL;
        rgOptions[2].Value.pszValue = szAutoProxyURL;

        if (szAutoConfigURL[0] == TEXT('\0') && szAutoProxyURL[0] != TEXT('\0')) {
            rgOptions[1].Value.pszValue = szAutoProxyURL;
            rgOptions[2].Value.pszValue = TEXT("");
        }
        Out(LI1(TEXT("\"Autoconfig URL\" is set to \"%s\"."), rgOptions[1].Value.pszValue));
        Out(LI1(TEXT("\"Autoproxy URL\" is set to \"%s\"."),  rgOptions[2].Value.pszValue));

        rgOptions[3].dwOption      = INTERNET_PER_CONN_AUTOCONFIG_RELOAD_DELAY_MINS;
        rgOptions[3].Value.dwValue = dwTime;
        Out(LI1(TEXT("\"Autoconfig reload delay\" is set to %u minutes."), rgOptions[3].Value.dwValue));
    }

    if (FALSE == InternetSetOption(NULL, INTERNET_OPTION_PER_CONNECTION_OPTION, &list, list.dwSize)) {
        Out(LI0(TEXT("! Internal failure.")));
        hr = E_FAIL;
    }

Exit:
    Out(LI0(TEXT("Done.")));
    return hr;
}

HRESULT insProcessProxy(PCTSTR pszName)
{   MACRO_LI_PrologEx_C(PIF_STD_C, insProcessProxy)

    INTERNET_PER_CONN_OPTION_LIST list;
    INTERNET_PER_CONN_OPTION      rgOptions[3];
    TCHAR   szProxy[MAX_PATH], szHttpProxy[MAX_PATH],
            szProxyBypass[MAX_STRING];
    TCHAR   *pszProxy = NULL;
    HRESULT hr;
    int     iUseProxy;
    BOOL    fUseSameProxy = FALSE;

    Out(LI0(TEXT("Processing proxy settings from the ins file...")));
    hr = S_OK;

    iUseProxy = InsGetInt(IS_PROXY, IK_PROXYENABLE, -1, g_GetIns());
    if (iUseProxy == -1) {
        Out(LI0(TEXT("Proxy settings are not customized!")));
        hr = S_FALSE;
        goto Exit;
    }
    ASSERT(iUseProxy == (int)FALSE || iUseProxy == (int)TRUE);

    InsGetString(IS_PROXY, IK_HTTPPROXY, szHttpProxy, countof(szHttpProxy), g_GetIns());

    fUseSameProxy = InsGetBool(IS_PROXY, IK_SAMEPROXY, FALSE, g_GetIns());
    if (fUseSameProxy)
    {
        StrCpy(szProxy , szHttpProxy);
        pszProxy = szProxy;
    }
    else {
        TCHAR szSecureProxy[MAX_PATH],
              szFtpProxy   [MAX_PATH],
              szGopherProxy[MAX_PATH],
              szSocksProxy [MAX_PATH];

        pszProxy = (TCHAR*)CoTaskMemAlloc(StrCbFromCch(5*(MAX_PATH+1) + 64));
        if (pszProxy == NULL)
        {
            Out(LI0(TEXT("! Internal processing ran out of memory.")));
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
        ZeroMemory(pszProxy, StrCbFromCch(5*(MAX_PATH+1) + 64));
        InsGetString(IS_PROXY, IK_SECPROXY,    szSecureProxy, countof(szSecureProxy), g_GetIns());
        InsGetString(IS_PROXY, IK_FTPPROXY,    szFtpProxy,    countof(szFtpProxy),    g_GetIns());
        InsGetString(IS_PROXY, IK_GOPHERPROXY, szGopherProxy, countof(szGopherProxy), g_GetIns());
        InsGetString(IS_PROXY, IK_SOCKSPROXY,  szSocksProxy,  countof(szSocksProxy),  g_GetIns());

        pszProxy[0] = TEXT('\0');
        if (szHttpProxy[0] != TEXT('\0')) {
            StrCat(pszProxy, TEXT("http="));
            StrCat(pszProxy, szHttpProxy);
            StrCat(pszProxy, TEXT(";"));
        }

        if (szSecureProxy[0] != TEXT('\0')) {
            StrCat(pszProxy, TEXT("https="));
            StrCat(pszProxy, szSecureProxy);
            StrCat(pszProxy, TEXT(";"));
        }

        if (szFtpProxy[0] != TEXT('\0')) {
            StrCat(pszProxy, TEXT("ftp="));
            StrCat(pszProxy, szFtpProxy);
            StrCat(pszProxy, TEXT(";"));
        }

        if (szGopherProxy[0] != TEXT('\0')) {
            StrCat(pszProxy, TEXT("gopher="));
            StrCat(pszProxy, szGopherProxy);
            StrCat(pszProxy, TEXT(";"));
        }

        if (szSocksProxy[0] != TEXT('\0')) {
            StrCat(pszProxy, TEXT("socks="));
            StrCat(pszProxy, szSocksProxy);
        }

        if (pszProxy[StrLen(pszProxy) - 1] == TEXT(';'))
            pszProxy[StrLen(pszProxy) - 1]  = TEXT('\0');
    }

    InsGetString(IS_PROXY, IK_PROXYOVERRIDE, szProxyBypass, countof(szProxyBypass), g_GetIns());

    ZeroMemory(&list, sizeof(list));
    list.dwSize = sizeof(list);

    list.pszConnection = NULL;
    if (pszName != NULL && *pszName != TEXT('\0'))
        list.pszConnection = (PTSTR)pszName;

    if (HasFlag(g_GetContext(), (CTX_ISP | CTX_ICP)))
        if (szProxyBypass[0] != TEXT('\0')) {
            TCHAR szMerged[MAX_STRING];

            mergeProxyBypass(pszName, szProxyBypass, szMerged, countof(szMerged));
            if (szMerged[0] != TEXT('\0'))
                StrCpy(szProxyBypass, szMerged);
        }

    list.dwOptionCount = countof(rgOptions);
    list.pOptions      = rgOptions;

    ZeroMemory(&rgOptions, sizeof(rgOptions));
    rgOptions[0].dwOption       = INTERNET_PER_CONN_FLAGS;
    rgOptions[0].Value.dwValue  = getWininetFlagsSetting(pszName);
    SetFlag(&rgOptions[0].Value.dwValue, PROXY_TYPE_PROXY, FALSE);
    SetFlag(&rgOptions[0].Value.dwValue, ((BOOL)iUseProxy ? PROXY_TYPE_PROXY : 0));
    Out(LI1(TEXT("\"Flags\" is set to 0x%lX."), rgOptions[0].Value.dwValue));

    rgOptions[1].dwOption       = INTERNET_PER_CONN_PROXY_SERVER;
    rgOptions[1].Value.pszValue = pszProxy;
    Out(LI1(TEXT("\"ProxyServer\" is set to \"%s\"."), rgOptions[1].Value.pszValue));

    rgOptions[2].dwOption       = INTERNET_PER_CONN_PROXY_BYPASS;
    rgOptions[2].Value.pszValue = szProxyBypass;
    Out(LI1(TEXT("\"ProxyBypass\" is set to \"%s\"."), rgOptions[2].Value.pszValue));

    if (FALSE == InternetSetOption(NULL, INTERNET_OPTION_PER_CONNECTION_OPTION, &list, list.dwSize)) {
        Out(LI0(TEXT("! Processing of this Wininet.dll connection settings failed.")));
        hr = E_FAIL;
    }

Exit:
    if (!fUseSameProxy && (pszProxy != NULL))
        CoTaskMemFree(pszProxy);
    Out(LI0(TEXT("Done.")));
    return hr;
}


DWORD getWininetFlagsSetting(PCTSTR pszName /*= NULL*/)
{
    INTERNET_PER_CONN_OPTION_LIST list;
    INTERNET_PER_CONN_OPTION      option;
    DWORD dwResult,
          dwSize;

    dwResult = 0;

    ZeroMemory(&list, sizeof(list));
    list.dwSize        = sizeof(list);
    list.pszConnection = (PTSTR)pszName;
    list.dwOptionCount = 1;
    list.pOptions      = &option;

    ZeroMemory(&option, sizeof(option));
    option.dwOption = INTERNET_PER_CONN_FLAGS;

    dwSize = list.dwSize;
    if (TRUE == InternetQueryOption(NULL, INTERNET_OPTION_PER_CONNECTION_OPTION, &list, &dwSize))
        dwResult = option.Value.dwValue;

    return dwResult;
}

BOOL mergeProxyBypass(PCTSTR pszName, PCTSTR pszProxyBypass, PTSTR pszResult, UINT cchResult)
{   MACRO_LI_PrologEx_C(PIF_STD_C, mergeProxyBypass)

    static const TCHAR s_szLocal[] = LOCALPROXY;

    INTERNET_PER_CONN_OPTION_LIST list;
    INTERNET_PER_CONN_OPTION      option;
    TCHAR szBuf[MAX_STRING];
    PTSTR pszNew, pszOld,
          pszCur, pszNext,
          pszToken, pszAux;
    DWORD dwSize;
    UINT  nLen, nTokenLen;
    BOOL  fResult,
          fHasLocal;

    if (pszResult == NULL)
        return FALSE;
    *pszResult = TEXT('\0');

    fResult = FALSE;

    ASSERT(StrLen(pszProxyBypass) < countof(szBuf));
    szBuf[0] = TEXT('\0');
    StrCpy(szBuf, pszProxyBypass);
    pszNew   = szBuf;

    // REVIEW: (andrewgu) which one takes precedence: pszNew or pszOld?
    Out(LI1(TEXT("New \"ProxyBypass\" settings are \"%s\"."), pszNew));
    trimProxyBypass(pszNew);

    ZeroMemory(&list, sizeof(list));
    list.dwSize = sizeof(list);

    list.pszConnection = NULL;
    if (pszName != NULL && *pszName != TEXT('\0'))
        list.pszConnection = (PTSTR)pszName;

    list.dwOptionCount = 1;
    list.pOptions      = &option;

    ZeroMemory(&option, sizeof(option));
    option.dwOption = INTERNET_PER_CONN_PROXY_BYPASS;

    pszOld = NULL;
    dwSize = list.dwSize;
    if (FALSE == InternetQueryOption(NULL, INTERNET_OPTION_PER_CONNECTION_OPTION, &list, &dwSize)) {
        Out(LI0(TEXT("! Retrieving existing \"ProxyBypass\" settings failed.")));
        goto Exit;
    }

    pszOld = option.Value.pszValue;
    Out(LI1(TEXT("Existing \"ProxyBypass\" settings are \"%s\"."), (NULL != pszOld) ? pszOld : TEXT("")));

    if (pszOld == NULL || *pszOld == TEXT('\0'))
        goto SetOutParams;

    trimProxyBypass(pszOld);

    // make sure that at least the old setting will fit in the out-param
    if (cchResult != 0 && (UINT)StrLen(pszOld) >= cchResult) {
        ASSERT(FALSE);
        goto Exit;
    }

    //----- Deal with <local> -----
    Out(LI0(TEXT("Merging existing and new \"ProxyBypass\" settings...")));

    // NOTE: (andrewgu) This processing is needed based on the perception that <local> has to be
    // at the end (the very last token)
    fHasLocal = FALSE;

    pszAux = StrStrI(pszOld, s_szLocal);
    if (pszAux != NULL) {
        // remove <local>, including trailing ';' if any
        nLen = countof(s_szLocal)-1;
        if (*(pszAux + nLen) == TEXT(';'))
            nLen++;
        StrCpy(pszAux, pszAux + nLen);

        fHasLocal = TRUE;
    }

    pszAux = StrStrI(pszNew, s_szLocal);
    if (pszAux != NULL) {
        // remove <local>, including trailing ';' if any
        nLen = countof(s_szLocal)-1;
        if (*(pszAux + nLen) == TEXT(';'))
            nLen++;
        StrCpy(pszAux, pszAux + nLen);

        fHasLocal = TRUE;
    }

    //----- Main Loop -----
    for (pszCur = pszNew; pszCur != NULL && *pszCur != TEXT('\0'); pszCur = pszNext) {

        //_____ Form token in pszNew (zero terminated) pointed to by pszCur _____
        pszNext = StrChr(pszCur, TEXT(';'));
        if (pszNext != NULL) {
            *pszNext  = TEXT('\0');
            nTokenLen = UINT(pszNext - pszCur);

            pszNext++;
            ASSERT(*pszNext != TEXT(';'));      // due to trimProxyBypass
        }
        else
            nTokenLen = StrLen(pszCur);

        //_____ Find this token in pszOld _____
        ASSERT(*pszCur != TEXT('\0'));          // a little involved, but true

        pszToken = StrStrI(pszOld, pszCur);
        if (pszToken != NULL) {
            ASSERT(nTokenLen <= (UINT)StrLen(pszToken));
            pszAux = pszToken + nTokenLen;

            if ((pszToken == pszOld || *(pszToken - 1) == TEXT(';')) &&
                (*pszAux == TEXT(';') || *pszAux == TEXT('\0'))) {

                if (*pszAux == TEXT(';'))
                    // copy the tail on top of pszToken
                    StrCpy(pszToken, pszToken + nTokenLen+1);

                else /* if (*pszAux == TEXT('\0')) */
                    // simply zero terminate
                    if (pszToken > pszOld) {
                        ASSERT(*(pszToken-1) == TEXT(';'));
                        *(pszToken-1) = TEXT('\0');
                    }
                    else 
                        *pszToken = TEXT('\0');
            }
        }

        //_____ Restore separator in pszNew _____
        if (pszNext != NULL) {
            pszAux = pszCur + nTokenLen;
            ASSERT(pszAux == pszNext - 1);      // due to trimProxyBypass
            ASSERT(*pszAux == TEXT('\0'));
            *pszAux = TEXT(';');
        }

        if (*pszOld == TEXT('\0'))
            break;
    }

    //----- Endgame -----
    pszAux = NULL;
    nLen   = StrLen(pszNew);
    nLen  += (*pszOld != TEXT('\0')) ? (1 + StrLen(pszOld)) : 0;
    nLen  += (UINT)(fHasLocal               ?   countof(s_szLocal) : 0);

    // if the combined setting won't fit, fall back and return the old setting
    if (cchResult != 0 && nLen >= cchResult) {
        ASSERT(FALSE);
        pszNew = pszOld;                        // repoint pszNew
        goto SetOutParams;
    }

    if (nLen >= countof(szBuf)) {
        pszAux = (PTSTR)CoTaskMemAlloc(nLen + 1);
        if (pszAux != NULL) {
            ZeroMemory(pszAux, nLen + 1);
            StrCpy(pszAux, pszNew);
            pszNew = pszAux;                    // repoint pszNew
        }
    }

    if (*pszOld != TEXT('\0')) {
        StrCat(pszNew, TEXT(";"));
        StrCat(pszNew, pszOld);
    }

    if (fHasLocal) {
        StrCat(pszNew, TEXT(";"));
        StrCat(pszNew, s_szLocal);
    }

SetOutParams:
    if (cchResult != 0 && (UINT)StrLen(pszNew) >= cchResult)
        goto Exit;

    StrCpy(pszResult, pszNew);
    Out(LI1(TEXT("The final \"ProxyBypass\" settings are \"%s\"."), pszResult));

    fResult = TRUE;

Exit:
    if (pszNew != szBuf && pszNew != pszOld)    // pszNew has been CoTaskMemAlloc'ed
        CoTaskMemFree(pszNew);

    if (pszOld != NULL)
        GlobalFree(pszOld);

    return fResult;
}

void trimProxyBypass(PTSTR pszProxyBypass)
{
    PTSTR pszOld, pszNew, pszToken;

    ASSERT(pszProxyBypass != NULL);

    for (pszToken = pszNew = pszOld  = pszProxyBypass;
         pszNew  != NULL && *pszNew != TEXT('\0');
         pszToken = pszNew) {

        pszNew = StrChr(pszToken, TEXT(';'));
        if (pszNew != NULL) {
            *pszNew  = TEXT('\0');
            pszNew  += 1 + StrSpn(pszNew + 1, TEXT(";"));
        }

        StrRemoveWhitespace(pszToken);
        if (*pszToken == TEXT('\0'))
            continue;
        ASSERT(pszToken >= pszOld);

        if (pszOld > pszProxyBypass) {
            ASSERT(*pszOld == TEXT('\0'));
            *pszOld++ = TEXT(';');
        }

        StrCpy(pszOld, pszToken);
        pszOld += StrLen(pszToken);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\brandll\brandaux.cpp ===
#include "precomp.h"

// Private forward decalarations
#define WM_DO_UPDATEALL (WM_USER + 338)

#define TRUSTED_PUB_FLAG    0x00040000

LPCTSTR rtgGetRatingsFile(LPTSTR pszFile = NULL, UINT cch = 0);
void broadcastSettingsChange(LPVOID lpVoid);

// NOTE: (andrewgu) i haven't touched these functions. i merely ported them and moved them around.
BOOL rtgIsRatingsInRegistry();
void rtgRegMoveRatings();

BOOL IsInGUIModeSetup();


HRESULT ProcessZonesReset()
{   MACRO_LI_PrologEx_C(PIF_STD_C, ProcessZonesReset)

    HINSTANCE hUrlmonDLL;

    Out(LI0(TEXT("\r\nProcessing reset of zones settings...")));

    // Don't write to HKCU if in GUI-mode setup
    if (IsInGUIModeSetup())
    {
        Out(LI0(TEXT("\r\nIn GUI mode setup, skipping urlmon HKCU settings")));
        goto quit;
    }

    if ((hUrlmonDLL = LoadLibrary(TEXT("urlmon.dll"))) != NULL)
    {
        HRESULT hr;

        hr = RegInstall(hUrlmonDLL, "IEAKReg.HKCU", NULL);
        Out(LI1(TEXT("\"RegInstall\" on \"IEAKReg.HKCU\" in \"urlmon.dll\" returned %s."), GetHrSz(hr)));

        FreeLibrary(hUrlmonDLL);
    }
    else
        Out(LI0(TEXT("! \"urlmon.dll\" could not be loaded.")));

quit:
    Out(LI0(TEXT("Done.")));

    return S_OK;
}

HRESULT ProcessRatingsPol()
{   MACRO_LI_PrologEx_C(PIF_STD_C, ProcessRatingsPol)

    LPCTSTR pszRatingsFile;
    HKEY    hk;
    LONG    lResult;

    if (rtgIsRatingsInRegistry())
        return S_OK;

    pszRatingsFile = rtgGetRatingsFile();
    SetFileAttributes(pszRatingsFile, FILE_ATTRIBUTE_NORMAL);
    DeleteFile(pszRatingsFile);

    rtgRegMoveRatings();

    lResult = SHCreateKeyHKLM(RK_IEAKPOLICYDATA, KEY_SET_VALUE, &hk);
    if (lResult == ERROR_SUCCESS) {
        SHDeleteValue(hk, RK_USERS, RV_KEY);

        RegSaveKey (hk, pszRatingsFile, NULL);
        SHCloseKey (hk);
        SHDeleteKey(HKEY_LOCAL_MACHINE, RK_IEAKPOLICYDATA);
    }

    return S_OK;
}

// NOTE: (pritobla) if TrustedPublisherLockdown restriction is set via inetres.inf and in order
// for this restriction to work, we have to call regsvr32 /i:"S 10 TRUE" initpki.dll
HRESULT ProcessTrustedPublisherLockdown()
{   MACRO_LI_PrologEx_C(PIF_STD_C, ProcessTrustedPublisherLockdown)

    DWORD      dwVal, dwSize, dwState;

    ASSERT(SHValueExists(HKEY_LOCAL_MACHINE, RK_POLICES_RESTRICTIONS, RV_TPL));
    dwVal    = 0;
    dwSize   = sizeof(dwVal);
    SHGetValue(HKEY_LOCAL_MACHINE, RK_POLICES_RESTRICTIONS, RV_TPL, NULL, &dwVal, &dwSize);

    // check the new location, if either location is set then we need to set trusted publisher
    // lockdown

    dwVal = InsGetBool(IS_SITECERTS, IK_TRUSTPUBLOCK, FALSE, g_GetIns()) ? 1 : dwVal;

    dwSize = sizeof(dwState);

    if (SHGetValue(g_GetHKCU(), REG_KEY_SOFTPUB, REG_VAL_STATE, NULL, &dwState, &dwSize) == ERROR_SUCCESS)
    {
        Out(LI1(TEXT("Trusted publisher lockdown will be %s!"), dwVal ? TEXT("set") : TEXT("cleared")));
        
        if (dwVal)
            dwState |= TRUSTED_PUB_FLAG;
        else
            dwState &= ~TRUSTED_PUB_FLAG;

        SHSetValue(g_GetHKCU(), REG_KEY_SOFTPUB, REG_VAL_STATE, REG_DWORD, &dwState, sizeof(dwState));
    }

    return S_OK;
}

// NOTE: (andrewgu) i haven't touched this function. i merely moved it around.
HRESULT ProcessCDWelcome()
{   MACRO_LI_PrologEx_C(PIF_STD_C, ProcessCDWelcome)

    TCHAR szPath[MAX_PATH];
    HKEY hk;

    GetWindowsDirectory(szPath, countof(szPath));
    PathAppend(szPath, TEXT("welc.exe"));

    if (PathFileExists(szPath))
    {
        TCHAR szDestPath[MAX_PATH];

        Out(LI0(TEXT("Welcome exe found in windows dir.")));
        GetIEPath(szDestPath, countof(szDestPath));
        PathAppend(szDestPath, TEXT("welcome.exe"));

        if (!PathFileExists(szDestPath))
        {
            HKEY hkCurVer;

            CopyFile(szPath, szDestPath, FALSE);

            if (SHOpenKeyHKLM(REGSTR_PATH_SETUP, KEY_READ | KEY_WRITE, &hkCurVer) == ERROR_SUCCESS)
            {
                RegSetValueEx(hkCurVer, TEXT("DeleteWelcome"), 0, REG_SZ, (LPBYTE)szDestPath, (DWORD)StrCbFromSz(szDestPath));
                SHCloseKey(hkCurVer);
            }
            Out(LI0(TEXT("Copying welcome exe to ie dir.")));
        }

        DeleteFile(szPath);
    }

    if (ERROR_SUCCESS == SHOpenKeyHKLM(REGSTR_PATH_SETUP, KEY_READ | KEY_WRITE, &hk)) {
        if (ERROR_SUCCESS == RegQueryValueEx(hk, TEXT("IEFromCD"), NULL, NULL, NULL, NULL)) {
            HKEY hkTips;

            RegDeleteValue(hk, TEXT("IEFromCD"));

            // (pritobla)
            // the logic in loadwc.exe (if in non-integrated mode) and in explorer.exe (if in integrated mode)
            // which determines if the welcome screen should be shown or not is as follows:
            //   if the ShowIE4 reg value *doesn't exist* OR if the value is non-zero,
            //   show the welcome screen; otherwise, don't show

            // so, if ie has been installed from a custom CD build, check if ShowIE4 reg value is 0.
            // if yes, set it to 1 so that welcome.exe is run which in turn will show the start.htm and also,
            // set CDForcedOn to 1 so that isk3ro.exe will set ShowIE4 back to 0.

            if (SHOpenKey(g_GetHKCU(), REG_KEY_TIPS, KEY_READ | KEY_WRITE, &hkTips) == ERROR_SUCCESS)
            {
                DWORD dwVal, dwSize;

                // NOTE: (pritobla) It's important to initialize dwVal to 0 because on OSR2.5, ShowIE4 (REG_VAL_SHOWIE4)
                // is of binary type and is set to 00 (single byte).  If dwVal is not initialized to 0, then only the
                // low order byte would be set to 0.  The remaining bytes would be garbage which would make the entire DWORD
                // a non-zero value.
                dwVal  = 0;
                dwSize = sizeof(dwVal);
                if (RegQueryValueEx(hkTips, REG_VAL_SHOWIE4, NULL, NULL, (LPBYTE) &dwVal, &dwSize) == ERROR_SUCCESS  &&
                    dwVal == 0)
                {
                    dwVal = 1;
                    RegSetValueEx(hkTips, REG_VAL_SHOWIE4, 0, REG_DWORD, (CONST BYTE *)&dwVal, sizeof(dwVal));

                    RegSetValueEx(hk, TEXT("CDForcedOn"), 0, REG_SZ, (LPBYTE)TEXT("1"), StrCbFromCch(2));
                }

                SHCloseKey(hkTips);
            }
        }

        SHCloseKey(hk);
    }

    return S_OK;
}

HRESULT ProcessBrowserRefresh()
{   MACRO_LI_PrologEx_C(PIF_STD_C, ProcessBrowserRefresh)

    static const CHAR *s_pszIEHiddenA = "Internet Explorer_Hidden";

    CHAR      szClassNameA[32];
    HWND      hwnd;
    HANDLE    hThread = NULL;
    DWORD     dwThread;

    hwnd = GetTopWindow(GetDesktopWindow());
    while (hwnd != NULL) {
        GetClassNameA(hwnd, szClassNameA, sizeof(szClassNameA));

        if (!StrCmpIA(szClassNameA, s_pszIEHiddenA)) {
            PostMessage(hwnd, WM_DO_UPDATEALL, 0, FALSE);
            Out(LI0(TEXT("Posted update request to the hidden browser window!")));
        }

        hwnd = GetNextWindow(hwnd, GW_HWNDNEXT);
    }

    Out(LI0(TEXT("Broadcasting \"Windows settings change\" to all top level windows...")));

    if (g_CtxIs(CTX_AUTOCONFIG))
        hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) broadcastSettingsChange, NULL, 0, &dwThread);

    if (hThread == NULL)        // if CreateThread fails or it is not in AutoConfig mode
        broadcastSettingsChange(NULL);
    else
        CloseHandle(hThread);

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// Implementation helper routines

LPCTSTR rtgGetRatingsFile(LPTSTR pszFile /*= NULL*/, UINT cch /*= 0*/)
{   MACRO_LI_PrologEx_C(PIF_STD_C, rtgGetRatingsFile)

    static TCHAR s_szFile[MAX_PATH];
    static DWORD s_dwSize;

    if (pszFile != NULL)
        *pszFile = TEXT('\0');

    if (s_szFile[0] == TEXT('\0')) {
        s_dwSize = GetSystemDirectory(s_szFile, countof(s_szFile));
        PathAppend(s_szFile, RATINGS_POL);
        s_dwSize += 1 + countof(RATINGS_POL)-1;

        Out(LI1(TEXT("Ratings file location is \"%s\"."), s_szFile));
    }
    else
        ASSERT(s_dwSize > 0);

    if (pszFile == NULL || cch <= (UINT)s_dwSize)
        return s_szFile;

    StrCpy(pszFile, s_szFile);
    return pszFile;
}

BOOL rtgIsRatingsInRegistry()
{
    HKEY hkUpdate, hkLogon, hkRatings;
    BOOL fRet = TRUE;
    DWORD dwUpMode, dwType, dwProfiles;
    DWORD K4 = 4;

    if ((GetVersion() & 0x80000000) == 0)
        return TRUE;

    if (SHOpenKeyHKLM(REGSTR_PATH_CURRENT_CONTROL_SET TEXT("\\Update"), KEY_QUERY_VALUE, &hkUpdate) == ERROR_SUCCESS)
    {
        if (RegQueryValueEx(hkUpdate, TEXT("UpdateMode"), 0, &dwType, (LPBYTE)&dwUpMode, &K4) != ERROR_SUCCESS)
            fRet = FALSE;
        else
            fRet &= dwUpMode;
        SHCloseKey(hkUpdate);
        if (!fRet)
            return fRet;
    }
    else
        return FALSE;

    if (SHOpenKeyHKLM(REGSTR_PATH_NETWORK_USERSETTINGS TEXT("\\Logon"), KEY_QUERY_VALUE, &hkLogon) == ERROR_SUCCESS)
    {
        if (RegQueryValueEx(hkLogon, TEXT("UserProfiles"), 0, &dwType, (LPBYTE)&dwProfiles, &K4) != ERROR_SUCCESS)
            fRet = FALSE;
        else
            fRet &= dwProfiles;
        SHCloseKey(hkLogon);
        if (!fRet)
            return fRet;
    }
    else
        return FALSE;

    if (SHOpenKeyHKLM(RK_RATINGS, KEY_QUERY_VALUE, &hkRatings) == ERROR_SUCCESS)
    {
        HKEY hkRatDef;
        if (SHOpenKey(hkRatings, TEXT(".Default"), KEY_QUERY_VALUE, &hkRatDef) != ERROR_SUCCESS)
            fRet = FALSE;
        else
            SHCloseKey(hkRatDef);
        SHCloseKey(hkRatings);
    }
    else
        return FALSE;

    return fRet;
}

void rtgRegMoveRatings()
{
    TCHAR szData[MAX_PATH], szValue[MAX_PATH];
    HKEY  hkSrc = NULL, hkDest = NULL, hkSrcDef = NULL, hkDestDef = NULL;  
    DWORD dwType;
    DWORD dwiVal = 0;
    DWORD sData  = sizeof(szData);
    DWORD sValue = countof(szValue);

    if (SHOpenKeyHKLM(RK_RATINGS, KEY_DEFAULT_ACCESS, &hkSrc) != ERROR_SUCCESS)
        goto Exit;

    if (SHCreateKeyHKLM(RK_IEAKPOLICYDATA_USERS, KEY_DEFAULT_ACCESS, &hkDest) != ERROR_SUCCESS)
        goto Exit;

    while (RegEnumValue(hkSrc, dwiVal++, szValue, &sValue, NULL, &dwType, (LPBYTE)szData, &sData) == ERROR_SUCCESS)
    {
        RegSetValueEx(hkDest, szValue, 0, dwType, (LPBYTE)szData, sData);
        sData  = sizeof(szData);
        sValue = countof(szValue);
    }

    if (SHOpenKey(hkSrc, TEXT(".Default"), KEY_DEFAULT_ACCESS, &hkSrcDef) != ERROR_SUCCESS)
        goto Exit;
    
    if (SHCreateKey(hkDest, TEXT(".Default"), KEY_DEFAULT_ACCESS, &hkDestDef) != ERROR_SUCCESS)
        goto Exit;

    SHCopyKey(hkSrcDef, hkDestDef);

    SHCloseKey(hkSrcDef);
    SHCloseKey(hkDestDef);

    if (SHOpenKey(hkSrc, TEXT("PICSRules"), KEY_DEFAULT_ACCESS, &hkSrcDef) != ERROR_SUCCESS)
        goto Exit;

    if (SHCreateKey(hkDest, REG_KEY_RATINGS TEXT("\\PICSRules"), KEY_DEFAULT_ACCESS, &hkDestDef) != ERROR_SUCCESS)
        goto Exit;

    SHCopyKey(hkSrcDef, hkDestDef);

Exit:
    SHCloseKey(hkSrc);
    SHCloseKey(hkDest);
    SHCloseKey(hkSrcDef);
    SHCloseKey(hkDestDef);
}

void broadcastSettingsChange(LPVOID lpVoid)
{
    DWORD_PTR dwResult;

    UNREFERENCED_PARAMETER(lpVoid);

    // NOTE: (pritobla) timeout value of 20 secs is not random; apparently, the shell guys have
    // recommended this value; so don't change it unless you know what you're doing :)
    SendMessageTimeout(HWND_BROADCAST, WM_WININICHANGE, 0, NULL, SMTO_ABORTIFHUNG | SMTO_NORMAL, 20000, &dwResult);
}


// Helper to determine if we're currently loaded during GUI mode setup
BOOL IsInGUIModeSetup()
{
    HKEY hKeySetup = NULL;
    DWORD dwSystemSetupInProgress = 0;

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                      TEXT("System\\Setup"),
                                      0,
                                      KEY_READ,
                                      &hKeySetup))
    {
        DWORD dwSize = sizeof(dwSystemSetupInProgress);

        if (ERROR_SUCCESS != RegQueryValueEx (hKeySetup,
                                              TEXT("SystemSetupInProgress"),
                                              NULL,
                                              NULL,
                                              (LPBYTE) &dwSystemSetupInProgress,
                                              &dwSize))
        {
            dwSystemSetupInProgress = 0;
        }
        else
        {
            dwSize = sizeof(dwSystemSetupInProgress);
            if (dwSystemSetupInProgress &&
                ERROR_SUCCESS != RegQueryValueEx (hKeySetup,
                                                  TEXT("UpgradeInProgress"),
                                                  NULL,
                                                  NULL,
                                                  (LPBYTE) &dwSystemSetupInProgress,
                                                  &dwSize))
            {
                dwSystemSetupInProgress = 0;
            }
        }

        RegCloseKey(hKeySetup);
    }
    return dwSystemSetupInProgress ? TRUE : FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\brandll\brandfav.h ===
#ifndef _BRANDFAV_H_
#define _BRANDFAV_H_

//----- Favorites ordering -----
// stolen from shell\inc\shguidp.h
DEFINE_GUID(CLSID_OrderListExport, 0xf3368374, 0xcf19, 0x11d0, 0xb9, 0x3d, 0x0, 0xa0, 0xc9, 0x3, 0x12, 0xe1);
DEFINE_GUID(IID_IOrderList,        0x8bfcb27d, 0xcf1a, 0x11d0, 0xb9, 0x3d, 0x0, 0xa0, 0xc9, 0x3, 0x12, 0xe1);

// stolen from shell\inc\shellp.h
//
// IOrderList - for ordering info in favorites/channels
//
// Typical usage is: GetOrderList, AllocOrderItem, insert into correct
// position, SetOrderList, and then FreeOrderList.
//
typedef struct {
    LPITEMIDLIST pidl;                          // IDlist for this item
    int          nOrder;                        // Ordinal indicating user preference
    DWORD        lParam;                        // store custom order info.
} ORDERITEM, * PORDERITEM;

// Values for SortOrderList
#define OI_SORTBYNAME    0
#define OI_SORTBYORDINAL 1
#define OI_MERGEBYNAME   2

#undef  INTERFACE
#define INTERFACE  IOrderList
DECLARE_INTERFACE_(IOrderList, IUnknown)
{
    // IUnknown
    STDMETHOD (QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)  (THIS) PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // IOrderList
    STDMETHOD(GetOrderList)  (THIS_ HDPA *phdpa) PURE;
    STDMETHOD(SetOrderList)  (THIS_ HDPA hdpa, IShellFolder *psf) PURE;
    STDMETHOD(FreeOrderList) (THIS_ HDPA hdpa) PURE;
    STDMETHOD(SortOrderList) (THIS_ HDPA hdpa, DWORD dw) PURE;
    STDMETHOD(AllocOrderItem)(THIS_ PORDERITEM *ppoi, LPCITEMIDLIST pidl) PURE;
    STDMETHOD(FreeOrderItem) (THIS_ PORDERITEM poi) PURE;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\brandll\brandad4.cpp ===
#include "precomp.h"
#include <winuserp.h>                           // for GetShellWindow API only

// Private forward decalarations
void    doWallpaperFix(HKEY hKeyDesktopNew);
BOOL    isHtmlFileByExt           (LPCTSTR pszFilename);
BOOL    isNormalWallpaperFileByExt(LPCTSTR pszFilename);
BOOL    getFileTimeByName(LPCTSTR pszFilename, LPFILETIME pft);
HRESULT pepDeleteFilesEnumProc(LPCTSTR pszPath, PWIN32_FIND_DATA pfd, LPARAM lParam, PDWORD *prgdwControl = NULL);


HRESULT lcy4x_ProcessActiveDesktop()
{   MACRO_LI_PrologEx_C(PIF_STD_C, lcy4x_ProcessActiveDesktop)

    USES_CONVERSION;

    TCHAR     szWebPath[MAX_PATH], szWallpaperPath[MAX_PATH],
              szValue[MAX_PATH], szAux[MAX_PATH], szAux2[MAX_PATH],
              szInsKey[21];
    LPCTSTR   pszFilename;
    HKEY      hk;
    DWORD_PTR dwAux;
    DWORD     dwValue,
              dwResult;
    int       iNumFiles, iNumFiles2,
              i;
    BOOL      fAux;

    hk = NULL;

    //----- Initialization -----
    CreateWebFolder();
    GetWebPath (szWebPath, countof(szWebPath));
    PathCombine(szWallpaperPath, szWebPath, FOLDER_WALLPAPER);

    // turn on active desktop
    fAux = TRUE;
    SHGetSetActiveDesktop(TRUE, &fAux);

    //----- My Computer, Control Panel -----
    StrCpy(szAux, FILEPREFIX);
    StrCat(szAux, szWebPath);

    GetPrivateProfileString(IS_DESKTOPOBJS, IK_MYCPTRPATH,  TEXT(""), szValue, countof(szValue), g_GetIns());
    if (szValue[0] != TEXT('\0')) {
        StrCpy    (szAux2, szAux);
        PathAppend(szAux2, PathFindFileName(szValue));
        ASSERT(PathFileExists(szAux2));

        SHSetValue(HKEY_LOCAL_MACHINE, RK_MYCOMPUTER, RV_PERSISTMONIKER, REG_SZ, szAux2, (DWORD)StrCbFromSz(szAux2));
    }

    GetPrivateProfileString(IS_DESKTOPOBJS, IK_CPANELPATH,  TEXT(""), szValue, countof(szValue), g_GetIns());
    if (szValue[0] != TEXT('\0')) {
        StrCpy    (szAux2, szAux);
        PathAppend(szAux2, PathFindFileName(szValue));
        ASSERT(PathFileExists(szAux2));

        SHSetValue(HKEY_LOCAL_MACHINE, RK_CONTROLPANEL, RV_PERSISTMONIKER, REG_SZ, szAux2, (DWORD)StrCbFromSz(szAux2));
    }

    //----- Desktop component -----
    GetPrivateProfileString(IS_DESKTOPOBJS, IK_DTOPCOMPURL, TEXT(""), szValue, countof(szValue), g_GetIns());
    if (szValue[0] != TEXT('\0')) {
        IActiveDesktop *piad;
        HRESULT hr;

        fAux = InsGetBool(IS_DESKTOPOBJS, IK_DESKCOMPLOCAL, FALSE, g_GetIns());
        if (fAux) {
            PathCombine(szAux, szWebPath, PathFindFileName(szValue));
            ASSERT(PathFileExists(szAux));
        }
        else
            StrCpy(szAux, szValue);

        hr = CoCreateInstance(CLSID_ActiveDesktop, NULL, CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER,
            IID_IActiveDesktop, (LPVOID *)&piad);
        if (SUCCEEDED(hr)) {
            ASSERT(piad != NULL);

            piad->AddUrl(NULL, T2CW(szAux), NULL, ADDURL_SILENT);
            piad->ApplyChanges(AD_APPLY_SAVE | AD_APPLY_HTMLGEN);
            piad->Release();
        }
    }

    //----- Wierd stuff (wallpaper path and marking something as dirty) -----
    iNumFiles  = GetPrivateProfileInt(IS_WALLPAPER,       IK_NUMFILES, 0, g_GetIns());
    iNumFiles2 = GetPrivateProfileInt(IS_CUSTOMWALLPAPER, IK_NUMFILES, 0, g_GetIns());

    if (iNumFiles > 0 || iNumFiles2 > 0) {
        DWORD dwType, dwSize;

        // set default wallpaper path in registry
        // REVIEW: (andrewgu) two things really:
        // 1. i don't know if it was written this way or became the way it was over time. but this
        // was the most unefficient way to do anything i've ever seen. and also it was buggy;
        // 2. why the heck do we need to mack with this at all?
        dwResult = SHOpenKeyHKLM(RK_WINDOWS, KEY_QUERY_VALUE | KEY_SET_VALUE, &hk);
        if (dwResult == ERROR_SUCCESS) {
            szAux[0] = TEXT('\0');
            dwSize   = sizeof(szAux);
            SHQueryValueEx(hk, RV_WALLPAPERDIR, NULL, NULL, (PBYTE)szAux, &dwSize);

            if (szAux[0] != TEXT('\0'))
                StrCpy(szWallpaperPath, szAux);

            else
                RegSetValueEx(hk, RV_WALLPAPERDIR, 0, REG_SZ, (PBYTE)szWallpaperPath, (DWORD)StrCbFromSz(szWallpaperPath));

            SHCloseKey(hk);
        }

        // who knows why this is needed
        dwResult = SHCreateKey(g_GetHKCU(), RK_DT_COMPONENTS, KEY_QUERY_VALUE | KEY_SET_VALUE, &hk);
        if (dwResult == ERROR_SUCCESS) {
            dwValue = 0;
            dwSize  = sizeof(dwValue);
            RegQueryValueEx(hk, RV_GENERALFLAGS, NULL, &dwType, (LPBYTE)&dwValue, &dwSize);

            dwValue |= RD_DIRTY;
            RegSetValueEx(hk, RV_GENERALFLAGS, 0, dwType, (LPBYTE)&dwValue, dwSize);

            SHCloseKey(hk);
        }
    }

    //----- Wallpaper files -----
    szValue[0] = TEXT('\0');

    if (iNumFiles > 0) {
        wnsprintf(szInsKey, countof(szInsKey), FILE_TEXT, 0);
        GetPrivateProfileString(IS_WALLPAPER, szInsKey, TEXT(""), szValue, countof(szValue), g_GetIns());
    }

    if (szValue[0] != TEXT('\0')) {
        pszFilename = PathFindFileName(szValue);

        PathCombine(szAux,  szWebPath,       pszFilename);
        PathCombine(szAux2, szWallpaperPath, pszFilename);
        CopyFile   (szAux,  szAux2, FALSE);
        ASSERT(PathFileExists(szAux2));

        dwResult = SHCreateKey(g_GetHKCU(), RK_DT_GENERAL, KEY_QUERY_VALUE | KEY_SET_VALUE, &hk);
        if (dwResult == ERROR_SUCCESS) {
            dwValue = GetPrivateProfileInt(IS_WALLPAPER, IK_COMPONENTPOS, 2, g_GetIns());
            RegSetValueEx(hk, RV_COMPONENTPOS, 0, REG_DWORD, (LPBYTE)&dwValue, sizeof(dwValue));

            if (isNormalWallpaperFileByExt(pszFilename)) {
                SHCloseKey(hk);

                dwResult = SHCreateKey(g_GetHKCU(), RK_CP_DESKTOP, KEY_SET_VALUE, &hk);
            }
            else
                doWallpaperFix(hk);
        }

        if (dwResult == ERROR_SUCCESS) {
            RegSetValueEx(hk, RV_WALLPAPER, 0, REG_SZ, (LPBYTE)szAux2, (DWORD)StrCbFromSz(szAux2));
            SHCloseKey(hk);
        }

        // BUGBUG: (pritobla) it would be faster if we just enumerated the HtmlImgs based on
        // iNumFiles and just copied them (see old code) instead of parsing thru the Html file
        // again.
        if (isHtmlFileByExt(pszFilename))
            CopyHtmlImgs(szAux, szWallpaperPath, NULL, NULL);
    }
    ASSERT(hk == NULL);

    //----- Custom wallpaper files -----
    szValue[0] = TEXT('\0');

    if (iNumFiles2 > 0) {
        wnsprintf(szInsKey, countof(szInsKey), FILE_TEXT, 0);
        GetPrivateProfileString(IS_CUSTOMWALLPAPER, szInsKey, TEXT(""), szValue, countof(szValue), g_GetIns());
    }

    if (szValue[0] != TEXT('\0')) {
        LPCTSTR pszRegKey;

        pszFilename = PathFindFileName(szValue);

        PathCombine(szAux,  szWebPath,       pszFilename);
        PathCombine(szAux2, szWallpaperPath, pszFilename);
        CopyFile   (szAux, szAux2, FALSE);
        ASSERT(PathFileExists(szAux2));

        fAux      = isNormalWallpaperFileByExt(pszFilename);
        pszRegKey = fAux ? RK_CP_DESKTOP : RK_DT_GENERAL;

        dwResult = SHCreateKey(g_GetHKCU(), pszRegKey, KEY_DEFAULT_ACCESS, &hk);
        if (dwResult == ERROR_SUCCESS) {
            if (!fAux)
                doWallpaperFix(hk);

            RegSetValueEx(hk, RV_WALLPAPER, 0, REG_SZ, (LPBYTE)szAux2, (DWORD)StrCbFromSz(szAux2));
            SHCloseKey(hk);
        }

        // BUGBUG: (pritobla) it would be faster if we just enumerated the HtmlImgs based on
        // iNumFiles2 and just copied them (see old code) instead of parsing thru the Html file
        // again.
        if (isHtmlFileByExt(pszFilename))
            CopyHtmlImgs(szAux, szWallpaperPath, NULL, NULL);
    }
    ASSERT(hk == NULL);

    //----- Quick Launch files -----
    iNumFiles = GetPrivateProfileInt(IS_QUICKLAUNCH, IK_NUMFILES, 0, g_GetIns());
    if (iNumFiles > 0) {
        TCHAR szQuickLaunchPath[MAX_PATH];

        //_____ Determine Quick Launch folder location _____
        StrCpy(szQuickLaunchPath, GetQuickLaunchPath());

        if (0 == LoadString(g_GetHinst(), IDS_IELNK, szAux, countof(szAux)))
            StrCpy(szAux, TEXT("Launch Internet Explorer Browser"));
        PathAddExtension(szAux, TEXT(".lnk"));

        //_____ Main processing _____
        // NOTE: (pritobla) make sure we don't delete existing IE link created by toolbar.inf if
        // we imported from server
        fAux = InsGetBool(IS_QUICKLAUNCH, IK_KEEPIELNK, FALSE, g_GetIns());
        PathEnumeratePath(szQuickLaunchPath, PEP_SCPE_NOFOLDERS | PEP_CTRL_ENUMPROCFIRST, pepDeleteFilesEnumProc,
            (LPARAM)(fAux ? szAux : NULL));

        for (i = 0; i < iNumFiles; i++) {
            wnsprintf(szInsKey, countof(szInsKey), FILE_TEXT, i);
            GetPrivateProfileString(IS_QUICKLAUNCH, szInsKey, TEXT(""), szValue, countof(szValue), g_GetIns());
            if (szValue[0] == TEXT('\0'))
                continue;

            pszFilename = PathFindFileName(szValue);

            PathCombine(szAux,  szWebPath,         pszFilename);
            PathCombine(szAux2, szQuickLaunchPath, pszFilename);
            CopyFile   (szAux,  szAux2, FALSE);
            ASSERT(PathFileExists(szAux2));
        }
    }

    // refresh desktop
    // NOTE: (pritobla) timeout value of 20 secs is not random; apparently, the shell guys have
    // recommended this value; so don't change it unless you know what you're doing :)
    if (IsOS(OS_NT))
        SendMessageTimeoutW(GetShellWindow(), WM_WININICHANGE, 0, (LPARAM)T2W(REFRESH_DESKTOP), SMTO_NORMAL | SMTO_ABORTIFHUNG, 20000, &dwAux);
    else
        SendMessageTimeoutA(GetShellWindow(), WM_WININICHANGE, 0, (LPARAM)T2A(REFRESH_DESKTOP), SMTO_NORMAL | SMTO_ABORTIFHUNG, 20000, &dwAux);

    return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// Implementation helper routines

BOOL isHtmlFileByExt(LPCTSTR pszFilename)
{
    LPCTSTR pszExt;

    if (pszFilename == NULL || *pszFilename == TEXT('\0'))
        return TRUE;

    pszExt = PathFindExtension(pszFilename);
    return (0 == StrCmpI(pszExt, TEXT(".htm"))  ||
            0 == StrCmpI(pszExt, TEXT(".html")) ||
            0 == StrCmpI(pszExt, TEXT(".htt")));
}

BOOL isNormalWallpaperFileByExt(LPCTSTR pszFilename)
{
    LPCTSTR pszExt;

    if (pszFilename == NULL || *pszFilename == TEXT('\0'))
        return TRUE;

    pszExt = PathFindExtension(pszFilename);

    // check for specific files that can be shown only in ActiveDesktop mode
    // everything else (including *.bmp) are "normal" wallpapers
    return !(isHtmlFileByExt(pszFilename)        ||
             0 == StrCmpI(pszExt, TEXT(".gif"))  ||
             0 == StrCmpI(pszExt, TEXT(".jpg"))  ||
             0 == StrCmpI(pszExt, TEXT(".png")));
}

// NOTE: (a-saship) fix suggested by sankar for the wallpaper to be displayed. this function is
// only called for wallpaper files other than .bmp format.
void doWallpaperFix(HKEY hkNew)
{
    FILETIME ft;
    TCHAR    szTemp[MAX_PATH];
    HKEY     hkOld = NULL;
    DWORD    dwSize;

    if (hkNew == NULL)
        return;

    hkOld = NULL;
    SHOpenKey(g_GetHKCU(), RK_CP_DESKTOP, KEY_READ, &hkOld);
    if (hkOld == NULL)
        return;

    // copy TileWallpaper & WallpaperStyle to new location
    dwSize = sizeof(szTemp);
    if (ERROR_SUCCESS == RegQueryValueEx(hkOld, RV_TILEWALLPAPER, NULL, NULL, (LPBYTE)szTemp, &dwSize))
        RegSetValueEx(hkNew, RV_TILEWALLPAPER, 0, REG_SZ, (LPBYTE)szTemp, dwSize);

    dwSize = sizeof(szTemp);
    if (ERROR_SUCCESS == RegQueryValueEx(hkOld, RV_WALLPAPERSTYLE, NULL, NULL, (LPBYTE)szTemp, &dwSize))
        RegSetValueEx(hkNew, RV_WALLPAPERSTYLE, 0, REG_SZ, (LPBYTE)szTemp, dwSize);

    // read the Wallpaper and copy it to the new location as BackupWallpaper
    dwSize = sizeof(szTemp);
    if (ERROR_SUCCESS == RegQueryValueEx(hkOld, RV_WALLPAPER, NULL, NULL, (LPBYTE)szTemp, &dwSize))
        RegSetValueEx(hkNew, RV_BACKUPWALLPAPER, 0, REG_SZ, (LPBYTE)szTemp, dwSize);

    // set the wallpaper file creation time at the new location
    getFileTimeByName(szTemp, &ft);
    RegSetValueEx(hkNew, RV_WALLPAPERFILETIME, 0, REG_BINARY, (LPBYTE)&ft, sizeof(ft));

    SHCloseKey(hkOld);
}

BOOL getFileTimeByName(LPCTSTR pszFilename, LPFILETIME pft)
{
    HANDLE hFile;
    BOOL   fResult;

    if (pft == NULL)
        return FALSE;
    ZeroMemory(pft, sizeof(*pft));

    hFile = CreateFile(pszFilename, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
    if (hFile == INVALID_HANDLE_VALUE)
        return FALSE;

    fResult = GetFileTime(hFile, NULL, NULL, pft);
    CloseHandle(hFile);

    return fResult;
}

HRESULT pepDeleteFilesEnumProc(LPCTSTR pszPath, PWIN32_FIND_DATA pfd, LPARAM lParam, PDWORD *prgdwControl /*= NULL*/)
{
    UNREFERENCED_PARAMETER(prgdwControl);

    ASSERT(pszPath != NULL && pfd != NULL && prgdwControl != NULL && *prgdwControl == NULL);
    ASSERT(!HasFlag(pfd->dwFileAttributes, FILE_ATTRIBUTE_DIRECTORY));

    if (0 == StrCmpI(pfd->cFileName, (LPCTSTR)lParam))
        return S_OK;

    DeleteFile(pszPath);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\brandll\brandfav.cpp ===
#include "precomp.h"
#include <intshcut.h>
#include <shlobjp.h>                            // for SHChangeDWORDAsIDList only
#include <comctrlp.h>                           // for the DPA stuff only
#include "favs.h"

#include <initguid.h>
#include "brandfav.h"

// Private forward decalarations
#define MAX_QUICKLINKS 50

static IShellFolder *s_psfDesktop = NULL;

#define FD_REMOVE_POLICY_CREATED  0x00010000

#define DFEP_DELETEORDERSTREAM    0x00000001
#define DFEP_DELETEOFFLINECONTENT 0x00000002
#define DFEP_DELETEEMPTYFOLDER    0x00000004

typedef struct {
    ISubscriptionMgr2 *psm;
    DWORD dwInsFlags;
    DWORD dwEnumFlags;
} DFEPSTRUCT, *PDFEPSTRUCT;

HRESULT processFavoritesOrdering(BOOL fQL);

HRESULT pepSpecialFoldersEnumProc (LPCTSTR pszPath, PWIN32_FIND_DATA pfd, LPARAM lParam, PDWORD *prgdwControl = NULL);
HRESULT pepDeleteFavoritesEnumProc(LPCTSTR pszPath, PWIN32_FIND_DATA pfd, LPARAM lParam, PDWORD *prgdwControl = NULL);

HRESULT deleteFavoriteOfflineContent(LPCTSTR pszFavorite, IUnknown *punk = NULL, ISubscriptionMgr2 *psm = NULL);

HRESULT deleteFavoriteFolder(LPCTSTR pszFolder);
HRESULT pepIsFolderEmptyEnumProc(LPCTSTR pszPath, PWIN32_FIND_DATA pfd, LPARAM lParam, PDWORD *prgdwControl = NULL);

BOOL isFileAttributeIncluded(UINT nFlags, DWORD dwFileAttributes);
UINT isSpecialFolderIncluded(UINT nFlags, LPCTSTR pszPath); // 0 - nothing, 1 - FD_FOLDER, 2 - FD_EMPTY_FOLDERS

HRESULT replacePlaceholders(LPCTSTR pszSrc, LPCTSTR pszIns, LPTSTR pszBuffer, PUINT pcchBuffer, BOOL fLookupLDID = FALSE);

DWORD   getFavItems        (LPCTSTR pcszSection, LPCTSTR pcszFmt, LPTSTR *ppszFavItems);
HRESULT orderFavorites     (LPITEMIDLIST pidlFavFolder, IShellFolder *psfFavFolder, LPTSTR pszFavItems, DWORD cFavs);
HRESULT orderFavoriteFolder(LPITEMIDLIST pidlFavFolder, IShellFolder *psfFavFolder, LPCTSTR pcszFavItems, DWORD cFavs);
DWORD   getFolderSection   (LPCTSTR pcszFolderName, LPTSTR pszSection, LPTSTR *ppszFolderItems, LPDWORD pdwNItems);


void ClearFavoritesThread()
{
    DFEPSTRUCT dfep;
    PCTSTR     pszFavorites;
    HRESULT    hr;


    HRESULT hrComInit;
    hrComInit = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
    if (SUCCEEDED(hrComInit))
        Out(LI1(TEXT("COM initialized with %s success code."), GetHrSz(hrComInit)));
    else
    {
        Out(LI1(TEXT("! COM initialization failed with %s."), GetHrSz(hrComInit)));
    }

    //----- Initialization -----
    Out(LI0(TEXT("Clearing favorites...")));
    ZeroMemory(&dfep, sizeof(dfep));

    dfep.dwInsFlags = FD_FAVORITES |
        FD_CHANNELS      | FD_SOFTWAREUPDATES  |
        FD_QUICKLINKS    | FD_EMPTY_QUICKLINKS |
        FD_REMOVE_HIDDEN | FD_REMOVE_SYSTEM    |
        FD_REMOVE_POLICY_CREATED;

    hr = CoCreateInstance(CLSID_SubscriptionMgr, NULL, CLSCTX_INPROC_SERVER, IID_ISubscriptionMgr2, (LPVOID *)&dfep.psm);
    if (SUCCEEDED(hr))
        dfep.dwEnumFlags |= DFEP_DELETEOFFLINECONTENT;

    else
        Out(LI1(TEXT("! Creation of SubscriptionMgr object failed with %s."), GetHrSz(hr)));

    { MACRO_LI_Offset(1);                       // need a new scope

    Out(LI0(TEXT("Determining paths to special folders...")));
    pszFavorites = GetFavoritesPath();
    if (NULL == pszFavorites) {
        Out(LI0(TEXT("! The path to the <Favorites> folder could not be determined.")));
        goto Exit;
    }

    GetChannelsPath();
    GetSoftwareUpdatesPath();
    GetLinksPath();
    Out(LI0(TEXT("Done.\r\n")));

    }                                           // end of offset scope

    //----- Main processing -----
    hr = PathEnumeratePath(pszFavorites,
        PEP_SCPE_NOFOLDERS | PEP_CTRL_USECONTROL,
        pepDeleteFavoritesEnumProc, (LPARAM)&dfep);
    if (FAILED(hr)) {
        Out(LI1(TEXT("! Enumeration of favorites in <Favorites> folder failed with %s."), GetHrSz(hr)));
        goto Exit;
    }

    // cleanup favorites subfolders with regard to special ones
    hr = PathEnumeratePath(pszFavorites,
        PEP_SCPE_NOFILES | PEP_CTRL_ENUMPROCFIRST | PEP_CTRL_NOSECONDCALL | PEP_CTRL_USECONTROL,
        pepSpecialFoldersEnumProc, (LPARAM)&dfep);
    if (FAILED(hr)) {
        Out(LI1(TEXT("! Enumeration of special folders failed with %s."), GetHrSz(hr)));
        goto Exit;
    }

Exit:
    //free com
    if (SUCCEEDED(hrComInit))
        CoUninitialize();

    Out(LI0(TEXT("Done.")));

}

void ClearFavorites(DWORD dwFlags /*= FF_ENABLE*/)
{   MACRO_LI_PrologEx_C(PIF_STD_C, ClearFavorites)

    UNREFERENCED_PARAMETER(dwFlags);

    //because isubscriptionmgr2 fails to work in a multithreaded com environment, we're having to do 
    //any dealings with it on a separate thread.  

    Out(LI0(TEXT("Creating separate thread for clearing favorites...\r\n")));
    DWORD     dwThread;

    HANDLE hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) ClearFavoritesThread, NULL, 0, &dwThread);

    if (hThread == NULL)        // if CreateThread fails, call it on this thread and hope for the best
    {
        Out(LI0(TEXT("CreateThread failed, clearing favorites on this thread...\r\n")));
        ClearFavoritesThread();
    }
    else
    {
        // Wait until the thread is terminated
        // this seems unfortunate, but is necessary because otherwise other favorites processing threads could clobber this one.
        while (MsgWaitForMultipleObjects(1, &hThread, FALSE, INFINITE, QS_ALLINPUT) != WAIT_OBJECT_0)
        {
            MSG msg;
            while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }

        if (hThread != NULL) CloseHandle(hThread);
    }
}

void DeleteFavoritesThread()
{
    DFEPSTRUCT dfep;
    LPCTSTR    pszFavorites;
    HRESULT    hrResult, hr;

    HRESULT hrComInit;
    hrComInit = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
    if (SUCCEEDED(hrComInit))
        Out(LI1(TEXT("COM initialized with %s success code."), GetHrSz(hrComInit)));
    else
    {
        Out(LI1(TEXT("! COM initialization failed with %s."), GetHrSz(hrComInit)));
    }

    //----- Initialization -----
    hrResult = E_FAIL;
    ZeroMemory(&dfep, sizeof(dfep));

    dfep.dwInsFlags = GetPrivateProfileInt(IS_BRANDING, IK_FAVORITES_DELETE, (int)FD_DEFAULT, g_GetIns());
    if (HasFlag(dfep.dwInsFlags, FD_REMOVE_IEAK_CREATED))
        Out(LI0(TEXT("Only the favorites and quick links created by the IEAK will be deleted!")));

    hr = CoCreateInstance(CLSID_SubscriptionMgr, NULL, CLSCTX_INPROC_SERVER, IID_ISubscriptionMgr2, (LPVOID *)&dfep.psm);
    if (SUCCEEDED(hr))
        dfep.dwEnumFlags |= DFEP_DELETEOFFLINECONTENT;

    else
        Out(LI1(TEXT("! Creation of SubscriptionMgr object failed with %s."), GetHrSz(hr)));

    { MACRO_LI_Offset(1);                       // need a new scope

    Out(LI0(TEXT("Determining paths to special folders...")));
    pszFavorites = GetFavoritesPath();
    if (pszFavorites == NULL) {
        Out(LI0(TEXT("! The path to the <Favorites> folder could not be determined.")));
        goto Exit;
    }

    GetChannelsPath();
    GetSoftwareUpdatesPath();
    GetLinksPath();
    Out(LI0(TEXT("Done.\r\n")));

    }                                           // end of offset scope

    //----- Main processing -----
    if (HasFlag(dfep.dwInsFlags, FD_FAVORITES)) {
        dfep.dwEnumFlags |= DFEP_DELETEEMPTYFOLDER;

        if (HasFlag(dfep.dwInsFlags, FD_EMPTY_FAVORITES)) {
            // go at it at full steam
            hrResult = PathEnumeratePath(pszFavorites,
                PEP_CTRL_USECONTROL,
                pepDeleteFavoritesEnumProc, (LPARAM)&dfep);
            if (FAILED(hrResult)) {
                Out(LI1(TEXT("! Enumeration of favorites failed with %s."), GetHrSz(hrResult)));
                goto Exit;
            }

            deleteFavoriteFolder(pszFavorites);

            SHDeleteKey(g_GetHKCU(), RK_FAVORDER);
            Out(LI0(TEXT("The entire <Favorites> folder removed!")));
        }
        else {
            Out(LI0(TEXT("The <Favorites> folder is being cleaned with regard to special folders...")));

            // cleanup up favorites in the Favorites folder
            hrResult = PathEnumeratePath(pszFavorites,
                PEP_SCPE_NOFOLDERS | PEP_CTRL_USECONTROL,
                pepDeleteFavoritesEnumProc, (LPARAM)&dfep);
            if (FAILED(hrResult)) {
                Out(LI1(TEXT("! Enumeration of favorites in <Favorites> folder failed with %s."), GetHrSz(hrResult)));
                goto Exit;
            }

            SHDeleteValue(g_GetHKCU(), RK_FAVORDER, RV_ORDER);

            // cleanup favorites subfolders with regard to special ones
            hrResult = PathEnumeratePath(pszFavorites,
                PEP_SCPE_NOFILES | PEP_CTRL_ENUMPROCFIRST | PEP_CTRL_NOSECONDCALL | PEP_CTRL_USECONTROL,
                pepSpecialFoldersEnumProc, (LPARAM)&dfep);
            if (FAILED(hrResult)) {
                Out(LI1(TEXT("! Enumeration of special folders failed with %s."), GetHrSz(hrResult)));
                goto Exit;
            }

            Out(LI0(TEXT("<Favorites> folder emptied.")));
        }
    }
    else {
        Out(LI0(TEXT("Processing special folders only...")));

        // cleanup only special favorites subfolders
        hrResult = PathEnumeratePath(pszFavorites,
            PEP_SCPE_NOFILES | PEP_CTRL_ENUMPROCFIRST | PEP_CTRL_NOSECONDCALL | PEP_CTRL_USECONTROL,
            pepSpecialFoldersEnumProc, (LPARAM)&dfep);
        if (FAILED(hrResult))
            Out(LI1(TEXT("! Enumeration of special folders failed with %s."), GetHrSz(hrResult)));
    }

Exit:
    //free com
    if (SUCCEEDED(hrComInit))
        CoUninitialize();

    if (dfep.psm != NULL)
        dfep.psm->Release();
}

HRESULT ProcessFavoritesDeletion()
{   MACRO_LI_PrologEx_C(PIF_STD_C, ProcessFavoritesDeletion)

    //because isubscriptionmgr2 fails to work in a multithreaded com environment, we're having to do 
    //any dealings with it on a separate thread.  

    Out(LI0(TEXT("Creating separate thread for deleting favorites...\r\n")));
    DWORD     dwThread;

    HANDLE hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) DeleteFavoritesThread, NULL, 0, &dwThread);

    if (hThread == NULL)        // if CreateThread fails, call it on this thread and hope for the best
    {
        Out(LI0(TEXT("CreateThread failed, deleting favorites on this thread...\r\n")));
        DeleteFavoritesThread();
    }
    else
    {
        // Wait until the thread is terminated
        // this seems unfortunate, but is necessary because otherwise other favorites processing threads could clobber this one.
        while (MsgWaitForMultipleObjects(1, &hThread, FALSE, INFINITE, QS_ALLINPUT) != WAIT_OBJECT_0)
        {
            MSG msg;
            while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }

        if (hThread != NULL) CloseHandle(hThread);
    }

    return S_OK;

}

void ProcessFavoritesThread()
{
    IUnknown  *punk;
    ISubscriptionMgr2 *pSubMgr2;
    CFavorite fav;
    TCHAR     szAux[2*MAX_PATH + 1],
              szKey[32];
    HRESULT   hr;
    BOOL      fNewFormat,
              fContinueOnFailure, fTotalSuccess;

    hr                 = S_OK;
    punk               = NULL;
    pSubMgr2           = NULL;
    fContinueOnFailure = TRUE;
    fTotalSuccess      = TRUE;

    HRESULT hrComInit;
    hrComInit = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
    if (SUCCEEDED(hrComInit))
        Out(LI1(TEXT("COM initialized with %s success code."), GetHrSz(hrComInit)));
    else
    {
        Out(LI1(TEXT("! COM initialization failed with %s."), GetHrSz(hrComInit)));
    }

    wnsprintf(szKey, countof(szKey), IK_TITLE_FMT, 1);
    fNewFormat = !InsIsKeyEmpty(IS_FAVORITESEX, szKey, g_GetIns());

    hr = CoCreateInstance(CLSID_InternetShortcut, NULL, CLSCTX_INPROC_SERVER, IID_IUnknown, (LPVOID *)&punk);
    if (FAILED(hr)) {
        Out(LI1(TEXT("! Creation of InternetShortcut object failed with %s."), GetHrSz(hr)));
        if (SUCCEEDED(hrComInit))
            CoUninitialize();
        return;
    }

    hr = CoCreateInstance(CLSID_SubscriptionMgr, NULL, CLSCTX_INPROC_SERVER, IID_ISubscriptionMgr2, (LPVOID *) &pSubMgr2);
    if (FAILED(hr)) {
        Out(LI1(TEXT("! Creation of SubscriptionMgr object failed with %s."), GetHrSz(hr)));
        hr = S_OK;                              // don't treat this as an error
    }

    if (fNewFormat) {
        Out(LI0(TEXT("Using [FavoritesEx] section...\r\n")));

        // for corp, mark the favorites created so that they can be deleted without deleting user created ones
        fav.m_fMarkIeakCreated = g_CtxIs(CTX_CORP | CTX_AUTOCONFIG | CTX_GP);

        for (UINT i = 1; TRUE; i++) {
            MACRO_LI_Offset(1);
            if (i > 1)
                Out(LI0(TEXT("\r\n")));

            // processing title
            wnsprintf(szKey, countof(szKey), IK_TITLE_FMT, i);
            Out(LI1(TEXT("Preprocessing \"%s\" title key..."), szKey));

            hr = formStrWithoutPlaceholders(IS_FAVORITESEX, szKey, g_GetIns(),
                fav.m_szTitle, countof(fav.m_szTitle), FSWP_VALUE);
            if (FAILED(hr)) {
                Out(LI1(TEXT("Failed with %s."), GetHrSz(hr)));

                if (fContinueOnFailure) {
                    fTotalSuccess = FALSE;
                    continue;
                }
                else
                    break;
            }

            ASSERT(fav.m_szTitle[0] == TEXT('\0'));
            if (fav.m_szTitle[1] == TEXT('\0')) {
                Out(LI0(TEXT("This key doesn't exist indicating that there are no more favorites.")));
                break;
            }

            StrCpy(fav.m_szTitle, &fav.m_szTitle[1]);

            // processing URL
            wnsprintf(szKey, countof(szKey), IK_URL_FMT, i);
            Out(LI1(TEXT("Preprocessing \"%s\" URL key..."), szKey));

            hr = formStrWithoutPlaceholders(IS_FAVORITESEX, szKey, g_GetIns(),
                fav.m_szUrl, countof(fav.m_szUrl), FSWP_VALUE | FSWP_VALUELDID);
            if (FAILED(hr)) {
                Out(LI1(TEXT("Failed with %s."), GetHrSz(hr)));

                if (fContinueOnFailure) {
                    fTotalSuccess = FALSE;
                    continue;
                }
                else
                    break;
            }

            ASSERT(fav.m_szUrl[0] == TEXT('\0') && fav.m_szUrl[1] != TEXT('\0'));
            StrCpy(fav.m_szUrl, &fav.m_szUrl[1]);

            // processing icon file (no need to process with formStrWithoutPlaceholders)
            wnsprintf(szKey, countof(szKey), IK_ICON_FMT, i);
            GetPrivateProfileString(IS_FAVORITESEX, szKey, TEXT(""), szAux, countof(szAux), g_GetIns());
            if (szAux[0] != TEXT('\0'))
                PathCombine(fav.m_szIcon, g_GetTargetPath(), PathFindFileName(szAux));
            else
                fav.m_szIcon[0] = TEXT('\0');

            // get the offline flag
            wnsprintf(szKey, countof(szKey), IK_OFFLINE_FMT, i);
            fav.m_fOffline = InsGetBool(IS_FAVORITESEX, szKey, FALSE, g_GetIns());

            // actually adding this favorite
            Out(LI0(TEXT("Adding this favorite:")));
            hr = fav.Create(punk, pSubMgr2, NULL, g_GetIns());
            if (FAILED(hr)) {
                Out(LI1(TEXT("Failed with %s."), GetHrSz(hr)));

                if (fContinueOnFailure)
                    fTotalSuccess = FALSE;
                else
                    break;
            }

            Out(LI0(TEXT("Done.")));
        }
    }
    else { /* favorites in the legacy format */
        LPCTSTR pszPreTitle;
        LPTSTR  pszBuffer;
        HANDLE  hIns;
        DWORD   dwInsSize;

        Out(LI0(TEXT("Using [Favorites] section...\r\n")));

        fav.m_fMarkIeakCreated = FALSE;

        hIns = CreateFile(g_GetIns(), GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
        if (hIns == INVALID_HANDLE_VALUE) {
            hr = STG_E_FILENOTFOUND;
            goto Exit;
        }
        dwInsSize = GetFileSize(hIns, NULL);
        ASSERT(dwInsSize != 0xFFFFFFFF);
        CloseHandle(hIns);

        pszBuffer = (LPTSTR)CoTaskMemAlloc(dwInsSize);
        if (pszBuffer == NULL) {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
        ZeroMemory(pszBuffer, dwInsSize);

        GetPrivateProfileString(IS_FAVORITES, NULL, TEXT(""), pszBuffer, (UINT)dwInsSize, g_GetIns());
        ASSERT(*pszBuffer != TEXT('\0'));

        for (pszPreTitle = pszBuffer; *pszPreTitle != TEXT('\0'); pszPreTitle += StrLen(pszPreTitle) + 1) {
            MACRO_LI_Offset(1);
            if (pszPreTitle != pszBuffer)
                Out(LI0(TEXT("\r\n")));

            // processing title and URL
            Out(LI1(TEXT("Preprocessing \"%s\" favorite key..."), pszPreTitle));
            hr = formStrWithoutPlaceholders(IS_FAVORITES, pszPreTitle, g_GetIns(), szAux, countof(szAux));
            if (FAILED(hr)) {
                Out(LI1(TEXT("Failed with %s."), GetHrSz(hr)));

                if (fContinueOnFailure) {
                    fTotalSuccess = FALSE;
                    continue;
                }
                else
                    break;
            }

            if (szAux[0] == TEXT('\0')) {
                StrCpy(fav.m_szTitle, pszPreTitle);
                StrCpy(fav.m_szUrl,   &szAux[1]);
            }
            else {
                StrCpy(fav.m_szTitle, szAux);
                StrCpy(fav.m_szUrl,   &szAux[StrLen(szAux) + 1]);
            }

            fav.m_fOffline = FALSE;

            // actually adding this favorite
            Out(LI0(TEXT("Adding this favorite:")));
            hr = fav.Create(punk, NULL, NULL, g_GetIns());
            if (FAILED(hr)) {
                Out(LI1(TEXT("Failed with %s."), GetHrSz(hr)));

                if (fContinueOnFailure)
                    fTotalSuccess = FALSE;
                else
                    break;
            }

            Out(LI0(TEXT("Done.")));
        }

        CoTaskMemFree(pszBuffer);
    }

Exit:
    if (punk != NULL)
        punk->Release();

    if (pSubMgr2 != NULL)
        pSubMgr2->Release();

    if (fContinueOnFailure) {
        if (!fTotalSuccess)
            hr = S_FALSE;                       // at least one failed
        else
            ASSERT(SUCCEEDED(hr));
    }

    if (SUCCEEDED(hr))
        SetFeatureBranded(FID_FAV_MAIN);

    //free com
    if (SUCCEEDED(hrComInit))
        CoUninitialize();


}


HRESULT ProcessFavorites()
{   MACRO_LI_PrologEx_C(PIF_STD_C, ProcessFavorites)

    //because isubscriptionmgr2 fails to work in a multithreaded com environment, we're having to do 
    //any dealings with it on a separate thread.  

    Out(LI0(TEXT("Creating separate thread for processing favorites...\r\n")));
    DWORD     dwThread;

    HANDLE hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) ProcessFavoritesThread, NULL, 0, &dwThread);

    if (hThread == NULL)        // if CreateThread fails, call it on this thread and hope for the best
    {
        Out(LI0(TEXT("CreateThread failed, processing favorites on this thread...\r\n")));
        ProcessFavoritesThread();
    }
    else
    {
        // Wait until the thread is terminated
        // this seems unfortunate, but is necessary because otherwise other favorites processing threads could clobber this one.
        while (MsgWaitForMultipleObjects(1, &hThread, FALSE, INFINITE, QS_ALLINPUT) != WAIT_OBJECT_0)
        {
            MSG msg;
            while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }

        if (hThread != NULL) CloseHandle(hThread);
    }

    return S_OK;
}


HRESULT ProcessFavoritesOrdering()
{
    return processFavoritesOrdering(FALSE);
}

void ProcessQuickLinksThread()
{
    IUnknown  *punk;
    ISubscriptionMgr2 *pSubMgr2;
    CFavorite fav;
    TCHAR     szAux[2*MAX_PATH + 1],
              szLinks[32],
              szKey[32];
    HRESULT   hr;
    int       i;
    BOOL      fContinueOnFailure,
              fTotalSuccess;

    HRESULT hrComInit;
    hrComInit = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
    if (SUCCEEDED(hrComInit))
        Out(LI1(TEXT("COM initialized with %s success code."), GetHrSz(hrComInit)));
    else
    {
        Out(LI1(TEXT("! COM initialization failed with %s."), GetHrSz(hrComInit)));
    }


    LoadString(g_GetHinst(), IDS_FOLDER_LINKS, szLinks, countof(szLinks));

    hr                 = S_OK;
    punk               = NULL;
    pSubMgr2           = NULL;
    fContinueOnFailure = TRUE;
    fTotalSuccess      = TRUE;

    hr = CoCreateInstance(CLSID_InternetShortcut, NULL, CLSCTX_INPROC_SERVER, IID_IUnknown, (LPVOID *)&punk);
    if (FAILED(hr)) {
        Out(LI1(TEXT("! Creation of InternetShortcut object failed with %s."), GetHrSz(hr)));
        if (SUCCEEDED(hrComInit))
            CoUninitialize();
        return;
    }

    hr = CoCreateInstance(CLSID_SubscriptionMgr, NULL, CLSCTX_INPROC_SERVER, IID_ISubscriptionMgr2, (LPVOID *) &pSubMgr2);
    if (FAILED(hr)) {
        Out(LI1(TEXT("! Creation of SubscriptionMgr object failed with %s."), GetHrSz(hr)));
        hr = S_OK;          // don't treat this as an error
    }

    // for corp, mark the quick links created so that they can be deleted without deleting user created ones
    fav.m_fMarkIeakCreated = HasFlag(g_GetContext(), CTX_CORP | CTX_AUTOCONFIG | CTX_GP);

    for (i = 1; i <= MAX_QUICKLINKS; i++) {
        MACRO_LI_Offset(1);
        if (i > 1)
            Out(LI0(TEXT("\r\n")));

        // processing title
        wnsprintf(szKey, countof(szKey), IK_QUICKLINK_NAME, i);
        Out(LI1(TEXT("Preprocessing \"%s\" quick link title key..."), szKey));

        hr = formStrWithoutPlaceholders(IS_URL, szKey, g_GetIns(), szAux, countof(szAux), FSWP_VALUE);
        if (FAILED(hr)) {
            Out(LI1(TEXT("Failed with %s."), GetHrSz(hr)));

            if (fContinueOnFailure) {
                fTotalSuccess = FALSE;
                continue;
            }
            else
                break;
        }

        ASSERT(szAux[0] == TEXT('\0'));
        if (szAux[1] == TEXT('\0')) {
            Out(LI0(TEXT("This key doesn't exist indicating that there are no more quick links.")));
            break;
        }

        fav.m_szTitle[0] = TEXT('\0');
        PathCombine(fav.m_szTitle, szLinks, &szAux[1]);

        // processing URL
        wnsprintf(szKey, countof(szKey), IK_QUICKLINK_URL, i);
        Out(LI1(TEXT("Preprocessing \"%s\" quick link URL key..."), szKey));

        hr = formStrWithoutPlaceholders(IS_URL, szKey, g_GetIns(),
            fav.m_szUrl, countof(fav.m_szUrl), FSWP_VALUE | FSWP_VALUELDID);
        if (FAILED(hr)) {
            Out(LI1(TEXT("Failed with %s."), GetHrSz(hr)));

            if (fContinueOnFailure) {
                fTotalSuccess = FALSE;
                continue;
            }
            else
                break;
        }

        ASSERT(fav.m_szUrl[0] == TEXT('\0') && fav.m_szUrl[1] != TEXT('\0'));
        StrCpy(fav.m_szUrl, &fav.m_szUrl[1]);

        // processing icon file (no need to process with formStrWithoutPlaceholders)
        wnsprintf(szKey, countof(szKey), IK_QUICKLINK_ICON, i);
        GetPrivateProfileString(IS_URL, szKey, TEXT(""), szAux, countof(szAux), g_GetIns());
        if (szAux[0] != TEXT('\0'))
            PathCombine(fav.m_szIcon, g_GetTargetPath(), PathFindFileName(szAux));
        else
            fav.m_szIcon[0] = TEXT('\0');

        // get the offline flag
        wnsprintf(szKey, countof(szKey), IK_QUICKLINK_OFFLINE, i);
        fav.m_fOffline = InsGetBool(IS_URL, szKey, FALSE, g_GetIns());

        // actually adding this favorite
        Out(LI0(TEXT("Adding this quick link:")));
        hr = fav.Create(punk, pSubMgr2, NULL, g_GetIns());
        if (FAILED(hr)) {
            Out(LI1(TEXT("Failed with %s."), GetHrSz(hr)));

            if (fContinueOnFailure)
                fTotalSuccess = FALSE;
            else
                break;
        }

        Out(LI0(TEXT("Done.")));
    }

    if (punk != NULL)
        punk->Release();

    if (pSubMgr2 != NULL)
        pSubMgr2->Release();

    if (fContinueOnFailure) {
        if (!fTotalSuccess)
            hr = S_FALSE;                       // at least one failed
        else
            ASSERT(SUCCEEDED(hr));
    }

    //free com
    if (SUCCEEDED(hrComInit))
        CoUninitialize();
}

HRESULT ProcessQuickLinks()
{   MACRO_LI_PrologEx_C(PIF_STD_C, ProcessQuickLinks)


    //because isubscriptionmgr2 fails to work in a multithreaded com environment, we're having to do 
    //any dealings with it on a separate thread.  

    Out(LI0(TEXT("Creating separate thread for processing quick links...\r\n")));
    DWORD     dwThread;

    HANDLE hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) ProcessQuickLinksThread, NULL, 0, &dwThread);

    if (hThread == NULL)        // if CreateThread fails, call it on this thread and hope for the best
    {
        Out(LI0(TEXT("CreateThread failed, processing quick links on this thread...\r\n")));
        ProcessQuickLinksThread();
    }
    else
    {
        // Wait until the thread is terminated
        // this seems unfortunate, but is necessary because otherwise other favorites processing threads could clobber this one.
        while (MsgWaitForMultipleObjects(1, &hThread, FALSE, INFINITE, QS_ALLINPUT) != WAIT_OBJECT_0)
        {
            MSG msg;
            while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }

        if (hThread != NULL) CloseHandle(hThread);
    }

    return S_OK;
}

HRESULT ProcessQuickLinksOrdering()
{
    return processFavoritesOrdering(TRUE);
}


/////////////////////////////////////////////////////////////////////////////
// Implementation helper routines

HRESULT processFavoritesOrdering(BOOL fQL)
{   MACRO_LI_PrologEx_C(PIF_STD_C, processFavoritesOrdering)

    IShellFolder *psfFavorites;
    LPITEMIDLIST pidlFavorites;
    LPTSTR  pszFavItems;
    HRESULT hr;
    DWORD   cFavs;

    psfFavorites  = NULL;
    pidlFavorites = NULL;
    pszFavItems   = NULL;
    hr            = S_OK;

    // figure out if there are any eligible favorites/links at all
    cFavs = getFavItems(!fQL ? IS_FAVORITESEX : IS_URL, !fQL ? IK_TITLE_FMT : IK_QUICKLINK_NAME, &pszFavItems);
    if (cFavs == 0) {
        Out(LI1(TEXT("There are no %s to process!"), !fQL ? TEXT("favorites") : TEXT("links")));
        goto Exit;
    }

    // get the IShellFolder for the desktop folder
    // NOTE: (andrewgu) this should be the only place we ever aquire s_psfDesktop, otherwise since
    // we release and set it to NULL at the end of the function, there is a potential for a memory
    // leak.
    if (NULL == s_psfDesktop) {
        hr = SHGetDesktopFolder(&s_psfDesktop);
        if (FAILED(hr)) {
            Out(LI1(TEXT("! SHGetDesktopFolder failed with %s"), GetHrSz(hr)));
            goto Exit;
        }
    }

    if (!fQL)
    {
        // get the pidl to the favorites folder
        hr = SHGetFolderLocationSimple(CSIDL_FAVORITES, &pidlFavorites);
        if (FAILED(hr))
        {
            Out(LI1(TEXT("! SHGetSpecialFolderLocation for CSIDL_FAVORITES failed with %s"), GetHrSz(hr)));
            goto Exit;
        }
    }
    else
    {
        TCHAR szLinksFolder[32];
        TCHAR szFavFolder[MAX_PATH], szFullPath[MAX_PATH];
        ULONG ucch;

        if (LoadString(g_GetHinst(), IDS_FOLDER_LINKS, szLinksFolder, countof(szLinksFolder)) == 0)
        {
            Out(LI0(TEXT("! LoadString failed to get the name of the links folder")));
            goto Exit;
        }

        if (GetFavoritesPath(szFavFolder, countof(szFavFolder)) == NULL)
        {
            Out(LI0(TEXT("! The path to the <Favorites> folder could not be determined.")));
            goto Exit;
        }

        PathCombine(szFullPath, szFavFolder, szLinksFolder);

        // get the pidl to the links folder
        hr = s_psfDesktop->ParseDisplayName(NULL, NULL, T2W(szFullPath), &ucch, &pidlFavorites, NULL);
        if (FAILED(hr))
        {
            Out(LI1(TEXT("! Getting the pidl to the links folder failed with %s"), GetHrSz(hr)));
            goto Exit;
        }
    }

    // get the IShellFolder for the favorites folder
    hr = s_psfDesktop->BindToObject(pidlFavorites, NULL, IID_IShellFolder, (LPVOID *) &psfFavorites);
    if (FAILED(hr))
    {
        Out(LI2(TEXT("! BindToObject on the %s pidl failed with %s"), !fQL ? TEXT("favorites") : TEXT("links"), GetHrSz(hr)));
        goto Exit;
    }

    hr = orderFavorites(pidlFavorites, psfFavorites, pszFavItems, cFavs);
    if (FAILED(hr))
    {
        Out(LI2(TEXT("! Ordering %s failed with %s"), !fQL ? TEXT("favorites") : TEXT("links"), GetHrSz(hr)));
        goto Exit;
    }

Exit:
    if (pszFavItems != NULL)
        CoTaskMemFree(pszFavItems);

    if (psfFavorites != NULL)
        psfFavorites->Release();

    if (s_psfDesktop != NULL) {
        s_psfDesktop->Release();
        s_psfDesktop = NULL;
    }

    if (pidlFavorites != NULL)
        CoTaskMemFree(pidlFavorites);

    return hr;
}

HRESULT pepSpecialFoldersEnumProc(LPCTSTR pszPath, PWIN32_FIND_DATA pfd, LPARAM lParam, PDWORD *prgdwControl /*= NULL*/)
{
    DFEPSTRUCT  dfep;
    PDFEPSTRUCT pdfep;
    TCHAR       szFolder[MAX_PATH];
    HRESULT     hr;
    UINT        nSpecialFolder;

    ASSERT(pszPath != NULL && pfd != NULL && lParam != NULL && prgdwControl != NULL);

    // empty in-params, so out-params are zero if not set specifically
    ASSERT(HasFlag((*prgdwControl)[PEP_ENUM_INPOS_FLAGS], PEP_SCPE_NOFILES));
    ASSERT(HasFlag((*prgdwControl)[PEP_ENUM_INPOS_FLAGS], PEP_CTRL_ENUMPROCFIRST));
    ZeroMemory((*prgdwControl), sizeof(DWORD) * PEP_ENUM_OUTPOS_LAST);

    //----- Initialization -----
    pdfep = (const PDFEPSTRUCT)lParam;

    ZeroMemory(&dfep, sizeof(dfep));
    dfep.psm         = pdfep->psm;
    dfep.dwInsFlags  = pdfep->dwInsFlags;
    dfep.dwEnumFlags = pdfep->dwEnumFlags;

    //----- Main processing -----
    ASSERT(HasFlag(pfd->dwFileAttributes, FILE_ATTRIBUTE_DIRECTORY));

    // skip based on the file attributes
    if (isFileAttributeIncluded(pdfep->dwInsFlags, pfd->dwFileAttributes))
        return S_OK;

    // skip based on special folder flags
    nSpecialFolder = isSpecialFolderIncluded(pdfep->dwInsFlags, pszPath);

    if (HasFlag(pdfep->dwInsFlags, FD_FAVORITES)) {
        if (1 == nSpecialFolder) {
            Out(LI1(TEXT("Special folder <%s> excluded from removing."), pfd->cFileName));

            (*prgdwControl)[PEP_ENUM_OUTPOS_SECONDCALL] = PEP_CTRL_NOSECONDCALL;
            return S_OK;
        }

        SetFlag(&dfep.dwEnumFlags, DFEP_DELETEEMPTYFOLDER, (0 == nSpecialFolder));
    }
    else {
        if (0 == nSpecialFolder) {
            (*prgdwControl)[PEP_ENUM_OUTPOS_SECONDCALL] = PEP_CTRL_NOSECONDCALL;
            return S_OK;
        }

        SetFlag(&dfep.dwEnumFlags, DFEP_DELETEEMPTYFOLDER, (2 == nSpecialFolder));
    }

    // remove everything unbeneath
    hr = PathEnumeratePath(pszPath,
        PEP_CTRL_USECONTROL,
        pepDeleteFavoritesEnumProc, (LPARAM)&dfep);

    // deal with the folder itself
    if (SUCCEEDED(hr)) {
        if (HasFlag(dfep.dwEnumFlags, DFEP_DELETEEMPTYFOLDER))
            deleteFavoriteFolder(pszPath);

        if (HasFlag(pdfep->dwInsFlags, FD_FAVORITES)) {
            if (!HasFlag(dfep.dwEnumFlags, DFEP_DELETEEMPTYFOLDER))
                Out(LI1(TEXT("Special folder <%s> emptied."), pfd->cFileName));
        }
        else
            if (!HasFlag(dfep.dwEnumFlags, DFEP_DELETEEMPTYFOLDER))
                Out(LI1(TEXT("Special folder <%s> emptied."), pfd->cFileName));

            else
                Out(LI1(TEXT("The entire <%s> folder is removed."), pfd->cFileName));
    }

    PathCombine(szFolder, RK_FAVORDER, pfd->cFileName);
    SHDeleteKey(g_GetHKCU(), szFolder);

    return hr;
}

HRESULT pepDeleteFavoritesEnumProc(LPCTSTR pszPath, PWIN32_FIND_DATA pfd, LPARAM lParam, PDWORD *prgdwControl /*= NULL*/)
{
    IUnknown    *punk;
    PDFEPSTRUCT pdfep;
    HRESULT     hrResult;

    ASSERT(pszPath != NULL && pfd != NULL && lParam != NULL && prgdwControl != NULL);

    // empty in-params, so out-params are zero if not set specifically
    ASSERT(!HasFlag((*prgdwControl)[PEP_ENUM_INPOS_FLAGS], PEP_CTRL_ENUMPROCFIRST));
    ZeroMemory((*prgdwControl), sizeof(DWORD) * PEP_ENUM_OUTPOS_LAST);

    pdfep    = (const PDFEPSTRUCT)lParam;
    punk     = NULL;
    hrResult = S_OK;

    //----- Remove folder (potentially, with desktop.ini inside) -----
    if (HasFlag(pfd->dwFileAttributes, FILE_ATTRIBUTE_DIRECTORY)) {

        // order stream
        if (HasFlag(pdfep->dwEnumFlags, DFEP_DELETEORDERSTREAM)) {
            TCHAR szFolders[MAX_PATH];
            int   iFavoritesLen;

            iFavoritesLen = StrLen(GetFavoritesPath());
            if (iFavoritesLen >= StrLen(pszPath))
                StrCpy(szFolders, RK_FAVORDER);

            else {
                ASSERT(pszPath[iFavoritesLen] == TEXT('\\'));
                PathCombine(szFolders, RK_FAVORDER, (pszPath + iFavoritesLen+1));
            }

            SHDeleteKey(g_GetHKCU(), szFolders);
        }

        // folder itself
        if (HasFlag(pdfep->dwEnumFlags, DFEP_DELETEEMPTYFOLDER))
            deleteFavoriteFolder(pszPath);

        return hrResult;
    }

    //----- Process individual favorite file -----
    ASSERT(!HasFlag(pfd->dwFileAttributes, FILE_ATTRIBUTE_DIRECTORY));

    // skip special file "desktop.ini"
    if (StrCmpI(pfd->cFileName, DESKTOP_INI) == 0 && HasFlag(pfd->dwFileAttributes, FILE_ATTRIBUTE_HIDDEN))
        goto Exit;


    // skip based on the file attributes
    if (isFileAttributeIncluded(pdfep->dwInsFlags, pfd->dwFileAttributes))
        goto NoFolder;

    // skip based on inside-favorite flags
    if (HasFlag(pdfep->dwInsFlags, (FD_REMOVE_IEAK_CREATED | FD_REMOVE_POLICY_CREATED))) {
        HRESULT hr;
        DWORD   dwFlags;
        BOOL    fRemove;

        hr = CreateInternetShortcut(pszPath, IID_IUnknown, (LPVOID *)&punk);
        if (FAILED(hr))
            goto NoFolder;

        dwFlags = GetFavoriteIeakFlags(pszPath, punk);
        if (0 == dwFlags)
            goto NoFolder;

        // only admin-created favorites beyound this point
        fRemove = (HasFlag(dwFlags, 1) && HasFlag(pdfep->dwInsFlags, FD_REMOVE_IEAK_CREATED));

        if (!fRemove)
            fRemove = (HasFlag(dwFlags, 2) && HasFlag(pdfep->dwInsFlags, FD_REMOVE_POLICY_CREATED));

        if (!fRemove) {
            ASSERT(FALSE);
            goto NoFolder;
        }
    }

    // delete offline content
    if (HasFlag(pdfep->dwEnumFlags, DFEP_DELETEOFFLINECONTENT))
        deleteFavoriteOfflineContent(pszPath, punk, pdfep->psm);

    SetFileAttributes(pszPath, FILE_ATTRIBUTE_NORMAL);
    DeleteFile(pszPath);

    goto Exit;

NoFolder:
    (*prgdwControl)[PEP_ENUM_OUTPOS_SECONDCALL] = PEP_CTRL_NOSECONDCALL;

Exit:
    if (punk != NULL)
        punk->Release();

    return hrResult;
}


HRESULT deleteFavoriteOfflineContent(LPCTSTR pszFavorite, IUnknown *punk /*= NULL*/, ISubscriptionMgr2 *psm /*= NULL*/)
{
    IUniformResourceLocator *purl;
    BSTR    bstrUrl;
    LPTSTR  pszUrl;
    HRESULT hr;
    BOOL    fOwnSubMgr;

    ASSERT(pszFavorite != NULL && *pszFavorite != TEXT('\0'));

    //----- Get IUniformResourceLocator on internet shortcut object -----
    if (punk != NULL)
        hr = punk->QueryInterface(IID_IUniformResourceLocator, (LPVOID *)&purl);

    else
        hr = CreateInternetShortcut(pszFavorite, IID_IUniformResourceLocator, (LPVOID *)&purl);

    if (FAILED(hr))
        return hr;

    //----- Get URL -----
    hr = purl->GetURL(&pszUrl);
    purl->Release();

    if (FAILED(hr))
        return hr;

    //----- Delete subscription -----
    fOwnSubMgr = FALSE;
    if (psm == NULL) {
        hr = CoCreateInstance(CLSID_SubscriptionMgr, NULL, CLSCTX_INPROC_SERVER, IID_ISubscriptionMgr2, (LPVOID *)&psm);
        if (FAILED(hr))
            return hr;

        fOwnSubMgr = TRUE;
    }

    bstrUrl = T2BSTR(pszUrl);
    hr      = psm->DeleteSubscription(bstrUrl, NULL);
    SysFreeString(bstrUrl);

    if (fOwnSubMgr)
        psm->Release();

    return hr;
}


HRESULT deleteFavoriteFolder(LPCTSTR pszFolder)
{
    TCHAR   szDesktopIni[MAX_PATH];
    HRESULT hr;
    BOOL    fEmpty;

    ASSERT(pszFolder != NULL && *pszFolder != TEXT('\0'));

    fEmpty = TRUE;
    hr     = PathEnumeratePath(pszFolder,
        PEP_CTRL_ENUMPROCFIRST | PEP_CTRL_NOSECONDCALL,
        pepIsFolderEmptyEnumProc, (LPARAM)&fEmpty);
    if (FAILED(hr))
        return hr;

    if (!fEmpty)
        return S_FALSE;

    PathCombine(szDesktopIni, pszFolder, DESKTOP_INI);
    if (PathFileExists(szDesktopIni)) {
        SetFileAttributes(szDesktopIni, FILE_ATTRIBUTE_NORMAL);
        DeleteFile(szDesktopIni);
    }

    return (0 != RemoveDirectory(pszFolder)) ? S_OK : E_FAIL;
}

HRESULT pepIsFolderEmptyEnumProc(LPCTSTR pszPath, PWIN32_FIND_DATA pfd, LPARAM lParam, PDWORD *prgdwControl /*= NULL*/)
{
    PBOOL pfEmpty;

    ASSERT(pszPath != NULL && pfd != NULL && lParam != NULL && prgdwControl != NULL);
    UNREFERENCED_PARAMETER(pszPath);
    UNREFERENCED_PARAMETER(prgdwControl);

    pfEmpty  = (PBOOL)lParam;
    *pfEmpty = FALSE;

    if (HasFlag(pfd->dwFileAttributes, FILE_ATTRIBUTE_DIRECTORY))
        return S_FALSE;

    if (StrCmpI(pfd->cFileName, DESKTOP_INI) != 0 || !HasFlag(pfd->dwFileAttributes, FILE_ATTRIBUTE_HIDDEN))
        return S_FALSE;

    *pfEmpty = TRUE;
    return S_OK;
}


BOOL isFileAttributeIncluded(UINT nFlags, DWORD dwFileAttributes)
{
    static DWORD s_rgdwMapAttributes[] = {
        FD_REMOVE_HIDDEN,   FILE_ATTRIBUTE_HIDDEN,
        FD_REMOVE_SYSTEM,   FILE_ATTRIBUTE_SYSTEM,
        FD_REMOVE_READONLY, FILE_ATTRIBUTE_READONLY
    };
    DWORD dwAux;
    UINT  i;

    for (dwAux = 0, i = 0; i < countof(s_rgdwMapAttributes); i += 2)
        if (!HasFlag(s_rgdwMapAttributes[i], nFlags))
            dwAux |= s_rgdwMapAttributes[i+1];

    return HasFlag(dwAux, dwFileAttributes);
}

UINT isSpecialFolderIncluded(UINT nFlags, LPCTSTR pszPath)
{
    static MAPDW2PSZ s_mpFolders[] = {
        { FD_CHANNELS        | FD_EMPTY_CHANNELS,        NULL },
        { FD_SOFTWAREUPDATES | FD_EMPTY_SOFTWAREUPDATES, NULL },
        { FD_QUICKLINKS      | FD_EMPTY_QUICKLINKS,      NULL }
    };
    UINT i,
         nResult;

    if (s_mpFolders[0].psz == NULL) {
        s_mpFolders[0].psz = GetChannelsPath();
        s_mpFolders[1].psz = GetSoftwareUpdatesPath();
        s_mpFolders[2].psz = GetLinksPath();
    }

    nResult = 0;

    for (i = 0; i < countof(s_mpFolders); i++)
        if (StrCmpI(s_mpFolders[i].psz, pszPath) == 0 &&
            HasFlag(nFlags, (s_mpFolders[i].dw & FD_FOLDERS))) {
            nResult = 1;

            if (HasFlag(nFlags, (s_mpFolders[i].dw & FD_EMPTY_FOLDERS)))
                nResult = 2;

            break;
        }

    return nResult;
}


HRESULT formStrWithoutPlaceholders(LPCTSTR pszSection, LPCTSTR pszKey, LPCTSTR pszIns,
    LPTSTR pszBuffer, UINT cchBuffer,
    DWORD dwFlags /*= FSWP_DEFAULT */)
{
    TCHAR   szResult[2*MAX_PATH + 1], szAux[MAX_PATH];
    HRESULT hr;
    DWORD   dwLen;
    UINT    nResultSize, nAuxSize;

    if (pszSection == NULL || pszKey == NULL || pszIns == NULL)
        return E_INVALIDARG;

    if (pszBuffer == NULL)
        return E_INVALIDARG;
    if (cchBuffer > 0 && cchBuffer < 3)
        return E_OUTOFMEMORY;
    ZeroMemory(pszBuffer, StrCbFromCch(3));     // triple zero terminate

    if (dwFlags == 0)
        dwFlags = FSWP_DEFAULT;
    if (((dwFlags & FSWP_KEY) == 0) && ((dwFlags & FSWP_VALUE) == 0))
        return E_INVALIDARG;

    szResult[0] = TEXT('\0');
    nResultSize = 1;
    if ((dwFlags & FSWP_KEY) != 0) {
        nResultSize = countof(szResult);
        hr = replacePlaceholders(pszKey, pszIns, szResult, &nResultSize, (dwFlags & FSWP_KEYLDID) != 0);
        if (FAILED(hr))
            return hr;

        if (hr == S_OK)                         // include last TEXT('\0')
            nResultSize++;

        else {
            ASSERT(hr == S_FALSE);

            szResult[0] = TEXT('\0');
            nResultSize = 1;
        }
    }

    szResult[nResultSize] = TEXT('\0');
    if ((dwFlags & FSWP_VALUE) != 0) {
        dwLen = GetPrivateProfileString(pszSection, pszKey, TEXT(""), szAux, countof(szAux), pszIns);
        if (dwLen > 0) {
            nAuxSize = countof(szResult) - nResultSize;
            hr = replacePlaceholders(szAux, pszIns, &szResult[nResultSize], &nAuxSize, (dwFlags & FSWP_VALUELDID) != 0);
            if (FAILED(hr))
                return hr;

            nResultSize += nAuxSize;
        }
    }

    nResultSize++;
    if (cchBuffer > 0 && cchBuffer <= nResultSize)
        return E_OUTOFMEMORY;

    ASSERT(szResult[nResultSize - 1] == TEXT('\0'));
    szResult[nResultSize] = TEXT('\0');         // double zero terminate
    CopyMemory(pszBuffer, szResult, StrCbFromCch(nResultSize + 1));

    return S_OK;
}

HRESULT replacePlaceholders(LPCTSTR pszSrc, LPCTSTR pszIns, LPTSTR pszBuffer, PUINT pcchBuffer, BOOL fLookupLDID /*= FALSE*/)
{
    static const TCHAR s_szStrings[] = TEXT("Strings");

    TCHAR   szResult[2 * MAX_PATH],
            szAux1[MAX_PATH], szAux2[MAX_PATH];
    LPCTSTR pszAux;
    HRESULT hr;
    DWORD   dwLen;
    UINT    nLeftPos, nRightPos, nTokenLen,
            nDestPos;

    if (pszSrc == NULL)
        return E_INVALIDARG;

    if (pszBuffer == NULL || pcchBuffer == NULL)
        return E_INVALIDARG;
    *pszBuffer = TEXT('\0');

    hr       = S_FALSE;
    nDestPos = 0;
    nLeftPos = (UINT)-1;
    for (pszAux = pszSrc; *pszAux != TEXT('\0'); pszAux = CharNext(pszAux)) {
        if (*pszAux != TEXT('%')) {
            szResult[nDestPos++] = *pszAux;

#ifndef _UNICODE
            if (IsDBCSLeadByte(*pszAux))
                szResult[nDestPos++] = *(pszAux + 1);   // copy the trail byte as well
#endif
            continue;
        }
        else {
#ifndef _UNICODE
            ASSERT(!IsDBCSLeadByte(*pszAux));
#endif
            if (*(pszAux + 1) == TEXT('%')) {   // "%%" is just '%' in the string
                if (nLeftPos != (UINT)-1)
                    // REVIEW: (andrewgu) "%%" are not allowed inside tokens. this also means that
                    // tokens can't be like %foo%%bar%, where the intention is for foo and bar to
                    // be tokens.
                    return E_UNEXPECTED;

                szResult[nDestPos++] = *pszAux;
                pszAux++;
                continue;
            }
        }

        nRightPos = UINT(pszAux - pszSrc);      // initialized, but not necessarily used as such
        if (nLeftPos == (UINT)-1) {
            nLeftPos = nRightPos;
            continue;
        }

        // "%%" is invalid here
        ASSERT(nLeftPos < nRightPos - 1);
        nTokenLen = nRightPos-nLeftPos - 1;

        hr = S_OK;
        StrCpyN(szAux1, pszSrc + nLeftPos+1, nTokenLen + 1);
        dwLen = GetPrivateProfileString(s_szStrings, szAux1, TEXT(""), szAux2, countof(szAux2), pszIns);
        if (dwLen == 0)                         // there is no such string
            return !fLookupLDID ? E_FAIL : E_NOTIMPL;

        ASSERT(nDestPos >= nTokenLen);
        StrCpyN(&szResult[nDestPos - nTokenLen], szAux2, countof(szResult) - (nDestPos-nTokenLen));
        nDestPos += dwLen - nTokenLen;

        nLeftPos = (UINT)-1;
    }
    if (nLeftPos != (UINT)-1)                   // mismatched '%'
        return E_UNEXPECTED;

    if (*pcchBuffer > 0 && *pcchBuffer <= nDestPos)
        return E_OUTOFMEMORY;

    szResult[nDestPos] = TEXT('\0');            // make sure zero terminated
    StrCpy(pszBuffer, szResult);
    *pcchBuffer = nDestPos;

    return hr;
}


// Get the favorites titles
// For example, if .ins contains the following lines:
//    [FavoritesEx]
//    Title1=Name1.url
//    Url1=...
//    Title2=Foo\Name2.url
//    Url2=...
//    Title3=Bar\Name3.url
//    Url3=...
// then *ppszFavItems would point to:
//    Name1.url\0
//    Foo\Name2.url\0
//    Bar\Name3.url\0
//    \0
// and the return value would be 3 (no. of items)
DWORD getFavItems(LPCTSTR pcszSection, LPCTSTR pcszFmt, LPTSTR *ppszFavItems)
{
    TCHAR   szTitle[MAX_PATH + 2],
            szKey[32];
    LPTSTR  pszTitle, pszPtr,
            pszAux;
    HRESULT hr;
    DWORD   dwNItems,
            dwSize, dwLen;
    UINT    nTitleLen;
    BOOL    fContinueOnFailure;

    if (ppszFavItems == NULL)
        return 0;

    fContinueOnFailure = TRUE;
    dwNItems           = 0;
    pszTitle           = &szTitle[1];           // always points to the real title
    dwLen              = 0;

    dwSize        = 1024;                       // initially, allocate buffer of size 1K
    *ppszFavItems = (LPTSTR)CoTaskMemAlloc(StrCbFromCch(dwSize));
    if (ppszFavItems == NULL)
        goto Exit;
    ZeroMemory(*ppszFavItems, StrCbFromCch(dwSize));

    for (dwNItems = 0; TRUE; dwNItems++) {
        pszPtr = *ppszFavItems + dwLen;

        // read in the current title; decode it
        wnsprintf(szKey, countof(szKey), pcszFmt, dwNItems + 1);
        hr = formStrWithoutPlaceholders(pcszSection, szKey, g_GetIns(), szTitle, countof(szTitle), FSWP_VALUE);
        if (FAILED(hr))
            if (fContinueOnFailure)
                continue;

            else {
                dwNItems = 0;
                goto Exit;
            }
        ASSERT(szTitle[0] == TEXT('\0'));
        if (*pszTitle == TEXT('\0'))
            break;

        DecodeTitle(pszTitle, g_GetIns());
        nTitleLen = StrLen(pszTitle) + 1;       // include terminating TEXT('\0')

        // increase return buffer (if necessary)
        if (dwLen + nTitleLen > dwSize - 1) {
            dwSize += 1024;
            pszAux  = (LPTSTR)CoTaskMemRealloc(*ppszFavItems, StrCbFromCch(dwSize));
            if (pszAux == NULL) {
                dwNItems = 0;
                goto Exit;
            }
            ZeroMemory(pszAux + dwSize - 1024, StrCbFromCch(1024));

            *ppszFavItems = pszAux;
            pszPtr        = *ppszFavItems + dwLen;
        }

        // copy current title to the buffer
        StrCpyN(pszPtr, pszTitle, nTitleLen);
        dwLen += nTitleLen;
    }
    *(*ppszFavItems + dwLen) = TEXT('\0');      // double zero terminate

Exit:
    if (dwNItems == 0 && *ppszFavItems != NULL) {
        CoTaskMemFree(*ppszFavItems);
        *ppszFavItems = NULL;
    }

    return dwNItems;
}

// Order Favorites (recursively)
HRESULT orderFavorites(LPITEMIDLIST pidlFavFolder, IShellFolder *psfFavFolder, LPTSTR pszFavItems, DWORD cFavs)
{   MACRO_LI_PrologEx_C(PIF_STD_C, orderFavorites)

    HRESULT hr = S_OK;

    // first, order the current favorite folder.
    // then do a depth first traversal and order each sub folder recursively

    // order the current favorite folder.
    hr = orderFavoriteFolder(pidlFavFolder, psfFavFolder, pszFavItems, cFavs);
    if (FAILED(hr))
        goto Exit;

    while (*pszFavItems)
    {
        LPTSTR pszSubFolderItems;
        DWORD dwLen;

        if ((pszSubFolderItems = StrChr(pszFavItems, TEXT('\\'))) != NULL)      // a sub folder is specified
        {
            TCHAR szFolderName[MAX_PATH];
            DWORD dwNItems;
            WCHAR *pwszFullPath = NULL,
                  wszFullPath[MAX_PATH];
            ULONG ucch;
            LPITEMIDLIST pidlFavSubFolder = NULL;
            IShellFolder *psfFavSubFolder = NULL;
            STRRET str;

            StrCpyN(szFolderName, pszFavItems, (int)(pszSubFolderItems - pszFavItems + 1));

            // retrieve the section that corresponds to szFolderName from pszFavItems
            dwLen = getFolderSection(szFolderName, pszFavItems, &pszSubFolderItems, &dwNItems);

            // get the display name for the current FavFolder
            hr = s_psfDesktop->GetDisplayNameOf(pidlFavFolder, SHGDN_FORPARSING, &str);
            if (FAILED(hr))
                goto Cleanup;

            hr = StrRetToStrW(&str, pidlFavFolder, &pwszFullPath);
            if (FAILED(hr))
                goto Cleanup;

            StrCpyW(wszFullPath, pwszFullPath);
            CoTaskMemFree(pwszFullPath);
            pwszFullPath = NULL;

            // get the full pidl for the current SubFolder
            PathAppendW(wszFullPath, T2CW(szFolderName));
            hr = s_psfDesktop->ParseDisplayName(NULL, NULL, wszFullPath, &ucch, &pidlFavSubFolder, NULL);
            if (FAILED(hr))
                goto Cleanup;

            // get the IShellFolder for the current SubFolder
            hr = s_psfDesktop->BindToObject(pidlFavSubFolder, NULL, IID_IShellFolder, (LPVOID *) &psfFavSubFolder);
            if (FAILED(hr))
                goto Cleanup;

            // recursively process this sub folder
            hr = orderFavorites(pidlFavSubFolder, psfFavSubFolder, pszSubFolderItems, dwNItems);
            if (FAILED(hr))
                goto Cleanup;

            Out(LI1(TEXT("%s folder has been ordered successfully!"), szFolderName));

Cleanup:
            if (psfFavSubFolder != NULL)
                psfFavSubFolder->Release();

            if (pidlFavSubFolder != NULL)
                CoTaskMemFree(pidlFavSubFolder);

            if (pwszFullPath != NULL)
                CoTaskMemFree(pwszFullPath);

            if (FAILED(hr))
                goto Exit;
        }
        else
            dwLen = StrLen(pszFavItems) + 1;

        pszFavItems += dwLen;
    }

Exit:
    return hr;
}


HRESULT orderFavoriteFolder(LPITEMIDLIST pidlFavFolder, IShellFolder *psfFavFolder, LPCTSTR pcszFavItems, DWORD cFavs)
{
    HRESULT hr;
    IPersistFolder *pPF = NULL;
    IOrderList *pOL = NULL;
    HDPA hdpa = NULL;
    INT iInsertPos = 0;
    TCHAR szFavSubFolder[MAX_PATH] = TEXT("");
    DWORD dwIndex;
    SHChangeDWORDAsIDList dwidl;

    // Get the IOrderList for the FavFolder
    hr = CoCreateInstance(CLSID_OrderListExport, NULL, CLSCTX_INPROC_SERVER, IID_IPersistFolder, (LPVOID *) &pPF);
    if (FAILED(hr))
        goto Exit;

    hr = pPF->Initialize(pidlFavFolder);
    if (FAILED(hr))
        goto Exit;

    hr = pPF->QueryInterface(IID_IOrderList, (LPVOID *) &pOL);
    if (FAILED(hr))
        goto Exit;

    hr = pOL->GetOrderList(&hdpa);
    if (hdpa == NULL)
    {
        // create a DPA list if there wasn't one already
        if ((hdpa = DPA_Create(2)) == NULL)
            goto Exit;
    }
    else
    {
        PORDERITEM poi;

        // by default, when the favorites are added, they are sorted by name
        // and the nOrder is set to -5.

        // if nOrder in the first item is negative, then nOrder in all the items will be negative
        poi = (PORDERITEM) DPA_GetPtr(hdpa, 0);
        if (poi != NULL  &&  poi->nOrder < 0)
        {
            INT i;

            // fix up the nOrder with its positive index value
            poi->nOrder = 0;
            for (i = 1;  (poi = (PORDERITEM) DPA_GetPtr(hdpa, i)) != NULL;  i++)
            {
                ASSERT(poi->nOrder < 0);
                poi->nOrder = i;
            }
        }
    }

    for (dwIndex = 0;  dwIndex < cFavs;  dwIndex++, pcszFavItems += StrLen(pcszFavItems) + 1)
    {
        LPCTSTR pcszItem;
        WCHAR wszFavItem[MAX_PATH];
        ULONG ucch;
        LPITEMIDLIST pidlFavItem = NULL;
        PORDERITEM poi;
        INT iCurrPos = -1;
        INT i;

        if ((pcszItem = StrChr(pcszFavItems, TEXT('\\'))) != NULL)
        {
            // a sub folder is specified

            // check if we have already processed this folder
            if (StrCmpNI(szFavSubFolder, pcszFavItems, (int)(pcszItem - pcszFavItems)) == 0)
                continue;

            // we haven't processed it; save the sub folder name in szFavSubFolder
            StrCpyN(szFavSubFolder, pcszFavItems, (int)(pcszItem - pcszFavItems + 1));
            pcszItem = szFavSubFolder;
        }
        else
            // this is a favorite item
            pcszItem = pcszFavItems;

        // get the pidl for the current FavItem
        T2Wbuf(pcszItem, wszFavItem, countof(wszFavItem));
        hr = psfFavFolder->ParseDisplayName(NULL, NULL, wszFavItem, &ucch, &pidlFavItem, NULL);
        if (FAILED(hr))
            goto Cleanup;

        // find out if the current FavItem exists in the DPA list
        i = 0;
        while ((poi = (PORDERITEM)DPA_GetPtr(hdpa, i++)) != NULL)
            if (psfFavFolder->CompareIDs(0, pidlFavItem, poi->pidl) == 0)
            {
                // match found; we should insert this item at iInsertPos
                iCurrPos = poi->nOrder;
                break;
            }

        if (iCurrPos == -1)             // item not found
        {
            // allocate an order item to insert
            hr = pOL->AllocOrderItem(&poi, pidlFavItem);
            if (FAILED(hr))
                goto Exit;

            // append it to the DPA list
            if ((iCurrPos = DPA_AppendPtr(hdpa, (LPVOID) poi)) >= 0)
                poi->nOrder = iCurrPos;
            else
            {
                hr = E_FAIL;
                goto Cleanup;
            }
        }

        // reorder the DPA list.
        // the current FavItem is at iCurrPos; we should move it to iInsertPos.
        if (iCurrPos != iInsertPos)
        {
            int i = 0;
            while ((poi = (PORDERITEM) DPA_GetPtr(hdpa, i++)) != NULL)
            {
                if (poi->nOrder == iCurrPos  &&  iCurrPos >= iInsertPos)
                    poi->nOrder = iInsertPos;
                else if (poi->nOrder >= iInsertPos  &&  poi->nOrder < iCurrPos)
                    poi->nOrder++;
            }
        }

        iInsertPos++;

Cleanup:
        if (pidlFavItem != NULL)
            CoTaskMemFree(pidlFavItem);

        if (FAILED(hr))
            goto Exit;
    }

    // sort the DPA list by name
    // the reason why we should sort by name (from lamadio):
    //   "The incoming list of filenames is sorted by name. Then we merge, so the order list needs to be sorted by name.
    //    It's for faster startup."
    pOL->SortOrderList(hdpa, OI_SORTBYNAME);

    // save the DPA list
    hr = pOL->SetOrderList(hdpa, psfFavFolder);
    if (FAILED(hr))
        goto Exit;

    // Notify everyone that the order has changed
    dwidl.cb = sizeof(dwidl) - sizeof(dwidl.cbZero);
    dwidl.dwItem1 = SHCNEE_ORDERCHANGED;
    dwidl.dwItem2 = 0;
    dwidl.cbZero = 0;

    SHChangeNotify(SHCNE_EXTENDED_EVENT, 0, (LPCITEMIDLIST) &dwidl, pidlFavFolder);

Exit:
    if (hdpa != NULL)
        pOL->FreeOrderList(hdpa);

    if (pOL != NULL)
        pOL->Release();

    if (pPF != NULL)
        pPF->Release();

    return hr;
}

// Get the favorite items that contain pcszFolderName as prefix
// For example, if pcszFolderName is "Foo" and if pszSection points to:
//    Foo\Name1.url\0
//    Foo\Name2.url\0
//    Bar\Name3.url\0
//    etc.
// then *ppszFolderItems would point to:
//    Name1.url\0
//    Name2.url\0
//    \0
// and *pdwNItems would contain 2 (no. of items).
//
// Note that manipulations are done in place within the buffer that's pointed to by pszSection;
// no new buffer is allocated for *ppszFolderItems.
// The return value is the length (in chars) of the lines that got modified.  In this example,
// the length returned = (StrLen("Foo\Name1.url") + 1) + (StrLen("Foo\Name2.url") + 1).
DWORD getFolderSection(LPCTSTR pcszFolderName, LPTSTR pszSection, LPTSTR *ppszFolderItems, LPDWORD pdwNItems)
{
    DWORD dwLen = 0;
    DWORD dwFolderLength;
    LPTSTR pszCurr;

    *ppszFolderItems = pszSection;
    *pdwNItems = 0;

    pszCurr = pszSection;
    dwFolderLength = StrLen(pcszFolderName);
    while ((StrCmpNI(pszSection, pcszFolderName, dwFolderLength) == 0) &&
           (pszSection[dwFolderLength] == TEXT('\\')))   // should succeed the first time
    {
        DWORD dwTmp = StrLen(pszSection) + 1;

        // remove the FolderName prefix and copy the remaining name to position pszCurr
        StrCpy(pszCurr, pszSection + StrLen(pcszFolderName) + 1);
        pszCurr += StrLen(pszCurr) + 1;

        // increment the no. of items
        (*pdwNItems)++;

        dwLen += dwTmp;
        pszSection += dwTmp;
    }

    *pszCurr = TEXT('\0');              // double nul terminate

    return dwLen;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\brandll\clear.h ===
#ifndef _CLEAR_H_
#define _CLEAR_H_

void ClearZonesHklm(DWORD dwFlags = FF_ENABLE);
void ClearRatings(DWORD dwFlags = FF_ENABLE);
void ClearAuthenticode(DWORD dwFlags = FF_ENABLE);
void ClearGeneral(DWORD dwFlags = FF_ENABLE);
void ClearChannels(DWORD dwFlags = FF_ENABLE);
void ClearToolbarButtons(DWORD dwFlags = FF_ENABLE);

// brandfav.cpp
void ClearFavorites(DWORD dwFlags = FF_ENABLE);

// brandcs.cpp
void ClearConnectionSettings(DWORD dwFlags = FF_ENABLE);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\brandll\cabver.h ===
#ifndef _CABVER_H_
#define _CABVER_H_

struct SCabVersion
{
// Constructors
public:
    SCabVersion(LPCTSTR pszVer = NULL)
        { Init(pszVer); }

// Attributes
public:
    WORD cv_w1;                                 // most sig version number
    WORD cv_w2;
    WORD cv_w3;
    WORD cv_w4;                                 // least sig version number

// Operations
public:
    BOOL Init(LPCTSTR pszVer = NULL)
    {
        LPCTSTR pszToken, pszDelim;
        int     iAux;
        BOOL    fOK;

        cv_w1 = cv_w2 = cv_w3 = cv_w4 = 0;
        if (pszVer == NULL || *pszVer == TEXT('\0'))
            return TRUE;

        fOK = FALSE;

        pszToken = pszVer;
        pszDelim = StrChr(pszToken, TEXT('.'));
        if (pszDelim == NULL)
            return fOK;

        if (*pszToken != TEXT('\0') && StrToIntEx(pszToken, STIF_SUPPORT_HEX, &iAux)) {
            cv_w1 = (WORD)iAux;

            pszToken = pszDelim + 1;
            pszDelim = StrChr(pszToken, TEXT('.'));
            if (pszDelim == NULL)
                return fOK;

            if (*pszToken != TEXT('\0') && StrToIntEx(pszToken, STIF_SUPPORT_HEX, &iAux)) {
                cv_w2 = (WORD)iAux;

                pszToken = pszDelim + 1;
                pszDelim = StrChr(pszToken, TEXT('.'));
                if (*pszToken != TEXT('\0') && StrToIntEx(pszToken, STIF_SUPPORT_HEX, &iAux)) {
                    cv_w3 = (WORD)iAux;

                    if (pszDelim != NULL) {
                        pszToken = pszDelim + 1;
                        if (*pszToken == TEXT('\0'))
                            fOK = TRUE;

                        else
                            if (StrToIntEx(pszToken, STIF_SUPPORT_HEX, &iAux)) {
                                cv_w4 = (WORD)iAux;

                                fOK = TRUE;
                            }
                    }
                    else
                        fOK = TRUE;
                }
            }
        }

        return fOK;
    }

    int Compare(const SCabVersion& cv) const
    {
        int i;

        i = compareItem(cv_w1, cv.cv_w1);
        if (i == 0) {
            i = compareItem(cv_w2, cv.cv_w2);
            if (i == 0) {
                i = compareItem(cv_w3, cv.cv_w3);
                if (i == 0)
                    i = compareItem(cv_w4, cv.cv_w4);
            }
        }

        return i;
    }

    BOOL operator==(const SCabVersion& cv) const
        { return (Compare(cv) == 0); }

    BOOL operator!=(const SCabVersion& cv) const
        { return (Compare(cv) != 0); }

    BOOL operator< (const SCabVersion& cv) const
        { return (Compare(cv) <  0); }

    BOOL operator> (const SCabVersion& cv) const
        { return (Compare(cv) >  0); }

    BOOL operator<=(const SCabVersion& cv) const
        { return (Compare(cv) <= 0); }

    BOOL operator>=(const SCabVersion& cv) const
        { return (Compare(cv) >= 0); }

// Implementation
protected:
    // implementation helper routines
    static int compareItem(WORD w1, WORD w2)
    {
        if (w1 > w2)
            return 1;
        if (w1 < w2)
            return -1;

        return 0;
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\brandll\cmdline.cpp ===
#include "precomp.h"
#include "globalsw.h"

HRESULT getCommandValuePairs(PCTSTR pszCmdLine, PTSTR pszResult, UINT cchResult);
HRESULT getFeatureCodePairs (PCTSTR pszCmdLine, PBYTE pbResult,  UINT cbResult);

BOOL    getCommand(PCTSTR pszMark, PCTSTR *ppszEnd);
BOOL    getValue  (PCTSTR pszMark, PCTSTR *ppszEnd);

PCTSTR  skipChars(PCTSTR pszStart, BOOL fWhitespace);
BOOL    isWhitespace (TCHAR ch);
BOOL    isCommandMark(TCHAR ch);
BOOL    isValueMark  (TCHAR ch);


HRESULT GetCmdLineSwitches(PCTSTR pszCmdLine, PCMDLINESWITCHES pcls)
{
    static PCTSTR s_rgpszCommands[] = {
        TEXT("mode"),
        TEXT("ins"),
        TEXT("target"),
        TEXT("peruser"),
        TEXT("flags"),
        TEXT("disable")
    };

    static MAPDW2PSZ s_mpContexts[] = {
        { CTX_GENERIC,      TEXT("generic")    },
        { CTX_CORP,         TEXT("corp")       },
        { CTX_ISP,          TEXT("isp")        },
        { CTX_ICP,          TEXT("icp")        },
        { CTX_AUTOCONFIG,   TEXT("autoconfig") },
        { CTX_ICW,          TEXT("icw")        },
        { CTX_W2K_UNATTEND, TEXT("win2000")    },
        { CTX_INF_AND_OE,   NULL               },
        { CTX_BRANDME,      NULL               },
        { CTX_GP,           TEXT("gp")         }
    };

    static MAPDW2PSZ s_mpSignupModes[] = {
        { CTX_SIGNUP_ICW,    TEXT("icw")    },
        { CTX_SIGNUP_KIOSK,  TEXT("kiosk")  },
        { CTX_SIGNUP_CUSTOM, TEXT("custom") }
    };

    CMDLINESWITCHES cls;
    TCHAR   szBuffer [3 * MAX_PATH];
    BYTE    rgbBuffer[StrCbFromCch(MAX_PATH)];
    PTSTR   pszLeft, pszRight,
            pszAux;
    PDWORD  pdwFlags;
    HRESULT hr;
    UINT    i,
            cchAux,
            cchAux2;

    //----- Initialization -----
    if (pcls == NULL)
        return E_INVALIDARG;

    ZeroMemory(pcls, sizeof(CMDLINESWITCHES));
    pcls->dwContext = CTX_UNINITIALIZED;
    for (i = 0; i < countof(pcls->rgdwFlags); i++)
        pcls->rgdwFlags[i] = FF_INVALID;
    pcls->rgdwFlags[FID_WININETSETUP    ] = FF_ENABLE;
    pcls->rgdwFlags[FID_ACTIVESETUPSITES] = FF_ENABLE;
    pcls->rgdwFlags[FID_REFRESHBROWSER  ] = FF_ENABLE;

    if (pszCmdLine == NULL || *pszCmdLine == TEXT('\0'))
        return S_FALSE;                         // return initialized structure

    ZeroMemory(&cls, sizeof(cls));
    cls.dwContext = CTX_UNINITIALIZED;
    for (i = 0; i < countof(cls.rgdwFlags); i++)
        cls.rgdwFlags[i] = FF_INVALID;
    cls.rgdwFlags[FID_WININETSETUP    ] = FF_ENABLE;
    cls.rgdwFlags[FID_ACTIVESETUPSITES] = FF_ENABLE;
    cls.rgdwFlags[FID_REFRESHBROWSER  ] = FF_ENABLE;

    hr = getCommandValuePairs(pszCmdLine, szBuffer, countof(szBuffer));
    if (FAILED(hr))
        return hr;

    //----- Enumerate swithches pairs -----
    for (pszLeft = szBuffer; TEXT('\0') != *pszLeft; pszLeft = pszRight + cchAux2) {
        cchAux   = StrLen(pszLeft);
        pszRight = pszLeft + cchAux+1;
        cchAux2 = StrLen(pszRight)+1;
        ASSERT(TEXT('\0') == *pszRight || !isWhitespace(*pszRight));

        //_____ Look up current command _____
        for (i = 0; i < countof(s_rgpszCommands); i++)
            if (0 == StrCmpNI(pszLeft, s_rgpszCommands[i], min(cchAux, (UINT)StrLen(s_rgpszCommands[i]))))
                break;
        if (i >= countof(s_rgpszCommands))
            continue;

        //_____ Process recognized commands _____
        switch (*s_rgpszCommands[i]) {

        //- - - Context command - - -
        case TEXT('m'):
            pszAux = StrChrI(pszRight, TEXT(','));
            if (NULL != pszAux) {
                *pszAux = TEXT('\0');
                pszAux++;

                StrRemoveWhitespace(pszRight);
                StrRemoveWhitespace(pszAux);
            }

            cchAux = StrLen(pszRight);
            for (i = 0; i < countof(s_mpContexts); i++)
                if (NULL != s_mpContexts[i].psz &&
                    0 == StrCmpNI(pszRight, s_mpContexts[i].psz, min(cchAux, (UINT)StrLen(s_mpContexts[i].psz))))
                    break;
            if (i >= countof(s_mpContexts) || CTX_UNINITIALIZED != cls.dwContext)
                break;

            cls.dwContext = s_mpContexts[i].dw;
            if (HasFlag(cls.dwContext, CTX_ISP) && NULL != pszAux) {
                cchAux = StrLen(pszAux);
                for (i = 0; i < countof(s_mpSignupModes); i++)
                    if (NULL != s_mpSignupModes[i].psz &&
                        0 == StrCmpNI(pszAux, s_mpSignupModes[i].psz, min(cchAux, (UINT)StrLen(s_mpSignupModes[i].psz))))
                        break;
                if (i >= countof(s_mpSignupModes))
                    break;

                cls.dwContext |= s_mpSignupModes[i].dw;
            }
            break;

        //- - - .ins file and target folder path commands - - -
        case TEXT('i'):
        case TEXT('t'):
            pszAux = (TEXT('i') == *s_rgpszCommands[i]) ? cls.szIns : cls.szTargetPath;

            PathUnquoteSpaces(pszRight);
            PathRemoveBlanks (pszRight);
            StrCpy(pszAux, pszRight);
            break;

        //- - - PerUser command - - -
        case TEXT('p'):
            cls.fPerUser = TRUE;
            break;

        //- - - Feature flags command - - -
        case TEXT('f'):
            hr = getFeatureCodePairs(pszRight, rgbBuffer, sizeof(rgbBuffer));
            if (FAILED(hr)) {
                hr = S_FALSE;                   // partial success
                break;
            }

            for (pszLeft = (PTSTR)rgbBuffer; TEXT('\0') != *pszLeft; pszLeft = (PTSTR)(pdwFlags+1)) 
            {
                // flags are stored on aligned offsets
                pdwFlags = (PDWORD)(pszLeft + ((StrLen(pszLeft)+1 + sizeof(DWORD)-1) & ~(sizeof(DWORD)-1)));

                for (i = 0; i < countof(g_mpFeatures); i++)
                {
                    if (NULL != g_mpFeatures[i].psz &&
                        0 == StrCmpI(pszLeft, g_mpFeatures[i].psz))
                        break;
                }
                if (i >= countof(g_mpFeatures))
                    break;

                cls.rgdwFlags[g_mpFeatures[i].dw] = *pdwFlags;
            }
            break;

        //- - - Disable command - - -
        case TEXT('d'):
            cls.fDisable = TRUE;
            break;
        }
    }

    ASSERT(SUCCEEDED(hr));
    CopyMemory(pcls, &cls, sizeof(cls));

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// Implementation helper routines

HRESULT getCommandValuePairs(PCTSTR pszCmdLine, PTSTR pszResult, UINT cchResult)
{
    TCHAR   szBuffer[3 * MAX_PATH];
    PCTSTR  pszCur, pszAux, pszEnd;
    HRESULT hr;
    UINT    cchBuffer;
    BOOL    fResult;

    if (pszCmdLine == NULL || *pszCmdLine == TEXT('\0'))
        return E_INVALIDARG;

    if (pszResult == NULL)
        return E_INVALIDARG;
    *pszResult = TEXT('\0');

    hr        = S_OK;
    cchBuffer = 0;

    //----- Find first pair -----
    BOOL fSwitch;

    pszCur  = skipChars(pszCmdLine, TRUE);
    fSwitch = TRUE;
    for (; TEXT('\0') != pszCur; fSwitch = !fSwitch, pszCur = skipChars(pszCur, fSwitch))
        if (isCommandMark(*pszCur))
            break;

    if (TEXT('\0') == *pszCur)
        return S_FALSE;                         // nothing there, partial success

    //----- Enumerate pairs -----
    for (; NULL != pszCur && TEXT('\0') != *pszCur; pszCur = pszEnd) {
        ASSERT(isCommandMark(*pszCur));
        fResult = getCommand(pszCur, &pszEnd);

        if (!fResult) {
            if (isValueMark(*pszEnd))
                getValue(pszEnd, &pszEnd);

            hr = S_FALSE;                       // partial success
        }
        else
            if (isValueMark(*pszEnd)) {
                pszAux  = pszEnd;
                fResult = getValue(pszAux, &pszEnd);

                if (!fResult)
                    hr = S_FALSE;               // partial success

                else {
                    // copy pair to the out buffer
                    StrCpyN(&szBuffer[cchBuffer], pszCur + 1, (int)(pszAux - pszCur));
                    StrRemoveWhitespace(&szBuffer[cchBuffer]);
                    cchBuffer += StrLen(&szBuffer[cchBuffer]) + 1;

                    StrCpyN(&szBuffer[cchBuffer], pszAux + 1, (int)(pszEnd - pszAux));
                    StrRemoveWhitespace(&szBuffer[cchBuffer]);
                    cchBuffer += StrLen(&szBuffer[cchBuffer]) + 1;
                }
            }
            else {
                ASSERT(TEXT('\0') == *pszEnd || isCommandMark(*pszEnd));

                // copy pair to the out buffer
                StrCpyN(&szBuffer[cchBuffer], pszCur + 1, (int)(pszEnd - pszCur));
                StrRemoveWhitespace(&szBuffer[cchBuffer]);
                cchBuffer += StrLen(&szBuffer[cchBuffer]) + 1;

                // no value
                szBuffer[cchBuffer] = TEXT('\0');
                cchBuffer++;
            }

        ASSERT(NULL == pszEnd || TEXT('\0') == *pszEnd || isCommandMark(*pszEnd));
    }

    // add empty command to indicate the end
    szBuffer[cchBuffer] = TEXT('\0');
    cchBuffer++;

    //----- Set out-parameters -----
    if (cchResult != 0 && cchBuffer > cchResult)
        hr = E_OUTOFMEMORY;

    else
        CopyMemory(pszResult, szBuffer, StrCbFromCch(cchBuffer));

    return hr;
}

HRESULT getFeatureCodePairs(PCTSTR pszCmdLine, PBYTE pbResult, UINT cbResult)
{
    BYTE    rgbBuffer[StrCbFromCch(MAX_PATH)];
    PCTSTR  pszCur, pszAux, pszEnd;
    HRESULT hr;
    UINT    cbBuffer;
    DWORD   dwCode;

    if (pszCmdLine == NULL || *pszCmdLine == TEXT('\0'))
        return E_INVALIDARG;

    if (pbResult == NULL)
        return E_INVALIDARG;
    *(PTSTR)pbResult = TEXT('\0');

    hr        = S_OK;
    cbBuffer  = 0;

    for (pszCur = pszCmdLine; TEXT('\0') != *pszCur; pszCur = pszEnd) {
        //----- Isolate token -----
        pszEnd = StrChr(pszCur, TEXT(','));
        if (pszEnd == NULL) {
            pszEnd = pszCur + StrLen(pszCur);
            ASSERT(*pszEnd == TEXT('\0'));
        }

        //----- Split token at the '=' character -----
        for (pszAux = pszCur; TEXT('=') != *pszAux && pszAux < (pszEnd - 1); pszAux++)
            ;
        if (TEXT('=') != *pszAux)
            continue;

        _int32 iCode;

        StrToIntEx(pszAux + 1, STIF_SUPPORT_HEX, &iCode);
        dwCode = (DWORD)iCode;

        //----- Copy pair to the out buffer -----
        StrCpyN((PTSTR)&rgbBuffer[cbBuffer], pszCur, (int)(pszAux - pszCur + 1));
        StrRemoveWhitespace((PTSTR)&rgbBuffer[cbBuffer]);
        cbBuffer += (UINT)StrCbFromSz((PTSTR)&rgbBuffer[cbBuffer]);
        // flags are stored on aligned offsets
        cbBuffer = (cbBuffer + (sizeof(DWORD)-1)) & ~(sizeof(DWORD)-1);

        *(PDWORD)&rgbBuffer[cbBuffer] = dwCode;
        cbBuffer  += sizeof(DWORD);

        if (*pszEnd == TEXT(','))
            pszEnd++;
    }

    // add empty feature id to indicate the end
    *(PTSTR)&rgbBuffer[cbBuffer] = TEXT('\0');
    cbBuffer += StrCbFromCch(1);

    //----- Set out-parameters -----
    if (cbResult != 0 && cbBuffer > cbResult)
        hr = E_OUTOFMEMORY;

    else
        CopyMemory(pbResult, rgbBuffer, cbBuffer);

    return hr;
}


BOOL getCommand(PCTSTR pszMark, PCTSTR *ppszEnd)
{
    PCTSTR pszCur;
    BOOL   fValid,
           fResult;

    ASSERT(pszMark != NULL && ppszEnd != NULL);
    *ppszEnd = NULL;

    if (TEXT('\0') == *pszMark)
        return FALSE;
    ASSERT(isCommandMark(*pszMark));

    pszCur  = pszMark + 1;
    fValid  = FALSE;
    fResult = TRUE;

    for (pszCur = skipChars(pszCur, TRUE); TEXT('\0') != *pszCur; pszCur = skipChars(pszCur, TRUE), fValid = TRUE) {
        if (isCommandMark(*pszCur))
            break;

        for (; TEXT('\0') != *pszCur && !isWhitespace(*pszCur); pszCur++)
            if (isValueMark(*pszCur))
                break;

        if (isValueMark(*pszCur))
            break;
    }
    ASSERT(TEXT('\0') == *pszCur || isCommandMark(*pszCur) || isValueMark(*pszCur));

    if (TEXT('\0') == *pszCur) {
        if (!fValid)
            fResult = FALSE;                    // whitespace only after the mark
    }
    else if (isCommandMark(*pszCur)) {
        if (!fValid)
            fResult = FALSE;                    // no separating whitespace
    }
    else {
        ASSERT(isValueMark(*pszCur));
        ASSERT(pszCur > pszMark);

        if (!fValid && isWhitespace(*(pszCur - 1)))
            fResult = FALSE;                    // no command between mark and ':'
    }

    *ppszEnd = pszCur;
    return fResult;
}

BOOL getValue(PCTSTR pszMark, PCTSTR *ppszEnd)
{
    PCTSTR pszCur;
    BOOL   fValid,
           fResult;

    ASSERT(pszMark != NULL && ppszEnd != NULL);
    *ppszEnd = NULL;

    if (TEXT('\0') == *pszMark)
        return FALSE;
    ASSERT(isValueMark(*pszMark));

    pszCur  = pszMark + 1;
    fValid  = FALSE;
    fResult = TRUE;

    for (pszCur = skipChars(pszCur, TRUE); TEXT('\0') != *pszCur; pszCur = skipChars(pszCur, TRUE), fValid = TRUE) {
        if (isCommandMark(*pszCur))
            break;

        if (TEXT('"') == *pszCur)
            pszCur = StrChr(pszCur + 1, TEXT('"'));

        if (NULL != pszCur)
            pszCur = skipChars(pszCur + 1, FALSE);

        else {
            fResult = FALSE;                    // no closing '"'
            break;
        }
    }
    ASSERT(NULL == pszCur || TEXT('\0') == *pszCur || isCommandMark(*pszCur));

    if (fResult) {
        if (TEXT('\0') == *pszCur) {
            if (!fValid)
                fResult = FALSE;                // whitespace only after the mark
        }
        else {
            ASSERT(isCommandMark(*pszCur));

            if (!fValid)
                fResult = FALSE;                // no separating whitespace
        }
    }

    *ppszEnd = pszCur;
    return fResult;
}


PCTSTR skipChars(PCTSTR pszStart, BOOL fWhitespace)
{
    if (pszStart == NULL)
        return NULL;

    while (*pszStart != TEXT('\0') && isWhitespace(*pszStart) == fWhitespace)
        pszStart++;

    return pszStart;
}

BOOL isWhitespace(TCHAR ch)
{
    return (NULL != StrChr(TEXT(" \t\r\n"), ch));
}

BOOL isCommandMark(TCHAR ch)
{
    return (NULL != StrChr(TEXT("/-"), ch));
}

BOOL isValueMark(TCHAR ch)
{
    return (TEXT(':') == ch);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\brandll\clear.cpp ===
#include "precomp.h"
#include "brand.h"

void ClearZonesHklm(DWORD dwFlags /*= FF_ENABLE*/)
{
    UNREFERENCED_PARAMETER(dwFlags);
    //17073[WinSERaid]: W2K GPO: IE Security Zone GPO settings may not apply to the client correctly
    //In theory we should delete HKLM, "...\Internet Settings\ZoneMap" key, but to minimize the changes, 
    //only delete "ZoneMap\Domains"
    SHDeleteKey(HKEY_LOCAL_MACHINE, REG_KEY_ZONEMAP TEXT("\\Domains"));
}

void ClearRatings(DWORD dwFlags /*= FF_ENABLE*/)
{
    UNREFERENCED_PARAMETER(dwFlags);

    SHDeleteKey(HKEY_LOCAL_MACHINE, RK_RATINGS);
}

void ClearAuthenticode(DWORD dwFlags /*= FF_ENABLE*/)
{
    UNREFERENCED_PARAMETER(dwFlags);

    SHDeleteKey(g_GetHKCU(), REG_KEY_AUTHENTICODE);
}

void ClearGeneral(DWORD dwFlags /*= FF_ENABLE*/)
{
    HKEY  hkHklmMain,
          hkHkcuMain,
          hkHkcuHelpMenuUrl,
          hkHkcuToolbar,
          hkHklmUAString;

    if (FF_ENABLE == dwFlags)
        dwFlags = FF_GEN_ALL;

    hkHklmMain        = NULL;
    hkHkcuMain        = NULL;
    hkHkcuHelpMenuUrl = NULL;
    hkHkcuToolbar     = NULL;
    hkHklmUAString    = NULL;

    SHOpenKeyHKLM(         RK_IE_MAIN,         KEY_SET_VALUE,      &hkHklmMain);
    SHOpenKey(g_GetHKCU(), RK_IE_MAIN,         KEY_SET_VALUE,      &hkHkcuMain);
    SHOpenKey(g_GetHKCU(), RK_HELPMENUURL,     KEY_SET_VALUE,      &hkHkcuHelpMenuUrl);
    SHOpenKey(g_GetHKCU(), RK_TOOLBAR,         KEY_SET_VALUE,      &hkHkcuToolbar);
    SHOpenKeyHKLM(         RK_UA_POSTPLATFORM, KEY_DEFAULT_ACCESS, &hkHklmUAString);

    if (HasFlag(dwFlags, FF_GEN_TITLE)) {
        if (NULL != hkHkcuMain)
            RegDeleteValue(hkHkcuMain, RV_WINDOWTITLE);

        if (NULL != hkHklmMain)
            RegDeleteValue(hkHklmMain, RV_WINDOWTITLE);
    }

    if (HasFlag(dwFlags, FF_GEN_HOMEPAGE)) {
        TCHAR szIEResetInf[MAX_PATH];

        if (NULL != hkHkcuMain)
            RegDeleteValue(hkHkcuMain, RV_HOMEPAGE);

        // restore RV_DEFAULTPAGE and START_PAGE_URL to the default MS value
        GetWindowsDirectory(szIEResetInf, countof(szIEResetInf));
        PathAppend(szIEResetInf, TEXT("inf\\iereset.inf"));
        if (PathFileExists(szIEResetInf))
        {
            TCHAR szDefHomePage[MAX_PATH];

            GetPrivateProfileString(IS_STRINGS, TEXT("MS_START_PAGE_URL"), TEXT(""), szDefHomePage, countof(szDefHomePage), szIEResetInf);
            WritePrivateProfileString(IS_STRINGS, TEXT("START_PAGE_URL"), szDefHomePage, szIEResetInf);

            if (hkHklmMain != NULL)
                RegSetValueEx(hkHklmMain, RV_DEFAULTPAGE, 0, REG_SZ, (PBYTE)szDefHomePage, (DWORD)StrCbFromSz(szDefHomePage));
        }
    }

    if (HasFlag(dwFlags, FF_GEN_SEARCHPAGE))
        if (NULL != hkHkcuMain) {
            RegDeleteValue(hkHkcuMain, RV_SEARCHBAR);
            RegDeleteValue(hkHkcuMain, RV_USE_CUST_SRCH_URL);
        }

    if (HasFlag(dwFlags, FF_GEN_HELPPAGE))
        if (NULL != hkHkcuHelpMenuUrl)
            RegDeleteValue(hkHkcuHelpMenuUrl, RV_ONLINESUPPORT);

    if (HasFlag(dwFlags, FF_GEN_UASTRING))
        if (NULL != hkHklmUAString) {
            TCHAR szUAVal[MAX_PATH];
            TCHAR szUAData[32];
            DWORD sUAVal = countof(szUAVal);
            DWORD sUAData = sizeof(szUAData);
            int iUAValue = 0;
            
            while (RegEnumValue(hkHklmUAString, iUAValue, szUAVal, &sUAVal, NULL, NULL, (LPBYTE)szUAData, &sUAData) == ERROR_SUCCESS)
            {
                sUAVal  = countof(szUAVal);
                sUAData = sizeof(szUAData);
            
                if (StrCmpN(szUAData, TEXT("IEAK"), 4) == 0)
                {
                    Out(LI1(TEXT("Deleting User Agent Key %s"), szUAVal));
                    RegDeleteValue(hkHklmUAString, szUAVal);
                    continue;
                }
            
                iUAValue++;
            }
    }

    if (HasFlag(dwFlags, FF_GEN_TOOLBARBMP))
        if (NULL != hkHkcuToolbar) {
            RegDeleteValue(hkHkcuToolbar, RV_BACKGROUNDBMP50);
            RegDeleteValue(hkHkcuToolbar, RV_BACKGROUNDBMP);
            RegDeleteValue(hkHkcuToolbar, RV_BITMAPMODE);
        }

    if (HasFlag(dwFlags, FF_GEN_TBICONTHEME))
        if (NULL != hkHkcuToolbar) {
            RegDeleteValue(hkHkcuToolbar, RV_TOOLBARTHEME);
            TCHAR szEntry[MAX_PATH];
            StrCpy(szEntry, RV_TOOLBARICON);
            for (DWORD i=0; i<8; i++)
            {
                szEntry[countof(RV_TOOLBARICON)-2] = TEXT('0')+(TCHAR)i;
                RegDeleteValue(hkHkcuToolbar, szEntry);
            }
        }

    if (HasFlag(dwFlags, FF_GEN_STATICLOGO)) {
        if (NULL != hkHkcuToolbar) {
            RegDeleteValue(hkHkcuToolbar, RV_LARGEBITMAP);
            RegDeleteValue(hkHkcuToolbar, RV_SMALLBITMAP);
        }

        if (NULL != hkHklmMain) {
            RegDeleteValue(hkHklmMain, RV_LARGEBITMAP);
            RegDeleteValue(hkHklmMain, RV_SMALLBITMAP);
        }
    }

    if (HasFlag(dwFlags, FF_GEN_ANIMATEDLOGO))
        if (NULL != hkHkcuToolbar) {
            RegDeleteValue(hkHkcuToolbar, RV_BRANDBMP);
            RegDeleteValue(hkHkcuToolbar, RV_SMALLBRANDBMP);
        }

    SHCloseKey(hkHklmMain);
    SHCloseKey(hkHkcuMain);
    SHCloseKey(hkHkcuHelpMenuUrl);
    SHCloseKey(hkHkcuToolbar);
    SHCloseKey(hkHklmUAString);
}

void ClearChannels(DWORD dwFlags /*= FF_ENABLE*/)
{
    UNREFERENCED_PARAMETER(dwFlags);

    ProcessRemoveAllChannels(TRUE);
}

void ClearToolbarButtons(DWORD dwFlags /*= FF_ENABLE*/)
{
    UNREFERENCED_PARAMETER(dwFlags);

    ProcessDeleteToolbarButtons(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\brandll\dllmap.cpp ===
#include "precomp.h"

// DelayLoadFailureHook() is defined in ieakutil.lib
// for more info, read the Notes section in ieak5\ieakutil\dload.cpp
PfnDliHook __pfnDliFailureHook = DelayLoadFailureHook;

// We need a notify hook so that we can tell if we loaded wininet
STDAPI_(FARPROC) DelayloadNotifyHook(UINT iReason, PDelayLoadInfo pdli);
PfnDliHook __pfnDliNotifyHook = DelayloadNotifyHook;


//
// For every API that's imported from a delay loaded DLL, define a handler
//
// IMPORTANT: The entries in DEFINE_PROCNAME_ENTRIES() and g_DllEntries[]
//            should be sorted by name.

//----- advpack.dll -----
static HRESULT WINAPI DelNode(PCSTR pszFileOrDirName, DWORD dwFlags)
{
    UNREFERENCED_PARAMETER(pszFileOrDirName);
    UNREFERENCED_PARAMETER(dwFlags);

    return E_UNEXPECTED;
}

static HRESULT WINAPI ExtractFiles(PCSTR pszCabName, PCSTR pszExpandDir, DWORD dwFlags, PCSTR pszFileList,
    PVOID pvReserved, DWORD dwReserved)
{
    UNREFERENCED_PARAMETER(pszCabName);
    UNREFERENCED_PARAMETER(pszExpandDir);
    UNREFERENCED_PARAMETER(dwFlags);
    UNREFERENCED_PARAMETER(pszFileList);
    UNREFERENCED_PARAMETER(pvReserved);
    UNREFERENCED_PARAMETER(dwReserved);

    return E_UNEXPECTED;
}

static HRESULT WINAPI GetVersionFromFile(PSTR pszFilename, PDWORD pdwMSVer, PDWORD pdwLSVer, BOOL fVersion)
{
    UNREFERENCED_PARAMETER(pszFilename);
    UNREFERENCED_PARAMETER(fVersion);

    if (pdwMSVer != NULL)
        *pdwMSVer = 0;

    if (pdwLSVer != NULL)
        *pdwLSVer = 0;

    return E_UNEXPECTED;
}

static HRESULT WINAPI RegInstall(HMODULE hm, LPCSTR pszSection, LPCSTRTABLE pstTable)
{
    UNREFERENCED_PARAMETER(hm);
    UNREFERENCED_PARAMETER(pszSection);
    UNREFERENCED_PARAMETER(pstTable);

    return E_UNEXPECTED;
}

static HRESULT WINAPI RunSetupCommand(HWND hWnd, PCSTR pszCmdName, PCSTR pszInfSection, PCSTR pszDir,
    PCSTR pszTitle, HANDLE *phExe, DWORD dwFlags, LPVOID pvReserved)
{
    UNREFERENCED_PARAMETER(hWnd);
    UNREFERENCED_PARAMETER(pszCmdName);
    UNREFERENCED_PARAMETER(pszInfSection);
    UNREFERENCED_PARAMETER(pszDir);
    UNREFERENCED_PARAMETER(pszTitle);
    UNREFERENCED_PARAMETER(phExe);
    UNREFERENCED_PARAMETER(dwFlags);
    UNREFERENCED_PARAMETER(pvReserved);

    return E_UNEXPECTED;
}


// IMPORTANT: The entries in DEFINE_PROCNAME_ENTRIES should be sorted by name
DEFINE_PROCNAME_ENTRIES(advpack)
{
    DLPENTRY(DelNode)
    DLPENTRY(ExtractFiles)
    DLPENTRY(GetVersionFromFile)
    DLPENTRY(RegInstall)
    DLPENTRY(RunSetupCommand)
};

DEFINE_PROCNAME_MAP(advpack)


//----- crypt32.dll -----
#define _CRYPT32_
#include <wincrypt.h>

static WINCRYPT32API BOOL WINAPI CertCloseStore(IN HCERTSTORE hCertStore, DWORD dwFlags)
{
    UNREFERENCED_PARAMETER(hCertStore);
    UNREFERENCED_PARAMETER(dwFlags);

    return FALSE;
}

static WINCRYPT32API HCERTSTORE WINAPI CertOpenStore(IN PCSTR pszStoreProvider, IN DWORD dwEncodingType,
    IN HCRYPTPROV hCryptProv, IN DWORD dwFlags, IN const void *pvParam)
{
    UNREFERENCED_PARAMETER(pszStoreProvider);
    UNREFERENCED_PARAMETER(dwEncodingType);
    UNREFERENCED_PARAMETER(hCryptProv);
    UNREFERENCED_PARAMETER(dwFlags);
    UNREFERENCED_PARAMETER(pvParam);

    return NULL;
}


// IMPORTANT: The entries in DEFINE_PROCNAME_ENTRIES should be sorted by name
DEFINE_PROCNAME_ENTRIES(crypt32)
{
    DLPENTRY(CertCloseStore)
    DLPENTRY(CertOpenStore)
};

DEFINE_PROCNAME_MAP(crypt32)


//----- inseng.dll -----
static HRESULT WINAPI CheckTrustEx(PCSTR pszUrl, PCSTR pszFilename, HWND hwndForUI, BOOL fShowBadUI, DWORD dwReserved)
{
    UNREFERENCED_PARAMETER(pszUrl);
    UNREFERENCED_PARAMETER(pszFilename);
    UNREFERENCED_PARAMETER(hwndForUI);
    UNREFERENCED_PARAMETER(fShowBadUI);
    UNREFERENCED_PARAMETER(dwReserved);

    return E_UNEXPECTED;
}


// IMPORTANT: The entries in DEFINE_PROCNAME_ENTRIES should be sorted by name
DEFINE_PROCNAME_ENTRIES(inseng)
{
    DLPENTRY(CheckTrustEx)
};

DEFINE_PROCNAME_MAP(inseng)


//----- shfolder.dll -----
#define _SHFOLDER_
#include <shfolder.h>

static HRESULT SHGetFolderPathA(HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, PSTR pszPath)
{
    UNREFERENCED_PARAMETER(hwnd);
    UNREFERENCED_PARAMETER(csidl);
    UNREFERENCED_PARAMETER(hToken);
    UNREFERENCED_PARAMETER(dwFlags);

    if (NULL != pszPath)
        *pszPath = '\0';

    return E_UNEXPECTED;
}

static HRESULT SHGetFolderPathW(HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, PWSTR pszPath)
{
    UNREFERENCED_PARAMETER(hwnd);
    UNREFERENCED_PARAMETER(csidl);
    UNREFERENCED_PARAMETER(hToken);
    UNREFERENCED_PARAMETER(dwFlags);

    if (NULL != pszPath)
        *pszPath = L'\0';

    return E_UNEXPECTED;
}


// IMPORTANT: The entries in DEFINE_PROCNAME_ENTRIES should be sorted by name
DEFINE_PROCNAME_ENTRIES(shfolder)
{
    DLPENTRY(SHGetFolderPathA)
    DLPENTRY(SHGetFolderPathW)
};

DEFINE_PROCNAME_MAP(shfolder)


//----- userenv.dll -----
#define _USERENV_
#include <userenv.h>

static USERENVAPI BOOL WINAPI CreateEnvironmentBlock(LPVOID *lpEnvironment, HANDLE hToken, BOOL bInherit)
{
    UNREFERENCED_PARAMETER(hToken);
    UNREFERENCED_PARAMETER(bInherit);

    *lpEnvironment = NULL;

    return FALSE;
}

static USERENVAPI BOOL WINAPI DestroyEnvironmentBlock(LPVOID lpEnvironment)
{
    UNREFERENCED_PARAMETER(lpEnvironment);

    return FALSE;
}

// IMPORTANT: The entries in DEFINE_PROCNAME_ENTRIES should be sorted by name
DEFINE_PROCNAME_ENTRIES(userenv)
{
    DLPENTRY(CreateEnvironmentBlock)
    DLPENTRY(DestroyEnvironmentBlock)
};

DEFINE_PROCNAME_MAP(userenv)

//----- define g_DllMap -----
// IMPORTANT: The entries in g_DllEntries should be sorted by name
const DLOAD_DLL_ENTRY g_DllEntries[] = {
    DLDENTRYP(advpack)
    DLDENTRYP(crypt32)
    DLDENTRYP(inseng)
    DLDENTRYP(shfolder)
    DLDENTRYP(userenv)
};

const DLOAD_DLL_MAP g_DllMap = {
    countof(g_DllEntries),
    g_DllEntries
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\brandll\defines.h ===
#define FOLDER_ALLUSERS TEXT("All Users")

#define RP_IEAK         RP_MS   TEXT("\\Ieak")
#define RP_IEAK_GPOS    RP_IEAK TEXT("\\GroupPolicy")
#define RP_IEAK_BRANDED RP_IEAK TEXT("\\BrandedFeatures")

//#define RK_IEAK    RP_IEAK
#define   RV_ISPSIGN TEXT("ISP Signup Required")

#define RK_IEAK_GPOS               RP_IEAK_GPOS
#define RK_IEAK_EXTERNAL           TEXT("External")
#define RK_IEAK_ADM                TEXT("Advanced")

#define RK_IEAK_BRANDED            RP_IEAK_BRANDED
#define RV_BF_ZONES_HKCU           TEXT("Zones.Hkcu")
#define RV_BF_ZONES_HKLM           TEXT("Zones.Hklm")
#define RV_BF_RATINGS              TEXT("Ratings")
#define RV_BF_AUTHCODE             TEXT("Authcode")
#define RV_BF_PROGRAMS             TEXT("Programs")
#define RV_BF_TITLE                TEXT("Title")
#define RV_BF_HOMEPAGE             TEXT("HomePage")
#define RV_BF_SEARCHPAGE           TEXT("SearchPage")
#define RV_BF_HELPPAGE             TEXT("HelpPage")
#define RV_BF_UASTRING             TEXT("UAString")
#define RV_BF_TOOLBARBMP           TEXT("ToolbarBitmap")
#define RV_BF_TBICONTHEME          TEXT("TBIconTheme")
#define RV_BF_STATICLOGO           TEXT("StaticLogo")
#define RV_BF_ANIMATEDLOGO         TEXT("AnimatedLogo")
#define RV_BF_TOOLBARBUTTONS       TEXT("ToolbarButtons")
#define RV_BF_FAVORITES            TEXT("Favorites")
#define RV_BF_CHANNELS             TEXT("Channels")
#define RV_BF_CONNECTIONSETTINGS   TEXT("ConnectionSettings")

#define RK_BRND_CS                 RP_IEAK_BRANDED TEXT("\\ConnectionSettings")
#define RV_NAMESLIST               TEXT("NamesList")
#define RV_LANBACKUP               TEXT("LanBackup")

#define RK_IEAK_CABVER             RP_IEAK TEXT("\\CabVersions")
#define RV_LAST_AUTOCNF_URL        TEXT("LastAutoConfigURL")
#define RV_DATE                    TEXT("Date")

#define RK_FAVORDER                RP_WINDOWS TEXT("\\Explorer\\MenuOrder\\Favorites")
#define RV_ORDER                   TEXT("Order")

#define RK_CONNECTIONS             RP_INETSET TEXT("\\Connections")

#define RK_AS_INSTALLEDCOMPONENTS  RP_MS TEXT("\\Active Setup\\Installed Components")
#define RK_IE_UPDATE               TEXT("Software\\Microsoft\\Active Setup\\Installed Components\\%s\\AuthorizedCDFPrefix")
#define RK_COMPLETED_MODIFICATIONS RP_IE_POLICIES TEXT("\\Infodelivery\\CompletedModifications")

#define IK_GPO_GUID        TEXT("GP")
// use this string for marking GP mandated settings
#define IEAK_GP_MANDATE    TEXT("IeakPolicy")

#define IS_BRANDINGW       L"Branding"
#define IK_IEAK_CREATEDW   L"IeakCreated"
#define IK_IEAK_CREATED    TEXT("IEAKCreated")

// links deletion stuff
#define MSIMN_EXE          TEXT("msimn.exe")
#define VIEWCHANNELS_SCF   TEXT("view channels.scf")

#define DESKTOP_FOLDER     0x00000001
#define PROGRAMS_FOLDER    0x00000002
#define QUICKLAUNCH_FOLDER 0x00000004
#define PROGRAMS_IE_FOLDER 0x00000008
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\brandll\download.cpp ===
#include "precomp.h"
#include "cabver.h"

// Private forward decalarations
#define ACF_ALWAYSUPDATECAB 0x0001              // ACF is for AutoConfingFlags

HRESULT updateCabFile(LPCTSTR pszSection, LPCTSTR pszKey, LPCTSTR pszIns, BOOL fForceUpdate, LPCTSTR pszTargetPath);
HRESULT internetDownloadFile(LPCTSTR pszURL, LPCTSTR pszTargetPath);


BOOL UpdateBrandingCab(BOOL fForceUpdate)
{
    return SUCCEEDED(updateCabFile(IS_CUSTOMBRANDING, IK_BRANDING, g_GetIns(), fForceUpdate, g_GetTargetPath()));
}

BOOL UpdateDesktopCab(BOOL fForceUpdate)
{
    TCHAR   szTargetPath[MAX_PATH],
            szMyCptrPath[MAX_PATH], szCPanelPath[MAX_PATH],
            szAux[MAX_PATH];
    HRESULT hr;
    DWORD   dwMyCptrAttribs, dwCPanelAttribs;

    if (!CreateWebFolder())
        return FALSE;
    GetWebPath(szTargetPath, countof(szTargetPath));

    // BUGBUG: Because of bug #62123, on NT, the ExtractFiles() API in urlmon.dll fails to extract
    // if the target file has SYSTEM + HIDDEN attribs set; in our case, the files are the mycomp
    // and controlp htt files. A hacky solution is to reset the attribs of these to NORMAL before
    // extracting the cab and set them back to their original attribs after they have been
    // extracted. Only do this if we're running on NT4.  For NT5, we don't want to overwrite the
    // existing ones

    dwMyCptrAttribs = 0xFFFFFFFF; // these are placed outside to prevent compiler warning
    dwCPanelAttribs = 0xFFFFFFFF; // about uninitialized vars  

    if (!IsOS(OS_NT5)) {
        //----- My Computer htt file handling -----
        szMyCptrPath[0] = TEXT('\0');

        GetPrivateProfileString(IS_DESKTOPOBJS, IK_MYCPTRPATH, TEXT(""), szAux, countof(szAux), g_GetIns());
        if (szAux[0] != TEXT('\0')) {
            PathCombine(szMyCptrPath, szTargetPath, PathFindFileName(szAux));
            ASSERT(szMyCptrPath[0] != TEXT('\0'));
            
            dwMyCptrAttribs = GetFileAttributes(szMyCptrPath);
            if (dwMyCptrAttribs != 0xFFFFFFFF) {
                ASSERT(PathFileExists(szMyCptrPath));
                SetFileAttributes(szMyCptrPath, FILE_ATTRIBUTE_NORMAL);
            }
        }

        //----- Control Panel htt file handling -----
        szCPanelPath[0] = TEXT('\0');
        
        GetPrivateProfileString(IS_DESKTOPOBJS, IK_CPANELPATH, TEXT(""), szAux, countof(szAux), g_GetIns());
        if (szAux[0] != TEXT('\0')) {
            PathCombine(szCPanelPath, szTargetPath, PathFindFileName(szAux));
            ASSERT(szCPanelPath[0] != TEXT('\0'));
            
            dwCPanelAttribs = GetFileAttributes(szCPanelPath);
            if (dwCPanelAttribs != 0xFFFFFFFF) {
                ASSERT(PathFileExists(szCPanelPath));
                SetFileAttributes(szCPanelPath, FILE_ATTRIBUTE_NORMAL);
            }
        }
    }

    hr = updateCabFile(IS_CUSTOMDESKTOP, IK_DESKTOP, g_GetIns(), fForceUpdate, szTargetPath);

    if (!IsOS(OS_NT5)) {
        // restore the attributes (see BUGBUG above)
        if (szMyCptrPath[0] != TEXT('\0') && dwMyCptrAttribs != 0xFFFFFFFF)
            SetFileAttributes(szMyCptrPath, dwMyCptrAttribs);
        
        if (szCPanelPath[0] != TEXT('\0') &&  dwCPanelAttribs != 0xFFFFFFFF)
            SetFileAttributes(szCPanelPath, dwCPanelAttribs);
    }

    return SUCCEEDED(hr);
}

HRESULT DownloadSourceFile(LPCTSTR pszURL, LPTSTR pszTargetPath, UINT cchTargetPath, BOOL fCheckTrust /*= TRUE*/)
{   MACRO_LI_PrologEx_C(PIF_STD_C, DownloadSourceFile)

    TCHAR   szTargetFile[MAX_PATH];
    HRESULT hr;
    BOOL    fCopyPossible;

    if (pszURL == NULL)
        return E_INVALIDARG;

    if (!PathIsValidPath(pszTargetPath, PIVP_FOLDER_ONLY))
        return STG_E_PATHNOTFOUND;

    PathCombine(szTargetFile, pszTargetPath, PathFindFileName(pszURL));
    if ((UINT)StrLen(szTargetFile) >= cchTargetPath)
        return E_OUTOFMEMORY;

    if (PathIsFileSpec(pszURL) && PathFileExists(szTargetFile)) {
        Out(LI1(TEXT("\"%s\" is already present!"), szTargetFile));
        StrCpy(pszTargetPath, szTargetFile);
        return S_OK;
    }

    fCopyPossible = !PathIsURL(pszURL);
    if (!fCopyPossible) {
        URL_COMPONENTS uc;

        ZeroMemory(&uc, sizeof(uc));
        uc.dwStructSize     = sizeof(uc);
        uc.dwSchemeLength   = 1;
        uc.dwHostNameLength = 1;
        uc.dwUrlPathLength  = 1;

        // REVIEW: (andrewgu) consider adding support for decoding escape sequencies with dwFlags
        // parameter.
        if (InternetCrackUrl(pszURL, 0, 0, &uc))
            if (uc.nScheme == INTERNET_SCHEME_FILE) {
                // the below ASSERT explains the case we got here
                ASSERT(uc.lpszHostName == NULL && uc.dwHostNameLength == 0);

                pszURL = uc.lpszUrlPath;
                fCopyPossible = TRUE;
            }
    }

    if (!fCopyPossible) {
        hr = internetDownloadFile(pszURL, pszTargetPath);
        if (FAILED(hr)) {
            Out(LI1(TEXT("! Download failed with %s."), GetHrSz(hr)));
            return hr;
        }
    }
    else {
        hr = PathFileExists(pszURL) ? S_OK : E_FAIL;
        if (FAILED(hr))
            Out(LI1(TEXT("! File \"%s\" doesn't exist."), pszURL));
        else {
            hr = CopyFile(pszURL, szTargetFile, FALSE) ? S_OK : E_FAIL;
            if (FAILED(hr))
                Out(LI1(TEXT("! File \"%s\" can NOT be copied."), pszURL));
        }
    }

    if (SUCCEEDED(hr) && fCheckTrust) {
        hr = CheckTrustExWrap(pszURL, szTargetFile, NULL, TRUE, 0);
        if (FAILED(hr)) {
            DeleteFile(szTargetFile);
            Out(LI2(TEXT("! Check trust operation on \"%s\" failed with %s."), szTargetFile, GetHrSz(hr)));
            return hr;
        }
    }

    if (SUCCEEDED(hr)) {
        Out(LI1(TEXT("\"%s\" downloaded successfully!"), szTargetFile));
        StrCpy(pszTargetPath, szTargetFile);
    }

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// Implementation helper routines

HRESULT updateCabFile(LPCTSTR pszSection, LPCTSTR pszKey, LPCTSTR pszIns, BOOL fForceUpdate, LPCTSTR pszTargetPath)
{   MACRO_LI_PrologEx_C(PIF_STD_C, updateCabFile)

    TCHAR szInsLine[INTERNET_MAX_URL_LENGTH + 50],
          szKeyName[128];
    HKEY  hk;
    DWORD dwSize;
    LONG  lResult;

    //----- Initialization -----
    if (pszSection == NULL || pszKey == NULL || pszIns == NULL)
        return E_INVALIDARG;

    if (!PathIsValidPath(pszTargetPath, PIVP_FOLDER_ONLY))
        return STG_E_PATHNOTFOUND;

    // initialize szInsLine
    Out(LI0(TEXT("\r\nVersion checking and updating cab file...")));

    GetPrivateProfileString(pszSection, pszKey, TEXT(""), szInsLine, countof(szInsLine), pszIns);
    if (szInsLine[0] == TEXT('\0'))
        GetPrivateProfileString(IS_CUSTOMVER, pszKey, TEXT(""), szInsLine, countof(szInsLine), pszIns);
    if (szInsLine[0] == TEXT('\0')) {
        Out(LI1(TEXT("Required update information for \"%s\" cab was not found!"), pszKey));
        return E_FAIL;
    }

    // initialize szKeyName, hk
    wnsprintf(szKeyName, countof(szKeyName), RK_IEAK_CABVER TEXT("\\%s"), pszKey);
    hk = NULL;

    //----- Parse szInsLine on tokens -----
    LPTSTR pszToken, pszDelim,
           pszNewCabFileURL, pszNewVer;
    UINT   nFlags;
    int    iTimeout;

    pszNewCabFileURL = NULL;
    pszNewVer        = NULL;
    iTimeout         = 0;
    nFlags           = 0;

    pszToken = szInsLine;
    pszDelim = StrChr(pszToken, TEXT(','));
    if (pszDelim != NULL)
        *pszDelim = TEXT('\0');

    // pszNewCabFileURL
    pszNewCabFileURL = pszToken;
    StrRemoveWhitespace(pszNewCabFileURL);

    if (pszDelim != NULL) {
        pszToken = pszDelim + 1;
        pszDelim = StrChr(pszToken, TEXT(','));
        if (pszDelim != NULL)
            *pszDelim = TEXT('\0');

        // pszNewVer
        pszNewVer = pszToken;
        StrRemoveWhitespace(pszNewVer);

        if (!fForceUpdate && pszDelim != NULL) {
            pszToken = pszDelim + 1;
            pszDelim = StrChr(pszToken, TEXT(','));
            if (pszDelim != NULL)
                *pszDelim = TEXT('\0');

            // iTimeout
            StrRemoveWhitespace(pszToken);
            if (*pszToken != TEXT('\0') && StrToIntEx(pszToken, STIF_SUPPORT_HEX, &iTimeout))
                if (pszDelim != NULL) {
                    pszToken = pszDelim + 1;

                    // nFlags
                    StrRemoveWhitespace(pszToken);
                    if (*pszToken != TEXT('\0'))
                        StrToIntEx(pszToken, STIF_SUPPORT_HEX, (LPINT)&nFlags);
                }
        }
    }

    ASSERT(pszNewCabFileURL != NULL);
    if (*pszNewCabFileURL == TEXT('\0')) {
        Out(LI1(TEXT("! Parsing error in line \"%s\"."), szInsLine));
        return E_FAIL;
    }

    //----- Determine if updating is needed -----
    SYSTEMTIME st;
    BOOL       fUpdate;

    GetLocalTime(&st);

    fUpdate = (fForceUpdate || pszNewVer == NULL || iTimeout == 0 || HasFlag(nFlags, ACF_ALWAYSUPDATECAB));
    if (fUpdate) {
        if (fForceUpdate)
            Out(LI1(TEXT("Update of \"%s\" cab is forced from outside."), pszKey));
        else if (pszNewVer == NULL)
            Out(LI1(TEXT("No version information for \"%s\" cab."), pszKey));
        else if (iTimeout == 0)
            Out(LI1(TEXT("Timeout on \"%s\" cab is set to zero."), pszKey));
        else /* if (HasFlag(nFlags, ACF_ALWAYSUPDATECAB)) */
            Out(LI1(TEXT("Update options for \"%s\" cab include flag \"always update\"."), pszKey));
    }
    else { /* if (!fUpdate) */
        lResult = SHOpenKeyHKLM(szKeyName, KEY_QUERY_VALUE, &hk);
        fUpdate = (lResult != ERROR_SUCCESS);

        // cab url
        if (!fUpdate) {
            TCHAR szOldCabFileURL[INTERNET_MAX_URL_LENGTH];

            ASSERT(hk != NULL);

            szOldCabFileURL[0] = TEXT('\0');
            dwSize             = sizeof(szOldCabFileURL);
            RegQueryValueEx(hk, RV_URL, NULL, NULL, (LPBYTE)&szOldCabFileURL, &dwSize);

            fUpdate = (szOldCabFileURL[0] == TEXT('\0') || StrCmpI(szOldCabFileURL, pszNewCabFileURL) != 0);
            if (fUpdate)
                Out(LI1(TEXT("Download URL for \"%s\" cab has changed."), pszKey));
        }

        // version
        if (!fUpdate) {
            SCabVersion cvOld, cvNew;
            TCHAR       szOldVer[40];

            szOldVer[0] = TEXT('\0');
            dwSize      = sizeof(szOldVer);
            RegQueryValueEx(hk, RV_VERSION, NULL, NULL, (LPBYTE)&szOldVer, &dwSize);

            fUpdate = (cvOld.Init(szOldVer) && cvNew.Init(pszNewVer)) ? (cvOld < cvNew) : TRUE;
            if (fUpdate)
                Out(LI1(TEXT("New version of \"%s\" cab is available."), pszKey));
        }

        // date
        if (!fUpdate && iTimeout > 0) {
            SCabVersion cvAux;
            TCHAR       szOldDate[32];
            int         iTimeDiff;

            szOldDate[0] = TEXT('\0');
            dwSize       = sizeof(szOldDate);
            RegQueryValueEx(hk, RV_DATE, NULL, NULL, (LPBYTE)&szOldDate, &dwSize);

            if (cvAux.Init(szOldDate)) {
                iTimeDiff = (st.wYear - cvAux.cv_w1) * 365 + (st.wMonth - cvAux.cv_w2) * 30 + (st.wDay - cvAux.cv_w3);

                fUpdate = (iTimeDiff >= iTimeout);
                if (fUpdate)
                    Out(LI1(TEXT("Existing version of \"%s\" cab has become outdated."), pszKey));
            }
        }

        SHCloseKey(hk);
    }

    if (!fUpdate) {
        Out(LI1(TEXT("No update is needed for \"%s\" cab!"), pszKey));
        return S_FALSE;
    }

    //----- Download and extract cab -----
    CNewCursor cursor(IDC_WAIT);                // turn cursor into a hourglass

    TCHAR   szTargetFile[MAX_PATH];
    HRESULT hr;

    StrCpy(szTargetFile, pszTargetPath);
    hr = DownloadSourceFile(pszNewCabFileURL, szTargetFile, countof(szTargetFile));
    if (FAILED(hr)) {
        if (g_CtxIs(CTX_W2K_UNATTEND)) {
            TCHAR szCabFile[MAX_PATH];

            // check if the cab file is in the same directory as the INS file

            // initialize the full path to the cab file -- path to the ins + cab name
            StrCpy(szCabFile, pszIns);
            PathRemoveFileSpec(szCabFile);
            PathAppend(szCabFile, PathFindFileName(pszNewCabFileURL));

            // reinitialize szTargetFile just in case it was munged by DownloadSourceFile
            StrCpy(szTargetFile, pszTargetPath);

            // call DownloadSourceFile again but turn off checktrust because the cab is not downloaded
            Out(LI0(TEXT("Check if the cab is present in the same folder as the INS file...")));
            hr = DownloadSourceFile(szCabFile, szTargetFile, countof(szTargetFile), FALSE);
        }

        if (FAILED(hr)) {
            Out(LI3(TEXT("! Downloading \"%s\" to \"%s\" failed with %s."), pszNewCabFileURL, pszTargetPath, GetHrSz(hr)));
            return hr;
        }
    }

    hr = ExtractFilesWrap(szTargetFile, pszTargetPath, 0, NULL, NULL, 0);
    DeleteFile(szTargetFile);
    if (FAILED(hr)) {
        Out(LI2(TEXT("! Extracting files out of \"%s\" failed with %s."), szTargetFile, GetHrSz(hr)));
        return hr;
    }

    //----- Update registry information -----
    TCHAR szDate[40];

    ASSERT(hk == NULL);
    lResult = SHCreateKeyHKLM(szKeyName, KEY_SET_VALUE, &hk);
    if (lResult == ERROR_SUCCESS) {
        dwSize = (DWORD)StrCbFromSz(pszNewCabFileURL);
        RegSetValueEx(hk, RV_URL, 0, REG_SZ, (LPBYTE)pszNewCabFileURL, dwSize);

        if (pszNewVer != NULL) {
            dwSize = (DWORD)StrCbFromSz(pszNewVer);
            RegSetValueEx(hk, RV_VERSION, 0, REG_SZ, (LPBYTE)pszNewVer, dwSize);
        }

        dwSize = wnsprintf(szDate, countof(szDate), TEXT("%d.%d.%d"), st.wYear, st.wMonth, st.wDay);
        dwSize = StrCbFromCch(dwSize+1);
        RegSetValueEx(hk, RV_DATE, 0, REG_SZ, (LPBYTE)szDate, dwSize);

        SHCloseKey(hk);
    }

    Out(LI0(TEXT("Done.")));
    return S_OK;
}

HRESULT internetDownloadFile(LPCTSTR pszURL, LPCTSTR pszTargetPath)
{   MACRO_LI_PrologEx_C(PIF_STD_C, internetDownloadFile)

    static const TCHAR c_szUnknownInternetError[] = TEXT("<unknown internet error>");

    TCHAR     szAux[4096],
              szTargetFile[MAX_PATH],
              szError[MAX_PATH];
    LPCTSTR   pszDescription,
              pszFilename;
    HINTERNET hInternet,
              hinetFile;
    HRESULT   hr;
    DWORD     dwTotalSize, dwRead,
              dwAux, dwSize, dwError;
    BOOL      fResult;

    ASSERT(PathIsURL(pszURL));
    ASSERT(PathIsValidPath(pszTargetPath, PIVP_FOLDER_ONLY));

    hInternet = InternetOpen(TEXT("IE Branding DLL"), INTERNET_OPEN_TYPE_PRECONFIG_WITH_NO_AUTOPROXY, NULL, NULL, 0);
    if (hInternet == NULL) {
        ASSERT(FALSE);
        return E_UNEXPECTED;
    }

    Out(LI1(TEXT("Downloading \"%s\"..."), pszURL));
    hinetFile = NULL;
    hr        = S_OK;

    hinetFile = InternetOpenUrl(hInternet, pszURL, TEXT("Accept: */*\r\n"), (DWORD)-1,
        INTERNET_FLAG_EXISTING_CONNECT | INTERNET_FLAG_NEED_FILE, 0);
    if (hinetFile == NULL) {
        dwError = GetLastError();
        hr      = HRESULT_FROM_WIN32(dwError);

        if (dwError == ERROR_INTERNET_EXTENDED_ERROR) {
            dwSize  = countof(szError);
            fResult = InternetGetLastResponseInfo(&dwError, szError, &dwSize);
            hr      = HRESULT_FROM_WIN32(dwError);

            pszDescription = fResult ? szError : c_szUnknownInternetError;
            Out(LI1(TEXT("! Download failed because of \"%s\"."), pszDescription));
        }
        else
            Out(LI1(TEXT("! Download failed with %s."), GetHrSz(hr)));

        goto Exit;
    }

    dwSize  = sizeof(dwAux);
    fResult = InternetQueryOption(hinetFile, INTERNET_OPTION_HANDLE_TYPE, &dwAux, &dwSize);
    ASSERT(fResult);
    if (fResult && dwAux == INTERNET_HANDLE_TYPE_HTTP_REQUEST) {
        dwSize  = sizeof(dwAux);
        fResult = HttpQueryInfo(hinetFile, HTTP_QUERY_FLAG_NUMBER | HTTP_QUERY_STATUS_CODE, &dwAux, &dwSize, NULL);
        ASSERT(fResult);
        if (fResult && dwAux != 200) {
            Out(LI1(TEXT("! Download failed with HTTP error %lu."), dwAux));
            hr = STG_E_FILENOTFOUND;
            goto Exit;
        }
    }

    for (dwTotalSize = 0; TRUE; dwTotalSize += dwRead) {
        fResult = InternetReadFile(hinetFile, szAux, sizeof(szAux), &dwRead);
        if (!fResult) {
            dwError = GetLastError();
            hr      = HRESULT_FROM_WIN32(dwError);

            if (dwError == ERROR_INTERNET_EXTENDED_ERROR) {
                dwSize  = countof(szError);
                fResult = InternetGetLastResponseInfo(&dwError, szError, &dwSize);
                hr      = HRESULT_FROM_WIN32(dwError);

                pszDescription = fResult ? szError : c_szUnknownInternetError;
                Out(LI2(TEXT("! After downloading 0x%lX bytes error \"%s\" occured."), dwTotalSize, pszDescription));
            }
            else
                Out(LI2(TEXT("! After downloading 0x%lX bytes of error %s occured."), dwTotalSize, GetHrSz(hr)));

            goto Exit;
        }

        if (dwRead == 0)
            break;
    }
    Out(LI1(TEXT("Downloaded 0x%lX bytes."), dwTotalSize));

    dwSize  = countof(szAux);
    fResult = InternetQueryOption(hinetFile, INTERNET_OPTION_DATAFILE_NAME, szAux, &dwSize);
    if (!fResult) {
        Out(LI1(TEXT("! Download failed with %s."), GetHrSz(HRESULT_FROM_WIN32(GetLastError()))));
        goto Exit;
    }

    pszFilename = PathFindFileName(pszURL);
    ASSERT(StrLen(pszFilename) < MAX_PATH);
    ASSERT(PathIsValidFile(pszFilename));
    PathCombine(szTargetFile, pszTargetPath, pszFilename);
    CopyFile(szAux, szTargetFile, FALSE);
    Out(LI0(TEXT("Done.")));

Exit:
    if (hinetFile != NULL)
        InternetCloseHandle(hinetFile);

    if (hInternet != NULL)
        InternetCloseHandle(hInternet);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\brandll\exports.h ===
#ifndef _EXPORTS_H_
#define _EXPORTS_H_

#ifdef __cplusplus
extern "C" {
#endif

BOOL CALLBACK DllMain(HANDLE hModule, DWORD fdwReason, LPVOID);

void CALLBACK BrandInternetExplorer(HWND, HINSTANCE, LPCSTR pszCmdLineA, int);

BOOL CALLBACK BrandICW (LPCSTR pszInsA, LPCSTR, DWORD);
BOOL CALLBACK BrandICW2(LPCSTR pszInsA, LPCSTR, DWORD, LPCSTR pszConnectoidA);

BOOL CALLBACK BrandMe(LPCSTR pszInsA, LPCSTR);
BOOL CALLBACK BrandIntra(LPCSTR pszInsA);

void CALLBACK BrandIE4(HWND, HINSTANCE, LPCSTR pszCmdLineA, int);
BOOL CALLBACK _InternetInitializeAutoProxyDll(DWORD, LPCSTR pszInsA, LPCSTR, LPVOID, DWORD_PTR);
void CALLBACK BrandInfAndOutlookExpress(LPCSTR pszInsA);

BOOL CALLBACK BrandCleanInstallStubs(HWND, HINSTANCE, LPCSTR pszCompanyA, int);
void CALLBACK Clear(HWND, HINSTANCE, LPCSTR, int);
void CALLBACK CloseRASConnections(HWND, HINSTANCE, LPCSTR, int);

#ifdef __cplusplus
}
#endif

#endif /* _EXPORTS_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\brandll\favs.h ===
#ifndef __FAVS_H_
#define __FAVS_H_

class CFavorite {
// Constructors
public:
    CFavorite()
        { m_szTitle[0] = m_szUrl[0] = m_szIcon[0] = TEXT('\0'); m_fOffline = FALSE; }

// Operations
public:
    HRESULT Create(IUnknown *punk, ISubscriptionMgr2 *pSubMgr2, LPCTSTR pszPath, LPCTSTR pszIns);

// Properties
public:
    static BOOL m_fMarkIeakCreated;

    TCHAR m_szTitle[MAX_PATH];
    TCHAR m_szUrl  [INTERNET_MAX_URL_LENGTH];
    TCHAR m_szIcon [MAX_PATH];
    BOOL  m_fOffline;

// Implementation
protected:
    virtual BOOL findFile(LPCTSTR pszPath, LPCTSTR pszTitle, LPTSTR pszFoundFile = NULL, UINT cchFoundFile = 0);
    virtual BOOL createUniqueFile(LPCTSTR pszPath, LPCTSTR pszTitle, LPTSTR pszFile, UINT cchFile = 0);
    virtual void finishSave(LPCTSTR pszTitle, LPCTSTR pszFile);
};


HRESULT CreateInternetShortcut(LPCTSTR pszFavorite, REFIID riid, PVOID *ppv);
DWORD   GetFavoriteIeakFlags(LPCTSTR pszFavorite, IUnknown *punk = NULL);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\brandll\favs.cpp ===
#include "precomp.h"
#include <intshcut.h>
#include <shlobjp.h>                            // for IID_INamedPropertyBag only
#include "favs.h"

/////////////////////////////////////////////////////////////////////////////
// CFavorite operations

BOOL CFavorite::m_fMarkIeakCreated = FALSE;

HRESULT CFavorite::Create(IUnknown *punk, ISubscriptionMgr2 *pSubMgr2, LPCTSTR pszPath, LPCTSTR pszIns)
{   MACRO_LI_PrologEx(PIF_STD, CFavorite, Create)

    IUniformResourceLocator *purl;
    IPersistFile            *ppf;
    //INamedPropertyBag       *pnpb;

    TCHAR   szPath[MAX_PATH], szFile[MAX_PATH], szTitle[MAX_PATH],
            szAux[MAX_PATH];
    LPTSTR  pszFileName;
    LPCWSTR pwszFile;
    HRESULT hr;
    DWORD   dwFlags;
    BOOL    fOwnUnknown;

    Out(LI0(TEXT("Determining favorites attributes...")));
    if (m_szTitle[0] == TEXT('\0') || m_szUrl[0] == TEXT('\0'))
        return E_INVALIDARG;

    ASSERT(pszIns != NULL && *pszIns != TEXT('\0'));

    if (pszPath == NULL || !PathIsDirectory(pszPath)) {
        GetFavoritesPath(szPath, countof(szPath));
        if (szPath[0] == TEXT('\0'))
            return STG_E_PATHNOTFOUND;

        ASSERT(PathIsDirectory(szPath));
    }
    else
        StrCpy(szPath, pszPath);

    purl = NULL;
    ppf  = NULL;
    //pnpb = NULL;

    // figure out what the title will be and put it into szTitle
    StrCpy(szAux, m_szTitle);
    DecodeTitle(szAux, pszIns);
    PathRemoveExtension(szAux);

    pszFileName = PathFindFileName(szAux);
    StrCpy(szTitle, pszFileName);               // szTitle has the final title

    // create folders hierarchy (if neccesary), setup szPath
    if (pszFileName > &szAux[0]) {
        ASSERT(!PathIsFileSpec(szAux));

        *(pszFileName - 1) = TEXT('\0');        // replace '\\' with '\0'

        PathAppend(szPath, szAux);
        if (!PathCreatePath(szPath))
            return STG_E_PATHNOTFOUND;
    }

    // figure out what the name of the file will be and put it into szFile
    if (findFile(szPath, szTitle, szFile, countof(szFile))) {

        // NOTE: (andrewgu) special case for favorites coming from a preferences gpo.
        if (g_CtxIs(CTX_GP) && g_CtxIs(CTX_MISC_PREFERENCES)) {
            dwFlags = GetFavoriteIeakFlags(szFile);
            if (HasFlag(dwFlags, 2))
                return E_ACCESSDENIED;
        }
    }
    else
        if (!createUniqueFile(szPath, szTitle, szFile, countof(szFile)))
            return E_FAIL;

    // everything is figured out, lets create this favorite
    fOwnUnknown = FALSE;
    if (punk == NULL) {
        hr = CoCreateInstance(CLSID_InternetShortcut, NULL, CLSCTX_INPROC_SERVER, IID_IUnknown, (LPVOID *)&punk);
        if (FAILED(hr))
            return E_UNEXPECTED;

        fOwnUnknown = TRUE;
    }

    // save the url
    hr = punk->QueryInterface(IID_IUniformResourceLocator, (LPVOID *)&purl);
    if (FAILED(hr))
        goto Exit;

    hr = purl->SetURL(m_szUrl, 0);
    if (FAILED(hr))
        goto Exit;

    hr = purl->QueryInterface(IID_IPersistFile, (LPVOID *)&ppf);
    if (FAILED(hr))
        goto Exit;

    /***
    // BUGBUG: pritobla: there's seems to be some problem with WritePropertyNPB;
    // for the first url created, some junk appears instead of the [Branding] section;
    // should track this down.  But for now, I'm going with WritePrivateProfile function.

    hr = purl->QueryInterface(IID_INamedPropertyBag, (LPVOID *)&pnpb);
    if (FAILED(hr))
        goto Exit;

    // IMPORTANT: WritePropertyNPB/RemovePropertyNPB should be called *before* ppf->Save.
    if (m_fMarkIeakCreated)
    {
        BSTR        bstr;
        PROPVARIANT var = { 0 };

        bstr = SysAllocString(L"1");

        var.vt = VT_BSTR;
        var.bstrVal = bstr;

        pnpb->WritePropertyNPB(L"Branding", L"IEAKCreated", &var);

        SysFreeString(bstr);
    }
    else
        pnpb->RemovePropertyNPB(L"Branding", L"IEAKCreated");
    ***/

    pwszFile = T2CW(szFile);
    hr = ppf->Save(pwszFile, TRUE);
    if (SUCCEEDED(hr)) {
        ppf->SaveCompleted(pwszFile);

        finishSave(szTitle, szFile);

        // BUGBUG: (pritobla) see comments above regarding WritePropertyNPB. when that's fixed,
        // calling InsXxx functions should be deleted.
        if (m_fMarkIeakCreated) {
            dwFlags = 1;
            if (g_CtxIs(CTX_GP) && !g_CtxIs(CTX_MISC_PREFERENCES))
                dwFlags |= 2;

            InsWriteInt(IS_BRANDING, IK_IEAK_CREATED, dwFlags, szFile);
        }
        else
            InsDeleteSection(IS_BRANDING, szFile);
        InsFlushChanges(szFile);

        Out(LI1(TEXT("Title     - \"%s\","), m_szTitle));
        Out(LI1(TEXT("URL       - \"%s\","), m_szUrl));
        if (m_szIcon[0] != TEXT('\0'))
            Out(LI1(TEXT("Icon file - \"%s\","), m_szIcon));
        else
            Out(LI0(TEXT("with a default icon,")));
        Out(LI1(TEXT("%smarked IEAK created,"), m_fMarkIeakCreated ? TEXT("") : TEXT("not ")));

        if (pSubMgr2 != NULL)
        {
            PCWSTR pwszUrl;

            pwszUrl = T2CW(m_szUrl);

            if (m_fOffline)                     // make this favorite available offline
            {
                SUBSCRIPTIONINFO si;
                DWORD dwFlags;

                dwFlags = CREATESUBS_ADDTOFAVORITES | CREATESUBS_FROMFAVORITES | CREATESUBS_NOUI;

                ZeroMemory(&si, sizeof(si));
                si.cbSize       = sizeof(SUBSCRIPTIONINFO);
                si.fUpdateFlags = SUBSINFO_SCHEDULE;
                si.schedule     = SUBSSCHED_MANUAL;

                hr = pSubMgr2->CreateSubscription(NULL, pwszUrl, T2CW(szTitle), dwFlags, SUBSTYPE_URL, &si);
                if (SUCCEEDED(hr))
                {
                    ISubscriptionItem *pSubItem = NULL;

                    hr = pSubMgr2->GetItemFromURL(pwszUrl, &pSubItem);
                    if (SUCCEEDED(hr))
                    {
                        SUBSCRIPTIONCOOKIE sc;

                        hr = pSubItem->GetCookie(&sc);
                        if (SUCCEEDED(hr))
                        {
                            DWORD dwState;

                            hr = pSubMgr2->UpdateItems(SUBSMGRUPDATE_MINIMIZE, 1, &sc);

                            // NOTE: a better way of finding out if the sync is complete or not is to implement
                            // IOleCommandTarget::Exec(), register the interface GUID to webcheck and delete it
                            // after we are done.  When the sync is complete, webcheck would call IOleCommandTarget::Exec()
                            // notify that it is done.
CheckStatus:
                            dwState = 0;
                            hr = pSubMgr2->GetSubscriptionRunState(1, &sc, &dwState);
                            if (SUCCEEDED(hr))
                            {
                                if (dwState  &&  !(dwState & RS_COMPLETED))
                                {
                                    MSG msg;

                                    while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
                                    {
                                        TranslateMessage(&msg);
                                        DispatchMessage(&msg);
                                    }

                                    goto CheckStatus;
                                }
                            }
                        }
                    }

                    if (pSubItem != NULL)
                        pSubItem->Release();
                }
            }
            else
                pSubMgr2->DeleteSubscription(pwszUrl, NULL);

            if (SUCCEEDED(hr))
                Out(LI1(TEXT("%smade available offline"), m_fOffline ? TEXT("") : TEXT("not ")));
            else
            {
                Out(LI1(TEXT("! Making available offline failed with %s."), GetHrSz(hr)));
                hr = S_OK;          // don't care if make available offline fails
            }
        }
    }

Exit:
    if (fOwnUnknown)
        punk->Release();

    //if (pnpb != NULL)
    //    pnpb->Release();

    if (ppf != NULL)
        ppf->Release();

    if (purl != NULL)
        purl->Release();

    Out(LI0(TEXT("Done.")));
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CFavorite implementation helper routines

BOOL CFavorite::findFile(LPCTSTR pszPath, LPCTSTR pszTitle, LPTSTR pszFoundFile /*= NULL*/, UINT cchFoundFile /*= 0*/)
{
    TCHAR szName[MAX_PATH];
    BOOL  fExists;

    if (pszFoundFile != NULL)
        *pszFoundFile = TEXT('\0');

    if (pszPath == NULL || *pszPath == TEXT('\0')) {
        pszPath = GetFavoritesPath();
        if (pszPath == NULL)
            return FALSE;
    }

    if (pszTitle == NULL || *pszTitle == TEXT('\0'))
        return FALSE;
    ASSERT(PathIsFileSpec(pszTitle));

    PathCombine(szName, pszPath, pszTitle);
    // NOTE: Shouldn't use PathAddExtension because if title contains ".foobar", then the call would fail
    // PathAddExtension(szName, TEXT(".url"));
    StrCat(szName, TEXT(".url"));

    fExists = PathFileExists(szName);
    if (fExists && pszFoundFile != NULL) {
        if (cchFoundFile == 0)
            cchFoundFile = MAX_PATH;

        if (cchFoundFile > (UINT)StrLen(szName))
            StrCpy(pszFoundFile, szName);
    }

    return fExists;
}

BOOL CFavorite::createUniqueFile(LPCTSTR pszPath, LPCTSTR pszTitle, LPTSTR pszFile, UINT cchFile /*= 0*/)
{
    TCHAR szFile[MAX_PATH];

    if (pszFile == NULL)
        return FALSE;
    *pszFile = TEXT('\0');

    if (pszPath == NULL || *pszPath == TEXT('\0')) {
        pszPath = GetFavoritesPath();
        if (pszPath == NULL)
            return FALSE;
    }

    if (pszTitle == NULL || *pszTitle == TEXT('\0'))
        return FALSE;
    ASSERT(PathIsFileSpec(pszTitle));

    PathCombine(szFile, pszPath, pszTitle);
    // NOTE: Shouldn't use PathRenameExtension because if title contains ".foobar", then it would be replaced with ".url"
    // PathRenameExtension(szName, TEXT(".url"));
    StrCat(szFile, DOT_URL);

    if (cchFile == 0)
        cchFile = MAX_PATH;

    if (cchFile > (UINT)StrLen(szFile))
        StrCpy(pszFile, szFile);

    return TRUE;
}

void CFavorite::finishSave(LPCTSTR pszTitle, LPCTSTR pszFile)
{
    UNREFERENCED_PARAMETER(pszTitle);

    if (m_szIcon[0] != TEXT('\0')) {
        WritePrivateProfileString(IS_INTERNETSHORTCUT, IK_ICONINDEX, TEXT("0"), pszFile);
        WritePrivateProfileString(IS_INTERNETSHORTCUT, IK_ICONFILE,  m_szIcon,  pszFile);
    }
}


HRESULT CreateInternetShortcut(LPCTSTR pszFavorite, REFIID riid, PVOID *ppv)
{
    USES_CONVERSION;

    IPersistFile *ppf;
    HRESULT hr;

    ASSERT(pszFavorite != NULL && *pszFavorite != TEXT('\0'));

    hr = CoCreateInstance(CLSID_InternetShortcut, NULL, CLSCTX_INPROC_SERVER, IID_IPersistFile, (LPVOID *)&ppf);
    if (FAILED(hr))
        goto Exit;

    hr = ppf->Load(T2COLE(pszFavorite), STGM_READ | STGM_SHARE_DENY_WRITE);
    if (FAILED(hr))
        goto Exit;

    hr = ppf->QueryInterface(riid, ppv);

Exit:
    if (ppf != NULL)
        ppf->Release();

    return hr;
}

DWORD GetFavoriteIeakFlags(LPCTSTR pszFavorite, IUnknown *punk /*= NULL*/)
{
    INamedPropertyBag *pnpb;
    PROPVARIANT var;
    HRESULT     hr;

    ASSERT(NULL != pszFavorite && TEXT('\0') != *pszFavorite);

    //----- Get INamedPropertyBag on internet shortcut object -----
    if (NULL != punk)
        hr = punk->QueryInterface(IID_INamedPropertyBag, (LPVOID *)&pnpb);
    else
        hr = CreateInternetShortcut(pszFavorite, IID_INamedPropertyBag, (LPVOID *)&pnpb);

    if (FAILED(hr))
        return 0;

    //----- Get special IEAK flags -----
    ZeroMemory(&var, sizeof(var));
    var.vt = VT_UI4;

    hr = pnpb->ReadPropertyNPB(IS_BRANDINGW, IK_IEAK_CREATEDW, &var);
    pnpb->Release();

    return (S_OK == hr) ? var.ulVal : 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\brandll\exports.cpp ===
#include "precomp.h"
#include <rashelp.h>
#include "ieaksie.h"
#include "exports.h"
#include "globalsw.h"

#include "tchar.h"

// The following bug may be due to having CHICAGO_PRODUCT set in sources.
// This file and all rsop??.cpp files need to have WINVER defined at at least 500

// BUGBUG: (andrewgu) no need to say how bad this is!
#undef   WINVER
#define  WINVER 0x0500
#include <userenv.h>

#include "RSoP.h"

#define RAS_MAX_TIMEOUT 60                      // 1 minute

static BOOL s_rgfLevels[6] = { TRUE, TRUE, TRUE, TRUE, TRUE, TRUE };
MACRO_LI_InitializeEx(LIF_DEFAULT | LIF_DUPLICATEINODS, s_rgfLevels, countof(s_rgfLevels));


DWORD ProcessGroupPolicyInternal(DWORD dwFlags, HANDLE hToken, HKEY hKeyRoot,
                                                                 PGROUP_POLICY_OBJECT pDeletedGPOList,
                                                                 PGROUP_POLICY_OBJECT pChangedGPOList,
                                                                 ASYNCCOMPLETIONHANDLE pHandle,
                                                                 PBOOL pfAbort,
                                                                 PFNSTATUSMESSAGECALLBACK pfnStatusCallback,
                                                                 BOOL bRSoP = FALSE);

static BOOL   g_SetupLog  (BOOL fInit = TRUE, PCTSTR pszLogFolder = NULL, BOOL bRSoP = FALSE);
static PCTSTR getLogFolder(PTSTR pszFolder = NULL, UINT cchFolder = 0, HANDLE hToken = NULL);
BOOL IsIE5Ins(LPCSTR pszInsA, BOOL fNeedLog = FALSE);

extern TCHAR g_szConnectoidName[RAS_MaxEntryName + 1];

HMODULE g_hmodWininet = NULL;


//
// we use this function to see if we have loaded wininet.dll due to a delayload thunk so that we 
// can free it at dll detach and therefore it will cleanup all of its crud
//
STDAPI_(FARPROC) DelayloadNotifyHook(UINT iReason, PDelayLoadInfo pdli)
{
    if (iReason == dliNoteEndProcessing)
    {
        if (pdli        &&
            pdli->szDll &&
            (StrCmpIA("wininet.dll", pdli->szDll) == 0))
        {
            // wininet was loaded!!
            g_hmodWininet = pdli->hmodCur;
        }
    }

    return NULL;
}


BOOL CALLBACK DllMain(HANDLE hModule, DWORD fdwReason, PVOID fProcessUnload)
{
    if (DLL_PROCESS_ATTACH == fdwReason) {
        g_SetHinst((HINSTANCE)hModule);

        g_hBaseDllHandle        = g_GetHinst();
        DisableThreadLibraryCalls(g_GetHinst());
    }
    else if (DLL_PROCESS_DETACH == fdwReason)
    {
        if (g_CtxIsGp())
        {
            SHCloseKey(g_hHKCU);
        }

        if (fProcessUnload == NULL)
        {
            // we are being unloaded because of a free library,
            // so see if we need to free wininet
            if (IsOS(OS_NT) && g_hmodWininet)
            {
                // we need to free wininet if it was loaded because of a delayload thunk. 
                //
                // (a) we can only safely do this on NT since on win9x calling FreeLibrary during
                //     process detach can cause a crash (depending on what msvcrt you are using).
                //
                // (b) we only really need to free this module from winlogon.exe's process context 
                //     because when we apply group policy in winlogon, MUST finally free wininet 
                //     so that it will clean up all of its reg key and file handles.
                FreeLibrary(g_hmodWininet);
            }
        }
    }

    return TRUE;
}


void CALLBACK BrandInternetExplorer(HWND, HINSTANCE, LPCSTR pszCmdLineA, int)
{   MACRO_LI_PrologEx_C(PIF_STD_C, BrandInternetExplorer)

    USES_CONVERSION;

    PCFEATUREINFO pfi;
    PCTSTR  pszCmdLine;
    HRESULT hr;
    UINT    i;

    g_SetupLog(TRUE, getLogFolder());
    MACRO_InitializeDependacies();
    Out(LI0(TEXT("\r\n")));

    Out(LI0(TEXT("Branding Internet Explorer...")));
    if (NULL != pszCmdLineA && IsBadStringPtrA(pszCmdLineA, StrCbFromCchA(3*MAX_PATH))) {
        Out(LI0(TEXT("! Command line is invalid.")));
        goto Exit;
    }
    
    pszCmdLine = A2CT(pszCmdLineA);
    Out(LI1(TEXT("Command line is \"%s\"."), (NULL != pszCmdLine) ? pszCmdLine : TEXT("<empty>")));

    hr = g_SetGlobals(pszCmdLine);

    if (FAILED(hr)) {
        Out(LI1(TEXT("! Setup of the branding process failed with %s."), GetHrSz(hr)));
        goto Exit;
    }

    if (!IsIE5Ins(T2CA(g_GetIns())))
        goto Exit;

    // BUGBUG: <oliverl> this is a really ugly hack to fix bug 84062 in IE5 database.  
    // Basically what we're doing here is figuring out if this is the external process
    // with only zones reset which doesn't require an ins file.

    pfi = g_GetFeature(FID_ZONES_HKCU);
    
    if (!g_CtxIs(CTX_GP) || !g_CtxIs(CTX_MISC_CHILDPROCESS) ||
        HasFlag(pfi->dwFlags, FF_DISABLE))
    {
        if (!g_IsValidGlobalsSetup()) {
            Out(LI0(TEXT("! Setup of the branding process is invalid.")));
            goto Exit;
        }
    }

    // NOTE: (andrewgu) if *NOT* running in GP or Win2k unattend install context, check if
    // NoExternalBranding restriction is set. this used to include Autoconfig as well, but was
    // taken out to fix ie5.5 b#83568.
    if (!g_CtxIs(CTX_GP | CTX_W2K_UNATTEND) &&
        SHGetRestriction(RP_IE_POLICIESW, RK_RESTRICTIONSW, RV_NO_EXTERNAL_BRANDINGW)) {

        Out(LI0(TEXT("! NoExternalBranding restriction is set. Branding will not be applied.")));
        goto Exit;
    }

    // NOTE: (andrewgu) at this point it can be assumed that all the globals are setup and all
    // necessary files downloaded and move on to the actual branding.
    {   MACRO_LI_Offset(-1);
        Out(LI0(TEXT("\r\n")));
        g_LogGlobalsInfo();
    }

    //----- Download additional customization files -----
    if (g_CtxIs(CTX_AUTOCONFIG | CTX_ICW | CTX_W2K_UNATTEND)) {
        Out(LI0(TEXT("\r\nDownloading additional customization files...")));

        if (g_CtxIs(CTX_AUTOCONFIG | CTX_W2K_UNATTEND))
            hr = ProcessAutoconfigDownload();

        else {
            ASSERT(g_CtxIs(CTX_ICW));
            hr = ProcessIcwDownload();
        }

        if (SUCCEEDED(hr))
            Out(LI0(TEXT("Done.")));

        else {
            Out(LI1(TEXT("Warning! Download failed with %s"), GetHrSz(hr)));
            Out(LI0(TEXT("All customizations requiring additional files will fail!")));
        }
    }

    //----- Main processing loop -----
    hr = S_OK;

    for (i = FID_FIRST; i < FID_LAST; i++) {
        pfi = g_GetFeature(i);
        ASSERT(NULL != pfi);

        if (HasFlag(pfi->dwFlags, FF_DISABLE))
            continue;

        if (NULL == pfi->pfnProcess)
            continue;

        // HACK: <oliverl> we cannot skip favs, qls, channels, general and connection settings
        // and toolbar buttons since their preference/mandate concept is per item and we can't
        // hack GetFeatureBranded because clear logic depends on that returning the right value
        if (g_CtxIs(CTX_GP) && g_CtxIs(CTX_MISC_PREFERENCES) && 
            (FF_DISABLE != GetFeatureBranded(i)) &&
            !((i == FID_TOOLBARBUTTONS) || (i == FID_FAV_MAIN) || (i == FID_QL_MAIN) ||
              (i == FID_LCY4X_CHANNELS) || (i == FID_GENERAL)  || (i == FID_CS_MAIN)))
            continue;

        if (NULL != pfi->pszDescription) {
            MACRO_LI_Offset(1);
            Out(LI1(TEXT("\r\n%s"), pfi->pszDescription));
        }

        if (NULL == pfi->pfnApply || pfi->pfnApply())
            hr = pfi->pfnProcess();

        if (NULL != pfi->pszDescription) {
            MACRO_LI_Offset(1);
            Out(LI0(TEXT("Done.")));
        }

        /* if (E_UNEXPECTED == hr) {
            Out(LI0(TEXT("! Due to fatal error in the processing of the last feature, branding will be terminated.")));
            break;
        } */
    }

Exit:
    Out(LI0(TEXT("Done.")));
    g_SetupLog(FALSE);
}


BOOL CALLBACK BrandICW(LPCSTR pszInsA, LPCSTR, DWORD)
{
    CHAR szCmdLineA[2*MAX_PATH];

    if (!IsIE5Ins(pszInsA,TRUE))
        return TRUE;

    wsprintfA(szCmdLineA, "/mode:icw /ins:\"%s\"", pszInsA);
    BrandInternetExplorer(NULL, NULL, szCmdLineA, 0);

    SHDeleteValue(HKEY_LOCAL_MACHINE, RK_IEAK, RV_ISPSIGN);
    SHDeleteValue(g_GetHKCU(), RK_IEAK, RV_ISPSIGN);

    return TRUE;
}

// new wrapper for BrandICW with extra paramter for connectoid name so we can set the
// LAN settings for the connectoid
BOOL CALLBACK BrandICW2(LPCSTR pszInsA, LPCSTR, DWORD, LPCSTR pszConnectoidA)
{
    USES_CONVERSION;

    LPCTSTR pszIns;

    if (!IsIE5Ins(pszInsA,TRUE))
        return TRUE;

    // BUGBUG: (pritobla) we should avoid writing to target files.  if the ins file is on a
    // read-only media, we would fail..

    // NOTE: (andrewgu) save the connectioid name that was passed in, so connection settings
    // processing code can pick it up.
    pszIns = A2CT(pszInsA);
    InsWriteString (IS_CONNECTSET, IK_APPLYTONAME, A2CT(pszConnectoidA), pszIns);
    InsFlushChanges(pszIns);

    return BrandICW(pszInsA, NULL, 0);
}

BOOL CALLBACK BrandMe(LPCSTR pszInsA, LPCSTR)
{
    return BrandICW(pszInsA, NULL, 0);
}

BOOL CALLBACK BrandIntra(LPCSTR pszInsA)
{
    CHAR szCmdLineA[20 + MAX_PATH];

    wsprintfA(szCmdLineA, "/mode:win2000 /ins:\"%s\"", pszInsA);
    BrandInternetExplorer(NULL, NULL, szCmdLineA, 0);

    return TRUE;
}

void CALLBACK BrandIE4(HWND, HINSTANCE, LPCSTR pszCmdLineA, int)
{   MACRO_LI_PrologEx_C(PIF_STD_C, BrandIE4)

    USES_CONVERSION;

    CHAR    szCmdLineA[MAX_PATH];
    HRESULT hr;
    BOOL    fNoClear,
            fDefAddon;

    g_SetupLog(TRUE, getLogFolder());

    if (0 != StrCmpIA(pszCmdLineA, T2CA(FOLDER_CUSTOM)) &&
        0 != StrCmpIA(pszCmdLineA, T2CA(FOLDER_SIGNUP)) &&
        0 != StrCmpIA(pszCmdLineA, "SIGNUP")) //this is because in turkish i!=I 
    {
        Out(LI1(TEXT("! Command line \"%s\" is invalid."), A2CT(pszCmdLineA)));
        goto Exit;
    }

    // BUGBUG: (pritobla) checking the restriction should be moved into BrandInternetExplorer
    // Can't move it currently because we do other procesing here.
    if (SHGetRestriction(RP_IE_POLICIESW, RK_RESTRICTIONSW, RV_NO_EXTERNAL_BRANDINGW)) {
        Out(LI0(TEXT("! NoExternalBranding restriction is set. Branding will not be applied.")));
        goto Exit;
    }

    wsprintfA(szCmdLineA, "/mode:%s /peruser", (FALSE == ChrCmpIA('c', *pszCmdLineA)) ? "corp" : "isp");

    // BUGBUG: (andrewgu) this is very wrong! we should not be initializing globals here!
    hr = g_SetGlobals(A2CT(szCmdLineA));
    if (FAILED(hr)) {
        Out(LI1(TEXT("! Setup of the branding process failed with %s."), GetHrSz(hr)));
        goto Exit;
    }

    if (!g_IsValidGlobalsSetup()) {
        Out(LI0(TEXT("! Setup of the branding process is invalid.")));
        goto Exit;
    }

    if (!IsIE5Ins(T2CA(g_GetIns())))
        goto Exit;

    //----- Main processing -----
    // NOTE: (andrewgu) at this point it can be assumed that all the globals are setup and all
    // necessary files downloaded and move on to the actual branding.
    fNoClear  = InsGetBool(IS_BRANDING, TEXT("NoClear"), FALSE, g_GetIns());
    fDefAddon = InsGetBool(IS_BRANDING, IK_DEF_ADDON,    FALSE, g_GetIns());

    Out(LI1(TEXT("NoClear flag is%s specified."), fNoClear ? TEXT("") : TEXT(" not")));

    // if NoClear is not set or use default menu text and URL for Windows Update is specified,
    // delete the custom reg values
    if (!fNoClear || fDefAddon) {
        if (fNoClear  &&  fDefAddon)
            Out(LI0(TEXT("Use default Windows Update menu text and URL flag is specified.")));

        SHDeleteValue(g_GetHKCU(), RK_IE_POLICIES, RV_HELP_MENU_TEXT);
        SHDeleteValue(HKEY_LOCAL_MACHINE, RK_HELPMENUURL, RV_3);

        Out(LI0(TEXT("Deleted reg values for custom Windows Update menu text and URL.")));
    }

    // process Tools->Windows Update menu text and URL customization only if one of
    // fDefAddon or fNoAddon or fCustAddon is TRUE
    if (!fDefAddon) {
        TCHAR szAddOnURL[INTERNET_MAX_URL_LENGTH],
              szMenuText[128];
        BOOL  fSetReg = FALSE,
              fNoAddon,
              fCustAddon;

        fNoAddon   = InsGetBool(IS_BRANDING, IK_NO_ADDON,   FALSE, g_GetIns());
        fCustAddon = InsGetBool(IS_BRANDING, IK_CUST_ADDON, FALSE, g_GetIns());

        if (fNoAddon) {
            Out(LI0(TEXT("Flag to remove Windows Update from Tools menu is specified.")));

            *szMenuText = TEXT('\0');
            *szAddOnURL = TEXT('\0');
            fSetReg = TRUE;
        }
        else if (fCustAddon) {
            Out(LI0(TEXT("Use custom Windows Update text and URL flag is specified.")));

            GetPrivateProfileString(IS_BRANDING, IK_HELP_MENU_TEXT, TEXT(""), szMenuText, countof(szMenuText), g_GetIns());
            GetPrivateProfileString(IS_BRANDING, IK_ADDONURL,       TEXT(""), szAddOnURL, countof(szAddOnURL), g_GetIns());
            if (TEXT('\0') != szMenuText[0] && TEXT('\0') != szAddOnURL[0]) {
                Out(LI1(TEXT("Custom Windows Update menu text = \"%s\""), szMenuText));
                Out(LI1(TEXT("Custom Windows Update URL       = \"%s\""), szAddOnURL));
                fSetReg = TRUE;
            }
            else
                Out(LI0(TEXT("One of custom Windows Update menu text or URL is not specified;")
                        TEXT(" so customization will not be applied.")));
        }

        if (fSetReg) {
            // if the menu text is an empty string, the browser will remove the item from the Tools menu;
            // otherwise, it will use string we set
            SHSetValue(g_GetHKCU(), RK_IE_POLICIES, RV_HELP_MENU_TEXT, REG_SZ, (CONST BYTE *) szMenuText, (DWORD)StrCbFromSz(szMenuText));

            // Note. The association of the value name "3" with the addon URL comes from homepage.inf.
            // So we have a dependency with homepage.inf.
            if (*szAddOnURL)
                SHSetValue(HKEY_LOCAL_MACHINE, RK_HELPMENUURL, RV_3, REG_SZ, (CONST BYTE *) szAddOnURL, (DWORD)StrCbFromSz(szAddOnURL));
            else
                SHDeleteValue(HKEY_LOCAL_MACHINE, RK_HELPMENUURL, RV_3);
        }
    }

    switch (*pszCmdLineA) {
    case 'c':
    case 'C':
        {
            MACRO_LI_Offset(-1);                // need a new scope
            Out(LI0(TEXT("\r\n")));
            BrandInternetExplorer(NULL, NULL, szCmdLineA, 0);
        }
        break;

    case 's':
    case 'S':
        if (HasFlag(g_GetContext(), CTX_SIGNUP_ALL) && IsNTAdmin()) {
            DWORD dwAux, dwSize;

            dwAux  = 1;
            dwSize = sizeof(dwAux);
            SHSetValue(HKEY_LOCAL_MACHINE, RK_IEAK, RV_ISPSIGN, REG_DWORD, (LPBYTE)&dwAux, dwSize);
            SHSetValue(g_GetHKCU(), RK_IEAK, RV_ISPSIGN, REG_DWORD, (LPBYTE)&dwAux, dwSize);

            dwAux = 0;
            SHSetValue(g_GetHKCU(), RK_ICW, RV_COMPLETED, REG_DWORD, (LPBYTE)&dwAux, dwSize);
        }

        {
            MACRO_LI_Offset(-1);                // need a new scope
            Out(LI0(TEXT("\r\n")));
            BrandInternetExplorer(NULL, NULL, szCmdLineA, 0);
        }

        // launch IE to complete the sign up process after the branding is complete
        if (HasFlag(g_GetContext(), CTX_SIGNUP_ALL) && IsNTAdmin()) {
            TCHAR szIExplorePath[MAX_PATH];
            DWORD dwType = REG_SZ,
                  dwSize;

            // check for automatic signup
            dwSize = countof(szIExplorePath);
            *szIExplorePath = TEXT('\0'); // using szIExplorePath as a temporary variable...
            SHGetValue(g_GetHKCU(), RK_IEAK, RV_NOAUTOSIGNUP, &dwType, (LPBYTE)szIExplorePath, &dwSize);
            if (StrCmp(szIExplorePath, TEXT("1")) != 0) // if do autosignup
            {
                dwSize = countof(szIExplorePath);
                if (SHGetValue(HKEY_LOCAL_MACHINE, REGSTR_PATH_APPPATHS TEXT("\\IEXPLORE.EXE"),
                               TEXT(""), NULL, (LPVOID)szIExplorePath, &dwSize) == ERROR_SUCCESS) {
                    SHELLEXECUTEINFO shInfo;

                    ZeroMemory(&shInfo, sizeof(shInfo));
                    shInfo.cbSize = sizeof(shInfo);
                    shInfo.fMask  = SEE_MASK_NOCLOSEPROCESS;
                    shInfo.hwnd   = GetDesktopWindow();
                    shInfo.lpVerb = TEXT("open");
                    shInfo.lpFile = szIExplorePath;
                    shInfo.nShow  = SW_SHOWNORMAL;

                    ShellExecuteEx(&shInfo);
                    if (shInfo.hProcess != NULL)
                        CloseHandle(shInfo.hProcess);
                }
            }
        }
        break;

    default:
        ASSERT(FALSE);
    }

Exit:
    Out(LI0(TEXT("Done.")));
    g_SetupLog(FALSE);
}

//Qfe 3430: When parsing ins file, with reference to pac file, wininet needs to 
//know the connectoid name in order to set the pac file correctly. Currently there
//is no way for wininet to pass the connectoid name to branding dll. To workaround
//this, we use the AUTO_PROXY_EXTERN_STRUC to pass the connectoid name in lpszScriptBuffer
//variable. 
typedef struct 
{
    DWORD dwStructSize;
    LPSTR lpszScriptBuffer;
    DWORD dwScriptBufferSize;
}  AUTO_PROXY_EXTERN_STRUC, *LPAUTO_PROXY_EXTERN_STRUC;

BOOL CALLBACK _InternetInitializeAutoProxyDll(DWORD, LPCSTR pszInsA, LPCSTR, LPVOID, DWORD_PTR lpExtraStruct)
{
    static BOOL fRunning; /*= FALSE;*/
    CHAR szCmdLineA[2*MAX_PATH];

    if (fRunning)
        return TRUE;
    fRunning = TRUE;

    USES_CONVERSION;
    
    if(lpExtraStruct && ((LPAUTO_PROXY_EXTERN_STRUC)lpExtraStruct)->lpszScriptBuffer)
    {
        LPCSTR pszConnectoidA = ((LPAUTO_PROXY_EXTERN_STRUC)lpExtraStruct)->lpszScriptBuffer;
        StrCpy(g_szConnectoidName, A2CT(pszConnectoidA));
    }

    wsprintfA(szCmdLineA, "/mode:autoconfig /ins:\"%s\"", pszInsA);
    BrandInternetExplorer(NULL, NULL, szCmdLineA, 0);

    fRunning = FALSE;
    return TRUE;
}

void CALLBACK BrandInfAndOutlookExpress(LPCSTR pszInsA)
{
    CHAR szCmdLineA[2*MAX_PATH];

    wsprintfA(szCmdLineA, "/mode:generic /ins:\"%s\" /flags:erim=0,eriu=0,oe=0 /disable", pszInsA);
    BrandInternetExplorer(NULL, NULL, szCmdLineA, 0);
}

BOOL CALLBACK BrandCleanInstallStubs(HWND, HINSTANCE, LPCSTR pszCompanyA, int)
{   MACRO_LI_PrologEx_C(PIF_STD_C, BrandCleanInstallStubs)

    USES_CONVERSION;

    TCHAR   szBrandStubGuid[MAX_PATH];
    LPCTSTR pszCompany;
    HKEY    hklm, hkcu;
    LONG    lResult;

    g_SetupLog(TRUE, getLogFolder());

    pszCompany = A2CT(pszCompanyA);
    if (pszCompany == NULL)
        pszCompany = TEXT("");

    if (*pszCompany == TEXT('>'))
        StrCpy(szBrandStubGuid, pszCompany);
    else
        wnsprintf(szBrandStubGuid, countof(szBrandStubGuid), TEXT(">%s%s"), BRANDING_GUID_STR, pszCompany);
        
    Out(LI1(TEXT("\r\nCleaning install stubs; Company GUID is \"%s\"..."), szBrandStubGuid));

    if (*pszCompany != TEXT('\0') && *pszCompany != TEXT(' ')) {
        HKEY hk;

        lResult = SHCreateKeyHKLM(RK_UNINSTALL_BRANDING, KEY_SET_VALUE, &hk);
        if (lResult == ERROR_SUCCESS) {
            RegSetValueEx(hk, RV_QUIET,      0, REG_SZ, (LPBYTE)RD_RUNDLL, sizeof(RD_RUNDLL));
            RegSetValueEx(hk, RV_REQUIRE_IE, 0, REG_SZ, (LPBYTE)RD_IE_VER, sizeof(RD_IE_VER));

            SHCloseKey(hk);
        }
    }
    else {
        SHDeleteKey(HKEY_LOCAL_MACHINE, RK_UNINSTALL_BRANDING);

        SHDeleteValue(HKEY_LOCAL_MACHINE, RK_IEAK, RV_ISPSIGN);
        SHDeleteValue(g_GetHKCU(),  RK_IEAK, RV_ISPSIGN);

        // if the previous version of IE is 3.0 or lower, delete the CUSTOM and SIGNUP folders under the IE install dir
        if (BackToIE3orLower())
        {
            TCHAR szPath[MAX_PATH];

            if (GetIEPath(szPath, countof(szPath)) != NULL)
            {
                LPTSTR pszPtr = PathAddBackslash(szPath);

                SHDeleteKey(g_GetHKCU(), RK_IEAK_CABVER);
                SHDeleteKey(HKEY_LOCAL_MACHINE, RK_IEAK_CABVER);

                StrCpy(pszPtr, TEXT("CUSTOM"));
                PathRemovePath(szPath);
                Out(LI1(TEXT("Deleted folder \"%s\"..."), szPath));

                StrCpy(pszPtr, TEXT("SIGNUP"));
                PathRemovePath(szPath);
                Out(LI1(TEXT("Deleted folder \"%s\"..."), szPath));
            }
        }

        Clear(NULL, NULL, NULL, 0);

        // clear out the "Windows Update" menu customizations
        // NOTE: this can't be merged into Clear() because during
        // install time, these customizations are set before Clear()
        // is called.
        SHDeleteValue(g_GetHKCU(), RK_IE_POLICIES, RV_HELP_MENU_TEXT);
        SHDeleteValue(HKEY_LOCAL_MACHINE, RK_HELPMENUURL, RV_3);
    }

    lResult = SHOpenKeyHKLM(RK_AS_INSTALLEDCOMPONENTS, KEY_ALL_ACCESS, &hklm);
    if (lResult == ERROR_SUCCESS) 
    {
        TCHAR szSubkey[MAX_PATH];
        DWORD dwSize,
              dwSubkey;

        hkcu = NULL;                            // if the next line fails
        SHOpenKey(g_GetHKCU(), RK_AS_INSTALLEDCOMPONENTS, KEY_ALL_ACCESS, &hkcu);

        dwSubkey = 0;
        dwSize   = countof(szSubkey);
        while (RegEnumKeyEx(hklm, dwSubkey, szSubkey, &dwSize, NULL, NULL, 0, NULL) == ERROR_SUCCESS) 
        {
            TCHAR szCompId[MAX_PATH];

            if (StrCmpI(szBrandStubGuid, szSubkey) != 0)
            {
                // look for the BRANDING.CAB ComponentID value under the key if we didn't just add
                // this guid
                
                dwSize = sizeof(szCompId);
                
                if ((SHGetValue(hklm, szSubkey, TEXT("ComponentID"), NULL, (LPBYTE)szCompId, 
                    &dwSize) == ERROR_SUCCESS) && (StrCmpI(szCompId, TEXT("BRANDING.CAB")) == 0))
                {
                    Out(LI1(TEXT("Deleting install stub key \"%s\"..."), szSubkey));
                    
                    SHDeleteKey(hklm, szSubkey);
                    if (hkcu != NULL)
                        SHDeleteKey(hkcu, szSubkey);
                    
                    dwSize = countof(szSubkey);
                    continue;                   // maintain the index properly
                }
            }
            dwSize = countof(szSubkey);
            dwSubkey++;
        }
        SHCloseKey(hklm);

        if (hkcu != NULL)
            SHCloseKey(hkcu);
    }

    Out(LI0(TEXT("Done.")));
    g_SetupLog(FALSE);

    return TRUE;
}

void CALLBACK Clear(HWND, HINSTANCE, LPCSTR, int)
{   MACRO_LI_PrologEx_C(PIF_STD_C, Clear)

    HKEY  hk;
    TCHAR szIEResetInf[MAX_PATH];

    g_SetupLog(TRUE, getLogFolder());

    Out(LI0(TEXT("\r\nRemoving customizations...")));
    MACRO_InitializeDependacies();

    if (SHOpenKeyHKLM(RK_IE_MAIN, KEY_DEFAULT_ACCESS, &hk) == ERROR_SUCCESS)
    {
        RegDeleteValue(hk, RV_COMPANYNAME);
        RegDeleteValue(hk, RV_WINDOWTITLE);
        RegDeleteValue(hk, RV_CUSTOMKEY);
        RegDeleteValue(hk, RV_SMALLBITMAP);
        RegDeleteValue(hk, RV_LARGEBITMAP);

        SHCloseKey(hk);
    }

    if (SHOpenKey(g_GetHKCU(), RK_IE_MAIN, KEY_DEFAULT_ACCESS, &hk) == ERROR_SUCCESS)
    {
        RegDeleteValue(hk, RV_SEARCHBAR);
        RegDeleteValue(hk, RV_USE_CUST_SRCH_URL);
        RegDeleteValue(hk, RV_WINDOWTITLE);

        SHCloseKey(hk);
    }

    if (SHOpenKey(g_GetHKCU(), RK_HELPMENUURL, KEY_DEFAULT_ACCESS, &hk) == ERROR_SUCCESS)
    {
        RegDeleteValue(hk, RV_ONLINESUPPORT);
        SHCloseKey(hk);
    }

    if (SHOpenKey(g_GetHKCU(), RK_TOOLBAR, KEY_DEFAULT_ACCESS, &hk) == ERROR_SUCCESS)
    {
        RegDeleteValue(hk, RV_BRANDBMP);
        RegDeleteValue(hk, RV_SMALLBRANDBMP);
        RegDeleteValue(hk, RV_BACKGROUNDBMP);
        RegDeleteValue(hk, RV_BACKGROUNDBMP50);
        RegDeleteValue(hk, RV_SMALLBITMAP);
        RegDeleteValue(hk, RV_LARGEBITMAP);

        SHCloseKey(hk);
    }

    if (SHOpenKeyHKLM(RK_UA_POSTPLATFORM, KEY_DEFAULT_ACCESS, &hk) == ERROR_SUCCESS)
    {
        TCHAR szUAVal[MAX_PATH];
        TCHAR szUAData[32];
        DWORD sUAVal = countof(szUAVal);
        DWORD sUAData = sizeof(szUAData);
        int iUAValue = 0;

        while (RegEnumValue(hk, iUAValue, szUAVal, &sUAVal, NULL, NULL, (LPBYTE)szUAData, &sUAData) == ERROR_SUCCESS)
        {
            Out(LI2(TEXT("Checking User Agent Key %s = %s"), szUAVal, szUAData));

            sUAVal  = countof(szUAVal);
            sUAData = sizeof(szUAData);

            if (StrCmpN(szUAData, TEXT("IEAK"), 4) == 0)
            {
                Out(LI1(TEXT("Deleting User Agent Key %s"), szUAVal));
                RegDeleteValue(hk, szUAVal);
                continue;
            }

            iUAValue++;
        }

        SHCloseKey(hk);
    }

    // restore RV_DEFAULTPAGE and START_PAGE_URL to the default MS value
    GetWindowsDirectory(szIEResetInf, countof(szIEResetInf));
    PathAppend(szIEResetInf, TEXT("inf\\iereset.inf"));
    if (PathFileExists(szIEResetInf))
    {
        TCHAR szDefHomePage[MAX_PATH];

        GetPrivateProfileString(IS_STRINGS, TEXT("MS_START_PAGE_URL"), TEXT(""), szDefHomePage, countof(szDefHomePage), szIEResetInf);
        WritePrivateProfileString(IS_STRINGS, TEXT("START_PAGE_URL"), szDefHomePage, szIEResetInf);

        SHSetValue(HKEY_LOCAL_MACHINE, RK_IE_MAIN, RV_DEFAULTPAGE, REG_SZ, (LPCVOID)szDefHomePage, (DWORD)StrCbFromSz(szDefHomePage));
    }

    Out(LI0(TEXT("Done.")));
    g_SetupLog(FALSE);
}

void CALLBACK CloseRASConnections(HWND, HINSTANCE, LPCTSTR, int)
{   MACRO_LI_PrologEx_C(PIF_STD_C, CloseRASConnections)

    USES_CONVERSION;

    RASCONNSTATUSA rcsA;
    LPRASCONNA     prcA;
    DWORD cEntries,
          dwResult;
    UINT  i, iRetries;
    BOOL  fRasApisLoaded;

    g_SetupLog(TRUE, getLogFolder());

    Out(LI0(TEXT("Closing RAS connections...")));
    prcA           = NULL;
    fRasApisLoaded = FALSE;

    if (!RasIsInstalled()) {
        Out(LI0(TEXT("RAS support is not installed. There are no active RAS connections!")));
        goto Exit;
    }

    if (!RasPrepareApis(RPA_RASHANGUPA | RPA_RASGETCONNECTSTATUSA) ||
        (g_pfnRasHangupA == NULL || g_pfnRasGetConnectStatusA == NULL)) {
        Out(LI0(TEXT("! Required RAS APIs failed to load.")));
        goto Exit;
    }
    fRasApisLoaded = TRUE;

    dwResult = RasEnumConnectionsExA(&prcA, NULL, &cEntries);
    if (dwResult != ERROR_SUCCESS) {
        Out(LI1(TEXT("! Enumeration of RAS connections failed with %s."), GetHrSz(dwResult)));
        goto Exit;
    }

    for (i = 0;  i < cEntries;  i++) {
        if (i > 0)
            Out(LI0(TEXT("\r\n")));
        Out(LI1(TEXT("Closing \"%s\" connection..."), A2CT((prcA + i)->szEntryName)));

        dwResult = g_pfnRasHangupA((prcA + i)->hrasconn);
        if (dwResult != ERROR_SUCCESS) {
            Out(LI1(TEXT("! Operation failed with %s."), GetHrSz(dwResult)));
            continue;
        }

        for (iRetries = 0; iRetries < RAS_MAX_TIMEOUT; iRetries++) {
            ZeroMemory(&rcsA, sizeof(rcsA));
            rcsA.dwSize = sizeof(rcsA);
            dwResult   = g_pfnRasGetConnectStatusA((prcA + i)->hrasconn, &rcsA);
            if (dwResult != ERROR_SUCCESS)
                break;

            TimerSleep(1000);                   // 1 second
        }
        if (iRetries >= RAS_MAX_TIMEOUT)
            Out(LI0(TEXT("! Operation timed out.")));
    }

Exit:
    if (prcA != NULL)
        CoTaskMemFree(prcA);

    if (fRasApisLoaded)
        RasPrepareApis(RPA_UNLOAD, FALSE);

    Out(LI0(TEXT("Done.")));
    g_SetupLog(FALSE);
}


/////////////////////////////////////////////////////////////////////////////
// Implementation helper routines

#define BRNDLOG_INI TEXT("brndlog.ini")
#define RSOPLOG_INI TEXT("rsoplog.ini")
#define BRNDLOG_TXT TEXT("brndlog.txt")
#define RSOPLOG_TXT TEXT("rsoplog.txt")
#define DOT_BAK     TEXT(".bak")

#define IS_SETTINGS TEXT("Settings")
#define IK_FILE     TEXT("LogFile")
#define IK_LOGFLAGS TEXT("LogFlags")
#define IK_DOLOG    TEXT("DoLog")
#define IK_BACKUP   TEXT("BackupFiles")
#define IK_FLUSH    TEXT("FlushEveryWrite")
#define IK_APPEND   TEXT("AppendToLog")


static BOOL g_SetupLog(BOOL fInit /*= TRUE*/, PCTSTR pszLogFolder /*= NULL*/, BOOL bRSoP /*= FALSE*/)
{
    static UINT s_cRef; /*= 0*/

    if (fInit) {
        TCHAR szIni[MAX_PATH],
              szLog[MAX_PATH], szBak[MAX_PATH], szAux[MAX_PATH], szExt[5],
              szFlags[17];
        DWORD dwFlags;
        UINT  nBackups,
              i;
        BOOL  fDoLog,
              fAppend;

        // refcount g_hfileLog
        if (NULL != g_hfileLog) {
            ASSERT(0 < s_cRef);
            s_cRef++;

            return TRUE;
        }
        ASSERT(0 == s_cRef);

        // determine the locaion of the log settings file
        if (NULL != pszLogFolder){
            ASSERT(PathIsValidPath(pszLogFolder));

            StrCpy(szIni, pszLogFolder);
        }
        else {
            ASSERT(NULL != g_GetHinst());

            GetModuleFileName(g_GetHinst(), szIni, countof(szIni));
            PathRemoveFileSpec(szIni);
        }
        PathAppend(szIni, bRSoP ? RSOPLOG_INI : BRNDLOG_INI);

        // log file name or even log file path
                InsGetString(IS_SETTINGS, IK_FILE, szLog, countof(szLog), szIni);
                if (TEXT('\0') == szLog[0])
                        StrCpy(szLog, bRSoP ? RSOPLOG_TXT : BRNDLOG_TXT);

        if (PathIsFileSpec(szLog))
            if (NULL != pszLogFolder) {
                PathCombine(szAux, pszLogFolder, szLog);
                StrCpy(szLog, szAux);
            }
            else {
                GetWindowsDirectory(szAux, countof(szAux));
                PathAppend(szAux, szLog);
                StrCpy(szLog, szAux);
            }

        // logging flags
        dwFlags = LIF_NONE;

        InsGetString(IS_SETTINGS, IK_LOGFLAGS, szFlags, countof(szFlags), szIni);
        if (TEXT('\0') != szFlags[0]) {
            StrToIntEx(szFlags, STIF_SUPPORT_HEX, (PINT)&dwFlags);
            if (-1 == (int)dwFlags)
                dwFlags = LIF_NONE;
        }

        if (LIF_NONE == dwFlags) {
            dwFlags = LIF_DATETIME | LIF_APPENDCRLF;
            DEBUG_CODE(dwFlags |= LIF_FILE | LIF_FUNCTION | LIF_CLASS | LIF_LINE);
        }
        MACRO_LI_SetFlags(dwFlags);

        // append to the existing log?
        fAppend = InsGetBool(IS_SETTINGS, IK_APPEND, FALSE, szIni);

        // backup settings
        // Note. if (fAppend), the default is to clear all the backups.
        StrCpy(szBak, szLog);

        if (fAppend)
            nBackups = 0;

        else {
            nBackups = 1;                       // default in retail: 1
            DEBUG_CODE(nBackups = 10);          // default in debug: 10
        }

        nBackups = InsGetInt(IS_SETTINGS, IK_BACKUP, nBackups, szIni);
        for (i = nBackups; i < 10; i++) {
            if (0 == i)
                StrCpy(szExt, DOT_BAK);
            else
                wnsprintf(szExt, countof(szExt), TEXT(".%03u"), i);

            PathRenameExtension(szBak, szExt);
            if (!PathFileExists(szBak))
                break;
            DeleteFile(szBak);
        }

        // create a log for the call in progress?
        fDoLog = InsGetBool(IS_SETTINGS, IK_DOLOG, TRUE, szIni);
        g_fFlushEveryWrite = FALSE;

        if (fDoLog) {
            if (!fAppend && 0 < nBackups) {
                StrCpy(szAux, szLog);
                StrCpy(szBak, szLog);

                for (i = nBackups; 0 < i; i--) {
                    // source file
                    if (1 == i)
                        StrCpy(szAux, szLog);

                    else {
                        if (2 == i)
                            StrCpy(szExt, DOT_BAK);
                        else
                            wnsprintf(szExt, countof(szExt), TEXT(".%03u"), i-2);

                        PathRenameExtension(szAux, szExt);
                        if (!PathFileExists(szAux))
                            continue;
                    }

                    // target file
                    if (1 == i)
                        StrCpy(szExt, DOT_BAK);
                    else
                        wnsprintf(szExt, countof(szExt), TEXT(".%03u"), i-1);

                    PathRenameExtension(szBak, szExt);

                    // push log down the chain
                    CopyFile(szAux, szBak, FALSE);
                }
            }

            // flush current log on every write (i.e. every log output)?
            DEBUG_CODE(g_fFlushEveryWrite = TRUE);
            g_fFlushEveryWrite = InsGetBool(IS_SETTINGS, IK_FLUSH, g_fFlushEveryWrite, szIni);

            g_hfileLog = CreateFile(szLog,
                                    GENERIC_WRITE,
                                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                                    NULL,
                                    fAppend ? OPEN_ALWAYS : CREATE_ALWAYS,
                                    FILE_ATTRIBUTE_NORMAL,
                                    NULL);
            if (INVALID_HANDLE_VALUE == g_hfileLog)
                g_hfileLog = NULL;

            else {
                s_cRef++;                       // increment g_hfileLog ref count

                if (fAppend) {
                    SetFilePointer(g_hfileLog, 0, NULL, FILE_END);
                    Out(LI0(TEXT("\r\n\r\n")));
                }
            }
        }
    }
    else { /* if (!fInit) */
        if (1 == s_cRef && NULL != g_hfileLog) {
            CloseHandle(g_hfileLog);
            g_hfileLog = NULL;
        }

        if (0 < s_cRef)
            s_cRef--;
    }

    return TRUE;
}

PCTSTR getLogFolder(PTSTR pszFolder /*= NULL*/, UINT cchFolder /*= 0*/, HANDLE hToken /* = NULL */)
{
    static TCHAR s_szPath[MAX_PATH];
    static UINT  s_cchPath;

    if (NULL != pszFolder)
        *pszFolder = TEXT('\0');

    if (!IsOS(OS_NT))
        return NULL;

    if (TEXT('\0') == s_szPath[0]) {
                HRESULT hr;

                hr = SHGetFolderPathSimple(CSIDL_APPDATA | CSIDL_FLAG_CREATE, s_szPath);
                if (FAILED(hr))
                                return NULL;

                // need to make sure app data path is owned by user in the GP context

                if (g_CtxIsGp() && (hToken != NULL))
                                SetUserFileOwner(hToken, s_szPath);

                PathAppend(s_szPath, TEXT("Microsoft"));
                if (!PathFileExists(s_szPath)) {
                                CreateDirectory  (s_szPath, NULL);
                                SetFileAttributes(s_szPath, FILE_ATTRIBUTE_SYSTEM);
                }
                PathAppend(s_szPath, TEXT("Internet Explorer"));

                PathCreatePath(s_szPath);
                if (!PathFileExists(s_szPath))
                                return NULL;

                s_cchPath = StrLen(s_szPath);
    }
    else
        ASSERT(0 < s_cchPath);

    if (NULL == pszFolder || cchFolder <= s_cchPath)
        return s_szPath;

    StrCpy(pszFolder, s_szPath);
    return pszFolder;
}

// NOTE: (genede) Added 1/26/2001 to block branding of INS files created prior to IE 5.0 Gold.
// While the Wizard creates a [Branding] | Wizard_Version key that can be used to determine 
// this, neither the Profile Manger nor the IEM did so, so their INS files must always be
// branded.  To allow IEAK 7 to be able to block all INS files made prior to IE 6, IE 6 bug db 
// #25076 was opened, requiring the addition of a version entry to Profile Manager and IEM
// created INS files.  This bug was fixed on 2/23/2001.
BOOL IsIE5Ins(LPCSTR pszInsA, BOOL fNeedLog /*= FALSE*/)
{   MACRO_LI_PrologEx_C(PIF_STD_C, IsIE5Ins)

    USES_CONVERSION;

    TCHAR szWizVer[MAX_PATH];
    DWORD dwVer,
          dwBuild;

    // If [Branding] | Wizard_Version exists, the INS was created by the Wizard.
    if (InsKeyExists(IS_BRANDING, IK_WIZVERSION, A2CT(pszInsA))) {
        InsGetString(IS_BRANDING, IK_WIZVERSION, szWizVer, countof(szWizVer), A2CT(pszInsA));
        ConvertVersionStrToDwords(szWizVer, &dwVer, &dwBuild);
        // If the version is < 5, don't brand.
        if (5 > HIWORD(dwVer)) {
            // Open a log if one has not already been opened.
            if (fNeedLog)
                g_SetupLog(TRUE, getLogFolder());

            Out(LI0(TEXT("! Branding of INS files created by IEAK Wizard 4.x and earlier is not supported.")));

            // Close a log if one was opened.
            if (fNeedLog)
                g_SetupLog(FALSE);

            return FALSE;
        }
    }

    // The INS was created by ProfMgr or IEM, or by Wiz ver 5.0 or greater, so brand.
    return TRUE;
}

//----------------------------------------------------------------------------------------
// NT5 client processing

#define RK_IEAKCSE   REGSTR_PATH_NT_CURRENTVERSION TEXT("\\Winlogon\\GPExtensions\\{A2E30F80-D7DE-11d2-BBDE-00C04F86AE3B}")

static void    brandExternalHKCUStuff(LPCTSTR pcszInsFile);
static BOOL    constructCmdLine(LPTSTR pszCmdLine, DWORD cchLen, LPCTSTR pcszInsFile, BOOL fExternal);
static void    displayStatusMessage(PFNSTATUSMESSAGECALLBACK pStatusCallback);
static HRESULT pepCopyFilesEnumProc(LPCTSTR pszPath, PWIN32_FIND_DATA pfd, LPARAM lParam, PDWORD *prgdwControl = NULL);
PFNPATHENUMPATHPROC GetPepCopyFilesEnumProc() {return pepCopyFilesEnumProc;}

STDAPI DllRegisterServer(void)
{   MACRO_LI_PrologEx_C(PIF_STD_C, DllRegisterServer)
    HKEY hKey;
    LONG lResult = S_OK;
    TCHAR szName[MAX_PATH];

    g_SetupLog(TRUE, getLogFolder());

    if (IsOS(OS_NT5))
    {
        lResult = SHCreateKeyHKLM(RK_IEAKCSE, KEY_WRITE, &hKey);
        
        if (lResult == ERROR_SUCCESS)
        {
            DWORD dwVal;

            if (IsOS(OS_WHISTLERORGREATER))
            {
                RegSetValueEx(hKey, TEXT("ProcessGroupPolicyEx"), 0, REG_SZ, (LPBYTE)TEXT("ProcessGroupPolicyEx"),
                                (StrLen(TEXT("ProcessGroupPolicyEx")) + 1) * sizeof(TCHAR));
                RegSetValueEx(hKey, TEXT("GenerateGroupPolicy"), 0, REG_SZ, (LPBYTE)TEXT("GenerateGroupPolicy"),
                                (StrLen(TEXT("GenerateGroupPolicy")) + 1) * sizeof(TCHAR));
            }

            // ushaji said this chould stay registered in Whistler
            RegSetValueEx(hKey, TEXT("ProcessGroupPolicy"), 0, REG_SZ, (LPBYTE)TEXT("ProcessGroupPolicy"),
                                    (StrLen(TEXT("ProcessGroupPolicy")) + 1) * sizeof(TCHAR));

            RegSetValueEx(hKey, TEXT("DllName"), 0, REG_EXPAND_SZ, (LPBYTE)TEXT("iedkcs32.dll"),
                    (StrLen(TEXT("iedkcs32.dll")) + 1) * sizeof(TCHAR));

            LoadString(g_GetHinst(), IDS_NAME, szName, countof(szName));

            RegSetValueEx(hKey, NULL, 0, REG_SZ, (LPBYTE) szName,
                    (DWORD)StrCbFromSz(szName));

            // do not process on slow link by default

            dwVal = 1;
            RegSetValueEx(hKey, TEXT("NoSlowLink"), 0, REG_DWORD, (LPBYTE)&dwVal, sizeof(dwVal)); 
            
            // process in background by default

            dwVal = 0;
            RegSetValueEx(hKey, TEXT("NoBackgroundPolicy"), 0, REG_DWORD, (LPBYTE)&dwVal, sizeof(dwVal)); 
            
            // do not process if no GPO changes by default

            dwVal = 1;
            RegSetValueEx(hKey, TEXT("NoGPOListChanges"), 0, REG_DWORD, (LPBYTE)&dwVal, sizeof(dwVal)); 
            
            // do not process machine policy changes by default

            dwVal = 1;
            RegSetValueEx(hKey, TEXT("NoMachinePolicy"), 0, REG_DWORD, (LPBYTE)&dwVal, sizeof(dwVal)); 
            
            RegCloseKey (hKey);
            
            Out(LI0(TEXT("DllRegisterServer keys added successfully!")));
        }
    }

    Out(LI0(TEXT("DllRegisterServer finished.")));
    g_SetupLog(FALSE);

    return lResult;
}

STDAPI DllUnregisterServer(void)
{   MACRO_LI_PrologEx_C(PIF_STD_C, DllUnregisterServer)

    g_SetupLog(TRUE, getLogFolder());

    if (IsOS(OS_NT5))
        SHDeleteKey(HKEY_LOCAL_MACHINE, RK_IEAKCSE);

    Out(LI0(TEXT("DllUnregisterServer finished!")));
    g_SetupLog(FALSE);

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
DWORD WINAPI ProcessGroupPolicy(
    DWORD                    dwFlags,
    HANDLE                   hToken,
    HKEY                     hKeyRoot,
    PGROUP_POLICY_OBJECT     pDeletedGPOList,
    PGROUP_POLICY_OBJECT     pChangedGPOList,
    ASYNCCOMPLETIONHANDLE    pHandle,
    PBOOL                    pfAbort,
    PFNSTATUSMESSAGECALLBACK pfnStatusCallback
)
{   MACRO_LI_PrologEx_C(PIF_STD_C, ProcessGroupPolicy)

        return ProcessGroupPolicyInternal(dwFlags, hToken, hKeyRoot, pDeletedGPOList,
                                                                                pChangedGPOList, pHandle, pfAbort,
                                                                                pfnStatusCallback, FALSE);
}


///////////////////////////////////////////////////////////////////////////////
DWORD ProcessGroupPolicyInternal(
    DWORD                    dwFlags,
    HANDLE                   hToken,
    HKEY                     hKeyRoot,
    PGROUP_POLICY_OBJECT     pDeletedGPOList,
    PGROUP_POLICY_OBJECT     pChangedGPOList,
    ASYNCCOMPLETIONHANDLE    pHandle,
    PBOOL                    pfAbort,
    PFNSTATUSMESSAGECALLBACK pfnStatusCallback,
    BOOL                     bRSoP /*= FALSE*/)
{   MACRO_LI_PrologEx_C(PIF_STD_C, ProcessGroupPolicyInternal)

    TCHAR szIni[MAX_PATH];
    DWORD dwRet;
    BOOL  fDeleteIni;

    UNREFERENCED_PARAMETER(pHandle);
    UNREFERENCED_PARAMETER(hKeyRoot);
    UNREFERENCED_PARAMETER(pDeletedGPOList);
    UNREFERENCED_PARAMETER(bRSoP);

    szIni[0]   = TEXT('\0');
    dwRet      = ERROR_SUCCESS;
    fDeleteIni = TRUE;

    __try
    {
        USES_CONVERSION;

        PGROUP_POLICY_OBJECT pCurGPO;
        TCHAR szCustomDir[MAX_PATH],
              szTempDir[MAX_PATH],
              szInsFile[MAX_PATH];
        HKEY  hkGP = NULL;

        // get our user appdata path
        // BUGBUG: <oliverl> we are currently relying on the fact that g_GetUserToken is not
        // initialized here because when we pass in the NULL it currently gets the local appdata
        // path always due to per process shell folder cache.  This might change in the next
        // rev though if extension order has changed.  We need to do this because of possible
        // folder redirection of appdata to a UNC path which would bust us since we don't 
        // impersonate user everywhere we reference appdata files

        getLogFolder(szCustomDir, countof(szCustomDir), hToken);
        if (TEXT('\0') == szCustomDir[0])
            return ERROR_OVERRIDE_NOCHANGES;

        // set log to append, backup what's there
        g_SetupLog(TRUE, szCustomDir);
        PathCombine(szIni, szCustomDir, BRNDLOG_INI);

        fDeleteIni = !PathFileExists(szIni);
        if (!fDeleteIni && InsKeyExists(IS_SETTINGS, IK_APPEND, szIni))
            InsWriteBool(IS_SETTINGS, TEXT("Was") IK_APPEND,
                InsGetBool(IS_SETTINGS, IK_APPEND, FALSE, szIni), szIni);

        InsWriteBool(IS_SETTINGS, IK_APPEND, TRUE, szIni);

        PathAppend(szCustomDir, TEXT("Custom Settings"));
        MACRO_InitializeDependacies();
        Out(LI0(TEXT("\r\n")));

        Out(LI0(TEXT("Processing Group Policy...")));

        g_SetUserToken(hToken);
        g_SetGPOFlags(dwFlags);
        if (!g_SetHKCU())
            Out(LI0(TEXT("! Failed to acquire HKCU. Some of the settings may not get applied.")));

        /*
        if (dwFlags & GPO_INFO_FLAG_SLOWLINK)
            OutputDebugString (TEXT("IEDKCS32:  Policy is being applied across a slow link.\r\n"));

        if (dwFlags & GPO_INFO_FLAG_VERBOSE)
            OutputDebugString (TEXT("IEDKCS32:  Verbose policy logging is requested (to the eventlog).\r\n"));
        */

        // get a handle to the GPO tracking key up front since we use it so much in the
        // processing below

        if (SHCreateKey(g_GetHKCU(), RK_IEAK_GPOS, KEY_DEFAULT_ACCESS, &hkGP) != ERROR_SUCCESS)
        {
            OutD(LI0(TEXT("! Failed to create GP tracking key. Aborting ...")));
            dwRet =  ERROR_OVERRIDE_NOCHANGES; 
            goto End;
        }

        // Processing deleted GPO list

        for (pCurGPO = pDeletedGPOList; (pCurGPO != NULL); pCurGPO = pCurGPO->pNext)
        {
            if ( *pfAbort )
            {
                OutD(LI0(TEXT("! Aborting further processing due to abort message.")));
                dwRet =  ERROR_OVERRIDE_NOCHANGES; 
                goto End;
            }

            OutD(LI1(TEXT("Deleting GPO: \"%s\"."), pCurGPO->lpDisplayName));
            OutD(LI1(TEXT("Guid is \"%s\"."), pCurGPO->szGPOName));
            SHDeleteKey(hkGP, pCurGPO->szGPOName);
        }

        //
        // Process list of changed GPOs
        //
        if (ISNONNULL(szCustomDir))
        {
            LPTSTR  pszNum;
            LPTSTR  pszFile;
            TCHAR   szExternalCmdLine[MAX_PATH * 2] = TEXT("");
            LPCTSTR pcszGPOGuidArray[256];
            DWORD   dwIndex;
            BOOL    fResetZones, fImpersonate;

            StrCpy(szTempDir, szCustomDir);
            StrCat(szTempDir, TEXT(".tmp"));

            PathCreatePath(szTempDir);
            PathAppend(szTempDir, TEXT("Custom"));

            pszNum = szTempDir + StrLen(szTempDir);

            // need to impersonate the user when we go over the wire in case admin has
            // disabled/removed read access to GPO for authenticated users group

            fImpersonate = ImpersonateLoggedOnUser(g_GetUserToken());

            if (!fImpersonate)
            {
                OutD(LI0(TEXT("! Aborting further processing due to user impersonation failure.")));
                dwRet = ERROR_OVERRIDE_NOCHANGES;
                goto End;
            }
            // pass 1: copy all the files to a temp dir and check to make sure everything
            // is in synch

            Out(LI0(TEXT("Starting Internet Explorer group policy processing part 1 (copying files) ...")));
            for (pCurGPO = pChangedGPOList, dwIndex = 0; 
                 (pCurGPO != NULL) && (dwIndex < countof(pcszGPOGuidArray)); 
                 pCurGPO = pCurGPO->pNext)
            {
                TCHAR szBaseDir[MAX_PATH];
                
                if (*pfAbort)
                {
                    OutD(LI0(TEXT("! Aborting further processing due to abort message.")));
                    break;
                }

                OutD(LI1(TEXT("Processing GPO: \"%s\"."), pCurGPO->lpDisplayName));
                OutD(LI1(TEXT("File path is \"%s\"."), pCurGPO->lpFileSysPath));
                PathCombine(szBaseDir, pCurGPO->lpFileSysPath, TEXT("Microsoft\\Ieak\\install.ins"));
                
                if (PathFileExists(szBaseDir))
                {
                    TCHAR szNum[8];
                    TCHAR szFeatureDir[MAX_PATH];
                    BOOL  fResult;

                    PathRemoveFileSpec(szBaseDir);
                    
                    wnsprintf(szNum, countof(szNum), TEXT("%d"), dwIndex);
                    StrCpy(pszNum, szNum);

                    fResult = CreateDirectory(szTempDir, NULL) && CopyFileToDirEx(szBaseDir, szTempDir);

                    // branding files

                    if (fResult)
                    {
                        PathCombine(szFeatureDir, szBaseDir, IEAK_GPE_BRANDING_SUBDIR);
                        
                        if (PathFileExists(szFeatureDir))
                            fResult = SUCCEEDED(PathEnumeratePath(szFeatureDir, PEP_SCPE_NOFILES, 
                                pepCopyFilesEnumProc, (LPARAM)szTempDir));
                    }

                    // desktop files

                    if (fResult)
                    {
                        PathCombine(szFeatureDir, szBaseDir, IEAK_GPE_DESKTOP_SUBDIR);
                        
                        if (PathFileExists(szFeatureDir))
                            fResult = SUCCEEDED(PathEnumeratePath(szFeatureDir, PEP_SCPE_NOFILES,
                                pepCopyFilesEnumProc, (LPARAM)szTempDir));
                    }

                    if (!fResult)
                    {
                        Out(LI0(TEXT("! Error copying files. No further processing will be done.")));
                        break;
                    }

                    // check to see if cookie is there before doing anything
                    if (PathFileExistsInDir(IEAK_GPE_COOKIE_FILE, szTempDir))
                        break;

                    pcszGPOGuidArray[dwIndex] = pCurGPO->szGPOName;
                    dwIndex++;
                }
            }

            PathRemoveFileSpec(szTempDir);
                
            Out(LI0(TEXT("Done.\r\n")));

            if (fImpersonate)
                RevertToSelf();

            if (pCurGPO != NULL)
            {
                OutD(LI0(TEXT("! Aborting further processing because GPO replication is incomplete")));
                PathRemovePath(szTempDir);

                dwRet = ERROR_OVERRIDE_NOCHANGES;
                goto End;
            }

            // move all our files to the real custom dir
            if (PathFileExists(szCustomDir))
                PathRemovePath(szCustomDir);

            if (!MoveFileEx(szTempDir, szCustomDir, MOVEFILE_REPLACE_EXISTING))
            {
                Out(LI0(TEXT("! Error copying files. No further processing will be done.")));
                dwRet = ERROR_OVERRIDE_NOCHANGES;
                goto End;
            }

            PathCombine(szInsFile, szCustomDir, TEXT("Custom"));
            pszFile = szInsFile + StrLen(szInsFile);

            // begin clear code
            PCFEATUREINFO pfi;
            DWORD dwBranded;
            UINT  i;
            BOOL  fCrlf;

            Out(LI0(TEXT("Clearing policies set by a previous list of GPOs...")));
            fCrlf = FALSE;
            for (i = FID_FIRST; i < FID_LAST; i++) {
                pfi = g_GetFeature(i);
                ASSERT(NULL != pfi);

                if (NULL == pfi->pfnClear)
                    continue;

                dwBranded = GetFeatureBranded(i);
                if (FF_DISABLE != dwBranded) {
                    if (fCrlf)
                        Out(LI0(TEXT("\r\n")));

                    pfi->pfnClear(dwBranded);
                    fCrlf = TRUE;
                }
            }
            Out(LI0(TEXT("Done.\r\n")));

            fResetZones = (GetFeatureBranded(FID_ZONES_HKCU) != FF_DISABLE);

            SHDeleteKey(g_GetHKCU(), RK_IEAK_BRANDED);
            // end clear code

            // if fResetZones is TRUE set the first char to 'z' to indicate that
            // HKCU zones has to be reset to the default levels in the external branding
            szExternalCmdLine[0] = (fResetZones ? TEXT('z') : TEXT(';'));

            Out(LI0(TEXT("Starting Internet Explorer group policy processing part 2 ...")));

            for (dwIndex=0; ; dwIndex++)
            {
                TCHAR  szCmdLine[MAX_PATH*2 + 32];
                CHAR   szCmdLineA[MAX_PATH*2 + 32];
                TCHAR  szCurrentFile[16];
                TCHAR  szInsKey[MAX_PATH];

                if ( *pfAbort )
                {
                    OutD(LI0(TEXT("! Aborting further processing due to abort message.")));

                    dwRet = ERROR_OVERRIDE_NOCHANGES;
                    goto End;
                }
                
                wnsprintf(szCurrentFile, countof(szCurrentFile), TEXT("%d\\INSTALL.INS"), dwIndex);
                StrCpy(pszFile, szCurrentFile);

                if (!PathFileExists(szInsFile))
                    break;

                if (!IsIE5Ins(T2CA(szInsFile)))
                    break;
                
                // check to see if this is a preference GPO which has already been applied
                // we must be careful about which globals we use since context is in an
                // uninitialized state before we call BrandInternetExplorer

                if (InsKeyExists(IS_BRANDING, IK_GPE_ONETIME_GUID, szInsFile))
                {
                    TCHAR szCheckKey[MAX_PATH];
                    TCHAR szInsGuid[128];

                    // we'll check by checking all the way to the external key, if any keys
                    // before that don't exist(never seen the GPO or ins file) we'll fail
                    // as well

                    InsGetString(IS_BRANDING, IK_GPE_ONETIME_GUID, szInsGuid, countof(szInsGuid), szInsFile);
                    PathCombine(szInsKey, pcszGPOGuidArray[dwIndex], szInsGuid);
                    PathCombine(szCheckKey, szInsKey, RK_IEAK_EXTERNAL);
                    if (SHKeyExists(hkGP, szCheckKey) == S_OK)
                    {
                        OutD(LI0(TEXT("! Skipping preference GPO.")));
                        continue;
                    }
                }
                    
                // always set the GPO guid because adms will need this for both preference
                // and mandate GPOs

                g_SetGPOGuid(pcszGPOGuidArray[dwIndex]);
                    
                constructCmdLine(szCmdLine, countof(szCmdLine), szInsFile, FALSE);

                BrandInternetExplorer(NULL, NULL, T2Abux(szCmdLine, szCmdLineA), 0);

                // set our guid in the registry if this is a preference GPO

                if (g_CtxIs(CTX_MISC_PREFERENCES))
                {
                    HKEY hkIns;

                    // make sure the external key is deleted so we can track whether or not
                    // external branding succeeded

                    if (SHCreateKey(hkGP, szInsKey, KEY_DEFAULT_ACCESS, &hkIns) == ERROR_SUCCESS)
                    {
                        SHDeleteKey(hkIns, RK_IEAK_EXTERNAL);
                        SHCloseKey(hkIns);
                    }
                }

                if (constructCmdLine(NULL, 0, szInsFile, TRUE))
                {
                    TCHAR szIndex[8];

                    wnsprintf(szIndex, countof(szIndex), TEXT("%d"), dwIndex);
                    if (ISNONNULL(&szExternalCmdLine[1]))
                        StrCat(szExternalCmdLine, TEXT(","));
                    else
                    {
                        if (!(g_GetGPOFlags() & GPO_INFO_FLAG_BACKGROUND))
                            szExternalCmdLine[1] = TEXT('*');
                    }
                    StrCat(szExternalCmdLine, szIndex);

                    // write out the GPO guid so the external process can read it and mark it
                    // in the registy

                    InsWriteString(IS_BRANDING, IK_GPO_GUID, pcszGPOGuidArray[dwIndex], szInsFile);
                }
                else if (g_CtxIs(CTX_MISC_PREFERENCES))
                {
                    TCHAR szExternalKey[MAX_PATH];
                    HKEY  hkExternal = NULL;

                    // set the external key as finished
                    
                    PathCombine(szExternalKey, szInsKey, RK_IEAK_EXTERNAL);
                    SHCreateKey(hkGP, szExternalKey, KEY_DEFAULT_ACCESS, &hkExternal);
                    SHCloseKey(hkExternal);
                }
            }

            // flush wininet's thread token so they will get the system HKCU back
            InternetSetOption(NULL, INTERNET_OPTION_SETTINGS_CHANGED, NULL, 0);

            if (fResetZones || ISNONNULL(&szExternalCmdLine[1]))
            {
                // we need to pass in the target path since we're not using the true app
                // data path

                StrCat(szExternalCmdLine, TEXT("<"));
                StrCat(szExternalCmdLine, szCustomDir);
                // need to do external branding 
                brandExternalHKCUStuff(szExternalCmdLine);

                SetFilePointer(g_hfileLog, 0, NULL, FILE_END);
            }
        }

End:
        SHCloseKey(hkGP);
        displayStatusMessage(pfnStatusCallback);
        Out(LI0(TEXT("Done processing group policy.")));
    }
    __except(TRUE)
    {
        // might want to use except structures eventually to log out better info
#ifdef _DEBUG
        // REVIEW: (andrewgu) this Out, along with LI0 should still be safe. no double GPF should
        // happen.
        Out(LI1(TEXT("!! Exception caught in ProcessGroupPolicyInternal, RSoP is %s."),
                                bRSoP ? _T("enabled") : _T("disabled")));  
        MessageBeep(MB_ICONEXCLAMATION);
        MessageBeep(MB_ICONEXCLAMATION);
        MessageBeep(MB_ICONEXCLAMATION);
#endif
        dwRet = ERROR_OVERRIDE_NOCHANGES;
    }

    g_SetupLog(FALSE);

    // restore what was backed up (if necessary)
    if (TEXT('\0') != szIni[0] && PathFileExists(szIni))
        if (fDeleteIni)
            DeleteFile(szIni);

        else
            if (!InsKeyExists(IS_SETTINGS, TEXT("Was") IK_APPEND, szIni))
                InsDeleteKey(IS_SETTINGS, IK_APPEND, szIni);

            else {
                InsWriteBool(IS_SETTINGS, IK_APPEND,
                    InsGetBool(IS_SETTINGS, TEXT("Was") IK_APPEND, FALSE, szIni), szIni);
                InsDeleteKey(IS_SETTINGS, TEXT("Was") IK_APPEND, szIni);
            }

    return dwRet;
}

///////////////////////////////////////////////////////////////////////////////
// ProcessGroupPolicyEx
// Added 29 Aug 2000 for RSoP Enabling, logging mode - see RSoP.h & .cpp.
///////////////////////////////////////////////////////////////////////////////
DWORD WINAPI ProcessGroupPolicyEx(DWORD dwFlags, HANDLE hToken, HKEY hKeyRoot,
                                     PGROUP_POLICY_OBJECT pDeletedGPOList,
PGROUP_POLICY_OBJECT  pChangedGPOList,
ASYNCCOMPLETIONHANDLE pHandle, BOOL *pbAbort,
PFNSTATUSMESSAGECALLBACK pStatusCallback,
IWbemServices *pWbemServices,
HRESULT *pRsopStatus)
{
        DWORD dwRet = ERROR_SUCCESS;
        HRESULT hr = E_FAIL;

        TCHAR szIni[MAX_PATH];
        szIni[0] = TEXT('\0');
        BOOL fDeleteIni = TRUE;
        __try
        {
                MACRO_LI_PrologEx_C(PIF_STD_C, ProcessGroupPolicyEx)

                // first, process group policy through our standard function
                dwRet = ProcessGroupPolicyInternal(dwFlags, hToken, hKeyRoot, pDeletedGPOList,
                                                                                        pChangedGPOList, pHandle, pbAbort,
                                                                                        pStatusCallback,
                                                                                        (NULL == pWbemServices) ? FALSE : TRUE);

                // If ProcessGroupPolicy only completes partially with a partial error, rsop logging
                // should still occur.  TODO: keep track of the sections of policy that were
                // successfully applied, and only log those sections to RSoP.
                if (NULL != pWbemServices)
                {
                        dwRet = ERROR_SUCCESS;
                        TCHAR szCustomDir[MAX_PATH];
                        if (ERROR_SUCCESS == dwRet)
                        {
                                // get our user appdata path (i.e. C:\\Documents and Settins\\User\\Application Data\\Microsoft\\Internet Explorer
                                // BUGBUG: <oliverl> we are currently relying on the fact that g_GetUserToken is not
                                // initialized here because when we pass in the NULL it currently gets the local appdata
                                // path always due to per process shell folder cache.  This might change in the next
                                // rev though if extension order has changed.  We need to do this because of possible
                                // folder redirection of appdata to a UNC path which would bust us since we don't 
                                // impersonate user everywhere we reference appdata files

                                getLogFolder(szCustomDir, countof(szCustomDir), hToken);
                                if (TEXT('\0') == szCustomDir[0])
                                        dwRet = ERROR_OVERRIDE_NOCHANGES;
                        }

                        if (ERROR_SUCCESS == dwRet && *pbAbort)
                        {
                                Out(LI0(TEXT("Aborting further processing in ProcessGroupPolicyEx due to abort message.")));
                                dwRet =  ERROR_OVERRIDE_NOCHANGES; 
                        }

                        if (ERROR_SUCCESS == dwRet)
                        {
                                // set log to append, backup what's there
                                g_SetupLog(TRUE, szCustomDir, TRUE);
                                Out(LI0(TEXT("Processing Group Policy RSoP (logging mode) ...")));

                                // determine if we need to delete the brndlog.ini log file when we're done
                                PathCombine(szIni, szCustomDir, RSOPLOG_INI);
                                fDeleteIni = !PathFileExists(szIni);
                                if (!fDeleteIni && InsKeyExists(IS_SETTINGS, IK_APPEND, szIni))
                                {
                                        InsWriteBool(IS_SETTINGS, TEXT("Was") IK_APPEND,
                                                                                        InsGetBool(IS_SETTINGS, IK_APPEND, FALSE, szIni), szIni);
                                }
                                InsWriteBool(IS_SETTINGS, IK_APPEND, TRUE, szIni);
                        }

                        // RSoP logging enabled
                        if (ERROR_SUCCESS == dwRet)
                        {
                                // Create the RSoPUpdate class and start logging to WMI
                                CRSoPUpdate RSoPUpdate(pWbemServices, szCustomDir);
                                hr = RSoPUpdate.Log(dwFlags, hToken, hKeyRoot, pDeletedGPOList,
                                                                                        pChangedGPOList, pHandle);
                                if (FAILED(hr))
                                {
                                        //TODO: what do we return here?
                                }
                        }

                        Out(LI0(TEXT("Done logging group policy RSoP.")));
                }

                displayStatusMessage(pStatusCallback);
        }
        __except(TRUE)
        {
                        // might want to use except structures eventually to log out better info
#ifdef _DEBUG
                        // REVIEW: (andrewgu) this Out, along with LI0 should still be safe. no double GPF should
                        // happen.
                        Out(LI0(TEXT("!! Exception caught in ProcessGroupPolicyEx.")));  
                        MessageBeep(MB_ICONEXCLAMATION);
                        MessageBeep(MB_ICONEXCLAMATION);
                        MessageBeep(MB_ICONEXCLAMATION);
#endif
                        dwRet = ERROR_OVERRIDE_NOCHANGES;
        }

        g_SetupLog(FALSE);

        // restore what was backed up (if necessary)
        if (TEXT('\0') != szIni[0] && PathFileExists(szIni))
        {
                if (fDeleteIni)
                        DeleteFile(szIni);
                else
                {
                        if (!InsKeyExists(IS_SETTINGS, TEXT("Was") IK_APPEND, szIni))
                                InsDeleteKey(IS_SETTINGS, IK_APPEND, szIni);
                        else
                        {
                                InsWriteBool(IS_SETTINGS, IK_APPEND,
                                                                                InsGetBool(IS_SETTINGS, TEXT("Was") IK_APPEND, FALSE, szIni), szIni);
                                InsDeleteKey(IS_SETTINGS, TEXT("Was") IK_APPEND, szIni);
                        }
                }
        }

        *pRsopStatus = hr;
        return dwRet;
}

///////////////////////////////////////////////////////////////////////////////
// ProcessGroupPolicyEx
// Added 29 Aug 2000 for RSoP Enabling, planning mode - see RSoP.h & .cpp.
///////////////////////////////////////////////////////////////////////////////
DWORD WINAPI GenerateGroupPolicy(DWORD dwFlags, BOOL *pbAbort, WCHAR *wszSite,
                                                                 PRSOP_TARGET pComputerTarget,
                                                                 PRSOP_TARGET pUserTarget)
{
        DWORD dwRet = ERROR_SUCCESS;

        TCHAR szIni[MAX_PATH];
        szIni[0] = TEXT('\0');
        BOOL fDeleteIni = TRUE;
        __try
        {
                MACRO_LI_PrologEx_C(PIF_STD_C, GenerateGroupPolicy)

                if (NULL != pUserTarget && NULL != pUserTarget->pWbemServices)
                {
                        TCHAR szCustomDir[MAX_PATH];
                        if (ERROR_SUCCESS == dwRet)
                        {
                                // get our user appdata path (i.e. C:\\Documents and Settins\\User\\Application Data\\Microsoft\\Internet Explorer
                                // BUGBUG: <oliverl> we are currently relying on the fact that g_GetUserToken is not
                                // initialized here because when we pass in the NULL it currently gets the local appdata
                                // path always due to per process shell folder cache.  This might change in the next
                                // rev though if extension order has changed.  We need to do this because of possible
                                // folder redirection of appdata to a UNC path which would bust us since we don't 
                                // impersonate user everywhere we reference appdata files

                                // TODO: no hToken passed in, can we use NULL instead?
                                getLogFolder(szCustomDir, countof(szCustomDir), NULL);
                                if (TEXT('\0') == szCustomDir[0])
                                        dwRet = ERROR_OVERRIDE_NOCHANGES;
                        }

                        if (ERROR_SUCCESS == dwRet && *pbAbort)
                        {
                                Out(LI0(TEXT("Aborting further processing in GenerateGroupPolicy due to abort message.")));
                                dwRet =  ERROR_OVERRIDE_NOCHANGES; 
                        }

                        if (ERROR_SUCCESS == dwRet)
                        {
                                // set log to append, backup what's there
                                g_SetupLog(TRUE, szCustomDir, TRUE);
                                Out(LI0(TEXT("Generating Group Policy RSoP (planning) ...")));
                                PathCombine(szIni, szCustomDir, RSOPLOG_INI);

                                // determine if we need to delete the brndlog.ini log file when we're done
                                fDeleteIni = !PathFileExists(szIni);
                                if (!fDeleteIni && InsKeyExists(IS_SETTINGS, IK_APPEND, szIni))
                                {
                                        InsWriteBool(IS_SETTINGS, TEXT("Was") IK_APPEND,
                                                                                        InsGetBool(IS_SETTINGS, IK_APPEND, FALSE, szIni), szIni);
                                }
                                InsWriteBool(IS_SETTINGS, IK_APPEND, TRUE, szIni);

                        }

                        // Create the RSoPUpdate class and start writing planning data to WMI
                        if (ERROR_SUCCESS == dwRet)
                        {
                                CRSoPUpdate RSoPUpdate(pUserTarget->pWbemServices, szCustomDir);
                                HRESULT hr = RSoPUpdate.Plan(dwFlags, wszSite, pComputerTarget,
                                                                                        pUserTarget);
                                if (FAILED(hr))
                                {
                                        //TODO: what do we return here?
                                }
                        }

                        if (ERROR_SUCCESS != dwRet)
                        {
                                Out(LI0(TEXT("Done writing planning information for group policy RSoP.")));
                        }
                }
        }
        __except(TRUE)
        {
                        // might want to use except structures eventually to log out better info
#ifdef _DEBUG
                        // REVIEW: (andrewgu) this Out, along with LI0 should still be safe. no double GPF should
                        // happen.
                        Out(LI0(TEXT("!! Exception caught in GenerateGroupPolicy.")));  
                        MessageBeep(MB_ICONEXCLAMATION);
                        MessageBeep(MB_ICONEXCLAMATION);
                        MessageBeep(MB_ICONEXCLAMATION);
#endif
                        dwRet = ERROR_OVERRIDE_NOCHANGES;
        }

        g_SetupLog(FALSE);

        // restore what was backed up (if necessary)
        if (TEXT('\0') != szIni[0] && PathFileExists(szIni))
        {
                if (fDeleteIni)
                        DeleteFile(szIni);
                else
                {
                        if (!InsKeyExists(IS_SETTINGS, TEXT("Was") IK_APPEND, szIni))
                                InsDeleteKey(IS_SETTINGS, IK_APPEND, szIni);
                        else
                        {
                                InsWriteBool(IS_SETTINGS, IK_APPEND,
                                                                                InsGetBool(IS_SETTINGS, TEXT("Was") IK_APPEND, FALSE, szIni), szIni);
                                InsDeleteKey(IS_SETTINGS, TEXT("Was") IK_APPEND, szIni);
                        }
                }
        }

        return dwRet;
}


// used for branding external features which have no concept of true HKCU in GP

void CALLBACK BrandExternal(HWND, HINSTANCE, LPCSTR pszCmdLineA, int)
{   MACRO_LI_PrologEx_C(PIF_STD_C, BrandExternal)

    LPTSTR pszComma, pszNum, pszEnd, pszPath;
    TCHAR szCmdLine[MAX_PATH];
    TCHAR szInsFile[MAX_PATH];

    USES_CONVERSION;

    if ((pszCmdLineA == NULL) || ISNULL(pszCmdLineA))
        return;

    A2Tbuf(pszCmdLineA, szCmdLine, countof(szCmdLine));

    pszPath = StrChr(szCmdLine, TEXT('<'));

    if (pszPath != NULL) 
    {
        BOOL fSkipRefresh,
             fResetZones;
        
        *pszPath = TEXT('\0');
        pszPath++;
        StrCpy(szInsFile, pszPath);
        PathAppend(szInsFile, TEXT("Custom"));
        pszEnd = szInsFile + StrLen(szInsFile);

        pszComma = szCmdLine;
        
        fResetZones = (*pszComma++ == TEXT('z'));
        
        fSkipRefresh = FALSE;
        if (*pszComma == TEXT('*'))
        {
            pszComma++;
            fSkipRefresh = TRUE;
        }
        
        do
        {
            TCHAR szFile[32];
            TCHAR szInsGuid[128];
            TCHAR szGPOGuid[128];
            CHAR szCurrentCmdLineA[MAX_PATH*2];
            
            pszNum = pszComma;
            pszComma = StrChr(pszNum, TEXT(','));
            
            if (pszComma != NULL)
                *pszComma++ = TEXT('\0');
            
            ASSERT(fResetZones || ISNONNULL(pszNum));
            
            // if only fResetZones is TRUE, we still have to pass an INS to BrandInternetExplorer.
            // any valid INS can be passed -- pick the one in Custom0 folder because it's guaranteed
            // to be there
            wnsprintf(szFile, countof(szFile), TEXT("%s\\install.ins"), ISNONNULL(pszNum) ? pszNum : TEXT("0"));
            StrCpy(pszEnd, szFile);
            wsprintfA(szCurrentCmdLineA, "/mode:gp /ins:\"%s\" /disable /flags:", T2CA(szInsFile));
            
            // BUGBUG: (andrewgu) we should clean this up!
            if (ISNONNULL(pszNum))
                StrCatA(szCurrentCmdLineA, "eriu=0,favo=0,qlo=0,chl=0,chlb=0");
            
            if (fResetZones)
            {
                if (ISNONNULL(pszNum))
                    StrCatA(szCurrentCmdLineA, ",");
                StrCatA(szCurrentCmdLineA, "znu=0");
            }
            
            if (fSkipRefresh)
                StrCatA(szCurrentCmdLineA, ",ref=1");
            
            InsGetString(IS_BRANDING, IK_GPO_GUID, szGPOGuid, countof(szGPOGuid), szInsFile);
            g_SetGPOGuid(szGPOGuid);
            
            if (!IsIE5Ins(T2CA(szInsFile),TRUE))
                continue;

            BrandInternetExplorer(NULL, NULL, szCurrentCmdLineA, 0);
            
            // set the external key for success for this ins if it's a preference GPO
            if (InsGetString(IS_BRANDING, IK_GPE_ONETIME_GUID, szInsGuid, countof(szInsGuid), g_GetIns()))
            {
                TCHAR szKey[MAX_PATH];
                HKEY  hkExternal = NULL;
                
                PathCombine(szKey, RK_IEAK_GPOS, szGPOGuid);
                PathAppend(szKey, szInsGuid);
                PathAppend(szKey, RK_IEAK_EXTERNAL);
                SHCreateKey(g_GetHKCU(), szKey, KEY_DEFAULT_ACCESS, &hkExternal);
                SHCloseKey(hkExternal);
            }
            
            if (fResetZones)
                fResetZones = FALSE;
        } while (pszComma != NULL);
    }
}



static void brandExternalHKCUStuff(LPCTSTR pcszCmdLine)
{
    typedef HANDLE (WINAPI *CREATEJOBOBJECT)(LPSECURITY_ATTRIBUTES, LPCTSTR);
    typedef BOOL (WINAPI *ASSIGNPROCESSTOJOBOBJECT)(HANDLE, HANDLE);
    typedef BOOL (WINAPI *TERMINATEJOBOBJECT)(HANDLE, UINT);
    typedef BOOL (WINAPI *CREATEPROCESSASUSERA)(HANDLE, LPCSTR, LPSTR, LPSECURITY_ATTRIBUTES,
        LPSECURITY_ATTRIBUTES, BOOL, DWORD, LPVOID, LPCSTR, LPSTARTUPINFOA, LPPROCESS_INFORMATION);

    HINSTANCE hKernel32 = NULL;
    HINSTANCE hAdvapi32 = NULL;
    CREATEJOBOBJECT lpfnCreateJobObject = NULL;
    ASSIGNPROCESSTOJOBOBJECT lpfnAssignProcessToJobObject = NULL;
    TERMINATEJOBOBJECT lpfnTerminateJobObject = NULL;
    CREATEPROCESSASUSERA lpfnCreateProcessAsUserA = NULL;

    CHAR  szCmdA[MAX_PATH * 2];
    LPVOID lpEnvironment = NULL;
    HANDLE hJob;
    STARTUPINFOA siA;
    PROCESS_INFORMATION pi;

    USES_CONVERSION;    


    // get all the function ptrs we need

    hKernel32 = LoadLibrary(TEXT("kernel32.dll"));
    hAdvapi32 = LoadLibrary(TEXT("advapi32.dll"));

    if ((hKernel32 == NULL) || (hAdvapi32 == NULL))
        goto exit;

    lpfnCreateJobObject = (CREATEJOBOBJECT)GetProcAddress(hKernel32, "CreateJobObjectW");
    lpfnAssignProcessToJobObject = (ASSIGNPROCESSTOJOBOBJECT)GetProcAddress(hKernel32, "AssignProcessToJobObject");
    lpfnTerminateJobObject = (TERMINATEJOBOBJECT)GetProcAddress(hKernel32, "TerminateJobObject");
    
    lpfnCreateProcessAsUserA = (CREATEPROCESSASUSERA)GetProcAddress(hAdvapi32, "CreateProcessAsUserA");

    if ((lpfnCreateJobObject == NULL) || (lpfnAssignProcessToJobObject == NULL) ||
        (lpfnTerminateJobObject == NULL) || (lpfnCreateProcessAsUserA == NULL))
        goto exit;

    // create a job object

    if ((hJob = lpfnCreateJobObject(NULL, TEXT("IEAKJOB"))) != NULL)
    {
        ASSERT(GetLastError() != ERROR_ALREADY_EXISTS);

        // get user environment state

        if (!CreateEnvironmentBlock(&lpEnvironment, g_GetUserToken(), FALSE))
        {
            OutD(LI0(TEXT("! Failed to get user environment. Some of the settings may not get applied.")));
            lpEnvironment = NULL;
        }

        // initialize process startup info

        ZeroMemory (&siA, sizeof(siA));
        siA.cb = sizeof(STARTUPINFOA);
        siA.wShowWindow = SW_SHOWMINIMIZED;
        siA.lpDesktop = "";

        // create the process suspended in the context of the current user

        wsprintfA(szCmdA, "rundll32 iedkcs32.dll,BrandExternal %s", T2CA(pcszCmdLine));

        if (!lpfnCreateProcessAsUserA(g_GetUserToken(), NULL, szCmdA, NULL, NULL, FALSE, 
                CREATE_SUSPENDED | CREATE_UNICODE_ENVIRONMENT, lpEnvironment, NULL, &siA, &pi))
            OutD(LI0(TEXT("! Failed to create user process for externals. Some of the settings may not get applied.")));

        else
        {

            // associate the process with the job so it gets cleaned up nicely
            if (!lpfnAssignProcessToJobObject(hJob, pi.hProcess))
            {
                OutD(LI0(TEXT("! Failed to associate user process to job. Some of the settings may not get applied.")));
                TerminateProcess(pi.hProcess, ERROR_ACCESS_DENIED);
            }
            else
            {
                DWORD dwRes = 0;

                USES_CONVERSION;

                // start the process and wait on it (give a timeout of 2 min. so the user will
                // be logged on eventually if we hang for some reason)
                OutD(LI1(TEXT("Branding externals with command line \"%s\"."), A2CT(szCmdA)));
                ResumeThread(pi.hThread);

                while (1)
                {
                    MSG msg;

                    dwRes = MsgWaitForMultipleObjects(1, &pi.hProcess, FALSE, 120000, QS_ALLINPUT);

                    if ((dwRes == WAIT_OBJECT_0) || (dwRes == WAIT_TIMEOUT))
                        break;

                    while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) 
                    {
                        TranslateMessage(&msg);
                        DispatchMessage(&msg);
                    }
                }

                if (dwRes == WAIT_TIMEOUT)
                {
                    lpfnTerminateJobObject(hJob, STATUS_TIMEOUT);
                    OutD(LI0(TEXT("! External process timed out.")));
                }
            }

            CloseHandle(pi.hThread);
            CloseHandle(pi.hProcess);
        }

        if (lpEnvironment != NULL)
            DestroyEnvironmentBlock(lpEnvironment);

        CloseHandle(hJob);
    }

exit:
    if (hKernel32 != NULL)
        FreeLibrary(hKernel32);

    if (hAdvapi32 != NULL)
        FreeLibrary(hAdvapi32);
}

static BOOL constructCmdLine(LPTSTR pszCmdLine, DWORD cchLen, LPCTSTR pcszInsFile, BOOL fExternal)
{
    BOOL fRun = FALSE;

    // index into global features array of external features which require a separate
    // process(for HKCU)

    static DWORD s_adwExternalFeatures[] = {
        FID_EXTREGINF_HKCU,
        FID_FAV_ORDER,
        FID_QL_ORDER,
        FID_LCY4X_CHANNELS,
        FID_LCY4X_CHANNELBAR
    };

    USES_CONVERSION;

    if (!fExternal)
        wnsprintf(pszCmdLine, cchLen, TEXT("BrandInternetExplorer /mode:gp /ins:\"%s\" /flags:"),
            pcszInsFile);

    for (int i = 0; i < countof(s_adwExternalFeatures); i++)
    {
        PCFEATUREINFO pfi;

        pfi = g_GetFeature(s_adwExternalFeatures[i]);

        if (!fExternal)
        {
            TCHAR szBuf[16];

            fRun = TRUE;
            
            wnsprintf(szBuf, countof(szBuf), TEXT("%s=%d,"), g_mpFeatures[s_adwExternalFeatures[i]].psz, FF_DISABLE);
            StrCat(pszCmdLine, szBuf);
        }
        else if (pfi->pfnApply)
        {
            if (pfi->pfnApply())
                fRun = TRUE;
        }
    }

    if (!fExternal)
        pszCmdLine[StrLen(pszCmdLine)-1] = TEXT('\0');

    return fRun;
}

static void displayStatusMessage(PFNSTATUSMESSAGECALLBACK pfnStatusCallback)
{
    TCHAR   szMessage [MAX_PATH];

    if (pfnStatusCallback == NULL)
        return;

    LoadString(g_GetHinst(), IDS_STATUSMSG, szMessage, countof(szMessage));
    pfnStatusCallback(TRUE, szMessage);
}

static HRESULT pepCopyFilesEnumProc(LPCTSTR pszPath, PWIN32_FIND_DATA pfd, LPARAM lParam, PDWORD *prgdwControl /*= NULL */)
{
    UNREFERENCED_PARAMETER(prgdwControl);
    UNREFERENCED_PARAMETER(pfd);

    // BUGBUG: <oliverl> we should reevaluate this function and make sure we're stopping the
    //         recursion as soon as we fail.  Not doing right now because of code churn

    if (!CopyFileToDirEx(pszPath, (LPCTSTR)lParam))
        return E_FAIL;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\brandll\globals.cpp ===
#include "precomp.h"
#include "globalsw.h"
#include "clear.h"
#include "apply.h"
#include "advpub.h"

#define TYPE_ICP  0
#define TYPE_ISP  1
#define TYPE_CORP 2
#define TYPE_ALL (TYPE_ICP | TYPE_ISP | TYPE_CORP)


// NOTE: (pritobla) g_hBaseDllHandle is used by DelayLoadFailureHook() -- defined in ieakutil.lib
// for more info, read the NOTES in ieak5\ieakutil\dload.cpp
TCHAR     g_szModule[]       = TEXT("iedkcs32.dll");
HINSTANCE g_hInst            = NULL;
HANDLE    g_hBaseDllHandle   = NULL;

TCHAR     g_szIns       [MAX_PATH];
TCHAR     g_szTargetPath[MAX_PATH];
DWORD     g_dwContext        = CTX_UNINITIALIZED;

HANDLE    g_hfileLog         = NULL;
BOOL      g_fFlushEveryWrite = FALSE;

TCHAR     g_szGPOGuid   [MAX_PATH];
HANDLE    g_hUserToken       = NULL;
DWORD     g_dwGPOFlags       = 0;

static FEATUREINFO s_rgfiList[FID_LAST] = {
    //----- Clear previous branding, Prepare to brand features -----
    {
        FID_CLEARBRANDING,
        TEXT("About to clear previous branding..."),
        NULL,                                   // no clear function
        ApplyClearBranding,
        ProcessClearBranding,
        NULL,                                   // no .ins key
        FF_ENABLE
    },
    {
        FID_MIGRATEOLDSETTINGS,
        TEXT("Processing migration of old settings..."),
        NULL,                                   // no clear function
        ApplyMigrateOldSettings,
        ProcessMigrateOldSettings,
        NULL,                                   // no .ins key
        FF_ENABLE
    },
    {
        FID_WININETSETUP,
        TEXT("Processing wininet setup..."),
        NULL,                                   // no clear function
        ApplyWininetSetup,
        ProcessWininetSetup,
        NULL,                                   // no .ins key
        FF_ENABLE
    },
    {
        FID_CS_DELETE,
        TEXT("Processing deletion of connection settings..."),
        NULL,                                   // no clear function
        ApplyConnectionSettingsDeletion,
        ProcessConnectionSettingsDeletion,
        NULL,                                   // no .ins key
        FF_ENABLE
    },
    {
        FID_ZONES_HKCU,
        TEXT("Processing zones HKCU settings..."),
        NULL,                                   // no clear function
        ApplyZonesReset,
        ProcessZonesReset,
        NULL,                                   // no .ins key
        FF_DISABLE                              // disabled by default
    },
    {
        FID_ZONES_HKLM,
        NULL,
        ClearZonesHklm,                         // clear HKLM zones setting
        NULL,                                   // no apply function
        NULL,                                   // no process function
        NULL,                                   // no .ins key
        FF_DISABLE                              // disabled by default
    },
    {
        FID_RATINGS,
        TEXT("Processing ratings settings..."),
        ClearRatings,
        NULL,                                   // no apply function
        NULL,                                   // no process function
        NULL,                                   // no .ins key
        FF_DISABLE                              // disabled by default
    },
    {
        FID_AUTHCODE,
        TEXT("Processing authenticode settings..."),
        ClearAuthenticode,
        NULL,                                   // no apply function
        NULL,                                   // no process function
        NULL,                                   // no .ins key
        FF_DISABLE                              // disabled by default
    },
    {
        FID_PROGRAMS,
        NULL,
        NULL,                                   // no clear function
        NULL,                                   // no apply function
        NULL,                                   // no process function
        NULL,                                   // no .ins key
        FF_DISABLE                              // disabled by default
    },

    //----- Main features branding -----
    {
        FID_EXTREGINF_HKLM,
        TEXT("Processing local machine policies and restrictions..."),
        NULL,                                   // no clear function
        ApplyExtRegInfHKLM,
        ProcessExtRegInfSectionHKLM,
        IK_FF_EXTREGINF,
        FF_ENABLE
    },
    {
        FID_EXTREGINF_HKCU,
        TEXT("Processing current user policies and restrictions..."),
        NULL,                                   // no clear function
        ApplyExtRegInfHKCU,
        ProcessExtRegInfSectionHKCU,
        IK_FF_EXTREGINF,
        FF_ENABLE
    },
    {
        FID_LCY50_EXTREGINF,
        TEXT("Processing legacy policies and restrictions..."),
        NULL,                                   // no clear function
        lcy50_ApplyExtRegInf,
        lcy50_ProcessExtRegInfSection,
        IK_FF_EXTREGINF,
        FF_ENABLE
    },
    {
        FID_GENERAL,
        TEXT("Processing general customizations..."),
        ClearGeneral,
        NULL,                                   // no apply function
        ProcessGeneral,
        IK_FF_GENERAL,
        FF_ENABLE
    },
    {
        FID_CUSTOMHELPVER,
        TEXT("Processing Help->About customization..."),
        NULL,                                   // no clear function
        ApplyCustomHelpVersion,
        ProcessCustomHelpVersion,
        NULL,                                   // no .ins key
        FF_ENABLE
    },
    {
        FID_TOOLBARBUTTONS,
        TEXT("Processing browser toolbar buttons..."),
        ClearToolbarButtons,
        ApplyToolbarButtons,
        ProcessToolbarButtons,
        IK_FF_TOOLBARBUTTONS,
        FF_ENABLE
    },
    {
        FID_ROOTCERT,
        TEXT("Processing root certificates..."),
        NULL,                                   // no clear function
        ApplyRootCert,
        ProcessRootCert,
        IK_FF_ROOTCERT,
        FF_ENABLE
    },

    //----- Favorites, Quick Links, and Connection Settings -----
    {
        FID_FAV_DELETE,
        TEXT("Processing deletion of favorites and/or quick links..."),
        NULL,                                   // no clear function
        ApplyFavoritesDeletion,
        ProcessFavoritesDeletion,
        NULL,                                   // no .ins key
        FF_ENABLE
    },
    {
        FID_FAV_MAIN,
        TEXT("Processing favorites..."),
        ClearFavorites,
        ApplyFavorites,
        ProcessFavorites,
        NULL,                                   // no .ins key
        FF_ENABLE
    },
    {
        FID_FAV_ORDER,
        TEXT("Processing ordering of favorites..."),
        NULL,                                   // no clear function
        ApplyFavoritesOrdering,
        ProcessFavoritesOrdering,
        NULL,                                   // no .ins key
        FF_ENABLE
    },
    {
        FID_QL_MAIN,
        TEXT("Processing quick links..."),
        NULL,                                   // no clear function
        ApplyQuickLinks,
        ProcessQuickLinks,
        NULL,                                   // no .ins key
        FF_ENABLE
    },
    {
        FID_QL_ORDER,
        TEXT("Processing ordering of quick links..."),
        NULL,                                   // no clear function
        ApplyQuickLinksOrdering,
        ProcessQuickLinksOrdering,
        NULL,                                   // no .ins key
        FF_ENABLE
    },
    {
        FID_CS_MAIN,
        TEXT("Processing connection settings..."),
        ClearConnectionSettings,
        ApplyConnectionSettings,
        ProcessConnectionSettings,
        NULL,                                   // no .ins key
        FF_ENABLE
    },

    //----- Miscellaneous -----
    {
        FID_TPL,
        TEXT("Processing TrustedPublisherLockdown restriction..."),
        NULL,                                   // no clear function
        ApplyTrustedPublisherLockdown,
        ProcessTrustedPublisherLockdown,
        IK_FF_TPL,
        FF_ENABLE
    },
    {
        FID_CD_WELCOME,
        NULL,
        NULL,                                   // no clear function
        NULL,                                   // no apply function
        ProcessCDWelcome,
        IK_FF_CD_WELCOME,
        FF_ENABLE
    },
    {
        FID_ACTIVESETUPSITES,
        TEXT("Registering download URLs as safe for updating IE..."),
        NULL,                                   // no clear function
        NULL,                                   // no apply function
        ProcessActiveSetupSites,
        NULL,                                   // no .ins key
        FF_ENABLE
    },
    {
        FID_LINKS_DELETE,
        TEXT("Deleting links..."),
        NULL,                                   // no clear function
        ApplyLinksDeletion,
        ProcessLinksDeletion,
        NULL,
        FF_ENABLE
    },

    //----- External components (Outlook Express et al.) -----
    {
        FID_OUTLOOKEXPRESS,
        TEXT("Branding Outlook Express..."),
        NULL,                                   // no clear function
        NULL,                                   // no apply function
        ProcessOutlookExpress,
        IK_FF_OUTLOOKEXPRESS,
        FF_ENABLE
    },
    
    //----- Legacy support -----
    {
        FID_LCY4X_ACTIVEDESKTOP,
        TEXT("Processing active desktop customizations..."),
        NULL,                                   // no clear function
        lcy4x_ApplyActiveDesktop,
        lcy4x_ProcessActiveDesktop,
        NULL,                                   // no .ins key
        FF_ENABLE
    },
    {
        FID_LCY4X_CHANNELS,
        TEXT("Processing channels and their categories (if any)..."),
        ClearChannels,
        lcy4x_ApplyChannels,
        lcy4x_ProcessChannels,
        IK_FF_CHANNELS,
        FF_ENABLE
    },
    {
        FID_LCY4X_SOFTWAREUPDATES,
        TEXT("Processing software update channels..."),
        NULL,                                   // no clear function
        NULL,                                   // no apply function
        lcy4x_ProcessSoftwareUpdateChannels,
        IK_FF_SOFTWAREUPDATES,
        FF_ENABLE
    },
    {
        FID_LCY4X_WEBCHECK,
        TEXT("Actual processing of channels by calling webcheck.dll \"DllInstall\" API..."),
        NULL,                                   // no clear function
        lcy4x_ApplyWebcheck,
        lcy4x_ProcessWebcheck,
        NULL,                                   // no .ins key
        FF_ENABLE
    },
    {
        FID_LCY4X_CHANNELBAR,
        TEXT("Showing channel bar on the desktop..."),
        NULL,                                   // no clear function
        lcy4x_ApplyChannelBar,
        lcy4x_ProcessChannelBar,
        IK_FF_CHANNELBAR,
        FF_ENABLE
    },
    {
        FID_LCY4X_SUBSCRIPTIONS,
        TEXT("Processing subscriptions..."),
        NULL,                                   // no clear function
        lcy4x_ApplySubscriptions,
        lcy4x_ProcessSubscriptions,
        IK_FF_SUBSCRIPTIONS,
        FF_ENABLE
    },

    //----- Commit new settings -----
    {
        FID_REFRESHBROWSER,
        TEXT("Refreshing browser settings..."),
        NULL,                                   // no clear function
        ApplyBrowserRefresh,
        ProcessBrowserRefresh,
        NULL,                                   // no .ins key
        FF_ENABLE
    }
};

DWORD ctxInitFromIns(PCTSTR pszIns);

DWORD ctxGetFolderFromTargetPath(PCTSTR pszTargetPath, DWORD dwContext = CTX_UNINITIALIZED, PCTSTR pszIns = NULL);
DWORD ctxGetFolderFromEntryPoint(DWORD dwContext, PCTSTR pszIns);
DWORD ctxGetFolderFromIns       (DWORD dwContext = CTX_UNINITIALIZED, PCTSTR pszIns = NULL);
BOOL  IsDirWritable( LPCTSTR );


HRESULT g_SetGlobals(PCTSTR pszCmdLine)
{
    CMDLINESWITCHES cls;
    HRESULT hr;

    hr = GetCmdLineSwitches(pszCmdLine, &cls);
    if (FAILED(hr))
        return hr;

    return g_SetGlobals(&cls);
}

HRESULT g_SetGlobals(PCMDLINESWITCHES pcls)
{
    CMDLINESWITCHES cls;
    PCTSTR  pszIE;
    HRESULT hr;
    DWORD   dwAux;
    UINT    i;
    BOOL    fSetIns,
            fSetTargetPath;

    if (pcls == NULL)
        return E_INVALIDARG;
    CopyMemory(&cls, pcls, sizeof(cls));

    pszIE          = GetIEPath();
    hr             = S_OK;
    fSetIns        = FALSE;
    fSetTargetPath = FALSE;

    //----- Validate .ins and targer folder path -----
    // NOTE: (andrewgu) past this section if these two strings are not empty they are valid. also,
    // .ins file is validated to exist, while target folder path doesn't have to exist to be valid.
    
    // BUGBUG: <oliverl> this is a really ugly hack to fix bug 84062 in IE5 database.  
    // Basically what we're doing here is figuring out if this is the external process
    // with only zones reset which doesn't require an ins file.  
    
    if (!HasFlag(pcls->dwContext, CTX_GP) ||
        (g_GetUserToken() != NULL) ||
        (pcls->rgdwFlags[FID_ZONES_HKCU] == 0xFFFFFFFF) ||
        HasFlag(pcls->rgdwFlags[FID_ZONES_HKCU], FF_DISABLE))
    {
        if (TEXT('\0') != cls.szIns[0] && !PathIsValidPath(cls.szIns, PIVP_FILE_ONLY)) {
            hr = E_INVALIDARG;
            goto Fail;
        }
    }
    
    if (TEXT('\0') != cls.szTargetPath[0] && !PathIsValidPath(cls.szTargetPath)) {
        hr = E_INVALIDARG;
        goto Fail;
    }

    //----- Context -----
    // RULE 1: (andrewgu) if context is uninitialized or is one of the values that can be
    // specified through the .ins file, go to the .ins file and figure out the final context
    // value. this means that whatever is in the .ins file can and will overwrite what's specified
    // in the command line.
    if (CTX_UNINITIALIZED == cls.dwContext ||
        HasFlag(cls.dwContext, (CTX_GENERIC | CTX_CORP | CTX_ISP | CTX_ICP))) {

        // RULE 2: (andrewgu) if .ins file is not specified try to assume smart defaults, which
        // is, first if target folder path is specified generate the .ins file by appending
        // install.ins to it. if target folder path is not specified, assume that it's
        // either <ie folder>\signup or <ie folder>\custom (based on whether or not CTX_CORP is
        // set) and proceed with the same algorithm to create the .ins file.
        dwAux = 0;
        if (TEXT('\0') == cls.szIns[0]) {
            if (TEXT('\0') == cls.szTargetPath[0]) {
                if (CTX_UNINITIALIZED == cls.dwContext || HasFlag(cls.dwContext, CTX_GENERIC)) {
                    hr = E_FAIL;
                    goto Fail;
                }

                if (NULL == pszIE) {
                    hr = E_UNEXPECTED;
                    goto Fail;
                }

                PathCombine(cls.szTargetPath, pszIE,
                    !HasFlag(cls.dwContext, CTX_CORP) ? FOLDER_SIGNUP : FOLDER_CUSTOM);

                if (!PathIsValidPath(cls.szTargetPath, PIVP_FOLDER_ONLY)) {
                    hr = STG_E_PATHNOTFOUND;
                    goto Fail;
                }
                fSetTargetPath = TRUE;

                SetFlag(&dwAux,
                    !HasFlag(cls.dwContext, CTX_CORP) ? CTX_FOLDER_SIGNUP : CTX_FOLDER_CUSTOM);
            }

            PathCombine(cls.szIns, cls.szTargetPath, INSTALL_INS);
            if (!PathIsValidPath(cls.szIns, PIVP_FILE_ONLY)) {
                hr = STG_E_FILENOTFOUND;
                goto Fail;                      // no .ins file
            }

            fSetIns = TRUE;
            SetFlag(&dwAux, CTX_FOLDER_INSFOLDER);
        }

        // read in entrypoint (and signup mode, if applicable)
        if (InsKeyExists(IS_BRANDING, IK_TYPE, cls.szIns)) {
            cls.dwContext = ctxInitFromIns(cls.szIns);
            SetFlag(&cls.dwContext, dwAux);
            hr = S_FALSE;
        }
    }

    // RULE 3: (andrewgu) there is actually a whole bunch of rules on how entry point info in the
    // context, .ins file and target folder relate to each other. especially, in cases when only
    // one of .ins file and target folder path is provided. this logic is encupsulated in the
    // helper apis which are pretty self-explanatory. another point is that this relationship is
    // conveyed via CTX_FOLDER_XXX flags in the context.
    if (!fSetTargetPath) {
        if (TEXT('\0') != cls.szTargetPath[0]) {
            dwAux = ctxGetFolderFromTargetPath(cls.szTargetPath, cls.dwContext, cls.szIns);
            if (CTX_UNINITIALIZED == dwAux)
                goto Fail;                      // internal failure
            SetFlag(&cls.dwContext, dwAux);
        }
        else {
            dwAux = ctxGetFolderFromEntryPoint(cls.dwContext, cls.szIns);
            if (CTX_UNINITIALIZED == dwAux)
                goto Fail;                      // not enough info
            SetFlag(&cls.dwContext, dwAux);

            dwAux = ctxGetFolderFromIns(cls.dwContext, cls.szIns);
            if (CTX_UNINITIALIZED != dwAux)
                SetFlag(&cls.dwContext, dwAux);
        }
    }
    else { /* fSetTargetPath */
        ASSERT(TEXT('\0') != cls.szTargetPath[0]);
        ASSERT(HasFlag(cls.dwContext, CTX_FOLDER_INSFOLDER));

        if (HasFlag(cls.dwContext, CTX_CORP)) {
            if (HasFlag(cls.dwContext, CTX_FOLDER_SIGNUP)) {
                hr = E_UNEXPECTED;
                goto Fail;                      // bad combination
            }

            ASSERT(HasFlag(cls.dwContext, CTX_FOLDER_CUSTOM));
        }
        else if (HasFlag(cls.dwContext, (CTX_ISP | CTX_ICP))) {
            if (HasFlag(cls.dwContext, CTX_FOLDER_CUSTOM)) {
                hr = E_UNEXPECTED;
                goto Fail;                      // bad combination
            }

            ASSERT(HasFlag(cls.dwContext, CTX_FOLDER_SIGNUP));
        }
    }

    //----- PerUser flag -----
    if (cls.fPerUser)
        cls.dwContext |= CTX_MISC_PERUSERSTUB;

    //----- .ins file -----
    // RULE 4: (andrewgu) after all context initialization is complete and if .ins file is still
    // empty, this is how it's is finally initialized. note, that target folder path may or may
    // not be used in the process.
    if (TEXT('\0') == cls.szIns[0]) {
        ASSERT(!fSetTargetPath && !fSetIns);
        ASSERT(!HasFlag(cls.dwContext, CTX_FOLDER_INDEPENDENT));

        if (TEXT('\0') != cls.szTargetPath[0]) {
            ASSERT(HasFlag(cls.dwContext, CTX_FOLDER_INSFOLDER));
            PathCombine(cls.szIns, cls.szTargetPath, INSTALL_INS);
        }
        else {
            ASSERT(HasFlag(cls.dwContext, (CTX_FOLDER_CUSTOM | CTX_FOLDER_SIGNUP)));

            if (NULL == pszIE)
                goto Fail;                      // can't set .ins file

            PathCombine(cls.szIns, pszIE,
                HasFlag(cls.dwContext, CTX_FOLDER_CUSTOM) ? FOLDER_CUSTOM : FOLDER_SIGNUP);
            PathAppend (cls.szIns, INSTALL_INS);
        }

        hr = S_FALSE;
    }

    //----- Target folder path -----
    // RULE 5: (andrewgu) after all context initialization is complete and if target folder path
    // is still empty, this is how it's is finally initialized. note, that .ins file may or may
    // not be used in the process.
    if (TEXT('\0') == cls.szTargetPath[0]) {
        ASSERT(!fSetTargetPath && !fSetIns);
        ASSERT(!HasFlag(cls.dwContext, CTX_FOLDER_INDEPENDENT));

        if (TEXT('\0') != cls.szIns[0] && HasFlag(cls.dwContext, CTX_FOLDER_INSFOLDER)) {
            StrCpy(cls.szTargetPath, cls.szIns);
            PathRemoveFileSpec(cls.szTargetPath);
        }
        else {
            ASSERT(HasFlag(cls.dwContext, (CTX_FOLDER_CUSTOM | CTX_FOLDER_SIGNUP)));

            if (NULL == pszIE)
                goto Fail;                      // can't set .ins file

            PathCombine(cls.szTargetPath, pszIE,
                HasFlag(cls.dwContext, CTX_FOLDER_CUSTOM) ? FOLDER_CUSTOM : FOLDER_SIGNUP);
        }

        hr = S_FALSE;
    }

    //----- Features flags -----
    for (i = 0; i < countof(cls.rgdwFlags); i++) {
        if (0xFFFFFFFF == cls.rgdwFlags[i])
            s_rgfiList[i].dwFlags = (cls.fDisable ? FF_DISABLE : FF_ENABLE);

        else
            s_rgfiList[i].dwFlags = cls.rgdwFlags[i];

        // REVIEW: (andrewgu) i can't estimate how much of a perf hit this is.
        if (FF_ENABLE == s_rgfiList[i].dwFlags && NULL != s_rgfiList[i].pszInsFlags)
            s_rgfiList[i].dwFlags = GetPrivateProfileInt(IS_FF, s_rgfiList[i].pszInsFlags, FF_ENABLE, cls.szIns);
    }

    //----- Tying-everything-together processing -----
    // NOTE: (andrewgu) technically, we can do away with this section and with the settings set
    // here as they all can be derived from some other information. it is still benificial to have
    // these as they increase readability and high-level understanding of the code.
    if (HasFlag(cls.dwContext, CTX_GP) && InsKeyExists(IS_BRANDING, IK_GPE_ONETIME_GUID, cls.szIns))
        SetFlag(&cls.dwContext, CTX_MISC_PREFERENCES);

    if (HasFlag(cls.dwContext, CTX_GP) && NULL == g_GetUserToken())
        SetFlag(&cls.dwContext, CTX_MISC_CHILDPROCESS);

    //----- Set globals -----
    g_dwContext = cls.dwContext;
    StrCpy(g_szIns,        cls.szIns);
    if(IsDirWritable(cls.szTargetPath))
        StrCpy(g_szTargetPath, cls.szTargetPath);
    else
    {
        StrCpy(g_szTargetPath, g_szIns);
        PathRemoveFileSpec(g_szTargetPath);
    }

    return hr;

Fail:
    if (SUCCEEDED(hr))
        hr = E_FAIL;

    g_dwContext       = CTX_UNINITIALIZED;
    g_szIns[0]        = TEXT('\0');
    g_szTargetPath[0] = TEXT('\0');

    for (i = 0; i < countof(s_rgfiList); i++)
        s_rgfiList[i].dwFlags = FF_DISABLE;

    return hr;
}


void g_SetHinst(HINSTANCE hInst)
{
    g_hInst = hInst;
}

BOOL g_SetHKCU()
{
    typedef LONG (APIENTRY* REGOPENCURRENTUSER)(REGSAM samDesired, PHKEY phkResult);

    REGOPENCURRENTUSER pfnRegOpenCurrentUser;
    HINSTANCE          hAdvapi32Dll;
    BOOL               fResult;

    if (!g_CtxIsGp())
        return FALSE;
    ASSERT(NULL != g_GetUserToken() && IsOS(OS_NT5));

    fResult = ImpersonateLoggedOnUser(g_GetUserToken());
    if (!fResult)
        return FALSE;

    hAdvapi32Dll = LoadLibrary(TEXT("advapi32.dll"));
    if (NULL != hAdvapi32Dll) {
        pfnRegOpenCurrentUser = (REGOPENCURRENTUSER)GetProcAddress(hAdvapi32Dll, "RegOpenCurrentUser");
        if (NULL != pfnRegOpenCurrentUser)
            pfnRegOpenCurrentUser(GENERIC_ALL, &g_hHKCU);

        FreeLibrary(hAdvapi32Dll);
    }

    RevertToSelf();
    return TRUE;
}

BOOL IsAdmin()
{
    BOOL fAdmin = FALSE;
    
    if (!g_CtxIsGp())
    {
        return IEHardened();
    }

    BOOL fResult = ImpersonateLoggedOnUser(g_GetUserToken());

    fAdmin = IsNTAdmin();

    if (fResult)
        RevertToSelf();

    return fAdmin;

}


#define SZ_ACTIVESETUPUSER L"SOFTWARE\\Microsoft\\Active Setup\\Installed Components\\{A509B1A8-37EF-4b3f-8CFC-4F3A74704073}"
#define SZ_ACTIVESETUPADMIN L"SOFTWARE\\Microsoft\\Active Setup\\Installed Components\\{A509B1A7-37EF-4b3f-8CFC-4F3A74704073}"
#define ACTIVESETUPKEY  L"Software\\Microsoft\\Active Setup\\Installed Components\\{89820200-ECBD-11cf-8B85-00AA005B4383}"

BOOL IsIEHardened()
{
    BOOL fRet = FALSE;
    HKEY hKey = 0;
    TCHAR szKey[MAX_PATH];

    if(IsAdmin())
    {
        lstrcpy(szKey, SZ_ACTIVESETUPADMIN);
    }
    else
    {
        lstrcpy(szKey, SZ_ACTIVESETUPUSER);
    }

    Out(LI1(TEXT("! Key is  \"%s\"."), szKey));

    if (RegOpenKeyExW(HKEY_LOCAL_MACHINE, szKey, 0, KEY_READ, &hKey) == ERROR_SUCCESS) 
    {
        DWORD dwValue = 0;
        DWORD dwSize = sizeof(dwValue);    
        if(ERROR_SUCCESS == RegQueryValueExW(hKey, L"IsInstalled", NULL, NULL, (LPBYTE)&dwValue, &dwSize))
        {
            fRet = (1 == dwValue);
        }

        RegCloseKey(hKey);
    }

    return fRet;
}

BOOL IsFirstTimeLogon()
{
    BOOL fRet = TRUE;
    HKEY hKey = NULL;
    HKEY hKeyLM = NULL;

    DWORD dwErr = RegOpenKeyExW(g_GetHKCU(), ACTIVESETUPKEY, 0, KEY_READ, &hKey);
    
    if(dwErr != ERROR_SUCCESS)
    {
        OutD(LI0(TEXT("No key exists for IE. First time login")));
        return fRet;
    }

    TCHAR szVersion[MAX_PATH];
    TCHAR szLMVersion[MAX_PATH];
    DWORD dwSize = MAX_PATH * sizeof(TCHAR);  

    if(ERROR_SUCCESS != RegQueryValueExW(hKey, L"Version", NULL, NULL, (LPBYTE)szVersion, &dwSize))
    {
        goto end;
    }

    if(ERROR_SUCCESS != RegOpenKeyExW(HKEY_LOCAL_MACHINE, ACTIVESETUPKEY, 0, KEY_READ, &hKeyLM))
    {
        goto end;
    }

    dwSize = MAX_PATH * sizeof(TCHAR);  
    if(ERROR_SUCCESS != RegQueryValueExW(hKeyLM, L"Version", NULL, NULL, (LPBYTE)szLMVersion, &dwSize))
    {
        goto end;
    }

    OutD(LI2(TEXT("!HKCU version  is  %s  HKLM version is %s"), szVersion, szLMVersion));

    fRet = (BOOL)StrCmpI(szLMVersion, szVersion);

end:
    if(hKey)
    {
        RegCloseKey(hKey);
    }

    if(hKeyLM)
    {
        RegCloseKey(hKeyLM);
    }

    return fRet;
}

void g_SetUserToken(HANDLE hUserToken)
{
    g_hUserToken = hUserToken;
}

void g_SetGPOFlags(DWORD dwFlags)
{
    g_dwGPOFlags = dwFlags;
}

void g_SetGPOGuid(LPCTSTR pcszGPOGuid)
{
    StrCpy(g_szGPOGuid, pcszGPOGuid);
}

HINSTANCE g_GetHinst()
{
    return g_hInst;
}

DWORD g_GetContext()
{
    return g_dwContext;
}

PCTSTR g_GetIns()
{
    return g_szIns;
}

PCTSTR g_GetTargetPath()
{
    return g_szTargetPath;
}

HKEY g_GetHKCU()
{
    return g_hHKCU;
}

HANDLE g_GetUserToken()
{
    return g_hUserToken;
}

DWORD g_GetGPOFlags()
{
    return g_dwGPOFlags;
}

LPCTSTR g_GetGPOGuid()
{
    return g_szGPOGuid;
}

BOOL g_IsValidContext()
{
    BOOL fResult;

    fResult = TRUE;
    if (g_GetContext() == CTX_UNINITIALIZED)
        fResult = FALSE;

    // ASSUMPTIONS: (andrewgu) below are restrictions on each of the CTX_XXX groups.

    // CTX_ENTRYPOINT_ALL: one and only one has to be set
    if (fResult && 1 != GetFlagsNumber(g_GetContext() & CTX_ENTRYPOINT_ALL))
        fResult = FALSE;

    // CTX_SIGNUP_ALL: if set there is only one
    if (fResult && 1 < GetFlagsNumber(g_GetContext() & CTX_SIGNUP_ALL))
        fResult = FALSE;

    // CTX_FOLDER_ALL: either one or two have to be set
    // NOTE: (andrewgu) looking forward i don't see this as something we'll use a lot because in
    // a sense this is redundant information and can easily be derived from elsewhere. plus it's
    // not all that important.
    if (fResult)
        if (2 < GetFlagsNumber(g_GetContext() & CTX_FOLDER_ALL))
            fResult = FALSE;

        else if (2 == GetFlagsNumber(g_GetContext() & CTX_FOLDER_ALL)) {
            if (!HasFlag(g_GetContext(), CTX_FOLDER_INSFOLDER) ||
                !HasFlag(g_GetContext(), (CTX_FOLDER_CUSTOM | CTX_FOLDER_SIGNUP)))
                fResult = FALSE;
        }
        else
            if (1 != GetFlagsNumber(g_GetContext() & CTX_FOLDER_ALL))
                fResult = FALSE;

    if (!fResult)
        Out(LI0(TEXT("! Fatal internal failure (assumptions about context are incorrect).")));

    return fResult;
}

BOOL g_IsValidIns()
{
    if (!PathIsValidPath(g_GetIns(), PIVP_FILE_ONLY)) {
        Out(LI0(TEXT("! Fatal internal failure (ins file is either invalid or doesn't exist).")));
        return FALSE;
    }

    return TRUE;
}

BOOL g_IsValidTargetPath()
{
    // NOTE: (andrewgu) these are the only cases when we create the target folder ourselves:
    // 1. w2k unattended has it's custom wierd download of the cab file. if it uses that way for
    // getting down the customization files, the folder may not be there yet;
    // 2. a rare case when autoconfig url is provided for a RAS connection, when this connection
    // was setup either by the user or through CTX_ISP before hand.
    if (g_CtxIs(CTX_AUTOCONFIG | CTX_W2K_UNATTEND))
        if (!PathFileExists(g_GetTargetPath()))
            if (PathCreatePath(g_GetTargetPath()))
                Out(LI0(TEXT("Target folder was created successfully!\r\n")));

    if (!PathIsValidPath(g_GetTargetPath(), PIVP_FOLDER_ONLY)) {
        Out(LI0(TEXT("Warning! Target folder is either invalid or doesn't exist.")));
        Out(LI0(TEXT("All customizations requiring additional files will fail!")));
    }

    return TRUE;
}


PCFEATUREINFO g_GetFeature(UINT nID)
{
    if (nID < FID_FIRST || nID >= FID_LAST)
        return NULL;

    return &s_rgfiList[nID];
}


BOOL g_IsValidGlobalsSetup()
{
    // if we're in group policy, then the GPO guid must be nonnull

    return (g_IsValidContext() && g_IsValidIns() && g_IsValidTargetPath() && 
        (!g_CtxIs(CTX_GP) || ISNONNULL(g_szGPOGuid)));
}

void g_LogGlobalsInfo()
{   MACRO_LI_PrologEx_C(PIF_STD_C, g_LogGlobalsInfo)

    static MAPDW2PSZ s_mpFlags[] = {
        { CTX_GENERIC,           TEXT("<generic>")                                  },
        { CTX_CORP,              TEXT("Corporations")                               },
        { CTX_ISP,               TEXT("Internet Service Providers")                 },
        { CTX_ICP,               TEXT("Internet Content Providers")                 },
        { CTX_AUTOCONFIG,        TEXT("Autoconfiguration")                          },
        { CTX_ICW,               TEXT("Internet Connection Wizard")                 },
        { CTX_W2K_UNATTEND,      TEXT("Windows 2000 unattended install")            },
        { CTX_INF_AND_OE,        TEXT("Policies, Restrictions and Outlook Express") },
        { CTX_BRANDME,           TEXT("BrandMe")                                    },
        { CTX_GP,                TEXT("Group Policy")                               },

        { CTX_SIGNUP_ICW,        TEXT("\"Internet Connection Wizard\" type signup") },
        { CTX_SIGNUP_KIOSK,      TEXT("\"Kiosk\" mode signup")                      },
        { CTX_SIGNUP_CUSTOM,     TEXT("\"Custom method\" mode signup")              },

        { CTX_MISC_PERUSERSTUB,  TEXT("running from per-user stub")                 },
        { CTX_MISC_PREFERENCES,  TEXT("preference settings")                        },
        { CTX_MISC_CHILDPROCESS, TEXT("spawned in a child process")                 }
    };

    TCHAR szText[MAX_PATH];
    UINT  i;

    Out(LI0(TEXT("Global branding settings are:")));
    { MACRO_LI_Offset(1);                       // need a new scope

    szText[0] = TEXT('\0');
    for (i = 0; i < countof(s_mpFlags); i++)
        if (HasFlag(s_mpFlags[i].dw, g_GetContext())) {
            if (szText[0] != TEXT('\0'))
                StrCat(szText, TEXT(", "));

            StrCat(szText, s_mpFlags[i].psz);
        }
    Out(LI2(TEXT("Context is (0x%08lX) \"%s\";"), g_GetContext(), szText));

    if ((g_GetContext() & CTX_ENTRYPOINT_ALL) == CTX_AUTOCONFIG) {
        INTERNET_PER_CONN_OPTION_LIST list;
        INTERNET_PER_CONN_OPTION      option;
        PTSTR pszUrl, pszAux;
        DWORD cbList;

        ZeroMemory(&list, sizeof(list));
        list.dwSize        = sizeof(list);
        list.dwOptionCount = 1;
        list.pOptions      = &option;

        ZeroMemory(&option, sizeof(option));
        option.dwOption = INTERNET_PER_CONN_AUTOCONFIG_URL;

        pszAux = NULL;
        cbList = list.dwSize;
        if (TRUE == InternetQueryOption(NULL, INTERNET_OPTION_PER_CONNECTION_OPTION, &list, &cbList))
            pszAux = option.Value.pszValue;
        pszUrl = pszAux;

        if (pszUrl != NULL && *pszUrl != TEXT('\0')) {
            URL_COMPONENTS uc;

            ZeroMemory(&uc, sizeof(uc));
            uc.dwStructSize    = sizeof(uc);
            uc.dwUrlPathLength = 1;

            if (InternetCrackUrl(pszUrl, 0, 0, &uc))
                if (uc.nScheme == INTERNET_SCHEME_FILE) {
                    // pszUrl should point to \\foo\bar\bar.ins
                    // the below ASSERT explains the case we got here
                    ASSERT(uc.lpszUrlPath != NULL && uc.dwUrlPathLength > 0);
                    pszUrl = uc.lpszUrlPath;
                }

            Out(LI1(TEXT("Autoconfig file is       \"%s\";"), pszUrl));
        }

        if (pszAux != NULL)
            GlobalFree(pszAux);
    }

    Out(LI1(TEXT("Settings file is        \"%s\";"), g_GetIns()));
    Out(LI1(TEXT("Target folder path is   \"%s\"."), g_GetTargetPath()));
    }                                           // end of offset scope

    Out(LI0(TEXT("Done.")));
}


/////////////////////////////////////////////////////////////////////////////
// Implementation helper routines

DWORD ctxInitFromIns(PCTSTR pszIns)
{
    DWORD dwResult;
    int   iAux;

    ASSERT(PathIsValidPath(pszIns, PIVP_FILE_ONLY));
    dwResult = CTX_UNINITIALIZED;

    //----- CTX_ISP vs CTX_ICP -----
    // NOTE: (andrewgu) gotta love these hacks! notice how default is TYPE_ICP but if value is
    // messed up we default to TYPE_ISP. this whole thing was introduced because of Netcom IE401.
    iAux  = GetPrivateProfileInt(IS_BRANDING, IK_TYPE, TYPE_ICP, pszIns);
    iAux &= TYPE_ALL;
    if (1 < GetFlagsNumber(iAux))
        iAux = TYPE_ISP;

    if (TYPE_ICP == iAux)
        dwResult = CTX_ICP;

    else if (TYPE_ISP == iAux)
        dwResult = CTX_ISP;

    else if (TYPE_CORP == iAux)
        dwResult = CTX_CORP;

    else
        ASSERT(FALSE);                          // bad usage - wrong assumption!

    if (TYPE_ISP != iAux)
        return dwResult;

    //----- CTX_SIGNUP_XXX (if any) -----
    // NOTE: (andrewgu) this implementation is not very robust. if more than one is present it
    // becomes order dependant.
    iAux = -1;

    if (iAux == -1) {
        iAux = GetPrivateProfileInt(IS_BRANDING, IK_USEICW, -1, pszIns);
        if (iAux != -1)
            SetFlag(&dwResult, CTX_SIGNUP_ICW);
    }

    if (iAux == -1) {
        iAux = GetPrivateProfileInt(IS_BRANDING, IK_SERVERKIOSK, -1, pszIns);
        if (iAux != -1)
            SetFlag(&dwResult, CTX_SIGNUP_KIOSK);
    }

    if (iAux == -1) {
        iAux = GetPrivateProfileInt(IS_BRANDING, IK_SERVERLESS, -1, pszIns);
        if (iAux != -1)
            SetFlag(&dwResult, CTX_SIGNUP_CUSTOM);
    }

#ifdef _DEBUG
    if (iAux == -1) {
        iAux = GetPrivateProfileInt(IS_BRANDING, IK_NODIAL, -1, pszIns);
        ASSERT(iAux != -1);
    }
#endif

    return dwResult;
}


DWORD ctxGetFolderFromTargetPath(PCTSTR pszTargetPath, DWORD dwContext /*= CTX_UNINITIALIZED*/, PCTSTR pszIns /*= NULL*/)
{
    TCHAR  szAux[MAX_PATH];
    PCTSTR pszIE,
           pszAux;
    DWORD  dwResult;

    ASSERT(pszTargetPath != NULL && *pszTargetPath != TEXT('\0') && pszIns != NULL);
    pszIE    = GetIEPath();
    dwResult = CTX_UNINITIALIZED;

    if (NULL != pszIE && PathIsPrefix(pszIE, pszTargetPath)) {
        pszAux = &pszTargetPath[StrLen(pszIE)];
        if (TEXT('\\') == *pszAux) {
            if (0 == StrStrI(pszAux + 1, FOLDER_SIGNUP)) {
                if (HasFlag(dwContext, (CTX_CORP | CTX_AUTOCONFIG | CTX_W2K_UNATTEND)))
                    return dwResult;            // bad combination

                dwResult = CTX_FOLDER_SIGNUP;
            }
            else if (0 == StrStrI(pszAux + 1, FOLDER_CUSTOM)) {
                if (HasFlag(dwContext, (CTX_ISP | CTX_ICP | CTX_ICW | CTX_BRANDME)))
                    return dwResult;            // bad combination

                dwResult = CTX_FOLDER_CUSTOM;
            }
        }
    }

    if (TEXT('\0') != *pszIns) {
        StrCpy(szAux, pszIns);
        PathRemoveFileSpec(szAux);

        dwResult = (0 == StrCmpI(szAux, pszTargetPath)) ? CTX_FOLDER_INSFOLDER : CTX_FOLDER_INDEPENDENT;
    }
    else
        // NOTE: (andrewgu) this is a little confusing. this means "even though .ins file is empty
        // now, when the time comes to set it, it'll be set based on the target folder path." the
        // name will be fixed to install.ins.
        dwResult = CTX_FOLDER_INSFOLDER;

    return dwResult;
}

DWORD ctxGetFolderFromEntryPoint(DWORD dwContext, PCTSTR pszIns /*= NULL*/)
{
    DWORD dwResult;

    dwResult = CTX_UNINITIALIZED;

    switch (dwContext & CTX_ENTRYPOINT_ALL) {
    case CTX_GENERIC:
    case CTX_INF_AND_OE:
    case CTX_GP:
        if (TEXT('\0') == pszIns)
            return dwResult;
        ASSERT(PathIsValidPath(pszIns, PIVP_FILE_ONLY));

        dwResult = CTX_FOLDER_INSFOLDER;
        break;

    case CTX_CORP:
    case CTX_AUTOCONFIG:
    case CTX_W2K_UNATTEND:
        dwResult = CTX_FOLDER_CUSTOM;
        break;

    case CTX_ISP:
    case CTX_ICP:
    case CTX_ICW:
    case CTX_BRANDME:
        dwResult = CTX_FOLDER_SIGNUP;
        break;
    }

    return dwResult;
}

DWORD ctxGetFolderFromIns(DWORD dwContext /*= CTX_UNINITIALIZED*/, PCTSTR pszIns /*= NULL*/)
{
    TCHAR  szAux[MAX_PATH], szAux2[MAX_PATH];
    PCTSTR pszIE;
    DWORD  dwResult;

    ASSERT(NULL != pszIns);
    dwResult = CTX_UNINITIALIZED;

    if (TEXT('\0') != *pszIns) 
    {
        ASSERT(PathIsValidPath(pszIns, PIVP_FILE_ONLY));
        pszIE = GetIEPath();
        if (NULL == pszIE)
            return dwResult;

        StrCpy(szAux, pszIns);
        PathRemoveFileSpec(szAux);

        if (!HasFlag(dwContext, CTX_FOLDER_INSFOLDER)) 
        {
            ASSERT(HasFlag(dwContext, (CTX_FOLDER_CUSTOM | CTX_FOLDER_SIGNUP)));

            PathCombine(szAux2, pszIE, HasFlag(dwContext, CTX_FOLDER_CUSTOM) ? FOLDER_CUSTOM : FOLDER_SIGNUP);
            if (0 == StrCmpI(szAux, szAux2))
                dwResult = CTX_FOLDER_INSFOLDER;
        }
        else
            if (!HasFlag(dwContext, (CTX_FOLDER_CUSTOM | CTX_FOLDER_SIGNUP))) 
            {
                PCTSTR pszFolder;

                pszFolder = PathFindFileName(pszIns);  
                int iCompLen;
                if (pszFolder-1 <= pszIns)  //pathfindfilename failed to find a filename
                    iCompLen = StrLen(pszIns);
                else
                    iCompLen = (int)(pszFolder-1 - pszIns);
                if (0 == StrCmpNI(pszIE, pszIns, iCompLen))
                    if (0 == StrCmpI(pszFolder, FOLDER_SIGNUP))
                        dwResult = CTX_FOLDER_SIGNUP;

                    else if (0 == StrCmpI(pszFolder, FOLDER_CUSTOM))
                        dwResult = CTX_FOLDER_CUSTOM;
            }
    }
    else { /* TEXT('\0') == *pszIns */
        // NOTE: (andrewgu) this is a little confusing. this means "even though .ins file is empty
        // now, when the time comes to set it, it'll be set based on the target folder path." this
        // is despite the fact that even target folder path itself may be empty at the moment, but
        // based on the context information it'll be possible to determine its value.
        if (!HasFlag(dwContext, (CTX_FOLDER_CUSTOM | CTX_FOLDER_SIGNUP)))
            return dwResult;

        dwResult = CTX_FOLDER_INSFOLDER;
    }

    return dwResult;
}

BOOL IsDirWritable( LPCTSTR szPath )
{
    DWORD  dwAttribs;
    HANDLE hFile;
    TCHAR  szTestFile[MAX_PATH];

    //Windows bug 721064-Intlsetup:opk:US:Customized icon is not showed up.(Customized IE Favorites,tool bar button)
    hFile = CreateFile(szPath, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL );
    if ( hFile == INVALID_HANDLE_VALUE ) 
        return( TRUE );
    else
        CloseHandle( hFile );

    lstrcpy( szTestFile, szPath );
    PathCombine( szTestFile, szTestFile, TEXT("TMP4352$.TMP") );
    DeleteFile( szTestFile );
    hFile = CreateFile( szTestFile, GENERIC_WRITE, 0, NULL, CREATE_NEW,
                        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_DELETE_ON_CLOSE,
                        NULL );

    if ( hFile == INVALID_HANDLE_VALUE )  {
        return( FALSE );
    }

    CloseHandle( hFile );
    dwAttribs = GetFileAttributes( szPath );

    if ( ( dwAttribs != 0xFFFFFFFF )
         && ( dwAttribs & FILE_ATTRIBUTE_DIRECTORY ) )
    {
        return( TRUE );
    }

    return( FALSE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\brandll\globalsr.h ===
#ifndef _GLOBALSR_H_
#define _GLOBALSR_H_

// Context values
// NOTE: (andrewgu) <Important in code reviews>
// if you change these values ALWAYS update CTX_XXX_ALL to reflect the new result. otherwise
// g_IsValidContext() may break, and no branding will happen. also if you update these values
// g_XXX() may well be affected (all of them) so don't forget to do the right thing.
#define CTX_UNINITIALIZED      0xFFFFFFFF       // uninitialized

// main entry points
#define CTX_GENERIC            0x00000001       // generic
#define CTX_CORP               0x00000002       // BrandIE4, custom
#define CTX_ISP                0x00000004       // BrandIE4, signup; [IS_BRANDING],IK_TYPE = 1
#define CTX_ICP                0x00000008       // BrandIE4, signup; [IS_BRANDING],IK_TYPE = 0
#define CTX_AUTOCONFIG         0x00000010       // InternetInitializeAutoProxyDll
#define CTX_ICW                0x00000020       // BrandICW, BrandICW2
#define CTX_W2K_UNATTEND       0x00000040       // BrandIntra
#define CTX_INF_AND_OE         0x00000080       // BrandInfAndOutlookExpress
#define CTX_BRANDME            0x00000100       // BrandMe - why it's needed
#define CTX_GP                 0x00000200       // ProcessGroupPolicy
#define CTX_ADMIN_ALL          0x00000252       // (CTX_CORP | CTX_AUTOCONFIG | CTX_W2K_UNATTEND | CTX_GP)
#define CTX_ENTRYPOINT_ALL     0x000003FF       // combination of all above

// signup information
#define CTX_SIGNUP_ICW         0x00010000       // only when CTX_ISP is set
#define CTX_SIGNUP_KIOSK       0x00020000       // only when CTX_ISP is set
#define CTX_SIGNUP_CUSTOM      0x00040000       // only when CTX_ISP is set (aka Serverless)
#define CTX_SIGNUP_NOSIGNUP                     // fake, use !CTX_SIGNUP_ALL
#define CTX_SIGNUP_ALL         0x00070000       // combination of all above

// location of the branding files (in most cases extracted from branding.cab)
#define CTX_FOLDER_INDEPENDENT 0x00100000       // ins file and target folder are independent
#define CTX_FOLDER_CUSTOM      0x00200000       // <ie folder>\custom
#define CTX_FOLDER_SIGNUP      0x00400000       // <ie folder>\signup
#define CTX_FOLDER_INSFOLDER   0x00800000       // folder where ins file lives
#define CTX_FOLDER_ALL         0x00F00000       // combination of all above

// miscellaneous information
#define CTX_MISC_PERUSERSTUB   0x01000000       // run from PerUser stubs
#define CTX_MISC_PREFERENCES   0x02000000       // Prefereneces ins is being processed
#define CTX_MISC_CHILDPROCESS  0x04000000       // running in a child process
#define CTX_MISC_ALL           0x07000000       // combination of all above

// access helpers
#define g_CtxIs(dwFlag)     (HasFlag(g_GetContext(), dwFlag))
#define g_CtxIsCorp()       (g_CtxIs(CTX_CORP))
#define g_CtxIsIsp()        (g_CtxIs(CTX_ISP))
#define g_CtxIsIcp()        (g_CtxIs(CTX_ICP))
#define g_CtxIsAutoconfig() (g_CtxIs(CTX_AUTOCONFIG))
#define g_CtxIsGp()         (g_CtxIs(CTX_GP))


// Feature IDs
#define FID_FIRST                  0
#define FID_CLEARBRANDING          0
#define FID_MIGRATEOLDSETTINGS     1
#define FID_WININETSETUP           2
#define FID_CS_DELETE              3
#define FID_ZONES_HKCU             4
#define FID_ZONES_HKLM             5
#define FID_RATINGS                6
#define FID_AUTHCODE               7
#define FID_PROGRAMS               8
#define FID_EXTREGINF_HKLM         9
#define FID_EXTREGINF_HKCU        10
#define FID_LCY50_EXTREGINF       11
#define FID_GENERAL               12
#define FID_CUSTOMHELPVER         13
#define FID_TOOLBARBUTTONS        14
#define FID_ROOTCERT              15
#define FID_FAV_DELETE            16
#define FID_FAV_MAIN              17
#define FID_FAV_ORDER             18
#define FID_QL_MAIN               19
#define FID_QL_ORDER              20
#define FID_CS_MAIN               21
#define FID_TPL                   23
#define FID_CD_WELCOME            24
#define FID_ACTIVESETUPSITES      25
#define FID_LINKS_DELETE          26
#define FID_OUTLOOKEXPRESS        27
#define FID_LCY4X_ACTIVEDESKTOP   28
#define FID_LCY4X_CHANNELS        29
#define FID_LCY4X_SOFTWAREUPDATES 30
#define FID_LCY4X_WEBCHECK        31
#define FID_LCY4X_CHANNELBAR      32
#define FID_LCY4X_SUBSCRIPTIONS   33
#define FID_REFRESHBROWSER        34
#define FID_LAST                  35

#define FF_INVALID          0xFFFFFFFF
#define FF_ENABLE           0x00000000
#define FF_DISABLE          0x00000001

#define FF_GEN_TITLE         0x00000010
#define FF_GEN_HOMEPAGE      0x00000020
#define FF_GEN_SEARCHPAGE    0x00000040
#define FF_GEN_HELPPAGE      0x00000080
#define FF_GEN_UASTRING      0x00000100
#define FF_GEN_TOOLBARBMP    0x00000200
#define FF_GEN_STATICLOGO    0x00000400
#define FF_GEN_ANIMATEDLOGO  0x00000800
#define FF_GEN_FIRSTHOMEPAGE 0x00001000
#define FF_GEN_TBICONTHEME   0x00002000
#define FF_GEN_ALL           0x00003FF0


// Feature structure
typedef void    (* PFNCLEARFEATURE)(DWORD dwFlags /*= FF_ENABLE*/);
typedef BOOL    (* PFNAPPLYFEATURE)();
typedef HRESULT (* PFNPROCESSFEATURE)();

typedef struct tagFEATUREINFO {
    UINT              nID;
    PCTSTR            pszDescription;
    PFNCLEARFEATURE   pfnClear;
    PFNAPPLYFEATURE   pfnApply;
    PFNPROCESSFEATURE pfnProcess;
    PCTSTR            pszInsFlags;
    DWORD             dwFlags;
} FEATUREINFO, *PFEATUREINFO;
typedef const FEATUREINFO *PCFEATUREINFO;


// Read-only access to globals
extern HANDLE g_hfileLog;
extern BOOL   g_fFlushEveryWrite;
BOOL IsIEHardened();
BOOL IsFirstTimeLogon();


HINSTANCE     g_GetHinst();
DWORD         g_GetContext();
PCTSTR        g_GetIns();
PCTSTR        g_GetTargetPath();
HKEY          g_GetHKCU();
HANDLE        g_GetUserToken();
DWORD         g_GetGPOFlags();
LPCTSTR       g_GetGPOGuid();
PCFEATUREINFO g_GetFeature(UINT nID);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\brandll\globalsw.h ===
#ifndef _GLOBALSW_H_
#define _GLOBALSW_H_
#include "globalsr.h"

extern TCHAR  g_szModule[];
extern HANDLE g_hBaseDllHandle;

HRESULT g_SetGlobals(PCTSTR pszCmdLine);
HRESULT g_SetGlobals(PCMDLINESWITCHES pcls);

void g_SetHinst(HINSTANCE hInst);

BOOL g_SetHKCU();
void g_SetUserToken(HANDLE hUserToken);
void g_SetGPOFlags(DWORD dwFlags);
void g_SetGPOGuid(LPCTSTR pcszGPOGuid);

BOOL g_IsValidContext();
BOOL g_IsValidIns();
BOOL g_IsValidTargetPath();

BOOL g_IsValidGlobalsSetup();
void g_LogGlobalsInfo();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\brandll\precomp.h ===
#ifndef _PRECOMP_H_
#define _PRECOMP_H_

#include <w95wraps.h>
#include <windows.h>
#include <wininet.h>                            // has to come before shlobj.h
#include <urlmon.h>

// NOTE: (andrewgu) this is needed so that shfolder can be dynamically linked. otherwise it
// doesn't compile giving error C2491.
#define _SHFOLDER_
#include <shlobj.h>

#include <shlwapi.h>
#include <shlwapip.h>
#include <shellapi.h>
#include <advpub.h>
#include <regstr.h>
#include <webcheck.h>

#include "brand.h"
#include <iedkbrnd.h>
#include <ieakutil.h>
#include "defines.h"
#include "globalsr.h"
#include "utils.h"
#include "resource.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\brandll\resource.h ===
#define IDD_DISPLAY 101

#define IDC_STATIC   -1
#define IDC_ANIM   1001

// the ids are out of order because of the localization requirements
#define IDS_SCHED_AUTO             3004
#define IDS_SCHED_DAILY            3005
#define IDS_SCHED_WEEKLY           3006
#define IDS_SCHED_MONTHLY          3007

#define IDS_FOLDER_LINKS           3008
#define IDS_FOLDER_QUICKLAUNCH     3009
#define IDS_FOLDER_CHANNELS        3020
#define IDS_FOLDER_SOFTWAREUPDATES 3021
#define IDS_FOLDER_DESKTOP         3022

#define IDS_IELNK                  3011
#define IDS_HELPSTRING             3012
#define IDS_STATUSMSG              3013
#define IDS_NAME                   3014

#define IDS_ICW_CONNECTTOINTERNET  3031
#define IDS_REG_BARPARENT          3032

#define IDS_FILE_VIEWCHANNELS      3041
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\brandll\rsop.cpp ===
#include "precomp.h"

// The following bug may be due to having CHICAGO_PRODUCT set in sources.
// This file and all rsop??.cpp files need to have WINVER defined at at least 500

// BUGBUG: (andrewgu) no need to say how bad this is!
#undef   WINVER
#define  WINVER 0x0501
#include <userenv.h>

#include "RSoP.h"

#include <atlbase.h>

#include "btoolbar.h"
#include "ieaksie.h"

extern PFNPATHENUMPATHPROC GetPepCopyFilesEnumProc();

///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////
// Extra Logging function
#define LI4(pszFormat, arg1, arg2, arg3, arg4)                              \
    g_li.Log(__LINE__, pszFormat, arg1, arg2, arg3, arg4)                   \

#define IK_PATH          TEXT("Path")

///////////////////////////////////////////////////////////////////////////////
// References to variables & functions


///////////////////////////////////////////////////////////////////////////////
// CRSoPGPO CLASS
///////////////////////////////////////////////////////////////////////////////
CRSoPGPO::CRSoPGPO(ComPtr<IWbemServices> pWbemServices, LPCTSTR szINSFile, BOOL fPlanningMode):
    m_pWbemServices(pWbemServices),
    m_pIEAKPSObj(NULL),
    m_dwPrecedence(0),
    m_bstrIEAKPSObjPath(NULL),
    m_fPlanningMode(fPlanningMode)
{
    MACRO_LI_PrologEx_C(PIF_STD_C, CRSoPGPO)
    __try
    {
        StrCpy(m_szINSFile, szINSFile);
    }
    __except(TRUE)
    {
    }
}

CRSoPGPO::~CRSoPGPO()
{
    __try
    {
        if (NULL != m_bstrIEAKPSObjPath)
            SysFreeString(m_bstrIEAKPSObjPath);
    }
    __except(TRUE)
    {
    }
}

///////////////////////////////////////////////////////////
BOOL CRSoPGPO::GetInsString(LPCTSTR szSection, LPCTSTR szKey,
                            LPTSTR szValue, DWORD dwValueLen,
                            BOOL &bEnabled)
{
    BOOL bRet = FALSE;
    __try
    {
        bEnabled = FALSE;
        bRet = InsGetString(szSection, szKey, szValue, dwValueLen, m_szINSFile,
                            NULL, &bEnabled);
        OutD(LI3(TEXT("Value read from INS >> %s >> %s = %s."),
                                    szSection, szKey, szValue));
    }
    __except(TRUE)
    {
        OutD(LI0(TEXT("Exception in GetInsString.")));
    }
    return bRet;
}

///////////////////////////////////////////////////////////
BOOL CRSoPGPO::GetInsBool(LPCTSTR szSection, LPCTSTR szKey, BOOL bDefault,
                          BOOL *pbEnabled /*= NULL*/)
{
    BOOL bRet = FALSE;
    __try
    {
        BOOL bEnabled = FALSE;
        if (NULL != pbEnabled)
            bEnabled = InsKeyExists(szSection, szKey, m_szINSFile);
        else
            bEnabled = TRUE;

        if (bEnabled)
        {
            bRet = InsGetBool(szSection, szKey, bDefault, m_szINSFile);
            OutD(LI3(TEXT("Value read from INS >> %s >> %s = %d."),
                                        szSection, szKey, bRet));
        }

        if (NULL != pbEnabled)
            *pbEnabled = bEnabled;
    }
    __except(TRUE)
    {
        OutD(LI0(TEXT("Exception in GetInsBool.")));
    }
    return bRet;
}

///////////////////////////////////////////////////////////
UINT CRSoPGPO::GetInsInt(LPCTSTR szSection, LPCTSTR szKey, INT nDefault,
                         BOOL *pbEnabled /*= NULL*/)
{
    UINT nRet = FALSE;
    __try
    {
        BOOL bEnabled = FALSE;
        if (NULL != pbEnabled)
            bEnabled = InsKeyExists(szSection, szKey, m_szINSFile);
        else
            bEnabled = TRUE;

        if (bEnabled)
        {
            nRet = InsGetInt(szSection, szKey, nDefault, m_szINSFile);
            OutD(LI3(TEXT("Value read from INS >> %s >> %s = %ld."),
                                        szSection, szKey, nRet));
        }

        if (NULL != pbEnabled)
            *pbEnabled = bEnabled;
    }
    __except(TRUE)
    {
        OutD(LI0(TEXT("Exception in GetInsInt.")));
    }
    return nRet;
}

///////////////////////////////////////////////////////////
BOOL CRSoPGPO::GetINFStringField(PINFCONTEXT pinfContext, LPCTSTR szFileName,
                                 LPCTSTR szSection, DWORD dwFieldIndex,
                                 LPCTSTR szFieldSearchText, LPTSTR szBuffer,
                                 DWORD dwBufferLen, BOOL &bFindNextLine)
{
    BOOL bRet = FALSE;
    __try
    {
        TCHAR szLineBuffer[512];
        DWORD dwRequiredSize = 0;
        if (SetupGetLineText(pinfContext, NULL, NULL, NULL, szLineBuffer,
                                                countof(szLineBuffer), &dwRequiredSize))
        {
            // If the search text is not found in this line, the line is not the one
            // the caller was expecting.  Don't return the next line in the context
            // because the current line hasn't been processed yet.
            if (NULL == szFieldSearchText || NULL != StrStr(szLineBuffer, szFieldSearchText))
            {
                if ((DWORD)-1 == dwFieldIndex) // -1 means get the whole line
                {
                    StrCpyN(szBuffer, szLineBuffer, dwBufferLen - 1);
                    szBuffer[dwBufferLen - 1] = _T('\0');

                    OutD(LI4(TEXT("Line read from %s >> [%s] >> %s = %s."),
                                                szFileName, szSection, szFieldSearchText, szBuffer));

                    bRet = TRUE;

                    if (bFindNextLine)
                        bFindNextLine = SetupFindNextLine(pinfContext, pinfContext) ? TRUE : FALSE;
                }
                else
                {
                    dwRequiredSize = 0;
                    if (SetupGetStringField(pinfContext, dwFieldIndex, szBuffer, dwBufferLen,
                                            &dwRequiredSize))
                    {
                        OutD(LI4(TEXT("Value read from %s >> [%s] >> %s = %s."),
                                    szFileName, szSection, szFieldSearchText, szBuffer));
                        bRet = TRUE;

                        // This is the expected line and the value was retrieved, move on to
                        // the next line.
                        if (bFindNextLine)
                            bFindNextLine = SetupFindNextLine(pinfContext, pinfContext) ? TRUE : FALSE;
                    }
                    else
                        OutD(LI1(TEXT("SetupGetStringField failed, requiring size of %lu"), dwRequiredSize));
                }
            }
            else
            {
                // do nothing - this isn't the line the caller was expecting
            }
        }
        else
            OutD(LI1(TEXT("SetupGetLineText failed, requiring size of %lu"), dwRequiredSize));
    }
    __except(TRUE)
    {
        OutD(LI0(TEXT("Exception in GetINFStringField.")));
    }

    return bRet;
}


///////////////////////////////////////////////////////////
HRESULT CRSoPGPO::PutWbemInstanceProperty(BSTR bstrPropName, _variant_t vtPropValue)
{
    HRESULT hr = NOERROR;
    __try
    {
        hr = m_pIEAKPSObj->Put(bstrPropName, 0, &vtPropValue, 0);
        if (FAILED(hr))
            OutD(LI2(TEXT("Error %lx setting the class instance value for property: '%s'."), hr, bstrPropName));
    }
    __except(TRUE)
    {
        OutD(LI0(TEXT("Exception in PutWbemInstanceProperty.")));
    }
    return hr;
}

///////////////////////////////////////////////////////////
HRESULT CRSoPGPO::PutWbemInstancePropertyEx(BSTR bstrPropName, _variant_t vtPropValue,
                                            ComPtr<IWbemClassObject> pWbemClass)
{
    HRESULT hr = NOERROR;
    __try
    {
        hr = pWbemClass->Put(bstrPropName, 0, &vtPropValue, 0);
        if (FAILED(hr))
            OutD(LI2(TEXT("Error %lx setting the class instance (ex) value for property: '%s'."), hr, bstrPropName));
    }
    __except(TRUE)
    {
        OutD(LI0(TEXT("Exception in PutWbemInstancePropertyEx.")));
    }
    return hr;
}

///////////////////////////////////////////////////////////
HRESULT CRSoPGPO::PutWbemInstance(ComPtr<IWbemClassObject> pWbemObj,
                                  BSTR bstrClassName, BSTR *pbstrObjPath)
{
    MACRO_LI_PrologEx_C(PIF_STD_C, PutWbemInstance)
    HRESULT hr = NOERROR;
    __try
    {
        OutD(LI1(TEXT("\r\nAbout to call WBEM PutInstance for '%s'."), bstrClassName));

        // Commit all  properties by calling PutInstance, semisynchronously
        ComPtr<IWbemCallResult> pCallResult = NULL;
        hr = m_pWbemServices->PutInstance(pWbemObj,
                                            WBEM_FLAG_CREATE_OR_UPDATE | WBEM_FLAG_RETURN_IMMEDIATELY,
                                            NULL, &pCallResult);
        if (SUCCEEDED(hr))
        {
            ASSERT(NULL != pCallResult);

            HRESULT hrGetStatus = pCallResult->GetCallStatus(5000L, &hr); // timeout in milliseconds
            if (SUCCEEDED(hr) && SUCCEEDED(hrGetStatus))
            {
                hr = pCallResult->GetResultString(10000L, pbstrObjPath); // timeout in milliseconds
                if (SUCCEEDED(hr) && NULL != *pbstrObjPath)
                    OutD(LI2(TEXT("Path of newly created '%s' object is {%s}."), bstrClassName, *pbstrObjPath));
                else
                {
                    if (NULL == *pbstrObjPath)
                        Out(LI0(TEXT("Error getting ResultString from WBEM PutInstance, returned string NULL")));
                    else
                        Out(LI1(TEXT("Error %lx getting ResultString from WBEM PutInstance."), hr));
                    
                }
            }
            else
                OutD(LI1(TEXT("Error %lx getting status of WBEM PutInstance."), hr));
        }
        else
            OutD(LI1(TEXT("Error %lx putting WBEM instance."), hr));
    }
    __except(TRUE)
    {
        OutD(LI0(TEXT("Exception in PutWbemInstance.")));
    }
    return hr;
}

///////////////////////////////////////////////////////////
HRESULT CRSoPGPO::CreateRSOPObject(BSTR bstrClass,
                                   IWbemClassObject **ppResultObj,
                                   BOOL bTopObj /*= FALSE*/)
{
    MACRO_LI_PrologEx_C(PIF_STD_C, CreateRSOPObject)

    HRESULT hr = NOERROR;
    __try
    {
        // If we were called from GenerateGroupPolicy, or if called from ProcessGroupPolicyEx
        // and no IEAK object already exists, create the GUID ID of the GPO.
        if (bTopObj)
        {
            // For the IEAK "id" property, which is the key, this must be unique.  However,
            // since there is only one of each top object per GPO (each GPO has a different
            // precedence number) per namespace, the class name guarantees uniqueness.
            
            // CSE's need to  determine their own key which needs to be unique for every
            // instance of their  policy instance, i.e. they may have a better key generation
            // algorithm say by concatenating some of their specific properties (see registry
            // RSoP implementation).
            m_bstrID = L"IEAK";
        }

        ComPtr<IWbemClassObject> pClass = NULL;
        _bstr_t btClass = bstrClass;
        hr = m_pWbemServices->GetObject(btClass, 0L, NULL, (IWbemClassObject**)&pClass, NULL);
        if (SUCCEEDED(hr))
        {
            hr = pClass->SpawnInstance(0, ppResultObj);
            if (FAILED(hr) || NULL == *ppResultObj)
            {
                if (SUCCEEDED(hr))
                    hr = WBEM_E_NOT_FOUND; // how can we succeed and return no objects?
                Out(LI2(TEXT("Error %lx spawning instance of %s class."), hr, bstrClass));
            }
        }
        else
            Out(LI2(TEXT("Error %lx opening %s class."), hr, bstrClass));
    }
    __except(TRUE)
    {
        OutD(LI0(TEXT("Exception in CreateRSOPObject.")));
    }

  return hr;
}

///////////////////////////////////////////////////////////
HRESULT CRSoPGPO::CreateAssociation(BSTR bstrAssocClass, BSTR bstrProp2Name,
                                    BSTR bstrProp2ObjPath)
{
    MACRO_LI_PrologEx_C(PIF_STD_C, CreateAssociation)
    HRESULT hr = NOERROR;
    __try
    {
        if (SysStringLen(bstrProp2ObjPath))
        {
            ComPtr<IWbemClassObject> pAssocObj = NULL;
            hr = CreateRSOPObject(bstrAssocClass, &pAssocObj);
            if (SUCCEEDED(hr))
            {
                // Put policySetting object path in the association
                _variant_t vtRef = m_bstrIEAKPSObjPath;
                hr = PutWbemInstancePropertyEx(L"policySetting", vtRef, pAssocObj);

                // Put 2nd property's object path and put it in the association
                vtRef = bstrProp2ObjPath; 
                hr = PutWbemInstancePropertyEx(bstrProp2Name, vtRef, pAssocObj);

                //
                // Commit all above properties by calling PutInstance
                //
                hr = m_pWbemServices->PutInstance(pAssocObj, WBEM_FLAG_CREATE_OR_UPDATE, NULL, NULL);
                if (SUCCEEDED(hr))
                    OutD(LI1(TEXT("Successfully stored '%s' information in CIMOM database."), bstrAssocClass));
                else
                    OutD(LI2(TEXT("Error %lx putting WBEM instance of '%s' class."), hr, bstrAssocClass));
            }
        }
        else 
            OutD(LI1(TEXT("Unable to create association for '%s' class, object path is null."), bstrAssocClass));
    }
    __except(TRUE)
    {
        OutD(LI0(TEXT("Exception in CreateAssociation.")));
    }
    return hr;
}

///////////////////////////////////////////////////////////
HRESULT CRSoPGPO::StorePrecedenceModeData()
{
    HRESULT hr = NOERROR;
    __try
    {
        //------------------------------------------------
        // preferenceMode
        if (InsKeyExists(IS_BRANDING, IK_GPE_ONETIME_GUID, m_szINSFile))
            hr = PutWbemInstanceProperty(L"preferenceMode", true);
    }
    __except(TRUE)
    {
        OutD(LI0(TEXT("Exception in StoreDisplayedText.")));
    }

  return hr;
}

///////////////////////////////////////////////////////////
HRESULT CRSoPGPO::StoreDisplayedText()
{
    HRESULT hr = NOERROR;
    __try
    {
        //------------------------------------------------
        // titleBarText
        TCHAR szValue[MAX_PATH];
        BOOL bEnabled;
        GetInsString(IS_BRANDING, IK_WINDOWTITLE, szValue, countof(szValue), bEnabled);
        if (bEnabled)
            hr = PutWbemInstanceProperty(L"titleBarText", szValue);

        //------------------------------------------------
        // titleBarCustomText
        GetInsString(IS_BRANDING, TEXT("Window_Title_CN"), szValue, countof(szValue), bEnabled); 
        if (bEnabled)
            hr = PutWbemInstanceProperty(L"titleBarCustomText", szValue);

        //------------------------------------------------
        // userAgentText
        ZeroMemory(szValue, sizeof(szValue));
        GetInsString(IS_BRANDING, IK_UASTR, szValue, countof(szValue), bEnabled);
        if (bEnabled)
            hr = PutWbemInstanceProperty(L"userAgentText", szValue);
    }
    __except(TRUE)
    {
        OutD(LI0(TEXT("Exception in StoreDisplayedText.")));
    }

  return hr;
}

///////////////////////////////////////////////////////////
HRESULT CRSoPGPO::StoreBitmapData()
{
    HRESULT hr = NOERROR;
    __try
    {
        //TODO: do paths need to be combined with another path to take
        // relative paths into account?
        //------------------------------------------------
        // toolbarBackgroundBitmapPath
        TCHAR szValue[MAX_PATH];
        BOOL bEnabled;
        GetInsString(IS_BRANDING, IK_TOOLBARBMP, szValue, countof(szValue), bEnabled);
        if (bEnabled)
            hr = PutWbemInstanceProperty(L"toolbarBackgroundBitmapPath", szValue);


        //------------------------------------------------
        // customizeAnimatedBitmaps
        BOOL bValue = GetInsBool(IS_ANIMATION, IK_DOANIMATION, FALSE, &bEnabled);
        if (bEnabled)
            hr = PutWbemInstanceProperty(L"customizeAnimatedBitmaps", bValue ? true : false);

        //------------------------------------------------
        // largeAnimatedBitmapPath & largeAnimatedBitmapName
        ZeroMemory(szValue, sizeof(szValue));
        GetInsString(IS_ANIMATION, TEXT("Big_Path"), szValue, countof(szValue), bEnabled);
        if (bEnabled)
        {
            hr = PutWbemInstanceProperty(L"largeAnimatedBitmapPath", szValue);
            hr = PutWbemInstanceProperty(L"largeAnimatedBitmapName", PathFindFileName(szValue));
        }

        //------------------------------------------------
        // smallAnimatedBitmapPath & smallAnimatedBitmapName
        ZeroMemory(szValue, sizeof(szValue));
        GetInsString(IS_ANIMATION, TEXT("Small_Path"), szValue, countof(szValue), bEnabled);
        if (bEnabled)
        {
            hr = PutWbemInstanceProperty(L"smallAnimatedBitmapPath", szValue);
            hr = PutWbemInstanceProperty(L"smallAnimatedBitmapName", PathFindFileName(szValue));
        }

        //------------------------------------------------
        // customizeLogoBitmaps
        if (InsKeyExists(IS_LARGELOGO, IK_PATH, m_szINSFile) ||
            InsKeyExists(IS_SMALLLOGO, IK_PATH, m_szINSFile))
        {
            // No tri-state on this.  Disabled state has to be NULL!
            hr = PutWbemInstanceProperty(L"customizeLogoBitmaps", true);
        }
        
        //------------------------------------------------
        // largeCustomLogoBitmapPath & largeCustomLogoBitmapName
        ZeroMemory(szValue, sizeof(szValue));
        GetInsString(IS_LARGELOGO, IK_PATH, szValue, countof(szValue), bEnabled);
        if (bEnabled)
        {
            hr = PutWbemInstanceProperty(L"largeCustomLogoBitmapPath", szValue);
            hr = PutWbemInstanceProperty(L"largeCustomLogoBitmapName", PathFindFileName(szValue));
        }

        //------------------------------------------------
        // smallCustomLogoBitmapPath & smallCustomLogoBitmapName
        ZeroMemory(szValue, sizeof(szValue));
        GetInsString(IS_SMALLLOGO, IK_PATH, szValue, countof(szValue), bEnabled);
        if (bEnabled)
        {
            hr = PutWbemInstanceProperty(L"smallCustomLogoBitmapPath", szValue);
            hr = PutWbemInstanceProperty(L"smallCustomLogoBitmapName", PathFindFileName(szValue));
        }
    }
    __except(TRUE)
    {
        OutD(LI0(TEXT("Exception in StoreBitmapData.")));
    }

  return hr;
}

///////////////////////////////////////////////////////////
HRESULT CRSoPGPO::CreateToolbarButtonObjects(BSTR **ppaTBBtnObjPaths,
                                             long &nTBBtnCount)
{
    HRESULT hr = NOERROR;
    __try
    {
        OutD(LI0(TEXT("\r\nEntered CreateToolbarButtonObjects function.")));

        ULONG nTBBtnArraySize = MAX_BTOOLBARS;
        _bstr_t bstrClass = L"RSOP_IEToolbarButton";

        //------------------------------------------------
        // following code taken from btoolbar.cpp in the brandll directory
        BSTR *paTBBtnObjects = (BSTR*)CoTaskMemAlloc(sizeof(BSTR) * nTBBtnArraySize);
        if (NULL != paTBBtnObjects)
        {
            ZeroMemory(paTBBtnObjects, sizeof(BSTR) * nTBBtnArraySize);

            ULONG nButton;
            BSTR *pCurTBBtnObj;
            nTBBtnCount = 0;
            for (nButton=0, pCurTBBtnObj = paTBBtnObjects; nButton < nTBBtnArraySize;
                    nButton++, pCurTBBtnObj += 1)
            {
                TCHAR szBToolbarTextParam[32];
                TCHAR szBToolbarIcoParam[32];
                TCHAR szBToolbarActionParam[32];
                TCHAR szBToolbarHotIcoParam[32];
                TCHAR szBToolbarShowParam[32];
                BTOOLBAR ToolBarInfo;

                wnsprintf(szBToolbarTextParam, ARRAYSIZE(szBToolbarTextParam), TEXT("%s%i"), IK_BTCAPTION, nButton);
                wnsprintf(szBToolbarIcoParam, ARRAYSIZE(szBToolbarIcoParam), TEXT("%s%i"), IK_BTICON, nButton);
                wnsprintf(szBToolbarActionParam, ARRAYSIZE(szBToolbarActionParam), TEXT("%s%i"), IK_BTACTION, nButton);
                wnsprintf(szBToolbarHotIcoParam, ARRAYSIZE(szBToolbarHotIcoParam), TEXT("%s%i"), IK_BTHOTICO, nButton);
                wnsprintf(szBToolbarShowParam, ARRAYSIZE(szBToolbarShowParam), TEXT("%s%i"), IK_BTSHOW, nButton);

                if ( !GetPrivateProfileString(IS_BTOOLBARS, szBToolbarTextParam, TEXT(""),
                            ToolBarInfo.szCaption, ARRAYSIZE(ToolBarInfo.szCaption), m_szINSFile) )
                {
                    break;
                }

                ComPtr<IWbemClassObject> pTBBtnObj = NULL;
                hr = CreateRSOPObject(bstrClass, &pTBBtnObj);
                if (SUCCEEDED(hr))
                {
                    // Write foreign keys from our stored precedence & id fields
                    OutD(LI2(TEXT("Storing property 'rsopPrecedence' in %s, value = %lx"), (BSTR)bstrClass, m_dwPrecedence));
                    hr = PutWbemInstancePropertyEx(L"rsopPrecedence", (long)m_dwPrecedence, pTBBtnObj);

                    OutD(LI2(TEXT("Storing property 'rsopID' in %s, value = %s"), (BSTR)bstrClass, (BSTR)m_bstrID));
                    hr = PutWbemInstancePropertyEx(L"rsopID", m_bstrID, pTBBtnObj);

                    //------------------------------------------------
                    // buttonOrder
                    hr = PutWbemInstancePropertyEx(L"buttonOrder", (long)nButton + 1, pTBBtnObj);

                    //------------------------------------------------
                    // caption
                    hr = PutWbemInstancePropertyEx(L"caption", ToolBarInfo.szCaption, pTBBtnObj);

                    //------------------------------------------------
                    // actionPath
                    GetPrivateProfileString(IS_BTOOLBARS, szBToolbarActionParam, TEXT(""),
                                        ToolBarInfo.szAction, ARRAYSIZE(ToolBarInfo.szAction), m_szINSFile);
                    hr = PutWbemInstancePropertyEx(L"actionPath", ToolBarInfo.szAction, pTBBtnObj);

                    //------------------------------------------------
                    // iconPath
                    GetPrivateProfileString(IS_BTOOLBARS, szBToolbarIcoParam, TEXT(""),
                                        ToolBarInfo.szIcon, ARRAYSIZE(ToolBarInfo.szIcon), m_szINSFile);
                    hr = PutWbemInstancePropertyEx(L"iconPath", ToolBarInfo.szIcon, pTBBtnObj);

                    //------------------------------------------------
                    // hotIconPath
                    GetPrivateProfileString(IS_BTOOLBARS, szBToolbarHotIcoParam, TEXT(""),
                                        ToolBarInfo.szHotIcon, ARRAYSIZE(ToolBarInfo.szHotIcon), m_szINSFile);
                    hr = PutWbemInstancePropertyEx(L"hotIconPath", ToolBarInfo.szHotIcon, pTBBtnObj);

                    //------------------------------------------------
                    // showOnToolbarByDefault
                    ToolBarInfo.fShow = (BOOL)GetPrivateProfileInt(IS_BTOOLBARS, szBToolbarShowParam, 1, m_szINSFile);
                    hr = PutWbemInstancePropertyEx(L"showOnToolbarByDefault",
                                                    ToolBarInfo.fShow ? true : false, pTBBtnObj);


                    //
                    // Commit all above properties by calling PutInstance, semisynchronously
                    //
                    hr = PutWbemInstance(pTBBtnObj, bstrClass, pCurTBBtnObj);
                    nTBBtnCount++;
                }
            }

            // toolbarButtons
            if (nTBBtnCount > 0)
                hr = PutWbemInstanceProperty(L"toolbarButtons", (long)nTBBtnCount);
        }

        *ppaTBBtnObjPaths = paTBBtnObjects;
    }
    __except(TRUE)
    {
        OutD(LI0(TEXT("Exception in CreateToolbarButtonObjects.")));
    }

    OutD(LI0(TEXT("Exiting CreateToolbarButtonObjects function.\r\n")));
  return hr;
}

///////////////////////////////////////////////////////////
HRESULT CRSoPGPO::StoreToolbarButtons(BSTR **ppaTBBtnObjPaths,
                                      long &nTBBtnCount)
{
    HRESULT hr = NOERROR;
    __try
    {
        //------------------------------------------------
        // deleteExistingToolbarButtons
        // No tri-state on this.  Disabled state has to be NULL!
        BOOL bValue = GetInsBool(IS_BTOOLBARS, IK_BTDELETE, FALSE);
        if (bValue)
            hr = PutWbemInstanceProperty(L"deleteExistingToolbarButtons", true);

        CreateToolbarButtonObjects(ppaTBBtnObjPaths, nTBBtnCount);
    }
    __except(TRUE)
    {
        OutD(LI0(TEXT("Exception in StoreToolbarButtons.")));
    }

  return hr;
}

///////////////////////////////////////////////////////////
HRESULT CRSoPGPO::StoreCustomURLs()
{
    HRESULT hr = NOERROR;
    __try
    {
        //------------------------------------------------
        // homePageURL
        TCHAR szValue[MAX_PATH];
        BOOL bEnabled;
        GetInsString(IS_URL, IK_HOMEPAGE, szValue, countof(szValue), bEnabled);
        if (bEnabled)
            hr = PutWbemInstanceProperty(L"homePageURL", szValue);

        //------------------------------------------------
        // searchBarURL
        ZeroMemory(szValue, sizeof(szValue));
        GetInsString(IS_URL, IK_SEARCHPAGE, szValue, countof(szValue), bEnabled);
        if (bEnabled)
            hr = PutWbemInstanceProperty(L"searchBarURL", szValue);

        //------------------------------------------------
        // onlineHelpPageURL
        ZeroMemory(szValue, sizeof(szValue));
        GetInsString(IS_URL, IK_HELPPAGE, szValue, countof(szValue), bEnabled);
        if (bEnabled)
            hr = PutWbemInstanceProperty(L"onlineHelpPageURL", szValue);
    }
    __except(TRUE)
    {
        OutD(LI0(TEXT("Exception in StoreCustomURLs.")));
    }

  return hr;
}

///////////////////////////////////////////////////////////
HRESULT CRSoPGPO::CreateFavoriteObjects(BSTR **ppaFavObjPaths,
                                        long &nFavCount)
{
    HRESULT hr = NOERROR;
    __try
    {
        OutD(LI0(TEXT("\r\nEntered CreateFavoriteObjects function.")));

        ULONG nFavArraySize = 10;
        _bstr_t bstrClass = L"RSOP_IEFavoriteItem";

        //------------------------------------------------
        // Process each favorite item in the INS file
        // following code taken from brandfav.cpp in the brandll directory
        BSTR *paFavObjects = (BSTR*)CoTaskMemAlloc(sizeof(BSTR) * nFavArraySize);
        if (NULL != paFavObjects)
        {
            ZeroMemory(paFavObjects, sizeof(BSTR) * nFavArraySize);

            ULONG nFav;
            BSTR *pCurFavObj;
            nFavCount = 0;
            for (nFav=1, pCurFavObj = paFavObjects; nFav <= nFavArraySize;
                    nFav++, pCurFavObj = paFavObjects + nFavCount)
            {
                TCHAR szTitle[32];
                TCHAR szURL[32];
                TCHAR szIconFile[32];
                TCHAR szOffline[32];

                TCHAR szTitleVal[MAX_PATH];
                TCHAR szURLVal[INTERNET_MAX_URL_LENGTH];
                TCHAR szIconFileVal[MAX_PATH];
                BOOL bOffline = FALSE;

                wnsprintf(szTitle, countof(szTitle), IK_TITLE_FMT, nFav);
                wnsprintf(szURL, countof(szURL), IK_URL_FMT, nFav);
                wnsprintf(szIconFile, countof(szIconFile), IK_ICON_FMT, nFav);
                wnsprintf(szOffline, countof(szOffline), IK_OFFLINE_FMT, nFav);

                if ( !GetPrivateProfileString(IS_FAVORITESEX, szTitle, TEXT(""),
                            szTitleVal, ARRAYSIZE(szTitleVal), m_szINSFile) )
                {
                    break;
                }

                ComPtr<IWbemClassObject> pFavObj = NULL;
                hr = CreateRSOPObject(bstrClass, &pFavObj);
                if (SUCCEEDED(hr))
                {
                    // Write foreign keys from our stored precedence & id fields
                    OutD(LI2(TEXT("Storing property 'rsopPrecedence' in %s, value = %lx"), (BSTR)bstrClass, m_dwPrecedence));
                    hr = PutWbemInstancePropertyEx(L"rsopPrecedence", (long)m_dwPrecedence, pFavObj);

                    OutD(LI2(TEXT("Storing property 'rsopID' in %s, value = %s"), (BSTR)bstrClass, (BSTR)m_bstrID));
                    hr = PutWbemInstancePropertyEx(L"rsopID", m_bstrID, pFavObj);

                    //------------------------------------------------
                    // order
                    hr = PutWbemInstancePropertyEx(L"order", (long)nFav, pFavObj);

                    //------------------------------------------------
                    // name
                    hr = PutWbemInstancePropertyEx(L"name", szTitleVal, pFavObj);

                    //------------------------------------------------
                    // shortName

                    //------------------------------------------------
                    // url
                    GetPrivateProfileString(IS_FAVORITESEX, szURL, TEXT(""),
                                        szURLVal, ARRAYSIZE(szURLVal), m_szINSFile);
                    hr = PutWbemInstancePropertyEx(L"url", szURLVal, pFavObj);

                    //------------------------------------------------
                    // iconPath
                    GetPrivateProfileString(IS_FAVORITESEX, szIconFile, TEXT(""),
                                        szIconFileVal, ARRAYSIZE(szIconFileVal), m_szINSFile);
                    hr = PutWbemInstancePropertyEx(L"iconPath", szIconFileVal, pFavObj);

                    //------------------------------------------------
                    // makeAvailableOffline
                    bOffline = InsGetBool(IS_FAVORITESEX, szOffline, FALSE, m_szINSFile);
                    hr = PutWbemInstancePropertyEx(L"makeAvailableOffline", bOffline ? true : false, pFavObj);

                    //------------------------------------------------
                    // folderItem
                    hr = PutWbemInstancePropertyEx(L"folderItem", false, pFavObj); // no folder items  yet

                    //------------------------------------------------
                    // parentPath


                    //
                    // Commit all above properties by calling PutInstance, semisynchronously
                    //
                    hr = PutWbemInstance(pFavObj, bstrClass, pCurFavObj);
                    nFavCount++;

                    // Grow the array of obj paths if we've outgrown the current array
                    if (nFavCount == (long)nFavArraySize)
                    {
                        paFavObjects = (BSTR*)CoTaskMemRealloc(paFavObjects, sizeof(BSTR) * (nFavArraySize + 5));
                        if (NULL != paFavObjects)
                            nFavArraySize += 5;
                    }
                }
            }

            // customFavorites
            if (nFavCount > 0)
                hr = PutWbemInstanceProperty(L"customFavorites", (long)nFavCount);
        }

        *ppaFavObjPaths = paFavObjects;
    }
    __except(TRUE)
    {
        OutD(LI0(TEXT("Exception in CreateFavoriteObjects.")));
    }

    OutD(LI0(TEXT("Exiting CreateFavoriteObjects function.\r\n")));
  return hr;
}

///////////////////////////////////////////////////////////
HRESULT CRSoPGPO::CreateLinkObjects(BSTR **ppaLinkObjPaths,
                                    long &nLinkCount)
{
    HRESULT hr = NOERROR;
    __try
    {
        OutD(LI0(TEXT("\r\nEntered CreateLinkObjects function.")));

        ULONG nLinkArraySize = 10;
        _bstr_t bstrClass = L"RSOP_IELinkItem";

        //------------------------------------------------
        // Process each link item in the INS file
        // following code taken from brandfav.cpp in the brandll directory
        BSTR *paLinkObjects = (BSTR*)CoTaskMemAlloc(sizeof(BSTR) * nLinkArraySize);
        if (NULL != paLinkObjects)
        {
            ZeroMemory(paLinkObjects, sizeof(BSTR) * nLinkArraySize);

            ULONG nLink;
            BSTR *pCurLinkObj;
            nLinkCount = 0;
            for (nLink=1, pCurLinkObj = paLinkObjects; nLink <= nLinkArraySize;
                    nLink++, pCurLinkObj = paLinkObjects + nLinkCount)
            {
                TCHAR szTitle[32];
                TCHAR szURL[32];
                TCHAR szIconFile[32];
                TCHAR szOffline[32];

                TCHAR szTitleVal[MAX_PATH];
                TCHAR szURLVal[INTERNET_MAX_URL_LENGTH];
                TCHAR szIconFileVal[MAX_PATH];
                BOOL bOffline = FALSE;

                wnsprintf(szTitle, countof(szTitle), IK_QUICKLINK_NAME, nLink);
                wnsprintf(szURL, countof(szURL), IK_QUICKLINK_URL, nLink);
                wnsprintf(szIconFile, countof(szIconFile), IK_QUICKLINK_ICON, nLink);
                wnsprintf(szOffline, countof(szOffline), IK_QUICKLINK_OFFLINE, nLink);

                if ( !GetPrivateProfileString(IS_URL, szTitle, TEXT(""),
                            szTitleVal, ARRAYSIZE(szTitleVal), m_szINSFile) )
                {
                    break;
                }

                ComPtr<IWbemClassObject> pLinkObj = NULL;
                hr = CreateRSOPObject(bstrClass, &pLinkObj);
                if (SUCCEEDED(hr))
                {
                    // Write foreign keys from our stored precedence & id fields
                    OutD(LI2(TEXT("Storing property 'rsopPrecedence' in %s, value = %lx"), (BSTR)bstrClass, m_dwPrecedence));
                    hr = PutWbemInstancePropertyEx(L"rsopPrecedence", (long)m_dwPrecedence, pLinkObj);

                    OutD(LI2(TEXT("Storing property 'rsopID' in %s, value = %s"), (BSTR)bstrClass, (BSTR)m_bstrID));
                    hr = PutWbemInstancePropertyEx(L"rsopID", m_bstrID, pLinkObj);

                    //------------------------------------------------
                    // order
                    hr = PutWbemInstancePropertyEx(L"order", (long)nLink, pLinkObj);

                    //------------------------------------------------
                    // name
                    hr = PutWbemInstancePropertyEx(L"name", szTitleVal, pLinkObj);

                    //------------------------------------------------
                    // url
                    GetPrivateProfileString(IS_URL, szURL, TEXT(""),
                                        szURLVal, ARRAYSIZE(szURLVal), m_szINSFile);
                    hr = PutWbemInstancePropertyEx(L"url", szURLVal, pLinkObj);

                    //------------------------------------------------
                    // iconPath
                    GetPrivateProfileString(IS_URL, szIconFile, TEXT(""),
                                        szIconFileVal, ARRAYSIZE(szIconFileVal), m_szINSFile);
                    hr = PutWbemInstancePropertyEx(L"iconPath", szIconFileVal, pLinkObj);

                    //------------------------------------------------
                    // makeAvailableOffline
                    bOffline = InsGetBool(IS_URL, szOffline, FALSE, m_szINSFile);
                    hr = PutWbemInstancePropertyEx(L"makeAvailableOffline", bOffline ? true : false, pLinkObj);


                    //
                    // Commit all above properties by calling PutInstance, semisynchronously
                    //
                    hr = PutWbemInstance(pLinkObj, bstrClass, pCurLinkObj);
                    nLinkCount++;

                    // Grow the array of obj paths if we've outgrown the current array
                    if (nLinkCount == (long)nLinkArraySize)
                    {
                        paLinkObjects = (BSTR*)CoTaskMemRealloc(paLinkObjects, sizeof(BSTR) * (nLinkArraySize + 5));
                        if (NULL != paLinkObjects)
                            nLinkArraySize += 5;
                    }
                }
            }

            // customLinks
            if (nLinkCount > 0)
                hr = PutWbemInstanceProperty(L"customLinks", (long)nLinkCount);
        }

        *ppaLinkObjPaths = paLinkObjects;
    }
    __except(TRUE)
    {
        OutD(LI0(TEXT("Exception in CreateLinkObjects.")));
    }

    OutD(LI0(TEXT("Exiting CreateLinkObjects function.\r\n")));
  return hr;
}

///////////////////////////////////////////////////////////
HRESULT CRSoPGPO::StoreFavoritesAndLinks(BSTR **ppaFavObjPaths,
                                         long &nFavCount,
                                         BSTR **ppaLinkObjPaths,
                                         long &nLinkCount)
{
    HRESULT hr = NOERROR;
    __try
    {
        //------------------------------------------------
        // placeFavoritesAtTopOfList
        BOOL bEnabled;
        BOOL bValue = GetInsBool(IS_BRANDING, IK_FAVORITES_ONTOP, FALSE, &bEnabled);
        if (bEnabled)
            hr = PutWbemInstanceProperty(L"placeFavoritesAtTopOfList", bValue ? true : false);

        //------------------------------------------------
        // deleteExistingFavorites
        DWORD dwValue = GetInsInt(IS_BRANDING, IK_FAVORITES_DELETE, FD_DEFAULT);
        if (FD_DEFAULT != dwValue)
            hr = PutWbemInstanceProperty(L"deleteExistingFavorites", true);

        //------------------------------------------------
        // deleteAdminCreatedFavoritesOnly
        hr = PutWbemInstanceProperty(L"deleteAdminCreatedFavoritesOnly",
                                        HasFlag(dwValue, FD_REMOVE_IEAK_CREATED));

        //------------------------------------------------
        // customFavorites
        bValue = GetInsBool(IS_BRANDING, IK_NOFAVORITES, FALSE, &bEnabled);
        if (bEnabled)
            hr = PutWbemInstanceProperty(L"customFavorites", (long)0);

        //------------------------------------------------
        // customLinks
        bValue = GetInsBool(IS_BRANDING, IK_NOLINKS, FALSE, &bEnabled);
        if (bEnabled)
            hr = PutWbemInstanceProperty(L"customLinks", (long)0);

        CreateFavoriteObjects(ppaFavObjPaths, nFavCount);
        CreateLinkObjects(ppaLinkObjPaths, nLinkCount);
    }
    __except(TRUE)
    {
        OutD(LI0(TEXT("Exception in StoreFavoritesAndLinks.")));
    }

  return hr;
}

///////////////////////////////////////////////////////////
HRESULT CRSoPGPO::CreateCategoryObjects(BSTR **ppaCatObjPaths,
                                        long &nCatCount)
{
    HRESULT hr = NOERROR;
    __try
    {
        OutD(LI0(TEXT("\r\nEntered CreateCategoryObjects function.")));

        ULONG nCatArraySize = 10;
        _bstr_t bstrClass = L"RSOP_IECategoryItem";

        //------------------------------------------------
        // Process each category item in the INS file
        // following code taken from brandchl.cpp in the brandll directory
        BSTR *paCatObjects = (BSTR*)CoTaskMemAlloc(sizeof(BSTR) * nCatArraySize);
        if (NULL != paCatObjects)
        {
            ZeroMemory(paCatObjects, sizeof(BSTR) * nCatArraySize);

            ULONG nCat;
            BSTR *pCurCatObj;
            nCatCount = 0;
            for (nCat=0, pCurCatObj = paCatObjects; nCat < nCatArraySize;
                    nCat++, pCurCatObj = paCatObjects + nCatCount)
            {
                TCHAR szTitle[32];
                TCHAR szHTML[32];
                TCHAR szBmpPath[32];
                TCHAR szIconPath[32];

                TCHAR szTitleVal[MAX_PATH];
                TCHAR szHTMLVal[INTERNET_MAX_URL_LENGTH];
                TCHAR szBmpPathVal[MAX_PATH];
                TCHAR szIconPathVal[MAX_PATH];

                wnsprintf(szTitle, countof(szTitle), TEXT("%s%u"), IK_CAT_TITLE, nCat);
                wnsprintf(szHTML, countof(szHTML), TEXT("%s%u"), CATHTML, nCat);
                wnsprintf(szBmpPath, countof(szBmpPath), TEXT("%s%u"), CATBMP, nCat);
                wnsprintf(szIconPath, countof(szIconPath), TEXT("%s%u"), CATICON, nCat);


                if ( !GetPrivateProfileString(IS_CHANNEL_ADD, szTitle, TEXT(""),
                            szTitleVal, ARRAYSIZE(szTitleVal), m_szINSFile) )
                {
                    break;
                }

                ComPtr<IWbemClassObject> pCatObj = NULL;
                hr = CreateRSOPObject(bstrClass, &pCatObj);
                if (SUCCEEDED(hr))
                {
                    // Write foreign keys from our stored precedence & id fields
                    OutD(LI2(TEXT("Storing property 'rsopPrecedence' in %s, value = %lx"), (BSTR)bstrClass, m_dwPrecedence));
                    hr = PutWbemInstancePropertyEx(L"rsopPrecedence", (long)m_dwPrecedence, pCatObj);

                    OutD(LI2(TEXT("Storing property 'rsopID' in %s, value = %s"), (BSTR)bstrClass, (BSTR)m_bstrID));
                    hr = PutWbemInstancePropertyEx(L"rsopID", m_bstrID, pCatObj);

                    //------------------------------------------------
                    // order
                    hr = PutWbemInstancePropertyEx(L"order", (long)nCat + 1, pCatObj);

                    //------------------------------------------------
                    // title
                    hr = PutWbemInstancePropertyEx(L"title", szTitleVal, pCatObj);

                    //------------------------------------------------
                    // categoryHTMLPage
                    GetPrivateProfileString(IS_CHANNEL_ADD, szHTML, TEXT(""),
                                        szHTMLVal, ARRAYSIZE(szHTMLVal), m_szINSFile);
                    hr = PutWbemInstancePropertyEx(L"categoryHTMLPage", szHTMLVal, pCatObj);

                    //------------------------------------------------
                    // narrowImagePath
                    GetPrivateProfileString(IS_CHANNEL_ADD, szBmpPath, TEXT(""),
                                        szBmpPathVal, ARRAYSIZE(szBmpPathVal), m_szINSFile);
                    hr = PutWbemInstancePropertyEx(L"narrowImagePath", szBmpPathVal, pCatObj);

                    //------------------------------------------------
                    // narrowImageName
                    hr = PutWbemInstancePropertyEx(L"narrowImageName", PathFindFileName(szBmpPathVal), pCatObj);

                    //------------------------------------------------
                    // iconPath
                    GetPrivateProfileString(IS_CHANNEL_ADD, szIconPath, TEXT(""),
                                        szIconPathVal, ARRAYSIZE(szIconPathVal), m_szINSFile);
                    hr = PutWbemInstancePropertyEx(L"iconPath", szIconPathVal, pCatObj);

                    //------------------------------------------------
                    // iconName
                    hr = PutWbemInstancePropertyEx(L"iconName", PathFindFileName(szIconPathVal), pCatObj);


                    //
                    // Commit all above properties by calling PutInstance, semisynchronously
                    //
                    hr = PutWbemInstance(pCatObj, bstrClass, pCurCatObj);
                    nCatCount++;

                    // Grow the array of obj paths if we've outgrown the current array
                    if (nCatCount == (long)nCatArraySize)
                    {
                        paCatObjects = (BSTR*)CoTaskMemRealloc(paCatObjects, sizeof(BSTR) * (nCatArraySize + 5));
                        if (NULL != paCatObjects)
                            nCatArraySize += 5;
                    }
                }
            }

            // categories
            if (nCatCount > 0)
                hr = PutWbemInstanceProperty(L"categories", (long)nCatCount);
        }

        *ppaCatObjPaths = paCatObjects;
    }
    __except(TRUE)
    {
        OutD(LI0(TEXT("Exception in CreateCategoryObjects.")));
    }

    OutD(LI0(TEXT("Exiting CreateCategoryObjects function.\r\n")));
  return hr;
}

///////////////////////////////////////////////////////////
HRESULT CRSoPGPO::CreateChannelObjects(BSTR **ppaChnObjPaths,
                                       long &nChnCount)
{
    HRESULT hr = NOERROR;
    __try
    {
        OutD(LI0(TEXT("\r\nEntered CreateChannelObjects function.")));

        ULONG nChnArraySize = 10;
        _bstr_t bstrClass = L"RSOP_IEChannelItem";

        //------------------------------------------------
        // Process each channel item in the INS file
        // following code taken from brandchl.cpp in the brandll directory
        BSTR *paChnObjects = (BSTR*)CoTaskMemAlloc(sizeof(BSTR) * nChnArraySize);
        if (NULL != paChnObjects)
        {
            ZeroMemory(paChnObjects, sizeof(BSTR) * nChnArraySize);

            ULONG nChn;
            BSTR *pCurChnObj;
            nChnCount = 0;
            for (nChn=0, pCurChnObj = paChnObjects; nChn < nChnArraySize;
                    nChn++, pCurChnObj = paChnObjects + nChnCount )
            {
                TCHAR szTitle[32];
                TCHAR szURL[32];
                TCHAR szPreloadURL[32];
                TCHAR szBmpPath[32];
                TCHAR szIconPath[32];
                TCHAR szAvailOffline[32];

                TCHAR szTitleVal[MAX_PATH];
                TCHAR szURLVal[INTERNET_MAX_URL_LENGTH];
                TCHAR szPreloadURLVal[MAX_PATH];
                TCHAR szBmpPathVal[MAX_PATH];
                TCHAR szIconPathVal[MAX_PATH];
                BOOL bOffline = FALSE;

                wnsprintf(szTitle, countof(szTitle), TEXT("%s%u"), IK_CHL_TITLE, nChn);
                wnsprintf(szURL, countof(szURL), TEXT("%s%u"), IK_CHL_URL, nChn);
                wnsprintf(szPreloadURL, countof(szPreloadURL), TEXT("%s%u"), IK_CHL_PRELOADURL, nChn);
                wnsprintf(szBmpPath, countof(szBmpPath), TEXT("%s%u"), CHBMP, nChn);
                wnsprintf(szIconPath, countof(szIconPath), TEXT("%s%u"), CHICON, nChn);
                wnsprintf(szAvailOffline, countof(szAvailOffline), TEXT("%s%u"), IK_CHL_OFFLINE, nChn);

                if ( !GetPrivateProfileString(IS_CHANNEL_ADD, szTitle, TEXT(""),
                            szTitleVal, ARRAYSIZE(szTitleVal), m_szINSFile) )
                {
                    break;
                }

                ComPtr<IWbemClassObject> pChnObj = NULL;
                hr = CreateRSOPObject(bstrClass, &pChnObj);
                if (SUCCEEDED(hr))
                {
                    // Write foreign keys from our stored precedence & id fields
                    OutD(LI2(TEXT("Storing property 'rsopPrecedence' in %s, value = %lx"), (BSTR)bstrClass, m_dwPrecedence));
                    hr = PutWbemInstancePropertyEx(L"rsopPrecedence", (long)m_dwPrecedence, pChnObj);

                    OutD(LI2(TEXT("Storing property 'rsopID' in %s, value = %s"), (BSTR)bstrClass, (BSTR)m_bstrID));
                    hr = PutWbemInstancePropertyEx(L"rsopID", m_bstrID, pChnObj);

                    //------------------------------------------------
                    // order
                    hr = PutWbemInstancePropertyEx(L"order", (long)nChn + 1, pChnObj);

                    //------------------------------------------------
                    // title
                    hr = PutWbemInstancePropertyEx(L"title", szTitleVal, pChnObj);

                    //------------------------------------------------
                    // channelDefinitionURL
                    GetPrivateProfileString(IS_CHANNEL_ADD, szURL, TEXT(""),
                                        szURLVal, ARRAYSIZE(szURLVal), m_szINSFile);
                    hr = PutWbemInstancePropertyEx(L"channelDefinitionURL", szURLVal, pChnObj);

                    //------------------------------------------------
                    // channelDefinitionFilePath
                    GetPrivateProfileString(IS_CHANNEL_ADD, szPreloadURL, TEXT(""),
                                        szPreloadURLVal, ARRAYSIZE(szPreloadURLVal), m_szINSFile);
                    hr = PutWbemInstancePropertyEx(L"channelDefinitionFilePath", szPreloadURLVal, pChnObj);

                    //------------------------------------------------
                    // narrowImagePath
                    GetPrivateProfileString(IS_CHANNEL_ADD, szBmpPath, TEXT(""),
                                        szBmpPathVal, ARRAYSIZE(szBmpPathVal), m_szINSFile);
                    hr = PutWbemInstancePropertyEx(L"narrowImagePath", szBmpPathVal, pChnObj);

                    //------------------------------------------------
                    // narrowImageName
                    hr = PutWbemInstancePropertyEx(L"narrowImageName", PathFindFileName(szBmpPathVal), pChnObj);

                    //------------------------------------------------
                    // iconPath
                    GetPrivateProfileString(IS_CHANNEL_ADD, szIconPath, TEXT(""),
                                        szIconPathVal, ARRAYSIZE(szIconPathVal), m_szINSFile);
                    hr = PutWbemInstancePropertyEx(L"iconPath", szIconPathVal, pChnObj);

                    //------------------------------------------------
                    // iconName
                    hr = PutWbemInstancePropertyEx(L"iconName", PathFindFileName(szIconPathVal), pChnObj);

                    //------------------------------------------------
                    // makeAvailableOffline
                    bOffline = GetInsBool(IS_CHANNEL_ADD, szAvailOffline, FALSE);
                    hr = PutWbemInstancePropertyEx(L"makeAvailableOffline", bOffline ? true : false, pChnObj);

                    //
                    // Commit all above properties by calling PutInstance, semisynchronously
                    //
                    hr = PutWbemInstance(pChnObj, bstrClass, pCurChnObj);
                    nChnCount++;

                    // Grow the array of obj paths if we've outgrown the current array
                    if (nChnCount == (long)nChnArraySize)
                    {
                        paChnObjects = (BSTR*)CoTaskMemRealloc(paChnObjects, sizeof(BSTR) * (nChnArraySize + 5));
                        if (NULL != paChnObjects)
                            nChnArraySize += 5;
                    }
                }
            }

            // channels
            if (nChnCount > 0)
                hr = PutWbemInstanceProperty(L"channels", (long)nChnCount);
        }

        *ppaChnObjPaths = paChnObjects;
    }
    __except(TRUE)
    {
        OutD(LI0(TEXT("Exception in CreateChannelObjects.")));
    }

    OutD(LI0(TEXT("Exiting CreateChannelObjects function.\r\n")));
  return hr;
}

///////////////////////////////////////////////////////////
HRESULT CRSoPGPO::StoreChannelsAndCategories(BSTR **ppaCatObjPaths,
                                             long &nCatCount,
                                             BSTR **ppaChnObjPaths,
                                             long &nChnCount)
{
    HRESULT hr = NOERROR;
    __try
    {
        //------------------------------------------------
        // deleteExistingChannels
        BOOL bEnabled;
        BOOL bValue = GetInsBool(IS_DESKTOPOBJS, IK_DELETECHANNELS, FALSE, &bEnabled);
        if (bEnabled)
            hr = PutWbemInstanceProperty(L"deleteExistingChannels", bValue ? true : false);

        //------------------------------------------------
        // enableDesktopChannelBarByDefault
        bValue = GetInsBool(IS_DESKTOPOBJS, IK_SHOWCHLBAR, FALSE, &bEnabled);
        if (bEnabled)
            hr = PutWbemInstanceProperty(L"enableDesktopChannelBarByDefault", bValue ? true : false);

        hr = CreateCategoryObjects(ppaCatObjPaths, nCatCount);
        hr = CreateChannelObjects(ppaChnObjPaths, nChnCount);
    }
    __except(TRUE)
    {
        OutD(LI0(TEXT("Exception in StoreChannelsAndCategories.")));
    }

  return hr;
}

//static const TCHAR c_szSzType[]     = TEXT("%s,\"%s\",%s,,\"%s\"");
//static const TCHAR c_szDwordType[]  = TEXT("%s,\"%s\",%s,0x10001");
//static const TCHAR c_szBinaryType[] = TEXT("%s,\"%s\",%s,1");

#define IS_PROGRAMS_INF        TEXT("PROGRAMS.INF")

///////////////////////////////////////////////////////////
HRESULT CRSoPGPO::StoreProgramSettings(BSTR *pbstrProgramSettingsObjPath)
{
    HRESULT hr = NOERROR;
    __try
    {
        OutD(LI0(TEXT("\r\nEntered StoreProgramSettings function.")));

        //------------------------------------------------
        // importProgramSettings
        BOOL bImportSettings = !InsIsKeyEmpty(IS_EXTREGINF, IK_PROGRAMS, m_szINSFile);
        OutD(LI1(TEXT("Value read from INS >> ExtRegInf >> Programs = %s."),
                    bImportSettings ? _T("Valid Settings") : _T("Empty")));

        if (bImportSettings)
            hr = PutWbemInstanceProperty(L"importProgramSettings", true);

        if (bImportSettings) // only create the program settings class if they are marked to be imported
        {
            //
            // Create & populate RSOP_IEProgramSettings
            //
            _bstr_t bstrClass = L"RSOP_IEProgramSettings";
            ComPtr<IWbemClassObject> pPSObj = NULL;
            hr = CreateRSOPObject(bstrClass, &pPSObj);
            if (SUCCEEDED(hr))
            {
                // Write foreign keys from our stored precedence & id fields
                OutD(LI2(TEXT("Storing property 'rsopPrecedence' in %s, value = %lx"), (BSTR)bstrClass, m_dwPrecedence));
                hr = PutWbemInstancePropertyEx(L"rsopPrecedence", (long)m_dwPrecedence, pPSObj);

                OutD(LI2(TEXT("Storing property 'rsopID' in %s, value = %s"), (BSTR)bstrClass, (BSTR)m_bstrID));
                hr = PutWbemInstancePropertyEx(L"rsopID", m_bstrID, pPSObj);

                // Get the path of the programs.inf file
                TCHAR szINFFile[MAX_PATH];
                StrCpy(szINFFile, m_szINSFile);
                PathRemoveFileSpec(szINFFile);
                StrCat(szINFFile, TEXT("\\programs.inf"));
                OutD(LI1(TEXT("Reading from %s"), szINFFile));

                // Get the AddReg.Hklm section for the majority of the strings we'll need.
                UINT nErrLine = 0;
                HINF hInfPrograms = SetupOpenInfFile(szINFFile, NULL, INF_STYLE_WIN4, &nErrLine);
                if (INVALID_HANDLE_VALUE != hInfPrograms)
                {
                    INFCONTEXT infContext;
                    BOOL bFound = TRUE;
                    BOOL bFindNextLine = TRUE;
                    // AddReg.Hklm section
                    if (SetupFindFirstLine(hInfPrograms, IS_IEAKADDREG_HKLM, NULL, &infContext))
                    {
                        //------------------------------------------------
                        // calendarProgram

                        TCHAR szValue[MAX_PATH];
                        bFound = GetINFStringField(&infContext, IS_PROGRAMS_INF,
                                                        IS_IEAKADDREG_HKLM, 5, TEXT("Software\\Clients\\Calendar"),
                                                        szValue, sizeof(szValue)/sizeof(TCHAR), bFindNextLine);
                        if (bFound)
                            hr = PutWbemInstancePropertyEx(L"calendarProgram", szValue, pPSObj);

                        //------------------------------------------------
                        // contactListProgram
                        if (bFindNextLine)
                        {
                            ZeroMemory(szValue, sizeof(szValue));
                            bFound = GetINFStringField(&infContext, IS_PROGRAMS_INF,
                                                            IS_IEAKADDREG_HKLM, 5, TEXT("Software\\Clients\\Contacts"),
                                                            szValue, sizeof(szValue)/sizeof(TCHAR), bFindNextLine);
                            if (bFound)
                                hr = PutWbemInstancePropertyEx(L"contactListProgram", szValue, pPSObj);
                        }

                        //------------------------------------------------
                        // internetCallProgram
                        if (bFindNextLine)
                        {
                            ZeroMemory(szValue, sizeof(szValue));
                            bFound = GetINFStringField(&infContext, IS_PROGRAMS_INF,
                                                            IS_IEAKADDREG_HKLM, 5, TEXT("Software\\Clients\\Internet Call"),
                                                            szValue, sizeof(szValue)/sizeof(TCHAR), bFindNextLine);
                            if (bFound)
                                hr = PutWbemInstancePropertyEx(L"internetCallProgram", szValue, pPSObj);
                        }

                        //------------------------------------------------
                        // emailProgram
                        if (bFindNextLine)
                        {
                            ZeroMemory(szValue, sizeof(szValue));
                            bFound = GetINFStringField(&infContext, IS_PROGRAMS_INF,
                                                            IS_IEAKADDREG_HKLM, 5, TEXT("Software\\Clients\\Mail"),
                                                            szValue, sizeof(szValue)/sizeof(TCHAR), bFindNextLine);
                            if (bFound)
                                hr = PutWbemInstancePropertyEx(L"emailProgram", szValue, pPSObj);
                        }

                        //------------------------------------------------
                        // newsgroupsProgram
                        if (bFindNextLine)
                        {
                            ZeroMemory(szValue, sizeof(szValue));
                            bFound = GetINFStringField(&infContext, IS_PROGRAMS_INF,
                                                            IS_IEAKADDREG_HKLM, 5, TEXT("Software\\Clients\\News"),
                                                            szValue, sizeof(szValue)/sizeof(TCHAR), bFindNextLine);
                            if (bFound)
                                hr = PutWbemInstancePropertyEx(L"newsgroupsProgram", szValue, pPSObj);
                        }

                        //------------------------------------------------
                        // htmlEditorHKLMRegData
                        _bstr_t bstrPropVal = L"";
                        while (bFindNextLine)
                        {
                            ZeroMemory(szValue, sizeof(szValue));
                            bFound = GetINFStringField(&infContext, IS_PROGRAMS_INF,
                                                            IS_IEAKADDREG_HKLM, (DWORD)-1, NULL,
                                                            szValue, sizeof(szValue)/sizeof(TCHAR), bFindNextLine);
                            if (bFound)
                            {
                                if (bstrPropVal.length() > 0)
                                    bstrPropVal += L"\r\n";
                                bstrPropVal += szValue;
                            }

                            if (!bFound || !bFindNextLine)
                            {
                                if (bstrPropVal.length() > 0)
                                    hr = PutWbemInstancePropertyEx(L"htmlEditorHKLMRegData", bstrPropVal, pPSObj);
                                break;
                            }
                        }
                    }
                    else
                    {
                        // No lines found under this section, so don't bother looking for any more
                    }

                    // AddReg.Hkcu section
                    if (SetupFindFirstLine(hInfPrograms, IS_IEAKADDREG_HKCU, NULL, &infContext))
                    {
                        //------------------------------------------------
                        // checkIfIEIsDefaultBrowser
                        TCHAR szValue[MAX_PATH];
                        bFindNextLine = TRUE;
                        bFound = GetINFStringField(&infContext, IS_PROGRAMS_INF,
                                                        IS_IEAKADDREG_HKCU, 5, TEXT("Check_Associations"),
                                                        szValue, sizeof(szValue)/sizeof(TCHAR), bFindNextLine);
                        if (bFound)
                        {
                            hr = PutWbemInstancePropertyEx(L"checkIfIEIsDefaultBrowser",
                                                        StrCmp(TEXT("yes"), szValue) ? false : true, pPSObj);
                        }

                        //------------------------------------------------
                        // htmlEditorProgram
                        if (bFindNextLine)
                        {
                            ZeroMemory(szValue, sizeof(szValue));
                            bFindNextLine = FALSE; // this line must be stored twice
                            bFound = GetINFStringField(&infContext, IS_PROGRAMS_INF, IS_IEAKADDREG_HKCU, 5,
                                                            RK_HTMLEDIT TEXT(",Description"), szValue,
                                                            sizeof(szValue)/sizeof(TCHAR), bFindNextLine);
                            if (bFound)
                                hr = PutWbemInstancePropertyEx(L"htmlEditorProgram", szValue, pPSObj);

                            bFindNextLine = TRUE;
                        }

                        //------------------------------------------------
                        // htmlEditorHKCURegData
                        _bstr_t bstrPropVal = L"";
                        while (bFindNextLine)
                        {
                            ZeroMemory(szValue, sizeof(szValue));
                            bFound = GetINFStringField(&infContext, IS_PROGRAMS_INF,
                                                            IS_IEAKADDREG_HKCU, (DWORD)-1, NULL,
                                                            szValue, sizeof(szValue)/sizeof(TCHAR), bFindNextLine);
                            if (bFound)
                            {
                                if (bstrPropVal.length() > 0)
                                    bstrPropVal += L"\r\n";
                                bstrPropVal += szValue;
                            }

                            if (!bFound || !bFindNextLine)
                            {
                                if (bstrPropVal.length() > 0)
                                    hr = PutWbemInstancePropertyEx(L"htmlEditorHKCURegData", bstrPropVal, pPSObj);
                                break;
                            }
                        }
                    }
                    else
                    {
                        // No lines found under this section, so don't bother looking for any more
                    }

                    SetupCloseInfFile(hInfPrograms);
                }
                else
                {
                    // Programs.INF file not found - fill out an empty object
                }

                //
                // Commit all above properties by calling PutInstance, semisynchronously
                //
                hr = PutWbemInstance(pPSObj, bstrClass, pbstrProgramSettingsObjPath);
            }
        }
    }
    __except(TRUE)
    {
        OutD(LI0(TEXT("Exception in StoreProgramSettings.")));
    }

    OutD(LI0(TEXT("Exiting StoreProgramSettings function.\r\n")));
  return hr;
}

///////////////////////////////////////////////////////////
//  LogPolicyInstance()
//
//  Purpose:    Logs an instance of IEAK RSoP policy. Will be called from
//                            ProcessGroupPolicyEx and GenerateGroupPolicy to log Rsop data
//                            for the IEAK RSoP CSE.
//
//  Parameters: wszGPO - GPO ID obtained from PGROUP_POLICY_OBJECT->lpDSPath
//              wszSOM - SOM ID obtained from PGROUP_POLICY_OBJECT->lpLink
//              dwPrecedence - Precedence order for this policy instance
//
//  Returns:    HRESULT
///////////////////////////////////////////////////////////
HRESULT CRSoPGPO::LogPolicyInstance(LPWSTR wszGPO, 
                                    LPWSTR wszSOM,
                                    DWORD dwPrecedence)
{
    MACRO_LI_PrologEx_C(PIF_STD_C, LogPolicyInstance)

    HRESULT hr = NOERROR;
    __try
    {
        OutD(LI1(TEXT("Entered LogPolicyInstance, m_pWbemServices is %lx."), m_pWbemServices));

        // get or create the class instance for the main IEAK RSoP class(es)
        _bstr_t bstrClass = L"RSOP_IEAKPolicySetting";
        hr = CreateRSOPObject(bstrClass, &m_pIEAKPSObj, TRUE);

        // First log CSE-specific properties - parent class,
        // i.e. RSOP_PolicyObject properties. For GPOID and SOMID fields,  
        // use the data in the fields PGROUP_POLICY_OBJECT->lpDSPath and 
        // PGROUP_POLICY_OBJECT->lpLink fields respectively. Also, the LDAP://CN=Machine
        // or LDAP:// needs to be removed from the prefix of lpDSPath and lpLink
        // to get the canonical values. Code for StripPrefix, StripLinkPrefix is given
        // below.

        // Precedence is determined by CSE to indicate winning Vs. losing policies
        if (SUCCEEDED(hr))
        {
            m_dwPrecedence = dwPrecedence;
            OutD(LI1(TEXT("Storing property 'precedence' in RSOP_IEAKPolicySetting, value = %lx"), dwPrecedence));
            hr = PutWbemInstanceProperty(L"precedence", (long)dwPrecedence);

            OutD(LI1(TEXT("Storing property 'GPOID' in RSOP_IEAKPolicySetting, value = %s"), wszGPO));
            hr = PutWbemInstanceProperty(L"GPOID", wszGPO);

            OutD(LI1(TEXT("Storing property 'SOMID' in RSOP_IEAKPolicySetting, value = %s"), wszSOM));
            hr = PutWbemInstanceProperty(L"SOMID", wszSOM);

            OutD(LI1(TEXT("Storing property 'id' in RSOP_IEAKPolicySetting, value = %s"), (BSTR)m_bstrID));
            hr = PutWbemInstanceProperty(L"id", m_bstrID);

            // ----- Now log IEAK-custom settings to WMI
            // Precedence Mode settings
            hr = StorePrecedenceModeData();

            // Browser UI settings
            hr = StoreDisplayedText();
            hr = StoreBitmapData();

            BSTR *paTBBtnObjects = NULL;
            long nTBBtnCount = 0;
            hr = StoreToolbarButtons(&paTBBtnObjects, nTBBtnCount);

            // Connection settings
            BSTR bstrConnSettingsObjPath = NULL;

            BSTR *paDUSObjects = NULL;
            BSTR *paDUCObjects = NULL;
            BSTR *paWSObjects = NULL;
            long nDUSCount = 0;
            long nDUCCount = 0;
            long nWSCount = 0;

            hr = StoreConnectionSettings(&bstrConnSettingsObjPath,
                                        &paDUSObjects, nDUSCount,
                                        &paDUCObjects, nDUCCount,
                                        &paWSObjects, nWSCount);

            // URL settings
            hr = StoreCustomURLs();

                    // favorites & links
            BSTR *paFavObjects = NULL;
            BSTR *paLinkObjects = NULL;
            long nFavCount = 0;
            long nLinkCount = 0;
            hr = StoreFavoritesAndLinks(&paFavObjects, nFavCount,
                                        &paLinkObjects, nLinkCount);

                    // channels & categories
//            BSTR *paCatObjects = NULL;
//            BSTR *paChnObjects = NULL;
//            long nCatCount = 0;
//            long nChnCount = 0;
//            hr = StoreChannelsAndCategories(&paCatObjects, nCatCount,
//                                            &paChnObjects, nChnCount);

            // Security settings
            hr = StoreSecZonesAndContentRatings();
            hr = StoreAuthenticodeSettings();

            // Program settings
            BSTR bstrProgramSettingsObjPath = NULL;
            hr = StoreProgramSettings(&bstrProgramSettingsObjPath);

            // Advanced settings
            hr = StoreADMSettings(wszGPO, wszSOM);
            // -----

            //
            // Commit all above properties by calling PutInstance - semisynchronously
            //
            hr = PutWbemInstance(m_pIEAKPSObj, bstrClass, &m_bstrIEAKPSObjPath);
            if (FAILED(hr))
                Out(LI2(TEXT("Error %lx saving %s instance data."), hr, (BSTR)bstrClass));


            //
            // Now create the association classes to connect the main RSOP_IEAKPolicySetting
            // class with all other classes such as connection settings, toolbar bitmaps, etc.
            //

            // Connection settings associations
            if (NULL != bstrConnSettingsObjPath)
            {
                if (SysStringLen(bstrConnSettingsObjPath))
                {
                    hr = CreateAssociation(L"RSOP_IEConnectionSettingsLink", L"connectionSettings",
                                                                    bstrConnSettingsObjPath);
                    SysFreeString(bstrConnSettingsObjPath);
                }
            }

            // Dial-up Settings associations
            BSTR *pbstrObjPath;
            long nItem;
            for (nItem = 0, pbstrObjPath = paDUSObjects; nItem < nDUSCount;
                    nItem++, pbstrObjPath += 1)
            {
                if (SysStringLen(*pbstrObjPath))
                {
                    hr = CreateAssociation(L"RSOP_IEConnectionDialUpSettingsLink", L"dialUpSettings",
                                            *pbstrObjPath);
                    SysFreeString(*pbstrObjPath);
                }
            }
            CoTaskMemFree(paDUSObjects);

            // Dial-up Credentials associations
            for (nItem = 0, pbstrObjPath = paDUCObjects; nItem < nDUCCount;
                    nItem++, pbstrObjPath += 1)
            {
                if (SysStringLen(*pbstrObjPath))
                {
                    hr = CreateAssociation(L"RSOP_IEConnectionDialUpCredentialsLink", L"dialUpCredentials",
                                            *pbstrObjPath);
                    SysFreeString(*pbstrObjPath);
                }
            }
            CoTaskMemFree(paDUCObjects);

            // WinINet associations
            for (nItem = 0, pbstrObjPath = paWSObjects; nItem < nWSCount;
                    nItem++, pbstrObjPath += 1)
            {
                if (SysStringLen(*pbstrObjPath))
                {
                    hr = CreateAssociation(L"RSOP_IEConnectionWinINetSettingsLink", L"winINetSettings",
                                            *pbstrObjPath);
                    SysFreeString(*pbstrObjPath);
                }
            }
            CoTaskMemFree(paWSObjects);
            

            // Toolbar button associations
            for (nItem = 0, pbstrObjPath = paTBBtnObjects; nItem < nTBBtnCount;
                    nItem++, pbstrObjPath += 1)
            {
                if (SysStringLen(*pbstrObjPath))
                {
                    hr = CreateAssociation(L"RSOP_IEToolbarButtonLink", L"toolbarButton",
                                                                    *pbstrObjPath);
                    SysFreeString(*pbstrObjPath);
                }
            }
            CoTaskMemFree(paTBBtnObjects);

            // Favorites associations
            for (nItem = 0, pbstrObjPath = paFavObjects; nItem < nFavCount;
                    nItem++, pbstrObjPath += 1)
            {
                if (SysStringLen(*pbstrObjPath))
                {
                    hr = CreateAssociation(L"RSOP_IEFavoriteItemLink", L"favoriteItem",
                                                                    *pbstrObjPath);
                    SysFreeString(*pbstrObjPath);
                }
            }
            CoTaskMemFree(paFavObjects);

            // Links associations
            for (nItem = 0, pbstrObjPath = paLinkObjects; nItem < nLinkCount;
                    nItem++, pbstrObjPath += 1)
            {
                if (SysStringLen(*pbstrObjPath))
                {
                    hr = CreateAssociation(L"RSOP_IELinkItemLink", L"linkItem",
                                                                    *pbstrObjPath);
                    SysFreeString(*pbstrObjPath);
                }
            }
            CoTaskMemFree(paLinkObjects);

            // Categories associations
//            for (nItem = 0, pbstrObjPath = paCatObjects; nItem < nCatCount;
//                    nItem++, pbstrObjPath += sizeof(BSTR))
//            {
//                hr = CreateAssociation(L"RSOP_IECategoryItemLink", L"categoryItem",
//                                                                *pbstrObjPath);
//                SysFreeString(*pbstrObjPath);
//            }
//            CoTaskMemFree(paCatObjects);

            // Channels associations
//            for (nItem = 0, pbstrObjPath = paChnObjects; nItem < nChnCount;
//                    nItem++, pbstrObjPath += sizeof(BSTR))
//            {
//                hr = CreateAssociation(L"RSOP_IEChannelItemLink", L"channelItem",
//                                                                *pbstrObjPath);
//                SysFreeString(*pbstrObjPath);
//            }
//            CoTaskMemFree(paChnObjects);

            // Program Settings association
            if (NULL != bstrProgramSettingsObjPath)
            {
                hr = CreateAssociation(L"RSOP_IEImportedProgramSettings", L"programSettings",
                                                                bstrProgramSettingsObjPath);
                SysFreeString(bstrProgramSettingsObjPath);
            }

            m_pIEAKPSObj = NULL;
        }
    }
    __except(TRUE)
    {
        OutD(LI0(TEXT("Exception in LogPolicyInstance.")));
    }

    OutD(LI1(TEXT("Exited LogPolicyInstance with result of %lx."), hr));
    return hr;
}

///////////////////////////////////////////////////////////
//  StripGPOPrefix()
//
//  Purpose:    Strips out prefix to get canonical path to GPO
//
//  Parameters: wszPath     - DS path to GPO
//
//  Returns:    Pointer to suffix
///////////////////////////////////////////////////////////
WCHAR *StripGPOPrefix(WCHAR *wszPath)
{
    WCHAR *wszPathSuffix = NULL;
    __try
    {
        WCHAR wszMachPrefix[] = L"LDAP://CN=Machine,";
        INT iMachPrefixLen = (INT)wcslen(wszMachPrefix);
        WCHAR wszUserPrefix[] = L"LDAP://CN=User,";
        INT iUserPrefixLen = (INT)wcslen(wszUserPrefix);

        //
        // Strip out prefix to get the canonical path to GPO
        //

        if (CSTR_EQUAL == CompareStringW(LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                                        wszPath, iUserPrefixLen, wszUserPrefix,
                                        iUserPrefixLen))
        {
          wszPathSuffix = wszPath + iUserPrefixLen;
        }
        else if (CSTR_EQUAL == CompareStringW(LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                                                wszPath, iMachPrefixLen, wszMachPrefix,
                                                iMachPrefixLen))
        {
          wszPathSuffix = wszPath + iMachPrefixLen;
        }
        else
            wszPathSuffix = wszPath;
    }
    __except(TRUE)
    {
        OutD(LI0(TEXT("Exception in StripGPOPrefix.")));
    }
    return wszPathSuffix;
}

///////////////////////////////////////////////////////////
//
//  StripSOMPrefix()
//
//  Purpose:    Strips out prefix to get canonical path to SOM
//              object
//
//  Parameters: wszPath - path to SOM to strip
//
//  Returns:    Pointer to suffix
//
///////////////////////////////////////////////////////////
WCHAR *StripSOMPrefix(WCHAR *wszPath)
{
    WCHAR *wszPathSuffix = NULL;
    __try
    {
        WCHAR wszPrefix[] = L"LDAP://";
        INT iPrefixLen = (INT)wcslen(wszPrefix);

        // Strip out prefix to get the canonical path to SOM
        if (wcslen(wszPath) > (DWORD)iPrefixLen)
        {
            if (CSTR_EQUAL == CompareStringW(LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                                            wszPath, iPrefixLen, wszPrefix, iPrefixLen))
            {
                wszPathSuffix = wszPath + iPrefixLen;
            }
            else
                wszPathSuffix = wszPath;
        }
        else
            wszPathSuffix = wszPath;
    }
    __except(TRUE)
    {
        OutD(LI0(TEXT("Exception in StripSOMPrefix.")));
    }

    return wszPathSuffix;
}

///////////////////////////////////////////////////////////////////////////////
// CRSoPUpdate CLASS
///////////////////////////////////////////////////////////////////////////////
CRSoPUpdate::CRSoPUpdate(ComPtr<IWbemServices> pWbemServices, LPCTSTR szCustomDir):
    m_pWbemServices(pWbemServices)
{
    MACRO_LI_PrologEx_C(PIF_STD_C, CRSoPUpdate)
    __try
    {
        StrCpy(m_szCustomDir, szCustomDir);
    }
    __except(TRUE)
    {
    }
}

CRSoPUpdate::~CRSoPUpdate()
{
}

///////////////////////////////////////////////////////////////////////////////
// Example extension line:
//        [{A2E30F80-D7DE-11D2-BBDE-00C04F86AE3B}{FC715823-C5FB-11D1-9EEF-00A0C90347FF}]
///////////////////////////////////////////////////////////////////////////////
BOOL DoesGPOHaveIEAKSettings(PGROUP_POLICY_OBJECT pGPO)
{
    BOOL bRet = FALSE;
    __try
    {
        if (NULL != pGPO->lpExtensions)
        {
            // Look for IEAK CSE GUID at first of line ('[').
            // If present, this GPO has IEAK settings
            if (NULL != StrStrI(pGPO->lpExtensions, _T("[{A2E30F80-D7DE-11D2-BBDE-00C04F86AE3B}")))
            {
                bRet = TRUE;
                OutD(LI0(TEXT("Changed IEAK settings detected in this GPO.")));
            }
            else
                OutD(LI1(TEXT("No changed IEAK settings detected in this GPO (see extension list as follows) = \r\n%s\r\n."),
                        pGPO->lpExtensions));
        }
        else
            OutD(LI0(TEXT("No extensions for this GPO.")));
    }
    __except(TRUE)
    {
        OutD(LI0(TEXT("Exception in StripSOMPrefix.")));
    }
    return bRet;
}

///////////////////////////////////////////////////////////
HRESULT CRSoPUpdate::DeleteObjects(BSTR bstrTempClass)
{
    MACRO_LI_PrologEx_C(PIF_STD_C, DeleteObjects)

    HRESULT hr = NOERROR;
    __try
    {
        // Make sure SysAllocString is called on the string or we'll get errors.
        _bstr_t bstrClass = bstrTempClass;
        ComPtr<IEnumWbemClassObject> pObjEnum = NULL;
        hr = m_pWbemServices->CreateInstanceEnum(bstrClass,
                                                WBEM_FLAG_FORWARD_ONLY,
                                                NULL, &pObjEnum);
        if (SUCCEEDED(hr))
        {
            hr = WBEM_S_NO_ERROR;

            // Final Next wil return WBEM_S_FALSE
            while (WBEM_S_NO_ERROR == hr)
            {
                ULONG nObjReturned;
                ComPtr<IWbemClassObject> pObj;
                hr = pObjEnum->Next(5000L, 1, (IWbemClassObject**)&pObj, &nObjReturned);
                if (WBEM_S_NO_ERROR == hr)
                {
                    // output to debugger the object's path
                    _variant_t vtRelPath;
                    _bstr_t bstrRelPath;
                    hr = pObj->Get(L"__relpath", 0L, &vtRelPath, NULL, NULL);
                    if (SUCCEEDED(hr) && VT_BSTR == vtRelPath.vt)
                    {
                        bstrRelPath = vtRelPath;
                        OutD(LI1(TEXT("About to delete %s."), (BSTR)bstrRelPath));

                        HRESULT hrDel = m_pWbemServices->DeleteInstance((BSTR)bstrRelPath, 0L, NULL, NULL);
                        if (FAILED(hrDel))
                            Out(LI2(TEXT("Error %lx deleting %s."), hr, (BSTR)bstrRelPath));
                    }
                    else
                        Out(LI2(TEXT("Error %lx getting __relpath from %s."), hr, bstrClass));
                }      // If Enum Succeeded
                else if (FAILED(hr))
                    Out(LI2(TEXT("Error %lx getting next WBEM object of class %s."), hr, bstrClass));
            }      // While Enum returning objects
        }
        else
            Out(LI2(TEXT("Error %lx querying WBEM object %s."), hr, bstrClass));
    }
    __except(TRUE)
    {
        OutD(LI0(TEXT("Exception in DeleteObjects.")));
    }
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
HRESULT CRSoPUpdate::DeleteIEAKDataFromNamespace()
{
    MACRO_LI_PrologEx_C(PIF_STD_C, DeleteIEAKDataFromNamespace)

    HRESULT hr = NOERROR;
    __try
    {
        // ----- Delete all IEAK-generated instances from namespace
        // Browser UI settings
        hr = DeleteObjects(L"RSOP_IEToolbarButton");
        hr = DeleteObjects(L"RSOP_IEToolbarButtonLink");


        // Connection settings
        hr = DeleteObjects(L"RSOP_IEConnectionSettings");
        hr = DeleteObjects(L"RSOP_IEConnectionSettingsLink");

        hr = DeleteObjects(L"RSOP_IEConnectionDialUpSettings");
        hr = DeleteObjects(L"RSOP_IEConnectionDialUpSettingsLink");

        hr = DeleteObjects(L"RSOP_IEConnectionDialUpCredentials");
        hr = DeleteObjects(L"RSOP_IEConnectionDialUpCredentialsLink");

        hr = DeleteObjects(L"RSOP_IEConnectionWinINetSettings");
        hr = DeleteObjects(L"RSOP_IEConnectionWinINetSettingsLink");


        // URL settings

                // favorites & links
        hr = DeleteObjects(L"RSOP_IEFavoriteItem");
        hr = DeleteObjects(L"RSOP_IEFavoriteItemLink");

        hr = DeleteObjects(L"RSOP_IELinkItem");
        hr = DeleteObjects(L"RSOP_IELinkItemLink");

        // Security settings
        hr = DeleteObjects(L"RSOP_IESecurityZoneSettings");
        hr = DeleteObjects(L"RSOP_IEESC");
        hr = DeleteObjects(L"RSOP_IEPrivacySettings");
        hr = DeleteObjects(L"RSOP_IESecurityContentRatings");

        hr = DeleteObjects(L"RSOP_IEAuthenticodeCertificate");


        // Program settings
        hr = DeleteObjects(L"RSOP_IEProgramSettings");
        hr = DeleteObjects(L"RSOP_IEImportedProgramSettings");


        // Advanced settings
        // TODO: Instances of each object class and its associations should eventually
        // be deleted only when processing occurs for those settings.
        hr = DeleteObjects(L"RSOP_IEAdministrativeTemplateFile");
        hr = DeleteObjects(L"RSOP_IERegistryPolicySetting");
        // -----


        //
        // Now delete the main root policy setting object
        //
        hr = DeleteObjects(L"RSOP_IEAKPolicySetting");
    }
    __except(TRUE)
    {
        OutD(LI0(TEXT("Exception in DeleteIEAKDataFromNamespace.")));
    }
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
HRESULT CRSoPUpdate::Log(DWORD dwFlags, HANDLE hToken, HKEY hKeyRoot,
                                             PGROUP_POLICY_OBJECT pDeletedGPOList,
                                             PGROUP_POLICY_OBJECT  pChangedGPOList,
                                             ASYNCCOMPLETIONHANDLE pHandle)
{
    MACRO_LI_PrologEx_C(PIF_STD_C, Log)

    UNREFERENCED_PARAMETER(dwFlags);
    UNREFERENCED_PARAMETER(hToken);
    UNREFERENCED_PARAMETER(hKeyRoot);
    UNREFERENCED_PARAMETER(pDeletedGPOList);
    UNREFERENCED_PARAMETER(pHandle);

    HRESULT hr = NOERROR;

    __try
    {
        // Deleted GPOs
        // Don't do anything with the deleted GPOList.  We'll just delete all instances
        // and write the new one out to CIMOM.

        // only need to delete all instances of the classes once, not per GPO
        BOOL bExistingDataDeleted = FALSE;

        // Changed GPOs
        Out(LI0(TEXT("Starting Internet Explorer RSoP group policy looping through changed GPOs ...")));

        // Find out how many GPOs are in our list
        PGROUP_POLICY_OBJECT pCurGPO = NULL;
        DWORD dwTotalGPOs = 0;
        for (pCurGPO = pChangedGPOList; pCurGPO != NULL; pCurGPO = pCurGPO->pNext)
            dwTotalGPOs++;


        // Prepare the variables that will store the path to the local copy of the
        // GPO directories.
        PathAppend(m_szCustomDir, TEXT("Custom Settings"));

        TCHAR szTempDir[MAX_PATH];
        StrCpy(szTempDir, m_szCustomDir);

        PathAppend(szTempDir, TEXT("Custom"));
        LPTSTR pszNum = szTempDir + StrLen(szTempDir);


        // Loop through all changed GPOs in the list
        DWORD dwIndex = 0;
        for (pCurGPO = pChangedGPOList, dwIndex = 0; 
                pCurGPO != NULL, dwIndex < dwTotalGPOs; pCurGPO = pCurGPO->pNext)
        {
            // If the IEAK CSE guid is in the lpExtensions for this GPO, process it.
            OutD(LI1(TEXT("GPO - lpDisplayName: \"%s\"."), pCurGPO->lpDisplayName));
            OutD(LI1(TEXT("GPO - szGPOName: \"%s\"."), pCurGPO->szGPOName));
            OutD(LI1(TEXT("File path is \"%s\"."), pCurGPO->lpFileSysPath));

            if (DoesGPOHaveIEAKSettings(pCurGPO))
            {
                if (!bExistingDataDeleted)
                {
                    DeleteIEAKDataFromNamespace();
                    bExistingDataDeleted = TRUE;
                }

                // Store file system portion of GPO and the WBEM class instance in a
                // new RSoP GPO object,  TODO: this had better be a copy of the actual
                // data, just in case the data is modified mid-stream (check for planning mode)

                // Because the GPO directory was already copied to a local directory for
                // normal GP processing, and since we should make a copy anyway, we'll just
                // use the copy already on our local machine (AppData directory).  We can
                // therefore ignore the pCurGPO->lpFileSysPath.

                TCHAR szNum[8];
                wnsprintf(szNum, countof(szNum), TEXT("%d"), dwIndex);
                StrCpy(pszNum, szNum);

                TCHAR szINSFile[MAX_PATH] = _T("");
                PathCombine(szINSFile, szTempDir, _T("install.ins"));
                OutD(LI1(TEXT("GPO file path is %s."), szINSFile));

                CRSoPGPO GPO(m_pWbemServices, szINSFile, FALSE);

                // Convert directory service portion of GPO and the path to the Active
                // Directory site, domain, or organization unit to which this GPO is linked.
                // If the GPO is linked to the local GPO, this member is "Local". 
                _bstr_t bstrGPODSPath = pCurGPO->lpDSPath;
                LPWSTR wszStrippedGPO = StripGPOPrefix(bstrGPODSPath);

                _bstr_t bstrGPOLink = pCurGPO->lpLink;
                LPWSTR wszStrippedSOM = StripSOMPrefix(bstrGPOLink);

                // GPOs are passed in the order in which they are to be processed.  The last
                // one processed is precedence 1, 2nd to last is precedence 2, etc.
                GPO.LogPolicyInstance(wszStrippedGPO, wszStrippedSOM, dwTotalGPOs - dwIndex);

                dwIndex++;
            }
        }

        Out(LI0(TEXT("Finished Internet Explorer RSoP group policy looping through GPOs ...")));
    }
    __except(TRUE)
    {
        OutD(LI0(TEXT("Exception in Log.")));
    }

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
HRESULT CRSoPUpdate::Plan(DWORD dwFlags, WCHAR *wszSite,
                          PRSOP_TARGET pComputerTarget, PRSOP_TARGET pUserTarget)
{
    MACRO_LI_PrologEx_C(PIF_STD_C, Plan)

    UNREFERENCED_PARAMETER(dwFlags);
    UNREFERENCED_PARAMETER(wszSite);
    UNREFERENCED_PARAMETER(pComputerTarget);

    HRESULT hr = NOERROR;

    __try
    {
        // Changed GPOs
        Out(LI0(TEXT("Starting Internet Explorer RSoP group policy looping through changed GPOs ...")));

        // Find out how many GPOs are in our list
        PGROUP_POLICY_OBJECT pCurGPO = NULL;
        DWORD dwTotalGPOs = 0;
        for (pCurGPO = pUserTarget->pGPOList; pCurGPO != NULL; pCurGPO = pCurGPO->pNext)
            dwTotalGPOs++;

        // Prepare the variables that will store the path to the local copy of the
        // GPO directories.
        PathAppend(m_szCustomDir, TEXT("Custom Settings.gpp")); // gpp is for group policy planning

        TCHAR szTempDir[MAX_PATH];
        StrCpy(szTempDir, m_szCustomDir);
        PathCreatePath(szTempDir);

        PathAppend(szTempDir, TEXT("Custom"));
        LPTSTR pszNum = szTempDir + StrLen(szTempDir);

        // need to impersonate the user when we go over the wire in case admin has
        // disabled/removed read access to GPO for authenticated users group

        // TODO: either delete impersonation code, or figure out how to get a valid
        // value for hToken;
//        g_SetUserToken(hToken);
        BOOL fImpersonate = FALSE; //ImpersonateLoggedOnUser(g_GetUserToken());
//        if (!fImpersonate)
//        {
//            OutD(LI0(TEXT("! Aborting further processing due to user impersonation failure.")));
//            hr = E_ACCESSDENIED;
//        }

        // pass 1: copy all the files to a temp dir and check to make sure everything
        // is in synch
        if (SUCCEEDED(hr))
        {
            // Loop through all changed GPOs in the list
            DWORD dwIndex = 0;
            for (pCurGPO = pUserTarget->pGPOList, dwIndex = 0; 
                    pCurGPO != NULL, dwIndex < dwTotalGPOs; pCurGPO = pCurGPO->pNext)
            {
                TCHAR szBaseDir[MAX_PATH];
                PathCombine(szBaseDir, pCurGPO->lpFileSysPath, TEXT("Microsoft\\Ieak\\install.ins"));

                if (PathFileExists(szBaseDir))
                {
                    PathRemoveFileSpec(szBaseDir);
                    
                    TCHAR szNum[8];
                    wnsprintf(szNum, countof(szNum), TEXT("%d"), dwIndex);
                    StrCpy(pszNum, szNum);

                    BOOL fResult = CreateDirectory(szTempDir, NULL) && CopyFileToDirEx(szBaseDir, szTempDir);

                    // branding files
                    TCHAR szFeatureDir[MAX_PATH];
                    if (fResult)
                    {
                        PathCombine(szFeatureDir, szBaseDir, IEAK_GPE_BRANDING_SUBDIR);
                        if (PathFileExists(szFeatureDir))
                            fResult = SUCCEEDED(PathEnumeratePath(szFeatureDir, PEP_SCPE_NOFILES, 
                                GetPepCopyFilesEnumProc(), (LPARAM)szTempDir));
                    }

                    // desktop files
                    if (fResult)
                    {
                        PathCombine(szFeatureDir, szBaseDir, IEAK_GPE_DESKTOP_SUBDIR);
                        
                        if (PathFileExists(szFeatureDir))
                            fResult = SUCCEEDED(PathEnumeratePath(szFeatureDir, PEP_SCPE_NOFILES,
                                GetPepCopyFilesEnumProc(), (LPARAM)szTempDir));
                    }

                    if (!fResult)
                    {
                        Out(LI0(TEXT("! Error copying files. No further processing will be done.")));
                        break;
                    }

                    // check to see if cookie is there before doing anything
                    if (PathFileExistsInDir(IEAK_GPE_COOKIE_FILE, szTempDir))
                        break;

                    dwIndex++;
                }
            }
        }

        PathRemoveFileSpec(szTempDir);

        Out(LI0(TEXT("Finished copying directories.\r\n")));

        if (fImpersonate)
            RevertToSelf();

        if (pCurGPO != NULL)
        {
            OutD(LI0(TEXT("! Aborting further processing because GPO replication is incomplete")));
            hr = E_FAIL;
        }

        if (SUCCEEDED(hr))
        {
            TCHAR szINSFile[MAX_PATH];
            PathCombine(szINSFile, m_szCustomDir, TEXT("Custom"));
            LPTSTR pszFile = szINSFile + StrLen(szINSFile);

            // Loop through all changed GPOs in the list
            DWORD dwIndex = 0;
            for (pCurGPO = pUserTarget->pGPOList, dwIndex = 0; 
                    pCurGPO != NULL, dwIndex < dwTotalGPOs; pCurGPO = pCurGPO->pNext)
            {
                // If the IEAK CSE guid is in the lpExtensions for this GPO, process it.
                OutD(LI1(TEXT("GPO - lpDisplayName: \"%s\"."), pCurGPO->lpDisplayName));
                OutD(LI1(TEXT("GPO - szGPOName: \"%s\"."), pCurGPO->szGPOName));
                OutD(LI1(TEXT("File path is \"%s\"."), pCurGPO->lpFileSysPath));

                if (DoesGPOHaveIEAKSettings(pCurGPO))
                {
                    // Store file system portion of GPO and the WBEM class instance in a
                    // new RSoP GPO object,  TODO: this had better be a copy of the actual
                    // data, just in case the data is modified mid-stream (check for planning mode)

                    // Because the GPO directory was already copied to a local directory for
                    // normal GP processing, and since we should make a copy anyway, we'll just
                    // use the copy already on our local machine (AppData directory).  We can
                    // therefore ignore the pCurGPO->lpFileSysPath.

                    TCHAR szCurrentFile[16];
                    wnsprintf(szCurrentFile, countof(szCurrentFile), TEXT("%d\\INSTALL.INS"), dwIndex);
                    StrCpy(pszFile, szCurrentFile);

                    OutD(LI1(TEXT("GPO file path is %s."), szINSFile));

                    CRSoPGPO GPO(m_pWbemServices, szINSFile, TRUE);

                    // Convert directory service portion of GPO and the path to the Active
                    // Directory site, domain, or organization unit to which this GPO is linked.
                    // If the GPO is linked to the local GPO, this member is "Local". 
                    _bstr_t bstrGPODSPath = pCurGPO->lpDSPath;
                    LPWSTR wszStrippedGPO = StripGPOPrefix(bstrGPODSPath);

                    _bstr_t bstrGPOLink = pCurGPO->lpLink;
                    LPWSTR wszStrippedSOM = StripSOMPrefix(bstrGPOLink);

                    // GPOs are passed in the order in which they are to be processed.  The last
                    // one processed is precedence 1, 2nd to last is precedence 2, etc.
                    GPO.LogPolicyInstance(wszStrippedGPO, wszStrippedSOM, dwTotalGPOs - dwIndex);

                    dwIndex++;
                }
            }
        }

        PathRemovePath(szTempDir);

        Out(LI0(TEXT("Finished Internet Explorer RSoP group policy looping through GPOs ...")));
    }
    __except(TRUE)
    {
        OutD(LI0(TEXT("Exception in Plan.")));
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\brandll\rsop.h ===
// Interface for RSoPUpdate class

#ifndef __IEAK_BRANDING_RSOP_H__
#define __IEAK_BRANDING_RSOP_H__

#include <userenv.h>

#include <setupapi.h>
#include "wbemcli.h"
#include <ras.h>
#include "reghash.h"

#include "SComPtr.h"



// defines
#define MAX_GUID_LENGTH 40

typedef struct _ADMFILEINFO {
    WCHAR *               pwszFile;            // Adm file path
    WCHAR *               pwszGPO;             // Gpo that the adm file is in
    FILETIME              ftWrite;             // Last write time of Adm file
    struct _ADMFILEINFO * pNext;               // Singly linked list pointer
} ADMFILEINFO;


///////////////////////////////////////////////////////////////////////////////
// Flags for GetWBEMObject
#define OPENRSOPOBJ_OPENEXISTING		0x00000000
#define OPENRSOPOBJ_NEVERCREATE			0x00000001
#define OPENRSOPOBJ_ALWAYSCREATE		0x00000010

///////////////////////////////////////////////////////////////////////////////
class CRSoPGPO
{
public:
	CRSoPGPO(ComPtr<IWbemServices> pWbemServices, LPCTSTR szINSFile, BOOL fPlanningMode);
	virtual ~CRSoPGPO();

// operations
public:
        HRESULT LogPolicyInstance(LPWSTR wszGPO, 
                                LPWSTR wszSOM,
                                DWORD dwPrecedence
                                );


private:
	// Text file functions
	BOOL GetInsString(LPCTSTR szSection, LPCTSTR szKey, LPTSTR szValue,
						DWORD dwValueLen, BOOL &bEnabled);
	BOOL GetInsBool(LPCTSTR szSection, LPCTSTR szKey, BOOL bDefault, BOOL *pbEnabled = NULL);
	UINT GetInsInt(LPCTSTR szSection, LPCTSTR szKey, INT nDefault, BOOL *pbEnabled = NULL);
	BOOL GetINFStringField(PINFCONTEXT pinfContext, LPCTSTR szFileName,
							 LPCTSTR szSection, DWORD dwFieldIndex,
							 LPCTSTR szFieldSearchText, LPTSTR szBuffer,
							 DWORD dwBufferLen, BOOL &bFindNextLine);
	HRESULT StoreStringArrayFromIniFile(LPCTSTR szSection, LPCTSTR szKeyFormat,
										ULONG nArrayInitialSize, ULONG nArrayIncSize,
										LPCTSTR szFile, BSTR bstrPropName,
										ComPtr<IWbemClassObject> pWbemObj);


	// Property putting & getting
	HRESULT PutWbemInstanceProperty(BSTR bstrPropName, _variant_t vtPropValue);
	HRESULT PutWbemInstancePropertyEx(BSTR bstrPropName, _variant_t vtPropValue,
																		ComPtr<IWbemClassObject> pWbemClass);
	HRESULT PutWbemInstance(ComPtr<IWbemClassObject> pWbemObj,
													BSTR bstrClassName, BSTR *pbstrObjPath);

	// Object creation, deletion, retrieval
	HRESULT CreateAssociation(BSTR bstrAssocClass, BSTR bstrProp2Name,
														BSTR bstrProp2ObjPath);
        HRESULT CreateRSOPObject(BSTR bstrClass,
                                IWbemClassObject **ppResultObj,
                                BOOL bTopObj = FALSE
                                );


	// -------------------- Methods which write data to WMI
	// Precedence Mode
	HRESULT StorePrecedenceModeData();

	// Browser UI settings
	HRESULT StoreDisplayedText();
	HRESULT StoreBitmapData();

			// toolbar buttons
	HRESULT StoreToolbarButtons(BSTR **ppaTBBtnObjPaths, long &nTBBtnCount);
	HRESULT CreateToolbarButtonObjects(BSTR **ppaTBBtnObjPaths,
										long &nTBBtnCount);

	// Connection settings
	HRESULT StoreConnectionSettings(BSTR *bstrConnSettingsObjPath,
									BSTR **ppaDUSObjects, long &nDUSCount,
									BSTR **ppaDUCObjects, long &nDUCCount,
									BSTR **ppaWSObjects, long &nWSCount);
	HRESULT StoreAutoBrowserConfigSettings(ComPtr<IWbemClassObject> pCSObj);
	HRESULT StoreProxySettings(ComPtr<IWbemClassObject> pCSObj);
	HRESULT ProcessAdvancedConnSettings(ComPtr<IWbemClassObject> pCSObj,
										BSTR **ppaDUSObjects, long &nDUSCount,
										BSTR **ppaDUCObjects, long &nDUCCount,
										BSTR **ppaWSObjects, long &nWSCount);
	HRESULT ProcessRasCS(PCWSTR pszNameW, PBYTE *ppBlob, LPRASDEVINFOW prdiW,
						UINT cDevices, ComPtr<IWbemClassObject> pCSObj,
						BSTR *pbstrConnDialUpSettingsObjPath);
	HRESULT ProcessRasCredentialsCS(PCWSTR pszNameW, PBYTE *ppBlob,
									ComPtr<IWbemClassObject> pCSObj,
									BSTR *pbstrConnDialUpCredObjPath);
	HRESULT ProcessWininetCS(PCWSTR pszNameW, PBYTE *ppBlob,
							ComPtr<IWbemClassObject> pCSObj,
							BSTR *pbstrConnWinINetSettingsObjPath);

	// URL settings
	HRESULT StoreCustomURLs();

			// favorites & links
	HRESULT StoreFavoritesAndLinks(BSTR **ppaFavObjPaths,
									long &nFavCount,
									BSTR **ppaLinkObjPaths,
									long &nLinkCount);
	HRESULT CreateFavoriteObjects(BSTR **ppaFavObjPaths, long &nFavCount);
	HRESULT CreateLinkObjects(BSTR **ppaLinkObjPaths, long &nLinkCount);

			// channels & categories
	HRESULT StoreChannelsAndCategories(BSTR **ppaCatObjPaths,
										long &nCatCount,
										BSTR **ppaChnObjPaths,
										long &nChnCount);
	HRESULT CreateCategoryObjects(BSTR **ppaCatObjPaths, long &nCatCount);
	HRESULT CreateChannelObjects(BSTR **ppaChnObjPaths, long &nChnCount);

	// Security settings
	HRESULT StoreSecZonesAndContentRatings();
	HRESULT StoreZoneSettings(LPCTSTR szRSOPZoneFile);
	HRESULT StorePrivacySettings(LPCTSTR szRSOPZoneFile);
	HRESULT StoreRatingsSettings(LPCTSTR szRSOPRatingsFile);
	HRESULT StoreAuthenticodeSettings();
	HRESULT StoreCertificates();

	// Program settings
	HRESULT StoreProgramSettings(BSTR *pbstrProgramSettingsObjPath);

	// Advanced settings
	HRESULT StoreADMSettings(LPWSTR wszGPO, LPWSTR wszSOM);
	BOOL LogRegistryRsopData(REGHASHTABLE *pHashTable, LPWSTR wszGPOID, LPWSTR wszSOMID);
	BOOL LogAdmRsopData(ADMFILEINFO *pAdmFileCache);

// attributes
private:
    // Keep copies of RSOP_PolicySetting key info to use as foreign keys in other
    // classes
    DWORD m_dwPrecedence;
    _bstr_t m_bstrID;
    BOOL  m_fPlanningMode;

// implementation
private:
	ComPtr<IWbemServices> m_pWbemServices;
	TCHAR m_szINSFile[MAX_PATH];

	// MOF class-specific info
	ComPtr<IWbemClassObject> m_pIEAKPSObj;
	BSTR m_bstrIEAKPSObjPath;
};

///////////////////////////////////////////////////////////////////////////////
class CRSoPUpdate
{
public:
	CRSoPUpdate(ComPtr<IWbemServices> pWbemServices, LPCTSTR szCustomDir);
	virtual ~CRSoPUpdate();

// operations
public:
	HRESULT Log(DWORD dwFlags, HANDLE hToken, HKEY hKeyRoot,
				PGROUP_POLICY_OBJECT pDeletedGPOList,
				PGROUP_POLICY_OBJECT  pChangedGPOList,
				ASYNCCOMPLETIONHANDLE pHandle);
	HRESULT Plan(DWORD dwFlags, WCHAR *wszSite,
					PRSOP_TARGET pComputerTarget, PRSOP_TARGET pUserTarget);

// attributes
// implementation
private:
	HRESULT DeleteIEAKDataFromNamespace();
	HRESULT DeleteObjects(BSTR bstrClass);

	ComPtr<IWbemServices> m_pWbemServices;
	TCHAR m_szCustomDir[MAX_PATH];
};



#endif //__IEAK_BRANDING_RSOP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\brandll\reghash.cpp ===
//*************************************************************
//
//  Hash table for registry Rsop data
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1999
//  All rights reserved
//
//  History:    7-Jun-99   SitaramR    Created
//
//*************************************************************

#include "precomp.h"

#include "reghash.h"

REGKEYENTRY * AllocRegKeyEntry( BOOL bHKCU, WCHAR *pwszKeyName );
void FreeRegKeyEntry( REGKEYENTRY *pKeyEntry );
REGVALUEENTRY *AllocValueEntry( WCHAR *pwszValueName );
void FreeValueEntry( REGVALUEENTRY *pValueEntry );
REGDATAENTRY * AllocDataEntry( REGOPERATION opnType,
                               DWORD dwType,
                               DWORD dwLen,
                               BYTE *pData,
                               WCHAR *pwszGPO,
                               WCHAR *pwszSOM,
                               WCHAR *pwszCommand);
                               
void FreeDataEntry( REGDATAENTRY *pDataEntry );
BOOL DeleteRegTree( REGHASHTABLE *pHashTable,
					BOOL bHKCU,
                    WCHAR *pwszKeyName,
                    WCHAR *pwszGPO,
                    WCHAR *pwszSOM,
                    WCHAR *szCommand);
REGKEYENTRY * FindRegKeyEntry( REGHASHTABLE *pHashTable,
								BOOL bHKCU,
								WCHAR *pwszKeyName,
								BOOL bCreate );
REGVALUEENTRY * FindValueEntry( REGHASHTABLE *pHashTable,
								BOOL bHKCU,
                                WCHAR *pwszKeyName,
                                WCHAR *pwszValueName,
                                BOOL bCreate );
BOOL AddDataEntry( REGVALUEENTRY *pValueEntry,
                   REGOPERATION opnType,
                   DWORD dwType,
                   DWORD dwLen,
                   BYTE *pData,
                   WCHAR *pwszGPO,
                   WCHAR *pwszSOM,
                   WCHAR *pwszCommand);


////////////////////////////////////////////////////////////////////////
// Hash Table for registry policies
// ----------------------------------
//
// This hash table is used to log rsop data for registry policies. 
// A hash table entry is created for each registry entry. The registry entry
// name itself is used to calculate the hash table.
//
// Each Registry entry has a link to each of the values modified by policy.
// These values are in a link list and sorted by the valueNames.
//
// Each Value has the list of Data that are being set on the Values. This 
// sorted by the order of execution. The topmost value will contain the final value.
// The Data entries have fields that mark the value as deleted and the Command 
// associated with the action. To look for the possible commands look in the
// ParseRegistryFile.
// 
// Additionally, in the hash table 2 special case values exist.
//  a.   **Command Value. The Data under this value will contain all the commands 
//                     that are executed under this key.
//
//  b.  An ""(Empty ValueName) This valuename represents the modifications happening
//      to the key itself. For example a key can deleted or added..
//
// Note:
//      The szCommand that is passed in has to be non NULL but can be an empty string.
// There is a dependency on it in AddDataEntry and in logger.cpp. There is an Assert 
// for this in AddRegHashEntry
// 
////////////////////////////////////////////////////////////////////////



//*************************************************************
//
//  AllocHashTable
//
//  Purpose:    Allocates a new hash table
//
//  Returns:    Pointer to hash table
//
//*************************************************************

REGHASHTABLE * AllocHashTable()
{
    DWORD i;

    REGHASHTABLE *pHashTable = (REGHASHTABLE *) LocalAlloc (LPTR, sizeof(REGHASHTABLE));

    if ( pHashTable == NULL ) {
        OutD(LI0(TEXT("AllocHashTable: Failed to alloc hashtable.")));
        return NULL;
    }

    for ( i=0; i<HASH_TABLE_SIZE; i++) {
        pHashTable->aHashTable[i] = 0;
    }

    pHashTable->hrError = S_OK;

    return pHashTable;
}



//*************************************************************
//
//  FreeHashTable
//
//  Purpose:    Deletes a hash table
//
//  Parameters: pHashTable   -  Hash table to delete
//
//*************************************************************

void FreeHashTable( REGHASHTABLE *pHashTable )
{

    DWORD i;

    if ( pHashTable == NULL )
        return;

    for ( i=0; i<HASH_TABLE_SIZE; i++ ) {
        REGKEYENTRY *pKeyEntry = pHashTable->aHashTable[i];

        while ( pKeyEntry ) {
            REGKEYENTRY *pNext = pKeyEntry->pNext;
            FreeRegKeyEntry( pKeyEntry );
            pKeyEntry = pNext;
        }
    }
}


//*************************************************************
//
//  AllocRegKey
//
//  Purpose:    Allocates a new registry key entry
//
//  Returns:    Pointer to registr key entry
//
//*************************************************************

REGKEYENTRY * AllocRegKeyEntry( BOOL bHKCU, WCHAR *pwszKeyName )
{
	REGKEYENTRY *pKeyEntry = (REGKEYENTRY *) LocalAlloc (LPTR, sizeof(REGKEYENTRY));
	if ( pKeyEntry == NULL ) {
		OutD(LI0(TEXT("AllocRegKeyEntry: Failed to alloc key entry.")));
		return NULL;
	}

	pKeyEntry->pwszKeyName = (WCHAR *) LocalAlloc (LPTR, (lstrlen(pwszKeyName) + 1 ) * sizeof(WCHAR));

	if ( pKeyEntry->pwszKeyName == NULL ) {
		OutD(LI0(TEXT("AllocRegKeyEntry: Failed to alloc key name.")));
		LocalFree( pKeyEntry );
		return NULL;
	}

	lstrcpy( pKeyEntry->pwszKeyName, pwszKeyName );

	pKeyEntry->bHKCU = bHKCU;

	return pKeyEntry;
}


//*************************************************************
//
//  FreeRegKeyEntry
//
//  Purpose:    Deletes a registry key entry
//
//  Parameters: pKeyEntry   -  Entry to delete
//
//*************************************************************

void FreeRegKeyEntry( REGKEYENTRY *pKeyEntry )
{
    REGVALUEENTRY *pValueEntry = NULL;

    if ( pKeyEntry == NULL )
        return;

    LocalFree( pKeyEntry->pwszKeyName );

    pValueEntry = pKeyEntry->pValueList;
    while ( pValueEntry ) {
        REGVALUEENTRY *pNext = pValueEntry->pNext;
        FreeValueEntry( pValueEntry );
        pValueEntry = pNext;
    }

    LocalFree( pKeyEntry );
}


//*************************************************************
//
//  AllocValueEntry
//
//  Purpose:    Allocates a new value entry
//
//  Returns:    Pointer to value entry
//
//*************************************************************

REGVALUEENTRY *AllocValueEntry( WCHAR *pwszValueName )
{
    REGVALUEENTRY *pValueEntry = (REGVALUEENTRY *) LocalAlloc (LPTR, sizeof(REGVALUEENTRY));
    if ( pValueEntry == NULL ) {
        OutD(LI0(TEXT("AllocValueEntry: Failed to alloc value entry.")));
        return NULL;
    }

    pValueEntry->pwszValueName = (WCHAR *) LocalAlloc (LPTR, (lstrlen(pwszValueName) + 1 ) * sizeof(WCHAR));

    if ( pValueEntry->pwszValueName == NULL ) {
        OutD(LI0(TEXT("AllocValueEntry: Failed to alloc key name.")));
        LocalFree( pValueEntry );
        return NULL;
    }

    lstrcpy( pValueEntry->pwszValueName, pwszValueName );

    return pValueEntry;
}


//*************************************************************
//
//  FreeValueEntry
//
//  Purpose:    Deletes a value entry
//
//  Parameters: pValueEntry   -  Entry to delete
//
//*************************************************************

void FreeValueEntry( REGVALUEENTRY *pValueEntry )
{
    REGDATAENTRY *pDataEntry = NULL;

    if ( pValueEntry == NULL )
        return;

    LocalFree( pValueEntry->pwszValueName );

    pDataEntry = pValueEntry->pDataList;
    while ( pDataEntry ) {
        REGDATAENTRY *pNext = pDataEntry->pNext;
        FreeDataEntry( pDataEntry );
        pDataEntry = pNext;
    }

    LocalFree( pValueEntry );
}



//*************************************************************
//
//  AllocDataEntry
//
//  Purpose:    Allocates a new data entry
//
//  Returns:    Pointer to data entry
//
//*************************************************************

REGDATAENTRY * AllocDataEntry( REGOPERATION opnType,
                               DWORD dwType,
                               DWORD dwLen,
                               BYTE *pData,
                               WCHAR *pwszGPO,
                               WCHAR *pwszSOM,
                               WCHAR *pwszCommand)
{
	UNREFERENCED_PARAMETER(pwszGPO);
	UNREFERENCED_PARAMETER(pwszSOM);

    BOOL bResult = FALSE;

    REGDATAENTRY *pDataEntry = (REGDATAENTRY *) LocalAlloc (LPTR, sizeof(REGDATAENTRY));
    if ( pDataEntry == NULL ) {
        OutD(LI0(TEXT("AllocDataEntry: Failed to alloc data entry.")));
        return NULL;
    }

    if ( opnType == REG_ADDVALUE )
        pDataEntry->bDeleted = FALSE;
    else
        pDataEntry->bDeleted = TRUE;

    pDataEntry->bAdmPolicy = FALSE;
    pDataEntry->dwValueType = dwType;
    pDataEntry->dwDataLen = dwLen;

    if ( pData ) {
        pDataEntry->pData = (BYTE *) LocalAlloc (LPTR, dwLen);
        if ( pDataEntry->pData == NULL ) {
            OutD(LI0(TEXT("AllocDataEntry: Failed to alloc data.")));
            goto Exit;
        }

        CopyMemory( pDataEntry->pData, pData, dwLen );
    }

/*    pDataEntry->pwszGPO = (WCHAR *) LocalAlloc (LPTR, (lstrlen(pwszGPO) + 1 ) * sizeof(WCHAR));

    if ( pDataEntry->pwszGPO == NULL ) {
        OutD(LI0(TEXT("AllocDataEntry: Failed to alloc Gpo name.")));
        goto Exit;
    }

    lstrcpy( pDataEntry->pwszGPO, pwszGPO );

    pDataEntry->pwszSOM = (WCHAR *) LocalAlloc (LPTR, (lstrlen(pwszSOM) + 1 ) * sizeof(WCHAR));

    if ( pDataEntry->pwszSOM == NULL ) {
        OutD(LI0(TEXT("AllocDataEntry: Failed to alloc Sdou name.")));
        goto Exit;
    }

    lstrcpy( pDataEntry->pwszSOM, pwszSOM );
*/
	pDataEntry->pwszGPO = NULL;
	pDataEntry->pwszSOM = NULL;

    pDataEntry->pwszCommand = (WCHAR *) LocalAlloc (LPTR, (lstrlen(pwszCommand) + 1 ) * sizeof(WCHAR));

    if ( pDataEntry->pwszCommand == NULL ) {
        OutD(LI0(TEXT("AllocDataEntry: Failed to alloc Sdou name.")));
        goto Exit;
    }

    lstrcpy( pDataEntry->pwszCommand, pwszCommand );

    bResult = TRUE;

Exit:

    if ( !bResult ) {
        LocalFree( pDataEntry->pData );
        LocalFree( pDataEntry->pwszGPO );
        LocalFree( pDataEntry->pwszSOM );
        if (pDataEntry->pwszCommand)
            LocalFree(pDataEntry->pwszCommand);
        LocalFree( pDataEntry);
        return NULL;
    }

    return pDataEntry;

}


//*************************************************************
//
//  FreeDataEntry
//
//  Purpose:    Deletes a data entry
//
//  Parameters: pDataEntry   -  Entry to delete
//
//*************************************************************

void FreeDataEntry( REGDATAENTRY *pDataEntry )
{
    if ( pDataEntry )
	{
        LocalFree( pDataEntry->pData );

		if (NULL != pDataEntry->pwszGPO)
			LocalFree( pDataEntry->pwszGPO );
		if (NULL != pDataEntry->pwszSOM)
	        LocalFree( pDataEntry->pwszSOM );
        LocalFree( pDataEntry);
    }
}



//*************************************************************
//
//  Hash
//
//  Purpose:    Maps a key name to a hash bucket
//
//  Parameters: pwszName   -  Key name
//
//  Returns:    Hash bucket
//
//*************************************************************

DWORD Hash( WCHAR *pwszName )
{
    DWORD dwLen = lstrlen( pwszName );
    DWORD dwHashValue = 0;

    for ( ; dwLen>0; pwszName++ ) {
        dwHashValue = toupper(*pwszName) + 31 * dwHashValue;
        dwLen--;
    }

    return dwHashValue % HASH_TABLE_SIZE;
}


//*************************************************************
//
//  AddRegHashEntry
//
//  Purpose:    Adds a registry key to the hash table
//
//  Parameters: pwszName   -  Key name
//
//*************************************************************

BOOL AddRegHashEntry( REGHASHTABLE *pHashTable,
                      REGOPERATION opnType,
					  BOOL bHKCU,
                      WCHAR *pwszKeyName,
                      WCHAR *pwszValueName,
                      DWORD dwType,
                      DWORD dwDataLen,
                      BYTE *pData,
                      WCHAR *pwszGPO,
                      WCHAR *pwszSOM,
                      WCHAR *szCommand,
                      BOOL   bCreateCommand)
{
	REGVALUEENTRY *pValueEntry = NULL;
    BOOL bResult = FALSE;
	REGKEYENTRY *pKeyEntry=NULL;


	switch (opnType) {

	case REG_DELETEKEY:
		bResult = DeleteRegTree( pHashTable, bHKCU, pwszKeyName, pwszGPO, pwszSOM, szCommand );
		break;
    
	case REG_INTERNAL_DELETESINGLEKEY:
	case REG_DELETEALLVALUES:

		pKeyEntry = FindRegKeyEntry( pHashTable, bHKCU, pwszKeyName, FALSE );
		if ( pKeyEntry == NULL ) {

			//
			// Delete all values is similar to policy being disabled and
			// so do nothing. 
			//

			if (opnType == REG_DELETEALLVALUES)
				break;
			else
				// no command entry in this case.
				return TRUE;
		}

		pValueEntry = pKeyEntry->pValueList;
		while ( pValueEntry ) {

			if (lstrcmp(pValueEntry->pwszValueName, TEXT("")) != 0) {

				if (lstrcmpi(pValueEntry->pwszValueName, STARCOMMAND) != 0) {
            

					//
					// Mark the value as deleted
					//
                
					bResult = AddDataEntry( pValueEntry, opnType, 0, 0, NULL,
											pwszGPO, pwszSOM, szCommand );
					if ( !bResult )
						return FALSE;
				}
			}
			else {

				//
				// Mark the key as deleted
				//
            
				if (opnType == REG_INTERNAL_DELETESINGLEKEY) {
					bResult = AddDataEntry( pValueEntry, opnType, 0, 0, NULL,
											pwszGPO, pwszSOM, szCommand );
					if ( !bResult )
						return FALSE;
				}                        
			}
        
			pValueEntry = pValueEntry->pNext;
		}

		break;
    
	case REG_ADDVALUE:
	case REG_SOFTADDVALUE:

		//
		// We have to make a value with no name to represent the creation of key itself..
		//

		pValueEntry = FindValueEntry( pHashTable, bHKCU, pwszKeyName, TEXT(""), TRUE );
		if ( pValueEntry == NULL )
			return FALSE;

		bResult = AddDataEntry( pValueEntry, opnType, 0, 0, NULL,
								pwszGPO, pwszSOM, szCommand );


		if (!bResult)
			return FALSE;
        
		if ((!pwszValueName) || (!(*pwszValueName)) || 
				(dwDataLen == 0) || (dwType == REG_NONE)) 
			break;                                

	// fall through

	case REG_DELETEVALUE:
		pValueEntry = FindValueEntry( pHashTable, bHKCU, pwszKeyName,
									  pwszValueName, TRUE );
		if ( pValueEntry == NULL )
			return FALSE;


		//
		// In case of SOFTADDVALUE the final decision to add the value is made in
		// AddDataEntry
		//
    
		bResult = AddDataEntry( pValueEntry, opnType, dwType, dwDataLen, pData,
								pwszGPO, pwszSOM, szCommand );

	break;
	default:
		break;
	}


	//
	// If everything succeeded, then log the command if
	// bCreateCommand is true. This is done creating or adding
	// to a value called **Command. This means that this value is not
	// Settable by adm file..
	//

	if ((bResult) && (bCreateCommand) && (opnType != REG_INTERNAL_DELETESINGLEKEY) && (*szCommand != TEXT('\0'))) {
		pValueEntry = FindValueEntry( pHashTable, bHKCU, pwszKeyName, STARCOMMAND, TRUE );
                                  
		if ( pValueEntry == NULL )
			return FALSE;

		bResult = AddDataEntry( pValueEntry, REG_ADDVALUE, 0, 
								sizeof(TCHAR)*(lstrlen(szCommand)+1), (BYTE *)szCommand,
								pwszGPO, pwszSOM, szCommand);    
	}

	return bResult;
}


//*************************************************************
//
//  DeleteRegTree
//
//  Purpose:    Deletes a key and all its subkeys
//
//  Parameters: pHashTable   -   Hash table
//              pwszKeyName  -   Key name to delete
//              pwszGPO      -   Gpo
//              pwszSOM      -   Sdou that the Gpo is linked to
//
//*************************************************************

BOOL DeleteRegTree( REGHASHTABLE *pHashTable,
					BOOL bHKCU,
                    WCHAR *pwszKeyName,
                    WCHAR *pwszGPO,
                    WCHAR *pwszSOM,
                    WCHAR *szCommand)
{
    DWORD i=0;
    DWORD dwKeyLen = lstrlen( pwszKeyName );

    for ( i=0; i<HASH_TABLE_SIZE; i++ ) {

        REGKEYENTRY *pKeyEntry = pHashTable->aHashTable[i];
        while ( pKeyEntry ) {

            BOOL bAdd = FALSE;
            DWORD dwKeyLen2  = lstrlen(pKeyEntry->pwszKeyName);

            if ( dwKeyLen2 >= dwKeyLen
				&& CompareString (LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                                   pKeyEntry->pwszKeyName, dwKeyLen,
                                   pwszKeyName, dwKeyLen ) == CSTR_EQUAL
				&& bHKCU == pKeyEntry->bHKCU) {

                //
                // It's a prefix if length and strings match, or if one
                // string is bigger and there is a '\' at the right place.
                //

                if ( dwKeyLen2 > dwKeyLen ) {

                    if ( pKeyEntry->pwszKeyName[dwKeyLen] == L'\\' ) 
                        bAdd = TRUE;
                } else
                    bAdd = TRUE;

                if ( bAdd ) {
                    BOOL bResult = AddRegHashEntry( pHashTable,
                                                    REG_INTERNAL_DELETESINGLEKEY,
													bHKCU, pKeyEntry->pwszKeyName,
                                                    NULL, 0, 0, NULL,
                                                    pwszGPO, pwszSOM, szCommand, FALSE );
                    if ( !bResult )
                        return FALSE;
                }

            }   // if dwKeyLen2 >= dwKeyLen

            pKeyEntry = pKeyEntry->pNext;

        }   // while

    }   // for

    return TRUE;
}


//*************************************************************
//
//  FindRegKeyEntry
//
//  Purpose:    Looks up a reg key entry in hash table
//
//  Parameters: pHashTable   -   Hash table
//              pwszKeyName  -   Key name to find
//              bCreate      -   Should key be created if not found ?
//
//*************************************************************

REGKEYENTRY * FindRegKeyEntry( REGHASHTABLE *pHashTable, BOOL bHKCU,
								WCHAR *pwszKeyName, BOOL bCreate )
{
    DWORD dwHashValue = Hash( pwszKeyName );

    REGKEYENTRY *pCurPtr = pHashTable->aHashTable[dwHashValue];
    REGKEYENTRY *pTrailPtr = NULL;

    while ( pCurPtr != NULL ) {

        INT iResult = CompareString( LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                                     pwszKeyName, -1,
                                     pCurPtr->pwszKeyName, -1 );

        if ( iResult == CSTR_EQUAL && bHKCU == pCurPtr->bHKCU) {
            return pCurPtr;
        } else if ( iResult == CSTR_LESS_THAN ) {

            //
            // Keys are in ascending order, so insert if bCreate
            //

            if ( bCreate ) {

                REGKEYENTRY *pKeyEntry = AllocRegKeyEntry( bHKCU, pwszKeyName );
                if ( pKeyEntry == NULL )
                    return 0;

                pKeyEntry->pNext = pCurPtr;
                if ( pTrailPtr == NULL )
                    pHashTable->aHashTable[dwHashValue] = pKeyEntry;
                else
                    pTrailPtr->pNext = pKeyEntry;

                return pKeyEntry;

            } else
                return NULL;

        } else {

            //
            // Advance down the list
            //

            pTrailPtr = pCurPtr;
            pCurPtr = pCurPtr->pNext;

        }

    }

    //
    // End of list or null list case
    //

    if ( bCreate ) {
        REGKEYENTRY *pKeyEntry = AllocRegKeyEntry( bHKCU, pwszKeyName );
        if ( pKeyEntry == NULL )
            return 0;

        pKeyEntry->pNext = 0;
        if ( pTrailPtr == NULL )
            pHashTable->aHashTable[dwHashValue] = pKeyEntry;
        else
            pTrailPtr->pNext = pKeyEntry;

        return pKeyEntry;
    }

    return NULL;
}


//*************************************************************
//
//  FindValueEntry
//
//  Purpose:    Looks up a value entry in hash table
//
//  Parameters: pHashTable    -   Hash table
//              pwszKeyName   -   Key name to find
//              pwszValueName -   Value name to find
//              bCreate       -   Should key be created if not found ?
//
//*************************************************************

REGVALUEENTRY * FindValueEntry( REGHASHTABLE *pHashTable,
								BOOL bHKCU,
                                WCHAR *pwszKeyName,
                                WCHAR *pwszValueName,
                                BOOL bCreate )
{
    REGVALUEENTRY *pCurPtr = NULL;
    REGVALUEENTRY *pTrailPtr = NULL;

    REGKEYENTRY *pKeyEntry = FindRegKeyEntry( pHashTable, bHKCU, pwszKeyName, bCreate );
    if ( pKeyEntry == NULL )
        return NULL;

    pCurPtr = pKeyEntry->pValueList;
    pTrailPtr = NULL;

    while ( pCurPtr != NULL ) {

        INT iResult = CompareString( LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                                     pwszValueName, -1,
                                     pCurPtr->pwszValueName, -1 );

        if ( iResult  == CSTR_EQUAL ) {
            return pCurPtr;
        } else if ( iResult == CSTR_LESS_THAN ) {

            //
            // Keys are in ascending order, so insert if bCreate
            //

            if ( bCreate ) {

                REGVALUEENTRY *pValueEntry = AllocValueEntry( pwszValueName );
                if ( pValueEntry == NULL )
                    return 0;

                pValueEntry->pNext = pCurPtr;
                if ( pTrailPtr == NULL )
                    pKeyEntry->pValueList = pValueEntry;
                else
                    pTrailPtr->pNext = pValueEntry;

                return pValueEntry;

            } else
                return NULL;

        } else {

            //
            // Advance down the list
            //

            pTrailPtr = pCurPtr;
            pCurPtr = pCurPtr->pNext;

        }

    }

    //
    // End of list or null list case
    //

    if ( bCreate ) {

        REGVALUEENTRY *pValueEntry = AllocValueEntry( pwszValueName );
        if ( pValueEntry == NULL )
            return 0;

        pValueEntry->pNext = 0;
        if ( pTrailPtr == NULL )
            pKeyEntry->pValueList = pValueEntry;
        else
            pTrailPtr->pNext = pValueEntry;

        return pValueEntry;
    }

    return NULL;
}



//*************************************************************
//
//  AddDataEntry
//
//  Purpose:    Adds a data entry to a value entry struct
//
//  Parameters: pValueEntry   - Value entry
//              opnType       - Operation type
//              dwType        - Type of registry data
//              dwLen         - Length of registry data
//              pData         - Data
//              pwszGPO       - Gpo that set this value
//              pwszSOM       - Sdou that the Gpo is linked to
//
//*************************************************************

BOOL AddDataEntry( REGVALUEENTRY *pValueEntry,
                   REGOPERATION opnType,
                   DWORD dwType,
                   DWORD dwLen,
                   BYTE *pData,
                   WCHAR *pwszGPO,
                   WCHAR *pwszSOM,
                   WCHAR *pwszCommand)
{
    REGDATAENTRY *pDataEntry = NULL; 

    if (opnType == REG_SOFTADDVALUE) {

        //
        // if the data list is null or if the first value (highest precedence value is deleted)
        // then add it to the list
        //
        
        if ((pValueEntry->pDataList == NULL) || (pValueEntry->pDataList->pNext->bDeleted))         
            opnType = REG_ADDVALUE;
        else
            return TRUE;
            // return without adding the value.
    }


    pDataEntry = AllocDataEntry( opnType, dwType, dwLen, pData,
									pwszGPO, pwszSOM, pwszCommand );
    if ( pDataEntry == NULL )
        return FALSE;
    
    //
    // Prepend to data list because entries at beginning of list have higher precedence
    //

    pDataEntry->pNext = pValueEntry->pDataList;
    pValueEntry->pDataList = pDataEntry;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\brandll\reghash.h ===
//*************************************************************
//
//  Hash table for registry Rsop data
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1999
//  All rights reserved
//
//  History:    7-Jun-99   SitaramR    Created
//
//*************************************************************

#define HASH_TABLE_SIZE 97                  // # buckets in hash table
#define STARCOMMAND     TEXT("**Command")   // A special valuename created to keep the commands
//
// List of data values for key registry value in precedence order,
// entries at the beginning of list have higher precedence.
//

typedef struct _REGDATAENTRY {
    BOOL                      bDeleted;        // Is this a deleted value ?
    BOOL                      bAdmPolicy;      // Is this generated by an Adm policy ?
    DWORD                     dwValueType;
    DWORD                     dwDataLen;
    BYTE  *                   pData;
    WCHAR *                   pwszGPO;         // Gpo that set this data
    WCHAR *                   pwszSOM;         // SDOU that the above Gpo is linked to
    WCHAR *                   pwszCommand;     // The actual command that caused the change in data value
    struct _REGDATAENTRY *    pNext;
} REGDATAENTRY, *LPREGDATAENTRY;


//
// List of registry value names under a common registry key
//

typedef struct _REGVALUEENTRY {
    WCHAR *                   pwszValueName;    // Registry value name
    REGDATAENTRY *            pDataList;
    struct _REGVALUEENTRY *   pNext;

} REGVALUEENTRY, *LPREGVALUEENTRY;



//
// List of registry keys that map to same hash bucket
//

typedef struct _REGKEYENTRY {
	BOOL					bHKCU;
    WCHAR *                 pwszKeyName;        // Registry key name
    REGVALUEENTRY *         pValueList;
    struct _REGKEYENTRY *   pNext;
} REGKEYENTRY, *LPREGKEYENTRY;


//
// Hash table for looking up registry keys
//

typedef struct _REGHASHTABLE {
    REGKEYENTRY *   aHashTable[HASH_TABLE_SIZE];
    HRESULT         hrError;
} REGHASHTABLE, *LPREGHASHTABLE;


//
// Registry operation types for deleting and
// adding values.
//

typedef enum _REGOPERATION {
    REG_DELETEVALUE = 0,
    REG_DELETEALLVALUES,
    REG_DELETEKEY,
    REG_ADDVALUE,
    REG_SOFTADDVALUE,
    REG_INTERNAL_DELETESINGLEKEY
} REGOPERATION;

//
// Public methods of hash table: alloc, free and addentry
//

#ifdef __cplusplus
extern "C" {
#endif

REGHASHTABLE * AllocHashTable();

void FreeHashTable( REGHASHTABLE *pHashTable );

BOOL AddRegHashEntry( REGHASHTABLE *pHashTable,
                      REGOPERATION opnType,
					  BOOL bHKCU,
                      WCHAR *pwszKeyName,
                      WCHAR *pwszValueName,
                      DWORD dwType,
                      DWORD dwDataLen,
                      BYTE *pData,
                      WCHAR *pwszGPO,
                      WCHAR *pwszSOM,
                      WCHAR *szCommand, 
                      BOOL bCreateCommand);
#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\brandll\rsopsec.cpp ===
#include "precomp.h"

// BUGBUG: (andrewgu) no need to say how bad this is!
#undef   WINVER
#define  WINVER 0x0501
#include <userenv.h>

#include "RSoP.h"

#include <tchar.h>
#include <wincrypt.h>


#define g_dwMsgAndCertEncodingType  PKCS_7_ASN_ENCODING | X509_ASN_ENCODING

HRESULT SystemTimeToWbemTime(SYSTEMTIME& sysTime, _bstr_t &xbstrWbemTime);


extern SAFEARRAY *CreateSafeArray(VARTYPE vtType, long nElements, long nDimensions = 1);

///////////////////////////////////////////////////////////
HRESULT CRSoPGPO::StoreStringArrayFromIniFile(LPCTSTR szSection, LPCTSTR szKeyFormat,
											  ULONG nArrayInitialSize, ULONG nArrayIncSize,
											  LPCTSTR szFile, BSTR bstrPropName,
											  ComPtr<IWbemClassObject> pWbemObj)
{
	HRESULT hr = NOERROR;
	__try
	{
		ULONG nStrArraySize = nArrayInitialSize;
		BSTR *paStrs = (BSTR*)CoTaskMemAlloc(sizeof(BSTR) * nStrArraySize);
		if (NULL != paStrs)
		{
			ZeroMemory(paStrs, sizeof(BSTR) * nStrArraySize);
			long nStrCount = 0;

			TCHAR szKey[32];
			for (int nItem = 0; ; nItem++)
			{
				wnsprintf(szKey, countof(szKey), szKeyFormat, nItem);

				TCHAR szValue[MAX_PATH];
				if (!GetPrivateProfileString(szSection, szKey, TEXT(""), szValue, ARRAYSIZE(szValue), szFile))
					break;

				// Grow the strings array if we've outgrown the current array
				if (nStrCount == (long)nStrArraySize)
				{
					paStrs = (BSTR*)CoTaskMemRealloc(paStrs, sizeof(BSTR) * (nStrArraySize + nArrayIncSize));
					if (NULL != paStrs)
						nStrArraySize += nArrayIncSize;
				}

				// Add this string to the WMI array of strings
				paStrs[nStrCount] = SysAllocString(szValue);
				nStrCount++;
			}

			// Create a SAFEARRAY from our array of bstr strings
			SAFEARRAY *psa = CreateSafeArray(VT_BSTR, nStrCount);
			for (long nStr = 0; nStr < nStrCount; nStr++) 
				SafeArrayPutElement(psa, &nStr, paStrs[nStr]);

			if (nStrCount > 0)
			{
				VARIANT vtData;
				vtData.vt = VT_BSTR | VT_ARRAY;
				vtData.parray = psa;

				//------------------------------------------------
				// bstrPropName
				hr = PutWbemInstancePropertyEx(bstrPropName, vtData, pWbemObj);
			}

			// free up the strings array
			for (nStr = 0; nStr < nStrCount; nStr++) 
				SysFreeString(paStrs[nStr]);
			SafeArrayDestroy(psa);
			CoTaskMemFree(paStrs);
		}
	}
	__except(TRUE)
	{
	}
	return hr;
}


///////////////////////////////////////////////////////////
HRESULT CRSoPGPO::StoreSecZonesAndContentRatings()
{   MACRO_LI_PrologEx_C(PIF_STD_C, StoreSecZonesAndContentRatings)
	HRESULT hr = NOERROR;
	__try
	{
		//------------------------------------------------
		// importSecurityZoneSettings
		BOOL bValue = GetInsBool(SECURITY_IMPORTS, TEXT("ImportSecZones"), FALSE);
		if (bValue)
			hr = PutWbemInstanceProperty(L"importSecurityZoneSettings", true);

		// TODO: eventually create associations to these security classes from
		// RSOP_IEAKPolicySetting

		// First open the INF file and get 2 contexts going - for HKLM and for HKCU
		// Get the path of the seczones.inf file
		TCHAR szRSOPZoneFile[MAX_PATH];
		TCHAR szRSOPRatingsFile[MAX_PATH];

		StrCpy(szRSOPZoneFile, m_szINSFile);
		PathRemoveFileSpec(szRSOPZoneFile);
		StrCpy(szRSOPRatingsFile, szRSOPZoneFile);

		StrCat(szRSOPZoneFile, TEXT("\\seczrsop.inf"));
		OutD(LI1(TEXT("Reading from %s"), szRSOPZoneFile));

		hr = StoreZoneSettings(szRSOPZoneFile);

		StrCat(szRSOPRatingsFile, TEXT("\\ratrsop.inf"));
		OutD(LI1(TEXT("Reading from %s"), szRSOPRatingsFile));

		hr = StoreRatingsSettings(szRSOPRatingsFile);

		//------------------------------------------------
		// importContentRatingsSettings
		bValue = GetInsBool(SECURITY_IMPORTS, TEXT("ImportRatings"), FALSE);
		if (bValue)
			hr = PutWbemInstanceProperty(L"importContentRatingsSettings", true);
	}
	__except(TRUE)
	{
		OutD(LI0(TEXT("Exception in StoreSecZonesAndContentRatings.")));
	}

  return hr;
}

///////////////////////////////////////////////////////////
HRESULT CRSoPGPO::StoreZoneSettings(LPCTSTR szFile)
{   MACRO_LI_PrologEx_C(PIF_STD_C, StoreZoneSettings)

	HRESULT hr = NOERROR;
    BOOL fHardenedGP = GetPrivateProfileInt(SECURITY_IMPORTS, IK_IEESC, 0, szFile);

    if(IsIEHardened())
    {
        Out(LI0(TEXT("IE is hardened")));
    }

    if(fHardenedGP)
    {
        Out(LI0(TEXT("It is hardened gp")));
    }

    //In logging mode, If this is a hardened policy and we are applying on a softened machine, 
    //then don't log the settings, because they will not be applied.
    if(!m_fPlanningMode && ((!fHardenedGP && IsIEHardened()) || (fHardenedGP && !IsIEHardened())))
    {
        PutWbemInstanceProperty(L"importSecurityZoneSettings", false);
        Out(LI0(TEXT("GP state does not match the machine state. Not Logging security settings")));
        return S_OK;
    }
    
    __try
    {
        if(!m_fPlanningMode)
        {
            _bstr_t bstrClass = L"RSOP_IEESC";
            ComPtr<IWbemClassObject> pIEEsc = NULL;
            hr = CreateRSOPObject(bstrClass, &pIEEsc);
            if(SUCCEEDED(hr))
            {
                OutD(LI0(TEXT("RSOP_IEESC Setting EscEnabled")));
                if(FAILED(PutWbemInstancePropertyEx(L"EscEnabled", fHardenedGP? true : false, pIEEsc)))
                {
                    OutD(LI0(TEXT("Put Property for EscEnabled failed")));
                }

                if(FAILED(PutWbemInstancePropertyEx(L"rsopPrecedence", (long)m_dwPrecedence, pIEEsc)))
                {
                    OutD(LI0(TEXT("Put Property for  rsopPrecedence failed ")));
                }

                if(FAILED(PutWbemInstancePropertyEx(L"rsopID", m_bstrID, pIEEsc)))
                {
                    OutD(LI0(TEXT("Put Property for  rsopID failed ")));
                }

                BSTR bstrNewObjPath = NULL;
                hr = PutWbemInstance(pIEEsc, bstrClass, &bstrNewObjPath);
                if(FAILED(hr))
                {
                    Out(LI0(TEXT("PutWbemInstance for RSOP_IEESC failed.")));
                }
            }
            else
            {
                //We should see this only when you run this dll on downlevel OS. 
                Out(LI0(TEXT("RSOP_IEESC failed. Probably running on downlevel")));
            }
        }
        
        //ignore failures setting ESC object
        hr = S_OK;

		_bstr_t bstrClass = L"RSOP_IESecurityZoneSettings";
		DWORD dwZoneCount = GetPrivateProfileInt(SECURITY_IMPORTS, IK_ZONES, 0, szFile);
		
		//------------------------------------------------
		// importedZoneCount
		if (dwZoneCount > 0)
			hr = PutWbemInstanceProperty(L"importedZoneCount", (long)dwZoneCount);

		TCHAR szSection[32];
		for (UINT nZone = 0; nZone < dwZoneCount; nZone++)
		{
			for (int nHKLM = 0; nHKLM < 2; nHKLM++)
			{
				ComPtr<IWbemClassObject> pZoneObj = NULL;
				hr = CreateRSOPObject(bstrClass, &pZoneObj);
				if (SUCCEEDED(hr))
				{
					BOOL fUseHKLM = (0 == nHKLM) ? FALSE : TRUE;
					wnsprintf(szSection, countof(szSection),
								fUseHKLM ? IK_ZONE_HKLM_FMT : IK_ZONE_HKCU_FMT, nZone);

					// Write foreign keys from our stored precedence & id fields
					OutD(LI2(TEXT("Storing property 'rsopPrecedence' in %s, value = %lx"), (BSTR)bstrClass, m_dwPrecedence));
					hr = PutWbemInstancePropertyEx(L"rsopPrecedence", (long)m_dwPrecedence, pZoneObj);

					OutD(LI2(TEXT("Storing property 'rsopID' in %s, value = %s"), (BSTR)bstrClass, (BSTR)m_bstrID));
					hr = PutWbemInstancePropertyEx(L"rsopID", m_bstrID, pZoneObj);

					//------------------------------------------------
					// zoneIndex
					hr = PutWbemInstancePropertyEx(L"zoneIndex", (long)nZone, pZoneObj);

					//------------------------------------------------
					// useHKLM
					hr = PutWbemInstancePropertyEx(L"useHKLM", fUseHKLM ? true : false, pZoneObj);

					//
					// Get the zone attributes
					//

					//------------------------------------------------
					// displayName
					TCHAR szValue[MAX_PATH];
			        GetPrivateProfileString(szSection, IK_DISPLAYNAME, TEXT(""), szValue, ARRAYSIZE(szValue), szFile);
					hr = PutWbemInstancePropertyEx(L"displayName", szValue, pZoneObj);

					//------------------------------------------------
					// description
			        GetPrivateProfileString(szSection, IK_DESCRIPTION, TEXT(""), szValue, ARRAYSIZE(szValue), szFile);
					hr = PutWbemInstancePropertyEx(L"description", szValue, pZoneObj);

					//------------------------------------------------
					// iconPath
			        GetPrivateProfileString(szSection, IK_ICONPATH, TEXT(""), szValue, ARRAYSIZE(szValue), szFile);
					hr = PutWbemInstancePropertyEx(L"iconPath", szValue, pZoneObj);


					//------------------------------------------------
					// minimumTemplateLevel
			        DWORD dwValue = GetPrivateProfileInt(szSection, IK_MINLEVEL, 0, szFile);
					hr = PutWbemInstancePropertyEx(L"minimumTemplateLevel", (long)dwValue, pZoneObj);

					//------------------------------------------------
					// recommendedTemplateLevel
			        dwValue = GetPrivateProfileInt(szSection, IK_RECOMMENDLEVEL, 0, szFile);
					hr = PutWbemInstancePropertyEx(L"recommendedTemplateLevel", (long)dwValue, pZoneObj);

					//------------------------------------------------
					// currentTemplateLevel
			        dwValue = GetPrivateProfileInt(szSection, IK_CURLEVEL, 0, szFile);
					hr = PutWbemInstancePropertyEx(L"currentTemplateLevel", (long)dwValue, pZoneObj);

					//------------------------------------------------
					// flags
			        dwValue = GetPrivateProfileInt(szSection, IK_FLAGS, 0, szFile);
					hr = PutWbemInstancePropertyEx(L"flags", (long)dwValue, pZoneObj);


					// Get the zone action settings
					//------------------------------------------------
					// actionValues
					hr = StoreStringArrayFromIniFile(szSection, IK_ACTIONVALUE_FMT,
													30, 5, szFile, L"actionValues",
													pZoneObj);

					// write out zone mappings
					//------------------------------------------------
					// zoneMappings
					hr = StoreStringArrayFromIniFile(szSection, IK_MAPPING_FMT,
													20, 5, szFile, L"zoneMappings",
													pZoneObj);


					//
					// Commit all above properties by calling PutInstance, semisynchronously
					//
					BSTR bstrNewObjPath = NULL;
					hr = PutWbemInstance(pZoneObj, bstrClass, &bstrNewObjPath);
				}
			}
		}

		// Now store privacy settings which are interdependent with security zones
		hr = StorePrivacySettings(szFile);
	}
	__except(TRUE)
	{
		OutD(LI0(TEXT("Exception in StoreZoneSettings.")));
	}

  return hr;
}

///////////////////////////////////////////////////////////
HRESULT CRSoPGPO::StorePrivacySettings(LPCTSTR szFile)
{   MACRO_LI_PrologEx_C(PIF_STD_C, StorePrivacySettings)

	HRESULT hr = NOERROR;
	__try
	{
		_bstr_t bstrClass = L"RSOP_IEPrivacySettings";

		ComPtr<IWbemClassObject> pPrivObj = NULL;
		hr = CreateRSOPObject(bstrClass, &pPrivObj);
		if (SUCCEEDED(hr))
		{
			// Write foreign keys from our stored precedence & id fields
			OutD(LI2(TEXT("Storing property 'rsopPrecedence' in %s, value = %lx"), (BSTR)bstrClass, m_dwPrecedence));
			hr = PutWbemInstancePropertyEx(L"rsopPrecedence", (long)m_dwPrecedence, pPrivObj);

			OutD(LI2(TEXT("Storing property 'rsopID' in %s, value = %s"), (BSTR)bstrClass, (BSTR)m_bstrID));
			hr = PutWbemInstancePropertyEx(L"rsopID", m_bstrID, pPrivObj);

			// Store privacy settings
			//------------------------------------------------
			// firstPartyPrivacyType
			DWORD dwValue = GetPrivateProfileInt(IK_PRIVACY, IK_PRIV_1PARTY_TYPE, 0, szFile);
			hr = PutWbemInstancePropertyEx(L"firstPartyPrivacyType", (long)dwValue, pPrivObj);

			//------------------------------------------------
			// firstPartyPrivacyTypeText
			TCHAR szValue[MAX_PATH];
			GetPrivateProfileString(IK_PRIVACY, IK_PRIV_1PARTY_TYPE_TEXT, TEXT(""), szValue, ARRAYSIZE(szValue), szFile);
			hr = PutWbemInstancePropertyEx(L"firstPartyPrivacyTypeText", szValue, pPrivObj);

			//------------------------------------------------
			// thirdPartyPrivacyType
			dwValue = GetPrivateProfileInt(IK_PRIVACY, IK_PRIV_3PARTY_TYPE, 0, szFile);
			hr = PutWbemInstancePropertyEx(L"thirdPartyPrivacyType", (long)dwValue, pPrivObj);

			//------------------------------------------------
			// thirdPartyPrivacyTypeText
			GetPrivateProfileString(IK_PRIVACY, IK_PRIV_3PARTY_TYPE_TEXT, TEXT(""), szValue, ARRAYSIZE(szValue), szFile);
			hr = PutWbemInstancePropertyEx(L"thirdPartyPrivacyTypeText", szValue, pPrivObj);

			//------------------------------------------------
			// useAdvancedSettings
			dwValue = GetPrivateProfileInt(IK_PRIVACY, IK_PRIV_ADV_SETTINGS, 0, szFile);
			hr = PutWbemInstancePropertyEx(L"useAdvancedSettings", (0 == dwValue) ? false : true, pPrivObj);

			//
			// Commit all above properties by calling PutInstance, semisynchronously
			//
			BSTR bstrNewObjPath = NULL;
			hr = PutWbemInstance(pPrivObj, bstrClass, &bstrNewObjPath);
		}
	}
	__except(TRUE)
	{
		OutD(LI0(TEXT("Exception in StorePrivacySettings.")));
	}

  return hr;
}

///////////////////////////////////////////////////////////
HRESULT CRSoPGPO::StoreRatingsSettings(LPCTSTR szFile)
{   MACRO_LI_PrologEx_C(PIF_STD_C, StoreRatingsSettings)

	HRESULT hr = NOERROR;
	__try
	{
		_bstr_t bstrClass = L"RSOP_IESecurityContentRatings";

		ComPtr<IWbemClassObject> pRatObj = NULL;
		hr = CreateRSOPObject(bstrClass, &pRatObj);
		if (SUCCEEDED(hr))
		{
			// Write foreign keys from our stored precedence & id fields
			OutD(LI2(TEXT("Storing property 'rsopPrecedence' in %s, value = %lx"), (BSTR)bstrClass, m_dwPrecedence));
			hr = PutWbemInstancePropertyEx(L"rsopPrecedence", (long)m_dwPrecedence, pRatObj);

			OutD(LI2(TEXT("Storing property 'rsopID' in %s, value = %s"), (BSTR)bstrClass, (BSTR)m_bstrID));
			hr = PutWbemInstancePropertyEx(L"rsopID", m_bstrID, pRatObj);

			// Store rating system filenames
			//------------------------------------------------
			// ratingSystemFileNames
			hr = StoreStringArrayFromIniFile(IK_FF_GENERAL, TEXT("FileName%i"),
											10, 5, szFile, L"ratingSystemFileNames",
											pRatObj);

			//------------------------------------------------
			// viewUnknownRatedSites
			DWORD dwValue = GetPrivateProfileInt(IK_FF_GENERAL, VIEW_UNKNOWN_RATED_SITES, 0, szFile);
			hr = PutWbemInstancePropertyEx(L"viewUnknownRatedSites", (0 == dwValue) ? false : true, pRatObj);

			//------------------------------------------------
			// passwordOverrideEnabled
			dwValue = GetPrivateProfileInt(IK_FF_GENERAL, PASSWORD_OVERRIDE_ENABLED, 0, szFile);
			hr = PutWbemInstancePropertyEx(L"passwordOverrideEnabled", (0 == dwValue) ? false : true, pRatObj);

			// Store approved sites
			//------------------------------------------------
			// alwaysViewableSites
			hr = StoreStringArrayFromIniFile(IK_FF_GENERAL, TEXT("Approved%i"),
											10, 5, szFile, L"alwaysViewableSites",
											pRatObj);

			// Store disapproved sites
			//------------------------------------------------
			// neverViewableSites
			hr = StoreStringArrayFromIniFile(IK_FF_GENERAL, TEXT("Disapproved%i"),
											10, 5, szFile, L"neverViewableSites",
											pRatObj);

			//------------------------------------------------
			// selectedRatingsBureau
			TCHAR szValue[MAX_PATH];
			if (GetPrivateProfileString(IK_FF_GENERAL, IK_BUREAU, TEXT(""),
										szValue, ARRAYSIZE(szValue), szFile))
			{
				hr = PutWbemInstancePropertyEx(L"selectedRatingsBureau", szValue, pRatObj);
			}

			//
			// Commit all above properties by calling PutInstance, semisynchronously
			//
			BSTR bstrNewObjPath = NULL;
			hr = PutWbemInstance(pRatObj, bstrClass, &bstrNewObjPath);
		}
	}
	__except(TRUE)
	{
		OutD(LI0(TEXT("Exception in StoreRatingsSettings.")));
	}

  return hr;
}

///////////////////////////////////////////////////////////
HRESULT CRSoPGPO::StoreAuthenticodeSettings()
{   MACRO_LI_PrologEx_C(PIF_STD_C, StoreAuthenticodeSettings)
	HRESULT hr = NOERROR;
	__try
	{
		//------------------------------------------------
		// importAuthenticodeSecurityInfo
		BOOL bValue = GetInsBool(SECURITY_IMPORTS, TEXT("ImportAuthCode"), FALSE);
		if (bValue)
		{
			hr = PutWbemInstanceProperty(L"importAuthenticodeSecurityInfo", true);

			hr = StoreCertificates();
		}

		//------------------------------------------------
		// enableTrustedPublisherLockdown
		bValue = GetInsBool(SECURITY_IMPORTS, IK_TRUSTPUBLOCK, FALSE);
		if (bValue)
			hr = PutWbemInstanceProperty(L"enableTrustedPublisherLockdown", true);
	}
	__except(TRUE)
	{
		OutD(LI0(TEXT("Exception in StoreAuthenticodeSettings.")));
	}

  return hr;
}

///////////////////////////////////////////////////////////
//  Check to see if the certificate is an end-entity cert
//
///////////////////////////////////////////////////////////
BOOL IsCertificateEndEntity(PCCERT_CONTEXT pCertContext)
{
    PCERT_EXTENSION                     pCertExt=NULL;
    BOOL                                fEndEntity=FALSE;
    DWORD                               cbData=0;
    PCERT_BASIC_CONSTRAINTS_INFO        pBasicInfo=NULL;
    PCERT_BASIC_CONSTRAINTS2_INFO       pBasicInfo2=NULL;

    if(!pCertContext)
        return FALSE;

    //get the extension szOID_BASIC_CONSTRAINTS2
    pCertExt=CertFindExtension(
              szOID_BASIC_CONSTRAINTS2,
              pCertContext->pCertInfo->cExtension,
              pCertContext->pCertInfo->rgExtension);


    if(pCertExt)
    {
        //deocde the extension
        cbData=0;

        if(!CryptDecodeObject(
                X509_ASN_ENCODING,
                X509_BASIC_CONSTRAINTS2,
                pCertExt->Value.pbData,
                pCertExt->Value.cbData,
                0,
                NULL,
                &cbData))
            goto CLEANUP;

       pBasicInfo2=(PCERT_BASIC_CONSTRAINTS2_INFO)LocalAlloc(LPTR, cbData);

       if(NULL==pBasicInfo2)
           goto CLEANUP;

        if(!CryptDecodeObject(
                X509_ASN_ENCODING,
                X509_BASIC_CONSTRAINTS2,
                pCertExt->Value.pbData,
                pCertExt->Value.cbData,
                0,
                pBasicInfo2,
                &cbData))
            goto CLEANUP;

        if(pBasicInfo2->fCA)
            fEndEntity=FALSE;
        else
            fEndEntity=TRUE;
    }
    else
    {
        //get the extension szOID_BASIC_CONSTRAINTS
        pCertExt=CertFindExtension(
                  szOID_BASIC_CONSTRAINTS,
                  pCertContext->pCertInfo->cExtension,
                  pCertContext->pCertInfo->rgExtension);

        if(pCertExt)
        {
            //deocde the extension
            cbData=0;

            if(!CryptDecodeObject(
                    X509_ASN_ENCODING,
                    X509_BASIC_CONSTRAINTS,
                    pCertExt->Value.pbData,
                    pCertExt->Value.cbData,
                    0,
                    NULL,
                    &cbData))
                goto CLEANUP;

           pBasicInfo=(PCERT_BASIC_CONSTRAINTS_INFO)LocalAlloc(LPTR, cbData);

           if(NULL==pBasicInfo)
               goto CLEANUP;

            if(!CryptDecodeObject(
                    X509_ASN_ENCODING,
                    X509_BASIC_CONSTRAINTS,
                    pCertExt->Value.pbData,
                    pCertExt->Value.cbData,
                    0,
                    pBasicInfo,
                    &cbData))
                goto CLEANUP;

            if(0 == pBasicInfo->SubjectType.cbData)
            {
                fEndEntity=FALSE;
            }
            else
            {

                if(CERT_END_ENTITY_SUBJECT_FLAG & (pBasicInfo->SubjectType.pbData[0]))
                    fEndEntity=TRUE;
                else
                {
                    if(CERT_CA_SUBJECT_FLAG & (pBasicInfo->SubjectType.pbData[0]))
                      fEndEntity=FALSE;
                }
            }
        }
    }


CLEANUP:

    if(pBasicInfo)
        LocalFree((HLOCAL)pBasicInfo);

    if(pBasicInfo2)
        LocalFree((HLOCAL)pBasicInfo2);

    return fEndEntity;

}

BOOL TrustIsCertificateSelfSigned(PCCERT_CONTEXT pContext,
								  DWORD dwEncoding, DWORD dwFlags)
{
    if (!(pContext) ||
        (dwFlags != 0))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    if (!(CertCompareCertificateName(dwEncoding, 
                                     &pContext->pCertInfo->Issuer,
                                     &pContext->pCertInfo->Subject)))
    {
        return(FALSE);
    }

    DWORD dwFlag = CERT_STORE_SIGNATURE_FLAG;
    if (!(CertVerifySubjectCertificateContext(pContext, pContext, &dwFlag)) || 
        (dwFlag & CERT_STORE_SIGNATURE_FLAG))
    {
        return(FALSE);
    }

    return(TRUE);
}

//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
BOOL MyGetOIDInfo(LPWSTR string, DWORD stringSize, LPSTR pszObjId)
{   
    PCCRYPT_OID_INFO pOIDInfo;
            
    pOIDInfo = CryptFindOIDInfo(
                CRYPT_OID_INFO_OID_KEY, 
                pszObjId, 
                0);

    if (pOIDInfo != NULL)
    {
        if ((DWORD)wcslen(pOIDInfo->pwszName)+1 <= stringSize)
        {
            wcscpy(string, pOIDInfo->pwszName);
        }
        else
        {
            return FALSE;
        }
    }
    else
    {
        return (MultiByteToWideChar(CP_ACP, 0, pszObjId, -1, string, stringSize) != 0);
    }
    return TRUE;
}

#define CRYPTUI_MAX_STRING_SIZE 768
//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
BOOL FormatEnhancedKeyUsageString(LPWSTR *ppString, PCCERT_CONTEXT pCertContext, BOOL fPropertiesOnly, BOOL fMultiline)
{
    CERT_ENHKEY_USAGE   *pKeyUsage = NULL;
    DWORD               cbKeyUsage = 0;
    DWORD               numChars = 1;
    WCHAR               szText[CRYPTUI_MAX_STRING_SIZE];
    DWORD               i;

    //
    // Try to get the enhanced key usage property
    //

    if (!CertGetEnhancedKeyUsage (  pCertContext,
                                    fPropertiesOnly ? CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG : 0,
                                    NULL,
                                    &cbKeyUsage))
    {
        return FALSE;
    }

    if (NULL == (pKeyUsage = (CERT_ENHKEY_USAGE *) malloc(cbKeyUsage)))
    {
        return FALSE;
    }

    if (!CertGetEnhancedKeyUsage (  pCertContext,
                                    fPropertiesOnly ? CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG : 0,
                                    pKeyUsage,
                                    &cbKeyUsage))
    {
        free(pKeyUsage);
        return FALSE;
    }

    if (pKeyUsage->cUsageIdentifier == 0)
    {
        free (pKeyUsage);
        if (GetLastError() == CRYPT_E_NOT_FOUND)
        {
			LPWSTR wszTemp = L"<All>";
			*ppString = (LPWSTR) malloc((wcslen(wszTemp)+1) * sizeof(WCHAR));
			if (NULL == *ppString)
			{
				SetLastError((DWORD)E_OUTOFMEMORY);
                return FALSE; 
			}
			else
			{
				lstrcpyW(*ppString, wszTemp);
                return TRUE;
			}
        }
        else
        {
			LPWSTR wszTemp = L"<None>";
			*ppString = (LPWSTR) malloc((wcslen(wszTemp)+1) * sizeof(WCHAR));
			if (NULL == *ppString)
			{
				SetLastError((DWORD)E_OUTOFMEMORY);
                return FALSE; 
			}
			else
			{
				lstrcpyW(*ppString, wszTemp);
                return TRUE;
			}
        }
    }

    //
    // calculate size
    //

    // loop for each usage and add it to the display string
    for (i=0; i<pKeyUsage->cUsageIdentifier; i++)
    {
        if (MyGetOIDInfo(szText, ARRAYSIZE(szText), pKeyUsage->rgpszUsageIdentifier[i]))
        {
            // add delimeter if not first iteration
            if (i != 0)
            {
                numChars += 2;
            }

            numChars += (DWORD)wcslen(szText);
        }
        else
        {
            free (pKeyUsage);
            return FALSE;   
        }
    }

    if (NULL == (*ppString = (LPWSTR) malloc((numChars+1) * sizeof(WCHAR))))
    {
        free (pKeyUsage);
        return FALSE; 
    }

    //
    // copy to buffer
    //
    (*ppString)[0] = 0;
    // loop for each usage and add it to the display string
    for (i=0; i<pKeyUsage->cUsageIdentifier; i++)
    {
        if (MyGetOIDInfo(szText, ARRAYSIZE(szText), pKeyUsage->rgpszUsageIdentifier[i]))
        {
            // add delimeter if not first iteration
            if (i != 0)
            {
                if (fMultiline)
                    wcscat(*ppString, L"\n");
                else
                    wcscat(*ppString, L", ");
                    
                numChars += 2;
            }

            //  add the enhanced key usage string
            wcscat(*ppString, szText);
            numChars += (DWORD)wcslen(szText);
        }
        else
        {
            free (pKeyUsage);
            return FALSE;   
        }
    }

    free (pKeyUsage);
    return TRUE;
}

///////////////////////////////////////////////////////////
// Based on the tab(store) and the intended purpose selected,
// find the correct certificates and store them in WMI
// Criteria:
//      Tab 0:  My Store with private key
//      Tab 1:  Ca Store's end-entity cert and the "ADDRESSBOOK" store
//      Tab 2:  Ca Store's CA certs
//      Tab 3:  Root store's self signed certs
//      Tab 4:  Trusted publisher certs
///////////////////////////////////////////////////////////
HRESULT CRSoPGPO::StoreCertificates()
{   MACRO_LI_PrologEx_C(PIF_STD_C, StoreCertificates)
	HRESULT hr = NOERROR;
	__try
	{
	//TODO    FreeCerts(pCertMgrInfo);

		//open the correct store based on the tab selected
		HCERTSTORE rghCertStore[] = {NULL, NULL};
		BOOL bContinue = TRUE;
		for (DWORD dwTabIndex = 0; dwTabIndex < 5; dwTabIndex++)
		{
			DWORD dwStoreCount = 0;
			DWORD dwCertIndex = 0;
			switch (dwTabIndex)
			{
			case 0:
				//open my store
				rghCertStore[dwStoreCount] = CertOpenStore(CERT_STORE_PROV_SYSTEM_W,
															g_dwMsgAndCertEncodingType,
															NULL,
															CERT_STORE_MAXIMUM_ALLOWED_FLAG |
															CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG |
															CERT_SYSTEM_STORE_CURRENT_USER,
															(LPWSTR)L"my");
				if (NULL != rghCertStore[dwStoreCount])
					dwStoreCount++;
				else
					bContinue = FALSE;

				break;
			case 1:
				//open ca store
				rghCertStore[dwStoreCount] = CertOpenStore(CERT_STORE_PROV_SYSTEM_W,
															g_dwMsgAndCertEncodingType,
															NULL,
															CERT_STORE_MAXIMUM_ALLOWED_FLAG |
															CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG |
															CERT_SYSTEM_STORE_CURRENT_USER,
															(LPWSTR)L"ca");
				if(NULL != rghCertStore[dwStoreCount])
				{
					dwStoreCount++;

					//open the "AddressBook" store
					rghCertStore[dwStoreCount] = CertOpenStore(
								CERT_STORE_PROV_SYSTEM_W,
								g_dwMsgAndCertEncodingType,
								NULL,
								CERT_STORE_MAXIMUM_ALLOWED_FLAG |
								CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG |
								CERT_SYSTEM_STORE_CURRENT_USER |
								CERT_STORE_OPEN_EXISTING_FLAG,
								(LPWSTR)L"ADDRESSBOOK");

					if(NULL != rghCertStore[dwStoreCount])
						dwStoreCount++;
					else
					{
						//it is OK that user does not have "AddressBook" store
						rghCertStore[dwStoreCount]=NULL;
					}
				}
				else
					bContinue = FALSE;

				break;
			case 2:
				//open CA store
				rghCertStore[dwStoreCount] = CertOpenStore(CERT_STORE_PROV_SYSTEM_W,
															g_dwMsgAndCertEncodingType,
															NULL,
															CERT_STORE_MAXIMUM_ALLOWED_FLAG |
															CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG |
															CERT_SYSTEM_STORE_CURRENT_USER,
															(LPWSTR)L"ca");
				if(NULL != rghCertStore[dwStoreCount])
					dwStoreCount++;
				else
					bContinue = FALSE;

				break;
			case 3:
				//open root store
				rghCertStore[dwStoreCount] = CertOpenStore(CERT_STORE_PROV_SYSTEM_W,
															g_dwMsgAndCertEncodingType,
															NULL,
															CERT_STORE_MAXIMUM_ALLOWED_FLAG |
															CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG |
															CERT_SYSTEM_STORE_CURRENT_USER,
															(LPWSTR)L"root");
				if(NULL != rghCertStore[dwStoreCount])
					dwStoreCount++;
				else
					bContinue = FALSE;

				break;
			case 4:
				//open trusted publisher store
				rghCertStore[dwStoreCount] = CertOpenStore(CERT_STORE_PROV_SYSTEM_W,
															g_dwMsgAndCertEncodingType,
															NULL,
															CERT_STORE_MAXIMUM_ALLOWED_FLAG |
															CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG |
															CERT_SYSTEM_STORE_CURRENT_USER,
															(LPWSTR)L"TrustedPublisher");
				if(NULL != rghCertStore[dwStoreCount])
					dwStoreCount++;
				else
					bContinue = FALSE;

				break;
			default:
				bContinue = FALSE;
				break;
			}

			if (!bContinue)
			{
				OutD(LI1(TEXT("Exited prematurely in tab %d"), dwTabIndex));
				continue;
			}


			//gather new certificates from the store opened
			PCCERT_CONTEXT pCurCertContext = NULL;
			PCCERT_CONTEXT pPreCertContext = NULL;
			BOOL fValidCert = FALSE;
			for (DWORD dwIndex=0; dwIndex < dwStoreCount; dwIndex++)
			{
				pPreCertContext = NULL;
				pCurCertContext = CertEnumCertificatesInStore(rghCertStore[dwIndex],
																pPreCertContext);
				while (NULL != pCurCertContext)
				{
					DWORD cbData=0;
					switch (dwTabIndex)
					{
						case 0:
							//certificate has to have private key associated
							//with it
							if( (CertGetCertificateContextProperty(
									pCurCertContext, CERT_KEY_PROV_INFO_PROP_ID,	
									NULL, &cbData) && (0!=cbData)) ||
								(CertGetCertificateContextProperty(
									pCurCertContext, CERT_PVK_FILE_PROP_ID, NULL,	
									&cbData) && (0!=cbData)) )
							{
							   fValidCert=TRUE;
							}
							break;
						case 1:
							//the certificate has to be end entity cert for CA cert
							if(0 == dwIndex)
							{
								if (IsCertificateEndEntity(pCurCertContext))
									fValidCert=TRUE;
							}

							//we display everything in the addressbook store
							if(1==dwIndex)
								fValidCert=TRUE;
							break;
						case 2:
							//for certificate in CA store, has to be CA cert
							if(!IsCertificateEndEntity(pCurCertContext))
								fValidCert=TRUE;
							break;
						case 4:
							fValidCert=TRUE;
							break;
						case 3:
						default:
							//the certificate has to be self-signed
							if (TrustIsCertificateSelfSigned(pCurCertContext,
									pCurCertContext->dwCertEncodingType, 0))
							{
								fValidCert=TRUE;
							}

							break;
					}

					if (fValidCert)
					{
						// Create & populate RSOP_IEAuthenticodeCertificate
						_bstr_t bstrClass = L"RSOP_IEAuthenticodeCertificate";
						ComPtr<IWbemClassObject> pCert = NULL;
						HRESULT hr = CreateRSOPObject(bstrClass, &pCert);
						if (SUCCEEDED(hr))
						{
							// Write foreign keys from our stored precedence & id fields
							OutD(LI2(TEXT("Storing property 'rsopPrecedence' in %s, value = %lx"),
									(BSTR)bstrClass, m_dwPrecedence));
							hr = PutWbemInstancePropertyEx(L"rsopPrecedence", (long)m_dwPrecedence, pCert);

							OutD(LI2(TEXT("Storing property 'rsopID' in %s, value = %s"),
									(BSTR)bstrClass, (BSTR)m_bstrID));
							hr = PutWbemInstancePropertyEx(L"rsopID", m_bstrID, pCert);

							//------------------------------------------------
							// tabIndex
							hr = PutWbemInstancePropertyEx(L"tabIndex", (long)dwTabIndex, pCert);

							//------------------------------------------------
							// certIndex
							hr = PutWbemInstancePropertyEx(L"certIndex", (long)dwCertIndex, pCert);

							//------------------------------------------------
							// subjectName
							DWORD dwChar = CertGetNameStringW(pCurCertContext,
															CERT_NAME_SIMPLE_DISPLAY_TYPE,
															0, NULL, NULL, 0);

							LPWSTR wszVal = NULL;
							_bstr_t bstrVal;
							if (0 != dwChar)
								wszVal = (LPWSTR)LocalAlloc(LPTR, dwChar * sizeof(WCHAR));
							if (0 != dwChar && NULL != wszVal)
							{
								CertGetNameStringW(pCurCertContext,
													CERT_NAME_SIMPLE_DISPLAY_TYPE,
													0, NULL, wszVal, dwChar);

								bstrVal = wszVal;
								hr = PutWbemInstancePropertyEx(L"subjectName", bstrVal, pCert);

								//free the memory
								LocalFree((HLOCAL)wszVal);
								wszVal = NULL;
							}

							//------------------------------------------------
							// issuerName
							dwChar = CertGetNameStringW(pCurCertContext,
														CERT_NAME_SIMPLE_DISPLAY_TYPE,
														CERT_NAME_ISSUER_FLAG, NULL,
														NULL, 0);

							if (0 != dwChar)
								wszVal = (LPWSTR)LocalAlloc(LPTR, dwChar * sizeof(WCHAR));
							if (0 != dwChar && NULL != wszVal)
							{
								CertGetNameStringW(pCurCertContext,
													CERT_NAME_SIMPLE_DISPLAY_TYPE,
													CERT_NAME_ISSUER_FLAG,
													NULL, wszVal, dwChar);

								bstrVal = wszVal;
								hr = PutWbemInstancePropertyEx(L"issuerName", bstrVal, pCert);

								//free the memory
								LocalFree((HLOCAL)wszVal);
								wszVal = NULL;
							}

							//------------------------------------------------
							// expirationDate
							SYSTEMTIME sysTime;
							if (!FileTimeToSystemTime( &pCurCertContext->pCertInfo->NotAfter, &sysTime ))
								OutD(LI1(TEXT("FileTimeToSystemTime failed with 0x%x" ), GetLastError() ));
							else
							{
								_bstr_t bstrTime;
								HRESULT hr = SystemTimeToWbemTime(sysTime, bstrTime);
								if(FAILED(hr) || bstrTime.length() <= 0)
									OutD(LI1(TEXT("Call to SystemTimeToWbemTime failed. hr=0x%08X"), hr));
								else
								{
									hr = PutWbemInstancePropertyEx(L"expirationDate", bstrTime, pCert);
									if ( FAILED(hr) )
										OutD(LI1(TEXT("Put failed with 0x%x" ), hr ));
								}
							}

							//------------------------------------------------
							// friendlyName
							if (CertGetCertificateContextProperty(pCurCertContext,
																CERT_FRIENDLY_NAME_PROP_ID,
																NULL, &dwChar) && (0 != dwChar))
							{
								wszVal = (LPWSTR)LocalAlloc(LPTR, dwChar * sizeof(WCHAR));
								if (NULL != wszVal)
								{
								   CertGetCertificateContextProperty(pCurCertContext,
																	CERT_FRIENDLY_NAME_PROP_ID,
																	wszVal, &dwChar);
								}

								bstrVal = wszVal;
								hr = PutWbemInstancePropertyEx(L"friendlyName", bstrVal, pCert);

								//free the memory
								LocalFree((HLOCAL)wszVal);
								wszVal = NULL;
							}

							//------------------------------------------------
							// intendedPurposes
							if (FormatEnhancedKeyUsageString(&wszVal, pCurCertContext, FALSE, FALSE))
							{
								if (wszVal != NULL)
								{
									bstrVal = wszVal;
									hr = PutWbemInstancePropertyEx(L"intendedPurposes", bstrVal, pCert);

									free(wszVal);
									wszVal = NULL;
								}
							}
    

							//
							// Commit all above properties by calling PutInstance, semisynchronously
							//
							BSTR bstrCurCertObj = NULL;
							hr = PutWbemInstance(pCert, bstrClass, &bstrCurCertObj);
						}
					}

					fValidCert=FALSE;

					pPreCertContext=pCurCertContext;
					pCurCertContext = CertEnumCertificatesInStore(rghCertStore[dwIndex],
																	pPreCertContext);

					dwCertIndex++;
				}
			}

			//close all the certificate stores
			for (DWORD dwIndex=0; dwIndex<dwStoreCount; dwIndex++)
				CertCloseStore(rghCertStore[dwIndex], 0);
		} // end looping through 5 tabs
	}
	__except(TRUE)
	{
		OutD(LI0(TEXT("Exception in StoreCertificates.")));
	}

  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\brandll\rsopcs.cpp ===
#include "precomp.h"

// The following bug may be due to having CHICAGO_PRODUCT set in sources.
// This file and all rsop??.cpp files need to have WINVER defined at at least 500

// BUGBUG: (andrewgu) no need to say how bad this is!
#undef   WINVER
#define  WINVER 0x0501
#include <userenv.h>

#include "RSoP.h"

#include <rashelp.h>

#pragma warning(disable: 4201)                  // nonstandard extension used : nameless struct/union
#include <winineti.h>

#include <tchar.h>


// Private forward decalarations
extern void setSzFromBlobA(PBYTE *ppBlob, UNALIGNED CHAR  **ppszStrA);
extern void setSzFromBlobW(PBYTE *ppBlob, UNALIGNED WCHAR **ppszStrW);

//----- Miscellaneous -----
extern DWORD getWininetFlagsSetting(PCTSTR pszName = NULL);

//TODO: UNCOMMENT   TCHAR g_szConnectoidName[RAS_MaxEntryName + 1];

///////////////////////////////////////////////////////////
SAFEARRAY *CreateSafeArray(VARTYPE vtType, long nElements, long nDimensions = 1)
{
	SAFEARRAYBOUND *prgsabound = NULL;
	SAFEARRAY *psa = NULL;
	__try
	{
		//TODO: support multiple dimensions
		nDimensions = 1;

		prgsabound = (SAFEARRAYBOUND *)CoTaskMemAlloc(sizeof(SAFEARRAYBOUND) * nDimensions);
		prgsabound[0].lLbound = 0;
		prgsabound[0].cElements = nElements;
		psa = ::SafeArrayCreate(vtType, nDimensions, prgsabound);

		CoTaskMemFree(prgsabound);
	}
	__except(TRUE)
	{
		if (NULL != prgsabound)
			CoTaskMemFree((LPVOID)prgsabound);
		throw;
	}
	return psa;
}


///////////////////////////////////////////////////////////
HRESULT CRSoPGPO::StoreConnectionSettings(BSTR *pbstrConnSettingsObjPath,
										  BSTR **ppaDUSObjects, long &nDUSCount,
										  BSTR **ppaDUCObjects, long &nDUCCount,
										  BSTR **ppaWSObjects, long &nWSCount)
{   MACRO_LI_PrologEx_C(PIF_STD_C, StoreConnectionSettings)
	HRESULT hr = E_FAIL;
	__try
	{
		OutD(LI0(TEXT("\r\nEntered StoreConnectionSettings function.")));

		//
		// Create & populate RSOP_IEConnectionSettings
		//
		_bstr_t bstrClass = L"RSOP_IEConnectionSettings";
		ComPtr<IWbemClassObject> pCSObj = NULL;
		hr = CreateRSOPObject(bstrClass, &pCSObj);
		if (SUCCEEDED(hr))
		{
			hr = StoreProxySettings(pCSObj); // also writes foreign key fields
			hr = StoreAutoBrowserConfigSettings(pCSObj);

			//------------------------------------------------
			// importCurrentConnSettings
			// No tri-state on this.  Disabled state has to be NULL!
			BOOL bValue = GetInsBool(IS_CONNECTSET, IK_OPTION, FALSE);
			if (bValue)
				hr = PutWbemInstancePropertyEx(L"importCurrentConnSettings", true, pCSObj);

			//------------------------------------------------
			// deleteExistingConnSettings
			// No tri-state on this.  Disabled state has to be NULL!
			bValue = GetInsBool(IS_CONNECTSET, IK_DELETECONN, FALSE);
			if (bValue)
				hr = PutWbemInstancePropertyEx(L"deleteExistingConnSettings", true, pCSObj);

			//
			// Advanced settings from cs.dat
			//
			hr = ProcessAdvancedConnSettings(pCSObj,
											ppaDUSObjects, nDUSCount,
											ppaDUCObjects, nDUCCount,
											ppaWSObjects, nWSCount);
			//
			// Commit all above properties by calling PutInstance, semisynchronously
			//
			hr = PutWbemInstance(pCSObj, bstrClass, pbstrConnSettingsObjPath);
		}

	}
	__except(TRUE)
	{
		OutD(LI0(TEXT("Exception in StoreConnectionSettings.")));
	}

	OutD(LI0(TEXT("Exiting StoreConnectionSettings function.\r\n")));
  return hr;
}

///////////////////////////////////////////////////////////
HRESULT CRSoPGPO::StoreAutoBrowserConfigSettings(ComPtr<IWbemClassObject> pCSObj)
{   MACRO_LI_PrologEx_C(PIF_STD_C, StoreAutoBrowserConfigSettings)
	HRESULT hr = E_FAIL;
	__try
	{
		//------------------------------------------------
		// autoConfigURL
	    TCHAR szValue[MAX_PATH];
		BOOL bEnabled;
		GetInsString(IS_URL, IK_AUTOCONFURL, szValue, countof(szValue), bEnabled);
		if (bEnabled)
			hr = PutWbemInstancePropertyEx(L"autoConfigURL", szValue, pCSObj);

		//------------------------------------------------
		// autoConfigUseLocal
		BOOL bValue = GetInsBool(IS_URL, IK_LOCALAUTOCONFIG, FALSE, &bEnabled);
		if (bEnabled)
			hr = PutWbemInstancePropertyEx(L"autoConfigUseLocal", bValue ? true : false, pCSObj);

		//------------------------------------------------
		// autoProxyURL
		ZeroMemory(szValue, sizeof(szValue));
		GetInsString(IS_URL, IK_AUTOCONFURLJS, szValue, countof(szValue), bEnabled);
		if (bEnabled)
			hr = PutWbemInstancePropertyEx(L"autoProxyURL", szValue, pCSObj);

		//------------------------------------------------
		// autoConfigTime
	    long nValue = GetInsInt(IS_URL, IK_AUTOCONFTIME, 0, &bEnabled);
		if (bEnabled)
			hr = PutWbemInstancePropertyEx(L"autoConfigTime", nValue, pCSObj);

		//------------------------------------------------
		// autoDetectConfigSettings
		// No tri-state on this.  Disabled state has to be NULL!
		nValue = GetInsInt(IS_URL, IK_DETECTCONFIG, -1);
		if (TRUE == nValue)
			hr = PutWbemInstancePropertyEx(L"autoDetectConfigSettings", true, pCSObj);

		//------------------------------------------------
		// autoConfigEnable
		// No tri-state on this.  Disabled state has to be NULL!
		nValue = GetInsInt(IS_URL, IK_USEAUTOCONF,  -1);
		if (TRUE == nValue)
			hr = PutWbemInstancePropertyEx(L"autoConfigEnable", true, pCSObj);
	}
	__except(TRUE)
	{
		OutD(LI0(TEXT("Exception in StoreAutoBrowserConfigSettings.")));
	}

  return hr;
}

///////////////////////////////////////////////////////////
HRESULT CRSoPGPO::StoreProxySettings(ComPtr<IWbemClassObject> pCSObj)
{   MACRO_LI_PrologEx_C(PIF_STD_C, StoreProxySettings)
	HRESULT hr = E_FAIL;
	__try
	{
		OutD(LI0(TEXT("\r\nEntered StoreProxySettings function.")));

		// Write foreign keys from our stored precedence & id fields
		OutD(LI1(TEXT("Storing property 'rsopPrecedence' in RSOP_IEConnectionSettings, value = %lx"),
									m_dwPrecedence));
		hr = PutWbemInstancePropertyEx(L"rsopPrecedence", (long)m_dwPrecedence, pCSObj);

		OutD(LI1(TEXT("Storing property 'rsopID' in RSOP_IEConnectionSettings, value = %s"),
									m_bstrID));
		hr = PutWbemInstancePropertyEx(L"rsopID", m_bstrID, pCSObj);

		//------------------------------------------------
		// enableProxy
		// No tri-state on this.  Disabled state has to be NULL!
		BOOL bValue = GetInsBool(IS_PROXY, IK_PROXYENABLE, TRUE);
		if (TRUE == bValue)
			hr = PutWbemInstancePropertyEx(L"enableProxy", true, pCSObj);

		//------------------------------------------------
		// useSameProxy
		BOOL bEnabled;
		bValue = GetInsBool(IS_PROXY, IK_SAMEPROXY, FALSE, &bEnabled);
		if (bEnabled)
			hr = PutWbemInstancePropertyEx(L"useSameProxy", bValue ? true : false, pCSObj);

		//------------------------------------------------
		// httpProxyServer
		TCHAR szValue[MAX_PATH];
		GetInsString(IS_PROXY, IK_HTTPPROXY, szValue, countof(szValue), bEnabled);
		if (bEnabled)
			hr = PutWbemInstancePropertyEx(L"httpProxyServer", szValue, pCSObj);

		//------------------------------------------------
		// proxyOverride
		ZeroMemory(szValue, sizeof(szValue));
		GetInsString(IS_PROXY, IK_PROXYOVERRIDE, szValue, countof(szValue), bEnabled);
		if (bEnabled)
			hr = PutWbemInstancePropertyEx(L"proxyOverride", szValue, pCSObj);

		//------------------------------------------------
		// ftpProxyServer
		ZeroMemory(szValue, sizeof(szValue));
		GetInsString(IS_PROXY, IK_FTPPROXY, szValue, countof(szValue), bEnabled);
		if (bEnabled)
			hr = PutWbemInstancePropertyEx(L"ftpProxyServer", szValue, pCSObj);

		//------------------------------------------------
		// gopherProxyServer
		ZeroMemory(szValue, sizeof(szValue));
		GetInsString(IS_PROXY, IK_GOPHERPROXY, szValue, countof(szValue), bEnabled);
		if (bEnabled)
			hr = PutWbemInstancePropertyEx(L"gopherProxyServer", szValue, pCSObj);

		//------------------------------------------------
		// secureProxyServer
		ZeroMemory(szValue, sizeof(szValue));
		GetInsString(IS_PROXY, IK_SECPROXY, szValue, countof(szValue), bEnabled);
		if (bEnabled)
			hr = PutWbemInstancePropertyEx(L"secureProxyServer", szValue, pCSObj);

		//------------------------------------------------
		// socksProxyServer
		ZeroMemory(szValue, sizeof(szValue));
		GetInsString(IS_PROXY, IK_SOCKSPROXY, szValue, countof(szValue), bEnabled);
		if (bEnabled)
			hr = PutWbemInstancePropertyEx(L"socksProxyServer", szValue, pCSObj);
	}
	__except(TRUE)
	{
		OutD(LI0(TEXT("Exception in StoreProxySettings.")));
	}

	OutD(LI0(TEXT("Exiting StoreProxySettings function.\r\n")));
	return hr;
}

/////////////////////////////////////////////////////////////////////
HRESULT CRSoPGPO::ProcessAdvancedConnSettings(ComPtr<IWbemClassObject> pCSObj,
											  BSTR **ppaDUSObjects, long &nDUSCount,
											  BSTR **ppaDUCObjects, long &nDUCCount,
											  BSTR **ppaWSObjects, long &nWSCount)
{   MACRO_LI_PrologEx_C(PIF_STD_C, ProcessAdvancedConnSettings)

    USES_CONVERSION;

	HRESULT hr = E_FAIL;
	__try
	{
		LPRASDEVINFOW prdiW;
		TCHAR   szTargetFile[MAX_PATH],
				szApplyToName[RAS_MaxEntryName + 1];
		PCWSTR  pszCurNameW;
		PWSTR   pszNameW;
		PBYTE   pBuf, pCur;
		HANDLE  hFile;
		HRESULT hr;
		DWORD   dwVersion,
				cbBuffer, cbFile,
				cDevices;
		ULONG nNameArraySize = 0;
		BSTR *paNames = NULL;

		prdiW          = NULL;
		pszNameW       = NULL;
		pBuf           = NULL;
		hFile          = NULL;
		hr             = E_FAIL;
		cDevices       = 0;

		ULONG nDUSArraySize = 3;
		ULONG nDUCArraySize = 3;
		ULONG nWSArraySize = 4; // one extra for lan settings

		BSTR *paDUSObjects = (BSTR*)CoTaskMemAlloc(sizeof(BSTR) * nDUSArraySize);
		BSTR *paDUCObjects = (BSTR*)CoTaskMemAlloc(sizeof(BSTR) * nDUCArraySize);
		BSTR *paWSObjects = (BSTR*)CoTaskMemAlloc(sizeof(BSTR) * nWSArraySize);

		ULONG nDUSObj = 0;
		ULONG nDUCObj = 0;
		ULONG nWSObj = 0;
		BSTR *pCurDUSObj = paDUSObjects;
		BSTR *pCurDUCObj = paDUCObjects;
		BSTR *pCurWSObj = paWSObjects;

		//----- Global settings processing -----

		//------------------------------------------------
		// dialupState
		long nDialupState = 0;
		BOOL bEnabled;
		if (GetInsBool(IS_CONNECTSET, IK_NONETAUTODIAL, FALSE, &bEnabled))
			nDialupState = 1;
		else if (GetInsBool(IS_CONNECTSET, IK_ENABLEAUTODIAL, FALSE, &bEnabled))
			nDialupState = 2;

		if (bEnabled)
			hr = PutWbemInstancePropertyEx(L"dialupState", nDialupState, pCSObj);


		DWORD dwAux = 0;
		BOOL fSkipBlob = FALSE;
		BOOL fRasApisLoaded = FALSE;

		//----- Process version information -----
		if (!InsGetBool(IS_CONNECTSET, IK_OPTION, FALSE, m_szINSFile)) {
			hr = S_FALSE;
			goto PartTwo;
		}

		// Locate the path for the cs.dat file
		TCHAR szTargetDir[MAX_PATH];
		StrCpy(szTargetDir, m_szINSFile);
		PathRemoveFileSpec(szTargetDir);
		PathCombine(szTargetFile, szTargetDir, CS_DAT);
		if (PathFileExists(szTargetFile))
			dwAux = CS_VERSION_5X;

		if (0 == dwAux) {
			PathCombine(szTargetFile, szTargetDir, CONNECT_SET);
			if (PathFileExists(szTargetFile))
				dwAux = CS_VERSION_50;

			else {
				Out(LI0(TEXT("Connection settings file(s) is absent!")));
				goto PartTwo;
			}
		}
		ASSERT(0 != dwAux);

		hFile = CreateFile(szTargetFile, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
		if (hFile == INVALID_HANDLE_VALUE) {
			Out(LI0(TEXT("! Connections settings file(s) can't be opened.")));
			hr = STG_E_ACCESSDENIED;
			goto PartTwo;
		}

		SetFilePointer(hFile, 0, NULL, FILE_BEGIN);
		ReadFile(hFile, &dwVersion, sizeof(dwVersion), &cbFile, NULL);

		if (CS_VERSION_50 == dwVersion) {
			if (CS_VERSION_50 != dwAux) {
				Out(LI0(TEXT("! Version of connections settings file(s) is mismatched.")));
				goto PartTwo;
			}

			CloseFile(hFile);
			hFile = NULL;

			// TODO: convert this to RSoP
			OutD(LI0(TEXT("Would have called lcy50_ProcessConnectionSettings.")));
	//UNCOMMENT        hr = lcy50_ProcessConnectionSettings();
			goto PartTwo;
		}
		else if (CS_VERSION_5X <= dwVersion && CS_VERSION_5X_MAX >= dwVersion) {
			if (CS_VERSION_5X != dwAux) {
				Out(LI0(TEXT("! Version of connections settings file(s) is mismatched.")));
				goto PartTwo;
			}
		}
		else {
			Out(LI0(TEXT("! Version information in connection settings file(s) is corrupted.")));
			goto PartTwo;
		}

		Out(LI1(TEXT("Connection settings file is \"%s\"."), CS_DAT));
		Out(LI1(TEXT("The version of connection settings file is 0x%lX.\r\n"), dwVersion));

		//----- Read CS file into internal memory buffer -----
		cbBuffer = GetFileSize(hFile, NULL);
		if (cbBuffer == 0xFFFFFFFF) {
			Out(LI0(TEXT("! Internal processing error.")));
			goto PartTwo;
		}
		cbBuffer -= sizeof(dwVersion);

		pBuf = (PBYTE)CoTaskMemAlloc(cbBuffer);
		if (pBuf == NULL) {
			Out(LI0(TEXT("! Internal processing ran out of memory.")));
			hr = E_OUTOFMEMORY;
			goto PartTwo;
		}
		ZeroMemory(pBuf, cbBuffer);

		ReadFile (hFile, pBuf, cbBuffer, &cbFile, NULL);
		CloseFile(hFile);
		hFile = NULL;

		pCur = pBuf;

		//----- Get information about RAS devices on the local system -----
		if (!RasIsInstalled())
			Out(LI0(TEXT("RAS support is not installed. Only LAN settings will be processed!\r\n")));

		else {
			fRasApisLoaded = (RasPrepareApis(RPA_RASSETENTRYPROPERTIESA) && g_pfnRasSetEntryPropertiesA != NULL);
			if (!fRasApisLoaded)
				Out(LI0(TEXT("! Required RAS APIs failed to load. Only LAN settings will be processed.\r\n")));
		}

		if (fRasApisLoaded) {
			RasEnumDevicesExW(&prdiW, NULL, &cDevices);
			if (cDevices == 0)
				Out(LI0(TEXT("There are no RAS devices to connect to. Only LAN settings will be processed!\r\n")));
		}


		nNameArraySize = 5;
		paNames = (BSTR*)CoTaskMemAlloc(sizeof(BSTR) * nNameArraySize);
		if (NULL != paNames)
		{
			ZeroMemory(paNames, sizeof(BSTR) * nNameArraySize);
			long nNameCount = 0;
			BOOL bNewConn = FALSE;

			//----- Main loop -----
			pszCurNameW = L"";
			hr = S_OK;

			if (NULL != paDUSObjects && NULL != paDUCObjects && NULL != paWSObjects)
			{
				ZeroMemory(paDUSObjects, sizeof(BSTR) * nDUSArraySize);
				ZeroMemory(paDUCObjects, sizeof(BSTR) * nDUCArraySize);
				ZeroMemory(paWSObjects, sizeof(BSTR) * nWSArraySize);

				nDUSCount = 0;
				nDUCCount = 0;
				nWSCount = 0;

				while (pCur < pBuf + cbBuffer && nDUSObj < nDUSArraySize &&
						nDUCObj < nDUCArraySize && nWSObj < nWSArraySize)
				{
					//_____ Determine connection name _____
					if (*((PDWORD)pCur) == CS_STRUCT_HEADER) {
						if (bNewConn)
						{
							bNewConn = FALSE;

							// Grow the names array if we've outgrown the current array
							if (nNameCount == (long)nNameArraySize)
							{
								paNames = (BSTR*)CoTaskMemRealloc(paNames, sizeof(BSTR) * (nNameArraySize + 5));
								if (NULL != paNames)
									nNameArraySize += 5;
							}

							// Add this name to the WMI array of connection name strings
							paNames[nNameCount] = SysAllocString(pszNameW);
							nNameCount++;
						}

						pCur += 2*sizeof(DWORD);
						setSzFromBlobW(&pCur, &pszNameW);
					}

					//_____ Special case no RAS or no RAS devices _____
					// NOTE: (andrewgu) in this case it makes sense to process wininet settings for LAN only.
					if (!fRasApisLoaded || cDevices == 0) {
						if (pszNameW != NULL || *((PDWORD)pCur) != CS_STRUCT_WININET) {
							pCur += *((PDWORD)(pCur + sizeof(DWORD)));
							continue;
						}

						ASSERT(pszNameW == NULL && *((PDWORD)pCur) == CS_STRUCT_WININET);
					}

					//_____ Main processing _____
					if (pszCurNameW != pszNameW) {
						fSkipBlob = FALSE;

						if (TEXT('\0') != *pszCurNameW)     // tricky: empty string is an invalid name
							Out(LI0(TEXT("Done.")));        // if not that, there were connections before

						if (NULL != pszNameW) {
							PCTSTR pszName;

							pszName = W2CT(pszNameW);
							Out(LI1(TEXT("Proccessing settings for \"%s\" connection..."), pszName));
						}
						else {
							Out(LI0(TEXT("Proccessing settings for LAN connection...")));

							// ASSUMPTION: (andrewgu) if connection settings marked branded in the registry -
							// LAN settings have already been enforced. (note, that technically it may not be
							// true - if there is no cs.dat and *.ins customized ras connection through
							// IK_APPLYTONAME)
							fSkipBlob = (g_CtxIs(CTX_GP) && g_CtxIs(CTX_MISC_PREFERENCES)) && FF_DISABLE != GetFeatureBranded(FID_CS_MAIN);
							if (fSkipBlob)
								Out(LI0(TEXT("These settings have been enforced through policies!\r\n")));
						}

						pszCurNameW = pszNameW;
					}

					if (fSkipBlob) {
						pCur += *((PDWORD)(pCur + sizeof(DWORD)));
						continue;
					}

					switch (*((PDWORD)pCur)) {
					case CS_STRUCT_RAS:
						bNewConn = TRUE;
						hr = ProcessRasCS(pszNameW, &pCur, prdiW, cDevices, pCSObj, pCurDUSObj);
						if (SUCCEEDED(hr))
						{
							nDUSCount++;

							// Grow the array of obj paths if we've outgrown the current array
							if (nDUSCount == (long)nDUSArraySize)
							{
								paDUSObjects = (BSTR*)CoTaskMemRealloc(paDUSObjects, sizeof(BSTR) * (nDUSArraySize + 3));
								if (NULL != paDUSObjects)
									nDUSArraySize += 3;
							}

							nDUSObj++;
							pCurDUSObj = paDUSObjects + nDUSCount;
						}
						else
							Out(LI1(TEXT("ProcessRasCS returned error: %lx"), hr));
						break;

					case CS_STRUCT_RAS_CREADENTIALS:
						bNewConn = TRUE;
						hr = ProcessRasCredentialsCS(pszNameW, &pCur, pCSObj, pCurDUCObj);
						if (SUCCEEDED(hr))
						{
							nDUCCount++;

							// Grow the array of obj paths if we've outgrown the current array
							if (nDUCCount == (long)nDUCArraySize)
							{
								paDUCObjects = (BSTR*)CoTaskMemRealloc(paDUCObjects, sizeof(BSTR) * (nDUCArraySize + 3));
								if (NULL != paDUCObjects)
									nDUCArraySize += 3;
							}

							nDUCObj++;
							pCurDUCObj = paDUCObjects + nDUCCount;
						}
						else
							Out(LI1(TEXT("ProcessRasCredentialsCS returned error: %lx"), hr));
						break;

					case CS_STRUCT_WININET:
						bNewConn = TRUE;
						hr = ProcessWininetCS(pszNameW, &pCur, pCSObj, pCurWSObj);
						if (SUCCEEDED(hr))
						{
							nWSCount++;

							// Grow the array of obj paths if we've outgrown the current array
							if (nWSCount == (long)nWSArraySize)
							{
								paWSObjects = (BSTR*)CoTaskMemRealloc(paWSObjects, sizeof(BSTR) * (nWSArraySize + 3));
								if (NULL != paWSObjects)
									nWSArraySize += 3;
							}

							nWSObj++;
							pCurWSObj = paWSObjects + nWSCount;
						}
						else
							Out(LI1(TEXT("ProcessWininetCS returned error: %lx"), hr));
						break;

					default:
						pCur += *((PDWORD)(pCur + sizeof(DWORD)));
						hr    = S_FALSE;
					}

					if (hr == E_UNEXPECTED) {
						Out(LI0(TEXT("! The settings file is corrupted beyond recovery.")));
						goto PartTwo;
					}
				}
			}
			else
			{
				paDUSObjects = NULL;
				paDUCObjects = NULL;
				paWSObjects = NULL;
			}

			// Create a SAFEARRAY from our array of bstr connection names
			SAFEARRAY *psa = CreateSafeArray(VT_BSTR, nNameCount);
			for (long nName = 0; nName < nNameCount; nName++) 
				SafeArrayPutElement(psa, &nName, paNames[nName]);

			if (nNameCount > 1)
			{
				VARIANT vtData;
				vtData.vt = VT_BSTR | VT_ARRAY;
				vtData.parray = psa;
				//------------------------------------------------
				// dialUpConnections
				hr = PutWbemInstancePropertyEx(L"dialUpConnections", vtData, pCSObj);
			}


			// free up the connection names array
			for (nName = 0; nName < nNameCount; nName++) 
				SysFreeString(paNames[nName]);
			SafeArrayDestroy(psa);
			CoTaskMemFree(paNames);

			*ppaDUSObjects = paDUSObjects;
			*ppaDUCObjects = paDUCObjects;
			*ppaWSObjects = paWSObjects;
		}

		Out(LI0(TEXT("Done.")));                    // to indicate end for the last connection

	PartTwo:
		//_____ Ins proxy and autoconfig information _____
		{ MACRO_LI_Offset(1);                       // need a new scope

		InsGetString(IS_CONNECTSET, IK_APPLYTONAME, szApplyToName, countof(szApplyToName), m_szINSFile);
	//TODO: UNCOMMENT       if (szApplyToName[0] == TEXT('\0') && g_szConnectoidName[0] != TEXT('\0'))
	//TODO: UNCOMMENT           StrCpy(szApplyToName, g_szConnectoidName);

		Out(LI0(TEXT("\r\n")));
		if (szApplyToName[0] == TEXT('\0'))
			Out(LI0(TEXT("Settings from the *.ins file will be applied to LAN connection!")));
		else
			Out(LI1(TEXT("Settings from the *.ins file will be applied to \"%s\" connection!"), szApplyToName));

		}                                           // end offset scope

		if (prdiW != NULL) {
			CoTaskMemFree(prdiW);
			prdiW = NULL;
		}

		if (fRasApisLoaded)
			RasPrepareApis(RPA_UNLOAD, FALSE);

		if (pBuf != NULL) {
			CoTaskMemFree(pBuf);
			pBuf = NULL;
		}

		if (hFile != NULL && hFile != INVALID_HANDLE_VALUE) {
			CloseFile(hFile);
			hFile = NULL;
		}
	}
	__except(TRUE)
	{
		OutD(LI0(TEXT("Exception in ProcessAdvancedConnSettings.")));
	}

	OutD(LI0(TEXT("Exiting ProcessAdvancedConnSettings function.\r\n")));
	return hr;
}

/*HRESULT lcy50_ProcessConnectionSettings()
{   MACRO_LI_PrologEx_C(PIF_STD_C, lcy50_ProcessConnectionSettings)

    USES_CONVERSION;

    TCHAR  szTargetFile[MAX_PATH];
    HANDLE hFile;
    PBYTE  pBuf, pCur;
    DWORD  cbBuffer, cbAux,
           dwResult,
           cDevices;
    UINT   i;

    Out(LI0(TEXT("Connection settings are in IE5 format...")));

    hFile    = NULL;
    pBuf     = NULL;
    cbBuffer = 0;
    cbAux    = 0;
    cDevices = 0;

    //----- Connect.ras processing -----
    Out(LI1(TEXT("Processing RAS connections information from \"%s\"."), CONNECT_RAS));

		TCHAR szTargetDir[MAX_PATH];
    PathCombine(szTargetDir, m_szINSFile, TEXT("BRANDING\\cs"));
    PathCombine(szTargetFile, szTargetDir, CONNECT_RAS);
    if (!PathFileExists(szTargetFile))
        Out(LI0(TEXT("This file doesn't exist!")));

    else {
        LPRASDEVINFOA prdiA;
        LPRASENTRYA   preA;
        TCHAR szName[RAS_MaxEntryName + 1],
              szScript[MAX_PATH],
              szDeviceName[RAS_MaxDeviceName + 1],
              szKey[16];
        CHAR  szNameA[RAS_MaxEntryName + 1];
        PSTR  pszScriptA;
        DWORD cbRasEntry;
        UINT  j;
        BOOL  fRasApisLoaded;

        prdiA          = NULL;
        hFile          = NULL;
        fRasApisLoaded = FALSE;

        if (!RasIsInstalled()) {
            Out(LI0(TEXT("RAS support is not installed. Only LAN settings will be processed!")));
            goto RasExit;
        }

        //_____ Read Connect.ras into internal memory buffer _____
        hFile = CreateFile(szTargetFile, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
        if (hFile == INVALID_HANDLE_VALUE) {
            Out(LI0(TEXT("! This file can't be opened.")));
            goto RasExit;
        }

        SetFilePointer(hFile, 0, NULL, FILE_BEGIN);
        cbBuffer = GetFileSize(hFile, NULL);
        if (cbBuffer == 0xFFFFFFFF) {
            Out(LI0(TEXT("! Internal processing error.")));
            goto RasExit;
        }

        pBuf = (PBYTE)CoTaskMemAlloc(cbBuffer);
        if (pBuf == NULL) {
            Out(LI0(TEXT("! Internal processing ran out of memory.")));
            goto RasExit;
        }
        ZeroMemory(pBuf, cbBuffer);

        ReadFile(hFile, pBuf, cbBuffer, &cbAux, NULL);
        if (*((PDWORD)pBuf) != CS_VERSION_50) {
            Out(LI0(TEXT("! The version information in this file is corrupted.")));
            goto RasExit;
        }

        //_____ Preload RAS dlls _____
        if (!RasPrepareApis(RPA_RASSETENTRYPROPERTIESA) || g_pfnRasSetEntryPropertiesA == NULL) {
            Out(LI0(TEXT("! Required RAS APIs failed to load. Only LAN settings will be processed!\r\n")));
            goto RasExit;
        }
        fRasApisLoaded = TRUE;

        //_____ Get information about RAS devices on the local system _____
        RasEnumDevicesExA(&prdiA, NULL, &cDevices);
        if (cDevices == 0) {
            Out(LI0(TEXT("There are no RAS devices to connect to. Only LAN settings will be processed!\r\n")));
            goto RasExit;
        }

        //_____ Parse through RAS connections information _____
        for (i = cbAux = 0, pCur = pBuf 