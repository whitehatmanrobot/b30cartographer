lDesc);
	} while (False);

	if (CleanupLock)
	{
		AfpSwmrRelease(&pVolDesc->vds_IdDbAccessLock);
	}

	return Status;
}


/***	AfpQuerySecurityIdsAndRights
 *
 *	Find the owner id and primary group id for this entity. Map the corres.
 *	SIDs to their posix ids. Determine also the access rights for owner,
 *	group, world and this user. The access rights are divided into the
 *	following:
 *
 *	Owner's rights
 *	Primary group's rights
 *	World rights
 *	This user's rights
 *
 *	The handle to the directory should be opened with READ_CONTROL
 *	See Files vs. See Folders resolution for Owner/Group/World is already done.
 */
LOCAL AFPSTATUS
AfpQuerySecurityIdsAndRights(
	IN	PSDA			pSda,
	IN	PFILESYSHANDLE	pFSHandle,
	IN	DWORD			Bitmap,
	IN OUT PFILEDIRPARM	pFDParm
)
{
	NTSTATUS	Status;
	BYTE		ORights, GRights, WRights;

	PAGED_CODE( );

	// Save contents of the AfpInfo stream access bits
	ORights = pFDParm->_fdp_OwnerRights | DIR_ACCESS_WRITE;
	GRights = pFDParm->_fdp_GroupRights | DIR_ACCESS_WRITE;
	WRights = pFDParm->_fdp_WorldRights | DIR_ACCESS_WRITE;

	// Initialize to no rights for everybody
	pFDParm->_fdp_Rights = 0;

	// Get the OwnerId and GroupId for this directory.
	// Determine the Owner/Group and World rights for this directory
	// Determine if this user is a member of the directory's group
	Status = AfpGetAfpPermissions(pSda,
								  pFSHandle->fsh_FileHandle,
								  pFDParm);
	if (!NT_SUCCESS(Status))
		return Status;

	// Modify owner/group/world rights for the SeeFiles/SeeFolder weirdness
	// Also if the ACLs say we have READ & SEARCH access but AfpInfo stream
	// says we don't, then ignore AfpInfo stream
	if ((pFDParm->_fdp_OwnerRights & (DIR_ACCESS_READ | DIR_ACCESS_SEARCH)) &&
		!(ORights & (DIR_ACCESS_READ | DIR_ACCESS_SEARCH)))
		ORights |= (DIR_ACCESS_READ | DIR_ACCESS_SEARCH);
	pFDParm->_fdp_OwnerRights &= ORights;

	if ((pFDParm->_fdp_GroupRights & (DIR_ACCESS_READ | DIR_ACCESS_SEARCH)) &&
		!(GRights & (DIR_ACCESS_READ | DIR_ACCESS_SEARCH)))
		GRights |= (DIR_ACCESS_READ | DIR_ACCESS_SEARCH);
	pFDParm->_fdp_GroupRights &= GRights;

	if ((pFDParm->_fdp_WorldRights & (DIR_ACCESS_READ | DIR_ACCESS_SEARCH)) &&
		!(WRights & (DIR_ACCESS_READ | DIR_ACCESS_SEARCH)))
		WRights |= (DIR_ACCESS_READ | DIR_ACCESS_SEARCH);
	pFDParm->_fdp_WorldRights &= WRights;

	// One last bit of munging. Owner & Group can be the same and they both
	// could be everyone !! Coalese that.
	if (pFDParm->_fdp_OwnerId == SE_WORLD_POSIX_ID)
	{
		pFDParm->_fdp_WorldRights |= (pFDParm->_fdp_OwnerRights & ~DIR_ACCESS_OWNER);
		pFDParm->_fdp_OwnerRights |= pFDParm->_fdp_WorldRights;
	}

	if (pFDParm->_fdp_GroupId == SE_WORLD_POSIX_ID)
	{
		pFDParm->_fdp_WorldRights |= pFDParm->_fdp_GroupRights;
		pFDParm->_fdp_GroupRights |= pFDParm->_fdp_WorldRights;
	}

	if (pFDParm->_fdp_GroupId == pFDParm->_fdp_OwnerId)
	{
		pFDParm->_fdp_OwnerRights |= pFDParm->_fdp_GroupRights;
		pFDParm->_fdp_GroupRights |= (pFDParm->_fdp_OwnerRights & ~DIR_ACCESS_OWNER);
	}

	// Modify User rights for the SeeFiles/SeeFolder weirdness by determining
	// if the user is owner/group or world
	if (pFDParm->_fdp_UserRights & (DIR_ACCESS_READ | DIR_ACCESS_SEARCH))
	{
		BYTE	URights = (pFDParm->_fdp_UserRights & (DIR_ACCESS_WRITE | DIR_ACCESS_OWNER));

		if ((pFDParm->_fdp_WorldRights & (DIR_ACCESS_READ | DIR_ACCESS_SEARCH))
									!= (DIR_ACCESS_READ | DIR_ACCESS_SEARCH))
		{
			pFDParm->_fdp_UserRights = pFDParm->_fdp_WorldRights;
			if (pFDParm->_fdp_UserIsOwner)
			{
				pFDParm->_fdp_UserRights |= pFDParm->_fdp_OwnerRights;
			}
			if (pFDParm->_fdp_UserIsMemberOfDirGroup)
			{
				pFDParm->_fdp_UserRights |= pFDParm->_fdp_GroupRights;
			}
			if ((pFDParm->_fdp_UserRights & (DIR_ACCESS_READ | DIR_ACCESS_SEARCH)) == 0)
				pFDParm->_fdp_UserRights |= (DIR_ACCESS_READ | DIR_ACCESS_SEARCH);
			pFDParm->_fdp_UserRights &= ~DIR_ACCESS_WRITE;
			pFDParm->_fdp_UserRights |= URights;
		}
	}

	return Status;
}


/***	AfpConvertNTAttrToAfpAttr
 *
 *	Map NT Attributes to the AFP equivalents.
 */
USHORT
AfpConvertNTAttrToAfpAttr(
	IN	DWORD	Attr
)
{
	USHORT	AfpAttr = FD_BITMAP_ATTR_SET;

	PAGED_CODE( );

	if (Attr & FILE_ATTRIBUTE_READONLY)
	{
		AfpAttr |= FD_BITMAP_ATTR_RENAMEINH | FD_BITMAP_ATTR_DELETEINH;
		if (!(Attr & FILE_ATTRIBUTE_DIRECTORY))
			AfpAttr |= FILE_BITMAP_ATTR_WRITEINH;
	}

	if (Attr & FILE_ATTRIBUTE_HIDDEN)
		AfpAttr |= FD_BITMAP_ATTR_INVISIBLE;

	if (Attr & FILE_ATTRIBUTE_SYSTEM)
		AfpAttr |= FD_BITMAP_ATTR_SYSTEM;

	if (Attr & FILE_ATTRIBUTE_ARCHIVE)
	{
		AfpAttr |= FD_BITMAP_ATTR_BACKUPNEED;
	}

	return AfpAttr;
}


/***	AfpConvertAfpAttrToNTAttr
 *
 *	Map AFP Attributes to the NT equivalents.
 */
DWORD
AfpConvertAfpAttrToNTAttr(
	IN	USHORT	Attr
)
{
	DWORD	NtAttr = 0;

	PAGED_CODE( );

	if (Attr & (FD_BITMAP_ATTR_RENAMEINH |
				FD_BITMAP_ATTR_DELETEINH |
				FILE_BITMAP_ATTR_WRITEINH))
		NtAttr |= FILE_ATTRIBUTE_READONLY;

	if (Attr & FD_BITMAP_ATTR_INVISIBLE)
		NtAttr |= FILE_ATTRIBUTE_HIDDEN;

	if (Attr & FD_BITMAP_ATTR_SYSTEM)
		NtAttr |= FILE_ATTRIBUTE_SYSTEM;

	if (Attr & FD_BITMAP_ATTR_BACKUPNEED)
	{
		NtAttr |= FILE_ATTRIBUTE_ARCHIVE;
	}

	return NtAttr;
}


/***	AfpNormalizeAfpAttr
 *
 *	Normalize the various inhibit bits in afp attributes vs. the RO bit on the
 *	disk.
 */
VOID
AfpNormalizeAfpAttr(
	IN OUT	PFILEDIRPARM	pFDParm,
	IN		DWORD			NtAttr
)
{
	USHORT	AfpAttr;

	PAGED_CODE( );

	AfpAttr = AfpConvertNTAttrToAfpAttr(NtAttr);

	/*
	 *	The Attributes fall into two classes, the ones that are on
	 *	on the filesystem and the others maintained in the AfpInfo
	 *	stream. We need to coalesce these two sets. The RO bit on
	 *	the disk corres. to the three inhibit bits. Fine grain
	 *	control is possible.
	 *
	 *	The other set of bits that are in the exclusive realm of
	 *	the AfpInfo stream are the RAlreadyOpen and DAlreadyOpen
	 *	bits and the multi-user bit.
	 */
	if (((pFDParm->_fdp_Attr & FD_BITMAP_ATTR_NT_RO) == 0) ^
		((AfpAttr & FD_BITMAP_ATTR_NT_RO) == 0))
	{
		if ((AfpAttr & FD_BITMAP_ATTR_NT_RO) == 0)
			 pFDParm->_fdp_Attr &= ~FD_BITMAP_ATTR_NT_RO;
		else pFDParm->_fdp_Attr |= FD_BITMAP_ATTR_NT_RO;
	}

	pFDParm->_fdp_Attr &= (AfpAttr |
							(FILE_BITMAP_ATTR_MULTIUSER |
							 FILE_BITMAP_ATTR_DATAOPEN  |
							 FILE_BITMAP_ATTR_RESCOPEN  |
							 FD_BITMAP_ATTR_SET));
	pFDParm->_fdp_Attr |= (AfpAttr & (FD_BITMAP_ATTR_BACKUPNEED |
									  FD_BITMAP_ATTR_SYSTEM |
									  FD_BITMAP_ATTR_INVISIBLE));

}


/***AfpMapFDBitmapOpenAccess
 *
 *	Map the FD_INTERNAL_BITMAP_OPENACCESS_xxx bits to the appropriate
 *  FILEIO_ACCESS_xxx values.  The returned OpenAccess is used by the
 *  pathmap code to open the data stream of a file/dir (under impersonation
 *  for NTFS) for use in the AFP APIs.
 *
 */
DWORD
AfpMapFDBitmapOpenAccess(
	IN	DWORD	Bitmap,
	IN	BOOLEAN IsDir
)
{
	DWORD	OpenAccess = FILEIO_ACCESS_NONE;

	PAGED_CODE( );

	do
	{
		if (!(Bitmap & FD_INTERNAL_BITMAP_OPENACCESS_ALL))
		{
			break;
		}
		if (Bitmap & FD_INTERNAL_BITMAP_OPENACCESS_READCTRL)
		{
			// For GetFileDirParms we don't know if it was a file or dir they
			// are asking for, so we had to OR the file and dir bitmaps together
			// before pathmapping.
			if (IsDir)
				OpenAccess = (FILEIO_ACCESS_NONE |
							  READ_CONTROL |
							  SYNCHRONIZE);
			break;
		}
		// Used by AfpAdmwDirectoryGetInfo
		if (Bitmap & FD_INTERNAL_BITMAP_OPENACCESS_ADMINGET)
		{
			OpenAccess = (FILE_READ_ATTRIBUTES |
						  READ_CONTROL |
						  SYNCHRONIZE);
			break;
		}
		if (Bitmap & FD_INTERNAL_BITMAP_OPENACCESS_ADMINSET)
		{
			OpenAccess = (FILE_READ_ATTRIBUTES |
						  READ_CONTROL |
						  SYNCHRONIZE |
						  FILE_WRITE_ATTRIBUTES |
						  WRITE_DAC |
						  WRITE_OWNER);
			break;
		}
		if (Bitmap & FD_INTERNAL_BITMAP_OPENACCESS_RW_ATTR)
		{
			OpenAccess |= (FILEIO_ACCESS_NONE | FILE_WRITE_ATTRIBUTES);
		}
		if (Bitmap & FD_INTERNAL_BITMAP_OPENACCESS_RWCTRL)
		{
			OpenAccess |= (FILEIO_ACCESS_NONE |
						   READ_CONTROL |
						   WRITE_DAC |
						   WRITE_OWNER |
						   SYNCHRONIZE);
			break;
		}
		if (Bitmap & FD_INTERNAL_BITMAP_OPENACCESS_READ)
		{
			OpenAccess |= FILEIO_ACCESS_READ;
		}
		if (Bitmap & FD_INTERNAL_BITMAP_OPENACCESS_WRITE)
		{
			OpenAccess |= FILEIO_ACCESS_WRITE;
		}
		if (Bitmap & FD_INTERNAL_BITMAP_OPENACCESS_DELETE)
		{
			OpenAccess |= FILEIO_ACCESS_DELETE;
		}
	} while (False);

	return OpenAccess;
}


/*** AfpCheckForInhibit
 *
 *  This routine checks for the setting of the Afp RenameInhibit, DeleteInhibit
 *  or WriteInhibit attributes.  It first queries for the host File/Dir
 *  attributes to find out the setting of the ReadOnly attribute, then checks
 *  that against the Afp InhibitBit of interest.  AFP_ERR_NONE is returned if
 *  the InhibitBit is not set, else AFP_ERR_OBJECT_LOCKED is returned.
 *  The input handle must be a handle to the $DATA stream of the file/dir open
 *  in server's context.  The host attributes are returned in pNTAttr if the
 *  error code is not AFP_ERR_MISC.
 *
 */
AFPSTATUS
AfpCheckForInhibit(
	IN	PFILESYSHANDLE	hData,		// handle to DATA stream in server context
	IN	DWORD			InhibitBit,
	IN	DWORD			AfpAttr,
	OUT PDWORD			pNTAttr
)
{
	AFPSTATUS	Status = STATUS_SUCCESS;

	PAGED_CODE();

	do
	{
		if (!NT_SUCCESS(AfpIoQueryTimesnAttr(hData, NULL, NULL, pNTAttr)))
		{
			Status = AFP_ERR_MISC;
			break;
		}

		if (!(*pNTAttr & FILE_ATTRIBUTE_READONLY))
		{
	        Status = AFP_ERR_NONE;
			break;
		}
		if (!(AfpAttr & FD_BITMAP_ATTR_NT_RO) || (AfpAttr & InhibitBit))
		{
			// The file/dir is ReadOnly, but NONE of the AFP Inhibit bits are
			// set, so we assume the PC has set the RO bit; or, the requested
			// inhibit bit IS set.
			Status = AFP_ERR_OBJECT_LOCKED;
			break;
		}
	} while (False);

	return Status;
}

/***	AfpUnpackCatSearchSpecs
 *
 *	Unpack the information from the on-the-wire format to the FileDirParm
 *	structures for Specification 1 and 2.  Specification 1 contains the
 *  CatSearch criteria for lower bounds and values.  Specification 2
 *  contains the CatSearch criteria for upper bounds and masks.  The parameters
 *  are packed in the same order that the bits are set in the request bitmap.
 *  These are read into FILEDIRPARM structures.
 *
 *	The fields in Specification 1 and Specification 2 have different uses:
 *
 *	- In the name field, Specification 1 holds the target string and
 *    Specification 2 must always have a nil name field.
 *
 *	- In all date and length fields, Specification 1 holds the lowest value
 *    in the target range and Specification 2 holds the highest value in the
 *    target range.
 *
 *	- In file attributes and Finder Info fields, Specification 1 holds the
 *    target value, and Specification 2 holds the bitwise mask that specifies
 *    which bits in that field in Specification 1 are relevant to the current
 *    search.
 *
 */
AFPSTATUS
AfpUnpackCatSearchSpecs(
	IN	PBYTE			pBuffer,		// Pointer to beginning of Spec data
	IN	USHORT			BufLength,		// Length of Spec1 + Spec2 data
	IN	DWORD			Bitmap,
	OUT	PFILEDIRPARM	pFDParm1,
	OUT PFILEDIRPARM	pFDParm2,
	OUT PUNICODE_STRING	pMatchString
)
{
	PCATSEARCHSPEC	pSpec1, pSpec2;
	PBYTE			pBuffer1, pBuffer2, pEndOfBuffer;
	USHORT			Offset = 0, MinSpecLength1, MinSpecLength2;
	AFPSTATUS		Status = AFP_ERR_NONE;
	BOOLEAN			NoNullString = False;

	PAGED_CODE( );

	pSpec1 = (PCATSEARCHSPEC) pBuffer;
	pSpec2 = (PCATSEARCHSPEC) ((PBYTE)pBuffer + sizeof(CATSEARCHSPEC) +
			  pSpec1->__StructLength);

	// Point to data after the specification length and filler byte

	pBuffer1 = (PBYTE)pSpec1 + sizeof(CATSEARCHSPEC);
	pBuffer2 = (PBYTE)pSpec2 + sizeof(CATSEARCHSPEC);

	do
	{
		//
        // Make sure pSpec2 is at least pointing into the buffer we have, and
		// that its length is within the buffer as well.
		//
		pEndOfBuffer = pBuffer + BufLength;

		if (((PBYTE)pSpec2 >= pEndOfBuffer) ||
			((PBYTE)pSpec2+pSpec2->__StructLength+sizeof(CATSEARCHSPEC)
			  > pEndOfBuffer))
		{
			DBGPRINT(DBG_COMP_AFPAPI_FD, DBG_LEVEL_ERR,
				("UnpackCatSearchParms: Buffer not large enough!\n"));
			Status = AFP_ERR_PARAM;
			break;
		}

		//
		// Validate that input buffer is long enough to hold all the info the
		// bitmap says it does.  Note we cannot yet account for the length of
		// a longname string's characters if there was one specified.
		//
		MinSpecLength1 = MinSpecLength2 = sizeof(CATSEARCHSPEC) +
						AfpGetFileDirParmsReplyLength(pFDParm1, Bitmap);

        //
		// HACK: In order to support LLPT, if the catsearch is
		// asking to match filename, we should allow the Spec2 name to
		// be missing from the buffer (as opposed to being the null string),
		// but still expect the offset to the name.
		//
		// We also need to support system 7.1 who sends a zero length spec2
		// if the Bitmap == FD_BITMAP_LONGNAME.
		//
		// Real Appleshare handles both these cases with no error.
		//

		if (Bitmap & FD_BITMAP_LONGNAME)
		{
			if (pSpec2->__StructLength == (MinSpecLength2-sizeof(CATSEARCHSPEC)-sizeof(BYTE)) )
			{
				MinSpecLength2 -= sizeof(BYTE);
				NoNullString = True;
			}
			else if ((Bitmap == FD_BITMAP_LONGNAME) && (pSpec2->__StructLength == 0))
			{
				MinSpecLength2 -= sizeof(USHORT) + sizeof(BYTE);
				NoNullString = True;
			}
		}

		if ( ((MinSpecLength1 + MinSpecLength2) > BufLength) ||
			 (pSpec1->__StructLength < (MinSpecLength1-sizeof(CATSEARCHSPEC))) ||
			 (pSpec2->__StructLength < (MinSpecLength2-sizeof(CATSEARCHSPEC))) )
		{
			DBGPRINT(DBG_COMP_AFPAPI_FD, DBG_LEVEL_ERR,
				("UnpackCatSearchParms: Buffer not large enough!\n"));
			Status = AFP_ERR_PARAM;
			break;
		}

		if (Bitmap & FD_BITMAP_ATTR)
		{

			GETSHORT2SHORT(&pFDParm1->_fdp_Attr, pBuffer1+Offset);
			GETSHORT2SHORT(&pFDParm2->_fdp_Attr, pBuffer2+Offset);
			if ((pFDParm2->_fdp_Attr & ~FD_BITMAP_ATTR_NT_RO) ||
				(pFDParm2->_fdp_Attr == 0))
			{
				Status = AFP_ERR_PARAM;
				break;
			}
			Offset += sizeof(USHORT);
		}
		if (Bitmap & FD_BITMAP_PARENT_DIRID)
		{
			GETDWORD2DWORD(&pFDParm1->_fdp_ParentId, pBuffer1+Offset);
			GETDWORD2DWORD(&pFDParm2->_fdp_ParentId, pBuffer2+Offset);
			if (pFDParm1->_fdp_ParentId < AFP_ID_ROOT)
			{
				Status = AFP_ERR_PARAM;
				break;
			}
			Offset += sizeof(DWORD);
		}
		if (Bitmap & FD_BITMAP_CREATETIME)
		{
			GETDWORD2DWORD(&pFDParm1->_fdp_CreateTime, pBuffer1+Offset);
			GETDWORD2DWORD(&pFDParm2->_fdp_CreateTime, pBuffer2+Offset);
			Offset += sizeof(DWORD);
		}
		if (Bitmap & FD_BITMAP_MODIFIEDTIME)
		{
			GETDWORD2DWORD(&pFDParm1->_fdp_ModifiedTime, pBuffer1+Offset);
			GETDWORD2DWORD(&pFDParm2->_fdp_ModifiedTime, pBuffer2+Offset);
			Offset += sizeof(DWORD);
		}
		if (Bitmap & FD_BITMAP_BACKUPTIME)
		{
			GETDWORD2DWORD(&pFDParm1->_fdp_BackupTime, pBuffer1+Offset);
			GETDWORD2DWORD(&pFDParm2->_fdp_BackupTime, pBuffer2+Offset);
			Offset += sizeof(DWORD);
		}
		if (Bitmap & FD_BITMAP_FINDERINFO)
		{
			RtlCopyMemory((PBYTE)&pFDParm1->_fdp_FinderInfo,
						  pBuffer1+Offset,
						  sizeof(FINDERINFO));

			RtlCopyMemory((PBYTE)&pFDParm2->_fdp_FinderInfo,
						  pBuffer2+Offset,
						  sizeof(FINDERINFO));

			Offset += sizeof(FINDERINFO);
		}
		if (Bitmap & FD_BITMAP_LONGNAME)
		{
			DWORD	NameOffset1, NameOffset2;

			//
			// Get the parm relative offset to the start of the pascal string
			//

			GETSHORT2DWORD(&NameOffset1, pBuffer1+Offset);
			if ((Bitmap == FD_BITMAP_LONGNAME) && (pSpec2->__StructLength == 0))
			{
				// HACK for system 7.1
				NameOffset2 = NameOffset1;
				pBuffer2 = NULL;
			}
			else
				GETSHORT2DWORD(&NameOffset2, pBuffer2+Offset);

			if ((NameOffset1 != NameOffset2) ||
				(pBuffer1 + NameOffset1 >= (PBYTE)pSpec2) ||
				(pBuffer2 + NameOffset2 > pEndOfBuffer))
			{
				Status = AFP_ERR_PARAM;
				break;
			}
			Offset += sizeof(USHORT);

			//
			// Get the pascal string length
			//

			GETBYTE2SHORT(&pFDParm1->_fdp_LongName.Length, pBuffer1+NameOffset1);

			// HACK: In order to support LLPT and system 7.1, if the catsearch is
			// asking to match filename, we should allow the Spec2 name to
			// be missing from the buffer (as opposed to being the null string).
			// Real Appleshare handles this case with no error.
			if (NoNullString)
				pFDParm2->_fdp_LongName.Length = 0;
			else
				GETBYTE2SHORT(&pFDParm2->_fdp_LongName.Length, pBuffer2+NameOffset1);

			if ((pFDParm1->_fdp_LongName.Length > AFP_LONGNAME_LEN) ||
				(pFDParm2->_fdp_LongName.Length != 0) ||
				(pBuffer1+NameOffset1+sizeof(BYTE)+pFDParm1->_fdp_LongName.Length > (PBYTE)pSpec2))
			{
				// Specification 2 must always have a nil name field.  Also
				// ensure that Specification 1 does not have a bogus string
				// length.
				Status = AFP_ERR_PARAM;
				break;
			}
			RtlCopyMemory(pFDParm1->_fdp_LongName.Buffer,
						  pBuffer1+NameOffset1+sizeof(BYTE),
						  pFDParm1->_fdp_LongName.Length);
            AfpConvertStringToMungedUnicode(&pFDParm1->_fdp_LongName, pMatchString);
		}
		// OFFSPRINGS bit for directories, DATALEN bit for files are the same
		if (Bitmap & DIR_BITMAP_OFFSPRINGS)
		{
			ASSERT(pFDParm1->_fdp_Flags != (DFE_FLAGS_FILE_WITH_ID | DFE_FLAGS_DIR));
			if (IsDir(pFDParm1))
			{
				// We have to combine total offspring count into the
				// FileCount field here since the API does not separate
				// them into separate file and dir offspring counts
				GETSHORT2DWORD(&pFDParm1->_fdp_FileCount, pBuffer1+Offset);
				GETSHORT2DWORD(&pFDParm2->_fdp_FileCount, pBuffer2+Offset);
				Offset += sizeof(USHORT);
			}
			else
			{
				GETDWORD2DWORD(&pFDParm1->_fdp_DataForkLen, pBuffer1+Offset);
				GETDWORD2DWORD(&pFDParm2->_fdp_DataForkLen, pBuffer2+Offset);
				Offset += sizeof(DWORD);
			}
		}
		if (Bitmap & FILE_BITMAP_RESCLEN)
		{
			ASSERT(pFDParm1->_fdp_Flags == DFE_FLAGS_FILE_WITH_ID);
			GETDWORD2DWORD(&pFDParm1->_fdp_RescForkLen, pBuffer1+Offset);
			GETDWORD2DWORD(&pFDParm2->_fdp_RescForkLen, pBuffer2+Offset);
			Offset += sizeof(DWORD);
		}

	} while (False);

	return Status;
}

/***	AfpIsCatSearchMatch
 *
 *	Given a DFE and a set of search criteria, see if this item should be
 *  returned as a match in the catalog search.
 *
 *
 *	LOCKS_ASSUMED: vds_IdDbAccessLock (SWMR, Exclusive)
 */
SHORT
AfpIsCatSearchMatch(
	IN	PDFENTRY		pDFE,
	IN	DWORD			Bitmap,			// Search criteria
	IN	DWORD			ReplyBitmap,	// Info to return
	IN	PFILEDIRPARM	pFDParm1,
	IN	PFILEDIRPARM	pFDParm2,
	IN	PUNICODE_STRING	pMatchName OPTIONAL	
)
{
	BOOLEAN		IsMatch = True;
	SHORT		Length = 0;

	PAGED_CODE();

	do
	{

		if (Bitmap & FD_BITMAP_ATTR)
		{
			FILEDIRPARM	fdp;

			fdp._fdp_Attr = pDFE->dfe_AfpAttr;
			AfpNormalizeAfpAttr(&fdp, pDFE->dfe_NtAttr);

			if ((fdp._fdp_Attr & pFDParm2->_fdp_Attr) != pFDParm1->_fdp_Attr)

			{
				IsMatch = False;
				break;
			}
		}
		if (Bitmap & FD_BITMAP_PARENT_DIRID)
		{
			if ((pDFE->dfe_Parent->dfe_AfpId < pFDParm1->_fdp_ParentId) ||
				(pDFE->dfe_Parent->dfe_AfpId > pFDParm2->_fdp_ParentId))
			{
				IsMatch = False;
				break;
			}
		}
		if (Bitmap & FD_BITMAP_CREATETIME)
		{
			if (((AFPTIME)pDFE->dfe_CreateTime < (AFPTIME)pFDParm1->_fdp_CreateTime) ||
				((AFPTIME)pDFE->dfe_CreateTime > (AFPTIME)pFDParm2->_fdp_CreateTime))
			{
				IsMatch = False;
				break;
			}
		}
		if (Bitmap & FD_BITMAP_MODIFIEDTIME)
		{
			AFPTIME	ModTime;

			ModTime = AfpConvertTimeToMacFormat(&pDFE->dfe_LastModTime);
			if ((ModTime < pFDParm1->_fdp_ModifiedTime) ||
				(ModTime > pFDParm2->_fdp_ModifiedTime))
			{
				IsMatch = False;
				break;
			}
		}
		if (Bitmap & FD_BITMAP_BACKUPTIME)
		{
			if ((pDFE->dfe_BackupTime < pFDParm1->_fdp_BackupTime) ||
				(pDFE->dfe_BackupTime > pFDParm2->_fdp_BackupTime))
			{
				IsMatch = False;
				break;
			}
		}
		if (Bitmap & FD_BITMAP_FINDERINFO)
		{
			int			i;
			PBYTE		pF, p1, p2;
			FINDERINFO 	FinderInfo;

			// NOTE: why doesn't dfe_FinderInfo.Attr1 correctly reflect the
			// Nt Hidden attribute in the first place?
			FinderInfo = pDFE->dfe_FinderInfo;
			if (pDFE->dfe_NtAttr & FILE_ATTRIBUTE_HIDDEN)
				FinderInfo.fd_Attr1 |= FINDER_FLAG_INVISIBLE;

			pF = (PBYTE) &FinderInfo;
			p1 = (PBYTE) &pFDParm1->_fdp_FinderInfo;
			p2 = (PBYTE) &pFDParm2->_fdp_FinderInfo;

			for (i = 0; i < sizeof(FINDERINFO); i++)
			{
				if ((*pF++ & *p2++) != *p1++)
				{
					IsMatch = False;
					break;	// out of for loop
				}
			}

			if (IsMatch == False)
				break;	// out of while loop
		}
		if (Bitmap & FD_BITMAP_LONGNAME)
		{
			ASSERT(ARGUMENT_PRESENT(pMatchName));

			if (pFDParm2->_fdp_fPartialName)
			{
				// Name must contain substring
				if (!AfpIsProperSubstring(&pDFE->dfe_UnicodeName, pMatchName))
				{
					IsMatch = False;
					break;
				}
			}
			else if (!EQUAL_UNICODE_STRING(&pDFE->dfe_UnicodeName, pMatchName, True))
			{
				// Whole name must match
				IsMatch = False;
				break;
			}
		}
		if (Bitmap & FILE_BITMAP_DATALEN)
		{
			// This bit is also used as DIR_BITMAP_OFFSPRINGS for directories
			if (IsDir(pFDParm1))
			{
				DWORD count;

				ASSERT(DFE_IS_DIRECTORY(pDFE) && DFE_CHILDREN_ARE_PRESENT(pDFE));

				count = pDFE->dfe_DirOffspring + pDFE->dfe_FileOffspring;

				// In this case, _fdp_FileCount holds total # of files and dirs
				if ((count < pFDParm1->_fdp_FileCount) ||
					(count > pFDParm2->_fdp_FileCount))
				{
					IsMatch = False;
					break;
				}
			}
			else
			{
				ASSERT(DFE_IS_FILE(pDFE));

				if ((pDFE->dfe_DataLen < pFDParm1->_fdp_DataForkLen) ||
					(pDFE->dfe_DataLen > pFDParm2->_fdp_DataForkLen))
				{
					IsMatch = False;
					break;
				}
			}
	
		}
		if (Bitmap & FILE_BITMAP_RESCLEN)
		{
			ASSERT(DFE_IS_FILE(pDFE));

			if ((pDFE->dfe_RescLen < pFDParm1->_fdp_RescForkLen) ||
				(pDFE->dfe_RescLen > pFDParm2->_fdp_RescForkLen))
			{
				IsMatch = False;
				break;
			}
		}
	
	} while (False);

	if (IsMatch)
	{
		Length = 2 * sizeof(BYTE);	// Struct Length plus File/Dir Flag
		if (ReplyBitmap & FD_BITMAP_PARENT_DIRID)
		{
			Length += sizeof(DWORD);
		}
		if (ReplyBitmap & FD_BITMAP_LONGNAME)
		{
			// Offset to string + pascal string length + characters
#ifdef DBCS
// FiX #11992 SFM: As a result of search, I get incorrect file information.
// 1996.09.26 V-HIDEKK
			{
			ANSI_STRING	AName;
			BYTE		NameBuf[AFP_LONGNAME_LEN+1];

			AfpInitAnsiStringWithNonNullTerm(&AName, sizeof(NameBuf), NameBuf);
			AfpConvertMungedUnicodeToAnsi(&pDFE->dfe_UnicodeName, &AName);
			Length += sizeof(USHORT) + sizeof(BYTE) + AName.Length;
			}
#else
			Length += sizeof(USHORT) + sizeof(BYTE) + pDFE->dfe_UnicodeName.Length/sizeof(WCHAR);
#endif
		}
		Length = EVENALIGN(Length);
	}

	return Length;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\server\forkio.c ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	forkio.c

Abstract:

	This module contains the routines for performing fork reads and writes
	directly by building IRPs and not using NtReadFile/NtWriteFile. This
	should be used only by the FpRead and FpWrite Apis.

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	15 Jan 1993		Initial Version

Notes:	Tab stop: 4
--*/

#define	FILENUM	FILE_FORKIO

#define	FORKIO_LOCALS
#include <afp.h>
#include <forkio.h>
#include <gendisp.h>

#if DBG
PCHAR	AfpIoForkFunc[] =
	{
		"",
		"READ",
		"WRITE",
		"LOCK",
		"UNLOCK"
	};
#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, AfpIoForkRead)
#pragma alloc_text( PAGE, AfpIoForkWrite)
#pragma alloc_text( PAGE, AfpIoForkLockUnlock)
#endif

/***	afpIoGenericComplete
 *
 *	This is the generic completion routine for a posted io request.
 */
NTSTATUS
afpIoGenericComplete(
	IN	PDEVICE_OBJECT	pDeviceObject,
	IN	PIRP			pIrp,
	IN	PCMPLCTXT		pCmplCtxt
)
{
	PSDA		pSda;			// Not valid for Unlock
	struct _ResponsePacket	// For lock/unlock request
	{
		union
		{
			BYTE	__RangeStart[4];
			BYTE	__LastWritten[4];
		};
	};

	ASSERT(VALID_CTX(pCmplCtxt));

	if (pCmplCtxt->cc_Func != FUNC_UNLOCK)
	{
		pSda = (PSDA)(pCmplCtxt->cc_pSda);
		ASSERT(VALID_SDA(pSda));

        if (pCmplCtxt->cc_Func == FUNC_WRITE)
        {
			AfpFreeIOBuffer(pSda);
        }
        else if (!NT_SUCCESS(pIrp->IoStatus.Status) &&
                (pCmplCtxt->cc_Func == FUNC_READ))
        {
            AfpIOFreeBackFillBuffer(pSda);
        }
	}

	if (!NT_SUCCESS(pIrp->IoStatus.Status))
	{
		DBGPRINT(DBG_COMP_AFPAPI_FORK, DBG_LEVEL_WARN,
				("afpIoGenericComplete: %s ERROR %lx\n",
				AfpIoForkFunc[pCmplCtxt->cc_Func], pIrp->IoStatus.Status));

		if (pCmplCtxt->cc_Func != FUNC_UNLOCK)
		{
			if (pIrp->IoStatus.Status == STATUS_FILE_LOCK_CONFLICT)
				pCmplCtxt->cc_SavedStatus = AFP_ERR_LOCK;
			else if (pIrp->IoStatus.Status == STATUS_END_OF_FILE)
			{
				pCmplCtxt->cc_SavedStatus = AFP_ERR_NONE;
				if (pIrp->IoStatus.Information == 0)
					 pCmplCtxt->cc_SavedStatus = AFP_ERR_EOF;
			}
			else if (pIrp->IoStatus.Status == STATUS_DISK_FULL)
				 pCmplCtxt->cc_SavedStatus = AFP_ERR_DISK_FULL;
			else pCmplCtxt->cc_SavedStatus = AFP_ERR_MISC;
		}
		else
		{
			AFPLOG_ERROR(AFPSRVMSG_CANT_UNLOCK,
						 pIrp->IoStatus.Status,
						 NULL,
						 0,
						 NULL);
		}

		if (pCmplCtxt->cc_Func == FUNC_LOCK)
		{
			DBGPRINT(DBG_COMP_FORKS, DBG_LEVEL_ERR,
					("afpIoGenericComplete: ForkLock failed %lx, aborting for range %ld,%ld\n",
					pIrp->IoStatus.Status,
					pCmplCtxt->cc_pForkLock->flo_Offset,
					pCmplCtxt->cc_pForkLock->flo_Offset+pCmplCtxt->cc_pForkLock->flo_Size-1));
			AfpForkLockUnlink(pCmplCtxt->cc_pForkLock);
		}
	}

	else switch (pCmplCtxt->cc_Func)
	{
	  case FUNC_WRITE:
		INTERLOCKED_ADD_STATISTICS(&AfpServerStatistics.stat_DataWritten,
								   pCmplCtxt->cc_Offst,
								   &AfpStatisticsLock);
		pSda->sda_ReplySize = SIZE_RESPPKT;
		if (AfpAllocReplyBuf(pSda) == AFP_ERR_NONE)
		{
			PUTDWORD2DWORD(pRspPkt->__LastWritten,
						pCmplCtxt->cc_Offst + pCmplCtxt->cc_ReqCount);
		}
		else pCmplCtxt->cc_SavedStatus = AFP_ERR_MISC;
		break;

	  case FUNC_READ:
		{
			LONG	i, Size;
			PBYTE	pBuf;
			BYTE	NlChar = pCmplCtxt->cc_NlChar;
			BYTE	NlMask = pCmplCtxt->cc_NlMask;

			INTERLOCKED_ADD_STATISTICS(&AfpServerStatistics.stat_DataRead,
									   (ULONG)pIrp->IoStatus.Information,
									   &AfpStatisticsLock);

			Size = (LONG)pIrp->IoStatus.Information;
#if 0
			// The following code does the right thing as per the spec but
			// the finder seems to think otherwise.
			if (Size < pCmplCtxt->cc_ReqCount)
				pCmplCtxt->cc_SavedStatus = AFP_ERR_EOF;
#endif
			if (Size == 0)
			{
				pCmplCtxt->cc_SavedStatus = AFP_ERR_EOF;
                AfpIOFreeBackFillBuffer(pSda);
			}
			else if (pCmplCtxt->cc_NlMask != 0)
			{
				for (i = 0, pBuf = pSda->sda_ReplyBuf; i < Size; i++, pBuf++)
				{
					if ((*pBuf & NlMask) == NlChar)
					{
						Size = ++i;
						pCmplCtxt->cc_SavedStatus = AFP_ERR_NONE;
						break;
					}
				}
			}
			pSda->sda_ReplySize = (USHORT)Size;
		}
		ASSERT((pCmplCtxt->cc_SavedStatus != AFP_ERR_EOF) ||
				(pSda->sda_ReplySize == 0));
		break;

	  case FUNC_LOCK:
		INTERLOCKED_ADD_ULONG(&AfpServerStatistics.stat_CurrentFileLocks,
							  1,
							  &AfpStatisticsLock);
		pSda->sda_ReplySize = SIZE_RESPPKT;
		if (AfpAllocReplyBuf(pSda) == AFP_ERR_NONE)
			PUTDWORD2DWORD(pRspPkt->__RangeStart, pCmplCtxt->cc_pForkLock->flo_Offset);
		else pCmplCtxt->cc_SavedStatus = AFP_ERR_MISC;
		break;

	  case FUNC_UNLOCK:
		INTERLOCKED_ADD_ULONG(
					&AfpServerStatistics.stat_CurrentFileLocks,
					(ULONG)-1,
					&AfpStatisticsLock);
		break;

	  default:
		ASSERTMSG(0, "afpIoGenericComplete: Invalid function\n");
		KeBugCheck(0);
		break;
	}

	if (pIrp->MdlAddress != NULL)
		AfpFreeMdl(pIrp->MdlAddress);

	AfpFreeIrp(pIrp);

	if (pCmplCtxt->cc_Func != FUNC_UNLOCK)
	{
		DBGPRINT(DBG_COMP_AFPAPI_FORK, DBG_LEVEL_INFO,
				("afpIoGenericComplete: %s Returning %ld\n",
				AfpIoForkFunc[pCmplCtxt->cc_Func], pCmplCtxt->cc_SavedStatus));
		AfpCompleteApiProcessing(pSda, pCmplCtxt->cc_SavedStatus);
	}

    AfpFreeCmplCtxtBuf(pCmplCtxt);

	// Return STATUS_MORE_PROCESSING_REQUIRED so that IoCompleteRequest
	// will stop working on the IRP.

	return STATUS_MORE_PROCESSING_REQUIRED;
}



/***	AfpIoForkRead
 *
 *	Read a chunk of data from the open fork. The read buffer is always the
 *	the reply buffer in the sda (sda_ReplyBuf).
 */
AFPSTATUS
AfpIoForkRead(
	IN	PSDA			pSda,			// The session requesting read
	IN	POPENFORKENTRY	pOpenForkEntry,	// The open fork in question
	IN	PFORKOFFST		pOffset,		// Pointer to fork offset
	IN	LONG			ReqCount,		// Size of read request
	IN	BYTE			NlMask,
	IN	BYTE			NlChar
)
{
	PIRP				pIrp = NULL;
	PIO_STACK_LOCATION	pIrpSp;
	NTSTATUS			Status;
	PMDL				pMdl = NULL;
	PCMPLCTXT			pCmplCtxt;

	PAGED_CODE( );

	ASSERT (KeGetCurrentIrql() < DISPATCH_LEVEL);

	ASSERT(VALID_OPENFORKENTRY(pOpenForkEntry));

	DBGPRINT(DBG_COMP_AFPAPI_FORK, DBG_LEVEL_INFO,
			("AfpIoForkRead: Session %ld, Offset %ld, Size %ld, Fork %ld\n",
			pSda->sda_SessionId, pOffset->LowPart, ReqCount, pOpenForkEntry->ofe_ForkId));

	do
	{

		// Allocate and initialize the completion context

		pCmplCtxt = AfpAllocCmplCtxtBuf(pSda);
        if (pCmplCtxt == NULL)
        {
			AfpFreeIOBuffer(pSda);
			Status = AFP_ERR_MISC;
			break;
        }

		afpInitializeCmplCtxt(pCmplCtxt,
							  FUNC_READ,
							  pSda->sda_ReadStatus,
							  pSda,
							  NULL,
							  ReqCount,
							  pOffset->LowPart);
		pCmplCtxt->cc_NlChar  = NlChar;
		pCmplCtxt->cc_NlMask  = NlMask;

		// Allocate and initialize the IRP for this operation.
		if ((pIrp = AfpAllocIrp(pOpenForkEntry->ofe_pDeviceObject->StackSize)) == NULL)
		{
			AfpFreeIOBuffer(pSda);
			Status = AFP_ERR_MISC;
			break;
		}

		if ((pOpenForkEntry->ofe_pDeviceObject->Flags & DO_BUFFERED_IO) == 0)
		{
			// Allocate an Mdl to describe the read buffer
			if ((pMdl = AfpAllocMdl(pSda->sda_ReplyBuf, ReqCount, pIrp)) == NULL)
			{
				Status = AFP_ERR_MISC;
				break;
			}
		}

		// Set up the completion routine.
		IoSetCompletionRoutine( pIrp,
								(PIO_COMPLETION_ROUTINE)afpIoGenericComplete,
								pCmplCtxt,
								True,
								True,
								True);

		pIrpSp = IoGetNextIrpStackLocation(pIrp);

		pIrp->Tail.Overlay.OriginalFileObject = AfpGetRealFileObject(pOpenForkEntry->ofe_pFileObject);
		pIrp->Tail.Overlay.Thread = AfpThread;
		pIrp->RequestorMode = KernelMode;

		// Get a pointer to the stack location for the first driver.
		// This will be used to pass the original function codes and
		// parameters.

		pIrpSp->MajorFunction = IRP_MJ_READ;
		pIrpSp->MinorFunction = IRP_MN_NORMAL;
		pIrpSp->FileObject = AfpGetRealFileObject(pOpenForkEntry->ofe_pFileObject);
		pIrpSp->DeviceObject = pOpenForkEntry->ofe_pDeviceObject;

		// Copy the caller's parameters to the service-specific portion of the
		// IRP.

		pIrpSp->Parameters.Read.Length = ReqCount;
		pIrpSp->Parameters.Read.Key = pSda->sda_SessionId;
		pIrpSp->Parameters.Read.ByteOffset = *pOffset;

		if ((pOpenForkEntry->ofe_pDeviceObject->Flags & DO_BUFFERED_IO) != 0)
		{
			pIrp->AssociatedIrp.SystemBuffer = pSda->sda_ReplyBuf;
			pIrp->Flags = IRP_BUFFERED_IO | IRP_INPUT_OPERATION;
		}
		else if ((pOpenForkEntry->ofe_pDeviceObject->Flags & DO_DIRECT_IO) != 0)
		{
			pIrp->MdlAddress = pMdl;
		}
		else
		{
			pIrp->UserBuffer = pSda->sda_ReplyBuf;
			pIrp->MdlAddress = pMdl;
		}

		// Now simply invoke the driver at its dispatch entry with the IRP.
		IoCallDriver(pOpenForkEntry->ofe_pDeviceObject, pIrp);

		Status = AFP_ERR_EXTENDED;	// This makes the caller do nothing and
	} while (False);				// the completion routine handles everything

	if (Status != AFP_ERR_EXTENDED)
	{
		if (pIrp != NULL)
			AfpFreeIrp(pIrp);

		if (pMdl != NULL)
			AfpFreeMdl(pMdl);

        if (pCmplCtxt)
        {
            AfpFreeCmplCtxtBuf(pCmplCtxt);
        }
	}

	DBGPRINT(DBG_COMP_AFPAPI_FORK, DBG_LEVEL_INFO,
			("AfpIoForkRead: Returning %ld\n", Status));

	return Status;
}


/***	AfpIoForkWrite
 *
 *	Write a chunk of data to the open fork. The write buffer is always the
 *	the write buffer in the sda (sda_IOBuf).
 */
AFPSTATUS
AfpIoForkWrite(
	IN	PSDA			pSda,			// The session requesting read
	IN	POPENFORKENTRY	pOpenForkEntry,	// The open fork in question
	IN	PFORKOFFST		pOffset,		// Pointer to fork offset
	IN	LONG			ReqCount		// Size of write request
)
{
	PIRP				pIrp = NULL;
	PIO_STACK_LOCATION	pIrpSp;
	NTSTATUS			Status;
	PMDL				pMdl = NULL;
	PCMPLCTXT			pCmplCtxt;

	PAGED_CODE( );

	ASSERT (KeGetCurrentIrql() < DISPATCH_LEVEL);

	ASSERT(VALID_OPENFORKENTRY(pOpenForkEntry));

	DBGPRINT(DBG_COMP_AFPAPI_FORK, DBG_LEVEL_INFO,
			("AfpIoForkWrite: Session %ld, Offset %ld, Size %ld, Fork %ld\n",
			pSda->sda_SessionId, pOffset->LowPart, ReqCount, pOpenForkEntry->ofe_ForkId));

	do
	{
		// Allocate and initialize the completion context
		pCmplCtxt = AfpAllocCmplCtxtBuf(pSda);
        if (pCmplCtxt == NULL)
        {
			Status = AFP_ERR_MISC;
			break;
        }

		afpInitializeCmplCtxt(pCmplCtxt,
							  FUNC_WRITE,
							  AFP_ERR_NONE,
							  pSda,
							  NULL,
							  ReqCount,
							  pOffset->LowPart);

		// Allocate and initialize the IRP for this operation.
		if ((pIrp = AfpAllocIrp(pOpenForkEntry->ofe_pDeviceObject->StackSize)) == NULL)
		{
			Status = AFP_ERR_MISC;
			break;
		}

		if ((pOpenForkEntry->ofe_pDeviceObject->Flags & DO_BUFFERED_IO) == 0)
		{
			// Allocate an Mdl to describe the write buffer
			if ((pMdl = AfpAllocMdl(pSda->sda_IOBuf, ReqCount, pIrp)) == NULL)
			{
				Status = AFP_ERR_MISC;
				break;
			}
		}

		// Set up the completion routine.
		IoSetCompletionRoutine( pIrp,
								(PIO_COMPLETION_ROUTINE)afpIoGenericComplete,
								pCmplCtxt,
								True,
								True,
								True);

		pIrpSp = IoGetNextIrpStackLocation(pIrp);

		pIrp->Tail.Overlay.OriginalFileObject = AfpGetRealFileObject(pOpenForkEntry->ofe_pFileObject);
		pIrp->Tail.Overlay.Thread = AfpThread;
		pIrp->RequestorMode = KernelMode;

		// Get a pointer to the stack location for the first driver.
		// This will be used to pass the original function codes and
		// parameters.

		pIrpSp->MajorFunction = IRP_MJ_WRITE;
		pIrpSp->MinorFunction = IRP_MN_NORMAL;
		pIrpSp->FileObject = AfpGetRealFileObject(pOpenForkEntry->ofe_pFileObject);
		pIrpSp->DeviceObject = pOpenForkEntry->ofe_pDeviceObject;

		// Copy the caller's parameters to the service-specific portion of the
		// IRP.

		pIrpSp->Parameters.Write.Length = ReqCount;
		pIrpSp->Parameters.Write.Key = pSda->sda_SessionId;
		pIrpSp->Parameters.Write.ByteOffset = *pOffset;

		if ((pOpenForkEntry->ofe_pDeviceObject->Flags & DO_BUFFERED_IO) != 0)
		{
			pIrp->AssociatedIrp.SystemBuffer = pSda->sda_IOBuf;
			pIrp->Flags = IRP_BUFFERED_IO;
		}
		else if ((pOpenForkEntry->ofe_pDeviceObject->Flags & DO_DIRECT_IO) != 0)
		{
			pIrp->MdlAddress = pMdl;
		}
		else
		{
			pIrp->UserBuffer = pSda->sda_IOBuf;
			pIrp->MdlAddress = pMdl;
		}

		// Now simply invoke the driver at its dispatch entry with the IRP.
		IoCallDriver(pOpenForkEntry->ofe_pDeviceObject, pIrp);

		Status = AFP_ERR_EXTENDED;	// This makes the caller do nothing and
	} while (False);				// the completion routine handles everything

	if (Status != AFP_ERR_EXTENDED)
	{
		if (pIrp != NULL)
			AfpFreeIrp(pIrp);

		if (pMdl != NULL)
			AfpFreeMdl(pMdl);

        if (pCmplCtxt)
        {
            AfpFreeCmplCtxtBuf(pCmplCtxt);
        }
	}

	DBGPRINT(DBG_COMP_AFPAPI_FORK, DBG_LEVEL_INFO,
			("AfpIoForkWrite: Returning %ld\n", Status));

	return Status;
}



/***	AfpIoForkLock
 *
 *	Lock/Unlock a section of the open fork.
 */
AFPSTATUS
AfpIoForkLockUnlock(
	IN	PSDA				pSda,
	IN	PFORKLOCK			pForkLock,
	IN	PFORKOFFST			pForkOffset,
	IN	PFORKSIZE			pLockSize,
	IN	BYTE				Func
)
{
	PIRP				pIrp = NULL;
	PIO_STACK_LOCATION	pIrpSp;
	POPENFORKENTRY		pOpenForkEntry = pForkLock->flo_pOpenForkEntry;
	NTSTATUS			Status;
	PCMPLCTXT			pCmplCtxt;

	PAGED_CODE( );

	ASSERT (KeGetCurrentIrql() < DISPATCH_LEVEL);

	ASSERT(VALID_OPENFORKENTRY(pOpenForkEntry));

	DBGPRINT(DBG_COMP_AFPAPI_FORK, DBG_LEVEL_INFO,
			("AfpIoForkLockUnlock: %sLOCK Session %ld, Offset %ld, Size %ld, Fork %ld\n",
			(Func == FUNC_LOCK) ? "" : "UN", pSda->sda_SessionId,
			pForkOffset->LowPart, pLockSize->LowPart, pOpenForkEntry->ofe_ForkId));

	do
	{
		// Allocate and initialize the completion context
		pCmplCtxt = AfpAllocCmplCtxtBuf(pSda);
        if (pCmplCtxt == NULL)
        {
			Status = AFP_ERR_MISC;
			break;
        }

		afpInitializeCmplCtxt(pCmplCtxt,
							  Func,
							  AFP_ERR_NONE,
							  pSda,
							  pForkLock,
							  pForkOffset->LowPart,
							  pLockSize->LowPart);

		// Allocate and initialize the IRP for this operation.
		if ((pIrp = AfpAllocIrp(pOpenForkEntry->ofe_pDeviceObject->StackSize)) == NULL)
		{
			Status = AFP_ERR_MISC;
			break;
		}

		// Set up the completion routine.
		IoSetCompletionRoutine( pIrp,
								(PIO_COMPLETION_ROUTINE)afpIoGenericComplete,
								pCmplCtxt,
								True,
								True,
								True);

		pIrpSp = IoGetNextIrpStackLocation(pIrp);

		pIrp->Tail.Overlay.OriginalFileObject = AfpGetRealFileObject(pOpenForkEntry->ofe_pFileObject);
		pIrp->Tail.Overlay.Thread = AfpThread;
		pIrp->RequestorMode = KernelMode;

		// Get a pointer to the stack location for the first driver.
		// This will be used to pass the original function codes and parameters.

		pIrpSp->MajorFunction = IRP_MJ_LOCK_CONTROL;
		pIrpSp->MinorFunction = (Func == FUNC_LOCK) ? IRP_MN_LOCK : IRP_MN_UNLOCK_SINGLE;
		pIrpSp->FileObject = AfpGetRealFileObject(pOpenForkEntry->ofe_pFileObject);
		pIrpSp->DeviceObject = pOpenForkEntry->ofe_pDeviceObject;

		// Copy the caller's parameters to the service-specific portion of the IRP.

		pIrpSp->Parameters.LockControl.Length = pLockSize;
		pIrpSp->Parameters.LockControl.Key = pSda->sda_SessionId;
		pIrpSp->Parameters.LockControl.ByteOffset = *pForkOffset;

		pIrp->MdlAddress = NULL;
		pIrpSp->Flags = SL_FAIL_IMMEDIATELY | SL_EXCLUSIVE_LOCK;

		// Now simply invoke the driver at its dispatch entry with the IRP.
		IoCallDriver(pOpenForkEntry->ofe_pDeviceObject, pIrp);

		// For lock operation this makes the caller do nothing
		// and the completion routine handles everything
		// For unlock operation we complete the request here.
		Status = (Func == FUNC_LOCK) ? AFP_ERR_EXTENDED : AFP_ERR_NONE;
		} while (False);


    if ((Status != AFP_ERR_EXTENDED) && (Status != AFP_ERR_NONE))
    {
		if (pIrp != NULL)
			AfpFreeIrp(pIrp);

        if (pCmplCtxt)
        {
            AfpFreeCmplCtxtBuf(pCmplCtxt);
        }
    }
	DBGPRINT(DBG_COMP_AFPAPI_FORK, DBG_LEVEL_INFO,
			("AfpIoForkLock: Returning %ld\n", Status));

	return Status;
}



PCMPLCTXT
AfpAllocCmplCtxtBuf(
	IN	PSDA	pSda
)
{
	KIRQL	OldIrql;
    PBYTE   pRetBuffer;


	ACQUIRE_SPIN_LOCK(&pSda->sda_Lock, &OldIrql);

	ASSERT (sizeof(CMPLCTXT) <= pSda->sda_SizeNameXSpace);

	if (((pSda->sda_Flags & SDA_NAMEXSPACE_IN_USE) == 0) &&
		(sizeof(CMPLCTXT) <= pSda->sda_SizeNameXSpace))
	{
		pRetBuffer = pSda->sda_NameXSpace;
		pSda->sda_Flags |= SDA_NAMEXSPACE_IN_USE;
	}
	else
	{
		pRetBuffer = AfpAllocNonPagedMemory(sizeof(CMPLCTXT));
	}

	RELEASE_SPIN_LOCK(&pSda->sda_Lock, OldIrql);

	return ((PCMPLCTXT)(pRetBuffer));
}


VOID
AfpFreeCmplCtxtBuf(
	IN	PCMPLCTXT   pCmplCtxt
)
{
	KIRQL	OldIrql;
    PSDA    pSda;


    ASSERT(VALID_CTX(pCmplCtxt));

    pSda = pCmplCtxt->cc_pSda;

    ASSERT(VALID_SDA(pSda));

	ACQUIRE_SPIN_LOCK(&pSda->sda_Lock, &OldIrql);

#if DBG
    pCmplCtxt->Signature = 0x12341234;
    pCmplCtxt->cc_Func = 0xff;
    pCmplCtxt->cc_pSda = (PSDA)0x12341234;
    pCmplCtxt->cc_pForkLock = (PFORKLOCK)0x12341234;
    pCmplCtxt->cc_SavedStatus = 0x12341234;
    pCmplCtxt->cc_ReqCount = 0x12341234;
    pCmplCtxt->cc_Offst = 0x12341234;
#endif

	if (((PBYTE)pCmplCtxt) == pSda->sda_NameXSpace)
	{
        ASSERT(pSda->sda_Flags & SDA_NAMEXSPACE_IN_USE);

		pSda->sda_Flags &= ~SDA_NAMEXSPACE_IN_USE;
	}
	else
	{
		AfpFreeMemory((PBYTE)(pCmplCtxt));
	}

	RELEASE_SPIN_LOCK(&pSda->sda_Lock, OldIrql);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\server\filenums.h ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	filenums.h

Abstract:

	This file defines some constant identifiiers for each file for use by
	the errorlogging system.

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	10 Jan 1993             Initial Version

Notes:  Tab stop: 4
--*/


#ifndef _FILENUMS_
#define _FILENUMS_

#define	FILE_ACCESS		0x010000
#define FILE_ADMIN		0x020000
#define FILE_AFPAPI		0x030000
#define FILE_AFPINFO	0x040000
#define FILE_ATALKIO	0x050000
#define FILE_CLIENT		0x060000
#define FILE_DESKTOP	0x070000
#define FILE_ERRORLOG	0x080000
#define FILE_FDPARM		0x090000
#define FILE_FILEIO		0x0A0000
#define FILE_FORKIO		0x0B0000
#define FILE_FORKS		0x0C0000
#define FILE_FSD		0x0D0000
#define FILE_FSD_DTP	0x0E0000
#define FILE_FSD_FORK	0x0F0000
#define FILE_FSD_SRV	0x100000
#define FILE_FSD_VOL	0x110000
#define FILE_FSP_DIR	0x120000
#define FILE_FSP_DTP	0x130000
#define FILE_FSP_FD		0x140000
#define FILE_FSP_FILE	0x150000
#define FILE_FSP_FORK	0x160000
#define FILE_FSP_SRV	0x170000
#define FILE_FSP_VOL	0x180000
#define FILE_IDINDEX	0x190000
#define FILE_INTRLCKD	0x1A0000
#define FILE_MACANSI	0x1B0000
#define FILE_MEMORY		0x1C0000
#define FILE_NWTRASH	0x1D0000
#define FILE_PATHMAP	0x1E0000
#define FILE_SCAVENGR	0x1F0000
#define FILE_SDA		0x100000
#define FILE_SECUTIL	0x200000
#define FILE_SERVER		0x210000
#define FILE_SWMR		0x220000
#define FILE_TIME		0x230000
#define FILE_VOLUME		0x240000
#define FILE_CHGNTFY	0x250000
#define FILE_TCPTDI     0x260000
#define FILE_TCPUTIL    0x270000
#define FILE_TCPDSI     0x280000
#define	FILE_CACHEMDL   0x290000

#endif	// _FILENUMS_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\server\fileio.h ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	fileio.h

Abstract:

	This file defines the file I/O prototypes

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	18 Jun 1992		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef	_FILEIO_
#define	_FILEIO_

#define	FILEIO_OPEN_FILE					(FILE_NON_DIRECTORY_FILE		|\
											 FILE_RANDOM_ACCESS				|\
											 FILE_SYNCHRONOUS_IO_NONALERT)

#define	FILEIO_OPEN_FILE_SEQ				(FILE_NON_DIRECTORY_FILE		|\
											 FILE_SEQUENTIAL_ONLY			|\
											 FILE_NO_INTERMEDIATE_BUFFERING	|\
											 FILE_SYNCHRONOUS_IO_NONALERT)

#define	FILEIO_OPEN_DIR						(FILE_DIRECTORY_FILE			|\
											 FILE_SYNCHRONOUS_IO_NONALERT)

#define FILEIO_OPEN_EITHER					(FILE_SYNCHRONOUS_IO_NONALERT)

#define FILEIO_ACCESS_NONE					(FILE_READ_ATTRIBUTES			|\
											 SYNCHRONIZE)
#define FILEIO_ACCESS_READ					(GENERIC_READ					|\
											 SYNCHRONIZE)
#define FILEIO_ACCESS_WRITE					(GENERIC_WRITE					|\
											 SYNCHRONIZE)
#define FILEIO_ACCESS_READWRITE				(FILEIO_ACCESS_READ				|\
											 FILEIO_ACCESS_WRITE)
#define	FILEIO_ACCESS_DELETE				(DELETE							|\
											 SYNCHRONIZE)
#define	FILEIO_ACCESS_MAX					4

// Note that READ and WRITE share modes are enforced on a per-stream
// basis, whereas DELETE share mode is still per-file.  We must include
// SHARE_DELETE even for deny-all since things like cmd.exe will open
// a directory for DELETE when cd-ing into that directory.  If we were to
// then try to open the AFP_AfpInfo stream with no share delete access it
// would fail.  Since mac has no concept of share delete this is acceptible.
// In addition, mac must open for delete in order to rename/move a file/dir.
//
// The sharing modes are strictly per-stream except for the following
// exceptions:
//
// To delete the entire file, the caller must open the unnamed data
// stream (file) or the directory for delete access.
//
// If an open of any stream does not permit delete access to that stream
// then no one may open the file for for delete access.  Conversely if
// the file is already opened for delete access then any open of a
// stream which denies delete access will fail with a sharing violation.
//
// The reasoning is that if someone wants to prevent a stream from being
// deleted then they must prevent anyone from opening the file for
// delete.

#define	FILEIO_DENY_NONE					(FILE_SHARE_READ				|\
											 FILE_SHARE_WRITE				|\
											 FILE_SHARE_DELETE)
#define	FILEIO_DENY_READ					(FILE_SHARE_WRITE				|\
											 FILE_SHARE_DELETE)
#define	FILEIO_DENY_WRITE					(FILE_SHARE_READ				|\
											 FILE_SHARE_DELETE)
#define	FILEIO_DENY_ALL						FILE_SHARE_DELETE
#define	FILEIO_DENY_MAX						4

#define FILEIO_CREATE_SOFT					FILE_CREATE
#define FILEIO_CREATE_HARD					FILE_SUPERSEDE
#define	FILEIO_CREATE_INTERNAL				FILE_OPEN_IF
#define FILEIO_CREATE_MAX					2

// do NOT change the order of these unless you also change the code in
// afpVolumeCloseHandleAndFreeDesc for deleting streams from volume root.
#define	AFP_STREAM_DATA						0
#define	AFP_STREAM_RESC						1
#define	AFP_STREAM_IDDB						2
#define	AFP_STREAM_DT						3
#define	AFP_STREAM_INFO						4
#define	AFP_STREAM_COMM						5
#define	AFP_STREAM_MAX						6

// directories to ignore when enumerating
GLOBAL	UNICODE_STRING 		Dot EQU {0, 0, NULL};
GLOBAL	UNICODE_STRING 		DotDot EQU {0, 0, NULL};

// stream not to create during CopyFile
GLOBAL	UNICODE_STRING		DataStreamName EQU {0, 0, NULL};
#define IS_DATA_STREAM(pUnicodeStreamName) \
		EQUAL_UNICODE_STRING(pUnicodeStreamName, &DataStreamName, False)

GLOBAL	UNICODE_STRING		FullCommentStreamName EQU {0, 0, NULL};
#define IS_COMMENT_STREAM(pUnicodeStreamName) \
		EQUAL_UNICODE_STRING(pUnicodeStreamName, &FullCommentStreamName, False)

GLOBAL	UNICODE_STRING		FullResourceStreamName EQU {0, 0, NULL};
#define IS_RESOURCE_STREAM(pUnicodeStreamName) \
		EQUAL_UNICODE_STRING(pUnicodeStreamName, &FullResourceStreamName, True)

GLOBAL	UNICODE_STRING		FullInfoStreamName EQU {0, 0, NULL};
#define IS_INFO_STREAM(pUnicodeStreamName) \
		EQUAL_UNICODE_STRING(pUnicodeStreamName, &FullInfoStreamName, True)

// temporary filename when renaming files for FpExchangeFiles
// the name is composed of 40 spaces
#define AFP_TEMP_EXCHANGE_NAME	L"                                        "
GLOBAL 	UNICODE_STRING		AfpExchangeName EQU {0, 0, NULL};

GLOBAL	UNICODE_STRING		DosDevices EQU {0, 0, NULL};

GLOBAL	UNICODE_STRING		AfpStreams[AFP_STREAM_MAX] EQU { 0 };

#define	AfpIdDbStream						AfpStreams[AFP_STREAM_IDDB]
#define	AfpDesktopStream					AfpStreams[AFP_STREAM_DT]
#define	AfpResourceStream					AfpStreams[AFP_STREAM_RESC]
#define	AfpInfoStream						AfpStreams[AFP_STREAM_INFO]
#define	AfpCommentStream					AfpStreams[AFP_STREAM_COMM]
#define	AfpDataStream						AfpStreams[AFP_STREAM_DATA]

#pragma warning(disable:4010)

#if 0
GLOBAL	DWORD	AfpAccessModes[FILEIO_ACCESS_MAX] EQU		\
{															\
	FILEIO_ACCESS_NONE,										\
	FILEIO_ACCESS_READ,										\
	FILEIO_ACCESS_WRITE,									\
	FILEIO_ACCESS_READWRITE									\
};
#endif

GLOBAL	DWORD	AfpDenyModes[FILEIO_DENY_MAX] EQU			\
{															\
	FILEIO_DENY_NONE,										\
	FILEIO_DENY_READ,										\
	FILEIO_DENY_WRITE,										\
	FILEIO_DENY_ALL											\
};

GLOBAL	DWORD	AfpCreateDispositions[FILEIO_CREATE_MAX] EQU\
{															\
	FILEIO_CREATE_SOFT,										\
	FILEIO_CREATE_HARD										\
};

// This structure is used by file-system interface code

#if DBG
#define	FSH_SIGNATURE		*(DWORD *)"FSH"
#define	VALID_FSH(pFSH)		(((pFSH) != NULL) && \
							 ((pFSH)->fsh_FileHandle != NULL) && \
							 ((pFSH)->fsh_FileObject != NULL) && \
							 ((pFSH)->Signature == FSH_SIGNATURE))
#else
#define	VALID_FSH(pFSH)		(((pFSH)->fsh_FileHandle != NULL) && \
							 ((pFSH)->fsh_FileObject != NULL))
#endif

// NOTE: We overload the FileObject pointer to keep track of internal/client
//		 handles. We always mask off this while actually accessing it. The
//		 assumption here is that this pointer will never be odd.
//
#define	FSH_INTERNAL_MASK	1
#define	AfpGetRealFileObject(pFileObject)	(PFILE_OBJECT)((ULONG_PTR)(pFileObject) & ~FSH_INTERNAL_MASK)
typedef struct _FileSysHandle
{
#if	DBG
	DWORD			Signature;
#endif
	HANDLE			fsh_FileHandle;			// Host file handle
	PFILE_OBJECT	fsh_FileObject;			// File Object corres. to the file handle
	PDEVICE_OBJECT	fsh_DeviceObject;		// Device Object corres. to the file handle
} FILESYSHANDLE, *PFILESYSHANDLE;

#define	INTERNAL_HANDLE(pFSHandle)	((ULONG_PTR)((pFSHandle)->fsh_FileObject) & FSH_INTERNAL_MASK) ? True : False
#define	UPGRADE_HANDLE(pFSHandle)	((ULONG_PTR)((pFSHandle)->fsh_FileObject) &= ~FSH_INTERNAL_MASK)

typedef	struct _StreamsInfo
{
	UNICODE_STRING	si_StreamName;
	LARGE_INTEGER	si_StreamSize;
} STREAM_INFO, *PSTREAM_INFO;

typedef	struct _CopyFileInfo
{
	LONG			cfi_NumStreams;
	PFILESYSHANDLE	cfi_SrcStreamHandle;
	PFILESYSHANDLE	cfi_DstStreamHandle;
} COPY_FILE_INFO, *PCOPY_FILE_INFO;


#define AFP_RETRIEVE_MODTIME    1
#define AFP_RESTORE_MODTIME     2

extern
NTSTATUS
AfpFileIoInit(
	VOID
);


extern
VOID
AfpFileIoDeInit(
	VOID
);


extern
AFPSTATUS
AfpIoOpen(
	IN	PFILESYSHANDLE		hRelative,
	IN	DWORD				StreamId,
	IN	DWORD				Options,
	IN	PUNICODE_STRING		pObject,
	IN	DWORD				AfpAccess,
	IN	DWORD				AfpDenyMode,
	IN	BOOLEAN				CheckAccess,
	OUT	PFILESYSHANDLE		pFileSysHandle
);


extern
AFPSTATUS
AfpIoCreate(
	IN	PFILESYSHANDLE		hRelative,						// create relative to this
	IN	DWORD				StreamId,   					// Id of stream to create
	IN	PUNICODE_STRING		pObject,						// Name of file
	IN	DWORD				AfpAccess,						// FILEIO_ACCESS_XXX desired access
	IN	DWORD				AfpDenyMode,					// FILEIO_DENY_XXX
	IN	DWORD				CreateOptions,					// File/Directory etc.
	IN	DWORD				Disposition,					// Soft or hard create
	IN	DWORD				Attributes,						// hidden, archive, normal, etc.
	IN	BOOLEAN				CheckAccess,                	// If TRUE, enforce security
	IN	PSECURITY_DESCRIPTOR pSecDesc			OPTIONAL, 	// Security descriptor to slap on
	OUT	PFILESYSHANDLE		pFileSysHandle,             	// Place holder for the handle
	OUT PDWORD				pInformation		OPTIONAL,	// file opened, created, etc.
 	IN	struct _VolDesc *	pVolDesc			OPTIONAL,	// only if NotifyPath
	IN	PUNICODE_STRING		pNotifyPath			OPTIONAL,
	IN	PUNICODE_STRING		pNotifyParentPath	OPTIONAL
);


extern
AFPSTATUS
AfpIoRead(
	IN	PFILESYSHANDLE		pFileSysHandle,
	IN	PFORKOFFST			pForkOffset,
	IN	LONG				SizeReq,
	OUT	PLONG				pSizeRead,
	OUT	PBYTE				pBuffer
);


extern
AFPSTATUS
AfpIoWrite(
	IN	PFILESYSHANDLE		pFileSysHandle,
	IN	PFORKOFFST			pForkOffset,
	IN	LONG				SizeReq,
	OUT	PBYTE				pBuffer
);

extern
AFPSTATUS FASTCALL
AfpIoQuerySize(
	IN	PFILESYSHANDLE		pFileSysHandle,
	OUT	PFORKSIZE			pForkLength
);


extern
AFPSTATUS FASTCALL
AfpIoSetSize(
	IN	PFILESYSHANDLE		pFileSysHandle,
	IN	LONG				ForkLength
);

extern
AFPSTATUS
AfpIoChangeNTModTime(
	IN	PFILESYSHANDLE		pFileHandle,
	OUT	PTIME				pModTime
);

extern
AFPSTATUS
AfpIoQueryTimesnAttr(
	IN	PFILESYSHANDLE		pFileHandle,
	OUT	PDWORD				pCreatTime	OPTIONAL,
	OUT	PTIME				pModTime	OPTIONAL,
	OUT	PDWORD				pAttr		OPTIONAL
);

extern
AFPSTATUS
AfpIoSetTimesnAttr(
	IN PFILESYSHANDLE		pFileSysHandle,
	IN PAFPTIME				pCreateTime		OPTIONAL,
	IN PAFPTIME				pModTime		OPTIONAL,
	IN DWORD				AttrSet,
	IN DWORD				AttrClear,
	IN struct _VolDesc *	pVolDesc	OPTIONAL,	// only if NotifyPath
	IN PUNICODE_STRING		pNotifyPath	OPTIONAL
);


extern
AFPSTATUS
AfpIoRestoreTimeStamp(
	IN PFILESYSHANDLE		pFileSysHandle,
    IN OUT PTIME            pOriginalModTime,
    IN DWORD                dwFlag
);

extern
AFPSTATUS FASTCALL
AfpIoQueryShortName(
 	IN	PFILESYSHANDLE		pFileSysHandle,
	OUT	PANSI_STRING		pName
);

extern
NTSTATUS
AfpIoQueryLongName(
	IN	PFILESYSHANDLE		pFileHandle,
	IN	PUNICODE_STRING		pShortname,
	OUT	PUNICODE_STRING		pLongName
);

extern
PSTREAM_INFO FASTCALL
AfpIoQueryStreams(
	IN	PFILESYSHANDLE		pFileHandle

);

extern
NTSTATUS
AfpIoMarkFileForDelete(
	IN	PFILESYSHANDLE	pFileSysHandle,
	IN	struct _VolDesc *	pVolDesc	OPTIONAL, // only if pNotifyPath
	IN	PUNICODE_STRING pNotifyPath OPTIONAL,
	IN	PUNICODE_STRING pNotifyParentPath OPTIONAL
);

extern
NTSTATUS
AfpIoQueryDirectoryFile(
	IN	PFILESYSHANDLE		pFileSysHandle,
	OUT	PVOID				Enumbuf,
	IN	ULONG				Enumbuflen,
	IN	ULONG				FileInfoClass,
	IN	BOOLEAN				ReturnSingleEntry,
	IN	BOOLEAN 			RestartScan,
	IN	PUNICODE_STRING 	pString OPTIONAL
);


NTSTATUS
AfpIoQueryBasicInfo(
	IN	PFILESYSHANDLE		pFileHandle,
	OUT	PVOID				BasicInfoBuf
);

extern
AFPSTATUS FASTCALL
AfpIoClose(
 	IN	PFILESYSHANDLE		pFileSysHandle
);

extern
AFPSTATUS
AfpIoQueryVolumeSize(
	IN	struct _VolDesc *	pVolDesc,
	OUT LARGE_INTEGER   *   pFreeBytes,
	OUT	LARGE_INTEGER   *   pVolumeSize OPTIONAL
);

extern
AFPSTATUS
AfpIoMoveAndOrRename(
	IN	PFILESYSHANDLE		pfshFile,
	IN	PFILESYSHANDLE		pfshNewParent 		OPTIONAL,// Supply for Move operation
	IN	PUNICODE_STRING		pNewName,
	IN struct _VolDesc *	pVolDesc			OPTIONAL,// only if NotifyPath
	IN PUNICODE_STRING		pNotifyPath1		OPTIONAL,// REMOVE or RENAME action
	IN PUNICODE_STRING		pNotifyParentPath1	OPTIONAL,
	IN PUNICODE_STRING		pNotifyPath2		OPTIONAL,// ADDED action
	IN PUNICODE_STRING		pNotifyParentPath2	OPTIONAL
);

extern
AFPSTATUS
AfpIoCopyFile1(
	IN	PFILESYSHANDLE		phSrcFile,
	IN	PFILESYSHANDLE		phDstDir,
	IN	PUNICODE_STRING		pNewName,
	IN	struct _VolDesc *	pVolDesc			OPTIONAL,	// only if pNotifyPath
	IN	PUNICODE_STRING		pNotifyPath			OPTIONAL,
	IN	PUNICODE_STRING		pNotifyParentPath	OPTIONAL,
	OUT	PCOPY_FILE_INFO		pCopyFileInfo
);

extern
AFPSTATUS
AfpIoCopyFile2(
	IN	PCOPY_FILE_INFO		pCopyFileInfo,
	IN	struct _VolDesc *	pVolDesc			OPTIONAL,	// only if pNotifyPath
	IN	PUNICODE_STRING		pNotifyPath			OPTIONAL,
	IN	PUNICODE_STRING		pNotifyParentPath	OPTIONAL
);

extern
AFPSTATUS FASTCALL
AfpIoConvertNTStatusToAfpStatus(
	IN	NTSTATUS			Status
);

extern
VOID FASTCALL
AfpUpgradeHandle(
	IN	PFILESYSHANDLE		pFileHandle
);

extern
NTSTATUS FASTCALL
AfpIoWait(
	IN	PVOID				pObject,
	IN	PLARGE_INTEGER		pTimeOut			OPTIONAL
);

extern
NTSTATUS
AfpQueryPath(
	IN	HANDLE				FileHandle,
	IN	PUNICODE_STRING		pPath,
	IN	ULONG				MaximumBuf
);

extern
BOOLEAN FASTCALL
AfpIoIsSupportedDevice(
	IN	PFILESYSHANDLE 		pFileHandle,
	OUT	PDWORD				pFlags
);


#ifdef	FILEIO_LOCALS

LOCAL	UNICODE_STRING afpNTFSName = { 0 };
LOCAL	UNICODE_STRING afpCDFSName = { 0 };

LOCAL	UNICODE_STRING afpAHFSName = { 0 };

LOCAL VOID FASTCALL
afpUpdateOpenFiles(
	IN	BOOLEAN				Internal,		// True for internal handles
	IN	BOOLEAN				Open			// True for open, False for close
);

LOCAL VOID FASTCALL
afpUpdateFastIoStat(
	IN	BOOLEAN				Success
);

#endif	// FILEIO_LOCALS

#endif	// _FILEIO_


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\server\forks.h ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	forks.h

Abstract:

	This module contains the data structures to handle open forks.

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	25 Apr 1992		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef _FORKS_
#define _FORKS_

// Afp Open modes
#define	FORK_OPEN_NONE		0x00
#define	FORK_OPEN_READ		0x01
#define	FORK_OPEN_WRITE		0x02
#define	FORK_OPEN_READWRITE	0x03
#define	FORK_OPEN_MASK		0x03

// The Deny mode values are shifted left 2 bits and or'd with the open modes
// in AfpOpenFork() API.
#define	FORK_DENY_SHIFT		4

#define	FORK_DENY_NONE		0x00
#define	FORK_DENY_READ		0x01
#define	FORK_DENY_WRITE		0x02
#define	FORK_DENY_ALL		0x03
#define	FORK_DENY_MASK		0x03

// AfpOpenFork SubFunction values
#define	FORK_DATA			0
#define	FORK_RSRC			0x80

#define	AFP_UNLOCK_FLAG		1
#define	AFP_END_FLAG		0x80

/*
 * A ForkLock describes a lock on the fork. The locks are anchored at the
 * OpenForkDesc structure. The list describes all locks for this fork by
 * all sessions and all OForkRefNums. flo_key and flo_OForkRefNum identifies
 * the lock uniquely.
 */
#if DBG
#define	FORKLOCK_SIGNATURE			*(DWORD *)"FLO"
#define	VALID_FORKLOCK				(((pForkLock) != NULL) && \
									 ((pForkLock)->Signature == FORKLOCK_SIGNATURE))
#else
#define	VALID_FORKLOCK				((pForkLock) != NULL)
#endif

// Forward reference for the ForkLock structure
struct	_OpenForkEntry;

typedef struct _ForkLock
{
#if	DBG
	DWORD					Signature;
	DWORD					QuadAlign1;
#endif
	struct _ForkLock *		flo_Next;		// ForkDesc links
	struct _OpenForkEntry * flo_pOpenForkEntry;
	DWORD					QuadAlign2;
											// The owning OFE for this lock
	LONG					flo_Offset;		// Beginning of lock
	LONG					flo_Size;		// Size of lock
	DWORD					flo_Key;		// Key for this lock, essentially the
											// SessionId from the SDA
} FORKLOCK, *PFORKLOCK;

/*
 * An OpenForkDesc represents an open-fork. The list is anchored at the volume
 * Descriptor. There is exactly one entry per file/fork. Multiple instances of
 * open just ups the reference count. The list of locks originating here is for
 * all instances. A back link to the Volume descriptor exists for comfort.
 */
#if	DBG
#define	OPENFORKDESC_SIGNATURE		*(DWORD *)"OFD"
#define	VALID_OPENFORKDESC(pOpenForkDesc)	(((pOpenForkDesc) != NULL) && \
						((pOpenForkDesc)->Signature == OPENFORKDESC_SIGNATURE))
#else
#define	VALID_OPENFORKDESC(pOpenForkDesc)	((pOpenForkDesc) != NULL)
#endif

typedef struct _OpenForkDesc
{
#if	DBG
	DWORD					Signature;
	DWORD					QuadAlign1;
#endif
	struct _OpenForkDesc *	ofd_Next;			// Volume links
	struct _OpenForkDesc **	ofd_Prev;			// Volume links

	struct _VolDesc *		ofd_pVolDesc;		// Pointer to the volume descriptor
	PFORKLOCK				ofd_pForkLock;		// List of file locks
	DWORD					ofd_FileNumber;		// File number of the open file
	LONG					ofd_UseCount;		// Number of OpenForkEntry refs.
	USHORT					ofd_cOpenR;			// # of instances of open for read
	USHORT					ofd_cOpenW;			// # of instances of open for write
	USHORT					ofd_cDenyR;			// # of instances of deny read
	USHORT					ofd_cDenyW;			// # of instances of deny write
	USHORT					ofd_NumLocks;		// Number of file locks
	USHORT					ofd_Flags;			// OPEN_FORK_xxx bits
	AFP_SPIN_LOCK				ofd_Lock;			// Lock for this descriptor
	UNICODE_STRING			ofd_FileName;		// Name of the file (w/o the stream)
	UNICODE_STRING			ofd_FilePath;		// Volume relative path to the file
} OPENFORKDESC, *POPENFORKDESC;


#define	OPEN_FORK_RESOURCE			True
#define	OPEN_FORK_DATA				False
#define	OPEN_FORK_CLOSING			0x8000
// To determine whether FlushFork of resource should really take the current
// ChangeTime to be the LastWriteTime
#define OPEN_FORK_WRITTEN			0x0100

/*
 * An OpenForkEntry represents an OForkRefNum. Every instance of an open
 * fork has an entry here. This list is anchored in the SDA. A global open
 * fork list used by the admin APIs is also linked to this.
 */
#if DBG
#define	OPENFORKENTRY_SIGNATURE		*(DWORD *)"OFE"
#define	VALID_OPENFORKENTRY(pOpenForkEntry)	\
						(((pOpenForkEntry) != NULL) && \
						 ((pOpenForkEntry)->Signature == OPENFORKENTRY_SIGNATURE))
#else
#define	VALID_OPENFORKENTRY(pOpenForkEntry) ((pOpenForkEntry) != NULL)
#endif

typedef struct _OpenForkEntry
{
#if	DBG
	DWORD					Signature;
#endif

	struct _OpenForkEntry *	ofe_Next;			// Global links
	struct _OpenForkEntry **ofe_Prev;			// Global links

	struct _OpenForkDesc *	ofe_pOpenForkDesc;	// Pointer to the descriptor
    struct _SessDataArea *  ofe_pSda;           // Identifies the owning session
	struct _ConnDesc *	    ofe_pConnDesc;	    // Identifies the owning connection
	
	FILESYSHANDLE			ofe_FileSysHandle;	// The file system handles
#define	ofe_ForkHandle		ofe_FileSysHandle.fsh_FileHandle
#define	ofe_pFileObject		ofe_FileSysHandle.fsh_FileObject
#define	ofe_pDeviceObject	ofe_FileSysHandle.fsh_DeviceObject

	DWORD					ofe_OForkRefNum;	// Open Fork reference number
	DWORD					ofe_ForkId;			// Unique file id used by admin.
												// Not re-cycled
	BYTE					ofe_OpenMode;		// Open modes - AFP
	BYTE					ofe_DenyMode;		// Deny modes - AFP
	USHORT					ofe_Flags;			// Flag bits defined above
	LONG					ofe_RefCount;		// Count of references to this entry
	LONG					ofe_cLocks;			// Number of locks on this fork
	AFP_SPIN_LOCK				ofe_Lock;			// Lock for manipulating locks etc.
} OPENFORKENTRY, *POPENFORKENTRY;



#define	RESCFORK(pOpenForkEntry)	\
		(((pOpenForkEntry)->ofe_Flags & OPEN_FORK_RESOURCE) ? True : False)

#define	DATAFORK(pOpenForkEntry)	(!RESCFORK(pOpenForkEntry))

#define	FORK_OPEN_CHUNKS	7
typedef struct _OpenForkSession
{
	POPENFORKENTRY	ofs_pOpenForkEntry[FORK_OPEN_CHUNKS];
										// Pointer to actual entry
	struct _OpenForkSession *ofs_Link;	// Link to next cluster
} OPENFORKSESS, *POPENFORKSESS;

// Used by AfpForkLockOperation call.
typedef	enum
{
	LOCK = 1,
	UNLOCK,
	IOCHECK,
} LOCKOP;

GLOBAL	POPENFORKENTRY	AfpOpenForksList EQU NULL; // List of open forks
GLOBAL	DWORD			AfpNumOpenForks EQU 0;	// Total # of open forks
GLOBAL	AFP_SPIN_LOCK		AfpForksLock EQU { 0 };	// Lock for AfpOpenForksList,
												// and AfpNumOpenForks
extern
NTSTATUS
AfpForksInit(
	VOID
);

extern
POPENFORKENTRY FASTCALL
AfpForkReferenceByRefNum(
	IN	struct _SessDataArea *	pSda,
 	IN	DWORD					OForkRefNum
);

extern
POPENFORKENTRY FASTCALL
AfpForkReferenceByPointer(
	IN	POPENFORKENTRY			pOpenForkEntry
);

extern
POPENFORKENTRY FASTCALL
AfpForkReferenceById(
	IN	DWORD					ForkId
);

extern
VOID FASTCALL
AfpForkDereference(
	IN	POPENFORKENTRY			pOpenForkEntry
);

extern
AFPSTATUS
AfpForkOpen(
	IN	struct _SessDataArea *	pSda,
	IN	struct _ConnDesc *		pConnDesc,
	IN	struct _PathMapEntity *	pPME,
	IN	struct _FileDirParms *	pFDParm,
	IN	DWORD					AccessMode,
	IN	BOOLEAN					Resource,
	OUT	POPENFORKENTRY *		ppOpenForkEntry,
	OUT	PBOOLEAN				pCleanupExchgLock
);

extern
VOID
AfpForkClose(
	IN	POPENFORKENTRY			pOpenForkEntry
);

extern
AFPSTATUS
AfpCheckDenyConflict(
	IN	struct _VolDesc	*		pVolDesc,
	IN	DWORD					AfpId,
	IN	BOOLEAN					Resource,
	IN	BYTE					OpenMode,
	IN	BYTE					DenyMode,
	IN	POPENFORKDESC *			ppOpenForkDesc	OPTIONAL
);

extern
AFPSTATUS
AfpForkLockOperation(
	IN	struct _SessDataArea *	pSda,
	IN	POPENFORKENTRY			pOpenForkEntry,
	IN OUT	PFORKOFFST      	pOffset,
	IN OUT	PFORKSIZE       	pSize,
	IN	LOCKOP					Operation,	// LOCK, UNLOCK or IOCHECK
	IN	BOOLEAN					EndFlag		// If True range is from end, else start
);

extern
VOID
AfpForkLockUnlink(
	IN	PFORKLOCK				pForkLock
);

extern
AFPSTATUS
AfpAdmWForkClose(
	IN	OUT	PVOID	InBuf		OPTIONAL,
	IN	LONG		OutBufLen	OPTIONAL,
	OUT	PVOID		OutBuf		OPTIONAL
);

extern
VOID
AfpExchangeForkAfpIds(
	IN	struct _VolDesc	*		pVolDesc,
	IN	DWORD		AfpId1,
	IN	DWORD		AfpId2
);

#ifdef FORK_LOCALS

LOCAL	DWORD	afpNextForkId = 1;	// Id to be assigned to an open fork

LOCAL BOOLEAN
afpForkGetNewForkRefNumAndLinkInSda(
	IN	struct _SessDataArea *	pSda,
	IN	POPENFORKENTRY			pOpenForkEntry
);

LOCAL
AFPSTATUS
afpForkConvertToAbsOffSize(
	IN	POPENFORKENTRY			pOpenForkEntry,
	IN	LONG					Offset,
	IN OUT	PLONG				pSize,
	OUT	PFORKOFFST				pAbsOffset
);

#endif	// FORK_LOCALS
#endif	// _FORKS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\server\forkio.h ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	forkio.h

Abstract:

	This file defines the fork I/O prototypes which are callable at DISPATCH
	level.

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	15 Jan 1993		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef	_FORKIO_
#define	_FORKIO_


#define AFP_DELALLOC_SIGNATURE  0x15263748

typedef struct _DelayedAlloc
{
#if DBG
    LIST_ENTRY          Linkage;
    DWORD               Signature;
    PIRP                pIrp;
    DWORD               State;
#endif
    WORK_ITEM           WorkItem;
    PSDA                pSda;
    PREQUEST            pRequest;
    LARGE_INTEGER       Offset;
    DWORD               BufSize;
    POPENFORKENTRY      pOpenForkEntry;
    PMDL                pMdl;
    DWORD               Flags;

} DELAYEDALLOC, *PDELAYEDALLOC;


#define AFP_CACHEMDL_DEADSESSION    0x1
#define AFP_CACHEMDL_ALLOC_ERROR    0x2

#define AFP_DBG_MDL_INIT                0x00000001
#define AFP_DBG_MDL_REQUESTED           0x00000002
#define AFP_DBG_MDL_IN_USE              0x00000004
#define AFP_DBG_MDL_RETURN_IN_PROGRESS  0x00000008
#define AFP_DBG_MDL_RETURN_COMPLETED    0x00000010
#define AFP_DBG_MDL_PROC_QUEUED         0x00000020
#define AFP_DBG_MDL_PROC_IN_PROGRESS    0x00000040
#define AFP_DBG_WRITE_MDL               0x10000000
#define AFP_DBG_READ_MDL                0x40000000
#define AFP_DBG_MDL_END                 0x80000000

#if DBG
#define AFP_DBG_SET_DELALLOC_STATE(_pDelA, _flag) (_pDelA->State |= _flag)
#define AFP_DBG_SET_DELALLOC_IRP(_pDelA, _pIrp)   (_pDelA->pIrp = (PIRP)_pIrp)
#define AFP_DBG_INC_DELALLOC_BYTECOUNT(_Counter, _ByteCount)    \
{                                                               \
    KIRQL   _OldIrql;                                           \
    ACQUIRE_SPIN_LOCK(&AfpDebugSpinLock, &_OldIrql);            \
    _Counter += _ByteCount;                                     \
    RELEASE_SPIN_LOCK(&AfpDebugSpinLock, _OldIrql);             \
}

#define AFP_DBG_DEC_DELALLOC_BYTECOUNT(_Counter, _ByteCount)    \
{                                                               \
    KIRQL   _OldIrql;                                           \
    ACQUIRE_SPIN_LOCK(&AfpDebugSpinLock, &_OldIrql);            \
    _Counter -= _ByteCount;                                     \
    RELEASE_SPIN_LOCK(&AfpDebugSpinLock, _OldIrql);             \
}

#else
#define AFP_DBG_SET_DELALLOC_STATE(_pDelA, _flag)
#define AFP_DBG_SET_DELALLOC_IRP(_pDelA, _pIrp)
#define AFP_DBG_INC_DELALLOC_BYTECOUNT(_Counter, _ByteCount)
#define AFP_DBG_DEC_DELALLOC_BYTECOUNT(_Counter, _ByteCount)
#endif


extern
AFPSTATUS
AfpIoForkRead(
	IN	PSDA			pSda,			// The session requesting read
	IN	POPENFORKENTRY	pOpenForkEntry,	// The open fork in question
	IN	PFORKOFFST		pOffset,		// Pointer to fork offset
	IN	LONG			ReqCount,		// Size of read request
	IN	BYTE			NlMask,
	IN	BYTE			NlChar
);

extern
AFPSTATUS
AfpIoForkWrite(
	IN	PSDA			pSda,			// The session requesting read
	IN	POPENFORKENTRY	pOpenForkEntry,	// The open fork in question
	IN	PFORKOFFST		pOffset,		// Pointer to fork offset
	IN	LONG			ReqCount		// Size of read request
);

extern
AFPSTATUS
AfpIoForkLockUnlock(
	IN	PSDA			pSda,
	IN	PFORKLOCK		pForkLock,
	IN	PFORKOFFST		pForkOffset,
	IN	PFORKSIZE		pLockSize,
	IN	BYTE			Func			
);

extern
VOID FASTCALL
AfpAllocWriteMdl(
    IN PDELAYEDALLOC    pDelAlloc
);

extern
NTSTATUS
AfpAllocWriteMdlCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           pIrp,
    IN PVOID          Context
);

extern
NTSTATUS FASTCALL
AfpBorrowWriteMdlFromCM(
    IN  PDELAYEDALLOC   pDelAlloc,
    OUT PMDL           *ppReturnMdl
);

extern
VOID FASTCALL
AfpReturnWriteMdlToCM(
    IN  PDELAYEDALLOC   pDelAlloc
);

extern
NTSTATUS
AfpReturnWriteMdlToCMCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           pIrp,
    IN PVOID          Context
);

extern
NTSTATUS FASTCALL
AfpBorrowReadMdlFromCM(
    IN PSDA             pSda
);

extern
NTSTATUS
AfpBorrowReadMdlFromCMCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           pIrp,
    IN PVOID          Context
);


extern
VOID FASTCALL
AfpReturnReadMdlToCM(
    IN  PDELAYEDALLOC   pDelAlloc
);


extern
NTSTATUS
AfpReturnReadMdlToCMCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           pIrp,
    IN PVOID          Context
);


extern
PDELAYEDALLOC FASTCALL
AfpAllocDelAlloc(
    IN VOID
);


extern
VOID FASTCALL
AfpFreeDelAlloc(
    IN PDELAYEDALLOC    pDelAlloc
);


// defined in fsp_fork.c, but we will put the prototype here
extern
AFPSTATUS FASTCALL
AfpFspDispReadContinue(
	IN	PSDA	pSda
);


#define	FUNC_READ		0x01
#define	FUNC_WRITE		0x02
#define	FUNC_LOCK		0x03
#define	FUNC_UNLOCK		0x04
#define	FUNC_NOTIFY		0x05

// if the Write size is below this, it's probably more efficient to avoid going to cache mgr
#define CACHEMGR_WRITE_THRESHOLD    8192

// if the Read size is below this, it's probably more efficient to avoid going to cache mgr
#define CACHEMGR_READ_THRESHOLD     8192

#ifdef	FORKIO_LOCALS

// The following structure is used as a context in the Irp. The completion
// routines uses this to handle responding to the original request.

#if DBG
#define	CTX_SIGNATURE			*(DWORD *)"FCTX"
#define	VALID_CTX(pCmplCtxt)	(((pCmplCtxt) != NULL) && \
								 ((pCmplCtxt)->Signature == CTX_SIGNATURE))
#else
#define	VALID_CTX(pCmplCtxt)	((pCmplCtxt) != NULL)
#endif

typedef	struct _CompletionContext
{
#if	DBG
	DWORD				Signature;
#endif
	PSDA				cc_pSda;		// The session context (valid except unlock)
	PFORKLOCK			cc_pForkLock;	// Valid only during a LOCK
	AFPSTATUS			cc_SavedStatus;	// Used by READ
	LONG				cc_Offst;		// Offset of Write request
	LONG				cc_ReqCount;	// The request count for read/write
	BYTE				cc_Func;		// READ/WRITE/LOCK/UNLOCK/NOTIFY
	BYTE				cc_NlMask;		// For read only
	BYTE				cc_NlChar;		// For read only
} CMPLCTXT, *PCMPLCTXT;


#if	DBG
#define	afpInitializeCmplCtxt(pCtxt, Func, SavedStatus, pSda, pForkLock, ReqCount, Offst)	\
		(pCtxt)->Signature = CTX_SIGNATURE;		\
		(pCtxt)->cc_Func	= Func;				\
		(pCtxt)->cc_pSda	= pSda;				\
		(pCtxt)->cc_pForkLock = pForkLock;		\
		(pCtxt)->cc_SavedStatus = SavedStatus;	\
		(pCtxt)->cc_ReqCount= ReqCount;			\
		(pCtxt)->cc_Offst = Offst;
#else
#define	afpInitializeCmplCtxt(pCtxt, Func, SavedStatus, pSda, pForkLock, ReqCount, Offst)	\
		(pCtxt)->cc_Func	= Func;				\
		(pCtxt)->cc_pSda	= pSda;				\
		(pCtxt)->cc_pForkLock = pForkLock;		\
		(pCtxt)->cc_SavedStatus = SavedStatus;	\
		(pCtxt)->cc_ReqCount= ReqCount;			\
		(pCtxt)->cc_Offst = Offst;
#endif

extern
PCMPLCTXT
AfpAllocCmplCtxtBuf(
	IN	PSDA	pSda
);

VOID
AfpFreeCmplCtxtBuf(
	IN	PCMPLCTXT   pCmplCtxt
);

#endif	// FORKIO_LOCALS

#endif	// _FORKIO_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\server\fsddata.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

	fsd.c

Abstract:

	This module implements the File System pageable data. It is here because of
	the restrictions on pageable code and data in a single module.

Author:

	Jameel Hyder (microsoft!jameelh)

Revision History:
	10 Nov 1993		Initial Version

--*/

#define	FILENUM	FILE_FSDDATA

#define	SERVER_LOCALS
#include <afp.h>
#define	AFPADMIN_LOCALS
#include <afpadmin.h>
#include <scavengr.h>
#include <access.h>
#include <secutil.h>

#ifdef	ALLOC_DATA_PRAGMA
#pragma data_seg("PAGE")
#endif

INIT_SYSTEMS	AfpInitSubSystems[NUM_INIT_SYSTEMS] =
		{
			{	AfpMacAnsiInit,		AfpMacAnsiDeInit,
#if DBG
				False,				False
				,"AfpMacAnsiInit",	"AfpMacAnsiDeInit"
#endif
			},
			{	AfpFileIoInit,		NULL,
#if DBG
				False,				False
				,"AfpFileIoInit",	NULL
#endif
			},
			{	AfpSdaInit,			NULL,
#if DBG
				False, 				False
				,"AfpSdaInit",		NULL
#endif
			},
			{	AfpVolumeInit,		NULL,
#if DBG
				False,				False
				,"AfpVolumeInit",	NULL,
#endif
			},
			{	AfpForksInit,		NULL,
#if DBG
				False,				False
				,"AfpForksInit",	NULL,
#endif
			},
			{	AfpDesktopInit,		NULL,
#if DBG
				False,				False
				,"AfpDesktopInit",	NULL,
#endif
			},
			{	AfpScavengerInit,	AfpScavengerDeInit,
#if DBG
				False,				False
				,"AfpScavengerInit","AfpScavengerDeInit"
#endif
			},
			{	AfpSecUtilInit,		AfpSecUtilDeInit,
#if DBG
				False,				False
				,"AfpInitSecUtil",	"AfpSecUtilDeInit"
#endif
			},

			// The following should happen after the scavenger is initialized
			{	AfpMemoryInit,		AfpMemoryDeInit,
#if DBG
				False,				False
				,"AfpMemoryDeInit",	"AfpMemoryDeInit"
#endif
			},
			{	NULL,				AfpAdminDeInit,
#if DBG
				False, 				False
				,NULL,				"AfpAdminDeInit"
#endif
			},
			{	AfpDfeInit,			AfpDfeDeInit,
#if DBG
				False, 				False
				,"AfpDfeInit",		"AfpDfeDeInit"
#endif
			}
	};

// This table is tightly linked to the opcode definitions in H\ADMIN.H
ADMIN_DISPATCH_TABLE AfpAdminDispatchTable[CC_BASE_MAX] =
{
	{
	  0,							0,
	  True,							OP_SERVICE_START,
	  NULL,							AfpAdmServiceStart,
	  {
		{ DESC_NONE, 0 },
		{ DESC_NONE, 0 },
		{ DESC_NONE, 0 }
	  }
	},
	{
	  0,							0,
	  True,							OP_SERVICE_STOP,
	  NULL,							AfpAdmServiceStop,
	  {
		{ DESC_NONE, 0 },
		{ DESC_NONE, 0 },
		{ DESC_NONE, 0 }
	  }
	},
	{
	  0,							0,
	  True,							OP_SERVICE_PAUSE,
	  NULL,							AfpAdmServicePause,
	  {
		{ DESC_NONE, 0 },
		{ DESC_NONE, 0 },
		{ DESC_NONE, 0 }
	  }
	},
	{
	  0,							0,
	  True,							OP_SERVICE_CONTINUE,
	  NULL,							AfpAdmServiceContinue,
	  {
		{ DESC_NONE, 0 },
		{ DESC_NONE, 0 },
		{ DESC_NONE, 0 }
	  }
	},
	{
	  sizeof(AFP_STATISTICS_INFO),	0,
	  False,						OP_GET_STATISTICS,
	  AfpAdmGetStatistics,			NULL,
	  {
		{ DESC_NONE, 0 },
		{ DESC_NONE, 0 },
		{ DESC_NONE, 0 }
	  }
	},
	{
	  sizeof(AFP_STATISTICS_INFO_EX),	0,
	  False,						OP_GET_STATISTICS_EX,
	  AfpAdmGetStatisticsEx,		NULL,
	  {
		{ DESC_NONE, 0 },
		{ DESC_NONE, 0 },
		{ DESC_NONE, 0 }
	  }
	},
	{
	  0,							0,
	  False,						OP_CLEAR_STATISTICS,
	  AfpAdmClearStatistics,		NULL,
	  {
		{ DESC_NONE, 0 },
		{ DESC_NONE, 0 },
		{ DESC_NONE, 0 }
	  }
	},
	{
	  sizeof(AFP_PROFILE_INFO),		0,
	  False,						OP_GET_PROF_COUNTERS,
	  AfpAdmGetProfCounters,		NULL,
	  {
		{ DESC_NONE, 0 },
		{ DESC_NONE, 0 },
		{ DESC_NONE, 0 }
	  }
	},
	{
	  0,							0,
	  False,						OP_CLEAR_PROF_COUNTERS,
	  AfpAdmClearProfCounters,		NULL,
	  {
		{ DESC_NONE, 0 },
		{ DESC_NONE, 0 },
		{ DESC_NONE, 0 }
	  }
	},
	{
	  sizeof(AFP_SID_OFFSET_DESC),	0,
	  True,							OP_SERVER_ADD_SID_OFFSETS,
	  AfpAdmServerSetParms,			NULL,
	  {
		{ DESC_SPECIAL, 0 },
		{ DESC_NONE, 0 },
		{ DESC_NONE, 0 }
	  }
	},
	{
	  0,							0,
	  False,						OP_SERVER_GET_INFO,
	  AfpAdmServerGetInfo,			NULL,
	  {
		{ DESC_NONE, 0 },
		{ DESC_NONE, 0 },
		{ DESC_NONE, 0 }
	  }
	},
	{
	  sizeof(AFP_SERVER_INFO),		sizeof(SETINFOREQPKT),
	  True,							OP_SERVER_SET_INFO,
	  NULL, 						AfpAdmWServerSetInfo,
	  {
		{ DESC_STRING, sizeof(SETINFOREQPKT) + FIELD_OFFSET(AFP_SERVER_INFO, afpsrv_name) },
		{ DESC_STRING, sizeof(SETINFOREQPKT) + FIELD_OFFSET(AFP_SERVER_INFO, afpsrv_login_msg) },
		{ DESC_STRING, sizeof(SETINFOREQPKT) + FIELD_OFFSET(AFP_SERVER_INFO, afpsrv_codepage) },
	  }
	},
	{
	  sizeof(SRVETCPKT),			0,
	  True,							OP_SERVER_ADD_ETC,
	  AfpAdmServerAddEtc,			NULL,
	  {
		{ DESC_ETC, FIELD_OFFSET(SRVETCPKT, retc_NumEtcMaps) },
		{ DESC_NONE, 0 },
		{ DESC_NONE, 0 }
	  }
	},
	{
	  sizeof(ETCMAPINFO),			sizeof(SETINFOREQPKT),
	  True,							OP_SERVER_SET_ETC,
	  AfpAdmServerSetEtc,			NULL,
	  {
		{ DESC_NONE, 0 },
		{ DESC_NONE, 0 },
		{ DESC_NONE, 0 }
	  }
	},
	{
	  sizeof(ETCMAPINFO),			0,
	  True,							OP_SERVER_DELETE_ETC,
	  AfpAdmServerDeleteEtc,		NULL,
	  {
		{ DESC_NONE, 0 },
		{ DESC_NONE, 0 },
		{ DESC_NONE, 0 }
	  }
	},
	{
	  sizeof(SRVICONINFO),			0,
	  True,							OP_SERVER_ADD_ICON,
	  AfpAdmServerAddIcon,			NULL,
	  {
		{ DESC_ICON, FIELD_OFFSET(SRVICONINFO, icon_length) },
		{ DESC_NONE, 0 },
		{ DESC_NONE, 0 }
	  }
	},
	{
	  sizeof(AFP_VOLUME_INFO),		0,
	  True,							OP_VOLUME_ADD,
	  AfpAdmVolumeAdd,				AfpAdmWVolumeAdd,
	  {
		{ DESC_STRING, FIELD_OFFSET(AFP_VOLUME_INFO, afpvol_name) },
		{ DESC_STRING, FIELD_OFFSET(AFP_VOLUME_INFO, afpvol_password) },
		{ DESC_STRING, FIELD_OFFSET(AFP_VOLUME_INFO, afpvol_path) }
	  }
	},
	{
	  sizeof(AFP_VOLUME_INFO),		0,
	  True,							OP_VOLUME_DELETE,
	  NULL,							AfpAdmWVolumeDelete,
	  {
		{ DESC_STRING, FIELD_OFFSET(AFP_VOLUME_INFO, afpvol_name) },
		{ DESC_STRING, FIELD_OFFSET(AFP_VOLUME_INFO, afpvol_password) },
		{ DESC_STRING, FIELD_OFFSET(AFP_VOLUME_INFO, afpvol_path) }
	  }
	},
	{
	  sizeof(AFP_VOLUME_INFO),		0,
	  False,						OP_VOLUME_GET_INFO,
	  AfpAdmVolumeGetInfo,			NULL,
	  {
		{ DESC_STRING, FIELD_OFFSET(AFP_VOLUME_INFO, afpvol_name) },
		{ DESC_NONE, 0 },
		{ DESC_NONE, 0 }
	  }
	},
	{
	  sizeof(SETINFOREQPKT) + sizeof(AFP_VOLUME_INFO),	sizeof(SETINFOREQPKT),
	  True,							OP_VOLUME_SET_INFO,
	  AfpAdmVolumeSetInfo,			NULL,
	  {
		{ DESC_STRING, sizeof(SETINFOREQPKT) + FIELD_OFFSET(AFP_VOLUME_INFO, afpvol_name) },
		{ DESC_STRING, sizeof(SETINFOREQPKT) + FIELD_OFFSET(AFP_VOLUME_INFO, afpvol_password) },
		{ DESC_STRING, sizeof(SETINFOREQPKT) + FIELD_OFFSET(AFP_VOLUME_INFO, afpvol_path) }
	  }
	},
	{
	  sizeof(ENUMREQPKT),			0,
	  False,						OP_VOLUME_ENUM,
	  AfpAdmVolumeEnum,				NULL,
	  {
		{ DESC_NONE, 0 },
		{ DESC_NONE, 0 },
		{ DESC_NONE, 0 }
	  }
	},
	{
	  sizeof(ENUMREQPKT),			0,
	  False,						OP_SESSION_ENUM,
	  AfpAdmSessionEnum,			NULL,
	  {
		{ DESC_NONE, 0 },
		{ DESC_NONE, 0 },
		{ DESC_NONE, 0 }
	  }
	},
	{
	  sizeof(AFP_SESSION_INFO),		0,
	  True,							OP_SESSION_CLOSE,
	  NULL,							AfpAdmWSessionClose,
	  {
		{ DESC_NONE, 0 },
		{ DESC_NONE, 0 },
		{ DESC_NONE, 0 }
	  }
	},
	{
	  sizeof(ENUMREQPKT),			0,
	  False,						OP_CONNECTION_ENUM,
	  AfpAdmConnectionEnum,			NULL,
	  {
		{ DESC_NONE, 0 },
		{ DESC_NONE, 0 },
		{ DESC_NONE, 0 }
	  }
	},
	{
	  sizeof(ENUMREQPKT),			0,
	  True,							OP_CONNECTION_CLOSE,
	  NULL,							AfpAdmWConnectionClose,
	  {
		{ DESC_NONE, 0 },
		{ DESC_NONE, 0 },
		{ DESC_NONE, 0 }
	  }
	},
	{
	  sizeof(AFP_DIRECTORY_INFO),	0,
	  False,						OP_DIRECTORY_GET_INFO,
	  NULL,							AfpAdmWDirectoryGetInfo,
	  {
		{ DESC_STRING, FIELD_OFFSET(AFP_DIRECTORY_INFO, afpdir_path) },
		{ DESC_NONE, 0 },
		{ DESC_NONE, 0 }
	  }
	},
	{
	  sizeof(SETINFOREQPKT) + sizeof(AFP_DIRECTORY_INFO),	sizeof(SETINFOREQPKT),
	  True,							OP_DIRECTORY_SET_INFO,
	  NULL,							AfpAdmWDirectorySetInfo,
	  { { DESC_STRING,	sizeof(SETINFOREQPKT) + FIELD_OFFSET(AFP_DIRECTORY_INFO, afpdir_path)  },
		{ DESC_SID,		sizeof(SETINFOREQPKT) + FIELD_OFFSET(AFP_DIRECTORY_INFO, afpdir_owner) },
		{ DESC_SID,		sizeof(SETINFOREQPKT) + FIELD_OFFSET(AFP_DIRECTORY_INFO, afpdir_group) } }
	},
	{
	  sizeof(ENUMREQPKT),			0,
	  False,						OP_FORK_ENUM,
	  AfpAdmForkEnum,				NULL,
	  {
		{ DESC_NONE, 0 },
		{ DESC_NONE, 0 },
		{ DESC_NONE, 0 }
	  }
	},
	{
	  sizeof(AFP_FILE_INFO),		0,
	  True,							OP_FORK_CLOSE,
	  NULL,							AfpAdmWForkClose,
	  {
		{ DESC_NONE, 0 },
		{ DESC_NONE, 0 },
		{ DESC_NONE, 0 }
	  }
	},
	{
	  sizeof(AFP_MESSAGE_INFO),		0,
	  True,							OP_MESSAGE_SEND,
	  AfpAdmMessageSend,			NULL,
	  {
		{ DESC_STRING,  FIELD_OFFSET(AFP_MESSAGE_INFO, afpmsg_text) },
		{ DESC_NONE, 0 },
		{ DESC_NONE, 0 }
	  }
	},
	{
      sizeof(SETINFOREQPKT) + sizeof(AFP_FINDER_INFO), sizeof(SETINFOREQPKT),
	  True,						OP_FINDER_SET,
	  NULL,						AfpAdmWFinderSetInfo,
	  {
        { DESC_STRING, 	sizeof(SETINFOREQPKT) + FIELD_OFFSET(AFP_FINDER_INFO, afpfd_path) },
		{ DESC_NONE, 0 },
		{ DESC_NONE, 0 }
	  }
	}
};

#ifdef	ALLOC_DATA_PRAGMA
#pragma data_seg()
#endif



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\server\forks.c ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	forks.c

Abstract:

	This module contains the routines for manipulating the open forks.

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	25 Apr 1992		Initial Version

Notes:	Tab stop: 4
--*/

#define	FORK_LOCALS
#define	FORKIO_LOCALS
#define	FILENUM	FILE_FORKS

#include <afp.h>
#include <client.h>
#include <fdparm.h>
#include <pathmap.h>
#include <scavengr.h>
#include <afpinfo.h>
#include <forkio.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, AfpForksInit)
#pragma alloc_text( PAGE, afpForkConvertToAbsOffSize)
#pragma alloc_text( PAGE_AFP, AfpAdmWForkClose)
#pragma alloc_text( PAGE_AFP, AfpForkReferenceById)
#endif

/***	AfpForksInit
 *
 *	Initialize locks for forks.
 */
NTSTATUS
AfpForksInit(
	VOID
)
{
	INITIALIZE_SPIN_LOCK(&AfpForksLock);
	return STATUS_SUCCESS;
}


/***	AfpForkReferenceByRefNum
 *
 *	Map a OForkRefNum to an open fork entry for the session and reference it.
 *
 *	LOCKS:	ofe_Lock
 *
 *	CALLABLE at DISPATCH_LEVEL ONLY !!!
 */
POPENFORKENTRY FASTCALL
AfpForkReferenceByRefNum(
	IN	PSDA	pSda,
	IN	DWORD	OForkRefNum
)
{
	POPENFORKSESS	pOpenForkSess;
	POPENFORKENTRY	pOpenForkEntry;
	POPENFORKENTRY	pOFEntry = NULL;

	ASSERT (KeGetCurrentIrql() == DISPATCH_LEVEL);
	ASSERT (VALID_SDA(pSda));

    if (OForkRefNum == 0)
    {
	    DBGPRINT(DBG_COMP_FORKS, DBG_LEVEL_ERR,
			("AfpForkReferenceByRefNum: client sent 0 for ForkRefNumFork\n"));
        return(NULL);
    }

	pOpenForkSess = &pSda->sda_OpenForkSess;
	while (OForkRefNum > FORK_OPEN_CHUNKS)
	{
		OForkRefNum -= FORK_OPEN_CHUNKS;
		pOpenForkSess = pOpenForkSess->ofs_Link;
		if (pOpenForkSess == NULL)
			return NULL;
	}
	pOpenForkEntry = pOpenForkSess->ofs_pOpenForkEntry[OForkRefNum-1];

	// If this has been marked closed, then return NULL

	if (pOpenForkEntry != NULL)
	{
		ASSERT(VALID_OPENFORKENTRY(pOpenForkEntry));

		ACQUIRE_SPIN_LOCK_AT_DPC(&pOpenForkEntry->ofe_Lock);

		if (!(pOpenForkEntry->ofe_Flags & OPEN_FORK_CLOSING))
		{
			pOpenForkEntry->ofe_RefCount ++;
			pOFEntry = pOpenForkEntry;
		}

		RELEASE_SPIN_LOCK_FROM_DPC(&pOpenForkEntry->ofe_Lock);
	}

	return pOFEntry;
}


/***	AfpForkReferenceByPointer
 *
 *	Reference the Open Fork Entry. This is used by the admin APIs.
 *
 *	LOCKS:	ofe_Lock
 */
POPENFORKENTRY FASTCALL
AfpForkReferenceByPointer(
	IN	POPENFORKENTRY	pOpenForkEntry
)
{
	POPENFORKENTRY	pOFEntry = NULL;
	KIRQL			OldIrql;

	ASSERT (VALID_OPENFORKENTRY(pOpenForkEntry));

	ACQUIRE_SPIN_LOCK(&pOpenForkEntry->ofe_Lock, &OldIrql);

	if (!(pOpenForkEntry->ofe_Flags & OPEN_FORK_CLOSING))
	{
		pOpenForkEntry->ofe_RefCount ++;
		pOFEntry = pOpenForkEntry;
	}

	RELEASE_SPIN_LOCK(&pOpenForkEntry->ofe_Lock, OldIrql);

	return pOFEntry;
}


/***	AfpForkReferenceById
 *
 *	Reference the Open Fork Entry. This is used by the admin APIs.
 *
 *	LOCKS:		ofe_Lock, AfpForksLock
 *	LOCK_ORDER:	ofe_Lock after AfpForksLock
 */
POPENFORKENTRY FASTCALL
AfpForkReferenceById(
	IN	DWORD	ForkId
)
{
	POPENFORKENTRY	pOpenForkEntry;
	POPENFORKENTRY	pOFEntry = NULL;
	KIRQL			OldIrql;

	ASSERT (ForkId != 0);

	ACQUIRE_SPIN_LOCK(&AfpForksLock, &OldIrql);

	for (pOpenForkEntry = AfpOpenForksList;
		 (pOpenForkEntry != NULL) && (pOpenForkEntry->ofe_ForkId >= ForkId);
		 pOpenForkEntry = pOpenForkEntry->ofe_Next)
	{
		if (pOpenForkEntry->ofe_ForkId == ForkId)
		{
			ACQUIRE_SPIN_LOCK_AT_DPC(&pOpenForkEntry->ofe_Lock);

			if (!(pOpenForkEntry->ofe_Flags & OPEN_FORK_CLOSING))
			{
				pOFEntry = pOpenForkEntry;
				pOpenForkEntry->ofe_RefCount ++;
			}

			RELEASE_SPIN_LOCK_FROM_DPC(&pOpenForkEntry->ofe_Lock);
			break;
		}
	}

	RELEASE_SPIN_LOCK(&AfpForksLock, OldIrql);

	return pOFEntry;
}


/***	AfpForkClose
 *
 *	Close an open fork. Simply set the close flag on the open fork and update
 *	connection counts, if any.
 *
 *	LOCKS: ofd_EntryLock, cds_ConnLock
 */
VOID
AfpForkClose(
	IN	POPENFORKENTRY	pOpenForkEntry
)
{
	PCONNDESC		pConnDesc;
	PVOLDESC		pVolDesc = pOpenForkEntry->ofe_pOpenForkDesc->ofd_pVolDesc;
	KIRQL			OldIrql;
    BOOLEAN         fAlreadyClosing=FALSE;


	ASSERT(VALID_CONNDESC(pOpenForkEntry->ofe_pConnDesc));

    pConnDesc = pOpenForkEntry->ofe_pConnDesc;

	if ((pConnDesc != NULL) &&
        (AfpConnectionReferenceByPointer(pConnDesc) != NULL))
	{
		ASSERT (pConnDesc->cds_pVolDesc == pVolDesc);
		INTERLOCKED_DECREMENT_LONG(&pConnDesc->cds_cOpenForks);

		// update the disk quota for this user
		if (pVolDesc->vds_Flags & VOLUME_DISKQUOTA_ENABLED)
		{
            // reference again: afpUpdateDiskQuotaInfo will remove this refcount
			if (AfpConnectionReferenceByPointer(pConnDesc) != NULL)
			{
				afpUpdateDiskQuotaInfo(pConnDesc);
			}
		}

		AfpConnectionDereference(pConnDesc);
	}

	ACQUIRE_SPIN_LOCK(&pOpenForkEntry->ofe_Lock, &OldIrql);

    if (!(pOpenForkEntry->ofe_Flags & OPEN_FORK_CLOSING))
    {
	    pOpenForkEntry->ofe_Flags |= OPEN_FORK_CLOSING;
    }
    else
    {
        fAlreadyClosing = TRUE;
    }

	RELEASE_SPIN_LOCK(&pOpenForkEntry->ofe_Lock, OldIrql);

    if (!fAlreadyClosing)
    {
	    // Take away the creation reference
	    AfpForkDereference(pOpenForkEntry);
    }
}


/***	AfpForkDereference
 *
 *	Dereference an open fork entry. If it is marked for deletion and this is
 *	the last reference, then it is cleaned up.
 *
 *	LOCKS:		AfpForksLock (SPIN), vds_VolLock (SPIN), ofd_Lock (SPIN),
 *	LOCKS:		ofe_Lock (SPIN), AfpStatisticsLock (SPIN), sda_Lock (SPIN)
 *
 *	LOCK_ORDER: AfpStatisticsLock after ofd_Lock after vds_VolLock
 *
 */
VOID FASTCALL
AfpForkDereference(
	IN	POPENFORKENTRY	pOpenForkEntry
)
{
	POPENFORKSESS	pOpenForkSess;
	POPENFORKDESC	pOpenForkDesc;
	PVOLDESC		pVolDesc;
	PFORKLOCK		pForkLock, *ppForkLock;
	DWORD			OForkRefNum, FileNum, NumLocks;
	PSDA			pSda;
	KIRQL			OldIrql;
	BOOLEAN			Resource, LastClose = False;
	BOOLEAN			Cleanup;
	PDFENTRY		pDfEntry = NULL;
	FORKSIZE 		forklen;
	DWORD	 		Status;

	ASSERT(VALID_OPENFORKENTRY(pOpenForkEntry));

	ACQUIRE_SPIN_LOCK(&pOpenForkEntry->ofe_Lock, &OldIrql);

	pOpenForkEntry->ofe_RefCount --;

        ASSERT(pOpenForkEntry->ofe_RefCount >= 0);

	Cleanup =  (pOpenForkEntry->ofe_RefCount == 0);

	RELEASE_SPIN_LOCK(&pOpenForkEntry->ofe_Lock, OldIrql);

	if (!Cleanup)
		return;

	// Unlink this from the global list
	ACQUIRE_SPIN_LOCK(&AfpForksLock, &OldIrql);

	AfpUnlinkDouble(pOpenForkEntry, ofe_Next, ofe_Prev);
	AfpNumOpenForks --;

	RELEASE_SPIN_LOCK(&AfpForksLock, OldIrql);

	// Clean up the rest
	pOpenForkDesc = pOpenForkEntry->ofe_pOpenForkDesc;
	pVolDesc = pOpenForkDesc->ofd_pVolDesc;

	ASSERT(VALID_CONNDESC(pOpenForkEntry->ofe_pConnDesc));
	pSda = pOpenForkEntry->ofe_pSda;

	ASSERT(VALID_OPENFORKDESC(pOpenForkDesc));

	DBGPRINT(DBG_COMP_FORKS, DBG_LEVEL_INFO,
			("AfpForkDereference: Closing Fork %ld for Session %ld\n",
			pOpenForkEntry->ofe_ForkId, pSda->sda_SessionId));

	// Save OForkRefNum for clearing up the Sda entry later on
	OForkRefNum = pOpenForkEntry->ofe_OForkRefNum;
	Resource = RESCFORK(pOpenForkEntry);

	// We are not relying on
	// change notifies to update our cached DFE Fork lengths and
	// modified times from Writes and SetForkParms, so we must do it
	// ourselves at the time when the fork handle is closed by mac.
	// Note the order that the locks are taken here and for
	// FpExchangeFiles/AfpExchangeForkAfpIds to prevent a FileId stored
	// in the OpenForkDesc from changing out from under us due to
	// an FpExchangeFiles call.

	AfpSwmrAcquireExclusive(&pVolDesc->vds_ExchangeFilesLock);

	// Save file number so we can clear the ALREADY_OPEN flag in the DFEntry.
	FileNum = pOpenForkDesc->ofd_FileNumber;

	// Get rid of locks for this fork entry and reduce the use count
	// We do not actually have to unlock the ranges as the close will
	// get rid of them for us. If use count goes to zero, also unlink
	// this fork desc from the volume list.

	ACQUIRE_SPIN_LOCK(&pVolDesc->vds_VolLock, &OldIrql);
	ACQUIRE_SPIN_LOCK_AT_DPC(&pOpenForkDesc->ofd_Lock);

	pOpenForkDesc->ofd_UseCount --;

	for (NumLocks = 0, ppForkLock = &pOpenForkDesc->ofd_pForkLock;
		 (pForkLock = *ppForkLock) != NULL;
		 NOTHING)
	{
		if (pForkLock->flo_pOpenForkEntry == pOpenForkEntry)
		{
			ASSERT(pOpenForkDesc->ofd_NumLocks > 0);
			pOpenForkDesc->ofd_NumLocks --;
			ASSERT(pOpenForkEntry->ofe_cLocks > 0);
#if DBG
			pOpenForkEntry->ofe_cLocks --;
#endif
			NumLocks ++;
			*ppForkLock = pForkLock->flo_Next;
			DBGPRINT(DBG_COMP_FORKS, DBG_LEVEL_INFO,
					("AfpForkDereference: Freeing lock %lx\n", pForkLock));
			AfpIOFreeBuffer(pForkLock);
		}
		else ppForkLock = &pForkLock->flo_Next;
	}

	INTERLOCKED_ADD_ULONG_DPC(&AfpServerStatistics.stat_CurrentFileLocks,
							  (ULONG)(-(LONG)NumLocks),
							  &(AfpStatisticsLock.SpinLock));

	ASSERT (pOpenForkEntry->ofe_cLocks == 0);

	if (pOpenForkDesc->ofd_UseCount == 0)
	{
		ASSERT (pOpenForkDesc->ofd_NumLocks == 0);
		ASSERT (pOpenForkDesc->ofd_cOpenR <= FORK_OPEN_READ);
		ASSERT (pOpenForkDesc->ofd_cOpenW <= FORK_OPEN_WRITE);
		ASSERT (pOpenForkDesc->ofd_cDenyR <= FORK_DENY_READ);
		ASSERT (pOpenForkDesc->ofd_cDenyW <= FORK_DENY_WRITE);

		LastClose = True;

		// Unlink the OpenForkDesc from the Volume Descriptor
		AfpUnlinkDouble(pOpenForkDesc, ofd_Next, ofd_Prev);

		RELEASE_SPIN_LOCK_FROM_DPC(&pOpenForkDesc->ofd_Lock);
		RELEASE_SPIN_LOCK(&pVolDesc->vds_VolLock, OldIrql);

		// Free the memory for the OpenFork descriptor and path buffer
		if (pOpenForkDesc->ofd_FilePath.Length > 0)
		{
			AfpFreeMemory(pOpenForkDesc->ofd_FilePath.Buffer);
			DBGPRINT(DBG_COMP_FORKS, DBG_LEVEL_INFO,
					("AfpForkDereference: Freeing path to file %lx\n",
                    pOpenForkDesc->ofd_FilePath.Buffer));
		}

		// Dereference the volume descriptor now
		AfpVolumeDereference(pVolDesc);

		// Finally free the open fork descriptor
		AfpFreeMemory(pOpenForkDesc);
	}
	else
	{
		// Update the open & deny modes
		pOpenForkDesc->ofd_cOpenR -= (pOpenForkEntry->ofe_OpenMode & FORK_OPEN_READ);
		pOpenForkDesc->ofd_cOpenW -= (pOpenForkEntry->ofe_OpenMode & FORK_OPEN_WRITE);
		pOpenForkDesc->ofd_cDenyR -= (pOpenForkEntry->ofe_DenyMode & FORK_OPEN_READ);
		pOpenForkDesc->ofd_cDenyW -= (pOpenForkEntry->ofe_DenyMode & FORK_OPEN_WRITE);

		RELEASE_SPIN_LOCK_FROM_DPC(&pOpenForkDesc->ofd_Lock);
		RELEASE_SPIN_LOCK(&pVolDesc->vds_VolLock, OldIrql);
	}

	// Lookup the DFE entry by ID, query for the fork length and
	// for the appropriate time (LastWriteTime for DATA$ fork,
	// ChangeTime for Resource) and set the LastWriteTime
	// to last ChangeTime if its resource fork.  If its the last close
	// for this fork, since we already have the DFE pointer and hold
	// the IdDb SWMR, update the DFE_FLAGS_x_ALREADYOPEN flag.  Then
	// release the SWMR.

	AfpSwmrAcquireExclusive(&pVolDesc->vds_IdDbAccessLock);

	pDfEntry = AfpFindDfEntryById(pVolDesc,
							       FileNum,
								   DFE_FILE);

	Status = AfpIoQuerySize(&pOpenForkEntry->ofe_FileSysHandle,
							&forklen);

	if (NT_SUCCESS(Status) && (pDfEntry != NULL))
	{
        if (IS_VOLUME_NTFS(pVolDesc))
        {
		    AfpIoChangeNTModTime(&pOpenForkEntry->ofe_FileSysHandle,
								 &pDfEntry->dfe_LastModTime);
        }

		if (Resource)
		{
			pDfEntry->dfe_RescLen = forklen.LowPart;
			if (LastClose)
			{
				pDfEntry->dfe_Flags &= ~DFE_FLAGS_R_ALREADYOPEN;
#ifdef	AGE_DFES
				if (IS_VOLUME_AGING_DFES(pVolDesc))
				{
					pDfEntry->dfe_Parent->dfe_pDirEntry->de_ChildForkOpenCount --;
				}
#endif
			}
		}
		else
		{
			pDfEntry->dfe_DataLen = forklen.LowPart;
			if (LastClose)
			{
				pDfEntry->dfe_Flags &= ~DFE_FLAGS_D_ALREADYOPEN;
#ifdef	AGE_DFES
				if (IS_VOLUME_AGING_DFES(pVolDesc))
				{
					pDfEntry->dfe_Parent->dfe_pDirEntry->de_ChildForkOpenCount --;
				}
#endif
			}
		}
	}

	AfpSwmrRelease(&pVolDesc->vds_IdDbAccessLock);
	AfpSwmrRelease(&pVolDesc->vds_ExchangeFilesLock);

	// Now clear up the entry in the Sda
	ACQUIRE_SPIN_LOCK(&pSda->sda_Lock, &OldIrql);

	pSda->sda_cOpenForks--;
	pOpenForkSess = &pSda->sda_OpenForkSess;
	while (OForkRefNum > FORK_OPEN_CHUNKS)
	{
		OForkRefNum -= FORK_OPEN_CHUNKS;
		pOpenForkSess = pOpenForkSess->ofs_Link;
		ASSERT (pOpenForkSess != NULL);
	}

	ASSERT (pOpenForkEntry == pOpenForkSess->ofs_pOpenForkEntry[OForkRefNum-1]);
	pOpenForkSess->ofs_pOpenForkEntry[OForkRefNum-1] = NULL;

	RELEASE_SPIN_LOCK(&pSda->sda_Lock, OldIrql);

	AfpSdaDereferenceSession(pSda);		// Remove the reference for this fork here

    ASSERT(VALID_CONNDESC(pOpenForkEntry->ofe_pConnDesc));
    AfpConnectionDereference(pOpenForkEntry->ofe_pConnDesc);

	ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

	// All done, close the fork handle and free the OFE
	if (pOpenForkEntry->ofe_ForkHandle != NULL)
	{
		AfpIoClose(&pOpenForkEntry->ofe_FileSysHandle);
	}

	DBGPRINT(DBG_COMP_FORKS, DBG_LEVEL_INFO,
			("AfpForkDereference: Fork %ld is history\n", pOpenForkEntry->ofe_ForkId));

	AfpFreeMemory(pOpenForkEntry);
}


/***	AfpCheckDenyConflict
 *
 *	Check if the requested Open & Deny Modes clash with current open & deny modes.
 *
 *	LOCKS:			ofd_Lock, vds_VolLock (SPIN) IFF ppOpenForkDesc is NULL ELSE
 *	LOCKS_ASSUMED: vds_VolLock (SPIN)
 *
 *	LOCK_ORDER:  ofd_Lock after vds_VolLock
 */
AFPSTATUS
AfpCheckDenyConflict(
	IN	PVOLDESC				pVolDesc,
	IN	DWORD					AfpId,
	IN	BOOLEAN					Resource,
	IN	BYTE					OpenMode,
	IN	BYTE					DenyMode,
	IN	POPENFORKDESC *			ppOpenForkDesc	OPTIONAL
)
{
	KIRQL			OldIrql;
	POPENFORKDESC	pOpenForkDesc;
	AFPSTATUS		Status = AFP_ERR_NONE;
	BOOLEAN			Foundit = False;

	if (ARGUMENT_PRESENT(ppOpenForkDesc))
		 *ppOpenForkDesc = NULL;
	else ACQUIRE_SPIN_LOCK(&pVolDesc->vds_VolLock, &OldIrql);

	// check the list of open forks in this volume for any deny conflicts
	for (pOpenForkDesc = pVolDesc->vds_pOpenForkDesc;
		 pOpenForkDesc != NULL;
		 pOpenForkDesc = pOpenForkDesc->ofd_Next)
	{
		BOOLEAN	DescRes;

		// Take the DescLock before looking at AfpId since FpExchangeFiles
		// can change the ID
		ACQUIRE_SPIN_LOCK_AT_DPC(&pOpenForkDesc->ofd_Lock);

		DescRes = (pOpenForkDesc->ofd_Flags & OPEN_FORK_RESOURCE) ? True : False;
		if ((pOpenForkDesc->ofd_FileNumber == AfpId) &&
			!(DescRes ^ Resource))
		{
			Foundit = True;
			// Check that the open & deny modes do not clash with existing
			// settings
			if (((OpenMode & FORK_OPEN_READ)  && (pOpenForkDesc->ofd_cDenyR > 0)) ||
				((OpenMode & FORK_OPEN_WRITE) && (pOpenForkDesc->ofd_cDenyW > 0)) ||
				((DenyMode & FORK_DENY_READ)  && (pOpenForkDesc->ofd_cOpenR > 0)) ||
				((DenyMode & FORK_DENY_WRITE) && (pOpenForkDesc->ofd_cOpenW > 0)))
			{
				Status = AFP_ERR_DENY_CONFLICT;
			}
		}

		RELEASE_SPIN_LOCK_FROM_DPC(&pOpenForkDesc->ofd_Lock);
		if (Foundit)
		{
			break;
        }
	}

	if (ARGUMENT_PRESENT(ppOpenForkDesc))
		 *ppOpenForkDesc = pOpenForkDesc;
	else RELEASE_SPIN_LOCK(&pVolDesc->vds_VolLock, OldIrql);

	return Status;
}


/***	AfpForkOpen
 *
 *	This is called after the fork has been successfully opened. Deny-mode conflicts are
 *	checked and if no conflicts are found, appropriate data structures are created and
 *	linked. If a deny conflict results, return NULL for pOpenForkEntry.
 *
 *	LOCKS:			AfpForksLock (SPIN), vds_VolLock (SPIN), cds_VolLock (SPIN), ofd_Lock (SPIN), ofe_Lock (SPIN)
 *	LOCK_ORDER:		vds_ExchangeFilesLock, then ofd_Lock after vds_VolLock
 *  LOCKS_ASSUMED:	vds_ExchangeFilesLock
 */
AFPSTATUS
AfpForkOpen(
	IN	PSDA				pSda,
	IN	PCONNDESC			pConnDesc,
	IN	PPATHMAPENTITY		pPME,
	IN	PFILEDIRPARM		pFDParm,
	IN	DWORD				AccessMode,
	IN	BOOLEAN				Resource,
	OUT	POPENFORKENTRY *	ppOpenForkEntry,
	OUT	PBOOLEAN			pCleanupExchgLock
)
{

	POPENFORKENTRY	pOpenForkEntry;
	POPENFORKDESC	pOpenForkDesc;
	PVOLDESC		pVolDesc;
	AFPSTATUS		Status = AFP_ERR_NONE;
	KIRQL			OldIrql;
	BYTE			OpenMode, DenyMode;
	BOOLEAN			NewForkDesc = False;

	ASSERT(VALID_CONNDESC(pConnDesc));

	pVolDesc = pConnDesc->cds_pVolDesc;

	ASSERT(VALID_VOLDESC(pVolDesc));

	OpenMode = (BYTE)(AccessMode & FORK_OPEN_MASK);
	DenyMode = (BYTE)((AccessMode >> FORK_DENY_SHIFT) & FORK_DENY_MASK);
	*ppOpenForkEntry = NULL;

	if ((pOpenForkEntry = (POPENFORKENTRY)AfpAllocZeroedNonPagedMemory(sizeof(OPENFORKENTRY))) == NULL)
		return AFP_ERR_MISC;

	ACQUIRE_SPIN_LOCK(&pVolDesc->vds_VolLock, &OldIrql);

	Status = AfpCheckDenyConflict(pVolDesc,
								  pFDParm->_fdp_AfpId,
								  Resource,
								  OpenMode,
								  DenyMode,
								  &pOpenForkDesc);

	if (pOpenForkDesc == NULL)
	{
		// This fork has not been opened. We can party.
		if ((pOpenForkDesc = (POPENFORKDESC)AfpAllocZeroedNonPagedMemory(sizeof(OPENFORKDESC))) == NULL)
			Status = AFP_ERR_MISC;
		else
		{
			NewForkDesc = True;
			INITIALIZE_SPIN_LOCK(&pOpenForkDesc->ofd_Lock);
#if DBG
			pOpenForkDesc->Signature = OPENFORKDESC_SIGNATURE;
#endif
			pOpenForkDesc->ofd_pVolDesc = pVolDesc;

			pOpenForkDesc->ofd_FileNumber = pFDParm->_fdp_AfpId;
			pOpenForkDesc->ofd_Flags = Resource ?
								OPEN_FORK_RESOURCE : OPEN_FORK_DATA;
		}
	}

	if ((pOpenForkDesc != NULL) && (Status == AFP_ERR_NONE))
	{
		// A lock is not needed if this is a new fork desc
		if (!NewForkDesc)
		{
			ACQUIRE_SPIN_LOCK_AT_DPC(&pOpenForkDesc->ofd_Lock);
		}

		pOpenForkDesc->ofd_UseCount ++;
		pOpenForkDesc->ofd_cOpenR += (OpenMode & FORK_OPEN_READ);
		pOpenForkDesc->ofd_cOpenW += (OpenMode & FORK_OPEN_WRITE);
		pOpenForkDesc->ofd_cDenyR += (DenyMode & FORK_DENY_READ);
		pOpenForkDesc->ofd_cDenyW += (DenyMode & FORK_DENY_WRITE);

		if (NewForkDesc)
		{
			// Now link this into the volume descriptor but only if it is a
			// new forkdesc. Explicitly reference the volume descriptor. We
			// cannot call AfpVolumeReference here since we already own the
			// volume lock Moreover since the connection is owning it, the
			// volume is OK. Initialize the volume relative path of the file
			// being opened from the PME.
            pOpenForkDesc->ofd_FilePath = pPME->pme_FullPath;
            pOpenForkDesc->ofd_FileName = pPME->pme_UTail;

			// Set the pme_FullPath to NULL so that it does not get freed up
            pPME->pme_FullPath.Buffer = NULL;

			DBGPRINT(DBG_COMP_FORKS, DBG_LEVEL_INFO,
					("AfpForksOpen: Initializing forkdesc with path %Z(%lx), name %Z(%lx)\n",
					&pOpenForkDesc->ofd_FilePath, pOpenForkDesc->ofd_FilePath.Buffer,
					&pOpenForkDesc->ofd_FileName, pOpenForkDesc->ofd_FileName.Buffer));

			pVolDesc->vds_RefCount ++;
			AfpLinkDoubleAtHead(pVolDesc->vds_pOpenForkDesc,
								pOpenForkDesc,
								ofd_Next,
								ofd_Prev);
		}
		else
		{
			RELEASE_SPIN_LOCK_FROM_DPC(&pOpenForkDesc->ofd_Lock);
		}
	}

	RELEASE_SPIN_LOCK(&pVolDesc->vds_VolLock, OldIrql);

	if ((pOpenForkDesc == NULL) || (Status != AFP_ERR_NONE))
	{
		AfpFreeMemory(pOpenForkEntry);
		return Status;
	}

	ASSERT (Status == AFP_ERR_NONE);

	// All seems to be fine, so far. We'll go ahead and create the appropriate
	// data structures and link them in. In case of errors we'll back out.
	do
	{
#if DBG
		pOpenForkEntry->Signature = OPENFORKENTRY_SIGNATURE;
#endif
		INITIALIZE_SPIN_LOCK(&pOpenForkEntry->ofe_Lock);
        pOpenForkEntry->ofe_pSda = pSda;

        if (AfpConnectionReferenceByPointer(pConnDesc) == NULL)
        {
	        DBGPRINT(DBG_COMP_FORKS, DBG_LEVEL_ERR,
                ("AfpForkOpen: couldn't reference pConnDesc\n"));
		    AfpFreeMemory(pOpenForkEntry);
			return AFP_ERR_MISC;
        }
		pOpenForkEntry->ofe_pConnDesc = pConnDesc;
		pOpenForkEntry->ofe_pOpenForkDesc = pOpenForkDesc;
		pOpenForkEntry->ofe_OpenMode = OpenMode;
		pOpenForkEntry->ofe_DenyMode = DenyMode;
		pOpenForkEntry->ofe_FileSysHandle = pPME->pme_Handle;
		pOpenForkEntry->ofe_Flags = Resource ?
										OPEN_FORK_RESOURCE : OPEN_FORK_DATA;
		// One reference for creation and the other for the api to dereference.
		pOpenForkEntry->ofe_RefCount = 2;
		if (!afpForkGetNewForkRefNumAndLinkInSda(pSda, pOpenForkEntry))
        {
		    AfpFreeMemory(pOpenForkEntry);
            AfpConnectionDereference(pConnDesc);
	            DBGPRINT(DBG_COMP_FORKS, DBG_LEVEL_ERR,("AfpForkOpen: ...LinkInSda failed\n"));
			return AFP_ERR_MISC;
        }

		// Now link this in global list
		ACQUIRE_SPIN_LOCK(&AfpForksLock, &OldIrql);

        ACQUIRE_SPIN_LOCK_AT_DPC(&pSda->sda_Lock);
        pSda->sda_cOpenForks++;
        RELEASE_SPIN_LOCK_FROM_DPC(&pSda->sda_Lock);

		pOpenForkEntry->ofe_ForkId = afpNextForkId ++;
		AfpLinkDoubleAtHead(AfpOpenForksList,
							pOpenForkEntry,
							ofe_Next,
							ofe_Prev);
		AfpNumOpenForks ++;

		RELEASE_SPIN_LOCK(&AfpForksLock, OldIrql);

		if (NewForkDesc)
		{
			ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

			if ((Status = AfpSetDFFileFlags(pVolDesc,
											pFDParm->_fdp_AfpId,
											Resource ?
												DFE_FLAGS_R_ALREADYOPEN :
												DFE_FLAGS_D_ALREADYOPEN,
											False,
											False)) != AFP_ERR_NONE)
			{
				break;
			}
		}

		if (NT_SUCCESS(Status))
		{
			*ppOpenForkEntry = pOpenForkEntry;
			Status = AFP_ERR_NONE;
		}
		else
		{
			Status = AfpIoConvertNTStatusToAfpStatus(Status);
		}
	} while (False);

	// Perform cleanup here, if we failed for any reason
	if (Status != AFP_ERR_NONE)
	{
		ASSERT (pOpenForkEntry != NULL);
		ACQUIRE_SPIN_LOCK(&pOpenForkEntry->ofe_Lock, &OldIrql);

		pOpenForkEntry->ofe_Flags |= OPEN_FORK_CLOSING;

		RELEASE_SPIN_LOCK(&pOpenForkEntry->ofe_Lock, OldIrql);

		// We must free this lock on behalf of AfpFspDispOpenFork because
		// the act of dereferencing it will end up calling ForkClose which
		// also must take this lock.  Indicate to caller that he should not
		// attempt to release this lock again.
		AfpSwmrRelease(&pVolDesc->vds_ExchangeFilesLock);
		*pCleanupExchgLock = False;

        // remove the refcount for the api (which won't see this pOpenForkEntry)
		AfpForkDereference(pOpenForkEntry);

        // remove the creation refcount
		AfpForkDereference(pOpenForkEntry);
                
        //
        //  Dereferencing the open fork entry will close the handle passed
        //  to us.  NULL out the callers handle value so the caller does
        //  not try to close it again.
        //

        pPME->pme_Handle.fsh_FileHandle = NULL;
	}

	return Status;
}


/***	AfpForkLockOperation
 *
 *	Called for both ByteRangeLock/Unlock as well as Read/Write.
 *	For Lock, a check is made to ensure the requested range does not
 *	overlap an existing range FROM ANY OPEN FORK.
 *	For Unlock, the requested range MUST MATCH exactly with an existing
 *	locked range.
 *	For IO, return the effective range where IO is possible - could be
 *	potentially be an empty range. Note in this case that the start of
 *	the range must be free to get a non-empty range. For an empty range
 *	AFP_ERR_LOCK is returned. For a non-empty range AFP_ERR_NONE.
 *
 *	Locks are maintained in a sorted (descending) order from the OpenForkDesc.
 *	The search can be abandoned if the start of the requested range is
 *	larger than the end of the encountered range.
 *
 *	LOCKS:	ofd_Lock (SPIN)
 */
AFPSTATUS
AfpForkLockOperation(
	IN		PSDA			pSda,
	IN		POPENFORKENTRY	pOpenForkEntry,
	IN OUT	PFORKOFFST		pOffset,
	IN OUT	PFORKSIZE       pSize,
	IN		LOCKOP			Operation,	// LOCK, UNLOCK or IOCHECK
	IN		BOOLEAN			EndFlag		// If True range is from end, else start
)
{
	POPENFORKDESC		pOpenForkDesc;
	PFORKLOCK			pForkLock, pForkLockNew, *ppForkLock;
	IO_STATUS_BLOCK		IoStsBlk;
	PFAST_IO_DISPATCH	pFastIoDisp;
	KIRQL				OldIrql;
	AFPSTATUS			Status;
	LONG				Offset, Size;
	DWORD				EndOff;
	BOOLEAN				UnlockForkDesc = True;

	DBGPRINT(DBG_COMP_FORKS, DBG_LEVEL_INFO,
			("AfpForkLockOperation: (%s) - (%ld,%ld,%ld,%ld)\n",
			(Operation == LOCK) ? "Lock" : ((Operation == UNLOCK) ? "Unlock" : "Io"),
			pOffset->LowPart, pSize->LowPart,
			pOpenForkEntry->ofe_ForkId, pSda->sda_SessionId));

	if (EndFlag)
	{
		LONG	Off;

		Size = pSize->LowPart;
		if (pSize->QuadPart < 0)
		{
			FORKSIZE	FSize;

			FSize.QuadPart = -(pSize->QuadPart);
			Size = -(LONG)(FSize.LowPart);
		}
		Off = pOffset->LowPart;
		if (pOffset->QuadPart < 0)
		{
			FORKSIZE	FOffset;

			FOffset.QuadPart = -(pOffset->QuadPart);
			Off = -(LONG)(FOffset.LowPart);
		}

		if ((Status = afpForkConvertToAbsOffSize(pOpenForkEntry,
												 Off,
												 &Size,
												 pOffset)) != AFP_ERR_NONE)
			return Status;
		pSize->QuadPart = Size;

		DBGPRINT(DBG_COMP_FORKS, DBG_LEVEL_INFO,
				("AfpForkLockOperation: Effective (%s) - (%ld,%ld,%ld,%ld)\n",
				(Operation == LOCK) ? "Lock" : ((Operation == UNLOCK) ? "Unlock" : "Io"),
				pOffset->LowPart, Size,
				pOpenForkEntry->ofe_ForkId,
				pSda->sda_SessionId));
	}

	Offset = pOffset->LowPart;
	Size = pSize->LowPart;

	// Walk down the list and check. If the option is to lock, then no locks
	// should conflict. If the option is to unlock, then the lock should
	// exist and owned. If the option is to check for Io, then either the
	// overlapped range be 'owned' or the start of the range must not overap
	// OPTIMIZATION - if there is only one instance of this fork open, then
	// all locks belong to this fork and hence there can be no conflicts.
	pOpenForkDesc = pOpenForkEntry->ofe_pOpenForkDesc;

	ASSERT (pOpenForkDesc->ofd_UseCount > 0);

	if ((Operation == IOCHECK) &&
		(pOpenForkDesc->ofd_UseCount == 1))
	{
		DBGPRINT(DBG_COMP_FORKS, DBG_LEVEL_INFO,
				("AfpForkLockOperation: Skipping for IOCHECK - UseCount %ld ,Locks %ld\n",
				pOpenForkDesc->ofd_UseCount, pOpenForkDesc->ofd_NumLocks));
		return AFP_ERR_NONE;
	}

	// Set default error code.
	Status = (Operation == UNLOCK) ? AFP_ERR_RANGE_NOT_LOCKED : AFP_ERR_NONE;

	EndOff = (DWORD)Offset + (DWORD)Size - 1;

	ACQUIRE_SPIN_LOCK(&pOpenForkDesc->ofd_Lock, &OldIrql);

	for (ppForkLock = &pOpenForkDesc->ofd_pForkLock;
		 (pForkLock = *ppForkLock) != NULL;
		 ppForkLock = &pForkLock->flo_Next)
	{
		DWORD	LEndOff;

		// There are 4 possible ways locks can overlap
		//
		//		1					2
		//	+-----------+		+-----------+
		//	|			|		|			|
		//			|				|
		//			+-- LockRange --+
		//			|				|
		//				|	3	|
		//				+-------+
		//		|			4			|
		//		+-----------------------+

		DBGPRINT(DBG_COMP_FORKS, DBG_LEVEL_INFO,
				("AfpForkLockOperation: (%s) - Found (%ld,%ld,%ld,%ld)\n",
				(Operation == LOCK) ? "Lock" : ((Operation == UNLOCK) ? "Unlock" : "Io"),
				pForkLock->flo_Offset, pForkLock->flo_Size,
				pForkLock->flo_pOpenForkEntry->ofe_ForkId,
				pForkLock->flo_Key));

		// Calculate the end point of the current locked range
		LEndOff = (DWORD)(pForkLock->flo_Offset) + (DWORD)(pForkLock->flo_Size) - 1;

		// The list is ordered by descending flo_Offset. We can stop scanning
		// if the start of the requested range is more than the end of the
		// current locked range.
		if ((DWORD)Offset > LEndOff)
		{
			DBGPRINT(DBG_COMP_FORKS, DBG_LEVEL_INFO,
					("AfpForkLockOperation: %s Request (%ld, %ld) - Current (%ld,%ld), %s\n",
					(Operation == LOCK) ? "Lock" : ((Operation == UNLOCK) ? "Unlock" : "Io"),
					Offset, Size, pForkLock->flo_Offset, pForkLock->flo_Size,
					(Operation == UNLOCK) ?  "failing" : "success"));
			break;
		}

		// The end of the requested range is beyond the locked range ?
		// continue scanning.
		if (EndOff < (DWORD)(pForkLock->flo_Offset))
		{
			DBGPRINT(DBG_COMP_FORKS, DBG_LEVEL_INFO,
					("AfpForkLockOperation: %s Request (%ld, %ld) - Current (%ld,%ld), skipping\n",
					(Operation == LOCK) ? "Lock" : ((Operation == UNLOCK) ? "Unlock" : "Io"),
					Offset, Size, pForkLock->flo_Offset,
					pForkLock->flo_Size,
					(Operation == UNLOCK) ?  "failing" : "success"));
			continue;
		}

		// We have either a match or an overlap.
		if (Operation == LOCK)
		{
			// For a lock request it is a failure.
			DBGPRINT(DBG_COMP_FORKS, DBG_LEVEL_WARN,
					("AfpForkLockOperation: Lock Request (%ld, %ld) - Current (%ld,%ld), failing\n",
					Offset, Size, pForkLock->flo_Offset, pForkLock->flo_Size));
			Status = (pForkLock->flo_pOpenForkEntry == pOpenForkEntry) ?
							  AFP_ERR_RANGE_OVERLAP : AFP_ERR_LOCK;
		}
		else if (Operation == UNLOCK)
		{
			// For an unlock request, we must have an exact match. Also the session key
			// and the OpenForkEntry must match
			if ((Offset == pForkLock->flo_Offset) &&
				(Size == pForkLock->flo_Size) &&
				(pForkLock->flo_Key == pSda->sda_SessionId) &&
				(pForkLock->flo_pOpenForkEntry == pOpenForkEntry))
			{
				// Unlink this lock from the list
				*ppForkLock = pForkLock->flo_Next;
				pOpenForkDesc->ofd_NumLocks --;
				pOpenForkEntry->ofe_cLocks --;
				RELEASE_SPIN_LOCK(&pOpenForkDesc->ofd_Lock, OldIrql);
                UnlockForkDesc = False;
				DBGPRINT(DBG_COMP_FORKS, DBG_LEVEL_INFO,
						("AfpForkLockOperation: (Unlock) Deleting Range,Key (%ld,%ld,%ld,%ld)\n",
						Offset, Size, pOpenForkEntry->ofe_ForkId, pSda->sda_SessionId));

				// Try the fast I/O path first.  If that fails, call AfpIoForkUnlock
				// to use the normal build-an-IRP path.
				pFastIoDisp = pOpenForkEntry->ofe_pDeviceObject->DriverObject->FastIoDispatch;
				if ((pFastIoDisp != NULL) &&
					(pFastIoDisp->FastIoUnlockSingle != NULL) &&
					pFastIoDisp->FastIoUnlockSingle(AfpGetRealFileObject(pOpenForkEntry->ofe_pFileObject),
											pOffset,
											pSize,
											AfpProcessObject,
											pSda->sda_SessionId,
											&IoStsBlk,
											pOpenForkEntry->ofe_pDeviceObject))
				{
					DBGPRINT(DBG_COMP_AFPAPI_FORK, DBG_LEVEL_INFO,
							("AfpForkLockOperation: Fast Unlock Succeeded\n"));
#ifdef			PROFILING
					// The fast I/O path worked. Update profile
					INTERLOCKED_INCREMENT_LONG((PLONG)(&AfpServerProfile->perf_NumFastIoSucceeded));
#endif  		
					INTERLOCKED_ADD_ULONG(&AfpServerStatistics.stat_CurrentFileLocks,
										  (ULONG)-1,
										  &AfpStatisticsLock);
					Status = AFP_ERR_NONE;
				}
				else
				{
#ifdef	PROFILING
					INTERLOCKED_INCREMENT_LONG((PLONG)(&AfpServerProfile->perf_NumFastIoFailed));
#endif
					Status = AfpIoForkLockUnlock(pSda, pForkLock, pOffset, pSize, FUNC_UNLOCK);
				}
				AfpIOFreeBuffer(pForkLock);
			}
			else
			{
				DBGPRINT(DBG_COMP_FORKS, DBG_LEVEL_WARN,
						("AfpForkLockOperation: UnLock Request (%ld, %ld) - Current (%ld,%ld), failing\n",
						Offset, Size, pForkLock->flo_Offset, pForkLock->flo_Size));
			}
		}
		else
		{
			ASSERT (Operation == IOCHECK);

			// Check if this is a conflict
			if (pForkLock->flo_Key != pSda->sda_SessionId)
			{
				if ((Offset < pForkLock->flo_Offset) &&
					(EndOff >= (DWORD)(pForkLock->flo_Offset)))
				{
					pSize->LowPart = (pForkLock->flo_Offset - Offset);
				}
				else Status =  AFP_ERR_LOCK;
				DBGPRINT(DBG_COMP_FORKS, DBG_LEVEL_INFO,
						("AfpForkLockOperation: Conflict found\n"));
			}
			else
			{
				DBGPRINT(DBG_COMP_FORKS, DBG_LEVEL_INFO,
						("AfpForkLockOperation: Our own lock found, ignoring\n"));
			}
		}
		break;
	}

	// We have the right status code. Do the needful
	if (Operation == LOCK)
	{
		if (Status == AFP_ERR_NONE)
		{
			Status = AFP_ERR_MISC;
			// Allocate the locks out of the pool.
			if ((pForkLockNew = (PFORKLOCK)AfpIOAllocBuffer(sizeof(FORKLOCK))) != NULL)
			{
#if DBG
				pForkLockNew->Signature = FORKLOCK_SIGNATURE;
#endif
				// Link this in such that the list is sorted in ascending order.
				// ppForkLock points to the place where the new lock will be
				// added, pForkLock is the next in the list.
				pForkLockNew->flo_Next = pForkLock;
				*ppForkLock = pForkLockNew;

				pForkLockNew->flo_Key = pSda->sda_SessionId;
				pForkLockNew->flo_pOpenForkEntry = pOpenForkEntry;
				pForkLockNew->flo_Offset = Offset;
				pForkLockNew->flo_Size = Size;
				pOpenForkDesc->ofd_NumLocks ++;
				pOpenForkEntry->ofe_cLocks ++;
				RELEASE_SPIN_LOCK(&pOpenForkDesc->ofd_Lock, OldIrql);
                UnlockForkDesc = False;

				DBGPRINT(DBG_COMP_FORKS, DBG_LEVEL_INFO,
						("AfpForkLockOperation: Adding Range,Key (%ld,%ld,%ld,%ld)\n",
						Offset, Size,
						pOpenForkEntry->ofe_ForkId, pSda->sda_SessionId));

				// Try the fast I/O path first.  If that fails, fall through to the
				// normal build-an-IRP path.
				pFastIoDisp = pOpenForkEntry->ofe_pDeviceObject->DriverObject->FastIoDispatch;
				if ((pFastIoDisp != NULL) &&
					(pFastIoDisp->FastIoLock != NULL) &&
					pFastIoDisp->FastIoLock(AfpGetRealFileObject(pOpenForkEntry->ofe_pFileObject),
											pOffset,
											pSize,
											AfpProcessObject,
											pSda->sda_SessionId,
											True,		// Fail immediately
											True,		// Exclusive
											&IoStsBlk,
											pOpenForkEntry->ofe_pDeviceObject))
				{
					if (NT_SUCCESS(IoStsBlk.Status) ||
						(IoStsBlk.Status == STATUS_LOCK_NOT_GRANTED))
					{
						DBGPRINT(DBG_COMP_AFPAPI_FORK, DBG_LEVEL_INFO,
								("AfpIoForkLock: Fast Lock Succeeded\n"));
		
#ifdef	PROFILING
						// The fast I/O path worked. Update profile
						INTERLOCKED_INCREMENT_LONG((PLONG)(&AfpServerProfile->perf_NumFastIoSucceeded));
#endif
						if (IoStsBlk.Status == STATUS_LOCK_NOT_GRANTED)
						{
							Status = AFP_ERR_LOCK;
						}
						else
						{
							Status = AFP_ERR_NONE;
							INTERLOCKED_ADD_ULONG(&AfpServerStatistics.stat_CurrentFileLocks,
												  1,
												  &AfpStatisticsLock);
						}
					}
				}
				else
				{
#ifdef	PROFILING
					INTERLOCKED_INCREMENT_LONG((PLONG)(&AfpServerProfile->perf_NumFastIoFailed));
#endif

					Status = AfpIoForkLockUnlock(pSda, pForkLockNew, pOffset, pSize, FUNC_LOCK);
				}

				if ((Status != AFP_ERR_NONE) &&
					(Status != AFP_ERR_EXTENDED) &&
					(Status != AFP_ERR_QUEUE))
				{
					// Undo the above work
					DBGPRINT(DBG_COMP_FORKS, DBG_LEVEL_ERR,
							("AfpForkLockOperation: AfpIoForkLock failed %lx, aborting for range %ld,%ld\n",
							Status, Offset, EndOff));
					AfpForkLockUnlink(pForkLockNew);
				}
			}
		}
	}
	if (UnlockForkDesc)
		RELEASE_SPIN_LOCK(&pOpenForkDesc->ofd_Lock, OldIrql);

	return Status;
}


/***	AfpForkLockUnlink
 *
 *	Unlink this lock from its open file descriptor and free it.
 */
VOID
AfpForkLockUnlink(
	IN	PFORKLOCK		pForkLock
)
{
	POPENFORKDESC	pOpenForkDesc = pForkLock->flo_pOpenForkEntry->ofe_pOpenForkDesc;
	PFORKLOCK *		ppForkLock;
	PFORKLOCK 		pTmpForkLock;
	KIRQL			OldIrql;

	ACQUIRE_SPIN_LOCK(&pOpenForkDesc->ofd_Lock, &OldIrql);

	pOpenForkDesc->ofd_NumLocks --;
	pForkLock->flo_pOpenForkEntry->ofe_cLocks --;
	
	for (ppForkLock = &pOpenForkDesc->ofd_pForkLock;
		 (pTmpForkLock = *ppForkLock) != NULL;
		 ppForkLock = &pTmpForkLock->flo_Next)
	{
		if (*ppForkLock == pForkLock)
		{
			*ppForkLock = pForkLock->flo_Next;
			break;
		}
	}
	RELEASE_SPIN_LOCK(&pOpenForkDesc->ofd_Lock, OldIrql);
	AfpIOFreeBuffer(pForkLock);
}


/***	afpForkConvertToAbsOffSize
 *
 *	Convert the offset,size pair as supplied by the client to their absolute
 *	values.
 */
LOCAL	AFPSTATUS
afpForkConvertToAbsOffSize(
	IN	POPENFORKENTRY	pOpenForkEntry,
	IN	LONG			Offset,
	IN OUT	PLONG		pSize,
	OUT	PFORKOFFST		pAbsOffset
)
{
	AFPSTATUS	Status;

	PAGED_CODE ();

	ASSERT (KeGetCurrentIrql() < DISPATCH_LEVEL);

	DBGPRINT(DBG_COMP_FORKS, DBG_LEVEL_INFO,
		("afpForkConvertToAbsOffSize: Converting %ld, %ld\n", Offset, *pSize));

	// We are relative to the end, then convert it to absolute
	if ((Status = AfpIoQuerySize(&pOpenForkEntry->ofe_FileSysHandle,
								 pAbsOffset)) == AFP_ERR_NONE)
	{
		FORKOFFST	EndRange, MaxOffset;

		MaxOffset.QuadPart = Offset;
		pAbsOffset->QuadPart += MaxOffset.QuadPart;
		MaxOffset.QuadPart = MAXLONG;

		// Now we have the *pAbsOffset and Size. Normalize the size.
		// if the *pAbsOffset is > MAXLONG, refuse this.
		if ((pAbsOffset->QuadPart > MaxOffset.QuadPart) ||
			(pAbsOffset->QuadPart < 0))
			Status = AFP_ERR_PARAM;

		else
		{
			EndRange.QuadPart = pAbsOffset->QuadPart + *pSize;
			if (EndRange.QuadPart >= MaxOffset.QuadPart)
				*pSize = (MAXLONG - pAbsOffset->LowPart);

			DBGPRINT(DBG_COMP_FORKS, DBG_LEVEL_INFO,
					("afpForkConvertToAbsOffSize: Converted to %ld, %ld\n",
					pAbsOffset->LowPart, *pSize));
            Status = AFP_ERR_NONE;
		}
	}

	return Status;
}


/***	AfpAdmWForkClose
 *
 *	Close a fork forcibly. This is an admin operation and must be queued
 *	up since this can potentially cause filesystem operations that are valid
 *	only in the system process context.
 */
AFPSTATUS
AfpAdmWForkClose(
	IN	OUT	PVOID	InBuf		OPTIONAL,
	IN	LONG		OutBufLen	OPTIONAL,
	OUT	PVOID		OutBuf		OPTIONAL
)
{
	PAFP_FILE_INFO	pFileInfo = (PAFP_FILE_INFO)InBuf;
	POPENFORKENTRY	pOpenForkEntry;
	DWORD			ForkId;
	AFPSTATUS		Status = AFPERR_InvalidId;

	if ((ForkId = pFileInfo->afpfile_id) != 0)
	{
		if ((pOpenForkEntry = AfpForkReferenceById(ForkId)) != NULL)
		{
			AfpForkClose(pOpenForkEntry);

			AfpForkDereference(pOpenForkEntry);

			Status = AFP_ERR_NONE;
		}
	}
	else
	{
		BOOLEAN			Shoot;
		DWORD			ForkId = MAXULONG;
		KIRQL			OldIrql;

		Status = AFP_ERR_NONE;
		while (True)
		{
			ACQUIRE_SPIN_LOCK(&AfpForksLock, &OldIrql);

			for (pOpenForkEntry = AfpOpenForksList;
				 pOpenForkEntry != NULL;
				 pOpenForkEntry = pOpenForkEntry->ofe_Next)
			{
				if (pOpenForkEntry->ofe_ForkId > ForkId)
					continue;

				ForkId = pOpenForkEntry->ofe_ForkId;

				Shoot = False;

				ACQUIRE_SPIN_LOCK_AT_DPC(&pOpenForkEntry->ofe_Lock);

				if (!(pOpenForkEntry->ofe_Flags & OPEN_FORK_CLOSING))
				{
					pOpenForkEntry->ofe_RefCount ++;
					Shoot = True;
				}

				RELEASE_SPIN_LOCK_FROM_DPC(&pOpenForkEntry->ofe_Lock);

				if (Shoot)
				{
					RELEASE_SPIN_LOCK(&AfpForksLock, OldIrql);

					AfpForkClose(pOpenForkEntry);

					AfpForkDereference(pOpenForkEntry);

					break;
				}
			}
			if (pOpenForkEntry == NULL)
			{
				RELEASE_SPIN_LOCK(&AfpForksLock, OldIrql);
				break;
			}
		}
	}
	return Status;
}


/***	afpForkGetNewForkRefNumAndLinkInSda
 *
 *	Assign a new OForkRefNum to a fork that is being opened. The smallest one
 *	is always allocated. Make the right entry in the SDA point to the
 *	OpenForkEntry.
 *
 *	LOCKS: sda_Lock (SPIN)
 */
LOCAL BOOLEAN
afpForkGetNewForkRefNumAndLinkInSda(
	IN	PSDA			pSda,
	IN	POPENFORKENTRY	pOpenForkEntry
)
{
	POPENFORKSESS	pOpenForkSess;
	KIRQL			OldIrql;
	USHORT			i;
	USHORT			OForkRefNum = 1;
	BOOLEAN			Found = False;

	ACQUIRE_SPIN_LOCK(&pSda->sda_Lock, &OldIrql);

	pOpenForkSess = &pSda->sda_OpenForkSess;
	pOpenForkEntry->ofe_OForkRefNum = 0;
	while (!Found)
	{
		for (i = 0; i < FORK_OPEN_CHUNKS; i++, OForkRefNum++)
		{
			if (pOpenForkSess->ofs_pOpenForkEntry[i] == NULL)
			{
				pOpenForkSess->ofs_pOpenForkEntry[i] = pOpenForkEntry;
				pOpenForkEntry->ofe_OForkRefNum = OForkRefNum;
				Found = True;
				break;
			}
		}
		if (!Found)
		{
			if (pOpenForkSess->ofs_Link != NULL)
			{
				pOpenForkSess = pOpenForkSess->ofs_Link;
				continue;
			}
			if ((pOpenForkSess->ofs_Link = (POPENFORKSESS)AfpAllocZeroedNonPagedMemory(sizeof(OPENFORKSESS))) != NULL)
			{
				pOpenForkSess->ofs_Link->ofs_pOpenForkEntry[0] = pOpenForkEntry;
				pOpenForkEntry->ofe_OForkRefNum = OForkRefNum;
				Found = True;
			}
			break;
		}
	}

	if (Found)
	{
		// Reference sda for this fork and up the MaxOForkRefNum, if needed
		pSda->sda_RefCount ++;
		if (OForkRefNum > pSda->sda_MaxOForkRefNum)
	        pSda->sda_MaxOForkRefNum = OForkRefNum;
	}

	RELEASE_SPIN_LOCK(&pSda->sda_Lock, OldIrql);
	return Found;
}

/***	AfpExchangeForkAfpIds
 *
 *	When an FpExchangeFiles occurs, if the data or resource fork of either
 *  of the 2 files being exchanged is open, we must fix up the AfpId kept
 *  in the OpenForkDesc structure.  This is because when the final close
 *  is done on the fork, the cleanup code must clear the DFE_X_ALREADYOPEN
 *  flag in the corresponding DFEntry of the Idindex database.
 *
 *	LOCKS:			ofd_Lock (SPIN), vds_VolLock (SPIN)
 *  LOCK_ORDER: 	ofd_Lock after vds_VolLock
 *  LOCKS_ASSUMED:	vds_IdDbAccessLock (SWMR, Exclusive)
 */
VOID
AfpExchangeForkAfpIds(
	IN	PVOLDESC	pVolDesc,
	IN	DWORD		AfpId1,
	IN	DWORD		AfpId2
)
{
	KIRQL			OldIrql;
	POPENFORKDESC	pOpenForkDesc;
	AFPSTATUS		Status = AFP_ERR_NONE;

	ACQUIRE_SPIN_LOCK(&pVolDesc->vds_VolLock, &OldIrql);

	// check the list of open forks in this volume for the IDs specified
	for (pOpenForkDesc = pVolDesc->vds_pOpenForkDesc;
		 pOpenForkDesc != NULL;
		 pOpenForkDesc = pOpenForkDesc->ofd_Next)
	{
		ACQUIRE_SPIN_LOCK_AT_DPC(&pOpenForkDesc->ofd_Lock);
		if (pOpenForkDesc->ofd_FileNumber == AfpId1)
		{
			pOpenForkDesc->ofd_FileNumber = AfpId2;
		}
		else if (pOpenForkDesc->ofd_FileNumber == AfpId2)
		{
			pOpenForkDesc->ofd_FileNumber = AfpId1;
		}

		RELEASE_SPIN_LOCK_FROM_DPC(&pOpenForkDesc->ofd_Lock);

	}

	RELEASE_SPIN_LOCK(&pVolDesc->vds_VolLock, OldIrql);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\server\fsd_dtp.c ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	fsd_dtp.c

Abstract:

	This module contains the entry points for the AFP desktop APIs. The API
	dispatcher calls these. These are all callable from FSD. All of the APIs
	complete in the DPC context. The ones which are completed in the FSP are
	directly queued to the workers in fsp_dtp.c

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	25 Apr 1992		Initial Version

Notes:	Tab stop: 4
--*/

#define	FILENUM	FILE_FSD_DTP

#include <afp.h>
#include <gendisp.h>


/***	AfpFsdDispOpenDT
 *
 *	This routine implements the AfpOpenDT API. This completes here i.e. it is
 *	not queued to the FSP.
 *
 *	The request packet is represented below.
 *
 *	sda_ReqBlock	PCONNDESC	pConnDesc
 */
AFPSTATUS FASTCALL
AfpFsdDispOpenDT(
	IN	PSDA	pSda
)
{
	AFPSTATUS	Status = AFP_ERR_PARAM;
	struct _RequestPacket
	{
		PCONNDESC	_pConnDesc;
	};
	struct _ResponsePacket
	{
		BYTE	__DTRefNum[2];
	};

	DBGPRINT(DBG_COMP_AFPAPI_DTP, DBG_LEVEL_INFO,
											("AfpFsdDispOpenDT: Entered\n"));

	ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);
	ASSERT(VALID_CONNDESC(pReqPkt->_pConnDesc) &&
		   VALID_VOLDESC(pReqPkt->_pConnDesc->cds_pVolDesc));

	if (AfpVolumeMarkDt(pSda, pReqPkt->_pConnDesc, True))
	{
		pSda->sda_ReplySize = SIZE_RESPPKT;
		if ((Status = AfpAllocReplyBuf(pSda)) == AFP_ERR_NONE)
			PUTDWORD2SHORT(pRspPkt->__DTRefNum,
						   pReqPkt->_pConnDesc->cds_pVolDesc->vds_VolId);
	}
	return Status;
}


/***	AfpFsdDispCloseDT
 *
 *	This routine implements the AfpCloseDT API. This completes here i.e. it is
 *	not queued to the FSP.
 *
 *	The request packet is represented below.
 *
 *	sda_ReqBlock	PCONNDESC	pConnDesc
 */
AFPSTATUS FASTCALL
AfpFsdDispCloseDT(
	IN	PSDA	pSda
)
{
	struct _RequestPacket
	{
		PCONNDESC	_pConnDesc;
	};

	DBGPRINT(DBG_COMP_AFPAPI_DTP, DBG_LEVEL_INFO,
										("AfpFsdDispCloseDT: Entered\n"));

	ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);
	ASSERT(VALID_CONNDESC(pReqPkt->_pConnDesc) &&
		   VALID_VOLDESC(pReqPkt->_pConnDesc->cds_pVolDesc));

	return (AfpVolumeMarkDt(pSda, pReqPkt->_pConnDesc, False) ?
							AFP_ERR_NONE : AFP_ERR_PARAM);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\server\fsd_srv.c ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	fsd_srv.c

Abstract:

	This module contains the entry points for the AFP server APIs. The API
	dispatcher calls these. These are all callable from FSD. All of the APIs
	complete in the DPC context. The ones which are completed in the FSP are
	directly queued to the workers in fsp_srv.c

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	25 Apr 1992		Initial Version

Notes:	Tab stop: 4
--*/

#define	FILENUM	FILE_FSD_SRV

#include <afp.h>
#include <gendisp.h>


/***	AfpFsdDispGetSrvrParms
 *
 *	This routine implements the AfpGetSrvrParms API. This completes here i.e.
 *	it is not queued up to the Fsp.
 *
 *	There is no request packet for this API.
 *
 *	Locks are acquired for both the volume list and individual volume descs.
 *
 *	LOCKS: vds_VolLock (SPIN), AfpVolumeListLock (SPIN)
 *
 *	LOCK_ORDER: vds_VolLock (SPIN) after AfpVolumeListLock (SPIN)
 */
AFPSTATUS FASTCALL
AfpFsdDispGetSrvrParms(
	IN	PSDA	pSda
)
{
	PBYTE		pTemp;				// Roving pointer
	PVOLDESC	pVolDesc;
	LONG		VolCount;
	AFPTIME		MacTime;
	BOOLEAN		MoreSpace = True;
	struct _ResponsePacket
	{
		BYTE	__ServerTime[4];
		BYTE	__NumVols;
	};

	DBGPRINT(DBG_COMP_AFPAPI_SRV, DBG_LEVEL_INFO,
										("AfpFsdDispGetSrvrParms: Entered\n"));

	ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);
	/*
	 *	Estimate the size of reply buffer needed. We need one big enough to
	 *	either accomodate all volumes or the maximum size buffer whichever
	 *	is less.
	 *
	 *	The reply consists of the server time, count of volumes and a list of
	 *	volumes and flags to indicate if this volume has a password.
	 *
	 *	NOTE: If we decide to do private volumes, then the following code
	 *		  has to change. Specifically AfpVolCount will have to be computed
	 *		  based on how many private volumes exist and if there is one
	 *		  for this user.
	 */

	ACQUIRE_SPIN_LOCK_AT_DPC(&AfpVolumeListLock);

	/*
	 * Each volume entry takes a byte for flags, a byte for length and the
	 * size of the volume name string. We estimate based on maximum size of
	 * the volume name. On an average it will be less. For every volume, apart
	 * from the volume name, we need a byte for volume flags and a byte for
	 * the volume name length.
	 */
	if ((pSda->sda_ReplySize = (USHORT)(SIZE_RESPPKT + AfpVolCount *
				(SIZE_PASCALSTR(AFP_VOLNAME_LEN+1) + sizeof(BYTE)))) > pSda->sda_MaxWriteSize)
		pSda->sda_ReplySize = (USHORT)pSda->sda_MaxWriteSize;

	if (AfpAllocReplyBuf(pSda) != AFP_ERR_NONE)
	{
		RELEASE_SPIN_LOCK_FROM_DPC(&AfpVolumeListLock);
		return AFP_ERR_MISC;
	}

	// Point pTemp past the response header
	pTemp = pSda->sda_ReplyBuf + SIZE_RESPPKT;

	for (VolCount = 0, pVolDesc = AfpVolumeList;
		 (pVolDesc != NULL) && MoreSpace;
		 pVolDesc = pVolDesc->vds_Next)
	{
		ACQUIRE_SPIN_LOCK_AT_DPC(&pVolDesc->vds_VolLock);
		do
		{
			// Ignore volumes that have not been added completely
			if (pVolDesc->vds_Flags & (VOLUME_INTRANSITION | VOLUME_DELETED | VOLUME_INITIAL_CACHE))
				break;

			// Ignore volumes that do not have guest access and the client
			// is guest
			if (!(pVolDesc->vds_Flags & AFP_VOLUME_GUESTACCESS) &&
				(pSda->sda_ClientType == SDA_CLIENT_GUEST))
				break;

			// See if we are likely to cross bounds. For each volume we need a
			// byte for the PASCALSTR name and a flag byte. Note that we do not
			// add any pads.
			if ((pTemp + SIZE_PASCALSTR(pVolDesc->vds_MacName.Length) +
					sizeof(BYTE)) >= (pSda->sda_ReplyBuf + pSda->sda_ReplySize))
			{
				DBGPRINT(DBG_COMP_AFPAPI_SRV, DBG_LEVEL_INFO,
						("AfpFsdDispGetSrvrParms: Out of space\n"));
				MoreSpace = False;
				break;
			}

			// Check for volume password. We never carry the HasConfigInfo bit !!
			*pTemp++ = (pVolDesc->vds_Flags & AFP_VOLUME_HASPASSWORD) 	?
										SRVRPARMS_VOLUMEHASPASS : 0;

			*pTemp++ = (BYTE)pVolDesc->vds_MacName.Length;
			RtlCopyMemory(pTemp, pVolDesc->vds_MacName.Buffer,
									pVolDesc->vds_MacName.Length);

			pTemp += pVolDesc->vds_MacName.Length;
			VolCount ++;
		} while (False);
		RELEASE_SPIN_LOCK_FROM_DPC(&pVolDesc->vds_VolLock);
	}
	RELEASE_SPIN_LOCK_FROM_DPC(&AfpVolumeListLock);

	pSda->sda_ReplySize = (USHORT)(pTemp - pSda->sda_ReplyBuf);

	ASSERT (VolCount <= AfpVolCount);
	AfpGetCurrentTimeInMacFormat(&MacTime);
	PUTDWORD2DWORD(pRspPkt->__ServerTime, MacTime);
	PUTDWORD2BYTE(&pRspPkt->__NumVols, VolCount);

	return AFP_ERR_NONE;
}


/***	AfpFsdDispGetSrvrMsg
 *
 *	This routine implements the AfpGetSrvrMsg API. This completes here i.e.
 *	it is not queued up to the Fsp.
 *
 *	The request packet is represented below.
 *
 *	sda_ReqBlock	DWORD	MsgType
 *	sda_ReqBlock	DWORD	Bitmap
 *
 *	LOCKS:		AfpServerGlobalLock (SPIN), sda_Lock (SPIN)
 *	LOCK_ORDER:	sda_Lock after AfpServerGlobalLock
 */
AFPSTATUS FASTCALL
AfpFsdDispGetSrvrMsg(
	IN	PSDA	pSda
)
{
	DWORD		MsgType,
				Bitmap;
	AFPSTATUS	Status = AFP_ERR_NONE;
	ANSI_STRING	Message;

	struct _RequestPacket
	{
		DWORD	_MsgType,
				_Bitmap;
	};
	struct _ResponsePacket
	{
		BYTE	__MsgType[2],
				__Bitmap[2],
				__Message[1];
	};

	DBGPRINT(DBG_COMP_AFPAPI_SRV, DBG_LEVEL_INFO,
			("AfpFsdDispGetSrvrMsg: Entered\n"));

	ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

	// Note: Should we be doing this ? Why not give it to him since he asked.
	if (pSda->sda_ClientVersion < AFP_VER_21)
		return AFP_ERR_CALL_NOT_SUPPORTED;

	MsgType = pReqPkt->_MsgType;
	Bitmap = pReqPkt->_Bitmap;

	do
	{
		if (Bitmap & ~SRVRMSG_BITMAP_MESSAGE)
		{
			Status = AFP_ERR_BITMAP;
			break;
		}

		if ((MsgType != SRVRMSG_LOGIN) &&
			(MsgType != SRVRMSG_SERVER))
		{
			Status = AFP_ERR_PARAM;
			break;
		}

		// Allocate a reply buffer for a maximum size message. We cannot hold the
		// SDA lock and call the AllocBuf routine since it calls AfpInterlocked...
		pSda->sda_ReplySize = SIZE_RESPPKT + AFP_MAXCOMMENTSIZE;
		if ((Status = AfpAllocReplyBuf(pSda)) == AFP_ERR_NONE)
		{
			ACQUIRE_SPIN_LOCK_AT_DPC(&AfpServerGlobalLock);
			ACQUIRE_SPIN_LOCK_AT_DPC(&pSda->sda_Lock);

			switch (MsgType)
			{
			  case SRVRMSG_LOGIN:
				Message = AfpLoginMsg;
				break;
			  case SRVRMSG_SERVER:
				if (pSda->sda_Message != NULL)
					Message = *(pSda->sda_Message);
				else if (AfpServerMsg != NULL)
					Message = *AfpServerMsg;
				else		// Setup a default of No message.
					AfpSetEmptyAnsiString(&Message, 0, NULL);
				break;
			}

			pSda->sda_ReplySize = SIZE_RESPPKT + Message.Length;

			PUTSHORT2SHORT(pRspPkt->__MsgType, MsgType);
			PUTSHORT2SHORT(pRspPkt->__Bitmap, Bitmap);
			pRspPkt->__Message[0] = (BYTE) Message.Length;
			if (Message.Length > 0)
			{
				RtlCopyMemory( &pRspPkt->__Message[1],
								Message.Buffer,
								Message.Length);
			}
			// If this is not a broadcast message, then get rid of the
			// Sda message memory as it is consuming non-paged resources
			if ((MsgType == SRVRMSG_SERVER) &&
				(pSda->sda_Message != NULL))
			{
				AfpFreeMemory(pSda->sda_Message);
				pSda->sda_Message = NULL;
			}

			RELEASE_SPIN_LOCK_FROM_DPC(&pSda->sda_Lock);
			RELEASE_SPIN_LOCK_FROM_DPC(&AfpServerGlobalLock);
		}

		if (Status == AFP_ERR_NONE)
			INTERLOCKED_INCREMENT_LONG(&AfpServerStatistics.stat_NumMessagesSent);
	} while (False);

	return Status;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\server\fsd.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

	fsd.c

Abstract:

	This module implements the File System Driver for the AFP Server. All of
	the initialization, admin request handler etc. is here.

Author:

	Jameel Hyder (microsoft!jameelh)

Revision History:
	01 Jun 1992		Initial Version

--*/

#define	FILENUM	FILE_FSD

#include <afp.h>
#define	AFPADMIN_LOCALS
#include <afpadmin.h>
#include <client.h>
#include <scavengr.h>
#include <secutil.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, DriverEntry)
#pragma alloc_text( INIT, afpInitServer)
#pragma alloc_text( PAGE, afpFsdDispatchAdminRequest)
#pragma alloc_text( PAGE, afpFsdHandleAdminRequest)
#pragma alloc_text( PAGE, afpHandleQueuedAdminRequest)
#pragma alloc_text( PAGE, afpFsdUnloadServer)
#pragma alloc_text( PAGE, afpAdminThread)
#pragma alloc_text( PAGE, afpFsdHandleShutdownRequest)
#endif

/***	afpFsdDispatchAdminRequest
 *
 *	This is the driver entry point. This is for the sole use by the server
 *	service which opens the driver for EXCLUSIVE use. The admin request is
 *	received here as a request packet defined in admin.h.
 */
LOCAL NTSTATUS
afpFsdDispatchAdminRequest(
	IN	PDEVICE_OBJECT	pDeviceObject,
	IN	PIRP			pIrp
)
{
	PIO_STACK_LOCATION	pIrpSp;
	NTSTATUS			Status;
	BOOLEAN				LockDown = True;
	static	DWORD		afpOpenCount = 0;

	pDeviceObject;		// prevent compiler warnings

	PAGED_CODE( );

	pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
	pIrp->IoStatus.Information = 0;

	if ((pIrpSp->MajorFunction == IRP_MJ_FILE_SYSTEM_CONTROL)	||
		(pIrpSp->MajorFunction == IRP_MJ_CREATE)				||
		(pIrpSp->MajorFunction == IRP_MJ_CLOSE))
	{
		LockDown = False;
	}
	else
	{
		afpStartAdminRequest(pIrp);		// Lock admin code
	}

	switch (pIrpSp->MajorFunction)
	{
	  case IRP_MJ_CREATE:
		DBGPRINT(DBG_COMP_ADMINAPI, DBG_LEVEL_INFO,
				("afpFsdDispatchAdminRequest: Open Handle\n"));

		INTERLOCKED_INCREMENT_LONG(&afpOpenCount);
		// Fall through

	  case IRP_MJ_CLOSE:
		Status = STATUS_SUCCESS;
		break;

	  case IRP_MJ_DEVICE_CONTROL:
		Status =  afpFsdHandleAdminRequest(pIrp);
		break;

	  case IRP_MJ_FILE_SYSTEM_CONTROL:
		Status = AfpSecurityUtilityWorker(pIrp, pIrpSp);
		break;

	  case IRP_MJ_CLEANUP:
		Status = STATUS_SUCCESS;
		DBGPRINT(DBG_COMP_ADMINAPI, DBG_LEVEL_INFO,
				("afpFsdDispatchAdminRequest: Close Handle\n"));
		INTERLOCKED_DECREMENT_LONG(&afpOpenCount);

#if 0
		// If the service is closing its handle. Force a service stop
		if ((afpOpenCount == 0) &&
			(AfpServerState != AFP_STATE_STOPPED))
			AfpAdmServiceStop(NULL, 0, NULL);
#endif
		break;

	  case IRP_MJ_SHUTDOWN:
		DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
				("afpFsdDispatchAdminRequest: Received shutdown notification !!\n"));
		Status = afpFsdHandleShutdownRequest(pIrp);
		break;

	  default:
		Status = STATUS_NOT_IMPLEMENTED;
		break;
	}

	ASSERT (KeGetCurrentIrql() < DISPATCH_LEVEL);

	if (Status != STATUS_PENDING)
	{
		pIrp->IoStatus.Status = Status;
		if (LockDown)
		{
			afpStopAdminRequest(pIrp);	// Unlock admin code (and complete request)
		}
		else
		{
			IoCompleteRequest(pIrp, IO_NETWORK_INCREMENT);
		}
	}

	return Status;
}


/***	afpFsdHandleAdminRequest
 *
 *	This is the admin request handler. The list of admin requests are defined
 *	in admin.h. The admin requests must happen in a pre-defined order. The
 *	service start must happen after atleast the following.
 *
 *		ServerSetInfo
 *
 *	Preferably all VolumeAdds should also happen before server start. This is
 *	not enforced, obviously since the server can start w/o any volumes defined.
 *
 */
LOCAL NTSTATUS
afpFsdHandleAdminRequest(
	IN PIRP		pIrp
)
{
	NTSTATUS				Status = STATUS_PENDING;
	USHORT					FuncCode;
	USHORT					Method;
	PVOID					pBufIn;
	PVOID					pBufOut;
	LONG					i, Off, iBufLen, oBufLen;
    LONG                    NumEntries;
	PADMQREQ				pAdmQReq;
	IN PIO_STACK_LOCATION	pIrpSp;
	struct	_AdminApiDispatchTable *pDispTab;


	PAGED_CODE( );

	// Initialize the I/O Status block
	pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
	iBufLen = pIrpSp->Parameters.DeviceIoControl.InputBufferLength;
	pBufIn = pIrp->AssociatedIrp.SystemBuffer;

	FuncCode = (USHORT)AFP_CC_BASE(pIrpSp->Parameters.DeviceIoControl.IoControlCode);
	Method = (USHORT)AFP_CC_METHOD(pIrpSp->Parameters.DeviceIoControl.IoControlCode);

	if (Method == METHOD_BUFFERED)
	{
		// Get the output buffer and its length. Input and Output buffers are
		// both pointed to by the SystemBuffer
		pBufOut = pBufIn;
		oBufLen = pIrpSp->Parameters.DeviceIoControl.OutputBufferLength;
	}
	else if ((Method == METHOD_IN_DIRECT) && (pIrp->MdlAddress != NULL))
	{
		pBufOut = MmGetSystemAddressForMdlSafe(
				pIrp->MdlAddress,
				NormalPagePriority);

        if (pBufOut == NULL)
        {
            ASSERT(0);
		    return STATUS_INSUFFICIENT_RESOURCES;
        }
		oBufLen = MmGetMdlByteCount(pIrp->MdlAddress);
	}
	else
	{
		DBGPRINT(DBG_COMP_ADMINAPI, DBG_LEVEL_ERR,
				("afpFsdHandleAdminRequest: Invalid Request %d/%d\n", FuncCode, Method));
		return STATUS_INVALID_PARAMETER;
	}

	DBGPRINT(DBG_COMP_ADMINAPI, DBG_LEVEL_INFO,
			("afpFsdHandleAdminRequest Entered, Function %d\n", FuncCode));

	// Validate the function code
	if (FuncCode == 0 || FuncCode >= CC_BASE_MAX)
		return STATUS_INVALID_PARAMETER;

	pDispTab = &AfpAdminDispatchTable[FuncCode - 1];
	if ((pDispTab->_MinBufLen > (SHORT)iBufLen) ||
		(pDispTab->_OpCode != pIrpSp->Parameters.DeviceIoControl.IoControlCode))
	{
		return STATUS_INVALID_PARAMETER;
	}

	INTERLOCKED_INCREMENT_LONG( &AfpServerStatistics.stat_NumAdminReqs );

	if (pDispTab->_CausesChange)
		INTERLOCKED_INCREMENT_LONG( &AfpServerStatistics.stat_NumAdminChanges );
							

	// Now validate the DESCRIPTOR of the input buffer
	for (i = 0; i < MAX_FIELDS; i++)
	{
		if (pDispTab->_Fields[i]._FieldDesc == DESC_NONE)
			break;

		Off = pDispTab->_Fields[i]._FieldOffset;
		switch (pDispTab->_Fields[i]._FieldDesc)
		{
		  case DESC_STRING:
		    ASSERT(pBufIn != NULL);

		    // Make Sure that the string is pointing to somewhere within
		    // the buffer and also the end of the buffer is a UNICODE_NULL
			if ((*(PLONG)((PBYTE)pBufIn + Off) > iBufLen) ||
				(*(LPWSTR)((PBYTE)pBufIn + iBufLen - sizeof(WCHAR)) != UNICODE_NULL))
		    {
				return STATUS_INVALID_PARAMETER;
		    }
		    // Convert the offset to a pointer
		    OFFSET_TO_POINTER(*(PBYTE *)((PBYTE)pBufIn + Off),
							  (PBYTE)pBufIn + pDispTab->_OffToStruct);
		    break;

		  case DESC_ETC:
		    ASSERT(pBufIn != NULL);

		    // Make Sure that there are as many etc mappings as the
		    // structure claims
            NumEntries = *(PLONG)((PBYTE)pBufIn + Off);
		    if ((LONG)(NumEntries * sizeof(ETCMAPINFO) + sizeof(DWORD)) > iBufLen)
		    {
		    	return STATUS_INVALID_PARAMETER;
		    }

            if (NumEntries > (LONG)((iBufLen/sizeof(ETCMAPINFO)) + 1))
            {
		    	return STATUS_INVALID_PARAMETER;
            }
		    break;

		  case DESC_ICON:
		    // Validate that the buffer is atleast big enough to hold the
		    // icon that this purports to.
		    ASSERT(pBufIn != NULL);

		    if ((LONG)((*(PLONG)((PBYTE)pBufIn + Off) +
		    			 sizeof(SRVICONINFO))) > iBufLen)
		    {
		    	return STATUS_INVALID_PARAMETER;
		    }
		    break;

		  case DESC_SID:
		    // Validate that the buffer is big enough to hold the Sid
		    ASSERT(pBufIn != NULL);
		    {
		    	LONG	Offst, SidSize;

		    	Offst = *(PLONG)((PBYTE)pBufIn + Off);
				// If no SID is being sent then we're done
				if (Offst == 0)
				{
					break;
				}

		    	if ((Offst > iBufLen) ||
		    		(Offst < (LONG)(sizeof(AFP_DIRECTORY_INFO))) ||
		    		((Offst + (LONG)sizeof(SID)) > iBufLen))
		    	{
		    		return STATUS_INVALID_PARAMETER;
		    	}

		    	// Convert the offset to a pointer
		    	OFFSET_TO_POINTER(*(PBYTE *)((PBYTE)pBufIn + Off),
		    				(PBYTE)pBufIn + pDispTab->_OffToStruct);

		    	// Finally check if the buffer is big enough for the real
		    	// sid
		    	SidSize = RtlLengthSid(*((PSID *)((PBYTE)pBufIn + Off)));
		    	if ((Off + SidSize) > iBufLen)
		    	{
		    		return STATUS_INVALID_PARAMETER;
		    	}
		    }
		    break;

		  case DESC_SPECIAL:
		    // Validate that the buffer is big enough to hold all the
		    // information. The information consists of limits on non-paged
		    // and paged memory and a list of domain sids and their corres.
		    // posix offsets
		    ASSERT(pBufIn != NULL);
		    {
		    	LONG			i;
		    	LONG			SizeRemaining;
		    	PAFP_SID_OFFSET	pSidOff;

		    	SizeRemaining = iBufLen - (sizeof(AFP_SID_OFFSET_DESC) -
		    										sizeof(AFP_SID_OFFSET));
		    	for (i = 0;
		    		 i < (LONG)(((PAFP_SID_OFFSET_DESC)pBufIn)->CountOfSidOffsets);
		    		 i++, pSidOff++)
		    	{
		    		pSidOff = &((PAFP_SID_OFFSET_DESC)pBufIn)->SidOffsetPairs[i];
		    		if (SizeRemaining < (sizeof(AFP_SID_OFFSET) + sizeof(SID)))
		    			return STATUS_INVALID_PARAMETER;
		    		OFFSET_TO_POINTER(pSidOff->pSid, pSidOff);

		    		if ((LONG)(((PBYTE)(pSidOff->pSid) - (PBYTE)pBufIn +
		    					RtlLengthSid(pSidOff->pSid))) > iBufLen)
		    			return STATUS_INVALID_PARAMETER;
		    		SizeRemaining -= (RtlLengthSid(pSidOff->pSid) +
		    						  sizeof(AFP_SID_OFFSET));
		    	}
		    }
		    break;
		}
	}

	// Can this request be handled/validated at this level
	if (pDispTab->_AdminApiWorker != NULL)
	{
		Status = (*pDispTab->_AdminApiWorker)(pBufIn, oBufLen, pBufOut);

		if (NT_SUCCESS(Status))
		{
			if (Method != METHOD_BUFFERED)
				pIrp->IoStatus.Information = oBufLen;
		}
	}

	if (Status == STATUS_PENDING)
	{
		ASSERT (pDispTab->_AdminApiQueuedWorker != NULL);

		// Mark this as a pending Irp as we are about to queue it up
		IoMarkIrpPending(pIrp);

		if ((pAdmQReq =
			(PADMQREQ)AfpAllocNonPagedMemory(sizeof(ADMQREQ))) == NULL)
		{
			Status = STATUS_INSUFFICIENT_RESOURCES;
		}
		else
		{
			PWORK_ITEM	pWI = &pAdmQReq->aqr_WorkItem;

			DBGPRINT(DBG_COMP_ADMINAPI, DBG_LEVEL_INFO,
					("afpFsdHandleAdminRequest: Queuing to worker\n"));

			AfpInitializeWorkItem(pWI,
								 afpHandleQueuedAdminRequest,
								 pAdmQReq);

			pAdmQReq->aqr_AdminApiWorker = pDispTab->_AdminApiQueuedWorker;
			pAdmQReq->aqr_pIrp = pIrp;

			// Insert item in admin queue
			INTERLOCKED_ADD_ULONG(&AfpWorkerRequests, 1, &AfpServerGlobalLock);
			KeInsertQueue(&AfpAdminQueue, &pAdmQReq->aqr_WorkItem.wi_List);
		}
	}

	return Status;
}

/***	afpHandleQueuedAdminRequest
 *
 *	This handles queued admin requests. It is called in the context of the
 *	worker thread.
 */
LOCAL VOID FASTCALL
afpHandleQueuedAdminRequest(
	IN	PADMQREQ	pAdmQReq
)
{
	PIRP				pIrp;
	PIO_STACK_LOCATION	pIrpSp;
	PVOID				pBufOut = NULL;
	LONG				oBufLen = 0;
	USHORT				Method;

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_ADMINAPI, DBG_LEVEL_INFO,
			("afpHandleQueuedAdminRequest Entered\n"));

	// Get the IRP and the IRP Stack location out of the request
	pIrp = pAdmQReq->aqr_pIrp;
	ASSERT (pIrp != NULL);

	pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
	ASSERT (pIrpSp != NULL);

	Method = (USHORT)AFP_CC_METHOD(pIrpSp->Parameters.DeviceIoControl.IoControlCode);

	if (Method == METHOD_BUFFERED)
	{
		// Get the output buffer and its length. Input and Output buffers are
		// both pointed to by the SystemBuffer
		oBufLen = pIrpSp->Parameters.DeviceIoControl.OutputBufferLength;
		pBufOut = pIrp->AssociatedIrp.SystemBuffer;
	}
	else if ((Method == METHOD_IN_DIRECT) && (pIrp->MdlAddress != NULL))
	{
		pBufOut = MmGetSystemAddressForMdlSafe(
				        pIrp->MdlAddress,
				        NormalPagePriority);

        if (pBufOut == NULL)
        {
            ASSERT(0);

            pAdmQReq->aqr_pIrp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
            IoCompleteRequest(pAdmQReq->aqr_pIrp, IO_NETWORK_INCREMENT);
            AfpFreeMemory(pAdmQReq);

            return;
        }
		oBufLen = MmGetMdlByteCount(pIrp->MdlAddress);
	}
	else ASSERTMSG(0, "afpHandleQueuedAdminRequest: Invalid method\n");

		
	// Call the worker and complete the IoRequest
	pIrp->IoStatus.Status = (*pAdmQReq->aqr_AdminApiWorker)(pIrp->AssociatedIrp.SystemBuffer,
														    oBufLen,
															pBufOut);
	if (NT_SUCCESS(pIrp->IoStatus.Status))
	{
		if (Method != METHOD_BUFFERED)
			pIrp->IoStatus.Information = oBufLen;
	}

	ASSERT(pIrp->IoStatus.Status != STATUS_PENDING);

	ASSERT (KeGetCurrentIrql() < DISPATCH_LEVEL);

	afpStopAdminRequest(pIrp);		// Unlock admin code and complete request

	AfpFreeMemory(pAdmQReq);
}



/***	afpFsdUnloadServer
 *
 *	This is the unload routine for the Afp Server. The server can ONLY be
 *	unloaded in its passive state i.e. either before recieving a ServiceStart
 *	or after recieving a ServiceStop. This is ensured by making the service
 *	dependent on the server. Also the IO system ensures that there are no open
 *	handles to our device when this happens.
 */
LOCAL VOID
afpFsdUnloadServer(
	IN	PDRIVER_OBJECT DeviceObject
)
{
	NTSTATUS		Status;
	LONG			i;
	LONG			LastThreadCount = 0;
	PETHREAD		pLastThrdPtr;

	DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
			("afpFsdUnloadServer Entered\n"));

	ASSERT((AfpServerState == AFP_STATE_STOPPED) || (AfpServerState == AFP_STATE_IDLE));

	// Stop our threads before unloading
	DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
			("afpFsdUnloadServer: Stopping worker threads\n"));

	//
    // tell TDI we don't care to know if the stack is going away
	//
    if (AfpTdiNotificationHandle)
    {
        Status = TdiDeregisterPnPHandlers(AfpTdiNotificationHandle);

        if (!NT_SUCCESS(Status))
        {
	        DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
			    ("afpFsdUnloadServer: TdiDeregisterNotificationHandler failed with %lx\n",Status));
        }

        AfpTdiNotificationHandle = NULL;
    }

    DsiShutdown();

	// Stop the scavenger. This also happens during server stop but we can get here
	// another way as well
	AfpScavengerFlushAndStop();

	DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
			("afpFsdUnloadServer: Stopping admin thread\n"));

	if (AfpNumAdminThreads > 0)
	{
		KeClearEvent(&AfpStopConfirmEvent);

		KeInsertQueue(&AfpAdminQueue, &AfpTerminateThreadWI.wi_List);

		do
		{
			Status = AfpIoWait(&AfpStopConfirmEvent, &FiveSecTimeOut);
			if (Status == STATUS_TIMEOUT)
			{
				DBGPRINT(DBG_COMP_ADMINAPI_SC, DBG_LEVEL_ERR,
						("afpFsdUnloadServer: Timeout Waiting for admin thread, re-waiting\n"));
			}
		} while (Status == STATUS_TIMEOUT);
	}

	KeRundownQueue(&AfpAdminQueue);

	if (AfpNumNotifyThreads > 0)
	{
		for (i = 0; i < NUM_NOTIFY_QUEUES; i++)
		{
			KeClearEvent(&AfpStopConfirmEvent);
	
			KeInsertQueue(&AfpVolumeNotifyQueue[i], &AfpTerminateNotifyThread.vn_List);
	
			do
			{
				Status = AfpIoWait(&AfpStopConfirmEvent, &FiveSecTimeOut);
				if (Status == STATUS_TIMEOUT)
				{
					DBGPRINT(DBG_COMP_ADMINAPI_SC, DBG_LEVEL_ERR,
							("afpFsdUnloadServer: Timeout Waiting for Notify Thread %d, re-waiting\n", i));
				}
			} while (Status == STATUS_TIMEOUT);
			KeRundownQueue(&AfpVolumeNotifyQueue[i]);
		}
	}

    ASSERT (KeGetCurrentIrql() < DISPATCH_LEVEL);

    // Cleanup virtual memory used by volumes for private notifies
    afpFreeNotifyBlockMemory();

	// Stop worker threads
	if (AfpNumThreads > 0)
	{
		KeClearEvent(&AfpStopConfirmEvent);

		KeInsertQueue(&AfpWorkerQueue, &AfpTerminateThreadWI.wi_List);

		do
		{
			Status = AfpIoWait(&AfpStopConfirmEvent, &FiveSecTimeOut);
			if (Status == STATUS_TIMEOUT)
			{
				DBGPRINT(DBG_COMP_ADMINAPI_SC, DBG_LEVEL_ERR,
						("afpFsdUnloadServer: Timeout Waiting for worker threads, re-waiting\n"));
			}
		} while (Status == STATUS_TIMEOUT);
	}

    // See how many threads are around
    // Loop around until we have exactly one thread left or if no worker
    // thread was started
    do 
    {
	    pLastThrdPtr = NULL;
        LastThreadCount = 0;

	    for (i=0; i<AFP_MAX_THREADS; i++)
	    {
	        if (AfpThreadPtrsW[i] != NULL)
	        {
		        pLastThrdPtr = AfpThreadPtrsW[i];
		        LastThreadCount++;

		        if (LastThreadCount > 1)
		        {
		            Status = AfpIoWait(pLastThrdPtr, &FiveSecTimeOut);
                    break;
		        }
    
	        }
        }

        if ((LastThreadCount == 1) || (LastThreadCount == 0))
        {
            break;
        }
	} while (TRUE);

	// wait on the last thread pointer.  When that thread quits, we are signaled.  This
	// is the surest way of knowing that the thread has really really died
	if (pLastThrdPtr)
	{
	    do
	    {
		Status = AfpIoWait(pLastThrdPtr, &FiveSecTimeOut);
		if (Status == STATUS_TIMEOUT)
		{
			DBGPRINT(DBG_COMP_ADMINAPI_SC, DBG_LEVEL_ERR,
					("afpFsdUnloadServer: Timeout Waiting for last threads, re-waiting\n"));
		}
	    } while (Status == STATUS_TIMEOUT);

	    ObDereferenceObject(pLastThrdPtr);
	}

	KeRundownQueue(&AfpDelAllocQueue);

	KeRundownQueue(&AfpWorkerQueue);

	// Close the cloned process token
	if (AfpFspToken != NULL)
		NtClose(AfpFspToken);

	DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
			("afpFsdUnloadServer: De-initializing sub-systems\n"));

	// De-initialize all sub-systems now
	AfpDeinitializeSubsystems();

	DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
			("afpFsdUnloadServer: Deleting device\n"));

	// Destroy the DeviceObject for our device
	IoDeleteDevice(AfpDeviceObject);

#ifdef	PROFILING
	ASSERT(AfpServerProfile->perf_cAllocatedIrps == 0);
	ASSERT(AfpServerProfile->perf_cAllocatedMdls == 0);
	ExFreePool(AfpServerProfile);
#endif

	DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO, ("Current Sessions = %ld\n NonPaged usage = %ld\n CurrPagedUsage = %ld \n CurrentFileLocks = %ld \n CurrentFileOpen = %ld \n CurrentInternalOpens = %ld, NotifyBlockCount = %ld, NotifyCount = %d \n", 
	AfpServerStatistics.stat_CurrentSessions,
	AfpServerStatistics.stat_CurrNonPagedUsage, 
	AfpServerStatistics.stat_CurrPagedUsage,
	AfpServerStatistics.stat_CurrentFileLocks,
	AfpServerStatistics.stat_CurrentFilesOpen,
	AfpServerStatistics.stat_CurrentInternalOpens,
    	afpNotifyBlockAllocCount,
    	afpNotifyAllocCount
    	));

	// Make sure we do not have resource leaks
	ASSERT(AfpServerStatistics.stat_CurrentSessions == 0);
	ASSERT(AfpServerStatistics.stat_CurrNonPagedUsage == 0);
	ASSERT(AfpServerStatistics.stat_CurrPagedUsage == 0);
	ASSERT(AfpServerStatistics.stat_CurrentFileLocks == 0);
	ASSERT(AfpServerStatistics.stat_CurrentFilesOpen == 0);
	ASSERT(AfpServerStatistics.stat_CurrentInternalOpens == 0);

	ASSERT (AfpLockCount == 0);

	DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO, ("afpFsdUnloadServer Done\n"));

	// Give the worker threads a chance to really, really die
	AfpSleepAWhile(1000);

}


/***	afpAdminThread
 *
 *	This thread is used to do all the work of the queued admin threads.
 *
 *	LOCKS:	AfpServerGlobalLock (SPIN)
 */
LOCAL VOID
afpAdminThread(
	IN	PVOID	pContext
)
{
	PLIST_ENTRY			pList;
	PWORK_ITEM			pWI;
	ULONG				BasePriority;
	NTSTATUS			Status;

	AfpThread = PsGetCurrentThread();

    IoSetThreadHardErrorMode( FALSE );

	// Boost our priority to just below low realtime.
	// The idea is get the work done fast and get out of the way.
	BasePriority = LOW_REALTIME_PRIORITY;
	Status = NtSetInformationThread(NtCurrentThread(),
									ThreadBasePriority,
									&BasePriority,
									sizeof(BasePriority));
	ASSERT(NT_SUCCESS(Status));

	do
	{
		// Wait for admin request to process.
		pList = KeRemoveQueue(&AfpAdminQueue,
							  KernelMode,		// Do not let the kernel stack be paged
							  NULL);
		ASSERT(Status == STATUS_SUCCESS);

		ASSERT (KeGetCurrentIrql() < DISPATCH_LEVEL);

		pWI = CONTAINING_RECORD(pList, WORK_ITEM, wi_List);

		if (pWI == &AfpTerminateThreadWI)
		{
			break;
		}

		(*pWI->wi_Worker)(pWI->wi_Context);
		INTERLOCKED_ADD_ULONG(&AfpWorkerRequests, (ULONG)-1, &AfpServerGlobalLock);

		ASSERT (KeGetCurrentIrql() < DISPATCH_LEVEL);
	} while (True);

	DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO, ("afpAdminThread: Quitting\n"));

	KeSetEvent(&AfpStopConfirmEvent, IO_NETWORK_INCREMENT, False);
}


/***	afpStartStopAdminRequest
 *
 *	Called whenever an admin request is started/stopped. The admin code is locked
 *	or unlocked accordingly.
 */
LOCAL VOID
afpStartStopAdminRequest(
	IN	PIRP			pIrp,
	IN	BOOLEAN			Start
)
{

	// EnterCriticalSection
	AfpIoWait(&AfpPgLkMutex, NULL);

	ASSERT (AfpLockHandle != NULL);

	if (Start)
	{
		if (AfpLockCount == 0)
		{
			MmLockPagableSectionByHandle(AfpLockHandle);
		}
		AfpLockCount ++;
		pIrp->IoStatus.Status = STATUS_PENDING;
	}
	else
	{
		ASSERT (AfpLockCount > 0);

		AfpLockCount --;
		if (AfpLockCount == 0)
		{
			MmUnlockPagableImageSection(AfpLockHandle);
		}
	}

	// LeaveCriticalSection
	KeReleaseMutex(&AfpPgLkMutex, False);

	if (!Start)
		IoCompleteRequest(pIrp, IO_NETWORK_INCREMENT);
}


/***	afpFsdHandleShutdownRequest
 *
 *	This is the shutdown request handler. All sessions are shutdown and volumes
 *	flushed.
 */
LOCAL NTSTATUS
afpFsdHandleShutdownRequest(
	IN PIRP			pIrp
)
{
	PADMQREQ			pAdmQReq;
	NTSTATUS			Status;

	if ((pAdmQReq =
		(PADMQREQ)AfpAllocNonPagedMemory(sizeof(ADMQREQ))) == NULL)
	{
		Status = STATUS_INSUFFICIENT_RESOURCES;
	}
	else
	{
		PWORK_ITEM	pWI = &pAdmQReq->aqr_WorkItem;

		DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
				("afpFsdHandleShutdownRequest: Queuing to worker\n"));

		AfpInitializeWorkItem(&pAdmQReq->aqr_WorkItem,
							 afpHandleQueuedAdminRequest,
							 pAdmQReq);

		pAdmQReq->aqr_AdminApiWorker = AfpAdmSystemShutdown;
		pAdmQReq->aqr_pIrp = pIrp;

		// Insert item in admin queue
		KeInsertQueue(&AfpAdminQueue, &pAdmQReq->aqr_WorkItem.wi_List);
		Status = STATUS_PENDING;
	}

	return Status;
}


/***	DriverEntry
 *
 *  This is the initialization routine for the AFP server file
 *  system driver.  This routine creates the device object for the
 *  AfpServer device and performs all other driver initialization.
 */

NTSTATUS
DriverEntry (
	IN PDRIVER_OBJECT	DriverObject,
	IN PUNICODE_STRING	RegistryPath
)
{
	UNICODE_STRING	DeviceName;
	LONG			i;
	NTSTATUS		Status;

	DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
			("AFP Server Fsd initialization started\n"));

	//
	// Initialize global data event log insertion strings
	//


	KeInitializeQueue(&AfpDelAllocQueue, 0);
	KeInitializeQueue(&AfpWorkerQueue, 0);
    KeInitializeQueue(&AfpAdminQueue, 0);

	AfpProcessObject = IoGetCurrentProcess();

	Status = AfpInitializeDataAndSubsystems();

	if (!NT_SUCCESS(Status))
	{
		return Status;
	}

	DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
			("AFP Server Fsd Data initialized %lx\n", Status));

	// Create the device object.  (IoCreateDevice zeroes the memory
	// occupied by the object.)
	//
	// Should we apply an ACL to the device object ?

	RtlInitUnicodeString(&DeviceName, AFPSERVER_DEVICE_NAME);

	Status = IoCreateDevice(DriverObject,			// DriverObject
							0,						// DeviceExtension
							&DeviceName,			// DeviceName
							FILE_DEVICE_NETWORK,	// DeviceType
							FILE_DEVICE_SECURE_OPEN, // DeviceCharacteristics
							False,					// Exclusive
							&AfpDeviceObject);		// DeviceObject

	if (!NT_SUCCESS(Status))
	{
		// Do not errorlog here since logging uses the device object
		AfpDeinitializeSubsystems();
		return Status;
	}

	do
	{
		DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
				("DriverEntry: Creating Admin Thread\n"));

		// Create the Admin thread. This handles all queued operations

		Status = AfpCreateNewThread(afpAdminThread, 0);
		if (!NT_SUCCESS(Status))
		{
			DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_FATAL,
					("afpInitServer: Admin Thread creation failed %lx\n", Status));
			break;
		}
		AfpNumAdminThreads = 1;

		for (i = 0; i < NUM_NOTIFY_QUEUES; i++)
		{
			// Initialize volume change notify queue
			KeInitializeQueue(&AfpVolumeNotifyQueue[i], 0);

			// Start a thread to process change notifies
			Status = AfpCreateNewThread(AfpChangeNotifyThread, i);
			if (!NT_SUCCESS(Status))
			{
				DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_FATAL,
						("afpInitServer: Notify Thread %d, creation failed %lx\n", i+1, Status));
				break;
			}
		}
		if (!NT_SUCCESS(Status))
		{
			for (--i; i >= 0; i--)
			{
				KeClearEvent(&AfpStopConfirmEvent);
				KeInsertQueue(&AfpVolumeNotifyQueue[i], &AfpTerminateNotifyThread.vn_List);
				AfpIoWait(&AfpStopConfirmEvent, NULL);
			}
			break;
		}

		AfpNumNotifyThreads = NUM_NOTIFY_QUEUES;

		for (i = 0; i < AFP_MIN_THREADS; i++)
		{
			AfpThreadState[i] = AFP_THREAD_STARTED;
			Status = AfpCreateNewThread(AfpWorkerThread, i);
			if (!NT_SUCCESS(Status))
			{
				AfpThreadState[i] = AFP_THREAD_DEAD;
				DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_FATAL,
						("afpInitServer: Thread creation failed %d\n", i+1));
				if (i > 0)
				{
					KeClearEvent(&AfpStopConfirmEvent);
					KeInsertQueue(&AfpWorkerQueue, &AfpTerminateThreadWI.wi_List);
					AfpIoWait(&AfpStopConfirmEvent, NULL);
				}
				break;
			}
#if DBG
			AfpSleepAWhile(50);		// Make it so threads do not time out together
									// Helps with debugging
#endif
		}
		AfpNumThreads = AFP_MIN_THREADS;

		if (!NT_SUCCESS(Status))
			break;

		DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
				("AFP Server Fsd initialization completed %lx\n", Status));


        // initialize DSI specific things
        DsiInit();

        Status = AfpTdiRegister();

	    if (!NT_SUCCESS(Status))
	    {
	        DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
			    ("TdiRegisterNotificationHandler failed %lx\n", Status));
		    break;
	    }

		Status = afpInitServer();

		if (NT_SUCCESS(Status))
		{
			// Initialize the driver object for this file system driver.
			DriverObject->DriverUnload = afpFsdUnloadServer;
			for (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++)
			{
				DriverObject->MajorFunction[i] = afpFsdDispatchAdminRequest;
			}

			// Register for shutdown notification.  We don't care if this fails.
			Status = IoRegisterShutdownNotification(AfpDeviceObject);
			if (!NT_SUCCESS(Status))
			{
				DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
						("Afp Server Fsd: IoRegisterShutdownNotification failed %lx\n", Status));
			}
			Status = STATUS_SUCCESS;
		}
	} while (False);

	if (!NT_SUCCESS(Status))
	{
		afpFsdUnloadServer(DriverObject);
		Status = STATUS_UNSUCCESSFUL;
	}

	KeClearEvent(&AfpStopConfirmEvent);

	return Status;
}





/***	afpInitServer
 *
 *	Initialize the AFP Server. This happens on FSD initialization.
 *	The initialization consists of the following steps.
 *
 *	- Create a socket on the appletalk stack.
 *	- Create a token for ourselves.
 *	- Initialize security
 *	- Open the Authentication pacakage
 *
 * Note: Any errorlogging done from here must use AFPLOG_DDERROR since we
 *    will not have a usermode thread to do our errorlogging if anything
 *    goes wrong here.
 */
NTSTATUS
afpInitServer(
	VOID
)
{
	NTSTATUS			Status;
	ANSI_STRING			LogonProcessName;
	ULONG				OldSize;
	HANDLE				ProcessToken;
	TOKEN_PRIVILEGES	ProcessPrivileges, PreviousPrivilege;
	OBJECT_ATTRIBUTES	ObjectAttr;
	UNICODE_STRING	    PackageName;
	WCHAR				PkgBuf[5];
	TimeStamp			Expiry;       // unused on the server side (i.e. us)


	InitSecurityInterface();

	do
	{
		// Open our socket on the ASP Device. Implicitly checks out the
		// Appletalk stack

		DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
				("afpInitServer: Initializing Atalk\n"));

		DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
				("afpInitServer: Creating token\n"));

		// Clone the system process token and add the required privilges that
		// we need. This token will be used to impersonate when we set permissions
		Status = NtOpenProcessToken(NtCurrentProcess(),
									TOKEN_ALL_ACCESS,
									&ProcessToken);
		if (!NT_SUCCESS(Status))
		{
			AFPLOG_DDERROR(AFPSRVMSG_PROCESS_TOKEN, Status, NULL, 0, NULL);
			break;
		}

		InitializeObjectAttributes(&ObjectAttr, NULL, 0, NULL, NULL);
		ObjectAttr.SecurityQualityOfService = &AfpSecurityQOS;

		Status = NtDuplicateToken(ProcessToken,
								  TOKEN_ALL_ACCESS,
								  &ObjectAttr,
								  False,
								  TokenImpersonation,
								  &AfpFspToken);

		NtClose(ProcessToken);

		if (!NT_SUCCESS(Status))
		{
			AFPLOG_DDERROR(AFPSRVMSG_PROCESS_TOKEN, Status, NULL, 0, NULL);
			break;
		}

		ProcessPrivileges.PrivilegeCount = 1L;
		ProcessPrivileges.Privileges[0].Attributes =
								SE_PRIVILEGE_ENABLED | SE_PRIVILEGE_USED_FOR_ACCESS;
		ProcessPrivileges.Privileges[0].Luid = RtlConvertLongToLuid(SE_RESTORE_PRIVILEGE);

		Status = NtAdjustPrivilegesToken(AfpFspToken,
										 False,
										 &ProcessPrivileges,
										 sizeof(TOKEN_PRIVILEGES),
										 &PreviousPrivilege,
										 &OldSize);

		if (!NT_SUCCESS(Status))
		{
			AFPLOG_DDERROR(AFPSRVMSG_PROCESS_TOKEN, Status, NULL, 0, NULL);
			break;
		}

		PackageName.Length = 8;
		PackageName.Buffer = (LPWSTR)PkgBuf;
		RtlCopyMemory( PackageName.Buffer, NTLMSP_NAME, 8);

		Status = AcquireCredentialsHandle(NULL,		// Default principal
										  (PSECURITY_STRING)&PackageName,
										  SECPKG_CRED_INBOUND,
										  NULL,
										  NULL,
										  NULL,
										  (PVOID) NULL,
										  &AfpSecHandle,
										  &Expiry);
		if(!NT_SUCCESS(Status))
		{
		    DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_ERR,
			   ("AfpInitServer: AcquireCredentialsHandle() failed with %X\n", Status));
		    ASSERT(0);

		    if (AfpFspToken != NULL)
		    {
				NtClose(AfpFspToken);
				AfpFspToken = NULL;
		    }

		    break;
		}

		// Finally obtain a handle to our conditionally locked section
		AfpLockHandle = MmLockPagableCodeSection((PVOID)AfpAdmWServerSetInfo);
		MmUnlockPagableImageSection(AfpLockHandle);

	} while (False);

	return Status;
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\server\fsp_dir.c ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	fsp_dir.c

Abstract:

	This module contains the entry points for the AFP directory APIs. The API
	dispatcher calls these. These are all callable from FSD. All of the APIs
	complete in the DPC context. The ones which are completed in the FSP are
	directly queued to the workers in fsp_dir.c

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	25 Apr 1992		Initial Version

Notes:	Tab stop: 4
--*/

#define	FILENUM	FILE_FSP_DIR

#include <afp.h>
#include <gendisp.h>
#include <fdparm.h>
#include <pathmap.h>
#include <client.h>
#include <afpinfo.h>
#include <access.h>

#define	DEF_ID_CNT		128
#define	max(a,b)	(((a) > (b)) ? (a) : (b))

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, AfpFspDispOpenDir)
#pragma alloc_text( PAGE, AfpFspDispCloseDir)
#pragma alloc_text( PAGE, AfpFspDispCreateDir)
#pragma alloc_text( PAGE, AfpFspDispEnumerate)
#pragma alloc_text( PAGE, AfpFspDispSetDirParms)
#endif

/***	AfpFspDispOpenDir
 *
 *	This is the worker routine for the AfpOpenDir API.
 *
 *	The request packet is represented below.
 *
 *	sda_ReqBlock	PCONNDESC	pConnDesc
 *	sda_ReqBlock	DWORD		ParentId
 *	sda_Name1		ANSI_STRING	DirName
 */
AFPSTATUS FASTCALL
AfpFspDispOpenDir(
	IN	PSDA	pSda
)
{
	FILEDIRPARM		FDParm;
	PATHMAPENTITY	PME;
	AFPSTATUS		Status = AFP_ERR_PARAM;
	struct _RequestPacket
	{
		PCONNDESC	_pConnDesc;
		DWORD		_ParentId;
	};
	struct _ResponsePacket
	{
		BYTE		__DirId[4];
	};

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_AFPAPI_DIR, DBG_LEVEL_INFO,
										("AfpFspDispOpenDir: Entered\n"));

	ASSERT(VALID_CONNDESC(pReqPkt->_pConnDesc) &&
		   VALID_VOLDESC(pReqPkt->_pConnDesc->cds_pVolDesc));

	AfpInitializePME(&PME, 0, NULL);
	if ((Status = AfpMapAfpPathForLookup(pReqPkt->_pConnDesc,
										 pReqPkt->_ParentId,
										 &pSda->sda_Name1,
										 pSda->sda_PathType,
										 DFE_DIR,
										 DIR_BITMAP_DIRID,
										 &PME,
										 &FDParm)) == AFP_ERR_NONE)
		AfpIoClose(&PME.pme_Handle);	// Close the handle

	if (Status == AFP_ERR_NONE)
	{
		pSda->sda_ReplySize = SIZE_RESPPKT;
		if ((Status = AfpAllocReplyBuf(pSda)) == AFP_ERR_NONE)
			PUTDWORD2DWORD(pRspPkt->__DirId, FDParm._fdp_AfpId);
	}

	return Status;
}


/***	AfpFspDispCloseDir
 *
 *	This routine implements the AfpCloseDir API.
 *
 *	The request packet is represented below.
 *
 *	sda_ReqBlock	PCONNDESC	pConnDesc
 *	sda_ReqBlock	DWORD		DirId
 */
AFPSTATUS FASTCALL
AfpFspDispCloseDir(
	IN	PSDA	pSda
)
{
	FILEDIRPARM		FDParm;
	PATHMAPENTITY	PME;
	AFPSTATUS		Status;
	struct _RequestPacket
	{
		PCONNDESC	_pConnDesc;
		DWORD		_DirId;
	};

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_AFPAPI_DIR, DBG_LEVEL_INFO,
										("AfpFspDispCloseDir: Entered\n"));

	ASSERT(VALID_CONNDESC(pReqPkt->_pConnDesc) &&
		   VALID_VOLDESC(pReqPkt->_pConnDesc->cds_pVolDesc));

	AfpInitializeFDParms(&FDParm);

	AfpInitializePME(&PME, 0, NULL);
	Status = AfpMapAfpIdForLookup(pReqPkt->_pConnDesc,
								  pReqPkt->_DirId,
								  DFE_DIR,
								  0,
								  &PME,
								  &FDParm);
	if (Status == AFP_ERR_NONE)
	{
		AfpIoClose(&PME.pme_Handle);
	}
	else Status = AFP_ERR_PARAM;

	return Status;
}


/***	AfpFspDispCreateDir
 *
 *	This is the worker routine for the AfpCreateDir API.
 *
 *	The request packet is represented below.
 *
 *	sda_ReqBlock	PCONNDESC	pConnDesc
 *	sda_ReqBlock	DWORD		ParentId
 *	sda_Name1		ANSI_STRING	DirName
 */
AFPSTATUS FASTCALL
AfpFspDispCreateDir(
	IN	PSDA	pSda
)
{
	AFPSTATUS		Status = AFP_ERR_PARAM, PostStatus;
	PATHMAPENTITY	PME;
	PDFENTRY		pNewDfe;
	FILESYSHANDLE	hNewDir, hAfpInfo;
	AFPINFO			afpinfo;
	PVOLDESC		pVolDesc;		// For post-create processing
	BYTE			PathType;		// -- ditto --
	WCHAR			PathBuf[BIG_PATH_LEN];
	BOOLEAN			InRoot;
	struct _RequestPacket
	{
		PCONNDESC	_pConnDesc;
		DWORD		_ParentId;
	};
	struct _ResponsePacket
	{
		BYTE		__DirId[4];
	};

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_AFPAPI_DIR, DBG_LEVEL_INFO,
										("AfpFspDispCreateDir: Entered\n"));

	ASSERT(VALID_CONNDESC(pReqPkt->_pConnDesc));

	pVolDesc = pReqPkt->_pConnDesc->cds_pVolDesc;

	ASSERT(VALID_VOLDESC(pVolDesc));

	AfpSwmrAcquireExclusive(&pVolDesc->vds_IdDbAccessLock);

	do
	{
		hNewDir.fsh_FileHandle = NULL;
		hAfpInfo.fsh_FileHandle = NULL;
		AfpInitializePME(&PME, sizeof(PathBuf), PathBuf);
		if (!NT_SUCCESS(Status = AfpMapAfpPath(pReqPkt->_pConnDesc,
											   pReqPkt->_ParentId,
											   &pSda->sda_Name1,
											   PathType = pSda->sda_PathType,
											   SoftCreate,
											   DFE_DIR,
											   0,
											   &PME,
											   NULL)))
		{
			break;
		}

		AfpImpersonateClient(pSda);

		InRoot = (PME.pme_ParentPath.Length == 0) ? True : False;
		Status = AfpIoCreate(&pVolDesc->vds_hRootDir,
							AFP_STREAM_DATA,
							&PME.pme_FullPath,
							FILEIO_ACCESS_NONE | FILEIO_ACCESS_DELETE | AFP_OWNER_ACCESS,
							FILEIO_DENY_NONE,
							FILEIO_OPEN_DIR,
							FILEIO_CREATE_SOFT,
							FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_ARCHIVE,
							True,
#ifdef	INHERIT_DIRECTORY_PERMS
							NULL,
#else
							pSda->sda_pSecDesc,
#endif
							&hNewDir,
							NULL,
							pVolDesc,
							&PME.pme_FullPath,
							// we don't get notified of parent mod time changing if
							// there is no handle open for the parent dir at the time
							// of create, which we cannot predict here.
							&PME.pme_ParentPath);

		AfpRevertBack();

		if (!NT_SUCCESS(Status))
		{
			Status = AfpIoConvertNTStatusToAfpStatus(Status);
			break;
		}

#ifdef	INHERIT_DIRECTORY_PERMS
		{
			PFILEDIRPARM pFdParm;

			if ((pFdParm = (PFILEDIRPARM)AfpAllocNonPagedMemory(sizeof(FILEDIRPARM))) != NULL)
			{
				pFdParm->_fdp_OwnerId = pSda->sda_UID;
				pFdParm->_fdp_GroupId = pSda->sda_GID;
				pFdParm->_fdp_OwnerRights = DIR_ACCESS_ALL | DIR_ACCESS_OWNER;
				pFdParm->_fdp_GroupRights = 0;
				pFdParm->_fdp_WorldRights = 0;
				pFdParm->_fdp_Flags = DFE_FLAGS_DIR;

				// Now set the owner and group permissions on this folder
				Status = AfpSetAfpPermissions(hNewDir.fsh_FileHandle,
											  DIR_BITMAP_OWNERID	|
												DIR_BITMAP_GROUPID	|
												DIR_BITMAP_ACCESSRIGHTS,
											  pFdParm);
				AfpFreeMemory(pFdParm);
			}
			else
			{
				Status = AFP_ERR_MISC;
			}

			if (!NT_SUCCESS(Status))
			{
				AfpIoMarkFileForDelete(&hNewDir,
									   pVolDesc,
									   &PME.pme_FullPath,
									   InRoot ? NULL : &PME.pme_ParentPath);
				break;
			}
		}
#endif

		// Add this entry to the IdDb
		pNewDfe = AfpAddDfEntry(pVolDesc,
								PME.pme_pDfeParent,
								&PME.pme_UTail,
								True,
								0);
		if (pNewDfe != NULL)
		{
			// If mac creates a dir we want it to show up as already
			// enumerated in the ID database since new things can only
			// be added after this.
			DFE_MARK_CHILDREN_PRESENT(pNewDfe);
			afpinfo.afpi_Id = pNewDfe->dfe_AfpId;

			// !!!HACK ALERT!!!
			// At this point we are pretty much done i.e. the create has succeeded
			// and we can return doing the rest of the work post-reply. Any errors
			// from now on SHOULD BE IGNORED. Also NO REFERENCE SHOULD BE MADE TO
			// the PSda & pConnDesc. Status should not be changed either. Also
			// reference the Volume for good measure. It cannot fail !!!
			AfpVolumeReference(pVolDesc);

			pSda->sda_ReplySize = SIZE_RESPPKT;
			if ((Status = AfpAllocReplyBuf(pSda)) == AFP_ERR_NONE)
				PUTDWORD2DWORD(pRspPkt->__DirId, pNewDfe->dfe_AfpId);

			AfpCompleteApiProcessing(pSda, Status);
			Status = AFP_ERR_EXTENDED;

			// Create the AfpInfo stream and cache the afpinfo
			if (!NT_SUCCESS(AfpCreateAfpInfoStream(pVolDesc,
												   &hNewDir,
												   afpinfo.afpi_Id,
												   True,
												   NULL,
												   &PME.pme_FullPath,
												   &afpinfo,
												   &hAfpInfo)))
			{
				// If we fail to add the AFP_AfpInfo stream, we must
				// rewind back to the original state.  i.e. delete
				// the directory we just created, and remove it from
				// the Id database.
				AfpIoMarkFileForDelete(&hNewDir,
									   pVolDesc,
									   &PME.pme_FullPath,
									   InRoot ? NULL : &PME.pme_ParentPath);
				AfpDeleteDfEntry(pVolDesc, pNewDfe);
			}
			else
			{
				DWORD			Attr;

				// Get the rest of the File info, and cache it
				PostStatus = AfpIoQueryTimesnAttr(&hNewDir,
												  &pNewDfe->dfe_CreateTime,
												  &pNewDfe->dfe_LastModTime,
												  &Attr);

				ASSERT(NT_SUCCESS(PostStatus));
				if (NT_SUCCESS(PostStatus))
				{
					pNewDfe->dfe_NtAttr = (USHORT)Attr & FILE_ATTRIBUTE_VALID_FLAGS;
					DFE_UPDATE_CACHED_AFPINFO(pNewDfe, &afpinfo);
					AfpVolumeSetModifiedTime(pVolDesc);

					AfpCacheParentModTime(pVolDesc, NULL,
										  &PME.pme_ParentPath,
										  pNewDfe->dfe_Parent,
										  0);
				}
				else
				{
					AfpIoMarkFileForDelete(&hNewDir,
										   pVolDesc,
										   &PME.pme_FullPath,
										   InRoot ? NULL : &PME.pme_ParentPath);
					AfpDeleteDfEntry(pVolDesc, pNewDfe);
				}
			}
		}

		AfpVolumeDereference(pVolDesc);
	} while (False);

	AfpSwmrRelease(&pVolDesc->vds_IdDbAccessLock);

	if (hNewDir.fsh_FileHandle != NULL)
		AfpIoClose(&hNewDir);

	if (hAfpInfo.fsh_FileHandle != NULL)
		AfpIoClose(&hAfpInfo);

	if ((PME.pme_FullPath.Buffer != NULL) &&
		(PME.pme_FullPath.Buffer != PathBuf))
		AfpFreeMemory(PME.pme_FullPath.Buffer);

	return Status;
}


/***	AfpFspDispEnumerate
 *
 *	This is the worker routine for the AfpEnumerate API.
 *
 *	The request packet is represented below.
 *
 *	sda_ReqBlock	PCONNDESC	pConnDesc
 *	sda_ReqBlock	DWORD		ParentId
 *	sda_ReqBlock	DWORD		File Bitmap
 *	sda_ReqBlock	DWORD		Dir Bitmap
 *	sda_ReqBlock	LONG		Request Count
 *	sda_ReqBlock	LONG		Start Index
 *	sda_ReqBlock	LONG		Max Reply Size
 *	sda_Name1		ANSI_STRING	DirName
 */
AFPSTATUS FASTCALL
AfpFspDispEnumerate(
	IN	PSDA	pSda
)
{
	AFPSTATUS		Status = AFP_ERR_PARAM;
	PATHMAPENTITY	PME;
	PVOLDESC		pVolDesc;
	FILEDIRPARM		FDParm;
	DWORD			BitmapF, BitmapD, BitmapI = 0;
	LONG			i = 0, ActCount = 0, ReqCnt = 0;
	PENUMDIR		pEnumDir;
	PEIT			pEit;
	SHORT			CleanupFlags = 0;
	SHORT			BaseLenD = 0, BaseLenF = 0;
	USHORT			SizeUsed;
	BOOLEAN			FreeReplyBuf = False;
	struct _RequestPacket
	{
		PCONNDESC	_pConnDesc;
		DWORD		_ParentId;
		DWORD		_FileBitmap;
		DWORD		_DirBitmap;
		LONG		_ReqCnt;
		LONG		_Index;
		LONG		_ReplySize;
	};
	struct _ResponsePacket
	{
		BYTE		__FileBitmap[2];
		BYTE		__DirBitmap[2];
		BYTE		__EnumCount[2];
	};
	typedef struct _EnumEntityPkt
	{
		BYTE		__Length;
		BYTE		__FileDirFlag;
		// The real parameters follow
	} EEP, *PEEP;
	PEEP		pEep;

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_AFPAPI_DIR, DBG_LEVEL_INFO,
			("AfpFspDispEnumerate: Entered\n"));

	ASSERT(VALID_CONNDESC(pReqPkt->_pConnDesc));

	pVolDesc = pReqPkt->_pConnDesc->cds_pVolDesc;

	ASSERT(VALID_VOLDESC(pVolDesc));

	if ((pReqPkt->_ReqCnt <= 0)		||
		(pReqPkt->_Index <= 0)	    ||
		(pReqPkt->_ReplySize <= 0))
	{
		return AFP_ERR_PARAM;
	}

	BitmapF = pReqPkt->_FileBitmap;
	BitmapD = pReqPkt->_DirBitmap;

	if ((BitmapF == 0) && (BitmapD == 0))
	{
		return AFP_ERR_BITMAP;
	}

	if (BitmapD & DIR_BITMAP_ACCESSRIGHTS)
	{
		BitmapI = FD_INTERNAL_BITMAP_OPENACCESS_READCTRL;
	}

	do
	{
		AfpInitializeFDParms(&FDParm);
		AfpInitializePME(&PME, 0, NULL);

		// This is the size of the buffer needed (plus the name) for enumerating
		// one entity. We do not want to do this many times.
		FDParm._fdp_Flags = DFE_FLAGS_DIR;
		if (BitmapD != 0)
			BaseLenD = ((SHORT)AfpGetFileDirParmsReplyLength(&FDParm, BitmapD) +
																	sizeof(EEP));

		FDParm._fdp_Flags = 0;
		if (BitmapF != 0)
			BaseLenF = ((SHORT)AfpGetFileDirParmsReplyLength(&FDParm, BitmapF) +
																	sizeof(EEP));

		if ((Status = AfpEnumerate(pReqPkt->_pConnDesc,
								   pReqPkt->_ParentId,
								   &pSda->sda_Name1,
								   BitmapF,
								   BitmapD,
								   pSda->sda_PathType,
								   0,
								   &pEnumDir)) != AFP_ERR_NONE)
			break;

		if (pEnumDir->ed_ChildCount < pReqPkt->_Index)
		{
			Status = AFP_ERR_OBJECT_NOT_FOUND;
			break;
		}

		ReqCnt = (DWORD)pReqPkt->_ReqCnt;
		if (ReqCnt > (pEnumDir->ed_ChildCount - pEnumDir->ed_BadCount - pReqPkt->_Index + 1))
			ReqCnt = (pEnumDir->ed_ChildCount - pEnumDir->ed_BadCount - pReqPkt->_Index + 1);

		// We have enumerated the directory and now have afp ids of all the
		// children. Allocate the reply buffer
		pSda->sda_ReplySize = (USHORT)pReqPkt->_ReplySize;

        AfpIOAllocBackFillBuffer(pSda);
		if (pSda->sda_ReplyBuf == NULL)
		{
			pSda->sda_ReplySize = 0;
			Status = AFP_ERR_MISC;
			break;
		}

#if DBG
        AfpPutGuardSignature(pSda);
#endif

		FreeReplyBuf = True;
		pEep = (PEEP)(pSda->sda_ReplyBuf + SIZE_RESPPKT);

		// For each of the enumerated entities, get the requested parameters
		// and pack it in the replybuf.
		// We also do not want to impersonate the user here. A Mac user expects
		// to see belted items as opposed to invisible ones.
		SizeUsed = SIZE_RESPPKT;
		pEit = &pEnumDir->ed_pEit[pReqPkt->_Index + pEnumDir->ed_BadCount - 1];
		for (i = 0, ActCount = 0; (i < ReqCnt); i++, pEit++)
		{
			SHORT	Len;
			DWORD	Bitmap;
			BOOLEAN	NeedHandle = False;

			Bitmap = BitmapF;
			Len = BaseLenF;

			if (pEit->eit_Flags & DFE_DIR)
			{
				Bitmap = BitmapD | BitmapI;
				Len = BaseLenD;
				if (IS_VOLUME_NTFS(pVolDesc) &&
					(Bitmap & (DIR_BITMAP_ACCESSRIGHTS |
							  DIR_BITMAP_OWNERID |
							  DIR_BITMAP_GROUPID)))
				{
					NeedHandle = True;
				}
			}

			FDParm._fdp_LongName.Length = FDParm._fdp_ShortName.Length = 0;

			Status = AfpMapAfpIdForLookup(pReqPkt->_pConnDesc,
										  pEit->eit_Id,
										  pEit->eit_Flags,
										  Bitmap |
											FD_BITMAP_ATTR |
											FD_INTERNAL_BITMAP_SKIP_IMPERSONATION,
										  NeedHandle ? &PME : NULL,
										  &FDParm);

			// This can fail if the enitity gets deleted in the interim or if the
			// user has no access to this entity.
			// An error here should not be treated as such.
			// Reset the Status to none since we do not want to fall out
			// with this error code
			if (!NT_SUCCESS(Status))
			{
				DBGPRINT(DBG_COMP_AFPAPI_DIR, DBG_LEVEL_ERR,
						("AfpFspDispEnumerate: Dropping id %ld\n", pEit->eit_Id));
				pEnumDir->ed_BadCount ++;
				Status = AFP_ERR_NONE;
				continue;
			}

			if (NeedHandle)
			{
				AfpIoClose(&PME.pme_Handle);	// Close the handle to the entity
			}

			Bitmap &= ~BitmapI;

			if (Bitmap & FD_BITMAP_LONGNAME)
				Len += FDParm._fdp_LongName.Length;
			if (Bitmap & FD_BITMAP_SHORTNAME)
				Len += FDParm._fdp_ShortName.Length;
			Len = EVENALIGN(Len);

			if (Len > (pSda->sda_ReplySize - SizeUsed))
			{
				if (SizeUsed == SIZE_RESPPKT)
				{
					Status = AFP_ERR_PARAM;
				}
				break;
			}

			PUTSHORT2BYTE(&pEep->__Length, Len);
			pEep->__FileDirFlag = IsDir(&FDParm) ?
									FILEDIR_FLAG_DIR : FILEDIR_FLAG_FILE;

			AfpPackFileDirParms(&FDParm, Bitmap, (PBYTE)pEep + sizeof(EEP));

			pEep = (PEEP)((PBYTE)pEep + Len);
			SizeUsed += Len;
			ActCount ++;
		}

		if (Status == AFP_ERR_NONE)
			FreeReplyBuf = False;
	} while (False);

	if (FreeReplyBuf || (ActCount == 0))
	{
        AfpIOFreeBackFillBuffer(pSda);
	}

	if (Status == AFP_ERR_NONE)
	{
		if (ActCount > 0)
		{
			PUTSHORT2SHORT(&pRspPkt->__FileBitmap, BitmapF);
			PUTSHORT2SHORT(&pRspPkt->__DirBitmap,  BitmapD);
			PUTSHORT2SHORT(&pRspPkt->__EnumCount,  ActCount);
			pSda->sda_ReplySize = SizeUsed;
		}
		else Status = AFP_ERR_OBJECT_NOT_FOUND;
	}

	if (Status != AFP_ERR_NONE)
	{
		if (pReqPkt->_pConnDesc->cds_pEnumDir != NULL)
		{
			AfpFreeMemory(pReqPkt->_pConnDesc->cds_pEnumDir);
			pReqPkt->_pConnDesc->cds_pEnumDir = NULL;
		}
	}
	return Status;
}



/***	AfpFspDispSetDirParms
 *
 *	This is the worker routine for the AfpSetDirParms API.
 *
 *	The request packet is represented below.
 *
 *	sda_ReqBlock	PCONNDESC	pConnDesc
 *	sda_ReqBlock	DWORD		ParentId
 *	sda_ReqBlock	DWORD		Dir Bitmap
 *	sda_Name1		ANSI_STRING	Path
 *	sda_Name2		BLOCK		Dir Parameters
 */
AFPSTATUS FASTCALL
AfpFspDispSetDirParms(
	IN	PSDA	pSda
)
{
	FILEDIRPARM		FDParm;
	PATHMAPENTITY	PME, PMEfile;
	PVOLDESC		pVolDesc;
	WCHAR			PathBuf[BIG_PATH_LEN];
	DWORD			Bitmap,
					BitmapI = FD_INTERNAL_BITMAP_RETURN_PMEPATHS |
							  FD_INTERNAL_BITMAP_OPENACCESS_RW_ATTR;
	AFPSTATUS		Status = AFP_ERR_PARAM;
	struct _RequestPacket
	{
		PCONNDESC	_pConnDesc;
		DWORD		_ParentId;
		DWORD		_Bitmap;
	};

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_AFPAPI_DIR, DBG_LEVEL_INFO,
										("AfpFspDispSetDirParms: Entered\n"));

	ASSERT(VALID_CONNDESC(pReqPkt->_pConnDesc));

	pVolDesc = pReqPkt->_pConnDesc->cds_pVolDesc;

	ASSERT(VALID_VOLDESC(pVolDesc));

	Bitmap = pReqPkt->_Bitmap;

	AfpInitializeFDParms(&FDParm);
	AfpInitializePME(&PME, sizeof(PathBuf), PathBuf);

	do
	{
		if (Bitmap & (DIR_BITMAP_OWNERID |
					  DIR_BITMAP_GROUPID |
					  DIR_BITMAP_ACCESSRIGHTS |
					  FD_BITMAP_ATTR))
		{
			BitmapI |= (pSda->sda_ClientType == SDA_CLIENT_ADMIN) ?

						(FD_INTERNAL_BITMAP_OPENACCESS_ADMINSET |
						 DIR_BITMAP_OFFSPRINGS |
						 FD_INTERNAL_BITMAP_RETURN_PMEPATHS) :

						(FD_INTERNAL_BITMAP_OPENACCESS_RWCTRL |
						 FD_INTERNAL_BITMAP_RETURN_PMEPATHS |
						 DIR_BITMAP_OFFSPRINGS |
						 DIR_BITMAP_DIRID |
						 DIR_BITMAP_ACCESSRIGHTS |
						 DIR_BITMAP_OWNERID |
						 DIR_BITMAP_GROUPID);
		}

		Status = AfpMapAfpPathForLookup(pReqPkt->_pConnDesc,
										pReqPkt->_ParentId,
										&pSda->sda_Name1,
										pSda->sda_PathType,
										DFE_DIR,
										Bitmap | BitmapI,
										&PME,
										&FDParm);

		if (!NT_SUCCESS(Status))
		{
			PME.pme_Handle.fsh_FileHandle = NULL;
			break;
		}

		// Check for Network Trash Folder and do not change its permissions
		if ((FDParm._fdp_AfpId == AFP_ID_NETWORK_TRASH) &&
			(Bitmap & (DIR_BITMAP_OWNERID |
						DIR_BITMAP_GROUPID |
						DIR_BITMAP_ACCESSRIGHTS)))
		{
			Bitmap &= ~(DIR_BITMAP_OWNERID |
						DIR_BITMAP_GROUPID |
						DIR_BITMAP_ACCESSRIGHTS);
			if (Bitmap == 0)
			{
				// We are not setting anything else, return success
				Status = STATUS_SUCCESS;
				break;
			}
		}

		// Make sure user has the necessary rights to change any of this
		if (pSda->sda_ClientType == SDA_CLIENT_ADMIN)
		{
			FDParm._fdp_UserRights = DIR_ACCESS_ALL | DIR_ACCESS_OWNER;
		}
		// If attributes are to be set, the check for access is done during unpacking
		else if	((Bitmap & (DIR_BITMAP_OWNERID |
							DIR_BITMAP_GROUPID |
							DIR_BITMAP_ACCESSRIGHTS)) &&
				 !(FDParm._fdp_UserRights & DIR_ACCESS_OWNER))
		{
			Status = AFP_ERR_ACCESS_DENIED;
			break;
		}

		if ((Status = AfpUnpackFileDirParms(pSda->sda_Name2.Buffer,
										    (LONG)pSda->sda_Name2.Length,
										    &Bitmap,
										    &FDParm)) != AFP_ERR_NONE)
			break;

		if (Bitmap != 0)
		{
			if ((Bitmap & FD_BITMAP_ATTR) &&
				(FDParm._fdp_Attr & (FILE_BITMAP_ATTR_MULTIUSER |
									 FILE_BITMAP_ATTR_DATAOPEN	|
									 FILE_BITMAP_ATTR_RESCOPEN	|
									 FILE_BITMAP_ATTR_COPYPROT)))
			{
				Status = AFP_ERR_PARAM;
				break;
			}

			Status = AfpSetFileDirParms(pVolDesc,
										&PME,
										Bitmap,
										&FDParm);
			if (!NT_SUCCESS(Status))
			{
				DBGPRINT(DBG_COMP_AFPAPI_DIR, DBG_LEVEL_INFO,
						("AfpFspDispSetDirParms: AfpSetFileDirParms returned %ld\n", Status));
				break;
			}

			// Close the directory handle
			AfpIoClose(&PME.pme_Handle);

			// If any permissions are being changed, then apply them to all files within
			// this directory. Start off by enumerating the files in the directory and
			// then walk the list applying to each individual file.
			if ((Bitmap & (DIR_BITMAP_OWNERID |
						   DIR_BITMAP_GROUPID |
						   DIR_BITMAP_ACCESSRIGHTS)) &&
				(FDParm._fdp_FileCount != 0))
			{
				PENUMDIR		pEnumDir;
				PEIT			pEit;
				FILEDIRPARM		FileParm;
				ANSI_STRING		DummyName;
				LONG			i;

				// Do not treat any of the following as errors from now on.
				// Quitely terminate
				AfpInitializeFDParms(&FileParm);

				AfpSetEmptyAnsiString(&DummyName, 1, "");
				if (AfpEnumerate(pReqPkt->_pConnDesc,
								 FDParm._fdp_AfpId,
								 &DummyName,
								 1,				// Some non-zero value
								 0,
								 AFP_LONGNAME,
								 DFE_FILE,
								 &pEnumDir) != AFP_ERR_NONE)
					break;

				FDParm._fdp_Flags &= ~DFE_FLAGS_DIR;
				AfpInitializePME(&PMEfile, 0, NULL);
				for (i = 0, pEit = &pEnumDir->ed_pEit[0];
					 i < pEnumDir->ed_ChildCount; i++, pEit++)
				{
					AFPSTATUS		Rc;

					Rc = AfpMapAfpIdForLookup(pReqPkt->_pConnDesc,
											pEit->eit_Id,
											DFE_FILE,
											FD_INTERNAL_BITMAP_OPENACCESS_RWCTRL |
															FD_BITMAP_LONGNAME,
											&PMEfile,
											&FileParm);

					DBGPRINT(DBG_COMP_AFPAPI_DIR, DBG_LEVEL_INFO,
							("AfpFspDispSetDirParms: AfpMapAfpIdForLookup returned %ld\n", Rc));

					if (Rc != AFP_ERR_NONE)
						continue;

					AfpSetAfpPermissions(PMEfile.pme_Handle.fsh_FileHandle,
										 Bitmap,
										 &FDParm);

					AfpIoClose(&PMEfile.pme_Handle);

					DBGPRINT(DBG_COMP_AFPAPI_DIR, DBG_LEVEL_INFO,
							("AfpFspDispSetDirParms: AfpSetAfpPermissions returned %ld\n", Rc));
				}
				if (pReqPkt->_pConnDesc->cds_pEnumDir != NULL)
				{
					AfpFreeMemory(pReqPkt->_pConnDesc->cds_pEnumDir);
					pReqPkt->_pConnDesc->cds_pEnumDir = NULL;
				}
			}
		}
	} while (False);

	// NOTE: This is also called by the admin side so do not try the early reply trick
	//		 here. If it does get important to do it, then check for client type.
	if (PME.pme_Handle.fsh_FileHandle != NULL)
		AfpIoClose(&PME.pme_Handle);

	if ((PME.pme_FullPath.Buffer != NULL) &&
		(PME.pme_FullPath.Buffer != PathBuf))
	{
		AfpFreeMemory(PME.pme_FullPath.Buffer);
	}

	return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\server\fsp_fd.c ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	fsp_fd.c

Abstract:

	This module contains the entry points for the AFP file-dir APIs queued to
	the FSP. These are all callable from FSP Only.

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	25 Apr 1992		Initial Version

Notes:	Tab stop: 4
--*/

#define	FILENUM	FILE_FSP_FD

#include <afp.h>
#include <gendisp.h>
#include <fdparm.h>
#include <pathmap.h>
#include <client.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, AfpFspDispGetFileDirParms)
#pragma alloc_text( PAGE, AfpFspDispSetFileDirParms)
#pragma alloc_text( PAGE, AfpFspDispDelete)
#pragma alloc_text( PAGE, AfpFspDispRename)
#pragma alloc_text( PAGE, AfpFspDispMoveAndRename)
#pragma alloc_text( PAGE, AfpFspDispCatSearch)
#endif

/***	AfpFspDispGetFileDirParms
 *
 *	This is the worker routine for the AfpGetFileDirParms API.
 *
 *	The request packet is represented below
 *
 *	sda_ReqBlock	PCONNDESC	pConnDesc
 *	sda_ReqBlock	DWORD		ParentId
 *	sda_ReqBlock	DWORD		File Bitmap
 *	sda_ReqBlock	DWORD		Dir Bitmap
 *	sda_Name1		ANSI_STRING	Path
 */
AFPSTATUS FASTCALL
AfpFspDispGetFileDirParms(
	IN	PSDA	pSda
)
{
	FILEDIRPARM		FDParm;
	PATHMAPENTITY	PME;
	BOOLEAN			NeedHandle = False;
	PVOLDESC		pVolDesc;
	DWORD			BitmapF, BitmapD, BitmapI = 0;
	AFPSTATUS		Status = AFP_ERR_PARAM;
	struct _RequestPacket
	{
		PCONNDESC	_pConnDesc;
		DWORD		_ParentId;
		DWORD		_FileBitmap;
		DWORD		_DirBitmap;
	};
	struct _ResponsePacket
	{
		BYTE	__FileBitmap[2];
		BYTE	__DirBitmap[2];
		BYTE	__FileDirFlag;
		BYTE	__Pad;
	};

	PAGED_CODE();

	DBGPRINT(DBG_COMP_AFPAPI_FD, DBG_LEVEL_INFO,
			("AfpFspDispGetFileDirParms: Entered\n"));

	ASSERT(VALID_CONNDESC(pReqPkt->_pConnDesc));

	pVolDesc = pReqPkt->_pConnDesc->cds_pVolDesc;

	ASSERT(VALID_VOLDESC(pVolDesc));
	
	BitmapF = pReqPkt->_FileBitmap;
	BitmapD = pReqPkt->_DirBitmap;

	do
	{
		AfpInitializeFDParms(&FDParm);
		AfpInitializePME(&PME, 0, NULL);
		if (IS_VOLUME_NTFS(pVolDesc) &&
			(BitmapD & (DIR_BITMAP_ACCESSRIGHTS |
					    DIR_BITMAP_OWNERID |
					    DIR_BITMAP_GROUPID)))
		{
			NeedHandle = True;
		}

		if (BitmapD & DIR_BITMAP_ACCESSRIGHTS)
		{
			BitmapI = FD_INTERNAL_BITMAP_OPENACCESS_READCTRL;
		}


		if ((Status = AfpMapAfpPathForLookup(pReqPkt->_pConnDesc,
											 pReqPkt->_ParentId,
											 &pSda->sda_Name1,
											 pSda->sda_PathType,
											 DFE_ANY,
											 BitmapF | BitmapD | BitmapI,
											 NeedHandle ? &PME : NULL,
											 &FDParm)) != AFP_ERR_NONE)
		{
			PME.pme_Handle.fsh_FileHandle = NULL;
			break;
		}

		pSda->sda_ReplySize = SIZE_RESPPKT +
					  EVENALIGN(AfpGetFileDirParmsReplyLength(&FDParm,
									IsDir(&FDParm) ? BitmapD : BitmapF));
	
		if ((Status = AfpAllocReplyBuf(pSda)) == AFP_ERR_NONE)
		{
			AfpPackFileDirParms(&FDParm,
								IsDir(&FDParm) ? BitmapD : BitmapF,
								pSda->sda_ReplyBuf + SIZE_RESPPKT);
			PUTDWORD2SHORT(&pRspPkt->__FileBitmap, BitmapF);
			PUTDWORD2SHORT(&pRspPkt->__DirBitmap, BitmapD);
			pRspPkt->__FileDirFlag = IsDir(&FDParm) ?
										FILEDIR_FLAG_DIR : FILEDIR_FLAG_FILE;
			pRspPkt->__Pad = 0;
		}
	} while (False);
	
	// Return before we close thus saving some time
	AfpCompleteApiProcessing(pSda, Status);

	if (NeedHandle && (PME.pme_Handle.fsh_FileHandle != NULL))
		AfpIoClose(&PME.pme_Handle);	// Close the handle to the entity

	return AFP_ERR_EXTENDED;
}



/***	AfpFspDispSetFileDirParms
 *
 *	This is the worker routine for the AfpSetFileDirParms API.
 *
 *	The request packet is represented below
 *
 *	sda_ReqBlock	PCONNDESC	pConnDesc
 *	sda_ReqBlock	DWORD		ParentId
 *	sda_ReqBlock	DWORD		File or Directory Bitmap
 *	sda_Name1		ANSI_STRING	Path
 *	sda_Name2		BLOCK		File or Directory parameters
 */
AFPSTATUS FASTCALL
AfpFspDispSetFileDirParms(
	IN	PSDA	pSda
)
{
	PATHMAPENTITY	PME;
	PVOLDESC		pVolDesc;
	FILEDIRPARM		FDParm;
	DWORD			Bitmap, BitmapI;
	AFPSTATUS		Status = AFP_ERR_PARAM;
	WCHAR			PathBuf[BIG_PATH_LEN];
	struct _RequestPacket
	{
		PCONNDESC	_pConnDesc;
		DWORD		_ParentId;
		DWORD		_Bitmap;
	};

	PAGED_CODE();

	DBGPRINT(DBG_COMP_AFPAPI_FD, DBG_LEVEL_INFO,
			("AfpFspDispSetFileDirParms: Entered\n"));

	ASSERT(VALID_CONNDESC(pReqPkt->_pConnDesc));

	pVolDesc = pReqPkt->_pConnDesc->cds_pVolDesc;

	ASSERT(VALID_VOLDESC(pVolDesc));
	
	Bitmap = pReqPkt->_Bitmap;

	// Force the FD_BITMAP_LONGNAME in case a *file* is missing the afpinfo
	// stream we will be able to generate the correct type/creator in
	// AfpSetAfpInfo
	BitmapI = FD_INTERNAL_BITMAP_OPENACCESS_RW_ATTR |
			  FD_BITMAP_LONGNAME |
			  FD_INTERNAL_BITMAP_RETURN_PMEPATHS;

	// For a directory only the owner can change certain attributes like the
	// various inhibit bits. Check for access if an attempt is made to modify
	// any of these bits. We do not know at this point whether any of these
	// attributes are being set/cleared yet !!!
	if (Bitmap & FD_BITMAP_ATTR)
		BitmapI = FD_INTERNAL_BITMAP_OPENACCESS_READCTRL|
				  FD_BITMAP_LONGNAME 					|
				  DIR_BITMAP_OWNERID 					|
				  DIR_BITMAP_GROUPID 					|
				  DIR_BITMAP_ACCESSRIGHTS				|
				  FD_INTERNAL_BITMAP_RETURN_PMEPATHS;

	AfpInitializeFDParms(&FDParm);
	AfpInitializePME(&PME, sizeof(PathBuf), PathBuf);

	do
	{
		Status = AfpMapAfpPathForLookup(pReqPkt->_pConnDesc,
										pReqPkt->_ParentId,
										&pSda->sda_Name1,
										pSda->sda_PathType,
										DFE_ANY,
										Bitmap | BitmapI,
										&PME,
										&FDParm);

		if (!NT_SUCCESS(Status))
		{
			PME.pme_Handle.fsh_FileHandle = NULL;
			break;
		}

		if ((Status = AfpUnpackFileDirParms(pSda->sda_Name2.Buffer,
										   (LONG)pSda->sda_Name2.Length,
										   &Bitmap,
										   &FDParm)) != AFP_ERR_NONE)
			break;

		if (Bitmap != 0)
		{
			// Make sure they are not trying to set/clear any attributes
			// that are not common to both files and directories
			if ((Bitmap & FD_BITMAP_ATTR) &&
				(FDParm._fdp_Attr & ~(FD_BITMAP_ATTR_SET		|
									  FD_BITMAP_ATTR_INVISIBLE	|
									  FD_BITMAP_ATTR_DELETEINH	|
									  FILE_BITMAP_ATTR_WRITEINH	|
									  FD_BITMAP_ATTR_RENAMEINH	|
									  FD_BITMAP_ATTR_SYSTEM)))
			{
				Status = AFP_ERR_PARAM;
				break;
			}
			Status = AfpSetFileDirParms(pVolDesc,
										&PME,
										Bitmap,
										&FDParm);
		}
	} while (False);
	
	// Return before we close thus saving some time
	AfpCompleteApiProcessing(pSda, Status);

	if (PME.pme_Handle.fsh_FileHandle != NULL)
		AfpIoClose(&PME.pme_Handle);

	if ((PME.pme_FullPath.Buffer != NULL) &&
		(PME.pme_FullPath.Buffer != PathBuf))
	{
		AfpFreeMemory(PME.pme_FullPath.Buffer);
	}

	return AFP_ERR_EXTENDED;
}



/***	AfpFspDispDelete
 *
 *	This is the worker routine for the AfpDelete API.  Deleting an open file
 *  or a directory that is not empty is not permitted under AFP.
 *
 *	The request packet is represented below
 *
 *	sda_ReqBlock	PCONNDESC	pConnDesc
 *	sda_ReqBlock	DWORD		ParentId
 *	sda_Name1		ANSI_STRING	Path
 */
AFPSTATUS FASTCALL
AfpFspDispDelete(
	IN	PSDA	pSda
)
{
	PATHMAPENTITY	PME;
	PVOLDESC		pVolDesc;
    PCONNDESC       pConnDesc;
	FILEDIRPARM		FDParm;
	DWORD			Bitmap, NTAttr;
	AFPSTATUS		Status = AFP_ERR_PARAM;
	FILESYSHANDLE	hParent;
	WCHAR			PathBuf[BIG_PATH_LEN];
	BOOLEAN			InRoot;
	struct _RequestPacket
	{
		PCONNDESC	_pConnDesc;
		DWORD		_ParentId;
	};

	PAGED_CODE();

	DBGPRINT(DBG_COMP_AFPAPI_FD, DBG_LEVEL_INFO,
										("AfpFspDispDelete: Entered\n"));

	ASSERT(VALID_CONNDESC(pReqPkt->_pConnDesc));
    pConnDesc = pReqPkt->_pConnDesc;

	pVolDesc = pReqPkt->_pConnDesc->cds_pVolDesc;

	ASSERT(VALID_VOLDESC(pVolDesc));
	
	AfpInitializeFDParms(&FDParm);
	AfpInitializePME(&PME, sizeof(PathBuf), PathBuf);
	Bitmap = FD_BITMAP_ATTR | FD_INTERNAL_BITMAP_OPENACCESS_DELETE;

	AfpSwmrAcquireExclusive(&pVolDesc->vds_IdDbAccessLock);

	do
	{
		hParent.fsh_FileHandle = NULL;
		if (!NT_SUCCESS(Status = AfpMapAfpPath(pReqPkt->_pConnDesc,
											   pReqPkt->_ParentId,
											   &pSda->sda_Name1,
											   pSda->sda_PathType,
											   Lookup,
											   DFE_ANY,
											   Bitmap,
											   &PME,
											   &FDParm)))
		{
			PME.pme_Handle.fsh_FileHandle = NULL;
			break;
		}

		if ((FDParm._fdp_AfpId == AFP_ID_ROOT) ||
			(FDParm._fdp_AfpId == AFP_ID_NETWORK_TRASH))
		{
			Status = AFP_ERR_ACCESS_DENIED;
			break;
		}

		if (FDParm._fdp_Attr & (FILE_BITMAP_ATTR_DATAOPEN | FILE_BITMAP_ATTR_RESCOPEN))
		{
			ASSERT(!(FDParm._fdp_Flags & DFE_FLAGS_DIR));
			Status = AFP_ERR_FILE_BUSY;	// Cannot delete an open file
			break;
		}

		if (!NT_SUCCESS(Status = AfpCheckForInhibit(&PME.pme_Handle,
													FD_BITMAP_ATTR_DELETEINH,
													FDParm._fdp_Attr,
													&NTAttr)))
		{
			break;
		}

		// Check for SeeFiles or SeeFolders on the parent dir
		if (!NT_SUCCESS(Status = AfpCheckParentPermissions(pReqPkt->_pConnDesc,
														   FDParm._fdp_ParentId,
														   &PME.pme_ParentPath,
														   (FDParm._fdp_Flags & DFE_FLAGS_DIR) ?
														   		DIR_ACCESS_SEARCH : DIR_ACCESS_READ,
														   &hParent,
														   NULL)))
		{
			break;
		}

		if (NTAttr & FILE_ATTRIBUTE_READONLY)
		{
			// We must remove the ReadOnly attribute to delete the file/dir
			Status = AfpIoSetTimesnAttr(&PME.pme_Handle,
										NULL,
										NULL,
										0,
										FILE_ATTRIBUTE_READONLY,
										pVolDesc,
										&PME.pme_FullPath);
		}

		if (NT_SUCCESS(Status))
		{
			InRoot = (PME.pme_ParentPath.Length == 0) ? True : False;
			Status = AfpIoMarkFileForDelete(&PME.pme_Handle,
											pVolDesc,
											&PME.pme_FullPath,
											InRoot ? NULL : &PME.pme_ParentPath);

			if (!NT_SUCCESS(Status))
			{
				Status = AfpIoConvertNTStatusToAfpStatus(Status);
			}

			// !!! HACK ALERT !!!
			// At this point we are pretty much done i.e. the delete has either
			// succeeded or failed and we can return doing the rest of the work
			// post-reply. Any errors from now on SHOULD BE IGNORED. Also NO
			// REFERENCE SHOULD BE MADE TO the pSda & pConnDesc. Status should
			// not be changed either. Also reference the Volume for good measure.
			// It cannot fail !!!
			AfpVolumeReference(pVolDesc);

			AfpCompleteApiProcessing(pSda, Status);

			if (NT_SUCCESS(Status)) // Delete succeeded
			{
				ASSERT(VALID_DFE(PME.pme_pDfEntry));
				ASSERT(PME.pme_pDfEntry->dfe_AfpId == FDParm._fdp_AfpId);
				AfpDeleteDfEntry(pVolDesc, PME.pme_pDfEntry);
				AfpIoClose(&PME.pme_Handle);
				AfpCacheParentModTime(pVolDesc,
									  &hParent,
									  NULL,
									  NULL,
									  FDParm._fdp_ParentId);
			}
			else if (NTAttr & FILE_ATTRIBUTE_READONLY) // Delete failed
			{
				// Set the ReadOnly attribute back on the file/dir if need be
				Status = AfpIoSetTimesnAttr(&PME.pme_Handle,
											NULL,
											NULL,
											FILE_ATTRIBUTE_READONLY,
											0,
											pVolDesc,
											&PME.pme_FullPath);
				ASSERT(NT_SUCCESS(Status));
			}
			Status = AFP_ERR_EXTENDED;
		}
		ASSERT (Status == AFP_ERR_EXTENDED);
		AfpVolumeDereference(pVolDesc);
	} while (False);

	// Close file handle so file really gets deleted before mac can come
	// back in with another request using same filename (like create)
	if (PME.pme_Handle.fsh_FileHandle != NULL)
		AfpIoClose(&PME.pme_Handle);
	
	AfpSwmrRelease(&pVolDesc->vds_IdDbAccessLock);

	if (hParent.fsh_FileHandle != NULL)
		AfpIoClose(&hParent);

	if ((PME.pme_FullPath.Buffer != NULL) &&
		(PME.pme_FullPath.Buffer != PathBuf))
	{
		AfpFreeMemory(PME.pme_FullPath.Buffer);
	}

	return Status;
}



/***	AfpFspDispRename
 *
 *	This is the worker routine for the AfpRename API.  Renaming a file does
 *  NOT provoke a new Extension-Type/Creator mapping.  Renaming an open file
 *  is permitted under AFP.
 *
 *	The request packet is represented below
 *
 *	sda_ReqBlock	PCONNDESC	pConnDesc
 *	sda_ReqBlock	DWORD		ParentId
 *	sda_Name1		ANSI_STRING	Path
 *	sda_Name2		ANSI_STRING	New name
 */
AFPSTATUS FASTCALL
AfpFspDispRename(
	IN	PSDA	pSda
)
{
	PATHMAPENTITY	PME;
	PVOLDESC		pVolDesc;
	FILEDIRPARM		FDParm;
	DWORD			Bitmap, NTAttr;
	AFPSTATUS		Status = AFP_ERR_PARAM;
	UNICODE_STRING	uNewName;
	WCHAR			wcbuf[AFP_FILENAME_LEN+1];
	WCHAR			PathBuf[BIG_PATH_LEN];
	PDFENTRY		pDfEntry;
	FILESYSHANDLE 	hParent;
	BOOLEAN			InRoot;
	struct _RequestPacket
	{
		PCONNDESC	_pConnDesc;
		DWORD		_ParentId;
	};

	PAGED_CODE();

	DBGPRINT(DBG_COMP_AFPAPI_FD, DBG_LEVEL_INFO,
			("AfpFspDispRename: Entered\n"));

	ASSERT(VALID_CONNDESC(pReqPkt->_pConnDesc));

	pVolDesc = pReqPkt->_pConnDesc->cds_pVolDesc;

	ASSERT(VALID_VOLDESC(pVolDesc));
	
	AfpInitializeFDParms(&FDParm);
	AfpInitializePME(&PME, sizeof(PathBuf), PathBuf);
	AfpSetEmptyUnicodeString(&uNewName, sizeof(wcbuf), wcbuf);

	Bitmap = FD_BITMAP_ATTR | FD_INTERNAL_BITMAP_OPENACCESS_DELETE;
	hParent.fsh_FileHandle = NULL;
		
	AfpSwmrAcquireExclusive(&pVolDesc->vds_IdDbAccessLock);

	do
	{
		// Make sure the new name is not a null string or too long
		if ((pSda->sda_Name2.Length == 0) ||
			(pSda->sda_Name2.Length > AFP_FILENAME_LEN) ||
			((pSda->sda_PathType == AFP_SHORTNAME) &&
			 !AfpIsLegalShortname(&pSda->sda_Name2)) ||
			(!NT_SUCCESS(AfpConvertStringToMungedUnicode(&pSda->sda_Name2,
														 &uNewName))))
			break;

		if (!NT_SUCCESS(Status = AfpMapAfpPath(pReqPkt->_pConnDesc,
											   pReqPkt->_ParentId,
											   &pSda->sda_Name1,
											   pSda->sda_PathType,
											   Lookup,
											   DFE_ANY,
											   Bitmap,
											   &PME,
											   &FDParm)))
		{
			PME.pme_Handle.fsh_FileHandle = NULL;
			break;
		}

		if ((FDParm._fdp_AfpId == AFP_ID_ROOT) ||
			(FDParm._fdp_AfpId == AFP_ID_NETWORK_TRASH))
		{
			Status = AFP_ERR_CANT_RENAME;
			break;
		}

		// Check if the RO bit is on & retain the mod time
		if (!NT_SUCCESS(Status = AfpCheckForInhibit(&PME.pme_Handle,
													FD_BITMAP_ATTR_RENAMEINH,
													FDParm._fdp_Attr,
													&NTAttr)))
		{
			break;
		}

		// Check for SeeFiles or SeeFolders on the parent dir
		if (!NT_SUCCESS(Status = AfpCheckParentPermissions(pReqPkt->_pConnDesc,
														   FDParm._fdp_ParentId,
														   &PME.pme_ParentPath,
														   (FDParm._fdp_Flags & DFE_FLAGS_DIR) ?
														   DIR_ACCESS_SEARCH : DIR_ACCESS_READ,
														   &hParent,
														   NULL)))
		{
			break;
		}

		if (NTAttr & FILE_ATTRIBUTE_READONLY)
		{
			// We must temporarily remove the ReadOnly attribute so that
			// we can rename the file/dir
			Status = AfpIoSetTimesnAttr(&PME.pme_Handle,
										NULL,
										NULL,
										0,
										FILE_ATTRIBUTE_READONLY,
										pVolDesc,
										&PME.pme_FullPath);
		}

		if (NT_SUCCESS(Status))
		{
			// We must impersonate to do the rename since it is name based
			AfpImpersonateClient(pSda);

			InRoot = (PME.pme_ParentPath.Length == 0) ? True : False;
			Status = AfpIoMoveAndOrRename(&PME.pme_Handle,
										  NULL,
										  &uNewName,
										  pVolDesc,
										  &PME.pme_FullPath,
										  InRoot ? NULL : &PME.pme_ParentPath,
										  NULL,
										  NULL);

			AfpRevertBack();

			if (NT_SUCCESS(Status))	// Rename succeeded
			{
				if ((pDfEntry = AfpFindDfEntryById(pVolDesc,
												   FDParm._fdp_AfpId,
												   DFE_ANY)) != NULL)
				{
					ASSERT(((pDfEntry->dfe_Flags & DFE_FLAGS_DFBITS) &
							FDParm._fdp_Flags) != 0);
					pDfEntry = AfpRenameDfEntry(pVolDesc,
												pDfEntry,
												&uNewName);
					if (pDfEntry == NULL)
					{
						// We could not rename the id entry, so
						// just delete it, and hope the parent dir
						// gets enumerated again
						// NOTE: How will the parent directory
						//	 get re-enumerated now ?
						ASSERT(VALID_DFE(PME.pme_pDfEntry));
						ASSERT(PME.pme_pDfEntry->dfe_AfpId == FDParm._fdp_AfpId);
						AfpDeleteDfEntry(pVolDesc, PME.pme_pDfEntry);
						Status = AFP_ERR_MISC;	// Out of memory
					}
					else
					{
						AfpCacheParentModTime(pVolDesc,
											  &hParent,
											  NULL,
											  pDfEntry->dfe_Parent,
											  0);
					}
				}
			}
		}
		else
		{
			Status = AFP_ERR_MISC;	// Could not delete ReadOnly attribute
			break;
		}

		// Set the ReadOnly attribute back on the file/dir if need be.
		if (NTAttr & FILE_ATTRIBUTE_READONLY)
			AfpIoSetTimesnAttr(&PME.pme_Handle,
								NULL,
								NULL,
								FILE_ATTRIBUTE_READONLY,
								0,
								pVolDesc,
								&PME.pme_FullPath);
	} while (False);

	// Return before we close thus saving some time
	AfpCompleteApiProcessing(pSda, Status);

	if (PME.pme_Handle.fsh_FileHandle != NULL)
		AfpIoClose(&PME.pme_Handle);

	if (hParent.fsh_FileHandle != NULL)
	{
		AfpIoClose(&hParent);
	}

	AfpSwmrRelease(&pVolDesc->vds_IdDbAccessLock);

	if ((PME.pme_FullPath.Buffer != NULL) &&
		(PME.pme_FullPath.Buffer != PathBuf))
	{
		AfpFreeMemory(PME.pme_FullPath.Buffer);
	}

	return AFP_ERR_EXTENDED;
}



/***	AfpFspDispMoveAndRename
 *
 *	This is the worker routine for the AfpMoveAndRename API.  Note that
 *  in AFP 2.x, a FILE (not a dir) CAN BE MOVED when its RenameInhibit bit
 *  is set if it is NOT BEING RENAMED.
 *
 *	The request packet is represented below
 *
 *	sda_ReqBlock	PCONNDESC	pConnDesc
 *	sda_ReqBlock	DWORD		Source ParentId
 *	sda_ReqBlock	DWORD		Dest ParentId
 *	sda_Name1		ANSI_STRING	Source Path
 *	sda_Name2		ANSI_STRING	Dest Path
 *	sda_Name3		ANSI_STRING	New Name
 */
AFPSTATUS FASTCALL
AfpFspDispMoveAndRename(
	IN	PSDA	pSda
)
{
	PATHMAPENTITY	PMEsrc, PMEdst;
	PVOLDESC		pVolDesc;
	FILEDIRPARM		FDParmsrc, FDParmdst;
	DWORD			Bitmap, NTAttr;
	AFPSTATUS		Status = AFP_ERR_PARAM;
	UNICODE_STRING	uNewName;
	WCHAR			wcbuf[AFP_FILENAME_LEN+1];
	BOOLEAN			Rename = True, Move = True, SrcInRoot, DstInRoot;
	PDFENTRY		pDfesrc, pDfedst, pDfeParentsrc;
	FILESYSHANDLE	hSrcParent;
	struct _RequestPacket
	{
		PCONNDESC	_pConnDesc;
		DWORD		_SrcParentId;
		DWORD		_DstParentId;
	};

	PAGED_CODE();

	DBGPRINT(DBG_COMP_AFPAPI_FD, DBG_LEVEL_INFO,
										("AfpFspDispMoveAndRename: Entered\n"));

	ASSERT(VALID_CONNDESC(pReqPkt->_pConnDesc));

	pVolDesc = pReqPkt->_pConnDesc->cds_pVolDesc;

	ASSERT(VALID_VOLDESC(pVolDesc));
	
	AfpInitializeFDParms(&FDParmsrc);
	AfpInitializeFDParms(&FDParmdst);
	AfpInitializePME(&PMEsrc, 0, NULL);
	AfpInitializePME(&PMEdst, 0, NULL);

	Bitmap = FD_BITMAP_ATTR | FD_BITMAP_LONGNAME | FD_INTERNAL_BITMAP_OPENACCESS_DELETE;
	AfpSetEmptyUnicodeString(&uNewName, sizeof(wcbuf), wcbuf);
	hSrcParent.fsh_FileHandle = NULL;

	AfpSwmrAcquireExclusive(&pVolDesc->vds_IdDbAccessLock);

	do
	{
		// Make sure the new name is not too long
		if ((pSda->sda_Name3.Length > 0) &&
			((pSda->sda_Name3.Length > AFP_FILENAME_LEN) ||
			((pSda->sda_PathType == AFP_SHORTNAME) &&
			 !AfpIsLegalShortname(&pSda->sda_Name3)) ||
			(!NT_SUCCESS(AfpConvertStringToMungedUnicode(&pSda->sda_Name3,
														 &uNewName)))))
			break;

		// Map source path for lookup (could be file or dir).
		// We ask for the finderinfo in case the user is moving an
		// application file to another directory, we can update its
		// parent dirid in the APPL desktop database
		if (!NT_SUCCESS(Status = AfpMapAfpPath(pReqPkt->_pConnDesc,
											   pReqPkt->_SrcParentId,
											   &pSda->sda_Name1,
											   pSda->sda_PathType,
											   Lookup,
											   DFE_ANY,
											   Bitmap | FD_BITMAP_FINDERINFO,
											   &PMEsrc,
											   &FDParmsrc)))
		{
			PMEsrc.pme_Handle.fsh_FileHandle = NULL;
			break;
		}

		// Map the destination parent directory path for lookup
		if (!NT_SUCCESS(Status = AfpMapAfpPath(pReqPkt->_pConnDesc,
											   pReqPkt->_DstParentId,
											   &pSda->sda_Name2,
											   pSda->sda_PathType,
											   Lookup,
											   DFE_DIR,
											   0,
											   &PMEdst,
											   &FDParmdst)))
		{
			PMEdst.pme_Handle.fsh_FileHandle = NULL;
			break;
		}

		if ((FDParmsrc._fdp_AfpId == AFP_ID_ROOT) ||
			(FDParmsrc._fdp_AfpId == AFP_ID_NETWORK_TRASH))
		{
			Status = AFP_ERR_CANT_MOVE;
			break;
		}

		if (!NT_SUCCESS(Status = AfpCheckForInhibit(&PMEsrc.pme_Handle,
													FD_BITMAP_ATTR_RENAMEINH,
													FDParmsrc._fdp_Attr,
													&NTAttr)))
		{
			// Files (not dirs) marked RenameInhibit that are NOT being
			// renamed are allowed to be moved in AFP 2.x
			if (!((Status == AFP_ERR_OBJECT_LOCKED) &&
				 (!IsDir(&FDParmsrc)) &&
				 (pSda->sda_Name3.Length == 0)))
			{
				break;
			}
		}

		if (FDParmsrc._fdp_ParentId == FDParmdst._fdp_AfpId)
		{
			// if the parent directories are the same, we are not
			// moving anything to a new directory, so the change
			// notify we expect will be a rename in the source dir.
			Move = False;

			//
			// Trying to move a file onto itself.  Just return success.
			// (some apps move files onto
			// themselves for who knows what reason)
			//
			if ((pSda->sda_Name3.Length == 0) ||
				 RtlEqualString(&pSda->sda_Name3,
								&FDParmsrc._fdp_LongName,
								False))
			{
				Status = AFP_ERR_NONE;
				break;
			}

		}

		// Check for SeeFiles or SeeFolders on the source parent dir
		if (!NT_SUCCESS(Status = AfpCheckParentPermissions(pReqPkt->_pConnDesc,
														   FDParmsrc._fdp_ParentId,
														   &PMEsrc.pme_ParentPath,
														   (FDParmsrc._fdp_Flags & DFE_FLAGS_DIR) ?
																DIR_ACCESS_SEARCH : DIR_ACCESS_READ,
														   &hSrcParent,
														   NULL)))
		{
			break;
		}

		if (NTAttr & FILE_ATTRIBUTE_READONLY)
		{
			// We must temporarily remove the ReadOnly attribute so that
			// we can move the file/dir
			Status = AfpIoSetTimesnAttr(&PMEsrc.pme_Handle,
										NULL,
										NULL,
										0,
										FILE_ATTRIBUTE_READONLY,
										pVolDesc,
										&PMEsrc.pme_FullPath);
		}

		if (NT_SUCCESS(Status))
		{
			// If no new name was supplied, we need to use the
			// current name
			if (pSda->sda_Name3.Length == 0)
			{
				Rename = False;
				uNewName = PMEsrc.pme_UTail;
			}
			
			// We must impersonate to do the move since it is name based
			AfpImpersonateClient(pSda);

            if (Move)
			{
				// if we are moving, we will also get an ADDED notification
				// for the destination directory.  Since we have the path
				// of the parent dir, but we really want the name of the
				// thing we are about to move and/or rename, munge the
				// destination paths to reflect the new name of the thing
				// we are moving/renaming

				PMEdst.pme_ParentPath = PMEdst.pme_FullPath;
				if (PMEdst.pme_FullPath.Length > 0)
				{
					PMEdst.pme_FullPath.Buffer[PMEdst.pme_FullPath.Length / sizeof(WCHAR)] = L'\\';
					PMEdst.pme_FullPath.Length += sizeof(WCHAR);
				}
				Status = RtlAppendUnicodeStringToString(&PMEdst.pme_FullPath,
														&uNewName);
				ASSERT(NT_SUCCESS(Status));
			}

			SrcInRoot = (PMEsrc.pme_ParentPath.Length == 0) ? True : False;
			DstInRoot = (PMEdst.pme_ParentPath.Length == 0) ? True : False;
			Status = AfpIoMoveAndOrRename(&PMEsrc.pme_Handle,
										  Move ? &PMEdst.pme_Handle : NULL,
										  &uNewName,
										  pVolDesc,
										  &PMEsrc.pme_FullPath,
										  SrcInRoot ? NULL : &PMEsrc.pme_ParentPath,
										  Move ? &PMEdst.pme_FullPath : NULL,
										  (Move && !DstInRoot) ? &PMEdst.pme_ParentPath : NULL);
			AfpRevertBack();

			if (NT_SUCCESS(Status))	// Move succeeded
			{
				if (((pDfesrc = AfpFindDfEntryById(pVolDesc,
												   FDParmsrc._fdp_AfpId,
												   DFE_ANY)) != NULL) &&
					((pDfedst = AfpFindDfEntryById(pVolDesc,
												   FDParmdst._fdp_AfpId,
												   DFE_DIR)) != NULL))

				{
					ASSERT(((pDfesrc->dfe_Flags & DFE_FLAGS_DFBITS) &
							FDParmsrc._fdp_Flags) != 0);
					pDfeParentsrc = pDfesrc->dfe_Parent;
					pDfesrc = AfpMoveDfEntry(pVolDesc,
											 pDfesrc,
											 pDfedst,
											 Rename ? &uNewName : NULL);
					if (pDfesrc == NULL)
					{
						// We could not move the id entry, so
						// just delete it.
						ASSERT(VALID_DFE(PMEsrc.pme_pDfEntry));
						ASSERT(PMEsrc.pme_pDfEntry->dfe_AfpId == FDParmsrc._fdp_AfpId);
						AfpDeleteDfEntry(pVolDesc, PMEsrc.pme_pDfEntry);
						Status = AFP_ERR_MISC;	// Out of memory
					}

					// update cached mod time of source parent directory
					AfpCacheParentModTime(pVolDesc,
										  &hSrcParent,
										  NULL,
										  pDfeParentsrc,
										  0);
					if (Move)
					{
						// update cached mod time of destination directory
						AfpCacheParentModTime(pVolDesc,
											  &PMEdst.pme_Handle,
											  NULL,
											  pDfedst,
											  0);
						//
						// if we just moved an application program, update
						// the parentID in the corresponding APPL mapping.
						//
						if ((!IsDir(&FDParmsrc)) &&
							(FDParmsrc._fdp_FinderInfo.fd_TypeD == *(PDWORD)"APPL"))
						{
							AfpAddAppl(pVolDesc,
									   FDParmsrc._fdp_FinderInfo.fd_CreatorD,
									   0,
									   FDParmsrc._fdp_AfpId,
									   True,
									   FDParmdst._fdp_AfpId);
						}
					}
				}
			}
		}
		else
		{
			Status = AFP_ERR_MISC;	// Could not delete ReadOnly attribute
			break;
		}

		// Set the ReadOnly attribute back on the file/dir if need be
		if (NTAttr & FILE_ATTRIBUTE_READONLY)
			AfpIoSetTimesnAttr(&PMEsrc.pme_Handle,
								NULL,
								NULL,
								FILE_ATTRIBUTE_READONLY,
								0,
								pVolDesc,
								&PMEsrc.pme_FullPath);
	} while (False);

	// Return before we close thus saving some time
	AfpCompleteApiProcessing(pSda, Status);

	AfpSwmrRelease(&pVolDesc->vds_IdDbAccessLock);

	if (PMEsrc.pme_Handle.fsh_FileHandle != NULL)
		AfpIoClose(&PMEsrc.pme_Handle);

	if (PMEdst.pme_Handle.fsh_FileHandle != NULL)
		AfpIoClose(&PMEdst.pme_Handle);

	if (hSrcParent.fsh_FileHandle != NULL)
		AfpIoClose(&hSrcParent);

	if (PMEsrc.pme_FullPath.Buffer != NULL)
		AfpFreeMemory(PMEsrc.pme_FullPath.Buffer);

	if (PMEdst.pme_FullPath.Buffer != NULL)
		AfpFreeMemory(PMEdst.pme_FullPath.Buffer);

	return AFP_ERR_EXTENDED;
}


/***	AfpFspDispCatSearch
 *
 *	This is the worker routine for the AfpCatSearch API.
 *
 *	The request packet is represented below
 *
 *	sda_ReqBlock	PCONNDESC	pConnDesc
 *	sda_ReqBlock	DWORD		RequestedMatches
 *	sda_Name1		ANSI_STRING	Catalog Position - 16 bytes
 *	sda_Name2		ANSI_STRING	Everything else - needs unmarshalling
 *
 *	The reason we could not unmarshall all the parameters is because this
 *  API's parameters do not conform to the common way all the other APIs'
 *  parameters do, and therefore we cannot use the common code and table
 *  structures in afpapi.c.
 */
AFPSTATUS FASTCALL
AfpFspDispCatSearch(
	IN	PSDA	pSda
)
{
	AFPSTATUS		Status = AFP_ERR_PARAM;
	PBYTE			pEndOfBuffer;
	USHORT			Flags;
	SHORT			SizeLeft = 0;
	PVOLDESC		pVolDesc;
	DWORD			FileResultBitmap;
	DWORD			DirResultBitmap;
	DWORD			RequestBitmap;
	DWORD			Count;
	BOOLEAN			fPartialName = False, FreeReplyBuf = False;
    FILEDIRPARM		FDPLowerAndValue, FDPUpperAndMask;
	PCATSEARCHSPEC	pSpec1, pSpec2;
	UNICODE_STRING	MatchString;
	WCHAR			strbuf[AFP_LONGNAME_LEN+1];

	struct _RequestPacket
	{
		PCONNDESC	_pConnDesc;
		DWORD		_RequestedMatches;
	};

	// The part of the request buffer that could not be unmarshalled into
	// fields in the Sda because they don't conform to any of the other APIs.
	// These will be unmarshalled here into local variables, the sda_Name2
	// can be cast to this structure for easy access.
	struct _RestOfRawRequest
	{
		USHORT	_FileResultBitmap;
		USHORT	_DirResultBitmap;
		BYTE	_fPartialName;
		BYTE	_Pad1;
		USHORT	_RequestBitmap;
		// Spec1 and Spec2 follow
	};

#define pRawPkt	((struct _RestOfRawRequest *)(pSda->sda_Name2.Buffer))

	struct _ResponsePacket
	{
		 BYTE		__CatPosition[16];
		 BYTE		__FileBitmap[2];
		 BYTE		__DirBitmap[2];
		 BYTE		__ActualCount[4];
	};

	PAGED_CODE();

	DBGPRINT(DBG_COMP_AFPAPI_FD, DBG_LEVEL_INFO,
										("AfpFspDispCatSearch: Entered\n"));

	ASSERT(VALID_CONNDESC(pReqPkt->_pConnDesc));

	do
	{
		if (pSda->sda_Name2.Length < (sizeof(struct _RestOfRawRequest) +
									  (2 * sizeof(CATSEARCHSPEC))))
		{
			// The request buffer must be at least as big as the rest of the
			// parameters that weren't yet unmarshalled, plus 2 Spec structs
			break;
		}
		
		GETSHORT2DWORD(&FileResultBitmap, &pRawPkt->_FileResultBitmap);
		GETSHORT2DWORD(&DirResultBitmap, &pRawPkt->_DirResultBitmap);
		GETSHORT2DWORD(&RequestBitmap, &pRawPkt->_RequestBitmap);
	
		if ( (pRawPkt->_fPartialName & 0x80) != 0 )
		{
			fPartialName = True;
		}

		//
		// Validate the bitmaps
		//
		if (((FileResultBitmap | DirResultBitmap) == 0) ||
			((FileResultBitmap | DirResultBitmap) & ~FD_VALID_SEARCH_RESULT) ||
			(RequestBitmap == 0))
		{
			Status = AFP_ERR_BITMAP;
			break;
		}

		// make sure CatSearch is enabled: if it's disabled, reject the call
		if (!(pReqPkt->_pConnDesc->cds_pVolDesc->vds_Flags & AFP_VOLUME_SUPPORTS_CATSRCH))
		{
			DBGPRINT(DBG_COMP_AFPAPI_FD, DBG_LEVEL_ERR,
					("AfpFspDispCatSearch: CATSRCH not supported by volume\n"));

			Status = AFP_ERR_CALL_NOT_SUPPORTED;
			break;
		}

		AfpInitializeFDParms(&FDPLowerAndValue);
		AfpInitializeFDParms(&FDPUpperAndMask);

		if (DirResultBitmap == 0)
		{
			FDPLowerAndValue._fdp_Flags = FDPUpperAndMask._fdp_Flags = DFE_FLAGS_FILE_WITH_ID;
			if (RequestBitmap & ~FILE_VALID_SEARCH_CRITERIA)
			{
				Status = AFP_ERR_BITMAP;
				break;
			}
		}
		else if (FileResultBitmap == 0)
		{
			FDPLowerAndValue._fdp_Flags = FDPUpperAndMask._fdp_Flags = DFE_FLAGS_DIR;
			if (RequestBitmap & ~DIR_VALID_SEARCH_CRITERIA)
			{
				Status = AFP_ERR_BITMAP;
				break;
			}
		}
		else
		{
			FDPLowerAndValue._fdp_Flags = FDPUpperAndMask._fdp_Flags = DFE_FLAGS_FILE_WITH_ID | DFE_FLAGS_DIR;
			if (RequestBitmap & ~FD_VALID_SEARCH_CRITERIA)
			{
				Status = AFP_ERR_BITMAP;
				break;
			}
		}

		Flags = ((PCATALOGPOSITION)pSda->sda_Name1.Buffer)->cp_Flags;
		// The caller should not muck with the catalog position at all
		if ((Flags & ~CATFLAGS_VALID) ||
			// Writelock should only be required if we were about to search files
			((Flags & CATFLAGS_WRITELOCK_REQUIRED) && !(Flags & CATFLAGS_SEARCHING_FILES)))
			// NOTE: also should make sure ONLY ONE of the SEARCHING bits is on
			break;

		//
		// Now unpack the search criteria
		//
		MatchString.Length = 0;
		MatchString.MaximumLength = sizeof(strbuf);
		MatchString.Buffer = strbuf;

        Status = AfpUnpackCatSearchSpecs((PBYTE)pSda->sda_Name2.Buffer + sizeof(struct _RestOfRawRequest),
										 (USHORT)(pSda->sda_Name2.Length - sizeof(struct _RestOfRawRequest)),
										 RequestBitmap,
										 &FDPLowerAndValue,
										 &FDPUpperAndMask,
										 &MatchString);
		if (!NT_SUCCESS(Status))
		{
			break;
		}

		//
		// Allocate the reply buffer.  Estimate the required size by using
		// the maximum possible filename length plus potential pad bytes for
		// even alignment of each entry plus the length of the parent dirid.
		//
		pSda->sda_ReplySize = (USHORT)(SIZE_RESPPKT + (pReqPkt->_RequestedMatches *
				((2 * sizeof(BYTE)) + sizeof(DWORD) + sizeof(USHORT) + sizeof(BYTE) + AFP_LONGNAME_LEN + 1)));

		if (pSda->sda_ReplySize > MAX_CATSEARCH_REPLY)
		{
			pSda->sda_ReplySize = MAX_CATSEARCH_REPLY;
		}

        AfpIOAllocBackFillBuffer(pSda);

		if (pSda->sda_ReplyBuf == NULL)
		{
			pSda->sda_ReplySize = 0;
			Status = AFP_ERR_MISC;
			break;
		}

#if DBG
        AfpPutGuardSignature(pSda);
#endif

		FreeReplyBuf = True;

		//
		// Perform the search
		//

		FDPUpperAndMask._fdp_fPartialName = fPartialName;

		Count = pReqPkt->_RequestedMatches;
		Status = AfpCatSearch(pReqPkt->_pConnDesc,
						      (PCATALOGPOSITION)pSda->sda_Name1.Buffer, // CatalogPosition
						      RequestBitmap,
							  FileResultBitmap,
							  DirResultBitmap,
							  &FDPLowerAndValue,
							  &FDPUpperAndMask,
							  &MatchString,
							  &Count,					// IN OUT
							  (SHORT)(pSda->sda_ReplySize - SIZE_RESPPKT),
							  &SizeLeft,
							  pSda->sda_ReplyBuf + SIZE_RESPPKT,
							  (PCATALOGPOSITION)pSda->sda_ReplyBuf);

         if (!NT_SUCCESS(Status) && ((Status != AFP_ERR_EOF) &&
									 (Status != AFP_ERR_CATALOG_CHANGED)))
		 {
			 break;
		 }

		 PUTSHORT2SHORT(&pRspPkt->__FileBitmap, FileResultBitmap);
		 PUTSHORT2SHORT(&pRspPkt->__DirBitmap, DirResultBitmap);
		 PUTDWORD2DWORD(&pRspPkt->__ActualCount, Count);
		 pSda->sda_ReplySize -= SizeLeft;
		 ASSERT(pSda->sda_ReplySize <= MAX_CATSEARCH_REPLY);
		 FreeReplyBuf = False;



	} while (False);

	if (FreeReplyBuf)
	{
        AfpIOFreeBackFillBuffer(pSda);
	}

	return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\server\fsp_dtp.c ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	fsp_dtp.c

Abstract:

	This module contains the entry points for the AFP desktop APIs queued to
	the FSP. These are all callable from FSP Only.

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	25 Apr 1992		Initial Version

Notes:	Tab stop: 4
--*/

#define	FILENUM	FILE_FSP_DTP

#include <afp.h>
#include <gendisp.h>
#include <fdparm.h>
#include <pathmap.h>
#include <client.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, AfpFspDispAddIcon)
#pragma alloc_text( PAGE, AfpFspDispGetIcon)
#pragma alloc_text( PAGE, AfpFspDispGetIconInfo)
#pragma alloc_text( PAGE, AfpFspDispAddAppl)
#pragma alloc_text( PAGE, AfpFspDispGetAppl)
#pragma alloc_text( PAGE, AfpFspDispRemoveAppl)
#pragma alloc_text( PAGE, AfpFspDispAddComment)
#pragma alloc_text( PAGE, AfpFspDispGetComment)
#pragma alloc_text( PAGE, AfpFspDispRemoveComment)
#endif

/***	AfpFspDispAddIcon
 *
 *	This is the worker routine for the AfpAddIcon API.
 *
 *	The request packet is represented below
 *
 *	sda_ReqBlock	PCONNDESC	pConnDesc
 *	sda_ReqBlock	DWORD		Creator
 *	sda_ReqBlock	DWORD		Type
 *	sda_ReqBlock	DWORD		IconType
 *	sda_ReqBlock	DWORD		IconTag
 *	sda_ReqBlock	LONG		BitmapSize
 *	sda_ReplyBuf	BYTE[]		IconBuffer
 */
AFPSTATUS FASTCALL
AfpFspDispAddIcon(
	IN	PSDA	pSda
)
{
	AFPSTATUS	Status = AFP_ERR_PARAM;
	struct _RequestPacket
	{
		PCONNDESC	_pConnDesc;
		DWORD		_Creator;
		DWORD		_Type;
		DWORD		_IconType;
		DWORD		_IconTag;
		LONG		_Size;
	};

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_AFPAPI_DTP, DBG_LEVEL_INFO,
										("AfpFspDispAddIcon: Entered\n"));

	ASSERT(VALID_CONNDESC(pReqPkt->_pConnDesc) &&
		   VALID_VOLDESC(pReqPkt->_pConnDesc->cds_pVolDesc));

	ASSERT(VALID_CONNDESC(pReqPkt->_pConnDesc));

	ASSERT(VALID_VOLDESC(pReqPkt->_pConnDesc->cds_pVolDesc));


	if (pSda->sda_IOSize > 0)
	{
		ASSERT(pSda->sda_IOBuf != NULL);

		Status = AfpAddIcon(pReqPkt->_pConnDesc->cds_pVolDesc,
							pReqPkt->_Creator,
							pReqPkt->_Type,
							pReqPkt->_IconTag,
							pReqPkt->_Size,
							pReqPkt->_IconType,
							pSda->sda_IOBuf);
		AfpFreeIOBuffer(pSda);
	}

	return Status;
}


/***	AfpFspDispGetIcon
 *
 *	This is the worker routine for the AfpGetIcon API.
 *
 *	The request packet is represented below
 *
 *	sda_ReqBlock	PCONNDESC	pConnDesc
 *	sda_ReqBlock	DWORD		Creator
 *	sda_ReqBlock	DWORD		Type
 *	sda_ReqBlock	DWORD		IconType
 *	sda_ReqBlock	LONG		Length of buffer
 */
AFPSTATUS FASTCALL
AfpFspDispGetIcon(
	IN	PSDA	pSda
)
{
	AFPSTATUS	Status = AFP_ERR_PARAM;
    LONG        ActualLength;
	struct _RequestPacket
	{
		PCONNDESC	_pConnDesc;
		DWORD		_Creator;
		DWORD		_Type;
		DWORD		_IconType;
		LONG		_Length;
	};

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_AFPAPI_DTP, DBG_LEVEL_INFO,
										("AfpFspDispGetIcon: Entered\n"));

	ASSERT(VALID_CONNDESC(pReqPkt->_pConnDesc) &&
		   VALID_VOLDESC(pReqPkt->_pConnDesc->cds_pVolDesc));

	if (pReqPkt->_Length >= 0)
	{
		pSda->sda_ReplySize = (USHORT)pReqPkt->_Length;
		if (pReqPkt->_Length > (LONG)pSda->sda_MaxWriteSize)
			pSda->sda_ReplySize = (USHORT)pSda->sda_MaxWriteSize;

		if ((pSda->sda_ReplySize == 0) ||
			((pSda->sda_ReplySize > 0) &&
			 (Status = AfpAllocReplyBuf(pSda)) == AFP_ERR_NONE))
		{
			if ((Status = AfpLookupIcon(pReqPkt->_pConnDesc->cds_pVolDesc,
										pReqPkt->_Creator,
										pReqPkt->_Type,
										pReqPkt->_Length,
										pReqPkt->_IconType,
                                        &ActualLength,
										pSda->sda_ReplyBuf)) != AFP_ERR_NONE)
			{
				Status = AFP_ERR_ITEM_NOT_FOUND;
			}
            else
            {
                pSda->sda_ReplySize = (USHORT)ActualLength;
            }
		}
	}

	return Status;
}


/***	AfpFspDispGetIconInfo
 *
 *	This is the worker routine for the AfpGetIconInfo API.
 *
 *	The request packet is represented below
 *
 *	sda_ReqBlock	PCONNDESC	pConnDesc
 *	sda_ReqBlock	DWORD		Creator
 *	sda_ReqBlock	LONG		Icon index
 */
AFPSTATUS FASTCALL
AfpFspDispGetIconInfo(
	IN	PSDA	pSda
)
{
	LONG		Size;
	DWORD		Type,
				Tag;
	DWORD		IconType;
	AFPSTATUS	Status = AFP_ERR_PARAM;
	struct _RequestPacket
	{
		PCONNDESC	_pConnDesc;
		DWORD		_Creator;
		DWORD		_Index;
	};
	struct _ResponsePacket
	{
		BYTE		__IconTag[4];
		BYTE		__Type[4];
		BYTE		__IconType;
		BYTE		__Pad;
		BYTE		__Size[2];
	};

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_AFPAPI_DTP, DBG_LEVEL_INFO,
										("AfpFspDispGetIconInfo: Entered\n"));

	ASSERT(VALID_CONNDESC(pReqPkt->_pConnDesc) &&
		   VALID_VOLDESC(pReqPkt->_pConnDesc->cds_pVolDesc));

	if ((Status = AfpLookupIconInfo(pReqPkt->_pConnDesc->cds_pVolDesc,
									pReqPkt->_Creator,
									pReqPkt->_Index,
									&Type,
									&IconType,
									&Tag,
									&Size)) == AFP_ERR_NONE)
	{
		pSda->sda_ReplySize = SIZE_RESPPKT;
		if ((Status = AfpAllocReplyBuf(pSda)) == AFP_ERR_NONE)
		{
			PUTDWORD2DWORD(&pRspPkt->__IconTag, Tag);
			RtlCopyMemory(&pRspPkt->__Type, (PBYTE)&Type, sizeof(DWORD));
			PUTSHORT2BYTE(&pRspPkt->__IconType, IconType);
			PUTDWORD2SHORT(&pRspPkt->__Size, Size);
		}
	}

	return Status;
}


/***	AfpFspDispAddAppl
 *
 *	This is the worker routine for the AfpAddAppl API.
 *
 *	The request packet is represented below
 *
 *	sda_ReqBlock	PCONNDESC	pConnDesc
 *	sda_ReqBlock	DWORD		Directory Id
 *	sda_ReqBlock	DWORD		Creator
 *	sda_ReqBlock	DWORD		APPL Tag
 *	sda_Name1		ANSI_STRING	PathName
 */
AFPSTATUS FASTCALL
AfpFspDispAddAppl(
	IN	PSDA	pSda
)
{
	FILEDIRPARM		FDParm;
	PATHMAPENTITY	PME;
	AFPSTATUS		Status = AFP_ERR_PARAM;
	struct _RequestPacket
	{
		PCONNDESC	_pConnDesc;
		DWORD		_DirId;
		DWORD		_Creator;
		DWORD		_ApplTag;
	};

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_AFPAPI_DTP, DBG_LEVEL_INFO,
										("AfpFspDispAddAppl: Entered\n"));

	ASSERT(VALID_CONNDESC(pReqPkt->_pConnDesc) &&
		   VALID_VOLDESC(pReqPkt->_pConnDesc->cds_pVolDesc));

	AfpInitializePME(&PME, 0, NULL);
	if ((Status = AfpMapAfpPathForLookup(pReqPkt->_pConnDesc,
										 pReqPkt->_DirId,
										 &pSda->sda_Name1,
										 pSda->sda_PathType,
										 DFE_FILE,
										 FILE_BITMAP_FILENUM |
										 FD_INTERNAL_BITMAP_OPENACCESS_WRITE,
										 &PME,
										 &FDParm)) == AFP_ERR_NONE)
	{
		AfpIoClose(&PME.pme_Handle); // only needed to check for RW access

		Status = AfpAddAppl(pReqPkt->_pConnDesc->cds_pVolDesc,
							pReqPkt->_Creator,
							pReqPkt->_ApplTag,
							FDParm._fdp_AfpId,
							False,
							FDParm._fdp_ParentId);
	}

	return Status;
}


/***	AfpFspDispGetAPPL
 *
 *	This is the worker routine for the AfpGetAppl API.
 *
 *	The request packet is represented below
 *
 *	sda_ReqBlock	PCONNDESC	pConnDesc
 *	sda_ReqBlock	DWORD		Creator
 *	sda_ReqBlock	DWORD		APPL Index
 *	sda_ReqBlock	DWORD		Bitmap
 */
AFPSTATUS FASTCALL
AfpFspDispGetAppl(
	IN	PSDA	pSda
)
{
	DWORD			ApplTag;
	DWORD			Bitmap,			// Need to copy this as it goes into the resp
					FileNum, ParentID;
	AFPSTATUS		Status = AFP_ERR_PARAM;
	FILEDIRPARM		FDParm;
	PATHMAPENTITY	PME;
	struct _RequestPacket
	{
		PCONNDESC	_pConnDesc;
		DWORD		_Creator;
		DWORD		_Index;
		DWORD		_Bitmap;
	};
	struct _ResponsePacket
	{
		BYTE		__Bitmap[2];
		BYTE		__ApplTag[4];
		// Followed by the File Parameters. These cannot be represented as a
		// structure since it depends on the bitmap
	};

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_AFPAPI_DTP, DBG_LEVEL_INFO,
										("AfpFspDispGetAppl: Entered\n"));

	ASSERT(VALID_CONNDESC(pReqPkt->_pConnDesc) &&
		   VALID_VOLDESC(pReqPkt->_pConnDesc->cds_pVolDesc));

	Bitmap = pReqPkt->_Bitmap;
	AfpInitializePME(&PME, 0, NULL);

	do
	{
		if ((Status = AfpLookupAppl(pReqPkt->_pConnDesc->cds_pVolDesc,
									pReqPkt->_Creator,
									pReqPkt->_Index,
									&ApplTag, &FileNum, &ParentID)) != AFP_ERR_NONE)
			break;

		AfpInitializeFDParms(&FDParm);

		// Call AfpMapAfpPathForLookup on the parent ID first to make sure
		// its files are cached in.
		if (ParentID != 0)
		{
			ANSI_STRING nullname = {0, 0, NULL};

			if ((Status = AfpMapAfpPathForLookup(pReqPkt->_pConnDesc,
										 ParentID,
										 &nullname,
										 AFP_LONGNAME,
										 DFE_DIR,
										 0,		// Bitmap
										 NULL,
										 NULL)) != AFP_ERR_NONE)
		    {
				break;
			}
		}

		if ((Status = AfpMapAfpIdForLookup(pReqPkt->_pConnDesc,
								FileNum,
								DFE_FILE,
								Bitmap | FD_INTERNAL_BITMAP_OPENACCESS_READ,
								&PME,	// open a handle to check access
								&FDParm)) != AFP_ERR_NONE)
			break;

		pSda->sda_ReplySize = SIZE_RESPPKT +
						EVENALIGN(AfpGetFileDirParmsReplyLength(&FDParm, Bitmap));

		if ((Status = AfpAllocReplyBuf(pSda)) == AFP_ERR_NONE)
		{
			AfpPackFileDirParms(&FDParm, Bitmap,
								pSda->sda_ReplyBuf + SIZE_RESPPKT);
			PUTDWORD2SHORT(pRspPkt->__Bitmap, Bitmap);
			PUTDWORD2DWORD(pRspPkt->__ApplTag, ApplTag);
		}

	} while (False);

	if (PME.pme_Handle.fsh_FileHandle != NULL)
		AfpIoClose(&PME.pme_Handle);

	return Status;
}


/***	AfpFspDispRemoveAppl
 *
 *	This is the worker routine for the AfpRemoveAppl API.
 *
 *	The request packet is represented below
 *
 *	sda_ReqBlock	PCONNDESC	pConnDesc
 *	sda_ReqBlock	DWORD		Directory Id
 *	sda_ReqBlock	DWORD		Creator
 *	sda_Name1		ANSI_STRING	PathName
 */
AFPSTATUS FASTCALL
AfpFspDispRemoveAppl(
	IN	PSDA	pSda
)
{
	FILEDIRPARM		FDParm;
	PATHMAPENTITY	PME;
	AFPSTATUS		Status = AFP_ERR_PARAM;
	struct _RequestPacket
	{
		PCONNDESC	_pConnDesc;
		DWORD		_DirId;
		DWORD		_Creator;
	};

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_AFPAPI_DTP, DBG_LEVEL_INFO,
										("AfpFspDispRemoveAppl: Entered\n"));

	ASSERT(VALID_CONNDESC(pReqPkt->_pConnDesc) &&
		   VALID_VOLDESC(pReqPkt->_pConnDesc->cds_pVolDesc));

	AfpInitializePME(&PME, 0, NULL);
	if ((Status = AfpMapAfpPathForLookup(pReqPkt->_pConnDesc,
										 pReqPkt->_DirId,
										 &pSda->sda_Name1,
										 pSda->sda_PathType,
										 DFE_FILE,
										 FILE_BITMAP_FILENUM |
											FD_INTERNAL_BITMAP_OPENACCESS_READWRITE,
										&PME,
										&FDParm)) == AFP_ERR_NONE)
	{
		AfpIoClose(&PME.pme_Handle); // only needed to check access

		Status = AfpRemoveAppl(pReqPkt->_pConnDesc->cds_pVolDesc,
							   pReqPkt->_Creator,
							   FDParm._fdp_AfpId);
	}

	return Status;
}


/***	AfpFspDispAddComment
 *
 *	This is the worker routine for the AfpAddComment API.
 *
 *	The request packet is represented below
 *
 *	sda_ReqBlock	PCONNDESC	pConnDesc
 *	sda_ReqBlock	DWORD		Directory Id
 *	sda_Name1		ANSI_STRING	PathName
 *	sda_Name2		ANSI_STRING	Comment
 */
AFPSTATUS FASTCALL
AfpFspDispAddComment(
	IN	PSDA	pSda
)
{
	PATHMAPENTITY	PME;
	FILEDIRPARM		FDParm;
	AFPSTATUS		Status;
	struct _RequestPacket
	{
		PCONNDESC	_pConnDesc;
		DWORD		_DirId;
	};

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_AFPAPI_DTP, DBG_LEVEL_INFO,
										("AfpFspDispAddComment: Entered\n"));

	ASSERT(VALID_CONNDESC(pReqPkt->_pConnDesc) &&
		   VALID_VOLDESC(pReqPkt->_pConnDesc->cds_pVolDesc));

	AfpInitializePME(&PME, 0, NULL);
	if ((Status = AfpMapAfpPathForLookup(pReqPkt->_pConnDesc,
										 pReqPkt->_DirId,
										 &pSda->sda_Name1,
										 pSda->sda_PathType,
										 DFE_ANY,
										 0,
										 &PME,
										 &FDParm)) == AFP_ERR_NONE)
	{
		Status = AFP_ERR_VOLUME_LOCKED;
		if (IS_CONN_NTFS(pReqPkt->_pConnDesc))
			Status = AfpAddComment(pSda,
								   pReqPkt->_pConnDesc->cds_pVolDesc,
								   &pSda->sda_Name2,
								   &PME,
								   IsDir(&FDParm),
								   FDParm._fdp_AfpId);
		AfpIoClose(&PME.pme_Handle);
	}
	return Status;
}


/***	AfpFspDispGetComment
 *
 *	This is the worker routine for the AfpGetComment API.
 *
 *	The request packet is represented below
 *
 *	sda_ReqBlock	PCONNDESC	pConnDesc
 *	sda_ReqBlock	DWORD		Directory Id
 *	sda_Name1		ANSI_STRING	PathName
 */
AFPSTATUS FASTCALL
AfpFspDispGetComment(
	IN	PSDA	pSda
)
{
	PATHMAPENTITY	PME;
	FILEDIRPARM		FDParm;
	AFPSTATUS		Status;
	struct _RequestPacket
	{
		PCONNDESC	_pConnDesc;
		DWORD		_DirId;
	};

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_AFPAPI_DTP, DBG_LEVEL_INFO,
										("AfpFspDispGetComment: Entered\n"));

	ASSERT(VALID_CONNDESC(pReqPkt->_pConnDesc) &&
		   VALID_VOLDESC(pReqPkt->_pConnDesc->cds_pVolDesc));

	AfpInitializePME(&PME, 0, NULL);
	if ((Status = AfpMapAfpPathForLookup(pReqPkt->_pConnDesc,
										 pReqPkt->_DirId,
										 &pSda->sda_Name1,
										 pSda->sda_PathType,
										 DFE_ANY,
										 0,
										 &PME,
										 &FDParm)) == AFP_ERR_NONE)
	{
		// Assume no comment to start with
		Status = AFP_ERR_ITEM_NOT_FOUND;

		if (IS_CONN_NTFS(pReqPkt->_pConnDesc) &&
			(FDParm._fdp_Flags & DFE_FLAGS_HAS_COMMENT))
		{
			pSda->sda_ReplySize = AFP_MAXCOMMENTSIZE + 1;

			if ((Status = AfpAllocReplyBuf(pSda)) == AFP_ERR_NONE)
			{
				if ((Status = AfpGetComment(pSda,
											pReqPkt->_pConnDesc->cds_pVolDesc,
											&PME,
											IsDir(&FDParm))) != AFP_ERR_NONE)
				{
					AfpFreeReplyBuf(pSda, FALSE);
				}
			}
		}
		AfpIoClose(&PME.pme_Handle);
	}

	return Status;
}


/***	AfpFspDispRemoveComment
 *
 *	This is the worker routine for the AfpRemoveComment API.
 *
 *	The request packet is represented below
 *
 *	sda_ReqBlock	PCONNDESC	pConnDesc
 *	sda_ReqBlock	DWORD		Directory Id
 *	sda_Name1		ANSI_STRING	PathName
 */
AFPSTATUS FASTCALL
AfpFspDispRemoveComment(
	IN	PSDA	pSda
)
{
	PATHMAPENTITY	PME;
	FILEDIRPARM		FDParm;
	AFPSTATUS		Status = AFP_ERR_ITEM_NOT_FOUND;
	struct _RequestPacket
	{
		PCONNDESC	_pConnDesc;
		DWORD		_DirId;
	};

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_AFPAPI_DTP, DBG_LEVEL_INFO,
										("AfpFspDispRemoveComment: Entered\n"));

	ASSERT(VALID_CONNDESC(pReqPkt->_pConnDesc) &&
		   VALID_VOLDESC(pReqPkt->_pConnDesc->cds_pVolDesc));

	AfpInitializePME(&PME, 0, NULL);
	if (IS_CONN_NTFS(pReqPkt->_pConnDesc) &&
		(Status = AfpMapAfpPathForLookup(pReqPkt->_pConnDesc,
										 pReqPkt->_DirId,
										 &pSda->sda_Name1,
										 pSda->sda_PathType,
										 DFE_ANY,
										 0,
										 &PME,
										 &FDParm)) == AFP_ERR_NONE)
	{
		Status = AFP_ERR_ITEM_NOT_FOUND;
		if (IS_CONN_NTFS(pReqPkt->_pConnDesc) &&
			(FDParm._fdp_Flags & DFE_FLAGS_HAS_COMMENT))
			Status = AfpRemoveComment(pSda,
									  pReqPkt->_pConnDesc->cds_pVolDesc,
									  &PME,
									  IsDir(&FDParm),
									  FDParm._fdp_AfpId);
		AfpIoClose(&PME.pme_Handle);
	}

	return Status;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\server\fsp_file.c ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	fsp_file.c

Abstract:

	This module contains the entry points for the AFP file APIs queued to
	the FSP. These are all callable from FSP Only.

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	25 Apr 1992		Initial Version

Notes:	Tab stop: 4

--*/

#define	FILENUM	FILE_FSP_FILE

#include <afp.h>
#include <gendisp.h>
#include <fdparm.h>
#include <pathmap.h>
#include <client.h>
#include <afpinfo.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, AfpFspDispCreateFile)
#pragma alloc_text( PAGE, AfpFspDispSetFileParms)
#pragma alloc_text( PAGE, AfpFspDispCopyFile)
#pragma alloc_text( PAGE, AfpFspDispCreateId)
#pragma alloc_text( PAGE, AfpFspDispResolveId)
#pragma alloc_text( PAGE, AfpFspDispDeleteId)
#pragma alloc_text( PAGE, AfpFspDispExchangeFiles)
#endif

/***	AfpFspDispCreateFile
 *
 *	This is the worker routine for the AfpCreateFile API.
 *
 *	The request packet is represented below.
 *
 *	sda_AfpSubFunc	BYTE		Create option
 *	sda_ReqBlock	PCONNDESC	pConnDesc
 *	sda_ReqBlock	DWORD		ParentId
 *	sda_Name1		ANSI_STRING	FileName
 */
AFPSTATUS FASTCALL
AfpFspDispCreateFile(
	IN	PSDA	pSda
)
{
	AFPSTATUS		Status = AFP_ERR_PARAM, PostStatus;
	PATHMAPENTITY	PME;
	PDFENTRY		pNewDfe;
	FILESYSHANDLE	hNewFile, hAfpInfo, hParent;
	AFPINFO			afpinfo;
	DWORD			crinfo;
	PATHMAP_TYPE	CreateOption;
	WCHAR			PathBuf[BIG_PATH_LEN];
	PVOLDESC		pVolDesc;		// For post-create processing
	BYTE			PathType;		// -- ditto --
	BOOLEAN			InRoot;
	struct _RequestPacket
	{
		PCONNDESC	_pConnDesc;
		DWORD		_ParentId;
	};

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_AFPAPI_FILE, DBG_LEVEL_INFO,
										("AfpFspDispCreateFile: Entered\n"));

	ASSERT(VALID_CONNDESC(pReqPkt->_pConnDesc));

	pVolDesc = pReqPkt->_pConnDesc->cds_pVolDesc;

	ASSERT(VALID_VOLDESC(pVolDesc));
	
	AfpSwmrAcquireExclusive(&pVolDesc->vds_IdDbAccessLock);

	do
	{
		hNewFile.fsh_FileHandle = NULL;
		hAfpInfo.fsh_FileHandle = NULL;
		hParent.fsh_FileHandle = NULL;
		CreateOption = (pSda->sda_AfpSubFunc == AFP_HARDCREATE_FLAG) ?
							HardCreate : SoftCreate;
		AfpInitializePME(&PME, sizeof(PathBuf), PathBuf);

		if (!NT_SUCCESS(Status = AfpMapAfpPath(pReqPkt->_pConnDesc,
											   pReqPkt->_ParentId,
											   &pSda->sda_Name1,
											   PathType = pSda->sda_PathType,
											   CreateOption,
											   DFE_FILE,
											   0,
											   &PME,
											   NULL)))
		{
			break;
		}

		// check for seefiles on the parent directory if hard create
		if (CreateOption == HardCreate)
		{
			if (!NT_SUCCESS(Status = AfpCheckParentPermissions(
												pReqPkt->_pConnDesc,
												PME.pme_pDfeParent->dfe_AfpId,
												&PME.pme_ParentPath,
												DIR_ACCESS_READ,
												&hParent,
												NULL)))
			{
				break;
			}
		}

		AfpImpersonateClient(pSda);

		InRoot = (PME.pme_ParentPath.Length == 0) ? True : False;
		Status = AfpIoCreate(&pVolDesc->vds_hRootDir,
							AFP_STREAM_DATA,
							&PME.pme_FullPath,
							FILEIO_ACCESS_NONE | FILEIO_ACCESS_DELETE,
							FILEIO_DENY_NONE,
							FILEIO_OPEN_FILE,
							AfpCreateDispositions[pSda->sda_AfpSubFunc / AFP_HARDCREATE_FLAG],
							FILE_ATTRIBUTE_NORMAL | FILE_ATTRIBUTE_ARCHIVE,
							True,
							NULL,
							&hNewFile,
							&crinfo,
							pVolDesc,
							&PME.pme_FullPath,
// we don't get notified of parent mod time changing if there is no handle
// open for the parent dir at the time of create, which we cannot predict here.
							&PME.pme_ParentPath);

		AfpRevertBack();

		if (!NT_SUCCESS(Status))
		{
			Status = AfpIoConvertNTStatusToAfpStatus(Status);
			break;
		}

		// !!! HACK ALERT !!!
		// At this point we are pretty much done i.e. the create has succeeded
		// and we can return doing the rest of the work post-reply. Any errors
		// from now on SHOULD BE IGNORED. Also NO REFERENCE SHOULD BE MADE TO
		// the PSda & pConnDesc. Status should not be changed either. Also
		// reference the Volume for good measure. It cannot fail !!!
		AfpVolumeReference(pVolDesc);

		AfpCompleteApiProcessing(pSda, AFP_ERR_NONE);
		Status = AFP_ERR_EXTENDED;

		// Add this entry to the IdDb
		if (crinfo == FILE_CREATED)
		{
			pNewDfe = AfpAddDfEntry(pVolDesc,
									PME.pme_pDfeParent,
									&PME.pme_UTail,
									False,
									0);
		}
		else if (crinfo == FILE_SUPERSEDED)
		{
			ASSERT(CreateOption == HardCreate);
			pNewDfe = AfpFindEntryByUnicodeName(pVolDesc,
												&PME.pme_UTail,
												PathType,
												PME.pme_pDfeParent,
												DFE_FILE);
			if (pNewDfe == NULL)
			{
				pNewDfe = AfpAddDfEntry(pVolDesc,
										PME.pme_pDfeParent,
										&PME.pme_UTail,
										False,
										0);
			}

		}
		else ASSERTMSG("AfpFspDispCreateFile: unexpected create action", 0);
			
		if (pNewDfe != NULL)
		{
			afpinfo.afpi_Id = pNewDfe->dfe_AfpId;

			// Create the AfpInfo stream
			if (!NT_SUCCESS(AfpCreateAfpInfoStream(pVolDesc,
												   &hNewFile,
												   afpinfo.afpi_Id,
												   False,
												   &PME.pme_UTail,
												   &PME.pme_FullPath,
												   &afpinfo,
												   &hAfpInfo)))
			{
				// If we fail to add the AFP_AfpInfo stream, we must
				// rewind back to the original state.  i.e. delete
				// the file we just created, and remove it from
				// the Id database.
				AfpIoMarkFileForDelete(&hNewFile,
									   pVolDesc,
									   &PME.pme_FullPath,
									   InRoot ? NULL : &PME.pme_ParentPath);

				AfpDeleteDfEntry(pVolDesc, pNewDfe);
			}
			else
			{
				DWORD			Attr;

				// Get the rest of the File info, and cache it
				PostStatus = AfpIoQueryTimesnAttr(&hNewFile,
												  &pNewDfe->dfe_CreateTime,
												  &pNewDfe->dfe_LastModTime,
												  &Attr);
				
				if (NT_SUCCESS(PostStatus))
				{
					pNewDfe->dfe_NtAttr = (USHORT)Attr & FILE_ATTRIBUTE_VALID_FLAGS;
					pNewDfe->dfe_FinderInfo = afpinfo.afpi_FinderInfo;
					pNewDfe->dfe_BackupTime = afpinfo.afpi_BackupTime;
					pNewDfe->dfe_AfpAttr = afpinfo.afpi_Attributes;
					pNewDfe->dfe_DataLen = 0;
					pNewDfe->dfe_RescLen = 0;
					AfpVolumeSetModifiedTime(pVolDesc);
					AfpCacheParentModTime(pVolDesc,
										  (hParent.fsh_FileHandle == NULL) ? NULL : &hParent,
										  (hParent.fsh_FileHandle == NULL) ? &PME.pme_ParentPath : NULL,
										  PME.pme_pDfeParent,
										  0);
				}
				else
				{
					AfpIoMarkFileForDelete(&hNewFile,
										   pVolDesc,
										   &PME.pme_FullPath,
										   InRoot ? NULL : &PME.pme_ParentPath);
					AfpDeleteDfEntry(pVolDesc, pNewDfe);
				}
			}
		}

		AfpVolumeDereference(pVolDesc);
		ASSERT (Status == AFP_ERR_EXTENDED);
	} while (False);

	if (hNewFile.fsh_FileHandle != NULL)
		AfpIoClose(&hNewFile);

	if (hAfpInfo.fsh_FileHandle != NULL)
		AfpIoClose(&hAfpInfo);

	// If you release the lock before closing the handles,
	// for datahandle the FPOpenFork could get a sharing violation.
	// For AfpInfo stream CopyFile can get a sharing violation.
	AfpSwmrRelease(&pVolDesc->vds_IdDbAccessLock);

	if (hParent.fsh_FileHandle != NULL)
		AfpIoClose(&hParent);

	if ((PME.pme_FullPath.Buffer != NULL) &&
		(PME.pme_FullPath.Buffer != PathBuf))
		AfpFreeMemory(PME.pme_FullPath.Buffer);

	return Status;
}


/***	AfpFspDispSetFileParms
 *
 *	This is the worker routine for the AfpSetFileParms API.
 *
 *	The request packet is represented below.
 *
 *	sda_ReqBlock	PCONNDESC	pConnDesc
 *	sda_ReqBlock	DWORD		ParentId
 *	sda_ReqBlock	DWORD		File Bitmap
 *	sda_Name1		ANSI_STRING	Path
 *	sda_Name2		BLOCK		File Parameters
 */
AFPSTATUS FASTCALL
AfpFspDispSetFileParms(
	IN	PSDA	pSda
)
{
	FILEDIRPARM		FDParm;
	PATHMAPENTITY	PME;
	PVOLDESC		pVolDesc;
	DWORD			Bitmap;
	AFPSTATUS		Status = AFP_ERR_PARAM;
	struct _RequestPacket
	{
		PCONNDESC	_pConnDesc;
		DWORD		_ParentId;
		DWORD		_Bitmap;
	};

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_AFPAPI_FILE, DBG_LEVEL_INFO,
										("AfpFspDispSetFileParms: Entered\n"));

	ASSERT(VALID_CONNDESC(pReqPkt->_pConnDesc));

	pVolDesc = pReqPkt->_pConnDesc->cds_pVolDesc;

	ASSERT(VALID_VOLDESC(pVolDesc));
	
	Bitmap = pReqPkt->_Bitmap;

	AfpInitializeFDParms(&FDParm);
	AfpInitializePME(&PME, 0, NULL);
	do
	{
		// Force the FD_BITMAP_LONGNAME in case a *file* is missing the afpinfo
		// stream we will be able to generate the correct type/creator in
		// AfpSetAfpInfo
		Status = AfpMapAfpPathForLookup(pReqPkt->_pConnDesc,
										pReqPkt->_ParentId,
										&pSda->sda_Name1,
										pSda->sda_PathType,
										DFE_FILE,
										Bitmap | FD_INTERNAL_BITMAP_OPENACCESS_RW_ATTR |
												 FD_INTERNAL_BITMAP_RETURN_PMEPATHS |
												 FD_BITMAP_LONGNAME,
										&PME,
										&FDParm);

		if (!NT_SUCCESS(Status))
		{
			PME.pme_Handle.fsh_FileHandle = NULL;
			break;
		}

		if (Bitmap & (FD_BITMAP_ATTR |
					  FD_BITMAP_CREATETIME |
					  FD_BITMAP_MODIFIEDTIME))
		{
			DWORD	Attr;
			TIME	ModTime;

			if (!NT_SUCCESS(Status = AfpIoQueryTimesnAttr(&PME.pme_Handle,
														  &FDParm._fdp_CreateTime,
														  &ModTime,
														  &Attr)))
				break;
			
			FDParm._fdp_ModifiedTime = AfpConvertTimeToMacFormat(&ModTime);
			if (Bitmap & FD_BITMAP_ATTR)
				AfpNormalizeAfpAttr(&FDParm, Attr);
		}
		if ((Status = AfpUnpackFileDirParms(pSda->sda_Name2.Buffer,
											(LONG)pSda->sda_Name2.Length,
											&Bitmap,
											&FDParm)) != AFP_ERR_NONE)
			break;

		if (Bitmap != 0)
		{
			if ((Bitmap & FD_BITMAP_ATTR) &&
				(FDParm._fdp_Attr & (FILE_BITMAP_ATTR_DATAOPEN |
									 FILE_BITMAP_ATTR_RESCOPEN |
									 FILE_BITMAP_ATTR_COPYPROT)))
			{
				Status = AFP_ERR_PARAM;
				break;
			}
			AfpSetFileDirParms(pVolDesc, &PME, Bitmap, &FDParm);
		}
	} while (False);
	
	// Return before we close thus saving some time
	AfpCompleteApiProcessing(pSda, Status);

	if (PME.pme_Handle.fsh_FileHandle != NULL)
		AfpIoClose(&PME.pme_Handle);

	if (PME.pme_FullPath.Buffer != NULL)
	{
		AfpFreeMemory(PME.pme_FullPath.Buffer);
	}

	return AFP_ERR_EXTENDED;
}


/***	AfpFspDispCopyFile
 *
 *	This is the worker routine for the AfpCopyFile API.
 *
 *	The request packet is represented below.
 *
 *	sda_ReqBlock	PCONNDESC	Source pConnDesc
 *	sda_ReqBlock	DWORD		Source ParentId
 *	sda_ReqBlock	DWORD		Dest VolId
 *	sda_ReqBlock	DWORD		Dest ParentId
 *	sda_Name1		ANSI_STRING	Source Path
 *	sda_Name2		ANSI_STRING	Dest Path
 *	sda_Name3		ANSI_STRING	New Name
 */
AFPSTATUS FASTCALL
AfpFspDispCopyFile(
	IN	PSDA	pSda
)
{
	PCONNDESC		pConnDescD;
	PATHMAPENTITY	PMESrc, PMEDst;
	FILEDIRPARM		FDParmSrc, FDParmDst;
	PANSI_STRING	pAnsiName;
	UNICODE_STRING	uNewName;
	WCHAR			wcbuf[AFP_FILENAME_LEN+1];
	PSWMR			pSwmr;
	PDFENTRY		pDfeParent, pNewDfe;
	AFPSTATUS		Status = AFP_ERR_PARAM;
	BOOLEAN			DstLockTaken = False, Rename = True, InRoot;
	LONG			i;
	COPY_FILE_INFO	CopyFileInfo;
	PCOPY_FILE_INFO	pCopyFileInfo = &CopyFileInfo;
	DWORD			CreateTime = 0;
	AFPTIME			aModTime;
	TIME			ModTime;

	struct _RequestPacket
	{
		PCONNDESC	_pConnDescS;
		DWORD		_SrcParentId;
		DWORD		_DstVolId;
		DWORD		_DstParentId;
	};

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_AFPAPI_FILE, DBG_LEVEL_INFO,
										("AfpFspDispCopyFile: Entered\n"));

	ASSERT(VALID_CONNDESC(pReqPkt->_pConnDescS) &&
		   VALID_VOLDESC(pReqPkt->_pConnDescS->cds_pVolDesc));

	if	((pConnDescD =
			AfpConnectionReference(pSda, pReqPkt->_DstVolId)) != NULL)
	{
		ASSERT(VALID_CONNDESC(pConnDescD) &&
			   VALID_VOLDESC(pConnDescD->cds_pVolDesc));
	
		AfpInitializeFDParms(&FDParmSrc);
		AfpInitializeFDParms(&FDParmDst);
		AfpInitializePME(&PMESrc, 0, NULL);
		AfpInitializePME(&PMEDst, 0, NULL);
		AfpSetEmptyUnicodeString(&uNewName, sizeof(wcbuf), wcbuf);
        RtlZeroMemory(&CopyFileInfo, sizeof(COPY_FILE_INFO));
		PMESrc.pme_Handle.fsh_FileHandle = NULL;
		PMEDst.pme_Handle.fsh_FileHandle = NULL;

		do
		{
			if (pConnDescD->cds_pVolDesc->vds_Flags & AFP_VOLUME_READONLY)
			{
				Status = AFP_ERR_VOLUME_LOCKED;
				break;
			}

			// Make sure the new name is valid
			pAnsiName = &pSda->sda_Name3;
			if ((pSda->sda_Name3.Length > 0) &&
				((pSda->sda_Name3.Length > AFP_FILENAME_LEN) ||
				((pSda->sda_PathType == AFP_SHORTNAME) &&
				 !AfpIsLegalShortname(&pSda->sda_Name3)) ||
				(!NT_SUCCESS(AfpConvertStringToMungedUnicode(&pSda->sda_Name3,
															 &uNewName)))))
				break;

			Status = AfpMapAfpPathForLookup(pReqPkt->_pConnDescS,
											pReqPkt->_SrcParentId,
											&pSda->sda_Name1,
											pSda->sda_PathType,
											DFE_FILE,
											FD_INTERNAL_BITMAP_OPENACCESS_READ |
												FD_BITMAP_ATTR |
												FD_BITMAP_LONGNAME |
												FD_BITMAP_FINDERINFO |
												FILE_BITMAP_RESCLEN |
												FILE_BITMAP_DATALEN |
												FD_INTERNAL_BITMAP_DENYMODE_WRITE,
											&PMESrc,
											&FDParmSrc);

			if (!NT_SUCCESS(Status))
			{
				break;
			}

			// Source opened ok. However we may have an internal deny conflict
			// Check that
			if (((Status = AfpCheckDenyConflict(pReqPkt->_pConnDescS->cds_pVolDesc,
												FDParmSrc._fdp_AfpId,
												False,
												FORK_OPEN_READ,
												FORK_DENY_WRITE,
												NULL)) != AFP_ERR_NONE) ||
				((Status = AfpCheckDenyConflict(pReqPkt->_pConnDescS->cds_pVolDesc,
												FDParmSrc._fdp_AfpId,
												True,
												FORK_OPEN_READ,
												FORK_DENY_WRITE,
												NULL)) != AFP_ERR_NONE))
			{
				Status = AFP_ERR_DENY_CONFLICT;
				break;
			}

			pSwmr = &pConnDescD->cds_pVolDesc->vds_IdDbAccessLock;
			AfpSwmrAcquireExclusive(pSwmr);
			DstLockTaken = True;

			// Map the destination directory for Lookup
			if (!NT_SUCCESS(Status = AfpMapAfpPath(pConnDescD,
												   pReqPkt->_DstParentId,
												   &pSda->sda_Name2,
												   pSda->sda_PathType,
												   Lookup,
												   DFE_DIR,
												   0,
												   &PMEDst,
												   &FDParmDst)))
			{
				break;
			}

			AfpImpersonateClient(pSda);
			
			// If no new name was supplied, we need to use the
			// current name
			if (pSda->sda_Name3.Length == 0)
			{
				Rename = False;
				pAnsiName = &FDParmSrc._fdp_LongName;
				AfpConvertStringToMungedUnicode(pAnsiName,
												&uNewName);
			}

			// since we really want the path of the thing we are about
			// to create, munge the strings in the PMEDst
			PMEDst.pme_ParentPath = PMEDst.pme_FullPath;
			if (PMEDst.pme_FullPath.Length > 0)
			{
				PMEDst.pme_FullPath.Buffer[PMEDst.pme_FullPath.Length / sizeof(WCHAR)] = L'\\';
				PMEDst.pme_FullPath.Length += sizeof(WCHAR);
			}
			Status = RtlAppendUnicodeStringToString(&PMEDst.pme_FullPath,
													&uNewName);
			ASSERT(NT_SUCCESS(Status));

			InRoot = (PMEDst.pme_ParentPath.Length == 0) ? True : False;
			Status = AfpIoCopyFile1(&PMESrc.pme_Handle,
									&PMEDst.pme_Handle,
									&uNewName,
									pConnDescD->cds_pVolDesc,
									&PMEDst.pme_FullPath,
									InRoot ? NULL : &PMEDst.pme_ParentPath,
									&CopyFileInfo);

			AfpRevertBack();

			if (!NT_SUCCESS(Status))
			{
				break;
			}

			// Add this entry to the IdDb. First find the parent directory
			pDfeParent = AfpFindDfEntryById(pConnDescD->cds_pVolDesc,
											FDParmDst._fdp_AfpId,
											DFE_DIR);
			ASSERT(pDfeParent != NULL);
			pNewDfe = AfpAddDfEntry(pConnDescD->cds_pVolDesc,
									pDfeParent,
									&uNewName,
									False,
									0);

			Status = AFP_ERR_MISC; // Assume failure
			if (pNewDfe != NULL)
			{
				// Put the new file's AFPId into the AfpInfo stream
				AfpInitializeFDParms(&FDParmDst);
				FDParmDst._fdp_Flags = DFE_FLAGS_FILE_NO_ID;
				FDParmDst._fdp_AfpId = pNewDfe->dfe_AfpId;
				FDParmDst._fdp_BackupTime = BEGINNING_OF_TIME;

	            // Copy the finderinfo from the source to the destination
				// Also clear the inited bit so that finder will assign
				// new coordinates for the new file.
				FDParmDst._fdp_FinderInfo = FDParmSrc._fdp_FinderInfo;
				FDParmDst._fdp_FinderInfo.fd_Attr1 &= ~FINDER_FLAG_SET;
				AfpConvertMungedUnicodeToAnsi(&pNewDfe->dfe_UnicodeName,
											  &FDParmDst._fdp_LongName);

				Status = AfpSetAfpInfo(&CopyFileInfo.cfi_DstStreamHandle[0],
									   FILE_BITMAP_FILENUM	|
									   FD_BITMAP_BACKUPTIME	|
									   FD_BITMAP_FINDERINFO,
									   &FDParmDst,
									   NULL,
									   NULL);

				if (NT_SUCCESS(Status))
				{
					// Get the rest of the File info, and cache it
					Status = AfpIoQueryTimesnAttr(&CopyFileInfo.cfi_SrcStreamHandle[0],
												  &pNewDfe->dfe_CreateTime,
												  &pNewDfe->dfe_LastModTime,
												  NULL);
					
					if (NT_SUCCESS(Status))
					{
			            // Copy the finderinfo into the destination DFE.
						// Use the FDParmDst version since it has the right
						// version - see above.
						pNewDfe->dfe_FinderInfo = FDParmDst._fdp_FinderInfo;
						pNewDfe->dfe_BackupTime = BEGINNING_OF_TIME;
						pNewDfe->dfe_AfpAttr = FDParmSrc._fdp_Attr &
														~(FD_BITMAP_ATTR_SET |
														  FILE_BITMAP_ATTR_DATAOPEN |
														  FILE_BITMAP_ATTR_RESCOPEN);
						pNewDfe->dfe_NtAttr =  (USHORT)AfpConvertAfpAttrToNTAttr(pNewDfe->dfe_AfpAttr);
						pNewDfe->dfe_DataLen = FDParmSrc._fdp_DataForkLen;
						pNewDfe->dfe_RescLen = FDParmSrc._fdp_RescForkLen;
	
						AfpCacheParentModTime(pConnDescD->cds_pVolDesc,
											  NULL,
											  &PMEDst.pme_ParentPath,
											  pNewDfe->dfe_Parent,
											  0);
					}

					// Set the attributes such that it matches the source
					Status = AfpIoSetTimesnAttr(&CopyFileInfo.cfi_DstStreamHandle[0],
												NULL,
												NULL,
												pNewDfe->dfe_NtAttr,
												0,
												pConnDescD->cds_pVolDesc,
												&PMEDst.pme_FullPath);
				}

				if (!NT_SUCCESS(Status))
				{
					// If we failed to write the correct AfpId onto the
					// new file, then delete the file, and remove it from
					// the Id database.
					AfpIoMarkFileForDelete(&CopyFileInfo.cfi_DstStreamHandle[0],
										   pConnDescD->cds_pVolDesc,
										   &PMEDst.pme_FullPath,
										   InRoot ? NULL : &PMEDst.pme_ParentPath);

					AfpDeleteDfEntry(pConnDescD->cds_pVolDesc, pNewDfe);
					Status = AFP_ERR_MISC;
				}
			}
		} while (False);

		if (DstLockTaken == True)
			AfpSwmrRelease(pSwmr);

		// If we have successfully come so far, go ahead and complete the copy
		if (Status == AFP_ERR_NONE)
		{
			Status = AfpIoCopyFile2(&CopyFileInfo,
									pConnDescD->cds_pVolDesc,
									&PMEDst.pme_FullPath,
									InRoot ? NULL : &PMEDst.pme_ParentPath);
			if (Status == AFP_ERR_NONE)
			{
				// We need to get the create and modified time from the source
				// file before we close it.
				AfpIoQueryTimesnAttr(&pCopyFileInfo->cfi_SrcStreamHandle[0],
									 &CreateTime,
									 &ModTime,
									 NULL);

				aModTime = AfpConvertTimeToMacFormat(&ModTime);

			} else {

				AfpSwmrAcquireExclusive(pSwmr);
				// Note that we cannot use pNewDfe. We need to remap. It could have
				// got deleted when we relinquished the Swmr.
				pNewDfe = AfpFindDfEntryById(pConnDescD->cds_pVolDesc,
											  FDParmDst._fdp_AfpId,
											  DFE_FILE);
				if (pNewDfe != NULL)
					AfpDeleteDfEntry(pConnDescD->cds_pVolDesc, pNewDfe);
				AfpSwmrRelease(pSwmr);
			}

            // update the disk quota for this user on the destination volume
            if (pConnDescD->cds_pVolDesc->vds_Flags & VOLUME_DISKQUOTA_ENABLED)
            {
                if (AfpConnectionReferenceByPointer(pConnDescD) != NULL)
                {
                    afpUpdateDiskQuotaInfo(pConnDescD);
                }
            }
		}

		// Close the source file and dest directory handles
		if (PMESrc.pme_Handle.fsh_FileHandle != NULL)
			AfpIoClose(&PMESrc.pme_Handle);
		if (PMEDst.pme_Handle.fsh_FileHandle != NULL)
			AfpIoClose(&PMEDst.pme_Handle);

		// Close all the handles, Free the handle space. We come here regardless
		// of success/error. MAKE SURE THE SOURCE HANDLE IS NOT CLOSED HERE SINCE
		// IT HAS BEEN CLOSED ABOVE.
		// MAKE SURE THE DESTINATION HANDLE IS NOT CLOSED HERE SINCE WE NEED IT TO
		// SET THE FILE TIME.
		for (i = 1; i < CopyFileInfo.cfi_NumStreams; i++)
		{
			if (CopyFileInfo.cfi_SrcStreamHandle[i].fsh_FileHandle != NULL)
			{
				AfpIoClose(&CopyFileInfo.cfi_SrcStreamHandle[i]);
			}
			if (CopyFileInfo.cfi_DstStreamHandle[i].fsh_FileHandle != NULL)
			{
				AfpIoClose(&CopyFileInfo.cfi_DstStreamHandle[i]);
			}
		}

		if ((CopyFileInfo.cfi_DstStreamHandle != NULL) &&
		    (CopyFileInfo.cfi_DstStreamHandle[0].fsh_FileHandle != NULL))
		{
			if (Status == AFP_ERR_NONE)
			{
				// Set the creation and modification date on the destination
				// file to match that of the source file
				AfpIoSetTimesnAttr(&pCopyFileInfo->cfi_DstStreamHandle[0],
								   &CreateTime,
								   &aModTime,
								   0,
								   0,
								   pConnDescD->cds_pVolDesc,
								   &PMEDst.pme_FullPath);
			}
			AfpIoClose(&CopyFileInfo.cfi_DstStreamHandle[0]);
		}

		if (PMEDst.pme_FullPath.Buffer != NULL)
			AfpFreeMemory(PMEDst.pme_FullPath.Buffer);

		if (CopyFileInfo.cfi_SrcStreamHandle != NULL)
			AfpFreeMemory(CopyFileInfo.cfi_SrcStreamHandle);
		if (CopyFileInfo.cfi_DstStreamHandle != NULL)
			AfpFreeMemory(CopyFileInfo.cfi_DstStreamHandle);

		AfpConnectionDereference(pConnDescD);
	}

	return Status;
}


/***	AfpFspDispCreateId
 *
 *	This is the worker routine for the AfpCreateId API.
 *
 *	The request packet is represented below.
 *
 *	sda_ReqBlock	PCONNDESC	pConnDesc
 *	sda_ReqBlock	DWORD		ParentId
 *	sda_Name1		ANSI_STRING	Path
 */
AFPSTATUS FASTCALL
AfpFspDispCreateId(
	IN	PSDA	pSda
)
{
	AFPSTATUS		Status = AFP_ERR_PARAM, Status2;
	FILEDIRPARM		FDParm;
	PATHMAPENTITY	PME;
	struct _RequestPacket
	{
		PCONNDESC	_pConnDesc;
		DWORD		_ParentId;
	};
	struct _ResponsePacket
	{
		BYTE	__FileId[4];
	};

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_AFPAPI_FILE, DBG_LEVEL_INFO,
										("AfpFspDispCreateId: Entered\n"));

	ASSERT(VALID_CONNDESC(pReqPkt->_pConnDesc) &&
		   VALID_VOLDESC(pReqPkt->_pConnDesc->cds_pVolDesc));
	
	do
	{
		AfpInitializePME(&PME, 0, NULL);
		Status = AfpMapAfpPathForLookup(pReqPkt->_pConnDesc,
										pReqPkt->_ParentId,
										&pSda->sda_Name1,
										pSda->sda_PathType,
										DFE_FILE,
										FILE_BITMAP_FILENUM | FD_INTERNAL_BITMAP_OPENACCESS_READ,
										&PME,
										&FDParm);
        // if we get sharing violation we know we have read access to the file
		if (!NT_SUCCESS(Status) && (Status != AFP_ERR_DENY_CONFLICT))
			break;

		// Set the bit in DF Entry
		Status = AfpSetDFFileFlags(pReqPkt->_pConnDesc->cds_pVolDesc,
								   FDParm._fdp_AfpId,
								   0,
								   True,
								   False);
	} while (False);

	if ((Status == AFP_ERR_VOLUME_LOCKED) && (FDParm._fdp_Flags & DFE_FLAGS_FILE_WITH_ID))
	{
		// If the volume is locked, but an Id exists, return it
		Status = AFP_ERR_ID_EXISTS;
	}

	if ((Status == AFP_ERR_NONE) || (Status == AFP_ERR_ID_EXISTS))
	{
		pSda->sda_ReplySize = SIZE_RESPPKT;
		if ((Status2 = AfpAllocReplyBuf(pSda)) == AFP_ERR_NONE)
		{
			PUTDWORD2DWORD(pRspPkt->__FileId, FDParm._fdp_AfpId);
		}
		else
		{
			Status = Status2;
		}
	}

	// Return before we close thus saving some time
	AfpCompleteApiProcessing(pSda, Status);

	if (PME.pme_Handle.fsh_FileHandle != NULL)
		AfpIoClose(&PME.pme_Handle);

	return AFP_ERR_EXTENDED;
}


/***	AfpFspDispResolveId
 *
 *	This is the worker routine for the AfpResolveId API.
 *
 *	The request packet is represented below.
 *
 *	sda_ReqBlock	PCONNDESC	pConnDesc
 *	sda_ReqBlock	DWORD		FileId
 *	sda_ReqBlock	DWORD		Bitmap
 */
AFPSTATUS FASTCALL
AfpFspDispResolveId(
	IN	PSDA	pSda
)
{
	DWORD			Bitmap;
	AFPSTATUS		Status = AFP_ERR_PARAM;
	FILEDIRPARM		FDParm;
	PATHMAPENTITY	PME;
	struct _RequestPacket
	{
		PCONNDESC	_pConnDesc;
		DWORD		_FileId;
		DWORD		_Bitmap;
	};
	struct _ResponsePacket
	{
		BYTE	__Bitmap[2];
		// Rest of the parameters
	};

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_AFPAPI_FILE, DBG_LEVEL_INFO,
										("AfpFspDispResolveId: Entered\n"));
	ASSERT(VALID_CONNDESC(pReqPkt->_pConnDesc) &&
		   VALID_VOLDESC(pReqPkt->_pConnDesc->cds_pVolDesc));
	
	Bitmap = pReqPkt->_Bitmap;

	do
	{
		AfpInitializeFDParms(&FDParm);
		AfpInitializePME(&PME, 0, NULL);

		// HACK: this is to make System 7.5 FindFile not grey out the first
		// item in the list of items found.  Normally we would check for
		// parameter non-zero in the api table in afpapi.c and return an
		// error there, but this is a special case.
		if (pReqPkt->_FileId == 0)
		{
			Status = AFP_ERR_ID_NOT_FOUND;
			break;
		}

		Status = AfpMapAfpIdForLookup(pReqPkt->_pConnDesc,
								pReqPkt->_FileId,
								DFE_FILE,
								Bitmap | FD_INTERNAL_BITMAP_OPENACCESS_READ,
								&PME,
								&FDParm);
		if (!NT_SUCCESS(Status) && (Status != AFP_ERR_DENY_CONFLICT))
		{								
			if (Status == AFP_ERR_OBJECT_NOT_FOUND)
			{
				Status = AFP_ERR_ID_NOT_FOUND;
			}
			break;
		}

		// a deny conflict means the user actually has access to the file, so
		// we need to open for nothing with no sharing modes to get the
		// bitmap parameters.
		if (Status == AFP_ERR_DENY_CONFLICT)
		{
			Status = AfpMapAfpIdForLookup(pReqPkt->_pConnDesc,
										  pReqPkt->_FileId,
										  DFE_FILE,
										  Bitmap,
										  &PME,
										  &FDParm);
			if (!NT_SUCCESS(Status))
			{
				if (Status == AFP_ERR_OBJECT_NOT_FOUND)
				{
					Status = AFP_ERR_ID_NOT_FOUND;
				}
				break;
			}

		}

		if (!(FDParm._fdp_Flags & DFE_FLAGS_FILE_WITH_ID))
		{
			Status = AFP_ERR_ID_NOT_FOUND;
			break;
		}

		pSda->sda_ReplySize = SIZE_RESPPKT +
						EVENALIGN(AfpGetFileDirParmsReplyLength(&FDParm, Bitmap));
	
		if ((Status = AfpAllocReplyBuf(pSda)) == AFP_ERR_NONE)
		{
			AfpPackFileDirParms(&FDParm, Bitmap, pSda->sda_ReplyBuf + SIZE_RESPPKT);
			PUTDWORD2SHORT(pRspPkt->__Bitmap, Bitmap);
		}
	} while (False);

	if (PME.pme_Handle.fsh_FileHandle != NULL)
		AfpIoClose(&PME.pme_Handle);

	return Status;
}


/***	AfpFspDispDeleteId
 *
 *	This is the worker routine for the AfpDeleteId API.
 *
 *	The request packet is represented below.
 *
 *	sda_ReqBlock	PCONNDESC	pConnDesc
 *	sda_ReqBlock	DWORD		FileId
 */
AFPSTATUS FASTCALL
AfpFspDispDeleteId(
	IN	PSDA	pSda
)
{
	AFPSTATUS		Status = AFP_ERR_PARAM;
	FILEDIRPARM		FDParm;
	PATHMAPENTITY	PME;
	struct _RequestPacket
	{
		PCONNDESC	_pConnDesc;
		DWORD		_FileId;
	};

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_AFPAPI_FILE, DBG_LEVEL_INFO,
										("AfpFspDispDeleteId: Entered\n"));

	ASSERT(VALID_CONNDESC(pReqPkt->_pConnDesc) &&
		   VALID_VOLDESC(pReqPkt->_pConnDesc->cds_pVolDesc));
	
	do
	{
		AfpInitializePME(&PME, 0, NULL);
		Status = AfpMapAfpIdForLookup(pReqPkt->_pConnDesc,
		                              pReqPkt->_FileId,
									  DFE_FILE,
									  FILE_BITMAP_FILENUM |
									   FD_INTERNAL_BITMAP_OPENACCESS_READWRITE,
									  &PME,
									  &FDParm);
		if (!NT_SUCCESS(Status) && (Status != AFP_ERR_DENY_CONFLICT))
		{
			if (Status == AFP_ERR_OBJECT_NOT_FOUND)
			{
				Status = AFP_ERR_ID_NOT_FOUND;
			}
			break;
		}

		// Set the bit in DF Entry
		Status = AfpSetDFFileFlags(pReqPkt->_pConnDesc->cds_pVolDesc,
								   FDParm._fdp_AfpId,
								   0,
								   False,
								   True);
	} while (False);

	// Return before we close thus saving some time
	AfpCompleteApiProcessing(pSda, Status);

	if (PME.pme_Handle.fsh_FileHandle != NULL)
		AfpIoClose(&PME.pme_Handle);

	return AFP_ERR_EXTENDED;
}


/***	AfpFspDispExchangeFiles
 *
 *	This is the worker routine for the AfpExchangeFiles API.
 *
 * Acquire the IdDb Swmr for Write and map both source and destination for
 * lookup (set to open the entities for DELETE access since we are going to
 * rename them). Check that we have the appropriate parent
 * permissions. Then rename source to destiation and vice versa (will need an
 * intermediate name - use a name > 31 chars so that it does not collide with
 * an existing name. Use characters that cannot be accessed by Win32 so that
 * side is taken care of as well (40 spaces should do it). Since we have the
 * Swmr held for WRITE, there is no issue of two different AfpExchangeFile
 * apis trying to rename to the same name). Then inter-change the file ids
 * and the FinderInfo in the AfpInfo streams. Also interchange the create
 * times (retain original ID and create time) on the files. Swap all the other
 * cached info in the 2 DFEntries.
 * Make sure the stuff is setup so that ChangeNotify filters are handled
 * appropriately.
 *
 * If either of the files are currently open, the name and ID in the
 * OpenForkDesc (that each OpenForkEntry points to) has to change to
 * the new name. Note that because the name and Id can now change in
 * the OpenForkDesc, we must make sure that everyone who accesses these
 * is taking appropriate locks.
 *
 *
 *	The request packet is represented below.
 *
 *	sda_ReqBlock	PCONNDESC	pConnDesc
 *	sda_ReqBlock	DWORD		Srce. DirId
 *	sda_ReqBlock	DWORD		Dest. DirId
 *	sda_Name1		ANSI_STRING	Srce. Path
 *	sda_Name2		ANSI_STRING	Dest. Path
 */
AFPSTATUS FASTCALL
AfpFspDispExchangeFiles(
	IN	PSDA	pSda
)
{
	PATHMAPENTITY	PMESrc, PMEDst;
	PVOLDESC		pVolDesc;
	FILEDIRPARM		FDParmSrc, FDParmDst;
	AFPSTATUS		Status = AFP_ERR_NONE, Status2 = AFP_ERR_NONE;
	BOOLEAN			Move = True, RevertBack = False, SrcInRoot, DstInRoot;
	BOOLEAN			RestoreSrcRO = False, RestoreDstRO = False;
	FILESYSHANDLE	hSrcParent, hDstParent;
	DWORD			checkpoint = 0; // denotes what needs cleanup on error
	DWORD			NTAttrSrc = 0, NTAttrDst = 0;
	WCHAR			PathBuf[BIG_PATH_LEN];
	UNICODE_STRING	TempPath;		// temporary filename for renaming files
	struct _RequestPacket
	{
		PCONNDESC	_pConnDesc;
		DWORD		_SrcParentId;
		DWORD		_DstParentId;
	};

#define _CHKPOINT_XCHG_DSTTOTEMP	1
#define _CHKPOINT_XCHG_SRCTODST		2
#define _CHKPOINT_XCHG_TEMPTOSRC	3

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_AFPAPI_FILE, DBG_LEVEL_INFO,
			("AfpFspDispExchangeFiles: Entered\n"));

	ASSERT(VALID_CONNDESC(pReqPkt->_pConnDesc) &&
		   VALID_VOLDESC(pReqPkt->_pConnDesc->cds_pVolDesc));

	pVolDesc = pReqPkt->_pConnDesc->cds_pVolDesc;

	AfpInitializeFDParms(&FDParmSrc);
	AfpInitializeFDParms(&FDParmDst);
	AfpInitializePME(&PMESrc, 0, NULL);
	AfpInitializePME(&PMEDst, 0, NULL);
	AfpSetEmptyUnicodeString(&TempPath, 0, NULL);
	hSrcParent.fsh_FileHandle = NULL;
	hDstParent.fsh_FileHandle = NULL;


	// Don't allow any fork operations that might access the FileId
	// in an OpenForkDesc that could get exchanged.
	AfpSwmrAcquireExclusive(&pVolDesc->vds_ExchangeFilesLock);

	AfpSwmrAcquireExclusive(&pVolDesc->vds_IdDbAccessLock);

	do
	{

		if (!NT_SUCCESS(Status = AfpMapAfpPath(pReqPkt->_pConnDesc,
											   pReqPkt->_SrcParentId,
											   &pSda->sda_Name1,
											   pSda->sda_PathType,
											   Lookup,
											   DFE_FILE,
											   FD_INTERNAL_BITMAP_OPENACCESS_DELETE |
												(FILE_BITMAP_MASK &
												~(FD_BITMAP_SHORTNAME | FD_BITMAP_PRODOSINFO)),
											   &PMESrc,
											   &FDParmSrc)))
		{
			break;
		}


		// Check for SeeFiles on the source parent dir
		if (!NT_SUCCESS(Status = AfpCheckParentPermissions(
												pReqPkt->_pConnDesc,
												FDParmSrc._fdp_ParentId,
												&PMESrc.pme_ParentPath,
												DIR_ACCESS_READ,
												&hSrcParent,
												NULL)))
		{
			break;
		}

		if (!NT_SUCCESS(Status = AfpCheckForInhibit(&PMESrc.pme_Handle,
											  FD_BITMAP_ATTR_RENAMEINH,
											  FDParmSrc._fdp_Attr,
											  &NTAttrSrc)))
		{
			break;
		}
		
		if (!NT_SUCCESS(Status = AfpMapAfpPath(pReqPkt->_pConnDesc,
											   pReqPkt->_DstParentId,
											   &pSda->sda_Name2,
											   pSda->sda_PathType,
											   Lookup,
											   DFE_FILE,
											   FD_INTERNAL_BITMAP_OPENACCESS_DELETE |
												(FILE_BITMAP_MASK &
												~(FD_BITMAP_SHORTNAME | FD_BITMAP_PRODOSINFO)),
											   &PMEDst,
											   &FDParmDst)))
		{
			break;
		}

		if (FDParmSrc._fdp_AfpId == FDParmDst._fdp_AfpId)
		{
			// make sure the src and dst are not the same file
			Status = AFP_ERR_SAME_OBJECT;
			break;
		}

		if (FDParmSrc._fdp_ParentId == FDParmDst._fdp_ParentId)
		{
			// if the parent directories are the same, we are not
			// moving anything to a new directory, so the change
			// notify we expect will be a rename in the source dir.
			Move = False;
		}
		else
		{
			// Check for SeeFiles on the destination parent dir
			if (!NT_SUCCESS(Status = AfpCheckParentPermissions(
													pReqPkt->_pConnDesc,
													FDParmDst._fdp_ParentId,
													&PMEDst.pme_ParentPath,
													DIR_ACCESS_READ,
													&hDstParent,
													NULL)))
			{
				break;
			}
		}

		if (!NT_SUCCESS(Status = AfpCheckForInhibit(&PMEDst.pme_Handle,
											  FD_BITMAP_ATTR_RENAMEINH,
											  FDParmDst._fdp_Attr,
											  &NTAttrDst)))
		{
			break;
		}


		//
		// Construct the path to the temporary filename for renaming during
		// the name exchange
		//
		TempPath.MaximumLength = PMEDst.pme_ParentPath.Length + sizeof(WCHAR) +
														AfpExchangeName.Length;
		TempPath.Buffer = PathBuf;
		if ((TempPath.MaximumLength > sizeof(PathBuf)) &&
			(TempPath.Buffer = (PWCHAR)AfpAllocNonPagedMemory(TempPath.MaximumLength)) == NULL)
		{
			Status = AFP_ERR_MISC;
			break;
		}

		AfpCopyUnicodeString(&TempPath, &PMEDst.pme_ParentPath);
		if (TempPath.Length != 0)
		{
			TempPath.Buffer[TempPath.Length / sizeof(WCHAR)] = L'\\';
			TempPath.Length += sizeof(WCHAR);
			ASSERT((TempPath.MaximumLength - TempPath.Length) >= AfpExchangeName.Length);
		}
		Status = RtlAppendUnicodeStringToString(&TempPath, &AfpExchangeName);
		ASSERT(NT_SUCCESS(Status));

		if (NTAttrSrc & FILE_ATTRIBUTE_READONLY)
		{
			// We must temporarily remove the ReadOnly attribute so that
			// we can rename the file/dir
			Status = AfpIoSetTimesnAttr(&PMESrc.pme_Handle,
										NULL,
										NULL,
										0,
										FILE_ATTRIBUTE_READONLY,
										pVolDesc,
										&PMESrc.pme_FullPath);
			if (!NT_SUCCESS(Status))
			{
				break;
			}
			else
				RestoreSrcRO = True;
		}

		if (NTAttrDst & FILE_ATTRIBUTE_READONLY)
		{
			// We must temporarily remove the ReadOnly attribute so that
			// we can rename the file/dir
			Status = AfpIoSetTimesnAttr(&PMEDst.pme_Handle,
										NULL,
										NULL,
										0,
										FILE_ATTRIBUTE_READONLY,
										pVolDesc,
										&PMEDst.pme_FullPath);
			if (!NT_SUCCESS(Status))
			{
				break;
			}
			else
				RestoreDstRO = True;
		}

		// We must impersonate to do the move since it is name based
		AfpImpersonateClient(pSda);
		RevertBack = True;

		SrcInRoot = (PMESrc.pme_ParentPath.Length == 0) ? True : False;
		DstInRoot = (PMEDst.pme_ParentPath.Length == 0) ? True : False;

		// First, rename the destination to a temporary name in the same
		// directory
		Status = AfpIoMoveAndOrRename(&PMEDst.pme_Handle,
									  NULL,
									  &AfpExchangeName,
									  pVolDesc,
									  &PMEDst.pme_FullPath,
									  DstInRoot ? NULL : &PMEDst.pme_ParentPath,
									  NULL,
									  NULL);

		if (NT_SUCCESS(Status))
		{
			checkpoint = _CHKPOINT_XCHG_DSTTOTEMP;
		}
		else
		{
			break;
		}

		// Next, rename the source to the destination name
		Status = AfpIoMoveAndOrRename(&PMESrc.pme_Handle,
									  Move ? &hDstParent : NULL,
									  &PMEDst.pme_UTail,
									  pVolDesc,
									  &PMESrc.pme_FullPath,
									  SrcInRoot ? NULL : &PMESrc.pme_ParentPath,
									  Move ? &PMEDst.pme_FullPath : NULL,
									  (Move && !DstInRoot) ? &PMEDst.pme_ParentPath : NULL);

		if (NT_SUCCESS(Status))
		{
			checkpoint = _CHKPOINT_XCHG_SRCTODST;
		}
		else
		{
			break;
		}


		// Finally, rename the temporary name to the source name
		Status = AfpIoMoveAndOrRename(&PMEDst.pme_Handle,
									  Move ? &hSrcParent : NULL,
									  &PMESrc.pme_UTail,
									  pVolDesc,
									  &TempPath,
									  DstInRoot ? NULL : &PMEDst.pme_ParentPath,
									  Move ? &PMESrc.pme_FullPath : NULL,
									  (Move && !SrcInRoot) ? &PMESrc.pme_ParentPath : NULL);

		if (NT_SUCCESS(Status))
		{
			checkpoint = _CHKPOINT_XCHG_TEMPTOSRC;
		}
		else
		{
			break;
		}

		AfpRevertBack();
		RevertBack = False;

		// Swap the FileIds and FinderInfo in the AfpInfo streams
		Status = AfpSetAfpInfo(&PMESrc.pme_Handle,
							   FILE_BITMAP_FILENUM | FD_BITMAP_FINDERINFO,
							   &FDParmDst,
							   NULL,
							   NULL);

		ASSERT(NT_SUCCESS(Status));
		Status = AfpSetAfpInfo(&PMEDst.pme_Handle,
							   FILE_BITMAP_FILENUM | FD_BITMAP_FINDERINFO,
							   &FDParmSrc,
							   NULL,
							   NULL);

		ASSERT(NT_SUCCESS(Status));
		// Swap the creation dates on the files
		Status = AfpIoSetTimesnAttr(&PMESrc.pme_Handle,
									&FDParmDst._fdp_CreateTime,
									NULL,
									0,
									0,
									pVolDesc,
									&PMEDst.pme_FullPath);
		ASSERT(NT_SUCCESS(Status));
		Status = AfpIoSetTimesnAttr(&PMEDst.pme_Handle,
									&FDParmSrc._fdp_CreateTime,
									NULL,
									0,
									0,
									pVolDesc,
									&PMESrc.pme_FullPath);
		ASSERT(NT_SUCCESS(Status));

		// All the physical file info that we *didn't* swap on the real
		// files, we need to swap in the DFEntries
		AfpExchangeIdEntries(pVolDesc,
							 FDParmSrc._fdp_AfpId,
							 FDParmDst._fdp_AfpId);

		// Now, if either of the 2 files is open, we have to update the
		// OpenForkDesc to contain the correct FileId (we don't bother
		// updating the path since we don't care if Admin shows the
		// original name of the file, even though it has been renamed)
		AfpExchangeForkAfpIds(pVolDesc,
							  FDParmSrc._fdp_AfpId,
							  FDParmDst._fdp_AfpId);

		// update the cached src and dest parent dir mod times
		AfpCacheParentModTime(pVolDesc,
							  &hSrcParent,
							  NULL,
							  NULL,
							  FDParmSrc._fdp_ParentId);

        if (Move)
		{
			AfpCacheParentModTime(pVolDesc,
								  &hDstParent,
								  NULL,
								  NULL,
								  FDParmDst._fdp_ParentId);
		}

	} while (False);

	// Use the checkpoint value to undo any renames that
	// need undoing if there was an error
	if (!NT_SUCCESS(Status))
	{
		switch(checkpoint)
		{
			case _CHKPOINT_XCHG_TEMPTOSRC:
			{
				// Need to rename the original dest back to temp name
				Status2 = AfpIoMoveAndOrRename(&PMEDst.pme_Handle,
											   Move ? &hDstParent : NULL,
											   &AfpExchangeName,
											   pVolDesc,
											   &PMESrc.pme_FullPath,
											   SrcInRoot ? NULL : &PMESrc.pme_ParentPath,
											   Move ? &TempPath : NULL,
											   (Move && !DstInRoot) ? &PMEDst.pme_ParentPath : NULL);
				if (!NT_SUCCESS(Status2))
				{
					break;
				}

				// fall thru;
			}
			case _CHKPOINT_XCHG_SRCTODST:
			{
				// Need to rename the dest back to original src name
				Status2 = AfpIoMoveAndOrRename(&PMESrc.pme_Handle,
											   Move ? &hSrcParent : NULL,
											   &PMESrc.pme_UTail,
											   pVolDesc,
											   &PMEDst.pme_FullPath,
											   DstInRoot ? NULL : &PMEDst.pme_ParentPath,
											   Move ? &PMESrc.pme_FullPath : NULL,
											   (Move && !SrcInRoot) ? &PMESrc.pme_ParentPath : NULL);
				
				if (!NT_SUCCESS(Status2))
				{
					break;
				}

				// fall thru;
			}
			case _CHKPOINT_XCHG_DSTTOTEMP:
			{
				// Need to rename the temp back to original dest name
				Status2 = AfpIoMoveAndOrRename(&PMEDst.pme_Handle,
											   NULL,
											   &PMEDst.pme_UTail,
											   pVolDesc,
											   &TempPath,
											   DstInRoot ? NULL : &PMEDst.pme_ParentPath,
											   NULL,
											   NULL);
				// update the cached src parent dir mod time
				AfpCacheParentModTime(pVolDesc,
									  &hSrcParent,
									  NULL,
									  NULL,
									  FDParmSrc._fdp_ParentId);
		
				if (Move)
				{
					// update the cached dest parent dir mod time
					AfpCacheParentModTime(pVolDesc,
										  &hDstParent,
										  NULL,
										  NULL,
										  FDParmDst._fdp_ParentId);
				}

				break;
			}
			default:
			{
				break;
			}

		} // end switch
	}

	// Set the ReadOnly attribute back on the files if need be
	// NOTE: will we get a notify for this since we havn't closed
	// the handle yet?
	if (RestoreSrcRO)
		AfpIoSetTimesnAttr(&PMESrc.pme_Handle,
							NULL,
							NULL,
							FILE_ATTRIBUTE_READONLY,
							0,
							NULL,
							NULL);
	if (RestoreDstRO)
		AfpIoSetTimesnAttr(&PMEDst.pme_Handle,
							NULL,
							NULL,
							FILE_ATTRIBUTE_READONLY,
							0,
							NULL,
							NULL);

	AfpSwmrRelease(&pVolDesc->vds_IdDbAccessLock);
	AfpSwmrRelease(&pVolDesc->vds_ExchangeFilesLock);

	if (RevertBack)
		AfpRevertBack();

	if (PMESrc.pme_Handle.fsh_FileHandle != NULL)
		AfpIoClose(&PMESrc.pme_Handle);

	if (PMEDst.pme_Handle.fsh_FileHandle != NULL)
		AfpIoClose(&PMEDst.pme_Handle);

	if (hSrcParent.fsh_FileHandle != NULL)
		AfpIoClose(&hSrcParent);

	if (hDstParent.fsh_FileHandle != NULL)
		AfpIoClose(&hDstParent);

	if ((TempPath.Buffer != NULL) &&
		(TempPath.Buffer != PathBuf))
		AfpFreeMemory(TempPath.Buffer);

	if (PMESrc.pme_FullPath.Buffer != NULL)
		AfpFreeMemory(PMESrc.pme_FullPath.Buffer);

	if (PMEDst.pme_FullPath.Buffer != NULL)
		AfpFreeMemory(PMEDst.pme_FullPath.Buffer);

	return Status;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\server\fsp_fork.c ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	fsp_fork.c

Abstract:

	This module contains the entry points for the AFP fork APIs queued to
	the FSP. These are all callable from FSP Only.

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	25 Apr 1992		Initial Version

Notes:	Tab stop: 4
--*/

#define	FILENUM	FILE_FSP_FORK

#include <afp.h>
#include <gendisp.h>
#include <fdparm.h>
#include <pathmap.h>
#include <forkio.h>

#ifdef ALLOC_PRAGMA
// #pragma alloc_text( PAGE, AfpFspDispOpenFork)		// Do not page this out for perf.
// #pragma alloc_text( PAGE, AfpFspDispCloseFork)		// Do not page this out for perf.
#pragma alloc_text( PAGE, AfpFspDispGetForkParms)
#pragma alloc_text( PAGE, AfpFspDispSetForkParms)
// #pragma alloc_text( PAGE, AfpFspDispRead)			// Do not page this out for perf.
// #pragma alloc_text( PAGE, AfpFspDispWrite)           // Do not page this out for perf.
#pragma alloc_text( PAGE, AfpFspDispByteRangeLock)
#pragma alloc_text( PAGE, AfpFspDispFlushFork)
#endif

/***	AfpFspDispOpenFork
 *
 *	This is the worker routine for the AfpOpenFork API.
 *
 *	The request packet is represented below.
 *
 *	sda_AfpSubFunc	BYTE		Resource/Data Flag
 *	sda_ReqBlock	PCONNDESC	pConnDesc
 *	sda_ReqBlock	DWORD		ParentDirId
 *	sda_ReqBlock	DWORD		Bitmap
 *	sda_ReqBlock	DWORD		AccessMode
 *	sda_Name1		ANSI_STRING	Path
 */
AFPSTATUS FASTCALL
AfpFspDispOpenFork(
	IN	PSDA	pSda
)
{
	DWORD			Bitmap, BitmapI;
	AFPSTATUS		RetCode = AFP_ERR_NONE, Status = AFP_ERR_PARAM;
	FILEDIRPARM		FDParm;
	PVOLDESC		pVolDesc;
	PATHMAPENTITY	PME;
	PCONNDESC		pConnDesc;
	POPENFORKENTRY	pOpenForkEntry = NULL;
	BOOLEAN			Resource, CleanupLock = False;
	BYTE			OpenMode = 0;
	UNICODE_STRING	ParentPath;
	struct _RequestPacket
	{
		 PCONNDESC	_pConnDesc;
		 DWORD		_ParentDirId;
		 DWORD		_Bitmap;
		 DWORD		_AccessMode;
	};
	struct _ResponsePacket
	{
		BYTE		__Bitmap[2];
		BYTE		__OForkRefNum[2];
	};
#if DBG
	static PBYTE	OpenDeny[] = { "None", "Read", "Write", "ReadWrite" };
#endif

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_AFPAPI_FORK, DBG_LEVEL_INFO,
			("AfpFspDispOpenFork: Entered - Session %ld\n", pSda->sda_SessionId));

	pConnDesc = pReqPkt->_pConnDesc;

	ASSERT(VALID_CONNDESC(pConnDesc));

	pVolDesc = pConnDesc->cds_pVolDesc;

	ASSERT(VALID_VOLDESC(pVolDesc));

	Bitmap = pReqPkt->_Bitmap;

	Resource = ((pSda->sda_AfpSubFunc & FORK_RSRC) == FORK_RSRC) ? True : False;

	if ((Resource && (Bitmap & FILE_BITMAP_DATALEN))  ||
		(!Resource && (Bitmap & FILE_BITMAP_RESCLEN)))
	{
		return AFP_ERR_BITMAP;
	}

	do
	{
		AfpInitializeFDParms(&FDParm);
		AfpInitializePME(&PME, 0, NULL);

		// We will use the PME.pme_Handle for open fork handle
		OpenMode = (BYTE)(pReqPkt->_AccessMode & FORK_OPEN_MASK);

		// Validate volume type and open modes
		if (!IS_CONN_NTFS(pConnDesc) && !IS_CONN_CD_HFS(pConnDesc))
		{
			// Resource fork only supported on NTFS and CD-HFS
			if (Resource)
			{
				Status = AFP_ERR_OBJECT_NOT_FOUND;
				break;
			}
			if (OpenMode & FORK_OPEN_WRITE)
			{
				Status = AFP_ERR_VOLUME_LOCKED;
				break;
			}
		}
		else if ((OpenMode & FORK_OPEN_WRITE) && IS_VOLUME_RO(pVolDesc))
		{
			Status = AFP_ERR_VOLUME_LOCKED;
			break;
		}

		BitmapI = FILE_BITMAP_FILENUM		|
				  FD_BITMAP_PARENT_DIRID	|
				  FD_INTERNAL_BITMAP_RETURN_PMEPATHS;

		// Encode the open access into the bitmap for pathmap
		// to use when opening the fork.
		if (Resource)
		{
			BitmapI |= FD_INTERNAL_BITMAP_OPENFORK_RESC;
		}
		if (OpenMode & FORK_OPEN_READ)
		{
			BitmapI |= FD_INTERNAL_BITMAP_OPENACCESS_READ;
		}
		if (OpenMode & FORK_OPEN_WRITE)
		{
			BitmapI |= FD_INTERNAL_BITMAP_OPENACCESS_WRITE;
		}

		// Encode the deny mode into the bitmap for pathmap
		// to use when opening the fork.
		BitmapI |= ((pReqPkt->_AccessMode >> FORK_DENY_SHIFT) &
					FORK_DENY_MASK) <<
					FD_INTERNAL_BITMAP_DENYMODE_SHIFT;

		DBGPRINT(DBG_COMP_AFPAPI_FORK, DBG_LEVEL_INFO,
				("AfpFspDispOpenFork: OpenMode %s, DenyMode %s\n",
				OpenDeny[(pReqPkt->_AccessMode & FORK_OPEN_MASK)],
				OpenDeny[(pReqPkt->_AccessMode >> FORK_DENY_SHIFT) & FORK_DENY_MASK]));

		//
		// Don't allow an FpExchangeFiles to occur while we are referencing
		// the DFE FileId -- we want to make sure we put the right ID into
		// the OpenForkDesc!!
		//
		AfpSwmrAcquireExclusive(&pVolDesc->vds_ExchangeFilesLock);
		CleanupLock = True;
		if ((Status = AfpMapAfpPathForLookup(pConnDesc,
											 pReqPkt->_ParentDirId,
											 &pSda->sda_Name1,
											 pSda->sda_PathType,
											 DFE_FILE,
											 Bitmap | BitmapI |
											 // Need these for drop folder
											 // checking
											 FILE_BITMAP_DATALEN | FILE_BITMAP_RESCLEN,
											 &PME,
											 &FDParm)) != AFP_ERR_NONE)
		{
			DBGPRINT(DBG_COMP_AFPAPI_FORK, DBG_LEVEL_INFO,
				("AfpFspDispOpenFork: AfpMapAfpPathForLookup %lx\n", Status));

			// If we got a DENY_CONFLICT error, then we still need the parameters
			// Do an open for nothing with no deny modes to get the parameters.
			PME.pme_Handle.fsh_FileHandle = NULL;
			if (Status == AFP_ERR_DENY_CONFLICT)
			{
				AFPSTATUS	xxStatus;

				// Free up any path-buffer allocated
				if (PME.pme_FullPath.Buffer != NULL)
				{
					DBGPRINT(DBG_COMP_FORKS, DBG_LEVEL_INFO,
							("AfpFspDispOpenFork: (DenyConflict) Freeing path buffer %lx\n",
							PME.pme_FullPath.Buffer));
					AfpFreeMemory(PME.pme_FullPath.Buffer);
				}
				AfpInitializePME(&PME, 0, NULL);

				BitmapI = FILE_BITMAP_FILENUM		|
							FD_BITMAP_PARENT_DIRID	|
							FD_INTERNAL_BITMAP_RETURN_PMEPATHS;
				if (Resource)
				{
					BitmapI |= FD_INTERNAL_BITMAP_OPENFORK_RESC;
				}
				xxStatus = AfpMapAfpPathForLookup(pConnDesc,
												 pReqPkt->_ParentDirId,
												 &pSda->sda_Name1,
												 pSda->sda_PathType,
												 DFE_FILE,
												 Bitmap | BitmapI,
												 &PME,
												 &FDParm);
				if (!NT_SUCCESS(xxStatus))
				{
					PME.pme_Handle.fsh_FileHandle = NULL;
					Status = xxStatus;
					break;
				}
			}
			else break;
		}

		if (Status == AFP_ERR_NONE)
		{
			Status = AfpForkOpen(pSda,
								 pConnDesc,
								 &PME,
								 &FDParm,
								 pReqPkt->_AccessMode,
								 Resource,
								 &pOpenForkEntry,
								 &CleanupLock);
		}

		// At this point we have either successfully opened the fork,
		// encountered a DENY_CONFLICT or some other error.
		if ((Status != AFP_ERR_NONE) &&
			(Status != AFP_ERR_DENY_CONFLICT))
			break;

		// Do drop folder sanity check if someone tries to open for Write only
		if ((Status == AFP_ERR_NONE) &&
			(OpenMode == FORK_OPEN_WRITE) &&
			((FDParm._fdp_RescForkLen != 0) ||
			 (FDParm._fdp_DataForkLen != 0)))
		{
			ASSERT (VALID_OPENFORKENTRY(pOpenForkEntry));

			// If either fork is not empty, and one of them is being
			// opened for write, the user must also have READ access
			// to the parent directory.
			ParentPath = pOpenForkEntry->ofe_pOpenForkDesc->ofd_FilePath;
			// adjust the length to not include the filename
			ParentPath.Length -= pOpenForkEntry->ofe_pOpenForkDesc->ofd_FileName.Length;
			if (ParentPath.Length > 0)
			{
				ParentPath.Length -= sizeof(WCHAR);
			}

			AfpSwmrAcquireExclusive(&pVolDesc->vds_IdDbAccessLock);
			Status = AfpCheckParentPermissions(pConnDesc,
								               FDParm._fdp_ParentId,
											   &ParentPath,
											   DIR_ACCESS_READ,
											   NULL,
											   NULL);
			AfpSwmrRelease(&pVolDesc->vds_IdDbAccessLock);
			//
			// We are no longer referencing the FileId or path kept
			// in the OpenForkDesc.  Ok for FpExchangeFiles to resume.
			//
			AfpSwmrRelease(&pVolDesc->vds_ExchangeFilesLock);
			CleanupLock = False;

			if (Status != AFP_ERR_NONE)
			{
				AfpForkClose(pOpenForkEntry);
				AfpForkDereference(pOpenForkEntry);

				// set this to null so it wont be upgraded/deref'd
				// in cleanup below
				pOpenForkEntry = NULL;

				// Set handle to null since it was closed in AfpForkClose
				// and we wont want it to be closed in cleanup below
				PME.pme_Handle.fsh_FileHandle = NULL;
				break;
			}
		}
		else
		{
			AfpSwmrRelease(&pVolDesc->vds_ExchangeFilesLock);
			CleanupLock = False;
		}

		if (RetCode == AFP_ERR_NONE)
		{
			pSda->sda_ReplySize = SIZE_RESPPKT +
						EVENALIGN(AfpGetFileDirParmsReplyLength(&FDParm, Bitmap));

			if ((RetCode = AfpAllocReplyBuf(pSda)) != AFP_ERR_NONE)
			{
				if (pOpenForkEntry != NULL)
					AfpForkClose(pOpenForkEntry);
				break;
			}
			AfpPackFileDirParms(&FDParm,
								Bitmap,
								pSda->sda_ReplyBuf + SIZE_RESPPKT);
			PUTDWORD2SHORT(pRspPkt->__Bitmap, Bitmap);
			PUTDWORD2SHORT(pRspPkt->__OForkRefNum, (pOpenForkEntry == NULL) ?
									0 : pOpenForkEntry->ofe_OForkRefNum);
			if (Status == AFP_ERR_NONE)
			{
				INTERLOCKED_INCREMENT_LONG(&pConnDesc->cds_cOpenForks);
			}
		}
		else Status = RetCode;
	} while (False);


	if (CleanupLock)
	{
		AfpSwmrRelease(&pVolDesc->vds_ExchangeFilesLock);
	}

    // update the disk quota for this user
    if (pVolDesc->vds_Flags & VOLUME_DISKQUOTA_ENABLED)
    {
        if (AfpConnectionReferenceByPointer(pConnDesc) != NULL)
        {
            afpUpdateDiskQuotaInfo(pConnDesc);
        }
    }

	if (pOpenForkEntry != NULL)
	{
		if (Status == AFP_ERR_NONE)
			AfpUpgradeHandle(&pOpenForkEntry->ofe_FileSysHandle);
		AfpForkDereference(pOpenForkEntry);
	}

	if (!NT_SUCCESS(Status))
	{
		if (PME.pme_Handle.fsh_FileHandle != NULL)
			AfpIoClose(&PME.pme_Handle);
	}

	if (PME.pme_FullPath.Buffer != NULL)
	{
		DBGPRINT(DBG_COMP_FORKS, DBG_LEVEL_INFO,
				("AfpFspDispOpenFork: Freeing path buffer %lx\n",
				PME.pme_FullPath.Buffer));
		AfpFreeMemory(PME.pme_FullPath.Buffer);
	}

	DBGPRINT(DBG_COMP_AFPAPI_FORK, DBG_LEVEL_INFO,
			("AfpFspDispOpenFork: Returning %ld\n", Status));

	return Status;
}



/***	AfpFspDispCloseFork
 *
 *	This is the worker routine for the AfpCloseFork API.
 *
 *	The request packet is represented below.
 *
 *	sda_ReqBlock	POPENFORKENTRY	pOpenForkEntry
 */
AFPSTATUS FASTCALL
AfpFspDispCloseFork(
	IN	PSDA	pSda
)
{
	struct _RequestPacket
	{
		 POPENFORKENTRY	_pOpenForkEntry;
	};

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_AFPAPI_FORK, DBG_LEVEL_INFO,
			("AfpFspDispCloseFork: Entered - Session %ld, Fork %ld\n",
			pSda->sda_SessionId, pReqPkt->_pOpenForkEntry->ofe_ForkId));

	ASSERT(VALID_OPENFORKENTRY(pReqPkt->_pOpenForkEntry));

	AfpForkClose(pReqPkt->_pOpenForkEntry);

	return AFP_ERR_NONE;
}



/***	AfpFspDispGetForkParms
 *
 *	This is the worker routine for the AfpGetForkParms API.
 *
 *	The request packet is represented below.
 *
 *	sda_ReqBlock	POPENFORKENTRY	pOpenForkEntry
 *	sda_ReqBlock	DWORD			Bitmap
 */
AFPSTATUS FASTCALL
AfpFspDispGetForkParms(
	IN	PSDA	pSda
)
{
	FILEDIRPARM		FDParm;
	DWORD			Bitmap;
	AFPSTATUS		Status = AFP_ERR_PARAM;
	struct _RequestPacket
	{
		POPENFORKENTRY	_pOpenForkEntry;
		DWORD  			_Bitmap;
	};
	struct _ResponsePacket
	{
		BYTE	__Bitmap[2];
	};

	PAGED_CODE( );

	ASSERT(VALID_OPENFORKENTRY(pReqPkt->_pOpenForkEntry));

	DBGPRINT(DBG_COMP_AFPAPI_FORK, DBG_LEVEL_INFO,
			("AfpFspDispGetForkParms: Entered Session %ld, Fork %ld\n",
			pSda->sda_SessionId, pReqPkt->_pOpenForkEntry->ofe_ForkId));

	Bitmap = pReqPkt->_Bitmap;

	do
	{
		if ((RESCFORK(pReqPkt->_pOpenForkEntry) && (Bitmap & FILE_BITMAP_DATALEN)) ||
			(DATAFORK(pReqPkt->_pOpenForkEntry) && (Bitmap & FILE_BITMAP_RESCLEN)))
		{
			Status = AFP_ERR_BITMAP;
			break;
		}

		AfpInitializeFDParms(&FDParm);

		// Optimize for the most common case.
		if ((Bitmap & (FILE_BITMAP_DATALEN | FILE_BITMAP_RESCLEN)) != 0)
		{
			FORKOFFST	ForkLength;

			Status = AfpIoQuerySize(&pReqPkt->_pOpenForkEntry->ofe_FileSysHandle,
									&ForkLength);

			ASSERT(NT_SUCCESS(Status));

			if (Bitmap & FILE_BITMAP_DATALEN)
				 FDParm._fdp_DataForkLen = ForkLength.LowPart;
			else FDParm._fdp_RescForkLen = ForkLength.LowPart;
			FDParm._fdp_Flags = 0;		// Take out the directory flag
		}

		// If we need more stuff, go get it
		if (Bitmap & ~(FILE_BITMAP_DATALEN | FILE_BITMAP_RESCLEN))
		{
			CONNDESC		ConnDesc;
			POPENFORKDESC	pOpenForkDesc = pReqPkt->_pOpenForkEntry->ofe_pOpenForkDesc;

			// Since the following call requires a pConnDesc and we do not
			// really have one, manufacture it
			ConnDesc.cds_pSda = pSda;
			ConnDesc.cds_pVolDesc = pOpenForkDesc->ofd_pVolDesc;

			// Don't let FpExchangeFiles come in while we are accessing
			// the stored FileId and its corresponding DFE
			AfpSwmrAcquireExclusive(&ConnDesc.cds_pVolDesc->vds_ExchangeFilesLock);

			Status = AfpMapAfpIdForLookup(&ConnDesc,
										  pOpenForkDesc->ofd_FileNumber,
										  DFE_FILE,
										  Bitmap & ~(FILE_BITMAP_DATALEN | FILE_BITMAP_RESCLEN),
										  NULL,
										  &FDParm);
            AfpSwmrRelease(&ConnDesc.cds_pVolDesc->vds_ExchangeFilesLock);
			if (Status != AFP_ERR_NONE)
			{
				break;
			}
		}

		if (Status == AFP_ERR_NONE)
		{
			pSda->sda_ReplySize = SIZE_RESPPKT +
					EVENALIGN(AfpGetFileDirParmsReplyLength(&FDParm, Bitmap));

			if ((Status = AfpAllocReplyBuf(pSda)) == AFP_ERR_NONE)
			{
				AfpPackFileDirParms(&FDParm, Bitmap, pSda->sda_ReplyBuf + SIZE_RESPPKT);
				PUTDWORD2SHORT(&pRspPkt->__Bitmap, Bitmap);
			}
		}
	}  while (False);

	DBGPRINT(DBG_COMP_AFPAPI_FORK, DBG_LEVEL_INFO,
			("AfpFspDispGetForkParms: Returning %ld\n", Status));

	return Status;
}



/***	AfpFspDispSetForkParms
 *
 *	This is the worker routine for the AfpSetForkParms API.
 *  Only thing that can be set with this API is the fork length.
 *
 *	The request packet is represented below.
 *
 *	sda_ReqBlock	POPENFORKENTRY	pOpenForkEntry
 *	sda_ReqBlock	DWORD			Bitmap
 *	sda_ReqBlock	LONG			ForkLength
 *
 *  LOCKS: vds_IdDbAccessLock (SWMR, Exclusive)
 */
AFPSTATUS FASTCALL
AfpFspDispSetForkParms(
	IN	PSDA	pSda
)
{
	AFPSTATUS		Status;
	DWORD			Bitmap;
	BOOLEAN			SetSize = False;
    PVOLDESC        pVolDesc;
    PCONNDESC       pConnDesc;
	struct _RequestPacket
	{
		POPENFORKENTRY	_pOpenForkEntry;
		DWORD  			_Bitmap;
		LONG			_ForkLength;
	};

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_AFPAPI_FORK, DBG_LEVEL_INFO,
			("AfpFspDispSetForkParms: Entered Session %ld Fork %ld, Length %ld\n",
			pSda->sda_SessionId, pReqPkt->_pOpenForkEntry->ofe_ForkId,
			pReqPkt->_ForkLength));

	ASSERT(VALID_OPENFORKENTRY(pReqPkt->_pOpenForkEntry));

	Bitmap = pReqPkt->_Bitmap;

	do
	{
		if ((RESCFORK(pReqPkt->_pOpenForkEntry) &&
				(pReqPkt->_Bitmap & FILE_BITMAP_DATALEN)) ||
			(DATAFORK(pReqPkt->_pOpenForkEntry) &&
				(pReqPkt->_Bitmap & FILE_BITMAP_RESCLEN)))
		{
			Status = AFP_ERR_BITMAP;
			break;
		}

		if (!(pReqPkt->_pOpenForkEntry->ofe_OpenMode & FORK_OPEN_WRITE))
		{
			Status = AFP_ERR_ACCESS_DENIED;
			break;
		}
		else if (pReqPkt->_ForkLength >= 0)
		{
			FORKSIZE	OldSize;

			// We don't try to catch our own changes for setting
			// forksize because we don't know how many times the mac
			// will set the size before closing the handle.  Since
			// a notification will only come in once the handle is
			// closed, we may pile up a whole bunch of our changes
			// in the list, but only one of them will get satisfied.
			//
			// We also do not want to attempt a change if the current length
			// is same as what it is being set to (this happens a lot,
			// unfortunately). Catch this red-handed.

			Status = AfpIoQuerySize(&pReqPkt->_pOpenForkEntry->ofe_FileSysHandle,
								   &OldSize);
			ASSERT (NT_SUCCESS(Status));
			if (!(((LONG)(OldSize.LowPart) == pReqPkt->_ForkLength) &&
				  (OldSize.HighPart == 0)))
			{
				SetSize = True;
				Status = AfpIoSetSize(&pReqPkt->_pOpenForkEntry->ofe_FileSysHandle,
								      pReqPkt->_ForkLength);

                // update the disk quota for this user
                pVolDesc = pReqPkt->_pOpenForkEntry->ofe_pConnDesc->cds_pVolDesc;

                if (pVolDesc->vds_Flags & VOLUME_DISKQUOTA_ENABLED)
                {
                    pConnDesc = pReqPkt->_pOpenForkEntry->ofe_pConnDesc;
                    if (AfpConnectionReferenceByPointer(pConnDesc) != NULL)
                    {
                        afpUpdateDiskQuotaInfo(pConnDesc);
                    }
                }
			}

			// Update the Dfe view of the fork length.  Don't update the cached
			// modified time even though it does change on NTFS immediately
			// (LastWriteTime for setting length of data fork, ChangeTime for
			// setting length of resource fork).  We will let the
			// change notify update the modified time when the handle is closed.
			// Appleshare 3.0 and 4.0 do not reflect a changed modified time for
			// changing fork length until the fork is closed (or flushed).
			if (NT_SUCCESS(Status) && SetSize)
			{
				PVOLDESC		pVolDesc;
				PDFENTRY		pDfEntry;
				POPENFORKDESC	pOpenForkDesc;

				pOpenForkDesc = pReqPkt->_pOpenForkEntry->ofe_pOpenForkDesc;
				pVolDesc = pOpenForkDesc->ofd_pVolDesc;

				// Don't let FpExchangeFiles come in while we are accessing
				// the stored FileId and its corresponding DFE
				AfpSwmrAcquireExclusive(&pVolDesc->vds_ExchangeFilesLock);

				AfpSwmrAcquireExclusive(&pVolDesc->vds_IdDbAccessLock);

				if ((pDfEntry = AfpFindDfEntryById(pVolDesc,
												   pOpenForkDesc->ofd_FileNumber,
												   DFE_FILE)) != NULL)
				{
				    ASSERT (VALID_DFE(pDfEntry));

					if (RESCFORK(pReqPkt->_pOpenForkEntry))
					{
						// If a FlushFork occurs on resource fork, it should
						// update the modified time to the ChangeTime
						pReqPkt->_pOpenForkEntry->ofe_Flags |= OPEN_FORK_WRITTEN;

						pDfEntry->dfe_RescLen = pReqPkt->_ForkLength;
					}
					else
				    {
						pDfEntry->dfe_DataLen = pReqPkt->_ForkLength;
                    }
				}

				AfpSwmrRelease(&pVolDesc->vds_IdDbAccessLock);
				AfpSwmrRelease(&pVolDesc->vds_ExchangeFilesLock);
			}

		}
		else Status = AFP_ERR_PARAM;
	} while (False);

	DBGPRINT(DBG_COMP_AFPAPI_FORK, DBG_LEVEL_INFO,
			("AfpFspDispSetForkParms: Returning %ld\n", Status));

	return Status;
}


/***	AfpFspDispRead
 *
 *	This routine implements the AfpRead API.
 *
 *	The request packet is represented below.
 *
 *	sda_ReqBlock	POPENFORKENTRY	pOpenForkEntry
 *	sda_ReqBlock	LONG			Offset
 *	sda_ReqBlock	LONG			Size
 *	sda_ReqBlock	DWORD			NewLine Mask
 *	sda_ReqBlock	DWORD			NewLine Char
 */
AFPSTATUS FASTCALL
AfpFspDispRead(
	IN	PSDA	pSda
)
{
	AFPSTATUS			Status=AFP_ERR_MISC;
	FORKOFFST			LOffset;
	FORKSIZE			LSize;
	PFAST_IO_DISPATCH	pFastIoDisp;
	IO_STATUS_BLOCK		IoStsBlk;
    NTSTATUS            NtStatus;
	struct _RequestPacket
	{
		POPENFORKENTRY	_pOpenForkEntry;
		LONG			_Offset;
		LONG			_Size;
		DWORD			_NlMask;
		DWORD			_NlChar;
	};

	PAGED_CODE( );

	ASSERT(VALID_OPENFORKENTRY(pReqPkt->_pOpenForkEntry));

	DBGPRINT(DBG_COMP_AFPAPI_FORK, DBG_LEVEL_INFO,
			("AfpFspDispRead: Entered, Session %ld Fork %ld, Offset %ld, Size %ld\n",
			pSda->sda_SessionId, pReqPkt->_pOpenForkEntry->ofe_ForkId,
			pReqPkt->_Offset, pReqPkt->_Size));

	if ((pReqPkt->_Size < 0) ||
		(pReqPkt->_Offset < 0))
		return AFP_ERR_PARAM;

	if (!(pReqPkt->_pOpenForkEntry->ofe_OpenMode & FORK_OPEN_READ))
	{
		DBGPRINT(DBG_COMP_AFPAPI_FORK, DBG_LEVEL_WARN,
				("AfpFspDispRead: AfpRead on a Fork not opened for read\n"));
		return AFP_ERR_ACCESS_DENIED;
	}

	if (pReqPkt->_Size >= 0)
	{
		if (pReqPkt->_Size > (LONG)pSda->sda_MaxWriteSize)
			pReqPkt->_Size = (LONG)pSda->sda_MaxWriteSize;

		Status = AFP_ERR_NONE;

		if (pReqPkt->_Size > 0)
		{
			pSda->sda_ReadStatus = AFP_ERR_NONE;
			LOffset.QuadPart = pReqPkt->_Offset;
			LSize.QuadPart = pReqPkt->_Size;

			if ((pReqPkt->_pOpenForkEntry->ofe_pOpenForkDesc->ofd_UseCount == 1) ||
				(Status = AfpForkLockOperation( pSda,
												pReqPkt->_pOpenForkEntry,
												&LOffset,
												&LSize,
												IOCHECK,
												False)) == AFP_ERR_NONE)
			{
				ASSERT (LSize.HighPart == 0);
				ASSERT ((LONG)(LOffset.LowPart) == pReqPkt->_Offset);
				if ((LONG)(LSize.LowPart) != pReqPkt->_Size)
					pSda->sda_ReadStatus = AFP_ERR_LOCK;

				Status = AFP_ERR_MISC;

                pSda->sda_ReplySize = (USHORT)LSize.LowPart;

                NtStatus = STATUS_UNSUCCESSFUL;

                //
                // if Read is large enough to justify going to the cache mgr, do it
                //
                if (pSda->sda_ReplySize >= CACHEMGR_READ_THRESHOLD)
                {
                    NtStatus = AfpBorrowReadMdlFromCM(pSda);
                }

                //
                // if we didn't go to the cache mgr, or if we did but cache mgr
                // couldn't satisfy our request, continue with the read
                //
                if (NtStatus != STATUS_PENDING)
                {
                    Status = AfpFspDispReadContinue(pSda);
                }

                //
                // our attempt to get CacheMgr's mdl is pending.  Return this
                // error code so we don't complete the api as yet
                //
                else
                {
                    Status = AFP_ERR_EXTENDED;
                }

			}
		}
	}

	DBGPRINT(DBG_COMP_AFPAPI_FORK, DBG_LEVEL_INFO,
			("AfpFspDispRead: Returning %ld\n", Status));

	return Status;
}



/***	AfpFspDispReadContinue
 *
 *	This routine implements the AfpRead API if our attempt to get ReadMdl directly
 *  from the cache mgr fails.
 *
 */
AFPSTATUS FASTCALL
AfpFspDispReadContinue(
	IN	PSDA	pSda
)
{
	AFPSTATUS			Status=AFP_ERR_MISC;
	FORKOFFST			LOffset;
	FORKSIZE			LSize;
	PFAST_IO_DISPATCH	pFastIoDisp;
	IO_STATUS_BLOCK		IoStsBlk;
    NTSTATUS            NtStatus;
	struct _RequestPacket
	{
		POPENFORKENTRY	_pOpenForkEntry;
		LONG			_Offset;
		LONG			_Size;
		DWORD			_NlMask;
		DWORD			_NlChar;
	};

	PAGED_CODE( );

    // allocate buffer for the read
    AfpIOAllocBackFillBuffer(pSda);

	if (pSda->sda_IOBuf != NULL)
    {
#if DBG
        AfpPutGuardSignature(pSda);
#endif

		LOffset.QuadPart = pReqPkt->_Offset;
		LSize.QuadPart = pReqPkt->_Size;

		// Try the fast I/O path first.  If that fails, call AfpIoForkRead
		// to use the normal build-an-IRP path.
		pFastIoDisp = pReqPkt->_pOpenForkEntry->ofe_pDeviceObject->DriverObject->FastIoDispatch;
		if ((pFastIoDisp != NULL) &&
			(pFastIoDisp->FastIoRead != NULL) &&
			pFastIoDisp->FastIoRead(AfpGetRealFileObject(pReqPkt->_pOpenForkEntry->ofe_pFileObject),
									&LOffset,
									LSize.LowPart,
									True,
									pSda->sda_SessionId,
									pSda->sda_ReplyBuf,
									&IoStsBlk,
									pReqPkt->_pOpenForkEntry->ofe_pDeviceObject))
		{
			LONG	i, Size;
			PBYTE	pBuf;
		
			DBGPRINT(DBG_COMP_AFPAPI_FORK, DBG_LEVEL_INFO,
				("AfpFspDispRead: Fast Read Succeeded\n"));

#ifdef	PROFILING
			// The fast I/O path worked. Update statistics
			INTERLOCKED_INCREMENT_LONG((PLONG)(&AfpServerProfile->perf_NumFastIoSucceeded));
#endif  	
			INTERLOCKED_ADD_STATISTICS(&AfpServerStatistics.stat_DataRead,
									   (ULONG)IoStsBlk.Information,
									   &AfpStatisticsLock);
			Status = pSda->sda_ReadStatus;
			Size = (LONG)IoStsBlk.Information;
#if 0   	
			// The following code does the right thing as per the spec but
			// the finder seems to think otherwise.
			if (Size < LSize.LowPart)
            {
				pSda->sda_ReadStatus = AFP_ERR_EOF;
            }
#endif  	
			if (Size == 0)
			{
				Status = AFP_ERR_EOF;
				AfpIOFreeBackFillBuffer(pSda);
			}
			else if (pReqPkt->_NlMask != 0)
			{
				for (i = 0, pBuf = pSda->sda_ReplyBuf; i < Size; i++, pBuf++)
				{
				    if ((*pBuf & (BYTE)(pReqPkt->_NlMask)) == (BYTE)(pReqPkt->_NlChar))
					{
						Size = ++i;
						break;
					}
				}
			}
			pSda->sda_ReplySize = (USHORT)Size;
			ASSERT((Status != AFP_ERR_EOF) || (pSda->sda_ReplySize == 0));
		}
		else
		{

#ifdef	PROFILING
			INTERLOCKED_INCREMENT_LONG((PLONG)(&AfpServerProfile->perf_NumFastIoFailed));
#endif
			Status = AfpIoForkRead(pSda,
								   pReqPkt->_pOpenForkEntry,
								   &LOffset,
								   LSize.LowPart,
								   (BYTE)pReqPkt->_NlMask,
								   (BYTE)pReqPkt->_NlChar);
		}
	}

    return(Status);
}


/***	AfpFspDispWrite
 *
 *	This routine implements the AfpWrite API.
 *
 *	The request packet is represented below.
 *
 *	sda_AfpSubFunc	BYTE			EndFlag
 *	sda_ReqBlock	POPENFORKENTRY	pOpenForkEntry
 *	sda_ReqBlock	LONG			Offset
 *	sda_ReqBlock	LONG			Size
 */
AFPSTATUS FASTCALL
AfpFspDispWrite(
	IN	PSDA			pSda
)
{
	FORKOFFST			LOffset;
	FORKSIZE			LSize;
	PFAST_IO_DISPATCH	pFastIoDisp;
	IO_STATUS_BLOCK		IoStsBlk;
	AFPSTATUS			Status = AFP_ERR_NONE;
	BOOLEAN				EndFlag, FreeWriteBuf = True;
    PVOLDESC            pVolDesc;
    PCONNDESC           pConnDesc;
	PREQUEST            pRequest;
    BOOLEAN             fUpdateQuota=FALSE;
	struct _RequestPacket
	{
		POPENFORKENTRY	_pOpenForkEntry;
		LONG			_Offset;
		LONG			_Size;
	};
	struct _ResponsePacket
	{
		BYTE	__RealOffset[4];
	};

	PAGED_CODE( );

	EndFlag = (pSda->sda_AfpSubFunc & AFP_END_FLAG) ? True : False;

	ASSERT(VALID_OPENFORKENTRY(pReqPkt->_pOpenForkEntry));

	DBGPRINT(DBG_COMP_AFPAPI_FORK, DBG_LEVEL_INFO,
			("AfpFspDispWrite: Entered, Session %ld, Fork %ld, Offset %ld, Size %ld %sRelative\n",
			pSda->sda_SessionId, pReqPkt->_pOpenForkEntry->ofe_ForkId,
			pReqPkt->_Offset, pReqPkt->_Size, EndFlag ? "End" : "Begin"));

	DBGPRINT(DBG_COMP_AFPAPI_FORK, DBG_LEVEL_WARN,
			("AfpFspDispWrite: OForkRefNum = %d, pOpenForkEntry = %lx\n",
			pReqPkt->_pOpenForkEntry->ofe_ForkId,pReqPkt->_pOpenForkEntry));
	do
	{
        pRequest = pSda->sda_Request;

        //
        // if we got this Mdl from the Cache mgr, we must return it.  Also, set
        // the status code such that we con't complete the request as yet, but
        // do so only afte cache mgr tells us that the write completed
        //
        if ((pRequest->rq_WriteMdl != NULL) &&
            (pRequest->rq_CacheMgrContext != NULL))
        {
            PDELAYEDALLOC   pDelAlloc;

            pDelAlloc = pRequest->rq_CacheMgrContext;

		    pReqPkt->_pOpenForkEntry->ofe_Flags |= OPEN_FORK_WRITTEN;

            ASSERT(pRequest->rq_WriteMdl == pDelAlloc->pMdl);
            ASSERT(!(pDelAlloc->Flags & AFP_CACHEMDL_ALLOC_ERROR));

            pRequest->rq_CacheMgrContext = NULL;

            AfpReturnWriteMdlToCM(pDelAlloc);

            FreeWriteBuf = False;
            Status = AFP_ERR_EXTENDED;
            break;
        }

        pConnDesc = pReqPkt->_pOpenForkEntry->ofe_pConnDesc;

        ASSERT(VALID_CONNDESC(pConnDesc));

		if ((pReqPkt->_Size < 0) ||
			(!EndFlag && (pReqPkt->_Offset < 0)))
		{
			Status = AFP_ERR_PARAM;
			break;
		}

		ASSERT((pReqPkt->_pOpenForkEntry->ofe_OpenMode & FORK_OPEN_WRITE) &&
			   ((pReqPkt->_Size == 0) ||
			   ((pReqPkt->_Size > 0) && (pSda->sda_IOBuf != NULL))));

		if (pReqPkt->_Size > (LONG)pSda->sda_MaxWriteSize)
			pReqPkt->_Size = (LONG)pSda->sda_MaxWriteSize;

		// Check if we have a lock conflict and also convert the offset &
		// size to absolute values if end relative
		LOffset.QuadPart = pReqPkt->_Offset;
		LSize.QuadPart = pReqPkt->_Size;

		if (pReqPkt->_Size == 0)
		{
			if (!(EndFlag && (pReqPkt->_Offset < 0)))
			{
				break;
			}
		}

		// Skip lock-check if this is the only instance of the open fork and I/O is
		// not end-relative.
		if ((!EndFlag &&
			(pReqPkt->_pOpenForkEntry->ofe_pOpenForkDesc->ofd_UseCount == 1)) ||
			(Status = AfpForkLockOperation( pSda,
											pReqPkt->_pOpenForkEntry,
											&LOffset,
											&LSize,
											IOCHECK,
											EndFlag)) == AFP_ERR_NONE)
		{
			ASSERT (LOffset.HighPart == 0);
			if ((LONG)(LSize.LowPart) != pReqPkt->_Size)
			{
				Status = AFP_ERR_LOCK;
			}
			else if (LSize.LowPart > 0)
			{
                ASSERT(VALID_CONNDESC(pReqPkt->_pOpenForkEntry->ofe_pConnDesc));

				// Assume write will succeed, set flag for FlushFork.
				// This is a one way flag, i.e. only set, never cleared
				pReqPkt->_pOpenForkEntry->ofe_Flags |= OPEN_FORK_WRITTEN;

				// Try the fast I/O path first.  If that fails, call AfpIoForkWrite
				// to use the normal build-an-IRP path.
				pFastIoDisp = pReqPkt->_pOpenForkEntry->ofe_pDeviceObject->DriverObject->FastIoDispatch;
				if ((pFastIoDisp != NULL) &&
					(pFastIoDisp->FastIoWrite != NULL) &&
					pFastIoDisp->FastIoWrite(AfpGetRealFileObject(pReqPkt->_pOpenForkEntry->ofe_pFileObject),
											&LOffset,
											LSize.LowPart,
											True,
											pSda->sda_SessionId,
											pSda->sda_IOBuf,
											&IoStsBlk,
											pReqPkt->_pOpenForkEntry->ofe_pDeviceObject))
				{
					DBGPRINT(DBG_COMP_AFPAPI_FORK, DBG_LEVEL_INFO,
							("AfpFspDispWrite: Fast Write Succeeded\n"));
		
#ifdef	PROFILING
					// The fast I/O path worked. Update statistics
					INTERLOCKED_INCREMENT_LONG((PLONG)(&AfpServerProfile->perf_NumFastIoSucceeded));
#endif  		
					INTERLOCKED_ADD_STATISTICS(&AfpServerStatistics.stat_DataWritten,
											   (ULONG)IoStsBlk.Information,
											   &AfpStatisticsLock);
					Status = AFP_ERR_NONE;
				}
				else
				{
#ifdef	PROFILING
					INTERLOCKED_INCREMENT_LONG((PLONG)(&AfpServerProfile->perf_NumFastIoFailed));
#endif
					if ((Status = AfpIoForkWrite(pSda,
												 pReqPkt->_pOpenForkEntry,
												 &LOffset,
												 LSize.LowPart)) == AFP_ERR_EXTENDED)
					{
						FreeWriteBuf = False;
					}
				}

			}
		}
	} while (False);

	if (FreeWriteBuf)
    {
		AfpFreeIOBuffer(pSda);
    }

	if (Status == AFP_ERR_NONE)
	{
		pSda->sda_ReplySize = SIZE_RESPPKT;
		if ((Status = AfpAllocReplyBuf(pSda)) == AFP_ERR_NONE)
		{
			PUTDWORD2DWORD(pRspPkt->__RealOffset, LOffset.LowPart+LSize.LowPart);
		}
	}

	DBGPRINT(DBG_COMP_AFPAPI_FORK, DBG_LEVEL_INFO,
			("AfpFspDispWrite: Returning %ld\n", Status));

	return Status;
}



/***	AfpFspDispByteRangeLock
 *
 *	This routine implements the AfpByteRangeLock API.
 *	We go ahead and call the file system to do the actual locking/unlocking.
 *
 *	The request packet is represented below.
 *
 *	sda_SubFunc		BYTE			Start/End Flag AND Lock/Unlock Flag
 *	sda_ReqBlock	POPENFORKENTRY	pOpenForkEntry
 *	sda_ReqBlock	LONG			Offset
 *	sda_ReqBlock	LONG			Length
 */
AFPSTATUS FASTCALL
AfpFspDispByteRangeLock(
	IN	PSDA	pSda
)
{
	BOOLEAN			EndFlag;
	LOCKOP			Lock;
	LONG			Offset;
    FORKOFFST       LOffset;
    FORKSIZE        LSize;
	AFPSTATUS		Status = AFP_ERR_PARAM;
	struct _RequestPacket
	{
		POPENFORKENTRY	_pOpenForkEntry;
		LONG			_Offset;
        LONG			_Length;
	};
	struct _ResponsePacket
	{
		BYTE	__RangeStart[4];
	};

	ASSERT (sizeof(struct _RequestPacket) <= (MAX_REQ_ENTRIES_PLUS_1)*sizeof(DWORD));

	PAGED_CODE( );

	Lock = (pSda->sda_AfpSubFunc & AFP_UNLOCK_FLAG) ? UNLOCK : LOCK;
	EndFlag = (pSda->sda_AfpSubFunc & AFP_END_FLAG) ? True : False;

	DBGPRINT(DBG_COMP_AFPAPI_FORK, DBG_LEVEL_INFO,
			("AfpFspDispByteRangeLock: %sLock - Session %ld, Fork %ld Offset %ld Len %ld %sRelative\n",
			(Lock == LOCK) ? "":"Un", pSda->sda_SessionId,
			pReqPkt->_pOpenForkEntry->ofe_ForkId,
			pReqPkt->_Offset, pReqPkt->_Length, EndFlag ? "End" : "Begin"));

	ASSERT(VALID_OPENFORKENTRY(pReqPkt->_pOpenForkEntry));

	if ((EndFlag && (Lock == UNLOCK))		||
		(pReqPkt->_Length == 0)				||
		(!EndFlag && (pReqPkt->_Offset < 0))||
		((pReqPkt->_Length < 0) && (pReqPkt->_Length != MAXULONG)))
		NOTHING;
	else
	{
		if (pReqPkt->_Length == MAXULONG)
			pReqPkt->_Length = MAXLONG;

		LOffset.QuadPart = Offset = pReqPkt->_Offset;
		LSize.QuadPart = pReqPkt->_Length;

		Status = AfpForkLockOperation(pSda,
									  pReqPkt->_pOpenForkEntry,
									  &LOffset,
									  &LSize,
									  Lock,
									  EndFlag);

		if (Status == AFP_ERR_NONE)
		{
			ASSERT (LOffset.HighPart == 0);
			ASSERT (EndFlag ||
					((LONG)(LOffset.LowPart) == Offset));
			pSda->sda_ReplySize = SIZE_RESPPKT;
			if ((Status = AfpAllocReplyBuf(pSda)) == AFP_ERR_NONE)
				PUTDWORD2DWORD(pRspPkt->__RangeStart, LOffset.LowPart);
		}
	}

	DBGPRINT(DBG_COMP_AFPAPI_FORK, DBG_LEVEL_INFO,
			("AfpFspDispByteRangeLock: Returning %ld\n", Status));

	return Status;
}


/***	AfpFspDispFlushFork
 *
 *	This routine implements the AfpFlushFork API. We don't actually do a
 *  real flush, we just query for the current forklength and modified time
 *  for this open fork handle and update our cached data.  Note if 2
 *  different handles to the same file are flushed, we may end up with
 *  different information for each flush.
 *
 *	The request packet is represented below.
 *
 *	sda_ReqBlock	POPENFORKENTRY	pOpenForkEntry
 */
AFPSTATUS FASTCALL
AfpFspDispFlushFork(
	IN	PSDA	pSda
)
{
	FORKOFFST	ForkLength;
	DWORD		Status;
    PCONNDESC   pConnDesc;
	struct _RequestPacket
	{
		POPENFORKENTRY	_pOpenForkEntry;
	};

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_AFPAPI_FORK, DBG_LEVEL_INFO,
										("AfpFspDispFlushFork: Entered\n"));

	ASSERT(VALID_OPENFORKENTRY(pReqPkt->_pOpenForkEntry));

	do
	{
		Status = AfpIoQuerySize(&pReqPkt->_pOpenForkEntry->ofe_FileSysHandle,
								&ForkLength);

		ASSERT(NT_SUCCESS(Status));

		if (NT_SUCCESS(Status))
		{
			PVOLDESC		pVolDesc;
			PDFENTRY		pDfEntry;
			POPENFORKDESC	pOpenForkDesc;

			pOpenForkDesc = pReqPkt->_pOpenForkEntry->ofe_pOpenForkDesc;
			pVolDesc = pOpenForkDesc->ofd_pVolDesc;

            ASSERT(IS_VOLUME_NTFS(pVolDesc));

			// Don't let FpExchangeFiles come in while we are accessing
			// the stored FileId and its corresponding DFE
			AfpSwmrAcquireExclusive(&pVolDesc->vds_ExchangeFilesLock);

			AfpSwmrAcquireExclusive(&pVolDesc->vds_IdDbAccessLock);

			if ((pDfEntry = AfpFindDfEntryById(pVolDesc,
											   pOpenForkDesc->ofd_FileNumber,
											   DFE_FILE)) != NULL)
			{
			    ASSERT (VALID_DFE(pDfEntry));

				AfpIoChangeNTModTime(&pReqPkt->_pOpenForkEntry->ofe_FileSysHandle,
										 &pDfEntry->dfe_LastModTime);

				if (RESCFORK(pReqPkt->_pOpenForkEntry))
					 pDfEntry->dfe_RescLen = ForkLength.LowPart;
				else pDfEntry->dfe_DataLen = ForkLength.LowPart;
			}

			AfpSwmrRelease(&pVolDesc->vds_IdDbAccessLock);
			AfpSwmrRelease(&pVolDesc->vds_ExchangeFilesLock);

            // update the disk quota for this user
            if (pVolDesc->vds_Flags & VOLUME_DISKQUOTA_ENABLED)
            {
                pConnDesc = pReqPkt->_pOpenForkEntry->ofe_pConnDesc;
                if (AfpConnectionReferenceByPointer(pConnDesc) != NULL)
                {
                    afpUpdateDiskQuotaInfo(pConnDesc);
                }
            }
		}

	} while (False);

	// Always return success
	return AFP_ERR_NONE;
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\server\fsd_vol.c ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	fsd_vol.c

Abstract:

	This module contains the entry points for the AFP volume APIs. The API
	dispatcher calls these. These are all callable from FSD.

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	25 Apr 1992		Initial Version

Notes:	Tab stop: 4
--*/

#define	FILENUM	FILE_FSD_VOL

#include <afp.h>
#include <gendisp.h>


/***	AfpFsdDispOpenVol
 *
 *	This routine implements the AfpOpenVol API. This completes here i.e. it is
 *	not queued up to the Fsp.
 *
 *	The request packet is represented below.
 *
 *	sda_ReqBlock	DWORD		Bitmap
 *	sda_Name1		ANSI_STRING	VolName
 *	sda_Name2		ANSI_STRING	VolPassword		OPTIONAL
 */
AFPSTATUS FASTCALL
AfpFsdDispOpenVol(
	IN	PSDA	pSda
)
{
	AFPSTATUS		Status;
	struct _RequestPacket
	{
		DWORD	_Bitmap;
	};

	DBGPRINT(DBG_COMP_AFPAPI_VOL, DBG_LEVEL_INFO,
			("AfpFsdDispOpenVol: Entered\n"));

	ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

	if (pSda->sda_Name1.Length > AFP_VOLNAME_LEN)
	{
		return AFP_ERR_PARAM;
	}

	pSda->sda_ReplySize = AfpVolumeGetParmsReplyLength(pReqPkt->_Bitmap,
													pSda->sda_Name1.Length);

	if ((Status = AfpAllocReplyBuf(pSda)) == AFP_ERR_NONE)
	{
		if (((Status = AfpConnectionOpen(pSda,
										 &pSda->sda_Name1,
										 &pSda->sda_Name2,
										 pReqPkt->_Bitmap,
										 pSda->sda_ReplyBuf)) != AFP_ERR_NONE) &&
			(Status != AFP_ERR_QUEUE))
		{
			AfpFreeReplyBuf(pSda, FALSE);
		}
	}

	// Change the worker routine if we need this to be queued.
	if (Status == AFP_ERR_QUEUE)
		pSda->sda_WorkerRoutine = AfpFspDispOpenVol;

	return Status;
}


/***	AfpFsdDispCloseVol
 *
 *	This routine implements the AfpCloseVol API. This completes here i.e. it is
 *	not queued up to the Fsp.
 *
 *	The request packet is represented below.
 *
 *	sda_ReqBlock	PCONNDESC	pConnDesc
 */
AFPSTATUS FASTCALL
AfpFsdDispCloseVol(
	IN	PSDA pSda
)
{
	struct _RequestPacket
	{
		PCONNDESC	_pConnDesc;
	};

	DBGPRINT(DBG_COMP_AFPAPI_VOL, DBG_LEVEL_INFO,
			("AfpFsdDispCloseVol: Entered\n"));

	ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

	ASSERT(VALID_CONNDESC(pReqPkt->_pConnDesc) &&
		   VALID_VOLDESC(pReqPkt->_pConnDesc->cds_pVolDesc));

	AfpConnectionClose(pReqPkt->_pConnDesc);

	return AFP_ERR_NONE;
}


/***	AfpFsdDispGetVolParms
 *
 *	This routine implements the AfpGetVolParms API. This completes here i.e.
 *	it is not queued up to the Fsp.
 *
 *	The request packet is represented below.
 *
 *	sda_ReqBlock	DWORD		VolId
 *	sda_ReqBlock	DWORD		Bitmap
 */
AFPSTATUS FASTCALL
AfpFsdDispGetVolParms(
	IN	PSDA	pSda
)
{
	AFPSTATUS	Status = AFP_ERR_PARAM;
    PVOLDESC    pVolDesc;
	struct _RequestPacket
	{
		PCONNDESC	_pConnDesc;
		DWORD		_Bitmap;
	};


	DBGPRINT(DBG_COMP_AFPAPI_VOL, DBG_LEVEL_INFO,
			("AfpFsdDispGetVolParms: Entered\n"));

	ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);
	ASSERT(VALID_CONNDESC(pReqPkt->_pConnDesc) &&
		   VALID_VOLDESC(pReqPkt->_pConnDesc->cds_pVolDesc));

    pVolDesc = pReqPkt->_pConnDesc->cds_pVolDesc;

    //
    // we need to update the diskquota for this user, if diskquota is enabled:
    // we are dpc here, so just queue this request
    //
    if (pVolDesc->vds_Flags & VOLUME_DISKQUOTA_ENABLED)
    {
        pSda->sda_WorkerRoutine = AfpFspDispGetVolParms;
        return(AFP_ERR_QUEUE);
    }

	pSda->sda_ReplySize = AfpVolumeGetParmsReplyLength(pReqPkt->_Bitmap,
							pReqPkt->_pConnDesc->cds_pVolDesc->vds_MacName.Length);

	if ((Status = AfpAllocReplyBuf(pSda)) == AFP_ERR_NONE)
	{
		AfpVolumePackParms(pSda, pVolDesc, pReqPkt->_Bitmap, pSda->sda_ReplyBuf);
	}

	return Status;
}


/***	AfpFsdDispSetVolParms
 *
 *	This routine implements the AfpSetVolParms API. This completes here i.e.
 *	it is not queued up to the Fsp.
 *
 *	The request packet is represented below.
 *
 *	sda_ReqBlock	PCONNDESC	pConnDesc
 *	sda_ReqBlock	DWORD		Bitmap
 *	sda_ReqBlock	DWORD		BackupTime
 */
AFPSTATUS FASTCALL
AfpFsdDispSetVolParms(
	IN	PSDA	pSda
)
{
	struct _RequestPacket
	{
		PCONNDESC	_pConnDesc;
		DWORD		_Bitmap;
		DWORD		_BackupTime;
	};
	PVOLDESC	pVolDesc;

	DBGPRINT(DBG_COMP_AFPAPI_VOL, DBG_LEVEL_INFO,
			("AfpFsdDispSetVolParms: Entered\n"));

	ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);
	ASSERT(VALID_CONNDESC(pReqPkt->_pConnDesc));

	pVolDesc = pReqPkt->_pConnDesc->cds_pVolDesc;

	ASSERT(VALID_VOLDESC(pVolDesc) & !IS_VOLUME_RO(pVolDesc));

	ACQUIRE_SPIN_LOCK_AT_DPC(&pVolDesc->vds_VolLock);
	pVolDesc->vds_BackupTime = pReqPkt->_BackupTime;
	pVolDesc->vds_Flags |= VOLUME_IDDBHDR_DIRTY;
	RELEASE_SPIN_LOCK_FROM_DPC(&pVolDesc->vds_VolLock);

	return AFP_ERR_NONE;
}


/***	AfpFsdDispFlush
 *
 *	This routine implements the AfpFlush API. The only thing done here is
 *	validation of the Volume Id. The call completes here i.e. it is not
 *	queued up to the FSP.
 *
 *	The request packet is represented below.
 *
 *	sda_ReqBlock	DWORD		VolId
 */
AFPSTATUS FASTCALL
AfpFsdDispFlush(
	IN	PSDA	pSda
)
{
	struct _RequestPacket
	{
		PCONNDESC	_pConnDesc;
	};

	ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);
	DBGPRINT(DBG_COMP_AFPAPI_VOL, DBG_LEVEL_INFO,
			("AfpFsdDispFlush: Entered\n"));

	ASSERT(VALID_CONNDESC(pReqPkt->_pConnDesc) &&
		   VALID_VOLDESC(pReqPkt->_pConnDesc->cds_pVolDesc));

	return AFP_ERR_NONE;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\server\fsp_srv.c ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

    fsp_srv.c

Abstract:

    This module contains the entry points for the AFP server APIs queued to
    the FSP. These are all callable from FSP Only.

Author:

    Jameel Hyder (microsoft!jameelh)


Revision History:
    25 Apr 1992     Initial Version

Notes:  Tab stop: 4
--*/

#define FILENUM FILE_FSP_SRV

#include <afp.h>
#include <gendisp.h>
#include <client.h>
#include <scavengr.h>
#include <secutil.h>

LOCAL BOOLEAN
afpGetUserNameAndPwdOrWSName(
    IN  PANSI_STRING    Block,
    IN  BOOLEAN         Password,
    OUT PUNICODE_STRING pUserName,
    OUT PUNICODE_STRING pDomainName,
    OUT PVOID           pParm
);


LOCAL BOOLEAN
afpGetNameAndDomain(
    IN  PANSI_STRING    pDomainNUser,
    OUT PUNICODE_STRING pUserName,
    OUT PUNICODE_STRING pDomainName
);

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, AfpFspDispLogin)
#pragma alloc_text( PAGE, AfpFspDispLoginCont)
#pragma alloc_text( PAGE, AfpFspDispLogout)
#pragma alloc_text( PAGE, AfpFspDispChangePassword)
#pragma alloc_text( PAGE, AfpFspDispMapName)
#pragma alloc_text( PAGE, AfpFspDispMapId)
#pragma alloc_text( PAGE, AfpFspDispGetUserInfo)
#pragma alloc_text( PAGE, afpGetUserNameAndPwdOrWSName)
#pragma alloc_text( PAGE, afpGetNameAndDomain)
#endif

/***    AfpFspDispLogin
 *
 *  This is the worker routine for the AfpLogin API.
 *
 *  The request packet is represented below.
 *
 *  sda_Name1   ANSI_STRING AFP Version
 *  sda_Name2   ANSI_STRING UAM String
 *  sda_Name3   BLOCK       Depends on the UAM used
 *                          NO_USER_AUTHENT     Not used
 *                          CLEAR_TEXT_AUTHENT  User Name & Password string
 *                          CUSTOM_UAM          User Name & Machine Name
 *  Both the ClearText and the Custom UAM case are treated identically
 *  except for validation.
 *
 *  LOCKS:  sda_Lock (SPIN)
 */
AFPSTATUS FASTCALL
AfpFspDispLogin(
    IN  PSDA    pSda
)
{
    LONG            i;
    ANSI_STRING     UserPasswd;
    PSID            GuestSid = NULL;
    BOOLEAN         fGuestLogon = FALSE;
    BOOLEAN         fKillSession = FALSE;
    AFPSTATUS       Status = AFP_ERR_NONE;
    IPADDRESS           IpAddress;

    struct _AppleUamRespPacket
    {
        BYTE    _LogonId[2];
        BYTE    _ChallengeToClient[1];
    };
    struct _AppleUamRespPacket *pAppleUamRespPacket;

    struct _ResponsePacket
    {
        BYTE    _ChallengeToClient[MSV1_0_CHALLENGE_LENGTH];
        BYTE    _TranslationTable[1];
    };

    PAGED_CODE( );

    DBGPRINT(DBG_COMP_AFPAPI_SRV, DBG_LEVEL_INFO,
            ("AfpFspDispLogin: Entered\n"));

    UserPasswd.Length = 0;
    UserPasswd.MaximumLength = 0;
    UserPasswd.Buffer = NULL;

    AfpSetEmptyAnsiString(&UserPasswd, 0, NULL);

    do
    {
        // First validate whether the call is allowed at this time. If a user
        // is either already logged on OR if we are awaiting a response after
        // a challenge has already been given, then this goes no further.
        if ((pSda->sda_Flags & SDA_LOGIN_MASK) != SDA_USER_NOT_LOGGEDIN)
        {
            Status = AFP_ERR_MISC;
            break;
        }

        // Validate the AFP Version
        for (i = 0; i < AFP_NUM_VERSIONS; i++)
        {
            if (RtlEqualString(&pSda->sda_Name1, &AfpVersions[i], True))
            {
                pSda->sda_ClientVersion = (BYTE)i;
                break;
            }

        }
        if (i == AFP_NUM_VERSIONS)
        {
            Status = AFP_ERR_BAD_VERSION;
            break;
        }


#if DBG
        if (pSda->sda_Flags & SDA_SESSION_OVER_TCP)
        {
            PTCPCONN    pTcpConn;
            pTcpConn = (PTCPCONN)(pSda->sda_SessHandle);
            IpAddress = pTcpConn->con_DestIpAddr;

            DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_WARN,
                ("AFP/TCP: Mac client version 2.%d (%d.%d.%d.%d) connected (%lx)\n",
                pTcpConn->con_pSda->sda_ClientVersion,(IpAddress>>24)&0xFF,
                (IpAddress>>16)&0xFF,(IpAddress>>8)&0xFF,IpAddress&0xFF,pTcpConn));
        }
        else if (pSda->sda_ClientVersion >= AFP_VER_22)
        {
            DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_WARN,
                ("AFP/Appletalk: Mac client version 2.%d connected\n",
                pSda->sda_ClientVersion));
        }
#endif

        // Validate the UAM string
        for (i = 0; i < AFP_NUM_UAMS; i++)
        {
            if (RtlEqualString(&pSda->sda_Name2, &AfpUamStrings[i], True))
            {
                pSda->sda_ClientType = (BYTE)i;
                break;
            }

        }

        if (i == AFP_NUM_UAMS)
        {
            DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                ("AfpFspDispLogin: unknown UAM, ignoring!\n"));

            Status = AFP_ERR_BAD_UAM;
            break;
        }


        // All seems OK so far. Handle the simple GUEST logon case first.
        pSda->sda_DomainName.Length = 0;
        pSda->sda_DomainName.Buffer = NULL;
        if (pSda->sda_ClientType == SDA_CLIENT_GUEST)
        {
            if (!(AfpServerOptions & AFP_SRVROPT_GUESTLOGONALLOWED))
            {
                Status = AFP_ERR_BAD_UAM;
                break;
            }

            // Lookup the current Guest account name

            {
                ULONG64         TempBuffer[16];
                ULONG           GuestSidSize = 0;
                ULONG           NameSize;
                ULONG           DomainSize;
                UNICODE_STRING  Name;
                UNICODE_STRING  Domain;
                SID_NAME_USE    NameUse;
                WCHAR           NameString[UNLEN+1];
                WCHAR           DomainString[DNLEN+1];
                SID_IDENTIFIER_AUTHORITY    NtAuthority =  SECURITY_NT_AUTHORITY;
                NTSTATUS        TempStatus = STATUS_SUCCESS;

                TempStatus = SecLookupWellKnownSid (
                        WinAccountGuestSid,
                        NULL,
                        0,
                        &GuestSidSize
                        );

                if (TempStatus == STATUS_BUFFER_TOO_SMALL)
                {
                    if ((GuestSid = (PSID)AfpAllocPagedMemory (GuestSidSize)) == NULL)
                    {
                        Status = AFP_ERR_MISC;
                        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                                ("AfpFspDispLogin: AfpAllocPagedMemory failed to allocate memory"));
                        break;
                    }
                    TempStatus = STATUS_SUCCESS;
                    TempStatus = SecLookupWellKnownSid (
                            WinAccountGuestSid,
                            GuestSid,
                            GuestSidSize,
                            &GuestSidSize
                            );
                    if (TempStatus != STATUS_SUCCESS)
                    {
                        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                            ("AfpFspDispLogin: SecLookupWellKnownSid 2 failed with error %ld\n",
                            TempStatus));
                        Status = AFP_ERR_MISC;
                        break;
                    }
                }
                else
                {
                    if (TempStatus != STATUS_SUCCESS)
                    {
                        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                            ("AfpFspDispLogin: SecLookupWellKnownSid 1 failed with error %ld\n",
                            TempStatus));
                        Status = AFP_ERR_MISC;
                        break;
                    }
                }

                Name.Buffer = NameString;
                Name.Length = sizeof (NameString);
                Name.MaximumLength = Name.Length;
                Domain.Buffer = DomainString;
                Domain.Length = sizeof (DomainString);
                Domain.MaximumLength = Domain.Length;

                TempStatus = SecLookupAccountSid (
                                                GuestSid,
                                                &NameSize,
                                                &Name,
                                                &DomainSize,
                                                &Domain,
                                                &NameUse
                                                );

                if (TempStatus != STATUS_SUCCESS)
                {
                    DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                        ("AfpFspDispLogin: SecLookupAccountSid failed with error %ld\n",
                        TempStatus));
                    Status = AFP_ERR_MISC;
                    break;
                }


                DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                    ("AfpFspDispLogin: SecLookupAccountSid returned GuestName = %Z, Guestname Size = %d\n",
                     &Name, Name.Length));


                if ((pSda->sda_UserName.Buffer =
                            (PWSTR)AfpAllocNonPagedMemory(Name.Length)) == NULL)
                {
                    Status = AFP_ERR_MISC;
                    break;
                }

                memcpy ((BYTE *)(pSda->sda_UserName.Buffer), (BYTE *)Name.Buffer,
                        Name.Length);
                pSda->sda_UserName.Length = Name.Length;
                pSda->sda_UserName.MaximumLength = Name.Length;

            }

            // Consider the guest as a cleartext client from this point on
            // with NULL password

            fGuestLogon = TRUE;
            pSda->sda_ClientType = SDA_CLIENT_CLEARTEXT;
            Status = AfpLogonUser(pSda, &UserPasswd);
            break;
        }

        // Take apart the sda_Name3 block. The block looks as follows. We have
        // already eliminated the possibility of a GUEST login.
        //  1.  ClearText/Custom UAM    PASCALSTR - UserName (+DomainName)
        //  2.  ClearText               PASCALSTR - Password
        //      Custom UAM              PASCALSTR - MachineName

        if (pSda->sda_ClientType == SDA_CLIENT_CLEARTEXT)
        {
            if (!(AfpServerOptions & AFP_SRVROPT_CLEARTEXTLOGONALLOWED))
            {
                Status = AFP_ERR_BAD_UAM;
                break;
            }
        }

        if (!afpGetUserNameAndPwdOrWSName(&pSda->sda_Name3,
                        pSda->sda_ClientType,
                        &pSda->sda_UserName,
                        &pSda->sda_DomainName,
                        (pSda->sda_ClientType == SDA_CLIENT_CLEARTEXT) ?
                        (PVOID)&UserPasswd : (PVOID)&pSda->sda_WSName))
        {
            DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_ERR,
                 ("AfpFspDispLogin: afpGetUserNameAndPwdOrWSName failed\n"));

            Status = AFP_ERR_USER_NOT_AUTH;
            break;
        }

        // Attempt to logon user for Cleartext case
        if (pSda->sda_ClientType == SDA_CLIENT_CLEARTEXT)
        {
            // The user password as we have it is potentially padded with nulls
            // if it is less than 8 chars. Get the length right
            UserPasswd.Length = strlen(UserPasswd.Buffer) + 1;
            Status = AfpLogonUser(pSda, &UserPasswd);

            // Free the buffer for the password
            AfpFreeMemory(UserPasswd.Buffer);
            break;
        }
        else
        {
            // Using the custom UAM, ship the challenge token
            pSda->sda_ReplySize = MSV1_0_CHALLENGE_LENGTH;

            // is this MS-UAM client?  if so, need room for translation table
            if ((pSda->sda_ClientType == SDA_CLIENT_MSUAM_V1) ||
                (pSda->sda_ClientType == SDA_CLIENT_MSUAM_V2) ||
                (pSda->sda_ClientType == SDA_CLIENT_MSUAM_V3))
            {
                pSda->sda_ReplySize += AFP_XLAT_TABLE_SIZE;
            }
            else
            {
                pSda->sda_ReplySize += sizeof(USHORT);    // space for LogonId
            }

            if (AfpAllocReplyBuf(pSda) != AFP_ERR_NONE)
            {
                DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_ERR,
                     ("AfpFspDispLogin: AfpAllocReplyBuf failed\n"));
                Status = AFP_ERR_USER_NOT_AUTH;
                break;
            }

            if ((pSda->sda_Challenge = AfpGetChallenge()) == NULL)
            {
                DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_ERR,
                     ("AfpFspDispLogin: AfpGetChallenge failed\n"));
                Status = AFP_ERR_USER_NOT_AUTH;
                AfpFreeReplyBuf(pSda, FALSE);
                break;
            }

            Status = AFP_ERR_AUTH_CONTINUE;

            // MS-UAM client?  copy challenge and translation table
            if ((pSda->sda_ClientType == SDA_CLIENT_MSUAM_V1) ||
                (pSda->sda_ClientType == SDA_CLIENT_MSUAM_V2) ||
                (pSda->sda_ClientType == SDA_CLIENT_MSUAM_V3))
            {
                RtlCopyMemory(pRspPkt->_ChallengeToClient, pSda->sda_Challenge,
                                                MSV1_0_CHALLENGE_LENGTH);
                RtlCopyMemory(pRspPkt->_TranslationTable,
                          AfpTranslationTable+AFP_XLAT_TABLE_SIZE,
                          AFP_XLAT_TABLE_SIZE);
            }
            else
            {
                pAppleUamRespPacket = (struct _AppleUamRespPacket *)(pSda->sda_ReplyBuf);


                // copy the LogonId (make one up, using the sda pointer itself!)
                //*(USHORT *)(&pAppleUamRespPacket->_LogonId[0]) = (USHORT)pSda;
                pAppleUamRespPacket->_LogonId[0] = 0;
                pAppleUamRespPacket->_LogonId[1] = 0;

                // copy the challenge
                RtlCopyMemory(&pAppleUamRespPacket->_ChallengeToClient[0],
                              pSda->sda_Challenge,
                              MSV1_0_CHALLENGE_LENGTH);
            }
        }
    } while (False);

    if (GuestSid != NULL)
    {
        AfpFreeMemory(GuestSid);
    }

    // Set the SDA in the right state
    if (Status == AFP_ERR_NONE)
    {
        // Cancel the scavenger event for checking this user's kickoff time
        // IF ANY
        AfpScavengerKillEvent(AfpSdaCheckSession,
                (PVOID)((ULONG_PTR)(pSda->sda_SessionId)));

        if (fGuestLogon)
        {
            AfpInterlockedSetDword(&pSda->sda_Flags,
                                    SDA_GUEST_LOGIN,
                                    &pSda->sda_Lock);
        }
        AfpInterlockedSetNClearDword(&pSda->sda_Flags,
                                     SDA_USER_LOGGEDIN,
                                     SDA_LOGIN_FAILED,
                                     &pSda->sda_Lock);
        pSda->sda_WSName.Length = 0;
        pSda->sda_WSName.MaximumLength = 0;
        pSda->sda_WSName.Buffer = NULL;
        if (pSda->sda_tTillKickOff < MAXLONG)
            AfpScavengerScheduleEvent(
                        AfpSdaCheckSession,
                        (PVOID)((ULONG_PTR)(pSda->sda_SessionId)),
                        (pSda->sda_tTillKickOff > SESSION_WARN_TIME) ?
                             (pSda->sda_tTillKickOff - SESSION_WARN_TIME) :
                             SESSION_CHECK_TIME,
                        True);
    }
    else if (Status == AFP_ERR_AUTH_CONTINUE)
    {
        // Login is half-way done. Set to receive a FPLoginCont call
        AfpInterlockedSetDword(&pSda->sda_Flags,
                                SDA_USER_LOGIN_PARTIAL,
                                &pSda->sda_Lock);
    }
    else if (Status == AFP_ERR_PWD_EXPIRED)
    {
        AfpInterlockedSetDword(&pSda->sda_Flags,
                                SDA_LOGIN_FAILED,
                                &pSda->sda_Lock);
        Status = AFP_ERR_NONE;
        fKillSession = True;
    }
    else
    {
        fKillSession = True;
    }

    if (fKillSession)
    {
        // Cancel the scavenger event for checking this user's kickoff time
        // IF ANY
        AfpScavengerKillEvent(AfpSdaCheckSession,
                (PVOID)((ULONG_PTR)(pSda->sda_SessionId)));

        DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_ERR,
                ("AfpFspDispLogin: Logon failed: Scheduling session to be killed in (%ld) seconds\n", SESSION_KILL_TIME));

        pSda->sda_tTillKickOff = SESSION_KILL_TIME;
        AfpScavengerScheduleEvent(
                AfpSdaCheckSession,
                (PVOID)((ULONG_PTR)(pSda->sda_SessionId)),
                (pSda->sda_tTillKickOff > SESSION_WARN_TIME) ?
                (pSda->sda_tTillKickOff - SESSION_WARN_TIME) :
                SESSION_CHECK_TIME,
                True);
    }
    
    return Status;
}


/***    AfpFspDispLoginCont
 *
 *  This is the worker routine for the AfpLoginCont API.
 *
 *  The request packet is represented below.
 *
 *  sda_Name1       BLOCK       Response to challenge (24 bytes)
 */
AFPSTATUS FASTCALL
AfpFspDispLoginCont(
    IN  PSDA    pSda
)
{
    AFPSTATUS       Status = AFP_ERR_NONE;
    ANSI_STRING     Passwd;
    struct _AppleUamReqPkt
    {
        BYTE    _LogonId[2];
        BYTE    _ChallengeResponse[1];
    };
    struct _AppleUamReqPkt *pAppleUamReqPkt;

    struct _RequestPacket
    {
        DWORD   _ChallengeResponse[1];
    };

    PAGED_CODE( );

    DBGPRINT(DBG_COMP_AFPAPI_SRV, DBG_LEVEL_INFO,
            ("AfpFspDispLoginCont: Entered\n"));

    if ((pSda->sda_Flags & SDA_LOGIN_MASK) != SDA_USER_LOGIN_PARTIAL)
    {
        Status = AFP_ERR_USER_NOT_AUTH;
    }

    else
    {
        if ((pSda->sda_ClientType == SDA_CLIENT_MSUAM_V1) ||
            (pSda->sda_ClientType == SDA_CLIENT_MSUAM_V2) ||
            (pSda->sda_ClientType == SDA_CLIENT_MSUAM_V3))
        {
            Passwd.Length = Passwd.MaximumLength = LM_RESPONSE_LENGTH;
            Passwd.Buffer = (PBYTE)&pReqPkt->_ChallengeResponse[0];
        }
        else
        {
            pAppleUamReqPkt = (struct _AppleUamReqPkt *)(pSda->sda_ReqBlock);
            Passwd.Buffer = (PBYTE)&pAppleUamReqPkt->_ChallengeResponse[0];

            if (pSda->sda_ClientType == SDA_CLIENT_RANDNUM)
            {
                Passwd.Length = Passwd.MaximumLength = RANDNUM_RESP_LEN;
            }
            else
            {
                Passwd.Length = Passwd.MaximumLength = TWOWAY_RESP_LEN;
            }
        }

        ASSERT (pSda->sda_Challenge != NULL);

        Status = AfpLogonUser(pSda, &Passwd);
        AfpFreeMemory(pSda->sda_Challenge);
        pSda->sda_Challenge = NULL;
    }

    // Set the SDA in the right state
    if (Status == AFP_ERR_NONE)
    {
        // Cancel the scavenger event for checking this user's kickoff time
        // IF ANY
		
        AfpScavengerKillEvent(AfpSdaCheckSession,
                (PVOID)((ULONG_PTR)(pSda->sda_SessionId)));

        AfpInterlockedSetNClearDword(&pSda->sda_Flags,
                                     SDA_USER_LOGGEDIN,
                                     SDA_USER_LOGIN_PARTIAL,
                                     &pSda->sda_Lock);
        if (pSda->sda_tTillKickOff < MAXLONG)
            AfpScavengerScheduleEvent(
                        AfpSdaCheckSession,
                        (PVOID)((ULONG_PTR)(pSda->sda_SessionId)),
                        (pSda->sda_tTillKickOff > SESSION_WARN_TIME) ?
                             (pSda->sda_tTillKickOff - SESSION_WARN_TIME) :
                             SESSION_CHECK_TIME,
                        True);
    }
    else
    {
        // Cancel the scavenger event for checking this user's kickoff time
        // IF ANY
        AfpScavengerKillEvent(AfpSdaCheckSession,
                (PVOID)((ULONG_PTR)(pSda->sda_SessionId)));

        DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_ERR,
                ("AfpFspDispLoginCont: Logon failed: Scheduling session to be killed in (%ld) seconds\n"));
	
        pSda->sda_tTillKickOff = SESSION_KILL_TIME;
        AfpScavengerScheduleEvent(
                AfpSdaCheckSession,
                (PVOID)((ULONG_PTR)(pSda->sda_SessionId)),
                (pSda->sda_tTillKickOff > SESSION_WARN_TIME) ?
                (pSda->sda_tTillKickOff - SESSION_WARN_TIME) :
                SESSION_CHECK_TIME,
                True);
    }

    return Status;
}


/***    AfpFspDispLogout
 *
 *  This is the worker routine for the AfpLogout API.
 *
 *  There is no request packet for this API.
 */
AFPSTATUS FASTCALL
AfpFspDispLogout(
    IN  PSDA    pSda
)
{
    AFP_SESSION_INFO    SessInfo;

    PAGED_CODE( );

    DBGPRINT(DBG_COMP_AFPAPI_SRV, DBG_LEVEL_INFO,
            ("AfpFspDispLogout: Entered\n"));

    AfpInterlockedClearDword(&pSda->sda_Flags, SDA_LOGIN_MASK, &pSda->sda_Lock);

    return AFP_ERR_NONE;
}


/***    AfpFspDispChangePassword
 *
 *  This is the worker routine for the AfpChangePassword API.
 *
 *  The request packet is represented below.
 *
 *  sda_AfpSubFunc  BYTE            New password length - UAM
 *  sda_Name1       ANSI_STRING     UAM String
 *  sda_Name2       ANSI_STRING     User Name [and domain]
 *  sda_Name3       BLOCK           Old and New passwords
 *                                  Format depends on the UAM
 *                      ClearText   Old Password (8 bytes, 0 padded)
 *                                  New Password (8 bytes, 0 padded)
 *                      Encrypted   Old Password LM_OWF_PASSWORD (16)
 *                                  New Password LM_OWF_PASSWORD (16)
 *
 *  All we do here is package the user name, domain name, old and new password
 *  and give it up to user mode to attempt the password change since we cannot
 *  do it in kernel mode.
 */
AFPSTATUS FASTCALL
AfpFspDispChangePassword(
    IN  PSDA    pSda
)
{
    AFPSTATUS       Status;
    PAFP_PASSWORD_DESC  pPwdDesc=NULL;
    ANSI_STRING     NewPwd;
    UNICODE_STRING      UNewPwd;
    UNICODE_STRING      UserName;
    UNICODE_STRING      DomainName;
    BYTE            Method;
    struct _ResponsePacket
    {
        BYTE    __ExtendedErrorCode[4];
    };

    PAGED_CODE( );

    DBGPRINT(DBG_COMP_AFPAPI_SRV, DBG_LEVEL_INFO,
            ("AfpFspDispChangePassword: Entered\n"));

    if ((pPwdDesc =
        (PAFP_PASSWORD_DESC)AfpAllocPagedMemory(sizeof(AFP_PASSWORD_DESC))) == NULL)
    {
        return AFP_ERR_MISC;
    }

    AfpSetEmptyUnicodeString(&DomainName,
                             sizeof(pPwdDesc->DomainName),
                             pPwdDesc->DomainName);
    AfpSetEmptyUnicodeString(&UserName,
                             sizeof(pPwdDesc->UserName),
                             pPwdDesc->UserName);

    do
    {
        Status = AFP_ERR_BAD_UAM;   // Default
        // Validate the UAM string, cannot be 'No User Authent'
        for (Method = CLEAR_TEXT_AUTHENT; Method < AFP_NUM_UAMS; Method++)
        {
            if (RtlEqualString(&pSda->sda_Name1,
                               &AfpUamStrings[Method],
                               True))
            {
                if (pSda->sda_Flags & SDA_USER_LOGGEDIN)
                {
                    // if the client is logged in using TWOWAY_EXCHANGE, the
                    // UAM specified in password change is still RANDNUM_EXCHANGE
                    // so, hack it, so rest of our logic works!
                    //
                    if ((Method == RANDNUM_EXCHANGE) &&
                        (pSda->sda_ClientType == TWOWAY_EXCHANGE))
                    {
                        Method = TWOWAY_EXCHANGE;
                    }

                    if (pSda->sda_ClientType == Method)
                    {
                        Status = AFP_ERR_NONE;
                    }
                    else
                    {
                        Status = AFP_ERR_PARAM;
                    }
                }
                else
                {
                    pSda->sda_ClientType = Method;
                    Status = AFP_ERR_NONE;
                }
                break;
            }

        }

        if ((Status != AFP_ERR_NONE) ||
            ((Method == CLEAR_TEXT_AUTHENT) &&
                !(AfpServerOptions & AFP_SRVROPT_CLEARTEXTLOGONALLOWED)))
        {
            break;
        }

        Status = AFP_ERR_PARAM;     // Assume failure
        RtlZeroMemory(pPwdDesc, sizeof(AFP_PASSWORD_DESC));

        // Validate and Convert user name to unicode. If the user is already
        // logged in, make sure the user name matches what we already know
        if (!afpGetNameAndDomain(&pSda->sda_Name2,
                                 &UserName,
                                 &DomainName) ||
            !RtlEqualUnicodeString(&UserName,
                                   &pSda->sda_UserName,
                                   True)    ||
            !RtlEqualUnicodeString(&DomainName,
                                   &pSda->sda_DomainName,
                                   True))
        {
            DBGPRINT(DBG_COMP_AFPAPI_SRV, DBG_LEVEL_ERR,
                ("AfpFspDispChangePassword: afpGetNameAndDomain failed\n"));

            break;
        }

        pPwdDesc->AuthentMode = Method;

        if (Method == CLEAR_TEXT_AUTHENT)
        {
            ANSI_STRING             ATmpPwd;
            UNICODE_STRING      UOldPwd;

            // Make sure the old and new passwords are atleast the min. size
            if (pSda->sda_Name3.Length < (2 * sizeof(AFP_MAXPWDSIZE)))
                break;

            // Translate both passwords to host ansi (upper case)

            ATmpPwd.Buffer = pSda->sda_Name3.Buffer;
            ATmpPwd.Length = AFP_MAXPWDSIZE;
            ATmpPwd.MaximumLength = AFP_MAXPWDSIZE;

            UOldPwd.Buffer = (PWCHAR)pPwdDesc->OldPassword;
            UOldPwd.Length = sizeof(pPwdDesc->OldPassword);
            UOldPwd.MaximumLength = sizeof(pPwdDesc->OldPassword);
            if (!NT_SUCCESS(AfpConvertPasswordStringToUnicode(&ATmpPwd, &UOldPwd)))
            {
                DBGPRINT(DBG_COMP_AFPAPI_SRV, DBG_LEVEL_ERR,
                    ("AfpFspDispChangePassword: AfpConvertPasswordStringToUnicode 1 failed\n"));
                break;
            }
            pPwdDesc->OldPasswordLen = AFP_MAXPWDSIZE*sizeof(WCHAR);
            if (wcslen(UOldPwd.Buffer) < AFP_MAXPWDSIZE)
            {
                pPwdDesc->OldPasswordLen = wcslen(UOldPwd.Buffer)*sizeof(WCHAR);
            }

            ATmpPwd.Buffer = pSda->sda_Name3.Buffer+AFP_MAXPWDSIZE;
            ATmpPwd.Length = AFP_MAXPWDSIZE;
            ATmpPwd.MaximumLength = AFP_MAXPWDSIZE;

            UNewPwd.Buffer = (PWCHAR)pPwdDesc->NewPassword;
            UNewPwd.Length = sizeof(pPwdDesc->NewPassword);
            UNewPwd.MaximumLength = sizeof(pPwdDesc->NewPassword);
            if (!NT_SUCCESS(AfpConvertPasswordStringToUnicode(&ATmpPwd, &UNewPwd)))
            {
                DBGPRINT(DBG_COMP_AFPAPI_SRV, DBG_LEVEL_ERR,
                    ("AfpFspDispChangePassword: AfpConvertPasswordStringToUnicode 2 failed\n"));
                break;
            }
            pPwdDesc->NewPasswordLen = AFP_MAXPWDSIZE*sizeof(WCHAR);
            if (wcslen(UNewPwd.Buffer) < AFP_MAXPWDSIZE)
            {
                pPwdDesc->NewPasswordLen = wcslen(UNewPwd.Buffer)*sizeof(WCHAR);
            }

#if 0
            DBGPRINT(DBG_COMP_AFPAPI_SRV, DBG_LEVEL_ERR,
                ("AfpFspDispChangePassword: OldPwd=(%Z), NewPwd=(%Z)\n",
                 &UOldPwd, &UNewPwd));
#endif
        }


        //
        // if this is a client using Apple's native UAM, parms are different!
        //
        else if ((Method == RANDNUM_EXCHANGE) ||
                 (Method == TWOWAY_EXCHANGE))
        {
            // Make sure the old and new passwords are atleast the min. size
            if (pSda->sda_Name3.Length < (2 * MAX_MAC_PWD_LEN))
            {
                ASSERT(0);
                break;
            }

            RtlCopyMemory(pPwdDesc->OldPassword,
                          pSda->sda_Name3.Buffer,
                          MAX_MAC_PWD_LEN);
            RtlCopyMemory(pPwdDesc->NewPassword,
                          pSda->sda_Name3.Buffer + RANDNUM_RESP_LEN,
                          MAX_MAC_PWD_LEN);
        }

        else if (Method == SDA_CLIENT_MSUAM_V1)
        {
            // Make sure the old and new passwords are atleast the min. size
            if (pSda->sda_Name3.Length < (2 * LM_OWF_PASSWORD_LENGTH))
            {
                break;
            }

            pPwdDesc->bPasswordLength = pSda->sda_AfpSubFunc;
            RtlCopyMemory(pPwdDesc->OldPassword,
                          pSda->sda_Name3.Buffer,
                          LM_OWF_PASSWORD_LENGTH);
            RtlCopyMemory(pPwdDesc->NewPassword,
                          pSda->sda_Name3.Buffer + LM_OWF_PASSWORD_LENGTH,
                          LM_OWF_PASSWORD_LENGTH);
        }
        else if (Method == SDA_CLIENT_MSUAM_V2)
        {
            // the data expected here is large (532 bytes) here
            try {

                RtlCopyMemory(pPwdDesc->OldPassword,
                              pSda->sda_Name3.Buffer,
                              LM_OWF_PASSWORD_LENGTH);
                RtlCopyMemory(pPwdDesc->NewPassword,
                              pSda->sda_Name3.Buffer + LM_OWF_PASSWORD_LENGTH,
                              (SAM_MAX_PASSWORD_LENGTH * 2) + 4);
            } except( EXCEPTION_EXECUTE_HANDLER ) {
                ASSERT(0);
                break;
            }
        }
        else if (Method == SDA_CLIENT_MSUAM_V3)
        {
            DBGPRINT(DBG_COMP_AFPAPI_SRV, DBG_LEVEL_INFO,
                    ("AfpFspDispChangePassword: SDA_CLIENT_MSUAM_V3\n"));

            // the data expected here is large
            try
            {
                RtlCopyMemory(&pPwdDesc->NtEncryptedBuff.Ciphers,
                      pSda->sda_Name3.Buffer,
                      sizeof(SFM_PASSWORD_CHANGE_MESSAGE_HEADER));

                if (!strcmp(pPwdDesc->NtEncryptedBuff.Ciphers.h.Signature, SFM_CHANGE_PASSWORD_SIGNATURE)
                    && (pPwdDesc->NtEncryptedBuff.Ciphers.h.Version == 1))
                {
                    if (pPwdDesc->NtEncryptedBuff.Ciphers.h.cbMessage == sizeof(SFM_PASSWORD_CHANGE_MESSAGE_1))
                    {
                        RtlCopyMemory(&pPwdDesc->NtEncryptedBuff.Ciphers,
                              pSda->sda_Name3.Buffer,
                              pPwdDesc->NtEncryptedBuff.Ciphers.h.cbMessage);
                    }
                    else if (pPwdDesc->NtEncryptedBuff.Ciphers.h.cbMessage == sizeof(SFM_PASSWORD_CHANGE_MESSAGE_1_SHORT))
                    {
                        RtlCopyMemory(
                            ((UCHAR*)&pPwdDesc->NtEncryptedBuff.Ciphers.m1)
                              + sizeof(pPwdDesc->NtEncryptedBuff.Ciphers.m1) - sizeof(SFM_PASSWORD_CHANGE_MESSAGE_1_SHORT) + 2, // trailing byte of 2
                            pSda->sda_Name3.Buffer,
                            pPwdDesc->NtEncryptedBuff.Ciphers.h.cbMessage);
                    }
                    else
                    {
                        DBGPRINT(DBG_COMP_AFPAPI_SRV, DBG_LEVEL_ERR,
                           ("AfpFspDispChangePassword: unexpected cbMessage\n"));
                        break;
                    }
                }
                else
                {
                    DBGPRINT(DBG_COMP_AFPAPI_SRV, DBG_LEVEL_ERR,
                       ("AfpFspDispChangePassword: unexpected cipher\n"));
                    break;
                }
            } except( EXCEPTION_EXECUTE_HANDLER ) {
                DBGPRINT(DBG_COMP_AFPAPI_SRV, DBG_LEVEL_ERR,
                   ("AfpFspDispChangePassword: exception\n"));

                ASSERT(0);
                break;
            }
        }
        else
        {
            DBGPRINT(DBG_COMP_AFPAPI_SRV, DBG_LEVEL_ERR,
                ("AfpFspDispChangePassword: unknown method %d\n",Method));
            ASSERT(0);
        }

        Status = AfpChangePassword(pSda, pPwdDesc);

        DBGPRINT(DBG_COMP_AFPAPI_SRV, DBG_LEVEL_ERR,
                ("AfpFspDispChangePassword: AfpChangePassword returned %lx\n",
                Status));
    } while (False);

    if (NT_SUCCESS(Status))
    {
        // Check if we are here because the login returned password expired.
        // If this is Afp 2.1 chooser, we also need to logon this fella
        if (pSda->sda_Flags & SDA_LOGIN_FAILED)
        {
            AfpInterlockedClearDword(&pSda->sda_Flags,
                                      SDA_LOGIN_FAILED,
                                      &pSda->sda_Lock);

            NewPwd.Buffer = pPwdDesc->NewPassword;
            NewPwd.Length = sizeof(pPwdDesc->NewPassword);
            NewPwd.MaximumLength = sizeof(pPwdDesc->NewPassword);
            RtlCopyMemory(pPwdDesc->NewPassword,
                          pSda->sda_Name3.Buffer+AFP_MAXPWDSIZE,
                          AFP_MAXPWDSIZE);
            if (AfpConvertMacAnsiToHostAnsi(&NewPwd) != AFP_ERR_NONE)
            {
                // break;
            }

            // The user password as we have it is potentially padded with nulls
            // if it is less than 8 chars. Get the length right
            NewPwd.Length = strlen(NewPwd.Buffer) + 1;
            Status = AfpLogonUser(pSda, &NewPwd);
            if (Status == AFP_ERR_NONE)
            {
                AfpInterlockedSetDword(&pSda->sda_Flags,
                                        SDA_USER_LOGGEDIN,
                                        &pSda->sda_Lock);
                pSda->sda_WSName.Length = 0;
                pSda->sda_WSName.MaximumLength = 0;
                pSda->sda_WSName.Buffer = NULL;
                if (pSda->sda_tTillKickOff < MAXLONG)
                    AfpScavengerScheduleEvent(
                            AfpSdaCheckSession,
                            (PVOID)((ULONG_PTR)(pSda->sda_SessionId)),
                            (pSda->sda_tTillKickOff > SESSION_WARN_TIME) ?
                                (pSda->sda_tTillKickOff - SESSION_WARN_TIME) :
                                SESSION_CHECK_TIME,
                             True);
            }
        }
    }
    else        // Failure - convert to right status code
    {
        {
            // Cancel the scavenger event for checking this user's kickoff time
            // IF ANY
            AfpScavengerKillEvent(AfpSdaCheckSession,
                    (PVOID)((ULONG_PTR)(pSda->sda_SessionId)));

            DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_ERR,
                    ("AfpFspDispChangePassword: Chgpwd/Logon failed: Scheduling session to be killed in (%ld) seconds\n"));

            pSda->sda_tTillKickOff = SESSION_KILL_TIME;
            AfpScavengerScheduleEvent(
                    AfpSdaCheckSession,
                    (PVOID)((ULONG_PTR)(pSda->sda_SessionId)),
                    (pSda->sda_tTillKickOff > SESSION_WARN_TIME) ?
                    (pSda->sda_tTillKickOff - SESSION_WARN_TIME) :
                    SESSION_CHECK_TIME,
                    True);
        }
        if ((pSda->sda_ClientType == SDA_CLIENT_MSUAM_V1) ||
            (pSda->sda_ClientType == SDA_CLIENT_MSUAM_V2) ||
            (pSda->sda_ClientType == SDA_CLIENT_MSUAM_V3))
        {
            if (Status == STATUS_PASSWORD_EXPIRED)
                Status = AFP_ERR_PASSWORD_EXPIRED;
            else if (Status == STATUS_ACCOUNT_DISABLED)
                Status = AFP_ERR_ACCOUNT_DISABLED;
            else if (Status == STATUS_INVALID_LOGON_HOURS)
                Status = AFP_ERR_INVALID_LOGON_HOURS;
            else if (Status == STATUS_INVALID_WORKSTATION)
                Status = AFP_ERR_INVALID_WORKSTATION;
            else if (Status == STATUS_PASSWORD_RESTRICTION)
                Status = AFP_ERR_PASSWORD_RESTRICTED;
            else if (Status == STATUS_PWD_TOO_SHORT)
                Status = AFP_ERR_PASSWORD_TOO_SHORT;
            else if (Status == STATUS_ACCOUNT_RESTRICTION)
                Status = AFP_ERR_ACCOUNT_RESTRICTED;
            else if (Status == STATUS_ACCESS_DENIED)
                Status = AFP_ERR_PASSWORD_CANT_CHANGE;
            else if ((Status != AFP_ERR_BAD_UAM) &&
                     (Status != AFP_ERR_PARAM))
                Status = AFP_ERR_MISC;
        }
        else
        {
            if (Status == STATUS_WRONG_PASSWORD)
                Status = AFP_ERR_USER_NOT_AUTH;

            else if ((Status == STATUS_PASSWORD_RESTRICTION) ||
                     (Status == STATUS_ACCOUNT_DISABLED))
                Status = AFP_ERR_ACCESS_DENIED;

            else if (Status == STATUS_PWD_TOO_SHORT)
            {
                if ((pSda->sda_Flags & SDA_USER_LOGGEDIN) &&
                    (pSda->sda_ClientVersion >= AFP_VER_21))
                {
                    Status = AFP_ERR_PWD_TOO_SHORT;
                }
                else
                    Status = AFP_ERR_ACCESS_DENIED;
            }

            else if ((Status == STATUS_NONE_MAPPED) ||
                     (Status == STATUS_NO_SUCH_USER))
                Status = AFP_ERR_PARAM;
            else if ((Status != AFP_ERR_BAD_UAM) &&
                     (Status != AFP_ERR_PARAM))
                Status = AFP_ERR_MISC;
        }
    }

    if (pPwdDesc)
    {
        AfpFreeMemory(pPwdDesc);
    }

    return Status;
}


/***    AfpFspDispMapName
 *
 *  This is the worker routine for the AfpMapName API.
 *
 *  The request packet is represented below.
 *
 *  sda_SubFunc BYTE        User/Group Flag
 *  sda_Name1   ANSI_STRING Name of user/group
 */
AFPSTATUS FASTCALL
AfpFspDispMapName(
    IN  PSDA    pSda
)
{
    AFPSTATUS       Status = AFP_ERR_NONE;
    UNICODE_STRING  Us;
    DWORD           UserOrGroupId = 0;
    struct _ResponsePacket
    {
        BYTE    __UserOrGroupId[4];
    };

    PAGED_CODE( );

    DBGPRINT(DBG_COMP_AFPAPI_SRV, DBG_LEVEL_INFO,
            ("AfpFspDispMapName: Entered\n"));

    if ((pSda->sda_AfpSubFunc != MAP_USER_NAME) &&
        (pSda->sda_AfpSubFunc != MAP_GROUP_NAME))
        return AFP_ERR_PARAM;

    AfpSetEmptyUnicodeString(&Us, 0, NULL);
    // If this is the first time we are asking for the name to be translated.
    if ((pSda->sda_Name1.Length != 0) &&
        (pSda->sda_SecUtilSid == NULL) &&
        (NT_SUCCESS(pSda->sda_SecUtilResult)))
    {
        Us.MaximumLength = (pSda->sda_Name1.Length + 1) * sizeof(WCHAR);
        if ((Us.Buffer = (LPWSTR)AfpAllocPagedMemory(Us.MaximumLength)) == NULL)
        {
            return AFP_ERR_MISC;
        }

        if (!NT_SUCCESS(Status = AfpConvertStringToUnicode(&pSda->sda_Name1, &Us)))
        {
            AfpFreeMemory(Us.Buffer);
            return AFP_ERR_MISC;
        }

        Status = AfpNameToSid( pSda, &Us );

        AfpFreeMemory(Us.Buffer);

        if (!NT_SUCCESS(Status))
        {
            if (Status != AFP_ERR_EXTENDED)
                Status = AFP_ERR_MISC;
        }

        return Status;
    }

    // If we have successfully translated the name
    if (pSda->sda_Name1.Length != 0)
    {
        if ((pSda->sda_SecUtilSid != NULL) &&
            (NT_SUCCESS( pSda->sda_SecUtilResult)))
            Status = AfpSidToMacId(pSda->sda_SecUtilSid, &UserOrGroupId);
        else Status = AFP_ERR_ITEM_NOT_FOUND;
    }

    if (NT_SUCCESS(Status))
    {
        pSda->sda_ReplySize = SIZE_RESPPKT;
        if ((Status = AfpAllocReplyBuf(pSda)) == AFP_ERR_NONE)
        {
            PUTDWORD2DWORD(pRspPkt->__UserOrGroupId, UserOrGroupId);
        }
    }

    if (pSda->sda_SecUtilSid != NULL)
    {
        AfpFreeMemory(pSda->sda_SecUtilSid);
        pSda->sda_SecUtilSid = NULL;
    }

    return Status;
}


/***    AfpFspDispMapId
 *
 *  This is the worker routine for the AfpMapId API.
 *
 *  The request packet is represented below.
 *
 *  sda_SubFunc     BYTE    User/Group Flag
 *  sda_ReqBlock    DWORD   UserId
 *
 *  We do not use the UserId field since it is invalid anyway !!
 */
AFPSTATUS FASTCALL
AfpFspDispMapId(
    IN  PSDA    pSda
)
{
    AFPSTATUS       Status = AFP_ERR_NONE;
     PAFP_SID_NAME  pSidName = NULL;
    PSID            pSid;           // Sid of user or group
    struct _RequestPacket
    {
        DWORD   _UserOrGroupId;
    };
    struct _ResponsePacket
    {
        BYTE    __NameLength[1];
        BYTE    __Name[1];
    };

    PAGED_CODE( );

    DBGPRINT(DBG_COMP_AFPAPI_SRV, DBG_LEVEL_INFO,
            ("AfpFspDispMapId: Entered\n"));

    if ((pSda->sda_AfpSubFunc != MAP_USER_ID) &&
        (pSda->sda_AfpSubFunc != MAP_GROUP_ID))
        return AFP_ERR_PARAM;

    Status = AFP_ERR_ITEM_NOT_FOUND;    // Assume failure

    if (NT_SUCCESS(pSda->sda_SecUtilResult)) do
    {
        ANSI_STRING As;

        As.Length = 0;
        As.MaximumLength = 1;
        As.Buffer = "";

        if (pReqPkt->_UserOrGroupId != 0)
        {
            Status = AfpMacIdToSid(pReqPkt->_UserOrGroupId, &pSid);
            if (!NT_SUCCESS(Status))
            {
                Status = AFP_ERR_ITEM_NOT_FOUND;
                break;
            }

            Status = AfpSidToName(pSda, pSid, &pSidName);

            if (!NT_SUCCESS(Status))
            {
                if (Status != AFP_ERR_EXTENDED)
                    Status = AFP_ERR_MISC;
                break;
            }

/* MSKK hideyukn, Unicode char length not eqaul to ansi byte length in DBCS, 08/07/95 */
#ifdef DBCS
            pSda->sda_ReplySize = pSidName->Name.Length + SIZE_RESPPKT;
#else
            pSda->sda_ReplySize = pSidName->Name.Length/sizeof(WCHAR) + SIZE_RESPPKT;
#endif // DBCS
        }
        else pSda->sda_ReplySize = SIZE_RESPPKT;        // For an id of 0

        if ((Status = AfpAllocReplyBuf(pSda)) == AFP_ERR_NONE)
        {
            if (pSidName != NULL)
            {
                As.MaximumLength = pSda->sda_ReplySize - 1;
                As.Buffer = pRspPkt->__Name;
                if ((Status = AfpConvertStringToAnsi(&pSidName->Name, &As)) != AFP_ERR_NONE)
                {
                    AfpFreeReplyBuf(pSda, FALSE);
                }
                PUTBYTE2BYTE(pRspPkt->__NameLength, As.Length);
            }
            else PUTBYTE2BYTE(pRspPkt->__NameLength, 0);
        }
    } while (False);

    return Status;
}


/***    AfpFspDispGetUserInfo
 *
 *  This routine implements the AfpGetUserInfo API.
 *
 *  The request packet is represented below.
 *
 *  sda_AfpSubFunc  BYTE    ThisUser flag
 *  sda_ReqBlock    DWORD   UserId
 *  sda_ReqBlock    DWORD   Bitmap
 *
 *  We do not use the UserId field since it is invalid anyway !!
 */
AFPSTATUS FASTCALL
AfpFspDispGetUserInfo(
    IN  PSDA    pSda
)
{
    DWORD       Bitmap;
    PBYTE       pTemp;
    AFPSTATUS   Status = AFP_ERR_PARAM;
    DWORD       Uid, Gid;
    struct _RequestPacket
    {
        DWORD   _UserId;
        DWORD   _Bitmap;
    };
    struct _ResponsePacket
    {
        BYTE    __Bitmap[2];
        BYTE    __Id1[4];
        BYTE    __Id2[4];
    };

    PAGED_CODE( );

    DBGPRINT(DBG_COMP_AFPAPI_SRV, DBG_LEVEL_INFO,
            ("AfpFspDispGetUserInfo: Entered\n"));

    do
    {
        if (!(pSda->sda_AfpSubFunc & USERINFO_THISUSER))
            break;

        Bitmap =  pReqPkt->_Bitmap;
        if (Bitmap & ~(USERINFO_BITMAP_USERID | USERINFO_BITMAP_PRIGID))
        {
            Status = AFP_ERR_BITMAP;
            break;
        }

        if (Bitmap & USERINFO_BITMAP_USERID)
        {
            if (!NT_SUCCESS(Status = AfpSidToMacId(pSda->sda_UserSid, &Uid)))
            {
                Status = AFP_ERR_MISC;
                break;
            }
        }

        if (Bitmap & USERINFO_BITMAP_PRIGID)
        {
            if (!NT_SUCCESS(Status = AfpSidToMacId(pSda->sda_GroupSid, &Gid)))
            {
                Status = AFP_ERR_MISC;
                break;
            }
        }

        pSda->sda_ReplySize = SIZE_RESPPKT;
        if ((Status = AfpAllocReplyBuf(pSda)) == AFP_ERR_NONE)
        {
            PUTSHORT2SHORT(pRspPkt->__Bitmap, Bitmap);
            pTemp = pRspPkt->__Id1;
            if (Bitmap & USERINFO_BITMAP_USERID)
            {
                PUTDWORD2DWORD(pTemp, Uid);
                pTemp = pRspPkt->__Id2;
            }
            else pSda->sda_ReplySize -= sizeof(DWORD);

            if (Bitmap & USERINFO_BITMAP_PRIGID)
            {
                PUTDWORD2DWORD(pTemp, Gid);
            }
            else pSda->sda_ReplySize -= sizeof(DWORD);
        }
    } while (False);
    return Status;
}


/***    afpGetUserNameAndPwdOrWSName
 *
 *  Unmarshall the block containing UserName and either password or WS Name
 *  into unicode/ansi strings. Allocate memory for the output strings.
 *
 *  The layout of the Buffer is as follows:
 *  User Name and an optional pad
 *  Workstation name or user password depending on the UAM.
 *
 *  The optional pad is not directly determined since this buffer has been
 *  copied and we do not know at this point whether this started at an odd
 *  or an even boundary. We get to it indirectly from the size.
 */
LOCAL BOOLEAN
afpGetUserNameAndPwdOrWSName(
    IN  PANSI_STRING    Block,
    IN  BYTE            ClientType,
    OUT PUNICODE_STRING pUserName,
    OUT PUNICODE_STRING pDomainName,
    OUT PVOID           pParm           // Either password or WSName
)
{
    ANSI_STRING     UserName;
#define pPwd    ((PANSI_STRING)pParm)
#define pWS     ((PUNICODE_STRING)pParm)
    PBYTE           pTmp;
    BOOLEAN         RetCode = False;

    PAGED_CODE( );

    do
    {
        pPwd->Buffer = NULL;
        pPwd->Length = 0;
        pUserName->Buffer = NULL;

        if (Block->Buffer == NULL)
        {
            ASSERT(0);
            return(False);
        }

        pTmp = Block->Buffer;
        UserName.Length = (USHORT)*pTmp;
        UserName.Buffer = ++pTmp;

        // Sanity check
        if ((USHORT)(UserName.Length + 1) > Block->Length)
            break;

        pTmp += UserName.Length;

        // make sure we are within bounds!
        if (pTmp <= (Block->Buffer + Block->Length))
        {
            // If there is a NULL pad, go past it.
            if (*pTmp == '\0')
                pTmp++;
        }

        pUserName->Buffer = NULL;   // Force allocation
        pDomainName->Buffer = NULL; // Force allocation
        if (!afpGetNameAndDomain(&UserName, pUserName, pDomainName))
            break;

        // Make sure we do not have a name of the form "DOMAIN\" i.e. a
        // valid domain name and a NULL user name, disallow that explicitly
        // so that we don't logon such users with a NULL session
        if (pUserName->Length == 0)
        {
            if (pUserName->Buffer != NULL)
            {
                AfpFreeMemory(pUserName->Buffer);
                pUserName->Buffer = NULL;
            }
            if (pDomainName->Buffer != NULL)
            {
                AfpFreeMemory(pDomainName->Buffer);
                pDomainName->Buffer = NULL;
            }
            return False;
        }

        // The balance of the buffer is the block, if it is a password. Else
        // it is the machine name string which is a PASCALSTR.
        pPwd->MaximumLength = (USHORT)(Block->Length - (pTmp - Block->Buffer) + 1);
        if (ClientType != SDA_CLIENT_CLEARTEXT)
        {
            // in case of Apple UAM (scrambled or 2-way), machine name won't
            // be present, so check only for MS-UAM
            //
            if (((ClientType == SDA_CLIENT_MSUAM_V1) ||
                (ClientType == SDA_CLIENT_MSUAM_V2) ||
                (ClientType == SDA_CLIENT_MSUAM_V3)) &&
					(pTmp <  (Block->Buffer + Block->Length - 1)))
            {
                pWS->MaximumLength = (USHORT)((*pTmp + 1) * sizeof(WCHAR));

                if (pWS->MaximumLength < (USHORT)((Block->Length -
                                (pTmp - Block->Buffer + 1)) *sizeof(WCHAR)))
                {
                    return False;
                }
            }
            else
            {
                pWS->MaximumLength = (sizeof(AFP_DEFAULT_WORKSTATION_A) *
                                     sizeof(WCHAR));
            }
        }

        if ((pPwd->Buffer = AfpAllocNonPagedMemory(pPwd->MaximumLength)) == NULL)
            break;

        if (ClientType == SDA_CLIENT_CLEARTEXT)
        {
            // We are dealing with a clear text password
            pPwd->Length = pPwd->MaximumLength - 1;
            RtlCopyMemory(pPwd->Buffer, pTmp, pPwd->Length);
            if (AfpConvertMacAnsiToHostAnsi(pPwd) != AFP_ERR_NONE)
                break;
            pPwd->Buffer[pPwd->Length] = 0;
        }
        else
        {
            ANSI_STRING AS;

            if (((ClientType == SDA_CLIENT_MSUAM_V1) ||
                (ClientType == SDA_CLIENT_MSUAM_V2) ||
                (ClientType == SDA_CLIENT_MSUAM_V3)) &&
					(pTmp <  (Block->Buffer + Block->Length - 1)))
            {
                AS.Buffer = ++pTmp;
                AS.MaximumLength = pWS->MaximumLength/sizeof(WCHAR);
                AS.Length = AS.MaximumLength - 1;
            }
            //
            // for scrambled and 2-way exchange, use default wksta name since
            // we don't know what it is
            //
            else
            {
                AS.Buffer = AFP_DEFAULT_WORKSTATION_A;
                AS.MaximumLength = pWS->MaximumLength/sizeof(WCHAR);
                AS.Length = AS.MaximumLength - 1;
            }

            // We have potentially a workstation name here. Since this is a
            // pascal string, adjust the length etc.
            AfpConvertStringToUnicode(&AS, pWS);
            pWS->Buffer[pWS->Length/sizeof(WCHAR)] = L'\0';
        }

        RetCode = True;
    } while (False);

    if (!RetCode)
    {
        if (pUserName->Buffer != NULL)
        {
            AfpFreeMemory(pUserName->Buffer);
            pUserName->Buffer = NULL;
        }
        if (pPwd->Buffer != NULL)
        {
            AfpFreeMemory(pPwd->Buffer);
            pPwd->Buffer = NULL;
        }
        if (pDomainName->Buffer != NULL)
        {
            AfpFreeMemory(pDomainName->Buffer);
            pDomainName->Buffer = NULL;
        }
    }

    return RetCode;
}



/***    afpGetNameAndDomain
 *
 *  Extract the name and domain from a string formed as DOMAIN\NAME.
 */
BOOLEAN
afpGetNameAndDomain(
    IN  PANSI_STRING    pDomainNUser,
    OUT PUNICODE_STRING pUserName,
    OUT PUNICODE_STRING pDomainName
)
{
    BYTE            c;
    ANSI_STRING     User, Domain;
    BOOLEAN         fDomainBuffAlloc=FALSE;

    // Check if the user name has a '\' character in it. If it does,
    // seperate the domain name from user name. The Username string is
    // not ASCIIZ. Before we search for a '\', make it ASCIIZ w/o trashing
    // whatever is there.

    PAGED_CODE( );

    User.Buffer = AfpStrChr(pDomainNUser->Buffer, pDomainNUser->Length, '\\');

    if (User.Buffer != NULL)
    {
        (User.Buffer) ++;           // Past the '\'
        Domain.Buffer = pDomainNUser->Buffer;

        Domain.Length = (USHORT)(User.Buffer - Domain.Buffer - 1);
        User.Length = pDomainNUser->Length - Domain.Length - 1;

        if (Domain.Length > DNLEN)
        {
            DBGPRINT(DBG_COMP_AFPAPI_SRV, DBG_LEVEL_ERR,
                ("afpGetNameAndDomain: domain name too long (%d vs. max %d): rejecting\n",
                Domain.Length, DNLEN));
            return(False);
        }

        Domain.MaximumLength = Domain.Length + 1;
        pDomainName->MaximumLength = Domain.MaximumLength * sizeof(WCHAR);

        if (pDomainName->Buffer == NULL)
        {
            if ((pDomainName->Buffer =
                (PWSTR)AfpAllocNonPagedMemory(pDomainName->MaximumLength)) == NULL)
            {
                return False;
            }
            fDomainBuffAlloc = TRUE;
        }
        AfpConvertStringToUnicode(&Domain, pDomainName);
    }
    else User = *pDomainNUser;

    if (User.Length > LM20_UNLEN)
    {
        DBGPRINT(DBG_COMP_AFPAPI_SRV, DBG_LEVEL_ERR,
            ("afpGetNameAndDomain: user name too long (%d vs. max %d): rejecting\n",
            User.Length,LM20_UNLEN));
        return(False);
    }

    User.MaximumLength = User.Length + 1;
    pUserName->MaximumLength = User.MaximumLength * sizeof(WCHAR);

    if ((pUserName->Buffer == NULL) &&
        (pUserName->Buffer =
            (PWSTR)AfpAllocNonPagedMemory(pUserName->MaximumLength)) == NULL)
    {
        if (fDomainBuffAlloc)
        {
            AfpFreeMemory(pDomainName->Buffer);
            pDomainName->Buffer = NULL;
        }
        return False;
    }

    AfpConvertStringToUnicode(&User, pUserName);

    return True;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\server\fwddecl.h ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

        fwddecl.h

Abstract:

        This file defines dummy structures to avoid the circular relationships in
        header files.

Author:

        Jameel Hyder (microsoft!jameelh)


Revision History:
        2       Oct 1992             Initial Version

Notes:  Tab stop: 4
--*/


#ifndef _FWDDECL_
#define _FWDDECL_


struct _SessDataArea;

struct _ConnDesc;

struct _VolDesc;

struct _FileDirParms;

struct _PathMapEntity;

struct _DirFileEntry;

struct _FileDirParms;

struct _IoPoolHdr;

struct _IoPool;

//
// enable asserts when running checked stack on free builds
//
#if DBG
#ifdef ASSERT
#undef ASSERT
#endif
#define ASSERT(exp)                                                     \
{                                                                       \
    if (!(exp))                                                         \
    {                                                                   \
        DbgPrint( "\n*** Assertion failed: %s (File %s, line %ld)\n",   \
              (exp),__FILE__, __LINE__);                                \
                                                                        \
        DbgBreakPoint();                                                \
    }                                                                   \
}
#endif

// Spinlock macros
#if     DBG
#define INITIALIZE_SPIN_LOCK(_pLock)                                                                                    \
        {                                                                                                                                                       \
                KeInitializeSpinLock(&(_pLock)->SpinLock);                                                              \
                (_pLock)->FileLineLock = 0;                                                                                             \
        }
#else   // DBG
#define INITIALIZE_SPIN_LOCK(_pLock)                                                                \
        {                                                                                                                               \
        KeInitializeSpinLock(&(_pLock)->SpinLock);                                                  \
        }
#endif

#if     DBG
#define ACQUIRE_SPIN_LOCK(_pLock, _pOldIrql)                                                                    \
        {                                                                                                                                                       \
                KeAcquireSpinLock(&(_pLock)->SpinLock,                                                                  \
                                                  _pOldIrql);                                                                                   \
                (_pLock)->FileLineLock = (FILENUM | __LINE__);                                                  \
        }

#define ACQUIRE_SPIN_LOCK_AT_DPC(_pLock)                                                                                \
        {                                                                                                                                                       \
                ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);                                                   \
                KeAcquireSpinLockAtDpcLevel(&(_pLock)->SpinLock);                                               \
                (_pLock)->FileLineLock = (FILENUM | __LINE__ | 0x80000000);                             \
        }

#define RELEASE_SPIN_LOCK(_pLock, _OldIrql)                                                                             \
        {                                                                                                                                                       \
                ASSERT ((_pLock)->FileLineLock != 0);                                                                   \
                ASSERT (((_pLock)->FileLineLock & 0x80000000) == 0);                                    \
                (_pLock)->FileLineLock = 0;                                                                                             \
                (_pLock)->FileLineUnlock = (FILENUM | __LINE__);                                                \
                KeReleaseSpinLock(&(_pLock)->SpinLock,                                                                  \
                                                  _OldIrql);                                                                                    \
        }

#define RELEASE_SPIN_LOCK_FROM_DPC(_pLock)                                                                              \
        {                                                                                                                                                       \
                ASSERT ((_pLock)->FileLineLock != 0);                                                                   \
                ASSERT ((_pLock)->FileLineLock & 0x80000000);                                                   \
                (_pLock)->FileLineLock = 0;                                                                                             \
                (_pLock)->FileLineUnlock = (FILENUM | __LINE__ | 0x80000000);                   \
                KeReleaseSpinLockFromDpcLevel(&(_pLock)->SpinLock);                                             \
                ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);                                                   \
        }

#else   // DBG

#define ACQUIRE_SPIN_LOCK(_pLock, _pOldIrql)                                                                    \
        {                                                                                                                                                       \
                KeAcquireSpinLock(&(_pLock)->SpinLock,                                                                  \
                                                  _pOldIrql);                                                                                   \
        }

#define ACQUIRE_SPIN_LOCK_AT_DPC(_pLock)                                                                                \
        {                                                                                                                                                       \
                KeAcquireSpinLockAtDpcLevel(&(_pLock)->SpinLock);                                               \
        }

#define RELEASE_SPIN_LOCK(_pLock, _OldIrql)                                                                             \
        {                                                                                                                                                       \
                KeReleaseSpinLock(&(_pLock)->SpinLock,                                                                  \
                                                  (_OldIrql));                                                                                  \
        }

#define RELEASE_SPIN_LOCK_FROM_DPC(_pLock)                                                                              \
        {                                                                                                                                                       \
                KeReleaseSpinLockFromDpcLevel(&(_pLock)->SpinLock);                                             \
        }                                                                                                                                                       \

#endif  // DBG

typedef struct
{
    KSPIN_LOCK      SpinLock;
#if DBG
    ULONG           FileLineLock;
    ULONG           FileLineUnlock;
#endif
} AFP_SPIN_LOCK, *PAFP_SPIN_LOCK;

#endif  // _FWDDECL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\server\fsp_vol.c ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	fsp_vol.c

Abstract:

	This module contains the entry points for the AFP volume APIs. The API
	dispatcher calls these. These are all callable from FSP.

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	10 Dec 1992		Initial Version

Notes:	Tab stop: 4
--*/

#define	FILENUM	FILE_FSP_VOL

#include <afp.h>
#include <gendisp.h>


#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, AfpFspDispOpenVol)
#endif

/***	AfpFspDispOpenVol
 *
 *	This routine implements the AfpOpenVol API.
 *
 *	The request packet is represented below.
 *
 *	sda_ReqBlock	DWORD		Bitmap
 *	sda_Name1		ANSI_STRING	VolName
 *	sda_Name2		ANSI_STRING	VolPassword		OPTIONAL
 */
AFPSTATUS FASTCALL
AfpFspDispOpenVol(
	IN	PSDA	pSda
)
{
	AFPSTATUS		Status;
	struct _RequestPacket
	{
		DWORD	_Bitmap;
	};

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_AFPAPI_VOL, DBG_LEVEL_INFO,
										("AfpFspDispOpenVol: Entered\n"));

	ASSERT (pSda->sda_ReplyBuf != NULL);

	if ((Status = AfpConnectionOpen(pSda, &pSda->sda_Name1, &pSda->sda_Name2,
						pReqPkt->_Bitmap, pSda->sda_ReplyBuf)) != AFP_ERR_NONE)
	{
		AfpFreeReplyBuf(pSda, FALSE);
	}
	return Status;
}


/***	AfpFspDispGetVolParms
 *
 *	This routine implements the AfpGetVolParms API, at task level.  We need to
 *  come to this routine if DiskQuota is enabled on the volume because we have
 *  to be at task level to query quota info
 *
 *	The request packet is represented below.
 *
 *	sda_ReqBlock	DWORD		VolId
 *	sda_ReqBlock	DWORD		Bitmap
 */
AFPSTATUS FASTCALL
AfpFspDispGetVolParms(
	IN	PSDA	pSda
)
{
	AFPSTATUS	Status = AFP_ERR_PARAM;
    PVOLDESC    pVolDesc;
	struct _RequestPacket
	{
		PCONNDESC	_pConnDesc;
		DWORD		_Bitmap;
	};


	DBGPRINT(DBG_COMP_AFPAPI_VOL, DBG_LEVEL_INFO,
			("AfpFspDispGetVolParms: Entered\n"));

	ASSERT(KeGetCurrentIrql() != DISPATCH_LEVEL);

	ASSERT(VALID_CONNDESC(pReqPkt->_pConnDesc) &&
		   VALID_VOLDESC(pReqPkt->_pConnDesc->cds_pVolDesc));

    pVolDesc = pReqPkt->_pConnDesc->cds_pVolDesc;

    ASSERT(pVolDesc->vds_Flags & VOLUME_DISKQUOTA_ENABLED);

	pSda->sda_ReplySize = AfpVolumeGetParmsReplyLength(
                                pReqPkt->_Bitmap,
							    pVolDesc->vds_MacName.Length);


	if ((Status = AfpAllocReplyBuf(pSda)) == AFP_ERR_NONE)
	{
        if (AfpConnectionReferenceByPointer(pReqPkt->_pConnDesc) != NULL)
        {
            afpUpdateDiskQuotaInfo(pReqPkt->_pConnDesc);
        }

		AfpVolumePackParms(pSda, pVolDesc, pReqPkt->_Bitmap, pSda->sda_ReplyBuf);
	}

	return Status;
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\server\intrlckd.h ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

        intrlckd.h

Abstract:

        This module defines the routines that should have been in the EX package.
        This manipulates inter-locked operations on flags and such.

Author:

        Jameel Hyder (microsoft!jameelh)


Revision History:
        5 Sep 1992              Initial Version

Notes:  Tab stop: 4
--*/

#ifndef _INTRLCKD_
#define _INTRLCKD_

extern
VOID  FASTCALL
AfpInterlockedSetDword(
        IN      PDWORD          pSrc,
        IN      DWORD           Mask,
        IN      PAFP_SPIN_LOCK  pSpinLock
);


extern
VOID FASTCALL
AfpInterlockedClearDword(
        IN      PDWORD          pSrc,
        IN      DWORD           Mask,
        IN      PAFP_SPIN_LOCK  pSpinLock
);


extern
VOID FASTCALL
AfpInterlockedSetNClearDword(
        IN      PDWORD          pSrc,
        IN      DWORD           SetMask,
        IN      DWORD           ClrMask,
        IN      PAFP_SPIN_LOCK  pSpinLock
);


// Macros for Interlocked/ExInterlocked calls
//
// For future reference, here is the difference between all the different
// kernel mode interlocked routines:
//
// InterlockedIncrement/Decrement - fastest on all platforms, inlined
// where appropriate to avoid call overhead.  No spinlock required, usable
// on paged data. Operation is atomic ONLY with respect to other Interlocked
// calls.
//
// ExInterlockedIncrement/Decrement - not as efficient, requires a function
// call and a spinlock.  Operation is atomic ONLY with respect to other
// ExInterlockedIncrement/Decrement calls.  There is no reason to use this
// instead of InterlockedIncrement/Decrement. Does not actually acquire the
// spinlock.  Required for backwards compatibility.
//
// ExInterlockedAddUlong - most inefficient, requires a function call and a
// spinlock.  Spinlock is actually acquired, so the operation is atomic with
// respect to anything that acquires the same spinlock.
//
#define INTERLOCKED_INCREMENT_LONG(p)             InterlockedIncrement(p)
#define INTERLOCKED_DECREMENT_LONG(p)             InterlockedDecrement(p)
#define INTERLOCKED_ADD_STATISTICS(p, v, l)       ExInterlockedAddLargeStatistic(p, v)

#define INTERLOCKED_INCREMENT_LONG_DPC(p,l)       InterlockedIncrement(p)
#define INTERLOCKED_DECREMENT_LONG_DPC(p,l)       InterlockedDecrement(p)
#ifdef  NT40
#define INTERLOCKED_ADD_ULONG(p, v, l)            ExInterlockedExchangeAdd(p, v)
#else
#define INTERLOCKED_ADD_ULONG(p, v, l)            ExInterlockedAddUlong(p, v, &(l)->SpinLock)
#endif
#define INTERLOCKED_ADD_ULONG_DPC(p, v, l)        ExInterlockedAddUlong(p, v, l)
#define INTERLOCKED_ADD_LARGE_INTGR(p, v, l)      ExInterlockedAddLargeInteger(p, v, &(l)->SpinLock)
#define INTERLOCKED_ADD_LARGE_INTGR_DPC(p, v, l)  ExInterlockedAddLargeInteger(p, v, &(l)->SpinLock)

#endif  // _INTRLCKD_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\server\intrlckd.c ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	intrlckd.c

Abstract:

	This module contains the routines that should have been in the EX package.
	This manipulates inter-locked operations on flags and such.

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	5 Sep 1992		Initial Version

Notes:	Tab stop: 4
--*/

#define	FILENUM	FILE_INTRLCKD

#include <afp.h>


/***	AfpInterlockedSetDword
 *
 *	Set specified bits using the spin-lock to provide an interlocked operation.
 */
VOID FASTCALL
AfpInterlockedSetDword(
	IN	PDWORD		pSrc,
	IN	DWORD		Mask,
	IN	PAFP_SPIN_LOCK	pSpinLock
)
{
	KIRQL	OldIrql;

	ACQUIRE_SPIN_LOCK(pSpinLock, &OldIrql);

	*pSrc |= Mask;

	RELEASE_SPIN_LOCK(pSpinLock, OldIrql);
}



/***	AfpInterlockedClearDword
 *
 *	Clear specified bits using the spin-lock to provide an
 *	interlocked operation.
 */
VOID FASTCALL
AfpInterlockedClearDword(
	IN	PDWORD		pSrc,
	IN	DWORD		Mask,
	IN	PAFP_SPIN_LOCK	pSpinLock
)
{
	KIRQL	OldIrql;

	ACQUIRE_SPIN_LOCK(pSpinLock, &OldIrql);

	*pSrc &= ~Mask;

	RELEASE_SPIN_LOCK(pSpinLock, OldIrql);
}



/***	AfpInterlockedSetNClearDword
 *
 *	Set and Clear specified bits using the spin-lock to provide an
 *	interlocked operation.
 */
VOID FASTCALL
AfpInterlockedSetNClearDword(
	IN	PDWORD		pSrc,
	IN	DWORD		SetMask,
	IN	DWORD		ClrMask,
	IN	PAFP_SPIN_LOCK	pSpinLock
)
{
	KIRQL	OldIrql;

	ACQUIRE_SPIN_LOCK(pSpinLock, &OldIrql);

	*pSrc |= SetMask;
	*pSrc &= ~ClrMask;

	RELEASE_SPIN_LOCK(pSpinLock, OldIrql);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\server\iopool.h ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	iopool.h

Abstract:

	This module contains the IO pool management stuff.

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	25 Feb 1994		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef _IOPOOL_

#define	_IOPOOL_

#define	DWORDSIZEBLOCK(Size)		(((Size) + sizeof(DWORD) - 1) & ~(sizeof(DWORD)-1))
#define	LONGLONGSIZEBLOCK(Size)		((Size) + (sizeof(LONGLONG) - (Size)%(sizeof(LONGLONG))))
#define	PAGED_BLOCK_SIGNATURE		*(PDWORD)"PAGD"
#define	NONPAGED_BLOCK_SIGNATURE	*(PDWORD)"NPGD"

/* MSKK hideyukn, Our Nls table is larger than 0x20000, 07/05/95 */
// used for debug builds only: bumped up to 0x200000 (note one more 0)
#define	MAXIMUM_ALLOC_SIZE			0x200000			// For sanity checking

typedef	struct
{
	unsigned	tg_Size:20;
	unsigned	tg_Flags:4;
	unsigned	tg_Tag:8;
} TAG, *PTAG;

#define	MAX_POOL_AGE		6
#define	POOL_AGE_TIME		15
#define	POOL_ALLOC_SIZE		(0x2000) - POOL_OVERHEAD
#define	NUM_BUFS_IN_POOL	3

#define	POOL_ALLOC_3		ASP_QUANTUM
#define	POOL_ALLOC_2		1600
#define	POOL_ALLOC_1		512
#define	LOCKS_BUF_SPACE		(POOL_ALLOC_SIZE - sizeof(IOPOOL) -				\
							 POOL_ALLOC_1 - POOL_ALLOC_2 - POOL_ALLOC_3	-	\
							 (NUM_BUFS_IN_POOL * sizeof(IOPOOL_HDR)))

#define IO_POOL_NOT_IN_USE  0
#define IO_POOL_IN_USE      1
#define IO_POOL_HUGE_BUFFER 2

#define	NUM_LOCKS_IN_POOL	((LOCKS_BUF_SPACE)/(sizeof(IOPOOL_HDR) + sizeof(FORKLOCK)))

// The pool is structured as a set of 1 each of POOL_ALLOC_x buffers linked in
// ascending order of sizes. The balance of the POOL_ALLOC_SIZE is divided into
// a number of fork-lock structures. The layout is as follows:
//
//			+---------------------+
//			|  IoPool Structure   |----------+
//			|                     |--+       |
//			+---------------------+  |       |
//		 +--|    IoPool Hdr       |<-+       |
//		 |  +---------------------+          |
//		 |  |                     |          |
//		 |  .      Buffer 1       .          |
//		 |  |                     |          |
//		 |  +---------------------+          |
//		 +->|    IoPool Hdr       |--+       |
//		    +---------------------+  |       |
//		    |                     |  |       |
//		    .      Buffer 2       .  |       |
//		    |                     |  |       |
//		    +---------------------+  |       |
//	   |||--|    IoPool Hdr       |<-+       |
//			+---------------------+          |
//			|                     |          |
//			.      Buffer 3       .          |
//			|                     |          |
//			+---------------------+          |
//		 +--|    IoPool Hdr       |<---------+
//		 |  +---------------------+
//		 |  |                     |
//		 .  .      ForkLock1      .
//		 .  |                     |
//		 |  +---------------------+
//		 +->|    IoPool Hdr       |--|||
//		    +---------------------+
//		    |                     |
//		    .      ForkLockN      .
//		    |                     |
//		    +---------------------+
//
//
#if DBG
#define	POOLHDR_SIGNATURE			*(PDWORD)"PLH"
#define	VALID_PLH(pPoolHdr)			(((pPoolHdr) != NULL) && \
									 ((pPoolHdr)->Signature == POOLHDR_SIGNATURE))
#else
#define	VALID_PLH(pPoolHdr)			((pPoolHdr) != NULL)
#endif

typedef	struct _IoPoolHdr
{
#if	DBG
	DWORD				Signature;
	DWORD				IoPoolHdr_Align1;
#endif
	union
	{
		struct _IoPoolHdr *	iph_Next;    // Valid when it is on the free list
		struct _IoPool	  *	iph_pPool;   // Valid when it is allocated. Used
										 // to put it back on the free list
	};
	DWORD				IoPoolHdr_Align2;
	TAG					iph_Tag;	 	// Keep it at end since it is accessed
										 // by moving back from the free ptr
} IOPOOL_HDR, *PIOPOOL_HDR;

#if DBG
#define	IOPOOL_SIGNATURE			*(PDWORD)"IOP"
#define	VALID_IOP(pPool)			(((pPool) != NULL) && \
									 ((pPool)->Signature == IOPOOL_SIGNATURE))
#else
#define	VALID_IOP(pPool)			((pPool) != NULL)
#endif

typedef	struct _IoPool
{
#if	DBG
	DWORD				Signature;
	DWORD				QuadAlign1;
#endif
	struct _IoPool *	iop_Next;
	struct _IoPool **	iop_Prev;
	struct _IoPoolHdr *	iop_FreeBufHead;	// The list of POOL headers start here
	struct _IoPoolHdr *	iop_FreeLockHead;	// The list of fork-locks start here
	DWORD				QuadAlign2;
	USHORT				iop_Age;			// Used to age out pool
	BYTE				iop_NumFreeBufs;	// Number of free IO buffer
	BYTE				iop_NumFreeLocks;	// Number of free fork locks
} IOPOOL, *PIOPOOL;

LOCAL	PIOPOOL		afpIoPoolHead = { NULL };
LOCAL	AFP_SPIN_LOCK	afpIoPoolLock = { 0 };
LOCAL	USHORT		afpPoolAllocSizes[NUM_BUFS_IN_POOL] =
					{
						POOL_ALLOC_1,
						POOL_ALLOC_2,
						POOL_ALLOC_3
					};

LOCAL AFPSTATUS FASTCALL
afpIoPoolAge(
	IN	PVOID	pContext
);

#endif	// _IOPOOL_


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\server\idindex.c ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	idindex.c

Abstract:

	This module contains the id index manipulation routines.

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	25 Apr 1992	Initial Version
	24 Feb 1993 SueA	Fix AfpRenameDfEntry and AfpMoveDfEntry to invalidate
						the entire pathcache if the object of the move/rename
						is a directory that has children.  This is faster
						than having to either search the path cache for
						paths that have the moved/renamed dir path as a prefix,
						or having to walk down the subtree below that dir
						and invalidate the cache for each item there.
	05 Oct 1993 JameelH	Performance Changes. Merge cached afpinfo into the
						idindex structure. Make both the ANSI and the UNICODE
						names part of idindex. Added EnumCache for improving
						enumerate perf.
	05 Jun 1995 JameelH	Remove the ANSI name from DFE. Also keep the files
						in the directory in multiple hash buckets instead
						of a single one. The hash buckets are also
						seperated into files and directories for faster
						lookup. The notify filtering is now moved to completion
						time and made over-all optimizations related to iddb.

Notes:		Tab stop: 4

	Directories and files that the AFP server has enumerated have AFP ids
	associated with them. These ids are DWORD and start with 1 (0 is invalid).
	Id 1 is reserved for the 'parent of the volume root' directory.  Id 2 is
	reserved for the volume root directory.  Id 3 is reserved for the Network
	Trash directory.  Volumes that have no Network Trash will not use Id 3.

	These ids are per-volume and a database of ids are kept in memory in the
	form of a sibling tree which mirrors the part of the disk that the AFP
	server knows about (those files and dirs which have at some point been
	enumerated by a mac client).  An index is also maintained for this database
	which is in the form of a sorted hashed index.  The overflow hash links are
	sorted by AFP id in descending order.  This is based on the idea that the
	most recently created items will be accessed most frequently (at least
	for writable volumes).

--*/

#define IDINDEX_LOCALS
#define _IDDB_GLOBALS_
#define	FILENUM	FILE_IDINDEX

#include <afp.h>
#include <scavengr.h>
#include <fdparm.h>
#include <pathmap.h>
#include <afpinfo.h>
#include <access.h>	// for AfpWorldId

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, AfpDfeInit)
#pragma alloc_text(PAGE, AfpDfeDeInit)
#pragma alloc_text(PAGE, AfpFindDfEntryById)
#pragma alloc_text(PAGE, AfpFindEntryByUnicodeName)
#pragma alloc_text(PAGE, afpFindEntryByNtName)
#pragma alloc_text(PAGE, AfpAddDfEntry)
#pragma alloc_text(PAGE, AfpRenameDfEntry)
#pragma alloc_text(PAGE, AfpMoveDfEntry)
#pragma alloc_text(PAGE, AfpDeleteDfEntry)
#pragma alloc_text(PAGE, AfpExchangeIdEntries)
#pragma alloc_text(PAGE, AfpPruneIdDb)
#pragma alloc_text(PAGE, AfpEnumerate)
#pragma alloc_text(PAGE, AfpCatSearch)
#pragma alloc_text(PAGE, afpPackSearchParms)
#pragma alloc_text(PAGE, AfpSetDFFileFlags)
#pragma alloc_text(PAGE, AfpCacheParentModTime)
#pragma alloc_text(PAGE, afpAllocDfe)
#pragma alloc_text(PAGE, afpFreeDfe)
#pragma alloc_text(PAGE, AfpFreeIdIndexTables)
#pragma alloc_text(PAGE, AfpInitIdDb)
#pragma alloc_text(PAGE, afpSeedIdDb)
#pragma alloc_text(PAGE, afpDfeBlockAge)
#pragma alloc_text(PAGE, afpRenameInvalidWin32Name)
#ifdef	AGE_DFES
#pragma alloc_text( PAGE, AfpAgeDfEntries)
#endif
#if DBG
#pragma alloc_text( PAGE, afpDumpDfeTree)
#pragma alloc_text( PAGE, afpDisplayDfe)
#endif
#endif

/***	AfpDfeInit
 *
 *	Initialize the Swmr for Dfe Block package and start the aging scavenger for it.
 */
NTSTATUS
AfpDfeInit(
	VOID
)
{
	NTSTATUS	Status;

	// Initialize the DfeBlock Swmr
	AfpSwmrInitSwmr(&afpDfeBlockLock);

#if DBG
	AfpScavengerScheduleEvent(afpDumpDfeTree,
							  NULL,
							  2,
							  True);
#endif


	// Age out file and dir DFEs differently and seperately
	Status = AfpScavengerScheduleEvent(afpDfeBlockAge,
										afpDirDfeFreeBlockHead,
										DIR_BLOCK_AGE_TIME,
										True);
	if (NT_SUCCESS(Status))
	{
		// Age out file and dir DFEs differently and seperately
		Status = AfpScavengerScheduleEvent(afpDfeBlockAge,
										   afpFileDfeFreeBlockHead,
										   FILE_BLOCK_AGE_TIME,
										   True);
	}

	return Status;
}




/***	AfpDfeDeInit
 *
 *	Free any Dfe Blocks that have not yet been aged out.
 */
VOID
AfpDfeDeInit(
	VOID
)
{
	PDFEBLOCK	pDfb;
	int			i;

	ASSERT (afpDfeAllocCount == 0);

	for (i = 0; i < MAX_BLOCK_TYPE; i++)
	{
	    ASSERT (afpDirDfePartialBlockHead[i] == NULL);
	    ASSERT (afpDirDfeUsedBlockHead[i] == NULL);

		for (pDfb = afpDirDfeFreeBlockHead[i];
			 pDfb != NULL;
			 NOTHING)
		{
			PDFEBLOCK	pFree;

			ASSERT(pDfb->dfb_NumFree == afpDfeNumDirBlocks[i]);
			pFree = pDfb;
			pDfb = pDfb->dfb_Next;
			AfpFreeVirtualMemoryPage(pFree);
#if	DBG
			afpDfbAllocCount --;
#endif
		}

	    ASSERT (afpFileDfePartialBlockHead[i] == NULL);
	    ASSERT (afpFileDfeUsedBlockHead[i] == NULL);
		for (pDfb = afpFileDfeFreeBlockHead[i];
			 pDfb != NULL;)
		{
			PDFEBLOCK	pFree;

			ASSERT(pDfb->dfb_NumFree == afpDfeNumFileBlocks[i]);
			pFree = pDfb;
			pDfb = pDfb->dfb_Next;
			AfpFreeVirtualMemoryPage(pFree);
#if	DBG
			afpDfbAllocCount --;
#endif
		}
	}

	ASSERT (afpDfbAllocCount == 0);
}


/***	AfpFindDfEntryById
 *
 *	Search for an entity based on its AFP Id. returns a pointer to the entry
 *	if found, else null.
 *
 *	Callable from within the Fsp only. The caller should take Swmr lock for
 *	READ.
 *
 *	LOCKS_ASSUMED: vds_idDbAccessLock (SWMR, Shared)
 */
PDFENTRY
AfpFindDfEntryById(
	IN	PVOLDESC	pVolDesc,
	IN	DWORD		Id,
	IN	DWORD		EntityMask
)
{
	PDFENTRY	pDfEntry;
    struct _DirFileEntry    **DfeDirBucketStart;
    struct _DirFileEntry    **DfeFileBucketStart;
	BOOLEAN		Found = False;

	PAGED_CODE( );

#ifdef	PROFILING
	INTERLOCKED_INCREMENT_LONG(&AfpServerProfile->perf_NumDfeLookupById);
#endif

	if (Id == AFP_ID_ROOT)
	{
		Found = True;
		pDfEntry = pVolDesc->vds_pDfeRoot;
		ASSERT (VALID_DFE(pDfEntry));

#ifdef	PROFILING
		INTERLOCKED_INCREMENT_LONG(&AfpServerProfile->perf_DfeCacheHits);
#endif
	}
	else
	{
		pDfEntry = pVolDesc->vds_pDfeCache[HASH_CACHE_ID(Id)];
		if ((pDfEntry != NULL) && (pDfEntry->dfe_AfpId == Id))
		{
			Found = True;
			ASSERT (VALID_DFE(pDfEntry));
#ifdef	PROFILING
			INTERLOCKED_INCREMENT_LONG(&AfpServerProfile->perf_DfeCacheHits);
#endif
		}
		else
		{
			BOOLEAN	retry = False;

#ifdef	PROFILING
			INTERLOCKED_INCREMENT_LONG(&AfpServerProfile->perf_DfeCacheMisses);
#endif
            DfeDirBucketStart = pVolDesc->vds_pDfeDirBucketStart;
            DfeFileBucketStart = pVolDesc->vds_pDfeFileBucketStart;

			if ((EntityMask == DFE_ANY) || (EntityMask == DFE_DIR))
			{
				if (EntityMask == DFE_ANY)
					retry = True;
				pDfEntry = DfeDirBucketStart[HASH_DIR_ID(Id,pVolDesc)];
			}
			else
			{
				pDfEntry = DfeFileBucketStart[HASH_FILE_ID(Id,pVolDesc)];
			}

			do
			{
				for (NOTHING;
					 (pDfEntry != NULL) && (pDfEntry->dfe_AfpId >= Id);
					 pDfEntry = pDfEntry->dfe_NextOverflow)
				{
#ifdef	PROFILING
					INTERLOCKED_INCREMENT_LONG(&AfpServerProfile->perf_DfeDepthTraversed);
#endif
					ASSERT(VALID_DFE(pDfEntry));

					if (pDfEntry->dfe_AfpId < Id)
					{
						break;		// Did not find
					}

					if (pDfEntry->dfe_AfpId == Id)
					{
						pVolDesc->vds_pDfeCache[HASH_CACHE_ID(Id)] = pDfEntry;
						Found = True;
						break;
					}
				}

				if (Found)
				{
					break;
				}

				if (retry)
				{
					ASSERT(EntityMask == DFE_ANY);
					pDfEntry = DfeFileBucketStart[HASH_FILE_ID(Id,pVolDesc)];
				}
				retry ^= True;

			} while (!retry);
		}
	}

	if (Found)
	{
		afpValidateDFEType(pDfEntry, EntityMask);
		if (pDfEntry != NULL)
		{
			afpUpdateDfeAccessTime(pVolDesc, pDfEntry);
		}
	}
	else
	{
		DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_INFO,
				("AfpFindDfEntryById: Not found for id %lx, entity %d\n",
				Id, EntityMask));
		pDfEntry = NULL;
	}

	return pDfEntry;
}


/***	AfpFindEntryByUnicodeName
 *
 *	Search for an entity based on a Unicode name and its parent dfentry.
 *	Returns a pointer to the entry if found, else null.  If lookup is by
 *	longname, we just need to search the parent's children's names as
 *	stored in the database.  If lookup is by shortname, we first assume
 *	that longname == shortname.  If we don't find it in the database, we
 *	must query the filesystem for the longname, then search again.
 *
 *	Callable from within the Fsp only. The caller should take Swmr lock for
 *	READ.
 *
 *	LOCKS_ASSUMED: vds_idDbAccessLock (SWMR, Shared)
 */
PDFENTRY
AfpFindEntryByUnicodeName(
	IN	PVOLDESC		pVolDesc,
	IN	PUNICODE_STRING	pName,
	IN	DWORD			PathType,	// short or long name
	IN	PDFENTRY		pDfeParent,	// pointer to parent DFENTRY
	IN	DWORD			EntityMask	// find a file,dir or either
)
{
	PDFENTRY		pDfEntry;

	PAGED_CODE( );

#ifdef	PROFILING
	INTERLOCKED_INCREMENT_LONG(&AfpServerProfile->perf_NumDfeLookupByName);
#endif
	do
	{
		afpFindDFEByUnicodeNameInSiblingList(pVolDesc,
											 pDfeParent,
											 pName,
											 &pDfEntry,
											 EntityMask);

		if ((pDfEntry == NULL) && (PathType == AFP_SHORTNAME))
		{
			AFPSTATUS		Status;
			FILESYSHANDLE	hDir;
			UNICODE_STRING	HostPath;
			UNICODE_STRING	ULongName;
			WCHAR			LongNameBuf[AFP_LONGNAME_LEN+1];

			// AFP does not allow use of the volume root shortname (IA p.13-13)
			if (DFE_IS_PARENT_OF_ROOT(pDfeParent))
			{
				pDfEntry = NULL;
				break;
			}

			AfpSetEmptyUnicodeString(&HostPath, 0, NULL);

			if (!DFE_IS_ROOT(pDfeParent))
			{
				// Get the volume relative path of the parent dir
				if (!NT_SUCCESS(AfpHostPathFromDFEntry(pDfeParent,
													   0,
													   &HostPath)))
				{
					pDfEntry = NULL;
					break;
				}
			}

			// Open the parent directory
			hDir.fsh_FileHandle = NULL;
			Status = AfpIoOpen(&pVolDesc->vds_hRootDir,
								AFP_STREAM_DATA,
								FILEIO_OPEN_DIR,
								DFE_IS_ROOT(pDfeParent) ?
										&UNullString : &HostPath,
								FILEIO_ACCESS_READ,
								FILEIO_DENY_NONE,
								False,
								&hDir);

			if (HostPath.Buffer != NULL)
				AfpFreeMemory(HostPath.Buffer);

			if (!NT_SUCCESS(Status))
			{
				pDfEntry = NULL;
				break;
			}

			// get the LongName associated with this file/dir
			AfpSetEmptyUnicodeString(&ULongName, sizeof(LongNameBuf), LongNameBuf);
			Status = AfpIoQueryLongName(&hDir, pName, &ULongName);
			AfpIoClose(&hDir);
			if (!NT_SUCCESS(Status) ||
				EQUAL_UNICODE_STRING(&ULongName, pName, True))
			{
				pDfEntry = NULL;
				break;
			}

			afpFindDFEByUnicodeNameInSiblingList(pVolDesc,
												 pDfeParent,
												 &ULongName,
												 &pDfEntry,
												 EntityMask);
		} // end else if SHORTNAME
	} while (False);

	return pDfEntry;
}


/***	afpGetNextId
 *
 *	Get the next assignable id for a file/directory. This is a seperate
 *	routine so that AfpAddDfEntry can be paged. Only update the dirty bit
 *	and LastModified time if no new id is assigned.
 *
 *	LOCKS:	vds_VolLock (SPIN)
 */
LOCAL DWORD FASTCALL
afpGetNextId(
	IN	PVOLDESC	pVolDesc
)
{
	KIRQL	OldIrql;
	DWORD	afpId;

	ACQUIRE_SPIN_LOCK(&pVolDesc->vds_VolLock, &OldIrql);

	if (pVolDesc->vds_LastId == AFP_MAX_DIRID)
	{
		// errorlog the case where the assigned Id has wrapped around.
		// call product suppport and have them tell you to copy
		// all the files from one volume onto another volume FROM A MAC
		RELEASE_SPIN_LOCK(&pVolDesc->vds_VolLock, OldIrql);
		AFPLOG_ERROR(AFPSRVMSG_MAX_DIRID,
					 STATUS_UNSUCCESSFUL,
					 NULL,
					 0,
					 &pVolDesc->vds_Name);
		return 0;
	}

	afpId = ++ pVolDesc->vds_LastId;
	pVolDesc->vds_Flags |= VOLUME_IDDBHDR_DIRTY;

	RELEASE_SPIN_LOCK(&pVolDesc->vds_VolLock, OldIrql);

	if (IS_VOLUME_NTFS(pVolDesc))
	{
		AfpVolumeSetModifiedTime(pVolDesc);
	}

	return afpId;
}


/***	afpFindEntryByNtName
 *
 *	Search for an entity based on a Nt name (which could include names > 31
 *  chars or shortnames) and its parent dfentry.
 *	Returns a pointer to the entry if found, else null.
 *
 *	If we don't find it in the database, we query the filesystem for the
 *  longname (in the AFP sense), then search again based on this name.
 *
 *	Callable from within the Fsp only. The caller should take Swmr lock for
 *	READ.
 *
 *	It has been determined that:
 *	a, The name is longer than 31 chars	OR
 *	b, The name lookup in the IdDb has failed.
 *
 *	LOCKS_ASSUMED: vds_idDbAccessLock (SWMR, Exclusive)
 */
PDFENTRY
afpFindEntryByNtName(
	IN	PVOLDESC			pVolDesc,
	IN	PUNICODE_STRING		pName,
	IN	PDFENTRY			pParentDfe	// pointer to parent DFENTRY
)
{
	AFPSTATUS		Status;
	WCHAR			wbuf[AFP_LONGNAME_LEN+1];
	WCHAR			HostPathBuf[BIG_PATH_LEN];
	UNICODE_STRING	uLongName;
	UNICODE_STRING	HostPath;
	FILESYSHANDLE	hDir;
	PDFENTRY		pDfEntry = NULL;

	PAGED_CODE( );

	ASSERT(pParentDfe != NULL);
	ASSERT(pName->Length > 0);
	do
	{
		AfpSetEmptyUnicodeString(&HostPath, sizeof(HostPathBuf), HostPathBuf);

		if (!DFE_IS_ROOT(pParentDfe))
		{
			// Get the volume relative path of the parent dir
			if (!NT_SUCCESS(AfpHostPathFromDFEntry(pParentDfe,
												   0,
												   &HostPath)))
			{
				pDfEntry = NULL;
				break;
			}

		}

		// Open the parent directory
		// NOTE: We CANNOT use the vds_hRootDir handle to enumerate for this
		// purpose.  We MUST open another handle to the root dir because
		// the FileName parameter will be ignored on all subsequent enumerates
		// on a handle.  Therefore we must open a new handle for each
		// enumerate that we want to do for any directory.  When the handle
		// is closed, the 'findfirst' will be cancelled, otherwise we would
		// always be enumerating on the wrong filename!
		hDir.fsh_FileHandle = NULL;
		Status = AfpIoOpen(&pVolDesc->vds_hRootDir,
							AFP_STREAM_DATA,
							FILEIO_OPEN_DIR,
							DFE_IS_ROOT(pParentDfe) ?
								&UNullString : &HostPath,
							FILEIO_ACCESS_NONE,
							FILEIO_DENY_NONE,
							False,
							&hDir);

		if (!NT_SUCCESS(Status))
		{
			pDfEntry = NULL;
			break;
		}

		// get the 'AFP longname' associated with this file/dir.  If the
		// pName is longer than 31 chars, we will know it by its shortname,
		// so query for it's shortname (i.e. the 'AFP longname' we know it
		// by).  If the name is shorter than 31 chars, since we know we
		// didn't find it in our database, then the pName must be the ntfs
		// shortname.  Again, we need to Find the 'AFP longname' that we
		// know it by.
		AfpSetEmptyUnicodeString(&uLongName, sizeof(wbuf), wbuf);
		Status = AfpIoQueryLongName(&hDir, pName, &uLongName);
		AfpIoClose(&hDir);


		if (!NT_SUCCESS(Status) ||
			EQUAL_UNICODE_STRING(&uLongName, pName, True))
		{
			pDfEntry = NULL;

			if ((Status == STATUS_NO_MORE_FILES) ||
				(Status == STATUS_NO_SUCH_FILE))
			{
				// This file must have been deleted.  Since we cannot
				// identify it in our database by the NT name that was
				// passed in, we must reenumerate the parent directory.
				// Anything we don't see on disk that we still have in
				// our database must have been deleted from disk, so get
				// rid of it in the database as well.

				// We must open a DIFFERENT handle to the parent dir since
				// we had already done an enumerate using that handle and
				// searching for a different name.
				hDir.fsh_FileHandle = NULL;
				Status = AfpIoOpen(&pVolDesc->vds_hRootDir,
									AFP_STREAM_DATA,
									FILEIO_OPEN_DIR,
									DFE_IS_ROOT(pParentDfe) ?
										&UNullString : &HostPath,
									FILEIO_ACCESS_NONE,
									FILEIO_DENY_NONE,
									False,
									&hDir);

				if (NT_SUCCESS(Status))
				{
					AfpCacheDirectoryTree(pVolDesc,
										  pParentDfe,
										  REENUMERATE,
										  &hDir,
										  NULL);
					AfpIoClose(&hDir);
				}
			}
			break;
		}

		afpFindDFEByUnicodeNameInSiblingList(pVolDesc,
											 pParentDfe,
											 &uLongName,
											 &pDfEntry,
											 DFE_ANY);
	} while (False);

	if ((HostPath.Buffer != NULL) && (HostPath.Buffer != HostPathBuf))
		AfpFreeMemory(HostPath.Buffer);

	return pDfEntry;
}


/***	afpFindEntryByNtPath
 *
 *	Given a NT path relative to the volume root (which may contain names
 *  > 31 chars or shortnames), look up the entry in the idindex DB.
 *  If the Change Action is FILE_ACTION_ADDED, we want to lookup the entry
 *  for the item's parent dir.  Point the pParent and pTail strings into
 *  the appropriate places in pPath.
 *
 *  Called by the ProcessChangeNotify code when caching information in the DFE.
 *
 *	LOCKS:	vds_VolLock (SPIN)
 */
PDFENTRY
afpFindEntryByNtPath(
	IN	PVOLDESC			pVolDesc,
	IN  DWORD				ChangeAction,	// if ADDED then lookup parent DFE
	IN	PUNICODE_STRING		pPath,
	OUT	PUNICODE_STRING 	pParent,
	OUT	PUNICODE_STRING 	pTail
)
{
	PDFENTRY		pParentDfe, pDfEntry;
	PWSTR			CurPtr, EndPtr;
	USHORT 			Len;
	BOOLEAN			NewComp;

	DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_INFO,
			("afpFindEntryByNtPath: Entered for %Z\n", pPath));

	pParentDfe = pVolDesc->vds_pDfeRoot;
	ASSERT(pParentDfe != NULL);
	ASSERT(pPath->Length >= sizeof(WCHAR));
	ASSERT(pPath->Buffer[0] != L'\\');

	// Start off with Parent and Tail as both empty and modify as we go.
	AfpSetEmptyUnicodeString(pTail, 0, NULL);
#if DBG
	AfpSetEmptyUnicodeString(pParent, 0, NULL);	// Need it for the DBGPRINT down below
#endif

	CurPtr = pPath->Buffer;
	EndPtr = (PWSTR)((PBYTE)CurPtr + pPath->Length);
	NewComp = True;
	for (Len = 0; CurPtr < EndPtr; CurPtr++)
	{
		if (NewComp)
		{
			DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_INFO,
					("afpFindEntryByNtPath: Parent DFE %lx, Old Parent %Z\n",
					pParentDfe, pParent));

			// The previous char seen was a path separator
			NewComp = False;
			*pParent = *pTail;
			pParent->Length =
			pParent->MaximumLength = Len;
			pTail->Length =
			pTail->MaximumLength = (USHORT)((PBYTE)EndPtr - (PBYTE)CurPtr);
			pTail->Buffer = CurPtr;
			Len = 0;

			DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_INFO,
					("afpFindEntryByNtPath: Current Parent %Z, tail %Z\n",
					pParent, pTail));

			if (pParent->Length > 0)
			{
				// Map this name to a DFE. Do the most common case here
				// If the name is <= AFP_LONGNAME_NAME, then check the
				// current parent's children, else go the long route.
				pDfEntry = NULL;
				//if (pParent->Length/sizeof(WCHAR) <= AFP_LONGNAME_LEN)
				if ((RtlUnicodeStringToAnsiSize(pParent)-1) <= AFP_LONGNAME_LEN)
				{
					DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_INFO,
							("afpFindEntryByNtPath: Looking for %Z in parent DFE %lx\n",
							pParent, pParentDfe));
					afpFindDFEByUnicodeNameInSiblingList(pVolDesc,
														 pParentDfe,
														 pParent,
														 &pDfEntry,
														 DFE_DIR);
				}
				if (pDfEntry == NULL)
				{
					pDfEntry = afpFindEntryByNtName(pVolDesc,
													pParent,
													pParentDfe);
				}
				if ((pParentDfe = pDfEntry) == NULL)
				{
					break;
				}
			}
		}

		if (*CurPtr == L'\\')
		{
			// We have encountered a path terminator
			NewComp = True;
		}
		else Len += sizeof(WCHAR);
	}

	// At this point we have pParentDfe & pParent pointing to the parent directory
	// and pTail pointing to the last component. If it is an add operation, we are
	// set, else map the last component to its Dfe
	if ((ChangeAction != FILE_ACTION_ADDED) && (pParentDfe != NULL))
	{
		pDfEntry = NULL;
		//if (pTail->Length/sizeof(WCHAR) <= AFP_LONGNAME_LEN)
		if ((RtlUnicodeStringToAnsiSize(pTail)-1) <= AFP_LONGNAME_LEN)
		{
			afpFindDFEByUnicodeNameInSiblingList(pVolDesc,
												 pParentDfe,
												 pTail,
												 &pDfEntry,
												 DFE_ANY);
		}

		if (pDfEntry == NULL)
		{
			BOOLEAN KeepLooking = True;

			//
			// We couldn't find this item in the database by the name
			// given, which means that we either know it by a different
			// name or it has been deleted, renamed or moved since.
			// If this is a modify change notify, then search for a
			// corresponding DELETED or RENAMED_OLD_NAME change that might
			// be in the changelist by this same name (so can do a fast
			// case sensitive search).
			//
			// This will speed up the case (avoid disk enumerates) where
			// there are a bunch of changes that we are trying to process
			// for an item, but it has since been deleted.  It will prevent
			// us from re-enumerating the disk looking for the longname
			// and then also trying to prune out dead wood with a call to
			// AfpCacheDirectoryTree(REENUMERATE).
			//
			// This will pimp the case where a PC has made a change using
			// a different name than we know it by (and not deleted or
			// renamed the thing), but this case takes a back seat to the
			// other case that could happen when a mac app does a File-Save
			// doing a lot of writes followed by renames (or ExchangeFiles)
			// and deletes.
			//

			if ( (ChangeAction == FILE_ACTION_MODIFIED)  ||
				 (ChangeAction == FILE_ACTION_MODIFIED_STREAM) )
			{
				KIRQL			OldIrql;
				PLIST_ENTRY		pLink = &pVolDesc->vds_ChangeNotifyLookAhead;
				PVOL_NOTIFY 	pVolNotify;
				UNICODE_STRING	UName;
				PFILE_NOTIFY_INFORMATION	pFNInfo;

				ACQUIRE_SPIN_LOCK(&pVolDesc->vds_VolLock, &OldIrql);

				while (pLink->Flink != &pVolDesc->vds_ChangeNotifyLookAhead)
				{
					pLink = pLink->Flink;
					pVolNotify = CONTAINING_RECORD(pLink, VOL_NOTIFY, vn_DelRenLink);
					pFNInfo = (PFILE_NOTIFY_INFORMATION) (pVolNotify + 1);

					AfpInitUnicodeStringWithNonNullTerm(&UName,
														(USHORT)pFNInfo->FileNameLength,
														pFNInfo->FileName);

					if (EQUAL_UNICODE_STRING_CS(pPath, &UName))
					{
						KeepLooking = False;
						DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_WARN,
								("afpFindEntryByNtPath: Found later REMOVE for %Z, Ignoring change\n", pPath));
						break;
					}
				}

				RELEASE_SPIN_LOCK(&pVolDesc->vds_VolLock, OldIrql);
			}

			if (KeepLooking)
			{
				pDfEntry = afpFindEntryByNtName(pVolDesc,
												pTail,
												pParentDfe);
			}
		}
		pParentDfe = pDfEntry;
	}

	// pParent is pointing to the parent component, we need the entire volume
	// relative path. Make it so. Do not bother if pParentDfe is NULL. Make
	// sure that we handle the case where there is only one component
	if (pParentDfe != NULL)
	{
		*pParent = *pPath;
		pParent->Length = pPath->Length - pTail->Length;
		if (pPath->Length > pTail->Length)
			pParent->Length -= sizeof(L'\\');
	}

	return pParentDfe;
}


/***	AfpAddDfEntry
 *
 *	Triggerred by the creation of a file/directory or discovery of a file/dir
 *	from an enumerate or pathmapping operation. If no AFP Id is supplied, a new
 *	id is assigned to this entity.  If an AFP Id is supplied (we know the Id
 *	is within our current range and does not collide with any other entry), then
 *	we use that Id.  An entry is created and linked in to the database and hash
 *	table. If this is an NTFS volume, the Id database header is marked
 *	dirty if we assigned a new AFP Id, and the volume modification time is
 *	updated.  The hash table overflow entries are sorted in descending AFP Id
 *	order.
 *
 *	Callable from within the Fsp only. The caller should take Swmr lock for
 *	WRITE.
 *
 *	LOCKS_ASSUMED: vds_idDbAccessLock (SWMR, Exclusive)
 */
PDFENTRY
AfpAddDfEntry(
	IN	PVOLDESC			pVolDesc,
	IN	PDFENTRY			pDfeParent,
	IN	PUNICODE_STRING 	pUName,
	IN	BOOLEAN				fDirectory,
	IN	DWORD				AfpId		OPTIONAL
)
{
	PDFENTRY	pDfEntry;
	BOOLEAN		fSuccess;

	PAGED_CODE();

	ASSERT(DFE_IS_DIRECTORY(pDfeParent));

	do
	{
		if ((pDfEntry = ALLOC_DFE(USIZE_TO_INDEX(pUName->Length), fDirectory)) == NULL)
		{
			break;
		}

		pDfEntry->dfe_Flags = 0;

		if (!ARGUMENT_PRESENT((ULONG_PTR)AfpId))
			AfpId = afpGetNextId(pVolDesc);

		if (AfpId == 0)
		{
			// errorlog the case where the assigned Id has wrapped around.
			// call product suppport and have them tell you to copy
			// all the files from one volume onto another volume FROM A MAC
			//
			// NOTE:	How about a utility which will re-assign new ids on
			//			a volume after stopping the server ? A whole lot more
			//			palatable idea.
			FREE_DFE(pDfEntry);
			pDfEntry = NULL;
			break;
		}

		pDfEntry->dfe_AfpId = AfpId;

		// Initialize its parent
		pDfEntry->dfe_Parent = pDfeParent;

		// Copy the name
		AfpCopyUnicodeString(&pDfEntry->dfe_UnicodeName,
							 pUName);

		// And hash it
		afpHashUnicodeName(&pDfEntry->dfe_UnicodeName, &pDfEntry->dfe_NameHash);

		pDfEntry->dfe_NextOverflow = NULL;
		pDfEntry->dfe_NextSibling = NULL;

		// Now link this into the hash bucket, sorted in AFP Id descending order
		// and update the cache
		DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_INFO,
				("AfpAddDfEntry: Linking DFE %lx( Id %ld) for %Z into %s bucket %ld\n",
				pDfEntry, pDfEntry->dfe_AfpId, pUName,
				fDirectory ? "Dir" : "File",
				fDirectory ? HASH_DIR_ID(AfpId,pVolDesc) : HASH_FILE_ID(AfpId,pVolDesc)));

		if (fDirectory)
		{
			DFE_SET_DIRECTORY(pDfEntry, pDfeParent->dfe_DirDepth);
		}
		else
		{
			DFE_SET_FILE(pDfEntry);
		}

		afpInsertDFEInHashBucket(pVolDesc, pDfEntry, fDirectory, &fSuccess);
		if (!fSuccess)
		{
			/* Out of id space - bail out */
			FREE_DFE(pDfEntry);
			pDfEntry = NULL;
			break;
		}

		if (fDirectory)
		{
			if ((pDfeParent->dfe_DirOffspring == 0) && !EXCLUSIVE_VOLUME(pVolDesc))
			{
				DWORD requiredLen;

				// check to see if we need to reallocate a bigger notify buffer.
				// The buffer must be large enough to hold a rename
				// notification (which will contain 2 FILE_NOTIFY_INFORMATION
				// structures) for the deepest element in the directory tree.
				requiredLen = (((pDfEntry->dfe_DirDepth + 1) *
							  ((AFP_FILENAME_LEN + 1) * sizeof(WCHAR))) +
							  FIELD_OFFSET(FILE_NOTIFY_INFORMATION, FileName)) * 2 ;

                if (requiredLen > pVolDesc->vds_RequiredNotifyBufLen)
                {
				    pVolDesc->vds_RequiredNotifyBufLen = requiredLen;
                }
			}
			pDfeParent->dfe_DirOffspring ++;
			pDfEntry->dfe_DirOffspring = 0;
			pDfEntry->dfe_FileOffspring = 0;
			pVolDesc->vds_NumDirDfEntries ++;

#ifdef AGE_DFES
			// These fields are relevant to directories only
			pDfEntry->dfe_pDirEntry->de_LastAccessTime = BEGINNING_OF_TIME;
			pDfEntry->dfe_pDirEntry->de_ChildForkOpenCount = 0;
#endif
			ASSERT((FIELD_OFFSET(DIRENTRY, de_ChildFile) -
					FIELD_OFFSET(DIRENTRY, de_ChildDir)) == sizeof(PVOID));

			// Insert it into its sibling chain
			afpInsertDirDFEInSiblingList(pDfeParent, pDfEntry);
		}
		else
		{
			pDfeParent->dfe_FileOffspring ++;
			pDfEntry->dfe_DataLen = 0;
			pDfEntry->dfe_RescLen = 0;
			pVolDesc->vds_NumFileDfEntries ++;

			// Insert it into its sibling chain
			afpInsertFileDFEInSiblingList(pDfeParent, pDfEntry);
		}

	} while (False);

	return pDfEntry;
}


/***	AfpRenameDfEntry
 *
 *	Triggered by a rename of a file/directory.  If the new name is longer than
 *	the current name, the DFEntry is freed and then reallocated to fit the new
 *	name.  A renamed file/dir must retain its original ID.
 *
 *	Callable from within the Fsp only. The caller should take Swmr lock for
 *	WRITE.
 *
 *	LOCKS:	vds_VolLock (SPIN) for updating the IdDb header.
 *	LOCKS_ASSUMED: vds_idDbAccessLock (SWMR, Exclusive)
 *	LOCK_ORDER: VolDesc lock after IdDb Swmr.
 *
 */
PDFENTRY
AfpRenameDfEntry(
	IN	PVOLDESC			pVolDesc,
	IN	PDFENTRY			pDfEntry,
	IN	PUNICODE_STRING		pNewName
)
{
	BOOLEAN		fDirectory;
	PDFENTRY	pNewDfEntry = pDfEntry;
	DWORD		OldIndex, NewIndex;

	PAGED_CODE( );

	ASSERT((pDfEntry != NULL) && (pNewName != NULL) && (pVolDesc != NULL));

	do
	{
		fDirectory = DFE_IS_DIRECTORY(pDfEntry);
		OldIndex = USIZE_TO_INDEX(pDfEntry->dfe_UnicodeName.MaximumLength);
		NewIndex = USIZE_TO_INDEX(pNewName->Length);
		if (OldIndex != NewIndex)
		{
			if ((pNewDfEntry = ALLOC_DFE(NewIndex, fDirectory)) == NULL)
			{
				pNewDfEntry = NULL;
				break;
			}

			// Careful here how the structures are copied
			RtlCopyMemory(pNewDfEntry,
						  pDfEntry,
						  FIELD_OFFSET(DFENTRY, dfe_CopyUpto));

			// Update the cache
			pVolDesc->vds_pDfeCache[HASH_CACHE_ID(pDfEntry->dfe_AfpId)] = pNewDfEntry;

			// fix up the overflow links from the hash table
			AfpUnlinkDouble(pDfEntry,
							dfe_NextOverflow,
							dfe_PrevOverflow);
			if (pDfEntry->dfe_NextOverflow != NULL)
			{
				AfpInsertDoubleBefore(pNewDfEntry,
									  pDfEntry->dfe_NextOverflow,
									  dfe_NextOverflow,
									  dfe_PrevOverflow);
			}
			else
			{
				*(pDfEntry->dfe_PrevOverflow) = pNewDfEntry;
				pNewDfEntry->dfe_NextOverflow = NULL;
			}

			// now fix any of this thing's children's parent pointers.
			if (fDirectory)
			{
				PDFENTRY	pTmp;
				LONG		i;
	
				// First copy the DirEntry structure
				if (fDirectory)
				{
					*pNewDfEntry->dfe_pDirEntry = *pDfEntry->dfe_pDirEntry;
				}

				// Start with Dir children
				if ((pTmp = pDfEntry->dfe_pDirEntry->de_ChildDir) != NULL)
				{
					// First fix up the first child's PrevSibling pointer
					pTmp->dfe_PrevSibling = &pNewDfEntry->dfe_pDirEntry->de_ChildDir;
	
					for (NOTHING;
						 pTmp != NULL;
						 pTmp = pTmp->dfe_NextSibling)
					{
						ASSERT(pTmp->dfe_Parent == pDfEntry);
						pTmp->dfe_Parent = pNewDfEntry;
					}
				}
	
				// Repeat for File childs as well
				for (i = 0; i < MAX_CHILD_HASH_BUCKETS; i++)
				{
					if ((pTmp = pDfEntry->dfe_pDirEntry->de_ChildFile[i]) != NULL)
					{
						// First  fix up the first child's PrevSibling pointer
						pTmp->dfe_PrevSibling = &pNewDfEntry->dfe_pDirEntry->de_ChildFile[i];
	
						for (NOTHING;
							 pTmp != NULL;
							 pTmp = pTmp->dfe_NextSibling)
						{
							ASSERT(pTmp->dfe_Parent == pDfEntry);
							pTmp->dfe_Parent = pNewDfEntry;
						}
					}
				}
			}
		}

		// Now fix the sibling relationships. Note that this needs to be done
		// regardless of whether a new dfe was created since these depend on
		// name hash which has potentially changed
		AfpUnlinkDouble(pDfEntry,
						dfe_NextSibling,
						dfe_PrevSibling);

		// Copy the new unicode name and create a new hash
		AfpCopyUnicodeString(&pNewDfEntry->dfe_UnicodeName,
							 pNewName);
		afpHashUnicodeName(&pNewDfEntry->dfe_UnicodeName, &pNewDfEntry->dfe_NameHash);

		// Insert it into its sibling chain
		afpInsertDFEInSiblingList(pNewDfEntry->dfe_Parent, pNewDfEntry, fDirectory);

		if (pDfEntry != pNewDfEntry)
			FREE_DFE(pDfEntry);

		AfpVolumeSetModifiedTime(pVolDesc);
	} while (False);

	return pNewDfEntry;
}


/***	AfpMoveDfEntry
 *
 *	Triggered by a move/rename-move of a file/dir.  A moved entity must retain
 *	its AfpId.
 *
 *	Callable from within the Fsp only. The caller should take Swmr lock for
 *	WRITE.
 *
 *	LOCKS:	vds_VolLock (SPIN) for updating the IdDb header.
 *	LOCKS_ASSUMED: vds_idDbAccessLock (SWMR, Exclusive)
 *	LOCK_ORDER: VolDesc lock after IdDb Swmr.
 *
 */
PDFENTRY
AfpMoveDfEntry(
	IN	PVOLDESC			pVolDesc,
	IN	PDFENTRY			pDfEntry,
	IN	PDFENTRY			pNewParentDFE,
	IN	PUNICODE_STRING		pNewName		OPTIONAL
)
{
	SHORT		depthDelta;					// This must be signed
	BOOLEAN		fDirectory;

	PAGED_CODE( );

	ASSERT((pDfEntry != NULL) && (pNewParentDFE != NULL) && (pVolDesc != NULL));

	// do we need to rename the DFEntry ?
	if (ARGUMENT_PRESENT(pNewName) &&
		!EQUAL_UNICODE_STRING(pNewName, &pDfEntry->dfe_UnicodeName, True))
	{
		if ((pDfEntry = AfpRenameDfEntry(pVolDesc,
										 pDfEntry,
										 pNewName)) == NULL)
		{
			return NULL;
		}
	}

	if (pDfEntry->dfe_Parent != pNewParentDFE)
	{
		// unlink the current entry from its parent/sibling associations (but not
		// the overflow hash bucket list since the AfpId has not changed.  The
		// children of this entity being moved (if its a dir and it has any) will
		// remain intact, and move along with the dir)
		AfpUnlinkDouble(pDfEntry, dfe_NextSibling, dfe_PrevSibling);

		fDirectory = DFE_IS_DIRECTORY(pDfEntry);

		// Decrement the old parent's offspring count & increment the new parent
		if (fDirectory)
		{
			ASSERT(pDfEntry->dfe_Parent->dfe_DirOffspring > 0);
			pDfEntry->dfe_Parent->dfe_DirOffspring --;
			pNewParentDFE->dfe_DirOffspring ++;

			// insert it into the new parent's child list
			afpInsertDirDFEInSiblingList(pNewParentDFE, pDfEntry);
		}
		else
		{
			ASSERT(pDfEntry->dfe_Parent->dfe_FileOffspring > 0);
			pDfEntry->dfe_Parent->dfe_FileOffspring --;
			pNewParentDFE->dfe_FileOffspring ++;
#ifdef	AGE_DFES
			if (IS_VOLUME_AGING_DFES(pVolDesc))
			{
				if (pDfEntry->dfe_Flags & DFE_FLAGS_R_ALREADYOPEN)
				{
					pDfEntry->dfe_Parent->dfe_pDirEntry->de_ChildForkOpenCount --;
					pNewParentDFE->dfe_pDirEntry->de_ChildForkOpenCount ++;
				}
				if (pDfEntry->dfe_Flags & DFE_FLAGS_D_ALREADYOPEN)
				{
					pDfEntry->dfe_Parent->dfe_pDirEntry->de_ChildForkOpenCount --;
					pNewParentDFE->dfe_pDirEntry->de_ChildForkOpenCount ++;
				}
			}
#endif
			// insert it into the new parent's child list
			afpInsertFileDFEInSiblingList(pNewParentDFE, pDfEntry);
		}

		pDfEntry->dfe_Parent = pNewParentDFE;

		// If we moved a directory, we must adjust the directory depths of the
		// directory, and all directories below it
		if (fDirectory &&
			((depthDelta = (pNewParentDFE->dfe_DirDepth + 1 - pDfEntry->dfe_DirDepth)) != 0))
		{
			PDFENTRY	pTmp = pDfEntry;

			while (True)
			{
				if ((pTmp->dfe_pDirEntry->de_ChildDir != NULL) &&
					(pTmp->dfe_DirDepth != (pTmp->dfe_Parent->dfe_DirDepth + 1)))
				{
					ASSERT(DFE_IS_DIRECTORY(pTmp));
					pTmp->dfe_DirDepth += depthDelta;
					pTmp = pTmp->dfe_pDirEntry->de_ChildDir;
				}
				else
				{
					ASSERT(DFE_IS_DIRECTORY(pTmp));
					if ((pTmp->dfe_DirDepth != pTmp->dfe_Parent->dfe_DirDepth + 1))
						pTmp->dfe_DirDepth += depthDelta;

					if (pTmp == pDfEntry)
						break;
					else if (pTmp->dfe_NextSibling != NULL)
						 pTmp = pTmp->dfe_NextSibling;
					else pTmp = pTmp->dfe_Parent;
				}
			}
		}
	}

	AfpVolumeSetModifiedTime(pVolDesc);

	return pDfEntry;
}


/***	AfpDeleteDfEntry
 *
 *	Trigerred by the deletion of a file/directory. The entry as well as the
 *	index is unlinked and freed.  If we are deleting a directory that is not
 *	empty, the entire directory tree underneath is deleted as well.  Note when
 *	implementing FPDelete, always attempt the delete from the actual file system
 *	first, then delete from the IdDB if that succeeds.
 *
 *	Callable from within the Fsp only. The caller should take Swmr lock for
 *	WRITE.
 *
 *	LOCKS:	vds_VolLock (SPIN) for updating the IdDb header.
 *	LOCKS_ASSUMED: vds_idDbAccessLock (SWMR, Exclusive)
 *	LOCK_ORDER: VolDesc lock after IdDb Swmr.
 */
VOID FASTCALL
AfpDeleteDfEntry(
	IN	PVOLDESC	pVolDesc,
	IN	PDFENTRY	pDfEntry
)
{
	PDFENTRY	pDfeParent = pDfEntry->dfe_Parent;
	LONG		i;
	BOOLEAN		Prune = False;

	PAGED_CODE( );

	ASSERT(pDfeParent != NULL);

	if (DFE_IS_DIRECTORY(pDfEntry))
	{
		for (i = 0; i < MAX_CHILD_HASH_BUCKETS; i++)
		{
			if (pDfEntry->dfe_pDirEntry->de_ChildFile[i] != NULL)
			{
				Prune = True;
				break;
			}
		}
		if ((pDfEntry->dfe_pDirEntry->de_ChildDir != NULL) || Prune)
		{
			// This will happen if a PC user deletes a tree behind our back
			AfpPruneIdDb(pVolDesc, pDfEntry);
		}
		ASSERT(pDfeParent->dfe_DirOffspring > 0);
		pDfeParent->dfe_DirOffspring --;
	}
	else
	{
		ASSERT(pDfeParent->dfe_FileOffspring > 0);
		pDfeParent->dfe_FileOffspring --;

		// The Finder is bad about deleting APPL mappings (it deletes
		// the file before deleting the APPL mapping so always gets
		// ObjectNotFound error for RemoveAPPL, and leaves turd mappings).
		if (pDfEntry->dfe_FinderInfo.fd_TypeD == *(PDWORD)"APPL")
		{
			AfpRemoveAppl(pVolDesc,
 						  pDfEntry->dfe_FinderInfo.fd_CreatorD,
						  pDfEntry->dfe_AfpId);
		}

	}

	// Unlink it now from the hash table
	DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_INFO,
			("AfpDeleteDfEntry: Unlinking from the hash table\n") );
	AfpUnlinkDouble(pDfEntry,
					dfe_NextOverflow,
					dfe_PrevOverflow);

	// Make sure we get rid of the cache if valid
	if (pVolDesc->vds_pDfeCache[HASH_CACHE_ID(pDfEntry->dfe_AfpId)] == pDfEntry)
		pVolDesc->vds_pDfeCache[HASH_CACHE_ID(pDfEntry->dfe_AfpId)] = NULL;

	// Seperate it now from its siblings
	DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_INFO,
			("AfpDeleteDfEntry: Unlinking from the sibling list\n") );
	AfpUnlinkDouble(pDfEntry,
					dfe_NextSibling,
					dfe_PrevSibling);

	(DFE_IS_DIRECTORY(pDfEntry)) ?
		pVolDesc->vds_NumDirDfEntries -- :
		pVolDesc->vds_NumFileDfEntries --;

	FREE_DFE(pDfEntry);

	AfpVolumeSetModifiedTime(pVolDesc);
}


/***	AfpPruneIdDb
 *
 *	Lops off a branch of the IdDb.  Called by network trash code when
 *	cleaning out the trash directory, or by directory enumerate code that
 *	has discovered a directory has been 'delnoded' by a PC user.  The
 *	IdDb sibling tree is traversed, and each node under the pDfeTarget node
 *	is deleted from the database and freed.  pDfeTarget itself is NOT
 *	deleted.  If necessary, the caller should delete the target itself.
 *
 *	Callable from within the Fsp only. The caller should take Swmr lock for
 *	WRITE.
 *
 *	LOCKS:	vds_VolLock (SPIN) for updating the IdDb header.
 *	LOCKS_ASSUMED: vds_idDbAccessLock (SWMR, Exclusive)
 *	LOCK_ORDER: VolDesc lock after IdDb Swmr.
 */
VOID FASTCALL
AfpPruneIdDb(
	IN	PVOLDESC	pVolDesc,
	IN	PDFENTRY	pDfeTarget
)
{
	PDFENTRY	pCurDfe = pDfeTarget, pDelDfe;
	LONG		i = 0;

	PAGED_CODE( );

	ASSERT((pVolDesc != NULL) && (pDfeTarget != NULL) &&
			(pDfeTarget->dfe_Flags & DFE_FLAGS_DIR));

	DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_INFO,
			("AfpPruneIdDb entered...\n") );

	while (True)
	{
		ASSERT(DFE_IS_DIRECTORY(pCurDfe));

		// Delete all the file children of this node first
		for (i = 0; i < MAX_CHILD_HASH_BUCKETS; i++)
		{
			while ((pDelDfe = pCurDfe->dfe_pDirEntry->de_ChildFile[i]) != NULL)
			{
				AfpDeleteDfEntry(pVolDesc, pDelDfe);
			}
		}

		if (pCurDfe->dfe_pDirEntry->de_ChildDir != NULL)
		{
			pCurDfe = pCurDfe->dfe_pDirEntry->de_ChildDir;
		}
		else if (pCurDfe == pDfeTarget)
		{
			return;
		}
		else if (pCurDfe->dfe_NextSibling != NULL)
		{
			pDelDfe = pCurDfe;
			pCurDfe = pCurDfe->dfe_NextSibling;
			AfpDeleteDfEntry(pVolDesc, pDelDfe);
		}
		else
		{
			pDelDfe = pCurDfe;
			pCurDfe = pCurDfe->dfe_Parent;
			AfpDeleteDfEntry(pVolDesc, pDelDfe);
		}
	}
}


/***	AfpExchangeIdEntries
 *
 *	Called by AfpExchangeFiles api.
 *
 *	Callable from within the Fsp only. The caller should take Swmr lock for
 *	WRITE.
 *
 *	LOCKS_ASSUMED: vds_idDbAccessLock (SWMR, Exclusive)
 */
VOID
AfpExchangeIdEntries(
	IN	PVOLDESC	pVolDesc,
	IN	DWORD		AfpId1,
	IN	DWORD		AfpId2
)
{
	PDFENTRY pDFE1, pDFE2;
	DFENTRY	 DFEtemp;

	PAGED_CODE( );

	pDFE1 = AfpFindDfEntryById(pVolDesc, AfpId1, DFE_FILE);
	ASSERT(pDFE1 != NULL);

	pDFE2 = AfpFindDfEntryById(pVolDesc, AfpId2, DFE_FILE);
	ASSERT(pDFE2 != NULL);

    // a customer hit this problem on NT4 where one of the Dfe's was NULL!
    if (pDFE1 == NULL || pDFE2 == NULL)
    {
        ASSERT(0);
        return;
    }

	DFEtemp = *pDFE2;

	pDFE2->dfe_Flags = pDFE1->dfe_Flags;
	pDFE2->dfe_BackupTime  = pDFE1->dfe_BackupTime;
	pDFE2->dfe_LastModTime = pDFE1->dfe_LastModTime;
	pDFE2->dfe_DataLen = pDFE1->dfe_DataLen;
	pDFE2->dfe_RescLen = pDFE1->dfe_RescLen;
	pDFE2->dfe_NtAttr  = pDFE1->dfe_NtAttr;
	pDFE2->dfe_AfpAttr = pDFE1->dfe_AfpAttr;

	pDFE1->dfe_Flags = DFEtemp.dfe_Flags;
	pDFE1->dfe_BackupTime  = DFEtemp.dfe_BackupTime;
	pDFE1->dfe_LastModTime = DFEtemp.dfe_LastModTime;
	pDFE1->dfe_DataLen = DFEtemp.dfe_DataLen;
	pDFE1->dfe_RescLen = DFEtemp.dfe_RescLen;
	pDFE1->dfe_NtAttr  = DFEtemp.dfe_NtAttr;
	pDFE1->dfe_AfpAttr = DFEtemp.dfe_AfpAttr;
}


/***	AfpEnumerate
 *
 *	Enumerates files and dirs in a directory using the IdDb.
 *	An array of ENUMDIR structures is returned which represent
 *	the enumerated files and dirs.
 *
 *	Short Names
 *	ProDos Info
 *	Offspring count
 *	Permissions/Owner Id/Group Id
 *
 *	LOCKS: vds_idDbAccessLock (SWMR, Shared)
 *
 */
AFPSTATUS
AfpEnumerate(
	IN	PCONNDESC			pConnDesc,
	IN	DWORD				ParentDirId,
	IN	PANSI_STRING		pPath,
	IN	DWORD				BitmapF,
	IN	DWORD				BitmapD,
	IN	BYTE				PathType,
	IN	DWORD				DFFlags,
	OUT PENUMDIR *			ppEnumDir
)
{
	PENUMDIR		pEnumDir;
	PDFENTRY		pDfe, pTmp;
	PEIT			pEit;
	AFPSTATUS		Status;
	PATHMAPENTITY	PME;
	BOOLEAN			NeedHandle = False;
	FILEDIRPARM		FDParm;
	PVOLDESC		pVolDesc = pConnDesc->cds_pVolDesc;
	LONG			EnumCount;
	BOOLEAN			ReleaseSwmr = False, NeedWriteLock = False;

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_INFO,
			("AfpEnumerate Entered\n"));

	do
	{
		// Check if this enumeration matches the current enumeration
		if ((pEnumDir = pConnDesc->cds_pEnumDir) != NULL)
		{
			if ((pEnumDir->ed_ParentDirId == ParentDirId) &&
				(pEnumDir->ed_PathType == PathType) &&
				(pEnumDir->ed_TimeStamp >= pVolDesc->vds_ModifiedTime) &&
				(pEnumDir->ed_Bitmap == (BitmapF + (BitmapD << 16))) &&
                (pPath->Length == pEnumDir->ed_PathName.Length))
            {
                if (((pPath->Length == 0) && (pEnumDir->ed_PathName.Length == 0)) ||
				 RtlCompareMemory(pEnumDir->ed_PathName.Buffer,
								 pPath->Buffer,
								 pPath->Length))
                {
                    DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_INFO,
                            ("AfpEnumerate found cache hit\n"));
                    INTERLOCKED_INCREMENT_LONG(&AfpServerStatistics.stat_EnumCacheHits);
                    *ppEnumDir = pEnumDir;
                    Status = AFP_ERR_NONE;
                    break;
                }
            }

			// Does not match, cleanup the previous entry
			AfpFreeMemory(pEnumDir);
			pConnDesc->cds_pEnumDir = NULL;
		}

		INTERLOCKED_INCREMENT_LONG(&AfpServerStatistics.stat_EnumCacheMisses);
		DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_INFO,
				("AfpEnumerate creating new cache\n"));

		// We have no current enumeration. Create one now
		*ppEnumDir = NULL;
		AfpInitializeFDParms(&FDParm);
		AfpInitializePME(&PME, 0, NULL);

		if (IS_VOLUME_NTFS(pVolDesc))
		{
			NeedHandle = True;
		}
		Status = AfpMapAfpPathForLookup(pConnDesc,
										ParentDirId,
										pPath,
										PathType,
										DFE_DIR,
										DIR_BITMAP_DIRID |
											DIR_BITMAP_GROUPID |
											DIR_BITMAP_OWNERID |
											DIR_BITMAP_ACCESSRIGHTS |
											FD_INTERNAL_BITMAP_OPENACCESS_READCTRL |
											DIR_BITMAP_OFFSPRINGS,
										NeedHandle ? &PME : NULL,
										&FDParm);

		if (Status != AFP_ERR_NONE)
		{
			if (Status == AFP_ERR_OBJECT_NOT_FOUND)
				Status = AFP_ERR_DIR_NOT_FOUND;
			break;
		}

		if (NeedHandle)
		{
			AfpIoClose(&PME.pme_Handle);
		}

		// For admin, set all access bits
		if (pConnDesc->cds_pSda->sda_ClientType == SDA_CLIENT_ADMIN)
		{
			FDParm._fdp_UserRights = DIR_ACCESS_ALL | DIR_ACCESS_OWNER;
		}

		if ((BitmapF != 0) && (FDParm._fdp_UserRights & DIR_ACCESS_READ))
			DFFlags |= DFE_FILE;
		if ((BitmapD != 0) && (FDParm._fdp_UserRights & DIR_ACCESS_SEARCH))
			DFFlags |= DFE_DIR;

		// Catch access denied error here
		if (DFFlags == 0)
		{
			Status = AFP_ERR_ACCESS_DENIED;
			break;
		}

		// All is hunky-dory so far, go ahead with the enumeration now

#ifdef GET_CORRECT_OFFSPRING_COUNTS
	take_swmr_for_enum:
#endif
		NeedWriteLock ?
			AfpSwmrAcquireExclusive(&pVolDesc->vds_IdDbAccessLock) :
			AfpSwmrAcquireShared(&pVolDesc->vds_IdDbAccessLock);
		ReleaseSwmr = True;

		// Lookup the dfentry of the AfpIdEnumDir
		if ((pDfe = AfpFindDfEntryById(pVolDesc,
										FDParm._fdp_AfpId,
										DFE_DIR)) == NULL)
		{
			Status = AFP_ERR_OBJECT_NOT_FOUND;
			break;
		}

		// Allocate a ENUMDIR structure and initialize it
		EnumCount = 0;
		if (DFFlags & DFE_DIR)
			EnumCount += (DWORD)(pDfe->dfe_DirOffspring);
		if (DFFlags & DFE_FILE)
			EnumCount += (DWORD)(pDfe->dfe_FileOffspring);

		if (EnumCount == 0)
		{
			Status = AFP_ERR_OBJECT_NOT_FOUND;
			break;
		}

		if ((pEnumDir = (PENUMDIR)AfpAllocNonPagedMemory(sizeof(ENUMDIR) +
														 pPath->MaximumLength +
														 EnumCount*sizeof(EIT))) == NULL)
		{
			Status = AFP_ERR_OBJECT_NOT_FOUND;
			break;
		}

		pEnumDir->ed_ParentDirId = ParentDirId;
		pEnumDir->ed_ChildCount = EnumCount;
		pEnumDir->ed_PathType = PathType;
		pEnumDir->ed_Bitmap = (BitmapF + (BitmapD << 16));
		pEnumDir->ed_BadCount = 0;
		pEnumDir->ed_pEit = pEit = (PEIT)((PBYTE)pEnumDir + sizeof(ENUMDIR));
		AfpSetEmptyAnsiString(&pEnumDir->ed_PathName,
							  pPath->MaximumLength,
							  (PBYTE)pEnumDir +
									sizeof(ENUMDIR) +
									EnumCount*sizeof(EIT));
		RtlCopyMemory(pEnumDir->ed_PathName.Buffer,
					  pPath->Buffer,
					  pPath->Length);

		*ppEnumDir = pConnDesc->cds_pEnumDir = pEnumDir;

		// Now copy the enum parameters (Afp Id and file/dir flag) of
		// each of the children, files first
		if (DFFlags & DFE_FILE)
		{
			LONG	i;

			for (i = 0; i < MAX_CHILD_HASH_BUCKETS; i++)
			{
				for (pTmp = pDfe->dfe_pDirEntry->de_ChildFile[i];
					 pTmp != NULL;
					 pTmp = pTmp->dfe_NextSibling, pEit ++)
				{
					ASSERT(!DFE_IS_DIRECTORY(pTmp));

					pEit->eit_Id = pTmp->dfe_AfpId;
					pEit->eit_Flags = DFE_FILE;
				}
			}
		}
		if (DFFlags & DFE_DIR)
		{
			for (pTmp = pDfe->dfe_pDirEntry->de_ChildDir;
				 pTmp != NULL;
				 pTmp = pTmp->dfe_NextSibling, pEit ++)
			{
				ASSERT(DFE_IS_DIRECTORY(pTmp));

				pEit->eit_Id = pTmp->dfe_AfpId;
				pEit->eit_Flags = DFE_DIR;

#ifdef GET_CORRECT_OFFSPRING_COUNTS
				// We are returning a directory offspring, make sure
				// that it has its children cached in so we get the correct
				// file and dir offspring counts for it, otherwise Finder
				// 'view by name' doesn't work correctly because it sees
				// zero as the offspring count and clicking on the triangle
				// shows nothing since it tries to be smart and doesn't
				// explicitly enumerate that dir if offspring count is zero.
				//
				// This can be a big performance hit if a directory has lots
				// of subdirectories which in turn have tons of files.
				//
				// JH - Could we alternately return incorrect information about
				//		files as long as there are directry children. What else
				//		will break ?
				// if (!DFE_CHILDREN_ARE_PRESENT(pTmp) && (pTmp->dfe_DirOffspring == 0))
				if (!DFE_CHILDREN_ARE_PRESENT(pTmp))
				{
					if (!AfpSwmrLockedExclusive(&pVolDesc->vds_IdDbAccessLock) &&
						!AfpSwmrUpgradeToExclusive(&pVolDesc->vds_IdDbAccessLock))
					{
						NeedWriteLock = True;
						AfpSwmrRelease(&pVolDesc->vds_IdDbAccessLock);
						ReleaseSwmr = False;
						// We must free the memory here in case the next
						// time we enumerate the dir it has more children
						// than it had the first time -- since we must let go
						// of the swmr here things could change.
						AfpFreeMemory(pEnumDir);
						*ppEnumDir = pConnDesc->cds_pEnumDir = NULL;
						goto take_swmr_for_enum;
					}

					AfpCacheDirectoryTree(pVolDesc,
										  pTmp,
										  GETFILES,
										  NULL,
										  NULL);
				} // if children not cached
#endif
			}
		}

		AfpGetCurrentTimeInMacFormat(&pEnumDir->ed_TimeStamp);
		Status = AFP_ERR_NONE;
	} while (False);

	if (ReleaseSwmr)
		AfpSwmrRelease(&pVolDesc->vds_IdDbAccessLock);

	return Status;
}


/***	AfpCatSearch
 *
 *	This routine does a left-hand search on the DFE tree to search for
 *  file/dirs that match the search criteria indicated in pFDParm1 and
 *  pFDParm2.
 *
 *	LOCKS: vds_idDbAccessLock (SWMR, Shared or Exclusive)
 */
AFPSTATUS
AfpCatSearch(
	IN	PCONNDESC			pConnDesc,
	IN	PCATALOGPOSITION	pCatPosition,
	IN	DWORD				Bitmap,
	IN	DWORD				FileBitmap,
	IN	DWORD				DirBitmap,
	IN	PFILEDIRPARM		pFDParm1,
	IN	PFILEDIRPARM		pFDParm2,
	IN	PUNICODE_STRING		pMatchString	OPTIONAL,
	IN OUT	PDWORD			pCount,
	IN  SHORT				Buflen,
	OUT	PSHORT				pSizeLeft,
	OUT	PBYTE				pResults,
	OUT	PCATALOGPOSITION	pNewCatPosition
)
{
	PVOLDESC	pVolDesc = pConnDesc->cds_pVolDesc;
	PDFENTRY	pCurParent, pCurFile;
	BOOLEAN		MatchFiles = True, MatchDirs = True, NewSearch = False;
	BOOLEAN		HaveSeeFiles, HaveSeeFolders, CheckAccess = False;
	AFPSTATUS	Status = AFP_ERR_NONE;
	LONG		i;
	DWORD		ActCount = 0;
	SHORT		SizeLeft = Buflen;
	PSWMR		pSwmr = &(pConnDesc->cds_pVolDesc->vds_IdDbAccessLock);
	USHORT		Flags;
	UNICODE_STRING	CurPath;

	typedef struct _SearchEntityPkt
	{
		BYTE	__Length;
		BYTE	__FileDirFlag;
		// The real parameters follow
	} SEP, *PSEP;
	PSEP 	pSep;

	PAGED_CODE( );

	pSep = (PSEP)pResults;
	RtlZeroMemory(pNewCatPosition, sizeof(CATALOGPOSITION));

  CatSearchStart:
	Flags = pCatPosition->cp_Flags;
	pCurFile = NULL;
	i = MAX_CHILD_HASH_BUCKETS;

	if (Flags & CATFLAGS_WRITELOCK_REQUIRED)
	{
		ASSERT(Flags == (CATFLAGS_SEARCHING_FILES | CATFLAGS_WRITELOCK_REQUIRED));
		AfpSwmrAcquireExclusive(pSwmr);
		Flags &= ~CATFLAGS_WRITELOCK_REQUIRED;
	}
	else
		AfpSwmrAcquireShared(pSwmr);

	if (Flags == 0)
	{
		//
		// Start search from beginning of catalog (i.e. the root directory)
		//
		i = 0;
		pCurParent = pVolDesc->vds_pDfeRoot;
		pCurFile = pCurParent->dfe_pDirEntry->de_ChildFile[0];
		if (IS_VOLUME_NTFS(pVolDesc))
			CheckAccess = True;
		Flags = CATFLAGS_SEARCHING_FILES;
		NewSearch = True;
	}
	else
	{
		//
		// This is a continuation of a previous search, pickup where we
		// left off
		//

		AFPTIME CurrentTime;

		AfpGetCurrentTimeInMacFormat(&CurrentTime);

		// If we cannot find the current parent dir specified by this
		// catalog position, or too much time has elapsed since the
		// user last sent in this catalog position, then restart the search
		// from the root dir.  The reason we have a time limitation is that
		// if someone made a CatSearch request N minutes ago, and the
		// current position is deep in the tree, the directory permissions
		// higher up in the tree could have changed by now so that the user
		// shouldn't even have access to this part of the tree anymore.
		// Since we do move up in the tree without rechecking permissions,
		// this could happen.  (We assume that if we got down to the current
		// position in the tree that we had to have had access higher up
		// in order to get here, so moving up is ok.  But if somebody comes
		// back a day later and continues the catsearch where it left off,
		// we shouldn't let them.)  It is too expensive to be rechecking
		// parents' parent permissions everytime we move back up the tree.
		if (((CurrentTime - pCatPosition->cp_TimeStamp) >= MAX_CATSEARCH_TIME) ||
			((pCurParent = AfpFindDfEntryById(pVolDesc,
											  pCatPosition->cp_CurParentId,
											  DFE_DIR)) == NULL))
		{
			// Start over from root directory
			Status = AFP_ERR_CATALOG_CHANGED;
			DBGPRINT(DBG_COMP_AFPAPI_FD, DBG_LEVEL_WARN,
					("AfpCatSearch: Time diff >= MAX_CATSEARCH_TIME or couldn't find CurParent Id!\n"));
			pCurParent = pVolDesc->vds_pDfeRoot;
			Flags = CATFLAGS_SEARCHING_FILES;
			pSep = (PSEP)pResults;
			Status = AFP_ERR_NONE;
			MatchFiles = True;
			MatchDirs = True;
			SizeLeft = Buflen;
			ActCount = 0;
			if (IS_VOLUME_NTFS(pVolDesc))
				CheckAccess = True;
			NewSearch = True;
		}
		else if (pCatPosition->cp_TimeStamp < pVolDesc->vds_ModifiedTime)
		{
			Status = AFP_ERR_CATALOG_CHANGED;
			ASSERT(IS_VOLUME_NTFS(pVolDesc));
			DBGPRINT(DBG_COMP_AFPAPI_FD, DBG_LEVEL_WARN,
					("AfpCatSearch: Catalog timestamp older than IdDb Modtime\n"));
		}

		ASSERT(DFE_IS_DIRECTORY(pCurParent));

		// If we need to resume searching the files for this parent, find the
		// one we should start with, if it is not the first file child.
		if (Flags & CATFLAGS_SEARCHING_FILES)
		{
			//
			// Default is to start with parent's first child which
			// may or may not be null depending on if the parent has had
			// its file children cached in or not.  If we are restarting a
			// search because we had to let go of the IdDb SWMR in order to
			// reaquire for Exclusive access, this parent's children could
			// very well have been cached in by someone else in the mean time.
			// If so then we will pick it up here.
			//
			i = 0;
			pCurFile = pCurParent->dfe_pDirEntry->de_ChildFile[0];

			if (pCatPosition->cp_NextFileId != 0)
			{

				// Find the DFE corresponding to the next fileID to look at
				if (((pCurFile = AfpFindDfEntryById(pVolDesc,
													pCatPosition->cp_NextFileId,
													DFE_FILE)) == NULL) ||
					(pCurFile->dfe_Parent != pCurParent))
				{
					// If we can't find the file that was specified, start over
					// with this parent's first file child and indicate there may
					// be duplicates returned or files missed
					Status = AFP_ERR_CATALOG_CHANGED;
					DBGPRINT(DBG_COMP_AFPAPI_FD, DBG_LEVEL_WARN,
							 ("AfpCatSearch: Could not find file Child ID!\n"));
					i = 0;
					pCurFile = pCurParent->dfe_pDirEntry->de_ChildFile[0];
				}
				else
				{
					i = (pCurFile->dfe_NameHash % MAX_CHILD_HASH_BUCKETS);
				}
			}
		}
	}

	if (pFDParm1->_fdp_Flags == DFE_FLAGS_FILE_WITH_ID)
		MatchDirs = False;
	else if (pFDParm1->_fdp_Flags == DFE_FLAGS_DIR)
		MatchFiles = False;


	if (NewSearch && MatchDirs)
	{
		SHORT Length;

		ASSERT (DFE_IS_ROOT(pCurParent));

		// See if the volume root itself is a match
		if ((Length = AfpIsCatSearchMatch(pCurParent,
										  Bitmap,
										  DirBitmap,
										  pFDParm1,
										  pFDParm2,
										  pMatchString)) != 0)
		{
			ASSERT(Length <= SizeLeft);
			PUTSHORT2BYTE(&pSep->__Length, Length - sizeof(SEP));
			pSep->__FileDirFlag = FILEDIR_FLAG_DIR;

			afpPackSearchParms(pCurParent,
							   DirBitmap,
							   (PBYTE)pSep + sizeof(SEP));

			pSep = (PSEP)((PBYTE)pSep + Length);
			SizeLeft -= Length;
			ASSERT(SizeLeft >= 0);
			ActCount ++;
		}
	}
	NewSearch = False;

	while (True)
	{
		HaveSeeFiles = HaveSeeFolders = True;

		//
		// First time thru, if we are resuming a search and need to start
		// with the pCurParent's sibling, then do so.
		//
		if (Flags & CATFLAGS_SEARCHING_SIBLING)
		{
			Flags &= ~CATFLAGS_SEARCHING_SIBLING;
			goto check_sibling;
		}

		//
		// If we have not searched this directory yet and this is NTFS, check
		// that user has seefiles/seefolders access in this directory
		//
		if (CheckAccess)
		{
			BYTE		UserRights;
			NTSTATUS	PermStatus;

			ASSERT(IS_VOLUME_NTFS(pVolDesc));
			AfpSetEmptyUnicodeString(&CurPath, 0, NULL);

			// Get the root relative path of this directory
			if (NT_SUCCESS(AfpHostPathFromDFEntry(pCurParent,
												  0,
												  &CurPath)))
			{
				// Check for SeeFiles/SeeFolders which is the most common case
				if (!NT_SUCCESS((PermStatus = AfpCheckParentPermissions(pConnDesc,
																		pCurParent->dfe_AfpId,
																		&CurPath,
																		DIR_ACCESS_READ | DIR_ACCESS_SEARCH,
																		NULL,
																		&UserRights))))
				{
					if (PermStatus == AFP_ERR_ACCESS_DENIED)
					{
						if ((UserRights & DIR_ACCESS_READ) == 0)
							HaveSeeFiles = False;

						if ((UserRights & DIR_ACCESS_SEARCH) == 0)
							HaveSeeFolders = False;
					}
					else
						HaveSeeFiles = HaveSeeFolders = False;
				}

				if (CurPath.Buffer != NULL)
					AfpFreeMemory(CurPath.Buffer);
			}
			else
			{
				HaveSeeFiles = HaveSeeFolders = False;
				DBGPRINT(DBG_COMP_AFPAPI_FD, DBG_LEVEL_ERR,
						("AfpCatSearch: Could not get host path from DFE!!\n"));
			}

			CheckAccess = False;
		}

		// Search the files first if have seefiles access on the current
		// parent and the user has asked for file matches.  If we are
		// resuming a search by looking at a directory child first, don't look
		// at the files.
		if (HaveSeeFiles && MatchFiles && (Flags & CATFLAGS_SEARCHING_FILES))
		{
			PDFENTRY	pDFE;
			SHORT		Length;
			AFPSTATUS	subStatus = AFP_ERR_NONE, subsubStatus = AFP_ERR_NONE;

			if (!DFE_CHILDREN_ARE_PRESENT(pCurParent))
			{
				if (!AfpSwmrLockedExclusive(pSwmr) &&
					!AfpSwmrUpgradeToExclusive(pSwmr))
				{
					if (ActCount > 0)
					{
						// We have at least one thing to return to the user,
						// so return it now and set the flag for next time
						// to take the write lock.
						pNewCatPosition->cp_NextFileId = 0;
						Flags |= CATFLAGS_WRITELOCK_REQUIRED;
						break; // out of while loop
					}
					else
					{
						// Let go of lock and reaquire it for exclusive
						// access.  Start over where we left off here if
						// possible.  Put a new timestamp in the catalog
						// position so if it changes between the time we let
						// go of the lock and reaquire it for exclusive access,
						// we will return AFP_ERR_CATALOG_CHANGED since
						// something could change while we don't own the lock.
						AfpSwmrRelease(pSwmr);
						pCatPosition->cp_Flags = CATFLAGS_WRITELOCK_REQUIRED |
												 CATFLAGS_SEARCHING_FILES;
						pCatPosition->cp_CurParentId = pCurParent->dfe_AfpId;
						pCatPosition->cp_NextFileId = 0;
						AfpGetCurrentTimeInMacFormat(&pCatPosition->cp_TimeStamp);
						DBGPRINT(DBG_COMP_AFPAPI_FD, DBG_LEVEL_INFO,
								("AfpCatSearch: Lock released; reaquiring Exclusive\n"));
						goto CatSearchStart;
					}
				}

				AfpCacheDirectoryTree(pVolDesc,
									  pCurParent,
									  GETFILES,
									  NULL,
									  NULL);
				i = 0;
				pCurFile = pCurParent->dfe_pDirEntry->de_ChildFile[0];

				// If we have the exclusive lock, downgrade it to shared so
				// we don't lock out others who want to read.
				if (AfpSwmrLockedExclusive(pSwmr))
					AfpSwmrDowngradeToShared(pSwmr);
			}

			//
			// Search files for matches.  If we are picking up in the middle
			// of searching the files, then start with the right one as pointed
			// at by pCurFile.
			//
			while (TRUE)
			{
				while (pCurFile == NULL)
				{
					i ++;
					if (i < MAX_CHILD_HASH_BUCKETS)
					{
						pCurFile = pCurParent->dfe_pDirEntry->de_ChildFile[i];
					}
					else
					{
						subsubStatus = STATUS_NO_MORE_FILES;
						break; // out of while (pCurFile == NULL)
					}
				}

				if (subsubStatus != AFP_ERR_NONE)
				{
					break;
				}

				ASSERT(pCurFile->dfe_Parent == pCurParent);

				if ((Length = AfpIsCatSearchMatch(pCurFile,
												  Bitmap,
												  FileBitmap,
												  pFDParm1,
												  pFDParm2,
												  pMatchString)) != 0)
				{
					// Add this to the output buffer if there is room
					if ((Length <= SizeLeft) && (ActCount < *pCount))
					{
						PUTSHORT2BYTE(&pSep->__Length, Length - sizeof(SEP));
						pSep->__FileDirFlag = FILEDIR_FLAG_FILE;

						afpPackSearchParms(pCurFile,
										   FileBitmap,
										   (PBYTE)pSep + sizeof(SEP));

						pSep = (PSEP)((PBYTE)pSep + Length);
						SizeLeft -= Length;
						ASSERT(SizeLeft >= 0);
						ActCount ++;
					}
					else
					{
						// We don't have enough room to return this entry, or
						// we already have found the requested count.  So this
						// will be where we pick up from on the next search
						pNewCatPosition->cp_NextFileId = pCurFile->dfe_AfpId;
						subStatus = STATUS_BUFFER_OVERFLOW;
						break;
					}
				}
                pCurFile = pCurFile->dfe_NextSibling;
			}

			if (subStatus != AFP_ERR_NONE)
			{
				break;	// out of while loop
			}

			Flags = 0;
		}

		// If have seefolders on curparent and curparent has a dir child,
		// Move down the tree to the parent's first directory branch
		if (HaveSeeFolders && (pCurParent->dfe_pDirEntry->de_ChildDir != NULL))
		{
			SHORT Length;

			// If user has asked for directory matches, try the parent's
			// first directory child as a match
			if (MatchDirs &&
				((Length = AfpIsCatSearchMatch(pCurParent->dfe_pDirEntry->de_ChildDir,
											   Bitmap,
											   DirBitmap,
											   pFDParm1,
											   pFDParm2,
											   pMatchString)) != 0))
			{
				// Add this to the output buffer if there is room
				if ((Length <= SizeLeft) && (ActCount < *pCount))
				{
					PUTSHORT2BYTE(&pSep->__Length, Length - sizeof(SEP));
					pSep->__FileDirFlag = FILEDIR_FLAG_DIR;

					afpPackSearchParms(pCurParent->dfe_pDirEntry->de_ChildDir,
									   DirBitmap,
									   (PBYTE)pSep + sizeof(SEP));

					pSep = (PSEP)((PBYTE)pSep + Length);
					SizeLeft -= Length;
					ASSERT(SizeLeft >= 0);
					ActCount ++;
				}
				else
				{
					// We don't have enough room to return this entry, so
					// it will be where we pick up from on the next search
					Flags = CATFLAGS_SEARCHING_DIRCHILD;
					break;
				}
			}

			// Make the current parent's first dir child the new pCurParent
			// and continue the search from there.
			pCurParent = pCurParent->dfe_pDirEntry->de_ChildDir;
			if (IS_VOLUME_NTFS(pVolDesc))
				CheckAccess = True;
			Flags = CATFLAGS_SEARCHING_FILES;
			i = 0;
			pCurFile = pCurParent->dfe_pDirEntry->de_ChildFile[0];
			continue;
		}

		// We either don't have the access rights to go into any directories
		// under this parent, or the current parent did not have any directory
		// children.  See if it has any siblings.  We know we have access to
		// see this level of siblings since we are at this level in the first
		// place.
  check_sibling:
		if (pCurParent->dfe_NextSibling != NULL)
		{
			SHORT 	Length;

			// If user has asked for directory matches, try the parent's
			// next sibling as a match
			if (MatchDirs &&
				((Length = AfpIsCatSearchMatch(pCurParent->dfe_NextSibling,
											   Bitmap,
											   DirBitmap,
											   pFDParm1,
											   pFDParm2,
											   pMatchString)) != 0))
			{
				// Add this to the output buffer if there is room
				if ((Length <= SizeLeft) && (ActCount < *pCount))
				{
					PUTSHORT2BYTE(&pSep->__Length, Length - sizeof(SEP));
					pSep->__FileDirFlag = FILEDIR_FLAG_DIR;

					afpPackSearchParms(pCurParent->dfe_NextSibling,
									   DirBitmap,
									   (PBYTE)pSep + sizeof(SEP));

					pSep = (PSEP)((PBYTE)pSep + Length);
					SizeLeft -= Length;
					ASSERT(SizeLeft >= 0);
					ActCount ++;
				}
				else
				{
					// We don't have enough room to return this entry, so
					// it will be where we pick up from on the next search
					Flags = CATFLAGS_SEARCHING_SIBLING;
					break;
				}
			}

			// Make the current parent's next sibling the new pCurParent and
			// continue the search from there
			pCurParent = pCurParent->dfe_NextSibling;
			if (IS_VOLUME_NTFS(pVolDesc))
				CheckAccess = True;
			Flags = CATFLAGS_SEARCHING_FILES;
			i = 0;
			pCurFile = pCurParent->dfe_pDirEntry->de_ChildFile[0];
			continue;
		}

		// When we hit the root directory again we have searched everything.
		if (DFE_IS_ROOT(pCurParent))
		{
			Status = AFP_ERR_EOF;
			break;
		}

		// Move back up the tree and see if the parent has a sibling to
		// traverse.  If not, then it will come back here and move up
		// the tree again till it finds a node with a sibling or hits
		// the root.
		pCurParent = pCurParent->dfe_Parent;
		goto check_sibling;
	}

	if ((Status == AFP_ERR_NONE) || (Status == AFP_ERR_CATALOG_CHANGED) ||
		(Status == AFP_ERR_EOF))
	{
		// return the current catalog position and number of items returned
		if (Status != AFP_ERR_EOF)
		{
			ASSERT(Flags != 0);
			ASSERT(ActCount > 0);
			pNewCatPosition->cp_Flags = Flags;
			pNewCatPosition->cp_CurParentId = pCurParent->dfe_AfpId;
			AfpGetCurrentTimeInMacFormat(&pNewCatPosition->cp_TimeStamp);
		}
		*pCount = ActCount;
		ASSERT(SizeLeft >= 0);
		*pSizeLeft = SizeLeft;
	}

	AfpSwmrRelease(pSwmr);

	return Status;
}


/***	afpPackSearchParms
 *
 *
 * 	LOCKS_ASSUMED: vds_IdDbAccessLock (Shared or Exclusive)
 */
VOID
afpPackSearchParms(
	IN	PDFENTRY	pDfe,
	IN	DWORD		Bitmap,
	IN	PBYTE		pBuf
)
{
	DWORD		Offset = 0;
	ANSI_STRING	AName;
	BYTE		NameBuf[AFP_LONGNAME_LEN+1];

	PAGED_CODE( );

    RtlZeroMemory (NameBuf, AFP_LONGNAME_LEN+1);

	if (Bitmap & FD_BITMAP_PARENT_DIRID)
	{
		PUTDWORD2DWORD(pBuf, pDfe->dfe_Parent->dfe_AfpId);
		Offset += sizeof(DWORD);
	}
	if (Bitmap & FD_BITMAP_LONGNAME)
	{
		PUTDWORD2SHORT(pBuf + Offset, Offset + sizeof(USHORT));
		Offset += sizeof(USHORT);
#ifndef DBCS
// 1996.09.26 V-HIDEKK
		PUTSHORT2BYTE(pBuf + Offset, pDfe->dfe_UnicodeName.Length/sizeof(WCHAR));
#endif
		AfpInitAnsiStringWithNonNullTerm(&AName, sizeof(NameBuf), NameBuf);
		AfpConvertMungedUnicodeToAnsi(&pDfe->dfe_UnicodeName,
									  &AName);
#ifdef DBCS
// FiX #11992 SFM: As a result of search, I get incorrect file information.
// 1996.09.26 V-HIDEKK
        PUTSHORT2BYTE(pBuf + Offset, AName.Length);
#endif

		RtlCopyMemory(pBuf + Offset + sizeof(BYTE),
					  NameBuf,
					  AName.Length);
#ifdef DBCS
// FiX #11992 SFM: As a result of search, I get incorrect file information.
// 1996.09.26 V-HIDEKK
        Offset += sizeof(BYTE) + AName.Length;
#else
		Offset += sizeof(BYTE) + pDfe->dfe_UnicodeName.Length/sizeof(WCHAR);
#endif
	}

	if (Offset & 1)
		*(pBuf + Offset) = 0;
}


/***	AfpSetDFFileFlags
 *
 *	Set or clear the DAlreadyOpen or RAlreadyOpen flags for a DFEntry of type
 *	File, or mark the file as having a FileId assigned.
 *
 *	LOCKS: vds_idDbAccessLock (SWMR, Exclusive)
 */
AFPSTATUS
AfpSetDFFileFlags(
	IN	PVOLDESC		pVolDesc,
	IN	DWORD			AfpId,
	IN	DWORD			Flags		OPTIONAL,
	IN	BOOLEAN			SetFileId,
	IN	BOOLEAN			ClrFileId
)
{
	PDFENTRY		pDfeFile;
	AFPSTATUS		Status = AFP_ERR_NONE;

	PAGED_CODE( );

	ASSERT(!(SetFileId | ClrFileId) || (SetFileId ^ ClrFileId));

	AfpSwmrAcquireExclusive(&pVolDesc->vds_IdDbAccessLock);

	pDfeFile = AfpFindDfEntryById(pVolDesc, AfpId, DFE_FILE);
	if (pDfeFile != NULL)
	{
#ifdef	AGE_DFES
		if (IS_VOLUME_AGING_DFES(pVolDesc))
		{
			if (Flags)
			{
				pDfeFile->dfe_Parent->dfe_pDirEntry->de_ChildForkOpenCount ++;
			}
		}
#endif
		pDfeFile->dfe_Flags |=  (Flags & DFE_FLAGS_OPEN_BITS);
		if (SetFileId)
		{
			if (DFE_IS_FILE_WITH_ID(pDfeFile))
				Status = AFP_ERR_ID_EXISTS;
			DFE_SET_FILE_ID(pDfeFile);
		}
		if (ClrFileId)
		{
			if (!DFE_IS_FILE_WITH_ID(pDfeFile))
				Status = AFP_ERR_ID_NOT_FOUND;
			DFE_CLR_FILE_ID(pDfeFile);
		}
	}
	else Status = AFP_ERR_OBJECT_NOT_FOUND;

	AfpSwmrRelease(&pVolDesc->vds_IdDbAccessLock);
	return Status;
}


/***	AfpCacheParentModTime
 *
 *	When the contents of a directory change, the parent LastMod time must be
 *  updated.  Since we don't want to wait for a notification of this,
 *  certain apis must go query for the new parent mod time and cache it.
 *  These include:  CreateDir, CreateFile, CopyFile (Dest), Delete,
 *  Move (Src & Dest), Rename and ExchangeFiles.
 *
 *  LOCKS_ASSUMED: vds_IdDbAccessLock (SWMR, Exclusive)
 */
VOID
AfpCacheParentModTime(
	IN	PVOLDESC		pVolDesc,
	IN	PFILESYSHANDLE	pHandle		OPTIONAL,	// if pPath not supplied
	IN	PUNICODE_STRING	pPath		OPTIONAL,	// if pHandle not supplied
	IN	PDFENTRY		pDfeParent	OPTIONAL,	// if ParentId not supplied
	IN	DWORD			ParentId	OPTIONAL 	// if pDfeParent not supplied
)
{
	FILESYSHANDLE	fshParent;
	PFILESYSHANDLE 	phParent;
	NTSTATUS		Status;

	PAGED_CODE( );

	ASSERT(AfpSwmrLockedExclusive(&pVolDesc->vds_IdDbAccessLock));

	if (!ARGUMENT_PRESENT(pDfeParent))
	{
		ASSERT(ARGUMENT_PRESENT((ULONG_PTR)ParentId));
		pDfeParent = AfpFindDfEntryById(pVolDesc, ParentId, DFE_DIR);
		if (pDfeParent == NULL)
		{
			return;
		}
	}

	if (!ARGUMENT_PRESENT(pHandle))
	{
		ASSERT(ARGUMENT_PRESENT(pPath));
		Status = AfpIoOpen(&pVolDesc->vds_hRootDir,
							AFP_STREAM_DATA,
							FILEIO_OPEN_DIR,
							pPath,
							FILEIO_ACCESS_NONE,
							FILEIO_DENY_NONE,
							False,
							&fshParent);
		if (!NT_SUCCESS(Status))
		{
			return;
		}
		phParent = &fshParent;
	}
	else
	{
		ASSERT(pHandle->fsh_FileHandle != NULL);
		phParent = pHandle;
	}

	AfpIoQueryTimesnAttr(phParent,
						 NULL,
						 &pDfeParent->dfe_LastModTime,
						 NULL);
	if (!ARGUMENT_PRESENT(pHandle))
	{
		AfpIoClose(&fshParent);
	}
}


/***	afpAllocDfe
 *
 *	Allocate a DFE from the DFE Blocks. The DFEs are allocated in 4K chunks and internally
 *	managed. The idea is primarily to reduce the number of faults we may take during
 *	enumeration/pathmap code in faulting in multiple pages to get multiple DFEs.
 *
 *	The DFEs are allocated out of paged memory.
 *
 *	It is important to keep blocks which are all used up at the end, so that if we hit a
 *	block which is empty, we can stop.
 *
 *	LOCKS:	afpDfeBlockLock (SWMR, Exclusive)
 */
LOCAL PDFENTRY FASTCALL
afpAllocDfe(
	IN	LONG	Index,
	IN	BOOLEAN	fDir
)
{
	PDFEBLOCK	pDfb;
	PDFENTRY	pDfEntry = NULL;
#ifdef	PROFILING
	TIME		TimeS, TimeE, TimeD;

	INTERLOCKED_INCREMENT_LONG(&AfpServerProfile->perf_DFEAllocCount);
	AfpGetPerfCounter(&TimeS);
#endif

	PAGED_CODE( );

	ASSERT ((Index >= 0) && (Index < MAX_BLOCK_TYPE));

	AfpSwmrAcquireExclusive(&afpDfeBlockLock);

	// If the block head has no free entries then there are none !!
	// Pick the right block based on whether it is file or dir
	pDfb = fDir ? afpDirDfePartialBlockHead[Index] : afpFileDfePartialBlockHead[Index];
	if (pDfb == NULL)
	{
		//
		// There are no partial blocks. Check if there any free ones and if there move them to partial
		// since we about to allocate from them
		//
		if (fDir)
		{
			pDfb = afpDirDfeFreeBlockHead[Index];
			if (pDfb != NULL)
			{
				AfpUnlinkDouble(pDfb, dfb_Next, dfb_Prev);
				AfpLinkDoubleAtHead(afpDirDfePartialBlockHead[Index],
									pDfb,
									dfb_Next,
									dfb_Prev);
			}
		}
		else
		{
			pDfb = afpFileDfeFreeBlockHead[Index];
			if (pDfb != NULL)
			{
				AfpUnlinkDouble(pDfb, dfb_Next, dfb_Prev);
				AfpLinkDoubleAtHead(afpFileDfePartialBlockHead[Index],
									pDfb,
									dfb_Next,
									dfb_Prev);
			}
		}
	}

	if (pDfb != NULL)

	{
		ASSERT(VALID_DFB(pDfb));
		ASSERT((fDir && (pDfb->dfb_NumFree <= afpDfeNumDirBlocks[Index])) ||
			   (!fDir && (pDfb->dfb_NumFree <= afpDfeNumFileBlocks[Index])));

		ASSERT (pDfb->dfb_NumFree != 0);
		DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_INFO,
				("afpAllocDfe: Found space in Block %lx\n", pDfb));
	}

	if (pDfb == NULL)
	{
		ASSERT(QUAD_SIZED(sizeof(DFEBLOCK)));
		ASSERT(QUAD_SIZED(sizeof(DIRENTRY)));
		ASSERT(QUAD_SIZED(sizeof(DFENTRY)));

		if ((pDfb = (PDFEBLOCK)AfpAllocateVirtualMemoryPage()) != NULL)
		{
			LONG	i;
			USHORT	DfeSize, UnicodeSize, MaxDfes, DirEntrySize;

#if	DBG
			afpDfbAllocCount ++;
#endif
			UnicodeSize = afpDfeUnicodeBufSize[Index];

			DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_WARN,
					("afpAllocDfe: No free %s blocks. Allocated a new block %lx for index %ld\n",
					fDir ? "Dir" : "File", pDfb, Index));

			//
           	// Link it in the partial list as we are about to allocate one block out of it anyway.
			//
			if (fDir)
			{
				AfpLinkDoubleAtHead(afpDirDfePartialBlockHead[Index],
									pDfb,
									dfb_Next,
									dfb_Prev);
				DfeSize = afpDfeDirBlockSize[Index];
				pDfb->dfb_NumFree = MaxDfes = afpDfeNumDirBlocks[Index];
				DirEntrySize = sizeof(DIRENTRY);
			}
			else
			{
				AfpLinkDoubleAtHead(afpFileDfePartialBlockHead[Index],
									pDfb,
									dfb_Next,
									dfb_Prev);
				DfeSize = afpDfeFileBlockSize[Index];
				pDfb->dfb_NumFree = MaxDfes = afpDfeNumFileBlocks[Index];
				DirEntrySize = 0;
			}

			ASSERT(QUAD_SIZED(DfeSize));
			pDfb->dfb_fDir = fDir;
			pDfb->dfb_Age = 0;

			// Initialize the list of free dfentries
			for (i = 0, pDfEntry = pDfb->dfb_FreeHead = (PDFENTRY)((PBYTE)pDfb + sizeof(DFEBLOCK));
				 i < MaxDfes;
				 i++, pDfEntry = pDfEntry->dfe_NextFree)
			{
				pDfEntry->dfe_NextFree = (i == (MaxDfes - 1)) ?
											NULL :
											(PDFENTRY)((PBYTE)pDfEntry + DfeSize);
				pDfEntry->dfe_pDirEntry = fDir ?
								pDfEntry->dfe_pDirEntry = (PDIRENTRY)((PCHAR)pDfEntry+sizeof(DFENTRY)) : NULL;
				pDfEntry->dfe_UnicodeName.Buffer = (PWCHAR)((PCHAR)pDfEntry+
															DirEntrySize+
															sizeof(DFENTRY));
				pDfEntry->dfe_UnicodeName.MaximumLength = UnicodeSize;
			}
		}
        else
        {
			DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_ERR,
					("afpAllocDfe: AfpAllocateVirtualMemoryPage failed\n"));

            AFPLOG_ERROR(AFPSRVMSG_VIRTMEM_ALLOC_FAILED,
                         STATUS_INSUFFICIENT_RESOURCES,
                         NULL,
                         0,
                         NULL);
        }
	}

	if (pDfb != NULL)
	{
		PDFEBLOCK	pTmp;

		ASSERT(VALID_DFB(pDfb));

		pDfEntry = pDfb->dfb_FreeHead;
		ASSERT(VALID_DFE(pDfEntry));
		ASSERT(pDfb->dfb_fDir ^ (pDfEntry->dfe_pDirEntry == NULL));
#if	DBG
		afpDfeAllocCount ++;
#endif
		pDfb->dfb_FreeHead = pDfEntry->dfe_NextFree;
		pDfb->dfb_NumFree --;

		//
		// If the block is now empty (completely used), unlink it from here and move it
		// to the Used list.
		//
		if (pDfb->dfb_NumFree == 0)
		{
			AfpUnlinkDouble(pDfb, dfb_Next, dfb_Prev);
			if (fDir)
			{
				AfpLinkDoubleAtHead(afpDirDfeUsedBlockHead[Index],
									pDfb,
									dfb_Next,
									dfb_Prev);
			}
			else
			{
				AfpLinkDoubleAtHead(afpFileDfeUsedBlockHead[Index],
									pDfb,
									dfb_Next,
									dfb_Prev);
			}
		}

		pDfEntry->dfe_UnicodeName.Length = 0;
	}

	AfpSwmrRelease(&afpDfeBlockLock);

#ifdef	PROFILING
	AfpGetPerfCounter(&TimeE);
	TimeD.QuadPart = TimeE.QuadPart - TimeS.QuadPart;
	INTERLOCKED_ADD_LARGE_INTGR(&AfpServerProfile->perf_DFEAllocTime,
								 TimeD,
								 &AfpStatisticsLock);
#endif
	if ((pDfEntry != NULL) &&
		(pDfEntry->dfe_pDirEntry != NULL))
	{
		// For a directory ZERO out the directory entry
		RtlZeroMemory(&pDfEntry->dfe_pDirEntry->de_ChildDir, sizeof(DIRENTRY));
	}

	return pDfEntry;
}


/***	afpFreeDfe
 *
 *	Return a DFE to the allocation block.
 *
 *	LOCKS:	afpDfeBlockLock (SWMR, Exclusive)
 */
LOCAL VOID FASTCALL
afpFreeDfe(
	IN	PDFENTRY	pDfEntry
)
{
	PDFEBLOCK	pDfb;
	USHORT		NumBlks, index;
#ifdef	PROFILING
	TIME		TimeS, TimeE, TimeD;

	INTERLOCKED_INCREMENT_LONG(&AfpServerProfile->perf_DFEFreeCount);
	AfpGetPerfCounter(&TimeS);
#endif

	PAGED_CODE( );

	// NOTE: The following code *depends* on the fact that we allocate DFBs as
	//		 64K blocks and also that these are allocated *at* 64K boundaries
	//		 This lets us *cheaply* get to the owning DFB from the DFE.
	pDfb = (PDFEBLOCK)((ULONG_PTR)pDfEntry & ~(PAGE_SIZE-1));
	ASSERT(VALID_DFB(pDfb));
	ASSERT(pDfb->dfb_fDir ^ (pDfEntry->dfe_pDirEntry == NULL));

	AfpSwmrAcquireExclusive(&afpDfeBlockLock);

#if	DBG
	afpDfeAllocCount --;
#endif

	index = USIZE_TO_INDEX(pDfEntry->dfe_UnicodeName.MaximumLength);
	NumBlks = (pDfb->dfb_fDir) ? afpDfeNumDirBlocks[index] : afpDfeNumFileBlocks[index];

	ASSERT((pDfb->dfb_fDir && (pDfb->dfb_NumFree < NumBlks)) ||
		   (!pDfb->dfb_fDir && (pDfb->dfb_NumFree < NumBlks)));

	DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_INFO,
			("AfpFreeDfe: Returning pDfEntry %lx to Block %lx, size %d\n",
			pDfEntry, pDfb, pDfEntry->dfe_UnicodeName.MaximumLength));

	pDfb->dfb_NumFree ++;
	pDfEntry->dfe_NextFree = pDfb->dfb_FreeHead;
	pDfb->dfb_FreeHead = pDfEntry;

	if (pDfb->dfb_NumFree == 1)
	{
		LONG		Index;

		//
		// The block is now partially free (it used to be completely used). move it to the partial list.
		//

		Index = USIZE_TO_INDEX(pDfEntry->dfe_UnicodeName.MaximumLength);
		AfpUnlinkDouble(pDfb, dfb_Next, dfb_Prev);
		if (pDfb->dfb_fDir)
		{
			AfpLinkDoubleAtHead(afpDirDfePartialBlockHead[Index],
								pDfb,
								dfb_Next,
								dfb_Prev);
		}
		else
		{
			AfpLinkDoubleAtHead(afpFileDfePartialBlockHead[Index],
								pDfb,
								dfb_Next,
								dfb_Prev);
		}
	}
	else if (pDfb->dfb_NumFree == NumBlks)
	{
		LONG		Index;

		//
		// The block is now completely free (used to be partially used). move it to the free list
		//

		Index = USIZE_TO_INDEX(pDfEntry->dfe_UnicodeName.MaximumLength);
		pDfb->dfb_Age = 0;
		AfpUnlinkDouble(pDfb, dfb_Next, dfb_Prev);

		if (AfpServerState == AFP_STATE_STOP_PENDING)
		{
			DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_WARN,
					("afpFreeDfe: Freeing Block %lx\n", pDfb));
			AfpFreeVirtualMemoryPage(pDfb);
#if	DBG
			afpDfbAllocCount --;
#endif
		}

		else
		{
			if (pDfb->dfb_fDir)
			{
				AfpLinkDoubleAtHead(afpDirDfeFreeBlockHead[Index],
									pDfb,
									dfb_Next,
									dfb_Prev);
			}
			else
			{
				AfpLinkDoubleAtHead(afpFileDfeFreeBlockHead[Index],
									pDfb,
									dfb_Next,
									dfb_Prev);
			}
		}
	}

	AfpSwmrRelease(&afpDfeBlockLock);
#ifdef	PROFILING
	AfpGetPerfCounter(&TimeE);
	TimeD.QuadPart = TimeE.QuadPart - TimeS.QuadPart;
	INTERLOCKED_ADD_LARGE_INTGR(&AfpServerProfile->perf_DFEFreeTime,
								 TimeD,
								 &AfpStatisticsLock);
#endif
}


/***	afpDfeBlockAge
 *
 *	Age out Dfe Blocks
 *
 *	LOCKS:	afpDfeBlockLock (SWMR, Exclusive)
 */
AFPSTATUS FASTCALL
afpDfeBlockAge(
	IN	PPDFEBLOCK	ppBlockHead
)
{
	int			index, MaxDfes;
	PDFEBLOCK	pDfb;

	PAGED_CODE( );

	AfpSwmrAcquireExclusive(&afpDfeBlockLock);

	for (index = 0; index < MAX_BLOCK_TYPE; index++)
	{
		pDfb = ppBlockHead[index];
		if (pDfb != NULL)
		{
			MaxDfes = pDfb->dfb_fDir ? afpDfeNumDirBlocks[index] : afpDfeNumFileBlocks[index];
		}

		while (pDfb != NULL)
		{
			PDFEBLOCK	pFree;

			ASSERT(VALID_DFB(pDfb));

			pFree = pDfb;
			pDfb = pDfb->dfb_Next;

			ASSERT (pFree->dfb_NumFree == MaxDfes);

			DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_WARN,
					("afpDfeBlockAge: Aging Block %lx, Size %d\n", pFree,
					pFree->dfb_fDir ? afpDfeDirBlockSize[index] : afpDfeFileBlockSize[index]));
			if (++(pFree->dfb_Age) >= MAX_BLOCK_AGE)
			{
#ifdef	PROFILING
				INTERLOCKED_INCREMENT_LONG( &AfpServerProfile->perf_DFEAgeCount);
#endif
				DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_WARN,
						("afpDfeBlockAge: Freeing Block %lx, Size %d\n", pFree,
						pDfb->dfb_fDir ? afpDfeDirBlockSize[index] : afpDfeFileBlockSize[index]));
				AfpUnlinkDouble(pFree, dfb_Next, dfb_Prev);
				AfpFreeVirtualMemoryPage(pFree);
#if	DBG
				afpDfbAllocCount --;
#endif
			}
		}
	}

	AfpSwmrRelease(&afpDfeBlockLock);

	return AFP_ERR_REQUEUE;
}


/***	AfpInitIdDb
 *
 *	This routine initializes the memory image (and all related volume descriptor
 *	fields) of the ID index database for a new volume.  The entire tree is
 *  scanned so all the file/dir cached info can be read in and our view of
 *  the volume tree will be complete.  If an index database already exists
 *  on the disk for the volume root directory, that stream is read in. If this
 *	is a newly created volume, the Afp_IdIndex stream is created on the root of
 *	the volume.  If this is a CDFS volume, only the memory image is initialized.
 *
 *	The IdDb is not locked since the volume is still 'in transition' and not
 *	accessed by anybody.
 */
NTSTATUS FASTCALL
AfpInitIdDb(
	IN	PVOLDESC    pVolDesc,
    OUT BOOLEAN    *pfNewVolume,
    OUT BOOLEAN    *pfVerifyIndex
)
{
	NTSTATUS		Status;
	ULONG			CreateInfo;
	FILESYSHANDLE	fshIdDb;
    IDDBHDR         IdDbHdr;
    BOOLEAN         fLogEvent=FALSE;


	PAGED_CODE( );

	DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_INFO,
			("AfpInitIdDb: Initializing Id Database...\n"));

    *pfNewVolume = FALSE;

	do
	{
		afpInitializeIdDb(pVolDesc);

		// if this is not a CDFS volume, attempt to create the ID DB header
		// stream.  If it already exists, open it and read it in.
		if (IS_VOLUME_NTFS(pVolDesc))
		{
			// Force the scavenger to write out the IdDb and header when the
			// volume is successfully added
			pVolDesc->vds_Flags |= VOLUME_IDDBHDR_DIRTY;

			Status = AfpIoCreate(&pVolDesc->vds_hRootDir,
								AFP_STREAM_IDDB,
								&UNullString,
								FILEIO_ACCESS_READWRITE,
								FILEIO_DENY_WRITE,
								FILEIO_OPEN_FILE_SEQ,
								FILEIO_CREATE_INTERNAL,
								FILE_ATTRIBUTE_NORMAL,
								False,
								NULL,
								&fshIdDb,
								&CreateInfo,
								NULL,
								NULL,
								NULL);

			if (!NT_SUCCESS(Status))
			{
				DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_ERR,
					("AfpInitIdDb: AfpIoCreate failed with %lx\n", Status));
                ASSERT(0);

                fLogEvent = TRUE;
				break;
			}

			if (CreateInfo == FILE_OPENED)
			{
				// read in the existing header. If we fail, just start from scratch
				Status = afpReadIdDb(pVolDesc, &fshIdDb, pfVerifyIndex);
				if (!NT_SUCCESS(Status) || (pVolDesc->vds_pDfeRoot == NULL))
					CreateInfo = FILE_CREATED;
			}

			if (CreateInfo == FILE_CREATED)
			{
				// add the root and parent of root to the idindex
				// and initialize a new header
				Status = afpSeedIdDb(pVolDesc);
                *pfNewVolume = TRUE;
			}
			else if (CreateInfo != FILE_OPENED)
			{
				DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_ERR,
					("AfpInitIdDb: unexpected create action 0x%lx\n", CreateInfo));
				ASSERTMSG("Unexpected Create Action\n", 0); // this should never happen
                fLogEvent = TRUE;
				Status = STATUS_UNSUCCESSFUL;
			}

			AfpIoClose(&fshIdDb);

            //
            // write back the IdDb header to the file, but with bad signature.
            // If server shuts down, the correct signature will be
            // written.  If macfile is closed down using "net stop macfile"
            // signature is corrupted with a different type
            // If cool boot/bugcheck, a third type
            // During volume startup, we will know from the signature, 
            // whether to rebuild completely, read iddb but verify or
            // not rebuild at all
            //

            if (NT_SUCCESS(Status))
            {

				DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_ERR,
					("AfpInitIdDb: ***** Corrupting IDDB header ***** \n"));

                AfpVolDescToIdDbHdr(pVolDesc, &IdDbHdr);
            
                IdDbHdr.idh_Signature = AFP_SERVER_SIGNATURE_INITIDDB;

                AfpVolumeUpdateIdDbAndDesktop(pVolDesc,FALSE,FALSE,&IdDbHdr);
            }

		}
		else
		{
			// its CDFS, just initialize the memory image of the IdDB
			Status = afpSeedIdDb(pVolDesc);
            *pfNewVolume = TRUE;
		}

	} while (False);

	if (fLogEvent)
	{
		AFPLOG_ERROR(AFPSRVMSG_INIT_IDDB,
					 Status,
					 NULL,
					 0,
					 &pVolDesc->vds_Name);
		Status = STATUS_UNSUCCESSFUL;
	}

	return Status;
}


/***	afpSeedIdDb
 *
 *	This routine adds the 'parent of root' and the root directory entries
 *	to a newly created ID index database (the memory image of the iddb).
 *
**/
LOCAL NTSTATUS FASTCALL
afpSeedIdDb(
	IN	PVOLDESC pVolDesc
)
{
	PDFENTRY		pDfEntry;
	AFPTIME			CurrentTime;
	AFPINFO			afpinfo;
	FILESYSHANDLE	fshAfpInfo, fshComment, fshData;
	DWORD			i, crinfo, Attr;
	FINDERINFO		FinderInfo;
	NTSTATUS		Status = STATUS_SUCCESS;

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_INFO,
			("afpSeedIdDb: Creating new Id Database...\n"));

	do
	{
		pDfEntry = AfpFindDfEntryById(pVolDesc,
									  AFP_ID_PARENT_OF_ROOT,
									  DFE_DIR);
		ASSERT (pDfEntry != NULL);

		// add the root directory to the id index
		if ((pDfEntry = AfpAddDfEntry(pVolDesc,
									  pDfEntry,
									  &pVolDesc->vds_Name,
									  True,
									  AFP_ID_ROOT)) == NULL )
		{
			Status = STATUS_NO_MEMORY;
			break;
		}
		pVolDesc->vds_pDfeRoot = pDfEntry;	// Initialize pointer to root.

		// Attempt to open the comment stream. If it succeeds, set a flag in
		// the DFE indicating that this thing does indeed have a comment.
		if (NT_SUCCESS(AfpIoOpen(&pVolDesc->vds_hRootDir,
								 AFP_STREAM_COMM,
								 FILEIO_OPEN_FILE,
								 &UNullString,
								 FILEIO_ACCESS_NONE,
								 FILEIO_DENY_NONE,
								 False,
								 &fshComment)))
		{
			DFE_SET_COMMENT(pDfEntry);
			AfpIoClose(&fshComment);
		}

		// Get the directory information for volume root dir. Do not get the
		// mod-time. See below.
		Status = AfpIoQueryTimesnAttr(&pVolDesc->vds_hRootDir,
									  &pDfEntry->dfe_CreateTime,
									  NULL,
									  &Attr);
		// Setup up root directories Last ModTime such that it will
		// get enumerated.
        AfpConvertTimeFromMacFormat(BEGINNING_OF_TIME,
									&pDfEntry->dfe_LastModTime);

		ASSERT(NT_SUCCESS(Status));

		pDfEntry->dfe_NtAttr = (USHORT)Attr & FILE_ATTRIBUTE_VALID_FLAGS;

		if (IS_VOLUME_NTFS(pVolDesc))
		{
			if (NT_SUCCESS(Status = AfpCreateAfpInfo(&pVolDesc->vds_hRootDir,
													 &fshAfpInfo,
													 &crinfo)))
			{
				if ((crinfo == FILE_CREATED) ||
					(!NT_SUCCESS(AfpReadAfpInfo(&fshAfpInfo, &afpinfo))))
				{
					Status = AfpSlapOnAfpInfoStream(NULL,
													NULL,
													&pVolDesc->vds_hRootDir,
													&fshAfpInfo,
													AFP_ID_ROOT,
													True,
													NULL,
													&afpinfo);
				}
				else
				{
					// Just make sure the afp ID is ok, preserve the rest
					if (afpinfo.afpi_Id != AFP_ID_ROOT)
					{
						afpinfo.afpi_Id = AFP_ID_ROOT;
						AfpWriteAfpInfo(&fshAfpInfo, &afpinfo);
					}
				}
				AfpIoClose(&fshAfpInfo);

				pDfEntry->dfe_AfpAttr = afpinfo.afpi_Attributes;
				pDfEntry->dfe_FinderInfo = afpinfo.afpi_FinderInfo;
				if (pVolDesc->vds_Flags & AFP_VOLUME_HAS_CUSTOM_ICON)
				{
					// Don't bother writing back to disk since we do not
					// try to keep this in sync in the permanent afpinfo
					// stream with the actual existence of the icon<0d> file.
					pDfEntry->dfe_FinderInfo.fd_Attr1 |= FINDER_FLAG_HAS_CUSTOM_ICON;
				}
				pDfEntry->dfe_BackupTime = afpinfo.afpi_BackupTime;
				DFE_OWNER_ACCESS(pDfEntry) = afpinfo.afpi_AccessOwner;
				DFE_GROUP_ACCESS(pDfEntry) = afpinfo.afpi_AccessGroup;
				DFE_WORLD_ACCESS(pDfEntry) = afpinfo.afpi_AccessWorld;
			}
		}
		else // CDFS
		{
			RtlZeroMemory(&pDfEntry->dfe_FinderInfo, sizeof(FINDERINFO));

			if (IS_VOLUME_CD_HFS(pVolDesc))
			{
				Status = AfpIoOpen(&pVolDesc->vds_hRootDir,
							 AFP_STREAM_DATA,
							 FILEIO_OPEN_DIR,
							 &UNullString,
							 FILEIO_ACCESS_NONE,
							 FILEIO_DENY_NONE,
							 False,
							 &fshData);
				if (!NT_SUCCESS(Status))
				{
				    DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_ERR,
					  ("afpSeedIdDb: AfpIoOpeno failed with %lx for CD_HFS\n", Status));
				    break;
				}

				AfpIoClose(&fshData);
			}
			pDfEntry->dfe_BackupTime = BEGINNING_OF_TIME;
			DFE_OWNER_ACCESS(pDfEntry) = (DIR_ACCESS_SEARCH | DIR_ACCESS_READ);
			DFE_GROUP_ACCESS(pDfEntry) = (DIR_ACCESS_SEARCH | DIR_ACCESS_READ);
			DFE_WORLD_ACCESS(pDfEntry) = (DIR_ACCESS_SEARCH | DIR_ACCESS_READ);
			pDfEntry->dfe_AfpAttr = 0;
		}
	} while (False);

	return Status;
}


/***	AfpFreeIdIndexTables
 *
 *	Free the allocated memory for the volume id index tables. The volume is
 *	about to be deleted. Ensure that either the volume is readonly or it is
 *	clean i.e. the scavenger threads have written it back.
 *
 */
VOID FASTCALL
AfpFreeIdIndexTables(
	IN	PVOLDESC pVolDesc
)
{
	DWORD	i;
    struct _DirFileEntry ** DfeDirBucketStart;
    struct _DirFileEntry ** DfeFileBucketStart;

	PAGED_CODE( );

	ASSERT (IS_VOLUME_RO(pVolDesc) ||
			(pVolDesc->vds_pOpenForkDesc == NULL));

	// Traverse each of the hashed indices and free the entries.
	// Need only traverse the overflow links. Ignore other links.
	// JH - Do not bother if we are here during shutdown
	if (AfpServerState != AFP_STATE_SHUTTINGDOWN)
	{
		PDFENTRY pDfEntry, pFree;

        AfpSwmrAcquireExclusive(&pVolDesc->vds_IdDbAccessLock);

        DfeFileBucketStart = pVolDesc->vds_pDfeFileBucketStart;

        if (DfeFileBucketStart)
        {
		    for (i = 0; i < pVolDesc->vds_FileHashTableSize; i++)
		    {
			    for (pDfEntry = DfeFileBucketStart[i];
				    pDfEntry != NULL;
				    NOTHING)
			    {
    				ASSERT(VALID_DFE(pDfEntry));

    				pFree = pDfEntry;
				    pDfEntry = pDfEntry->dfe_NextOverflow;
				    FREE_DFE(pFree);
			    }
			    DfeFileBucketStart[i] = NULL;
		    }
        }

        DfeDirBucketStart = pVolDesc->vds_pDfeDirBucketStart;

        if (DfeDirBucketStart)
        {
		    for (i = 0; i < pVolDesc->vds_DirHashTableSize; i++)
		    {
    			for (pDfEntry = DfeDirBucketStart[i];
				    pDfEntry != NULL;
				    NOTHING)
			    {
    				ASSERT(VALID_DFE(pDfEntry));

				    pFree = pDfEntry;
				    pDfEntry = pDfEntry->dfe_NextOverflow;
				    FREE_DFE(pFree);
			    }
			    DfeDirBucketStart[i] = NULL;
		    }
        }

		RtlZeroMemory(pVolDesc->vds_pDfeCache,
					  IDINDEX_CACHE_ENTRIES * sizeof(PDFENTRY));

        AfpSwmrRelease(&pVolDesc->vds_IdDbAccessLock);
	}
}


/***	afpRenameInvalidWin32Name
 *
 */
VOID
afpRenameInvalidWin32Name(
	IN	PFILESYSHANDLE		phRootDir,
	IN	BOOLEAN				IsDir,
	IN	PUNICODE_STRING		pName
)
{
	FILESYSHANDLE	Fsh;
	NTSTATUS		rc;
	WCHAR			wc;

	DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_ERR,
			("afpRenameInvalidWin32Name: renaming on the fly %Z\n", pName));

	// Rename it now
	if (NT_SUCCESS(AfpIoOpen(phRootDir,
							 AFP_STREAM_DATA,
							 IsDir ? FILEIO_OPEN_DIR : FILEIO_OPEN_FILE,
							 pName,
							 FILEIO_ACCESS_DELETE,
							 FILEIO_DENY_NONE,
							 False,
							 &Fsh)))
	{
		DWORD	NtAttr;

		// Before we attempt a rename, check if the RO bit is set. If it is
		// reset it temporarily.
		rc = AfpIoQueryTimesnAttr(&Fsh, NULL, NULL, &NtAttr);
		ASSERT(NT_SUCCESS(rc));

		if (NtAttr & FILE_ATTRIBUTE_READONLY)
		{
			rc = AfpIoSetTimesnAttr(&Fsh,
									NULL,
									NULL,
									0,
									FILE_ATTRIBUTE_READONLY,
									NULL,
									NULL);
			ASSERT(NT_SUCCESS(rc));
		}

		// Convert the name back to UNICODE so that munging happens !!!
		wc = pName->Buffer[(pName->Length - 1)/sizeof(WCHAR)];
		if (wc == UNICODE_SPACE)
			pName->Buffer[(pName->Length - 1)/sizeof(WCHAR)] = AfpMungedUnicodeSpace;
		if (wc == UNICODE_PERIOD)
			pName->Buffer[(pName->Length - 1)/sizeof(WCHAR)] = AfpMungedUnicodePeriod;

		rc = AfpIoMoveAndOrRename(&Fsh,
								  NULL,
								  pName,
								  NULL,
								  NULL,
								  NULL,
								  NULL,
								  NULL);
		ASSERT(NT_SUCCESS(rc));

		// Set the RO Attr back if it was set to begin with
		if (NtAttr & FILE_ATTRIBUTE_READONLY)
		{
			rc = AfpIoSetTimesnAttr(&Fsh,
									NULL,
									NULL,
									FILE_ATTRIBUTE_READONLY,
									0,
									NULL,
									NULL);
			ASSERT(NT_SUCCESS(rc));
		}

		AfpIoClose(&Fsh);
	}
}


LONG	afpVirtualMemoryCount = 0;
LONG	afpVirtualMemorySize = 0;

/***	AfpAllocVirtualMemory
 *
 *	This is a wrapper over NtAllocateVirtualMemory.
 */
PBYTE FASTCALL
AfpAllocateVirtualMemoryPage(
	IN	VOID
)
{
	PBYTE		pMem = NULL;
	NTSTATUS	Status;
    PBLOCK64K   pCurrBlock;
    PBLOCK64K   pTmpBlk;
    SIZE_T      Size64K;
    DWORD       i, dwMaxPages;


    Size64K = BLOCK_64K_ALLOC;
    dwMaxPages = (BLOCK_64K_ALLOC/PAGE_SIZE);
    pCurrBlock = afp64kBlockHead;

    //
    // if we have never allocated a 64K block as yet, or we don't have one that
    // has any free page(s) in it, allocate a new block!
    //
    if ((pCurrBlock == NULL) || (pCurrBlock->b64_PagesFree == 0))
    {
        pCurrBlock = (PBLOCK64K)AfpAllocNonPagedMemory(sizeof(BLOCK64K));
        if (pCurrBlock == NULL)
        {
            return(NULL);
        }

	    ExInterlockedIncrementLong(&afpVirtualMemoryCount, &AfpStatisticsLock);
	    ExInterlockedAddUlong(&afpVirtualMemorySize, (ULONG)Size64K, &(AfpStatisticsLock.SpinLock));
	    Status = NtAllocateVirtualMemory(NtCurrentProcess(),
		    							 &pMem,
			    						 0L,
				    					 &Size64K,
					    				 MEM_COMMIT,
						    			 PAGE_READWRITE);
        if (NT_SUCCESS(Status))
        {
            ASSERT(pMem != NULL);

#if DBG
            afpDfe64kBlockCount++;
#endif

            pCurrBlock->b64_Next = afp64kBlockHead;
            pCurrBlock->b64_BaseAddress = pMem;
            pCurrBlock->b64_PagesFree = dwMaxPages;
            for (i=0; i<dwMaxPages; i++)
            {
                pCurrBlock->b64_PageInUse[i] = FALSE;
            }
            afp64kBlockHead = pCurrBlock;

        }
        else
        {
            AfpFreeMemory(pCurrBlock);
            return(NULL);
        }
    }


    //
    // if we came this far, we are guaranteed that pCurrBlock is pointing to a
    // block that has at least one page free
    //


    ASSERT ((pCurrBlock != NULL) &&
            (pCurrBlock->b64_PagesFree > 0) &&
            (pCurrBlock->b64_PagesFree <= dwMaxPages));

    // find out which page is free
    for (i=0; i<dwMaxPages; i++)
    {
        if (pCurrBlock->b64_PageInUse[i] == FALSE)
        {
            break;
        }
    }

    ASSERT(i < dwMaxPages);

    pCurrBlock->b64_PagesFree--;
    pCurrBlock->b64_PageInUse[i] = TRUE;
    pMem = ((PBYTE)pCurrBlock->b64_BaseAddress) + (i * PAGE_SIZE);


    //
    // if this 64kblock has no more free pages in it, move it to a spot after
    // all the blocks that have some pages free in it.  For that, we first
    // find the guy who has no pages free in him and move this block after him
    //
    if (pCurrBlock->b64_PagesFree == 0)
    {
        pTmpBlk = pCurrBlock->b64_Next;

        if (pTmpBlk != NULL)
        {
            while (1)
            {
                // found a guy who has no free page in it?
                if (pTmpBlk->b64_PagesFree == 0)
                {
                    break;
                }
                // is this the last guy on the list?
                if (pTmpBlk->b64_Next == NULL)
                {
                    break;
                }
                pTmpBlk = pTmpBlk->b64_Next;
            }
        }

        // if we found a block
        if (pTmpBlk)
        {
            ASSERT(afp64kBlockHead == pCurrBlock);

            afp64kBlockHead = pCurrBlock->b64_Next;
            pCurrBlock->b64_Next = pTmpBlk->b64_Next;
            pTmpBlk->b64_Next = pCurrBlock;
        }
    }

	return pMem;
}


VOID FASTCALL
AfpFreeVirtualMemoryPage(
	IN	PVOID	pBuffer
)
{
	NTSTATUS	Status;
    PBYTE       BaseAddr;
    PBLOCK64K   pCurrBlock;
    PBLOCK64K   pPrevBlk;
    SIZE_T      Size64K;
    DWORD       i, dwMaxPages, dwPageNum, Offset;


    dwMaxPages = (BLOCK_64K_ALLOC/PAGE_SIZE);
    Size64K = BLOCK_64K_ALLOC;
    pCurrBlock = afp64kBlockHead;
    pPrevBlk = afp64kBlockHead;

    BaseAddr = (PBYTE)((ULONG_PTR)pBuffer & ~(BLOCK_64K_ALLOC - 1));
    Offset = (DWORD)(((PBYTE)pBuffer - BaseAddr));

    dwPageNum = Offset/PAGE_SIZE;

    ASSERT(Offset < BLOCK_64K_ALLOC);

    while (pCurrBlock != NULL)
    {
        if (pCurrBlock->b64_BaseAddress == BaseAddr)
        {
            break;
        }

        pPrevBlk = pCurrBlock;
        pCurrBlock = pCurrBlock->b64_Next;
    }

    ASSERT(pCurrBlock->b64_BaseAddress == BaseAddr);

    pCurrBlock->b64_PageInUse[dwPageNum] = FALSE;
    pCurrBlock->b64_PagesFree++;

    //
    // if all the pages in this block are unused, then it's time to free this block
    // after removing from the list
    //
    if (pCurrBlock->b64_PagesFree == dwMaxPages)
    {
        // is our guy the first (and potentially the only one) on the list?
        if (afp64kBlockHead == pCurrBlock)
        {
            afp64kBlockHead = pCurrBlock->b64_Next;
        }
        // nope, there are others and we're somewhere in the middle (or end)
        else
        {
            pPrevBlk->b64_Next = pCurrBlock->b64_Next;
        }

        AfpFreeMemory(pCurrBlock);

	    ExInterlockedDecrementLong(&afpVirtualMemoryCount, &AfpStatisticsLock);
	    ExInterlockedAddUlong(&afpVirtualMemorySize,
                              -1*((ULONG)Size64K),
                              &(AfpStatisticsLock.SpinLock));
	    Status = NtFreeVirtualMemory(NtCurrentProcess(),
		    						 (PVOID *)&BaseAddr,
			    					 &Size64K,
				    				 MEM_RELEASE);

#if DBG
        ASSERT(afpDfe64kBlockCount > 0);
        afpDfe64kBlockCount--;
#endif

    }

    //
    // if a page became available in this block for the first time, move this
    // block to the front of the list (unless it already is there)
    //
    else if (pCurrBlock->b64_PagesFree == 1)
    {
        if (afp64kBlockHead != pCurrBlock)
        {
            pPrevBlk->b64_Next = pCurrBlock->b64_Next;
            pCurrBlock->b64_Next = afp64kBlockHead;
            afp64kBlockHead = pCurrBlock;
        }
    }
}

#ifdef	AGE_DFES

/***	AfpAgeDfEntries
 *
 *	Age out DfEntries out of the Id database. The Files in directories which have not been
 *	accessed for VOLUME_IDDB_AGE_DELAY are aged out. The directories are marked so that
 *	they will be enumerated when they are hit next.
 *
 *	LOCKS:	vds_idDbAccessLock(SWMR, Exclusive)
 */
VOID FASTCALL
AfpAgeDfEntries(
	IN	PVOLDESC	pVolDesc
)
{
	PDFENTRY	pDfEntry, *Stack = NULL;
	LONG		i, StackPtr = 0;
	AFPTIME		Now;

	ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

	AfpGetCurrentTimeInMacFormat(&Now);
	AfpSwmrAcquireExclusive(&pVolDesc->vds_IdDbAccessLock);

	// Potentially all of the files can be aged out. Allocate 'stack' space
	// for all of the directory DFEs
	if ((Stack = (PDFENTRY *)
				AfpAllocNonPagedMemory(pVolDesc->vds_NumDirDfEntries*sizeof(PDFENTRY))) != NULL)
	{
		// 'Prime' the stack of Dfe's
		Stack[StackPtr++] = pVolDesc->vds_pDfeRoot;

		while (StackPtr > 0)
		{
			PDFENTRY	pDir;

			pDfEntry = Stack[--StackPtr];

			ASSERT(DFE_IS_DIRECTORY(pDfEntry));
			if ((pDfEntry->dfe_AfpId >= AFP_FIRST_DIRID) &&
				(pDfEntry->dfe_pDirEntry->de_ChildForkOpenCount == 0)	 &&
				((Now - pDfEntry->dfe_pDirEntry->de_LastAccessTime) > VOLUME_IDDB_AGE_DELAY))
			{
				PDFENTRY	pFile, pNext;

				DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_INFO,
						("AfpAgeDfEntries: Aging out directory %Z\n", &pDfEntry->dfe_UnicodeName));
				// This directory's files need to be nuked
				pDfEntry->dfe_FileOffspring = 0;
				pDfEntry->dfe_Flags &= ~DFE_FLAGS_FILES_CACHED;

				for (i = 0; i < MAX_CHILD_HASH_BUCKETS; i++)
				{
					for (pFile = pDfEntry->dfe_pDirEntry->de_ChildFile[i];
						 pFile != NULL;
						 pFile = pNext)
					{
						pNext = pFile->dfe_NextSibling;

						// Unlink it from the hash buckets
						AfpUnlinkDouble(pFile,
										dfe_NextOverflow,
										dfe_PrevOverflow);
						// Nuke it from the cache if it is there
						if (pVolDesc->vds_pDfeCache[HASH_CACHE_ID(pFile->dfe_AfpId)] == pFile)
						{
							pVolDesc->vds_pDfeCache[HASH_CACHE_ID(pFile->dfe_AfpId)] = NULL;
						}
						// Finally free it
						FREE_DFE(pFile);
					}
					pDfEntry->dfe_pDirEntry->de_ChildFile[i] = NULL;
				}
			}

#if 0
			// NOTE: Should we leave the tree under 'Network Trash Folder' alone ?
			if (pDfEntry->dfe_AfpId == AFP_ID_NETWORK_TRASH)
				continue;
#endif
			// Pick up all the child directories of this directory and 'push' them on stack
			for (pDir = pDfEntry->dfe_pDirEntry->de_ChildDir;
				 pDir != NULL;
				 pDir = pDir->dfe_NextSibling)
			{
				Stack[StackPtr++] = pDir;
			}
		}

		AfpFreeMemory(Stack);
	}

	AfpSwmrRelease(&pVolDesc->vds_IdDbAccessLock);
}

#endif

#if	DBG

NTSTATUS FASTCALL
afpDumpDfeTree(
	IN	PVOID	Context
)
{
	PVOLDESC	pVolDesc;
	PDFENTRY	pDfEntry, pChild;
	LONG		i, StackPtr;

	if (afpDumpDfeTreeFlag)
	{
		afpDumpDfeTreeFlag = 0;

		for (pVolDesc = AfpVolumeList; pVolDesc != NULL; pVolDesc = pVolDesc->vds_Next)
		{
			StackPtr = 0;
			DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_INFO,
					("Volume : %Z\n", &pVolDesc->vds_Name));
			afpDfeStack[StackPtr++] = pVolDesc->vds_pDfeRoot;

			while (StackPtr > 0)
			{
				pDfEntry = afpDfeStack[--StackPtr];
				afpDisplayDfe(pDfEntry);
				for (i = 0; i < MAX_CHILD_HASH_BUCKETS; i++)
				{
					for (pChild = pDfEntry->dfe_pDirEntry->de_ChildFile[i];
						 pChild != NULL;
						 pChild = pChild->dfe_NextSibling)
					{
						afpDisplayDfe(pChild);
					}
				}
				for (pChild = pDfEntry->dfe_pDirEntry->de_ChildDir;
					 pChild != NULL;
					 pChild = pChild->dfe_NextSibling)
				{
					afpDfeStack[StackPtr++] = pChild;
				}
			}
		}
	}

	return AFP_ERR_REQUEUE;
}


VOID FASTCALL
afpDisplayDfe(
	IN	PDFENTRY	pDfEntry
)
{
	USHORT	i;

	// Figure out the indenting. One space for every depth unit of parent
	// If this is a directory, a '+' and then the dir name
	// If this is a file, then just the file name

	for (i = 0; i < (pDfEntry->dfe_Parent->dfe_DirDepth + 1); i++)
	{
		DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_INFO,
				("%c   ", 0xB3));
	}
	if (pDfEntry->dfe_NextSibling == NULL)
	{
		DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_INFO,
				("%c%c%c%c", 0xC0, 0xC4, 0xC4, 0xC4));
	}
	else
	{
		DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_INFO,
				("%c%c%c%c", 0xC3, 0xC4, 0xC4, 0xC4));
	}
	DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_INFO,
			("%Z ", &pDfEntry->dfe_UnicodeName));

	if (pDfEntry->dfe_Flags & DFE_FLAGS_DIR)
	{
		DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_INFO,
				("(%c, %lx, Id = %lx)\n", 0x9F, pDfEntry, pDfEntry->dfe_AfpId));
	}
	else
	{
		DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_INFO,
				("(%c, %lx, Id = %lx)\n", 0x46, pDfEntry, pDfEntry->dfe_AfpId));
	}
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\server\idindex.h ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	idindex.h

Abstract:

	This module contains the file and directory id structures.

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	25 Apr 1992		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef _IDINDEX_
#define _IDINDEX_

// AFP_IDDBHDR_VERSION2 was an experimental version.
#define AFP_IDDBHDR_VERSION1	0x00010000
#define AFP_IDDBHDR_VERSION2	0x00020000
#define AFP_IDDBHDR_VERSION3	0x00030000
#define AFP_IDDBHDR_VERSION4	0x00040000
#define AFP_IDDBHDR_VERSION5	0x00050000
#define AFP_IDDBHDR_VERSION		AFP_IDDBHDR_VERSION5

typedef struct _IdDbHeader				// Database header
{
	DWORD		idh_Signature;			// Signature
	DWORD		idh_Version;			// Version number
	DWORD		idh_LastId;				// Highest id that is assigned
	AFPTIME		idh_CreateTime;			// Creation time for this volume
	AFPTIME		idh_ModifiedTime;		// Modified time for this volume
	AFPTIME		idh_BackupTime;			// Backup time for this volume
} IDDBHDR, *PIDDBHDR;
// IdDb header is followed by a ULONG count of entries, then the DISKENTRies

#define VALID_DFE(pDfe)		((pDfe) != NULL)

struct _DfeBlock;
struct _DirFileEntry;

#define	MAX_CHILD_HASH_BUCKETS	6

typedef	struct _DirEntry
{
	// NOTE: Keep the ChildDir and ChildFile entries together and in this order
	//		 The code in AfpAddDfEntry depends on this to efficiently zero it out
	//		 Also de_ChildDir is accessed as de_ChildFile[-1] !!!
	struct _DirFileEntry *	de_ChildDir;		// First child in the dir list
	struct _DirFileEntry *	de_ChildFile[MAX_CHILD_HASH_BUCKETS];
												// File 'children' are hashed for faster lookup
	DWORD					de_Access;			// Combined access bits
#ifdef	AGE_DFES
	AFPTIME					de_LastAccessTime;	// Time when this DFE was last accessed
												// Valid for directories only
	LONG					de_ChildForkOpenCount;// Count of open forks within this directory
#endif
} DIRENTRY, *PDIRENTRY;

// Owner access mask (SFI vs. SFO)
#define	DE_OWNER_ACCESS(_pDE)	*((PBYTE)(&(_pDE)->de_Access) + 0)
// Group access mask (SFI vs. SFO)
#define	DE_GROUP_ACCESS(_pDE)	*((PBYTE)(&(_pDE)->de_Access) + 1)
// World access mask (SFI vs. SFO)
#define	DE_WORLD_ACCESS(_pDE)	*((PBYTE)(&(_pDE)->de_Access) + 2)

typedef struct _DirFileEntry
{
	// The dfe_Overflow is overloaded with dfe_NextFree for use by the block
	// allocation package for the DFEs.
#define	dfe_NextFree		dfe_NextOverflow
	struct _DirFileEntry *	dfe_NextOverflow;	// Overflow links
	struct _DirFileEntry **	dfe_PrevOverflow;	// Overflow links
	struct _DirFileEntry *	dfe_NextSibling;	// Next sibling.
	struct _DirFileEntry **	dfe_PrevSibling;	// Previous sibling.
	struct _DirFileEntry *	dfe_Parent;			// Parent entry

	DWORD					dfe_AfpId;			// Afp FileId or DirId (from AfpInfo)
	AFPTIME					dfe_BackupTime;		// Backup time for the file/dir (from AfpInfo)
												// (Volume backup time is stored
												// in the AFP_IdIndex stream)
	AFPTIME					dfe_CreateTime;		// Creation time

	TIME					dfe_LastModTime;	// Last modify time (as a LARGE_INTEGER)

	SHORT					dfe_DirDepth;		// Parent of root at -1, root at 0
	USHORT					dfe_Flags;			// file, dir or file with id

	USHORT					dfe_NtAttr;			// NT Attributes (FILE_ATTRIBUTE_VALID_FLAGS)
	USHORT					dfe_AfpAttr;		// Attributes mask (From AfpInfo)

	union
	{
		// File specific information
		struct									// For Files Only
		{
			DWORD			dfe_DataLen;		// Data fork length
			DWORD			dfe_RescLen;		// Resource fork length
		};
		// Directory specific information
		struct									// For Directories Only
		{
			DWORD			dfe_DirOffspring;	// count of dir offspring
			DWORD			dfe_FileOffspring;	// count of file offspring
		};
	};
	FINDERINFO				dfe_FinderInfo;		// Finder Info (32 bytes) (from AfpInfo)

	// NOTE: When Dfes are copied as a structure, the fields below are NOT TO BE COPIED.
	//		 The fields above should be.
#define	dfe_CopyUpto		dfe_UnicodeName

	UNICODE_STRING			dfe_UnicodeName;	// 'Munged' Unicode Name of the entity

	DWORD					dfe_NameHash;		// Hash value for the upcased munged Unicode name

	// For directories, the DirEntry structure follows this structure. The space for
	// this is allocated immediately after the DFENTRY structure and before the space
	// for the name strings. For files it is NULL. This pointer should not be copied
	// as well !!!
	PDIRENTRY				dfe_pDirEntry;		// Directory related fields
												// NULL for files
} DFENTRY, *PDFENTRY;

// Owner access mask (SFI vs. SFO)
#define	DFE_OWNER_ACCESS(_pDFE)	*((PBYTE)(&(_pDFE)->dfe_pDirEntry->de_Access) + 0)
// Group access mask (SFI vs. SFO)
#define	DFE_GROUP_ACCESS(_pDFE)	*((PBYTE)(&(_pDFE)->dfe_pDirEntry->de_Access) + 1)
// World access mask (SFI vs. SFO)
#define	DFE_WORLD_ACCESS(_pDFE)	*((PBYTE)(&(_pDFE)->dfe_pDirEntry->de_Access) + 2)

typedef	struct _EnumIdAndType
{
	DWORD			eit_Id;
	DWORD			eit_Flags;
} EIT, *PEIT;

// There is the result of enumeration of a directory for this session and is stored
// within the connection descriptor. This is purely for performance reasons. This is
// deleted whenever an api other than AfpEnumerate is called and a result is around.
typedef	struct _EnumDir
{
	DWORD			ed_ParentDirId;		// Anchor point
	DWORD			ed_Bitmap;			// Combination of file & dir bitmaps
	LONG			ed_ChildCount;		// Count of children of the dir being enumerated
	AFPTIME			ed_TimeStamp;		// Time at which created

	PEIT			ed_pEit;			// list of actual entries
	ANSI_STRING		ed_PathName;		// This is the name as passed by the client
										// and is not normalised.
	USHORT			ed_BadCount;		// Count of failed entities
	BYTE			ed_PathType;		// Long name or short name
} ENUMDIR, *PENUMDIR;

typedef	struct _CatSearchSpec
{
	BYTE			__StructLength;
	BYTE			__FillerOrFileDir;
	// The rest of the parameters follow
} CATSEARCHSPEC, *PCATSEARCHSPEC;

// Must be 16 bytes as per AfpCatSearch API
typedef struct _CatalogPosition
{
	USHORT			cp_Flags;			// if zero, then start search from beginning
	USHORT			cp_usPad1;
	DWORD			cp_CurParentId;
	DWORD			cp_NextFileId;
	AFPTIME			cp_TimeStamp;
} CATALOGPOSITION, *PCATALOGPOSITION;

#define CATFLAGS_SEARCHING_FILES		0x0001
#define CATFLAGS_SEARCHING_DIRCHILD		0x0002
#define CATFLAGS_SEARCHING_SIBLING		0x0004
#define	CATFLAGS_WRITELOCK_REQUIRED 	0x0008
#define	CATFLAGS_VALID					(CATFLAGS_SEARCHING_FILES		|	\
										 CATFLAGS_SEARCHING_DIRCHILD	|	\
										 CATFLAGS_SEARCHING_SIBLING		|	\
										 CATFLAGS_WRITELOCK_REQUIRED)

// Maximum time that a mac can hold onto a catsearch position and still
// have the search pickup from there instead of the beginning of the catalog
#define MAX_CATSEARCH_TIME				3600	// In seconds


// DFE_FLAGS_xxxx values for dfe_Flags field of DFENTRY structure
#define DFE_FLAGS_FILE_WITH_ID			0x0100
#define DFE_FLAGS_FILE_NO_ID			0x0200
#define DFE_FLAGS_DIR					0x0400
#define DFE_FLAGS_DFBITS				(DFE_FLAGS_FILE_WITH_ID | \
										 DFE_FLAGS_FILE_NO_ID	| \
										 DFE_FLAGS_DIR | \
                                         DFE_FLAGS_HAS_COMMENT)
#define DFE_FLAGS_HAS_COMMENT			0x0800
#define DFE_FLAGS_INIT_COMPLETED        0x20
#define DFE_FLAGS_ENUMERATED			0x8000

// Encode the child and sibling pointers
#define DFE_FLAGS_HAS_CHILD				0x1000	// Used for reading in IdDb from disk
#define DFE_FLAGS_HAS_SIBLING			0x2000	// Used for reading in IdDb from disk
#define DFE_FLAGS_CSENCODEDBITS			(DFE_FLAGS_HAS_CHILD | DFE_FLAGS_HAS_SIBLING | DFE_FLAGS_HAS_COMMENT)
#define DFE_FLAGS_NAMELENBITS			0x001F	// Encodes the length of the longname
												// which is 31 *characters* max

#define DFE_FLAGS_VALID_DSKBITS			(DFE_FLAGS_CSENCODEDBITS	| \
										 DFE_FLAGS_NAMELENBITS		| \
										 DFE_FLAGS_HAS_COMMENT)

// Valid only for directories when their files have been enumerated from disk
// and now all have cached DFEs in the IDDB tree structure
#define DFE_FLAGS_FILES_CACHED 			0x4000

// DAlreadyOpen and RAlreadyOpen flags for a File
#define DFE_FLAGS_R_ALREADYOPEN			0x0040
#define	DFE_FLAGS_D_ALREADYOPEN			0x0080
#define DFE_FLAGS_OPEN_BITS				(DFE_FLAGS_D_ALREADYOPEN | \
										 DFE_FLAGS_R_ALREADYOPEN)

	
typedef struct _DiskEntry
{
	DWORD		dsk_AfpId;
	AFPTIME		dsk_CreateTime;		// File Creation time
	TIME		dsk_LastModTime;	// Last modify time
	FINDERINFO	dsk_FinderInfo;		// Finder Info (32 bytes) (from AfpInfo)
	AFPTIME		dsk_BackupTime;		// Backup time for the file/dir (from AfpInfo)
									// (Volume backup time is stored
									// in the AFP_IdIndex stream)

	union
	{
		DWORD	dsk_DataLen;		// Data fork length
		DWORD	dsk_Access;			// Combined access rights
	};
	DWORD		dsk_RescLen;		// Resource fork length
	USHORT		dsk_Flags;			// DFE_FLAGS_XXXX
	USHORT		dsk_AfpAttr;		// Attributes mask (From AfpInfo)
	USHORT		dsk_NtAttr;			// From FileAttributes

	USHORT		dsk_Signature;		// AFP_DISKENTRY_SIGNATURE
	WCHAR		dsk_Name[2];		// Longname in 'munged' Unicode will follow and be padded
									// out, if necessary, to DWORD boundry (max 64 bytes)
} DISKENTRY, *PDISKENTRY;

// "::" = 0x3a3a  illegal name character
#define AFP_DISKENTRY_SIGNATURE			0x3a3a // illegal name character

// size of buffer used to read-in/write-out the IdDb entries from/to disk
#define	IDDB_UPDATE_BUFLEN				(16*1024)

// Round the length to 4*N
#define DWLEN(_b)	(((_b) + sizeof(DWORD) - 1) & ~(sizeof(DWORD) - 1))

// #define	DFE_IS_DIRECTORY(_pDFE)		(((_pDFE)->dfe_Flags & DFE_FLAGS_DIR) ? True : False)
#define	DFE_IS_DIRECTORY(_pDFE)			((_pDFE)->dfe_pDirEntry != NULL)

// #define	DFE_IS_FILE(_pDFE)			(((_pDFE)->dfe_Flags & (DFE_FLAGS_FILE_NO_ID | DFE_FLAGS_FILE_WITH_ID)) ? True : False)
#define	DFE_IS_FILE(_pDFE)				((_pDFE)->dfe_pDirEntry == NULL)

#define	DFE_IS_FILE_WITH_ID(_pDFE)		(((_pDFE)->dfe_Flags & DFE_FLAGS_FILE_WITH_ID) ? True : False)

#define	DFE_IS_ROOT(_pDFE)				((_pDFE)->dfe_AfpId == AFP_ID_ROOT)

#define	DFE_IS_PARENT_OF_ROOT(_pDFE)	((_pDFE)->dfe_AfpId == AFP_ID_PARENT_OF_ROOT)

#define DFE_IS_NWTRASH(_pDFE)			((_pDFE)->dfe_AfpId == AFP_ID_NETWORK_TRASH)

#define	DFE_SET_DIRECTORY(_pDFE, _ParentDepth)				\
	{														\
		((_pDFE)->dfe_DirDepth = _ParentDepth + 1);			\
		((_pDFE)->dfe_Flags |= DFE_FLAGS_DIR);				\
	}

#define	DFE_SET_FILE(_pDFE)				((_pDFE)->dfe_Flags |= DFE_FLAGS_FILE_NO_ID)

#define	DFE_SET_FILE_ID(_pDFE)			((_pDFE)->dfe_Flags |= DFE_FLAGS_FILE_WITH_ID)

#define	DFE_CLR_FILE_ID(_pDFE)			((_pDFE)->dfe_Flags &= ~DFE_FLAGS_FILE_WITH_ID)

// update just the AFPinfo in the dfentry
#define DFE_UPDATE_CACHED_AFPINFO(_pDFE, pAfpInfo)				\
	{															\
		(_pDFE)->dfe_BackupTime = (pAfpInfo)->afpi_BackupTime;	\
		(_pDFE)->dfe_FinderInfo = (pAfpInfo)->afpi_FinderInfo;	\
		(_pDFE)->dfe_AfpAttr = (pAfpInfo)->afpi_Attributes;		\
		if ((_pDFE)->dfe_Flags & DFE_FLAGS_DIR)					\
		{														\
			DFE_OWNER_ACCESS(_pDFE) = (pAfpInfo)->afpi_AccessOwner;	\
			DFE_GROUP_ACCESS(_pDFE) = (pAfpInfo)->afpi_AccessGroup;	\
			DFE_WORLD_ACCESS(_pDFE) = (pAfpInfo)->afpi_AccessWorld;	\
		}														\
	}


#define DFE_SET_COMMENT(_pDFE)			((_pDFE)->dfe_Flags |= DFE_FLAGS_HAS_COMMENT)

#define DFE_CLR_COMMENT(_pDFE)			((_pDFE)->dfe_Flags &= ~DFE_FLAGS_HAS_COMMENT)

// Check to see if this entry was enumerated on an NTFS directory
#define DFE_HAS_BEEN_SEEN(_pDFE)		((_pDFE)->dfe_Flags & DFE_FLAGS_ENUMERATED)

#define DFE_MARK_UNSEEN(_pDFE)			((_pDFE)->dfe_Flags &= ~DFE_FLAGS_ENUMERATED)

#define DFE_MARK_AS_SEEN(_pDFE)			((_pDFE)->dfe_Flags |= DFE_FLAGS_ENUMERATED)

// Directories only
#define DFE_CHILDREN_ARE_PRESENT(_pDFE) ((_pDFE)->dfe_Flags & DFE_FLAGS_FILES_CACHED)

// Directories only
#define DFE_MARK_CHILDREN_PRESENT(_pDFE) ((_pDFE)->dfe_Flags |= DFE_FLAGS_FILES_CACHED)

#define	DFE_FILE_HAS_SIBLING(_pDFE, _fbi, _pfHasSibling)			\
	{																\
		DWORD		_i;												\
		PDIRENTRY	_pDirEntry;										\
																	\
		*(_pfHasSibling) = False;									\
		if (((_pDFE)->dfe_NextSibling != NULL)	||					\
			((_pDFE)->dfe_Parent->dfe_pDirEntry->de_ChildDir != NULL)) \
		{															\
			*(_pfHasSibling) = True;								\
		}															\
		else														\
		{															\
			_pDirEntry = (_pDFE)->dfe_Parent->dfe_pDirEntry;	 	\
			ASSERT(_pDirEntry != NULL);								\
			for (_i = (_fbi) + 1;									\
				 _i < MAX_CHILD_HASH_BUCKETS;						\
				 _i++)												\
			{														\
				if (_pDirEntry->de_ChildFile[_i] != NULL)			\
				{													\
					*(_pfHasSibling) = True;						\
					break;											\
				}													\
			}														\
		}															\
	}

#define	HASH_DIR_ID(Id, _pVolDesc)		((Id) & ((_pVolDesc)->vds_DirHashTableSize-1))
#define	HASH_FILE_ID(Id, _pVolDesc)		((Id) & ((_pVolDesc)->vds_FileHashTableSize-1))
#define	HASH_CACHE_ID(Id)				((Id) & (IDINDEX_CACHE_ENTRIES-1))

#define	QUAD_SIZED(_X_)			(((_X_) % 8) == 0)

// Values for access checking
#define	ACCESS_READ						1
#define	ACCESS_WRITE					2

extern
NTSTATUS
AfpDfeInit(
	VOID
);

extern
VOID
AfpDfeDeInit(
	VOID
);

extern
PDFENTRY
AfpFindDfEntryById(
	IN	struct _VolDesc *			pVolDesc,
	IN	DWORD						Id,
	IN	DWORD						EntityMask
);

extern
PDFENTRY
AfpFindEntryByUnicodeName(
	IN	struct _VolDesc *			pVolDesc,
	IN	PUNICODE_STRING				pName,
	IN	DWORD						PathType,
	IN	PDFENTRY					pDfeParent,
	IN	DWORD						EntityMask
);

extern
PDFENTRY
AfpAddDfEntry(
	IN	struct _VolDesc *			pVolDesc,
	IN	PDFENTRY					pDfeParent,
	IN	PUNICODE_STRING				pUName,
	IN	BOOLEAN						Directory,
	IN	DWORD						AfpId			OPTIONAL
);

extern
PDFENTRY
AfpRenameDfEntry(
	IN	struct _VolDesc *			pVolDesc,
	IN	PDFENTRY					pDfEntry,
	IN	PUNICODE_STRING				pNewName
);

extern
PDFENTRY
AfpMoveDfEntry(				
	IN	struct _VolDesc *			pVolDesc,
	IN	PDFENTRY					pDfEntry,
	IN	PDFENTRY					pNewParentDfE,
	IN	PUNICODE_STRING				pNewName		OPTIONAL
);

extern
VOID FASTCALL
AfpDeleteDfEntry(
	IN	struct _VolDesc *			pVolDesc,
	IN	PDFENTRY					pDfE
);

extern
VOID
AfpExchangeIdEntries(
	IN	struct _VolDesc *			pVolDesc,
	IN	DWORD						AfpId1,
	IN	DWORD						AfpId2
);

extern
VOID FASTCALL
AfpPruneIdDb(
	IN	struct _VolDesc *			pVolDesc,
	IN	PDFENTRY					pDfeTarget
);

extern
NTSTATUS FASTCALL
AfpInitIdDb(
	IN	struct _VolDesc *			pVolDesc,
    OUT BOOLEAN         *           pfNewVolume,
    OUT BOOLEAN         *           pfVerifyIndex
);

extern
VOID FASTCALL
AfpFreeIdIndexTables(
	IN	struct _VolDesc *			pVolDesc
);

extern
AFPSTATUS
AfpEnumerate(
	IN	struct _ConnDesc *			pConnDesc,
	IN	DWORD						ParentDirId,
	IN	PANSI_STRING				pPath,
	IN	DWORD						BitmapF,
	IN	DWORD						BitmapD,
	IN	BYTE						PathType,
	IN	DWORD						DFFlags,
	OUT PENUMDIR *					ppEnumDir
);

extern
AFPSTATUS
AfpSetDFFileFlags(
	IN	struct _VolDesc *			pVolDesc,
	IN	DWORD						AfpId,
	IN	DWORD						FlagSet		OPTIONAL,
	IN	BOOLEAN						SetFileId,
	IN	BOOLEAN						ClrFileId
);

extern
VOID
AfpChangeNotifyThread(
	IN	PVOID						pContext
);

extern
VOID FASTCALL
AfpProcessChangeNotify(		
	IN	struct _VolumeNotify *		pVolNotify
);

extern
VOID
AfpQueuePrivateChangeNotify(
	IN	struct _VolDesc *			pVolDesc,
	IN	PUNICODE_STRING				pName,
	IN	PUNICODE_STRING				pPath,
	IN	DWORD						ParentId
);

extern
BOOLEAN FASTCALL
AfpShouldWeIgnoreThisNotification(
	IN	struct _VolumeNotify *		pVolNotify
);

extern
VOID
AfpQueueOurChange(
	IN	struct _VolDesc *			pVolDesc,
	IN	DWORD						Action,
	IN	PUNICODE_STRING				pPath,
	IN  PUNICODE_STRING				pParentPath	OPTIONAL
);

extern
VOID
AfpDequeueOurChange(
		IN struct _VolDesc *   		pVolDesc,
		IN DWORD                    Action,
		IN PUNICODE_STRING          pPath,
		IN PUNICODE_STRING          pParentPath OPTIONAL
);

extern
NTSTATUS FASTCALL
AddToDelayedNotifyList(
	IN  struct _VolDesc *			pVolDesc,
	IN  PUNICODE_STRING				pUName
);

extern
NTSTATUS
RemoveFromDelayedNotifyList(
	IN  struct _VolDesc *			pVolDesc,
	IN  PUNICODE_STRING				pUName,
	IN  PFILE_NOTIFY_INFORMATION    pFNInfo
);

extern
NTSTATUS
CheckAndProcessDelayedNotify(
	IN  struct _VolDesc *			pVolDesc,
	IN  PUNICODE_STRING				pUName,
	IN  PUNICODE_STRING				pUNewname,
	IN  PUNICODE_STRING				pUParent
);

extern
VOID
AfpCacheParentModTime(
	IN	struct _VolDesc *			pVolDesc,
	IN	PFILESYSHANDLE				pHandle		OPTIONAL,	// if pPath not supplied
	IN	PUNICODE_STRING				pPath		OPTIONAL,	// if pHandle not supplied
	IN	PDFENTRY					pDfeParent	OPTIONAL,	// if ParentId not supplied
	IN	DWORD						ParentId	OPTIONAL	// if pDfeParent not supplied
);

extern
AFPSTATUS
AfpCatSearch(
	IN	struct _ConnDesc *			pConnDesc,
	IN	PCATALOGPOSITION			pCatPosition,
	IN	DWORD						Bitmap,
	IN	DWORD						FileBitmap,
	IN	DWORD						DirBitmap,
	IN	struct _FileDirParms *		pFDParm1,
	IN	struct _FileDirParms *		pFDParm2,
	IN	PUNICODE_STRING				pMatchString	OPTIONAL,
	IN OUT	PDWORD					pCount,
	IN	SHORT						Buflen,
	OUT	PSHORT						pSizeLeft,
	OUT	PBYTE						pResults,
	OUT	PCATALOGPOSITION			pNewCatPosition
);

#ifdef	AGE_DFES

extern
VOID FASTCALL
AfpAgeDfEntries(
	IN	struct _VolDesc *			pVolDesc
);

#endif

#define	REENUMERATE		   			0x0001
#define	GETDIRSKELETON				0x0002
#define	GETFILES	    			0x0004
#define	GETENTIRETREE   			0x0008

extern
NTSTATUS
AfpCacheDirectoryTree(
	IN	struct _VolDesc *			pVolDesc,
	IN	PDFENTRY					pDFETreeRoot,
	IN	DWORD						Method,
	IN	PFILESYSHANDLE				phRootDir		OPTIONAL,
	IN	PUNICODE_STRING				pDirPath		OPTIONAL
);

extern
AFPSTATUS FASTCALL
AfpOurChangeScavenger(
	IN	struct _VolDesc *			pVolDesc
);

extern
VOID FASTCALL
AfpFlushIdDb(
	IN	struct _VolDesc *			pVolDesc,
	IN	PFILESYSHANDLE				phIdDb
);

extern
VOID
AfpGetDirFileHashSizes(
	IN	struct _VolDesc *	pVolDesc,
    OUT PDWORD              pdwDirHashSz,
    OUT PDWORD              pdwFileHashSz
);

#ifdef IDINDEX_LOCALS

#define	afpConvertBasicToBothDirInfo(_pFBasInfo, _pFBDInfo)			\
{																	\
	(_pFBDInfo)->CreationTime = (_pFBasInfo)->CreationTime;			\
	(_pFBDInfo)->LastWriteTime = (_pFBasInfo)->LastWriteTime;		\
	(_pFBDInfo)->ChangeTime = (_pFBasInfo)->ChangeTime;				\
	(_pFBDInfo)->FileAttributes = (_pFBasInfo)->FileAttributes;		\
	(_pFBDInfo)->EndOfFile.QuadPart = 0;																\
}

#undef	EQU
#ifdef	_IDDB_GLOBALS_
#define	IDDBGLOBAL
#define	EQU				=
#else
#define	IDDBGLOBAL		extern
#define	EQU				; / ## /
#endif

// This bit on a Notify action indicates it is a simulated notify. Volume
// modified time is not updated when such a notify comes in
#define	AFP_ACTION_PRIVATE		0x80000000

// DFEs come in four sizes. This helps in efficiently managing them in a block
// package (see later). THESE SIZES NEED TO BE 4*N, else we run into alignment
// faults on architectures that require it.
#define	DFE_INDEX_TINY			0
#define	DFE_INDEX_SMALL			1
#define	DFE_INDEX_MEDIUM		2
#define	DFE_INDEX_LARGE			3

//
// Make sure each of the sizes below (XXX_U) are multiple of 8
//
#define	DFE_SIZE_TINY			8		// These are lengths for ANSI names
#define	DFE_SIZE_SMALL			12		//		- ditto -
#define	DFE_SIZE_MEDIUM			20		//		- ditto -
#define	DFE_SIZE_LARGE			32		//		- ditto -	corres. to AFP_FILENAME_LEN

#define	DFE_SIZE_TINY_U			DFE_SIZE_TINY*sizeof(WCHAR)		// These are lengths for UNICODE names
#define	DFE_SIZE_SMALL_U		DFE_SIZE_SMALL*sizeof(WCHAR)	//		- ditto -
#define	DFE_SIZE_MEDIUM_U		DFE_SIZE_MEDIUM*sizeof(WCHAR)	//		- ditto -
#define	DFE_SIZE_LARGE_U		DFE_SIZE_LARGE*sizeof(WCHAR)	//		- ditto -	corres. to AFP_FILENAME_LEN

#define	ASIZE_TO_INDEX(_Size)												\
		(((_Size) <= DFE_SIZE_TINY) ? DFE_INDEX_TINY :						\
						(((_Size) <= DFE_SIZE_SMALL) ? DFE_INDEX_SMALL :	\
						 (((_Size) <= DFE_SIZE_MEDIUM) ? DFE_INDEX_MEDIUM : DFE_INDEX_LARGE)))

#define	USIZE_TO_INDEX(_Size)												\
		(((_Size) <= DFE_SIZE_TINY_U) ? DFE_INDEX_TINY :					\
						(((_Size) <= DFE_SIZE_SMALL_U) ? DFE_INDEX_SMALL :	\
						 (((_Size) <= DFE_SIZE_MEDIUM_U) ? DFE_INDEX_MEDIUM : DFE_INDEX_LARGE)))

#define	ALLOC_DFE(Index, fDir)	afpAllocDfe(Index, fDir)
#define FREE_DFE(pDfEntry)		afpFreeDfe(pDfEntry)


LOCAL DWORD FASTCALL
afpGetNextId(
	IN	struct _VolDesc *			pVolDesc
);

LOCAL
NTSTATUS FASTCALL
afpSeedIdDb(
	IN	struct _VolDesc *			pVolDesc
);

LOCAL
VOID
afpPackSearchParms(
	IN	PDFENTRY					pDfe,
	IN	DWORD						Bitmap,
	IN	PBYTE						pBuf
);

LOCAL
NTSTATUS FASTCALL
afpReadIdDb(
	IN	struct _VolDesc *			pVolDesc,
	IN	PFILESYSHANDLE				pfshIdDb,
	OUT	BOOLEAN         *           pfVerifyIndex
);

VOID
afpAddDfEntryAndCacheInfo(
	IN	struct _VolDesc *			pVolDesc,
	IN	PDFENTRY					pDfeParent,
	IN	PUNICODE_STRING				pUName,			// munged unicode name
	IN	PFILESYSHANDLE				pfshParentDir,	// open handle to parent directory
	IN	PFILE_BOTH_DIR_INFORMATION	pFBDInfo,		// from enumerate
	IN	PUNICODE_STRING				pNotifyPath,	// to filter out our own AFP_AfpInfo change notifies
	IN	PDFENTRY	*				ppDfEntry,
	IN	BOOLEAN						CheckDuplicate
);

VOID
afpVerifyDFE(
	IN	struct _VolDesc *			pVolDesc,
	IN	PDFENTRY					pDfeParent,
	IN	PUNICODE_STRING				pUName,			// munged unicode name
	IN	PFILESYSHANDLE				pfshParentDir,	// open handle to parent directory
	IN	PFILE_BOTH_DIR_INFORMATION	pFBDInfo,		// from enumerate
	IN	PUNICODE_STRING				pNotifyPath,	// to filter out our own AFP_AfpInfo change notifies
	IN	PDFENTRY	*				ppDfEntry
);

PDFENTRY
afpFindEntryByNtPath(
	IN	struct _VolDesc *			pVolDesc,
	IN	DWORD						ChangeAction,	// if ADDED then lookup parent DFE
	IN	PUNICODE_STRING				pPath,
	OUT PUNICODE_STRING				pParent,
	OUT PUNICODE_STRING				pTail
);

PDFENTRY
afpFindEntryByNtName(
	IN	struct _VolDesc *			pVolDesc,
	IN	PUNICODE_STRING				pName,
	IN	PDFENTRY					pDfeParent		// pointer to parent DFENTRY
);

VOID FASTCALL
afpProcessPrivateNotify(
	IN	struct _VolumeNotify *		pVolNotify
);

VOID FASTCALL
afpActivateVolume(
	IN	struct _VolDesc *			pVolDesc
);

VOID
afpRenameInvalidWin32Name(
	IN	PFILESYSHANDLE				phRootDir,
	IN	BOOLEAN						IsDir,
	IN PUNICODE_STRING				pName
);

#define	afpInitializeIdDb(_pVolDesc)									\
	{																	\
		AFPTIME		CurrentTime;										\
		PDFENTRY	pDfEntry;											\
																		\
		/* RO volumes don't use the network trash folder at all */		\
		(_pVolDesc)->vds_LastId	= AFP_ID_NETWORK_TRASH;					\
																		\
		AfpGetCurrentTimeInMacFormat(&CurrentTime);						\
		(_pVolDesc)->vds_CreateTime = CurrentTime;						\
		(_pVolDesc)->vds_ModifiedTime = CurrentTime;					\
		(_pVolDesc)->vds_BackupTime = BEGINNING_OF_TIME;				\
																		\
		/* Create a DFE for the root directory */						\
		afpCreateParentOfRoot(_pVolDesc, &pDfEntry);					\
	}


#ifdef AGE_DFES

#define	afpCreateParentOfRoot(_pVolDesc, _ppDfEntry)					\
	{																	\
		PDFENTRY	pDFE;												\
        struct _DirFileEntry ** _DfeDirBucketStart;                     \
																		\
		/*																\
		 * add the parent of root to the id index.						\
		 * This has to be done here										\
		 * (i.e. cannot call AfpAddDfEntry for parentofroot).			\
		 */																\
																		\
		if ((*(_ppDfEntry) = ALLOC_DFE(0, True)) != NULL)				\
		{																\
			pDFE = *(_ppDfEntry);										\
																		\
			(_pVolDesc)->vds_NumFileDfEntries = 0;						\
			(_pVolDesc)->vds_NumDirDfEntries = 0;						\
			pDFE->dfe_Flags = DFE_FLAGS_DIR | DFE_FLAGS_FILES_CACHED;	\
			pDFE->dfe_DirDepth = -1;									\
			pDFE->dfe_Parent = NULL;									\
			pDFE->dfe_NextOverflow = NULL;								\
																		\
			/* Initialize the DirEntry for ParentOfRoot */				\
			ASSERT((FIELD_OFFSET(DIRENTRY, de_ChildFile) -				\
					FIELD_OFFSET(DIRENTRY, de_ChildDir)) == sizeof(PVOID));\
																		\
			/* These fields are relevant to directories only */			\
			pDFE->dfe_pDirEntry->de_LastAccessTime = BEGINNING_OF_TIME;	\
			pDFE->dfe_pDirEntry->de_ChildForkOpenCount = 0;				\
																		\
			/*															\
			 * The parent of root has no siblings and this should		\
			 * never be referenced										\
			 */															\
			pDFE->dfe_NameHash = 0;										\
			pDFE->dfe_NextSibling = NULL;								\
			pDFE->dfe_PrevSibling = NULL;								\
			pDFE->dfe_AfpId = AFP_ID_PARENT_OF_ROOT;					\
			pDFE->dfe_DirOffspring = pDFE->dfe_FileOffspring = 0;		\
																		\
			/* link it into the hash buckets */							\
            _DfeDirBucketStart = (_pVolDesc)->vds_pDfeDirBucketStart;   \
			AfpLinkDoubleAtHead(_DfeDirBucketStart[HASH_DIR_ID(AFP_ID_PARENT_OF_ROOT,_pVolDesc)],\
								pDFE,									\
								dfe_NextOverflow,						\
								dfe_PrevOverflow);						\
		}																\
	}

#else

#define	afpCreateParentOfRoot(_pVolDesc, _ppDfEntry)					\
	{																	\
		PDFENTRY	pDfEntry;											\
        struct _DirFileEntry ** _DfeDirBucketStart;                     \
																		\
		/*																\
		 * add the parent of root to the id index.						\
		 * This has to be done here										\
		 *	(i.e. cannot call AfpAddDfEntry for parentofroot).			\
		 */																\
																		\
		if ((*(_ppDfEntry) = ALLOC_DFE(0, True)) != NULL)				\
		{																\
			pDfEntry = *(_ppDfEntry);									\
																		\
			(_pVolDesc)->vds_NumFileDfEntries = 0;						\
			(_pVolDesc)->vds_NumDirDfEntries = 0;						\
			pDfEntry->dfe_Flags = DFE_FLAGS_DIR | DFE_FLAGS_FILES_CACHED;\
			pDfEntry->dfe_DirDepth = -1;								\
			pDfEntry->dfe_Parent = NULL;								\
			pDfEntry->dfe_NextOverflow = NULL;							\
																		\
			/* Initialize the DirEntry for ParentOfRoot */				\
			ASSERT((FIELD_OFFSET(DIRENTRY, de_ChildFile) -				\
					FIELD_OFFSET(DIRENTRY, de_ChildDir)) == sizeof(PVOID));\
																		\
			/* The parent of root has no siblings and this should never be referenced */ \
			pDfEntry->dfe_NameHash = 0;									\
			pDfEntry->dfe_NextSibling = NULL;							\
			pDfEntry->dfe_PrevSibling = NULL;							\
			pDfEntry->dfe_AfpId = AFP_ID_PARENT_OF_ROOT;				\
			pDfEntry->dfe_DirOffspring = pDfEntry->dfe_FileOffspring = 0;\
																		\
			/* link it into the hash buckets */							\
            _DfeDirBucketStart = (_pVolDesc)->vds_pDfeDirBucketStart;   \
			AfpLinkDoubleAtHead(_DfeDirBucketStart[HASH_DIR_ID(AFP_ID_PARENT_OF_ROOT,_pVolDesc)],\
								pDfEntry,								\
								dfe_NextOverflow,						\
								dfe_PrevOverflow);						\
		}																\
	}

#endif

#define	afpHashUnicodeName(_pUnicodeName, _pHashValue)					\
	{																	\
		DWORD				j;											\
		UNICODE_STRING		upcaseName;									\
		WCHAR				buffer[AFP_LONGNAME_LEN+1];					\
		PDWORD				pbuf = NULL;								\
																		\
		AfpSetEmptyUnicodeString(&upcaseName, sizeof(buffer), buffer);	\
		RtlUpcaseUnicodeString(&upcaseName, _pUnicodeName, False);		\
		j = upcaseName.Length/sizeof(WCHAR);							\
		buffer[j] = UNICODE_NULL;										\
		pbuf = (PDWORD)buffer;											\
		j /= (sizeof(DWORD)/sizeof(WCHAR));								\
																		\
		for (*(_pHashValue) = 0; j > 0; j--, pbuf++)					\
		{																\
			*(_pHashValue) = (*(_pHashValue) << 3) + *pbuf;				\
		}																\
	}

#ifdef	SORT_DFE_BY_HASH
#define	afpFindDFEByUnicodeNameInSiblingList(_pVolDesc, _pDfeParent, _pName, _ppDfEntry, _EntityMask) \
	{																	\
		DWORD		NameHash; 											\
		PDFENTRY	pD, pF;												\
		BOOLEAN		Found, fFiles;										\
																		\
		afpHashUnicodeName(_pName, &NameHash);							\
																		\
		pD = (_pDfeParent)->dfe_pDirEntry->de_ChildDir;					\
		if (((_EntityMask) & (DFE_ANY | DFE_DIR)) == 0)					\
			pD = NULL;													\
																		\
		pF = NULL;														\
		if ((_EntityMask) & (DFE_ANY | DFE_FILE))						\
			pF = (_pDfeParent)->dfe_pDirEntry->de_ChildFile[NameHash % MAX_CHILD_HASH_BUCKETS];\
																		\
		*(_ppDfEntry) = pD;												\
		Found = fFiles = False;											\
		do																\
		{																\
			for (NOTHING;												\
				 *(_ppDfEntry) != NULL;									\
				 *(_ppDfEntry) = (*(_ppDfEntry))->dfe_NextSibling)		\
			{															\
				if ((*(_ppDfEntry))->dfe_NameHash < NameHash)			\
				{														\
					*(_ppDfEntry) = NULL;								\
					break;												\
				}														\
																		\
				if (((*(_ppDfEntry))->dfe_NameHash == NameHash)	&&		\
					EQUAL_UNICODE_STRING(&((*(_ppDfEntry))->dfe_UnicodeName), \
										 _pName,						\
										 True))							\
				{														\
					afpUpdateDfeAccessTime(_pVolDesc, *(_ppDfEntry));	\
					Found = True;										\
					break;												\
				}														\
			}															\
			if (Found)													\
				break;													\
																		\
			fFiles ^= True;												\
			if (fFiles)													\
			{															\
				*(_ppDfEntry) = pF;										\
			}															\
		} while (fFiles);												\
	}

#define	afpFindDFEByUnicodeNameInSiblingList_CS(_pVolDesc, _pDfeParent, _pName, _ppDfEntry, _EntityMask) \
	{																	\
		DWORD		NameHash; 											\
		PDFENTRY	pD, pF;												\
		BOOLEAN		Found, fFiles;										\
																		\
		afpHashUnicodeName(_pName, &NameHash);							\
																		\
		pD = (_pDfeParent)->dfe_pDirEntry->de_ChildDir;				 	\
		if (((_EntityMask) & (DFE_ANY | DFE_DIR)) == 0)					\
			pD = NULL;													\
																		\
		pF = NULL;														\
		if ((_EntityMask) & (DFE_ANY | DFE_FILE))						\
			pF = (_pDfeParent)->dfe_pDirEntry->de_ChildFile[NameHash % MAX_CHILD_HASH_BUCKETS];\
																		\
		*(_ppDfEntry) = pD;												\
		Found = fFiles = False;											\
		do																\
		{																\
			for (NOTHING;												\
				 *(_ppDfEntry) != NULL;									\
				 *(_ppDfEntry) = (*(_ppDfEntry))->dfe_NextSibling)		\
			{															\
				if ((*(_ppDfEntry))->dfe_NameHash < NameHash)			\
				{														\
					*(_ppDfEntry) = NULL;								\
					break;												\
				}														\
																		\
				if (((*(_ppDfEntry))->dfe_NameHash == NameHash)	&&		\
					EQUAL_UNICODE_STRING_CS(&((*(_ppDfEntry))->dfe_UnicodeName), _pName)) \
				{														\
					afpUpdateDfeAccessTime(_pVolDesc, *(_ppDfEntry));	\
					Found = True;										\
					break;												\
				}														\
			}															\
			if (Found)													\
				break;													\
																		\
			fFiles ^= True;												\
			if (fFiles)													\
			{															\
				*(_ppDfEntry) = pF;										\
			}															\
		} while (fFiles);												\
	}
#else
#define	afpFindDFEByUnicodeNameInSiblingList(_pVolDesc, _pDfeParent, _pName, _ppDfEntry, _EntityMask) \
	{																	\
		DWORD		NameHash; 											\
		PDFENTRY	pD, pF;												\
		BOOLEAN		Found, fFiles;										\
																		\
		afpHashUnicodeName(_pName, &NameHash);							\
																		\
		pD = (_pDfeParent)->dfe_pDirEntry->de_ChildDir;					\
		if (((_EntityMask) & (DFE_ANY | DFE_DIR)) == 0)					\
			pD = NULL;													\
																		\
		pF = NULL;														\
		if ((_EntityMask) & (DFE_ANY | DFE_FILE))						\
			pF = (_pDfeParent)->dfe_pDirEntry->de_ChildFile[NameHash % MAX_CHILD_HASH_BUCKETS];\
																		\
		*(_ppDfEntry) = pD;												\
		Found = fFiles = False;											\
		do																\
		{																\
			for (NOTHING;												\
				 *(_ppDfEntry) != NULL;									\
				 *(_ppDfEntry) = (*(_ppDfEntry))->dfe_NextSibling)		\
			{															\
				if (((*(_ppDfEntry))->dfe_NameHash == NameHash)	&&		\
					EQUAL_UNICODE_STRING(&((*(_ppDfEntry))->dfe_UnicodeName), \
										 _pName,						\
										 True))							\
				{														\
					afpUpdateDfeAccessTime(_pVolDesc, *(_ppDfEntry));	\
					Found = True;										\
					break;												\
				}														\
			}															\
			if (Found)													\
				break;													\
																		\
			fFiles ^= True;												\
			if (fFiles)													\
			{															\
				*(_ppDfEntry) = pF;										\
			}															\
		} while (fFiles);												\
	}

#define	afpFindDFEByUnicodeNameInSiblingList_CS(_pVolDesc, _pDfeParent, _pName, _ppDfEntry, _EntityMask) \
	{																	\
		DWORD		NameHash; 											\
		PDFENTRY	pD, pF;												\
		BOOLEAN		Found, fFiles;										\
																		\
		afpHashUnicodeName(_pName, &NameHash);							\
																		\
		pD = (_pDfeParent)->dfe_pDirEntry->de_ChildDir;				 	\
		if (((_EntityMask) & (DFE_ANY | DFE_DIR)) == 0)					\
			pD = NULL;													\
																		\
		pF = NULL;														\
		if ((_EntityMask) & (DFE_ANY | DFE_FILE))						\
			pF = (_pDfeParent)->dfe_pDirEntry->de_ChildFile[NameHash % MAX_CHILD_HASH_BUCKETS];\
																		\
		*(_ppDfEntry) = pD;												\
		Found = fFiles = False;											\
		do																\
		{																\
			for (NOTHING;												\
				 *(_ppDfEntry) != NULL;									\
				 *(_ppDfEntry) = (*(_ppDfEntry))->dfe_NextSibling)		\
			{															\
				if (((*(_ppDfEntry))->dfe_NameHash == NameHash)	&&		\
					EQUAL_UNICODE_STRING_CS(&((*(_ppDfEntry))->dfe_UnicodeName), _pName)) \
				{														\
					afpUpdateDfeAccessTime(_pVolDesc, *(_ppDfEntry));	\
					Found = True;										\
					break;												\
				}														\
			}															\
			if (Found)													\
				break;													\
																		\
			fFiles ^= True;												\
			if (fFiles)													\
			{															\
				*(_ppDfEntry) = pF;										\
			}															\
		} while (fFiles);												\
	}
#endif

#define	afpInsertDFEInSiblingList(_pDfeParent, _pDfEntry, _fDirectory)	\
	{																	\
		if (fDirectory)													\
		{																\
	        afpInsertDirDFEInSiblingList(_pDfeParent, _pDfEntry);		\
		}																\
		else															\
		{																\
	        afpInsertFileDFEInSiblingList(_pDfeParent, _pDfEntry);		\
		}																\
	}


#define	afpInsertFileDFEInSiblingList(_pDfeParent, _pDfEntry)			\
	{																	\
		DWORD		Index;												\
		PDFENTRY *	ppDfEntry;											\
																		\
		Index = (_pDfEntry)->dfe_NameHash % MAX_CHILD_HASH_BUCKETS;		\
		ppDfEntry = &(_pDfeParent)->dfe_pDirEntry->de_ChildFile[Index];	\
	    afpInsertInSiblingList(ppDfEntry,								\
							   (_pDfEntry));							\
	}


#define	afpInsertDirDFEInSiblingList(_pDfeParent, _pDfEntry)			\
	{																	\
		PDFENTRY *	ppDfEntry;											\
																		\
		ppDfEntry = &(_pDfeParent)->dfe_pDirEntry->de_ChildDir;			\
	    afpInsertInSiblingList(ppDfEntry,								\
							   (_pDfEntry));							\
	}

#ifdef	SORT_DFE_BY_HASH
#define	afpInsertInSiblingList(_ppHead, _pDfEntry)						\
	{																	\
		for (NOTHING;													\
			 *(_ppHead) != NULL;										\
			 (_ppHead) = &(*(_ppHead))->dfe_NextSibling)				\
		{																\
			if ((_pDfEntry)->dfe_NameHash > (*(_ppHead))->dfe_NameHash)	\
			{															\
				break;													\
			}															\
		}																\
		if (*(_ppHead) != NULL)											\
		{																\
			AfpInsertDoubleBefore(_pDfEntry,							\
								  *(_ppHead),							\
								  dfe_NextSibling,						\
								  dfe_PrevSibling);						\
		}																\
		else															\
		{																\
			*(_ppHead) = (_pDfEntry);									\
			(_pDfEntry)->dfe_NextSibling = NULL;						\
			(_pDfEntry)->dfe_PrevSibling = (_ppHead);					\
		}																\
	}
#else
#define	afpInsertInSiblingList(_ppHead, _pDfEntry)						\
	{																	\
		AfpLinkDoubleAtHead(*(_ppHead),									\
							(_pDfEntry),								\
							dfe_NextSibling,							\
							dfe_PrevSibling);							\
	}
#endif

#define	afpInsertDFEInHashBucket(_pVolDesc, _pDfEntry, _fDirectory, _pfS)\
	{																	\
		PDFENTRY	*ppTmp;												\
        struct _DirFileEntry ** _DfeDirBucketStart;                     \
        struct _DirFileEntry ** _DfeFileBucketStart;                    \
																		\
		afpUpdateDfeAccessTime(_pVolDesc, _pDfEntry);					\
		*(_pfS) = True;	/* Assume success */							\
                                                                        \
	  retry:															\
                                                                        \
        if (_fDirectory)                                                \
        {                                                               \
            _DfeDirBucketStart = (_pVolDesc)->vds_pDfeDirBucketStart;   \
            ppTmp = &_DfeDirBucketStart[HASH_DIR_ID((_pDfEntry)->dfe_AfpId,_pVolDesc)]; \
        }                                                               \
        else                                                            \
        {                                                               \
            _DfeFileBucketStart = (_pVolDesc)->vds_pDfeFileBucketStart;   \
            ppTmp = &_DfeFileBucketStart[HASH_FILE_ID((_pDfEntry)->dfe_AfpId,_pVolDesc)]; \
        }                                                               \
                                                                        \
		for (NOTHING;													\
			 *ppTmp != NULL;											\
			 ppTmp = &(*ppTmp)->dfe_NextOverflow)						\
		{																\
			ASSERT(VALID_DFE(*ppTmp));									\
			if ((_pDfEntry)->dfe_AfpId > (*ppTmp)->dfe_AfpId)			\
			{															\
				/* Found our slot */									\
				break;													\
			}															\
			if ((_pDfEntry)->dfe_AfpId == (*ppTmp)->dfe_AfpId)			\
			{															\
				/* Found a collision. Assign a new id and proceed */	\
				(_pDfEntry)->dfe_AfpId = afpGetNextId(_pVolDesc);		\
				if ((_pDfEntry)->dfe_AfpId == 0)						\
				{														\
					/* Uh-oh */											\
					*(_pfS) = False;									\
					DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_ERR,			\
							("afpInsertDFEInHashBucket: Collision & Id Overflow\n"));\
					break;												\
				}														\
				/* Write back the afpinfo stream with the new id */		\
				AfpUpdateIdInAfpInfo(_pVolDesc, _pDfEntry);				\
				goto retry;												\
			}															\
		}																\
		if (*(_pfS))													\
		{																\
			if (*ppTmp != NULL)											\
			{															\
				AfpInsertDoubleBefore((_pDfEntry),						\
									  *ppTmp,							\
									  dfe_NextOverflow,					\
									  dfe_PrevOverflow);				\
			}															\
			else														\
			{															\
				*ppTmp = _pDfEntry;										\
				(_pDfEntry)->dfe_PrevOverflow = ppTmp;					\
			}															\
			(_pVolDesc)->vds_pDfeCache[HASH_CACHE_ID((_pDfEntry)->dfe_AfpId)] = (_pDfEntry); \
		}																\
	}

#define	afpValidateDFEType(_pDfEntry, _EntityMask)						\
	{																	\
		if (((_EntityMask) & DFE_ANY) ||								\
			(((_EntityMask) & DFE_DIR) && DFE_IS_DIRECTORY(_pDfEntry)) || \
			(((_EntityMask) & DFE_FILE) && DFE_IS_FILE(_pDfEntry)))		\
			NOTHING;													\
		else															\
		{																\
			_pDfEntry = NULL;											\
		}																\
	}

/***	afpCheckDfEntry
 *
 *	When enumerating the disk during volume add, if a file/directory
 *	has an AfpId associated with it, then it is validated to see if it is
 *	within range as well as unique.  If there is a collision between AFPIds,
 *	a PC user must have copied (or restored) something from
 *	this volume, or a different volume (or server) that had the same AFPId,
 *	in which case we will give the new entity a different AFP Id;
 *	If there is not a collision between AFPIds, and the Id is larger than the
 *  last Id we know we assigned, then the new entity gets added with a new
 *  AFPId; else if the Id is within the range, we will just use its existing
 *  Id.
 *
 *	Discovered AFPId is:				Action for discovered entity in IdDb is:
 *	--------------------				----------------------------------------
 *	1) > last Id						Add a new entry, assign a new AFPId
 *
 *	2) Collides with existing Id:
 *		* Host copy occurred			Add a new entry, assign a new AFPId
 *
 *	3) < last Id						Insert this entity using same AFPId
 *
 *
 *	LOCKS_ASSUMED: vds_idDbAccessLock (SWMR, Exclusive)
 * VOID
 * afpCheckDfEntry(
 * 	IN	PVOLDESC		pVolDesc,
 * 	IN	PAFPINFO		pAfpInfo,	// AFP Info of the discovered entity
 * 	IN	PUNICODE_STRING pUName,		// Munged unicode name
 * 	IN	BOOLEAN			IsDir,		// is this thing a file or a directory?
 * 	IN	PDFENTRY		pParent,	// parent DFE of the discovered thing
 * 	OUT	PDFENTRY	*	ppDfEntry
 * );
 */
#define	afpCheckDfEntry(_pVolDesc, _AfpId, _pUName, _IsDir, _pParent, _ppDfEntry)	\
	{																	\
		PDFENTRY	pDfeNew;											\
																		\
		if (((_AfpId) > (_pVolDesc)->vds_LastId)	||					\
			((_AfpId) <= AFP_ID_NETWORK_TRASH)		||					\
			(AfpFindDfEntryById(_pVolDesc, _AfpId, DFE_ANY) != NULL))	\
		{																\
			/* add the item to the DB but assign it a new AFP Id */     \
			_AfpId = 0;												 	\
		}																\
																		\
		pDfeNew = AfpAddDfEntry(_pVolDesc,								\
								_pParent,								\
								_pUName,								\
								_IsDir,								 	\
								_AfpId);								\
																		\
		*(_ppDfEntry) = pDfeNew;										\
	}

#ifdef	AGE_DFES
#define	afpUpdateDfeAccessTime(_pVolDesc, _pDfEntry)					\
	{																	\
		if (IS_VOLUME_AGING_DFES(_pVolDesc))							\
		{																\
			if (DFE_IS_DIRECTORY(_pDfEntry))							\
				AfpGetCurrentTimeInMacFormat(&(_pDfEntry)->dfe_pDirEntry->de_LastAccessTime);\
			else AfpGetCurrentTimeInMacFormat(&(_pDfEntry)->dfe_Parent->dfe_pDirEntry->de_LastAccessTime);\
		}																\
	}
#else
#define	afpUpdateDfeAccessTime(pVolDesc, pDfEntry)
#endif

#define	afpMarkAllChildrenUnseen(_pDFETree)								\
	{																	\
		LONG		i = -1;												\
		PDFENTRY	pDFE;												\
																		\
		/*																\
		 * Even if this dir has not had its file children cached in		\
		 * yet, we still want to prune out any dead directory children	\
		 */																\
		for (pDFE = (_pDFETree)->dfe_pDirEntry->de_ChildDir;			\
			 True;														\
			 pDFE = (_pDFETree)->dfe_pDirEntry->de_ChildFile[i])		\
		{																\
			for (NOTHING;												\
				 pDFE != NULL;											\
				 pDFE = pDFE->dfe_NextSibling)							\
			{															\
				DFE_MARK_UNSEEN(pDFE);									\
			}															\
			if (++i == MAX_CHILD_HASH_BUCKETS)							\
				break;													\
		}																\
	}

#define	afpPruneUnseenChildren(_pVolDesc, _pDFETree)					\
	{																	\
		PDFENTRY	pDFE, *ppDfEntry;									\
		LONG		i;													\
																		\
		/*																\
		 * Go thru the list of children for this parent, and if there	\
		 * are any left that are not marked as seen, get rid of them.	\
		 */																\
		ppDfEntry = &(_pDFETree)->dfe_pDirEntry->de_ChildDir;			\
		i = -1;															\
		while (True)													\
		{																\
			while ((pDFE = *ppDfEntry) != NULL)							\
			{															\
				if (!DFE_HAS_BEEN_SEEN(pDFE))							\
				{														\
					DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_INFO,			\
							("afpPruneUnseenChildren: deleting nonexistant IdDb entry\n")); \
																		\
					AfpDeleteDfEntry(_pVolDesc, pDFE);					\
					continue;	/* make sure we don't skip any */		\
				}														\
				ppDfEntry = &pDFE->dfe_NextSibling;						\
			}															\
			if (++i == MAX_CHILD_HASH_BUCKETS)							\
			{															\
				break;													\
			}															\
			ppDfEntry = &(_pDFETree)->dfe_pDirEntry->de_ChildFile[i];	\
		}																\
	}

#define	afpUpdateDfeWithSavedData(_pDfe, _pDiskEnt)						\
	{																	\
		(_pDfe)->dfe_Flags |= (_pDiskEnt)->dsk_Flags & DFE_FLAGS_CSENCODEDBITS;\
		(_pDfe)->dfe_AfpAttr = (_pDiskEnt)->dsk_AfpAttr;				\
		(_pDfe)->dfe_NtAttr = (_pDiskEnt)->dsk_NtAttr;					\
		(_pDfe)->dfe_CreateTime = (_pDiskEnt)->dsk_CreateTime;			\
		(_pDfe)->dfe_LastModTime = (_pDiskEnt)->dsk_LastModTime;		\
		(_pDfe)->dfe_BackupTime = (_pDiskEnt)->dsk_BackupTime;			\
		(_pDfe)->dfe_FinderInfo = (_pDiskEnt)->dsk_FinderInfo;			\
		if (DFE_IS_DIRECTORY((_pDfe)))									\
		{																\
			(_pDfe)->dfe_pDirEntry->de_Access = (_pDiskEnt)->dsk_Access;\
		}																\
		else															\
		{																\
			(_pDfe)->dfe_DataLen = (_pDiskEnt)->dsk_DataLen;			\
			(_pDfe)->dfe_RescLen = (_pDiskEnt)->dsk_RescLen;			\
		}																\
	}

#define	afpSaveDfeData(_pDfe, _pDiskEnt)								\
	{                                                                   \
		/* Write a signature for sanity checking */                     \
		(_pDiskEnt)->dsk_Signature = AFP_DISKENTRY_SIGNATURE;           \
                                                                        \
		(_pDiskEnt)->dsk_AfpId = (_pDfe)->dfe_AfpId;                    \
		(_pDiskEnt)->dsk_AfpAttr = (_pDfe)->dfe_AfpAttr;                \
		(_pDiskEnt)->dsk_NtAttr = (_pDfe)->dfe_NtAttr;                  \
		(_pDiskEnt)->dsk_BackupTime = (_pDfe)->dfe_BackupTime;          \
		(_pDiskEnt)->dsk_CreateTime = (_pDfe)->dfe_CreateTime;          \
		(_pDiskEnt)->dsk_LastModTime = (_pDfe)->dfe_LastModTime;		\
		(_pDiskEnt)->dsk_FinderInfo = (_pDfe)->dfe_FinderInfo;          \
                                                                        \
		/* Encode the number of characters (not bytes) in the name */   \
		(_pDiskEnt)->dsk_Flags =										\
				((_pDfe)->dfe_Flags & DFE_FLAGS_DFBITS)	|				\
				((_pDfe)->dfe_UnicodeName.Length/sizeof(WCHAR));		\
                                                                        \
		/* Copy the name over */                                        \
		RtlCopyMemory(&(_pDiskEnt)->dsk_Name[0],           				\
					  (_pDfe)->dfe_UnicodeName.Buffer,                  \
					  (_pDfe)->dfe_UnicodeName.Length);                 \
	}

// File DFEs are aged after MAX_BLOCK_AGE*FILE_BLOCK_AGE_TIME seconds (currently 2 mins)
// File DFEs are aged after MAX_BLOCK_AGE*DIR_BLOCK_AGE_TIME seconds  (currently 6 mins)
#define	MAX_BLOCK_AGE			6
#define	FILE_BLOCK_AGE_TIME		600			// # of seconds
#define	DIR_BLOCK_AGE_TIME		3600		// # of seconds
#define	BLOCK_64K_ALLOC		    64*1024     // Virtual mem allocates 64K chunks
#define	MAX_BLOCK_TYPE			4			// For TINY, SMALL, MEDIUM & LARGE

#define VALID_DFB(pDfeBlock)	((pDfeBlock) != NULL)

typedef struct _Block64K
{
    struct _Block64K *b64_Next;
    PBYTE             b64_BaseAddress;
    DWORD             b64_PagesFree;
    BYTE              b64_PageInUse[BLOCK_64K_ALLOC/PAGE_SIZE];
} BLOCK64K, *PBLOCK64K;


typedef	struct _DfeBlock
{
	struct _DfeBlock *	dfb_Next;			// Link to next
	struct _DfeBlock **	dfb_Prev;			// Link to previous
	USHORT				dfb_NumFree;		// # of free DFEs in this block
	BYTE				dfb_Age;			// Age of the Block if all are free
	BOOLEAN				dfb_fDir;			// TRUE if it is a Dir DFB - else a file DFB
	PDFENTRY			dfb_FreeHead;		// Head of the list of free DFEs
} DFEBLOCK, *PDFEBLOCK, **PPDFEBLOCK;

LOCAL PDFENTRY FASTCALL
afpAllocDfe(
	IN	LONG						Index,
	IN	BOOLEAN						fDir
);

LOCAL VOID FASTCALL			
afpFreeDfe(					
	IN	PDFENTRY					pDfEntry
);

LOCAL AFPSTATUS FASTCALL
afpDfeBlockAge(				
	IN	PPDFEBLOCK					pBlockHead
);

#if DBG						

VOID FASTCALL
afpDisplayDfe(
	IN	PDFENTRY					pDfEntry
);

NTSTATUS FASTCALL
afpDumpDfeTree(				
	IN	PVOID						Context
);

#endif

IDDBGLOBAL  PBLOCK64K   afp64kBlockHead EQU NULL;

IDDBGLOBAL	PDFEBLOCK	afpDirDfeFreeBlockHead[MAX_BLOCK_TYPE] EQU  { NULL, NULL, NULL };
IDDBGLOBAL	PDFEBLOCK	afpDirDfePartialBlockHead[MAX_BLOCK_TYPE] EQU  { NULL, NULL, NULL };
IDDBGLOBAL	PDFEBLOCK	afpDirDfeUsedBlockHead[MAX_BLOCK_TYPE] EQU  { NULL, NULL, NULL };
IDDBGLOBAL	PDFEBLOCK	afpFileDfeFreeBlockHead[MAX_BLOCK_TYPE] EQU { NULL, NULL, NULL };
IDDBGLOBAL	PDFEBLOCK	afpFileDfePartialBlockHead[MAX_BLOCK_TYPE] EQU { NULL, NULL, NULL };
IDDBGLOBAL	PDFEBLOCK	afpFileDfeUsedBlockHead[MAX_BLOCK_TYPE] EQU { NULL, NULL, NULL };

IDDBGLOBAL	USHORT		afpDfeUnicodeBufSize[MAX_BLOCK_TYPE] EQU	\
	{																\
		DFE_SIZE_TINY_U, DFE_SIZE_SMALL_U,							\
		DFE_SIZE_MEDIUM_U, DFE_SIZE_LARGE_U							\
	};

IDDBGLOBAL	USHORT		afpDfeFileBlockSize[MAX_BLOCK_TYPE] EQU		\
	{																\
		sizeof(DFENTRY) + DFE_SIZE_TINY_U,							\
		sizeof(DFENTRY) + DFE_SIZE_SMALL_U,							\
		sizeof(DFENTRY) + DFE_SIZE_MEDIUM_U,						\
		sizeof(DFENTRY) + DFE_SIZE_LARGE_U							\
	};

IDDBGLOBAL	USHORT		afpDfeDirBlockSize[MAX_BLOCK_TYPE] EQU		    \
	{																    \
		(USHORT)(sizeof(DFENTRY) + sizeof(DIRENTRY) + DFE_SIZE_TINY_U),	\
		(USHORT)(sizeof(DFENTRY) + sizeof(DIRENTRY) + DFE_SIZE_SMALL_U),	\
		(USHORT)(sizeof(DFENTRY) + sizeof(DIRENTRY) + DFE_SIZE_MEDIUM_U),	\
		(USHORT)(sizeof(DFENTRY) + sizeof(DIRENTRY) + DFE_SIZE_LARGE_U)	\
	};

IDDBGLOBAL	USHORT      afpDfeNumFileBlocks[MAX_BLOCK_TYPE] EQU		\
	{																\
		(PAGE_SIZE - sizeof(DFEBLOCK))/						        \
			(sizeof(DFENTRY) + DFE_SIZE_TINY_U),					\
		(PAGE_SIZE - sizeof(DFEBLOCK))/						        \
			(sizeof(DFENTRY) + DFE_SIZE_SMALL_U),					\
		(PAGE_SIZE - sizeof(DFEBLOCK))/						        \
			(sizeof(DFENTRY) + DFE_SIZE_MEDIUM_U),					\
		(PAGE_SIZE - sizeof(DFEBLOCK))/						        \
			(sizeof(DFENTRY) + DFE_SIZE_LARGE_U)					\
	};

IDDBGLOBAL	USHORT      afpDfeNumDirBlocks[MAX_BLOCK_TYPE] EQU		\
	{																\
		(PAGE_SIZE - sizeof(DFEBLOCK))/						        \
			(sizeof(DFENTRY) + sizeof(DIRENTRY) + DFE_SIZE_TINY_U),	\
		(PAGE_SIZE - sizeof(DFEBLOCK))/						        \
			(sizeof(DFENTRY) + sizeof(DIRENTRY) + DFE_SIZE_SMALL_U),\
		(PAGE_SIZE - sizeof(DFEBLOCK))/						        \
			(sizeof(DFENTRY) + sizeof(DIRENTRY) + DFE_SIZE_MEDIUM_U),\
		(PAGE_SIZE - sizeof(DFEBLOCK))/						        \
			(sizeof(DFENTRY) + sizeof(DIRENTRY) + DFE_SIZE_LARGE_U)	\
	};

IDDBGLOBAL	SWMR	afpDfeBlockLock EQU { 0 };

#if DBG

IDDBGLOBAL	LONG		afpDfeAllocCount	EQU 0;
IDDBGLOBAL	LONG		afpDfbAllocCount	EQU 0;
IDDBGLOBAL	LONG		afpDfe64kBlockCount	EQU 0;
IDDBGLOBAL	BOOLEAN		afpDumpDfeTreeFlag	EQU 0;
IDDBGLOBAL	PDFENTRY	afpDfeStack[4096]	EQU { 0 };

#endif

#undef	EQU
#ifdef	_GLOBALS_
#define	EQU				=
#else
#define	EQU				; / ## /
#endif

#endif // IDINDEX_LOCALS

#endif // _IDINDEX_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\server\gendisp.h ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	gendisp.h

Abstract:

	This module contains prototypes for generic dispatch routines.

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	25 Apr 1992		Initial Version

Notes:	Tab stop: 4
--*/


#ifndef _GENDISP_
#define _GENDISP_

extern
AFPSTATUS FASTCALL
AfpFsdDispInvalidFunc(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFsdDispUnsupportedFunc(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFsdDispGetSrvrParms(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFsdDispGetSrvrMsg(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFspDispGetUserInfo(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFspDispLogin(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFspDispLoginCont(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFspDispLogout(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFspDispChangePassword(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFspDispMapName(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFspDispMapId(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFsdDispOpenVol(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFspDispOpenVol(
	IN	PSDA	pSda
);


AFPSTATUS FASTCALL
AfpFspDispGetVolParms(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFsdDispGetVolParms(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFsdDispSetVolParms(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFsdDispFlush(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFsdDispCloseVol(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFsdDispOpenDT(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFsdDispCloseDT(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFspDispAddIcon(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFspDispGetIcon(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFspDispGetIconInfo(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFspDispAddAppl(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFspDispGetAppl(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFspDispRemoveAppl(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFspDispAddComment(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFspDispGetComment(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFspDispRemoveComment(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFspDispFlushFork(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFspDispOpenFork(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFspDispCloseFork(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFspDispGetForkParms(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFspDispSetForkParms(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFspDispRead(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFspDispWrite(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFspDispByteRangeLock(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFspDispCreateFile(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFspDispSetFileParms(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFspDispCopyFile(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFspDispCreateId(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFspDispResolveId(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFspDispDeleteId(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFspDispCloseDir(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFspDispExchangeFiles(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFspDispOpenDir(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFspDispCreateDir(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFspDispEnumerate(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFspDispSetDirParms(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFspDispGetFileDirParms(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFspDispSetFileDirParms(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFspDispDelete(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFspDispRename(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFspDispMoveAndRename(
	IN	PSDA	pSda
);

extern
AFPSTATUS FASTCALL
AfpFspDispCatSearch(
	IN	PSDA	pSda
);


// Equates to access request and response packets

#define	pReqPkt			((struct _RequestPacket *)(pSda->sda_ReqBlock))
#define	pModPkt			((struct _ModifiedPacket *)(pSda->sda_ReqBlock))
#define	pRspPkt			((struct _ResponsePacket *)(pSda->sda_ReplyBuf))

#define	SIZE_RESPPKT	sizeof(struct _ResponsePacket)
#endif	// _GENDISP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\server\macansi.c ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	macansi.c

Abstract:

	This module contains conversion routines from macintosh ansi to unicode
	and vice versa


Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	10 Jul 1992		Initial Version

Notes:	Tab stop: 4
--*/

#define	_MACANSI_LOCALS
#define	FILENUM	FILE_MACANSI

#include <afp.h>

#define	FlagOn(x, y)	((x) & (y))

#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, AfpMacAnsiInit)
#pragma alloc_text( PAGE, AfpMacAnsiDeInit)
#pragma alloc_text( PAGE, AfpGetMacCodePage)
#pragma alloc_text( PAGE, AfpConvertStringToUnicode)
#pragma alloc_text( PAGE, AfpConvertStringToAnsi)
#pragma alloc_text( PAGE, AfpConvertStringToMungedUnicode)
#pragma alloc_text( PAGE, AfpConvertPasswordStringToUnicode)
#pragma alloc_text( PAGE, AfpConvertMungedUnicodeToAnsi)
#pragma alloc_text( PAGE, AfpConvertMacAnsiToHostAnsi)
#pragma alloc_text( PAGE, AfpConvertHostAnsiToMacAnsi)
#pragma alloc_text( PAGE, AfpIsLegalShortname)
#pragma alloc_text( PAGE, AfpIsProperSubstring)
#endif

/***	AfpMacAnsiInit
 *
 *	Initialize the code page for macintosh ANSI.
 */
NTSTATUS
AfpMacAnsiInit(
	VOID
)
{
	NTSTATUS	Status = STATUS_SUCCESS;
	int			i, SizeAltTbl;

	// Allocate the table for the alternate unicode characters
	SizeAltTbl = (AFP_INVALID_HIGH - AFP_INITIAL_INVALID_HIGH + 1) * sizeof(WCHAR);
	if ((afpAltUnicodeTable = (PWCHAR)AfpAllocZeroedPagedMemory(SizeAltTbl)) == NULL)
		return STATUS_INSUFFICIENT_RESOURCES;

	// Allocate and initialize the table for the reverse mapping table
	SizeAltTbl = (AFP_INVALID_HIGH - AFP_INITIAL_INVALID_HIGH + 1)*sizeof(BYTE);
	if ((afpAltAnsiTable = (PBYTE)AfpAllocZeroedPagedMemory(SizeAltTbl)) == NULL)
	{
		AfpFreeMemory(afpAltUnicodeTable);
		afpAltUnicodeTable = NULL;
		return STATUS_INSUFFICIENT_RESOURCES;
	}

	// Initialize the tables for the alternate unicode characters
	for (i = AFP_INITIAL_INVALID_HIGH + 1; i <= AFP_INVALID_HIGH; i++)
	{
		if (!FsRtlIsAnsiCharacterLegalNtfs((BYTE)i, False))
		{
			afpAltUnicodeTable[i-AFP_INITIAL_INVALID_HIGH] = afpLastAltChar;
			afpAltAnsiTable[afpLastAltChar - (AFP_ALT_UNICODE_BASE + AFP_INITIAL_INVALID_HIGH)] = (BYTE)i;
			afpLastAltChar++;
		}
	}

	// HACK: Also add in a couple of codes for 'space' and 'period' - they are only
	//		 used if they are at end. Another one for the 'apple' character
	AfpMungedUnicodeSpace =
	afpAltUnicodeTable[ANSI_SPACE-AFP_INITIAL_INVALID_HIGH] = afpLastAltChar;
	afpAltAnsiTable[afpLastAltChar - (AFP_ALT_UNICODE_BASE + AFP_INITIAL_INVALID_HIGH)] = ANSI_SPACE;
	afpLastAltChar ++;

	AfpMungedUnicodePeriod =
	afpAltUnicodeTable[ANSI_PERIOD-AFP_INITIAL_INVALID_HIGH] = afpLastAltChar;
	afpAltAnsiTable[afpLastAltChar - (AFP_ALT_UNICODE_BASE + AFP_INITIAL_INVALID_HIGH)] = ANSI_PERIOD;
	afpLastAltChar ++;

	// This is yet another hack
	afpAppleUnicodeChar = afpLastAltChar;
	afpLastAltChar ++;

	RtlZeroMemory(&AfpMacCPTableInfo, sizeof(AfpMacCPTableInfo));

	return Status;
}


/***	AfpMacAnsiDeInit
 *
 *	De-initialize the code page for macintosh ANSI.
 */
VOID
AfpMacAnsiDeInit(
	VOID
)
{
	PAGED_CODE( );

	if (AfpTranslationTable != NULL)
	{
		AfpFreeMemory(AfpTranslationTable);
	}

	if (AfpRevTranslationTable != NULL)
	{
		AfpFreeMemory(AfpRevTranslationTable);
	}

	if (afpAltUnicodeTable != NULL)
	{
		AfpFreeMemory(afpAltUnicodeTable);
	}

	if (afpAltAnsiTable != NULL)
	{
		AfpFreeMemory(afpAltAnsiTable);
	}

	if (AfpMacCPBaseAddress != NULL)
	{
		AfpFreeMemory(AfpMacCPBaseAddress);
	}
}


/***	AfpConvertStringToUnicode
 *
 *	Convert a Mac ANSI string to a unicode string.
 */
AFPSTATUS FASTCALL
AfpConvertStringToUnicode(
	IN	PANSI_STRING	pAnsiString,
	OUT	PUNICODE_STRING	pUnicodeString
)
{

	NTSTATUS	Status;
	ULONG		ulCast;

	PAGED_CODE( );

	ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

	Status = RtlCustomCPToUnicodeN(&AfpMacCPTableInfo,
								   pUnicodeString->Buffer,
								   pUnicodeString->MaximumLength,
								   &ulCast, pAnsiString->Buffer,
								   pAnsiString->Length);
	if (NT_SUCCESS(Status))
		pUnicodeString->Length = (USHORT)ulCast;
	else
	{
		AFPLOG_ERROR(AFPSRVMSG_MACANSI2UNICODE, Status, NULL, 0, NULL);
	}

	return Status;
}



/***	AfpConvertStringToAnsi
 *
 *	Convert a unicode string to a Mac ANSI string.
 */
AFPSTATUS FASTCALL
AfpConvertStringToAnsi(
	IN	PUNICODE_STRING	pUnicodeString,
	OUT	PANSI_STRING	pAnsiString
)
{
	NTSTATUS	Status;
	ULONG		ulCast;

	PAGED_CODE( );

	ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

	Status = RtlUnicodeToCustomCPN(&AfpMacCPTableInfo,
								   pAnsiString->Buffer,
								   pAnsiString->MaximumLength,
								   &ulCast, pUnicodeString->Buffer,
								   pUnicodeString->Length);
	if (NT_SUCCESS(Status))
		pAnsiString->Length = (USHORT)ulCast;
	else
	{
		AFPLOG_ERROR(AFPSRVMSG_UNICODE2MACANSI, Status, NULL, 0, NULL);
	}

	return Status;
}



/***	AfpConvertStringToMungedUnicode
 *
 *	Convert a Mac ANSI string to a unicode string. If there are any characters
 *	in the ansi string which are invalid filesystem (NTFS) characters, then
 *	map them to alternate unicode characters based on the table.
 */
AFPSTATUS FASTCALL
AfpConvertStringToMungedUnicode(
	IN	PANSI_STRING	pAnsiString,
	OUT	PUNICODE_STRING	pUnicodeString
)
{
	USHORT		i, len;
	BYTE		c;
	NTSTATUS	Status;
	ULONG		ulCast;
	PWCHAR		pWBuf;

	PAGED_CODE( );

	ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

	ASSERT(afpAltUnicodeTable != NULL);

	Status = RtlCustomCPToUnicodeN(&AfpMacCPTableInfo,
								   pUnicodeString->Buffer,
								   pUnicodeString->MaximumLength,
								   &ulCast,
								   pAnsiString->Buffer,
								   pAnsiString->Length);
	if (NT_SUCCESS(Status))
		pUnicodeString->Length = (USHORT)ulCast;
	else
	{
		AFPLOG_ERROR(AFPSRVMSG_MACANSI2UNICODE, Status, NULL, 0, NULL);
		return Status;
	}

	// Walk the ANSI string looking for the invalid characters and map it
	// to the alternate set

	for (i = 0, len = pAnsiString->Length, pWBuf = pUnicodeString->Buffer;
		 i < len;
		 i++, pWBuf ++)
	{
	    c = pAnsiString->Buffer[i];
	    if (c == ANSI_APPLE_CHAR)
	    {
			if (AfpServerIsGreek)
			{
				*pWBuf = AFP_GREEK_UNICODE_APPLE_CHAR;
			}
			else
			{
				*pWBuf = afpAppleUnicodeChar;
			}
	    }
	    else if (c < AFP_INITIAL_INVALID_HIGH)
		*pWBuf = c + AFP_ALT_UNICODE_BASE;
	    else if (!FsRtlIsAnsiCharacterLegalNtfs(c, False))
	    {
		ASSERT (c <= AFP_INVALID_HIGH);
		*pWBuf = afpAltUnicodeTable[c - AFP_INITIAL_INVALID_HIGH];
	    }
/* MSKK eichim, Appended to handle DBCS trailing 0x5c, 03/16/95 */
#ifdef DBCS
	    if (FsRtlIsLeadDbcsCharacter(c))
	        i++;
#endif // DBCS
	}

	// HACK: Make sure the last character in the name is not a 'space' or a '.'
	c = pAnsiString->Buffer[pAnsiString->Length - 1];
	if ((c == ANSI_SPACE) || (c == ANSI_PERIOD))
/* MSKK hideyukn, Unicode char length not eqaul to ansi byte length in DBCS, 06/30/95 */
#ifdef DBCS
        pUnicodeString->Buffer[(pUnicodeString->Length/sizeof(WCHAR)) - 1]
                                        = afpAltUnicodeTable[c - AFP_INITIAL_INVALID_HIGH];
#else
		pUnicodeString->Buffer[len - 1] = afpAltUnicodeTable[c - AFP_INITIAL_INVALID_HIGH];
#endif // DBCS

	return STATUS_SUCCESS;
}


/***	AfpConvertPasswordStringToUnicode
 *
 *	Convert a Mac ANSI clear-text password to a unicode string. 
 *
 */
AFPSTATUS FASTCALL
AfpConvertPasswordStringToUnicode(
	IN	PANSI_STRING	pAnsiString,
	OUT	PUNICODE_STRING	pUnicodeString
)
{
	USHORT		i, len;
	BYTE		c;
	NTSTATUS	Status;
	ULONG		ulCast;
	PWCHAR		pWBuf;

	PAGED_CODE( );

	ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

	ASSERT(afpAltUnicodeTable != NULL);

	Status = RtlCustomCPToUnicodeN(&AfpMacCPTableInfo,
		pUnicodeString->Buffer,
		pUnicodeString->MaximumLength,
		&ulCast,
		pAnsiString->Buffer,
		pAnsiString->Length);

	DBGPRINT(DBG_COMP_AFPAPI_SRV, DBG_LEVEL_ERR,
		("AfpConvertPasswordStringToUnicode: Ansilen=(%ld), ulCast=(%ld), Unicodelen=(%ld)\n", pAnsiString->Length, ulCast, pUnicodeString->MaximumLength));
	if (NT_SUCCESS(Status))
	    pUnicodeString->Length = (USHORT)ulCast;
	else
	{
	    AFPLOG_ERROR(AFPSRVMSG_MACANSI2UNICODE, Status, NULL, 0, NULL);
	    return Status;
	}

	return STATUS_SUCCESS;
}



/***	AfpConvertMungedUnicodeToAnsi
 *
 *	Convert a unicode string with possible alternate unicode characters
 *	to Mac Ansi.
 *	This is inverse of AfpConvertStringToMungedUnicode().
 */
NTSTATUS FASTCALL
AfpConvertMungedUnicodeToAnsi(
	IN	PUNICODE_STRING	pUnicodeString,
	OUT	PANSI_STRING	pAnsiString
)
{
	USHORT		i, len;
	WCHAR		wc;
	NTSTATUS	Status;
	ULONG		ulCast;
	PBYTE		pABuf;

	PAGED_CODE( );

	ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

	Status = RtlUnicodeToCustomCPN(&AfpMacCPTableInfo,
								   pAnsiString->Buffer,
								   pAnsiString->MaximumLength,
								   &ulCast, pUnicodeString->Buffer,
								   pUnicodeString->Length);
	if (NT_SUCCESS(Status))
		pAnsiString->Length = (USHORT)ulCast;
	else
	{
		AFPLOG_ERROR(AFPSRVMSG_UNICODE2MACANSI, Status, NULL, 0, NULL);
	}

	// Walk the Unicode string looking for alternate unicode chars and
	// replacing the ansi equivalents by the real ansi characters.
	for (i = 0, len = pUnicodeString->Length/(USHORT)sizeof(WCHAR), pABuf = pAnsiString->Buffer;
		i < len;
		i++, pABuf++)
	{
		wc = pUnicodeString->Buffer[i];
		if ((wc == afpAppleUnicodeChar) && (!AfpServerIsGreek))
		{
			*pABuf = ANSI_APPLE_CHAR;
		}
		else if ((wc == AFP_GREEK_UNICODE_APPLE_CHAR) && (AfpServerIsGreek))
		{
			*pABuf = ANSI_APPLE_CHAR;
		}
		else if ((wc >= AFP_ALT_UNICODE_BASE) && (wc < afpLastAltChar))
		{
			wc -= AFP_ALT_UNICODE_BASE;
			if (wc < AFP_INITIAL_INVALID_HIGH)
				*pABuf = (BYTE)wc;
			else *pABuf = afpAltAnsiTable[wc - AFP_INITIAL_INVALID_HIGH];
		}
/* MSKK hideyukn, Unicode char length not eqaul to ansi byte length in DBCS, 06/30/95 */
#ifdef DBCS
		if (FsRtlIsLeadDbcsCharacter(*pABuf))
            pABuf++;
#endif // DBCS
	}

	return Status;
}

/***	AfpConvertMacAnsiToHostAnsi
 *
 *	Convert a Mac ansi string to its host counterpart in uppercase OEM codepage.
 *  (in place). The name of this routine is misleading as a late bugfix was
 *  made to change the codepage used, but the name of the routine didn't change
 *  so none of the calling code had to be changed.  It should really be called
 *  AfpConvertMacAnsiToUpcaseOem.  This routine is only called to uppercase
 *  mac passwords for logon and changepassword.
 *
 */
AFPSTATUS FASTCALL
AfpConvertMacAnsiToHostAnsi(
	IN	OUT	PANSI_STRING	pAnsiString
)
{
	LONG	i, Len;
	BYTE	*pBuf;

	PAGED_CODE( );

	ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
	ASSERT (AfpTranslationTable != NULL);

	Len = pAnsiString->Length;
	pBuf = pAnsiString->Buffer;

	for (i = 0; i < Len; i++, pBuf++)
	{
/* MSKK NaotoN Appended to handle DBCS Mac path name 11/10/93 */
#ifdef DBCS
		if (FsRtlIsLeadDbcsCharacter( *pBuf )) {
			i++ ;
			pBuf++ ;
		}
		else
#endif // DBCS
		*pBuf = AfpTranslationTable[*pBuf];
	}
	return AFP_ERR_NONE;
}


/***	AfpConvertHostAnsiToMacAnsi
 *
 *	Convert a host unicode string to its mac counterpart in place.
 *	Only characters <= 0x20 and >= 0x80 are translated.
 *
 *	NOTE: This is extremely hacky and intended for translating messages only.
 */
VOID FASTCALL
AfpConvertHostAnsiToMacAnsi(
	IN	OUT PANSI_STRING	pAnsiString
)
{
	LONG	i, Len;
	BYTE	c, *pBuf;

	PAGED_CODE( );

	ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
	ASSERT (AfpRevTranslationTable != NULL);

	Len = pAnsiString->Length;
	pBuf = pAnsiString->Buffer;

	for (i = 0; i < Len; i++, pBuf++)
	{
		c = *pBuf;
/* MSKK NaotoN Appended to skip if Kanji 12/17/93 */
#ifdef DBCS
		if (FsRtlIsLeadDbcsCharacter( c )) {
			i++ ;
			pBuf++ ;
		}
		else
#endif // DBCS
		if (c < 0x20)
		{
			*pBuf = AfpRevTranslationTable[c];
		}
		else if (c >= 0x80)
		{
			*pBuf = AfpRevTranslationTable[c-(0x80-0x20)];
		}
	}
}

/***	AfpEqualUnicodeString
 *
 *	The AfpEqualUnicodeString function compares two counted unicode
 *	strings for equality using case SENSITIVE compare. This routine
 *	exists because it must be called at DPC level by the volume.c code
 *	for comparing 2 non-paged strings, and the RtlEqualUnicodeString
 *	routine that we would normally call is pageable code.
 *
 *	Note that case INSENSITIVE compare would require accessing
 *	paged up-case table info, and therefore could not be done at DPC level.
 *
 *	Arguments:
 *		String1 - Pointer to the first string.
 *		String2 - Pointer to the second string.
 *
 *	Return Value:
 *		True if String1 equals String2 and False otherwise.
 *
 *	Note: This is called at DPC level from volume.c and must not be made
 *		a pageable routine.
 */

BOOLEAN FASTCALL
AfpEqualUnicodeString(
	IN	PUNICODE_STRING	String1,
	IN	PUNICODE_STRING	String2
)
{
	WCHAR		*s1, *s2;
	USHORT		n1, n2;

	n1 = (USHORT)(String1->Length/sizeof(WCHAR));
	n2 = (USHORT)(String2->Length/sizeof(WCHAR));

	if (n1 != n2)
	{
		return False;
	}

	s1 = String1->Buffer;
	s2 = String2->Buffer;

	while (n1--)
	{
		if (*s1++ != *s2++)
		{
			return False;
		}
	}

	return True;
}


/***	AfpPrefixUnicodeString
 *
 *	The AfpPrefixUnicodeString function determines if the String1
 *	counted string parameter is a prefix of the String2 counted string
 *	parameter using case SENSITIVE compare. This routine exists because it
 *	must be called at DPC level by the volume.c code for comparing
 *	two non-paged strings, and the RtlPrefixUnicodeString routine that we
 *	would normally call is pageable code.
 *
 *	Note that case INSENSITIVE compare would require accessing
 *	paged up-case table info, and therefore could not be done at DPC level.
 *
 *	Arguments:
 *		String1 - Pointer to the first unicode string.
 *		String2 - Pointer to the second unicode string.
 *
 *	Return Value:
 *		True if String1 equals a prefix of String2 and False otherwise.
 *
 *	Note: This is called at DPC level from volume.c and must not be made
 *		 	   a pageable routine.
 */

BOOLEAN FASTCALL
AfpPrefixUnicodeString(
	IN	PUNICODE_STRING	String1,
	IN	PUNICODE_STRING	String2
)
{
	PWSTR s1, s2;
	ULONG n;
	WCHAR c1, c2;

	if (String2->Length < String1->Length)
	{
		return False;
	}

	s1 = String1->Buffer;
	s2 = String2->Buffer;
    n = String1->Length/sizeof(WCHAR);
	while (n--)
	{
		c1 = *s1++;
		c2 = *s2++;
		if (c1 != c2)
		{
			return False;
		}
	}
	return True;
}

/*** AfpGetMacCodePage
 *
 *	Open the default macintosh codepage, create a section backed by that file,
 *  map a view to the section, and initialize the CodePage info structure
 *  that is used with the RtlCustomCP routines.  Then create the Mac Ansi to
 *  Host Ansi mapping table.
 *
 *  BEWARE!
 *	This routine may only be called ONCE!  This will be called from the first
 *  admin call to ServerSetInfo.  Therefore, there can be NO calls to the
 *  macansi routines within this module (except for MacAnsiInit) before that
 *  happens.
 */
NTSTATUS FASTCALL
AfpGetMacCodePage(
	IN	LPWSTR	PathCP
)
{
	NTSTATUS 		Status;
	FILESYSHANDLE	FileHandle;
	UNICODE_STRING	uPathCP, devPathCP;
	ULONG			viewsize = 0;
	WCHAR			UnicodeTable[2*AFP_XLAT_TABLE_SIZE];
	BYTE			AnsiTable[2*AFP_XLAT_TABLE_SIZE + 1];
	UNICODE_STRING	UnicodeString;
	ANSI_STRING		AnsiString;
	LONG			i;

	PAGED_CODE( );

	FileHandle.fsh_FileHandle = NULL;
	UnicodeString.Length = AFP_XLAT_TABLE_SIZE * sizeof(WCHAR);
	UnicodeString.MaximumLength = (AFP_XLAT_TABLE_SIZE + 1) * sizeof(WCHAR);
	UnicodeString.Buffer = UnicodeTable;

	RtlInitUnicodeString(&uPathCP, PathCP);
	devPathCP.Length = 0;
	devPathCP.MaximumLength = uPathCP.Length + DosDevices.Length + sizeof(WCHAR);
	if ((devPathCP.Buffer = (PWSTR)AfpAllocPagedMemory(devPathCP.MaximumLength)) == NULL)
	{
		Status = STATUS_NO_MEMORY;
		AFPLOG_ERROR(AFPSRVMSG_MAC_CODEPAGE, Status, NULL, 0, NULL);
		return Status;
	}
	AfpCopyUnicodeString(&devPathCP, &DosDevices);
	RtlAppendUnicodeStringToString(&devPathCP, &uPathCP);

	do
	{
		FORKSIZE	liCPlen;
		LONG		lCPlen, sizeread=0;

		Status = AfpIoOpen(NULL,
						   AFP_STREAM_DATA,
						   FILEIO_OPEN_FILE,
						   &devPathCP,
						   FILEIO_ACCESS_READ,
						   FILEIO_DENY_NONE,
						   False,
						   &FileHandle);

		if (!NT_SUCCESS(Status))
			break;

		if (!NT_SUCCESS(Status = AfpIoQuerySize(&FileHandle,
												&liCPlen)))
			break;

		// NOTE: This assumes the codepage file will never be so big that
		// the high bit of the LowPart of the size will be set
		lCPlen = (LONG)liCPlen.LowPart;
		if ((AfpMacCPBaseAddress = (PUSHORT)AfpAllocPagedMemory(lCPlen)) == NULL)
		{
			Status = STATUS_NO_MEMORY;
			break;
		}

		Status = AfpIoRead(&FileHandle,
						   &LIZero,
						   lCPlen,
						   &sizeread,
						   (PBYTE)AfpMacCPBaseAddress);
		AfpIoClose(&FileHandle);

		if (!NT_SUCCESS(Status))
			break;

		if (sizeread != lCPlen)
		{
			Status = STATUS_UNSUCCESSFUL;
			break;
		}

		RtlInitCodePageTable(AfpMacCPBaseAddress, &AfpMacCPTableInfo);

		// Initialize mac ANSI to host upcase Oem translation table
		// Start by allocating memory for the table and filling it up.

/* HitoshiT modify following line to keep Unicode translation table.	5/18/94	*/
#ifdef DBCS
		if ((AfpTranslationTable = AfpAllocPagedMemory(2*AFP_XLAT_TABLE_SIZE*sizeof(USHORT) + 1)) == NULL)
#else
		if ((AfpTranslationTable = AfpAllocPagedMemory(2*AFP_XLAT_TABLE_SIZE + 1)) == NULL)
#endif // DBCS
		{
			Status = STATUS_NO_MEMORY;
			break;
		}

		for (i = 0; i < 2*AFP_XLAT_TABLE_SIZE; i++)
			AnsiTable[i] = (BYTE)i;

		// Now translate this from Mac ANSI to unicode
		AnsiString.Length = 2*AFP_XLAT_TABLE_SIZE;
		AnsiString.MaximumLength = 	2*AFP_XLAT_TABLE_SIZE + 1;
		AnsiString.Buffer = AnsiTable;

		UnicodeString.Length = 0;
		UnicodeString.MaximumLength = sizeof(UnicodeTable);
		UnicodeString.Buffer =	UnicodeTable;

		Status = AfpConvertStringToUnicode(&AnsiString, &UnicodeString);
		if (!NT_SUCCESS(Status))
			break;

		// Now convert the entire table to uppercase host Oem Codepage
		AnsiString.Length = 0;
/* HitoshiT modify following line to keep Unicode translation table	5/18/94 */
#ifdef DBCS
		AnsiString.MaximumLength = 2*AFP_XLAT_TABLE_SIZE * sizeof(USHORT) + 1;
#else
		AnsiString.MaximumLength = 2*AFP_XLAT_TABLE_SIZE + 1;
#endif // DBCS
		AnsiString.Buffer = AfpTranslationTable;

		Status = RtlUpcaseUnicodeStringToOemString(&AnsiString, &UnicodeString, False);
		// Bug 342062
		// Bug introduced due to RtlpDidUnicodeToOemWork check 
		// introduced in RtlUpcaseUnicodeStringToOemString
		// We have characters which will be mapped to default characters
		// and hence we should ignore STATUS_UNMAPPABLE_CHARACTER
		if ((!NT_SUCCESS(Status))&&(Status!=STATUS_UNMAPPABLE_CHARACTER))
			break;

		// Initialize host ANSI to mac ANSI translation table
		// Start by allocating memory for the table and filling it up.
		if ((AfpRevTranslationTable = AfpAllocPagedMemory(AFP_REV_XLAT_TABLE_SIZE + 1)) == NULL)
		{
			Status = STATUS_NO_MEMORY;
			break;
		}

		for (i = 0; i < 0x20; i++)
			AfpRevTranslationTable[i] = (BYTE)i;

		for (i = 0x80; i < 256; i++)
			AfpRevTranslationTable[i-(0x80-0x20)] = (BYTE)i;

		// Get rid of the line feed char
		AfpRevTranslationTable[0x0A] = 0;

		// Now translate host ANSI to unicode
		AnsiString.Length = AFP_REV_XLAT_TABLE_SIZE;
		AnsiString.MaximumLength = 	AFP_REV_XLAT_TABLE_SIZE + 1;
		AnsiString.Buffer = AfpRevTranslationTable;

		UnicodeString.Length = 0;

		Status = RtlAnsiStringToUnicodeString(&UnicodeString, &AnsiString, False);
		if (!NT_SUCCESS(Status))
			break;

		// and then translate from unicode to Mac ANSI
		Status = AfpConvertStringToAnsi(&UnicodeString, &AnsiString);

	} while (False);

	if (!NT_SUCCESS(Status))
	{
		AFPLOG_ERROR(AFPSRVMSG_MAC_CODEPAGE, Status, NULL, 0, NULL);
		if (AfpMacCPBaseAddress != NULL)
		{
			AfpFreeMemory(AfpMacCPBaseAddress);
			AfpMacCPBaseAddress = NULL;
		}

		if (FileHandle.fsh_FileHandle != NULL)
		{
			AfpIoClose(&FileHandle);
		}

		if (AfpTranslationTable != NULL)
		{
			AfpFreeMemory(AfpTranslationTable);
			AfpTranslationTable = NULL;
		}

		if (AfpRevTranslationTable != NULL)
		{
			AfpFreeMemory(AfpRevTranslationTable);
			AfpRevTranslationTable = NULL;
		}
	}

	AfpFreeMemory(devPathCP.Buffer);
	return Status;
}

/*** AfpIsLegalShortname
 *
 * Does a mac shortname conform to FAT 8.3 naming conventions?
 *
 */
BOOLEAN FASTCALL
AfpIsLegalShortname(
	IN	PANSI_STRING	pShortName			// Mac ANSI string
)
{
	return(FsRtlIsFatDbcsLegal(*pShortName, False, False, False));

}

/***	AfpIsProperSubstring
 *
 *	This routine looks for the substring pSubString in pString.  Both
 *  strings are in unicode, the comparison is done case insensitive
 *  (i.e. ignoring case).  This is used by the AfpCatSearch code.
 *
 */
BOOLEAN FASTCALL
AfpIsProperSubstring(
	IN	PUNICODE_STRING	pString,
	IN	PUNICODE_STRING	pSubString
)
{
	WCHAR			*s1, *s2, *ts1;
	USHORT			l1, l2, tl1;
	WCHAR			buf1[AFP_LONGNAME_LEN], buf2[AFP_LONGNAME_LEN];
	UNICODE_STRING	u1, u2;

	PAGED_CODE( );

	// see if this is a no-op?
	if (pSubString->Length > pString->Length)
		return False;

	AfpSetEmptyUnicodeString(&u1, sizeof(buf1), buf1);
	AfpSetEmptyUnicodeString(&u2, sizeof(buf2), buf2);
	if (!NT_SUCCESS(RtlUpcaseUnicodeString(&u1, pString, False)) ||
		!NT_SUCCESS(RtlUpcaseUnicodeString(&u2, pSubString, False)))
		return False;
	
	l1 = u1.Length/sizeof(WCHAR);
	s1 = u1.Buffer;

	do
	{
		l2 = u2.Length/sizeof(WCHAR);
		s2 = u2.Buffer;
		if (l2 > l1)
			return False;

		// look for the next occurrence of the first char of s2 in string s1
		while (l1)
		{
			if (*s2 == *s1)
				break;

			s1++;
			l1--;
		}

		if (l1 < l2)
			return False;
		if (l2 == 1)
			return True;

		l1--; l2--;
		s1++; s2++;

		ts1 = s1;
		tl1 = l1;

		while (l2)
		{
			// Look for substring s2 from current position in s1
			if (*s2 != *ts1)
				break;

			tl1--; l2--;
			ts1++; s2++;
		}

		if (l2 == 0)
			return True;

	} while (True);

	// Should never get here
	KeBugCheck(0);
}

/*** AfpStrChr
 *
 * DBCS sensitive strchr()
 *
 */
PCHAR
AfpStrChr(
    IN  PBYTE               String,
    IN  DWORD               StringLen,
    IN  BYTE                Char
)
{
    DWORD   BytesRemaining;


    BytesRemaining = StringLen;

    while (BytesRemaining > 0)
    {

/* MSKK hideyukn, strchr() does not work with DBCS, 08/07/95 */
#ifdef DBCS
        if (FsRtlIsLeadDbcsCharacter(*String))
        {
            String += 2;
            continue;
        }
#endif /* DBCS */

        if (*String == Char)
        {
            return(String);
        }

        String++;
        BytesRemaining--;
    }

    return(NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\server\lists.h ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	lists.h

Abstract:

	This module contains the macros for managing lists

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	25 Oct 1992		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef _LISTS_
#define _LISTS_

#define	AfpLinkDoubleAtHead(_pHead, _p, Next, Prev)			\
	{														\
		(_p)->Next = (_pHead);								\
		(_p)->Prev = &(_pHead);								\
		if ((_pHead) != NULL)								\
		(_pHead)->Prev = &(_p)->Next;						\
			(_pHead) = (_p);								\
	}

#define	AfpLinkDoubleAtEnd(_pThis, _pLast, Next, Prev)		\
	{														\
		(_pLast)->Next = (_pThis);							\
		(_pThis)->Prev = &(_pLast)->Next;					\
		(_pThis)->Next = NULL;								\
	}

#define	AfpInsertDoubleBefore(_pThis, _pBefore, Next, Prev)	\
	{														\
		(_pThis)->Next = (_pBefore);						\
		(_pThis)->Prev = (_pBefore)->Prev;					\
		(_pBefore)->Prev = &(_pThis)->Next;					\
		*((_pThis)->Prev) = (_pThis);						\
	}

#define	AfpUnlinkDouble(_p, Next, Prev)						\
	{														\
		*((_p)->Prev) = (_p)->Next;							\
		if ((_p)->Next != NULL)								\
			(_p)->Next->Prev = (_p)->Prev;					\
	}

#endif	// _LISTS_


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\server\macansi.h ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	macansi.h

Abstract:

	This module contains prototypes for ANSI to UNICODE conversion routines.

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	10 Jul 1992		Initial Version

Notes:	Tab stop: 4

--*/

#ifndef	_MACANSI_
#define	_MACANSI_

extern
NTSTATUS FASTCALL
AfpGetMacCodePage(
	IN	LPWSTR				PathCP
);

extern
NTSTATUS
AfpMacAnsiInit(
	VOID
);

extern
VOID
AfpMacAnsiDeInit(
	VOID
);

extern
NTSTATUS FASTCALL
AfpConvertStringToUnicode(
	IN	PANSI_STRING		pAnsiString,
	OUT	PUNICODE_STRING		pUnicodeString
);


extern
NTSTATUS FASTCALL
AfpConvertStringToAnsi(
	IN	PUNICODE_STRING		pUnicodeString,
	OUT	PANSI_STRING		pAnsiString
);

extern
NTSTATUS FASTCALL
AfpConvertStringToMungedUnicode(
	IN	PANSI_STRING		pAnsiString,
	OUT	PUNICODE_STRING		pUnicodeString
);

extern
NTSTATUS FASTCALL
AfpConvertPasswordStringToUnicode(
	IN	PANSI_STRING		pAnsiString,
	OUT	PUNICODE_STRING		pUnicodeString
);

extern
NTSTATUS FASTCALL
AfpConvertMungedUnicodeToAnsi(
	IN	PUNICODE_STRING		pUnicodeString,
	OUT	PANSI_STRING		pAnsiString
);

extern
AFPSTATUS FASTCALL
AfpConvertMacAnsiToHostAnsi(
	IN	OUT PANSI_STRING	pAnsiString
);

extern
VOID FASTCALL
AfpConvertHostAnsiToMacAnsi(
	IN	OUT PANSI_STRING	pAnsiString
);

extern
BOOLEAN FASTCALL
AfpEqualUnicodeString(
    IN PUNICODE_STRING 		String1,
    IN PUNICODE_STRING 		String2
);

extern
BOOLEAN FASTCALL
AfpPrefixUnicodeString(
    IN PUNICODE_STRING		String1,
    IN PUNICODE_STRING		String2
);

extern
BOOLEAN FASTCALL
AfpIsProperSubstring(
	IN	PUNICODE_STRING		pString,
	IN	PUNICODE_STRING		pSubString
);

extern
BOOLEAN FASTCALL
AfpIsLegalShortname(
	IN	PANSI_STRING		pShortName
);

extern
PCHAR
AfpStrChr(
    IN  PBYTE               String,
    IN  DWORD               StringLen,
    IN  BYTE                Char
);

// HACK: Space and Period are also mapped BUT ONLY if they occur at end
#define	ANSI_SPACE					' '
#define	ANSI_PERIOD					'.'
#define	ANSI_APPLE_CHAR				0xF0
#define	AFP_GREEK_UNICODE_APPLE_CHAR		0x03c0

#define	UNICODE_SPACE				L' '
#define	UNICODE_PERIOD				L'.'

GLOBAL	WCHAR	AfpMungedUnicodeSpace EQU 0;
GLOBAL	WCHAR	AfpMungedUnicodePeriod EQU 0;

#ifdef	_MACANSI_LOCALS

// Invalid NtFs characters are mapped starting at this value
#define	AFP_INITIAL_INVALID_HIGH	0x20
#define	AFP_INVALID_HIGH			0x7F
#define	AFP_ALT_UNICODE_BASE		0xF000

LOCAL	PWCHAR	afpAltUnicodeTable = NULL;
LOCAL	PBYTE	afpAltAnsiTable = NULL;
LOCAL	WCHAR	afpLastAltChar = AFP_ALT_UNICODE_BASE + AFP_INITIAL_INVALID_HIGH;
LOCAL	WCHAR	afpAppleUnicodeChar = 0;

#endif	// _MACANSI_LOCALS

#endif	// _MACANSI_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\server\memory.c ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	memory.c

Abstract:

	This module contains the routines which allocates and free memory - both
	paged and non-paged.

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	25 Apr 1992		Initial Version
	11 Mar 1993		SueA - Fixed AfpAllocUnicodeString to expect byte count,
					       not char count
Notes:	Tab stop: 4
--*/

#define	FILENUM	FILE_MEMORY

#define	AFPMEM_LOCALS
#include <afp.h>
#include <iopool.h>
#include <scavengr.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, AfpMemoryInit)
#pragma alloc_text( PAGE, AfpMemoryDeInit)
#endif


/***	AfpMemoryInit
 *
 *	Initialize the IO Pool system.
 */
NTSTATUS
AfpMemoryInit(
	VOID
)
{
	NTSTATUS	Status;

	INITIALIZE_SPIN_LOCK(&afpIoPoolLock);

	Status = AfpScavengerScheduleEvent(afpIoPoolAge,
									   NULL,
									   POOL_AGE_TIME,
									   False);
	return Status;
}

/***	AfpMemoryDeInit
 *
 *	Free any IO pool buffers.
 */
VOID
AfpMemoryDeInit(
	VOID
)
{
	PIOPOOL	pPool, pFree;

	for (pPool = afpIoPoolHead;
		 pPool != NULL;)
	{
		ASSERT(VALID_IOP(pPool));
		pFree = pPool;
		pPool = pPool->iop_Next;
		ASSERT (pFree->iop_NumFreeBufs == NUM_BUFS_IN_POOL);
		ASSERT (pFree->iop_NumFreeLocks == NUM_LOCKS_IN_POOL);
		AfpFreeMemory(pFree);
	}
}

/***	AfpAllocMemory
 *
 *	Allocate a block of memory from either the paged or the non-paged pool
 *	based on the memory tag. This is just a wrapper over ExAllocatePool.
 *	Allocation failures are error-logged. We always allocate a DWORD more
 *	than the specified size to accomodate the size. This is used by
 *	AfpFreeMemory to update the statistics.
 *
 *	While we are debugging, we also pad the block with a signature and test
 *	it when we free it. This detects memory overrun.
 */
PBYTE FASTCALL
AfpAllocMemory(
#ifdef	TRACK_MEMORY_USAGE
	IN	LONG	Size,
	IN	DWORD	FileLine
#else
	IN	LONG	Size
#endif
)
{
	KIRQL		OldIrql;
	PBYTE		Buffer;
	DWORD		OldMaxUsage;
	POOL_TYPE	PoolType;
	PDWORD		pCurUsage, pMaxUsage, pCount, pLimit;
        PDWORD          pDwordBuf;
	BOOLEAN		Zeroed;
#if DBG
	DWORD		Signature;
#endif
#ifdef	PROFILING
	TIME		TimeS1, TimeS2, TimeE, TimeD;

	AfpGetPerfCounter(&TimeS1);
#endif

	ASSERT ((Size & ~MEMORY_TAG_MASK) < MAXIMUM_ALLOC_SIZE);

	// Make sure that this allocation will not put us over the limit
	// of paged/non-paged pool that we can allocate.
	//
	// Account for this allocation in the statistics database.

	Zeroed = False;
	if (Size & ZEROED_MEMORY_TAG)
	{
		Zeroed = True;
        Size &= ~ZEROED_MEMORY_TAG;
	}

	if (Size & NON_PAGED_MEMORY_TAG)
	{
		PoolType  = NonPagedPool;
		pCurUsage = &AfpServerStatistics.stat_CurrNonPagedUsage;
		pMaxUsage = &AfpServerStatistics.stat_MaxNonPagedUsage;
		pCount    =	&AfpServerStatistics.stat_NonPagedCount;
		pLimit    = &AfpNonPagedPoolLimit;
#if DBG
		Signature = NONPAGED_BLOCK_SIGNATURE;
#endif
	}
	else
	{
		ASSERT (Size & PAGED_MEMORY_TAG);
		PoolType  = PagedPool;
		pCurUsage = &AfpServerStatistics.stat_CurrPagedUsage;
		pMaxUsage = &AfpServerStatistics.stat_MaxPagedUsage;
		pCount    =	&AfpServerStatistics.stat_PagedCount;
		pLimit    = &AfpPagedPoolLimit;
#if DBG
		Signature = PAGED_BLOCK_SIGNATURE;
#endif
	}

	Size &= ~MEMORY_TAG_MASK;

    if (Size == 0 )
    {
		DBGPRINT(DBG_COMP_MEMORY, DBG_LEVEL_ERR,
				("afpAllocMemory: Alloc for 0 bytes!\n"));
        ASSERT(0);
        return(NULL);
    }

	Size = DWORDSIZEBLOCK(Size) +
#if DBG
			sizeof(DWORD) +				// For the signature
#endif
                        LONGLONGSIZEBLOCK(sizeof(TAG));

	ACQUIRE_SPIN_LOCK(&AfpStatisticsLock, &OldIrql);

	*pCurUsage += Size;
	(*pCount) ++;

	OldMaxUsage = *pMaxUsage;
	if (*pCurUsage > *pMaxUsage)
		*pMaxUsage = *pCurUsage;

	RELEASE_SPIN_LOCK(&AfpStatisticsLock, OldIrql);

#ifdef	PROFILING
	AfpGetPerfCounter(&TimeS2);
#endif

	// Do the actual memory allocation.  Allocate four extra bytes so
	// that we can store the size of the allocation for the free routine.
	if ((Buffer = ExAllocatePoolWithTag(PoolType, Size, AFP_TAG)) == NULL)
	{
		ACQUIRE_SPIN_LOCK(&AfpStatisticsLock, &OldIrql);

		*pCurUsage -= Size;
		*pMaxUsage = OldMaxUsage;

		RELEASE_SPIN_LOCK(&AfpStatisticsLock, OldIrql);
		AFPLOG_DDERROR(AFPSRVMSG_PAGED_POOL, STATUS_NO_MEMORY, &Size,
					 sizeof(Size), NULL);

		DBGPRINT(DBG_COMP_SDA, DBG_LEVEL_ERR,
			("AfpAllocMemory: ExAllocatePool returned NULL for %d bytes\n",Size));

		return NULL;
	}
#ifdef	PROFILING
	AfpGetPerfCounter(&TimeE);
	TimeD.QuadPart = TimeE.QuadPart - TimeS2.QuadPart;
	if (PoolType == NonPagedPool)
	{
		INTERLOCKED_INCREMENT_LONG(AfpServerProfile->perf_ExAllocCountN);
	
		INTERLOCKED_ADD_LARGE_INTGR(&AfpServerProfile->perf_ExAllocTimeN,
									TimeD,
									&AfpStatisticsLock);
	else
	{
		INTERLOCKED_INCREMENT_LONG(AfpServerProfile->perf_ExAllocCountP);
	
		INTERLOCKED_ADD_LARGE_INTGR(&AfpServerProfile->perf_ExAllocTimeP,
									TimeD,
									&AfpStatisticsLock);
	}

	TimeD.QuadPart = TimeE.QuadPart - TimeS1.QuadPart;
	if (PoolType == NonPagedPool)
	{
		INTERLOCKED_INCREMENT_LONG(&AfpServerProfile->perf_AfpAllocCountN);
	}
	else
	{
		INTERLOCKED_ADD_LARGE_INTGR(&AfpServerProfile->perf_AfpAllocTimeP,
									TimeD,
									&AfpStatisticsLock);
	}
#endif

	// Save the size of this block along with the tag in the extra space we allocated.
        pDwordBuf = (PDWORD)Buffer;

#if DBG
        *pDwordBuf = 0xCAFEBEAD;
#endif
        // skip past the unused dword (it's only use in life is to get the buffer quad-aligned!)
        pDwordBuf++;

	((PTAG)pDwordBuf)->tg_Size = Size;
	((PTAG)pDwordBuf)->tg_Tag = (PoolType == PagedPool) ? PGD_MEM_TAG : NPG_MEM_TAG;

#if DBG
	// Write the signature at the end
	*(PDWORD)((PBYTE)Buffer + Size - sizeof(DWORD)) = Signature;
#endif

#ifdef	TRACK_MEMORY_USAGE
	DBGPRINT(DBG_COMP_MEMORY, DBG_LEVEL_INFO,
			("AfpAllocMemory: %lx Allocated %lx bytes @%lx\n",
			*(PDWORD)((PBYTE)(&Size) - sizeof(Size)), Size, Buffer));
	AfpTrackMemoryUsage(Buffer, True, (BOOLEAN)(PoolType == PagedPool), FileLine);
#endif

	// Return a pointer to the memory after the tag. Clear the memory, if requested
        //
        // We need the memory to be quad-aligned, so even though sizeof(TAG) is 4, we skip
        // LONGLONG..., which is 8.  The 1st dword is unused (for now?), the 2nd dword is the TAG

        Buffer += LONGLONGSIZEBLOCK(sizeof(TAG));

        Size -= LONGLONGSIZEBLOCK(sizeof(TAG));

	if (Zeroed)
	{
#if	DBG
		RtlZeroMemory(Buffer, Size - sizeof(DWORD));
#else
		RtlZeroMemory(Buffer, Size);
#endif
	}


	return Buffer;
}


/***	AfpAllocNonPagedLowPriority
 *
 *	Allocate a block of non-paged memory with a low priority
 */
PBYTE FASTCALL
AfpAllocNonPagedLowPriority(
#ifdef	TRACK_MEMORY_USAGE
	IN	LONG	Size,
	IN	DWORD	FileLine
#else
	IN	LONG	Size
#endif
)
{
	KIRQL		OldIrql;
	PBYTE		Buffer;
	DWORD		OldMaxUsage;
	POOL_TYPE	PoolType;
	PDWORD		pCurUsage, pMaxUsage, pCount, pLimit;
    PDWORD      pDwordBuf;
#if DBG
	DWORD		Signature;
#endif
#ifdef	PROFILING
	TIME		TimeS1, TimesS2, TimeE, TimeD;

	AfpGetPerfCounter(&TimeS1);
#endif

	ASSERT ((Size & ~MEMORY_TAG_MASK) < MAXIMUM_ALLOC_SIZE);

	PoolType  = NonPagedPool;
	pCurUsage = &AfpServerStatistics.stat_CurrNonPagedUsage;
	pMaxUsage = &AfpServerStatistics.stat_MaxNonPagedUsage;
	pCount    =	&AfpServerStatistics.stat_NonPagedCount;
	pLimit    = &AfpNonPagedPoolLimit;

#if DBG
	Signature = NONPAGED_BLOCK_SIGNATURE;
#endif

	Size &= ~MEMORY_TAG_MASK;
	Size = DWORDSIZEBLOCK(Size) +
#if DBG
			sizeof(DWORD) +				// For the signature
#endif
                        LONGLONGSIZEBLOCK(sizeof(TAG));

	ACQUIRE_SPIN_LOCK(&AfpStatisticsLock, &OldIrql);

	*pCurUsage += Size;
	(*pCount) ++;


	OldMaxUsage = *pMaxUsage;
	if (*pCurUsage > *pMaxUsage)
		*pMaxUsage = *pCurUsage;

	RELEASE_SPIN_LOCK(&AfpStatisticsLock, OldIrql);

#ifdef	PROFILING
	AfpGetPerfCounter(&TimeS2);
#endif

	// Do the actual memory allocation.  Allocate four extra bytes so
	// that we can store the size of the allocation for the free routine.

	Buffer = ExAllocatePoolWithTagPriority(PoolType,
                                           Size,
                                           AFP_TAG,
                                           LowPoolPriority);

	if (Buffer == NULL)
	{
        ASSERT(0);

		ACQUIRE_SPIN_LOCK(&AfpStatisticsLock, &OldIrql);

		*pCurUsage -= Size;
		*pMaxUsage = OldMaxUsage;

		RELEASE_SPIN_LOCK(&AfpStatisticsLock, OldIrql);
		AFPLOG_DDERROR(AFPSRVMSG_PAGED_POOL, STATUS_NO_MEMORY, &Size,
					 sizeof(Size), NULL);
		return NULL;
	}

#ifdef	PROFILING
	AfpGetPerfCounter(&TimeE);
	TimeD.QuadPart = TimeE.QuadPart - TimeS2.QuadPart;

	INTERLOCKED_INCREMENT_LONG(AfpServerProfile->perf_ExAllocCountN);
	
	INTERLOCKED_ADD_LARGE_INTGR(&AfpServerProfile->perf_ExAllocTimeN,
								TimeD,
								&AfpStatisticsLock);

	TimeD.QuadPart = TimeE.QuadPart - TimeS1.QuadPart;
	
	INTERLOCKED_INCREMENT_LONG(&AfpServerProfile->perf_AfpAllocCountN);
#endif

	// Save the size of this block along with the tag in the extra space we allocated.
    pDwordBuf = (PDWORD)Buffer;

#if DBG
    *pDwordBuf = 0xCAFEBEAD;
#endif
        // skip past the unused dword (it's only use in life is to get the buffer quad-aligned!)
    pDwordBuf++;

	((PTAG)pDwordBuf)->tg_Size = Size;
	((PTAG)pDwordBuf)->tg_Tag = (PoolType == PagedPool) ? PGD_MEM_TAG : NPG_MEM_TAG;

#if DBG
	// Write the signature at the end
	*(PDWORD)((PBYTE)Buffer + Size - sizeof(DWORD)) = Signature;
#endif

#ifdef	TRACK_MEMORY_USAGE
	DBGPRINT(DBG_COMP_MEMORY, DBG_LEVEL_INFO,
			("AfpAllocMemory: %lx Allocated %lx bytes @%lx\n",
			*(PDWORD)((PBYTE)(&Size) - sizeof(Size)), Size, Buffer));
	AfpTrackMemoryUsage(Buffer, True, (BOOLEAN)(PoolType == PagedPool), FileLine);
#endif

	// Return a pointer to the memory after the tag. Clear the memory, if requested
    //
    // We need the memory to be quad-aligned, so even though sizeof(TAG) is 4, we skip
    // LONGLONG..., which is 8.  The 1st dword is unused (for now?), the 2nd dword is the TAG

    Buffer += LONGLONGSIZEBLOCK(sizeof(TAG));

    Size -= LONGLONGSIZEBLOCK(sizeof(TAG));

	return Buffer;
}

/***	AfpFreeMemory
 *
 *	Free the block of memory allocated via AfpAllocMemory.
 *	This is a wrapper around ExFreePool.
 */
VOID FASTCALL
AfpFreeMemory(
	IN	PVOID	pBuffer
)
{
	BOOLEAN	Paged = False;
	DWORD	Size;
        DWORD   numDwords;
        PDWORD  pDwordBuf;
	PTAG	pTag;
        DWORD   i;
#ifdef	PROFILING
	TIME	TimeS1, TimeS2, TimeE, TimeD1, TimeD2;

	AfpGetPerfCounter(&TimeS1);
#endif


	//
	// Get a pointer to the block allocated by ExAllocatePool.
	//
	pTag = (PTAG)((PBYTE)pBuffer - sizeof(TAG));
	Size = pTag->tg_Size;

	if (pTag->tg_Tag == IO_POOL_TAG)
	{
		AfpIOFreeBuffer(pBuffer);
		return;
	}

	pBuffer = ((PBYTE)pBuffer - LONGLONGSIZEBLOCK(sizeof(TAG)));

	if (pTag->tg_Tag == PGD_MEM_TAG)
		Paged = True;

#if DBG
	{
		DWORD	Signature;

		// Check the signature at the end
		Signature = (Paged) ? PAGED_BLOCK_SIGNATURE : NONPAGED_BLOCK_SIGNATURE;

		if (*(PDWORD)((PBYTE)pBuffer + Size - sizeof(DWORD)) != Signature)
		{
			DBGPRINT(DBG_COMP_MEMORY, DBG_LEVEL_FATAL,
					("AfpFreeMemory: Memory Overrun\n"));
			DBGBRK(DBG_LEVEL_FATAL);
			return;
		}
		// Clear the signature
		*(PDWORD)((PBYTE)pBuffer + Size - sizeof(DWORD)) -= 1;

        // change the memory so that we can catch weirdnesses like using freed memory
        numDwords = (Size/sizeof(DWORD));
        numDwords -= 3;                  // 2 dwords at the beginning and 1 at the end

        pDwordBuf = (PULONG)pBuffer;
        *pDwordBuf++ = 0xABABABAB;         // to indicate that it's freed!
        pDwordBuf++;                       // skip past the tag
        for (i=0; i<numDwords; i++,pDwordBuf++)
        {
            *pDwordBuf = 0x55667788;
        }
	}

#endif	// DBG

#ifdef	TRACK_MEMORY_USAGE
	AfpTrackMemoryUsage(pBuffer, False, Paged, 0);
#endif

	//
	// Update the pool usage statistic.
	//
	if (Paged)
	{
		INTERLOCKED_ADD_ULONG(&AfpServerStatistics.stat_CurrPagedUsage,
							  (ULONG)(-(LONG)Size),
							  &AfpStatisticsLock);
		INTERLOCKED_ADD_ULONG(&AfpServerStatistics.stat_PagedCount,
							  (ULONG)-1,
							  &AfpStatisticsLock);
	}
	else
	{
		INTERLOCKED_ADD_ULONG(&AfpServerStatistics.stat_CurrNonPagedUsage,
							  (ULONG)(-(LONG)Size),
							  &AfpStatisticsLock);
		INTERLOCKED_ADD_ULONG(&AfpServerStatistics.stat_NonPagedCount,
							  (ULONG)-1,
							  &AfpStatisticsLock);
	}

#ifdef	PROFILING
	AfpGetPerfCounter(&TimeS2);
#endif

	// Free the pool and return.
	ExFreePool(pBuffer);

#ifdef	PROFILING
	AfpGetPerfCounter(&TimeE);
	TimeD2.QuadPart = TimeE.QuadPart - TimeS2.QuadPart;
	if (Paged)
	{
		INTERLOCKED_INCREMENT_LONG(&AfpServerProfile->perf_ExFreeCountP);
	
		INTERLOCKED_ADD_LARGE_INTGR(AfpServerProfile->perf_ExFreeTimeP,
									TimeD2,
									&AfpStatisticsLock);
		TimeD1.QuadPart = TimeE.QuadPart - TimeS1.QuadPart;
		INTERLOCKED_INCREMENT_LONG(&AfpServerProfile->perf_AfpFreeCountP);
	
		INTERLOCKED_ADD_LARGE_INTGR(&AfpServerProfile->perf_AfpFreeTimeP,
									TimeD1,
									&AfpStatisticsLock);
	}
	else
	{
		INTERLOCKED_INCREMENT_LONG(&AfpServerProfile->perf_ExFreeCountN);
	
		INTERLOCKED_ADD_LARGE_INTGR(&AfpServerProfile->perf_ExFreeTimeN,
									TimeD2,
									&AfpStatisticsLock);
		TimeD1.QuadPart = TimeE.QuadPart - TimeS1.QuadPart;
		INTERLOCKED_INCREMENT_LONG(&AfpServerProfile->perf_AfpFreeCountN);
	
		INTERLOCKED_ADD_LARGE_INTGR(&AfpServerProfile->perf_AfpFreeTimeN,
									TimeD1,
									&AfpStatisticsLock);
	}
#endif
}


/***	AfpAllocPAMemory
 *
 *	Similar to AfpAllocMemory, except that this allocates page-aligned/page-granular memory.
 */
PBYTE FASTCALL
AfpAllocPAMemory(
#ifdef	TRACK_MEMORY_USAGE
	IN	LONG	Size,
	IN	DWORD	FileLine
#else
	IN	LONG	Size
#endif
)
{
	KIRQL		OldIrql;
	PBYTE		Buffer;
	DWORD		OldMaxUsage;
	POOL_TYPE	PoolType;
	PDWORD		pCurUsage, pMaxUsage, pCount, pLimit;
	BOOLEAN		PageAligned;
#if DBG
	DWORD		Signature;
#endif
#ifdef	PROFILING
	TIME		TimeS1, TimeS2, TimeE, TimeD;

	AfpGetPerfCounter(&TimeS1);
#endif

	ASSERT ((Size & ~MEMORY_TAG_MASK) < MAXIMUM_ALLOC_SIZE);

	ASSERT (((Size & ~MEMORY_TAG_MASK) % PAGE_SIZE) == 0);

	//
	// Make sure that this allocation will not put us over the limit
	// of paged/non-paged pool that we can allocate.
	//
	// Account for this allocation in the statistics database.

	if (Size & NON_PAGED_MEMORY_TAG)
	{
		PoolType  = NonPagedPool;
		pCurUsage = &AfpServerStatistics.stat_CurrNonPagedUsage;
		pMaxUsage = &AfpServerStatistics.stat_MaxNonPagedUsage;
		pCount    =	&AfpServerStatistics.stat_NonPagedCount;
		pLimit    = &AfpNonPagedPoolLimit;
#if DBG
		Signature = NONPAGED_BLOCK_SIGNATURE;
#endif
	}
	else
	{
		ASSERT (Size & PAGED_MEMORY_TAG);
		PoolType = PagedPool;
		pCurUsage = &AfpServerStatistics.stat_CurrPagedUsage;
		pMaxUsage = &AfpServerStatistics.stat_MaxPagedUsage;
		pCount    =	&AfpServerStatistics.stat_PagedCount;
		pLimit    = &AfpPagedPoolLimit;
#if DBG
		Signature = PAGED_BLOCK_SIGNATURE;
#endif
	}

	Size &= ~MEMORY_TAG_MASK;

	ACQUIRE_SPIN_LOCK(&AfpStatisticsLock, &OldIrql);

	*pCurUsage += Size;
	(*pCount) ++;

// apparently very old code, added to track some problem: not needed anymore
#if 0
#if DBG
	// Make sure that this allocation will not put us over the limit
	// of paged pool that we can allocate. ONLY FOR CHECKED BUILDS NOW.

	if (*pCurUsage > *pLimit)
	{
		*pCurUsage -= Size;

		DBGPRINT(DBG_COMP_MEMORY, DBG_LEVEL_ERR,
				("afpAllocMemory: %sPaged Allocation exceeds limits %lx/%lx\n",
				(PoolType == NonPagedPool) ? "Non" : "", Size, *pLimit));

		RELEASE_SPIN_LOCK(&AfpStatisticsLock, OldIrql);

		DBGBRK(DBG_LEVEL_FATAL);

		AFPLOG_DDERROR((PoolType == PagedPool) ?
							AFPSRVMSG_PAGED_POOL : AFPSRVMSG_NONPAGED_POOL,
						STATUS_NO_MEMORY,
						NULL,
						0,
						NULL);

		return NULL;
	}
#endif
#endif  // #if 0

	OldMaxUsage = *pMaxUsage;
	if (*pCurUsage > *pMaxUsage)
		*pMaxUsage = *pCurUsage;

	RELEASE_SPIN_LOCK(&AfpStatisticsLock, OldIrql);

#ifdef	PROFILING
	AfpGetPerfCounter(&TimeS2);
#endif

	// Do the actual memory allocation.
	if ((Buffer = ExAllocatePoolWithTag(PoolType, Size, AFP_TAG)) == NULL)
	{
		ACQUIRE_SPIN_LOCK(&AfpStatisticsLock, &OldIrql);

		*pCurUsage -= Size;
		*pMaxUsage = OldMaxUsage;

		RELEASE_SPIN_LOCK(&AfpStatisticsLock, OldIrql);
		AFPLOG_DDERROR(AFPSRVMSG_PAGED_POOL, STATUS_NO_MEMORY, &Size,
					 sizeof(Size), NULL);
#if DBG
        DbgBreakPoint();
#endif
		return NULL;
	}
#ifdef	PROFILING
	AfpGetPerfCounter(&TimeE);
	TimeD.QuadPart = TimeE.QuadPart - TimeS2.QuadPart;
	INTERLOCKED_INCREMENT_LONG((PoolType == NonPagedPool) ?
									&AfpServerProfile->perf_ExAllocCountN :
									&AfpServerProfile->perf_ExAllocCountP);

	INTERLOCKED_ADD_LARGE_INTGR((PoolType == NonPagedPool) ?
									&AfpServerProfile->perf_ExAllocTimeN :
									&AfpServerProfile->perf_ExAllocTimeP,
								 TimeD,
								 &AfpStatisticsLock);

	TimeD.QuadPart = TimeE.QuadPart - TimeS1.QuadPart;
	INTERLOCKED_INCREMENT_LONG((PoolType == NonPagedPool) ?
									&AfpServerProfile->perf_AfpAllocCountN :
									&AfpServerProfile->perf_AfpAllocCountP);

	INTERLOCKED_ADD_LARGE_INTGR((PoolType == NonPagedPool) ?
									&AfpServerProfile->perf_AfpAllocTimeN :
									&AfpServerProfile->perf_AfpAllocTimeP,
								 TimeD,
								 &AfpStatisticsLock);
#endif

#ifdef	TRACK_MEMORY_USAGE
	DBGPRINT(DBG_COMP_MEMORY, DBG_LEVEL_INFO,
			("AfpAllocMemory: %lx Allocated %lx bytes @%lx\n",
			*(PDWORD)((PBYTE)(&Size) - sizeof(Size)), Size, Buffer));
	AfpTrackMemoryUsage(Buffer, True, (BOOLEAN)(PoolType == PagedPool), FileLine);
#endif

	return Buffer;
}


/***	AfpFreePAMemory
 *
 *	Free the block of memory allocated via AfpAllocPAMemory.
 */
VOID FASTCALL
AfpFreePAMemory(
	IN	PVOID	pBuffer,
	IN	DWORD	Size
)
{
	BOOLEAN	Paged = True;
#ifdef	PROFILING
	TIME	TimeS1, TimeS2, TimeE, TimeD;

	AfpGetPerfCounter(&TimeS1);
#endif

	ASSERT ((Size & ~MEMORY_TAG_MASK) < MAXIMUM_ALLOC_SIZE);

	ASSERT (((Size & ~MEMORY_TAG_MASK) % PAGE_SIZE) == 0);

	if (Size & NON_PAGED_MEMORY_TAG)
		Paged = False;

#ifdef	TRACK_MEMORY_USAGE
	AfpTrackMemoryUsage(pBuffer, False, Paged, 0);
#endif

	//
	// Update the pool usage statistic.
	//
	Size &= ~(NON_PAGED_MEMORY_TAG | PAGED_MEMORY_TAG);
	if (Paged)
	{
		INTERLOCKED_ADD_ULONG(&AfpServerStatistics.stat_CurrPagedUsage,
							  (ULONG)(-(LONG)Size),
							  &AfpStatisticsLock);
		INTERLOCKED_ADD_ULONG(&AfpServerStatistics.stat_PagedCount,
							  (ULONG)-1,
							  &AfpStatisticsLock);
	}
	else
	{
		INTERLOCKED_ADD_ULONG(&AfpServerStatistics.stat_CurrNonPagedUsage,
							  (ULONG)(-(LONG)Size),
							  &AfpStatisticsLock);
		INTERLOCKED_ADD_ULONG(&AfpServerStatistics.stat_NonPagedCount,
							  (ULONG)-1,
							  &AfpStatisticsLock);
	}

#ifdef	PROFILING
	AfpGetPerfCounter(&TimeS2);
#endif

	// Free the pool and return.
	ExFreePool(pBuffer);

#ifdef	PROFILING
	AfpGetPerfCounter(&TimeE);
	TimeD.QuadPart = TimeE.QuadPart - TimeS2.QuadPart;
	INTERLOCKED_INCREMENT_LONG( Paged ?
									&AfpServerProfile->perf_ExFreeCountP :
									&AfpServerProfile->perf_ExFreeCountN);

	INTERLOCKED_ADD_LARGE_INTGR(Paged ?
									&AfpServerProfile->perf_ExFreeTimeP :
									&AfpServerProfile->perf_ExFreeTimeN,
								 TimeD,
								 &AfpStatisticsLock);
	TimeD1.QuadPart = TimeE.QuadPart - TimeS1.QuadPart;
	INTERLOCKED_INCREMENT_LONG( Paged ?
									&AfpServerProfile->perf_AfpFreeCountP :
									&AfpServerProfile->perf_AfpFreeCountN);

	INTERLOCKED_ADD_LARGE_INTGR(Paged ?
									&AfpServerProfile->perf_AfpFreeTimeP :
									&AfpServerProfile->perf_AfpFreeTimeN,
								 TimeD,
								 &AfpStatisticsLock);
#endif
}


/***	AfpAllocIrp
 *
 *	This is a wrapper over IoAllocateIrp. We also do some book-keeping.
 */
PIRP FASTCALL
AfpAllocIrp(
	IN CCHAR StackSize
)
{
	PIRP	pIrp;

	if ((pIrp = IoAllocateIrp(StackSize, False)) == NULL)
	{
		DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_INFO,
				("afpAllocIrp: Allocation failed\n"));
        if (KeGetCurrentIrql() < DISPATCH_LEVEL)
        {
		    AFPLOG_ERROR(AFPSRVMSG_ALLOC_IRP, STATUS_INSUFFICIENT_RESOURCES,
					 NULL, 0, NULL);
        }
	}
    else
    {
#ifdef	PROFILING
	    INTERLOCKED_INCREMENT_LONG((PLONG)&AfpServerProfile->perf_cAllocatedIrps);
#endif
        AFP_DBG_INC_COUNT(AfpDbgIrpsAlloced);
    }

	DBGPRINT(DBG_COMP_MEMORY, DBG_LEVEL_INFO,
							("AfAllocIrp: Allocated Irp %lx\n", pIrp));
	return pIrp;
}


/***	AfpFreeIrp
 *
 *	This is a wrapper over IoFreeIrp. We also do some book-keeping.
 */
VOID FASTCALL
AfpFreeIrp(
	IN	PIRP	pIrp
)
{
	ASSERT (pIrp != NULL);

	DBGPRINT(DBG_COMP_MEMORY, DBG_LEVEL_INFO,
							("AfFreeIrp: Freeing Irp %lx\n", pIrp));
	IoFreeIrp(pIrp);

    AFP_DBG_DEC_COUNT(AfpDbgIrpsAlloced);

#ifdef	PROFILING
	INTERLOCKED_DECREMENT_LONG((PLONG)&AfpServerProfile->perf_cAllocatedIrps);
#endif
}


/***	AfpAllocMdl
 *
 *	This is a wrapper over IoAllocateMdl. We also do some book-keeping.
 */
PMDL FASTCALL
AfpAllocMdl(
	IN	PVOID	pBuffer,
	IN	DWORD	Size,
	IN	PIRP	pIrp
)
{
	PMDL	pMdl;

	if ((pMdl = IoAllocateMdl(pBuffer, Size, False, False, pIrp)) == NULL)
	{
		DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_INFO,
				("AfpAllocMdl: Allocation failed\n"));
		AFPLOG_ERROR(AFPSRVMSG_ALLOC_MDL, STATUS_INSUFFICIENT_RESOURCES,
					 NULL, 0, NULL);
	}
	else
	{
#ifdef	PROFILING
		INTERLOCKED_INCREMENT_LONG((PLONG)&AfpServerProfile->perf_cAllocatedMdls);
#endif
        AFP_DBG_INC_COUNT(AfpDbgMdlsAlloced);
		MmBuildMdlForNonPagedPool(pMdl);
	}

	DBGPRINT(DBG_COMP_MEMORY, DBG_LEVEL_INFO,
							("AfAllocMdl: Allocated Mdl %lx\n", pMdl));
	return pMdl;
}


/***	AfpFreeMdl
 *
 *	This is a wrapper over IoFreeMdl. We also do some book-keeping.
 */
VOID FASTCALL
AfpFreeMdl(
	IN	PMDL	pMdl
)
{
	ASSERT (pMdl != NULL);

	DBGPRINT(DBG_COMP_MEMORY, DBG_LEVEL_INFO,
							("AfFreeMdl: Freeing Mdl %lx\n", pMdl));
	IoFreeMdl(pMdl);
    AFP_DBG_DEC_COUNT(AfpDbgMdlsAlloced);

#ifdef	PROFILING
	INTERLOCKED_DECREMENT_LONG((PLONG)&AfpServerProfile->perf_cAllocatedMdls);
#endif
}



/***	AfpMdlChainSize
 *
 *	This routine counts the bytes in the mdl chain
 */
DWORD FASTCALL
AfpMdlChainSize(
	IN	PMDL    pMdl
)
{
    DWORD   dwSize=0;

    while (pMdl)
    {
        dwSize += MmGetMdlByteCount(pMdl);
        pMdl = pMdl->Next;
    }

	return (dwSize);
}


/***	AfpIOAllocBuffer
 *
 *	Maintain a pool of I/O buffers and fork-locks. These are aged out when not in use.
 */
PVOID FASTCALL
AfpIOAllocBuffer(
	IN	DWORD  	BufSize
)
{
	KIRQL		OldIrql;
	PIOPOOL		pPool;
	PIOPOOL_HDR	pPoolHdr, *ppPoolHdr;
	BOOLEAN		Found = False;
	PVOID		pBuf = NULL;
#ifdef	PROFILING
	TIME		TimeS, TimeE, TimeD;

	INTERLOCKED_INCREMENT_LONG( &AfpServerProfile->perf_BPAllocCount );

	AfpGetPerfCounter(&TimeS);
#endif

	ASSERT (BufSize <= (DSI_SERVER_REQUEST_QUANTUM+DSI_HEADER_SIZE));

	DBGPRINT(DBG_COMP_MEMORY, DBG_LEVEL_INFO,
			("AfpIOAllocBuffer: Request for %d\n", BufSize));

    //
    // if a large block (over 4K on x86) is being allocated, we don't want to
    // tie it in in the IoPool.  Do a direct allocation, set flags etc. so we know
    // how to free it when it's freed
    //
    if (BufSize > ASP_QUANTUM)
    {
		pPoolHdr = (PIOPOOL_HDR) ExAllocatePoolWithTag(
                                    NonPagedPool,
                                    (BufSize + sizeof(IOPOOL_HDR)),
                                    AFP_TAG);
        if (pPoolHdr == NULL)
        {
            DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                ("AfpIOAllocBuffer: big buf alloc (%d bytes) failed!\n",BufSize));

            return(NULL);
        }

#if	DBG
	    pPoolHdr->Signature = POOLHDR_SIGNATURE;
#endif
	    pPoolHdr->iph_Tag.tg_Tag = IO_POOL_TAG;
        pPoolHdr->iph_Tag.tg_Flags = IO_POOL_HUGE_BUFFER;

        // we only have 20 bits for tg_Size, so the size had better be less than that!
        ASSERT(BufSize <= 0xFFFFF);

        pPoolHdr->iph_Tag.tg_Size = BufSize;

        return((PVOID)((PBYTE)pPoolHdr + sizeof(IOPOOL_HDR)));
    }


	ACQUIRE_SPIN_LOCK(&afpIoPoolLock, &OldIrql);

  try_again:
	for (pPool = afpIoPoolHead;
		 pPool != NULL;
		 pPool = pPool->iop_Next)
	{
		ASSERT(VALID_IOP(pPool));

		if (BufSize > sizeof(FORKLOCK))
		{
			if (pPool->iop_NumFreeBufs > 0)
			{
				LONG	i;

				for (i = 0, ppPoolHdr = &pPool->iop_FreeBufHead;
					 (i < pPool->iop_NumFreeBufs);
					 ppPoolHdr = &pPoolHdr->iph_Next, i++)
				{
					pPoolHdr = *ppPoolHdr;
					ASSERT(VALID_PLH(pPoolHdr));

					if (pPoolHdr->iph_Tag.tg_Size >= BufSize)
					{
						DBGPRINT(DBG_COMP_MEMORY, DBG_LEVEL_INFO,
								("AfpIOAllocBuffer: Found space (bufs) in pool %lx\n", pPool));
						ASSERT (pPoolHdr->iph_Tag.tg_Flags == IO_POOL_NOT_IN_USE);
						*ppPoolHdr = pPoolHdr->iph_Next;
						INTERLOCKED_INCREMENT_LONG((PLONG)&AfpServerStatistics.stat_IoPoolHits);

						Found = True;
						break;
					}
				}
				if (Found)
					break;
			}
		}
		else if (pPool->iop_NumFreeLocks > 0)
		{
			// Even IO buffers for size <= sizeof(FORKLOCK) are allocated out of the
			// lock pool - hey why not !!!
			pPoolHdr = pPool->iop_FreeLockHead;
			ASSERT(VALID_PLH(pPoolHdr));

			ASSERT(pPoolHdr->iph_Tag.tg_Flags == IO_POOL_NOT_IN_USE);
			pPool->iop_FreeLockHead = pPoolHdr->iph_Next;
			DBGPRINT(DBG_COMP_MEMORY, DBG_LEVEL_INFO,
					("AfpIOAllocBuffer: Found space (locks) in pool %lx\n", pPool));
			INTERLOCKED_INCREMENT_LONG((PLONG)&AfpServerStatistics.stat_IoPoolHits);
						
			Found = True;
			break;
		}

		// All empty pool blocks are the end.
		if ((pPool->iop_NumFreeBufs == 0) && (pPool->iop_NumFreeLocks == 0))
		{
			break;
		}
	}

	if (!Found)
	{
		INTERLOCKED_INCREMENT_LONG((PLONG)&AfpServerStatistics.stat_IoPoolMisses);
					
		// If we failed to find it, allocate a new pool chunk, initialize and
		// link it in
		pPool = (PIOPOOL)AfpAllocNonPagedMemory(POOL_ALLOC_SIZE);
		DBGPRINT(DBG_COMP_MEMORY, DBG_LEVEL_INFO,
				("AfpIOAllocBuffer: No free slot, allocated a new pool %lx\n", pPool));

		if (pPool != NULL)
		{
			LONG	i;
			PBYTE	p;

#if	DBG
			pPool->Signature = IOPOOL_SIGNATURE;
#endif
			pPool->iop_NumFreeBufs = NUM_BUFS_IN_POOL;
			pPool->iop_NumFreeLocks = (BYTE)NUM_LOCKS_IN_POOL;
			AfpLinkDoubleAtHead(afpIoPoolHead, pPool, iop_Next, iop_Prev);
			p = (PBYTE)pPool + sizeof(IOPOOL);
            pPool->iop_FreeBufHead =  (PIOPOOL_HDR)p;

			// Initialize pool of buffers and locks
			for (i = 0, pPoolHdr = pPool->iop_FreeBufHead;
				 i < (NUM_BUFS_IN_POOL + NUM_LOCKS_IN_POOL);
				 i++)
			{
#if	DBG
				pPoolHdr->Signature = POOLHDR_SIGNATURE;
#endif
				pPoolHdr->iph_Tag.tg_Flags = IO_POOL_NOT_IN_USE;		// Mark it un-used
				pPoolHdr->iph_Tag.tg_Tag = IO_POOL_TAG;
				if (i < NUM_BUFS_IN_POOL)
				{
					p += sizeof(IOPOOL_HDR) + (pPoolHdr->iph_Tag.tg_Size = afpPoolAllocSizes[i]);
					if (i == (NUM_BUFS_IN_POOL-1))
					{
						pPoolHdr->iph_Next = NULL;
						pPoolHdr = pPool->iop_FreeLockHead =  (PIOPOOL_HDR)p;
					}
                    else
					{
						pPoolHdr->iph_Next = (PIOPOOL_HDR)p;
						pPoolHdr = (PIOPOOL_HDR)p;
					}
				}
				else
				{
					pPoolHdr->iph_Tag.tg_Size = sizeof(FORKLOCK);
					p += (sizeof(IOPOOL_HDR) + sizeof(FORKLOCK));
					if (i == (NUM_BUFS_IN_POOL+NUM_LOCKS_IN_POOL-1))
					{
						pPoolHdr->iph_Next = NULL;

					}
					else
					{
						pPoolHdr->iph_Next = (PIOPOOL_HDR)p;
						pPoolHdr = (PIOPOOL_HDR)p;

					}
				}
			}

			// Adjust this since we'll increment this again up above. This was
			// really a miss and not a hit
			INTERLOCKED_DECREMENT_LONG((PLONG)&AfpServerStatistics.stat_IoPoolHits);
						
			goto try_again;
		}
	}

	if (Found)
	{
		PIOPOOL	pTmp;

		ASSERT(VALID_IOP(pPool));
		ASSERT(VALID_PLH(pPoolHdr));

		pPoolHdr->iph_pPool = pPool;
		pPoolHdr->iph_Tag.tg_Flags = IO_POOL_IN_USE;		// Mark it used
		pPool->iop_Age = 0;
		pBuf = (PBYTE)pPoolHdr + sizeof(IOPOOL_HDR);
		if (BufSize > sizeof(FORKLOCK))
		{
			pPool->iop_NumFreeBufs --;
		}
		else
		{
			pPool->iop_NumFreeLocks --;
		}

		// If the block is now empty, unlink it from here and move it
		// to the first empty slot. We know that all blocks 'earlier' than
		// this are non-empty.
		if ((pPool->iop_NumFreeBufs == 0) &&
	        (pPool->iop_NumFreeLocks == 0) &&
			((pTmp = pPool->iop_Next) != NULL) &&
			((pTmp->iop_NumFreeBufs > 0) || (pTmp->iop_NumFreeLocks > 0)))
		{
			ASSERT(VALID_IOP(pTmp));

			AfpUnlinkDouble(pPool, iop_Next, iop_Prev);
			for (; pTmp != NULL; pTmp = pTmp->iop_Next)
			{
				if (pTmp->iop_NumFreeBufs == 0)
				{
					// Found a free one. Park it right here.
					AfpInsertDoubleBefore(pPool, pTmp, iop_Next, iop_Prev);
					break;
				}
				else if (pTmp->iop_Next == NULL)	// We reached the end
				{
					AfpLinkDoubleAtEnd(pPool, pTmp, iop_Next, iop_Prev);
					break;
				}
			}
		}
	}

	RELEASE_SPIN_LOCK(&afpIoPoolLock, OldIrql);

#ifdef	PROFILING
	AfpGetPerfCounter(&TimeE);
	TimeD.QuadPart = TimeE.QuadPart - TimeS.QuadPart;
	INTERLOCKED_ADD_LARGE_INTGR(&AfpServerProfile->perf_BPAllocTime,
								TimeD,
								&AfpStatisticsLock);
#endif

	return pBuf;
}


/***	AfpIOFreeBuffer
 *
 *	Return the IO buffer to the pool. Reset its age to 0. Insert into the free list
 *	in ascending order of sizes for bufs and at the head for locks
 */
VOID FASTCALL
AfpIOFreeBuffer(
	IN	PVOID	pBuf
)
{
	KIRQL		OldIrql;
	PIOPOOL		pPool;
	PIOPOOL_HDR	pPoolHdr, *ppPoolHdr;
#ifdef	PROFILING
	TIME			TimeS, TimeE, TimeD;

	INTERLOCKED_INCREMENT_LONG( &AfpServerProfile->perf_BPFreeCount);
				
	AfpGetPerfCounter(&TimeS);
#endif

	DBGPRINT(DBG_COMP_MEMORY, DBG_LEVEL_INFO,
			("AfpIOFreeBuffer: Freeing %lx\n", pBuf));

	pPoolHdr = (PIOPOOL_HDR)((PBYTE)pBuf - sizeof(IOPOOL_HDR));
	ASSERT(VALID_PLH(pPoolHdr));
	ASSERT (pPoolHdr->iph_Tag.tg_Flags != IO_POOL_NOT_IN_USE);
	ASSERT (pPoolHdr->iph_Tag.tg_Tag == IO_POOL_TAG);

    //
    // if this is a huge buffer we allocated, free it here and return
    //
    if (pPoolHdr->iph_Tag.tg_Flags == IO_POOL_HUGE_BUFFER)
    {
        ASSERT(pPoolHdr->iph_Tag.tg_Size > ASP_QUANTUM);

        ExFreePool((PVOID)pPoolHdr);
        return;
    }

	pPool = pPoolHdr->iph_pPool;
	ASSERT(VALID_IOP(pPool));

	ACQUIRE_SPIN_LOCK(&afpIoPoolLock, &OldIrql);

	if (pPoolHdr->iph_Tag.tg_Size > sizeof(FORKLOCK))
	{
		ASSERT (pPool->iop_NumFreeBufs < NUM_BUFS_IN_POOL);

		for (ppPoolHdr = &pPool->iop_FreeBufHead;
			 (*ppPoolHdr) != NULL;
			 ppPoolHdr = &(*ppPoolHdr)->iph_Next)
		{
			ASSERT(VALID_PLH(*ppPoolHdr));
			if ((*ppPoolHdr)->iph_Tag.tg_Size > pPoolHdr->iph_Tag.tg_Size)
			{
				DBGPRINT(DBG_COMP_MEMORY, DBG_LEVEL_INFO,
						("AfpIOFreeBuffer: Found slot for %lx (%lx)\n",
						pBuf, pPool));
				break;
			}
		}
		pPoolHdr->iph_Next = (*ppPoolHdr);
		*ppPoolHdr = pPoolHdr;
		pPool->iop_NumFreeBufs ++;
	}
	else
	{
		ASSERT (pPool->iop_NumFreeLocks < NUM_LOCKS_IN_POOL);

		pPoolHdr->iph_Next = pPool->iop_FreeLockHead;
        pPool->iop_FreeLockHead = pPoolHdr;
		pPool->iop_NumFreeLocks ++;
	}

	pPoolHdr->iph_Tag.tg_Flags = IO_POOL_NOT_IN_USE;		// Mark it un-used

	// If this block's status is changing from a 'none available' to 'available'
	// move him to the head of the list.
	if ((pPool->iop_NumFreeBufs + pPool->iop_NumFreeLocks) == 1)
	{
		AfpUnlinkDouble(pPool, iop_Next, iop_Prev);
		AfpLinkDoubleAtHead(afpIoPoolHead,
							pPool,
							iop_Next,
							iop_Prev);
	}

	RELEASE_SPIN_LOCK(&afpIoPoolLock, OldIrql);

#ifdef	PROFILING
	AfpGetPerfCounter(&TimeE);
	TimeD.QuadPart = TimeE.QuadPart - TimeS.QuadPart;
	INTERLOCKED_ADD_LARGE_INTGR(&AfpServerProfile->perf_BPFreeTime,
								TimeD,
								&AfpStatisticsLock);
#endif
}


/***	afpIoPoolAge
 *
 *	Scavenger worker for aging out the IO pool.
 */
LOCAL AFPSTATUS FASTCALL
afpIoPoolAge(
	IN	PVOID	pContext
)
{
	PIOPOOL	pPool;

	DBGPRINT(DBG_COMP_MEMORY, DBG_LEVEL_INFO,
			("afpIOPoolAge: Entered\n"));

	ACQUIRE_SPIN_LOCK_AT_DPC(&afpIoPoolLock);

	for (pPool = afpIoPoolHead;
		 pPool != NULL;
		 NOTHING)
	{
		PIOPOOL	pFree;

		ASSERT(VALID_IOP(pPool));

		pFree = pPool;
		pPool = pPool->iop_Next;

		// Since all blocks which are completely used up are at the tail end of
		// the list, if we encounter one, we are done.
		if ((pFree->iop_NumFreeBufs == 0) &&
	        (pFree->iop_NumFreeLocks == 0))
			break;

		if ((pFree->iop_NumFreeBufs == NUM_BUFS_IN_POOL) &&
			(pFree->iop_NumFreeLocks == NUM_LOCKS_IN_POOL))
		{
			DBGPRINT(DBG_COMP_MEMORY, DBG_LEVEL_WARN,
					("afpIOPoolAge: Aging pool %lx\n", pFree));
			if (++(pFree->iop_Age) >= MAX_POOL_AGE)
			{
#ifdef	PROFILING
				INTERLOCKED_INCREMENT_LONG( &AfpServerProfile->perf_BPAgeCount);
#endif
				DBGPRINT(DBG_COMP_MEMORY, DBG_LEVEL_WARN,
						("afpIOPoolAge: Freeing pool %lx\n", pFree));
				AfpUnlinkDouble(pFree, iop_Next, iop_Prev);
				AfpFreeMemory(pFree);
			}
		}
	}

	RELEASE_SPIN_LOCK_FROM_DPC(&afpIoPoolLock);

	return AFP_ERR_REQUEUE;
}


#ifdef	TRACK_MEMORY_USAGE

#define	MAX_PTR_COUNT	4*1024
#define	MAX_MEM_USERS	256
LOCAL	struct _MemPtr
{
	PVOID	mptr_Ptr;
	DWORD	mptr_FileLine;
} afpMemPtrs[MAX_PTR_COUNT] = { 0 };

typedef	struct
{
	ULONG	mem_FL;
	ULONG	mem_Count;
} MEM_USAGE, *PMEM_USAGE;

LOCAL	MEM_USAGE	afpMemUsageNonPaged[MAX_MEM_USERS] = {0};
LOCAL	MEM_USAGE	afpMemUsagePaged[MAX_MEM_USERS] = {0};

LOCAL	AFP_SPIN_LOCK		afpMemTrackLock = {0};

/***	AfpTrackMemoryUsage
 *
 *	Keep track of memory usage by storing and clearing away pointers as and
 *	when they are allocated or freed. This helps in keeping track of memory
 *	leaks.
 *
 *	LOCKS:	AfpMemTrackLock (SPIN)
 */
VOID
AfpTrackMemoryUsage(
	IN	PVOID	pMem,
	IN	BOOLEAN	Alloc,
	IN	BOOLEAN	Paged,
	IN	ULONG	FileLine
)
{
	KIRQL			OldIrql;
	static	int		i = 0;
	PMEM_USAGE		pMemUsage;
	int				j, k;

	pMemUsage = afpMemUsageNonPaged;
	if (Paged)
		pMemUsage = afpMemUsagePaged;

	ACQUIRE_SPIN_LOCK(&afpMemTrackLock, &OldIrql);

	if (Alloc)
	{
		for (j = 0; j < MAX_PTR_COUNT; i++, j++)
		{
			i = i & (MAX_PTR_COUNT-1);
			if (afpMemPtrs[i].mptr_Ptr == NULL)
			{
				afpMemPtrs[i].mptr_FileLine = FileLine;
				afpMemPtrs[i++].mptr_Ptr = pMem;
				break;
			}
		}
		for (k = 0; k < MAX_MEM_USERS; k++)
		{
			if (pMemUsage[k].mem_FL == FileLine)
			{
				pMemUsage[k].mem_Count ++;
				break;
			}
		}
		if (k == MAX_MEM_USERS)
		{
			for (k = 0; k < MAX_MEM_USERS; k++)
			{
				if (pMemUsage[k].mem_FL == 0)
				{
					pMemUsage[k].mem_FL = FileLine;
					pMemUsage[k].mem_Count = 1;
					break;
				}
			}
		}
		if (k == MAX_MEM_USERS)
		{
			DBGPRINT(DBG_COMP_MEMORY, DBG_LEVEL_ERR,
				("AfpTrackMemoryUsage: Out of space on afpMemUsage !!!\n"));
			DBGBRK(DBG_LEVEL_FATAL);
		}
	}
	else
	{
		for (j = 0, k = i; j < MAX_PTR_COUNT; j++, k--)
		{
			k = k & (MAX_PTR_COUNT-1);
			if (afpMemPtrs[k].mptr_Ptr == pMem)
			{
				afpMemPtrs[k].mptr_Ptr = NULL;
				afpMemPtrs[k].mptr_FileLine = 0;
				break;
			}
		}
	}

	RELEASE_SPIN_LOCK(&afpMemTrackLock, OldIrql);

	if (j == MAX_PTR_COUNT)
	{
		DBGPRINT(DBG_COMP_MEMORY, DBG_LEVEL_ERR,
			("AfpTrackMemoryUsage: (%lx) %s\n",
			FileLine, Alloc ? "Table Full" : "Can't find"));
	}
}

#endif	// TRACK_MEMORY_USAGE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\server\pathmap.c ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	pathmap.c

Abstract:

	This module contains the routines that manipulate AFP paths.

Author:

	Sue Adams	(microsoft!suea)


Revision History:
	04 Jun 1992			Initial Version
	05 Oct 1993 JameelH	Performance Changes. Merge cached afpinfo into the
						idindex structure. Make both the ANSI and the UNICODE
						names part of idindex. Added EnumCache for improving
						enumerate perf.

Notes:	Tab stop: 4
--*/

#define	_PATHMAP_LOCALS
#define	FILENUM	FILE_PATHMAP

#include <afp.h>
#include <fdparm.h>
#include <pathmap.h>
#include <afpinfo.h>
#include <client.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, AfpMapAfpPath)
#pragma alloc_text( PAGE, AfpMapAfpPathForLookup)
#pragma alloc_text( PAGE, AfpMapAfpIdForLookup)
#pragma alloc_text( PAGE, afpGetMappedForLookupFDInfo)
#pragma alloc_text( PAGE, afpMapAfpPathToMappedPath)
#pragma alloc_text( PAGE, AfpHostPathFromDFEntry)
#pragma alloc_text( PAGE, AfpCheckParentPermissions)
#pragma alloc_text( PAGE, afpOpenUserHandle)
#endif


/***	AfpMapAfpPath
 *
 *	If mapping is for lookup operation, a FILESYSHANDLE open in the user's
 *	context is returned,  The caller MUST close this handle when done with it.
 *
 *	If pFDParm is non-null, it will be filled in as appropriate according to Bitmap.
 *
 *	If mapping is for create operation, the volume root-relative host pathname
 *	(in unicode) of the item we are about to create is returned. For lookup
 *	operation the paths refer to the item being pathmapped.  This routine
 *	always returns the paths in the PME.  It is the caller's responsibility
 *	to free the Full HostPath Buffer, if it is not supplied already.
 *
 *	The caller MUST have the IdDb locked for Exclusive access.
 *
 *	LOCKS_ASSUMED: vds_IdDbAccessLock (SWMR, Exclusive)
 *
 */
AFPSTATUS
AfpMapAfpPath(
	IN		PCONNDESC		pConnDesc,
	IN		DWORD			DirId,
	IN		PANSI_STRING	pPath,
	IN		BYTE			PathType,			// short names or long names
	IN		PATHMAP_TYPE	MapReason,	 		// for lookup or hard/soft create?
	IN		DWORD			DFFlag,				// map to file? dir? or either?
	IN		DWORD			Bitmap,				// what fields of FDParm to fill in
	OUT		PPATHMAPENTITY	pPME,
	OUT		PFILEDIRPARM	pFDParm OPTIONAL	// for lookups only
)
{
	PVOLDESC		pVolDesc;
	MAPPEDPATH		mappedpath;
	AFPSTATUS		Status;
#ifdef	PROFILING
	TIME			TimeS, TimeE, TimeD;
#endif

	PAGED_CODE( );

	ASSERT((pConnDesc != NULL));

#ifdef	PROFILING
	INTERLOCKED_INCREMENT_LONG(&AfpServerProfile->perf_PathMapCount);
	AfpGetPerfCounter(&TimeS);
#endif

	pVolDesc = pConnDesc->cds_pVolDesc;
	ASSERT(IS_VOLUME_NTFS(pVolDesc));
	ASSERT(AfpSwmrLockedExclusive(&pVolDesc->vds_IdDbAccessLock));

	// initialize some fields in the PME
	AfpSetEmptyUnicodeString(&pPME->pme_ParentPath, 0, NULL);

	do
	{
		Status = afpMapAfpPathToMappedPath(pVolDesc,
										   DirId,
										   pPath,
										   PathType,
										   MapReason,
										   DFFlag,
										   True,
										   &mappedpath);
		if ((Status != AFP_ERR_NONE) &&
			!((MapReason == HardCreate) &&
			  (Status == AFP_ERR_OBJECT_EXISTS) &&
			  (DFFlag == DFE_FILE)))
		{
			break;
		}

		ASSERT(pPME != NULL);

		// Get the volume relative path to the parent directory for
		// creates, or to the item for lookups
		if ((Status = AfpHostPathFromDFEntry(mappedpath.mp_pdfe,
											 // since CopyFile and Move have to lookup
											 // the destination parent dir paths, we
											 // need to allocate extra room for them in
											 // the path to append the filename
											 (MapReason == Lookup) ?
												(AFP_LONGNAME_LEN + 1) * sizeof(WCHAR):
												mappedpath.mp_Tail.Length + sizeof(WCHAR),
											 &pPME->pme_FullPath)) != AFP_ERR_NONE)
			break;

		// if Pathmap is for hard (files only) or soft create (file or dir)
		if (MapReason != Lookup)
		{
			ASSERT(pFDParm == NULL);

			// fill in the dfe of parent dir in which create will take place
			pPME->pme_pDfeParent = mappedpath.mp_pdfe;

			// fill in path to parent
			pPME->pme_ParentPath = pPME->pme_FullPath;

			// Add a path separator if we are not at the root
			if (pPME->pme_FullPath.Length > 0)
			{
				pPME->pme_FullPath.Buffer[pPME->pme_FullPath.Length / sizeof(WCHAR)] = L'\\';
				pPME->pme_FullPath.Length += sizeof(WCHAR);
			}

			pPME->pme_UTail.Length = pPME->pme_UTail.MaximumLength = mappedpath.mp_Tail.Length;
			pPME->pme_UTail.Buffer = (PWCHAR)((PBYTE)pPME->pme_FullPath.Buffer +
											  pPME->pme_FullPath.Length);

			Status = RtlAppendUnicodeStringToString(&pPME->pme_FullPath,
													&mappedpath.mp_Tail);
			ASSERT(NT_SUCCESS(Status));
		}
		else // lookup operation
		{
			pPME->pme_pDfEntry = mappedpath.mp_pdfe;
			pPME->pme_UTail.Length = mappedpath.mp_pdfe->dfe_UnicodeName.Length;
			pPME->pme_UTail.Buffer = (PWCHAR)((PBYTE)pPME->pme_FullPath.Buffer +
											  pPME->pme_FullPath.Length -
											  pPME->pme_UTail.Length);

			pPME->pme_ParentPath.Length =
			pPME->pme_ParentPath.MaximumLength = pPME->pme_FullPath.Length - pPME->pme_UTail.Length;

			if (pPME->pme_FullPath.Length > pPME->pme_UTail.Length)
			{
				// subtract the path separator if not in root dir
				pPME->pme_ParentPath.Length -= sizeof(WCHAR);
				ASSERT(pPME->pme_ParentPath.Length >= 0);
			}
			pPME->pme_ParentPath.Buffer = pPME->pme_FullPath.Buffer;
			pPME->pme_UTail.MaximumLength = pPME->pme_FullPath.MaximumLength - pPME->pme_ParentPath.Length;

			Status = afpGetMappedForLookupFDInfo(pConnDesc,
												 mappedpath.mp_pdfe,
												 Bitmap,
												 pPME,
												 pFDParm);
			// if this fails do not free path buffer and set it back to
			// null.  We don't know that the path buffer isn't on
			// the callers stack. Caller should always clean it up himself.
		}
	} while (False);

#ifdef	PROFILING
	AfpGetPerfCounter(&TimeE);		
	TimeD.QuadPart = TimeE.QuadPart - TimeS.QuadPart;
	INTERLOCKED_ADD_LARGE_INTGR(&AfpServerProfile->perf_PathMapTime,
								 TimeD,
								 &AfpStatisticsLock);
#endif
	return Status;
}

/***	AfpMapAfpPathForLookup
 *
 *	Maps an AFP dirid/pathname pair to an open handle (in the user's context)
 *	to the DATA stream of the file/dir.
 *	The DirID database is locked for read for the duration of this
 *	routine, unless afpMapAfpPathToMappedPath returns
 *  AFP_ERR_WRITE_LOCK_REQUIRED in which case the DirID database will be locked
 *  for write.  This will only happen the first time a mac tries to access
 *  a directory who's files have not yet been cached in.
 *
 *	LOCKS: vds_IdDbAccessLock (SWMR, Shared OR Exclusive)
 */
AFPSTATUS
AfpMapAfpPathForLookup(
	IN		PCONNDESC		pConnDesc,
	IN		DWORD			DirId,
	IN		PANSI_STRING	pPath,
	IN		BYTE			PathType,	  // short names or long names
	IN		DWORD			DFFlag,
	IN		DWORD			Bitmap,
	OUT		PPATHMAPENTITY	pPME	OPTIONAL,
	OUT		PFILEDIRPARM	pFDParm OPTIONAL
)
{
	MAPPEDPATH	mappedpath;
	PVOLDESC	pVolDesc;
	PSWMR		pIdDbLock;
	AFPSTATUS	Status;
	BOOLEAN		swmrLockedExclusive = False;
	PATHMAP_TYPE mapReason = Lookup;
#ifdef	PROFILING
	TIME		TimeS, TimeE, TimeD;
#endif

	PAGED_CODE( );

	ASSERT((pConnDesc != NULL));


#ifdef	PROFILING
	INTERLOCKED_INCREMENT_LONG(&AfpServerProfile->perf_PathMapCount);
	AfpGetPerfCounter(&TimeS);
#endif

#ifndef GET_CORRECT_OFFSPRING_COUNTS
	if (pConnDesc->cds_pSda->sda_AfpFunc == _AFP_ENUMERATE)
	{
		mapReason = LookupForEnumerate;
	}
#endif

	pVolDesc  = pConnDesc->cds_pVolDesc;
	pIdDbLock = &(pVolDesc->vds_IdDbAccessLock);

	AfpSwmrAcquireShared(pIdDbLock);

	do
	{
		do
		{
			Status = afpMapAfpPathToMappedPath(pVolDesc,
											  DirId,
											  pPath,
											  PathType,
											  mapReason,	// lookups only
											  DFFlag,
											  swmrLockedExclusive,
											  &mappedpath);
	
			if (Status == AFP_ERR_WRITE_LOCK_REQUIRED)
			{
				ASSERT (!swmrLockedExclusive);
				// Pathmap needed to cache in the files for the last directory
				// in the path but didn't have the write lock to the ID database
				AfpSwmrRelease(pIdDbLock);
				AfpSwmrAcquireExclusive(pIdDbLock);
				swmrLockedExclusive = True;
				continue;
			}
			break;
		} while (True);

		if (!NT_SUCCESS(Status))
		{
			DBGPRINT (DBG_COMP_IDINDEX, DBG_LEVEL_ERR,
							("AfpMapAfpPathForLookup: afpMapAfpPathToMappedPath failed: Error = %lx\n", Status));
			break;
		}

		if (ARGUMENT_PRESENT(pPME))
		{
			pPME->pme_FullPath.Length = 0;
		}

		if (Bitmap & FD_INTERNAL_BITMAP_RETURN_PMEPATHS)
		{
			ASSERT(ARGUMENT_PRESENT(pPME));
			if ((Status = AfpHostPathFromDFEntry(mappedpath.mp_pdfe,
												 (Bitmap & FD_INTERNAL_BITMAP_OPENFORK_RESC) ?
														AfpResourceStream.Length : 0,
												 &pPME->pme_FullPath)) != AFP_ERR_NONE)
				break;

			pPME->pme_UTail.Length = mappedpath.mp_pdfe->dfe_UnicodeName.Length;
			pPME->pme_UTail.Buffer = (PWCHAR)((PBYTE)pPME->pme_FullPath.Buffer +
											  pPME->pme_FullPath.Length - pPME->pme_UTail.Length);

			pPME->pme_ParentPath.Length =
			pPME->pme_ParentPath.MaximumLength = pPME->pme_FullPath.Length - pPME->pme_UTail.Length;

			if (pPME->pme_FullPath.Length > pPME->pme_UTail.Length)
			{
				// subtract the path separator if not in root dir
				pPME->pme_ParentPath.Length -= sizeof(WCHAR);
				ASSERT(pPME->pme_ParentPath.Length >= 0);
			}
			pPME->pme_ParentPath.Buffer = pPME->pme_FullPath.Buffer;
			pPME->pme_UTail.MaximumLength = pPME->pme_FullPath.MaximumLength - pPME->pme_ParentPath.Length;
		}

		Status = afpGetMappedForLookupFDInfo(pConnDesc,
											 mappedpath.mp_pdfe,
											 Bitmap,
											 pPME,
											 pFDParm);
	} while (False);

	AfpSwmrRelease(pIdDbLock);

#ifdef	PROFILING
	AfpGetPerfCounter(&TimeE);
	TimeD.QuadPart = TimeE.QuadPart - TimeS.QuadPart;
	INTERLOCKED_ADD_LARGE_INTGR(&AfpServerProfile->perf_PathMapTime,
								 TimeD,
								 &AfpStatisticsLock);
#endif
	return Status;

}

/***	AfpMapAfpIdForLookup
 *
 *	Maps an AFP id to an open FILESYSTEMHANDLE (in the user's context) to
 * 	to the DATA stream of the file/dir.
 *	The DirID database is locked for shared or exclusive access for the duration
 *	of this routine.
 *
 *	LOCKS: vds_IdDbAccessLock (SWMR, Shared OR Exclusive)
 */
AFPSTATUS
AfpMapAfpIdForLookup(
	IN		PCONNDESC		pConnDesc,
	IN		DWORD			AfpId,
	IN		DWORD			DFFlag,
	IN		DWORD			Bitmap,
	OUT		PPATHMAPENTITY	pPME	OPTIONAL,
	OUT		PFILEDIRPARM	pFDParm OPTIONAL
)
{
	PVOLDESC	pVolDesc;
	PSWMR		pIdDbLock;
	AFPSTATUS	Status;
	PDFENTRY	pDfEntry;
	BOOLEAN		CleanupLock = False;
#ifdef	PROFILING
	TIME		TimeS, TimeE, TimeD;
#endif

	PAGED_CODE( );

#ifdef	PROFILING
	INTERLOCKED_INCREMENT_LONG(&AfpServerProfile->perf_PathMapCount);
	AfpGetPerfCounter(&TimeS);
#endif

	ASSERT((pConnDesc != NULL));

	do
	{
		if (AfpId == 0)
		{
			Status = AFP_ERR_PARAM;
			break;
		}

		pVolDesc  = pConnDesc->cds_pVolDesc;
		pIdDbLock = &(pVolDesc->vds_IdDbAccessLock);

		AfpSwmrAcquireShared(pIdDbLock);
		CleanupLock = True;

		if ((AfpId == AFP_ID_PARENT_OF_ROOT) ||
			((pDfEntry = AfpFindDfEntryById(pVolDesc, AfpId, DFE_ANY)) == NULL))
		{
			Status = AFP_ERR_OBJECT_NOT_FOUND;
			break;
		}

		if (((DFFlag == DFE_DIR) && DFE_IS_FILE(pDfEntry)) ||
			((DFFlag == DFE_FILE) && DFE_IS_DIRECTORY(pDfEntry)))
		{
			Status = AFP_ERR_OBJECT_TYPE;
			break;
		}

		if (ARGUMENT_PRESENT(pPME))
		{
			pPME->pme_FullPath.Length = 0;
		}

		Status = afpGetMappedForLookupFDInfo(pConnDesc,
											 pDfEntry,
											 Bitmap,
											 pPME,
											 pFDParm);
	} while (False);

	if (CleanupLock)
	{
		AfpSwmrRelease(pIdDbLock);
	}

#ifdef	PROFILING
	AfpGetPerfCounter(&TimeE);
	TimeD.QuadPart = TimeE.QuadPart - TimeS.QuadPart;
	INTERLOCKED_ADD_LARGE_INTGR(&AfpServerProfile->perf_PathMapTime,
								 TimeD,
								 &AfpStatisticsLock);
#endif
	return Status;
}

/***	afpGetMappedForLookupFDInfo
 *
 *	After a pathmap for LOOKUP operation, this routine is called to
 *	return various FileDir parm information about the mapped file/dir.
 *	The following FileDir information is always returned:
 *		AFP DirId/FileId
 *		Parent DirId
 *		DFE flags (indicating item is a directory, a file, or a file with an ID)
 *		Attributes (Inhibit bits and D/R Already open bits normalized with
 *					the NTFS attributes for RO, System, Hidden, Archive)
 *		BackupTime
 *		CreateTime
 *		ModifiedTime
 *
 *	The following FileDir information is returned according to the flags set
 *	in word 0 of the Bitmap parameter (these correspond to the AFP file/dir
 *	bitmap):
 *		Longname
 *		Shortname
 *		FinderInfo
 *		ProDosInfo
 *		Directory Access Rights (as stored in AFP_AfpInfo stream)
 *		Directory OwnerId/GroupId
 *		Directory Offspring count (file count and dir count are separate)
 *
 *	The open access is stored in word 1 of the Bitmap parameter.
 *	This is used by AfpOpenUserHandle (for NTFS volumes) or AfpIoOpen (for
 *	CDFS volumes) when opening the data stream of the file/dir (under
 *	impersonation for NTFS) who's handle will be returned within the
 *	pPME parameter if supplied.
 *
 *	LOCKS_ASSUMED: vds_IdDbAccessLock (SWMR, Shared)
 *
 */
LOCAL
AFPSTATUS
afpGetMappedForLookupFDInfo(
	IN	PCONNDESC			pConnDesc,
	IN	PDFENTRY			pDfEntry,
	IN	DWORD				Bitmap,
	OUT	PPATHMAPENTITY		pPME	OPTIONAL,	// Supply for NTFS only if need a
												// handle in user's context, usually
												// for security checking purposes
	OUT	PFILEDIRPARM		pFDParm	OPTIONAL	// Supply if want returned FDInfo
)
{
	BOOLEAN			fNtfsVol;
	AFPSTATUS		Status = STATUS_SUCCESS;
	DWORD			OpenAccess = FILEIO_ACCESS_NONE;
	FILESYSHANDLE	fsh;
	PFILESYSHANDLE	pHandle = NULL;

	PAGED_CODE( );

	fNtfsVol = IS_VOLUME_NTFS(pConnDesc->cds_pVolDesc);
	if (ARGUMENT_PRESENT(pPME))
	{
		pHandle = &pPME->pme_Handle;
	}
	else if ((fNtfsVol &&
			(Bitmap & (FD_BITMAP_SHORTNAME | FD_BITMAP_PRODOSINFO))))
	{
		pHandle = &fsh;
	}

	if (pHandle != NULL)
	{
		if (!NT_SUCCESS(Status = afpOpenUserHandle(pConnDesc,
												   pDfEntry,
												   (ARGUMENT_PRESENT(pPME) &&
													(pPME->pme_FullPath.Buffer != NULL)) ?
														&pPME->pme_FullPath : NULL,
												   Bitmap,		// encode open/deny modes
												   pHandle)))
		{
			if ((Status == AFP_ERR_DENY_CONFLICT) &&
				ARGUMENT_PRESENT(pFDParm))
			{
				// For CreateId/ResolveId/DeleteId
				pFDParm->_fdp_AfpId = pDfEntry->dfe_AfpId;
				pFDParm->_fdp_Flags = (pDfEntry->dfe_Flags & DFE_FLAGS_DFBITS);
			}
			return Status;
		}
	}

	do
	{
		if (ARGUMENT_PRESENT(pFDParm))
		{
			pFDParm->_fdp_AfpId = pDfEntry->dfe_AfpId;
			pFDParm->_fdp_ParentId = pDfEntry->dfe_Parent->dfe_AfpId;

			ASSERT(!((pDfEntry->dfe_Flags & DFE_FLAGS_DIR) &&
					 (pDfEntry->dfe_Flags & (DFE_FLAGS_FILE_WITH_ID | DFE_FLAGS_FILE_NO_ID))));

			pFDParm->_fdp_Flags = (pDfEntry->dfe_Flags & DFE_FLAGS_DFBITS);

			if (Bitmap & FD_BITMAP_FINDERINFO)
			{
				pFDParm->_fdp_FinderInfo = pDfEntry->dfe_FinderInfo;
			}

			pFDParm->_fdp_Attr = pDfEntry->dfe_AfpAttr;
			AfpNormalizeAfpAttr(pFDParm, pDfEntry->dfe_NtAttr);

			// The Finder uses the Finder isInvisible flag over
			// the file system Invisible attribute to tell if the thing is
			// displayed or not.  If the PC turns off the hidden attribute
			// we should clear the Finder isInvisible flag
			if ((Bitmap & FD_BITMAP_FINDERINFO) &&
				!(pFDParm->_fdp_Attr & FD_BITMAP_ATTR_INVISIBLE))
			{
				pFDParm->_fdp_FinderInfo.fd_Attr1 &= ~FINDER_FLAG_INVISIBLE;
			}

			pFDParm->_fdp_BackupTime = pDfEntry->dfe_BackupTime;
			pFDParm->_fdp_CreateTime = pDfEntry->dfe_CreateTime;
			pFDParm->_fdp_ModifiedTime = AfpConvertTimeToMacFormat(&pDfEntry->dfe_LastModTime);

			if (Bitmap & FD_BITMAP_LONGNAME)
			{
				ASSERT((pFDParm->_fdp_LongName.Buffer != NULL) &&
					   (pFDParm->_fdp_LongName.MaximumLength >=
						pDfEntry->dfe_UnicodeName.Length/(USHORT)sizeof(WCHAR)));
				AfpConvertMungedUnicodeToAnsi(&pDfEntry->dfe_UnicodeName,
											  &pFDParm->_fdp_LongName);
			}

			if (Bitmap & FD_BITMAP_SHORTNAME)
			{
				ASSERT(pFDParm->_fdp_ShortName.Buffer != NULL);

				if (!fNtfsVol)
				{
					ASSERT(pFDParm->_fdp_ShortName.MaximumLength >=
										(pDfEntry->dfe_UnicodeName.Length/sizeof(WCHAR)));
					AfpConvertMungedUnicodeToAnsi(&pDfEntry->dfe_UnicodeName,
												  &pFDParm->_fdp_ShortName);

					// if asking for shortname on CDFS, we will fill in the pFDParm
					// shortname with the pDfEntry longname, ONLY if it is an 8.3 name
					if (!AfpIsLegalShortname(&pFDParm->_fdp_ShortName))
					{
						pFDParm->_fdp_ShortName.Length = 0;
					}
				}
				else
				{
					// get NTFS shortname
					ASSERT(pFDParm->_fdp_ShortName.MaximumLength >= AFP_SHORTNAME_LEN);
					ASSERT(pHandle != NULL);

					Status = AfpIoQueryShortName(pHandle,
												 &pFDParm->_fdp_ShortName);
					if (!NT_SUCCESS(Status))
					{
						pFDParm->_fdp_ShortName.Length = 0;
						break;
					}
				}
			}

			if (DFE_IS_FILE(pDfEntry))
			{
				if (pDfEntry->dfe_Flags & DFE_FLAGS_D_ALREADYOPEN)
					pFDParm->_fdp_Attr |= FILE_BITMAP_ATTR_DATAOPEN;
				if (pDfEntry->dfe_Flags & DFE_FLAGS_R_ALREADYOPEN)
					pFDParm->_fdp_Attr |= FILE_BITMAP_ATTR_RESCOPEN;
				if (Bitmap & FILE_BITMAP_RESCLEN)
				{
					pFDParm->_fdp_RescForkLen = pDfEntry->dfe_RescLen;
				}
				if (Bitmap & FILE_BITMAP_DATALEN)
				{
					pFDParm->_fdp_DataForkLen = pDfEntry->dfe_DataLen;
				}
			}

			if (Bitmap & FD_BITMAP_PRODOSINFO)
			{
				if (fNtfsVol)
				{
					ASSERT(pHandle != NULL);
					Status = AfpQueryProDos(pHandle,
											&pFDParm->_fdp_ProDosInfo);
					if (!NT_SUCCESS(Status))
					{
						break;
					}
				}
				else	// CDFS File or Directory
				{
					RtlZeroMemory(&pFDParm->_fdp_ProDosInfo, sizeof(PRODOSINFO));
					if (DFE_IS_FILE(pDfEntry))	// CDFS file
					{
						AfpProDosInfoFromFinderInfo(&pDfEntry->dfe_FinderInfo,
													&pFDParm->_fdp_ProDosInfo);
					}
					else	// CDFS Directory
					{
						pFDParm->_fdp_ProDosInfo.pd_FileType[0] = PRODOS_TYPE_DIR;
						pFDParm->_fdp_ProDosInfo.pd_AuxType[1] = PRODOS_AUX_DIR;
					}
				}
			}

			// check for dir here since enumerate ANDs the file and dir bitmaps
			if (DFE_IS_DIRECTORY(pDfEntry) &&
				(Bitmap & (DIR_BITMAP_ACCESSRIGHTS |
						   DIR_BITMAP_OWNERID |
						   DIR_BITMAP_GROUPID)))
			{
				if (fNtfsVol)
				{
					// Because the file and dir bitmaps are OR'd together,
					// and the OwnerId bit is overloaded with the RescLen bit,
					// we don't know if this bit was actually included in the
					// file bitmap or the dir bitmap.  The api would have
					// determined whether or not it needed a handle based on
					// these bitmaps, so based on the pPME we can tell if we
					// actually need to query for security or not.
					if (ARGUMENT_PRESENT(pPME))
					{
						pFDParm->_fdp_OwnerRights = DFE_OWNER_ACCESS(pDfEntry);
						pFDParm->_fdp_GroupRights = DFE_GROUP_ACCESS(pDfEntry);
						pFDParm->_fdp_WorldRights = DFE_WORLD_ACCESS(pDfEntry);

						// Query this user's rights
						Status = AfpQuerySecurityIdsAndRights(pConnDesc->cds_pSda,
															  pHandle,
															  Bitmap,
															  pFDParm);
						if (!NT_SUCCESS(Status))
						{
							break;
						}
					}
				}
				else
				{
					pFDParm->_fdp_OwnerRights =
					pFDParm->_fdp_GroupRights =
					pFDParm->_fdp_WorldRights =
					pFDParm->_fdp_UserRights  = (DIR_ACCESS_READ | DIR_ACCESS_SEARCH);
					pFDParm->_fdp_OwnerId = pFDParm->_fdp_GroupId = 0;
				}
			}

			// Must check for type directory since this Bitmap bit is overloaded
			if (DFE_IS_DIRECTORY(pDfEntry) && (Bitmap & DIR_BITMAP_OFFSPRINGS))
			{
#ifndef GET_CORRECT_OFFSPRING_COUNTS
				if (!DFE_CHILDREN_ARE_PRESENT(pDfEntry) &&
					(pDfEntry->dfe_DirOffspring == 0))
				{
					// If the files have not yet been cached in for this dir,
					// return non-zero filecount so that system 7.x view by
					// name will enumerate the directory if user clicks the
					// triangle for this dir.  If you return zero offspring
					// What might break from lying like this?
					pFDParm->_fdp_FileCount = 1;
                }
				else
#endif
					pFDParm->_fdp_FileCount = pDfEntry->dfe_FileOffspring;

				pFDParm->_fdp_DirCount  = pDfEntry->dfe_DirOffspring;
			}
		}
	} while (False);

	if (pHandle == &fsh)
	{
		// if we had to open a handle just to query shortname or ProDOS
		// close it
		AfpIoClose(&fsh);
	}

	return Status;
}


/***	afpMapAfpPathToMappedPath
 *
 *	Maps an AFP DirId/pathname pair to a MAPPEDPATH structure.
 *	The CALLER must have the DirId/FileId database locked for shared
 *	access (or Exclusive access if they need that level of lock for other
 *	operations on the IDDB, to map a path only requires shared lock)
 *
 *	LOCKS_ASSUMED: vds_IdDbAccessLock (SWMR, Shared OR Exclusive)
 */
LOCAL
AFPSTATUS
afpMapAfpPathToMappedPath(
	IN		PVOLDESC		pVolDesc,
	IN		DWORD			DirId,
	IN		PANSI_STRING	Path,		// relative to DirId
	IN		BYTE			PathType,	// short names or long names
	IN		PATHMAP_TYPE	MapReason,  // for lookup or hard/soft create?
	IN		DWORD			DFflag,		// file, dir or don't know which
	IN		BOOLEAN			LockedExclusive,
	OUT		PMAPPEDPATH		pMappedPath

)
{
	PDFENTRY		pDFEntry, ptempDFEntry;
	CHAR			*position, *tempposition;
	int				length, templength;
	ANSI_STRING		acomponent;
	CHAR			component[AFP_FILENAME_LEN+1];
	BOOLEAN			checkEnumForParent = False, checkEnumForDir = False;

	PAGED_CODE( );

	ASSERT(pVolDesc != NULL);

#ifndef GET_CORRECT_OFFSPRING_COUNTS
	if (MapReason == LookupForEnumerate)
	{
		checkEnumForDir = True;
		MapReason = Lookup;
	}
#endif

	// Initialize the returned MappedPath structure
	pMappedPath->mp_pdfe = NULL;
	AfpSetEmptyUnicodeString(&pMappedPath->mp_Tail,
							 sizeof(pMappedPath->mp_Tailbuf),
							 pMappedPath->mp_Tailbuf);

	// Lookup the initial DirId in the index database, it better be valid
	if ((pDFEntry = AfpFindDfEntryById(pVolDesc,
									   DirId,
									   DFE_DIR)) == NULL)
	{
		return AFP_ERR_OBJECT_NOT_FOUND;
	}

	ASSERT(Path != NULL);
	tempposition = position = Path->Buffer;
	templength = length = Path->Length;

	do
	{
		// Lookup by DirId only?
		if (length == 0)				// no path was given
		{
			if (MapReason != Lookup)	// mapping is for create
			{
				return AFP_ERR_PARAM;	// missing the file or dirname
			}
			else if (DFE_IS_PARENT_OF_ROOT(pDFEntry))
			{
				return AFP_ERR_OBJECT_NOT_FOUND;
			}
			else
			{
				pMappedPath->mp_pdfe = pDFEntry;
#ifdef GET_CORRECT_OFFSPRING_COUNTS
				checkEnumForParent = checkEnumForDir = True;
#endif
				break;
			}
		}

		//
		// Pre-scan path to munge for easier component breakdown
		//

		// Get rid of a leading null to make scanning easier
		if (*position == AFP_PATHSEP)
		{
			length--;
			position++;
			if (length == 0)	// The path consisted of just one null byte
			{
				if (MapReason != Lookup)
				{
					return AFP_ERR_PARAM;
				}
				else if (DFE_IS_PARENT_OF_ROOT(pDFEntry))
				{
					return AFP_ERR_OBJECT_NOT_FOUND;
				}
				else if (((DFflag == DFE_DIR) && DFE_IS_FILE(pDFEntry)) ||
						 ((DFflag == DFE_FILE) && DFE_IS_DIRECTORY(pDFEntry)))
				{
					return AFP_ERR_OBJECT_TYPE;
				}
				else
				{
					pMappedPath->mp_pdfe = pDFEntry;
#ifdef GET_CORRECT_OFFSPRING_COUNTS
					checkEnumForParent = checkEnumForDir = True;
#endif
					break;
				}
			}
		}

		//
		// Get rid of a trailing null if it is not an "up" token --
		// i.e. preceded by another null.
		// The 2nd array access is ok because we know we have at
		// least 2 chars at that point
		//
		if ((position[length-1] == AFP_PATHSEP) &&
			(position[length-2] != AFP_PATHSEP))
		{
				length--;
		}


		// begin parsing out path components, stop when you find the last component
		while (1)
		{
			afpGetNextComponent(position,
								length,
								PathType,
								component,
								&templength);
			if (templength < 0)
			{
				// component was too long or an invalid AFP character was found
				return AFP_ERR_PARAM;
			}

			length -= templength;
			if (length == 0)
			{
				// we found the last component
				break;
			}

			position += templength;

			if (component[0] == AFP_PATHSEP)	// moving up?
			{	// make sure you don't go above parent of root!
				if (DFE_IS_PARENT_OF_ROOT(pDFEntry))
				{
					return AFP_ERR_OBJECT_NOT_FOUND;
				}
				else pDFEntry = pDFEntry->dfe_Parent;	//backup one level
			}
			else // Must be a directory component moving DOWN in tree
			{
				RtlInitString(&acomponent, component);
				AfpConvertStringToMungedUnicode(&acomponent, &pMappedPath->mp_Tail);
				if ((ptempDFEntry = AfpFindEntryByUnicodeName(pVolDesc,
															  &pMappedPath->mp_Tail,
															  PathType,
															  pDFEntry,
															  DFE_DIR)) == NULL)
				{
					return AFP_ERR_OBJECT_NOT_FOUND;
				}
				else
				{
					pDFEntry = ptempDFEntry;
				}
			}
		} // end while

		//
		// we have found the last component
		// is the last component an 'up' token?
		//
		if (component[0] == AFP_PATHSEP)
		{
			// don't bother walking up beyond the root
			switch (pDFEntry->dfe_AfpId)
			{
				case AFP_ID_PARENT_OF_ROOT:
					return AFP_ERR_OBJECT_NOT_FOUND;
				case AFP_ID_ROOT:
					return ((MapReason == Lookup) ? AFP_ERR_OBJECT_NOT_FOUND :
													AFP_ERR_PARAM);
				default: // backup one level
					pMappedPath->mp_pdfe = pDFEntry->dfe_Parent;
			}

			// this better be a lookup request
			if (MapReason != Lookup)
			{
				if (DFflag == DFE_DIR)
				{
					return AFP_ERR_OBJECT_EXISTS;
				}
				else
				{
					return AFP_ERR_OBJECT_TYPE;
				}
			}

			// had to have been a lookup operation
			if (DFflag == DFE_FILE)
			{
				return AFP_ERR_OBJECT_TYPE;
			}
			else
			{
#ifdef GET_CORRECT_OFFSPRING_COUNTS
				checkEnumForParent = checkEnumForDir = True;
#endif
				break;
			}
		} // endif last component was an 'up' token

		// the last component is a file or directory name
		RtlInitString(&acomponent, component);
		AfpConvertStringToMungedUnicode(&acomponent,
										&pMappedPath->mp_Tail);

		//
		// Before we search our database for the last component of the
		// path, make sure all the files have been cached in for this
		// directory
		//
		if (!DFE_CHILDREN_ARE_PRESENT(pDFEntry))
		{
			if (!LockedExclusive &&
				!AfpSwmrUpgradeToExclusive(&pVolDesc->vds_IdDbAccessLock))
			{
				return AFP_ERR_WRITE_LOCK_REQUIRED;
			}
			else
			{
				NTSTATUS status;
				LockedExclusive = True;
				status = AfpCacheDirectoryTree(pVolDesc,
											   pDFEntry,
											   GETFILES,
											   NULL,
											   NULL);
				if (!NT_SUCCESS(status))
				{
					DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_ERR,
							("afpMapAfpPathToMappedPath: could not cache dir tree for %Z (0x%lx)\n",
							 &(pDFEntry->dfe_UnicodeName), status) );
					return AFP_ERR_MISC;
				}
			}
		}

		ptempDFEntry = AfpFindEntryByUnicodeName(pVolDesc,
												 &pMappedPath->mp_Tail,
												 PathType,
												 pDFEntry,
												 DFE_ANY);

		if (MapReason == Lookup)	// its a lookup request
		{
			if (ptempDFEntry == NULL)
			{
				return AFP_ERR_OBJECT_NOT_FOUND;
			}
			else if (((DFflag == DFE_DIR) && DFE_IS_FILE(ptempDFEntry)) ||
					 ((DFflag == DFE_FILE) && DFE_IS_DIRECTORY(ptempDFEntry)))
			{
				return AFP_ERR_OBJECT_TYPE;
			}
			else
			{
				pMappedPath->mp_pdfe = ptempDFEntry;
#ifdef GET_CORRECT_OFFSPRING_COUNTS
				if (DFE_IS_DIRECTORY(ptempDFEntry))
					// we've already made sure this thing's parent was
					// enumerated already above.
					checkEnumForDir = True;
#endif
				break;
			}
		}
		else	// path mapping is for a create
		{
			ASSERT(DFflag != DFE_ANY); // Create must specify the exact type

			// Save the parent DFEntry
			pMappedPath->mp_pdfe = pDFEntry;

			if (ptempDFEntry != NULL)
			{
				// A file or dir by that name exists in the database
				// (and we will assume it exists on disk)
				if (MapReason == SoftCreate)
				{
					// Attempting create of a directory, or soft create of a file,
					// and dir OR file by that name exists,
					if ((DFflag == DFE_DIR) || DFE_IS_FILE(ptempDFEntry))
					{
						return AFP_ERR_OBJECT_EXISTS;
					}
					else
					{
						return AFP_ERR_OBJECT_TYPE;
					}
				}
				else if (DFE_IS_FILE(ptempDFEntry))
				{
					// Must be hard create and file by that name exists
					if (ptempDFEntry->dfe_Flags & DFE_FLAGS_OPEN_BITS)
					{
						return AFP_ERR_FILE_BUSY;
					}
					else
					{
						// note we return object_exists instead of no_err
						return AFP_ERR_OBJECT_EXISTS;
					}
				}
				else
				{
					// Attempting hard create of file, but found a directory
					return AFP_ERR_OBJECT_TYPE;
				}
			}
			else
			{
				return AFP_ERR_NONE;
			}
		}

	} while (False);

	// The only way we should have gotten here is if we successfully mapped
	// the path to a DFENTRY for lookup and would return AFP_ERR_NONE
	ASSERT((pMappedPath->mp_pdfe != NULL) && (MapReason == Lookup));

#ifdef GET_CORRECT_OFFSPRING_COUNTS
	if (checkEnumForParent)
	{
		if (!DFE_CHILDREN_ARE_PRESENT(pMappedPath->mp_pdfe->dfe_Parent))
		{
			if (!LockedExclusive &&
				!AfpSwmrUpgradeToExclusive(&pVolDesc->vds_IdDbAccessLock))
			{
				return AFP_ERR_WRITE_LOCK_REQUIRED;
			}
			else
			{
				NTSTATUS status;
				LockedExclusive = True;
				status = AfpCacheDirectoryTree(pVolDesc,
											   pMappedPath->mp_pdfe->dfe_Parent,
											   GETFILES,
											   NULL,
											   NULL);
				if (!NT_SUCCESS(status))
				{
					DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_ERR,
							("afpMapAfpPathToMappedPath: could not cache dir tree for %Z (0x%lx)\n",
							 &(pMappedPath->mp_pdfe->dfe_Parent->dfe_UnicodeName), status) );
					return AFP_ERR_MISC;
				}
			}
		}

	}
#endif

	if (checkEnumForDir)
	{
		if (!DFE_CHILDREN_ARE_PRESENT(pMappedPath->mp_pdfe))
		{
			if (!LockedExclusive &&
				!AfpSwmrUpgradeToExclusive(&pVolDesc->vds_IdDbAccessLock))
			{
				return AFP_ERR_WRITE_LOCK_REQUIRED;
			}
			else
			{
				NTSTATUS status;
				LockedExclusive = True;
				status = AfpCacheDirectoryTree(pVolDesc,
											   pMappedPath->mp_pdfe,
											   GETFILES,
											   NULL,
											   NULL);
				if (!NT_SUCCESS(status))
				{
					DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_ERR,
							("afpMapAfpPathToMappedPath: could not cache dir tree for %Z (0x%lx)\n",
							 &(pMappedPath->mp_pdfe->dfe_UnicodeName), status) );
					return AFP_ERR_MISC;
				}
			}
		}

	}


	return AFP_ERR_NONE;
}


/***	AfpHostPathFromDFEntry
 *
 *	This routine takes a pointer to a DFEntry and builds the full
 *	host path (in unicode) to that entity by ascending the ID database
 *	tree.
 *
 *	IN	pDFE	--	pointer to DFEntry of which host path is desired
 *	IN	taillen --	number of extra *bytes*, if any, the caller
 *					desires to have allocated for the host path,
 *					including room for any path separators
 *	OUT	ppPath	--	pointer to UNICODE string
 *
 *	The caller must have the DirID/FileID database locked for read
 *	before calling this routine. The caller can supply a buffer which will
 *	be used if sufficient. Caller must free the allocated (if any)
 * 	unicode string buffer.
 *
 *	LOCKS_ASSUMED: vds_IdDbAccessLock (SWMR, Shared)
 */
AFPSTATUS
AfpHostPathFromDFEntry(
	IN		PDFENTRY		pDFE,
	IN		DWORD			taillen,
	OUT		PUNICODE_STRING	pPath
)
{
	AFPSTATUS		Status = AFP_ERR_NONE;
	DWORD			pathlen = taillen;
	PDFENTRY		*pdfelist = NULL, curpdfe = NULL;
	PDFENTRY		apdfelist[AVERAGE_NODE_DEPTH];
	int				counter;

	PAGED_CODE( );

	pPath->Length = 0;

	do
	{
		if (DFE_IS_FILE(pDFE))
		{
			counter = pDFE->dfe_Parent->dfe_DirDepth;
		}
		else // its a DIRECTORY entry
		{
			ASSERT(DFE_IS_DIRECTORY(pDFE));
			if (DFE_IS_ROOT(pDFE))
			{
				if ((pathlen > 0) && (pPath->MaximumLength < pathlen))
				{
					if ((pPath->Buffer = (PWCHAR)AfpAllocNonPagedMemory(pathlen)) == NULL)
					{
						Status = AFP_ERR_MISC;
						break;
					}
					pPath->MaximumLength = (USHORT)pathlen;
				}
				break;				// We are done
			}

			if (DFE_IS_PARENT_OF_ROOT(pDFE))
			{
				Status = AFP_ERR_OBJECT_NOT_FOUND;
				break;
			}

			ASSERT(pDFE->dfe_DirDepth >= 1);
			counter = pDFE->dfe_DirDepth - 1;
		}

		if (counter)
		{
			// if node is within average depth, use the array on the stack,
			// otherwise, allocate an array
			if (counter <= AVERAGE_NODE_DEPTH)
			{
				pdfelist = apdfelist;
			}
			else
			{
				pdfelist = (PDFENTRY *)AfpAllocNonPagedMemory(counter*sizeof(PDFENTRY));
				if (pdfelist == NULL)
				{
					Status = AFP_ERR_MISC;
					break;
				}
			}
			pathlen += counter * sizeof(WCHAR); // room for path separators
		}

		curpdfe = pDFE;
		pathlen += curpdfe->dfe_UnicodeName.Length;

		// walk up the tree till you find the root, collecting string lengths
		// and PDFENTRY values as you go...
		while (counter--)
		{
			pdfelist[counter] = curpdfe;
			curpdfe = curpdfe->dfe_Parent;
			pathlen += curpdfe->dfe_UnicodeName.Length;
		}

		// we are in the root, start building up the host path buffer
		if (pathlen > pPath->MaximumLength)
		{
			pPath->Buffer = (PWCHAR)AfpAllocNonPagedMemory(pathlen);
			if (pPath->Buffer == NULL)
			{
				Status = AFP_ERR_MISC;
				break;
			}
			DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_INFO,
					("AfpHostPathFromDFEntry: Allocated path buffer %lx\n",
					pPath->Buffer));
			pPath->MaximumLength = (USHORT)pathlen;
		}

		counter = 0;
		do
		{
			RtlAppendUnicodeStringToString(pPath, &curpdfe->dfe_UnicodeName);
			if (curpdfe != pDFE)
			{	// add a path separator
				pPath->Buffer[pPath->Length / sizeof(WCHAR)] = L'\\';
				pPath->Length += sizeof(WCHAR);
				curpdfe = pdfelist[counter++];
				continue;
			}
			break;
		} while (True);

		if (pdfelist && (pdfelist != apdfelist))
			AfpFreeMemory(pdfelist);
	} while (False);

	return Status;
}



/***	AfpCheckParentPermissions
 *
 *	Check if this user has the necessary SeeFiles or SeeFolders permissions
 *	to the parent directory of a file or dir we have just pathmapped.
 *
 *	LOCKS_ASSUMED: vds_IdDbAccessLock (SWMR, Exclusive or Shared)
 */
AFPSTATUS
AfpCheckParentPermissions(
	IN	PCONNDESC			pConnDesc,
	IN	DWORD				ParentDirId,
	IN	PUNICODE_STRING		pParentPath,	// path of dir to check
	IN	DWORD				RequiredPerms,	// seefiles,seefolders,makechanges mask
	OUT	PFILESYSHANDLE		pHandle OPTIONAL, // return open parent handle?
	OUT	PBYTE				pUserRights OPTIONAL // return user rights?
)
{
	NTSTATUS		Status = AFP_ERR_NONE;
	FILEDIRPARM		FDParm;
	PATHMAPENTITY	PME;
	PVOLDESC		pVolDesc = pConnDesc->cds_pVolDesc;
	PDFENTRY		pDfEntry;

	PAGED_CODE( );

	ASSERT(IS_VOLUME_NTFS(pVolDesc) && (ParentDirId != AFP_ID_PARENT_OF_ROOT));
	ASSERT(AfpSwmrLockedExclusive(&pVolDesc->vds_IdDbAccessLock) ||
		   AfpSwmrLockedShared(&pVolDesc->vds_IdDbAccessLock));

	do
	{
		PME.pme_Handle.fsh_FileHandle = NULL;
		if (ARGUMENT_PRESENT(pHandle))
		{
			pHandle->fsh_FileHandle = NULL;
		}
		ASSERT(ARGUMENT_PRESENT(pParentPath));
		AfpInitializePME(&PME, pParentPath->MaximumLength, pParentPath->Buffer);
		PME.pme_FullPath.Length = pParentPath->Length;

		if ((pDfEntry = AfpFindDfEntryById(pVolDesc,
											ParentDirId,
											DFE_DIR)) == NULL)
		{
			Status = AFP_ERR_OBJECT_NOT_FOUND;
			break;
		}

		ASSERT(DFE_IS_DIRECTORY(pDfEntry));
		AfpInitializeFDParms(&FDParm);

		Status = afpGetMappedForLookupFDInfo(pConnDesc,
											 pDfEntry,
											 DIR_BITMAP_ACCESSRIGHTS |
												FD_INTERNAL_BITMAP_OPENACCESS_READCTRL,
											 &PME,
											 &FDParm);

		if (!NT_SUCCESS(Status))
		{
			if (PME.pme_Handle.fsh_FileHandle != NULL)
			{
				AfpIoClose(&PME.pme_Handle);
			}
			break;
		}

		if ((FDParm._fdp_UserRights & RequiredPerms) != RequiredPerms)
		{
			Status = AFP_ERR_ACCESS_DENIED;
		}

		if (ARGUMENT_PRESENT(pHandle) && NT_SUCCESS(Status))
		{
			*pHandle = PME.pme_Handle;
		}
		else
		{
			AfpIoClose(&PME.pme_Handle);
		}

		if (ARGUMENT_PRESENT(pUserRights))
		{
			*pUserRights = FDParm._fdp_UserRights;
		}

	} while (False);

	return Status;
}

/***	afpOpenUserHandle
 *
 * Open a handle to data or resource stream of an entity in the user's
 * context.  Only called for NTFS volumes.
 *
 *	LOCKS_ASSUMED: vds_idDbAccessLock (SWMR, Shared)
 */
AFPSTATUS
afpOpenUserHandle(
	IN	PCONNDESC			pConnDesc,
	IN	PDFENTRY			pDfEntry,
	IN	PUNICODE_STRING		pPath		OPTIONAL,	// path of file/dir to open
	IN	DWORD				Bitmap,					// to extract the Open access mode
	OUT	PFILESYSHANDLE		pfshData				// Handle of data stream of object
)
{
	PVOLDESC		pVolDesc = pConnDesc->cds_pVolDesc;
	NTSTATUS		Status;
	DWORD			OpenAccess;
	DWORD			DenyMode;
	BOOLEAN			isdir, CheckAccess = False, Revert = False;
	WCHAR			HostPathBuf[BIG_PATH_LEN];
	UNICODE_STRING	uHostPath;

	PAGED_CODE( );

	pfshData->fsh_FileHandle = NULL;

	isdir = (DFE_IS_DIRECTORY(pDfEntry)) ? True : False;
	OpenAccess = AfpMapFDBitmapOpenAccess(Bitmap, isdir);

	// Extract the index into the AfpDenyModes array from Bitmap
	DenyMode = AfpDenyModes[(Bitmap & FD_INTERNAL_BITMAP_DENYMODE_ALL) >>
								FD_INTERNAL_BITMAP_DENYMODE_SHIFT];

	do
	{
		if (ARGUMENT_PRESENT(pPath))
		{
			uHostPath = *pPath;
		}
		else
		{
			AfpSetEmptyUnicodeString(&uHostPath,
									 sizeof(HostPathBuf),
									 HostPathBuf);
			ASSERT ((Bitmap & FD_INTERNAL_BITMAP_OPENFORK_RESC) == 0);
			if (!NT_SUCCESS(AfpHostPathFromDFEntry(pDfEntry,
												   0,
												   &uHostPath)))
			{
				Status = AFP_ERR_MISC;
				break;
			}
		}

		CheckAccess = False;
		Revert = False;
		// Don't impersonate or check access if this is ADMIN calling
		// or if volume is CDFS. If this handle will be used for setting
		// permissions, impersonate the user token instead. The caller
		// should have determined by now that this chappie has access
		// to change permissions.
		if (Bitmap & FD_INTERNAL_BITMAP_OPENACCESS_RWCTRL)
		{
			Revert = True;
			AfpImpersonateClient(NULL);
		}

		else if (!(Bitmap & FD_INTERNAL_BITMAP_SKIP_IMPERSONATION) &&
				 (pConnDesc->cds_pSda->sda_ClientType != SDA_CLIENT_ADMIN) &&
				 IS_VOLUME_NTFS(pVolDesc))
		{
			CheckAccess = True;
			Revert = True;
			AfpImpersonateClient(pConnDesc->cds_pSda);
		}

		DBGPRINT(DBG_COMP_AFPINFO, DBG_LEVEL_INFO,
				("afpOpenUserHandle: OpenMode %lx, DenyMode %lx\n",
				OpenAccess, DenyMode));

		if (Bitmap & FD_INTERNAL_BITMAP_OPENFORK_RESC)
		{
			DWORD	crinfo;	// was the Resource fork opened or created?

			ASSERT(IS_VOLUME_NTFS(pVolDesc));
			ASSERT((uHostPath.MaximumLength - uHostPath.Length) >= AfpResourceStream.Length);
			RtlCopyMemory((PBYTE)(uHostPath.Buffer) + uHostPath.Length,
						  AfpResourceStream.Buffer,
						  AfpResourceStream.Length);
			uHostPath.Length += AfpResourceStream.Length;
			Status = AfpIoCreate(&pVolDesc->vds_hRootDir,
								 AFP_STREAM_DATA,
								 &uHostPath,
								 OpenAccess,
								 DenyMode,
								 FILEIO_OPEN_FILE,
								 FILEIO_CREATE_INTERNAL,
								 FILE_ATTRIBUTE_NORMAL,
								 True,
								 NULL,
								 pfshData,
								 &crinfo,
								 NULL,
								 NULL,
								 NULL);
		}
		else
		{
			Status = AfpIoOpen(&pVolDesc->vds_hRootDir,
								AFP_STREAM_DATA,
								isdir ?
									FILEIO_OPEN_DIR : FILEIO_OPEN_FILE,
								&uHostPath,
								OpenAccess,
								DenyMode,
								CheckAccess,
								pfshData);
		}

		if (Revert)
			AfpRevertBack();

		if (!ARGUMENT_PRESENT(pPath))
		{
			if ((uHostPath.Buffer != NULL) && (uHostPath.Buffer != HostPathBuf))
				AfpFreeMemory(uHostPath.Buffer);
		}

		if (!NT_SUCCESS(Status))
		{
			DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_WARN,
					("afpOpenUserHandle: NtOpenFile/NtCreateFile (Open %lx, Deny %lx) %lx\n",
					OpenAccess, DenyMode, Status));
			Status = AfpIoConvertNTStatusToAfpStatus(Status);
			break;
		}

	} while (False);

	if (!NT_SUCCESS(Status) && (pfshData->fsh_FileHandle != NULL))
	{
		AfpIoClose(pfshData);
	}

	return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\server\nwtrash.c ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	nwtrash.c

Abstract:

	This module contains the routines for performing Network Trash Folder
	operations.

Author:

	Sue Adams (microsoft!suea)


Revision History:
	06 Aug 1992		Initial Version

Notes:	Tab stop: 4
--*/

#define	NWTRASH_LOCALS
#define	FILENUM	FILE_NWTRASH

#include <afp.h>
#include <fdparm.h>
#include <pathmap.h>
#include <nwtrash.h>
#include <afpinfo.h>
#include <access.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, AfpCreateNetworkTrash)
#pragma alloc_text( PAGE, AfpDeleteNetworkTrash)
#pragma alloc_text( PAGE, afpCleanNetworkTrash)
#pragma alloc_text( PAGE, AfpWalkDirectoryTree)
#pragma alloc_text( PAGE, afpPushDirNode)
#pragma alloc_text( PAGE, afpPopDirNode)
#pragma alloc_text( PAGE, AfpGetNextDirectoryInfo)
#pragma alloc_text( PAGE, afpNwtDeleteFileEntity)
#endif

/***	AfpCreateNetworkTrash
 *
 *	Create the network trash folder for a newly added volume.
 *  Make sure it is hidden and make sure the streams are intact.
 *  This routine may only be called for NTFS volumes.  Note that even
 *  ReadOnly NTFS volumes will have a trash created.  This is because
 *  if someone is going to toggle the volume ReadOnly bit, we don't need
 *  to worry about creating/deleting the trash on the fly.
 *  We keep an open handle to the network trash stored in the volume
 *  descriptor so that nobody can come in behind our backs and delete
 *  it.
 */
NTSTATUS
AfpCreateNetworkTrash(
	IN	PVOLDESC	pVolDesc
)
{
	FILESYSHANDLE	hNWT;
	PDFENTRY		pDfEntry;
	NTSTATUS 		Status;
	ULONG	 		info, Attr;
	AFPINFO			afpInfo;
	BOOLEAN			ReleaseSwmr = False;
	PISECURITY_DESCRIPTOR pSecDesc;
	FILEDIRPARM		fdparm;		// This is used to set the hidden attribute
								// of the FinderInfo for network trash folder

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_IDINDEX,DBG_LEVEL_INFO,("\tCreating Network Trash...\n"));
	ASSERT(pVolDesc->vds_Flags & VOLUME_NTFS);

	hNWT.fsh_FileHandle = NULL;

	Status = AfpMakeSecurityDescriptorForUser(&AfpSidWorld, &AfpSidWorld, &pSecDesc);

	if (!NT_SUCCESS(Status))
		return Status;

	ASSERT (pSecDesc != NULL);
	ASSERT (pSecDesc->Dacl != NULL);

	do
	{
		// NOTE: NTFS allows me to open a Readonly directory for
		// delete access.
		Status = AfpIoCreate(&pVolDesc->vds_hRootDir,
							 AFP_STREAM_DATA,
							 &AfpNetworkTrashNameU,
							 AFP_NWT_ACCESS | AFP_OWNER_ACCESS,
							 AFP_NWT_SHAREMODE,
							 AFP_NWT_OPTIONS,
							 AFP_NWT_DISPOSITION,
							 AFP_NWT_ATTRIBS, // makes it hidden
							 False,
							 pSecDesc,
							 &hNWT,
							 &info,
							 NULL,
							 NULL,
							 NULL);

		// Free the memory allocated for the security descriptor
		AfpFreeMemory(pSecDesc->Dacl);
		AfpFreeMemory(pSecDesc);

		if (!NT_SUCCESS(Status))
			break;

		ASSERT(info == FILE_CREATED);

		// Add the AfpInfo stream
		Status = AfpSlapOnAfpInfoStream(NULL,
										NULL,
										&hNWT,
										NULL,
										AFP_ID_NETWORK_TRASH,
										True,
										NULL,
										&afpInfo);
		if (!NT_SUCCESS(Status))
			break;

		// it does not exist in the ID index database, add it
		AfpSwmrAcquireExclusive(&pVolDesc->vds_IdDbAccessLock);
		ReleaseSwmr = True;

		ASSERT(pVolDesc->vds_pDfeRoot != NULL);

		pDfEntry = AfpAddDfEntry(pVolDesc,
								 pVolDesc->vds_pDfeRoot,
								 &AfpNetworkTrashNameU,
								 True,
								 AFP_ID_NETWORK_TRASH);

		if (pDfEntry == NULL)
		{
			Status = STATUS_UNSUCCESSFUL;
			break;
		}

		// NOTE: pDfEntry now points to the "Network Trash Folder"

		// Get directory info to cache
		Status = AfpIoQueryTimesnAttr(&hNWT,
									  &pDfEntry->dfe_CreateTime,
									  &pDfEntry->dfe_LastModTime,
									  &Attr);
	
		ASSERT(NT_SUCCESS(Status));

		ASSERT(Attr & FILE_ATTRIBUTE_HIDDEN);
		pDfEntry->dfe_NtAttr = (USHORT)Attr & FILE_ATTRIBUTE_VALID_FLAGS;
		pDfEntry->dfe_AfpAttr = afpInfo.afpi_Attributes;
		pDfEntry->dfe_FinderInfo = afpInfo.afpi_FinderInfo;
		pDfEntry->dfe_BackupTime = afpInfo.afpi_BackupTime;
		DFE_OWNER_ACCESS(pDfEntry) = (DIR_ACCESS_SEARCH | DIR_ACCESS_READ);
		DFE_GROUP_ACCESS(pDfEntry) = (DIR_ACCESS_SEARCH | DIR_ACCESS_READ);
		DFE_WORLD_ACCESS(pDfEntry) = (DIR_ACCESS_SEARCH | DIR_ACCESS_READ);

		// ok, we know it now exists both on disk and in the database
		if (NT_SUCCESS(Status))
		{
			RtlZeroMemory(&fdparm, sizeof(fdparm));
			fdparm._fdp_Flags = DFE_FLAGS_DIR;
			fdparm._fdp_AfpId = AFP_ID_NETWORK_TRASH;
			fdparm._fdp_FinderInfo = afpInfo.afpi_FinderInfo;

			// We must set the invisible flag in the finder info, because
			// System 6 seems to ignore the hidden attribute.
			pDfEntry->dfe_FinderInfo.fd_Attr1 |= FINDER_FLAG_INVISIBLE;
			fdparm._fdp_FinderInfo.fd_Attr1 |= FINDER_FLAG_INVISIBLE;
			Status = AfpSetAfpInfo(&hNWT,
								   FD_BITMAP_FINDERINFO,
								   &fdparm,
								   NULL,
								   NULL);
		}
	} while (False);

	if (hNWT.fsh_FileHandle != NULL)
		AfpIoClose(&hNWT);

	if (!NT_SUCCESS(Status))
	{
		AFPLOG_ERROR(AFPSRVMSG_CREATE_NWTRASH,
					 Status,
					 NULL,
					 0,
					 &pVolDesc->vds_Name);
	}
	else
	{
		// Open a Network Trash handle to keep around so that no one can
		// come in and delete the Network Trash dir out from under us
		Status = AfpIoOpen(&pVolDesc->vds_hRootDir,
						   AFP_STREAM_DATA,
						   AFP_NWT_OPTIONS,
						   &AfpNetworkTrashNameU,
						   FILEIO_ACCESS_READ,
						   AFP_NWT_SHAREMODE,
						   False,
						   &pVolDesc->vds_hNWT);
	
		if (!NT_SUCCESS(Status))
		{
			AFPLOG_ERROR(AFPSRVMSG_CREATE_NWTRASH, Status, NULL, 0,
						 &pVolDesc->vds_Name);
		}
	}

	if (ReleaseSwmr)
	{
		AfpSwmrRelease(&pVolDesc->vds_IdDbAccessLock);
	}

	return Status;
}

/*** AfpDeleteNetworkTrash
 *
 *	Delete the network trash folder from disk when a volume is being added,
 *  deleted or stopped.
 *
 * 	NOTE: this must be called in the server's context to ensure that we have
 * 	LOCAL_SYSTEM access to all the trash directories created by users
 */
NTSTATUS
AfpDeleteNetworkTrash(
	IN	PVOLDESC	pVolDesc,
	IN	BOOLEAN		VolumeStart 	// Is volume starting or is it stopping
)
{
	FILESYSHANDLE	hNWT;
	NTSTATUS 		Status;

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_INFO,
										("\tDeleting Network Trash...\n") );
	ASSERT(pVolDesc->vds_Flags & VOLUME_NTFS);

	if (!VolumeStart)
	{
		// Close the handle to Network Trash that we keep open so PC users can't
		// delete the directory out from under us.
		if (pVolDesc->vds_hNWT.fsh_FileHandle != NULL)
		{
			AfpIoClose(&pVolDesc->vds_hNWT);
			pVolDesc->vds_hNWT.fsh_FileHandle = NULL;
		}
	}

	do
	{
		AfpSwmrAcquireExclusive(&pVolDesc->vds_IdDbAccessLock);

		// Open for delete access
		Status = AfpIoOpen(&pVolDesc->vds_hRootDir,
						   AFP_STREAM_DATA,
						   AFP_NWT_OPTIONS,
						   &AfpNetworkTrashNameU,
						   AFP_NWT_ACCESS,
						   AFP_NWT_SHAREMODE,
						   False,
						   &hNWT);
		// there is no network trash folder to delete
		if (Status == STATUS_OBJECT_NAME_NOT_FOUND)
		{
			Status = STATUS_SUCCESS;
			break;
		}
	
		if (NT_SUCCESS(Status))
		{
			Status = afpCleanNetworkTrash(pVolDesc, &hNWT, NULL);
	
			if (NT_SUCCESS(Status) || !VolumeStart)
			{
	
				// NOTE: NTFS will allow me to open the directory for
				// DELETE access if it is marked Readonly, but I cannot delete it.
				// Clear the Readonly Bit on the Network Trash Folder
				AfpIoSetTimesnAttr(&hNWT,
								   NULL,
								   NULL,
								   0,
								   FILE_ATTRIBUTE_READONLY,
								   NULL,
								   NULL);
				Status = AfpIoMarkFileForDelete(&hNWT,
												NULL,
												NULL,
												NULL);
		
			}
	
			AfpIoClose(&hNWT);
		}
	} while (False);

	AfpSwmrRelease(&pVolDesc->vds_IdDbAccessLock);

	if ((!NT_SUCCESS(Status)) && (Status != STATUS_OBJECT_NAME_NOT_FOUND))
	{
		AFPLOG_ERROR(AFPSRVMSG_DELETE_NWTRASH,
					 Status,
					 NULL,
					 0,
					 &pVolDesc->vds_Name);
		Status = STATUS_UNSUCCESSFUL;
	}

	return Status;
}

/*** afpCleanNetworkTrash
 *
 *	Delete the contents of the network trash folder referenced by hNWT.
 *  If pDfeNWT is non-null, then delete the file/dir entries from the IdIndex
 *  database.  If pDfeNWT is null, the volume is being deleted and the
 *  IdIndex database is getting blown away too, so don't bother removing the
 *  entries.
 */
LOCAL
NTSTATUS
afpCleanNetworkTrash(
	IN	PVOLDESC		pVolDesc,
	IN	PFILESYSHANDLE	phNWT,
	IN	PDFENTRY		pDfeNWT OPTIONAL
)
{
	NTSTATUS Status;

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_IDINDEX,DBG_LEVEL_INFO,("afpCleanNetworkTrash entered\n"));

	if (pDfeNWT != NULL)
	{
		ASSERT(pDfeNWT->dfe_AfpId == AFP_ID_NETWORK_TRASH);
		// clean out all child DFEntries belonging to the network trash
		AfpPruneIdDb(pVolDesc,pDfeNWT);
	}

	Status = AfpWalkDirectoryTree(phNWT, afpNwtDeleteFileEntity);

	return Status;
}

NTSTATUS
AfpWalkDirectoryTree(
	IN	PFILESYSHANDLE	phTargetDir,
	IN	WALKDIR_WORKER	NodeWorker
)
{
	PFILE_DIRECTORY_INFORMATION	tmpptr;
	PWALKDIR_NODE	DirNodeStacktop = NULL, pcurrentnode;
	NTSTATUS		rc, status = STATUS_SUCCESS;
	PBYTE			enumbuf;
	PWCHAR			nodename;
	ULONG			nodenamelen;
	BOOLEAN			isdir;
	UNICODE_STRING	udirname;

	PAGED_CODE( );

	//
	// allocate the buffer that will hold enumerated files and dirs
	//
	if ((enumbuf = (PBYTE)AfpAllocPANonPagedMemory(AFP_ENUMBUF_SIZE)) == NULL)
	{
		return STATUS_INSUFFICIENT_RESOURCES;
	}

	do	// error handling loop
	{
		//
		// prime the pump with the top level (target dir) directory handle
		//
		if ((rc = afpPushDirNode(&DirNodeStacktop, NULL, NULL))
															!= STATUS_SUCCESS)
		{
			status = rc;
			break;
		}
		else
		{
			DirNodeStacktop->wdn_Handle = *phTargetDir;
		}

		//
		// keep popping enumerated directories off the stack until stack empty
		//
		while ((pcurrentnode = DirNodeStacktop) != NULL)
		{
			if (pcurrentnode->wdn_Enumerated == False)
			{
				//
				// get a handle to the directory so it can be enumerated
				//
				if (pcurrentnode->wdn_Handle.fsh_FileHandle == NULL)
				{
					RtlInitUnicodeString(&udirname,
										 pcurrentnode->wdn_RelativePath.Buffer);
					// open a handle to the thing relative to the phTargetDir
					rc = AfpIoOpen(phTargetDir,
								 AFP_STREAM_DATA,
								 FILEIO_OPEN_DIR,
								 &udirname,
								 FILEIO_ACCESS_READ,
								 FILEIO_DENY_NONE,
								 False,
								 &pcurrentnode->wdn_Handle);

					if (!NT_SUCCESS(rc))
					{
						status = rc;
						break;
					}
				}

				//
				// keep enumerating till we get all the entries
				//
				while (True)
				{
					rc = AfpIoQueryDirectoryFile(&pcurrentnode->wdn_Handle,
												 (PFILE_DIRECTORY_INFORMATION)enumbuf,
												 AFP_ENUMBUF_SIZE,
												 FileDirectoryInformation,
												 False,	// return multiple entries
												 False,	// don't restart scan
												 NULL);

					ASSERT(rc != STATUS_PENDING);

					if ((rc == STATUS_NO_MORE_FILES) ||
						(rc == STATUS_NO_SUCH_FILE))
					{
						pcurrentnode->wdn_Enumerated = True;
						break; // that's it, we've seen everything there is
					}
					//
					// NOTE: if we get STATUS_BUFFER_OVERFLOW, the IO status
					// information field does NOT tell us the required size
					// of the buffer, so we wouldn't know how big to realloc
					// the enum buffer if we wanted to retry, so don't bother
					else if (!NT_SUCCESS(rc))
					{
						status = rc;
						break;	// enumerate failed, bail out
					}

					//
					// process the enumerated files and dirs
					//
					tmpptr = (PFILE_DIRECTORY_INFORMATION)enumbuf;
					while (True)
					{
						rc = AfpGetNextDirectoryInfo(&tmpptr,
													 &nodename,
													 &nodenamelen,
													 &isdir);

						if (rc == STATUS_NO_MORE_ENTRIES)
						{
							break;
						}

						if (isdir == True)
						{
							AfpInitUnicodeStringWithNonNullTerm(&udirname,
													   (USHORT)nodenamelen,
													   nodename);

							if (RtlEqualUnicodeString(&Dot,&udirname,False) ||
								RtlEqualUnicodeString(&DotDot,&udirname,False))
							{
								continue;
							}

							//
							// push it onto the dir node stack
							//
							rc = afpPushDirNode(&DirNodeStacktop,
												&pcurrentnode->wdn_RelativePath,
												&udirname);
							if (rc != STATUS_SUCCESS)
							{
								status = rc;
								break;
							}
						}
						else
						{
							//
							// its a file, call worker with its relative handle
							// and path
							//
							rc = NodeWorker(&pcurrentnode->wdn_Handle,
											nodename,
											nodenamelen,
											False);
							if (!NT_SUCCESS(rc))
							{
								status = rc;
								break;
							}
						}

					} // while more entries in the enumbuf


					if (!NT_SUCCESS(status))
					{
						break;
					}

				} // while there are more files to enumerate

				if (pcurrentnode->wdn_Handle.fsh_FileHandle != phTargetDir->fsh_FileHandle)
				{
					AfpIoClose(&pcurrentnode->wdn_Handle);
				}
			}
			else	// we have already enumerated this directory
			{
				if (pcurrentnode->wdn_RelativePath.Length != 0)
				{
					// call the worker routine on this directory node
					rc = NodeWorker(phTargetDir,
									pcurrentnode->wdn_RelativePath.Buffer,
									pcurrentnode->wdn_RelativePath.Length,
									True);
				}
				else rc = STATUS_SUCCESS;

				afpPopDirNode(&DirNodeStacktop);
				if (!NT_SUCCESS(rc))
				{
					status = rc;
					break;
				}

			}


			if (!NT_SUCCESS(status))
			{
				break;
			}

		} // while there are directories to pop

	} while (False); // error handling loop

	while (DirNodeStacktop != NULL)
	{
		DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_WARN,
				 ("AfpWalkDirectoryTree: WARNING: cleaning up dir stack\n") );
		// clean up in case of error
		afpPopDirNode(&DirNodeStacktop);
	}
	AfpFreePANonPagedMemory(enumbuf, AFP_ENUMBUF_SIZE);
	return status;
}

/***	afpPushDirNode
 *
 *	Keep a record of all the directories we have encountered so far during
 *  enumeration of the tree.  We need to process directories from the
 *  bottom up because the WalkTree node worker routine does a delete
 *	on all the items in a tree, and we certainly cant be deleting directories that
 *  are not empty.
 *
 */
LOCAL
NTSTATUS
afpPushDirNode(
	IN OUT	PWALKDIR_NODE	*ppStacktop,
	IN		PUNICODE_STRING pParentPath,	// path to parent (NULL iff walk root)
	IN		PUNICODE_STRING	pDirName		// name of current node directory
)
{
	PWALKDIR_NODE	tempptr;
	UNICODE_STRING	ubackslash;
	ULONG			memsize;
	USHORT			namesize = 0;

	PAGED_CODE( );

	if (pParentPath != NULL)
	{
		namesize = pParentPath->Length + sizeof(WCHAR) +
				   pDirName->Length + sizeof(UNICODE_NULL);
	}
	memsize = namesize + sizeof(WALKDIR_NODE);

	if ((tempptr = (PWALKDIR_NODE)AfpAllocNonPagedMemory(memsize)) == NULL)
	{
		return STATUS_INSUFFICIENT_RESOURCES;
	}

	tempptr->wdn_Enumerated = False;
	tempptr->wdn_Handle.fsh_FileHandle = NULL;
	tempptr->wdn_RelativePath.Length = 0;
	tempptr->wdn_RelativePath.MaximumLength = namesize;

	if (pParentPath != NULL)
	{
		tempptr->wdn_RelativePath.Buffer = (LPWSTR)((PBYTE)tempptr +
														  sizeof(WALKDIR_NODE));
		if (pParentPath->Length != 0)
		{
			RtlInitUnicodeString(&ubackslash,L"\\");
			AfpCopyUnicodeString(&tempptr->wdn_RelativePath,pParentPath);
			RtlAppendUnicodeStringToString(&tempptr->wdn_RelativePath,
										   &ubackslash);
		}

		RtlAppendUnicodeStringToString(&tempptr->wdn_RelativePath,pDirName);
		tempptr->wdn_RelativePath.Buffer[tempptr->wdn_RelativePath.Length/sizeof(WCHAR)] = UNICODE_NULL;

	}
	else
	{
		tempptr->wdn_RelativePath.Buffer = NULL;
	}

	// push it on the stack
	tempptr->wdn_Next = *ppStacktop;
	*ppStacktop = tempptr;

	return STATUS_SUCCESS;
}

/*** afpPopDirNode
 *
 * Pop the top DirNode off of the stack and free it
 *
 ***/
LOCAL
VOID
afpPopDirNode(
	IN OUT PWALKDIR_NODE	*ppStackTop
)
{
	PWALKDIR_NODE	tempptr;

	PAGED_CODE( );

	ASSERT(*ppStackTop != NULL);

	tempptr = (*ppStackTop)->wdn_Next;
	AfpFreeMemory(*ppStackTop);
	*ppStackTop = tempptr;

}

/***	AfpGetNextDirectoryInfo
 *
 * Given a buffer full of FILE_DIRECTORY_INFORMATION entries as returned
 * from a directory enumerate, find the next structure in the buffer and
 * return the name information out of it, and whether or not the item
 * is a file or directory. Also update the ppInfoBuf to point to the next
 * available entry to return for the next time this routine is called.
 *
 */
NTSTATUS
AfpGetNextDirectoryInfo(
	IN OUT	PFILE_DIRECTORY_INFORMATION	*ppInfoBuf,
	OUT		PWCHAR		*pNodeName,
	OUT		PULONG		pNodeNameLen,
	OUT		PBOOLEAN	pIsDir
)
{
	PFILE_DIRECTORY_INFORMATION		tempdirinfo;

	PAGED_CODE( );

	if (*ppInfoBuf == NULL)
	{
		return STATUS_NO_MORE_ENTRIES;
	}

	tempdirinfo = *ppInfoBuf;
	if (tempdirinfo->NextEntryOffset == 0)
	{
		*ppInfoBuf = NULL;
	}
	else
	{
		(PBYTE)*ppInfoBuf += tempdirinfo->NextEntryOffset;
	}

	*pIsDir = (tempdirinfo->FileAttributes & FILE_ATTRIBUTE_DIRECTORY) ?
																True : False;
	*pNodeNameLen = tempdirinfo->FileNameLength;
	*pNodeName = tempdirinfo->FileName;

	return STATUS_SUCCESS;
}

/***	afpNwtDeleteFileEntity
 *
 * Delete a file or directory opening it with the name relative to phRelative
 * handle.
 * NOTE: can we use NtDeleteFile here since we dont really care about
 * any security checking?  Then we wouldn't even have to open a handle,
 * although that routine opens one for DELETE_ON_CLOSE for us, then
 * closes it.
 */
LOCAL
NTSTATUS
afpNwtDeleteFileEntity(
	IN	PFILESYSHANDLE	phRelative,
	IN	PWCHAR			Name,
	IN	ULONG			Namelen,
	IN 	BOOLEAN			IsDir
)
{
	ULONG			OpenOptions;
	FILESYSHANDLE	hEntity;
	NTSTATUS		rc;
	UNICODE_STRING	uname;

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_INFO,
									("\nafpNwtDeleteFileEntity entered\n"));

	OpenOptions = IsDir ? FILEIO_OPEN_DIR : FILEIO_OPEN_FILE;

	AfpInitUnicodeStringWithNonNullTerm(&uname,(USHORT)Namelen,Name);
	rc = AfpIoOpen(phRelative,
				   AFP_STREAM_DATA,
				   OpenOptions,
				   &uname,
				   FILEIO_ACCESS_DELETE,
				   FILEIO_DENY_ALL,
				   False,
				   &hEntity);

	if (!NT_SUCCESS(rc))
	{
		return rc;
	}

	rc = AfpIoMarkFileForDelete(&hEntity, NULL, NULL, NULL);

	if (!NT_SUCCESS(rc))
	{
		// If the file is marked readonly, try clearing the RO attribute
		if (((rc == STATUS_ACCESS_DENIED) || (rc == STATUS_CANNOT_DELETE)) &&
			(NT_SUCCESS(AfpIoSetTimesnAttr(&hEntity,
										   NULL,
										   NULL,
										   0,
										   FILE_ATTRIBUTE_READONLY,
										   NULL,
										   NULL))))

		{
			rc = AfpIoMarkFileForDelete(&hEntity, NULL, NULL, NULL);
		}
		if (!NT_SUCCESS(rc))
		{
			DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_ERR,
			("\nafpNwtDeleteFileEntity: could not delete file/dir (rc=0x%lx)\n",rc));
			DBGBRK(DBG_LEVEL_ERR);
		}
	}
	// NOTE: if marking it for delete fails, at least we could try deleting
	// the afpId stream so that we wouldn't find it at some future point...

	AfpIoClose(&hEntity);

	return rc;
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\server\scavengr.c ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	scavengr.c

Abstract:

	This file implements the scavenger queue management interface.

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	25 Jun 1992		Initial Version

Notes:	Tab stop: 4
--*/

#define	_SCAVENGER_LOCALS
#define	FILENUM	FILE_SCAVENGR

#include <afp.h>
#include <scavengr.h>
#include <client.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, AfpScavengerInit)
#pragma alloc_text( PAGE, AfpScavengerDeInit)
#endif

/***	AfpScavengerInit
 *
 *	Initialize the scavenger system. This consists of a queue protected by a
 *	spin lock and timer coupled to a DPC. The scavenger accepts requests to
 *	schedule a worker after N units of time.
 */
NTSTATUS
AfpScavengerInit(
	VOID
)
{
	BOOLEAN			TimerStarted;
	LARGE_INTEGER	TimerValue;

	KeInitializeTimer(&afpScavengerTimer);
	INITIALIZE_SPIN_LOCK(&afpScavengerLock);
	KeInitializeDpc(&afpScavengerDpc, afpScavengerDpcRoutine, NULL);
	TimerValue.QuadPart = AFP_SCAVENGER_TIMER_TICK;
	TimerStarted = KeSetTimer(&afpScavengerTimer,
							  TimerValue,
							  &afpScavengerDpc);
	ASSERT(!TimerStarted);

	return STATUS_SUCCESS;
}


/***	AfpScavengerDeInit
 *
 *	De-Initialize the scavenger system. Just cancel the timer.
 */
VOID
AfpScavengerDeInit(
	VOID
)
{
	KeCancelTimer(&afpScavengerTimer);
}


/***	AfpScavengerEnqueue
 *
 *	Here is a thesis on the code that follows.
 *
 *	The scavenger events are maintained as a list which the scavenger thread
 *	looks at every timer tick. The list is maintained in such a way that only
 *	the head of the list needs to be updated every tick i.e. the entire list
 *	is never scanned. The way this is achieved is by keeping delta times
 *	relative to the previous entry.
 *
 *	Every timer tick, the relative time at the head of the list is decremented.
 *	When that goes to ZERO, the head of the list is unlinked and dispatched.
 *
 *	To give an example, we have the following events queued at time slots
 *	X			Schedule A after 10 ticks.
 *	X+3			Schedule B after 5  ticks.
 *	X+5			Schedule C after 4  ticks.
 *	X+8			Schedule D after 6  ticks.
 *
 *	So A will schedule at X+10, B at X+8 (X+3+5), C at X+9 (X+5+4) and
 *	D at X+14 (X+8+6).
 *
 *	The above example covers all the situations.
 *
 *	- NULL List.
 *	- Inserting at head of list.
 *	- Inserting in the middle of the list.
 *	- Appending to the list tail.
 *
 *	The list will look as follows.
 *
 *		    BEFORE                          AFTER
 *		    ------                          -----
 *
 *    X   Head -->|                          Head -> A(10) ->|
 *    A(10)
 *
 *    X+3 Head -> A(7) ->|           Head -> B(5) -> A(2) ->|
 *    B(5)
 *
 *    X+5 Head -> B(3) -> A(2) ->|   Head -> B(3) -> C(1) -> A(1) ->|
 *    C(4)
 *
 *    X+8 Head -> C(1) -> A(1) ->|   Head -> C(1) -> A(1) -> D(4) ->|
 *    D(6)
 *
 *	The granularity is one tick.
 *
 *	LOCKS_ASSUMED:	AfpScavengerLock (SPIN)
 */
VOID
afpScavengerEnqueue(
	IN	PSCAVENGERLIST	pListNew
)
{
	PSCAVENGERLIST		pList, *ppList;
	LONG				DeltaTime = pListNew->scvgr_AbsTime;

	// The DeltaTime is adjusted in every pass of the loop to reflect the
	// time after the previous entry that the new entry will schedule.
	for (ppList = &afpScavengerList;
		 (pList = *ppList) != NULL;
		 ppList = &pList->scvgr_Next)
	{
		if (DeltaTime <= pList->scvgr_RelDelta)
		{
			pList->scvgr_RelDelta -= DeltaTime;
			break;
		}
		DeltaTime -= pList->scvgr_RelDelta;
	}

	pListNew->scvgr_RelDelta = DeltaTime;
	pListNew->scvgr_Next = pList;
	*ppList = pListNew;
}


/***	AfpScavengerScheduleEvent
 *
 *	Insert an event in the scavenger event list. If the list is empty, then
 *	fire off a timer. The time is specified in ticks. Each tick is currently
 *	ONE SECOND. It may not be negative.
 *
 *	The granularity is one tick.
 */
NTSTATUS
AfpScavengerScheduleEvent(
	IN	SCAVENGER_ROUTINE	Worker,		// Routine to invoke when time expires
	IN	PVOID				pContext,	// Context to pass to the routine
	IN	LONG				DeltaTime,	// Schedule after this much time
	IN	BOOLEAN				fQueue		// If TRUE, then worker must be queued
)
{
	PSCAVENGERLIST	pList = NULL;
	KIRQL			OldIrql;
	NTSTATUS		Status = STATUS_SUCCESS;

	// Negative DeltaTime is invalid. ZERO is valid which implies immediate action
	ASSERT (DeltaTime >= 0);

	do
	{
		pList = (PSCAVENGERLIST)AfpAllocNonPagedMemory(sizeof(SCAVENGERLIST));
		if (pList == NULL)
		{
		    DBGPRINT(DBG_COMP_SCVGR, DBG_LEVEL_ERR,
			    ("AfpScavengerScheduleEvent: malloc Failed\n"));
			Status = STATUS_INSUFFICIENT_RESOURCES;
			break;
		}

		AfpInitializeWorkItem(&pList->scvgr_WorkItem,
							  afpScavengerWorker,
							  pList);
		pList->scvgr_Worker = Worker;
		pList->scvgr_Context = pContext;
		pList->scvgr_AbsTime = DeltaTime;
		pList->scvgr_fQueue = fQueue;

		if (DeltaTime == 0)
		{
			ASSERT (fQueue);
			AfpQueueWorkItem(&pList->scvgr_WorkItem);
			break;
		}

		if (!afpScavengerStopped)
		{
	        ACQUIRE_SPIN_LOCK(&afpScavengerLock, &OldIrql);

            //
            // due to an assumption made elsewhere, it's necessary to check
            // this again after holding the spinlock!
            //
            if (!afpScavengerStopped)
            {
			    afpScavengerEnqueue(pList);
			    RELEASE_SPIN_LOCK(&afpScavengerLock, OldIrql);
            }
            else
            {
			    DBGPRINT(DBG_COMP_SCVGR, DBG_LEVEL_ERR,
					("AfpScavengerScheduleEvent: Called after Flush !!\n"));

			    RELEASE_SPIN_LOCK(&afpScavengerLock, OldIrql);
		        AfpFreeMemory(pList);
                Status = STATUS_UNSUCCESSFUL;
            }
		}

	} while (False);

	return Status;
}



/***	AfpScavengerKillEvent
 *
 *	Kill an event that was previously scheduled.
 */
BOOLEAN
AfpScavengerKillEvent(
	IN	SCAVENGER_ROUTINE	Worker,		// Routine that was scheduled
	IN	PVOID				pContext	// Context
)
{
	PSCAVENGERLIST	pList, *ppList;
	KIRQL			OldIrql;

	ACQUIRE_SPIN_LOCK(&afpScavengerLock, &OldIrql);

	// The DeltaTime is adjusted in every pass of the loop to reflect the
	// time after the previous entry that the new entry will schedule.
	for (ppList = &afpScavengerList;
		 (pList = *ppList) != NULL;
		 ppList = &pList->scvgr_Next)
	{
		if ((pList->scvgr_Worker == Worker) &&
	        (pList->scvgr_Context == pContext))
		{
			*ppList = pList->scvgr_Next;
			if (pList->scvgr_Next != NULL)
			{
				pList->scvgr_Next->scvgr_RelDelta += pList->scvgr_RelDelta;
			}
			break;
		}
	}

	RELEASE_SPIN_LOCK(&afpScavengerLock, OldIrql);

	if (pList != NULL)
		AfpFreeMemory(pList);

	return (pList != NULL);
}


/***	afpScavengerDpcRoutine
 *
 *	This is called in at DISPATCH_LEVEL when the timer expires. The entry at
 *	the head of the list is decremented and if ZERO unlinked and queued to the
 *	worker. If the list is non-empty, the timer is fired again.
 */
LOCAL VOID
afpScavengerDpcRoutine(
	IN	PKDPC	pKDpc,
	IN	PVOID	pContext,
	IN	PVOID	SystemArgument1,
	IN	PVOID	SystemArgument2
)
{
	PSCAVENGERLIST	pList;
	AFPSTATUS		Status;
	BOOLEAN			TimerStarted;
	LARGE_INTEGER	TimerValue;
#ifdef	PROFILING
	TIME			TimeS, TimeE;
	DWORD			NumDispatched = 0;

	AfpGetPerfCounter(&TimeS);
#endif


    AfpSecondsSinceEpoch++;

	if (afpScavengerStopped)
	{
		DBGPRINT(DBG_COMP_SCVGR, DBG_LEVEL_ERR,
				("afpScavengerDpcRoutine: Entered after flush !!!\n"));
		return;
	}

	if (afpScavengerList != NULL)
	{
		ACQUIRE_SPIN_LOCK_AT_DPC(&afpScavengerLock);

		if (afpScavengerList->scvgr_RelDelta != 0)
			(afpScavengerList->scvgr_RelDelta)--;

		// We should never be here if we have no work to do
		while (afpScavengerList != NULL)
		{
			// Dispatch all entries that are ready to go
			if (afpScavengerList->scvgr_RelDelta == 0)
			{
				pList = afpScavengerList;
				afpScavengerList = pList->scvgr_Next;
				DBGPRINT(DBG_COMP_SCVGR, DBG_LEVEL_INFO,
						("afpScavengerDpcRoutine: Dispatching %lx\n",
						pList->scvgr_WorkItem.wi_Worker));

				// Release spin lock as the caller might call us back
				RELEASE_SPIN_LOCK_FROM_DPC(&afpScavengerLock);

				Status = AFP_ERR_QUEUE;
				if (!pList->scvgr_fQueue)
				{
					Status = (*pList->scvgr_Worker)(pList->scvgr_Context);
#ifdef	PROFILING
					NumDispatched++;
#endif
				}

				ACQUIRE_SPIN_LOCK_AT_DPC(&afpScavengerLock);

				if (Status == AFP_ERR_QUEUE)
				{
					DBGPRINT(DBG_COMP_SCVGR, DBG_LEVEL_INFO,
								("afpScavengerDpcRoutine: Queueing %lx\n",
								pList->scvgr_WorkItem.wi_Worker));
					AfpQueueWorkItem(&pList->scvgr_WorkItem);
				}
				else if (Status == AFP_ERR_REQUEUE)
				{
					afpScavengerEnqueue(pList);
				}
				else AfpFreeMemory(pList);
			}
			else break;
		}

		RELEASE_SPIN_LOCK_FROM_DPC(&afpScavengerLock);
	}

	TimerValue.QuadPart = AFP_SCAVENGER_TIMER_TICK;
	TimerStarted = KeSetTimer(&afpScavengerTimer,
							  TimerValue,
							  &afpScavengerDpc);
	ASSERT(!TimerStarted);

#ifdef	PROFILING
	AfpGetPerfCounter(&TimeE);
	ACQUIRE_SPIN_LOCK_AT_DPC(&AfpStatisticsLock);
	AfpServerProfile->perf_ScavengerCount += NumDispatched;
	AfpServerProfile->perf_ScavengerTime.QuadPart +=
									(TimeE.QuadPart - TimeS.QuadPart);
	RELEASE_SPIN_LOCK_FROM_DPC(&AfpStatisticsLock);
#endif
}


/***	AfpScavengerFlushAndStop
 *
 *	Force all entries in the scavenger queue to be dispatched immediately. No
 *	more queue'ing of scavenger routines is permitted after this. The scavenger
 *	essentially shuts down. Callable only in the worker context.
 */
VOID
AfpScavengerFlushAndStop(
	VOID
)
{
	PSCAVENGERLIST	pList;
	KIRQL			OldIrql;

	ASSERT (KeGetCurrentIrql() < DISPATCH_LEVEL);

	DBGPRINT(DBG_COMP_SCVGR, DBG_LEVEL_INFO,
						("afpScavengerFlushAndStop: Entered\n"));

	ASSERT (KeGetCurrentIrql() < DISPATCH_LEVEL);

	ACQUIRE_SPIN_LOCK(&afpScavengerLock, &OldIrql);

	afpScavengerStopped = True;

	KeCancelTimer(&afpScavengerTimer);

	if (afpScavengerList != NULL)
	{
		// Dispatch all entries right away
		while (afpScavengerList != NULL)
		{
			AFPSTATUS	Status;

			pList = afpScavengerList;
			afpScavengerList = pList->scvgr_Next;

			// Call the worker with spin-lock held since they expect to be
			// called at DPC. We are safe since if the worker tries to
			// call AfpScavengerScheduleEvent(), we'll not try to re-acquire
			// the lock as afpScavengerStopped is True.
			DBGPRINT(DBG_COMP_SCVGR, DBG_LEVEL_INFO,
						("afpScavengerFlushAndStop: Dispatching %lx\n",
						pList->scvgr_WorkItem.wi_Worker));

			if (!(pList->scvgr_fQueue))
				Status = (*pList->scvgr_Worker)(pList->scvgr_Context);

			if (pList->scvgr_fQueue ||
				(Status == AFP_ERR_QUEUE))
			{
				// Well do it the hard way, if the worker insists on working
				// at non DISPACTH level.
				RELEASE_SPIN_LOCK(&afpScavengerLock, OldIrql);
				(*pList->scvgr_Worker)(pList->scvgr_Context);
				ACQUIRE_SPIN_LOCK(&afpScavengerLock, &OldIrql);
			}
			AfpFreeMemory(pList);
		}
	}
	RELEASE_SPIN_LOCK(&afpScavengerLock, OldIrql);
}


/***	AfpScavengerWorker
 *
 *	This gets invoked when the scavenger Dpc queues up the routine.
 */
LOCAL VOID FASTCALL
afpScavengerWorker(
	IN	PSCAVENGERLIST	pList
)
{
	AFPSTATUS		Status;
	KIRQL			OldIrql;
#ifdef	PROFILING
	TIME			TimeS, TimeE;

	AfpGetPerfCounter(&TimeS);
#endif

	ASSERT (KeGetCurrentIrql() < DISPATCH_LEVEL);

	// Call the worker routine
	Status = (*pList->scvgr_Worker)(pList->scvgr_Context);

	ASSERT (Status != AFP_ERR_QUEUE);

#ifdef	PROFILING
	AfpGetPerfCounter(&TimeE);
	ACQUIRE_SPIN_LOCK(&AfpStatisticsLock, &OldIrql);
	AfpServerProfile->perf_ScavengerCount++;
	AfpServerProfile->perf_ScavengerTime.QuadPart +=
									(TimeE.QuadPart - TimeS.QuadPart);
	RELEASE_SPIN_LOCK(&AfpStatisticsLock, OldIrql);
#endif

	if (Status == AFP_ERR_REQUEUE)
	{
		ACQUIRE_SPIN_LOCK(&afpScavengerLock, &OldIrql);
		afpScavengerEnqueue(pList);
		RELEASE_SPIN_LOCK(&afpScavengerLock, OldIrql);
	}
	else
	{
		ASSERT (NT_SUCCESS(Status));
		AfpFreeMemory(pList);
	}
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\server\nwtrash.h ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	nwtrash.h

Abstract:

	This file defines the file network trash folder routine prototypes

Author:

	Sue Adams (microsoft!suea)


Revision History:
	13 Aug 1992		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef	_NWTRASH_
#define	_NWTRASH_

//
//	NtOpenFile/NtCreateFile values for the network trash folder
//

#define	AFP_NWT_ACCESS		FILEIO_ACCESS_DELETE
#define AFP_NWT_SHAREMODE	FILE_SHARE_READ | FILE_SHARE_WRITE
#define AFP_NWT_OPTIONS		FILEIO_OPEN_DIR
#define AFP_NWT_ATTRIBS		FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_HIDDEN
#define AFP_NWT_DISPOSITION	FILEIO_CREATE_SOFT

typedef struct _WalkDirNode {
	BOOLEAN				wdn_Enumerated;
	FILESYSHANDLE		wdn_Handle;
	UNICODE_STRING		wdn_RelativePath;
	struct _WalkDirNode *wdn_Next;
} WALKDIR_NODE, *PWALKDIR_NODE;

typedef NTSTATUS (*WALKDIR_WORKER)(PFILESYSHANDLE phRelative, PWCHAR Name, ULONG Namelen, BOOLEAN IsDir);


extern
NTSTATUS
AfpCreateNetworkTrash(
	IN	PVOLDESC	pVolDesc
);

extern
NTSTATUS
AfpDeleteNetworkTrash(
	IN	PVOLDESC	pVolDesc,
	IN	BOOLEAN		VolumeStart
);

extern
NTSTATUS
AfpWalkDirectoryTree(
	IN	PFILESYSHANDLE	phTargetDir,
	IN	WALKDIR_WORKER	NodeWorker
);

extern
NTSTATUS
AfpGetNextDirectoryInfo(
	IN OUT	PFILE_DIRECTORY_INFORMATION	* ppInfoBuf,
	OUT		PWCHAR		*	pNodeName,
	OUT		PULONG			pNodeNameLen,
	OUT		PBOOLEAN		pIsDir
);

#ifdef	NWTRASH_LOCALS

LOCAL
NTSTATUS
afpCleanNetworkTrash(
	IN	PVOLDESC			pVolDesc,
	IN	PFILESYSHANDLE		phNWT,
	IN	PDFENTRY			pDfeNWT OPTIONAL
);

LOCAL
NTSTATUS
afpPushDirNode(
	IN OUT	PWALKDIR_NODE *	ppStackTop,
	IN		PUNICODE_STRING pParentPath,	// path to parent (NULL iff walk target)
	IN		PUNICODE_STRING	pDirName		// name of current directory node
);

LOCAL
VOID
afpPopDirNode(
	IN OUT	PWALKDIR_NODE *	ppStackTop
);

LOCAL
NTSTATUS
afpNwtDeleteFileEntity(
	IN	PFILESYSHANDLE	phRelative,
	IN	PWCHAR			Name,
	IN	ULONG			Namelen,
	IN 	BOOLEAN			IsDir
);

#endif	// NWTRASH_LOCALS

#endif 	// _NWTRASH_


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\server\pathmap.h ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	pathmap.c

Abstract:

	This module contains definitions relating to manipulation of AFP paths.

Author:

	Sue Adams	(microsoft!suea)


Revision History:
	04 Jun 1992		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef	_PATHMAP_
#define _PATHMAP_

#define UNICODE_HOST_PATHSEPZ	L"\\"	// a null terminated wide string
#define ANSI_HOST_PATHSEP		'\\'
#define AFP_PATHSEP				0
#define UNICODE_AFP_PATHSEP		UNICODE_NULL
#define AVERAGE_NODE_DEPTH		16

// describes the entity found by pathmapping routines
typedef struct _PathMapEntity
{
	// Handle is returned for LOOKUPS ONLY!
	FILESYSHANDLE		pme_Handle;	// Handle to DATA Stream, returned for lookups

	// Full, UTail and ParentPath are returned whenever the following bitmap
	//
	//		FD_INTERNAL_BITMAP_RETURN_PMEPATHS
	// is specified in the AfpMapAfpPath call. These are mostly for Create and
	// for lookups ONLY for apis that MAKE DISK CHANGES which will produce a
	// change notification to come in. Caller must free the FullPath.Buffer.
	// All other strings point into this buffer and do not need to be freed.
	// Also used by Open to get the path of the file being opened.
	UNICODE_STRING	pme_FullPath;	// Fully qualified relative to volume root
	UNICODE_STRING	pme_UTail;		// Points to last component of Full
	UNICODE_STRING	pme_ParentPath;	// Points to Full w/ length of UTail deleted

	// pme_pDfeParent is used for Create and points to the parent directory.
	// pme_pDfEntry is used for lookup (mainly for delete case) and points to the entity.
	union
	{
		PDFENTRY	pme_pDfeParent; // DFE of parent dir in which to create
		PDFENTRY	pme_pDfEntry;	// DFE of of the entity for Lookup
	};
} PATHMAPENTITY, *PPATHMAPENTITY;

#define	AfpInitializePME(pPME, FullPathLen, FullPathBuffer)			\
				(pPME)->pme_FullPath.Buffer = FullPathBuffer;		\
                (pPME)->pme_FullPath.MaximumLength = FullPathLen;	\
                (pPME)->pme_Handle.fsh_FileHandle = NULL

//
// Values for path mapping DFFlag parameter;
// DFE_DIR/FILE/ANY tell the pathmapping code what type of entity we are
// trying to lookup/create
//
#define	DFE_DIR					0x0001	// Specified if the object should be a dir
#define	DFE_FILE				0x0002	// Specified if the object should be a file
#define	DFE_ANY					0x0004	// Specified if the object can be either

//
// Values for reason of pathmap: Lookup, SoftCreate or HardCreate
//
typedef enum _PATHMAP_TYPE
{
	Lookup,
	SoftCreate,
	HardCreate,
	LookupForEnumerate		// Same as Lookup but file children will be cached
							// in during pathmap of the directory itself.
} PATHMAP_TYPE;

extern
AFPSTATUS
AfpMapAfpPath(
	IN		PCONNDESC			pConnDesc,
	IN		DWORD				DirId,
	IN		PANSI_STRING		Path,
	IN		BYTE				PathType,			
	IN		PATHMAP_TYPE		MapReason,
	IN		DWORD				DFFlag,
	IN		DWORD				Bitmap,
	OUT		PPATHMAPENTITY		pPME,
	OUT		PFILEDIRPARM		pFDParm OPTIONAL	// for lookups only
);

extern
AFPSTATUS
AfpMapAfpPathForLookup(
	IN		PCONNDESC			pConnDesc,
	IN		DWORD				DirId,
	IN		PANSI_STRING		Path,
	IN		BYTE				PathType,	
	IN		DWORD				DFFlag,
	IN		DWORD				Bitmap,
	OUT		PPATHMAPENTITY		pPME OPTIONAL,		
	OUT		PFILEDIRPARM		pFDParm OPTIONAL
);

extern
AFPSTATUS
AfpMapAfpIdForLookup(
	IN		PCONNDESC			pConnDesc,
	IN		DWORD				AfpId,
	IN		DWORD				DFFlag,
	IN		DWORD				Bitmap,
	OUT		PPATHMAPENTITY		pPME OPTIONAL,	
	OUT		PFILEDIRPARM		pFDParm OPTIONAL
);

extern
AFPSTATUS
AfpHostPathFromDFEntry(
	IN		PDFENTRY			pDFE,
	IN		DWORD				taillen,
	OUT		PUNICODE_STRING		pPath

);


extern
AFPSTATUS
AfpCheckParentPermissions(
	IN	PCONNDESC				pConnDesc,
	IN	DWORD					ParentDirId,
	IN	PUNICODE_STRING			pParentPath,
	IN	DWORD					RequiredPerms,
	OUT	PFILESYSHANDLE			pHandle OPTIONAL,
	OUT	PBYTE					pUserRights OPTIONAL
);

#ifdef	_PATHMAP_LOCALS

// An AFP path to an entity consists of a Dirid and pathname.  A MAPPEDPATH
// structure resolves the AFP path into a PDFENTRY for the entity on lookups,
// or to a PDFENTRY of the parent directory plus the UNICODE file/dir name
// of the entity on creates.
typedef struct _MappedPath
{
	PDFENTRY		mp_pdfe;
	UNICODE_STRING	mp_Tail;						// valid for Create only
	WCHAR			mp_Tailbuf[AFP_FILENAME_LEN+1]; // for mp_tail.Buffer
// mp_Tail is also used as an interim buffer during pathmap for looking up
// by name in the idindex database.
} MAPPEDPATH, *PMAPPEDPATH;

/* private function prototypes */

LOCAL
AFPSTATUS
afpGetMappedForLookupFDInfo(
	IN	PCONNDESC				pConnDesc,
	IN	PDFENTRY				pDfEntry,
	IN	DWORD					Bitmap,
	OUT	PPATHMAPENTITY			pPME OPTIONAL,
	OUT	PFILEDIRPARM			pFDParm	OPTIONAL
);

/***	afpGetNextComponent
 *
 *	Takes an AFP path with leading and trailing nulls removed,
 *	and parses out the next path component.
 *
 *	pComponent must point to a buffer of at least AFP_LONGNAME_LEN+1
 *	characters in length if pathtype is AFP_LONGNAME or AFP_SHORTNAME_LEN+1
 *	if pathtype is AFP_SHORTNAME.
 *
 *	Returns the number of bytes (Mac ANSI characters) parsed off of
 *	pPath, else -1 for error.
LOCAL VOID
afpGetNextComponent(
	IN	PCHAR					pPath,
	IN	int						Length,
	IN	BYTE					PathType,
	OUT	PCHAR					Component,
	OUT	PINT					pIndex
	)
 */
#define	afpGetNextComponent(_pPath, _Length, _PathType, _Component, _pIndex)	\
	do																			\
	{                                                                           \
		int			Length = _Length;                                           \
		PCHAR		pPath = _pPath;                                             \
		int			maxlen;                                                     \
		CHAR		ch;                                                         \
	                                                                            \
		maxlen = (_PathType == AFP_LONGNAME) ?                                  \
						AFP_LONGNAME_LEN :                                      \
						AFP_SHORTNAME_LEN;                                      \
		*(_pIndex) = 0;                                                         \
                                                                                \
		while ((Length > 0) && ((ch = *pPath) != '\0'))                         \
		{                                                                       \
			if ((*(_pIndex) == maxlen) || (ch == ':'))                          \
			{                                                                   \
	            /* component too long or invalid char */                        \
				*(_pIndex) = -1;                                                \
				break;                                                          \
			}                                                                   \
	                                                                            \
			(_Component)[(*(_pIndex))++] = ch;                                  \
	                                                                            \
			pPath++;                                                            \
			Length--;                                                           \
		}                                                                       \
                                                                                \
		if (*(_pIndex) == -1)                                                   \
			break;                                                              \
	                                                                            \
		/* null terminate the component */                                      \
		(_Component)[*(_pIndex)] = (CHAR)0;                                     \
	                                                                            \
		if ((PathType == AFP_SHORTNAME) && ((_Component)[0] != AFP_PATHSEP))    \
		{                                                                       \
			ANSI_STRING	as;                                                     \
	                                                                            \
			AfpInitUnicodeStringWithNonNullTerm(&as, *(_pIndex), _Component);   \
			if (!AfpIsLegalShortname(&as))                                      \
			{                                                                   \
				*(_pIndex) = -1;                                                \
				break;                                                          \
			}                                                                   \
		}                                                                       \
	                                                                            \
		/* if we stopped due to null, move past it */                           \
		if (Length > 0)                                                         \
		{                                                                       \
			(*(_pIndex))++;                                                     \
		}																		\
	} while (FALSE);


LOCAL
AFPSTATUS
afpMapAfpPathToMappedPath(
	IN		PVOLDESC			pVolDesc,
	IN		DWORD				DirId,
	IN		PANSI_STRING		Path,
	IN		BYTE				PathType,
	IN		PATHMAP_TYPE		MapReason,
	IN 		DWORD				DFflag,
	IN		BOOLEAN				LockedForWrite,
	OUT		PMAPPEDPATH			pMappedPath

);

LOCAL
AFPSTATUS
afpOpenUserHandle(
	IN	PCONNDESC				pConnDesc,
	IN	struct _DirFileEntry *	pDfEntry,
	IN	PUNICODE_STRING			pPath		OPTIONAL,
	IN	DWORD					Bitmap,
	OUT	PFILESYSHANDLE			pfshData	 // Handle of data stream of object
);

#endif	// _PATHMAP_LOCALS

#endif	// _PATHMAP_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\server\scavengr.h ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	scavengr.h

Abstract:

	This file defines the scavenger thread interface.

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	25 Jun 1992		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef	_SCAVENGER_
#define	_SCAVENGER_

typedef	AFPSTATUS	(FASTCALL *SCAVENGER_ROUTINE)(IN PVOID Parameter);

extern
NTSTATUS
AfpScavengerInit(
	VOID
);

extern
VOID
AfpScavengerDeInit(
	VOID
);

extern
NTSTATUS
AfpScavengerScheduleEvent(
	IN	SCAVENGER_ROUTINE	Worker,		// Routine to invoke when time expires
	IN	PVOID				pContext,	// Context to pass to the routine
	IN	LONG				DeltaTime,	// Schedule after this much time
	IN	BOOLEAN				fQueue		// If TRUE, then worker must be queued
);

extern
BOOLEAN
AfpScavengerKillEvent(
	IN	SCAVENGER_ROUTINE	Worker,		// Routine that was scheduled
	IN	PVOID				pContext	// Context
);

extern
VOID
AfpScavengerFlushAndStop(
	VOID
);

#ifdef	_SCAVENGER_LOCALS

// Keep this at a ONE second level. Most clients should be using close to
// 10 ticks or so.
#define	AFP_SCAVENGER_TIMER_TICK	-1*NUM_100ns_PER_SECOND

typedef	struct _ScavengerList
{
	struct _ScavengerList *	scvgr_Next;		// Link to next
	LONG					scvgr_AbsTime;	// Absolute time
	LONG					scvgr_RelDelta;	// Relative to the previous entry
	BOOLEAN					scvgr_fQueue;	// If TRUE, should always be queued
	SCAVENGER_ROUTINE		scvgr_Worker;	// Real Worker
	PVOID					scvgr_Context;	// Real context
	WORK_ITEM				scvgr_WorkItem;	// Used for queueing to worker thread
} SCAVENGERLIST, *PSCAVENGERLIST;

LOCAL	KTIMER				afpScavengerTimer = { 0 };
LOCAL	KDPC				afpScavengerDpc = { 0 };
LOCAL	BOOLEAN				afpScavengerStopped = False;
LOCAL	PSCAVENGERLIST		afpScavengerList = NULL;
LOCAL	AFP_SPIN_LOCK			afpScavengerLock = { 0 };

LOCAL VOID
afpScavengerDpcRoutine(
	IN	PKDPC				pKDpc,
	IN	PVOID				pContext,
	IN	PVOID				SystemArgument1,
	IN	PVOID				SystemArgument2
);

LOCAL VOID FASTCALL
afpScavengerWorker(
	IN	PSCAVENGERLIST		pList
);

#endif	// _SCAVENGER_LOCALS

#endif	// _SCAVENGER_


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\server\sda.h ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

    sda.h

Abstract:

    This module contains session data area and related data structures.

Author:

    Jameel Hyder (microsoft!jameelh)


Revision History:
    25 Apr 1992     Initial Version

Notes:  Tab stop: 4
--*/

#ifndef _SDA_
#define _SDA_

// sda_Flags values
#define SDA_USER_NOT_LOGGEDIN   0x0000  //
#define SDA_USER_LOGIN_PARTIAL  0x0001  // Encrypted logon is half-way done
#define SDA_USER_LOGGEDIN       0x0002
#define SDA_LOGIN_MASK          0x0003

#define SDA_REQUEST_IN_PROCESS  0x0004  // A request is being processed
#define SDA_REPLY_IN_PROCESS    0x0008  // A reply has been posted
#define SDA_NAMEXSPACE_IN_USE   0x0010  // NameXSpace is in use by reply processing

#define SDA_DEREF_VOLUME        0x0020  // Dereference volume before reply
#define SDA_DEREF_OFORK         0x0040  // Dereference open-fork before reply
#define SDA_LOGIN_FAILED        0x0080  // Funky stuff for AFP 2.1 Chooser
#define SDA_CLIENT_CLOSE        0x0100  // Set if the close if hapenning from the client side
#define SDA_QUEUE_IF_DPC        0x0200  // Copied from the dispatch table (see afpapi.c)
#define SDA_SESSION_CLOSED      0x0400  // If set, do not close session in deref.
#define SDA_SESSION_CLOSE_COMP  0x0800  // If set, close completion called for this session
#define SDA_SESSION_OVER_TCP    0x1000  // this is an AFP/TCP session
#define SDA_SESSION_NOTIFY_SENT 0x2000  // Server Notification sent to this sda
#define SDA_GUEST_LOGIN         0x4000  // User has logged-in using guest button
#define SDA_CLOSING             0x8000  // Session is marked to die

// sda_ClientType values
#define SDA_CLIENT_GUEST        NO_USER_AUTHENT
#define SDA_CLIENT_CLEARTEXT    CLEAR_TEXT_AUTHENT
#define SDA_CLIENT_MSUAM_V1     CUSTOM_UAM_V1
#define SDA_CLIENT_MSUAM_V2     CUSTOM_UAM_V2
#define SDA_CLIENT_MSUAM_V3     CUSTOM_UAM_V3
#define SDA_CLIENT_RANDNUM      RANDNUM_EXCHANGE
#define SDA_CLIENT_TWOWAY       TWOWAY_EXCHANGE
#define SDA_CLIENT_ADMIN        AFP_NUM_UAMS

#define MAX_REQ_ENTRIES         7
#define MAX_REQ_ENTRIES_PLUS_1  8       // used to allocate space 1 DWORD more
                                        // than required. The first entry is
                                        // used to store pointer to VolDesc
                                        // or ConnDesc. The extra DWORD is used
                                        // to accomodate 64-bit pointer if we
                                        // have one
#define MAX_VAR_ENTRIES         3

#define SESSION_CHECK_TIME      60      // In seconds
#define SESSION_WARN_TIME       SESSION_CHECK_TIME * 10
#define SESSION_KILL_TIME       SESSION_CHECK_TIME 

// SDA_SIZE is the total size allocated to the SDA pointer
// This includes sizeof(SDA) plus additional buffer allocated for
// copying strings into. This extra space is allocated after the
// first sizeof(SDA) bytes. The size is purely a ball-park figure
// The original design does not mention why the total space was 384
// Currently we are doubling the space to accomodate 64-bit stuff
#ifdef _WIN64
#define SDA_SIZE                (((768 - POOL_OVERHEAD)+7) & 0xfffffff8)
#else
#define SDA_SIZE                (((450 - POOL_OVERHEAD)+7) & 0xfffffff8)
#endif

// Linked list of deferred request packets. If the session is already
// processing a request, then subsequent requests are queued. These
// are always handled in a FIFO order.
typedef struct _DeferredRequestQueue
{
    LIST_ENTRY  drq_Link;
    PREQUEST    drq_pRequest;
} DFRDREQQ, *PDFRDREQQ;

/*
 * This is the per-session data area. This is allocated whenever a listen is
 * posted. At that point it is in the outstanding session list. When the listen
 * is completed, it moves to the active session list.
 */
#if DBG
#define SDA_SIGNATURE       *(DWORD *)"SDA"
#define VALID_SDA(pSda)     (((pSda) != NULL) && \
                             ((pSda)->Signature == SDA_SIGNATURE))
#else
#define VALID_SDA(pSda)     ((pSda) != NULL)
#endif

typedef struct _SessDataArea
{
#if DBG
    DWORD           Signature;
#endif
    struct _SessDataArea * sda_Next;    // link to next session in session list
    AFP_SPIN_LOCK       sda_Lock;           // Lock for manipulating certain SDA
                                        // fields
    DWORD           sda_Flags;          // Bit mask of the SDA states
    LONG            sda_RefCount;       // Count of references to this SDA
    PASP_XPORT_ENTRIES  sda_XportTable; // pointer to ASP's or DSI's entry points
    DWORD           sda_MaxWriteSize;   // 64000 for TCP/IP, 4624 for Appletalk
    PVOID           sda_SessHandle;     // Asp Session handle
    PREQUEST        sda_Request;        // Current request
    HANDLE          sda_UserToken;      // Logon token for this user.
    PSID            sda_UserSid;        // SID representing owner
    PSID            sda_GroupSid;       // SID representing primary group
    PTOKEN_GROUPS   sda_pGroups;        // List of groups this user is member of
#ifdef  INHERIT_DIRECTORY_PERMS
    DWORD           sda_UID;            // User Id corres. to sda_UserSid
    DWORD           sda_GID;            // Group Id corres. to sda_GroupSid
#else
    PISECURITY_DESCRIPTOR sda_pSecDesc; // Security descriptor used by directory
                                        // Creation API
    DWORD           sda_Dummy;          // For alignment
#endif
    PANSI_STRING    sda_Message;        // The actual message in macintosh ansi
                                        // The above field is used only for
                                        // client specific message. Broadcast
                                        // messages are stored in a global area
    UNICODE_STRING  sda_WSName;         // Workstation name of logged in user
    UNICODE_STRING  sda_UserName;       // User name
    UNICODE_STRING  sda_DomainName;     // DomainName for Login/ChgPwd

#ifdef  PROFILING
    TIME            sda_ApiStartTime;   // Time stamp when Api req. was recvd.
    TIME            sda_QueueTime;      // Time spent waiting for worker thread
#endif

    DWORD           sda_SessionId;      // Session Id for use by admin APIs
    AFPTIME         sda_TimeLoggedOn;   // Time when session established
                                        // in macintosh time
    DWORD           sda_tTillKickOff;   // # of seconds before this session will
                                        // be kicked off
    struct _ConnDesc *  sda_pConnDesc;  // List of connections by this session
    struct _OpenForkSession sda_OpenForkSess;
                                        // List of open files by this session
    LONG            sda_cOpenVolumes;   // Number of volumes mounted (admin api)
    LONG            sda_cOpenForks;     // Number of forks opened    (admin api)
    DWORD           sda_MaxOForkRefNum; // High-water mark of the fork-ref num assigned

    BYTE            sda_AfpFunc;        // AFP API in execution for FSP
    BYTE            sda_AfpSubFunc;     // Sub function code used by some APIs
    BYTE            sda_ClientVersion;  // AFP Version of the client s/w
                                        // AFP_VER_20
                                        // AFP_VER_21
    BYTE            sda_ClientType;     // One of SDA_CLIENT_XXXX
    BYTE            sda_PathType;       // For all path based calls
    USHORT          sda_SizeNameXSpace; // Constant, initialized once
    USHORT          sda_ReplySize;      // Size of the reply buffer

#define     sda_ReadStatus  sda_SecUtilResult
    NTSTATUS        sda_SecUtilResult;  // Result of scurity utitility call
    PSID            sda_SecUtilSid;     // Name to Sid translation. Should be
                                        // freed if non-null.
    // The incoming packet is copied here. The parameters from the RequestBuf
    // are un-marshalled into this. Each API structures this differently. Make
    // sure sda_Name and sda_ReqBlock are together and next to each other AND
    // in this order. The code in afpapi.c depends on this while clearing this.
    // The extra DWORD is used in cases where the first entry is reused to
    // stored pointer values. On 64-bit architecture we require 2 DWORD at
    // the start of the ReqBlock.
    DWORD           sda_ReqBlock[MAX_REQ_ENTRIES_PLUS_1];
    ANSI_STRING     sda_Name[MAX_VAR_ENTRIES];

#define sda_Name1   sda_Name[0]
#define sda_Name2   sda_Name[1]
#define sda_Name3   sda_Name[2]

#define sda_IOBuf   sda_ReplyBuf
#define sda_IOSize  sda_ReplySize

    PBYTE           sda_ReplyBuf;       // Reply Buffer (variable size)

    AFPAPIWORKER    sda_WorkerRoutine;  // Api Worker
    WORK_ITEM       sda_WorkItem;       // For queueing up to worker threads

    PBYTE           sda_Challenge;      // Challenge from MSV1_0

    LIST_ENTRY      sda_DeferredQueue;  // Queue of deferred requests
    PBYTE           sda_NameBuf;        // Space is allocated for variable
                                        // part of request buffer here.
    PBYTE           sda_NameXSpace;
} SDA, *PSDA;

GLOBAL  AFP_SPIN_LOCK       AfpSdaLock EQU {0};// Lock for session list
GLOBAL  PSDA            AfpSessionList EQU NULL;
                                        // Linked-List of sessions

// These values are subject to tuning.
GLOBAL  LONG            AfpNumSessions EQU 0;
GLOBAL  UNICODE_STRING  AfpDefaultWksta EQU {0, 0, NULL};

extern
NTSTATUS
AfpSdaInit(
    VOID
);

extern
VOID
AfpSdaDeInit(
    VOID
);

extern
PSDA FASTCALL
AfpSdaCreateNewSession(
    IN  PVOID   SessionHandle,
    IN  BOOLEAN fOverTcp
);

extern
VOID FASTCALL
afpQueueDeferredRequest(
    IN  PSDA        pSda,
    IN  PREQUEST    pRequest
);

extern
PSDA FASTCALL
AfpSdaReferenceSessionById(
    IN  DWORD               SessId
);

extern
PSDA FASTCALL
AfpSdaReferenceSessionByPointer(
    IN  PSDA                pSda
);

extern
VOID FASTCALL
AfpSdaDereferenceSession(
    IN  PSDA                pSda
);

extern
AFPSTATUS FASTCALL
AfpSdaCloseSession(
    IN  PSDA                pSda
);

extern
AFPSTATUS
AfpAdmWSessionClose(
    IN  OUT PVOID           Inbuf   OPTIONAL,
    IN  LONG                OutBufLen OPTIONAL,
    OUT PVOID               Outbuf OPTIONAL
);

extern
AFPSTATUS FASTCALL
AfpSdaCheckSession(
    IN  PVOID               pContext
);

extern
VOID FASTCALL
AfpKillSessionsOverProtocol(
    IN  BOOLEAN     fAppletalkSessions
);

extern
VOID FASTCALL
afpUpdateDiskQuotaInfo(
    IN struct _ConnDesc *  pConnDesc
);

#ifdef  _SDA_LOCALS

LOCAL   DWORD       afpNextSessionId = 1;

LOCAL AFPSTATUS FASTCALL
afpCloseSessionAndFreeSda(
    IN  PSDA                pSda
);

#endif  // _SDA_LOCALS

#endif  // _SDA_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\server\sda.c ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	sda.c

Abstract:

	This module contains the session data area manipulation routines.

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	25 Apr 1992		Initial Version

Notes:	Tab stop: 4

--*/

#define	_SDA_LOCALS
#define	FILENUM	FILE_SDA

#include <afp.h>
#include <scavengr.h>
#include <access.h>
#include <client.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, AfpSdaInit)
#pragma alloc_text( PAGE, afpCloseSessionAndFreeSda)
#pragma alloc_text( PAGE, AfpSdaCheckSession)
#endif

/***	AfpSdaInit
 *
 *	Initialize Sda Data structures. Called at init time.
 */
NTSTATUS
AfpSdaInit(
	VOID
)
{
	ASSERT(sizeof(SDA) <= 512);
	INITIALIZE_SPIN_LOCK(&AfpSdaLock);

	return STATUS_SUCCESS;
}


/***	AfpSdaReferenceSessionById
 *
 *	Reference a session by its id. The SDA cannot be referenced if it is
 *	marked closed. The SDA should be referenced before using it.
 *
 *	LOCKS:		AfpSdaLock (SPIN), sda_Lock (SPIN)
 *	LOCK_ORDER:	sda_Lock after AfpSdaLock
 */
PSDA FASTCALL
AfpSdaReferenceSessionById(
	IN DWORD	SessId
)
{
	PSDA	pSda=NULL;
    PSDA    pRetSda=NULL;
	KIRQL	OldIrql;

	ACQUIRE_SPIN_LOCK(&AfpSdaLock, &OldIrql);

	for (pSda = AfpSessionList;
		 (pSda != NULL) && (pSda->sda_SessionId >= SessId);
		 pSda = pSda->sda_Next)
	{
		if (pSda->sda_SessionId == SessId)
		{
			ACQUIRE_SPIN_LOCK_AT_DPC(&pSda->sda_Lock);

            if ((pSda->sda_Flags & SDA_CLOSING) == 0)
            {
			    ASSERT((pSda->sda_RefCount > 0) &&
				   (pSda->sda_SessionId != 0));

			    pSda->sda_RefCount ++;
                pRetSda = pSda;

			    DBGPRINT(DBG_COMP_SDA, DBG_LEVEL_INFO,
				    ("AfpSdaReferenceSessionById: New Count %d\n", pSda->sda_RefCount));
            }

			RELEASE_SPIN_LOCK_FROM_DPC(&pSda->sda_Lock);
			break;
		}
	}

	RELEASE_SPIN_LOCK(&AfpSdaLock, OldIrql);

	return pRetSda;
}


/***	AfpSdaReferenceSessionByPointer
 *
 *	Reference a session by pointer. The SDA cannot be referenced if it is
 *	marked closed. The SDA should be referenced before using it.
 *
 */
PSDA FASTCALL
AfpSdaReferenceSessionByPointer(
	IN PSDA     pSda
)
{
    PSDA    pRetSda=NULL;
	KIRQL	OldIrql;


    ASSERT(VALID_SDA(pSda));

	ACQUIRE_SPIN_LOCK(&pSda->sda_Lock, &OldIrql);

    if ((pSda->sda_Flags & SDA_CLOSING) == 0)
    {
	    pSda->sda_RefCount ++;
        pRetSda = pSda;
    }

	RELEASE_SPIN_LOCK(&pSda->sda_Lock, OldIrql);

	return pRetSda;
}



/***	afpSdaCloseSessionAndFreeSda
 *
 *	Run by the scavenger in the worker context. This is initiated as part of
 *	session cleanup.
 */
LOCAL AFPSTATUS FASTCALL
afpCloseSessionAndFreeSda(
	IN	PSDA	pSda
)
{
	POPENFORKSESS	    pOpenForkSess;
    PASP_XPORT_ENTRIES  XportTable;


	DBGPRINT(DBG_COMP_SDA, DBG_LEVEL_INFO,
			("afpCloseSessionAndFreeSda: Cleaning up session %lx\n",
			pSda->sda_SessionId));

	PAGED_CODE( );

#ifdef	OPTIMIZE_GUEST_LOGONS
	if (pSda->sda_ClientType != SDA_CLIENT_GUEST)
	{
#endif
#ifndef	INHERIT_DIRECTORY_PERMS
		// First free up paged memory used by the sda
		if (pSda->sda_pSecDesc != NULL)
		{
			if (pSda->sda_pSecDesc->Dacl != NULL)
				AfpFreeMemory(pSda->sda_pSecDesc->Dacl);
			AfpFreeMemory(pSda->sda_pSecDesc);
		}
#endif
		if ((pSda->sda_UserSid != NULL) && (pSda->sda_UserSid != &AfpSidWorld))
			AfpFreeMemory(pSda->sda_UserSid);

		if ((pSda->sda_GroupSid != NULL) && (pSda->sda_GroupSid != &AfpSidWorld))
			AfpFreeMemory(pSda->sda_GroupSid);

		if (pSda->sda_pGroups != NULL)
			AfpFreeMemory(pSda->sda_pGroups);
#ifdef	OPTIMIZE_GUEST_LOGONS
	}
#endif

	// Free any chains of fork entries that we created
	pOpenForkSess = pSda->sda_OpenForkSess.ofs_Link;
	while (pOpenForkSess != NULL)
	{
		POPENFORKSESS	pFree;

		pFree = pOpenForkSess;
		pOpenForkSess = pOpenForkSess->ofs_Link;
		AfpFreeMemory(pFree);
	}

	// Next log-out the user
	DBGPRINT(DBG_COMP_SDA, DBG_LEVEL_INFO,
			("afpCloseSessionAndFreeSda: Closing User Token\n"));

#ifdef	OPTIMIZE_GUEST_LOGON
	if ((pSda->sda_UserToken != NULL) && (pSda->sda_ClientType != SDA_CLIENT_GUEST))
#else
	if (pSda->sda_UserToken != NULL)
#endif
		NtClose(pSda->sda_UserToken);

	// Make sure there are no resource leaks
	ASSERT (pSda->sda_cOpenVolumes == 0);
	ASSERT (pSda->sda_pConnDesc == 0);
	ASSERT (pSda->sda_cOpenForks == 0);

    XportTable = pSda->sda_XportTable;

	(*(XportTable->asp_FreeConn))(pSda->sda_SessHandle);

    if (pSda->sda_ReplyBuf)
    {
	    DBGPRINT(DBG_COMP_SDA, DBG_LEVEL_ERR,
			("afpCloseSessionAndFreeSda: %d bytes would have leaked!\n",pSda->sda_ReplySize));

        // TRUE => lie that the lock is held: we don't need lock no more
        AfpFreeReplyBuf(pSda, TRUE);
    }

	// Free the sda memory, finally
	AfpFreeMemory(pSda);


	// If the server is stopping and the count of sessions has gone to zero
	// clear the termination confirmation event to unblock the admin thread
	if (((AfpServerState == AFP_STATE_STOP_PENDING) ||
		 (AfpServerState == AFP_STATE_SHUTTINGDOWN)) &&
		(AfpNumSessions == 0))
	{
		DBGPRINT(DBG_COMP_ADMINAPI, DBG_LEVEL_WARN,
			("afpSdaCloseSessionAndFreeSda: Unblocking server stop\n"));
		KeSetEvent(&AfpStopConfirmEvent, IO_NETWORK_INCREMENT, False);
	}

	DBGPRINT(DBG_COMP_SDA, DBG_LEVEL_INFO, ("afpCloseSessionAndFreeSda: Done\n"));

	return AFP_ERR_NONE;
}



/***	AfpSdaDereferenceSession
 *
 *	Dereference this SDA. This is called in response to either a AfpLogout
 *	request, a forced shutdown of this session by either SessionClose() api,
 *	the server shutdown or the session shutdown from the client end.
 *	The Sda should not be dereferenced until the entire request is processed
 *	i.e. the reply has ALSO COMPLETED.
 *
 *	NOTE: We unlink the session from the list but do not update the count till
 *		  the entire cleanup is complete.
 *
 *	LOCKS:		AfpSdaLock (SPIN), sda_Lock (SPIN), AfpStatisticsLock (SPIN)
 */
VOID FASTCALL
AfpSdaDereferenceSession(
	IN PSDA	pSda
)
{
	PSDA *		ppSda;
	KIRQL		OldIrql;
	LONG		RefCount;
    BOOLEAN     fTcpSession=TRUE;

	ASSERT(VALID_SDA(pSda));
	ASSERT((pSda->sda_RefCount > 0) &&
		   (pSda->sda_SessionId != 0));

	ACQUIRE_SPIN_LOCK(&pSda->sda_Lock, &OldIrql);
	RefCount = -- (pSda->sda_RefCount);
    if (RefCount == 0)
    {
        pSda->sda_Flags |= SDA_CLOSING;

        fTcpSession = (pSda->sda_Flags & SDA_SESSION_OVER_TCP)? TRUE : FALSE;
    }
	RELEASE_SPIN_LOCK(&pSda->sda_Lock, OldIrql);


	DBGPRINT(DBG_COMP_SDA, DBG_LEVEL_INFO,
			("AfpSdaDereferenceSession: Session %ld, New Count %ld\n",
			pSda->sda_SessionId, RefCount));

	// If there are more references, then we are done.
	if (RefCount > 0)
		return;

    ASSERT(RefCount == 0);     // catch refcount going below 0!

	ASSERT (!(pSda->sda_Flags & SDA_REQUEST_IN_PROCESS));

	DBGPRINT(DBG_COMP_SDA, DBG_LEVEL_INFO,
				("AfpSdaDereferenceSession: Closing down session %ld\n",
				pSda->sda_SessionId));

	// Cancel the scavenger event for checking this user's kickoff time
	AfpScavengerKillEvent(AfpSdaCheckSession,
						 (PVOID)((ULONG_PTR)(pSda->sda_SessionId)));

	// First unlink the Sda from the sessions list
	ACQUIRE_SPIN_LOCK(&AfpSdaLock, &OldIrql);

	for (ppSda = &AfpSessionList;
		 *ppSda != NULL;
		 ppSda = &(*ppSda)->sda_Next)
		if (pSda == *ppSda)
			break;

	ASSERT(*ppSda == pSda);

	*ppSda = pSda->sda_Next;

	// Update the count of active sessions
	ASSERT (AfpNumSessions > 0);
	--AfpNumSessions;

	RELEASE_SPIN_LOCK(&AfpSdaLock, OldIrql);

	// Free all buffers associated with the Sda
	// Now free the SDA memory
	if (pSda->sda_WSName.Buffer != NULL)
		AfpFreeMemory(pSda->sda_WSName.Buffer);

	if ((pSda->sda_ClientType != SDA_CLIENT_GUEST) &&
		(pSda->sda_UserName.Buffer != NULL))
		AfpFreeMemory(pSda->sda_UserName.Buffer);

	if (pSda->sda_Challenge != NULL)
		AfpFreeMemory(pSda->sda_Challenge);

	if (pSda->sda_DomainName.Buffer != NULL)
		AfpFreeMemory(pSda->sda_DomainName.Buffer);

	if (pSda->sda_Message != NULL)
		AfpFreeMemory(pSda->sda_Message);

	// Finally update statistics
	INTERLOCKED_ADD_ULONG((PLONG)&AfpServerStatistics.stat_CurrentSessions,
						  (ULONG)-1,
						  &AfpStatisticsLock);

	// it was a TCP session? update that counter as well
    if (fTcpSession)
    {
	    INTERLOCKED_ADD_ULONG((PLONG)&AfpServerStatistics.stat_TcpSessions,
		    				  (ULONG)-1,
			    			  &AfpStatisticsLock);
    }

	// The balance of the clean-up has to happen at LOW_LEVEL in the context
	// of the worker thread. So queue it up
	if ((OldIrql == DISPATCH_LEVEL) ||
		(PsGetCurrentProcess() != AfpProcessObject))
	{
		DBGPRINT(DBG_COMP_SDA, DBG_LEVEL_INFO,
				("AfpSdaDereferenceSession: Queuing Close&Free to Scavenger\n"));

		AfpScavengerScheduleEvent(afpCloseSessionAndFreeSda,
								  (PVOID)pSda,
								  0,
								  True);
	}
	else
	{
		afpCloseSessionAndFreeSda(pSda);
	}
}



/***	AfpSdaCreateNewSession
 *
 *	A new session has been initiated. Allocate and initialize a Sda and return a
 *	pointer to it. The new sda is linked into the list of active sessions.
 *
 *	LOCKS:		AfpSdaLock (SPIN), AfpServerGlobalLock (SPIN)
 *	LOCK_ORDER:	AfpServerGlobalLock after AfpSdaLock
 */
PSDA FASTCALL
AfpSdaCreateNewSession(
	IN	PVOID	SessionHandle,
    IN  BOOLEAN fOverTcp
)
{
	KIRQL	OldIrql;
	PSDA	*ppSda, pSda = NULL;


	if ((DWORD)AfpNumSessions < AfpServerMaxSessions)
	{
		if ((pSda = (PSDA)AfpAllocNonPagedMemory(SDA_SIZE)) == NULL)
			return NULL;

		// Initialize SDA fields
		RtlZeroMemory(pSda, sizeof(SDA));
#if DBG
		pSda->Signature = SDA_SIGNATURE;
#endif
		INITIALIZE_SPIN_LOCK(&pSda->sda_Lock);

		// Reference this Session
		pSda->sda_RefCount = 1;

		pSda->sda_Flags = SDA_USER_NOT_LOGGEDIN;

        if (fOverTcp)
        {
            pSda->sda_Flags |= SDA_SESSION_OVER_TCP;
            pSda->sda_XportTable = &AfpDsiEntries;
            pSda->sda_MaxWriteSize = DSI_SERVER_REQUEST_QUANTUM;
        }
        else
        {
            pSda->sda_XportTable = &AfpAspEntries;
            pSda->sda_MaxWriteSize = ASP_QUANTUM;
        }

		pSda->sda_SessHandle = SessionHandle;

		InitializeListHead(&pSda->sda_DeferredQueue);
		AfpInitializeWorkItem(&pSda->sda_WorkItem,
							  AfpStartApiProcessing,
							  pSda);
		AfpGetCurrentTimeInMacFormat(&pSda->sda_TimeLoggedOn);
		pSda->sda_tTillKickOff = MAXLONG;

		// Initialize space for request/response
		pSda->sda_SizeNameXSpace = (USHORT)(SDA_SIZE - sizeof(SDA));
		pSda->sda_NameXSpace = (PBYTE)pSda + sizeof(SDA);

		ACQUIRE_SPIN_LOCK(&AfpSdaLock, &OldIrql);

		// Assign a new session id to this session
		pSda->sda_SessionId = afpNextSessionId ++;

		ASSERT(pSda->sda_SessionId != 0);

		// Link the Sda into the active session list
		for (ppSda = &AfpSessionList;
			 *ppSda != NULL;
			 ppSda = &((*ppSda)->sda_Next))
		{
			if ((*ppSda)->sda_SessionId < pSda->sda_SessionId)
				break;
		}

		pSda->sda_Next = *ppSda;
		*ppSda = pSda;

		// Update the count of active sessions
		AfpNumSessions++;

		RELEASE_SPIN_LOCK(&AfpSdaLock, OldIrql);

		// Finally update statistics
		ACQUIRE_SPIN_LOCK(&AfpStatisticsLock, &OldIrql);
		AfpServerStatistics.stat_CurrentSessions ++;
		AfpServerStatistics.stat_TotalSessions ++;
		if (AfpServerStatistics.stat_CurrentSessions >
										AfpServerStatistics.stat_MaxSessions)
		AfpServerStatistics.stat_MaxSessions =
										AfpServerStatistics.stat_CurrentSessions;
        if (fOverTcp)
        {
            AfpServerStatistics.stat_TcpSessions++;

            if (AfpServerStatistics.stat_TcpSessions >
                                        AfpServerStatistics.stat_MaxTcpSessions)
            {
                AfpServerStatistics.stat_MaxTcpSessions =
                                        AfpServerStatistics.stat_TcpSessions;
            }
        }
		RELEASE_SPIN_LOCK(&AfpStatisticsLock, OldIrql);
	}

	return pSda;
}


/***	AfpSdaCloseSession
 *
 *	Setup to close the session
 */
AFPSTATUS FASTCALL
AfpSdaCloseSession(
	IN	PSDA	pSda
)
{
	LONG	ConnRef;
	DWORD	ForkRef, MaxOForkRefNum;

	DBGPRINT(DBG_COMP_SDA, DBG_LEVEL_INFO,
			("AfpSdaCloseSession: Entered for session %lx\n",
			pSda->sda_SessionId));

	// We should be coming in from the scavenger worker in its context i.e. at LOW_LEVEL.
	ASSERT (KeGetCurrentIrql() < DISPATCH_LEVEL);

	// Close down the open forks from this session
    MaxOForkRefNum = pSda->sda_MaxOForkRefNum;
	for (ForkRef = 1; ForkRef <= MaxOForkRefNum; ForkRef++)
	{
		POPENFORKENTRY	pOpenForkEntry;
		KIRQL			OldIrql;

		KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);
		pOpenForkEntry = AfpForkReferenceByRefNum(pSda, ForkRef);
		KeLowerIrql(OldIrql);

		if (pOpenForkEntry != NULL)
		{
			DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_INFO,
					("AfpSdaCloseSession: Forcing close of fork %lx, id %lx\n",
					ForkRef, pOpenForkEntry->ofe_ForkId));

			AfpForkClose(pOpenForkEntry);

			AfpForkDereference(pOpenForkEntry);
		}
	}

	// Now close down all open volumes.
	// Note that AfpConnectionClose will unlink the ConnDesc from the Sda
	for (ConnRef = 1; ConnRef <= afpLargestVolIdInUse; ConnRef++)
	{
		PCONNDESC	pConnDesc;

		if ((pConnDesc = AfpConnectionReference(pSda, ConnRef)) != NULL)
		{
			AfpConnectionClose(pConnDesc);
			AfpConnectionDereference(pConnDesc);
		}
	}

	DBGPRINT(DBG_COMP_SDA, DBG_LEVEL_INFO, ("AfpCloseSession: Done\n"));

	ASSERT (pSda->sda_Flags & SDA_SESSION_CLOSED);

	AfpSdaDereferenceSession(pSda);

	return AFP_ERR_NONE;
}


/***	AfpAdmWSessionClose
 *
 *	Close a session forcibly. This is an admin operation and must be queued
 *	up since this can potentially cause filesystem operations that are valid
 *	only in the system process context.
 *
 *	LOCKS:		AfpSdaLock (SPIN), sda_Lock (SPIN)
 *	LOCK_ORDER:	sda_Lock after AfpSdaLock
 */
NTSTATUS
AfpAdmWSessionClose(
	IN	OUT	PVOID	InBuf		OPTIONAL,
	IN	LONG		OutBufLen	OPTIONAL,
	OUT	PVOID		OutBuf		OPTIONAL
)
{
	AFPSTATUS			Status = AFPERR_InvalidId;
	DWORD				SessId;
	PSDA				pSda;
	KIRQL				OldIrql;
	PAFP_SESSION_INFO	pSessInfo = (PAFP_SESSION_INFO)InBuf;
	USHORT				AttnWord;
	BOOLEAN				Shoot = False;

	AttnWord = ATTN_USER_DISCONNECT;
	if ((AfpServerState == AFP_STATE_SHUTTINGDOWN) ||
        (AfpServerState == AFP_STATE_STOP_PENDING))
		AttnWord = ATTN_SERVER_SHUTDOWN;

	if ((SessId = pSessInfo->afpsess_id) != 0)
	{
		if ((pSda = AfpSdaReferenceSessionById(SessId)) != NULL)
		{
			Status = AFP_ERR_NONE;

			ACQUIRE_SPIN_LOCK(&pSda->sda_Lock, &OldIrql);

			if ((pSda->sda_Flags & (SDA_CLOSING | SDA_SESSION_CLOSED | SDA_CLIENT_CLOSE)) == 0)
			{
				Shoot = True;
				pSda->sda_Flags |= SDA_CLOSING | SDA_SESSION_CLOSED;
			}

			RELEASE_SPIN_LOCK(&pSda->sda_Lock, OldIrql);

			if (Shoot)
			{
				// Tell the client (s)he's being shot
				AfpSpSendAttention(pSda, AttnWord, True);

				AfpSpCloseSession(pSda);
			}
			AfpSdaDereferenceSession(pSda);
		}
        else
        {
		    DBGPRINT(DBG_COMP_SDA, DBG_LEVEL_ERR,
				("AfpAdmWSessionClose: no pSda found for SessId %d\n",pSessInfo->afpsess_id));
        }
	}
	else
	{
		PSDA	pSdaNext;

		// Here we want to block incoming sessions while we kill the existing ones
        AfpSpDisableListens();

		Status = AFP_ERR_NONE;
		ACQUIRE_SPIN_LOCK(&AfpSdaLock, &OldIrql);

		for (pSda = AfpSessionList; pSda != NULL; pSda = pSdaNext)
		{
			ACQUIRE_SPIN_LOCK_AT_DPC(&pSda->sda_Lock);

			Shoot = False;
			pSdaNext = pSda->sda_Next;
			if ((pSda->sda_Flags & (SDA_CLOSING | SDA_SESSION_CLOSED | SDA_CLIENT_CLOSE)) == 0)
			{
				pSda->sda_Flags |= SDA_CLOSING | SDA_SESSION_CLOSED;
				pSda->sda_RefCount ++;
				Shoot = True;
			}

			RELEASE_SPIN_LOCK_FROM_DPC(&pSda->sda_Lock);

			if (Shoot)
			{
				RELEASE_SPIN_LOCK(&AfpSdaLock, OldIrql);

				// Tell the client (s)he's being shot
				AfpSpSendAttention(pSda, AttnWord, True);

				AfpSpCloseSession(pSda);

				AfpSdaDereferenceSession(pSda);

				ACQUIRE_SPIN_LOCK(&AfpSdaLock, &OldIrql);
				pSdaNext = AfpSessionList;
			}
		}
		RELEASE_SPIN_LOCK(&AfpSdaLock, OldIrql);

		// Enable new incoming sessions - but only if we are not paused
		if ((AfpServerState & (AFP_STATE_PAUSED | AFP_STATE_PAUSE_PENDING)) == 0)
		{
			AfpSpEnableListens();
		}
	}

	return Status;
}


/***	AfpSdaCheckSession
 *
 *	Check if a session needs to be forcibly closed. If we are called by the
 *  scavenger for the first time and our scavenger interval is not
 *  SESSION_CHECK_TIME, we need to reschedule ourselves to run at this
 *	interval.
 *
 *	Since the sda_tTillKickOff is only used here, it needs
 *	no protection.
 */
AFPSTATUS FASTCALL
AfpSdaCheckSession(
	IN	PVOID	pContext
)
{
	PSDA				pSda;
	DWORD				SessionId = (DWORD)((ULONG_PTR)pContext);
	AFPSTATUS			Status = AFP_ERR_REQUEUE;
	BOOLEAN				RequeueOurself = False;

	PAGED_CODE( );

	if ((pSda = AfpSdaReferenceSessionById(SessionId)) != NULL)
	{
		if (pSda->sda_tTillKickOff > SESSION_WARN_TIME)
		{
			// This is the first time this routine has run, and it was
			// originally scheduled to run at a time greater than
			// SESSION_WARN_TIME.  Therefore, we need to reschedule this
			// scavenger event ourselves with a new SESSION_CHECK_TIME
			// interval.  This is the only time we need to do this.
			pSda->sda_tTillKickOff = SESSION_WARN_TIME;
			Status = AFP_ERR_NONE;
			RequeueOurself = True;
		}
		else if (pSda->sda_tTillKickOff > 0)
			pSda->sda_tTillKickOff -= SESSION_CHECK_TIME;

		ASSERT(pSda->sda_tTillKickOff <= SESSION_WARN_TIME);

		DBGPRINT(DBG_COMP_SDA, DBG_LEVEL_WARN,
				("AfpSdaCheckSession: Below warn level %ld\n",
				pSda->sda_tTillKickOff));

		// If we are at 0, kick this user out. Else just
		// send him a friendly warning.
		if (pSda->sda_tTillKickOff == 0)
		{
			AFP_SESSION_INFO	SessionInfo;

			DBGPRINT(DBG_COMP_SDA, DBG_LEVEL_WARN,
					("AfpSdaCheckSession: Booting session %ld\n", SessionId));

			SessionInfo.afpsess_id = SessionId;
			AfpAdmWSessionClose(&SessionInfo, 0, NULL);
			Status = AFP_ERR_NONE;		// Do not reschedule
		}
		else
		{
			DBGPRINT(DBG_COMP_SDA, DBG_LEVEL_WARN,
					("AfpSdaCheckSession: Warning session %ld\n", SessionId));

			AfpSpSendAttention(pSda,
							   (USHORT)(ATTN_USER_DISCONNECT |
										((pSda->sda_tTillKickOff/60) & ATTN_TIME_MASK)),
								True);
		}

		if (RequeueOurself)
		{
			AfpScavengerScheduleEvent(
							AfpSdaCheckSession,
							(PVOID)((ULONG_PTR)pSda->sda_SessionId),
							SESSION_CHECK_TIME,
							True);
		}

		AfpSdaDereferenceSession(pSda);
	}

	return Status;
}


/***	AfpKillSessionsOverProtocol
 *
 *	Kill all the sessions over a specific protocol (TCP/IP or Appletalk)
 */
VOID FASTCALL
AfpKillSessionsOverProtocol(
	IN	BOOLEAN     fAppletalkSessions
)
{
	PSDA        pSda;
	PSDA        pSdaNext;
    KIRQL       OldIrql;
    USHORT      AttnWord;


    AttnWord = ATTN_USER_DISCONNECT;

	ACQUIRE_SPIN_LOCK(&AfpSdaLock, &OldIrql);

	for (pSda = AfpSessionList; pSda != NULL; pSda = pSdaNext)
	{
		ACQUIRE_SPIN_LOCK_AT_DPC(&pSda->sda_Lock);

		pSdaNext = pSda->sda_Next;

        //
        // if this session is already being closing, skip it
        //
		if (pSda->sda_Flags & (SDA_CLOSING | SDA_SESSION_CLOSED | SDA_CLIENT_CLOSE))
		{
            RELEASE_SPIN_LOCK_FROM_DPC(&pSda->sda_Lock);
            continue;
		}

        //
        // if we are asked to kill all Appletalk sessions and this session
        // over Appletalk, skip it
        //
        if (fAppletalkSessions)
        {
            if (pSda->sda_Flags & SDA_SESSION_OVER_TCP)
            {
                DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
	                ("AfpKillSessionsOverProtocol: skipping TCP session %lx\n",pSda));

                RELEASE_SPIN_LOCK_FROM_DPC(&pSda->sda_Lock);
                continue;
            }
        }

        //
        // we are asked to kill all TCP/IP sessions, and this session is
        // over Appletalk: skip it
        //
        else
        {
            if (!(pSda->sda_Flags & SDA_SESSION_OVER_TCP))
            {
                DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
	                ("AfpKillSessionsOverProtocol: skipping Appletalk session %lx\n",pSda));

                RELEASE_SPIN_LOCK_FROM_DPC(&pSda->sda_Lock);
                continue;
            }
        }
		pSda->sda_Flags |= SDA_CLOSING | SDA_SESSION_CLOSED;

        // put a DISCONNECT refcount
		pSda->sda_RefCount ++;
		
        RELEASE_SPIN_LOCK_FROM_DPC(&pSda->sda_Lock);

		RELEASE_SPIN_LOCK(&AfpSdaLock, OldIrql);

		// give client the bad news
		AfpSpSendAttention(pSda, AttnWord, True);

		AfpSpCloseSession(pSda);

        // and remove that DISCONNECT refcount
		AfpSdaDereferenceSession(pSda);

		ACQUIRE_SPIN_LOCK(&AfpSdaLock, &OldIrql);

        // start from the head of the list
		pSdaNext = AfpSessionList;
	}

	RELEASE_SPIN_LOCK(&AfpSdaLock, OldIrql);

}


/***	AfpFreeReplyBuf
 *
 *	Free up the reply buffer
 *
 */
VOID
AfpFreeReplyBuf(
    IN  PSDA    pSda,
    IN  BOOLEAN fLockHeld
)
{
    KIRQL       OldIrql;
    BOOLEAN     fRelease=FALSE;
    PBYTE       pReplyBuffer;


    if (!fLockHeld)
    {
        ACQUIRE_SPIN_LOCK(&pSda->sda_Lock, &OldIrql);
        fRelease = TRUE;
    }

    ASSERT(pSda->sda_ReplyBuf != NULL);

    pReplyBuffer = pSda->sda_ReplyBuf - DSI_BACKFILL_OFFSET(pSda);

    if (pReplyBuffer == pSda->sda_NameXSpace)
    {
        ASSERT(pSda->sda_Flags & SDA_NAMEXSPACE_IN_USE);
        pSda->sda_Flags &= ~SDA_NAMEXSPACE_IN_USE;
    }
    else
    {
        AfpFreeMemory(pReplyBuffer);
    }

    pSda->sda_ReplyBuf = NULL;
    pSda->sda_ReplySize = 0;

    if (fRelease)
    {
        RELEASE_SPIN_LOCK(&pSda->sda_Lock, OldIrql);
    }
}



/***	afpUpdateDiskQuotaInfo
 *
 *	Get Available disk quota for this user
 *
 */

VOID FASTCALL
afpUpdateDiskQuotaInfo(
    IN PCONNDESC    pConnDesc
)
{

	FILE_FS_SIZE_INFORMATION	fssizeinfo;
	IO_STATUS_BLOCK				IoStsBlk;
	NTSTATUS					rc;
	LONG						BytesPerAllocationUnit;
	LARGE_INTEGER				FreeBytes, VolumeSize;
    KIRQL                       OldIrql;


    ASSERT(VALID_CONNDESC(pConnDesc));

    ASSERT(VALID_VOLDESC(pConnDesc->cds_pVolDesc));

	ASSERT(VALID_VOLDESC(pConnDesc->cds_pVolDesc) &&
           VALID_FSH(&pConnDesc->cds_pVolDesc->vds_hRootDir) &&
           (KeGetCurrentIrql() < DISPATCH_LEVEL));

    AfpImpersonateClient(pConnDesc->cds_pSda);

	rc = NtQueryVolumeInformationFile(
                pConnDesc->cds_pVolDesc->vds_hRootDir.fsh_FileHandle,
				&IoStsBlk,
				(PVOID)&fssizeinfo,
				sizeof(fssizeinfo),
				FileFsSizeInformation);

    AfpRevertBack();

	if (!NT_SUCCESS(rc))
	{
        DBGPRINT(DBG_COMP_FILEIO, DBG_LEVEL_ERR,
		("afpUpdateDiskQuotaInfo: NtQueryVolInfoFile failed 0x%lx\n",rc));

        // take away the refcount we put before calling this routine
        AfpConnectionDereference(pConnDesc);
        return;
	}

	//
	// note Macintosh can only handle 2Gb volume size. So kludge appropriately.
	// System 7.5 and beyond has upped this to 4GB. Optionally handle this if
	// the volume has that bit turned on.
	//

	BytesPerAllocationUnit =
		(LONG)(fssizeinfo.BytesPerSector * fssizeinfo.SectorsPerAllocationUnit);

	FreeBytes  = RtlExtendedIntegerMultiply(fssizeinfo.AvailableAllocationUnits,
											BytesPerAllocationUnit);

	VolumeSize = RtlExtendedIntegerMultiply(fssizeinfo.TotalAllocationUnits,
							BytesPerAllocationUnit);

    ACQUIRE_SPIN_LOCK(&pConnDesc->cds_ConnLock, &OldIrql);
    pConnDesc->cds_QuotaLimit = VolumeSize;
    pConnDesc->cds_QuotaAvl = FreeBytes;
    RELEASE_SPIN_LOCK(&pConnDesc->cds_ConnLock, OldIrql);

    DBGPRINT(DBG_COMP_SDA, DBG_LEVEL_INFO,
        ("afpUpdateDiskQuotaInfo: Conn %lx Limit=%ld, Available=%ld\n",
        pConnDesc,pConnDesc->cds_QuotaLimit.LowPart,pConnDesc->cds_QuotaAvl.LowPart));

    // take away the refcount we put before calling this routine
    AfpConnectionDereference(pConnDesc);

    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\server\secutil.h ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	secutil.h

Abstract:


Author:

	Narendra Gidwani (microsoft!NarenG)


Revision History:
	8 Sept. 1992			 Initial Version

Notes:  Tab stop: 4
--*/
											
#ifndef	_SECUTIL_
#define	_SECUTIL_

typedef struct _AFP_SID_NAME
{
	AFPTIME					LastAccessedTime;
	UNICODE_STRING			Name;
	struct _AFP_SID_NAME *	SidLink;		
	BYTE					Sid[1]; 	
} AFP_SID_NAME, *PAFP_SID_NAME;


typedef struct _AFP_SID_MACID
{
	struct _AFP_SID_MACID   *Next;
    DWORD                   MacId;
	BYTE					Sid[1]; 	
} AFP_SID_MACID, *PAFP_SID_MACID;

extern
NTSTATUS
AfpSecUtilInit(
	VOID
);

extern
VOID
AfpSecUtilDeInit(
	VOID
);

extern
NTSTATUS
AfpSecurityUtilityWorker(
	IN	PIRP pIrp,
	IN	PIO_STACK_LOCATION pIrpSp
);

extern
NTSTATUS FASTCALL
AfpNameToSid(
	IN	PSDA			  pSda,
	IN	PUNICODE_STRING   Name
);

extern
NTSTATUS
AfpSidToName(
	IN	PSDA			pSda,
	IN	PSID			Sid,
	OUT	PAFP_SID_NAME *	ppTranslatedSid
);

extern
NTSTATUS FASTCALL
AfpSidToMacId(
	IN	PSID			Sid,
	OUT PULONG			pMacId
);

extern
NTSTATUS FASTCALL
AfpMacIdToSid(
	IN	ULONG			MacId,
	OUT PSID *			ppSid
);

extern
NTSTATUS FASTCALL
AfpChangePassword(
	IN	PSDA				pSda,
	IN	PAFP_PASSWORD_DESC	pPassword
);


extern
AFPSTATUS FASTCALL
AfpInitSidOffsets(
	IN	ULONG			SidOffstPairs,
	IN	PAFP_SID_OFFSET	pSidOff
);

extern
VOID
AfpTerminateSecurityUtility(
	VOID
);

#ifdef	_SECUTIL_LOCALS

#define SIZE_SID_LOOKUP_TABLE			51
#define SID_HASH_RADIX					11
#define	SID_NAME_AGE					300	// In seconds

#define MAX_SECWORKITEM_QLEN            5000

typedef	VOID (*SEC_COMPLETION_ROUTINE)(IN ULONG, IN PVOID);

typedef struct _SEC_WORK_ITEM
{
	LIST_ENTRY				Links;

	PVOID					pOutput;
	LONG					OutputBufSize;
	SEC_COMPLETION_ROUTINE	pCompletionRoutine;
	PKEVENT					pCompletionEvent;
	PSDA					pSda;
} SEC_WORK_ITEM, *PSEC_WORK_ITEM;

typedef enum _SECURITY_THREAD_STATE
{
	IDLE=1,
  	BUSY,
	NOT_AVAILABLE

} SECURITY_THREAD_STATE;

typedef struct _AFP_SECURITY_THREAD
{

	SECURITY_THREAD_STATE	State;
	PIRP					pIrp;
 	PSEC_WORK_ITEM			pSecWorkItem;
} AFP_SECURITY_THREAD, *PAFP_SECURITY_THREAD;

// Array of utiity threads

LOCAL	AFP_SECURITY_THREAD 	afpSecurityThread[NUM_SECURITY_UTILITY_THREADS] = { 0 };

// Hash table for SID/Name cache

LOCAL	PAFP_SID_NAME *			afpSidLookupTable	= (PAFP_SID_NAME*)NULL;
LOCAL   PAFP_SID_MACID *        afpSidToMacIdTable  = (PAFP_SID_MACID*)NULL;

LOCAL   PAFP_SID_MACID          afpLastCachedSid = (PAFP_SID_MACID)NULL;
LOCAL   DWORD                   afpNextMacIdToUse = 1;

// Queue of work items for the SecurityThreads

LOCAL	LIST_ENTRY				afpSecWorkItemQ = { 0 };
LOCAL   DWORD                   afpSecWorkItemQLength = { 0 };


// Single Writer Multi Reader for the SID/Name cache

LOCAL	SWMR 					afpSWMRForSidNameCache = { 0 };

// Spinlock protects the array of worker threads, the work queue and the
// 'in progress' count/event
LOCAL	AFP_SPIN_LOCK				afpSecUtilLock = { 0 };

// Signalled when no work is in progress.
LOCAL	KEVENT					afpUtilWorkInProgressEvent = { 0 };
LOCAL	LONG					afpUtilWorkInProgress = 0;


LOCAL
NTSTATUS
afpQueueSecWorkItem(
	IN	AFP_FSD_CMD_ID			FsdCommand,
	IN	PSDA					pSda,
	IN	PKEVENT					pCompletionEvent,
	IN	PAFP_FSD_CMD_PKT 		pAfpFsdCmdPkt,
	IN	LONG					BufSize,
	IN	SEC_COMPLETION_ROUTINE	pCompletionRoutine
);

#define	ALLOC_SWI()	(PSEC_WORK_ITEM)AfpAllocNonPagedMemory(sizeof(SEC_WORK_ITEM))

LOCAL VOID
afpCompleteNameToSid(
	IN ULONG Index,
	IN PVOID pInBuf
);

LOCAL VOID
afpCompleteSidToName(
	IN ULONG Index,
	IN PVOID pInBuf
);

LOCAL VOID
afpCompleteMacIdToSid(
	IN ULONG Index,
	IN PVOID pInBuf
);

LOCAL VOID
afpCompleteChangePassword(
	IN ULONG Index,
	IN PVOID pInBuf
);

LOCAL VOID
afpCompleteLogEvent(
	IN	ULONG	Index,
	IN	PVOID	pInBuf
);

LOCAL NTSTATUS FASTCALL
afpUpdateNameSidCache(
	IN WCHAR * Name,
	IN PSID	Sid
);

LOCAL PAFP_SID_NAME FASTCALL
afpLookupSid(
	IN	PSID Sid
);

LOCAL ULONG FASTCALL
afpHashSid(
	IN PSID	Sid
);

LOCAL VOID
afpDeInitializeSecurityUtility(
	VOID
);

AFPSTATUS FASTCALL
afpAgeSidNameCache(
	IN	PVOID	pContext
);

#endif	// _SECUTIL_LOCALS

#endif	// _SECUTIL_


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\server\server.c ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

    server.c

Abstract:

    This module contains server global data and server init code.
    This is used by the admin interface to start-off the server.


Author:

    Jameel Hyder (microsoft!jameelh)


Revision History:
    25 Apr 1992     Initial Version

Notes:  Tab stop: 4
--*/

#define _GLOBALS_
#define SERVER_LOCALS
#define FILENUM FILE_SERVER

#include <seposix.h>
#include <afp.h>
#include <afpadmin.h>
#include <access.h>
#include <client.h>
#include <tcp.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, AfpInitializeDataAndSubsystems)
#pragma alloc_text( PAGE, AfpDeinitializeSubsystems)
#pragma alloc_text( PAGE, AfpAdmSystemShutdown)
#pragma alloc_text( PAGE, AfpCreateNewThread)
#pragma alloc_text( PAGE_AFP, AfpAdmWServerSetInfo)
//#pragma alloc_text( PAGE_AFP, AfpSetServerStatus)
#endif

// This is the device handle to the stack.
BOOLEAN             afpSpNameRegistered = False;
HANDLE              afpSpAddressHandle = NULL;
PDEVICE_OBJECT      afpSpAppleTalkDeviceObject = NULL;
PFILE_OBJECT        afpSpAddressObject = NULL;
LONG                afpSpNumOutstandingReplies = 0;

/***    AfpInitializeDataAndSubsystems
 *
 *  Initialize Server Data and all subsystems.
 */
NTSTATUS
AfpInitializeDataAndSubsystems(
    VOID
)
{
    NTSTATUS        Status;
    PBYTE           pBuffer;
    PBYTE           pDest;
    LONG            i, j;

    // Initialize various global locks
    INITIALIZE_SPIN_LOCK(&AfpServerGlobalLock);
    INITIALIZE_SPIN_LOCK(&AfpSwmrLock);
    INITIALIZE_SPIN_LOCK(&AfpStatisticsLock);

#if DBG
    INITIALIZE_SPIN_LOCK(&AfpDebugSpinLock);
    InitializeListHead(&AfpDebugDelAllocHead);
#endif

    KeInitializeEvent(&AfpStopConfirmEvent, NotificationEvent, False);
    KeInitializeMutex(&AfpPgLkMutex, 0xFFFF);
    AfpInitializeWorkItem(&AfpTerminateThreadWI, NULL, NULL);

    // The default security quality of service
    AfpSecurityQOS.Length = sizeof(AfpSecurityQOS);
    AfpSecurityQOS.ImpersonationLevel = SecurityImpersonation;
    AfpSecurityQOS.ContextTrackingMode = SECURITY_STATIC_TRACKING;
    AfpSecurityQOS.EffectiveOnly = False;

    // Timeout(s) value used by AfpIoWait
    FiveSecTimeOut.QuadPart = (-5*NUM_100ns_PER_SECOND);
    ThreeSecTimeOut.QuadPart = (-3*NUM_100ns_PER_SECOND);
    TwoSecTimeOut.QuadPart = (-2*NUM_100ns_PER_SECOND);
    OneSecTimeOut.QuadPart = (-1*NUM_100ns_PER_SECOND);

    // Default Type Creator. Careful with the initialization here.This has
    // to be processor independent
    AfpSwmrInitSwmr(&AfpEtcMapLock);
    PUTBYTE42BYTE4(&AfpDefaultEtcMap.etc_type, AFP_DEFAULT_ETC_TYPE);
    PUTBYTE42BYTE4(&AfpDefaultEtcMap.etc_creator, AFP_DEFAULT_ETC_CREATOR);
    PUTBYTE42BYTE4(&AfpDefaultEtcMap.etc_extension, AFP_DEFAULT_ETC_EXT);

    // Determine if the machine is little or big endian. This is not currently used
    // at all. The idea is to maintain all on-disk databases in little-endian
    // format and on big-endian machines, convert on the way-in and out.
    i = 0x01020304;
    AfpIsMachineLittleEndian = (*(BYTE *)(&i) == 0x04);
    AfpServerState = AFP_STATE_IDLE;
    AfpServerOptions = AFP_SRVROPT_NONE;
    AfpServerMaxSessions = AFP_MAXSESSIONS;

	// Check if server needs the Greek fix
	{
		UNICODE_STRING  valueName;
		UNICODE_STRING  regPath;
		HANDLE          ParametersHandle = NULL;
		PBYTE           Storage = NULL;
		PKEY_VALUE_FULL_INFORMATION Info = NULL;
		ULONG           bytesWritten;
		PDWORD          Value;
		OBJECT_ATTRIBUTES       ObjectAttributes;
		NTSTATUS        status;

		AfpServerIsGreek = FALSE;

		RtlInitUnicodeString (&regPath,
								AFP_KEYPATH_SERVER_PARAMS_GREEK);

		InitializeObjectAttributes(&ObjectAttributes,
									&regPath,
									OBJ_CASE_INSENSITIVE,
									NULL,
									NULL);

		status = ZwOpenKey(&ParametersHandle,
							KEY_READ,
							&ObjectAttributes);

		if (NT_SUCCESS(status))
		{
			RtlInitUnicodeString (&valueName,
									AFPREG_VALNAME_GreekServer);

			status = ZwQueryValueKey(ParametersHandle,
									&valueName,
									KeyValueFullInformation,
									NULL,
									0,
									&bytesWritten);
			if (status == STATUS_BUFFER_TOO_SMALL)
			{
				Storage = (PBYTE)AfpAllocNonPagedMemory (bytesWritten);
				Info = (PKEY_VALUE_FULL_INFORMATION)Storage;
				status = ZwQueryValueKey(ParametersHandle,
										&valueName,
										KeyValueFullInformation,
										Info,
										Storage?bytesWritten:0,
										&bytesWritten);

				if (NT_SUCCESS(status))
				{
					if (Info->Type != REG_DWORD)
					{
						DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
								("AfpInitializeDataAndSubsystems: Invalid value type=(%ld) expected=(%ld)\n",
								 Info->Type, REG_DWORD));
					}
					else
					{
						Value = (PDWORD)((PBYTE)Info + Info->DataOffset);
						DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
								("AfpInitializeDataAndSubsystems: Read in value for Greek key (%ld)\n",
								 *Value));
						if (*Value == TRUE)
						{
							AfpServerIsGreek = TRUE;
						}
					}
				}
				else
				{
					AfpServerIsGreek = FALSE;
					DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
							("AfpInitializeDataAndSubsystems: ZwQueryValueKey 2 failed with error (%0lx), Storagesize=(%ld), BytesNeeded=(%ld)\n",
							 status, sizeof(Storage), bytesWritten));
				}
			}
			else
			{
				DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
						("AfpInitializeDataAndSubsystems: ZwQueryValueKey 1 failed with error (%0lx), Storagesize=(%ld), BytesNeeded=(%ld)\n",
						 status, sizeof(Storage), bytesWritten));
			}
		}
		else
		{
			DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
					("AfpInitializeDataAndSubsystems: ZwOpenKey failed with error (%0lx)\n",
					 status));
		}

		if (ParametersHandle != NULL)
		{
			ZwClose(ParametersHandle);
		}
		if (Storage != NULL)
		{
			AfpFreeMemory (Storage);
		}
		status = STATUS_SUCCESS;
	}

	AfpGetCurrentTimeInMacFormat((PAFPTIME)&AfpServerStatistics.stat_TimeStamp);

    //AfpGetCurrentTimeInMacFormat(&AfpSrvrNotifSentTime);

    // generate a "unique" signature for our server
    pDest = &AfpServerSignature[0];
    for (i=0; i<2; i++)
    {
        pBuffer = AfpGetChallenge();
        if (pBuffer)
        {
            RtlCopyMemory(pDest, pBuffer, MSV1_0_CHALLENGE_LENGTH);
            pDest += MSV1_0_CHALLENGE_LENGTH;
            AfpFreeMemory(pBuffer);
        }
    }

#ifdef  PROFILING
    // Allocate this directly since AfpAllocMemory() uses AfpServerProfile !!!
    if ((AfpServerProfile = (PAFP_PROFILE_INFO)ExAllocatePoolWithTag(NonPagedPool,
                                                                     sizeof(AFP_PROFILE_INFO),
                                                                     AFP_TAG)) == NULL)
        return STATUS_INSUFFICIENT_RESOURCES;
    RtlZeroMemory(AfpServerProfile, sizeof(AFP_PROFILE_INFO));
    KeQueryPerformanceCounter(&AfpServerProfile->perf_PerfFreq);
#endif

    AfpInitStrings();

    // Initialize the sub-systems
    for (i = 0; i < NUM_INIT_SYSTEMS; i++)
    {
        DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("AfpInitializeDataAndSubsystems: Initializing s\n",
            AfpInitSubSystems[i].InitRoutineName));

        if (AfpInitSubSystems[i].InitRoutine != NULL)
        {
            Status = (*AfpInitSubSystems[i].InitRoutine)();
            if (!NT_SUCCESS(Status))
            {
                DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
                    ("AfpInitializeDataAndSubsystems: %s failed %lx\n",
                    AfpInitSubSystems[i].InitRoutineName, Status));

                // One of the subsystems failed to initialize. Deinitialize all
                // of them which succeeded.
                for (j = 0; j < i; j++)
                {
                    if (AfpInitSubSystems[j].DeInitRoutine != NULL)
                    {
                        DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
                                ("AfpInitializeDataAndSubsystems: Deinitializing %s\n",
                                AfpInitSubSystems[j].DeInitRoutineName));
                        (*AfpInitSubSystems[j].DeInitRoutine)();
                    }
#if DBG
                    AfpInitSubSystems[j].Deinitialized = True;
#endif
                }
                return Status;
            }
#if DBG
            AfpInitSubSystems[i].Initialized = True;
#endif
        }
    }

    return STATUS_SUCCESS;
}



/***    AfpDeinitializeSubsystems
 *
 *  De-initialize all subsystems.
 */
VOID
AfpDeinitializeSubsystems(
    VOID
)
{
    LONG    i;

    PAGED_CODE( );

    // De-initialize the sub-systems
    for (i = 0; i < NUM_INIT_SYSTEMS; i++)
    {
        if (AfpInitSubSystems[i].DeInitRoutine != NULL)
        {
            DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
                    ("AfpDeinitializeDataAndSubsystems: Deinitializing %s\n",
                    AfpInitSubSystems[i].DeInitRoutineName));
            (*AfpInitSubSystems[i].DeInitRoutine)();
        }
#if DBG
        AfpInitSubSystems[i].Deinitialized = True;
#endif
    }
}


/***    AfpSetServerStatus
 *
 *  Set the Server status block via afpSpSetStatus. This is called in once at
 *  server startup and anytime a change in server status makes this necessary.
 *  By now, ServerSetInfo() has happened and it has been validated that all
 *  paramters are kosher.
 *
 *  LOCKS:  AfpServerGlobalLock (SPIN)
 */
AFPSTATUS
AfpSetServerStatus(
    IN VOID
)
{
    KIRQL       OldIrql;
    AFPSTATUS   Status=STATUS_SUCCESS;
    AFPSTATUS   Status2;
    struct _StatusHeader
    {
        BYTE    _MachineString[2];  // These are offsets relative to the struct
        BYTE    _AfpVersions[2];    // ---------- do ------------
        BYTE    _UAMs[2];           // ---------- do ------------
        BYTE    _VolumeIcon[2];     // ---------- do ------------
        BYTE    _Flags[2];          // Server Flags
                        // The actual strings start here
    } *pStatusHeader;
    PASCALSTR   pStr;
    PBYTE       pNumUamPtr;
    LONG        Size;
    USHORT      Flags;
    BOOLEAN     GuestAllowed = False,
                ClearTextAllowed = False,
                NativeAppleUamSupported = False,
                MicrosoftUamSupported = False,
                AllowSavePass = False;
    BYTE        CountOfUams;
    PBYTE       pSignOffset;
    PBYTE       pNetAddrOffset;
    DWORD       IpAddrCount=0;
    PBYTE       IpAddrBlob=NULL;
    NTSTATUS    ntStatus;


    // Assert that all the info that we can possibly stuff in can indeed fit
    // in the buffer that we'll allocate

    // Allocate a buffer to fill the status information in. This will be
    // freed by AfpSpSetStatus(), this can be freed. We do not know up front
    // how much we'll need. Err on the safe side
    if ((pStatusHeader = (struct _StatusHeader *)
                AfpAllocZeroedNonPagedMemory(ASP_MAX_STATUS_BUF)) == NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // first, find out if we have any TCPIP addresses
    //
    ntStatus = DsiGetIpAddrBlob(&IpAddrCount, &IpAddrBlob);
    if (!NT_SUCCESS(ntStatus))
    {
        AfpFreeMemory(pStatusHeader);

        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("AfpSetServerStatus: DsiGetIpAddrBlob failed %lx\n",ntStatus));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    ACQUIRE_SPIN_LOCK(&AfpServerGlobalLock, &OldIrql);

    GuestAllowed = (AfpServerOptions & AFP_SRVROPT_GUESTLOGONALLOWED) ?
                                             True : False;

    ClearTextAllowed = (AfpServerOptions & AFP_SRVROPT_CLEARTEXTLOGONALLOWED) ?
                                             True : False;

    MicrosoftUamSupported = (AfpServerOptions & AFP_SRVROPT_MICROSOFT_UAM)?
                                             True : False;

    NativeAppleUamSupported = (AfpServerOptions & AFP_SRVROPT_NATIVEAPPLEUAM) ?
                                             True : False;

    if (!ClearTextAllowed && !MicrosoftUamSupported && !NativeAppleUamSupported)
    {
        DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_WARN,
            ("AfpSetServerStatus: got to enable at least one UAM! Failing request\n"));

        RELEASE_SPIN_LOCK(&AfpServerGlobalLock, OldIrql);
        AfpFreeMemory(pStatusHeader);
        if (IpAddrBlob)
        {
            AfpFreeMemory(IpAddrBlob);
        }
        return(STATUS_INVALID_PARAMETER);
    }

    Size = sizeof(struct _StatusHeader) +       // Status header
           AfpServerName.Length + 1 +           // Server Name
           AFP_MACHINE_TYPE_LEN + 1 +           // Machine String
           AfpVersion20.Length + 1 +            // Afp Versions
           AfpVersion21.Length + 1 +
           ICONSIZE_ICN;                        // Volume Icon & Mask

    ASSERT(Size <= ASP_MAX_STATUS_BUF);

    // Specify our capabilities
    Flags = SRVRINFO_SUPPORTS_COPYFILE  |
            SRVRINFO_SUPPORTS_CHGPASSWD |
            SRVRINFO_SUPPORTS_SERVERMSG |
            SRVRINFO_SUPPORTS_SRVSIGN   |
            SRVRINFO_SUPPORTS_SRVNOTIFY |
#ifdef  CLIENT36
            SRVRINFO_SUPPORTS_MGETREQS  |
#endif
            ((AfpServerOptions & AFP_SRVROPT_ALLOWSAVEDPASSWORD) ?
                0: SRVRINFO_DISALLOW_SAVEPASS);

    // do we have any ipaddresses?
    if (IpAddrCount > 0)
    {
        Flags |= SRVRINFO_SUPPORTS_TCPIP;
    }

    PUTSHORT2SHORT(&pStatusHeader->_Flags, Flags);

    // Copy the Server Name
    pStr = (PASCALSTR)((PBYTE)pStatusHeader + sizeof(struct _StatusHeader));
    pStr->ps_Length = (BYTE)(AfpServerName.Length);
    RtlCopyMemory(pStr->ps_String, AfpServerName.Buffer, AfpServerName.Length);
    (PBYTE)pStr += AfpServerName.Length + 1;

    // do we need a pad byte?
    if (((PBYTE)pStr - (PBYTE)pStatusHeader) % 2 == 1)
    {
        *(PBYTE)pStr = 0;
        ((PBYTE)pStr)++;
    }

    // skip past the Signature Offset field: we'll store the value later
    pSignOffset = (PBYTE)pStr;
    ((PBYTE)pStr) += 2;

    if ((IpAddrCount > 0) || (AfpServerBoundToAsp))
    {
        // skip past the Network Address Count Offset: we'll store the value later
        pNetAddrOffset = (PBYTE)pStr;
        ((PBYTE)pStr) += 2;
    }
    else
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("AfpSetServerStatus: Neither TCP nor Appletalk is active!!\n"));
    }

    PUTSHORT2SHORT(pStatusHeader->_MachineString,
                     (USHORT)((PBYTE)pStr - (PBYTE)pStatusHeader));


    // Copy the machine name string
    pStr->ps_Length = (BYTE) AFP_MACHINE_TYPE_LEN;
    RtlCopyMemory(pStr->ps_String, AFP_MACHINE_TYPE_STR, AFP_MACHINE_TYPE_LEN);
    (PBYTE)pStr += AFP_MACHINE_TYPE_LEN + 1;

    // Copy the Afp Version Strings
    PUTSHORT2SHORT(pStatusHeader->_AfpVersions,
            (USHORT)((PBYTE)pStr - (PBYTE)pStatusHeader));

    *((PBYTE)pStr)++ = AFP_NUM_VERSIONS;
    pStr->ps_Length = (BYTE)AfpVersion20.Length;
    RtlCopyMemory(pStr->ps_String, AfpVersion20.Buffer, AfpVersion20.Length);
    (PBYTE)pStr += AfpVersion20.Length + 1;

    pStr->ps_Length = (BYTE)AfpVersion21.Length;
    RtlCopyMemory(pStr->ps_String, AfpVersion21.Buffer, AfpVersion21.Length);
    (PBYTE)pStr += AfpVersion21.Length + 1;

    pStr->ps_Length = (BYTE)AfpVersion22.Length;
    RtlCopyMemory(pStr->ps_String, AfpVersion22.Buffer, AfpVersion22.Length);
    (PBYTE)pStr += AfpVersion22.Length + 1;

    // We always support at least one UAM!
    PUTSHORT2SHORT(pStatusHeader->_UAMs, (USHORT)((PBYTE)pStr - (PBYTE)pStatusHeader));
    pNumUamPtr = (PBYTE)pStr;
    ((PBYTE)pStr)++;

    CountOfUams = 0;

    if (GuestAllowed)
    {
        pStr->ps_Length = (BYTE)AfpUamGuest.Length;
        RtlCopyMemory(pStr->ps_String, AfpUamGuest.Buffer,
                                                    AfpUamGuest.Length);
        (PBYTE)pStr += AfpUamGuest.Length + 1;
        CountOfUams++;
        Size += (AfpUamGuest.Length + 1);
    }
    else
    {
        DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
            ("AfpSetServerStatus: Guest is disabled\n"));
    }


    if (ClearTextAllowed)
    {
        pStr->ps_Length = (BYTE)AfpUamClearText.Length;
        RtlCopyMemory(pStr->ps_String, AfpUamClearText.Buffer,
                                                    AfpUamClearText.Length);
        (PBYTE)pStr += AfpUamClearText.Length + 1;
        CountOfUams++;
        Size += (AfpUamClearText.Length + 1);
    }
    else
    {
        DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
            ("AfpSetServerStatus: ClearText UAM is NOT configured\n"));
    }

    if (MicrosoftUamSupported)
    {
        // copy in "Microsoft V1.0" string
        pStr->ps_Length = (BYTE)AfpUamCustomV1.Length;
        RtlCopyMemory(pStr->ps_String, AfpUamCustomV1.Buffer, AfpUamCustomV1.Length);
        (PBYTE)pStr += AfpUamCustomV1.Length + 1;
        CountOfUams++;
        Size += (AfpUamCustomV1.Length + 1 + 1);

        // copy in "Microsoft V2.0" string
        pStr->ps_Length = (BYTE)AfpUamCustomV2.Length;
        RtlCopyMemory(pStr->ps_String, AfpUamCustomV2.Buffer, AfpUamCustomV2.Length);
        (PBYTE)pStr += AfpUamCustomV2.Length + 1;
        CountOfUams++;
        Size += (AfpUamCustomV2.Length + 1 + 1);

        // copy in "Microsoft V3.0" string
        pStr->ps_Length = (BYTE)AfpUamCustomV3.Length;
        RtlCopyMemory(pStr->ps_String, AfpUamCustomV3.Buffer, AfpUamCustomV3.Length);
        (PBYTE)pStr += AfpUamCustomV3.Length + 1;
        CountOfUams++;
        Size += (AfpUamCustomV3.Length + 1 + 1);
    }
    else
    {
        DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
            ("AfpSetServerStatus: Microsoft UAM is NOT configured\n"));
    }

    if (NativeAppleUamSupported)
    {
        DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
            ("AfpSetServerStatus: Apple's native UAM is configured\n"));

        pStr->ps_Length = (BYTE)AfpUamApple.Length;
        RtlCopyMemory(pStr->ps_String, AfpUamApple.Buffer, AfpUamApple.Length);
        (PBYTE)pStr += AfpUamApple.Length + 1;
        CountOfUams++;
        Size += (AfpUamApple.Length + 1 + 1);

// 2-way not included for now
#if ALLOW_2WAY_ASWELL
        pStr->ps_Length = (BYTE)AfpUamApple2Way.Length;
        RtlCopyMemory(pStr->ps_String, AfpUamApple2Way.Buffer, AfpUamApple2Way.Length);
        (PBYTE)pStr += AfpUamApple2Way.Length + 1;
        CountOfUams++;
        Size += (AfpUamApple2Way.Length + 1 + 1);
#endif
    }

    // how many UAM's are we telling the client we support
    *pNumUamPtr = CountOfUams;

    // now we know where Server signature goes: write the offset
    PUTSHORT2SHORT(pSignOffset,(USHORT)((PBYTE)pStr - (PBYTE)pStatusHeader));

    // copy the Server signature
    RtlCopyMemory((PBYTE)pStr, AfpServerSignature, 16);
    ((PBYTE)pStr) += 16;

    //
    // if we have network address(es), send that info over!
    //
    if ((IpAddrCount > 0) || (AfpServerBoundToAsp))
    {
        // now we know where Network Address Count Offset goes: write the offset
        PUTSHORT2SHORT(pNetAddrOffset,(USHORT)((PBYTE)pStr - (PBYTE)pStatusHeader));

        // how many addresses are we returning?
        *(PBYTE)pStr = ((BYTE)IpAddrCount) + ((AfpServerBoundToAsp) ? 1 : 0);
        ((PBYTE)pStr)++;

        // copy the ipaddresses, if bound
        if (IpAddrCount > 0)
        {
            // copy the blob containing the Length, Tag and Ipaddress info
            RtlCopyMemory((PBYTE)pStr, IpAddrBlob, IpAddrCount*DSI_NETWORK_ADDR_LEN);
            ((PBYTE)pStr) += (IpAddrCount*DSI_NETWORK_ADDR_LEN);
        }

        // now copy the appletalk addres, if bound
        if (AfpServerBoundToAsp)
        {
            *(PBYTE)pStr = DSI_NETWORK_ADDR_LEN;
            ((PBYTE)pStr)++;

            *(PBYTE)pStr = ATALK_NETWORK_ADDR_ATKTAG;
            ((PBYTE)pStr)++;

            PUTDWORD2DWORD((PBYTE)pStr, AfpAspEntries.asp_AtalkAddr.Address);

            ((PBYTE)pStr) += sizeof(DWORD);
        }
    }

    // Now get the volume icon, if any
    if (AfpServerIcon != NULL)
    {
        RtlCopyMemory((PBYTE)pStr, AfpServerIcon, ICONSIZE_ICN);
        PUTSHORT2SHORT(pStatusHeader->_VolumeIcon,
                (USHORT)((PBYTE)pStr - (PBYTE)pStatusHeader));
    }
    else PUTSHORT2SHORT(pStatusHeader->_VolumeIcon, 0);

    RELEASE_SPIN_LOCK(&AfpServerGlobalLock, OldIrql);

    if (AfpServerBoundToAsp)
    {
        Status = AfpSpSetAspStatus((PBYTE)pStatusHeader, Size);
    }

    if (AfpServerBoundToTcp)
    {
        Status2 = AfpSpSetDsiStatus((PBYTE)pStatusHeader, Size);

        // as long as one succeeds, we want the call to succeed
        if (!NT_SUCCESS(Status))
        {
            Status = Status2;
        }
    }

    AfpFreeMemory(pStatusHeader);

    if (IpAddrBlob)
    {
        AfpFreeMemory(IpAddrBlob);
    }

    return Status;
}



/***    AfpAdmWServerSetInfo
 *
 *  This routine sets various server globals with data supplied by the admin.  The
 *  following server globals are set by this routine:
 *
 *  - Server Name
 *  - Maximum Sessions (valid values are 1 through AFP_MAXSESSIONS)
 *  - Server Options (i.e. guest logon allowed, etc.)
 *  - Server Login Message
 *  - Maximum paged and non-paged memory limits
 *  - Macintosh Code Page File
 *
 *  The server name and memory limits can only be changed while the server
 *  is stopped. The Macintosh Code Page File may only be set ONE time after
 *  the AFP server driver is loaded. i.e. if you want to reset the codepage,
 *  the service must unload the AFP server, then reload it.
 *
 *  This routine must execute in the context of the worker thread, since we
 *  need to map the Macintosh CodePage into the server's virtual memory
 *  space, not the client's.
 *
 *  LOCKS: AfpServerGlobalLock (SPIN)
 */
AFPSTATUS
AfpAdmWServerSetInfo(
    IN  OUT PVOID   InBuf       OPTIONAL,
    IN  LONG        OutBufLen   OPTIONAL,
    OUT PVOID       OutBuf      OPTIONAL
)
{
    KIRQL           OldIrql;
    AFPSTATUS       rc;
    ANSI_STRING     amsg, aname;
    UNICODE_STRING  uname, umsg, oldloginmsgU;
    DWORD           parmflags = ((PSETINFOREQPKT)InBuf)->sirqp_parmnum;
    PAFP_SERVER_INFO pSvrInfo = (PAFP_SERVER_INFO)((PCHAR)InBuf+sizeof(SETINFOREQPKT));
    BOOLEAN         setstatus = False;
    BOOLEAN         locktaken = False;
    BOOLEAN         servernameexists = False;


    amsg.Length = 0;
    amsg.MaximumLength = 0;
    amsg.Buffer = NULL;

    aname.Length = 0;
    aname.MaximumLength = 0;
    aname.Buffer = NULL;

    AfpSetEmptyUnicodeString(&umsg, 0, NULL);
    AfpSetEmptyUnicodeString(&oldloginmsgU, 0, NULL);

    /* Validate all limits */
    if ((parmflags & ~AFP_SERVER_PARMNUM_ALL)           ||

        ((parmflags & AFP_SERVER_PARMNUM_OPTIONS) &&
         (pSvrInfo->afpsrv_options & ~AFP_SRVROPT_ALL)) ||

        ((parmflags & AFP_SERVER_PARMNUM_MAX_SESSIONS) &&
         ((pSvrInfo->afpsrv_max_sessions > AFP_MAXSESSIONS) ||
          (pSvrInfo->afpsrv_max_sessions == 0))))
    {
        DBGPRINT(DBG_COMP_ADMINAPI_SRV, DBG_LEVEL_ERR,
            ("AfpAdmWServerSetInfo: invalid parm!\n"));
        return AFPERR_InvalidParms_MaxSessions;
    }

    if (parmflags == AFP_SERVER_GUEST_ACCT_NOTIFY)
    {
        AfpServerOptions ^= AFP_SRVROPT_GUESTLOGONALLOWED;

        DBGPRINT(DBG_COMP_ADMINAPI_SRV, DBG_LEVEL_ERR,
            ("AfpAdmWServerSetInfo: Guest account is now %s\n",
            (AfpServerOptions & AFP_SRVROPT_GUESTLOGONALLOWED)? "enabled":"disabled"));

        AfpSetServerStatus();
        return(STATUS_SUCCESS);
    }

    if (parmflags & AFP_SERVER_PARMNUM_CODEPAGE)
    {
        // You may only set the Macintosh CodePage once
        if (AfpMacCPBaseAddress != NULL)
            return AFPERR_InvalidServerState;
        else
        {
            rc = AfpGetMacCodePage(pSvrInfo->afpsrv_codepage);
            if (!NT_SUCCESS(rc))
            {
                return AFPERR_CodePage;
            }
        }
    }

    if (parmflags & AFP_SERVER_PARMNUM_LOGINMSG)
    {
        RtlInitUnicodeString(&umsg, pSvrInfo->afpsrv_login_msg);
        if (umsg.Length == 0)
        {
            umsg.Buffer = NULL;
        }
        amsg.MaximumLength = (USHORT)RtlUnicodeStringToAnsiSize(&umsg);
        amsg.Length = amsg.MaximumLength - 1;

        if (amsg.Length > AFP_MESSAGE_LEN)
        {
            return AFPERR_InvalidParms_LoginMsg;
        }

        if (amsg.Length != 0)
        {
            if ((umsg.Buffer =
                    (LPWSTR)AfpAllocPagedMemory(umsg.Length+1)) == NULL)
            {
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            if ((amsg.Buffer =
                    (PCHAR)AfpAllocNonPagedMemory(amsg.MaximumLength)) == NULL)
            {
                AfpFreeMemory(umsg.Buffer);
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            RtlCopyMemory(umsg.Buffer, pSvrInfo->afpsrv_login_msg, umsg.Length);
            rc = RtlUnicodeStringToAnsiString(&amsg, &umsg, False);
            if (!NT_SUCCESS(rc))
            {
                AfpFreeMemory(amsg.Buffer);
                AfpFreeMemory(umsg.Buffer);
                return AFPERR_InvalidParms;
            }
            else AfpConvertHostAnsiToMacAnsi(&amsg);
        }
    }

    do
    {
        if (parmflags & AFP_SERVER_PARMNUM_NAME)
        {
            RtlInitUnicodeString(&uname,pSvrInfo->afpsrv_name);
            aname.MaximumLength = (USHORT)RtlUnicodeStringToAnsiSize(&uname);
            aname.Length = aname.MaximumLength - 1;

            if ((aname.Length == 0) || (aname.Length > AFP_SERVERNAME_LEN))
            {
                DBGPRINT(DBG_COMP_ADMINAPI_SRV, DBG_LEVEL_ERR,
                    ("AfpAdmWServerSetInfo: bad name length %d, rejecting\n,aname.Length"));
                rc = AFPERR_InvalidServerName_Length;
                break;
            }

            if ((aname.Buffer = AfpAllocNonPagedMemory(aname.MaximumLength)) == NULL)
            {
                DBGPRINT(DBG_COMP_ADMINAPI_SRV, DBG_LEVEL_ERR,
                    ("AfpAdmWServerSetInfo: malloc failed on name change\n"));
                rc = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }
            rc = AfpConvertStringToAnsi(&uname, &aname);
            if (!NT_SUCCESS(rc))
            {
                rc = AFPERR_InvalidServerName;
                DBGPRINT(DBG_COMP_ADMINAPI_SRV, DBG_LEVEL_ERR,
                    ("AfpAdmWServerSetInfo: AfpConvertStringToAnsi failed %lx\n",rc));
                break;
            }
        }

        rc = STATUS_SUCCESS;

        //
        // take the global data lock and set the new information
        //
        ACQUIRE_SPIN_LOCK(&AfpServerGlobalLock, &OldIrql);
        locktaken = True;

        // Validate if we are in the right state to receive some of the
        // parameters
        if ((AfpServerState != AFP_STATE_IDLE) &&
             (parmflags & (AFP_SERVER_PARMNUM_PAGEMEMLIM |
                          AFP_SERVER_PARMNUM_NONPAGEMEMLIM)))
        {
            DBGPRINT(DBG_COMP_ADMINAPI_SRV, DBG_LEVEL_ERR,
                ("AfpAdmWServerSetInfo: failure at 1\n"));

            rc = AFPERR_InvalidServerState;
            break;
        }

        else if ((AfpServerState == AFP_STATE_IDLE) &&
                 (parmflags & (AFP_SERVER_PARMNUM_NAME |
                          AFP_SERVER_PARMNUM_PAGEMEMLIM |
                          AFP_SERVER_PARMNUM_NONPAGEMEMLIM)) !=
                         (DWORD)(AFP_SERVER_PARMNUM_NAME |
                          AFP_SERVER_PARMNUM_PAGEMEMLIM |
                          AFP_SERVER_PARMNUM_NONPAGEMEMLIM))
        {
            DBGPRINT(DBG_COMP_ADMINAPI_SRV, DBG_LEVEL_ERR,
                ("AfpAdmWServerSetInfo: failure at 2\n"));

            rc = AFPERR_InvalidParms;
            break;
        }

        if (parmflags & (AFP_SERVER_PARMNUM_PAGEMEMLIM |
                         AFP_SERVER_PARMNUM_NONPAGEMEMLIM))
        {
            AfpPagedPoolLimit = pSvrInfo->afpsrv_max_paged_mem * 1024;
            AfpNonPagedPoolLimit = pSvrInfo->afpsrv_max_nonpaged_mem * 1024;
        }

        if (parmflags & AFP_SERVER_PARMNUM_NAME)
        {
            setstatus = ((AfpServerState == AFP_STATE_RUNNING) ||
                        (AfpServerState == AFP_STATE_START_PENDING));

            rc = STATUS_SUCCESS;
            if (AfpServerName.Buffer == NULL)
            {
                AfpServerName = aname;
            }
            else
            {
                servernameexists = True;
            }

            // Re-register the name only if the service up and running
            // No point registering the name on a service not functioning.
            // This causes problems as we falsely advertise
            // the AFP server in the browser when it is not really available.
            if (setstatus)
            {

                // deregister the old name, if one exists
                if ((AfpServerBoundToAsp) && (servernameexists))
                {
                    RELEASE_SPIN_LOCK(&AfpServerGlobalLock,OldIrql);
                    rc = AfpSpRegisterName(&AfpServerName, False);
                    ACQUIRE_SPIN_LOCK(&AfpServerGlobalLock, &OldIrql);

                    AfpFreeMemory(AfpServerName.Buffer);
                }

                AfpServerName = aname;

                // if deregister succeeded, register the new name
                if ((NT_SUCCESS(rc)) && (AfpServerBoundToAsp))
                {
                    RELEASE_SPIN_LOCK(&AfpServerGlobalLock,OldIrql);
                    rc = AfpSpRegisterName(&AfpServerName, True);
                    ACQUIRE_SPIN_LOCK(&AfpServerGlobalLock, &OldIrql);
                }

            }
        }

        if (parmflags & AFP_SERVER_PARMNUM_OPTIONS)
        {
            if (pSvrInfo->afpsrv_options & AFP_SRVROPT_STANDALONE)
            {
                // Server is NtProductServer or NtProductWinNt
                AfpServerIsStandalone = True;
                if (AfpSidNone == NULL)
                {
                    // If we didn't initialize the AfpSidNone during
                    // AfpInitSidOffsets then the service either sent
                    // us bogus offsets, or this bit is bogus
                    rc = AFPERR_InvalidParms;
                    break;
                }
                pSvrInfo->afpsrv_options &= ~AFP_SRVROPT_STANDALONE;
            }
            if (!setstatus)
            {
                setstatus =
                    (AfpServerOptions ^ pSvrInfo->afpsrv_options) ? True : False;
                setstatus = setstatus &&
                                ((AfpServerState == AFP_STATE_RUNNING) ||
                                 (AfpServerState == AFP_STATE_START_PENDING));
            }
            AfpServerOptions = pSvrInfo->afpsrv_options;
        }

        if (parmflags & AFP_SERVER_PARMNUM_LOGINMSG)
        {
            if (AfpLoginMsg.Buffer != NULL)
            {
                AfpFreeMemory(AfpLoginMsg.Buffer);
            }
            AfpLoginMsg = amsg;
            oldloginmsgU = AfpLoginMsgU;
            AfpLoginMsgU = umsg;
        }

        if (parmflags & AFP_SERVER_PARMNUM_MAX_SESSIONS)
        {
            if (AfpServerMaxSessions != pSvrInfo->afpsrv_max_sessions)
            {
                BOOLEAN KillSome;

                KillSome = (AfpServerMaxSessions > pSvrInfo->afpsrv_max_sessions);

                AfpServerMaxSessions = pSvrInfo->afpsrv_max_sessions;

                RELEASE_SPIN_LOCK(&AfpServerGlobalLock,OldIrql);
                locktaken = False;
            }
        }
    } while (False);

    if (locktaken)
    {
        RELEASE_SPIN_LOCK(&AfpServerGlobalLock,OldIrql);
    }

    if (!NT_SUCCESS(rc))
    {
        DBGPRINT(DBG_COMP_ADMINAPI_SRV, DBG_LEVEL_ERR,
            ("AfpAdmWServerSetInfo: returning %lx\n",rc));
        if (amsg.Buffer != NULL)
        {
            AfpFreeMemory(amsg.Buffer);
        }
        if (aname.Buffer != NULL)
        {
            if (AfpServerName.Buffer == aname.Buffer)
            {
                AfpServerName.Buffer = NULL;
                AfpServerName.MaximumLength = 0;
                AfpServerName.Length = 0;
            }
            AfpFreeMemory(aname.Buffer);
        }
    }
    else if (setstatus)
    {
        return (AfpSetServerStatus());
    }

    if (oldloginmsgU.Buffer != NULL)
        AfpFreeMemory(oldloginmsgU.Buffer);

    return rc;
}



/***    AfpCreateNewThread
 *
 *  Create either an admin or a worker thread.
 */
NTSTATUS FASTCALL
AfpCreateNewThread(
    IN  VOID    (*ThreadFunc)(IN PVOID pContext),
    IN  LONG    ThreadNum
)
{
    NTSTATUS            Status;
    HANDLE              FspThread;

    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("AfpCreateNewThread: Creating thread %lx\n", ThreadFunc));

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
    ASSERT ((AfpServerState == AFP_STATE_IDLE) ||
            (ThreadNum < AFP_MAX_THREADS) && (AfpNumThreads >= AFP_MIN_THREADS));
    Status = PsCreateSystemThread(&FspThread,
                                  THREAD_ALL_ACCESS,
                                  NULL,
                                  NtCurrentProcess(),
                                  NULL,
                                  ThreadFunc,
                                  (PVOID)((ULONG_PTR)ThreadNum));
    if (!NT_SUCCESS(Status))
    {
        DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_WARN,
                ("AfpCreateNewThread: Cannot create threads %lx\n", Status));
        AFPLOG_DDERROR(AFPSRVMSG_CREATE_THREAD, Status, NULL, 0, NULL);
    }
    else
    {
        // Close the handle to the thread so that it goes away when the
        // thread terminates
        NtClose(FspThread);
    }
    return Status;
}


/***    AfpQueueWorkItem
 *
 *  Queue a work item to the worker thread.
 *
 *  LOCKS:      AfpStatisticsLock
 */
VOID FASTCALL
AfpQueueWorkItem(
    IN  PWORK_ITEM      pWI
)
{
    KIRQL   OldIrql;

    ACQUIRE_SPIN_LOCK(&AfpStatisticsLock, &OldIrql);

    AfpServerStatistics.stat_CurrQueueLength ++;
#ifdef  PROFILING
    AfpServerProfile->perf_QueueCount ++;
#endif
    if (AfpServerStatistics.stat_CurrQueueLength > AfpServerStatistics.stat_MaxQueueLength)
        AfpServerStatistics.stat_MaxQueueLength++;

    RELEASE_SPIN_LOCK(&AfpStatisticsLock, OldIrql);

    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("AfpQueueWorkItem: Queueing %lx (%lx)\n",
            pWI->wi_Worker, pWI->wi_Context));

    INTERLOCKED_ADD_ULONG(&AfpWorkerRequests, 1, &AfpServerGlobalLock);

    // Insert work item in worker queue
    KeInsertQueue(&AfpWorkerQueue, &pWI->wi_List);
}


/***    AfpWorkerThread
 *
 *  This thread is used to do all the work that is queued to the FSP.
 *
 *  We want to dynamically create and destroy threads so that we can
 *  optimize the number of threads used. The number of threads range
 *  from AFP_MIN_THREADS - AFP_MAX_THREADS.
 *  A new thread is created if the number of entries in the queue
 *  exceeds AFP_THREAD_THRESHOLD_REQ. A thread is terminated if the request count
 *  drops below AFP_THREAD_THRESHOLD_IDLE.
 */
VOID
AfpWorkerThread(
    IN  PVOID   pContext
)
{
    NTSTATUS        Status;
    PLIST_ENTRY     pList;
    PWORK_ITEM      pWI;
    LONG            IdleCount = 0;
    LONG            ThreadNum, CreateId;
    ULONG           BasePriority = THREAD_BASE_PRIORITY_MAX;
    KIRQL           OldIrql;
    BOOLEAN         Release = False;
    BOOLEAN         ReasonToLive = True;

    ThreadNum = (LONG)(LONG_PTR)pContext;

    ASSERT (AfpThreadState[ThreadNum] == AFP_THREAD_STARTED);

    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_WARN,
            ("AfpWorkerThread: Thread %ld Starting. NumThreads %ld\n",
            ThreadNum, AfpNumThreads));

    // Update the thread statistics.
    ACQUIRE_SPIN_LOCK(&AfpStatisticsLock, &OldIrql);
    AfpServerStatistics.stat_CurrThreadCount ++;
    if (AfpServerStatistics.stat_CurrThreadCount > AfpServerStatistics.stat_MaxThreadCount)
        AfpServerStatistics.stat_MaxThreadCount = AfpServerStatistics.stat_CurrThreadCount;
    RELEASE_SPIN_LOCK(&AfpStatisticsLock, OldIrql);

    // Set the thread base priority to 'foreground'
    NtSetInformationThread( NtCurrentThread(),
                            ThreadBasePriority,
                            &BasePriority,
                            sizeof(BasePriority));

    // Disable hard-error pop-ups for this thread
    IoSetThreadHardErrorMode( FALSE );
    AfpThreadPtrsW[ThreadNum] = PsGetCurrentThread();

    do
    {
        AfpThreadState[ThreadNum] = AFP_THREAD_WAITING;

        DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
                ("AfpWorkerThread: About to block\n"));

// DELALLOCQUEUE: unrem the #if 0 part
#if 0
        //
        // first check if there is someone waiting to get buffer allocation:
        // let's deal with them first, so some connection doesn't get "blocked"
        // because transport underneath doesn't have buffer
        //
        pList = KeRemoveQueue(&AfpDelAllocQueue, KernelMode, NULL);
        if (pList != NULL)
        {
            AfpThreadState[ThreadNum] = AFP_THREAD_BUSY;

            pWI = CONTAINING_RECORD(pList, WORK_ITEM, wi_List);

            // Call the worker
            (pWI->wi_Worker)(pWI->wi_Context);

            IdleCount = 0;

            continue;
        }
#endif

        pList = KeRemoveQueue(&AfpWorkerQueue, KernelMode, &ThreeSecTimeOut);
        Status = STATUS_SUCCESS;
        if ((NTSTATUS)((ULONG_PTR)pList) == STATUS_TIMEOUT)
            Status = STATUS_TIMEOUT;

        DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
                ("AfpWorkerThread: %s\n",
                (Status == STATUS_SUCCESS) ? "Another Work item" : "Timer - check"));

        if (Status == STATUS_SUCCESS)
        {
            pWI = CONTAINING_RECORD(pList, WORK_ITEM, wi_List);

            if (pWI == &AfpTerminateThreadWI)
            {
                BOOLEAN Requeue;

                ReasonToLive = False;
                ACQUIRE_SPIN_LOCK(&AfpServerGlobalLock, &OldIrql);
                AfpNumThreads --;
                Requeue = (AfpNumThreads != 0);
                RELEASE_SPIN_LOCK(&AfpServerGlobalLock, OldIrql);

                AfpThreadState[ThreadNum] = AFP_THREAD_DEAD;
                if (!Requeue)
                {
                    ASSERT((AfpServerState == AFP_STATE_STOPPED) ||
                           (AfpServerState == AFP_STATE_IDLE));
                    Release = True;
                }
                else
                {
                    // Re-queue this work-item so that other threads can die too !!!
                    KeInsertQueue(&AfpWorkerQueue, &AfpTerminateThreadWI.wi_List);
                }
                break;
            }

            DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
                    ("AfpWorkerThread: Dispatching %lx (%lx)\n",
                    pWI->wi_Worker, pWI->wi_Context));

            AfpThreadState[ThreadNum] = AFP_THREAD_BUSY;
#if DBG
            AfpThreadDispCount[ThreadNum] ++;
#endif
            // Call the worker
            (pWI->wi_Worker)(pWI->wi_Context);

            ASSERT (KeGetCurrentIrql() < DISPATCH_LEVEL);

            INTERLOCKED_ADD_ULONG((PLONG)(&AfpServerStatistics.stat_CurrQueueLength),
                                    (ULONG)-1,
                                    &AfpStatisticsLock);

            INTERLOCKED_ADD_ULONG(&AfpWorkerRequests, (ULONG)-1, &AfpServerGlobalLock);
            IdleCount = 0;
        }
        else
        {
            IdleCount ++;
        }

        ACQUIRE_SPIN_LOCK(&AfpServerGlobalLock, &OldIrql);

        if (((AfpWorkerRequests - AfpNumThreads) > AFP_THREAD_THRESHOLD_REQS) &&
            (AfpNumThreads < AFP_MAX_THREADS))
        {
            for (CreateId = 0; CreateId < AFP_MAX_THREADS; CreateId++)
            {
                if (AfpThreadState[CreateId] == AFP_THREAD_DEAD)
                {
                    AfpThreadState[CreateId] = AFP_THREAD_STARTED;
                    break;
                }
            }

            if (CreateId < AFP_MAX_THREADS)
            {
                AfpNumThreads++;

                ASSERT (CreateId < AFP_MAX_THREADS);

                DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_WARN,
                        ("AfpWorkerThread: Creating New Thread %ld\n", CreateId));

                RELEASE_SPIN_LOCK(&AfpServerGlobalLock, OldIrql);
                Status = AfpCreateNewThread(AfpWorkerThread, CreateId);
                ACQUIRE_SPIN_LOCK(&AfpServerGlobalLock, &OldIrql);

                if (!NT_SUCCESS(Status))
                {
                    ASSERT(AfpThreadState[CreateId] == AFP_THREAD_STARTED);
                    AfpThreadState[CreateId] = AFP_THREAD_DEAD;
                    AfpNumThreads --;
                }
            }
        }
        else if ((AfpNumThreads > AFP_MIN_THREADS) &&
                 (IdleCount >= AFP_THREAD_THRESHOLD_IDLE))
        {
            ReasonToLive = False;
            AfpThreadState[ThreadNum] = AFP_THREAD_DEAD;
            AfpNumThreads --;
            DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_WARN,
                    ("AfpWorkerThread: Thread %ld About to commit suicide, NumThreads %ld\n",
                    ThreadNum, AfpNumThreads));
        }

        RELEASE_SPIN_LOCK(&AfpServerGlobalLock, OldIrql);

    } while (ReasonToLive);

    AfpThreadPtrsW[ThreadNum] = NULL;

    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_WARN,
            ("AfpWorkerThread: Thread %ld Quitting\n", ThreadNum));

    INTERLOCKED_ADD_ULONG((PLONG)&AfpServerStatistics.stat_CurrThreadCount,
                            (ULONG)-1,
                            &AfpStatisticsLock);

    // if this is the last thread in the system, set things up so that unload code
    // can wait on the pointer and know when this thread has really died and not just
    // when KeSetEvent is called
    if (Release)
    {
        AfpThreadPtrsW[ThreadNum] = PsGetCurrentThread();
        ObReferenceObject(AfpThreadPtrsW[ThreadNum]);

        KeSetEvent(&AfpStopConfirmEvent, IO_NETWORK_INCREMENT, False);
    }
}


/***    AfpInitStrings
 *
 *  Initializes all the strings
 */
VOID FASTCALL
AfpInitStrings(
    IN VOID
)
{
    // Initialize UAM Strings
    RtlInitString(&AfpUamGuest, NO_USER_AUTHENT_NAME);
    RtlInitString(&AfpUamClearText, CLEAR_TEXT_AUTHENT_NAME);
    RtlInitString(&AfpUamCustomV1, CUSTOM_UAM_NAME_V1);
    RtlInitString(&AfpUamCustomV2, CUSTOM_UAM_NAME_V2);
    RtlInitString(&AfpUamCustomV3, CUSTOM_UAM_NAME_V3);
    RtlInitString(&AfpUamApple, RANDNUM_EXCHANGE_NAME);
    RtlInitString(&AfpUamApple2Way, TWOWAY_EXCHANGE_NAME);

    // Initialize AFP Versions
    RtlInitString(&AfpVersion20, AFP_VER_20_NAME);
    RtlInitString(&AfpVersion21, AFP_VER_21_NAME);
    RtlInitString(&AfpVersion22, AFP_VER_22_NAME);

    // Default Workstation name
    RtlInitUnicodeString(&AfpDefaultWksta, AFP_DEFAULT_WORKSTATION);

    RtlInitUnicodeString(&AfpNetworkTrashNameU, AFP_NWTRASH_NAME_U);
}


/***    AfpAdmSystemShutdown
 *
 *  Called during system shutdown. Simply close all active sessions and stop the volumes.
 */
AFPSTATUS
AfpAdmSystemShutdown(
    IN  OUT PVOID   Inbuf       OPTIONAL,
    IN  LONG        OutBufLen   OPTIONAL,
    OUT PVOID       Outbuf      OPTIONAL
)
{
    AFP_SESSION_INFO    SessInfo;
    NTSTATUS            Status;

    if ((AfpServerState & ( AFP_STATE_STOPPED       |
                            AFP_STATE_STOP_PENDING  |
                            AFP_STATE_SHUTTINGDOWN)) == 0)
    {
        AfpServerState = AFP_STATE_SHUTTINGDOWN;

        DBGPRINT(DBG_COMP_ADMINAPI_SC, DBG_LEVEL_ERR,
                        ("AfpAdmSystemShutdown: Shutting down server\n"));

        // Disable listens now that we are about to stop
        AfpSpDisableListens();

        SessInfo.afpsess_id = 0;    // Shutdown all sessions
        AfpAdmWSessionClose(&SessInfo, 0, NULL);

        // Wait for the sessions to complete, if there were active sessions
        if (AfpNumSessions > 0) do
        {
            Status = AfpIoWait(&AfpStopConfirmEvent, &FiveSecTimeOut);
            if (Status == STATUS_TIMEOUT)
            {
                DBGPRINT(DBG_COMP_ADMINAPI_SC, DBG_LEVEL_ERR,
                        ("AfpAdmSystemShutdown: Timeout Waiting for %ld sessions to die, re-waiting\n",
                        AfpNumSessions));
            }
        } while (Status == STATUS_TIMEOUT);

        // bring down the DSI-TCP interface
        DsiDestroyAdapter();

        // wait until DSI cleans up its interface with TCP
        AfpIoWait(&DsiShutdownEvent, NULL);

        // Set the flag to indicate that server is shutting down
        fAfpServerShutdownEvent = TRUE;

        // Now tell each of the volume scavengers to shut-down
        AfpVolumeStopAllVolumes();
    }

    return AFP_ERR_NONE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\server\server.h ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

    server.h

Abstract:

    This module contains server definition and data structures relating to
    server class APIs.

Author:

    Jameel Hyder (microsoft!jameelh)


Revision History:
    25 Apr 1992     Initial Version

Notes:  Tab stop: 4
--*/

#ifndef _SERVER_
#define _SERVER_

// AfpGetSrvrMsg values
#define SRVRMSG_LOGIN               0
#define SRVRMSG_SERVER              1
#define SRVRMSG_BITMAP_MESSAGE      1

// Attention word definitions. These are the only one's used.
#define ATTN_SERVER_SHUTDOWN        0x8000
#define ATTN_USER_DISCONNECT        0x9000
#define ATTN_SERVER_MESSAGE         0x2000
#define ATTN_SERVER_NOTIFY          0x3001
#define ATTN_TIME_MASK              0x0FFF

// AfpGetUserInfo values
#define USERINFO_BITMAP_USERID      1
#define USERINFO_BITMAP_PRIGID      2
#define USERINFO_THISUSER           1

// AfpMapId subfunction values
#define MAP_USER_ID                 1
#define MAP_GROUP_ID                2
#define MAP_USER_NAME               3
#define MAP_GROUP_NAME              4

#define SRVRPARMS_VOLUMEHASPASS     0x80

// AfpGetSrvrInfo values
#define SRVRINFO_SUPPORTS_COPYFILE  0x0001
#define SRVRINFO_SUPPORTS_CHGPASSWD 0x0002
#define SRVRINFO_DISALLOW_SAVEPASS  0x0004
#define SRVRINFO_SUPPORTS_SERVERMSG 0x0008
#define SRVRINFO_SUPPORTS_SRVSIGN   0x0010
#define SRVRINFO_SUPPORTS_TCPIP     0x0020
#define SRVRINFO_SUPPORTS_SRVNOTIFY 0x0040
#define SRVRINFO_SUPPORTS_MGETREQS  0x8000
#define SRVRINFO_MASK               0x800F

// in hopes that we will save some network traffic, we delay server notification for
// some time, so if too many changes are happening (e.g. xcopy on that dir) then
// we send just one notification for several of the changes combined...
#define AFP_MIN_SRVR_NOTIF_INTERVAL 3

// at the same time, we don't want to not send a notification for too long
#define AFP_MAX_SRVR_NOTIF_INTERVAL 15

// Server State values.
#define AFP_STATE_IDLE              0xFF
#define AFP_STATE_STOPPED           0x00
#define AFP_STATE_STOP_PENDING      0x01
#define AFP_STATE_START_PENDING     0x02
#define AFP_STATE_RUNNING           0x04
#define AFP_STATE_PAUSE_PENDING     0x08
#define AFP_STATE_PAUSED            0x10
#define AFP_STATE_CONTINUE_PENDING  0x20
#define AFP_STATE_SHUTTINGDOWN      0x40
#define AFP_STATE_PENDING_ANY       (AFP_STATE_STOP_PENDING  | \
                                    AFP_STATE_START_PENDING | \
                                    AFP_STATE_PAUSE_PENDING | \
                                    AFP_STATE_CONTINUE_PENDING)

#define AFP_XLAT_TABLE_SIZE         128
#define AFP_REV_XLAT_TABLE_SIZE     256 - (0x80 - 0x20)

// all server global data must be non-pagable if it is protected by
// an executive spin-lock (i.e. accessed at IRQL DISPATCH_LEVEL)

GLOBAL  AFP_SPIN_LOCK           AfpServerGlobalLock EQU {0};
GLOBAL  AFP_SPIN_LOCK           AfpSwmrLock EQU {0};
GLOBAL  PBYTE                   AfpServerIcon EQU NULL;
GLOBAL  PANSI_STRING            AfpServerMsg EQU NULL;
GLOBAL  ANSI_STRING             AfpServerName EQU { 0, 0 , NULL};
GLOBAL  ANSI_STRING             AfpLoginMsg EQU { 0, 0 , NULL};
GLOBAL  UNICODE_STRING          AfpLoginMsgU EQU { 0, 0 , NULL};

// There is no lock protecting the following codepage related variables
GLOBAL	PBYTE					AfpTranslationTable EQU NULL;
GLOBAL	PBYTE					AfpRevTranslationTable EQU NULL;
GLOBAL	PUSHORT					AfpMacCPBaseAddress EQU NULL;
GLOBAL	CPTABLEINFO				AfpMacCPTableInfo EQU { 0 };

GLOBAL	DWORD					AfpServerState EQU AFP_STATE_IDLE;
GLOBAL	DWORD					AfpServerMaxSessions EQU AFP_MAXSESSIONS;
GLOBAL	KEVENT					AfpStopConfirmEvent EQU { 0 };
GLOBAL	KMUTEX					AfpPgLkMutex EQU { 0 };
GLOBAL	DWORD					AfpServerOptions EQU AFP_SRVROPT_NONE;
GLOBAL	PDEVICE_OBJECT			AfpDeviceObject EQU NULL;
GLOBAL	BOOLEAN					AfpServerIsStandalone EQU { 0 };
GLOBAL	BOOLEAN					AfpServerIsGreek EQU { 0 };

GLOBAL  LONG                    AfpEtcMapCount EQU 0;   // # valid entries
GLOBAL  LONG                    AfpEtcMapsSize EQU 0;   // # entries allocated
GLOBAL  struct _EtcMapInfo *    AfpEtcMaps EQU NULL;    // array of entries
GLOBAL  struct _EtcMapInfo      AfpDefaultEtcMap EQU { 0 };
GLOBAL  SWMR                    AfpEtcMapLock EQU { 0 };

GLOBAL  DWORD                   AfpSecondsSinceEpoch EQU 0;
#ifdef USE_OBSOLETE_LSA_API
GLOBAL  HANDLE                  AfpLsaHandle EQU NULL;
#endif

GLOBAL  CredHandle                              AfpSecHandle EQU {0, 0};
GLOBAL  HANDLE                  AfpFspToken EQU NULL;

#ifdef OPTIMIZE_GUEST_LOGONS
GLOBAL  HANDLE                  AfpGuestToken EQU NULL;
#endif

GLOBAL  ULONG                                   EncryptionKeyCount EQU 0;
GLOBAL  PEPROCESS               AfpProcessObject EQU NULL;
GLOBAL  DWORD                   AfpAuthenticationPackage EQU 0;
GLOBAL  PETHREAD                AfpThread EQU NULL;

GLOBAL  AFP_SPIN_LOCK               AfpStatisticsLock EQU {0};
GLOBAL  AFP_STATISTICS_INFO_EX  AfpServerStatistics EQU { 0 };

GLOBAL  DWORD                   AfpSrvrNotifSentTime EQU 0;
GLOBAL  BOOLEAN                 fAfpServerShutdownEvent EQU FALSE;
GLOBAL  BOOLEAN                 fAfpAdminStop EQU FALSE;

#ifdef  PROFILING
GLOBAL  PAFP_PROFILE_INFO       AfpServerProfile EQU NULL;
#endif

GLOBAL  DWORD                   AfpPagedPoolLimit EQU AFP_DEF_MAXPAGEDMEM * 1024;
GLOBAL  DWORD                   AfpNonPagedPoolLimit EQU AFP_DEF_MAXNONPAGEDMEM * 1024;
GLOBAL  SECURITY_QUALITY_OF_SERVICE AfpSecurityQOS EQU { 0 };
GLOBAL  ANSI_STRING             AfpVersions[AFP_NUM_VERSIONS] EQU { 0 };

#define AfpVersion20            AfpVersions[AFP_VER_20]
#define AfpVersion21            AfpVersions[AFP_VER_21]
#define AfpVersion22            AfpVersions[AFP_VER_22]

GLOBAL  ANSI_STRING             AfpUamStrings[AFP_NUM_UAMS] EQU { 0 };

#define AfpUamGuest             AfpUamStrings[NO_USER_AUTHENT]
#define AfpUamClearText         AfpUamStrings[CLEAR_TEXT_AUTHENT]
#define AfpUamCustomV1          AfpUamStrings[CUSTOM_UAM_V1]
#define AfpUamCustomV2          AfpUamStrings[CUSTOM_UAM_V2]
#define AfpUamCustomV3          AfpUamStrings[CUSTOM_UAM_V3]
#define AfpUamApple             AfpUamStrings[RANDNUM_EXCHANGE]
#define AfpUamApple2Way         AfpUamStrings[TWOWAY_EXCHANGE]

GLOBAL  LARGE_INTEGER           FiveSecTimeOut  EQU {0, 0};
GLOBAL  LARGE_INTEGER           ThreeSecTimeOut EQU {0, 0};
GLOBAL  LARGE_INTEGER           TwoSecTimeOut   EQU {0, 0};
GLOBAL  LARGE_INTEGER           OneSecTimeOut   EQU {0, 0};
GLOBAL  LARGE_INTEGER           LIZero          EQU {0, 0};
GLOBAL  UNICODE_STRING          UNullString     EQU {0, 0, NULL};

GLOBAL  BYTE                    AfpServerSignature[16] EQU {0};

#define THREAD_BASE_PRIORITY_MAX    2   // maximum thread base priority boost

// To manage our own threads
#define AFP_MIN_THREADS                 3   // Independent of processors
#define AFP_MAX_THREADS                 200 // Independent of processors
#define NUM_NOTIFY_QUEUES               2   // # of change notify threads

#define AFP_THREAD_THRESHOLD_REQS       2
#define AFP_THREAD_THRESHOLD_IDLE       8

typedef BYTE    THREAD_STATE, *PTHREAD_STATE;

typedef LONG    (FASTCALL *WORKER)(IN PVOID);

#define AFP_THREAD_DEAD                 0
#define AFP_THREAD_STARTED              1
#define AFP_THREAD_WAITING              2
#define AFP_THREAD_BUSY                 3

typedef struct
{
    LIST_ENTRY  wi_List;
    WORKER      wi_Worker;
    PVOID       wi_Context;
} WORK_ITEM, *PWORK_ITEM;

GLOBAL  WORK_ITEM               AfpTerminateThreadWI EQU { 0 };

#define AfpInitializeWorkItem(pWI, Worker, Context) \
        {                                           \
            InitializeListHead(&(pWI)->wi_List);    \
            (pWI)->wi_Worker = (WORKER)(Worker);    \
            (pWI)->wi_Context = (Context);          \
        }

GLOBAL  THREAD_STATE        AfpThreadState[AFP_MAX_THREADS] EQU { AFP_THREAD_DEAD };
GLOBAL  PETHREAD            AfpThreadPtrsW[AFP_MAX_THREADS] EQU { NULL };
GLOBAL  PETHREAD            AfpThreadPtrsN[NUM_NOTIFY_QUEUES] EQU { NULL };

#if DBG
GLOBAL  LONG                AfpThreadDispCount[AFP_MAX_THREADS] EQU { 0 };
GLOBAL  AFP_SPIN_LOCK       AfpDebugSpinLock EQU {0};
GLOBAL  LIST_ENTRY          AfpDebugDelAllocHead;

GLOBAL  DWORD               AfpReadCMAlloced   EQU {0};
GLOBAL  DWORD               AfpWriteCMAlloced  EQU {0};
GLOBAL  DWORD               AfpDbgMdlsAlloced  EQU 0;
GLOBAL  DWORD               AfpDbgIrpsAlloced  EQU 0;

#define AFP_DBG_INC_COUNT(_Val)                         \
{                                                       \
    KIRQL       _OldIrql;                               \
    ACQUIRE_SPIN_LOCK(&AfpDebugSpinLock, &_OldIrql);    \
    _Val++;                                             \
    RELEASE_SPIN_LOCK(&AfpDebugSpinLock, _OldIrql);     \
}
#define AFP_DBG_DEC_COUNT(_Val)                         \
{                                                       \
    KIRQL       _OldIrql;                               \
    ACQUIRE_SPIN_LOCK(&AfpDebugSpinLock, &_OldIrql);    \
    if (_Val == 0)                                      \
    {                                                   \
        DbgPrint("How come this is 0!!\n");             \
        DbgBreakPoint();                                \
    }                                                   \
    _Val--;                                             \
    RELEASE_SPIN_LOCK(&AfpDebugSpinLock, _OldIrql);     \
}
#else
#define AFP_DBG_INC_COUNT(_Val)
#define AFP_DBG_DEC_COUNT(_Val)
#endif

GLOBAL  LONG                AfpLockCount        EQU 0;
GLOBAL  PVOID               AfpLockHandle       EQU NULL;
GLOBAL  LONG                AfpWorkerRequests   EQU 0;
GLOBAL  LONG                AfpNumThreads       EQU 0;
GLOBAL  LONG                AfpNumNotifyThreads EQU 0;
GLOBAL  LONG                AfpNumAdminThreads  EQU 0;
GLOBAL  KQUEUE              AfpWorkerQueue      EQU { 0 };
GLOBAL  KQUEUE              AfpDelAllocQueue    EQU { 0 };
GLOBAL  KQUEUE              AfpAdminQueue       EQU { 0 };

GLOBAL  BOOLEAN             AfpIsMachineLittleEndian EQU True;

GLOBAL  HANDLE              AfpTdiNotificationHandle EQU NULL;
GLOBAL  BOOLEAN             AfpServerBoundToAsp      EQU FALSE;
GLOBAL  BOOLEAN             AfpServerBoundToTcp      EQU FALSE;

typedef AFPSTATUS           (FASTCALL *AFPAPIWORKER)  (IN struct _SessDataArea *);
typedef AFPSTATUS           (*ADMINAPIWORKER)(IN PVOID, IN LONG, OUT PVOID);

typedef NTSTATUS            (*AFPINITSUBS)  (VOID);
typedef VOID                (*AFPDEINITSUBS)(VOID);

#define AFPAttachProcess(_CurrProc)                   \
{                                                     \
    if ((_CurrProc) != AfpProcessObject)  \
    {                                                 \
        KeAttachProcess( (PRKPROCESS)AfpProcessObject );\
    }                                                 \
}

#define AFPDetachProcess(_CurrProc)                   \
{                                                     \
    if ((_CurrProc) != AfpProcessObject)  \
    {                                                 \
        KeDetachProcess();                            \
    }                                                 \
}

#define AFP_KEYPATH_SERVER_PARAMS_GREEK \
 TEXT("\\REGISTRY\\MACHINE\\SYSTEM\\CurrentControlSet\\Services\\MacFile\\Parameters")
#define AFPREG_VALNAME_GreekServer          TEXT("GreekServer")

extern
NTSTATUS
AfpInitializeDataAndSubsystems(
    VOID
);

extern
VOID
AfpDeinitializeSubsystems(
    VOID
);

extern
VOID FASTCALL
AfpUnmarshallReq(
    IN  struct _SessDataArea *  pSda
);

extern
VOID FASTCALL
AfpDisposeRequest(
    IN  struct _SessDataArea *  pSda,
    IN  AFPSTATUS               RetCode
);

extern
VOID FASTCALL
AfpStartApiProcessing(
    IN  struct _SessDataArea *  pSda
);

extern
VOID FASTCALL
AfpCompleteApiProcessing(
    IN  struct _SessDataArea *  pSda,
    IN  AFPSTATUS               RetCode
);

extern
NTSTATUS FASTCALL
AfpGetWriteBuffer(
    IN  struct _SessDataArea *  pSda,
    IN  PREQUEST                pRequest
);

extern
NTSTATUS
AfpSetServerStatus(
    IN VOID
);

extern
AFPSTATUS
AfpAdmWServerSetInfo(
    IN  OUT PVOID               Inbuf       OPTIONAL,
    IN  LONG                    OutBufLen   OPTIONAL,
    OUT PVOID                   Outbuf      OPTIONAL
);


extern
NTSTATUS FASTCALL
AfpCreateNewThread(
    IN  VOID                    (*ThreadFunc)(IN PVOID pContext),
    IN  LONG                    ThreadNum
);


extern
VOID FASTCALL
AfpInitStrings(
    IN VOID
);


extern
VOID
AfpWorkerThread(
    IN  PVOID                   pContext
);

extern
VOID FASTCALL
AfpQueueWorkItem(
    IN  PWORK_ITEM              pWI
);

extern
VOID
AfpSleepAWhile(
    IN  DWORD                   SleepDuration
);

#ifdef  SERVER_LOCALS

#define NUM_INIT_SYSTEMS        11

typedef struct _AfpInitSystems
{
    AFPINITSUBS     InitRoutine;
    AFPDEINITSUBS   DeInitRoutine;
#if DBG
    BOOLEAN         Initialized;
    BOOLEAN         Deinitialized;
    PCHAR           InitRoutineName;
    PCHAR           DeInitRoutineName;
#endif
} INIT_SYSTEMS, *PINIT_SYSTEMS;

extern  INIT_SYSTEMS    AfpInitSubSystems[];

extern
VOID FASTCALL
afpQueueDeferredRequest(
    IN  struct _SessDataArea *  pSda,
    IN  PREQUEST                pRequest
);

#endif  // SERVER_LOCALS

#endif  // _SERVER_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\server\swmr.c ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	swmr.c

Abstract:

	This module contains the single-writer, multi-reader semaphore routines
	and the lock-list-count routines.

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	25 Apr 1992		Initial Version

Notes:	Tab stop: 4
--*/

#define	FILENUM	FILE_SWMR

#include <afp.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, AfpSwmrInitSwmr)
#endif

/***	AfpSwmrInitSwmr
 *
 *	Initialize the access data structure. Involves initialization of the spin
 *	lock and the shared and exclusive semaphores. All counts are zeroed.
 */
VOID FASTCALL FASTCALL
AfpSwmrInitSwmr(
	IN OUT	PSWMR	pSwmr
)
{
#if DBG
	pSwmr->Signature = SWMR_SIGNATURE;
#endif
	pSwmr->swmr_cOwnedExclusive = 0;
	pSwmr->swmr_cExclWaiting = 0;
	pSwmr->swmr_cSharedOwners = 0;
	pSwmr->swmr_cSharedWaiting = 0;
	pSwmr->swmr_ExclusiveOwner = NULL;
	KeInitializeSemaphore(&pSwmr->swmr_SharedSem, 0, MAXLONG);
	KeInitializeSemaphore(&pSwmr->swmr_ExclSem, 0, MAXLONG);
}


/***	AfpSwmrAcquireShared
 *
 *	Take the semaphore for shared access.
 */
VOID FASTCALL
AfpSwmrAcquireShared(
	IN	PSWMR	pSwmr
)
{
	NTSTATUS	Status;
	KIRQL		OldIrql;
#ifdef	PROFILING
	TIME		TimeS, TimeE, TimeD;
#endif

	ASSERT (VALID_SWMR(pSwmr));

	// This should never be called at DISPATCH_LEVEL
	ASSERT (KeGetCurrentIrql() < DISPATCH_LEVEL);

	ACQUIRE_SPIN_LOCK(&AfpSwmrLock, &OldIrql);

	if ((pSwmr->swmr_cOwnedExclusive > 0) ||
		(pSwmr->swmr_cExclWaiting != 0))
	{
		pSwmr->swmr_cSharedWaiting++;
		RELEASE_SPIN_LOCK(&AfpSwmrLock, OldIrql);

		DBGPRINT(DBG_COMP_LOCKS, DBG_LEVEL_INFO,
				("AfpSwmrAcquireShared: Blocking for Shared %lx\n", pSwmr));

#ifdef	PROFILING
		AfpGetPerfCounter(&TimeS);
#endif

		do
		{
			Status = AfpIoWait(&pSwmr->swmr_SharedSem, &FiveSecTimeOut);
			if (Status == STATUS_TIMEOUT)
			{
				DBGPRINT(DBG_COMP_ADMINAPI_SC, DBG_LEVEL_INFO,
						("AfpSwmrAcquireShared: Timeout Waiting for Shared acess, re-waiting (%lx)\n", pSwmr));
			}
		} while (Status == STATUS_TIMEOUT);
		ASSERT (pSwmr->swmr_cOwnedExclusive == 0);
		ASSERT (pSwmr->swmr_cSharedOwners != 0);

#ifdef	PROFILING
		AfpGetPerfCounter(&TimeE);
		TimeD.QuadPart = TimeE.QuadPart - TimeS.QuadPart;
		INTERLOCKED_INCREMENT_LONG(&AfpServerProfile->perf_SwmrWaitCount);
		INTERLOCKED_ADD_LARGE_INTGR(&AfpServerProfile->perf_SwmrWaitTime,
									 TimeD,
									 &AfpStatisticsLock);
#endif
	}
	else // Its either free or shared owners are present with no exclusive waiters
	{
		pSwmr->swmr_cSharedOwners++;
		RELEASE_SPIN_LOCK(&AfpSwmrLock, OldIrql);
	}
#ifdef	PROFILING
	AfpGetPerfCounter(&TimeE);
	TimeE.QuadPart = -(TimeE.QuadPart);
	INTERLOCKED_ADD_LARGE_INTGR(&AfpServerProfile->perf_SwmrLockTimeR,
								 TimeE,
								 &AfpStatisticsLock);
	INTERLOCKED_INCREMENT_LONG(&AfpServerProfile->perf_SwmrLockCountR);
#endif
}


/***	AfpSwmrAcquireExclusive
 *
 *	Take the semaphore for exclusive access.
 */
VOID FASTCALL
AfpSwmrAcquireExclusive(
	IN	PSWMR	pSwmr
)
{
	NTSTATUS	Status;
	KIRQL		OldIrql;
#ifdef	PROFILING
	TIME		TimeS, TimeE, TimeD;
#endif

	ASSERT (VALID_SWMR(pSwmr));

	// This should never be called at DISPATCH_LEVEL
	ASSERT (KeGetCurrentIrql() < DISPATCH_LEVEL);

	ACQUIRE_SPIN_LOCK(&AfpSwmrLock, &OldIrql);

	// If the exclusive access is already granted, Check if it is
	// the same thread requesting. If so grant it.
	if ((pSwmr->swmr_cOwnedExclusive != 0) &&
		(pSwmr->swmr_ExclusiveOwner == PsGetCurrentThread()))
	{
		pSwmr->swmr_cOwnedExclusive ++;
		RELEASE_SPIN_LOCK(&AfpSwmrLock, OldIrql);
	}
	
	else if ((pSwmr->swmr_cOwnedExclusive > 0)	||
			 (pSwmr->swmr_cExclWaiting != 0)	||
			 (pSwmr->swmr_cSharedOwners != 0))
	{
		pSwmr->swmr_cExclWaiting++;
		RELEASE_SPIN_LOCK(&AfpSwmrLock, OldIrql);

		DBGPRINT(DBG_COMP_LOCKS, DBG_LEVEL_INFO,
				("AfpSwmrAcquireExclusive: Blocking for exclusive %lx\n", pSwmr));

#ifdef	PROFILING
		AfpGetPerfCounter(&TimeS);
#endif
		do
		{
			Status = AfpIoWait(&pSwmr->swmr_ExclSem, &FiveSecTimeOut);
			if (Status == STATUS_TIMEOUT)
			{
				DBGPRINT(DBG_COMP_ADMINAPI_SC, DBG_LEVEL_INFO,
						("AfpSwmrAcquireExclusive: Timeout Waiting for exclusive acess, re-waiting\n"));
			}
		} while (Status == STATUS_TIMEOUT);
		ASSERT (pSwmr->swmr_cOwnedExclusive == 1);
		pSwmr->swmr_ExclusiveOwner = PsGetCurrentThread();

#ifdef	PROFILING
		AfpGetPerfCounter(&TimeE);
		TimeD.QuadPart = TimeE.QuadPart - TimeS.QuadPart;
		INTERLOCKED_INCREMENT_LONG(&AfpServerProfile->perf_SwmrWaitCount);
		INTERLOCKED_ADD_LARGE_INTGR(&AfpServerProfile->perf_SwmrWaitTime,
									 TimeD,
									 &AfpStatisticsLock);
#endif
	}
	else // it is free
	{
		pSwmr->swmr_cOwnedExclusive ++;

		ASSERT(pSwmr->swmr_ExclusiveOwner == NULL);
		pSwmr->swmr_ExclusiveOwner = PsGetCurrentThread();
		RELEASE_SPIN_LOCK(&AfpSwmrLock, OldIrql);
	}
#ifdef	PROFILING
	AfpGetPerfCounter(&TimeE);
	TimeE.QuadPart = -(TimeE.QuadPart);
	INTERLOCKED_ADD_LARGE_INTGR(&AfpServerProfile->perf_SwmrLockTimeW,
								 TimeE,
								 &AfpStatisticsLock);
	INTERLOCKED_INCREMENT_LONG(&AfpServerProfile->perf_SwmrLockCountW);
#endif
}


/***	AfpSwmrRelease
 *
 *	Release the specified access. It is assumed that the current thread had
 *	called AfpSwmrAcquirexxxAccess() before this is called. If the SWMR is owned
 *	exclusively, then there cannot possibly be any shared owners active. When releasing
 *	the swmr, we first check for exclusive waiters before shared waiters.
 */
VOID FASTCALL
AfpSwmrRelease(
	IN	PSWMR	pSwmr
)
{
	KIRQL	OldIrql;
#ifdef	PROFILING
	TIME	Time;
	BOOLEAN	Exclusive = False;
#endif
    BOOLEAN fWasShared=FALSE;

	ASSERT (VALID_SWMR(pSwmr));

	ACQUIRE_SPIN_LOCK(&AfpSwmrLock, &OldIrql);
	if (pSwmr->swmr_cOwnedExclusive > 0)
	{
		ASSERT((pSwmr->swmr_cSharedOwners == 0) &&
			   (pSwmr->swmr_ExclusiveOwner == PsGetCurrentThread()));
		pSwmr->swmr_cOwnedExclusive--;
		if (pSwmr->swmr_cOwnedExclusive == 0)
			pSwmr->swmr_ExclusiveOwner = NULL;
#ifdef	PROFILING
		Exclusive = True;
#endif
	}
	else if (pSwmr->swmr_cSharedOwners != 0)
	{
	    // Was owned for shared access
		pSwmr->swmr_cSharedOwners--;
        fWasShared = TRUE;
	}
	else
	{
		// Releasing w/o acquiring ?
		KeBugCheck(0);
	}

	// If there are shared owners present then we are done. Else check for any
	// waiting shared/exclusive waiters
	if ((pSwmr->swmr_cOwnedExclusive == 0) && (pSwmr->swmr_cSharedOwners == 0))
	{
		if ( (pSwmr->swmr_cExclWaiting) &&
             (fWasShared || (!pSwmr->swmr_cSharedWaiting)) )
		{
			ASSERT(pSwmr->swmr_cOwnedExclusive == 0);
			pSwmr->swmr_cOwnedExclusive = 1;
			pSwmr->swmr_cExclWaiting--;

			DBGPRINT(DBG_COMP_LOCKS, DBG_LEVEL_INFO,
						("AfpSwmrReleasAccess: Waking exclusive waiter %lx\n", pSwmr));

			// Wake up the first exclusive waiter. Everybody else coming in will
			// see the access is busy.
			KeReleaseSemaphore(&pSwmr->swmr_ExclSem,
							   SEMAPHORE_INCREMENT,
							   1,
							   False);
		}
		else if (pSwmr->swmr_cSharedWaiting)
		{
			pSwmr->swmr_cSharedOwners = pSwmr->swmr_cSharedWaiting;
			pSwmr->swmr_cSharedWaiting = 0;

			DBGPRINT(DBG_COMP_LOCKS, DBG_LEVEL_INFO,
						("AfpSwmrReleasAccess: Waking %d shared owner(s) %lx\n",
						pSwmr->swmr_cSharedOwners, pSwmr));

			KeReleaseSemaphore(&pSwmr->swmr_SharedSem,
							   SEMAPHORE_INCREMENT,
							   pSwmr->swmr_cSharedOwners,
							   False);
		}
	}
	RELEASE_SPIN_LOCK(&AfpSwmrLock, OldIrql);
#ifdef	PROFILING
	AfpGetPerfCounter(&Time);
	INTERLOCKED_ADD_LARGE_INTGR(Exclusive ?
									&AfpServerProfile->perf_SwmrLockTimeW :
									&AfpServerProfile->perf_SwmrLockTimeR,
								 Time,
								 &AfpStatisticsLock);
#endif
}


/***	AfpSwmrUpgradeAccess
 *
 *	The caller currently has shared access. Upgrade him to exclusive, if possible.
 */
BOOLEAN FASTCALL
AfpSwmrUpgradeToExclusive(
	IN	PSWMR	pSwmr
)
{
	KIRQL	OldIrql;
	BOOLEAN	RetCode = False;		// Assume failed

	ASSERT (VALID_SWMR(pSwmr));

	ASSERT((pSwmr->swmr_cOwnedExclusive == 0) && (pSwmr->swmr_cSharedOwners != 0));

	ACQUIRE_SPIN_LOCK(&AfpSwmrLock, &OldIrql);
	if (pSwmr->swmr_cSharedOwners == 1)		// Possible if there are no more shared owners
	{
		pSwmr->swmr_cSharedOwners = 0;
		pSwmr->swmr_cOwnedExclusive = 1;
        pSwmr->swmr_ExclusiveOwner = PsGetCurrentThread();
		RetCode = True;
#ifdef	PROFILING
		INTERLOCKED_INCREMENT_LONG(&AfpServerProfile->perf_SwmrUpgradeCount);
#endif
	}
	RELEASE_SPIN_LOCK(&AfpSwmrLock, OldIrql);

	return RetCode;
}


/***	AfpSwmrDowngradeAccess
 *
 *	The caller currently has exclusive access. Downgrade him to shared.
 */
VOID FASTCALL
AfpSwmrDowngradeToShared(
	IN	PSWMR	pSwmr
)
{
	KIRQL	OldIrql;
	int		cSharedWaiting;

	ASSERT (VALID_SWMR(pSwmr));

	ASSERT((pSwmr->swmr_cOwnedExclusive == 1) &&
		   (pSwmr->swmr_ExclusiveOwner == PsGetCurrentThread()) &&
		   (pSwmr->swmr_cSharedOwners == 0));

	ACQUIRE_SPIN_LOCK(&AfpSwmrLock, &OldIrql);
	pSwmr->swmr_cOwnedExclusive = 0;
    pSwmr->swmr_ExclusiveOwner = NULL;
	pSwmr->swmr_cSharedOwners = 1;
	if (cSharedWaiting = pSwmr->swmr_cSharedWaiting)
	{
		pSwmr->swmr_cSharedOwners += (BYTE)cSharedWaiting;
		pSwmr->swmr_cSharedWaiting = 0;

		DBGPRINT(DBG_COMP_LOCKS, DBG_LEVEL_INFO,
					("AfpSwmrDowngradeAccess: Waking %d Reader(s) %lx\n",
					cSharedWaiting, pSwmr));

		KeReleaseSemaphore(&pSwmr->swmr_SharedSem,
						SEMAPHORE_INCREMENT,
						cSharedWaiting,
						False);
	}
	RELEASE_SPIN_LOCK(&AfpSwmrLock, OldIrql);
#ifdef	PROFILING
	INTERLOCKED_INCREMENT_LONG(&AfpServerProfile->perf_SwmrDowngradeCount);
#endif
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\server\swmr.h ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	swmr.h

Abstract:

	This module contains the Single writer-Multi reader access structures
	Also the lock-list-count structures.

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	25 Apr 1992		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef _SWMR_
#define _SWMR_

#if DBG
#define	SWMR_SIGNATURE		*(DWORD *)"SWMR"
#define	VALID_SWMR(pSwmr)	(((pSwmr) != NULL) && \
							 ((pSwmr)->Signature == SWMR_SIGNATURE))
#else
#define	VALID_SWMR(pSwmr)	((pSwmr) != NULL)
#endif

#define SWMR_SOMEONE_WAITING( _pSwmr ) ((_pSwmr)->swmr_cExclWaiting || \
                                        (_pSwmr)->swmr_cSharedWaiting)
typedef struct _SingleWriterMultiReader
{
#if	DBG
	DWORD		Signature;
#endif
	BYTE		swmr_cOwnedExclusive;	// # of times a single thread has owned it exclusively
	BYTE		swmr_cExclWaiting;		// Number of writers waiting
	BYTE		swmr_cSharedOwners;		// Count of threads owning shared access
	BYTE		swmr_cSharedWaiting;	// Count of threads waiting for shared access
	PETHREAD	swmr_ExclusiveOwner;	// Owning thread for exclusive access
	KSEMAPHORE	swmr_ExclSem;			// semaphore for Exclusive owners
	KSEMAPHORE	swmr_SharedSem;			// Semaphore for Shared owners
} SWMR, *PSWMR;

extern
VOID FASTCALL
AfpSwmrInitSwmr(
	IN OUT	PSWMR	pSwmr
);

extern
VOID FASTCALL
AfpSwmrAcquireShared(
	IN	PSWMR	pSwmr
);

VOID FASTCALL
AfpSwmrAcquireExclusive(
	IN	PSWMR	pSwmr
);

extern
VOID FASTCALL
AfpSwmrRelease(
	IN	PSWMR	pSwmr
);

extern
BOOLEAN FASTCALL
AfpSwmrUpgradeToExclusive(
	IN	PSWMR	pSwmr
);

extern
VOID FASTCALL
AfpSwmrDowngradeToShared(
	IN	PSWMR	pSwmr
);

#define	AfpSwmrLockedShared(pSwmr)		\
					(((pSwmr)->swmr_cSharedOwners != 0) && \
					 ((pSwmr)->swmr_cOwnedExclusive == 0))
										
#define	AfpSwmrLockedExclusive(pSwmr)	\
					(((pSwmr)->swmr_cOwnedExclusive != 0) && \
					 ((pSwmr)->swmr_ExclusiveOwner == PsGetCurrentThread()))

#endif	// _SWMR_


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\server\secutil.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

	secutil.c

Abstract:

	This module contains code to accomplish the following tasks:

	1) Translate a SID to a name.
	2) Translate a name to a SID.
	3) Change the password for a given user.
	4) Translate a SID to a Mac Id.
	5) Translate a Mac Id to a SID.
	6) Server event logging

	This module communicates with the AFP Server Service to accomplish these
	functions. The real work is done in the Server Service. This utility
	exists because these functions cannot be made by calling APIs in kernel
	mode.

	The basic flow of control begins with an FSCTL from the server service.
	This FSCTL is marked as pending till one of the four functions is to be
	carried out. Then the IRP output buffer contains the function ID and
	function input data and the IRP is maeked as complete. The actual
	function is executed by the server service and the results are obtained
	by the server FSD via the next FSCTL. Most if this information is cached
	in paged-memory.


Author:

	Narendra Gidwani (microsoft!nareng)

Revision History:
	8	Sept 1992 		Initial Version
	28	Jan	 1993		SueA - added support for server event logging

--*/

#define	_SECUTIL_LOCALS
#define	FILENUM	FILE_SECUTIL

#include <afp.h>
#include <scavengr.h>
#include <secutil.h>
#include <access.h>
#include <seposix.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, AfpSecUtilInit)
#pragma alloc_text(PAGE, AfpSecUtilDeInit)
#pragma alloc_text(PAGE, afpDeInitializeSecurityUtility)
#pragma alloc_text(PAGE, AfpInitSidOffsets)
#pragma alloc_text(PAGE, AfpNameToSid)
#pragma alloc_text(PAGE, afpCompleteNameToSid)
#pragma alloc_text(PAGE, AfpSidToName)
#pragma alloc_text(PAGE, afpCompleteSidToName)
#pragma alloc_text(PAGE, AfpSidToMacId)
#pragma alloc_text(PAGE, AfpMacIdToSid)
#pragma alloc_text(PAGE, AfpChangePassword)
#pragma alloc_text(PAGE, afpCompleteChangePassword)
#pragma alloc_text(PAGE, afpLookupSid)
#pragma alloc_text(PAGE, afpUpdateNameSidCache)
#pragma alloc_text(PAGE, afpHashSid)
#pragma alloc_text(PAGE, AfpLogEvent)
#pragma alloc_text(PAGE, afpCompleteLogEvent)
#pragma alloc_text(PAGE, afpQueueSecWorkItem)
#pragma alloc_text(PAGE, afpAgeSidNameCache)
#endif


/***	AfpSecUtilInit
 *
 *	This routine will allocate intialize all the cache tables and
 * 	data structures used by this module. afpDeInitializeSecurityUtility
 *	should be call to Deallocate this memory.
 */
NTSTATUS
AfpSecUtilInit(
	VOID
)
{
	ULONG		Index;
	NTSTATUS	Status = STATUS_SUCCESS;

	// Initialize
	do
	{
		INITIALIZE_SPIN_LOCK(&afpSecUtilLock);

		// Set to Signalled state initially since there is no work in progress
		KeInitializeEvent(&afpUtilWorkInProgressEvent, NotificationEvent, True);

		// Initialize Single Write Multi-reader access for the SID/NAME cache
		AfpSwmrInitSwmr(&afpSWMRForSidNameCache);

		InitializeListHead(&afpSecWorkItemQ);

		// Allocate space for the SID Lookup table
		afpSidLookupTable = (PAFP_SID_NAME*)ALLOC_ACCESS_MEM(sizeof(PAFP_SID_NAME) * SIZE_SID_LOOKUP_TABLE);

		if (afpSidLookupTable == NULL)
		{
			Status = STATUS_INSUFFICIENT_RESOURCES;
			break;
		}

		// Initialize Sid lookup table
	 	RtlZeroMemory(afpSidLookupTable,
					  sizeof(PAFP_SID_NAME) * SIZE_SID_LOOKUP_TABLE);

        afpSidToMacIdTable = (PAFP_SID_MACID *)
                ALLOC_ACCESS_MEM(sizeof(PAFP_SID_MACID) * SIZE_SID_LOOKUP_TABLE);

        if (afpSidToMacIdTable == NULL)
        {
            AfpFreeMemory(afpSidLookupTable);
			Status = STATUS_INSUFFICIENT_RESOURCES;
			break;
        }

        RtlZeroMemory(afpSidToMacIdTable, sizeof(PAFP_SID_NAME) * SIZE_SID_LOOKUP_TABLE);

		// Initialize array of thread structures.
	 	for (Index = 0; Index < NUM_SECURITY_UTILITY_THREADS; Index++)
		{
		 	afpSecurityThread[Index].State = NOT_AVAILABLE;
		 	afpSecurityThread[Index].pSecWorkItem = (PSEC_WORK_ITEM)NULL;
		 	afpSecurityThread[Index].pIrp = (PIRP)NULL;
		}

		// Start the aging process
		AfpScavengerScheduleEvent(afpAgeSidNameCache,
								  NULL,
								  SID_NAME_AGE,
								  True);
	} while(False);

	return Status;
}


/***	AfpSecUtilDeInit
 *
 *	This routine will free the allocated resources from this module.
 * 	This is called during server unload.
 */
VOID
AfpSecUtilDeInit(
	VOID
)
{
	PAFP_SID_NAME 		  pSidName, pFree;
    PAFP_SID_MACID        pSidMacId, pFreeM;
	DWORD				  Count;

	PAGED_CODE();

	// De-Allocate space for the Sid Lookup table
	for(Count = 0; Count < SIZE_SID_LOOKUP_TABLE; Count++)
	{
		for (pSidName = afpSidLookupTable[Count]; pSidName != NULL; NOTHING)
		{
			pFree = pSidName;
			pSidName = pSidName->SidLink;
			AfpFreeMemory(pFree);
		}
	}

 	AfpFreeMemory(afpSidLookupTable);

    afpLastCachedSid = NULL;

	// De-Allocate space for the Sid-to-MacId Lookup table
	for(Count = 0; Count < SIZE_SID_LOOKUP_TABLE; Count++)
	{
		for (pSidMacId = afpSidToMacIdTable[Count]; pSidMacId != NULL; NOTHING)
		{
			pFreeM = pSidMacId;
			pSidMacId = pSidMacId->Next;
			AfpFreeMemory(pFreeM);
		}
	}

 	AfpFreeMemory(afpSidToMacIdTable);

	ASSERT(IsListEmpty(&afpSecWorkItemQ));
}


/***	AfpTerminateSecurityUtility
 *
 * 	This is called during server stop. All the service threads are told
 *	to terminate.
 */
VOID
AfpTerminateSecurityUtility(
	VOID
)
{
	KIRQL			 		OldIrql;
	ULONG			 		 Index;
	PAFP_SECURITY_THREAD	pSecThrd;
	PVOID					pBufOut;
	PIO_STACK_LOCATION		pIrpSp;

	DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
		("AfpTerminateSecurityUtility: waiting for workers to finish work..."));

	// Allow any remaining event logs to be processed
	AfpIoWait(&afpUtilWorkInProgressEvent, NULL);

	DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
		("AfpTerminateSecurityUtility: done waiting."));

	 do {

		ACQUIRE_SPIN_LOCK(&afpSecUtilLock, &OldIrql);

	 	for (pSecThrd = afpSecurityThread,Index = 0;
			 Index < NUM_SECURITY_UTILITY_THREADS;
			 Index++, pSecThrd++)
		{
			if (pSecThrd->State != NOT_AVAILABLE)
			{
				ASSERT(pSecThrd->State != BUSY);
		 		pSecThrd->State = NOT_AVAILABLE ;
				break;
			}
		}

		RELEASE_SPIN_LOCK(&afpSecUtilLock, OldIrql);

		// We are done, all threads are terminated
	 	if (Index == NUM_SECURITY_UTILITY_THREADS)
			 	return;

		DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
			("AfpTerminateSecurityUtility: Terminating thread %ld\n", Index));

		pIrpSp  = IoGetCurrentIrpStackLocation(pSecThrd->pIrp);
		pBufOut = pSecThrd->pIrp->AssociatedIrp.SystemBuffer;

		ASSERT(pIrpSp->Parameters.FileSystemControl.OutputBufferLength >= sizeof(AFP_FSD_CMD_HEADER));

	 	((PAFP_FSD_CMD_HEADER)pBufOut)->dwId 		= Index;
	 	((PAFP_FSD_CMD_HEADER)pBufOut)->FsdCommand = AFP_FSD_CMD_TERMINATE_THREAD;
		pSecThrd->pIrp->IoStatus.Information = sizeof(AFP_FSD_CMD_HEADER);

		pSecThrd->pIrp->IoStatus.Status = STATUS_SUCCESS;

	 	IoCompleteRequest(pSecThrd->pIrp, IO_NETWORK_INCREMENT);
		  pSecThrd->pIrp = NULL;
	} while (True);
}

/***	AfpInitSidOffsets
 *
 *	This routine will be called by AfpAdmServerSetParms to initialize the
 *	the array of Sid-Offset pairs.
 */
AFPSTATUS FASTCALL
AfpInitSidOffsets(
	IN	ULONG			SidOffstPairs,
	IN	PAFP_SID_OFFSET	pSidOff
)
{
	ULONG	SizeOfBufReqd = 0, SizeAdminSid = 0, SizeNoneSid = 0, SubAuthCount;
	LONG	i;
	BOOLEAN	IsDC = True;	// Assume Domain Controller

	PAGED_CODE();

	DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_INFO,
			("AfpInitSidOffsets: Entered, Count = %ld\n", SidOffstPairs));


	//
	// Determine if this is a Domain Controller or not by looking for
	// the 'account' domain. If the machine is a PDC/BDC, the service will
	// NOT send down the Account domain offset.
	//
	for (i = 0; i < (LONG)SidOffstPairs; i++)
	{
		if ((pSidOff[i].SidType == AFP_SID_TYPE_DOMAIN) &&
			 (pSidOff[i].Offset == SE_ACCOUNT_DOMAIN_POSIX_OFFSET))
		  {
			// We are either a server or a workstation (i.e. NtProductServer
			// or NtProductWinNt)
			IsDC = False;
		}

	}

	//
	// Determine the amount of memory needed
	//
	for (i = 0; i < (LONG)SidOffstPairs; i++)
	{
		SizeOfBufReqd += sizeof(AFP_SID_OFFSET) + RtlLengthSid(pSidOff[i].pSid);

		// Initialize DomainAdmins sid and size if this is a domain controller
		// AND this is the primary domain offset
		if (IsDC && (pSidOff[i].SidType == AFP_SID_TYPE_PRIMARY_DOMAIN))
		{
			ASSERT (SizeAdminSid == 0);
			ASSERT (AfpSidAdmins == NULL);

			SubAuthCount = *RtlSubAuthorityCountSid(pSidOff[i].pSid);

			SizeAdminSid = RtlLengthRequiredSid(SubAuthCount + 1);

			if ((AfpSidAdmins = (PSID)ALLOC_ACCESS_MEM(SizeAdminSid)) == NULL)
			{
				return STATUS_INSUFFICIENT_RESOURCES;
			}

			RtlCopySid(SizeAdminSid, AfpSidAdmins, pSidOff[i].pSid);

			// Add the relative ID
			*RtlSubAuthorityCountSid(AfpSidAdmins) = (UCHAR)(SubAuthCount+1);

			*RtlSubAuthoritySid(AfpSidAdmins, SubAuthCount) = DOMAIN_GROUP_RID_ADMINS;

				AfpSizeSidAdmins = RtlLengthSid(AfpSidAdmins);

		}
	}

	ASSERT (SizeOfBufReqd != 0);

	// HACK: To fake out the loop below we set SizeNoneSid to nonzero
	// on PDC/BDC. Since the AfpServerIsStandalone variable will not
	// get set until service calls AfpAdmWServerSetInfo we can
	// infer it here since we don't want to try to manufacture the None
	// sid on a PDC/BDC.
	if (IsDC)
		SizeNoneSid = 1;

	// If we did not get the Domain admins sid, we must be running on a
	// stand-alone machine. So manufacture MACHINE\Administrators
	// SID instead.  Also manufacture MACHINE\None if this is not a DC.
	for (i = SidOffstPairs - 1;
		 ((SizeAdminSid == 0) || (SizeNoneSid == 0)) && (i >= 0);
		 i--)
	{
		// Initialize "Administrators" sid and size
		if (pSidOff[i].SidType == AFP_SID_TYPE_DOMAIN)
		{
			if (RtlEqualSid(&AfpSidBuiltIn, pSidOff[i].pSid))
			{
				ASSERT (SizeAdminSid == 0);
				ASSERT (AfpSidAdmins == NULL);

				SubAuthCount = *RtlSubAuthorityCountSid(pSidOff[i].pSid);

				SizeAdminSid = RtlLengthRequiredSid(SubAuthCount + 1);

				if ((AfpSidAdmins = (PSID)ALLOC_ACCESS_MEM(SizeAdminSid)) == NULL)
				{
					return STATUS_INSUFFICIENT_RESOURCES;
				}

				RtlCopySid(SizeAdminSid, AfpSidAdmins, pSidOff[i].pSid);

				// Add the relative ID
				*RtlSubAuthorityCountSid(AfpSidAdmins) = (UCHAR)(SubAuthCount+1);

				*RtlSubAuthoritySid(AfpSidAdmins, SubAuthCount) = DOMAIN_ALIAS_RID_ADMINS;

				AfpSizeSidAdmins = RtlLengthSid(AfpSidAdmins);

			}
			else if (pSidOff[i].Offset == SE_ACCOUNT_DOMAIN_POSIX_OFFSET)
			{
				ASSERT (SizeNoneSid == 0);
				ASSERT (AfpSidNone == NULL);

				SubAuthCount = *RtlSubAuthorityCountSid(pSidOff[i].pSid);

				SizeNoneSid = RtlLengthRequiredSid(SubAuthCount + 1);

				if ((AfpSidNone = (PSID)ALLOC_ACCESS_MEM(SizeNoneSid)) == NULL)
				{
					return STATUS_INSUFFICIENT_RESOURCES;
				}

				RtlCopySid(SizeNoneSid, AfpSidNone, pSidOff[i].pSid);

				// Add the relative ID
				*RtlSubAuthorityCountSid(AfpSidNone) = (UCHAR)(SubAuthCount+1);

				// Note that the "None" sid on standalone is the same as the
				// "Domain Users" Sid on PDC/BDC. (On PDC/BDC the primary
				// domain is the same as the account domain).
				*RtlSubAuthoritySid(AfpSidNone, SubAuthCount) = DOMAIN_GROUP_RID_USERS;

				AfpSizeSidNone = RtlLengthSid(AfpSidNone);
			}
		}
	}

	ASSERT (SizeAdminSid != 0);
	ASSERT (AfpSidAdmins != NULL);

#if DBG
	if (IsDC)
	{
		ASSERT(AfpSidNone == NULL);
	}
	else
	{
		ASSERT(AfpSidNone != NULL);
	}
#endif

	return AFP_ERR_NONE;
}


/***	AfpSecurityUtilityWorker
 *
 * 		This is the main entry point for the security utility thread that
 *		comes from the AFP server service. This is called if the FSD receives
 *	a IRP_MJ_FILE_SYSTEM_CONTROL major function code.
 *
 *	This routine will:
 *	1) Assign a thread structure if this is a newly created thread.
 *	2) Complete the previous work item if this is not a newly created
 *		thread.
 *	3) Check to see if there are any work items to be processed from the
 *		Security utility work item queue. If there is a work item, it will
 *		de-queue the work item and complete the IRP. Otherwise it will
 *		mark the IRP as pending and return STATUS_PENDING.
 *
 */
NTSTATUS
AfpSecurityUtilityWorker(
	IN	PIRP 				pIrp,
	IN  PIO_STACK_LOCATION  pIrpSp		// Pointer to the IRP stack location
)
{
	USHORT		FuncCode;
	USHORT		Method;
	KIRQL		OldIrql;
	PVOID		pBufIn;
	PVOID		pBufOut;
	LONG		iBufLen;
	ULONG		Index;
	NTSTATUS	Status;
	BOOLEAN		FoundMoreWork = False;

	DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_INFO,
			("afpSecurityUtilityWorker: Entered \n"));

	FuncCode = (USHORT)
				AFP_CC_BASE(pIrpSp->Parameters.FileSystemControl.FsControlCode);

	Method = (USHORT)
			  AFP_CC_METHOD(pIrpSp->Parameters.FileSystemControl.FsControlCode);

 	if ((FuncCode != CC_BASE_GET_FSD_COMMAND) || (Method != METHOD_BUFFERED))
		return STATUS_INVALID_PARAMETER;

	// Get the output buffer and its length. Input and Output buffers are
	// both pointed to by the SystemBuffer

	iBufLen = pIrpSp->Parameters.FileSystemControl.InputBufferLength;
	pBufIn  = pIrp->AssociatedIrp.SystemBuffer;

    if ((iBufLen != 0) && (iBufLen < sizeof(AFP_FSD_CMD_HEADER)))
    {
	    DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_ERR,
		    ("afpSecurityUtilityWorker: iBufLen too small %d\n",iBufLen));
	    ASSERT(0);
		return STATUS_INVALID_PARAMETER;
    }

	pBufOut = pBufIn;

	if (pBufOut == NULL)
		return STATUS_INVALID_PARAMETER;

	// If this is a newly created thread, we need to find a slot for it

	if (iBufLen == 0)
	{
		ACQUIRE_SPIN_LOCK(&afpSecUtilLock,&OldIrql);

	 	for (Index = 0; Index < NUM_SECURITY_UTILITY_THREADS; Index++)
		{
		 	if (afpSecurityThread[Index].State == NOT_AVAILABLE)
			{
		 		afpSecurityThread[Index].State = BUSY;
				break;
			}
		}

		RELEASE_SPIN_LOCK(&afpSecUtilLock,OldIrql);

        // no more threads?  fail the request
		if (Index == NUM_SECURITY_UTILITY_THREADS)
        {
		    DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_ERR,
			    ("afpSecurityUtilityWorker: no thread available, failing request\n"));
		    ASSERT(0);
		    return STATUS_INSUFFICIENT_RESOURCES;
        }

		DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_INFO,
			("afpSecurityUtilityWorker: New Thread given slot=%d\n",Index));
	}
	else
	{
		PAFP_SECURITY_THREAD	pSecThrd;

		// The id is actually the slot index into the array of security threads

	 	Index = ((PAFP_FSD_CMD_HEADER)pBufIn)->dwId;

	 	if (Index >= NUM_SECURITY_UTILITY_THREADS)
			return STATUS_INVALID_PARAMETER;

		pSecThrd = &afpSecurityThread[Index];

        if (pSecThrd->State != BUSY)
        {
		    DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_ERR,
			    ("afpSecurityUtilityWorker: thread is not busy!\n"));
		    ASSERT(0);
		    return STATUS_INVALID_PARAMETER;
        }

		DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_INFO,
		("afpSecurityUtilityThread: Thread slot=%d completed request\n",Index));

	 	// Complete the current job

 		(*((pSecThrd->pSecWorkItem)->pCompletionRoutine))(Index, pBufIn);

		 // The job is completed so set the work item pointer to NULL.
		pSecThrd->pSecWorkItem = (PSEC_WORK_ITEM)NULL;
	}

	// OK, we are done with the previous job. Now we check to see if there
	// are any jobs in the queue

	ACQUIRE_SPIN_LOCK(&afpSecUtilLock,&OldIrql);

	if (iBufLen != 0)
	{
		ASSERT(afpUtilWorkInProgress > 0);
		// This is not a newly created thread, so decrement the count of
		// work items in progress. If it goes to zero and the work queue
		// is empty, signal the event signifying there is no work in progress
		if ((--afpUtilWorkInProgress == 0) && IsListEmpty(&afpSecWorkItemQ))
		{
			KeSetEvent(&afpUtilWorkInProgressEvent, IO_NETWORK_INCREMENT, False);
		}
	}

	if (IsListEmpty(&afpSecWorkItemQ))
	{
		// There is no work to be done so mark this irp as pending and
		// wait for a job

		afpSecurityThread[Index].State = IDLE;
		IoMarkIrpPending(pIrp);
		 afpSecurityThread[Index].pIrp = pIrp;
		Status = STATUS_PENDING;

		DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_INFO,
		("afpSecurityUtilityWorker: Thread slot=%d marked as IDLE\n",Index));
	}
	else
	{
		// Otherwise, there is a job to be processed, so take it off the queue.

		// Increment the count of work items in progress and set the event
		// to not signalled
		afpUtilWorkInProgress ++;
		KeClearEvent(&afpUtilWorkInProgressEvent);
		FoundMoreWork = True;

		afpSecurityThread[Index].State = BUSY;

 		afpSecurityThread[Index].pSecWorkItem =
							(PSEC_WORK_ITEM)RemoveHeadList(&afpSecWorkItemQ);

        ASSERT(afpSecWorkItemQLength > 0);

        afpSecWorkItemQLength--;

		ASSERT((LONG)(pIrpSp->Parameters.FileSystemControl.OutputBufferLength) >=
					(afpSecurityThread[Index].pSecWorkItem)->OutputBufSize);

		DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_INFO,
			("afpSecurityUtilityWorker: Thread slot=%d marked as BUSY\n",Index));
	}

	RELEASE_SPIN_LOCK(&afpSecUtilLock,OldIrql);

	// If there is a work item to process

	if (FoundMoreWork)
	{

		Status = STATUS_SUCCESS;

		// Simply copy the command packet into the IRP and return.
		RtlCopyMemory(pBufOut,
						(afpSecurityThread[Index].pSecWorkItem)->pOutput,
						(afpSecurityThread[Index].pSecWorkItem)->OutputBufSize);

	 	((PAFP_FSD_CMD_HEADER)pBufOut)->dwId = Index;

		pIrp->IoStatus.Information =
						(afpSecurityThread[Index].pSecWorkItem)->OutputBufSize;
	}

	 return Status;
}


/***	afpGetIndexOfIdle
 *
 * 	This routine will first check to see if there are any threads that
 *	are idle and are waiting for work to do. If there are, then it will
 *	mark it as busy and up the count of in progress items and release the
 *	InProgress event. Else it will queue up the work-item.
 */
LONG FASTCALL
afpGetIndexOfIdle(
	 IN	PSEC_WORK_ITEM 		pSecWorkItem
)
{
	KIRQL	OldIrql;
	LONG	Index;

	ACQUIRE_SPIN_LOCK(&afpSecUtilLock, &OldIrql);

	// See if there are any threads that are ready to process this request
 	for (Index = 0; Index < NUM_SECURITY_UTILITY_THREADS; Index++)
	{
		if (afpSecurityThread[Index].State == IDLE)
		{
			// If we found a thread that is ready, mark it as busy
			// Increment the count of work items in progress and set the event
			// to not signalled
			afpUtilWorkInProgress ++;
			KeClearEvent(&afpUtilWorkInProgressEvent);

			afpSecurityThread[Index].State = BUSY;
			break;
		}
	}

	if (Index == NUM_SECURITY_UTILITY_THREADS)
	{
		// All threads are busy so queue up this request.
		// Alternatively, it could be the case that someone has tried
		// to log an event before the usermode utility thread(s) have
		// started, in which case we should just queue up the item.
		InsertTailList(&afpSecWorkItemQ, &pSecWorkItem->Links);

        afpSecWorkItemQLength++;
	}

	RELEASE_SPIN_LOCK(&afpSecUtilLock, OldIrql);

	return Index;
}


/***	afpQueueSecWorkItem
 *
 * 	This routine will first check to see if there are any threads that
 *	are idle and are waiting for work to do. If there are, then it will
 *	copy the command packet into the IRP's output buffer and mark that
 *	IRP as complete. Otherwise, it will insert this work item at the
 *	tail of the work item queue.
 */
LOCAL NTSTATUS
afpQueueSecWorkItem(
	IN	AFP_FSD_CMD_ID			FsdCommand,
	IN	PSDA					pSda,
	IN	PKEVENT					pEvent,
	IN	PAFP_FSD_CMD_PKT 		pAfpFsdCmdPkt,
	IN	LONG					BufSize,
	IN	SEC_COMPLETION_ROUTINE	pCompletionRoutine
)
{
	LONG				Index;
	PSEC_WORK_ITEM 		pSecWorkItem;

	DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_INFO,
			("afpQueueSecWorkItem: Entered \n"));

	if ((pSecWorkItem = ALLOC_SWI()) == NULL)
		return STATUS_NO_MEMORY;

	pSecWorkItem->pSda = pSda;
	pSecWorkItem->pCompletionEvent = pEvent;
	pSecWorkItem->pCompletionRoutine = pCompletionRoutine;
	pSecWorkItem->OutputBufSize = BufSize;
	pSecWorkItem->pOutput = pAfpFsdCmdPkt;

	pAfpFsdCmdPkt->Header.FsdCommand = FsdCommand;

	Index = afpGetIndexOfIdle(pSecWorkItem);

	if (Index < NUM_SECURITY_UTILITY_THREADS)
	{
		PAFP_SECURITY_THREAD	pSecThrd;
		PIO_STACK_LOCATION		pIrpSp;

		// Wake this thread up by marking this IRP as complete
		pSecThrd = &afpSecurityThread[Index];
		pIrpSp  = IoGetCurrentIrpStackLocation(pSecThrd->pIrp);


		ASSERT((LONG)(pIrpSp->Parameters.FileSystemControl.OutputBufferLength) >=
												pSecWorkItem->OutputBufSize);

		pAfpFsdCmdPkt->Header.dwId = Index;
		RtlCopyMemory(pSecThrd->pIrp->AssociatedIrp.SystemBuffer,
					  pAfpFsdCmdPkt,
					  BufSize);

		pSecThrd->pSecWorkItem = pSecWorkItem;

		pSecThrd->pIrp->IoStatus.Information = (ULONG)(pSecWorkItem->OutputBufSize);

		pSecThrd->pIrp->IoStatus.Status = STATUS_SUCCESS;

		DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_INFO,
				("afpQueueSecWorkItem: Abount to release IRP\n"));

		IoCompleteRequest(afpSecurityThread[Index].pIrp, IO_NETWORK_INCREMENT);
	}

	return AFP_ERR_EXTENDED;
}


/***	AfpNameToSid
 *
 *	The FSD will call this routine to do a Name to SID translation.
 *  This routine will simply create a work item to do the translation.
 *  This work item will eventually be executed by the user-mode service.
 *  When the work item is completed, afpCompleteNameToSid will be called
 *  which will put the result in the SDA.
 *
 *  Returns: STATUS_SUCCESS
 *			  STATUS_NO_MEMORY
 *
 *	MODE: Non-blocking
 */
NTSTATUS FASTCALL
AfpNameToSid(
	IN  PSDA		 	  pSda,
	IN  PUNICODE_STRING	Name
)
{
	PAFP_FSD_CMD_PKT pAfpFsdCmdPkt;
	LONG			 BufSize;

	PAGED_CODE();

	 DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_INFO,
				("AfpNameToSid: mapping %ws\n", Name->Buffer));

	// Set up the work item that will translate the name to the SID

	BufSize = sizeof(AFP_FSD_CMD_PKT) + Name->Length + sizeof(WCHAR);

	if ((pAfpFsdCmdPkt = (PAFP_FSD_CMD_PKT)AfpAllocPagedMemory(BufSize)) == NULL)
	{
		return STATUS_NO_MEMORY;
	}

	RtlCopyMemory(pAfpFsdCmdPkt->Data.Name,
					Name->Buffer,
					Name->Length);
	 *(PWCHAR)(&pAfpFsdCmdPkt->Data.Name[Name->Length]) = UNICODE_NULL;

	return afpQueueSecWorkItem(AFP_FSD_CMD_NAME_TO_SID,
								pSda,
								NULL,
								pAfpFsdCmdPkt,
								BufSize,
								afpCompleteNameToSid);
}


/***	afpCompleteNameToSid
 *
 *	This routine will be called by AfpSecurityUtilityWorker when the
 *	thread that processed the work item queued up by afpNameToSid returns.
 *	This routine will free memory allocated by the afpNameToSid routine.
 *  It will insert the result in the SDA, and then queue up the worker
 *  routine that originally requested the lookup.
 */
LOCAL VOID
afpCompleteNameToSid(
	IN ULONG Index,
	IN PVOID pInBuf
)
{
	PAFP_FSD_CMD_PKT pAfpFsdCmdPkt;
	PSDA			 pSda;
	 PSID			 pSid;

	PAGED_CODE();

	pSda = (afpSecurityThread[Index].pSecWorkItem)->pSda;

	pAfpFsdCmdPkt = (PAFP_FSD_CMD_PKT)
					(afpSecurityThread[Index].pSecWorkItem)->pOutput;

	// If there was no error then set the result in the SDA
	if (NT_SUCCESS(((PAFP_FSD_CMD_PKT)pInBuf)->Header.ntStatus))
	{
	 	pSid = (PSID)(((PAFP_FSD_CMD_PKT)pInBuf)->Data.Sid);

		afpUpdateNameSidCache((PWCHAR)pAfpFsdCmdPkt->Data.Name, pSid);

		pSda->sda_SecUtilSid = (PSID)AfpAllocPagedMemory(RtlLengthSid(pSid));

		if (pSda->sda_SecUtilSid == (PSID)NULL)
			 pSda->sda_SecUtilResult = STATUS_NO_MEMORY;
		 else RtlCopySid(RtlLengthSid(pSid), pSda->sda_SecUtilSid, pSid);
	 }
	 else pSda->sda_SecUtilSid = (PSID)NULL;

	pSda->sda_SecUtilResult = ((PAFP_FSD_CMD_PKT)pInBuf)->Header.ntStatus;

	AfpFreeMemory(afpSecurityThread[Index].pSecWorkItem->pOutput);
	AfpFreeMemory(afpSecurityThread[Index].pSecWorkItem);

 	AfpQueueWorkItem(&(pSda->sda_WorkItem));
}


/***	AfpSidToName
 *
 *	The FSD will call this routine to do a SID to Name translation. It
 *	will first check to see if the SID is in the cache. If it is, it
 *	will return a pointer to the AFP_SID_NAME structure from which the
 *	translated Name value may be extracted and it will return
 *	STATUS_SUCCESS.
 *	Otherwise, it will queue up a SID to Name lookup request to the
 *	AFP server service and return AFP_ERR_EXTENDED.
 *
 *	MODE: Non-blocking
 */
NTSTATUS
AfpSidToName(
	IN  PSDA		 	  pSda,
	IN  PSID				  Sid,
	OUT PAFP_SID_NAME  	 *ppTranslatedSid
)
{
	PAFP_FSD_CMD_PKT pAfpFsdCmdPkt;
	LONG			 BufSize;

	PAGED_CODE();

	// First, check to see if the SID is cached
	AfpDumpSid("AfpSidToName: mapping Sid", Sid);

	if ((*ppTranslatedSid = afpLookupSid(Sid)) != NULL)
	 {
		 DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_INFO,
			  ("AfpSidToName: mapped to %ws\n", (*ppTranslatedSid)->Name.Buffer));
		return STATUS_SUCCESS;
	}

	// Not cached so we need to call the user-mode service to do this
	// translation
	BufSize = sizeof(AFP_FSD_CMD_PKT) + RtlLengthSid(Sid);

	if ((pAfpFsdCmdPkt = (PAFP_FSD_CMD_PKT)AfpAllocPagedMemory(BufSize)) == NULL)
	{
		return STATUS_NO_MEMORY;
	}

	RtlCopyMemory(pAfpFsdCmdPkt->Data.Sid, Sid, BufSize - sizeof(AFP_FSD_CMD_PKT));

	return afpQueueSecWorkItem(AFP_FSD_CMD_SID_TO_NAME,
								pSda,
								NULL,
								pAfpFsdCmdPkt,
								BufSize,
								afpCompleteSidToName);
}


/***	afpCompleteSidToName
 *
 *	This routine will be called by AfpSecurityUtilityWorker when the
 *	thread that processed the work item queued up by AfpSidToName returns.
 *	This routine will update the Name/SID cache, free memory allocated
 *	by the AfpSidtoName routine, and then queue up the worker routine that
 *	originally requested the lookup.
 */
LOCAL VOID
afpCompleteSidToName(
	IN ULONG Index,
	IN PVOID pInBuf
)
{
	PAFP_FSD_CMD_PKT pAfpFsdCmdPkt;
	PSDA			 pSda;

	PAGED_CODE();

	pAfpFsdCmdPkt = (PAFP_FSD_CMD_PKT)
					(afpSecurityThread[Index].pSecWorkItem)->pOutput;

	// If there was no error then update the cache
	if (NT_SUCCESS(((PAFP_FSD_CMD_PKT)pInBuf)->Header.ntStatus))
		afpUpdateNameSidCache((WCHAR*)(((PAFP_FSD_CMD_PKT)pInBuf)->Data.Name),
								(PSID)(pAfpFsdCmdPkt->Data.Sid));

	pSda = (afpSecurityThread[Index].pSecWorkItem)->pSda;

	pSda->sda_SecUtilResult = ((PAFP_FSD_CMD_PKT)pInBuf)->Header.ntStatus;

	AfpFreeMemory(afpSecurityThread[Index].pSecWorkItem->pOutput);
	AfpFreeMemory(afpSecurityThread[Index].pSecWorkItem);

 	AfpQueueWorkItem(&(pSda->sda_WorkItem));
}


/***	AfpSidToMacId
 *
 *	This routine is called by the FSD to map a SID to an AFP ID. This call
 *	will first extract the domain SID from this SID. IT will then check
 *	to see if this domain SID exists in the afpSidOffsetTable cache.
 *	If it does not exist STATUS_NONE_MAPPED will be returned.
 *
 *	MODE: Blocking
 */
NTSTATUS FASTCALL
AfpSidToMacId(
	IN  PSID	pSid,
	OUT PULONG	pMacId
)
{
    PAFP_SID_MACID      pSidMacId, pPrevSidMacId=NULL;
	USHORT			    SidLen;
	NTSTATUS			Status;
    ULONG               Location;

	PAGED_CODE();

	AfpDumpSid("AfpSidToMacId: Mapping Sid", pSid);

	if (RtlEqualSid(pSid, &AfpSidNull) ||
		(AfpServerIsStandalone && RtlEqualSid(pSid, AfpSidNone)))
	{
		*pMacId = 0;
		return STATUS_SUCCESS;
	}


    ASSERT(afpSWMRForSidNameCache.swmr_ExclusiveOwner != PsGetCurrentThread());

    AfpSwmrAcquireExclusive(&afpSWMRForSidNameCache);

	Location = afpHashSid(pSid);

    for (pSidMacId = afpSidToMacIdTable[Location];
         pSidMacId != NULL;
         pSidMacId = pSidMacId->Next)
    {
        // Found the MacId for this Sid?  we already have it: return it
        if (RtlEqualSid(pSid, &(pSidMacId->Sid)))
        {
            *pMacId = pSidMacId->MacId;
            AfpSwmrRelease(&afpSWMRForSidNameCache);
            return STATUS_SUCCESS;
        }

        pPrevSidMacId = pSidMacId;
    }

    //
    // we don't have a MacId for this sid in our cache.  Create a new one
    //

	SidLen = (USHORT)RtlLengthSid(pSid);

	pSidMacId = (PAFP_SID_MACID)ALLOC_ACCESS_MEM(sizeof(AFP_SID_MACID) + SidLen);

	if (pSidMacId == NULL)
    {
	    AfpSwmrRelease(&afpSWMRForSidNameCache);
		return STATUS_NO_MEMORY;
    }

	RtlCopyMemory(pSidMacId->Sid, pSid, SidLen);
    pSidMacId->Next = NULL;

    // assign a MacId for this Sid
    pSidMacId->MacId = afpNextMacIdToUse++;

    // and insert this into the list
    if (pPrevSidMacId)
    {
        ASSERT(pPrevSidMacId->Next == NULL);
        pPrevSidMacId->Next = pSidMacId;
    }
    else
    {
        ASSERT(afpSidToMacIdTable[Location] == NULL);
        afpSidToMacIdTable[Location] = pSidMacId;
    }

    *pMacId = pSidMacId->MacId;

    afpLastCachedSid = pSidMacId;

    AfpSwmrRelease(&afpSWMRForSidNameCache);

	return STATUS_SUCCESS;
}


/***	AfpMacIdToSid
 *
 *	This routine is called by the FSD to map a Afp Id to SID.
 *	*ppSid should be freed the caller using AfpFreeMemory.
 *
 *	MODE: Blocking
 */
NTSTATUS FASTCALL
AfpMacIdToSid(
	IN  ULONG	MacId,
	OUT PSID *	ppSid
)
{
    PAFP_SID_MACID      pSidMacId;
	ULONG				Count;
	DWORD				cbSid;
  	DWORD				SubAuthCount;
  	DWORD				GreatestOffset;
	NTSTATUS			Status;

	PAGED_CODE();


	if (MacId == 0)
	{
        *ppSid = &AfpSidNull;
		return STATUS_SUCCESS;
	}

    AfpSwmrAcquireShared(&afpSWMRForSidNameCache);

    // see if we just cached this Sid (quite likely)
    if ((afpLastCachedSid != NULL) &&
        (afpLastCachedSid->MacId == MacId))
    {
        *ppSid = &(afpLastCachedSid->Sid);
        AfpSwmrRelease(&afpSWMRForSidNameCache);
		return STATUS_SUCCESS;
    }

    for (Count = 0; Count < SIZE_SID_LOOKUP_TABLE; Count++)
    {
        for (pSidMacId = afpSidToMacIdTable[Count];
             pSidMacId != NULL;
             pSidMacId = pSidMacId->Next )
        {
            if (pSidMacId->MacId == MacId)
            {
                *ppSid = &(pSidMacId->Sid);
                AfpSwmrRelease(&afpSWMRForSidNameCache);
                return STATUS_SUCCESS;
            }
        }
    }

    AfpSwmrRelease(&afpSWMRForSidNameCache);

    *ppSid = NULL;

    return STATUS_NONE_MAPPED;
}


/***	AfpChangePassword
 *
 *	This routine is called by the FSD to change a password for a user.
 *	Most of the work for this is done by the AFP service. The work item
 *	is simply queued up. This routine waits for the completion and returns
 *	with thre result of the call.
 *
 *	MODE: Blocking
 */
NTSTATUS FASTCALL
AfpChangePassword(
	IN	PSDA				pSda,
	IN PAFP_PASSWORD_DESC	pPassword
)
{
	KEVENT				CompletionEvent;
	PAFP_FSD_CMD_PKT 	pAfpFsdCmdPkt	= NULL;
	NTSTATUS			Status;

	PAGED_CODE();

	do
	{

		 // Initialize the event that we will wait for
		 //
		KeInitializeEvent(&CompletionEvent, NotificationEvent, False);

		if ((pAfpFsdCmdPkt =
			(PAFP_FSD_CMD_PKT)AfpAllocPagedMemory(sizeof(AFP_FSD_CMD_PKT))) == NULL)
		{
			Status =  STATUS_NO_MEMORY;
			break;
		}

		// Copy all the change password data

		RtlCopyMemory(&(pAfpFsdCmdPkt->Data.Password),
				 pPassword,
				 sizeof(AFP_PASSWORD_DESC));

		DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_INFO,
						("afpChangePassword: Queing work item\n"));

		// Block till request completes
		if ((Status = afpQueueSecWorkItem(AFP_FSD_CMD_CHANGE_PASSWORD,
										 pSda,
										 &CompletionEvent,
										 pAfpFsdCmdPkt,
										 sizeof(AFP_FSD_CMD_PKT),
										 afpCompleteChangePassword)) == AFP_ERR_EXTENDED)
		{
			AfpIoWait(&CompletionEvent, NULL);

			// Request complete. Set return code.
			Status = pSda->sda_SecUtilResult;
		}
		else AfpFreeMemory(pAfpFsdCmdPkt);
	} while(False);

	 return Status;
}


/***	afpCompleteChangePassword
 *
 *	MODE: Blocking
 */
LOCAL VOID
afpCompleteChangePassword(
	IN ULONG Index,
	IN PVOID pInBuf
)
{
	PSEC_WORK_ITEM 		pSecWorkItem = afpSecurityThread[Index].pSecWorkItem;

	PAGED_CODE();

	// Set the completion result
	pSecWorkItem->pSda->sda_SecUtilResult =
								((PAFP_FSD_CMD_PKT)pInBuf)->Header.ntStatus;

	AfpFreeMemory(afpSecurityThread[Index].pSecWorkItem->pOutput);

	// Signal that this call is completed
	KeSetEvent(pSecWorkItem->pCompletionEvent,
				IO_NETWORK_INCREMENT,
				False);

	AfpFreeMemory(afpSecurityThread[Index].pSecWorkItem);
}

/***	afpLookupSid
 *
 *	Given a pointer to a SID value, this routine will search the cache
 *	for it. If it is found it returns a pointer to the AFP_SID_NAME
 *	structure so that the translated name may be extracted from it.
 */
LOCAL PAFP_SID_NAME FASTCALL
afpLookupSid(
	IN  PSID Sid
)
{
	PAFP_SID_NAME	pAfpSidName;

	PAGED_CODE();

	AfpSwmrAcquireShared(&afpSWMRForSidNameCache);

	for (pAfpSidName = afpSidLookupTable[afpHashSid(Sid)];
		  pAfpSidName != NULL;
		  pAfpSidName = pAfpSidName->SidLink)
	{
		if (RtlEqualSid(Sid, &(pAfpSidName->Sid)))
		{
			break;
		}
	}

	AfpSwmrRelease(&afpSWMRForSidNameCache);

	return pAfpSidName;

}

/***	afpUpdateNameSidCache
 *
 *	This routine will update the SID/Name cache given a SID/translated
 *	name pair.
 */
LOCAL NTSTATUS FASTCALL
afpUpdateNameSidCache(
	IN WCHAR * Name,
	IN PSID	 Sid
)
{
	PAFP_SID_NAME	pAfpSidName;
	ULONG			Location;
	USHORT			NameLen, SidLen;

	PAGED_CODE();

	NameLen = wcslen(Name) * sizeof(WCHAR);
	SidLen = (USHORT)RtlLengthSid(Sid);
	pAfpSidName = (PAFP_SID_NAME)ALLOC_ACCESS_MEM(sizeof(AFP_SID_NAME) +
											NameLen + SidLen + sizeof(WCHAR));
	if (pAfpSidName == NULL)
		return STATUS_NO_MEMORY;

	// Copy the data into the cache node
	RtlCopyMemory(pAfpSidName->Sid, Sid, SidLen);

	pAfpSidName->Name.Length = NameLen;
	pAfpSidName->Name.MaximumLength = NameLen + sizeof(WCHAR);
	pAfpSidName->Name.Buffer = (LPWSTR)((PBYTE)pAfpSidName +
										sizeof(AFP_SID_NAME) + SidLen);

	RtlCopyMemory(pAfpSidName->Name.Buffer, Name, NameLen);
	AfpGetCurrentTimeInMacFormat(&pAfpSidName->LastAccessedTime);

	// Insert into Sid lookup table
	AfpSwmrAcquireExclusive(&afpSWMRForSidNameCache);

	Location = afpHashSid(Sid);

	pAfpSidName->SidLink 		= afpSidLookupTable[Location];
	afpSidLookupTable[Location] = pAfpSidName;

	AfpSwmrRelease(&afpSWMRForSidNameCache);

	return STATUS_SUCCESS;

}


/***	afpHashSid
 *
 *	Given a SID value, this routine will return the bucket index of
 *	where this value is or should be stored.
 */
LOCAL ULONG FASTCALL
afpHashSid(
	IN PSID	Sid
)
{
	ULONG	Count;
	ULONG	Index;
	ULONG	Location;
	PBYTE	pByte;

	PAGED_CODE();

	for(Count 		= RtlLengthSid(Sid),
		 pByte 		= (PBYTE)Sid,
		 Index 		= 0,
		 Location 	= 0;

		 Index < Count;

		 Index++,
		 pByte++)

		Location = (Location * SID_HASH_RADIX) + *pByte;

	return (Location % SIZE_SID_LOOKUP_TABLE);
}


/***	afpAgeSidNameCache
 *
 *	This is called by the scavenger periodically to age out the cache. The
 *	entries that are aged are the ones not accessed for atleast SID_NAME_AGE
 *	seconds.
 */
AFPSTATUS FASTCALL
afpAgeSidNameCache(
	IN	PVOID	pContext
)
{
	PAFP_SID_NAME	pSidName, *ppSidName;
	AFPTIME			Now;
	int				i;

	PAGED_CODE();

	AfpGetCurrentTimeInMacFormat(&Now);

	AfpSwmrAcquireExclusive(&afpSWMRForSidNameCache);

	for (i = 0; i < SIZE_SID_LOOKUP_TABLE; i++)
	{
		for (ppSidName = &afpSidLookupTable[i];
			 (pSidName = *ppSidName) != NULL;)
		{
			if ((Now - pSidName->LastAccessedTime) > SID_NAME_AGE)
			{
				*ppSidName = pSidName->SidLink;
				AfpFreeMemory(pSidName);
			}
			else ppSidName = &pSidName->SidLink;
		}
	}

	AfpSwmrRelease(&afpSWMRForSidNameCache);

	// Requeue ourselves
	return AFP_ERR_REQUEUE;
}


/***	AfpLogEvent
 *
 *	Create a work item containing the event information for the user-mode
 *  service to write to the event log on behalf of the server.  When the
 *  work item is completed, afpCompleteLogEvent will be called to cleanup
 *  the work item buffers.  This routine is called to log both errors and
 *  events.  If FileHandle is specified, the name of the file/dir associated
 *  with the handle will be queried, and that will be used as the *first*
 *  insertion string.  Only one insertion string is allowed.
 *  Errorlog data will always be preceded by the file+line number from which
 *  the error was logged, and the NTSTATUS code.
 */
VOID
AfpLogEvent(
	IN USHORT		EventType, 			// Error, Information etc.
	IN ULONG		MsgId,
	IN DWORD		File_Line  OPTIONAL,// For errorlog only
	IN NTSTATUS		Status 		OPTIONAL,// For errorlog only
	IN PBYTE RawDataBuf OPTIONAL,
	IN LONG			RawDataLen,
	IN HANDLE FileHandle OPTIONAL,// For fileio errorlogs only
	IN LONG			String1Len,
	IN PWSTR        String1	 OPTIONAL
)
{
	PAFP_FSD_CMD_PKT	pAfpFsdCmdPkt;
	LONG					outbuflen, extradatalen = 0;
	UNICODE_STRING		path;
	PBYTE tmpptr = NULL;
	PWSTR  UNALIGNED *  ppstr = NULL;
	int					stringcount = 0;

	PAGED_CODE();

	ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

#ifdef	STOP_ON_ERRORS
	DBGBRK(DBG_LEVEL_ERR);
#endif

	AfpSetEmptyUnicodeString(&path, 0, NULL);

    //
    // if due to some weird condition, we have too many items pending on the queue, don't
    // accept this (note that we aren't taking a spinlock here: it's ok to be off by 1!)
    //
    if (afpSecWorkItemQLength > MAX_SECWORKITEM_QLEN)
    {
        ASSERT(0);
        return;
    }

	outbuflen = sizeof(AFP_FSD_CMD_HEADER) + sizeof(AFP_EVENTLOG_DESC) +
				RawDataLen + String1Len + sizeof(WCHAR) +
				sizeof(DWORD); // extra space for aligning string ptrs if needed

	if (ARGUMENT_PRESENT(String1))
	{
		outbuflen += sizeof(PWSTR);
		stringcount ++;
	}

	if (EventType == EVENTLOG_ERROR_TYPE)
	{
		extradatalen = sizeof(File_Line) + sizeof(Status);
		outbuflen += extradatalen;

		// Update error statistics count
		INTERLOCKED_INCREMENT_LONG(&AfpServerStatistics.stat_Errors);
	}

	 if (ARGUMENT_PRESENT(FileHandle))
	{
		outbuflen += sizeof(PWSTR);
		stringcount ++;

		// Figure out the filename associated with the handle
		if (!NT_SUCCESS(AfpQueryPath(FileHandle, &path,
								MAX_FSD_CMD_SIZE - outbuflen - sizeof(WCHAR))))
		{
			return;
		}
		outbuflen += path.Length + sizeof(WCHAR);
	}

	ASSERT(outbuflen <= MAX_FSD_CMD_SIZE);

	pAfpFsdCmdPkt = (PAFP_FSD_CMD_PKT)AfpAllocZeroedNonPagedMemory(outbuflen);

	if (pAfpFsdCmdPkt == NULL)
	{
		if (path.Buffer != NULL)
		{
			AfpFreeMemory(path.Buffer);
		}
		return;
	}

	// Fill in the command data
	pAfpFsdCmdPkt->Data.Eventlog.MsgID		 = MsgId;
	pAfpFsdCmdPkt->Data.Eventlog.EventType	= EventType;
	pAfpFsdCmdPkt->Data.Eventlog.StringCount = (USHORT)stringcount;
	pAfpFsdCmdPkt->Data.Eventlog.DumpDataLen = RawDataLen + extradatalen;
	// Fill in the offset to the dump data
	pAfpFsdCmdPkt->Data.Eventlog.pDumpData = tmpptr = (PBYTE)0 +
												sizeof(AFP_FSD_CMD_HEADER) +
												sizeof(AFP_EVENTLOG_DESC);

	 OFFSET_TO_POINTER(tmpptr, pAfpFsdCmdPkt);

	if (tmpptr == NULL)
	{
		if (path.Buffer != NULL)
		{
			AfpFreeMemory(path.Buffer);
			path.Buffer = NULL;
		}
		if (pAfpFsdCmdPkt != NULL)
		{
			AfpFreeMemory(pAfpFsdCmdPkt);
			pAfpFsdCmdPkt = NULL;
		}
		return;
	}

	if (EventType == EVENTLOG_ERROR_TYPE)
	{
		RtlCopyMemory(tmpptr, &File_Line, sizeof(File_Line));
		tmpptr += sizeof(File_Line);
		RtlCopyMemory(tmpptr, &Status, sizeof(Status));
		tmpptr += sizeof(Status);
	}

	RtlCopyMemory(tmpptr, RawDataBuf, RawDataLen);
	tmpptr += RawDataLen;

	// Align tmpptr on DWORD boundary for filling in string pointers
	tmpptr = (PBYTE)DWLEN((ULONG_PTR)tmpptr);

	if (tmpptr == NULL)
	{
		if (path.Buffer != NULL)
		{
			AfpFreeMemory(path.Buffer);
			path.Buffer = NULL;
		}
		if (pAfpFsdCmdPkt != NULL)
		{
			AfpFreeMemory(pAfpFsdCmdPkt);
			pAfpFsdCmdPkt = NULL;
		}
		return;
	}

	// Fill in the offset to the insertion string pointers
	pAfpFsdCmdPkt->Data.Eventlog.ppStrings = (PWSTR *)(tmpptr - (PBYTE)pAfpFsdCmdPkt);
	ppstr = (PWSTR *)tmpptr;
	ASSERT(((ULONG_PTR)ppstr & 3) == 0);
	*ppstr = NULL;

	// Advance over the string pointers to the place we will copy the strings
	tmpptr += stringcount * sizeof(PWSTR);
	ASSERT((LONG)(tmpptr - (PBYTE)pAfpFsdCmdPkt) < outbuflen);

	// If a handle was supplied, its path will always be the first string
	if (path.Length > 0)
	{
		ASSERT((LONG)(tmpptr + path.Length - (PBYTE)pAfpFsdCmdPkt) < outbuflen);
		RtlCopyMemory(tmpptr, path.Buffer, path.Length);
		*ppstr = (PWSTR)(tmpptr - (PBYTE)pAfpFsdCmdPkt);
		ppstr ++;
		tmpptr += path.Length;
		ASSERT((LONG)(tmpptr + sizeof(WCHAR) - (PBYTE)pAfpFsdCmdPkt) <=
												outbuflen);
		*(PWCHAR)tmpptr = UNICODE_NULL;
		tmpptr += sizeof(WCHAR);
		AfpFreeMemory(path.Buffer);
	}

	ASSERT((LONG)(tmpptr + String1Len - (PBYTE)pAfpFsdCmdPkt) <
												outbuflen);
	if (String1Len > 0)
	{
		RtlCopyMemory(tmpptr, String1, String1Len);
		*ppstr = (LPWSTR)(tmpptr - (ULONG_PTR)pAfpFsdCmdPkt);
		tmpptr += String1Len;
		ASSERT((LONG)(tmpptr + sizeof(WCHAR) - (PBYTE)pAfpFsdCmdPkt) <=
											outbuflen);
		*(PWCHAR)tmpptr = UNICODE_NULL;
	}


	afpQueueSecWorkItem(AFP_FSD_CMD_LOG_EVENT,
						NULL,
						NULL,
						pAfpFsdCmdPkt,
						outbuflen,
						afpCompleteLogEvent);
}

/***	afpCompleteLogEvent
 *
 *	This routine will be called by AfpSecurityUtilityWorker when the
 *  thread that processed the AfpLogEvent returns.  All this does is frees
 *  up the work item memory.
 */
LOCAL VOID
afpCompleteLogEvent(
	IN	ULONG	Index,
	IN	PVOID	pInBuf
)
{

	PAGED_CODE();

	AfpFreeMemory(afpSecurityThread[Index].pSecWorkItem->pOutput);
	AfpFreeMemory(afpSecurityThread[Index].pSecWorkItem);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\server\time.h ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	time.h

Abstract:

	This file defines macros and prototypes for time related operations.
	header files.

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	25 Apr 1992		Initial Version

Notes:	Tab stop: 4
--*/


#ifndef	_TIME_
#define	_TIME_

#define	AfpGetPerfCounter(pTime)	*(pTime) = KeQueryPerformanceCounter(NULL)

extern
VOID
AfpGetCurrentTimeInMacFormat(
	OUT	PAFPTIME 	MacTime
);


extern
AFPTIME
AfpConvertTimeToMacFormat(
	IN	PTIME		pSomeTime
);

extern
VOID
AfpConvertTimeFromMacFormat(
	IN	AFPTIME		MacTime,
	OUT PTIME		pNtTime
);

#endif	// _TIME_


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\server\tcp.h ===
/*

Copyright (c) 1998  Microsoft Corporation

Module Name:

	tcp.h

Abstract:

	This module contains definitions, declarations relevant to AFP/TCP


Author:

	Shirish Koti


Revision History:
	22 Jan 1998		Initial Version

--*/

#ifndef _TCP_
#define _TCP_

#define INVALID_HANDLE_VALUE          ((HANDLE)(-1))

#define AFP_TCP_BINDNAME        L"\\Device\\Tcp"
#define AFP_TCP_PORT            548

#define DSI_ADAPTER_SIGNATURE    *(DWORD *)"TADP"
#define DSI_CONN_SIGNATURE       *(DWORD *)"TCON"
#define DSI_REQUEST_SIGNATURE    *(DWORD *)"DREQ"

// number of connections on the free list
#define DSI_INIT_FREECONNLIST_SIZE   10

typedef ULONG   IPADDRESS;

// let's not send more than 10 ipaddresses to the Mac
#define DSI_MAX_IPADDR_COUNT    10

#define DSI_NETWORK_ADDR_LEN    6
#define DSI_NETWORK_ADDR_IPTAG  0x01

#define ATALK_NETWORK_ADDR_LEN      6
#define ATALK_NETWORK_ADDR_ATKTAG   0x03


#define DSI_HEADER_SIZE         16

#define DSI_TICKLE_TIMER        30   // every 30 seconds, see who needs a tickle
#define DSI_TICKLE_TIME_LIMIT   30   // if 30+ seconds since we last heard, send tickle

// the only DSI packets (i.e. packets that originate from the DSI layer) are
// for DsiOpenSession, DsiCloseSession and DsiTickle.  DsiOpenSession is the
// largest of these because it has the 6 bytes of options.  The spec says that
// this is a variable length field, but it only has given one option (Server
// Request Quantum) that the server can send.  If more options are ever defined,
// this define will have to change.  For now, only 6 additional bytes
//
#define DSI_MAX_DSI_OPTION_LEN  6
#define DSI_OPENSESS_OPTION_LEN 4
#define DSI_OPTION_FIXED_LEN    2

#define DSI_MAX_DSI_PKT_SIZE    (DSI_HEADER_SIZE + DSI_MAX_DSI_OPTION_LEN)

// round off to dword-align
#define DSI_BUFF_SIZE        ((DSI_MAX_DSI_PKT_SIZE) + (4 - (DSI_MAX_DSI_PKT_SIZE%4)))


//
// the htonX macros 'lifted' from sockets\netinet\in.h
//
#if (defined(_M_IX86) && (_MSC_FULL_VER > 13009037)) || ((defined(_M_AMD64) || defined(_M_IA64)) && (_MSC_FULL_VER > 13009175))
#define htons(x) _byteswap_ushort((USHORT)(x))
#define htonl(x) _byteswap_ulong((ULONG)(x))
#else
#define htons(x)        ((((x) >> 8) & 0x00FF) | (((x) << 8) & 0xFF00))

#define htonl(x)        ((((x) >> 24) & 0x000000FFL) | \
                         (((x) >>  8) & 0x0000FF00L) | \
                         (((x) <<  8) & 0x00FF0000L) | \
                         (((x) << 24) & 0xFF000000L))
#endif
#define ntohs(x)    htons(x)
#define ntohl(x)    htonl(x)

typedef NTSTATUS (FASTCALL *DSI_WORKER)(IN PVOID Context);

typedef struct _IpAddrEntity
{
    LIST_ENTRY  Linkage;
    IPADDRESS   IpAddress;

} IPADDRENTITY, *PIPADDRENTITY;


typedef struct _TcpAdptr
{
    DWORD               adp_Signature;
    DWORD               adp_RefCount;
    DWORD               adp_State;
    LIST_ENTRY          adp_ActiveConnHead;
    LIST_ENTRY          adp_FreeConnHead;
    DWORD               adp_NumFreeConnections;
    AFP_SPIN_LOCK       adp_SpinLock;
    HANDLE              adp_FileHandle;
    PFILE_OBJECT        adp_pFileObject;

} TCPADPTR, *PTCPADPTR;


// values for the adp_State field of TCPADPTR
#define TCPADPTR_STATE_INIT         0x1
#define TCPADPTR_STATE_BOUND        0x2
#define TCPADPTR_STATE_CLOSING      0x4
#define TCPADPTR_STATE_CLEANED_UP   0x8

//
// the DSI Commands
//
#define DSI_COMMAND_CLOSESESSION 1
#define DSI_COMMAND_COMMAND      2
#define DSI_COMMAND_GETSTATUS    3
#define DSI_COMMAND_OPENSESSION  4
#define DSI_COMMAND_TICKLE       5
#define DSI_COMMAND_WRITE        6
#define DSI_COMMAND_ATTENTION    8


//
// call-ins into AFP
//
#define AfpCB_SessionNotify       AfpSdaCreateNewSession
#define AfpCB_RequestNotify       afpSpHandleRequest
#define AfpCB_GetWriteBuffer      AfpGetWriteBuffer
#define AfpCB_ReplyCompletion     afpSpReplyComplete
#define AfpCB_AttnCompletion      afpSpAttentionComplete
#define AfpCB_CloseCompletion     afpSpCloseComplete

typedef struct _DsiReq
{
    LIST_ENTRY      dsi_Linkage;
    DWORD           dsi_Signature;
    struct _TcpConn *dsi_pTcpConn;       // the connection that this req belongs to
    REQUEST         dsi_AfpRequest;      // the request structure for AFP's use
    DWORD           dsi_RequestLen;      // how many bytes in the DSI command
    DWORD           dsi_WriteLen;        // total bytes to write (only in DSIWrite)
    USHORT          dsi_RequestID;       // what's the request ID
    BYTE            dsi_Command;         // what command is it
    BYTE            dsi_Flags;           // is this a request or a response?
    PBYTE           dsi_PartialBuf;      // buffer, in case partial data arrives
    DWORD           dsi_PartialBufSize;  // number of bytes in the partial buffer
    DWORD           dsi_PartialWriteSize; // number of bytes of the Write got so far
    PMDL            dsi_pDsiAllocedMdl;   // our mdl, if afp doesn't give us one
    PVOID           dsi_AttnContext;      // afp's context for SendAttention
    BYTE            dsi_RespHeader[DSI_BUFF_SIZE];  // header during response
} DSIREQ, *PDSIREQ;


typedef struct _TcpConn
{
    LIST_ENTRY          con_Linkage;
    DWORD               con_Signature;
    PTCPADPTR           con_pTcpAdptr;
    DWORD               con_RefCount;
    USHORT              con_State;
    USHORT              con_RcvState;
    DWORD               con_BytesWithTcp;
    DWORD               con_LastHeard;
    IPADDRESS           con_DestIpAddr;
    PDSIREQ             con_pDsiReq;
    LIST_ENTRY          con_PendingReqs;
    PSDA                con_pSda;
    PIRP                con_pRcvIrp;
    DWORD               con_MaxAttnPktSize;
    USHORT              con_OutgoingReqId;
    USHORT              con_NextReqIdToRcv;
    HANDLE              con_FileHandle;
    PFILE_OBJECT        con_pFileObject;
    AFP_SPIN_LOCK       con_SpinLock;
} TCPCONN, *PTCPCONN;


// values for the con_State field of TCPCONN
#define TCPCONN_STATE_INIT                  0x001
#define TCPCONN_STATE_CONNECTED             0x002
#define TCPCONN_STATE_AFP_ATTACHED          0x004
#define TCPCONN_STATE_NOTIFY_AFP            0x008
#define TCPCONN_STATE_NOTIFY_TCP            0x010
#define TCPCONN_STATE_PARTIAL_DATA          0x020
#define TCPCONN_STATE_TCP_HAS_IRP           0x040
#define TCPCONN_STATE_TICKLES_STOPPED       0x080
#define TCPCONN_STATE_CLOSING               0x100
#define TCPCONN_STATE_ABORTIVE_DISCONNECT   0x200
#define TCPCONN_STATE_RCVD_REMOTE_CLOSE     0x400
#define TCPCONN_STATE_CLEANED_UP            0x800


// values for con_RcvState field of TCPCONN
#define DSI_NEW_REQUEST         0    // waiting for new request
#define DSI_PARTIAL_HEADER      1    // got 1 or more but, less than 16 bytes of hdr
#define DSI_HDR_COMPLETE        2    // got full header, but 0 data
#define DSI_PARTIAL_COMMAND     3    // got full hdr, and part of data
#define DSI_COMMAND_COMPLETE    4    // got hdr and all the data with it
#define DSI_AWAITING_WRITE_MDL  5    // awaiting write mdl from afp server
#define DSI_PARTIAL_WRITE       6    // write command in progress
#define DSI_WRITE_COMPLETE      7    // all write bytes are in

#define DSI_REQUEST     0
#define DSI_REPLY       1

#define DSI_OFFSET_FLAGS            0
#define DSI_OFFSET_COMMAND          1
#define DSI_OFFSET_REQUESTID        2
#define DSI_OFFSET_DATAOFFSET       4
#define DSI_OFFSET_ERROROFFSET      4
#define DSI_OFFSET_DATALEN          8
#define DSI_OFFSET_RESERVED         12

#define DSI_OFFSET_OPTION_TYPE      0
#define DSI_OFFSET_OPTION_LENGTH    1
#define DSI_OFFSET_OPTION_OPTION    2

#define DSI_OPTION_SRVREQ_QUANTUM   0

#define DSI_SERVER_REQUEST_QUANTUM    65535

//
// get the relevant info from the DSI header.  If it's a Write
// request, the Enclosed Data Offset field contains how big the
// request part is.  The Total Data Length field contains how many
// bytes follow the DSI header.  The difference between the two
// is the size of the Write.
//

#define DSI_PARSE_HEADER(_pDsiReq, _Buffer)                         \
{                                                                   \
    (_pDsiReq)->dsi_Flags = (_Buffer)[DSI_OFFSET_FLAGS];            \
    (_pDsiReq)->dsi_Command = (_Buffer)[DSI_OFFSET_COMMAND];        \
                                                                    \
    GETSHORT2SHORT((&((_pDsiReq)->dsi_RequestID)),                  \
                   (&(_Buffer)[DSI_OFFSET_REQUESTID]));             \
                                                                    \
    if ((_pDsiReq)->dsi_Command == DSI_COMMAND_WRITE)               \
    {                                                               \
        GETDWORD2DWORD((&((_pDsiReq)->dsi_RequestLen)),             \
                       (&(_Buffer)[DSI_OFFSET_DATAOFFSET]));        \
                                                                    \
        GETDWORD2DWORD((&((_pDsiReq)->dsi_WriteLen)),               \
                       (&(_Buffer)[DSI_OFFSET_DATALEN]));           \
                                                                    \
        (_pDsiReq)->dsi_WriteLen -= (_pDsiReq)->dsi_RequestLen;     \
    }                                                               \
    else                                                            \
    {                                                               \
        GETDWORD2DWORD((&((_pDsiReq)->dsi_RequestLen)),             \
                       (&(_Buffer)[DSI_OFFSET_DATALEN]));           \
    }                                                               \
}


typedef struct _DsiHeader
{
    BYTE        Flags;
    BYTE        Command;
    USHORT      RequestID;
    DWORD       DataOffset;
    DWORD       TotalLength;
    DWORD       Reserved;
} DSIHEADER, *PDSIHEADER;


typedef struct _TcpWorkItem
{
    WORK_ITEM       tcp_WorkItem;
    DSI_WORKER      tcp_Worker;
    PVOID           tcp_Context;
} TCPWORKITEM, *PTCPWORKITEM;

#define VALID_TCPCONN(_pTcpConn)                                       \
    ((_pTcpConn->con_Signature == DSI_CONN_SIGNATURE) &&               \
     (_pTcpConn->con_RefCount > 0 && _pTcpConn->con_RefCount < 5000))   \


#define DsiTerminateConnection(pTcpConn)    \
        DsiKillConnection(pTcpConn, 0)

#define DsiAbortConnection(pTcpConn)        \
        DsiKillConnection(pTcpConn, TDI_DISCONNECT_ABORT)


//
// the globals
//

GLOBAL  PTCPADPTR       DsiTcpAdapter EQU NULL;

GLOBAL  AFP_SPIN_LOCK   DsiAddressLock;
GLOBAL  LIST_ENTRY      DsiIpAddrList;

GLOBAL  PBYTE           DsiStatusBuffer EQU NULL;
GLOBAL  DWORD           DsiStatusBufferSize EQU 0;

GLOBAL  BOOLEAN         DsiTcpEnabled EQU TRUE;

GLOBAL  AFP_SPIN_LOCK   DsiResourceLock;
GLOBAL  LIST_ENTRY      DsiFreeRequestList;
GLOBAL  DWORD           DsiFreeRequestListSize EQU 0;

GLOBAL  DWORD           DsiNumTcpConnections EQU 0;

GLOBAL  KEVENT          DsiShutdownEvent EQU {0};

//
// prototypes for functions in dsi.c
//

NTSTATUS
DsiAfpSetStatus(
    IN  PVOID   Context,
    IN  PUCHAR  pStatusBuf,
    IN  USHORT  StsBufSize
);

NTSTATUS
DsiAfpCloseConn(
    IN  PTCPCONN    pTcpConn
);

NTSTATUS
DsiAfpFreeConn(
    IN  PTCPCONN    pTcpConn
);

NTSTATUS FASTCALL
DsiAfpListenControl(
    IN  PVOID       Context,
    IN  BOOLEAN     Enable
);

NTSTATUS FASTCALL
DsiAfpWriteContinue(
    IN  PREQUEST    pRequest
);

NTSTATUS FASTCALL
DsiAfpReply(
    IN  PREQUEST    pRequest,
    IN  PBYTE       pResultCode
);

NTSTATUS
DsiAfpSendAttention(
    IN  PTCPCONN    pTcpConn,
    IN  USHORT      AttentionWord,
    IN  PVOID       pContext
);

NTSTATUS
DsiAcceptConnection(
    IN  PTCPADPTR       pTcpAdptr,
    IN  IPADDRESS       MacIpAddr,
    OUT PTCPCONN       *ppRetTcpConn
);


NTSTATUS
DsiProcessData(
    IN  PTCPCONN    pTcpConn,
    IN  ULONG       BytesIndicated,
    IN  ULONG       BytesAvailable,
    IN  PBYTE       pDsiData,
    OUT PULONG      pBytesAccepted,
    OUT PIRP       *ppRetIrp
);


BOOLEAN
DsiValidateHeader(
    IN  PTCPCONN    pTcpConn,
    IN  PDSIREQ     pDsiReq
);


NTSTATUS
DsiAfpReplyCompletion(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             pIrp,
    IN PVOID            pContext
);


NTSTATUS
DsiAcceptConnectionCompletion(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             pIrp,
    IN PVOID            Context
);

BOOLEAN
DsiKillConnection(
    IN  PTCPCONN    pTcpConn,
    IN DWORD        DiscFlag
);

NTSTATUS
DsiDisconnectWithTcp(
    IN  PTCPCONN    pTcpConn,
    IN DWORD        DiscFlag
);

NTSTATUS
DsiDisconnectWithAfp(
    IN  PTCPCONN    pTcpConn,
    IN  NTSTATUS    Reason
);

NTSTATUS
DsiTcpDisconnectCompletion(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             pIrp,
    IN PVOID            Context
);

NTSTATUS
DsiTcpRcvIrpCompletion(
    IN  PDEVICE_OBJECT  Unused,
    IN  PIRP            pIrp,
    IN  PVOID           pContext
);

NTSTATUS
DsiExecuteCommand(
    IN  PTCPCONN    pTcpConn,
    IN  PDSIREQ     pDsiReq
);


NTSTATUS
DsiOpenSession(
    IN  PTCPCONN    pTcpConn,
    IN  PDSIREQ     pDsiReq
);

NTSTATUS
DsiSendDsiRequest(
    IN  PTCPCONN    pTcpConn,
    IN  DWORD       DataLen,
    IN  USHORT      AttentionWord,
    IN  PVOID       AttentionContext,
    IN  BYTE        Command
);

NTSTATUS
DsiSendDsiReply(
    IN  PTCPCONN    pTcpConn,
    IN  PDSIREQ     pDsiReq,
    IN  NTSTATUS    OpStatus
);

NTSTATUS
DsiSendStatus(
    IN  PTCPCONN    pTcpConn,
    IN  PDSIREQ     pDsiReq
);


AFPSTATUS FASTCALL
DsiSendTickles(
    IN  PVOID pUnUsed
);


NTSTATUS
DsiSendCompletion(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             pIrp,
    IN PVOID            pContext
);



//
// prototypes for functions in tcptdi.c
//

NTSTATUS
DsiOpenTdiAddress(
    IN  PTCPADPTR       pTcpAdptr,
    OUT PHANDLE         pRetFileHandle,
    OUT PFILE_OBJECT   *ppRetFileObj
);


NTSTATUS
DsiOpenTdiConnection(
    IN PTCPCONN     pTcpConn
);

NTSTATUS
DsiAssociateTdiConnection(
    IN PTCPCONN     pTcpConn
);

NTSTATUS
DsiSetEventHandler(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PFILE_OBJECT     pFileObject,
    IN ULONG            EventType,
    IN PVOID            EventHandler,
    IN PVOID            Context
);

NTSTATUS
DsiTdiSynchronousIrp(
    IN PIRP             pIrp,
    PDEVICE_OBJECT      pDeviceObject
);

NTSTATUS
DsiTdiCompletionRoutine(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
);


NTSTATUS
DsiTdiSend(
    IN  PTCPCONN    pTcpConn,
    IN  PMDL        pMdl,
    IN  DWORD       DataLen,
    IN  PVOID       pCompletionRoutine,
    IN  PVOID       pContext
);

VOID
DsiIpAddressCameIn(
    IN  PTA_ADDRESS         Address,
    IN  PUNICODE_STRING     DeviceName,
    IN  PTDI_PNP_CONTEXT    Context2
);

VOID
DsiIpAddressWentAway(
    IN  PTA_ADDRESS         Address,
    IN  PUNICODE_STRING     DeviceName,
    IN  PTDI_PNP_CONTEXT    Context2
);

NTSTATUS
DsiTdiConnectHandler(
    IN PVOID                EventContext,
    IN int                  MacIpAddrLen,
    IN PVOID                pSrcAddress,
    IN int                  DsiDataLength,
    IN PVOID                pDsiData,
    IN int                  OptionsLength,
    IN PVOID                pOptions,
    OUT CONNECTION_CONTEXT  *pOurConnContext,
    OUT PIRP                *ppOurAcceptIrp
);

NTSTATUS
DsiTdiReceiveHandler(
    IN  PVOID       EventContext,
    IN  PVOID       ConnectionContext,
    IN  USHORT      RcvFlags,
    IN  ULONG       BytesIndicated,
    IN  ULONG       BytesAvailable,
    OUT PULONG      pBytesAccepted,
    IN  PVOID       pDsiData,
    OUT PIRP       *ppIrp
);

NTSTATUS
DsiTdiDisconnectHandler(
    IN PVOID        EventContext,
    IN PVOID        ConnectionContext,
    IN ULONG        DisconnectDataLength,
    IN PVOID        pDisconnectData,
    IN ULONG        DisconnectInformationLength,
    IN PVOID        pDisconnectInformation,
    IN ULONG        DisconnectIndicators
);

NTSTATUS
DsiTdiErrorHandler(
    IN PVOID    EventContext,
    IN NTSTATUS Status
);


NTSTATUS
DsiCloseTdiAddress(
    IN PTCPADPTR    pTcpAdptr
);

NTSTATUS
DsiCloseTdiConnection(
    IN PTCPCONN     pTcpConn
);

//
// prototypes for functions in tcputil.c
//

VOID
DsiInit(
    IN VOID
);

NTSTATUS FASTCALL
DsiCreateAdapter(
    IN VOID
);

BOOLEAN
IsThisOnAppletalksDefAdapter(
    IN PUNICODE_STRING  pBindDeviceName
);

NTSTATUS FASTCALL
DsiCreateTcpConn(
    IN PTCPADPTR    pTcpAdptr
);

NTSTATUS
DsiAddIpaddressToList(
    IN  IPADDRESS   IpAddress
);

BOOLEAN
DsiRemoveIpaddressFromList(
    IN  IPADDRESS   IpAddress
);

PDSIREQ
DsiGetRequest(
    IN VOID
);

PBYTE
DsiGetReqBuffer(
    IN DWORD    BufLen
);

VOID
DsiFreeRequest(
    PDSIREQ     pDsiReq
);

VOID
DsiFreeReqBuffer(
    IN PBYTE    pBuffer
);

VOID
DsiDereferenceAdapter(
    IN PTCPADPTR    pTcpAdptr
);

VOID
DsiDereferenceConnection(
    IN PTCPCONN     pTcpConn
);

NTSTATUS
DsiDestroyAdapter(
    IN VOID
);

NTSTATUS FASTCALL
DsiFreeAdapter(
    IN PTCPADPTR    pTcpAdptr
);

NTSTATUS FASTCALL
DsiFreeConnection(
    IN PTCPCONN     pTcpConn
);

NTSTATUS
DsiGetIpAddrBlob(
    IN DWORD    *pIpAddrCount,
    IN PBYTE    *ppIpAddrBlob
);

PIRP
DsiGetIrpForTcp(
    IN  PTCPCONN    pTcpConn,
    IN  PBYTE       pBuffer,
    IN  PMDL        pInputMdl,
    IN  DWORD       ReadSize
);

PMDL
DsiMakePartialMdl(
    IN  PMDL        pOrgMdl,
    IN  DWORD       dwOffset
);

NTSTATUS FASTCALL
DsiUpdateAfpStatus(
    IN PVOID    Unused
);

NTSTATUS
DsiScheduleWorkerEvent(
    IN  DSI_WORKER      WorkerRoutine,
    IN  PVOID           Context
);

VOID FASTCALL
DsiWorker(
    IN PVOID    Context
);

PTCPADPTR
DsiRefAdptrByBindName(
    IN  PUNICODE_STRING    pBindDeviceName
);

VOID
DsiShutdown(
    IN VOID
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\server\tcputil.c ===
/*

Copyright (c) 1998  Microsoft Corporation

Module Name:

	tcputil.c

Abstract:

	This module contains utility routines that used to implement the AFP/TCP interface


Author:

	Shirish Koti


Revision History:
	22 Jan 1998		Initial Version

--*/

#define	FILENUM	FILE_TCPUTIL

#include <afp.h>
#include <scavengr.h>



/***	DsiInit
 *
 *	This routine initialization of DSI related globals
 *
 *  Returns:  nothing
 *
 */
VOID
DsiInit(
    IN VOID
)
{
    DsiTcpAdapter = NULL;

    INITIALIZE_SPIN_LOCK(&DsiAddressLock);

    INITIALIZE_SPIN_LOCK(&DsiResourceLock);

    InitializeListHead(&DsiFreeRequestList);
    InitializeListHead(&DsiIpAddrList);

    KeInitializeEvent(&DsiShutdownEvent, NotificationEvent, False);

    //
    // initialize the function table of entry points into DSI
    //
    AfpDsiEntries.asp_AtalkAddr.Address = 0;
    AfpDsiEntries.asp_AspCtxt   = NULL;
    AfpDsiEntries.asp_SetStatus = DsiAfpSetStatus;
    AfpDsiEntries.asp_CloseConn = DsiAfpCloseConn;
    AfpDsiEntries.asp_FreeConn  = DsiAfpFreeConn;
    AfpDsiEntries.asp_ListenControl = DsiAfpListenControl;
    AfpDsiEntries.asp_WriteContinue = DsiAfpWriteContinue;
    AfpDsiEntries.asp_Reply = DsiAfpReply;
    AfpDsiEntries.asp_SendAttention = DsiAfpSendAttention;

}



/***	DsiCreateAdapter
 *
 *	This routine creates an adapter object.  It's called whenever TDI tells us that
 *  a tcpip interface became available
 *
 *  Returns:  status of operation
 *
 */
NTSTATUS FASTCALL
DsiCreateAdapter(
    IN VOID
)
{
    NTSTATUS            status;
    PTCPADPTR           pTcpAdptr;
    PTCPADPTR           pCurrTcpAdptr;
    KIRQL               OldIrql;
    HANDLE              FileHandle;
    PFILE_OBJECT        pFileObject;
    DWORD               i;


    KeClearEvent(&DsiShutdownEvent);

    pTcpAdptr = (PTCPADPTR)AfpAllocZeroedNonPagedMemory(sizeof(TCPADPTR));
    if (pTcpAdptr == NULL)
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiCreateInterface: alloc for PTCPADPTR failed\n"));

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto DsiCreateAdapter_ErrExit;
    }

    pTcpAdptr->adp_Signature = DSI_ADAPTER_SIGNATURE;

    pTcpAdptr->adp_RefCount  = 1;                   // creation refcount

    pTcpAdptr->adp_State     = TCPADPTR_STATE_INIT;

    InitializeListHead(&pTcpAdptr->adp_ActiveConnHead);
    InitializeListHead(&pTcpAdptr->adp_FreeConnHead);

    INITIALIZE_SPIN_LOCK(&pTcpAdptr->adp_SpinLock);

    pTcpAdptr->adp_FileHandle = INVALID_HANDLE_VALUE;
    pTcpAdptr->adp_pFileObject = NULL;


    //
    // ok, save this adapter as our global adapter (there can only be one
    // "adapter" active at any time.
    //

    ACQUIRE_SPIN_LOCK(&DsiAddressLock, &OldIrql);

    ASSERT(DsiTcpAdapter == NULL);

    if (DsiTcpAdapter == NULL)
    {
        DsiTcpAdapter = pTcpAdptr;
        status = STATUS_SUCCESS;
        RELEASE_SPIN_LOCK(&DsiAddressLock, OldIrql);

    }
    else
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiCreateAdapter: DsiTcpAdapter is not NULL!\n"));
        ASSERT(0);

        status = STATUS_ADDRESS_ALREADY_EXISTS;
        RELEASE_SPIN_LOCK(&DsiAddressLock, OldIrql);
        goto DsiCreateAdapter_ErrExit;
    }


    //
    // create TDI address for the AFP port
    //
    status = DsiOpenTdiAddress(pTcpAdptr,
                               &FileHandle,
                               &pFileObject);
    if (!NT_SUCCESS(status))
    {
	    DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiCreateAdapter: ...TdiAddr.. failed %lx on %lx!\n",
            status,pTcpAdptr));

        goto DsiCreateAdapter_ErrExit;
    }


    ACQUIRE_SPIN_LOCK(&pTcpAdptr->adp_SpinLock, &OldIrql);

    pTcpAdptr->adp_FileHandle = FileHandle;
    pTcpAdptr->adp_pFileObject = pFileObject;

    // mark that we now have opened the tdi address object
    pTcpAdptr->adp_State |= TCPADPTR_STATE_BOUND;

    // we are going to create DSI_INIT_FREECONNLIST_SIZE connections to put
    // on the free list.  Idea is at any time, so many (currently 2) connections
    // should be on the free list.

    pTcpAdptr->adp_RefCount += DSI_INIT_FREECONNLIST_SIZE;

    RELEASE_SPIN_LOCK(&pTcpAdptr->adp_SpinLock, OldIrql);

    //
    // now, schedule an event to create those connections for the free list
    //
    for (i=0; i<DSI_INIT_FREECONNLIST_SIZE; i++)
    {
        DsiScheduleWorkerEvent(DsiCreateTcpConn, pTcpAdptr);
    }

    ACQUIRE_SPIN_LOCK(&DsiAddressLock, &OldIrql);
    AfpServerBoundToTcp = TRUE;
    RELEASE_SPIN_LOCK(&DsiAddressLock, OldIrql);

    // start off tickle timer (monitor all connections to see who needs a tickle)
    AfpScavengerScheduleEvent(DsiSendTickles, NULL, DSI_TICKLE_TIMER, False);

    DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,("AFP/TCP bound and ready\n"));

    //
    // if we came this far, all went well: return success
    //
    return(STATUS_SUCCESS);


//
// Error path
//
DsiCreateAdapter_ErrExit:

    DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
        ("DsiCreateAdapter: couldn't create global adapter (%lx)\n",status));

    ASSERT(0);

    if (status != STATUS_ADDRESS_ALREADY_EXISTS)
    {
        ACQUIRE_SPIN_LOCK(&DsiAddressLock, &OldIrql);
        DsiTcpAdapter = NULL;
        RELEASE_SPIN_LOCK(&DsiAddressLock, OldIrql);
    }

    if (pTcpAdptr)
    {
        AfpFreeMemory(pTcpAdptr);
    }

    return(status);
}



/***	DsiCreateTcpConn
 *
 *	This routine creates a connection object, creates a tdi connection for it
 *  and associates it with the tdi address object for the AFP port, and finally
 *  puts it on the free connections list of the adapter in question.
 *
 *  Parm IN:  pTcpAdptr - adapter context
 *
 *  Returns:  status of operation
 *
 */
NTSTATUS FASTCALL
DsiCreateTcpConn(
    IN PTCPADPTR    pTcpAdptr
)
{
    PTCPCONN    pTcpConn;
    NTSTATUS    status;
    KIRQL       OldIrql;


    ASSERT(pTcpAdptr->adp_Signature == DSI_ADAPTER_SIGNATURE);


    pTcpConn = (PTCPCONN)AfpAllocZeroedNonPagedMemory(sizeof(TCPCONN));
    if (pTcpConn == NULL)
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiCreateTcpConn: alloc for TCPCONN failed\n"));

        // remove the CONN refcount (we put before calling this routine)
        DsiDereferenceAdapter(pTcpAdptr);
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    pTcpConn->con_pTcpAdptr      = pTcpAdptr;
    pTcpConn->con_Signature      = DSI_CONN_SIGNATURE;
    pTcpConn->con_State          = TCPCONN_STATE_INIT;
    pTcpConn->con_RcvState       = DSI_NEW_REQUEST;
    pTcpConn->con_DestIpAddr     = 0;
    pTcpConn->con_RefCount       = 1;
    pTcpConn->con_pDsiReq        = NULL;
    pTcpConn->con_FileHandle     = INVALID_HANDLE_VALUE;
    pTcpConn->con_pFileObject    = NULL;

    DBGREFCOUNT(("DsiCreateTcpConn: CREATION inc %lx (%d  %d,%d)\n",
        pTcpConn,pTcpConn->con_RefCount,pTcpConn->con_State,pTcpConn->con_RcvState));

    InitializeListHead(&pTcpConn->con_PendingReqs);

    //
    // initialize the TDI stuff for this connection and open handles
    //
    status = DsiOpenTdiConnection(pTcpConn);
    if (!NT_SUCCESS(status))
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiCreateTcpConn: ..TdiConn.. failed %lx\n",status));

        // remove the CONN refcount (we put before calling this routine)
        DsiDereferenceAdapter(pTcpAdptr);
        AfpFreeMemory(pTcpConn);
        return(status);
    }


    //
    // associate this connection with the addr object
    //
    status = DsiAssociateTdiConnection(pTcpConn);
    if (!NT_SUCCESS(status))
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiCreateTcpConn: ..AssociateTdiConn.. failed %lx\n",status));

        DsiCloseTdiConnection(pTcpConn);
        AfpFreeMemory(pTcpConn);
        // remove the CONN refcount (we put before calling this routine)
        DsiDereferenceAdapter(pTcpAdptr);
        return(status);
    }

    //
    // the connection is ready to be queued to the Free list.  Make sure the
    // addr object isn't closing before putting this puppy on the list
    //
    ACQUIRE_SPIN_LOCK(&pTcpAdptr->adp_SpinLock, &OldIrql);

    if (!(pTcpAdptr->adp_State & TCPADPTR_STATE_CLOSING))
    {
        InsertTailList(&pTcpAdptr->adp_FreeConnHead,&pTcpConn->con_Linkage);
        pTcpAdptr->adp_NumFreeConnections++;
        status = STATUS_SUCCESS;
    }
    else
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiCreateTcpConn: Failed #2, pTcpAdptr %lx is closing\n",pTcpAdptr));

        status = STATUS_INVALID_ADDRESS;
    }

    RELEASE_SPIN_LOCK(&pTcpAdptr->adp_SpinLock, OldIrql);

    //
    // if something went wrong, undo everything
    //
    if (!NT_SUCCESS(status))
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiCreateTcpConn: something went wrong status=%lx, conn not created\n",status));

        // close the TDI handles
        DsiCloseTdiConnection(pTcpConn);

        AfpFreeMemory(pTcpConn);

        // remove the CONN refcount (we put before calling this routine)
        DsiDereferenceAdapter(pTcpAdptr);
    }
    else
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_INFO,
            ("DsiCreateTcpConn: put new connection %lx on free list\n",pTcpConn));
    }

    return(status);
}



/***	DsiAddIpaddressToList
 *
 *	This routine saves an "active" ipaddress in our list of ipaddresses
 *
 *  Parm IN:  IpAddress - the ipaddress to save
 *
 *  Returns:  result of the operation
 *
 */
NTSTATUS
DsiAddIpaddressToList(
    IN  IPADDRESS   IpAddress
)
{
    KIRQL           OldIrql;
    PLIST_ENTRY     pList;
    PIPADDRENTITY   pIpaddrEntity;
    PIPADDRENTITY   pTmpIpaddrEntity;
    BOOLEAN         fAlreadyPresent=FALSE;


    pIpaddrEntity =
        (PIPADDRENTITY)AfpAllocZeroedNonPagedMemory(sizeof(IPADDRENTITY));
    if (pIpaddrEntity == NULL)
    {
	    DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiAddIpaddressToList: malloc failed! (%lx)\n",IpAddress));
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    pIpaddrEntity->IpAddress = IpAddress;

    ACQUIRE_SPIN_LOCK(&DsiAddressLock, &OldIrql);

    pList = DsiIpAddrList.Flink;

    while (pList != &DsiIpAddrList)
    {
        pTmpIpaddrEntity = CONTAINING_RECORD(pList, IPADDRENTITY, Linkage);
        if (pTmpIpaddrEntity->IpAddress == IpAddress)
        {
            fAlreadyPresent = TRUE;
            break;
        }
        pList = pList->Flink;
    }

    if (fAlreadyPresent)
    {
	    DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiAddIpaddressToList: %d.%d.%d.%d already present!\n",
            (IpAddress>>24)&0xFF,(IpAddress>>16)&0xFF,(IpAddress>>8)&0xFF,IpAddress&0xFF));

        ASSERT(0);

        RELEASE_SPIN_LOCK(&DsiAddressLock, OldIrql);
        return(STATUS_ADDRESS_ALREADY_EXISTS);
    }

    InsertTailList(&DsiIpAddrList, &pIpaddrEntity->Linkage);

    RELEASE_SPIN_LOCK(&DsiAddressLock, OldIrql);

    return(STATUS_SUCCESS);

}


/***	DsiRemoveIpaddressFromList
 *
 *	This routine remove ipaddress from our list of ipaddresses
 *
 *  Parm IN:  IpAddress - the ipaddress to remove
 *
 *  Returns:  TRUE if we removed the ipaddress, FALSE if we didn't
 *
 */
BOOLEAN
DsiRemoveIpaddressFromList(
    IN  IPADDRESS   IpAddress
)
{
    KIRQL           OldIrql;
    PLIST_ENTRY     pList;
    PIPADDRENTITY   pIpaddrEntity;
    BOOLEAN         fFoundInList=FALSE;


    ACQUIRE_SPIN_LOCK(&DsiAddressLock, &OldIrql);

    pList = DsiIpAddrList.Flink;

    while (pList != &DsiIpAddrList)
    {
        pIpaddrEntity = CONTAINING_RECORD(pList, IPADDRENTITY, Linkage);
        if (pIpaddrEntity->IpAddress == IpAddress)
        {
            fFoundInList = TRUE;
            break;
        }
        pList = pList->Flink;
    }

    if (!fFoundInList)
    {
	    DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiRemoveIpaddressFromList: %d.%d.%d.%d not in the list!\n",
            (IpAddress>>24)&0xFF,(IpAddress>>16)&0xFF,(IpAddress>>8)&0xFF,IpAddress&0xFF));

        ASSERT(0);

        RELEASE_SPIN_LOCK(&DsiAddressLock, OldIrql);
        return(FALSE);
    }

    RemoveEntryList(&pIpaddrEntity->Linkage);

    RELEASE_SPIN_LOCK(&DsiAddressLock, OldIrql);

    AfpFreeMemory(pIpaddrEntity);

    return(TRUE);
}



/***	DsiGetRequest
 *
 *	This routine allocates a DSI Request structure and returns.  For performance
 *  reasons, we don't alloc new memory each time, but save a list of these
 *
 *  Parm IN:  nothin'
 *
 *  Returns:  pointer to a DSIREQ strucutre (NULL on failure)
 *
 */
PDSIREQ
DsiGetRequest(
    IN VOID
)
{
    PDSIREQ         pDsiReq=NULL;
    PLIST_ENTRY     pList;
    KIRQL           OldIrql;


    ACQUIRE_SPIN_LOCK(&DsiResourceLock, &OldIrql);

    if (!IsListEmpty(&DsiFreeRequestList))
    {
        pList = RemoveHeadList(&DsiFreeRequestList);
        pDsiReq = CONTAINING_RECORD(pList, DSIREQ, dsi_Linkage);

        ASSERT(DsiFreeRequestListSize > 0);
        DsiFreeRequestListSize--;

        RtlZeroMemory(pDsiReq, sizeof(DSIREQ));
    }

    RELEASE_SPIN_LOCK(&DsiResourceLock, OldIrql);

    if (pDsiReq == NULL)
    {
        pDsiReq = (PDSIREQ)AfpAllocZeroedNonPagedMemory(sizeof(DSIREQ));
    }

    if (pDsiReq != NULL)
    {
        pDsiReq->dsi_Signature = DSI_REQUEST_SIGNATURE;

        InitializeListHead(&pDsiReq->dsi_Linkage);
    }
    else
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiGetRequest: malloc failed!\n"));
    }

    return(pDsiReq);
}



/***	DsiGetReqBuffer
 *
 *	This routine allocates a buffer to hold either a header or a command
 *  The likelihood of this function getting called is pretty slim (basically
 *  if a packet is fragmented by TCP).  So we simply make a call to alloc
 *
 *  Parm IN:  BufLen - length of the buffer requested
 *
 *  Returns:  pointer to a buffer (NULL on failure)
 *
 */
PBYTE
DsiGetReqBuffer(
    IN DWORD    BufLen
)
{
    PBYTE       pBuffer=NULL;

    pBuffer = AfpAllocNonPagedMemory(BufLen);

#if DBG
    if (pBuffer == NULL)
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
        ("DsiGetReqBuffer: malloc failed!\n"));
    }
#endif

    return(pBuffer);
}


/***	DsiFreeRequest
 *
 *	This routine frees up a previously allocated DSI Request structure.  Again,
 *  for performance reasons, we don't free up the memory but put this in a list
 *
 *  Parm IN:  pDsiReq - the request to be freed
 *
 *  Returns:  nothing
 *
 */
VOID
DsiFreeRequest(
    PDSIREQ     pDsiReq
)
{

    KIRQL           OldIrql;
    BOOLEAN         fQueueTooBig = TRUE;


    if ((pDsiReq->dsi_PartialBuf != NULL) &&
        (pDsiReq->dsi_PartialBuf != &pDsiReq->dsi_RespHeader[0]))
    {
        ASSERT(pDsiReq->dsi_PartialBufSize > 0);
        DsiFreeReqBuffer(pDsiReq->dsi_PartialBuf);

        pDsiReq->dsi_PartialBuf = NULL;
        pDsiReq->dsi_PartialBufSize = 0;
    }

    // if there was an Mdl we got via cache mgr, it had better be returned to system
    ASSERT(pDsiReq->dsi_AfpRequest.rq_CacheMgrContext == NULL);

    //
    // if we came here via abnormal disconnect, this could be non-null
    //
    if (pDsiReq->dsi_pDsiAllocedMdl)
    {
        AfpFreeMdl(pDsiReq->dsi_pDsiAllocedMdl);
    }

#if DBG
    RtlFillMemory(pDsiReq, sizeof(DSIREQ), 'f');
#endif

    ACQUIRE_SPIN_LOCK(&DsiResourceLock, &OldIrql);

    if (DsiFreeRequestListSize < DsiNumTcpConnections)
    {
        InsertTailList(&DsiFreeRequestList, &pDsiReq->dsi_Linkage);
        DsiFreeRequestListSize++;
        fQueueTooBig = FALSE;
    }

    RELEASE_SPIN_LOCK(&DsiResourceLock, OldIrql);

    if (fQueueTooBig)
    {
        AfpFreeMemory(pDsiReq);
    }


    return;
}


/***	DsiFreeReqBuffer
 *
 *	This routine allocates a buffer to hold either a header or a command
 *  The likelihood of this function getting called is pretty slim (basically
 *  if a packet is fragmented by TCP).  So we simply make a call to alloc
 *
 *  Parm IN:  BufLen - length of the buffer requested
 *
 *  Returns:  pointer to a buffer (NULL on failure)
 *
 */
VOID
DsiFreeReqBuffer(
    IN PBYTE    pBuffer
)
{
    ASSERT(pBuffer != NULL);

    AfpFreeMemory(pBuffer);

    return;
}


/***	DsiDereferenceAdapter
 *
 *	This routine dereferences the adapter object.  When refcount goes to 0, it
 *  removes it from the global list of adapters.  If at task time, it calls a
 *  routine to close tcp handles and free the memory.  If at dpc, it schedules
 *  an event to do the same.
 *
 *  Parm IN:  pTcpAdptr - adapter context
 *
 *  Returns:  nothin'
 *
 */
VOID
DsiDereferenceAdapter(
    IN PTCPADPTR    pTcpAdptr
)
{
    KIRQL       OldIrql;
    BOOLEAN     fDone=FALSE;


    ASSERT(pTcpAdptr->adp_Signature == DSI_ADAPTER_SIGNATURE);

    ACQUIRE_SPIN_LOCK(&pTcpAdptr->adp_SpinLock, &OldIrql);

    pTcpAdptr->adp_RefCount--;

    if (pTcpAdptr->adp_RefCount == 0)
    {
        fDone = TRUE;
        ASSERT(pTcpAdptr->adp_State & TCPADPTR_STATE_CLOSING);
    }

    RELEASE_SPIN_LOCK(&pTcpAdptr->adp_SpinLock, OldIrql);

    if (!fDone)
    {
        return;
    }

    //
    // this dude's life is over: do the needful to bid goodbye
    //

    // if we are at DPC, we need to do all the cleanup (file handle closing etc.)
    // at task time: queue an event
    if (KeGetCurrentIrql() == DISPATCH_LEVEL)
    {
        // queue an event, since we are at dpc
        DsiScheduleWorkerEvent(DsiFreeAdapter, pTcpAdptr);
    }
    else
    {
        DsiFreeAdapter(pTcpAdptr);
    }

    return;
}



/***	DsiDereferenceConnection
 *
 *	This routine dereferences the connection object.  When refcount goes to 0, it
 *  removes it from the list of connections.  If at task time, it calls a
 *  routine to close tcp handles and free the memory.  If at dpc, it schedules
 *  an event to do the same.
 *
 *  Parm IN:  pTcpConn - connection context
 *
 *  Returns:  nothin'
 *
 */
VOID
DsiDereferenceConnection(
    IN PTCPCONN     pTcpConn
)
{
    KIRQL       OldIrql;
    BOOLEAN     fDone=FALSE;


    ASSERT(VALID_TCPCONN(pTcpConn));

    ACQUIRE_SPIN_LOCK(&pTcpConn->con_SpinLock, &OldIrql);

    pTcpConn->con_RefCount--;

    if (pTcpConn->con_RefCount == 0)
    {
        fDone = TRUE;
        ASSERT(pTcpConn->con_State & TCPCONN_STATE_CLOSING);
    }

    RELEASE_SPIN_LOCK(&pTcpConn->con_SpinLock, OldIrql);

    if (!fDone)
    {
        return;
    }

    //
    // this dude's life is over: do the needful to bid goodbye
    //

#if 0
    // if we are at DPC, we need to do all the cleanup (file handle closing etc.)
    // at task time: queue an event
    if (KeGetCurrentIrql() == DISPATCH_LEVEL)
    {
        // queue an event, since we are at dpc
        DsiScheduleWorkerEvent(DsiFreeConnection, pTcpConn);
    }
    else
    {
        DsiFreeConnection(pTcpConn);
    }
#endif

    // schedule a worker event to free this connection
    DsiScheduleWorkerEvent(DsiFreeConnection, pTcpConn);

    return;
}


/***	DsiDestroyAdapter
 *
 *	This routine destroys the global adapter object.
 *
 *  Returns:  status of operation
 *
 */
NTSTATUS
DsiDestroyAdapter(
    IN VOID
)
{
    KIRQL               OldIrql;
    PLIST_ENTRY         pFreeList;
    PLIST_ENTRY         pActiveList;
    PTCPCONN            pTcpConn;
    BOOLEAN             fAlreadyCleanedUp=FALSE;


    if (DsiTcpAdapter == NULL)
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiDestroyAdapter: adapter gone!  How did this happen!!\n"));

        // unblock the event!
        KeSetEvent(&DsiShutdownEvent, IO_NETWORK_INCREMENT, False);
        return(STATUS_SUCCESS);
    }

    // stop the tickle timer
    if (!AfpScavengerKillEvent(DsiSendTickles, NULL))
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiDestroyAdapter: TickleTimer not running or hit timing window!!\n"));
    }

    ACQUIRE_SPIN_LOCK(&DsiTcpAdapter->adp_SpinLock, &OldIrql);

    if (DsiTcpAdapter->adp_State & TCPADPTR_STATE_CLEANED_UP)
    {
        fAlreadyCleanedUp = TRUE;
    }

    DsiTcpAdapter->adp_State |= TCPADPTR_STATE_CLOSING;
    DsiTcpAdapter->adp_State |= TCPADPTR_STATE_CLEANED_UP;

    if (fAlreadyCleanedUp)
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiDestroyAdapter: already destroyed!\n"));

        ASSERT(IsListEmpty(&DsiTcpAdapter->adp_FreeConnHead));
        ASSERT(IsListEmpty(&DsiTcpAdapter->adp_ActiveConnHead));
        ASSERT(DsiTcpAdapter->adp_NumFreeConnections == 0);

        RELEASE_SPIN_LOCK(&DsiTcpAdapter->adp_SpinLock, OldIrql);
        return(STATUS_SUCCESS);
    }

    //
    // free up all the connections from the Free list
    //
    while (!IsListEmpty(&DsiTcpAdapter->adp_FreeConnHead))
    {
        pFreeList = DsiTcpAdapter->adp_FreeConnHead.Flink;

        pTcpConn = CONTAINING_RECORD(pFreeList, TCPCONN, con_Linkage);

        RemoveEntryList(&pTcpConn->con_Linkage);

        ASSERT(DsiTcpAdapter->adp_NumFreeConnections > 0);

        DsiTcpAdapter->adp_NumFreeConnections--;

        InitializeListHead(&pTcpConn->con_Linkage);

        RELEASE_SPIN_LOCK(&DsiTcpAdapter->adp_SpinLock, OldIrql);

        pTcpConn->con_State |= TCPCONN_STATE_CLOSING;
        DsiDereferenceConnection(pTcpConn);

        DBGREFCOUNT(("DsiDestroyAdapter: Creation dec %lx (%d  %d,%d)\n",
            pTcpConn,pTcpConn->con_RefCount,pTcpConn->con_State,pTcpConn->con_RcvState));

        ACQUIRE_SPIN_LOCK(&DsiTcpAdapter->adp_SpinLock, &OldIrql);
    }

    //
    // kill all the connections from the Active list
    //
    pActiveList = DsiTcpAdapter->adp_ActiveConnHead.Flink;

    while (pActiveList != &DsiTcpAdapter->adp_ActiveConnHead)
    {
        pTcpConn = CONTAINING_RECORD(pActiveList, TCPCONN, con_Linkage);

        pActiveList = pActiveList->Flink;

        ACQUIRE_SPIN_LOCK_AT_DPC(&pTcpConn->con_SpinLock);

        // if this connection is already closing, skip it
        if (pTcpConn->con_State & TCPCONN_STATE_CLOSING)
        {
            RELEASE_SPIN_LOCK_FROM_DPC(&pTcpConn->con_SpinLock);
            continue;
        }

        // put ABORT refcount for now
        pTcpConn->con_RefCount++;

        DBGREFCOUNT(("DsiDestroyAdapter: ABORT inc %lx (%d  %d,%d)\n",
            pTcpConn,pTcpConn->con_RefCount,pTcpConn->con_State,pTcpConn->con_RcvState));

        RemoveEntryList(&pTcpConn->con_Linkage);
        InitializeListHead(&pTcpConn->con_Linkage);

        RELEASE_SPIN_LOCK_FROM_DPC(&pTcpConn->con_SpinLock);

        RELEASE_SPIN_LOCK(&DsiTcpAdapter->adp_SpinLock, OldIrql);

        DsiAbortConnection(pTcpConn);

        // remove that ABORT refcount
        DsiDereferenceConnection(pTcpConn);

        DBGREFCOUNT(("DsiDestroyAdapter: ABORT dec %lx (%d  %d,%d)\n",
            pTcpConn,pTcpConn->con_RefCount,pTcpConn->con_State,pTcpConn->con_RcvState));

        ACQUIRE_SPIN_LOCK(&DsiTcpAdapter->adp_SpinLock, &OldIrql);

        // since we released the lock, things could have changed: start over
        pActiveList = DsiTcpAdapter->adp_ActiveConnHead.Flink;
    }

    RELEASE_SPIN_LOCK(&DsiTcpAdapter->adp_SpinLock, OldIrql);

    // remove the creation refcount
    DsiDereferenceAdapter(DsiTcpAdapter);

    return(STATUS_SUCCESS);

}


/***	DsiKillConnection
 *
 *	This routine kills an active connection.
 *
 *  Parm IN:  pTcpConn - the connection to kill
 *
 *  Returns:  TRUE if we killed it, FALSE if we couldn't
 *
 */
BOOLEAN
DsiKillConnection(
    IN PTCPCONN     pTcpConn,
    IN DWORD        DiscFlag
)
{
    KIRQL           OldIrql;
    NTSTATUS        status;
    PDSIREQ         pPartialDsiReq=NULL;
    BOOLEAN         fFirstVisit=TRUE;



    ACQUIRE_SPIN_LOCK(&pTcpConn->con_SpinLock, &OldIrql);

    if (pTcpConn->con_State & TCPCONN_STATE_CLEANED_UP)
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_WARN,
            ("DsiKillConnection: connection %lx already cleaned up\n",pTcpConn));

        fFirstVisit = FALSE;
    }

    pTcpConn->con_State &= ~TCPCONN_STATE_CONNECTED;
    pTcpConn->con_State |= (TCPCONN_STATE_CLOSING | TCPCONN_STATE_CLEANED_UP);

    //
    // if a request is waiting for an mdl to become available, don't touch it here.
    // When afp returns with mdl (or null mdl), we'll clean up this request
    //
    if (pTcpConn->con_RcvState != DSI_AWAITING_WRITE_MDL)
    {
        pPartialDsiReq = pTcpConn->con_pDsiReq;
        pTcpConn->con_pDsiReq = NULL;
    }

    RELEASE_SPIN_LOCK(&pTcpConn->con_SpinLock, OldIrql);

    if (pPartialDsiReq)
    {
        // if we had allocated an mdl, let afp know so afp can free it
        if ((pPartialDsiReq->dsi_Command == DSI_COMMAND_WRITE) &&
            (pPartialDsiReq->dsi_AfpRequest.rq_WriteMdl != NULL))
        {
            AfpCB_RequestNotify(STATUS_REMOTE_DISCONNECT,
                                pTcpConn->con_pSda,
                                &pPartialDsiReq->dsi_AfpRequest);
        }

        DsiFreeRequest(pPartialDsiReq);

        // remove the REQUEST refcount
        DsiDereferenceConnection(pTcpConn);

        DBGREFCOUNT(("DsiKillConnection: REQUEST dec %lx (%d  %d,%d)\n",
            pTcpConn,pTcpConn->con_RefCount,pTcpConn->con_State,pTcpConn->con_RcvState));
    }

    status = (DiscFlag == TDI_DISCONNECT_ABORT)?
                STATUS_LOCAL_DISCONNECT: STATUS_REMOTE_DISCONNECT;

    // give AFP the bad news
    DsiDisconnectWithAfp(pTcpConn, status);

    // give TCP the bad news
    DsiDisconnectWithTcp(pTcpConn, DiscFlag);

    // remove the Creation refcount if this is the first time we're visiting
    // this routine
    if (fFirstVisit)
    {
        DsiDereferenceConnection(pTcpConn);

        DBGREFCOUNT(("DsiKillConnection: Creation dec %lx (%d  %d,%d)\n",
            pTcpConn,pTcpConn->con_RefCount,pTcpConn->con_State,pTcpConn->con_RcvState));
    }

    return(TRUE);
}



/***	DsiFreeAdapter
 *
 *	This routine frees the adapter object after closing the tcp handles
 *
 *  Parm IN:  pTcpAdptr - adapter object
 *
 *  Returns:  result of the operation
 *
 */
NTSTATUS FASTCALL
DsiFreeAdapter(
    IN PTCPADPTR    pTcpAdptr
)
{

    BOOLEAN         fRecreateAdapter=FALSE;
    KIRQL           OldIrql;


    ASSERT(KeGetCurrentIrql() != DISPATCH_LEVEL);

    ASSERT(pTcpAdptr->adp_Signature == DSI_ADAPTER_SIGNATURE);
    ASSERT(pTcpAdptr->adp_State & TCPADPTR_STATE_CLOSING);
    ASSERT(pTcpAdptr->adp_RefCount == 0);

    // close file handles
    DsiCloseTdiAddress(pTcpAdptr);

    ACQUIRE_SPIN_LOCK(&DsiAddressLock, &OldIrql);

    DsiTcpAdapter = NULL;
    AfpServerBoundToTcp = FALSE;

    //
    // it's possible that by the time we did all the cleanup and everything,
    // an ipaddress(es) became available.  If that has happened, go ahead and
    // create the global adapter again!
    //
    if (!IsListEmpty(&DsiIpAddrList))
    {
        fRecreateAdapter = TRUE;
    }

    // if we are shutting down, don't create the adapter again!
    if ((AfpServerState == AFP_STATE_STOP_PENDING) ||
        (AfpServerState == AFP_STATE_SHUTTINGDOWN) ||
        (AfpServerState == AFP_STATE_STOPPED))
    {
        fRecreateAdapter = FALSE;
    }

    RELEASE_SPIN_LOCK(&DsiAddressLock, OldIrql);

    ASSERT(pTcpAdptr->adp_pFileObject == NULL);
    ASSERT(pTcpAdptr->adp_FileHandle == INVALID_HANDLE_VALUE);

    DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
        ("DsiFreeAdapter: freeing adapter %lx\n",pTcpAdptr));

    AfpFreeMemory(pTcpAdptr);

    // wake up that blocked thread!
    KeSetEvent(&DsiShutdownEvent, IO_NETWORK_INCREMENT, False);

    if (fRecreateAdapter)
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiFreeAdapter: ipaddress came in, so recreating global adapter\n"));

        DsiCreateAdapter();
    }

    return(STATUS_SUCCESS);
}



/***	DsiFreeConnection
 *
 *	This routine frees the connection object after closing the tcp handles
 *
 *  Parm IN:  pTcpConn - connection object
 *
 *  Returns:  result of the operation
 *
 */
NTSTATUS FASTCALL
DsiFreeConnection(
    IN PTCPCONN     pTcpConn
)
{

    KIRQL       OldIrql;
    PTCPADPTR   pTcpAdptr;
    IPADDRESS   IpAddress;


    ASSERT(KeGetCurrentIrql() != DISPATCH_LEVEL);

    ASSERT(pTcpConn->con_Signature == DSI_CONN_SIGNATURE);
    ASSERT(pTcpConn->con_State & TCPCONN_STATE_CLOSING);
    ASSERT(pTcpConn->con_RefCount == 0);

    pTcpAdptr = pTcpConn->con_pTcpAdptr;

    ASSERT(pTcpAdptr->adp_Signature == DSI_ADAPTER_SIGNATURE);

    // close file handles
    DsiCloseTdiConnection(pTcpConn);

    // remove this puppy from the list
    ACQUIRE_SPIN_LOCK(&pTcpAdptr->adp_SpinLock, &OldIrql);
    RemoveEntryList(&pTcpConn->con_Linkage);
    RELEASE_SPIN_LOCK(&pTcpAdptr->adp_SpinLock, OldIrql);

    // remove the CONN refcount for this connection
    DsiDereferenceAdapter(pTcpConn->con_pTcpAdptr);

    ASSERT(pTcpConn->con_pFileObject == NULL);
    ASSERT(pTcpConn->con_FileHandle == INVALID_HANDLE_VALUE);

#if DBG
    IpAddress = pTcpConn->con_DestIpAddr;

    if (IpAddress)
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_WARN,
            ("DsiFreeConnection: freeing connection on %d.%d.%d.%d (%lx)\n",
            (IpAddress>>24)&0xFF,(IpAddress>>16)&0xFF,(IpAddress>>8)&0xFF,
            IpAddress&0xFF,pTcpConn));
    }

    pTcpConn->con_Signature = 0xDEADBEEF;
#endif

    AfpFreeMemory(pTcpConn);

    return(STATUS_SUCCESS);
}


/***	DsiGetIpAddrBlob
 *
 *	This routine generates a 'blob' that gets plugged into the ServerInfo buffer.
 *  Here we walk the ipaddr list and generate a blob with all the available
 *  ipaddresses (6-byte-per-ipaddress_
 *
 *  Parm OUT: pIpAddrCount - how many ipaddresses there are in the system
 *            ppIpAddrBlob - pointer to a pointer to a buffer
 *
 *  Returns:  status of operation
 *
 */
NTSTATUS
DsiGetIpAddrBlob(
    OUT DWORD    *pIpAddrCount,
    OUT PBYTE    *ppIpAddrBlob
)
{
    KIRQL               OldIrql;
    PLIST_ENTRY         pList;
    DWORD               AddrCount=0;
    DWORD               TmpCount=0;
    PBYTE               AddrBlob;
    PBYTE               pCurrentBlob;
    PIPADDRENTITY       pIpaddrEntity;


    *pIpAddrCount = 0;
    *ppIpAddrBlob = NULL;

    ACQUIRE_SPIN_LOCK(&DsiAddressLock, &OldIrql);

    if (!DsiTcpEnabled)
    {
        RELEASE_SPIN_LOCK(&DsiAddressLock, OldIrql);

        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiGetIpAddrBlob: Server is disabled\n"));

        return(STATUS_SUCCESS);
    }


    //
    // find out how many ipaddresses are there on the list
    //
    AddrCount = 0;
    pList = DsiIpAddrList.Flink;
    while (pList != &DsiIpAddrList)
    {
        AddrCount++;
        pList = pList->Flink;
    }

    if (AddrCount == 0)
    {
        RELEASE_SPIN_LOCK(&DsiAddressLock, OldIrql);

        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiGetIpAddrBlob: calling AfpSetServerStatus with 0 addrs\n"));

        return(STATUS_SUCCESS);
    }

    if (AddrCount > DSI_MAX_IPADDR_COUNT)
    {
        AddrCount = DSI_MAX_IPADDR_COUNT;
    }

    AddrBlob = AfpAllocZeroedNonPagedMemory(AddrCount * DSI_NETWORK_ADDR_LEN);

    if (AddrBlob == NULL)
    {
        RELEASE_SPIN_LOCK(&DsiAddressLock, OldIrql);

	    DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiGetIpAddrBlob: malloc failed\n"));

        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // create a "blob" that AfpSetServerStatus can directly copy
    //
    TmpCount = 0;
    pCurrentBlob = AddrBlob;

    pList = DsiIpAddrList.Flink;
    while (pList != &DsiIpAddrList)
    {
        pIpaddrEntity = CONTAINING_RECORD(pList, IPADDRENTITY, Linkage);

        pCurrentBlob[0] = DSI_NETWORK_ADDR_LEN;
        pCurrentBlob[1] = DSI_NETWORK_ADDR_IPTAG;
        PUTDWORD2DWORD(&pCurrentBlob[2], pIpaddrEntity->IpAddress);

        pCurrentBlob += DSI_NETWORK_ADDR_LEN;

        pList = pList->Flink;

        TmpCount++;
        if (TmpCount == AddrCount)
        {
            break;
        }
    }

    RELEASE_SPIN_LOCK(&DsiAddressLock, OldIrql);

    *pIpAddrCount = AddrCount;
    *ppIpAddrBlob = AddrBlob;

    return(STATUS_SUCCESS);
}



/***	DsiGetIrpForTcp
 *
 *	This routine is called when we need to pass an irp back to TCP to get the
 *  remainint data (when it has more data than it has indicated to us).
 *  Here we allocate an mdl if there isn't one already, and allocate and
 *  initialize an irp ready to be sent to TCP
 *
 *  Parm IN:  pTcpConn - the connection object
 *            pBuffer - buffer that TCP will copy data in
 *            pInputMdl - if non-null, then we don't allocate a new mdl
 *            ReadSize - how many bytes do we need
 *
 *  Returns:  pIrp if successful, NULL otherwise
 *
 *  NOTE: pTcpConn spinlock is held on entry
 *
 */
PIRP
DsiGetIrpForTcp(
    IN  PTCPCONN    pTcpConn,
    IN  PBYTE       pBuffer,
    IN  PMDL        pInputMdl,
    IN  DWORD       ReadSize
)
{
    PDEVICE_OBJECT                  pDeviceObject;
    PIRP                            pIrp=NULL;
    PTDI_REQUEST_KERNEL_RECEIVE     pRequest;
    PMDL                            pMdl;

    pDeviceObject = IoGetRelatedDeviceObject(pTcpConn->con_pFileObject);

    pIrp = AfpAllocIrp(pDeviceObject->StackSize);
    if (pIrp == NULL)
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiGetIrpForTcp: alloc irp failed!\n"));

        return(NULL);
    }

    if (pInputMdl)
    {
        pMdl = pInputMdl;
    }
    else
    {
        pMdl = AfpAllocMdl(pBuffer, ReadSize, NULL);

        if (pMdl == NULL)
        {
            DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                ("DsiGetIrpForTcp: alloc mdl failed!\n"));

            AfpFreeIrp(pIrp);
            return(NULL);
        }
    }

    pTcpConn->con_pRcvIrp = pIrp;

    pTcpConn->con_State |= TCPCONN_STATE_TCP_HAS_IRP;

    // put TcpIRP refcount, removed when the irp completes
    pTcpConn->con_RefCount++;

    DBGREFCOUNT(("DsiGetIrpForTcp: TcpIRP inc %lx (%d  %d,%d)\n",
        pTcpConn,pTcpConn->con_RefCount,pTcpConn->con_State,pTcpConn->con_RcvState));

    TdiBuildReceive(pIrp,
                    pDeviceObject,
                    pTcpConn->con_pFileObject,
                    DsiTcpRcvIrpCompletion,
                    (PVOID)pTcpConn,
                    pMdl,
                    TDI_RECEIVE_NORMAL,
                    ReadSize);

    //
    // this irp will be returned to TCP, so do what IoSubSystem
    // would have done if we had called IoCallDriver
    //
    IoSetNextIrpStackLocation(pIrp);

    return(pIrp);
}



/***	DsiMakePartialMdl
 *
 *	This routine is called when we need to reissue an Mdl (via irp) back to TCP
 *  because TCP prematurely completed the previous irp (i.e. all the requested
 *  bytes haven't come in yet, but say Push bit was set or something).  In such
 *  a case, we need to give a new mdl which accounts for the bytes we have got
 *  so far (i.e. the offset has changed)
 *
 *  Parm IN:  pOrgMdl - the original Mdl we gave to TCp
 *            dwOffset - what offset we want the new partial Mdl to describe
 *
 *  Returns:  the new partial Mdl if successful, NULL otherwise
 *
 */
PMDL
DsiMakePartialMdl(
    IN  PMDL        pOrgMdl,
    IN  DWORD       dwOffset
)
{
    PMDL    pSubMdl;
    PMDL    pPartialMdl=NULL;
    DWORD   dwNewMdlLen;
    PVOID   vAddr;


    ASSERT(pOrgMdl != NULL);
    ASSERT(dwOffset > 0);

    ASSERT(dwOffset < AfpMdlChainSize(pOrgMdl));

    pSubMdl = pOrgMdl;

    //
    // get to the Mdl that is going to have this offset
    //
    while (dwOffset >= MmGetMdlByteCount(pSubMdl))
    {
        dwOffset -= MmGetMdlByteCount(pSubMdl);
        pSubMdl = pSubMdl->Next;

        ASSERT(pSubMdl != NULL);
    }

    ASSERT(MmGetMdlByteCount(pSubMdl) > dwOffset);

    vAddr = (PVOID)((PUCHAR)MmGetMdlVirtualAddress( pSubMdl ) + dwOffset);

    dwNewMdlLen = MmGetMdlByteCount(pSubMdl) - dwOffset;

    pPartialMdl = IoAllocateMdl(vAddr, dwNewMdlLen, FALSE, FALSE, NULL);

    if (pPartialMdl == NULL)
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiMakePartialMdl: IoAllocateMdl failed\n"));
        return(NULL);
    }

    AFP_DBG_INC_COUNT(AfpDbgMdlsAlloced);

    IoBuildPartialMdl(pSubMdl, pPartialMdl, vAddr, dwNewMdlLen);

    // if there are further Mdl's down the original, link them on
    pPartialMdl->Next = pSubMdl->Next;

    return(pPartialMdl);

}



/***	DsiUpdateAfpStatus
 *
 *	This routine is just a wrapper function so that we can schedule an event to
 *  call the real function AfpSetServerStatus
 *
 *  Returns:  status of operation
 *
 */
NTSTATUS FASTCALL
DsiUpdateAfpStatus(
    IN PVOID    Unused
)
{
    NTSTATUS            status;


    status = AfpSetServerStatus();

    return(status);
}



/***	DsiScheduleWorkerEvent
 *
 *	This routine schedules an event for a later time.  This routine is called
 *  typically when we are at dpc but something (e.g. file handle operations)
 *  needs to be done at passive level.  This routine puts the request on the
 *  worker queue.
 *
 *  Parm IN:  WorkerRoutine - the routine to be exececuted by the worker thread
 *            Context - parameter for that routine
 *
 *  Returns:  result of the operation
 *
 */
NTSTATUS
DsiScheduleWorkerEvent(
    IN  DSI_WORKER      WorkerRoutine,
    IN  PVOID           Context
)
{
    PTCPWORKITEM    pTWItem;

    pTWItem = (PTCPWORKITEM)AfpAllocZeroedNonPagedMemory(sizeof(TCPWORKITEM));
    if (pTWItem == NULL)
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiScheduleWorkerEvent: alloc failed!\n"));
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    AfpInitializeWorkItem(&pTWItem->tcp_WorkItem, DsiWorker, pTWItem);

    pTWItem->tcp_Worker = WorkerRoutine;
    pTWItem->tcp_Context = Context;

    AfpQueueWorkItem(&pTWItem->tcp_WorkItem);

    return(STATUS_SUCCESS);
}



/***	DsiScheduleWorkerEvent
 *
 *	This routine gets called by the worker thread when DsiScheduleWorkerEvent
 *  schedules an event.  This routine then calls the actual routine that was
 *  scheduled for later time.
 *
 *  Parm IN:  Context - the work item
 *
 *  Returns:  result of the operation
 *
 */
VOID FASTCALL
DsiWorker(
    IN PVOID    Context
)
{
    PTCPWORKITEM    pTWItem;
    NTSTATUS        status;

    pTWItem = (PTCPWORKITEM)Context;


    ASSERT (KeGetCurrentIrql() < DISPATCH_LEVEL);

    (*pTWItem->tcp_Worker)(pTWItem->tcp_Context);

    AfpFreeMemory(pTWItem);
}




/***	DsiShutdown
 *
 *	This routine is called when sfm is shutting down.  We basically make sure
 *  that all the resources are freed up, file handles closed etc.
 *
 *  Returns:  Nothing
 *
 */
VOID
DsiShutdown(
    IN VOID
)
{
    KIRQL           OldIrql;
    PLIST_ENTRY     pList;
    PIPADDRENTITY   pIpaddrEntity;
    PDSIREQ         pDsiReq=NULL;



    ACQUIRE_SPIN_LOCK(&DsiAddressLock, &OldIrql);

    while (!IsListEmpty(&DsiIpAddrList))
    {
        pList = RemoveHeadList(&DsiIpAddrList);

        pIpaddrEntity = CONTAINING_RECORD(pList, IPADDRENTITY, Linkage);

        AfpFreeMemory(pIpaddrEntity);
    }

    if (DsiStatusBuffer != NULL)
    {
        AfpFreeMemory(DsiStatusBuffer);
        DsiStatusBuffer = NULL;
    }

    RELEASE_SPIN_LOCK(&DsiAddressLock, OldIrql);

    // kill the global adapter if it's around
    if (DsiTcpAdapter)
    {
        KeClearEvent(&DsiShutdownEvent);

        DsiDestroyAdapter();

        // if the "adapter" is still hanging around, wait till it's gone
        if (DsiTcpAdapter)
        {
            DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                ("DsiShutdown: waiting for the TCP interface to go away...\n"));

            AfpIoWait(&DsiShutdownEvent, NULL);

            DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                ("DsiShutdown: ... and the wait is over!\n"));
        }
    }

    ACQUIRE_SPIN_LOCK(&DsiResourceLock, &OldIrql);

    while (!IsListEmpty(&DsiFreeRequestList))
    {
        pList = RemoveHeadList(&DsiFreeRequestList);
        pDsiReq = CONTAINING_RECORD(pList, DSIREQ, dsi_Linkage);

        AfpFreeMemory(pDsiReq);
        DsiFreeRequestListSize--;
    }

    RELEASE_SPIN_LOCK(&DsiResourceLock, OldIrql);

    ASSERT(DsiFreeRequestListSize == 0);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\service\client\afpsvc_c_stub.c ===
#include "afpsvc_c.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\server\time.c ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	volume.c

Abstract:

	This module contains the routines which manipulates time values and
	conversions.

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	25 Apr 1992		Initial Version

Notes:	Tab stop: 4
--*/

#define	FILENUM	FILE_TIME

#include <afp.h>


/***	AfpGetCurrentTimeInMacFormat
 *
 *	This gets the current system time in macintosh format which is number of
 *	seconds since ZERO hours on Jan 1, 2000. Time before this date is
 * negative time. (the time returned is the system local time)
 */
VOID
AfpGetCurrentTimeInMacFormat(
	OUT AFPTIME *	pMacTime
)
{
	TIME	SystemTime;

	KeQuerySystemTime(&SystemTime);

	*pMacTime = AfpConvertTimeToMacFormat(&SystemTime);
}



/***	AfpConvertTimeToMacFormat
 *
 *	Convert time in the host format i.e. # of 100ns since 1601 A.D. to
 *	the macintosh time i.e. # of seconds since 2000 A.D. The system time
 *	is in UTC. We need to first convert it to local time.
 */
AFPTIME
AfpConvertTimeToMacFormat(
	IN	PTIME	pSystemTime
)
{
	AFPTIME	MacTime;
	TIME	LocalTime;

	// Convert this to number of seconds since 1980
	RtlTimeToSecondsSince1980(pSystemTime, (PULONG)&MacTime);

	MacTime -= SECONDS_FROM_1980_2000;

	return MacTime;
}


/***	AfpConvertTimeFromMacFormat
 *
 *	Convert time in the  macintosh time i.e. # of seconds since 2000 A.D. to
 *	the host format i.e. # of 100ns since 1601 A.D. Convert from local time
 *	to system time i.e UTC.
 */
VOID
AfpConvertTimeFromMacFormat(
	IN	AFPTIME	MacTime,
	OUT PTIME	pSystemTime
)
{
	TIME	LocalTime;

	MacTime += SECONDS_FROM_1980_2000;
	RtlSecondsSince1980ToTime(MacTime, pSystemTime);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\server\tcptdi.c ===
/*

Copyright (c) 1998  Microsoft Corporation

Module Name:

	tcptdi.c

Abstract:

	This module contains the interfaces to the TCP/IP stack via TDI


Author:

	Shirish Koti


Revision History:
	22 Jan 1998		Initial Version

--*/

#define	FILENUM	FILE_TCPTDI

#include <afp.h>



/***	DsiOpenTdiAddress
 *
 *	This routine creates a TDI address for the AFP port on the given adapter
 *
 *  Parm IN:  pTcpAdptr - adapter object
 *
 *  Parm OUT: pRetFileHandle - file handle to the address object
 *            ppRetFileObj - pointer to file object pointer
 *
 *  Returns:  status of operation
 *
 */
NTSTATUS
DsiOpenTdiAddress(
    IN  PTCPADPTR       pTcpAdptr,
    OUT PHANDLE         pRetFileHandle,
    OUT PFILE_OBJECT   *ppRetFileObj
)
{

    OBJECT_ATTRIBUTES           AddressAttributes;
    IO_STATUS_BLOCK             IoStatusBlock;
    PFILE_FULL_EA_INFORMATION   EaBuffer;
    NTSTATUS                    status;
    UNICODE_STRING              ucDeviceName;
    PTRANSPORT_ADDRESS          pTransAddressEa;
    PTRANSPORT_ADDRESS          pTransAddr;
    TDI_ADDRESS_IP              TdiIpAddr;
    HANDLE                      FileHandle;
    PFILE_OBJECT                pFileObject;
    PDEVICE_OBJECT              pDeviceObject;
    PEPROCESS                   CurrentProcess;
    BOOLEAN                     fAttachAttempted;


    ASSERT(KeGetCurrentIrql() != DISPATCH_LEVEL);

    ASSERT(pTcpAdptr->adp_Signature == DSI_ADAPTER_SIGNATURE);

    *pRetFileHandle = INVALID_HANDLE_VALUE;

    // copy device name into the unicode string

    ucDeviceName.MaximumLength = (wcslen(AFP_TCP_BINDNAME) + 1)*sizeof(WCHAR);
    ucDeviceName.Length = 0;
    ucDeviceName.Buffer = (PWSTR)AfpAllocZeroedNonPagedMemory(
                                    ucDeviceName.MaximumLength);

    if (ucDeviceName.Buffer == NULL)
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiOpenTdiAddress: malloc for ucDeviceName Failed\n"));
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    status = RtlAppendUnicodeToString(&ucDeviceName, AFP_TCP_BINDNAME);
    if (!NT_SUCCESS(status))
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiOpenTdiAddress: RtlAppend... failed %lx\n",status));

        AfpFreeMemory(ucDeviceName.Buffer);
        return(status);
    }

    EaBuffer = (PFILE_FULL_EA_INFORMATION)AfpAllocZeroedNonPagedMemory(
                    sizeof(FILE_FULL_EA_INFORMATION) - 1 +
                    TDI_TRANSPORT_ADDRESS_LENGTH + 1 +
                    sizeof(TRANSPORT_ADDRESS) +
                    sizeof(TDI_ADDRESS_IP));

    if (EaBuffer == NULL)
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiOpenTdiAddress: malloc for Eabuffer failed!\n"));

        AfpFreeMemory(ucDeviceName.Buffer);
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    EaBuffer->NextEntryOffset = 0;
    EaBuffer->Flags = 0;
    EaBuffer->EaNameLength = TDI_TRANSPORT_ADDRESS_LENGTH;

    EaBuffer->EaValueLength = sizeof(TRANSPORT_ADDRESS) -1
                                + sizeof(TDI_ADDRESS_IP);

    // put "TransportAddress" into the name
    RtlMoveMemory(EaBuffer->EaName,
                  TdiTransportAddress,
                  EaBuffer->EaNameLength + 1);

    // fill in the IP address and Port number
    //
    pTransAddressEa = (TRANSPORT_ADDRESS *)&EaBuffer->EaName[EaBuffer->EaNameLength+1];

    // allocate Memory for the transport address
    //
    pTransAddr = (PTRANSPORT_ADDRESS)AfpAllocZeroedNonPagedMemory(
                    sizeof(TDI_ADDRESS_IP)+sizeof(TRANSPORT_ADDRESS));

    if (pTransAddr == NULL)
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiOpenTdiAddress: malloc for pTransAddr failed!\n"));

        AfpFreeMemory(ucDeviceName.Buffer);
        AfpFreeMemory(EaBuffer);
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    pTransAddr->TAAddressCount = 1;
    pTransAddr->Address[0].AddressLength = sizeof(TDI_ADDRESS_IP);
    pTransAddr->Address[0].AddressType = TDI_ADDRESS_TYPE_IP;

    TdiIpAddr.sin_port = htons(AFP_TCP_PORT);    // put in network order
    TdiIpAddr.in_addr  = 0;                      // inaddr_any


    // zero fill the  last component of the IP address
    //
    RtlFillMemory((PVOID)&TdiIpAddr.sin_zero,
                  sizeof(TdiIpAddr.sin_zero),
                  0);

    // copy the ip address to the end of the structure
    //
    RtlMoveMemory(pTransAddr->Address[0].Address,
                  (CONST PVOID)&TdiIpAddr,
                  sizeof(TdiIpAddr));

    // copy the ip address to the end of the name in the EA structure
    //
    RtlMoveMemory((PVOID)pTransAddressEa,
                  (CONST PVOID)pTransAddr,
                  sizeof(TDI_ADDRESS_IP) + sizeof(TRANSPORT_ADDRESS)-1);


    InitializeObjectAttributes(
        &AddressAttributes,
        &ucDeviceName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL);


    CurrentProcess = IoGetCurrentProcess();
    AFPAttachProcess(CurrentProcess);
    fAttachAttempted = TRUE;

    status = ZwCreateFile(
                    &FileHandle,
                    GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE,
                    &AddressAttributes,
                    &IoStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    FILE_OPEN_IF,
                    0,
                    (PVOID)EaBuffer,
                    sizeof(FILE_FULL_EA_INFORMATION) - 1 +
                        EaBuffer->EaNameLength + 1 +
                        EaBuffer->EaValueLength);

    // don't need these no more..
    AfpFreeMemory((PVOID)pTransAddr);
    AfpFreeMemory((PVOID)EaBuffer);
    AfpFreeMemory(ucDeviceName.Buffer);


    if (NT_SUCCESS(status))
    {
        // if the ZwCreate passed set the status to the IoStatus
        status = IoStatusBlock.Status;

        if (!NT_SUCCESS(status))
        {
            DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                ("DsiOpenTdiAddress: ZwCreateFile failed, iostatus=%lx\n",status));

            AFPDetachProcess(CurrentProcess);
            return(status);
        }

        // dereference the file object to keep the device ptr around to avoid
        // this dereference at run time
        //
        status = ObReferenceObjectByHandle(
                        FileHandle,
                        (ULONG)0,
                        0,
                        KernelMode,
                        (PVOID *)&pFileObject,
                        NULL);

        if (NT_SUCCESS(status))
        {
            AFPDetachProcess(CurrentProcess);
            fAttachAttempted = FALSE;

	        pDeviceObject = IoGetRelatedDeviceObject(pFileObject);

            status = DsiSetEventHandler(
                            pDeviceObject,
                            pFileObject,
                            TDI_EVENT_ERROR,
                            (PVOID)DsiTdiErrorHandler,
                            (PVOID)pTcpAdptr);

            if (NT_SUCCESS(status))
            {
                status = DsiSetEventHandler(
                                pDeviceObject,
                                pFileObject,
                                TDI_EVENT_RECEIVE,
                                (PVOID)DsiTdiReceiveHandler,
                                (PVOID)pTcpAdptr);

                if (NT_SUCCESS(status))
                {
                    status = DsiSetEventHandler(
                                    pDeviceObject,
                                    pFileObject,
                                    TDI_EVENT_DISCONNECT,
                                    (PVOID)DsiTdiDisconnectHandler,
                                    (PVOID)pTcpAdptr);

                    if (NT_SUCCESS(status))
                    {
                        status = DsiSetEventHandler(
                                        pDeviceObject,
                                        pFileObject,
                                        TDI_EVENT_CONNECT,
                                        (PVOID)DsiTdiConnectHandler,
                                        (PVOID)pTcpAdptr);

                        if (NT_SUCCESS(status))
                        {
                            // all worked well: done here

                            *pRetFileHandle = FileHandle;
                            *ppRetFileObj = pFileObject;

                            return(status);
                        }
                        else
                        {
                            DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                                ("DsiOpenTdiAddress: Set.. DsiTdiConnectHandler failed %lx\n",
                                status));
                        }
                    }
                    else
                    {
                        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                            ("DsiOpenTdiAddress: Set.. DsiTdiDisconnectHandler failed %lx\n",
                            status));
                    }
                }
                else
                {
                    DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                        ("DsiOpenTdiAddress: Set.. DsiTdiReciveHandler failed %lx\n",
                        status));
                }

                //
                // ERROR Case
                //
                ObDereferenceObject(pFileObject);
                ZwClose(FileHandle);

                return(status);
            }
            else
            {
                DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                    ("DsiOpenTdiAddress: Set.. DsiTdiErrorHandler failed %lx\n",
                    status));
            }

        }
        else
        {
            DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                ("DsiOpenTdiAddress: ObReferenceObjectByHandle failed %lx\n",status));

            ZwClose(FileHandle);
        }

    }
    else
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiOpenTdiAddress: ZwCreateFile failed %lx\n",status));
    }

    if (fAttachAttempted)
    {
        AFPDetachProcess(CurrentProcess);
    }

    return(status);
}



/***	DsiOpenTdiConnection
 *
 *	This routine creates a TDI Conection for the given connection object
 *
 *  Parm IN:  pTcpConn - connection object
 *
 *  Returns:  status of operation
 *
 */
NTSTATUS
DsiOpenTdiConnection(
    IN PTCPCONN     pTcpConn
)
{

    IO_STATUS_BLOCK             IoStatusBlock;
    NTSTATUS                    Status;
    OBJECT_ATTRIBUTES           ObjectAttributes;
    PFILE_FULL_EA_INFORMATION   EaBuffer;
    UNICODE_STRING              RelativeDeviceName = {0,0,NULL};
    PMDL                        pMdl;
    PEPROCESS                   CurrentProcess;
    BOOLEAN                     fAttachAttempted;


    ASSERT(KeGetCurrentIrql() != DISPATCH_LEVEL);

    ASSERT(VALID_TCPCONN(pTcpConn));

    ASSERT(pTcpConn->con_pTcpAdptr->adp_Signature == DSI_ADAPTER_SIGNATURE);

    InitializeObjectAttributes (
        &ObjectAttributes,
        &RelativeDeviceName,
        0,
        pTcpConn->con_pTcpAdptr->adp_FileHandle,
        NULL);

    // Allocate memory for the address info to be passed to the transport
    EaBuffer = (PFILE_FULL_EA_INFORMATION)AfpAllocZeroedNonPagedMemory (
                    sizeof(FILE_FULL_EA_INFORMATION) - 1 +
                    TDI_CONNECTION_CONTEXT_LENGTH + 1 +
                    sizeof(CONNECTION_CONTEXT));

    if (!EaBuffer)
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiOpenTdiConnection: alloc for EaBuffer failed\n"));

        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    EaBuffer->NextEntryOffset = 0;
    EaBuffer->Flags = 0;
    EaBuffer->EaNameLength = TDI_CONNECTION_CONTEXT_LENGTH;
    EaBuffer->EaValueLength = sizeof (CONNECTION_CONTEXT);

    // copy ConnectionContext to EaName
    RtlMoveMemory( EaBuffer->EaName, TdiConnectionContext, EaBuffer->EaNameLength + 1 );

    // put out context into the EaBuffer
    RtlMoveMemory (
        (PVOID)&EaBuffer->EaName[EaBuffer->EaNameLength + 1],
        (CONST PVOID)&pTcpConn,
        sizeof (CONNECTION_CONTEXT));

    CurrentProcess = IoGetCurrentProcess();
    AFPAttachProcess(CurrentProcess);;
    fAttachAttempted = TRUE;

    Status = ZwCreateFile (
                 &pTcpConn->con_FileHandle,
                 GENERIC_READ | GENERIC_WRITE,
                 &ObjectAttributes,     // object attributes.
                 &IoStatusBlock,        // returned status information.
                 NULL,                  // block size (unused).
                 FILE_ATTRIBUTE_NORMAL, // file attributes.
                 0,
                 FILE_CREATE,
                 0,                     // create options.
                 (PVOID)EaBuffer,       // EA buffer.
                 sizeof(FILE_FULL_EA_INFORMATION) - 1 +
                    TDI_CONNECTION_CONTEXT_LENGTH + 1 +
                    sizeof(CONNECTION_CONTEXT));

    AfpFreeMemory((PVOID)EaBuffer);

    if (NT_SUCCESS(Status))
    {

        // if the ZwCreate passed set the status to the IoStatus
        //
        Status = IoStatusBlock.Status;

        if (NT_SUCCESS(Status))
        {
            // dereference file handle, now that we are at task time
            Status = ObReferenceObjectByHandle(
                        pTcpConn->con_FileHandle,
                        0L,
                        NULL,
                        KernelMode,
                        (PVOID *)&pTcpConn->con_pFileObject,
                        NULL);

            if (NT_SUCCESS(Status))
            {
                AFPDetachProcess(CurrentProcess);

                return(Status);
            }
            else
            {
                DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                    ("DsiOpenTdiConnection: ObReference.. failed %lx\n",Status));

                ZwClose(pTcpConn->con_FileHandle);
            }
        }
        else
        {
            DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                ("DsiOpenTdiConnection: ZwCreateFile IoStatus failed %lx\n",Status));
        }
    }
    else
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiOpenTdiConnection: ZwCreateFile failed %lx\n",Status));
    }

    if (fAttachAttempted)
    {
        AFPDetachProcess(CurrentProcess);
    }

    DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
        ("DsiOpenTdiConnection: taking error path, returning %lx\n",Status));

    return Status;

}




/***	DsiAssociateTdiConnection
 *
 *	This routine associates a TDI connection with the address object for AFP port
 *
 *  Parm IN:  pTcpConn - connection object
 *
 *  Returns:  status of operation
 *
 */
NTSTATUS
DsiAssociateTdiConnection(
    IN PTCPCONN     pTcpConn
)
{
    NTSTATUS            status;
    PIRP                pIrp;
    PDEVICE_OBJECT      pDeviceObject;


    ASSERT(VALID_TCPCONN(pTcpConn));

    ASSERT(pTcpConn->con_pTcpAdptr->adp_Signature == DSI_ADAPTER_SIGNATURE);

    pDeviceObject = IoGetRelatedDeviceObject(pTcpConn->con_pFileObject);

    if ((pIrp = AfpAllocIrp(pDeviceObject->StackSize)) == NULL)
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiAssociateTdiConnection: alloc for pIrp failed\n"));
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    TdiBuildAssociateAddress(
                pIrp,
                pDeviceObject,
                pTcpConn->con_pFileObject,
                DsiTdiCompletionRoutine,
                NULL,
                pTcpConn->con_pTcpAdptr->adp_FileHandle);

    status = DsiTdiSynchronousIrp(pIrp, pDeviceObject);

    if (status != STATUS_SUCCESS)
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiAssociateTdiConnection: ..TdiSynch.. failed %lx\n",status));
    }

    AfpFreeIrp(pIrp);

    return(status);
}




/***	DsiSetEventHandler
 *
 *	This routine sends an irp down to the tcp stack to set a specified event handler
 *
 *  Parm IN:  pDeviceObject - TCP's device object
 *            pFileObject - file object corresponding to the address object
 *            EventType - TDI_EVENT_CONNECT, TDI_EVENT_RECEIVE etc.
 *            EventHandler - the handler for this event
 *            Context - our adapter object
 *
 *  Returns:  status of operation
 *
 */
NTSTATUS
DsiSetEventHandler(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PFILE_OBJECT     pFileObject,
    IN ULONG            EventType,
    IN PVOID            EventHandler,
    IN PVOID            Context
)
{

    PIRP                pIrp;
    NTSTATUS            status;


    if ((pIrp = AfpAllocIrp(pDeviceObject->StackSize)) == NULL)
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiSetEventHandler: alloc for pIrp failed\n"));
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    TdiBuildSetEventHandler(pIrp,
                            pDeviceObject,
                            pFileObject,
                            NULL,
                            NULL,
                            EventType,
                            EventHandler,
                            Context);

    status = DsiTdiSynchronousIrp(pIrp, pDeviceObject);

    if (status != STATUS_SUCCESS)
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiSetEventHandler: ..TdiSynch.. failed %lx\n",status));
    }

    AfpFreeIrp(pIrp);

    return(status);

}




/***	DsiTdiSynchronousIrp
 *
 *	This routine sends an irp down to the tcp stack, and blocks until the irp
 *  is completed
 *
 *  Parm IN:  pIrp - the irp that needs to be sent down
 *            pDeviceObject - TCP's device object
 *
 *  Returns:  status of operation
 *
 */
NTSTATUS
DsiTdiSynchronousIrp(
    IN PIRP             pIrp,
    PDEVICE_OBJECT      pDeviceObject
)
{

    NTSTATUS            status;
    KEVENT              Event;


    KeInitializeEvent(&Event, SynchronizationEvent, FALSE);

    IoSetCompletionRoutine(pIrp,
                           (PIO_COMPLETION_ROUTINE)DsiTdiCompletionRoutine,
                           (PVOID)&Event,
                           TRUE,
                           TRUE,
                           TRUE);

    status = IoCallDriver(pDeviceObject, pIrp);

    if (!NT_SUCCESS(status))
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiTdiSynchronousIrp: IoCallDriver failed %lx\n",status));
    }

    if (status == STATUS_PENDING)
    {
        status = KeWaitForSingleObject((PVOID)&Event,
                                       Executive,
                                       KernelMode,
                                       FALSE,
                                       NULL);
        if (!NT_SUCCESS(status))
        {
            DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                ("DsiTdiSynchronousIrp: KeWaitFor... failed %lx\n",status));
            return(status);
        }
        status = pIrp->IoStatus.Status;
    }

    return(status);
}



/***	DsiTdiCompletionRoutine
 *
 *	This routine gets called when the irp sent in DsiTdiSynchronousIrp is
 *  completed
 *
 *  Parm IN:  pDeviceObject - TCP's device object
 *            pIrp - the irp that got completed
 *            Context - our adapter object
 *
 *  Returns:  status of operation
 *
 */
NTSTATUS
DsiTdiCompletionRoutine(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
)
{
    KeSetEvent((PKEVENT )Context, 0, FALSE);
    return(STATUS_MORE_PROCESSING_REQUIRED);
}



/***	DsiTdiSend
 *
 *	This routine is the send routine for all DSI sends out to TCP
 *
 *  Parm IN:  pTcpConn - the connection object
 *            pMdl - mdl containing the buffer
 *            DataLen - how many bytes to send
 *            pCompletionRoutine - whom to call when send completes
 *            pContext - context for the completion routine
 *
 *  Returns:  status of operation
 *
 */
NTSTATUS
DsiTdiSend(
    IN  PTCPCONN    pTcpConn,
    IN  PMDL        pMdl,
    IN  DWORD       DataLen,
    IN  PVOID       pCompletionRoutine,
    IN  PVOID       pContext
)
{
    PDEVICE_OBJECT      pDeviceObject;
    PIRP                pIrp;
    NTSTATUS            status;


// make sure beginning of the packet looks like the DSI header
#if DBG
    PBYTE  pPacket;
    pPacket = MmGetSystemAddressForMdlSafe(
			pMdl,
			NormalPagePriority);
	if (pPacket != NULL)
		ASSERT(*(DWORD *)&pPacket[DSI_OFFSET_DATALEN] == ntohl(DataLen-DSI_HEADER_SIZE));
#endif

    pDeviceObject = IoGetRelatedDeviceObject(pTcpConn->con_pFileObject);

    if ((pIrp = AfpAllocIrp(pDeviceObject->StackSize)) == NULL)
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiTdiSend: AllocIrp failed\n"));

        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    pIrp->CancelRoutine = NULL;

    TdiBuildSend(
        pIrp,
        pDeviceObject,
        pTcpConn->con_pFileObject,
        pCompletionRoutine,
        pContext,
        pMdl,
        0,
        DataLen);

    status = IoCallDriver(pDeviceObject,pIrp);

    if (!NT_SUCCESS(status))
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiTdiSend: IoCallDriver failed %lx\n",status));
    }

    return(STATUS_PENDING);

}



/***	DsiIpAddressCameIn
 *
 *	This routine gets called when ipaddress becomes available on an adapter
 *
 *  Parm IN:  Address - TA_ADDRESS
 *            Context1 -
 *            Context2 -
 *
 *  Returns:  none
 *
 */
VOID
DsiIpAddressCameIn(
    IN  PTA_ADDRESS         Address,
    IN  PUNICODE_STRING     DeviceName,
    IN  PTDI_PNP_CONTEXT    Context2
)
{
    IPADDRESS           IpAddress;
    PUNICODE_STRING     pBindDeviceName;
    NTSTATUS            status=STATUS_SUCCESS;
    KIRQL               OldIrql;
    BOOLEAN             fCreateAdapter=FALSE;
    BOOLEAN             fClosing=FALSE;


    pBindDeviceName = DeviceName;

    // if this is not an ipaddress, we don't care: just return
    if (Address->AddressType != TDI_ADDRESS_TYPE_IP)
    {
        return;
    }

    IpAddress = ntohl(((PTDI_ADDRESS_IP)&Address->Address[0])->in_addr);

    if (IpAddress == 0)
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_WARN,
            ("AfpTdiIpAddressCameIn: ipaddress is 0 on %ws!\n",
            (pBindDeviceName)->Buffer));
        return;
    }

	DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_WARN,
        ("AfpTdiIpAddressCameIn: %d.%d.%d.%d on %ws\n",
        (IpAddress>>24)&0xFF,(IpAddress>>16)&0xFF,(IpAddress>>8)&0xFF,
        IpAddress&0xFF,(pBindDeviceName)->Buffer));


    if ((AfpServerState == AFP_STATE_STOP_PENDING) ||
        (AfpServerState == AFP_STATE_SHUTTINGDOWN) ||
        (AfpServerState == AFP_STATE_STOPPED))
    {
	    DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("AfpTdiIpAddressCameIn: server shutting down, returning\n"));
        return;
    }

    //
    // do we already have the DSI-tdi interface initialized (i.e. DsiTcpAdapter
    // is non-null)?  If we already saw an ipaddr come in earlier, this would be
    // initialized.  if not, we must initialize now
    //
    ACQUIRE_SPIN_LOCK(&DsiAddressLock, &OldIrql);
    if (DsiTcpAdapter == NULL)
    {
        fCreateAdapter = TRUE;
    }
    RELEASE_SPIN_LOCK(&DsiAddressLock, OldIrql);


    // add this ipaddress to our list
    DsiAddIpaddressToList(IpAddress);

    if (fCreateAdapter)
    {
        DsiCreateAdapter();
    }

    // ipaddress came in: update the status buffer
    DsiScheduleWorkerEvent(DsiUpdateAfpStatus, NULL);
}




/***	DsiIpAddressWentAway
 *
 *	This routine gets called when ipaddress goes away on an adapter
 *
 *  Parm IN:  Address - TA_ADDRESS
 *            Context1 -
 *            Context2 -
 *
 *  Returns:  none
 *
 */
VOID
DsiIpAddressWentAway(
    IN  PTA_ADDRESS         Address,
    IN  PUNICODE_STRING     DeviceName,
    IN  PTDI_PNP_CONTEXT    Context2
)
{
    PUNICODE_STRING     pBindDeviceName;
    IPADDRESS           IpAddress;
    KIRQL               OldIrql;
    BOOLEAN             fDestroyIt=FALSE;
    BOOLEAN             fIpAddrRemoved=TRUE;
    BOOLEAN             fMustDeref=FALSE;


    pBindDeviceName = DeviceName;

    if (Address->AddressType != TDI_ADDRESS_TYPE_IP)
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_WARN,
            ("AfpTdiIpAddressWentAway: unknown AddrType %d on %ws, ignoring!\n",
            Address->AddressType,(pBindDeviceName)->Buffer));
        return;
    }

    IpAddress = ntohl(((PTDI_ADDRESS_IP)&Address->Address[0])->in_addr);

    if (IpAddress == 0)
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_WARN,
            ("AfpTdiIpAddressWentAway: ipaddress is 0 on %ws!\n",
            (pBindDeviceName)->Buffer));
        return;
    }

    DsiRemoveIpaddressFromList(IpAddress);

    //
    // if the global adapter exists, see if we need to destroy it because the
    // last ipaddress went away
    //
    ACQUIRE_SPIN_LOCK(&DsiAddressLock, &OldIrql);
    if (DsiTcpAdapter != NULL)
    {
        fDestroyIt = IsListEmpty(&DsiIpAddrList)? TRUE : FALSE;
    }

    RELEASE_SPIN_LOCK(&DsiAddressLock, OldIrql);

    // ipaddress went away: update the status buffer
    DsiScheduleWorkerEvent(DsiUpdateAfpStatus, NULL);

    if (fDestroyIt)
    {
        DsiDestroyAdapter();
    }
}



/***	DsiTdiConnectHandler
 *
 *	This routine
 *
 *  Parm IN:  EventContext - pTcpAdptr that we passed when we set tdi handlers
 *            MacIpAddrLen - length of the address of the Mac (4 bytes!)
 *            pMacIpAddr - ipaddr of the Mac that's attempting to connect
 *            DsiDataLength - length of DSI data, if any, in this connect request
 *            pDsiData - pointer to DSI data, if any
 *            OptionsLength - unused
 *            pOptions - unused
 *
 *  Parm OUT: pOurConnContext - connection context, pTcpConn for this connection
 *            ppOurAcceptIrp - irp, if accpeting this connection
 *
 *  Returns:  status of operation
 *
 */
NTSTATUS
DsiTdiConnectHandler(
    IN  PVOID                EventContext,
    IN  int                  MacIpAddrLen,
    IN  PVOID                pSrcAddress,
    IN  int                  DsiDataLength,
    IN  PVOID                pDsiData,
    IN  int                  OptionsLength,
    IN  PVOID                pOptions,
    OUT CONNECTION_CONTEXT  *pOurConnContext,
    OUT PIRP                *ppOurAcceptIrp
)
{
    NTSTATUS            status=STATUS_SUCCESS;
    PTCPADPTR           pTcpAdptr;
    PTCPCONN            pTcpConn;
    PDEVICE_OBJECT      pDeviceObject;
    IPADDRESS           MacIpAddr;
    PTRANSPORT_ADDRESS  pXportAddr;
    PIRP                pIrp;


    pTcpAdptr = (PTCPADPTR)EventContext;

    *pOurConnContext = NULL;
    *ppOurAcceptIrp = NULL;

    ASSERT(pTcpAdptr->adp_Signature == DSI_ADAPTER_SIGNATURE);

    pDeviceObject = IoGetRelatedDeviceObject(pTcpAdptr->adp_pFileObject);

    if ((pIrp = AfpAllocIrp(pDeviceObject->StackSize)) == NULL)
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiTdiConnectHandler: AllocIrp failed\n"));

        return(STATUS_DATA_NOT_ACCEPTED);
    }

    pXportAddr = (PTRANSPORT_ADDRESS)pSrcAddress;
    MacIpAddr = ((PTDI_ADDRESS_IP)&pXportAddr->Address[0].Address[0])->in_addr;

    //
    // see if DSI wants to accept this connection
    //
    status = DsiAcceptConnection(pTcpAdptr, ntohl(MacIpAddr), &pTcpConn);

    if (!NT_SUCCESS(status))
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiTdiConnectHandler: DsiAccep.. failed %lx\n",status));

        AfpFreeIrp(pIrp);
        return(status);
    }

    TdiBuildAccept(pIrp,
                   IoGetRelatedDeviceObject(pTcpConn->con_pFileObject),
                   pTcpConn->con_pFileObject,
                   DsiAcceptConnectionCompletion,
                   pTcpConn,
                   NULL,
                   NULL);

    pIrp->MdlAddress = NULL;

    *pOurConnContext = (CONNECTION_CONTEXT)pTcpConn;
    *ppOurAcceptIrp = pIrp;

    // do what IoSubSystem would have done, if we had called IoCallDriver
    IoSetNextIrpStackLocation(pIrp);

    return(STATUS_MORE_PROCESSING_REQUIRED);

}

/***	DsiTdiReceiveHandler
 *
 *	This routine
 *
 *  Parm IN:  EventContext - pTcpAdptr that we passed when we set tdi handlers
 *            ConnectionContext - our context, pTcpConn for this connection
 *            RcvFlags - more info about how the data was received
 *            BytesIndicated - number of bytes tcp is indicating
 *            BytesAvailable - number of bytes that came in (tcp has with it)
 *            pDsiData - the data that came in
 *
 *  Parm OUT: pBytesAccepted - how many bytes did we accept
 *            ppIrp - irp, if for tcp to copy data in (if needed)
 *
 *  Returns:  status of operation
 *
 */
NTSTATUS
DsiTdiReceiveHandler(
    IN  PVOID       EventContext,
    IN  PVOID       ConnectionContext,
    IN  USHORT      RcvFlags,
    IN  ULONG       BytesIndicated,
    IN  ULONG       BytesAvailable,
    OUT PULONG      pBytesAccepted,
    IN  PVOID       pDsiData,
    OUT PIRP       *ppIrp
)
{

    NTSTATUS        status;
    PTCPCONN        pTcpConn;
    PBYTE           pBuffer;
    PIRP            pIrp;


    pTcpConn = (PTCPCONN)ConnectionContext;

    *ppIrp = NULL;
    *pBytesAccepted = 0;

    ASSERT(VALID_TCPCONN(pTcpConn));

    status = DsiProcessData(pTcpConn,
                            BytesIndicated,
                            BytesAvailable,
                            (PBYTE)pDsiData,
                            pBytesAccepted,
                            ppIrp);

    return(status);
}

/***	DsiTdiDisconnectHandler
 *
 *	This routine
 *
 *  Parm IN:  EventContext - pTcpAdptr that we passed when we set tdi handlers
 *            ConnectionContext - our context, pTcpConn for this connection
 *            DisconnectDataLength -
 *            pDisconnectData -
 *
 *
 *
 *  Returns:  status of operation
 *
 */
NTSTATUS
DsiTdiDisconnectHandler(
    IN PVOID        EventContext,
    IN PVOID        ConnectionContext,
    IN ULONG        DisconnectDataLength,
    IN PVOID        pDisconnectData,
    IN ULONG        DisconnectInformationLength,
    IN PVOID        pDisconnectInformation,
    IN ULONG        DisconnectIndicators
)
{

    PTCPCONN        pTcpConn;
    KIRQL           OldIrql;
    BOOLEAN         fMustAbort=FALSE;
    BOOLEAN         fWeInitiatedAbort=FALSE;


    pTcpConn = (PTCPCONN)ConnectionContext;

    ASSERT(VALID_TCPCONN(pTcpConn));

    //
    // if the connection went away non-gracefully (i.e. TCP got a reset), and
    // if we have not already given an irp down to tcp to disconnect, then
    // complete the disconnect here
    //
    if ((UCHAR)DisconnectIndicators == TDI_DISCONNECT_ABORT)
    {
        ACQUIRE_SPIN_LOCK(&pTcpConn->con_SpinLock, &OldIrql);

        fWeInitiatedAbort =
            (pTcpConn->con_State & TCPCONN_STATE_ABORTIVE_DISCONNECT)? TRUE : FALSE;

        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("ABORT from %s on %lx\n",fWeInitiatedAbort?"Local":"Remote",pTcpConn));

        if (pTcpConn->con_State & TCPCONN_STATE_NOTIFY_TCP)
        {
            fMustAbort = TRUE;
            pTcpConn->con_State &= ~TCPCONN_STATE_NOTIFY_TCP;
            pTcpConn->con_State |= TCPCONN_STATE_CLOSING;
        }
        RELEASE_SPIN_LOCK(&pTcpConn->con_SpinLock, OldIrql);

        if (fMustAbort)
        {
            DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_WARN,
                ("DsiTdiDisconnectHandler: abortive disconnect on %lx\n",pTcpConn));

            DsiAbortConnection(pTcpConn);

            DsiTcpDisconnectCompletion(NULL, NULL, pTcpConn);

            // TCP is telling us it got cient's RST: remove the TCP CLIENT-FIN refcount
            DsiDereferenceConnection(pTcpConn);

            DBGREFCOUNT(("DsiTdiDisconnectHandler: CLIENT-FIN dec %lx (%d  %d,%d)\n",
                pTcpConn,pTcpConn->con_RefCount,pTcpConn->con_State,pTcpConn->con_RcvState));
        }

        //
        // if we had initiated a graceful close, remove that TCP CLIENT-FIN refcount:
        // (if we had initiated an abortive close, we already took care of it)
        //
        else if (!fWeInitiatedAbort)
        {
            DsiDereferenceConnection(pTcpConn);
        }
        else
        {
            DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                ("DsiTdiDisconnectHandler: abortive disc,race condition on %lx\n",
                pTcpConn));
        }
    }
    else if ((UCHAR)DisconnectIndicators == TDI_DISCONNECT_RELEASE)
    {
        //
        // since we got a graceful disconnect from the remote client, we had
        // better received the DSI Close already.  If not, the client is on
        // drugs, so just reset the connection!
        //
        ACQUIRE_SPIN_LOCK(&pTcpConn->con_SpinLock, &OldIrql);

        if ((pTcpConn->con_State & TCPCONN_STATE_AFP_ATTACHED) &&
            (!(pTcpConn->con_State & TCPCONN_STATE_RCVD_REMOTE_CLOSE)))
        {
            fMustAbort = TRUE;
        }
        RELEASE_SPIN_LOCK(&pTcpConn->con_SpinLock, OldIrql);

        if (fMustAbort)
        {
            DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_WARN,
                ("DsiTdiDisconnectHandler: ungraceful FIN, killing %lx\n",pTcpConn));

            DsiAbortConnection(pTcpConn);
        }
        else
        {
            //
            // by this time, we shouldn't have to do this, but just in case we
            // have an ill-behaved client (calling this routine many times is ok)
            //
            DsiTerminateConnection(pTcpConn);

            // TCP is telling us it got cient's FIN: remove the TCP CLIENT-FIN refcount
            DsiDereferenceConnection(pTcpConn);

            DBGREFCOUNT(("DsiTdiDisconnectHandler: CLIENT-FIN dec %lx (%d  %d,%d)\n",
                pTcpConn,pTcpConn->con_RefCount,pTcpConn->con_State,pTcpConn->con_RcvState));
        }
    }
    else
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiTdiDisconnectHandler: flag=%d, ignored on %lx\n",
            DisconnectIndicators,pTcpConn));
        ASSERT(0);
    }

    return(STATUS_SUCCESS);
}


/***	DsiTdiErrorHandler
 *
 *	This routine
 *
 *  Parm IN:  EventContext - pTcpAdptr that we passed when we set tdi handlers
 *            status - what went wrong?
 *
 *  Returns:  status of operation
 *
 */
NTSTATUS
DsiTdiErrorHandler(
    IN PVOID    EventContext,
    IN NTSTATUS Status
)
{

    DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
        ("DsiTdiErrorHandler: entered, with Status=%lx\n",Status));

    ASSERT(0);

    return(STATUS_DATA_NOT_ACCEPTED);
}


/***	DsiCloseTdiAddress
 *
 *	This routine closes the address object with TCP
 *
 *  Parm IN:  pTcpAdptr - our adapter object
 *
 *  Returns:  status of operation
 *
 */
NTSTATUS
DsiCloseTdiAddress(
    IN PTCPADPTR    pTcpAdptr
)
{

    PEPROCESS   CurrentProcess;


    ASSERT(KeGetCurrentIrql() != DISPATCH_LEVEL);

    ASSERT(pTcpAdptr->adp_Signature == DSI_ADAPTER_SIGNATURE);

    CurrentProcess = IoGetCurrentProcess();
    AFPAttachProcess(CurrentProcess);;

    if (pTcpAdptr->adp_pFileObject)
    {
        ObDereferenceObject((PVOID *)pTcpAdptr->adp_pFileObject);
        pTcpAdptr->adp_pFileObject = NULL;
    }

    if (pTcpAdptr->adp_FileHandle != INVALID_HANDLE_VALUE)
    {
        ZwClose(pTcpAdptr->adp_FileHandle);
        pTcpAdptr->adp_FileHandle = INVALID_HANDLE_VALUE;
    }

    AFPDetachProcess(CurrentProcess);

    return(STATUS_SUCCESS);
}




/***	DsiCloseTdiConnection
 *
 *	This routine closes the connection object with TCP
 *
 *  Parm IN:  pTcpConn - our connection context
 *
 *  Returns:  status of operation
 *
 */
NTSTATUS
DsiCloseTdiConnection(
    IN PTCPCONN     pTcpConn
)
{

    PEPROCESS   CurrentProcess;


    ASSERT(KeGetCurrentIrql() != DISPATCH_LEVEL);

    ASSERT(pTcpConn->con_Signature == DSI_CONN_SIGNATURE);

    ASSERT(pTcpConn->con_pTcpAdptr->adp_Signature == DSI_ADAPTER_SIGNATURE);

    CurrentProcess = IoGetCurrentProcess();
    AFPAttachProcess(CurrentProcess);;

    if (pTcpConn->con_pFileObject)
    {
        ObDereferenceObject((PVOID *)pTcpConn->con_pFileObject);
        pTcpConn->con_pFileObject = NULL;
    }

    if (pTcpConn->con_FileHandle != INVALID_HANDLE_VALUE)
    {
        ZwClose(pTcpConn->con_FileHandle);
        pTcpConn->con_FileHandle = INVALID_HANDLE_VALUE;
    }

    AFPDetachProcess(CurrentProcess);

    return(STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\server\volume.c ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	volume.c

Abstract:

	This module contains the volume list manipulation routines and worker
	routines for some afp volume apis.

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	25 Apr 1992		Initial Version

Notes:	Tab stop: 4

	Volumes are represented by two distinct data structures VolDesc and ConnDesc

	VolDesc:This structure represents a configured volume. The information in
			this descriptor consists of static configuration information like
			the name of the volume and its path, reconfigurable information like
			the volume password and volume options and dynamic information like
			the open desktop, id database, open forks etc.
			The list of VolDesc structures orignate from AfpVolumeList and is
			protected by AfpVolumeListLock . The Volume descriptor fields are
			protected by vds_VolLock.

			A volume descriptor has a UseCount field which specifies how many
			clients have this volume open. The reference count specifies the
			number of references to this volume. A volume descriptor can be
			unlinked from the AfpVolumeList ONLY if the UseCount is ZERO. It
			can be freed only when the reference count is ZERO. The reference
			count can NEVER be less than the use count.

	ConnDesc:This is created for every instance of a volume opened by a client.
			This structure is mostly used in the context of the client. This
			is also used by the admin connection apis. The ConnDesc list is
			linked to its owning VolDesc, its owning SDA and AfpConnList. The
			list orignating from the SDA is protected by sda_Lock. The list
			orignating from AfpConnList is protected by AfpConnLock and the
			list orignating from the VolDesc is protected by vds_VolLock.

			The order in which the locks are acquired is as follows:

			1. AfpConnLock
			2. cds_ConnLock
			3. vds_VolLock
--*/

#define	FILENUM	FILE_VOLUME
#define	VOLUME_LOCALS
#include <afp.h>
#include <fdparm.h>
#include <scavengr.h>
#include <nwtrash.h>
#include <pathmap.h>
#include <afpinfo.h>
#include <forkio.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, AfpVolumeInit)
#pragma alloc_text( PAGE, AfpAdmWVolumeAdd)
#pragma alloc_text( PAGE, AfpVolumePostChangeNotify)
#pragma alloc_text( PAGE, afpVolumeChangeNotifyComplete)
#pragma alloc_text( PAGE, afpVolumeCloseHandleAndFreeDesc)
#pragma alloc_text( PAGE, afpNudgeCdfsVolume)
#pragma alloc_text( PAGE, AfpVolumeUpdateIdDbAndDesktop)
#pragma alloc_text( PAGE_AFP, AfpVolumeReferenceByUpCaseName)
#pragma alloc_text( PAGE_AFP, AfpVolumeReferenceByPath)
#pragma alloc_text( PAGE_AFP, afpConnectionReferenceById)
#pragma alloc_text( PAGE_AFP, afpVolumeAdd)
#pragma alloc_text( PAGE_AFP, afpVolumeCheckForDuplicate)
#pragma alloc_text( PAGE_AFP, AfpAdmWVolumeDelete)
#pragma alloc_text( PAGE_AFP, AfpAdmWConnectionClose)
#pragma alloc_text( PAGE_AFP, afpVolumeGetNewIdAndLinkToList)
#pragma alloc_text( PAGE_AFP, AfpVolumeStopAllVolumes)
#pragma alloc_text(PAGE, afpAllocNotify)
#pragma alloc_text(PAGE, afpFreeNotify)
#pragma alloc_text(PAGE, afpNotifyBlockAge)
#pragma alloc_text(PAGE, afpFreeNotifyBlockMemory)
#endif


/***	AfpVolumeInit
 *
 *	Initialize Volume Data structures. Called at init time.
 */
NTSTATUS
AfpVolumeInit(
	VOID
)
{
	LONG		i;

	INITIALIZE_SPIN_LOCK(&AfpConnLock);
	INITIALIZE_SPIN_LOCK(&AfpVolumeListLock);
	AfpSwmrInitSwmr(&afpNotifyBlockLock);
	AfpSwmrInitSwmr(&AfpVolumeListSwmr);

	for (i = 0; i < NUM_NOTIFY_QUEUES; i++)
	{
		InitializeListHead(&AfpVolumeNotifyList[i]);
		InitializeListHead(&AfpVirtualMemVolumeNotifyList[i]);
		AfpNotifyListCount[i] = 0;
		AfpNotifyQueueCount[i] = 0;
	}

    // Age out Notify Blocks
    AfpScavengerScheduleEvent(afpNotifyBlockAge,
				afpDirNotifyFreeBlockHead,
				NOTIFY_DIR_BLOCK_AGE_TIME,
				True);

	return STATUS_SUCCESS;
}


/***	AfpVolumeReference
 *
 *	Mark the volume descriptor as being referenced.
 *
 *	LOCKS:		vds_VolLock (SPIN)
 *
 *	Callable from DISPATCH_LEVEL.
 */
BOOLEAN FASTCALL
AfpVolumeReference(
	IN	PVOLDESC	pVolDesc
)
{
	KIRQL	OldIrql;
	BOOLEAN	RetCode = False;

	ASSERT (VALID_VOLDESC(pVolDesc));

	ACQUIRE_SPIN_LOCK(&pVolDesc->vds_VolLock, &OldIrql);

	// NOTE: in order for ChangeNotify code to reference volume
	// before it is officially not INTRANSITION, we must allow
	// a reference before INTRANSITION
	if (!(pVolDesc->vds_Flags & (VOLUME_DELETED | VOLUME_STOPPED)))
	{
		ASSERT (pVolDesc->vds_RefCount >= pVolDesc->vds_UseCount);

		pVolDesc->vds_RefCount++;

		RetCode = True;
	}

	RELEASE_SPIN_LOCK(&pVolDesc->vds_VolLock, OldIrql);
	return RetCode;
}


/***	AfpVolumeReferenceByUpCaseName
 *
 *	Reference the volume in AfpVolumeList with the same vds_UpCaseName as
 *	pTargetName.  Since we are holding the AfpVolumeListLock (SpinLock)
 *	and are at DPC level, our string comparison must be case sensitive, because
 *	the codepage used to do case insensitive compares is in paged memory, and
 *	we cannot take a pagefault at DPC level.
 *
 *	If we find the volume we are looking for, it will be referenced.  THE
 *	CALLER IS THEN RESPONSIBLE FOR DEREFERENCING THE VOLUME!!!
 *
 *	LOCKS:		vds_VolLock (SPIN), AfpVolumeListLock (SPIN)
 *	LOCK_ORDER: vds_VolLock after AfpVolumeListLock
 *
 */
PVOLDESC FASTCALL
AfpVolumeReferenceByUpCaseName(
	IN	PUNICODE_STRING	pTargetName
)
{
	PVOLDESC	pVolDesc;
	KIRQL		OldIrql;

	ACQUIRE_SPIN_LOCK(&AfpVolumeListLock, &OldIrql);

	for (pVolDesc = AfpVolumeList;
		 pVolDesc != NULL;
		 pVolDesc = pVolDesc->vds_Next)
	{
		BOOLEAN	Found;

		Found = False;

		ACQUIRE_SPIN_LOCK_AT_DPC(&pVolDesc->vds_VolLock);

		if ((pVolDesc->vds_Flags & (VOLUME_DELETED |
									VOLUME_STOPPED |
									VOLUME_INTRANSITION)) == 0)
		{
			if (AfpEqualUnicodeString(pTargetName,
									  &pVolDesc->vds_UpCaseName))
			{
				pVolDesc->vds_RefCount ++;
				Found = True;
			}

		}

		RELEASE_SPIN_LOCK_FROM_DPC(&pVolDesc->vds_VolLock);

		if (Found)
			break;
	}

	RELEASE_SPIN_LOCK(&AfpVolumeListLock,OldIrql);

	return pVolDesc;
}


/***	AfpVolumeReferenceByPath
 *
 *	Reference the volume by a path into the volume. We ignore volumes which are
 *	marked as in-transition, stopped or deleted. Also this is only supported for
 *	NTFS volumes since thats what these are used for.
 *
 *	LOCKS:		AfpVolumeListLock (SPIN), vds_VolLock (SPIN)
 *	LOCK_ORDER:	vds_VolLock after AfpVolumeListLock
 *
 */
AFPSTATUS FASTCALL
AfpVolumeReferenceByPath(
	IN	PUNICODE_STRING	pFDPath,
	OUT	PVOLDESC	*	ppVolDesc
)
{
	UNICODE_STRING		UpCasedVolPath;
	KIRQL				OldIrql;
	PVOLDESC			pVolDesc;
	AFPSTATUS			Status = AFPERR_DirectoryNotInVolume;

	// Allocate a buffer for upcasing the path. Tag on a trailing '\' at the
	// end. Then uppercase the volume path
	*ppVolDesc = NULL;
	UpCasedVolPath.MaximumLength = pFDPath->Length + 2*sizeof(WCHAR);
	if ((UpCasedVolPath.Buffer = (LPWSTR)
				AfpAllocNonPagedMemory(UpCasedVolPath.MaximumLength)) == NULL)
	{
		return STATUS_INSUFFICIENT_RESOURCES;
	}

	RtlUpcaseUnicodeString(&UpCasedVolPath, pFDPath, False);
	UpCasedVolPath.Buffer[UpCasedVolPath.Length/sizeof(WCHAR)] = L'\\';
	UpCasedVolPath.Length += sizeof(WCHAR);

	// Scan the volume list and map the path to a volume descriptor
	// If we get a match, reference the volume
	ACQUIRE_SPIN_LOCK(&AfpVolumeListLock, &OldIrql);

	for (pVolDesc = AfpVolumeList;
		 pVolDesc != NULL;
		 pVolDesc = pVolDesc->vds_Next)
	{
		BOOLEAN	Found;

		Found = False;

		ACQUIRE_SPIN_LOCK_AT_DPC(&pVolDesc->vds_VolLock);

		if ((pVolDesc->vds_Flags & (VOLUME_INTRANSITION | VOLUME_STOPPED | VOLUME_DELETED)) == 0)
		{
			if (AfpPrefixUnicodeString(&pVolDesc->vds_Path, &UpCasedVolPath))
			{
				Found = True;
                // Share out NTFS, CD and CD-HFS 
				if (IS_VOLUME_NTFS(pVolDesc) || IS_VOLUME_RO(pVolDesc))
				// if (IS_VOLUME_NTFS(pVolDesc))
				{
					pVolDesc->vds_RefCount ++;
					Status = STATUS_SUCCESS;
					*ppVolDesc = pVolDesc;
				}
				else
				{
				    Status = AFPERR_UnsupportedFS;
                    DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_ERR,
                            ("AfpVolumeReferenceByPath: *** AFPERR_UnsupportedFS**" ));
				}
			}
		}
		RELEASE_SPIN_LOCK_FROM_DPC(&pVolDesc->vds_VolLock);

		if (Found)
			break;
	}
	RELEASE_SPIN_LOCK(&AfpVolumeListLock, OldIrql);

	AfpFreeMemory(UpCasedVolPath.Buffer);

	return Status;
}


/***	afpUnlinkVolume
 *
 *	Unlink the volume from the free list
 *
 *	LOCKS: AfpVolumeListLock (SPIN)
 */
LOCAL VOID FASTCALL
afpUnlinkVolume(
	IN	PVOLDESC	pVolDesc
)
{
	PVOLDESC *	ppVolDesc;
	KIRQL		OldIrql;

	// It is now safe for a new volume to be added using the same root
	// directory that this volume had used.  Unlink this volume from the
	// global volume list.
	ACQUIRE_SPIN_LOCK(&AfpVolumeListLock, &OldIrql);

	for (ppVolDesc = &AfpVolumeList;
		 *ppVolDesc != NULL;
		 ppVolDesc = &(*ppVolDesc)->vds_Next)
	{
		if (*ppVolDesc == pVolDesc)
			break;		// found it
	}

	ASSERT (*ppVolDesc != NULL);

	// Adjust the count of configured volumes
	AfpVolCount --;

	// Unlink it now
	*ppVolDesc = pVolDesc->vds_Next;

	// Is this the smallest recyclable Volid ?
	if (pVolDesc->vds_VolId < afpSmallestFreeVolId)
		afpSmallestFreeVolId = pVolDesc->vds_VolId;

        // if the volume with largest id so far is going away, update our value for largest id
        if (pVolDesc->vds_VolId == afpLargestVolIdInUse)
	{
                afpLargestVolIdInUse = 0;
		for (ppVolDesc = &AfpVolumeList;
			 *ppVolDesc != NULL;
			 ppVolDesc = &((*ppVolDesc)->vds_Next))
		{
			if ((*ppVolDesc)->vds_VolId > afpLargestVolIdInUse)
                                afpLargestVolIdInUse = (*ppVolDesc)->vds_VolId;
		}
	}

	// If the server is stopping and the count of sessions has gone to zero
	// clear the termination confirmation event to unblock the admin thread

	if (((AfpServerState == AFP_STATE_STOP_PENDING) ||
		 (AfpServerState == AFP_STATE_SHUTTINGDOWN)) &&
		(AfpVolCount == 0))
	{
		DBGPRINT(DBG_COMP_ADMINAPI, DBG_LEVEL_WARN,
				("afpVolumeCloseHandleAndFreeDesc: Unblocking server stop\n"));

		KeSetEvent(&AfpStopConfirmEvent, IO_NETWORK_INCREMENT, False);
	}

	RELEASE_SPIN_LOCK(&AfpVolumeListLock, OldIrql);
}


/***	afpVolumeCloseHandleAndFreeDesc
 *
 *	If the last entity to dereference the volume is at DPC level, this is run
 *	by the scavenger thread to perform the last rites for a volume descriptor.
 *	Otherwise, the last entity to dereference the deleted volume will call
 *	this routine directly.  The reason this is done here is because the last
 *	dereference may happen at DPC level and we cannot do this at DPC level.
 *
 *	The VolDesc is marked DELETED or STOPPED and as such, anyone looking at the
 *	VolDesc in the volume list will treat it as though it is non-existant.
 *	The one exception to this is the volume add code which must look at the
 *	volume root path in order to prohibit anyone from adding a new volume
 *	which points to the same path until we have actually done the final
 *	cleanup on the directory tree, such as deleting the network trash, deleting
 *	the various streams, etc.  In effect, the VOLUME_DELETED or VOLUME_STOPPED
 *	flags act as a lock for the volume, so that during this routine no locks are
 *	needed.
 *
 */
LOCAL AFPSTATUS FASTCALL
afpVolumeCloseHandleAndFreeDesc(
	IN	PVOLDESC		pVolDesc
)
{
	int				        id;
	FILESYSHANDLE	        streamhandle;
	PLIST_ENTRY	            pList;
	int				        i;
    PDELAYED_NOTIFY         pDelayedNotify;

	PAGED_CODE( );

	ASSERT(VALID_VOLDESC(pVolDesc));

	DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_WARN,
			("afpVolumeCloseHandleAndFreeDesc: Shutting Down volume %d\n",
			pVolDesc->vds_VolId));

	DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_WARN,
			("afpVolumeCloseHandleAndFreeDesc: Freeing up desktop tables\n"));
	// Free the volume desktop
	AfpFreeDesktopTables(pVolDesc);

	DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_WARN,
			("afpVolumeCloseHandleAndFreeDesc: Freeing up iddb tables\n"));
	// Free the id index tables
	AfpFreeIdIndexTables(pVolDesc);

	// Delete the Network Trash Folder and the Afp_IdIndex, AFP_DeskTop,
	// and AFP_AfpInfo streams from volume root directory (the streams
	// are removed only if the volume is being deleted.  NetworkTrash is
	// removed whenever the volume stops/gets deleted)
	if (IS_VOLUME_NTFS(pVolDesc))
	{
		DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_WARN,
				("afpVolumeCloseHandleAndFreeDesc: Deleting the Network trash tree\n"));
		AfpDeleteNetworkTrash(pVolDesc, False);
		if (!(pVolDesc->vds_Flags & (VOLUME_INTRANSITION | VOLUME_STOPPED)))
		{
			WCHAR	wchVolIcon[AFPSERVER_VOLUME_ICON_FILE_SIZE] = AFPSERVER_VOLUME_ICON_FILE;
			UNICODE_STRING UIconName;

			for (id = AFP_STREAM_IDDB;id < AFP_STREAM_COMM; id++)
			{
				if (NT_SUCCESS(AfpIoOpen(&pVolDesc->vds_hRootDir,
										 id,
										 FILEIO_OPEN_FILE,
										 &UNullString,
										 FILEIO_ACCESS_DELETE,
										 FILEIO_DENY_NONE,
										 False,
										 &streamhandle)))
				{
					AfpIoMarkFileForDelete(&streamhandle, NULL, NULL, NULL);
					AfpIoClose(&streamhandle);
				}
			}

			UIconName.Buffer = wchVolIcon;
			UIconName.Length = UIconName.MaximumLength =
					(AFPSERVER_VOLUME_ICON_FILE_SIZE - 1) * sizeof(WCHAR);

			// Delete the hidden volume Icon file
			if (NT_SUCCESS(AfpIoOpen(&pVolDesc->vds_hRootDir,
									 AFP_STREAM_DATA,
									 FILEIO_OPEN_FILE,
									 &UIconName,
									 FILEIO_ACCESS_DELETE,
									 FILEIO_DENY_NONE,
									 False,
									 &streamhandle)))

			{

				AfpIoMarkFileForDelete(&streamhandle, NULL, NULL, NULL);
				AfpIoClose(&streamhandle);
			}
		}
	}

	// Flush out any queued 'our changes' on this volume
	for (i = 0; i < NUM_AFP_CHANGE_ACTION_LISTS; i++)
	{
		POUR_CHANGE	pChange;

		ASSERTMSG("afpVolumeCloseHandleAndFreeDesc: vds_OurChangeList not empty\n",
				 IsListEmpty(&pVolDesc->vds_OurChangeList[i]));

		while (!IsListEmpty(&pVolDesc->vds_OurChangeList[i]))
		{
			pList = RemoveHeadList(&pVolDesc->vds_OurChangeList[i]);
			pChange = CONTAINING_RECORD(pList, OUR_CHANGE, oc_Link);
			DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_ERR,
					("afpVolumeCloseHandleAndFreeDesc: Manually freeing list for Action %x, Pathname %Z\n",
					i, &pChange->oc_Path));
			AfpFreeMemory(pChange);
		}
	}

	afpUnlinkVolume(pVolDesc);

	// Close the volume handle
	AfpIoClose(&pVolDesc->vds_hRootDir);
	if (pVolDesc->vds_EnumBuffer != NULL)
    {
		AfpFreePANonPagedMemory(pVolDesc->vds_EnumBuffer, AFP_ENUMBUF_SIZE);
    }

    if (pVolDesc->vds_pDfeDirBucketStart)
    {
        AfpFreeMemory(pVolDesc->vds_pDfeDirBucketStart);
    }

    if (pVolDesc->vds_pDfeFileBucketStart)
    {
        AfpFreeMemory(pVolDesc->vds_pDfeFileBucketStart);
    }

    pList = pVolDesc->vds_DelayedNotifyList.Flink;
    while (pList != &pVolDesc->vds_DelayedNotifyList)
    {
        DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_ERR,
            ("afpVolumeCloseHandleAndFreeDesc: freeing delayed notify buf %lx\n",pDelayedNotify));

        pDelayedNotify = CONTAINING_RECORD (pList, DELAYED_NOTIFY, dn_List);
        pList = pList->Flink;
        RemoveEntryList(&pDelayedNotify->dn_List);
        AfpFreeMemory(pDelayedNotify->filename.Buffer);
        AfpFreeMemory(pDelayedNotify);
    }

    DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_ERR,
        ("afpVolumeCloseHandleAndFreeDesc: freeing %lx for vol %Z\n",
        pVolDesc,&pVolDesc->vds_Name));

	AfpFreeMemory(pVolDesc);

	return AFP_ERR_NONE;
}


/***	AfpVolumeDereference
 *
 *	Dereference the volume descriptor. If it is marked to be deleted then
 *	also perform its last rites. Note that updates to the databases need
 *	to happen at a lower irql than DISPATCH_LEVEL. For this reason these
 *	activities have to be queued up for the scavenger to handle.
 *
 *	LOCKS:		vds_VolLock (SPIN)
 *
 *	Callable from DISPATCH_LEVEL.
 *
 *	NOTE: This should be re-entrant.
 */
VOID FASTCALL
AfpVolumeDereference(
	IN	PVOLDESC	pVolDesc
)
{
	KIRQL			OldIrql;
	BOOLEAN			Cleanup = False;


	ASSERT (pVolDesc != NULL);
	ASSERT (VALID_VOLDESC(pVolDesc));


	ACQUIRE_SPIN_LOCK(&pVolDesc->vds_VolLock, &OldIrql);

	ASSERT (pVolDesc->vds_RefCount >= pVolDesc->vds_UseCount);

	pVolDesc->vds_RefCount --;

	if ((pVolDesc->vds_RefCount == 0) &&
		(pVolDesc->vds_Flags & (VOLUME_DELETED | VOLUME_STOPPED)))
		Cleanup = True;

	RELEASE_SPIN_LOCK(&pVolDesc->vds_VolLock, OldIrql);

	if (Cleanup)
	{
        if ((pVolDesc->vds_Flags & VOLUME_INITIAL_CACHE) &&
            !(pVolDesc->vds_Flags & VOLUME_INTRANSITION))
        {
            // set this so we don't reset the Indexing global flag again!
            pVolDesc->vds_Flags |= VOLUME_INTRANSITION;
        }

		ASSERT((pVolDesc->vds_UseCount == 0) &&
			   (pVolDesc->vds_pOpenForkDesc == NULL));

		// We have to defer the actual close of the volume root handle to the
		// scavenger, if we are at DISPATCH_LEVEL.

		if (OldIrql == DISPATCH_LEVEL)
		{
			 DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_INFO,
					("AfpVolumeDereference: Queuing Close&Free to Scavenger\n"));

			 AfpScavengerScheduleEvent(afpVolumeCloseHandleAndFreeDesc,
									   pVolDesc,
									   0,
									   True);
		}
		else
        {
            afpVolumeCloseHandleAndFreeDesc(pVolDesc);
        }

	}
}


/***	AfpVolumeMarkDt
 *
 *	Set the ConnDesc for this volume to indicate that the desktop is
 *	opened/closed.
 *
 *	LOCKS:	cds_ConnLock (SPIN)
 *
 *	Callable from DISPATCH_LEVEL.
 */
BOOLEAN
AfpVolumeMarkDt(
	IN  PSDA		pSda,
	IN  PCONNDESC	pConnDesc,
	IN  DWORD		OpenState
)
{
	BOOLEAN		Success = True;

	ACQUIRE_SPIN_LOCK_AT_DPC(&pConnDesc->cds_ConnLock);
	if (OpenState)
	{
		 pConnDesc->cds_Flags |= CONN_DESKTOP_OPENED;
	}
	else if (pConnDesc->cds_Flags & CONN_DESKTOP_OPENED)
	{
		pConnDesc->cds_Flags &= ~CONN_DESKTOP_OPENED;
	}
	else
	{
		 Success = False;
	}
	RELEASE_SPIN_LOCK_FROM_DPC(&pConnDesc->cds_ConnLock);

	return Success;
}


/***	AfpVolumeSetModifiedTime
 *
 *	Set the Volume Modified time for this volume to the current time.
 *
 *	Callable from DISPATCH_LEVEL.
 *
 *	LOCKS:	vds_VolLock (SPIN)
 */
VOID FASTCALL
AfpVolumeSetModifiedTime(
	IN  PVOLDESC	pVolDesc
)
{
	KIRQL		OldIrql;
    AFPTIME     OriginalTime;
    DWORD       dwSchedDelay;
    BOOLEAN     fSendNotification=FALSE;


	// ASSERT (IS_VOLUME_NTFS(pVolDesc));

	ACQUIRE_SPIN_LOCK(&pVolDesc->vds_VolLock, &OldIrql);

    OriginalTime = pVolDesc->vds_ModifiedTime;
	AfpGetCurrentTimeInMacFormat(&pVolDesc->vds_ModifiedTime);

	pVolDesc->vds_Flags |= VOLUME_IDDBHDR_DIRTY;

    //
    // volume was modified: need to inform all the Afp22 clients
    //
    if ((pVolDesc->vds_ModifiedTime > OriginalTime) &&
		((pVolDesc->vds_Flags & (VOLUME_DELETED |
								 VOLUME_STOPPED |
								 VOLUME_INTRANSITION )) == 0))
    {
        fSendNotification = TRUE;

        // put SendNotif refcount
        pVolDesc->vds_RefCount++;

        //
        // if we don't have a notification pending, reset our MustSend clock!
        // (idea here is that if there are too many notifications happening withing
        // a very short time, we don't want to send a notification for every change,
        // but at the same time, don't want to wait beyond AFP_MAX_SRVR_NOTIF_INTERVAL
        // to send a notification).
        //
        if (!(pVolDesc->vds_Flags & VOLUME_SRVR_NOTIF_PENDING))
        {
            dwSchedDelay = AFP_MIN_SRVR_NOTIF_INTERVAL;

            pVolDesc->vds_TimeToSendNotify =
                        AfpSecondsSinceEpoch + AFP_MIN_SRVR_NOTIF_INTERVAL;

            pVolDesc->vds_TimeMustSendNotify =
                            AfpSecondsSinceEpoch + AFP_MAX_SRVR_NOTIF_INTERVAL;

            pVolDesc->vds_Flags |= VOLUME_SRVR_NOTIF_PENDING;
        }

        // advance the next send time by a second
        else
        {
            if (pVolDesc->vds_TimeToSendNotify >= AfpSecondsSinceEpoch)
            {
                pVolDesc->vds_TimeToSendNotify = pVolDesc->vds_TimeToSendNotify + 1;
            }
            else
            {
                pVolDesc->vds_TimeToSendNotify = AfpSecondsSinceEpoch + 1;
            }

            dwSchedDelay = (pVolDesc->vds_TimeToSendNotify - AfpSecondsSinceEpoch);
        }

    }

	RELEASE_SPIN_LOCK(&pVolDesc->vds_VolLock, OldIrql);

    // if necessary, tell those AFP22 clients that volume mod time changed
    if (fSendNotification)
    {
        AfpScavengerScheduleEvent(AfpSendServerNotification,
                                  pVolDesc,
                                  dwSchedDelay,
                                  True);
    }

}

AFPSTATUS FASTCALL
AfpSendServerNotification(
	IN  PVOLDESC	pVolDesc
)
{
    KIRQL       OldIrql;
    PSDA        pSda;
    PSDA        pSdaNext;
    PCONNDESC   pConnDesc;
    BOOLEAN     fSendOnThisSda;
    BOOLEAN     fMustSend=FALSE;



    ASSERT (VALID_VOLDESC(pVolDesc));
	// ASSERT (IS_VOLUME_NTFS(pVolDesc));

    ACQUIRE_SPIN_LOCK(&pVolDesc->vds_VolLock, &OldIrql);

    // is the volume shutting down?  if so, don't do anything
	if (pVolDesc->vds_Flags & (VOLUME_DELETED |
	                           VOLUME_STOPPED |
	                           VOLUME_INTRANSITION))
    {
        RELEASE_SPIN_LOCK(&pVolDesc->vds_VolLock, OldIrql);

        // remove the SendNotif refcount
        AfpVolumeDereference(pVolDesc);

        return(AFP_ERR_NONE);
    }

    // is it time to send the notify?
    if (AfpSecondsSinceEpoch >= pVolDesc->vds_TimeToSendNotify)
    {
        fMustSend = TRUE;
    }

    //
    // has it been a while since we sent a notify?  This would happen if a there is
    // a big tree copy going on the server which keeps pushing vds_TimeToSendNotify
    // forward, so AfpSecondsSinceEpoch is never less or equal to it.
    //
    else if (AfpSecondsSinceEpoch >= pVolDesc->vds_TimeMustSendNotify)
    {
        fMustSend = TRUE;
    }

    if (fMustSend)
    {
        pVolDesc->vds_Flags &= ~VOLUME_SRVR_NOTIF_PENDING;

        pVolDesc->vds_TimeMustSendNotify = AfpSecondsSinceEpoch;
    }

    RELEASE_SPIN_LOCK(&pVolDesc->vds_VolLock, OldIrql);

    if (!fMustSend)
    {
        // remove the SendNotif refcount
        AfpVolumeDereference(pVolDesc);

        return(AFP_ERR_NONE);
    }

    ACQUIRE_SPIN_LOCK(&AfpSdaLock, &OldIrql);

    for (pSda = AfpSessionList; pSda != NULL; pSda = pSdaNext)
    {
        pSdaNext = pSda->sda_Next;

        ACQUIRE_SPIN_LOCK_AT_DPC(&pSda->sda_Lock);

        //
        // if the sda is closing, or if the client is older than version AFP2.2 or if
        // we have just sent the notify to the client, skip this sda
        //
        if ((pSda->sda_Flags & (SDA_CLOSING | SDA_SESSION_CLOSED | SDA_CLIENT_CLOSE)) ||
            (pSda->sda_ClientVersion < AFP_VER_22) ||
            (pSda->sda_Flags & SDA_SESSION_NOTIFY_SENT))
        {
            RELEASE_SPIN_LOCK_FROM_DPC(&pSda->sda_Lock);
            continue;
        }

        //
        // find out if this session has mounted this volume.  Only if it is, we
        // send notification to this session
        //

        fSendOnThisSda = FALSE;
        pConnDesc = pSda->sda_pConnDesc;

        while (pConnDesc != NULL)
        {
            ASSERT(VALID_CONNDESC(pConnDesc));

            if (pConnDesc->cds_pVolDesc == pVolDesc)
            {
                fSendOnThisSda = TRUE;
                pSda->sda_RefCount ++;
                break;
            }
            pConnDesc = pConnDesc->cds_Next;
        }

        pSda->sda_Flags |= SDA_SESSION_NOTIFY_SENT;

        RELEASE_SPIN_LOCK_FROM_DPC(&pSda->sda_Lock);

        RELEASE_SPIN_LOCK(&AfpSdaLock, OldIrql);

        if (fSendOnThisSda)
        {
            AfpSpSendAttention(pSda, ATTN_SERVER_NOTIFY, False);

            AfpSdaDereferenceSession(pSda);
        }

        ACQUIRE_SPIN_LOCK(&AfpSdaLock, &OldIrql);

        pSdaNext = AfpSessionList;
    }

    RELEASE_SPIN_LOCK(&AfpSdaLock, OldIrql);

    //
    // now, go back and reset that flag
    //
    ACQUIRE_SPIN_LOCK(&AfpSdaLock, &OldIrql);
    for (pSda = AfpSessionList; pSda != NULL; pSda = pSda->sda_Next)
    {
        pSdaNext = pSda->sda_Next;

        ACQUIRE_SPIN_LOCK_AT_DPC(&pSda->sda_Lock);

        pSda->sda_Flags &= ~SDA_SESSION_NOTIFY_SENT;

        RELEASE_SPIN_LOCK_FROM_DPC(&pSda->sda_Lock);
    }
    RELEASE_SPIN_LOCK(&AfpSdaLock, OldIrql);

    // remove the SendNotif refcount
    AfpVolumeDereference(pVolDesc);

    return(AFP_ERR_NONE);
}


/***	AfpConnectionReference
 *
 *	Map the volume id to a pointer to the connection descriptor. Traverse the
 *	list starting from the Sda. Since the open volume can be reference from
 *	both the session using it as well as the worker serving admin requests,
 *	we need a lock.
 *
 *	LOCKS:		AfpConnLock, vds_VolLock (SPIN), cds_ConnLock (SPIN).
 *
 *	LOCK_ORDER:	vds_VolLock after cds_ConnLock. (via AfpVolumeReference)
 *
 *	Callable from DISPATCH_LEVEL.
 */
PCONNDESC FASTCALL
AfpConnectionReference(
	IN  PSDA		pSda,
	IN  LONG		VolId
)
{
	PCONNDESC	pConnDesc;
	KIRQL		OldIrql;

	KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);

	pConnDesc = AfpConnectionReferenceAtDpc(pSda, VolId);

	KeLowerIrql(OldIrql);

	return pConnDesc;
}



/***	AfpConnectionReferenceAtDpc
 *
 *	Map the volume id to a pointer to the connection descriptor. Traverse the
 *	list starting from the Sda. Since the open volume can be reference from
 *	both the session using it as well as the worker serving admin requests,
 *	we need a lock.
 *
 *	LOCKS:		AfpConnLock, vds_VolLock (SPIN), cds_ConnLock (SPIN).
 *
 *	LOCK_ORDER:	vds_VolLock after cds_ConnLock. (via AfpVolumeReference)
 *
 *	Callable from DISPATCH_LEVEL ONLY
 */
PCONNDESC FASTCALL
AfpConnectionReferenceAtDpc(
	IN  PSDA		pSda,
	IN  LONG		VolId
)
{
	PCONNDESC	pConnDesc, pCD = NULL;
	PVOLDESC	pVolDesc;

	ASSERT (VALID_SDA(pSda) && (VolId != 0));
	ASSERT (KeGetCurrentIrql() == DISPATCH_LEVEL);

	ACQUIRE_SPIN_LOCK_AT_DPC(&AfpConnLock);
	for (pConnDesc = pSda->sda_pConnDesc;
		 pConnDesc != NULL;
		 pConnDesc = pConnDesc->cds_Next)
	{
		if (pConnDesc->cds_pVolDesc->vds_VolId == VolId)
			break;
	}
	RELEASE_SPIN_LOCK_FROM_DPC(&AfpConnLock);

	if (pConnDesc != NULL)
	{
		ASSERT(VALID_CONNDESC(pConnDesc));

		pVolDesc = pConnDesc->cds_pVolDesc;
		ASSERT(VALID_VOLDESC(pVolDesc));

		ACQUIRE_SPIN_LOCK_AT_DPC(&pConnDesc->cds_ConnLock);

		if ((pConnDesc->cds_Flags & CONN_CLOSING) == 0)
		{
			pCD = pConnDesc;
			pConnDesc->cds_RefCount ++;
		}

		RELEASE_SPIN_LOCK_FROM_DPC(&pConnDesc->cds_ConnLock);
	}

	DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_INFO,
			("AfpConnectionReferenence: VolId %d, pConnDesc %lx\n", VolId, pConnDesc));

	return pCD;
}



/***	AfpConnectionReferenceByPointer
 *
 *	Reference the Connection descriptor. This is used by the admin APIs.
 *
 *	LOCKS:		vds_VolLock (SPIN), cds_ConnLock (SPIN).
 *
 *	LOCK_ORDER:	vds_VolLock after cds_ConnLock. (via AfpVolumeReference)
 *
 *	Callable from DISPATCH_LEVEL.
 */
PCONNDESC FASTCALL
AfpConnectionReferenceByPointer(
	IN	PCONNDESC	pConnDesc
)
{
	PCONNDESC	pCD = NULL;
	PVOLDESC	pVolDesc;
	KIRQL		OldIrql;

	ASSERT (VALID_CONNDESC(pConnDesc));

	pVolDesc = pConnDesc->cds_pVolDesc;
	ASSERT(VALID_VOLDESC(pVolDesc));

	ACQUIRE_SPIN_LOCK(&pConnDesc->cds_ConnLock, &OldIrql);

	if ((pConnDesc->cds_Flags & CONN_CLOSING) == 0)
	{
		pConnDesc->cds_RefCount ++;
		pCD = pConnDesc;
	}

	RELEASE_SPIN_LOCK(&pConnDesc->cds_ConnLock, OldIrql);

	return pCD;
}


/***	afpConnectionReferenceById
 *
 *	Map the Connection id to a pointer to the connection descriptor.
 *	Traverse the list starting from the AfpConnList. This is called by
 *	the Admin CloseConnection API.
 *
 *	LOCKS:		AfpConnLock, cds_ConnLock (SPIN).
 *
 *	LOCK_ORDER:	vds_VolLock after cds_ConnLock. (via AfpVolumeReference)
 *
 *	Callable from DISPATCH_LEVEL.
 */
LOCAL PCONNDESC FASTCALL
afpConnectionReferenceById(
	IN  DWORD		ConnId
)
{
	PCONNDESC	pConnDesc;
	PCONNDESC	pRetConnDesc=NULL;
	PVOLDESC	pVolDesc;
	KIRQL		OldIrql;

	ASSERT (ConnId != 0);

	ACQUIRE_SPIN_LOCK(&AfpConnLock, &OldIrql);

	for (pConnDesc = AfpConnList;
		 pConnDesc != NULL;
		 pConnDesc = pConnDesc->cds_NextGlobal)
	{
		if (pConnDesc->cds_ConnId == ConnId)
			break;
	}

	if (pConnDesc != NULL)
	{
		ASSERT(VALID_CONNDESC(pConnDesc));

#if DBG
		pVolDesc = pConnDesc->cds_pVolDesc;
		ASSERT(VALID_VOLDESC(pVolDesc));
#endif

		ACQUIRE_SPIN_LOCK_AT_DPC(&pConnDesc->cds_ConnLock);

		if ((pConnDesc->cds_Flags & CONN_CLOSING) == 0)
		{
			pConnDesc->cds_RefCount ++;
            pRetConnDesc = pConnDesc;
		}

		RELEASE_SPIN_LOCK_FROM_DPC(&pConnDesc->cds_ConnLock);
	}

	RELEASE_SPIN_LOCK(&AfpConnLock, OldIrql);

	return pRetConnDesc;
}


/***	AfpConnectionDereference
 *
 *	Dereference the open volume. If this is the last reference to it and the
 *	connection is marked to shut down, perform its last rites.
 *
 *	LOCKS:		vds_VolLock (SPIN), cds_ConnLock (SPIN), AfpConnLock (SPIN)
 *
 *	LOCK_ORDER:	vds_VolLock after cds_ConnLock
 *
 *	Callable from DISPATCH_LEVEL.
 */
VOID FASTCALL
AfpConnectionDereference(
	IN  PCONNDESC	pConnDesc
)
{
	PCONNDESC *		ppConnDesc;
	KIRQL			OldIrql;
	PSDA			pSda;
	PVOLDESC		pVolDesc;
	BOOLEAN			Cleanup;

	ASSERT (VALID_CONNDESC(pConnDesc) && (pConnDesc->cds_pVolDesc != NULL));

	ASSERT (pConnDesc->cds_RefCount > 0);

	ACQUIRE_SPIN_LOCK(&pConnDesc->cds_ConnLock, &OldIrql);

	Cleanup = (--(pConnDesc->cds_RefCount) == 0);

	RELEASE_SPIN_LOCK(&pConnDesc->cds_ConnLock, OldIrql);

	DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_INFO,
			("AfpConnectionDereferenence: pConnDesc %lx %s\n", pConnDesc,
											Cleanup ? "cleanup" : "normal"));

	if (!Cleanup)
	{
		return;
	}

	ASSERT(pConnDesc->cds_Flags & CONN_CLOSING);

	// Unlink this from the global list
	ACQUIRE_SPIN_LOCK(&AfpConnLock, &OldIrql);

	for (ppConnDesc = &AfpConnList;
		 *ppConnDesc != NULL;
		 ppConnDesc = &(*ppConnDesc)->cds_NextGlobal)
	{
		if (pConnDesc == *ppConnDesc)
			break;
	}
	ASSERT (*ppConnDesc != NULL);
	*ppConnDesc = pConnDesc->cds_NextGlobal;

	pVolDesc = pConnDesc->cds_pVolDesc;

	RELEASE_SPIN_LOCK(&AfpConnLock, OldIrql);

	INTERLOCKED_ADD_ULONG(&pVolDesc->vds_UseCount,
						  (DWORD)-1,
						  &pVolDesc->vds_VolLock);

	ACQUIRE_SPIN_LOCK(&pConnDesc->cds_ConnLock, &OldIrql);

	// Now unlink it from the Sda.
	pSda = pConnDesc->cds_pSda;
	for (ppConnDesc = &pSda->sda_pConnDesc;
		 *ppConnDesc != NULL;
		 ppConnDesc = &(*ppConnDesc)->cds_Next)
	{
		if (pConnDesc == *ppConnDesc)
			break;
	}

	ASSERT (*ppConnDesc != NULL);
	*ppConnDesc = pConnDesc->cds_Next;

	// Even though the connection is now history we need to release this
	// lock to get the right IRQL back.
	RELEASE_SPIN_LOCK(&pConnDesc->cds_ConnLock, OldIrql);

	INTERLOCKED_ADD_ULONG(&pSda->sda_cOpenVolumes,
						  (ULONG)-1,
						  &pSda->sda_Lock);

	// De-reference the volume descriptor and free the connection descriptor
	AfpVolumeDereference(pConnDesc->cds_pVolDesc);

	if (pConnDesc->cds_pEnumDir != NULL)
		AfpFreeMemory(pConnDesc->cds_pEnumDir);

	// Finally free the connection descriptor
	AfpFreeMemory(pConnDesc);

	DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_INFO,
			("AfpConnectionDereferenence: pConnDesc %lx is history\n", pConnDesc));
}



/***	AfpConnectionOpen
 *
 *	Open the specified volume. If the volume is already open this translates
 *	to a NOP. If the volume has a password, then it is checked.
 *
 *	The volume list lock is obtained for the duration of the processing.
 *
 *	Callable from DISPATCH_LEVEL.
 *
 *	LOCKS:	AfpVolumeListLock (SPIN), vds_VolLock (SPIN)
 *
 *	LOCK_ORDER: vds_VolLock after AfpVolumeListLock
 */
AFPSTATUS
AfpConnectionOpen(
	IN  PSDA			pSda,
	IN  PANSI_STRING	pVolName,
	IN  PANSI_STRING	pVolPass,
	IN  DWORD			Bitmap,
	OUT PBYTE			pVolParms
)
{
	PVOLDESC		pVolDesc;
	PCONNDESC		pConnDesc;
	AFPSTATUS		Status = AFP_ERR_NONE;
	KIRQL			OldIrql;
	BOOLEAN			VolFound = False;

	// First find the volume descriptor for this volume
	if (KeGetCurrentIrql() == DISPATCH_LEVEL)
	{
		ACQUIRE_SPIN_LOCK_AT_DPC(&AfpVolumeListLock);

		for (pVolDesc = AfpVolumeList;
			 pVolDesc != NULL;
			 pVolDesc = pVolDesc->vds_Next)
		{
			// Ignore volumes that are in the process of being added but
			// the operation has not completed yet.
			ACQUIRE_SPIN_LOCK_AT_DPC(&pVolDesc->vds_VolLock);

			if ((pVolDesc->vds_Flags & (VOLUME_CDFS_INVALID 	|
										VOLUME_INTRANSITION 	|
										VOLUME_INITIAL_CACHE	|
										VOLUME_DELETED			|
										VOLUME_STOPPED)) == 0)
			{
				// The compare is case sensitive here
				if (EQUAL_STRING(&pVolDesc->vds_MacName, pVolName, False))
				{
                    //
                    // if DiskQuota is enabled, we need to first find out the
                    // quota for this user which we cannot do at dpc: so come
                    // back at task time
                    //
                    if (pVolDesc->vds_Flags & VOLUME_DISKQUOTA_ENABLED)
                    {
		                DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_INFO,
		                    ("AfpConnectionOpen: %lx disk-quota on, queuing\n",pVolDesc));

			            RELEASE_SPIN_LOCK_FROM_DPC(&pVolDesc->vds_VolLock);
		                RELEASE_SPIN_LOCK_FROM_DPC(&AfpVolumeListLock);
		                return AFP_ERR_QUEUE;
                    }
                    else  // DiskQuota is not enabled: go ahead and process at DPC
                    {
					    pVolDesc->vds_RefCount ++;
					    pVolDesc->vds_UseCount ++;
					    VolFound = True;
                    }
				}
			}
#if DBG
			else if (pVolDesc->vds_Flags & VOLUME_CDFS_INVALID)
				ASSERT (!IS_VOLUME_NTFS(pVolDesc));
#endif
			RELEASE_SPIN_LOCK_FROM_DPC(&pVolDesc->vds_VolLock);

			if (VolFound)
				break;
		}

		RELEASE_SPIN_LOCK_FROM_DPC(&AfpVolumeListLock);

		if (pVolDesc == NULL)
		{
			return AFP_ERR_QUEUE;
		}

	}
	else
	{
		// We are here because we did not find the volume at DISPATCH_LEVEL and
		// possibly the volume has been specified with a different case. Catch
		// this
		WCHAR			VolNameBuf[AFP_VOLNAME_LEN + 1];
		WCHAR			UpCasedNameBuffer[AFP_VOLNAME_LEN + 1];
		UNICODE_STRING	UpCasedVolName;
		UNICODE_STRING	UVolName;

        pVolDesc = NULL;

		AfpSetEmptyUnicodeString(&UVolName, sizeof(VolNameBuf), VolNameBuf);
		AfpSetEmptyUnicodeString(&UpCasedVolName, sizeof(UpCasedNameBuffer), UpCasedNameBuffer);
		Status = AfpConvertStringToUnicode(pVolName, &UVolName);
		ASSERT (NT_SUCCESS(Status));

		Status = RtlUpcaseUnicodeString(&UpCasedVolName, &UVolName, False);

        if (!NT_SUCCESS(Status))
        {
            return(AFP_ERR_PARAM);
        }

		ACQUIRE_SPIN_LOCK(&AfpVolumeListLock, &OldIrql);

		for (pVolDesc = AfpVolumeList;
			 pVolDesc != NULL;
			 pVolDesc = pVolDesc->vds_Next)
		{
			// Ignore volumes that are in the process of being added but
			// the operation has not completed yet.
			ACQUIRE_SPIN_LOCK_AT_DPC(&pVolDesc->vds_VolLock);

			if ((pVolDesc->vds_Flags & (VOLUME_CDFS_INVALID 	|
										VOLUME_INTRANSITION 	|
										VOLUME_INITIAL_CACHE	|
										VOLUME_DELETED			|
										VOLUME_STOPPED)) == 0)
			{
				if (AfpEqualUnicodeString(&pVolDesc->vds_UpCaseName,
										  &UpCasedVolName))
				{
					pVolDesc->vds_RefCount ++;
					pVolDesc->vds_UseCount ++;
					VolFound = True;
				}
			}

			RELEASE_SPIN_LOCK_FROM_DPC(&pVolDesc->vds_VolLock);

			if (VolFound)
				break;
		}

		RELEASE_SPIN_LOCK(&AfpVolumeListLock, OldIrql);

		if (pVolDesc == NULL)
		{
			return AFP_ERR_PARAM;
		}
	}

	ASSERT (pVolDesc != NULL);

	do
	{
		ACQUIRE_SPIN_LOCK(&pVolDesc->vds_VolLock, &OldIrql);

		// Check for volume password, if one exists. Volume password is
		// case sensitive.

		if ((pVolDesc->vds_Flags & AFP_VOLUME_HASPASSWORD) &&
			((pVolPass->Buffer == NULL) ||
			 (!EQUAL_STRING(pVolPass, &pVolDesc->vds_MacPassword, False))))
		{
			Status = AFP_ERR_ACCESS_DENIED;
			break;
		}

		// Check if the volume is already open
		for (pConnDesc = pSda->sda_pConnDesc;
			 pConnDesc != NULL;
			 pConnDesc = pConnDesc->cds_Next)
		{
			if (pConnDesc->cds_pVolDesc == pVolDesc)
			{
				if (pConnDesc->cds_Flags & CONN_CLOSING)
					continue;
				// Dereference the volume since we already have it open
				pVolDesc->vds_RefCount --;
				pVolDesc->vds_UseCount --;
				break;
			}
		}

		// This volume is already open. Unlock the volume.
		if (pConnDesc != NULL)
		{
			RELEASE_SPIN_LOCK(&pVolDesc->vds_VolLock, OldIrql);
			break;
		}

		DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_INFO,
				("AfpConnectionOpen: Opening a fresh connection volid=%d\n",
					pVolDesc->vds_VolId));

		// This is a fresh open. Check if we have access to it and if we satisfy
		// the MAXUSES. If not dereference the volume before we quit
		if ((pVolDesc->vds_UseCount > pVolDesc->vds_MaxUses) ||
			(!(pVolDesc->vds_Flags & AFP_VOLUME_GUESTACCESS) &&
			 (pSda->sda_ClientType == SDA_CLIENT_GUEST)))
		{
			Status = AFP_ERR_TOO_MANY_FILES_OPEN;
			break;
		}

		// All is hunky-dory. Go ahead with the open
		pConnDesc = (PCONNDESC)AfpAllocZeroedNonPagedMemory(sizeof(CONNDESC));
		if (pConnDesc == NULL)
		{
			Status = AFP_ERR_MISC;
			break;
		}

		ASSERT ((pVolDesc->vds_Flags & (VOLUME_DELETED | VOLUME_STOPPED)) == 0);

		// Now release the vds_VolLock before we acquire the link it into
		// the global list since we acquire the AfpConnLock then.
		// Re-acquire it when we are done. We are safe since the VolDesc has
		// been referenced
		RELEASE_SPIN_LOCK(&pVolDesc->vds_VolLock, OldIrql);

		// Initialize the connection structure fields
	#if DBG
		pConnDesc->Signature = CONNDESC_SIGNATURE;
	#endif
		pConnDesc->cds_pSda = pSda;
		pConnDesc->cds_pVolDesc = pVolDesc;
		pConnDesc->cds_RefCount = 1;		// Creation reference

		AfpGetCurrentTimeInMacFormat(&pConnDesc->cds_TimeOpened);
		INITIALIZE_SPIN_LOCK(&pConnDesc->cds_ConnLock);

		// Assign a new connection id and link it in the global connection list.
		afpConnectionGetNewIdAndLinkToList(pConnDesc);

		// Link the new ConnDesc into the sda.
		pConnDesc->cds_Next = pSda->sda_pConnDesc;
		pSda->sda_pConnDesc = pConnDesc;
		pSda->sda_cOpenVolumes ++;
	} while (False);

	// We are holding the vds_VolLock if an error occured. The volume has a
	// usecount and reference count which we need to get rid of.
	if (!NT_SUCCESS(Status))
	{
		pVolDesc->vds_RefCount --;
		pVolDesc->vds_UseCount --;

		RELEASE_SPIN_LOCK(&pVolDesc->vds_VolLock, OldIrql);
	}
	else
    {
        //
        // if disk-quota is enabled on this volume, get this user's quota info
        //
        if (pVolDesc->vds_Flags & VOLUME_DISKQUOTA_ENABLED)
        {
            ASSERT(KeGetCurrentIrql() != DISPATCH_LEVEL);

            // up the refcount (this can't fail: we just created the thing!)
            AfpConnectionReferenceByPointer(pConnDesc);
            afpUpdateDiskQuotaInfo(pConnDesc);
        }
        else
        {
            // initialize these to something meaningful for now
            pConnDesc->cds_QuotaLimit = pVolDesc->vds_VolumeSize;
            pConnDesc->cds_QuotaAvl = pVolDesc->vds_FreeBytes;
        }

        AfpVolumePackParms(pSda, pVolDesc, Bitmap, pVolParms);
    }

	return Status;
}


/***	AfpConnectionClose
 *
 *	Close the connection - this represents an open volume.
 */
VOID FASTCALL
AfpConnectionClose(
	IN	PCONNDESC		pConnDesc
)
{
	KIRQL	OldIrql;

	ASSERT (VALID_CONNDESC(pConnDesc));
	ASSERT (pConnDesc->cds_RefCount > 1);
	ASSERT ((pConnDesc->cds_Flags & CONN_CLOSING) == 0);

	ACQUIRE_SPIN_LOCK(&pConnDesc->cds_ConnLock, &OldIrql);

	pConnDesc->cds_Flags |= CONN_CLOSING;

	RELEASE_SPIN_LOCK(&pConnDesc->cds_ConnLock, OldIrql);

	// Take away the creation reference.
	AfpConnectionDereference(pConnDesc);
}


/***	AfpVolumeGetParmsReplyLength
 *
 *	Compute the size of buffer required to copy the volume parameters based
 *	on the bitmap.
 */
USHORT FASTCALL
AfpVolumeGetParmsReplyLength(
	IN  DWORD		Bitmap,
	IN	USHORT		NameLen
)
{
	LONG	i;
	USHORT	Size = sizeof(USHORT);	// to accomodate a copy of the bitmap
	static	BYTE	Bitmap2Size[12] =
				{
					sizeof(USHORT),	                // Attributes
					sizeof(USHORT),	                // Signature
					sizeof(DWORD),	                // Creation date
					sizeof(DWORD),	                // Mod date
					sizeof(DWORD),	                // Backup date
					sizeof(USHORT),	                // Volume Id
					sizeof(DWORD),	                // Bytes Free
					sizeof(DWORD),	                // Bytes total
					sizeof(USHORT) + sizeof(BYTE),  // Volume name
                    sizeof(DWORD) + sizeof(DWORD),  // Extended Bytes Free
                    sizeof(DWORD) + sizeof(DWORD),  // Extended Bytes Total
                    sizeof(DWORD)                   // Allocation Block size
				};


	ASSERT ((Bitmap & ~VOL_BITMAP_MASK) == 0);

	if (Bitmap & VOL_BITMAP_VOLUMENAME)
		Size += NameLen;

	for (i = 0; Bitmap; i++)
	{
		if (Bitmap & 1)
			Size += (USHORT)Bitmap2Size[i];
		Bitmap >>= 1;
	}
	return Size;
}



/***	AfpVolumePackParms
 *
 *	Pack the volume parameters in the reply buffer. The AfpVolumeListLock is taken
 *	before the volume parameters are accessed. The parameters are copied in
 *	the on-the-wire format.
 *
 *	LOCKS:	vds_VolLock	(SPIN)
 */
VOID
AfpVolumePackParms(
	IN  PSDA		pSda,
	IN  PVOLDESC	pVolDesc,
	IN  DWORD		Bitmap,
	OUT PBYTE		pReplyBuf
)
{
	int		        Offset = sizeof(USHORT);
	KIRQL	        OldIrql;
	DWORD	        Attr;
    PCONNDESC       pConnDesc;
    PBYTE           pVolNamePtr;
    LARGE_INTEGER   QuotaAvailable={0};
    LARGE_INTEGER   QuotaLimit={0};

	// older Macs have problems with 2 or 4Gig volumes
	LARGE_INTEGER	TwoGig =  { 0x7E200000, 0 };
	LARGE_INTEGER	FourGig = { 0xFFFFFFFF, 0 };
    LARGE_INTEGER   Limit;
    BOOLEAN         fAfp21OrOlderClient=TRUE;


    //
    // get this info out before we grab the pVolDesc lock
    //
	if (Bitmap & (VOL_BITMAP_BYTESFREE | VOL_BITMAP_VOLUMESIZE |
                  VOL_BITMAP_EXTBYTESFREE | VOL_BITMAP_EXTBYTESTOTAL))
    {

        QuotaLimit = pVolDesc->vds_VolumeSize;
        QuotaAvailable = pVolDesc->vds_FreeBytes;

        if (pSda->sda_ClientVersion >= AFP_VER_22)
        {
            fAfp21OrOlderClient = FALSE;
        }

        if (pVolDesc->vds_Flags & VOLUME_DISKQUOTA_ENABLED)
        {
            pConnDesc = AfpConnectionReference(pSda, pVolDesc->vds_VolId);

            if (pConnDesc)
            {
                ACQUIRE_SPIN_LOCK(&pConnDesc->cds_ConnLock, &OldIrql);

                QuotaLimit = pConnDesc->cds_QuotaLimit;

                // if user's available quota shows 10MB, but space left on the
                // disk shows 3MB, we need to return 3MB (smaller of the two)
                //
                if (QuotaAvailable.QuadPart > pConnDesc->cds_QuotaAvl.QuadPart)
                {
                    QuotaAvailable = pConnDesc->cds_QuotaAvl;
                }

                RELEASE_SPIN_LOCK(&pConnDesc->cds_ConnLock, OldIrql);

                AfpConnectionDereference(pConnDesc);
            }
        }

        //
        // AFP2.1 and older clients can't handle more than 4GB (2GB if so configured)
        // Lie to the client so it survives
        //
        if (fAfp21OrOlderClient)
        {
    	    Limit = ((AfpServerOptions & AFP_SRVROPT_4GB_VOLUMES) ||
		    	    (pVolDesc->vds_Flags & AFP_VOLUME_4GB)) ? FourGig : TwoGig;

	        if (QuotaLimit.QuadPart > Limit.QuadPart)
            {
                QuotaLimit = Limit;
            }

            if (QuotaAvailable.QuadPart > Limit.QuadPart)
            {
                QuotaAvailable = Limit;
            }
        }
        else
        {
            Limit = FourGig;
        }
    }

	// First copy the bitmap
	PUTDWORD2SHORT(pReplyBuf, Bitmap);

	ACQUIRE_SPIN_LOCK(&pVolDesc->vds_VolLock, &OldIrql);
	if (Bitmap & VOL_BITMAP_ATTR)
	{
		Attr = pVolDesc->vds_Flags & AFP_VOLUME_MASK_AFP;
		if (pSda->sda_ClientVersion < AFP_VER_21)
			Attr &= AFP_VOLUME_READONLY;	// Do not give Afp 2.0 any more bits

		PUTDWORD2SHORT(pReplyBuf + Offset, Attr);
		Offset += sizeof(USHORT);
	}
	if (Bitmap & VOL_BITMAP_SIGNATURE)
	{
		PUTSHORT2SHORT(pReplyBuf + Offset, AFP_VOLUME_FIXED_DIR);
		Offset += sizeof(USHORT);
	}
	if (Bitmap & VOL_BITMAP_CREATETIME)
	{
		PUTDWORD2DWORD(pReplyBuf + Offset, pVolDesc->vds_CreateTime);
		Offset += sizeof(DWORD);
	}
	if (Bitmap & VOL_BITMAP_MODIFIEDTIME)
	{
		PUTDWORD2DWORD(pReplyBuf + Offset, pVolDesc->vds_ModifiedTime);
		Offset += sizeof(DWORD);
	}
	if (Bitmap & VOL_BITMAP_BACKUPTIME)
	{
		PUTDWORD2DWORD(pReplyBuf + Offset, pVolDesc->vds_BackupTime);
		Offset += sizeof(DWORD);
	}
	if (Bitmap & VOL_BITMAP_VOLUMEID)
	{
		PUTSHORT2SHORT(pReplyBuf + Offset, pVolDesc->vds_VolId);
		Offset += sizeof(USHORT);
	}
	if (Bitmap & VOL_BITMAP_BYTESFREE)
	{
        //
        // if this is a huge volume (and we are talking to an AFP2.2 or later client)
        // we need to fill 4GB in this field
        //
        if (QuotaAvailable.QuadPart > Limit.QuadPart)
        {
    	    PUTDWORD2DWORD(pReplyBuf + Offset, Limit.LowPart);
	        Offset += sizeof(DWORD);
        }
        else
        {
		    PUTDWORD2DWORD(pReplyBuf + Offset, QuotaAvailable.LowPart);
		    Offset += sizeof(DWORD);
        }
	}

	if (Bitmap & VOL_BITMAP_VOLUMESIZE)
	{
        //
        // if this is a huge volume (and we are talking to an AFP2.2 or later client)
        // we need to fill 4GB in this field
        //
        if (QuotaLimit.QuadPart > Limit.QuadPart)
        {
		    PUTDWORD2DWORD(pReplyBuf + Offset, Limit.LowPart);
		    Offset += sizeof(DWORD);
        }
        else
        {
		    PUTDWORD2DWORD(pReplyBuf + Offset, QuotaLimit.LowPart);
		    Offset += sizeof(DWORD);
        }
	}


    // save pointer to where we need to write the offset: we'll write at the
    // end after we figure out where the name goes
	if (Bitmap & VOL_BITMAP_VOLUMENAME)
	{
        pVolNamePtr = pReplyBuf + Offset;

		Offset += sizeof(USHORT);
	}

    //
    // 8-bytes to say how many free bytes there are
    //
    if (Bitmap & VOL_BITMAP_EXTBYTESFREE)
    {
	    PUTDWORD2DWORD(pReplyBuf + Offset, QuotaAvailable.HighPart);
	    Offset += sizeof(DWORD);

	    PUTDWORD2DWORD(pReplyBuf + Offset, QuotaAvailable.LowPart);
	    Offset += sizeof(DWORD);
    }

    //
    // 8-bytes to say how many bytes there are on the volume
    //
    if (Bitmap & VOL_BITMAP_EXTBYTESTOTAL)
    {
	    PUTDWORD2DWORD(pReplyBuf + Offset, QuotaLimit.HighPart);
	    Offset += sizeof(DWORD);

	    PUTDWORD2DWORD(pReplyBuf + Offset, QuotaLimit.LowPart);
	    Offset += sizeof(DWORD);
    }

    //
    // 4-bytes to say what is the block allocation size
    //
    if (Bitmap & VOL_BITMAP_ALLOCBLKSIZE)
    {
	    PUTDWORD2DWORD(pReplyBuf + Offset, pVolDesc->vds_AllocationBlockSize);
	    Offset += sizeof(DWORD);
    }

    // now, write the volume name (if asked for), after writing the offset, now
    // that we know it (subtract 2: we measure from parms, not Bitmap field)
	if (Bitmap & VOL_BITMAP_VOLUMENAME)
	{
		PUTSHORT2SHORT(pVolNamePtr, (Offset - sizeof(USHORT)));

		PUTSHORT2BYTE(pReplyBuf + Offset, pVolDesc->vds_MacName.Length);
		Offset += sizeof(BYTE);
		RtlCopyMemory(pReplyBuf + Offset,
					  pVolDesc->vds_MacName.Buffer,
					  pVolDesc->vds_MacName.Length);
	}

	RELEASE_SPIN_LOCK(&pVolDesc->vds_VolLock, OldIrql);
}


/***	AfpVolumeStopAllVolumes
 *
 *	This is called at service stop time. All configured volumes are asked to
 *	stop. Wait for the actual stop to happen before returning.
 *
 *	LOCKS:		AfpVolumeListLock (SPIN), vds_VolLock
 *	LOCK_ORDER:	vds_VolLock after AfpVolumeListLock
 */
VOID
AfpVolumeStopAllVolumes(
	VOID
)
{
	KIRQL		OldIrql;
	PVOLDESC	pVolDesc, pVolDescx = NULL;
	BOOLEAN		Wait, CancelNotify = False;
	NTSTATUS	Status;


	pVolDesc = AfpVolumeList;

	ACQUIRE_SPIN_LOCK(&AfpVolumeListLock, &OldIrql);

	if (Wait = (AfpVolCount > 0))
	{
		KeClearEvent(&AfpStopConfirmEvent);

		for (NOTHING; pVolDesc != NULL; pVolDesc = pVolDesc->vds_Next)
		{
			if ((pVolDesc == pVolDescx) ||
				(pVolDesc->vds_Flags & (VOLUME_STOPPED | VOLUME_DELETED)))
				continue;

			pVolDescx = pVolDesc;

			ACQUIRE_SPIN_LOCK_AT_DPC(&pVolDesc->vds_VolLock);

			// Cancel posted change notify
			pVolDesc->vds_Flags |= VOLUME_STOPPED;

			if (pVolDesc->vds_Flags & VOLUME_NOTIFY_POSTED)
			{
				DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_INFO,
						("AfpStopAllVolumes: Cancel notify on volume %ld\n",
						pVolDesc->vds_VolId));
				// ASSERT (IS_VOLUME_NTFS(pVolDesc));
				ASSERT (pVolDesc->vds_pIrp != NULL);

				CancelNotify = True;

				// Cancel after releasing the volume lock since the completion
				// routine acquires it and it could be called in the context
				// of IoCancelIrp(). Also Cancel uses paged resource and so
				// must be called w/o holding any spin locks.
				RELEASE_SPIN_LOCK_FROM_DPC(&pVolDesc->vds_VolLock);
				RELEASE_SPIN_LOCK(&AfpVolumeListLock, OldIrql);

				IoCancelIrp(pVolDesc->vds_pIrp);

				ACQUIRE_SPIN_LOCK(&AfpVolumeListLock, &OldIrql);
			}
			else RELEASE_SPIN_LOCK_FROM_DPC(&pVolDesc->vds_VolLock);

			// Remove the creation reference
			AfpVolumeDereference(pVolDesc);
		}
	}

	RELEASE_SPIN_LOCK(&AfpVolumeListLock, OldIrql);

	if (CancelNotify)
	{
		DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_INFO,
				("AfpStopAllVolumes: Waiting on all notify to complete\n"));
		do
		{
			Status = AfpIoWait(&AfpStopConfirmEvent, &FiveSecTimeOut);
			if (Status == STATUS_TIMEOUT)
			{
				DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_ERR,
						("AfpVolumeStopAllVolumes: Timeout Waiting for cancel notify, re-waiting\n"));
			}
		} while (Status == STATUS_TIMEOUT);
	}

	if (Wait)
	{
		KeClearEvent(&AfpStopConfirmEvent);

		AfpScavengerFlushAndStop();

		if (AfpVolCount > 0)
			AfpIoWait(&AfpStopConfirmEvent, NULL);
	}
	else
	{
		AfpScavengerFlushAndStop();
	}
}


/***	afpConnectionGetNewIdAndLinkToList
 *
 *	Get a new connection id for a volume that is being opened. A connection
 *	id ranges from 1 to MAXULONG. If it wraps, then the entire connection
 *	list is scanned to get a free one.
 *
 *	LOCKS:	AfpConnectionLock (SPIN)
 */
LOCAL VOID FASTCALL
afpConnectionGetNewIdAndLinkToList(
	IN	PCONNDESC	pConnDesc
)
{
	KIRQL		OldIrql;
	PCONNDESC *	ppConnDesc;

	ACQUIRE_SPIN_LOCK(&AfpConnLock, &OldIrql);

	pConnDesc->cds_ConnId = afpNextConnId++;

	for (ppConnDesc = &AfpConnList;
		 *ppConnDesc != NULL;
		 ppConnDesc = &(*ppConnDesc)->cds_NextGlobal)
	{
		if ((*ppConnDesc)->cds_ConnId < pConnDesc->cds_ConnId)
			break;
	}
	pConnDesc->cds_NextGlobal = *ppConnDesc;
	*ppConnDesc = pConnDesc;
	RELEASE_SPIN_LOCK(&AfpConnLock, OldIrql);
}


/***	AfpVolumeUpdateIdDbAndDesktop
 *
 *	Called by the volume scavenger to write either the IdDb header and/or the
 *	dektop to disk.
 */
VOID
AfpVolumeUpdateIdDbAndDesktop(
	IN	PVOLDESC			pVolDesc,
	IN	BOOLEAN				WriteDt,
	IN	BOOLEAN				WriteIdDb,
	IN	PIDDBHDR			pIdDbHdr	OPTIONAL
)
{
	FILESYSHANDLE	fshIdDb;
	NTSTATUS		Status;
	BOOLEAN			WriteBackROAttr = False;
    TIME            ModTime;
    NTSTATUS        ModStatus=AFP_ERR_MISC;

	PAGED_CODE();

	DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_ERR,
			("AfpVolumeUpdateIdDbAndDesktop: Called by volume scavenger\n") );

    ModStatus = AfpIoRestoreTimeStamp(&pVolDesc->vds_hRootDir,
                                      &ModTime,
                                      AFP_RETRIEVE_MODTIME);

	// If we need to update the IdIndex or Desktop streams, make sure
	// the ReadOnly bit is not set on the volume root directory
	AfpExamineAndClearROAttr(&pVolDesc->vds_hRootDir, &WriteBackROAttr, NULL, NULL);

	// Update the disk image of the IdDb header and/or the whole database if it is dirty
	if (WriteIdDb || ARGUMENT_PRESENT(pIdDbHdr))
	{
		if (NT_SUCCESS(Status = AfpIoOpen(&pVolDesc->vds_hRootDir,
										  AFP_STREAM_IDDB,
										  WriteIdDb ?
											FILEIO_OPEN_FILE_SEQ : FILEIO_OPEN_FILE,
										  &UNullString,
										  FILEIO_ACCESS_WRITE,
										  FILEIO_DENY_WRITE,
										  False,
										  &fshIdDb)))
		{

			if (ARGUMENT_PRESENT(pIdDbHdr))
			{
				DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_ERR,
						("AfpVolumeUpdateIdDbAndDesktop: Writing IdDb Header...\n") );
	
                if (!fAfpServerShutdownEvent)
                {
                    DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_ERR,
                            ("AfpVolumeUpdateIdDbAndDesktop: Corrupting IDDB header\n"));
                    pIdDbHdr->idh_Signature = AFP_SERVER_SIGNATURE_INITIDDB;
                }

				if (!NT_SUCCESS(Status = AfpIoWrite(&fshIdDb,
													&LIZero,
													sizeof(IDDBHDR),
													(PBYTE)pIdDbHdr)))
				{
					// Write failed, put back the dirty bit.
					AfpInterlockedSetDword(&pVolDesc->vds_Flags,
											VOLUME_IDDBHDR_DIRTY,
											&pVolDesc->vds_VolLock);
	
					AFPLOG_ERROR(AFPSRVMSG_WRITE_IDDB,
								 Status,
								 NULL,
								 0,
								 &pVolDesc->vds_Name);
					DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_ERR,
							("AfpVolumeUpdateIdDbAndDesktop: Error writing IdDb Header %lx\n",
							Status));
				}
			}
			if (WriteIdDb)
			{
				AfpFlushIdDb(pVolDesc, &fshIdDb);
			}

            AfpIoClose(&fshIdDb);

		}
		else
		{
			// Open failed, put back the dirty bit
			AfpInterlockedSetDword(&pVolDesc->vds_Flags,
									VOLUME_IDDBHDR_DIRTY,
									&pVolDesc->vds_VolLock);

			AFPLOG_ERROR(AFPSRVMSG_WRITE_IDDB,
						 Status,
						 NULL,
						 0,
						 &pVolDesc->vds_Name);
			DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_ERR,
					("AfpVolumeUpdateIdDbAndDesktop: Error opening IdDb Header %lx\n",
					Status));
		}
	}

	if (WriteDt)
	{
		AfpUpdateDesktop(pVolDesc);
	}

	AfpPutBackROAttr(&pVolDesc->vds_hRootDir, WriteBackROAttr);

    if (ModStatus == AFP_ERR_NONE)
    {

        ModStatus = AfpIoRestoreTimeStamp(&pVolDesc->vds_hRootDir,
                                          &ModTime,
                                          AFP_RESTORE_MODTIME);
    }


}

 /***	afpNudgeCdfsVolume
 *
 *	Called from within the volume scavenger to verify if either a CD which we
 *	believe to be valid is still so or one we believe to be invalid has become
 *	valid again.
 */
LOCAL VOID FASTCALL
afpNudgeCdfsVolume(
	IN	PVOLDESC	pVolDesc
)
{
	PFILE_FS_VOLUME_INFORMATION	pVolumeInfo;
	LONGLONG			VolumeBuf[(sizeof(FILE_FS_VOLUME_INFORMATION) + 128)/sizeof(LONGLONG) + 1];
	IO_STATUS_BLOCK				IoStsBlk;
	NTSTATUS					Status;

	PAGED_CODE();

	// Just nudge the CD volume handle to see if this is valid, if
	// not mark the volume as invalid.
	pVolumeInfo = (PFILE_FS_VOLUME_INFORMATION)VolumeBuf;
	Status = NtQueryVolumeInformationFile(pVolDesc->vds_hRootDir.fsh_FileHandle,
										  &IoStsBlk,
										  (PVOID)pVolumeInfo,
										  sizeof(VolumeBuf),
										  FileFsVolumeInformation);
	if (NT_SUCCESS(Status))
	{
		if (pVolDesc->vds_Flags & VOLUME_CDFS_INVALID)
		{
			DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_ERR,
					("afpNudgeCdfsVolume: Volume %d online again !!!\n",
					pVolDesc->vds_VolId));
			AfpInterlockedClearDword(&pVolDesc->vds_Flags,
								   VOLUME_CDFS_INVALID,
								   &pVolDesc->vds_VolLock);
			AfpVolumeSetModifiedTime(pVolDesc);
		}
	}
	else if ((Status == STATUS_WRONG_VOLUME)		||
			 (Status == STATUS_INVALID_VOLUME_LABEL)||
			 (Status == STATUS_NO_MEDIA_IN_DEVICE)	||
			 (Status == STATUS_UNRECOGNIZED_VOLUME))
	{
		DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_ERR,
				("afpNudgeCdfsVolume: Volume %d error %lx, marking volume invalid\n",
				pVolDesc->vds_VolId, Status));
		if (!(pVolDesc->vds_Flags & VOLUME_CDFS_INVALID))
		{
			// AFP_LOGERR();
		}
		AfpInterlockedSetDword(&pVolDesc->vds_Flags,
							   VOLUME_CDFS_INVALID,
							   &pVolDesc->vds_VolLock);
		AfpVolumeSetModifiedTime(pVolDesc);
	}
}


/***	AfpUpdateVolFreeSpaceAndModTime
 *
 *	Update free space on a volume and other volumes on the same physical drive. Update
 *	volume modified time on the volume as well.
 *
 *	LOCKS:	AfpVolumeListLock (SPIN)
 */
VOID FASTCALL
AfpUpdateVolFreeSpaceAndModTime(
	IN	PVOLDESC	pVolDesc,
    IN  BOOLEAN     fUpdateModTime
)
{
	PVOLDESC	    pVds;
	KIRQL		    OldIrql, OldIrql1;
	NTSTATUS	    Status;
	WCHAR		    DriveLetter;
	LARGE_INTEGER   FreeSpace;
	AFPTIME		    ModifiedTime;


	ASSERT (VALID_VOLDESC(pVolDesc));

	// Get new values for Free space on disk
	Status = AfpIoQueryVolumeSize(pVolDesc, &FreeSpace, NULL);

	if (!NT_SUCCESS(Status))
	{
		return;
	}

	// Update the free space on all volumes on the same physical ntfs partition
	ACQUIRE_SPIN_LOCK(&AfpVolumeListLock, &OldIrql);

	DriveLetter = pVolDesc->vds_Path.Buffer[0];
	AfpGetCurrentTimeInMacFormat(&ModifiedTime);

	for (pVds = AfpVolumeList; pVds != NULL; pVds = pVds->vds_Next)
	{
		if (pVds->vds_Path.Buffer[0] == DriveLetter)
		{
			DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_INFO,
					("AfpUpdateVolFreeSpace: Updating free space for volume %Z\n",
					&pVds->vds_Path));

			ACQUIRE_SPIN_LOCK_AT_DPC(&pVolDesc->vds_VolLock);
			pVds->vds_FreeBytes = FreeSpace;

            // have we been asked to update volume mod time?
            if (fUpdateModTime)
            {
			    pVolDesc->vds_ModifiedTime = ModifiedTime;
			    pVolDesc->vds_Flags |= VOLUME_IDDBHDR_DIRTY;
            }
			RELEASE_SPIN_LOCK_FROM_DPC(&pVolDesc->vds_VolLock);
		}
	}

	RELEASE_SPIN_LOCK(&AfpVolumeListLock, OldIrql);

}


/***	AfpVolumeScavenger
 *
 *	This is invoked by the scavenger periodically. It initiates the updates to
 *	the id index stream and the desktop stream. If the volume is marked for
 *	shutdown (STOPPED), then do one final flush to disk if needed.  This will
 *	guarantee that any remaining changes get flushed before stopping.
 *	If the volume is marked to either shutdown or delete, then it dereferences
 *	the volume and does not	reschedule itself.
 *
 *	For CD volumes, we want to try to check if the CD is still valid, if not we
 *	want to mark the volume appropritely - basically update the modified date
 *	on the volume - this will cause the clients to come in to refresh and we'll
 *	take care of it then.
 *
 *	LOCKS: vds_VolLock(SPIN),vds_idDbAccessLock(SWMR, Shared),vds_DtAccessLock(SWMR, Shared)
 */
AFPSTATUS FASTCALL
AfpVolumeScavenger(
	IN	PVOLDESC	pVolDesc
)
{
	KIRQL			OldIrql;
	IDDBHDR			IdDbHdr;
	BOOLEAN			WriteHdr = False, WriteIdDb = False, DerefVol = False;
	BOOLEAN			WriteDt = False, AgeDfes = False;
    BOOLEAN         MacLimitExceeded = False;
	AFPSTATUS		RequeueStatus = AFP_ERR_REQUEUE;

	ASSERT(VALID_VOLDESC(pVolDesc) && (pVolDesc->vds_RefCount > 0));

	// Determine if any updates needs to happen. Lock down the volume first
	ACQUIRE_SPIN_LOCK(&pVolDesc->vds_VolLock, &OldIrql);

	DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_INFO,
			("AfpVolumeScavenger: Volume %ld Scavenger entered @ %s_LEVEL\n",
		pVolDesc->vds_VolId,
		(OldIrql == DISPATCH_LEVEL) ? "DISPATCH" : "LOW"));

	if (pVolDesc->vds_Flags & (VOLUME_DELETED | VOLUME_STOPPED))
	{
		if (IS_VOLUME_NTFS(pVolDesc))
		{
			pVolDesc->vds_cScvgrIdDb = 1;
			pVolDesc->vds_cScvgrDt = 1;
		}
		DerefVol = True;
	}

	if (IS_VOLUME_NTFS(pVolDesc))
	{
		AFPTIME	CurTime;

#ifdef	AGE_DFES
		if (OldIrql == DISPATCH_LEVEL)
		{
			pVolDesc->vds_ScavengerInvocationCnt ++;
		}
#endif

		if (DerefVol && pVolDesc->vds_Flags & VOLUME_IDDBHDR_DIRTY)
		{
		    WriteHdr = True;
		}

		if (pVolDesc->vds_cScvgrIdDb > 0)
		{
		    WriteIdDb = True;
		    WriteHdr = False;	// We will always write the header with the iddb
		}

		if (pVolDesc->vds_cScvgrDt > 0)
		{
		    WriteDt = True;
		}
	}
#ifdef	AGE_DFES
	else	// Not NTFS
	{
		pVolDesc->vds_ScavengerInvocationCnt ++;
	}

	if (IS_VOLUME_AGING_DFES(pVolDesc) &&
		((pVolDesc->vds_ScavengerInvocationCnt % VOLUME_IDDB_AGE_GRANULARITY) == 0))
	{
		AgeDfes = True;
	}
#endif

    // if we are at DPC, return (we will come back at non-dpc)
	if (OldIrql == DISPATCH_LEVEL)
	{
	    RELEASE_SPIN_LOCK(&pVolDesc->vds_VolLock, OldIrql);
		return AFP_ERR_QUEUE;
	}


    // check to see if we have exceeded Mac limits (4GB vol size, 65535 file/folders)
    // if we know we have exceeded the limit, we have already logged an event.  Don't even
    // bother checking in that case.

    if (!pVolDesc->MacLimitExceeded)
    {
        DWORD   dwNumDirs = pVolDesc->vds_NumDirDfEntries;
        DWORD   dwNumFiles = pVolDesc->vds_NumFileDfEntries;

        if ( (dwNumDirs  > APLIMIT_MAX_FOLDERS) ||
             (dwNumFiles > APLIMIT_MAX_FOLDERS) ||
            (dwNumDirs+dwNumFiles > APLIMIT_MAX_FOLDERS) )
        {
            MacLimitExceeded = True;
            pVolDesc->MacLimitExceeded = TRUE;
        }
    }

	RELEASE_SPIN_LOCK(&pVolDesc->vds_VolLock, OldIrql);

    // update the disk space, but don't update timestamp

    AfpUpdateVolFreeSpaceAndModTime(pVolDesc, FALSE);

    if (MacLimitExceeded)
    {
        AFPLOG_INFO( AFPSRVMSG_TOO_MANY_FOLDERS,
	     		     0,
				     NULL,
					 0,
					 &pVolDesc->vds_Name);

	    DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_ERR,
				("AfpVolumeScavenger: more than 65535 files+folders on volume %lx\n", pVolDesc) );

    }

	// The following is intentionally bit-wise or instead of logical or
	// The result is same except that this is more efficient
	if (WriteHdr | WriteIdDb | WriteDt)
	{
		ASSERT (IS_VOLUME_NTFS(pVolDesc));

		// Snapshot the IdDbHdr for updating to the disk if it is dirty
		if (WriteHdr)
		{
			ACQUIRE_SPIN_LOCK(&pVolDesc->vds_VolLock, &OldIrql);

			AfpVolDescToIdDbHdr(pVolDesc, &IdDbHdr);

			// Clear the dirty bit
			pVolDesc->vds_Flags &= ~VOLUME_IDDBHDR_DIRTY;

			RELEASE_SPIN_LOCK(&pVolDesc->vds_VolLock, OldIrql);
		}

		AfpVolumeUpdateIdDbAndDesktop(pVolDesc,
									  WriteDt,
									  WriteIdDb,
									  WriteHdr ? &IdDbHdr : NULL);
	}

	if (!DerefVol)
	{
		if (!IS_VOLUME_NTFS(pVolDesc))
		{
			afpNudgeCdfsVolume(pVolDesc);
		}
#ifdef	AGE_DFES
		if (AgeDfes)
		{
			AfpAgeDfEntries(pVolDesc);
		}
#endif
	}
	else
	{
		AfpInterlockedClearDword(&pVolDesc->vds_Flags,
								 VOLUME_SCAVENGER_RUNNING,
								 &pVolDesc->vds_VolLock);
		AfpVolumeDereference(pVolDesc);
		RequeueStatus = AFP_ERR_NONE;
	}

	return RequeueStatus;
}


/***	afpVolumeAdd
 *
 *	Add a newly created volume to the server volume list.  At this point,
 *	at least the volume names, volume path and volume spinlock fields must be
 *	initialized in the volume descriptor.
 *
 *	LOCKS: AfpVolumeListLock (SPIN)
 */
LOCAL AFPSTATUS FASTCALL
afpVolumeAdd(
	IN  PVOLDESC pVolDesc
)
{
	KIRQL		OldIrql;
	AFPSTATUS	rc;

	DBGPRINT(DBG_COMP_ADMINAPI_VOL, DBG_LEVEL_INFO,
			("afpVolumeAdd entered\n"));

	// acquire the lock for server global volume list
	ACQUIRE_SPIN_LOCK(&AfpVolumeListLock, &OldIrql);

	// make sure a volume by that name does not already exist, and
	// make sure a volume doesn't already point to the same volume root dir
	// or to an ancestor or descendent directory of the root dir
	rc = afpVolumeCheckForDuplicate(pVolDesc);
	if (!NT_SUCCESS(rc))
	{
		RELEASE_SPIN_LOCK(&AfpVolumeListLock, OldIrql);
		return rc;
	}

	// Assign a new volume id and link in the new volume
	afpVolumeGetNewIdAndLinkToList(pVolDesc);

	// release the server global volume list lock
	RELEASE_SPIN_LOCK(&AfpVolumeListLock, OldIrql);

	return STATUS_SUCCESS;
}


/***	afpCheckForDuplicateVolume
 *
 *	Check for new volume that a volume by the same name does not
 *	already exist, and that the volume root does not point to an ancestor,
 *	descendent or same directory of an existing volume.  Note that each volume
 *	in the volume list is checked *regardless* of whether or not it is marked
 *	IN_TRANSITION or DELETED.
 *
 *	LOCKS_ASSUMED: AfpVolumeListLock (SPIN)
 */
LOCAL AFPSTATUS FASTCALL
afpVolumeCheckForDuplicate(
	IN PVOLDESC Newvol
)
{
	PVOLDESC	pVolDesc;
	AFPSTATUS	Status = AFP_ERR_NONE;

	DBGPRINT(DBG_COMP_ADMINAPI_VOL, DBG_LEVEL_INFO,
			("afpCheckForDuplicateVolume entered\n"));

	do
	{
		for (pVolDesc = AfpVolumeList;
			 pVolDesc != NULL;
			 pVolDesc = pVolDesc->vds_Next)
		{
			// We do not take vds_VolLock for each volume since even if a
			// volume is in transition, its names and path are at least
			// initialized, and cannot change.  We do not reference each
			// volume since in order for to delete or stop a volume, the
			// AfpVolListLock must be taken to unlink it from the list,
			// and whoever called us owns that lock.  These are special
			// exceptions ONLY allowed for the volume add code. Also ignore
			// the volumes that are on their way out. We do not want to punt
			// cases where somebody does a delete followed by an add.

			if (pVolDesc->vds_Flags & (VOLUME_DELETED | VOLUME_STOPPED))
				continue;

			if (AfpEqualUnicodeString(&pVolDesc->vds_UpCaseName,
									  &Newvol->vds_UpCaseName))
			{
				Status = AFPERR_DuplicateVolume;
				break;
			}
			// volume paths are stored as uppercase since we cannot do a case
			// insensitive compare while holding a spinlock (DPC level)
			if (AfpPrefixUnicodeString(&pVolDesc->vds_Path, &Newvol->vds_Path) ||
				AfpPrefixUnicodeString(&Newvol->vds_Path, &pVolDesc->vds_Path))
			{
				Status = AFPERR_NestedVolume;
				break;
			}
		}
	} while (False);

	return Status;
}


/***	afpVolumeGetNewIdAndLinkToList
 *
 *	Assign a new volume id to a volume that is being added. The volume is also
 *	inserted into the list but marked as "in transition". This should be cleared
 *	when the volume is 'ready to be mounted'.
 *	The volume ids are recycled. A volume id also cannot be 0 and cannot
 *	exceed MAXSHORT.
 *
 *	We always assign the lowest free id that is not in use. For example if
 *	there are currently N volumes with ids 1, 2, 4, 5 ... N then the newly
 *	created volume will be id 3.
 *
 *	LOCKS_ASSUMED:	AfpVolumeListLock (SPIN)
 */
LOCAL VOID FASTCALL
afpVolumeGetNewIdAndLinkToList(
	IN	PVOLDESC	pVolDesc
)
{
	PVOLDESC	*ppVolDesc;

	DBGPRINT(DBG_COMP_ADMINAPI_VOL, DBG_LEVEL_INFO,
			("afpGetNewVolIdAndLinkToList entered\n"));

	pVolDesc->vds_Flags |= (VOLUME_INTRANSITION | VOLUME_INITIAL_CACHE);
	AfpVolCount ++;						// Up the count of volumes.
	pVolDesc->vds_VolId = afpSmallestFreeVolId++;
										// This will always be valid
	DBGPRINT(DBG_COMP_ADMINAPI_VOL, DBG_LEVEL_INFO,
			("afpGetNewVolIdAndLinkToList: using volID %d\n",
			pVolDesc->vds_VolId));

	// See if we need to do anything to make the above True next time around
	if (afpSmallestFreeVolId <= AfpVolCount)
	{
		// What this means is that we have some holes. Figure out the first
		// free id that can be used.
		for (ppVolDesc = &AfpVolumeList;
			 *ppVolDesc != NULL;
			 ppVolDesc = &((*ppVolDesc)->vds_Next))
		{
			if ((*ppVolDesc)->vds_VolId < afpSmallestFreeVolId)
				continue;
			else if ((*ppVolDesc)->vds_VolId == afpSmallestFreeVolId)
				afpSmallestFreeVolId++;
			else
				break;
		}
	}
	DBGPRINT(DBG_COMP_ADMINAPI_VOL, DBG_LEVEL_INFO,
			("afpGetNewVolIdAndLinkToList: next free volID is %d\n",
			afpSmallestFreeVolId));

        // make sure our LargestVolIdInUse value is accurate
        //
        if (afpLargestVolIdInUse < pVolDesc->vds_VolId )
            afpLargestVolIdInUse = pVolDesc->vds_VolId;

	// Now link the descriptor in the list.
	for (ppVolDesc = &AfpVolumeList;
		 *ppVolDesc != NULL;
		 ppVolDesc = &((*ppVolDesc)->vds_Next))
	{
		ASSERT (pVolDesc->vds_VolId != (*ppVolDesc)->vds_VolId);
		if (pVolDesc->vds_VolId < (*ppVolDesc)->vds_VolId)
			break;
	}
	pVolDesc->vds_Next = *ppVolDesc;
	*ppVolDesc = pVolDesc;
}


/***	AfpAdmWVolumeAdd
 *
 *	This routine adds a volume to the server global list of volumes headed by
 *	AfpVolumeList.  The volume descriptor is created and initialized.  The ID
 *	index is read in (or created).  The same is true with the desktop.
 *
 *	This routine will be queued to the worker thread.
 *
 */
AFPSTATUS
AfpAdmWVolumeAdd(
	IN	OUT	PVOID	Inbuf		OPTIONAL,
	IN	LONG		OutBufLen	OPTIONAL,
	OUT	PVOID		Outbuf		OPTIONAL
)
{
	PVOLDESC		pVolDesc = NULL;
	UNICODE_STRING	RootName;
	FILESYSHANDLE	hVolRoot;
	DWORD			tempflags;
	DWORD			memsize;
	USHORT			ansivolnamelen, devpathlen;
	PBYTE			tempptr;
	UNICODE_STRING	uname, upwd, upath, udevpath;
	AFPSTATUS		status = STATUS_SUCCESS;
	PAFP_VOLUME_INFO pVolInfo = (PAFP_VOLUME_INFO)Inbuf;
	BOOLEAN			WriteBackROAttr = False, RefForNotify = False;
	BOOLEAN			VolLinked = False;
    BOOLEAN         fNewVolume;
    BOOLEAN         fVerifyIndex = FALSE;
    DWORD           dwDirHashSz;
    DWORD           dwFileHashSz;
	int				i;

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_ADMINAPI_VOL, DBG_LEVEL_INFO,
			("AfpAdmWVolumeAdd entered\n"));

	do
	{
		if (pVolInfo->afpvol_props_mask & AFP_VOLUME_DISALLOW_CATSRCH)
        {
		    pVolInfo->afpvol_props_mask &= ~AFP_VOLUME_DISALLOW_CATSRCH;
	        tempflags = AFP_VOLUME_SUPPORTS_FILEID;
        }
        else
        {
	        tempflags = AFP_VOLUME_SUPPORTS_FILEID | AFP_VOLUME_SUPPORTS_CATSRCH;
        }

		RtlInitUnicodeString(&uname,pVolInfo->afpvol_name);
		RtlInitUnicodeString(&upwd,pVolInfo->afpvol_password);
		RtlInitUnicodeString(&upath,pVolInfo->afpvol_path);
        hVolRoot.fsh_FileHandle = NULL;

		// need to prepend "\DOSDEVICES\" to the path of volume root
		devpathlen = upath.MaximumLength + DosDevices.MaximumLength;
		if ((udevpath.Buffer = (PWSTR)AfpAllocNonPagedMemory(devpathlen)) == NULL)
		{
			status = STATUS_INSUFFICIENT_RESOURCES;
			break;
		}
		udevpath.Length = 0;
		udevpath.MaximumLength = devpathlen;
		AfpCopyUnicodeString(&udevpath,&DosDevices);
		RtlAppendUnicodeStringToString(&udevpath,&upath);


		// open a handle to the volume root
		status = AfpIoOpen(NULL,
						   AFP_STREAM_DATA,
						   FILEIO_OPEN_DIR,
						   &udevpath,
						   FILEIO_ACCESS_NONE,
						   FILEIO_DENY_NONE,
						   False,
						   &hVolRoot);

		AfpFreeMemory(udevpath.Buffer);

		if (!NT_SUCCESS(status))
		{
		  break;
		}

		if (!AfpIoIsSupportedDevice(&hVolRoot, &tempflags))
		{
			status = AFPERR_UnsupportedFS;
            DBGPRINT(DBG_COMP_ADMINAPI_VOL, DBG_LEVEL_ERR,
                            ("AfpAdmWVolumeAdd: AFPERR_UnsupportedFS\n"));
			break;
		}

		// allocate a new volume descriptor -- allocate ALL required memory in
		// one fell swoop.  That is, we will just tack all the required string
		// pointers onto the end of the memory chunk that we allocate for the
		// volume descriptor.  In this way, we don't have to deal with checking
		// error codes in a million different places for memory routines and
		// have to clean up a million different pointers if one allocation should
		// fail.
		// NOTE: when deleting a volume, don't free all the individual strings
		//	   withing the voldesc, just free the one chunk of memory

		memsize = sizeof(VOLDESC) +			// volume descriptor
											// mac ansi volume name
				 (ansivolnamelen = (USHORT)RtlUnicodeStringToAnsiSize(&uname)) +
				  uname.MaximumLength * 2 + // unicode volume names (orginial
											//  and uppercase version)
				 AFP_VOLPASS_LEN+1  +		// mac ansi password
				 upath.MaximumLength +		// unicode root path
				 sizeof(WCHAR);				// need to append '\' to root path

		if ((pVolDesc = (PVOLDESC)AfpAllocZeroedNonPagedMemory(memsize)) == NULL)
		{
		  status = STATUS_INSUFFICIENT_RESOURCES;
		  break;
		}

	#if DBG
		pVolDesc->Signature = VOLDESC_SIGNATURE;
	#endif

		// the volume lock MUST be initialized prior to linking into global
		// volume list
		INITIALIZE_SPIN_LOCK(&pVolDesc->vds_VolLock);

		AfpSwmrInitSwmr(&pVolDesc->vds_IdDbAccessLock);
		AfpSwmrInitSwmr(&pVolDesc->vds_ExchangeFilesLock);

		for (i = 0; i < NUM_AFP_CHANGE_ACTION_LISTS; i++)
		{
			InitializeListHead(&pVolDesc->vds_OurChangeList[i]);
		}

		InitializeListHead(&pVolDesc->vds_ChangeNotifyLookAhead);

		InitializeListHead(&pVolDesc->vds_DelayedNotifyList);

		// calculate pointer for the unicode path string
		tempptr = (PBYTE)pVolDesc + sizeof(VOLDESC);

		// initialize unicode path string
		AfpSetEmptyUnicodeString(&(pVolDesc->vds_Path),
								 upath.MaximumLength + sizeof(WCHAR),tempptr);
		// This must be stored as uppercase since we cannot do case insensitive
		// string compares at DPC level (holding the volume spinlock) to
		// detect nested volumes
		RtlUpcaseUnicodeString(&(pVolDesc->vds_Path), &upath, False);

		// Does the path already contain a trailing backslash?
		if (pVolDesc->vds_Path.Buffer[(pVolDesc->vds_Path.Length/sizeof(WCHAR))-1] != L'\\')
		{
			// append a backslash to simplify search for nested volumes
			RtlCopyMemory(tempptr + upath.Length, L"\\", sizeof(WCHAR));
			pVolDesc->vds_Path.Length += sizeof(WCHAR);
			RtlCopyMemory(tempptr + upath.Length + sizeof(WCHAR), L"",
													sizeof(UNICODE_NULL));
		}

		// calculate pointer for the unicode volume name
		tempptr += upath.MaximumLength + sizeof(WCHAR);

		// initialize the unicode volume name
		AfpSetEmptyUnicodeString(&(pVolDesc->vds_Name),uname.MaximumLength,tempptr);
		AfpCopyUnicodeString(&(pVolDesc->vds_Name),&uname);
		RtlCopyMemory(tempptr + uname.Length,L"",sizeof(UNICODE_NULL));

		// calculate pointer for the UPPER CASE unicode volume name
		tempptr += uname.MaximumLength;

		// initialize the UPPER CASE unicode volume name
		AfpSetEmptyUnicodeString(&(pVolDesc->vds_UpCaseName),uname.MaximumLength,tempptr);
		RtlUpcaseUnicodeString(&(pVolDesc->vds_UpCaseName), &uname, False);
		RtlCopyMemory(tempptr + uname.Length,L"",sizeof(UNICODE_NULL));

		// calculate pointer for the mac ansi volume name
		tempptr += uname.MaximumLength;

		// initialize the mac ansi volume name
		AfpSetEmptyAnsiString(&(pVolDesc->vds_MacName),ansivolnamelen,tempptr);
		status = AfpConvertStringToAnsi(&uname, &(pVolDesc->vds_MacName));
		if (!NT_SUCCESS(status))
		{
			status = AFPERR_InvalidVolumeName;
			break;
		}

		// calculate pointer for the mac ansi password
		tempptr += ansivolnamelen;

		// initialize the mac ansi password
		AfpSetEmptyAnsiString(&pVolDesc->vds_MacPassword, AFP_VOLPASS_LEN+1, tempptr);
		if (pVolInfo->afpvol_props_mask & AFP_VOLUME_HASPASSWORD)
		{
			status = AfpConvertStringToAnsi(&upwd, &pVolDesc->vds_MacPassword);
			if (!NT_SUCCESS(status))
			{
				status = AFPERR_InvalidPassword;
				break;
			}
			pVolDesc->vds_MacPassword.Length = AFP_VOLPASS_LEN;
		}

		pVolDesc->vds_Flags = 0;

		// Add a creation reference and one for this routine itself.
		pVolDesc->vds_RefCount = 2;

		// add the volume to the global volume list - but mark it as 'add pending'
		status = afpVolumeAdd(pVolDesc);
		if (!NT_SUCCESS(status))
		{
			break;
		}
		VolLinked = True;

		// set miscellaneous fields in volume descriptor
		pVolDesc->vds_hRootDir = hVolRoot;


		pVolDesc->vds_hNWT.fsh_FileHandle = NULL;
		pVolDesc->vds_MaxUses = pVolInfo->afpvol_max_uses;

		pVolDesc->vds_Flags |= (pVolInfo->afpvol_props_mask | tempflags);
		pVolDesc->vds_UseCount = 0;
		pVolDesc->vds_pOpenForkDesc = NULL;

#ifdef	BLOCK_MACS_DURING_NOTIFYPROC
		pVolDesc->vds_QueuedNotifyCount = 0;
#endif
        if (pVolDesc->vds_Flags & VOLUME_DISKQUOTA_ENABLED)
        {
		    DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_ERR,
		        ("AfpAdmWVolumeAdd: DiskQuota is enabled on volume %Z\n",&pVolDesc->vds_Name));
        }

        AfpGetDirFileHashSizes(pVolDesc, &dwDirHashSz, &dwFileHashSz);

		DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_ERR,
    	    ("AfpAdmWVolumeAdd: DirHash = %d, FileHash = %d, VolSize = %d for vol %Z\n",
            dwDirHashSz,dwFileHashSz,
            (memsize + (sizeof(struct _DirFileEntry *) * (dwDirHashSz+dwFileHashSz))),
            &pVolDesc->vds_Name));

        pVolDesc->vds_DirHashTableSize = dwDirHashSz;
        pVolDesc->vds_FileHashTableSize = dwFileHashSz;

        pVolDesc->vds_pDfeDirBucketStart = (struct _DirFileEntry **)
            AfpAllocZeroedNonPagedMemory(sizeof(struct _DirFileEntry *) * dwDirHashSz);

        if (pVolDesc->vds_pDfeDirBucketStart == NULL)
        {
		    status = STATUS_INSUFFICIENT_RESOURCES;
		    break;
        }

        pVolDesc->vds_pDfeFileBucketStart = (struct _DirFileEntry **)
            AfpAllocZeroedNonPagedMemory(sizeof(struct _DirFileEntry *) * dwFileHashSz);

        if (pVolDesc->vds_pDfeFileBucketStart == NULL)
        {
		    status = STATUS_INSUFFICIENT_RESOURCES;
		    break;
        }

		// snapshot the disk space information
		status = AfpIoQueryVolumeSize(pVolDesc,
									  &pVolDesc->vds_FreeBytes,
									  &pVolDesc->vds_VolumeSize);

		if (!NT_SUCCESS(status))
		{
			break;
		}

		if (IS_VOLUME_NTFS(pVolDesc))
		{
			// In order to create IdIndex, AfpInfo and Desktop, the volume
			// root directory cannot be marked read only
			AfpExamineAndClearROAttr(&hVolRoot, &WriteBackROAttr, NULL, NULL);

			// Get rid of the NetworkTrash directory if it exists
			status = AfpDeleteNetworkTrash(pVolDesc, True);
			if (!NT_SUCCESS(status))
			{
				break;
			}
		}

		// initialize the desktop
		status = AfpInitDesktop(pVolDesc, &fNewVolume);
		if (!NT_SUCCESS(status))
		{
			break;
		}

        // if we just created the index database stream, this must be a new
        // volume.  Also, this is the first pass.  Note these facts
        if (fNewVolume)
        {
		    DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_ERR,
    		    ("AfpAdmWVolumeAdd: AfpInitDesktop says volume %Z is new\n",
                &pVolDesc->vds_Name));

            pVolDesc->vds_Flags |= VOLUME_NEW_FIRST_PASS;
        }

		// initialize the ID index database.
		status = AfpInitIdDb(pVolDesc, &fNewVolume, &fVerifyIndex);
		if (!NT_SUCCESS(status))
		{
		    DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_ERR,
    		    ("AfpAdmWVolumeAdd: AfpInitIdDb failed %lx on volume %Z\n",
                status,&pVolDesc->vds_Name));

			break;
		}

        if (fNewVolume)
        {
		    DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_ERR,
    		    ("AfpAdmWVolumeAdd: AfpInitIdDb says volume %Z is new\n",
                &pVolDesc->vds_Name));

            pVolDesc->vds_Flags |= VOLUME_NEW_FIRST_PASS;
        }

		if (IS_VOLUME_NTFS(pVolDesc))
		{
			// Create the network trash if this is not a CDFS volume;
			// a volume can be changed to/from readonly on the fly, so by putting
			// the network trash even on a readonly NTFS volume, we avoid a lot
			// of painful extra work.  This must be done AFTER initializing
			// the ID index database since we add the DFE for nwtrash.  We do
			// it here BEFORE posting the change notify since if an error
			// occurs, we don't have to clean up the posted notify.
			status = AfpCreateNetworkTrash(pVolDesc);
			if (!NT_SUCCESS(status))
			{
				break;
			}

            //
            // if it's a volume that was created earlier, and if this is not
            // an exclusive volume, post the chgntfy irp
            //
		    if (!fNewVolume && !EXCLUSIVE_VOLUME(pVolDesc))
		    {
    			// Begin monitoring changes to the tree. Even though we may
			    // start processing PC changes before we have finished
			    // enumerating the tree, if we get notified of part of the
			    // tree we have yet to cache (and therefore can't find it's
			    // path in our database its ok, since we will end up
			    // picking up the change when we enumerate that branch.  Also,
			    // by posting this before starting to cache the tree instead
			    // of after, we will pick up any changes that are made to parts
			    // of the tree we have already seen, otherwise we would miss
			    // those.

			    // Explicitly reference this volume for ChangeNotifies and post it
			    ASSERT (KeGetCurrentIrql() < DISPATCH_LEVEL);

			    if (AfpVolumeReference(pVolDesc))
                {
			        RefForNotify = True;
			        pVolDesc->vds_RequiredNotifyBufLen = AFP_VOLUME_NOTIFY_STARTING_BUFSIZE;
			        status = AfpVolumePostChangeNotify(pVolDesc);
			        if (!NT_SUCCESS(status))
			        {
    				    AfpVolumeDereference(pVolDesc);
				        RefForNotify = False;
				        break;
			        }
			        status = STATUS_SUCCESS;
                }
                else
                {
		            DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_ERR,
    			        ("AfpAdmWVolumeAdd: couldn't reference volume %Z!!\n",
                        &pVolDesc->vds_Name));

				    RefForNotify = False;
			        status = STATUS_UNSUCCESSFUL;
                }
		    }
            else
            {
		        DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_ERR,
				    ("AfpAdmWVolumeAdd: postponing chg-notify irp for %Z\n",&pVolDesc->vds_Name));
            }

		}
	} while (False);

	AfpPutBackROAttr(&hVolRoot, WriteBackROAttr);
	if (WriteBackROAttr && NT_SUCCESS(status))
	{
		pVolDesc->vds_pDfeRoot->dfe_NtAttr |= FILE_ATTRIBUTE_READONLY;
	}

	if (NT_SUCCESS(status))
	{
        if (fNewVolume || fVerifyIndex)
        {
            // put Indexing refcount, removed when we begin indexing
            pVolDesc->vds_RefCount++;
    
            AfpScavengerScheduleEvent(AfpVolumeBeginIndexing,
                                    pVolDesc,
                                    0,
                                    True);
        }
        else
        {
	        // mark the volume as 'officially' added.
	        AfpInterlockedClearDword(&pVolDesc->vds_Flags,
							        VOLUME_INTRANSITION,
                                    &pVolDesc->vds_VolLock);

            // activate the volume if IDDB was read correctly from the file
            afpActivateVolume(pVolDesc);

        }
	}
	else
	{

#if DBG
        if (pVolDesc)
        {
		    DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_ERR,
				("AfpAdmWVolumeAdd: Failed to add volume %Z %lx\n",&pVolDesc->vds_Name,status));
        }
        else
        {
		    DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_ERR,
				("AfpAdmWVolumeAdd: Failed to add volume %lx\n",status));
        }
#endif

		if ((hVolRoot.fsh_FileHandle != NULL) && !VolLinked)
		{
			AfpIoClose(&hVolRoot);
		}

		if (VolLinked)
		{
			// don't clear the VOLUME_INTRANSITION bit since this bit along
			// with VOLUME_DELETED bit signify the special case of an
			// error occurrence during volume add.
			pVolDesc->vds_Flags |= VOLUME_DELETED;

			// Remove the creation reference
			AfpVolumeDereference(pVolDesc);

			// if a Notify was posted, we need to cancel it here.  By
			// deleting the network trash we trigger the notify to complete.
			// This is safer than trying to cancel the irp since there are
			// windows where the vds_VolLock is not held between 2 threads
			// checking/setting vds_Flags. (Notify complete and repost).
			// The spin lock cannot be held while cancelling the Irp.
			//
			// Do this after marking the volume as DELETED since when the
			// notify completion sees the volume is being deleted it will
			// not repost (and will clean up the Irp, etc.).
			if (RefForNotify)
			{
				// Note at this point we are guaranteed there is a trash
				// directory since if creating the trash had failed, we
				// would have failed the volume add before posting the
				// change notify.
				AfpDeleteNetworkTrash(pVolDesc, False);
			}
		}
		else if (pVolDesc != NULL)
		{
            if (pVolDesc->vds_pDfeDirBucketStart)
            {
                AfpFreeMemory(pVolDesc->vds_pDfeDirBucketStart);
            }

            if (pVolDesc->vds_pDfeFileBucketStart)
            {
                AfpFreeMemory(pVolDesc->vds_pDfeFileBucketStart);
            }

			AfpFreeMemory(pVolDesc);
		}
	}

	// Dereferencing the volume here takes care of any necessary error cleanup work
	if (VolLinked)
	{
		AfpVolumeDereference(pVolDesc);
	}

	return status;
}


/***	AfpAdmWVolumeDelete
 *
 *	This routine deletes a volume from the server global list of volumes
 *	headed by AfpVolumeList and recycles its volid.  A volume with active
 *	connections cannot be deleted.
 *
 *	LOCKS: AfpVolumeListLock (SPIN), vds_VolLock (SPIN)
 *	LOCK_ORDER: vds_VolLock (SPIN) after AfpVolumeListLock (SPIN)
 *
 */
AFPSTATUS
AfpAdmWVolumeDelete(
	IN	OUT	PVOID	Inbuf		OPTIONAL,
	IN	LONG		OutBufLen	OPTIONAL,
	OUT	PVOID		Outbuf		OPTIONAL
)
{
	WCHAR			wcbuf[AFP_VOLNAME_LEN + 1];
	UNICODE_STRING	uvolname, upcasename;
	KIRQL			OldIrql;
	PVOLDESC		pVolDesc;
	AFPSTATUS		Status = STATUS_SUCCESS;

	DBGPRINT(DBG_COMP_ADMINAPI_VOL, DBG_LEVEL_INFO,
			("AfpAdmWVolumeDelete entered\n"));

	RtlInitUnicodeString(&uvolname, ((PAFP_VOLUME_INFO)Inbuf)->afpvol_name);
	AfpSetEmptyUnicodeString(&upcasename, sizeof(wcbuf), wcbuf);
	Status = RtlUpcaseUnicodeString(&upcasename, &uvolname, False);
	ASSERT(NT_SUCCESS(Status));

	do
	{
		// Reference the volume while we clean-up
		pVolDesc = AfpVolumeReferenceByUpCaseName(&upcasename);

		if (pVolDesc == NULL)
		{
			Status = AFPERR_VolumeNonExist;
			break;
		}

		ACQUIRE_SPIN_LOCK(&pVolDesc->vds_VolLock, &OldIrql);

		// make sure there are no AFP clients using the volume
		if (pVolDesc->vds_UseCount != 0)
		{
			RELEASE_SPIN_LOCK(&pVolDesc->vds_VolLock, OldIrql);
			Status = AFPERR_VolumeBusy;
            AfpVolumeDereference(pVolDesc);
			break;
		}

		// if this volume is in the process of being stopped or deleted,
		// in effect it should be 'invisible' to the caller.
		if (pVolDesc->vds_Flags & (VOLUME_STOPPED | VOLUME_DELETED))
		{
			RELEASE_SPIN_LOCK(&pVolDesc->vds_VolLock, OldIrql);
			Status = AFPERR_VolumeNonExist;
            AfpVolumeDereference(pVolDesc);
			break;
		}

        if ((pVolDesc->vds_Flags & VOLUME_INITIAL_CACHE) &&
            !(pVolDesc->vds_Flags & VOLUME_INTRANSITION))
        {
            // set this so we don't reset the Indexing global flag again!
            pVolDesc->vds_Flags |= VOLUME_INTRANSITION;
        }

		pVolDesc->vds_Flags |= VOLUME_DELETED;
		RELEASE_SPIN_LOCK(&pVolDesc->vds_VolLock, OldIrql);

		// Remove the creation reference
		AfpVolumeDereference(pVolDesc);

		// Cancel posted change notify
		if (pVolDesc->vds_Flags & VOLUME_NOTIFY_POSTED)
		{
			DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_INFO,
					("AfpAdmWVolumeDelete: Cancel notify on volume %ld\n",
					pVolDesc->vds_VolId));
			ASSERT (pVolDesc->vds_pIrp != NULL);

			// Cancel after releasing the volume lock since the completion
			// routine acquires it and it could be called in the context
			// of IoCancelIrp(). Also Cancel uses paged resource and so
			// must be called w/o holding any spin locks.

			IoCancelIrp(pVolDesc->vds_pIrp);
		}

		// We have a reference to the volume from AfpFindVolumeByUpcaseName
		ASSERT(pVolDesc->vds_RefCount >= 1);

		// Cancel the OurChange scavenger for this volume.
		if (AfpScavengerKillEvent(AfpOurChangeScavenger, pVolDesc))
		{
			// If it was deleted from scavenger list, run it one last time
			AfpOurChangeScavenger(pVolDesc);
		}

		// Cancel the volume scavenger and call it ourselves to avoid the delay
		if (AfpScavengerKillEvent(AfpVolumeScavenger, pVolDesc))
		{
			// This will do the dereference for the scavenger reference
			// Take away our reference before calling the volume scavenger
			AfpVolumeDereference(pVolDesc);
			AfpVolumeScavenger(pVolDesc);
		}
		else
        {
            AfpVolumeDereference(pVolDesc);
        }
	} while (False);

	return Status;
}



/***	AfpAdmWConnectionClose
 *
 *	Close a connection forcibly. This is an admin operation and must be queued
 *	up since this can potentially cause filesystem operations that are valid
 *	only in the system process context.
 *
 *	LOCKS: AfpConnLock (SPIN), cds_ConnLock (SPIN)
 *	LOCK_ORDER: cds_ConnLock (SPIN) after AfpConnLock (SPIN)
 */
AFPSTATUS
AfpAdmWConnectionClose(
	IN	OUT	PVOID	InBuf		OPTIONAL,
	IN	LONG		OutBufLen	OPTIONAL,
	OUT	PVOID		OutBuf		OPTIONAL
)
{
	AFPSTATUS				Status = AFPERR_InvalidId;
	PCONNDESC				pConnDesc;
	DWORD					ConnId;
	PAFP_CONNECTION_INFO	pConnInfo = (PAFP_CONNECTION_INFO)InBuf;
	AFP_SESSION_INFO		SessInfo;
	BOOLEAN					KillSessionToo;

	if ((ConnId = pConnInfo->afpconn_id) != 0)
	{
		if ((pConnDesc = afpConnectionReferenceById(ConnId)) != NULL)
		{
			SessInfo.afpsess_id = pConnDesc->cds_pSda->sda_SessionId;
			KillSessionToo = (pConnDesc->cds_pSda->sda_cOpenVolumes == 1) ?
											True : False;
			AfpConnectionClose(pConnDesc);
			AfpConnectionDereference(pConnDesc);

			if (KillSessionToo)
			{
				AfpAdmWSessionClose(&SessInfo, 0, NULL);
			}
			Status = AFP_ERR_NONE;
		}
	}
	else
	{
		DWORD			ConnId = MAXULONG;
		KIRQL			OldIrql;
		BOOLEAN			Shoot;

		Status = AFP_ERR_NONE;
		while (True)
		{
			ACQUIRE_SPIN_LOCK(&AfpConnLock, &OldIrql);

			for (pConnDesc = AfpConnList;
				 pConnDesc != NULL;
				 pConnDesc = pConnDesc->cds_NextGlobal)
			{
				if (pConnDesc->cds_ConnId > ConnId)
					continue;

				ACQUIRE_SPIN_LOCK_AT_DPC(&pConnDesc->cds_ConnLock);

				ConnId = pConnDesc->cds_ConnId;

				Shoot = False;

				if (!(pConnDesc->cds_Flags & CONN_CLOSING))
				{
					pConnDesc->cds_RefCount ++;
					Shoot = True;
					SessInfo.afpsess_id = pConnDesc->cds_pSda->sda_SessionId;
					KillSessionToo = (pConnDesc->cds_pSda->sda_cOpenVolumes == 1) ?
															True : False;
				}

				RELEASE_SPIN_LOCK_FROM_DPC(&pConnDesc->cds_ConnLock);

				if (Shoot)
				{
					RELEASE_SPIN_LOCK(&AfpConnLock, OldIrql);

					AfpConnectionClose(pConnDesc);
					AfpConnectionDereference(pConnDesc);

					if (KillSessionToo)
					{
						AfpAdmWSessionClose(&SessInfo, 0, NULL);
					}
					break;
				}
			}
			if (pConnDesc == NULL)
			{
				RELEASE_SPIN_LOCK(&AfpConnLock, OldIrql);
				break;
			}
		}
	}

	return Status;
}



/***	AfpVolumeBeginIndexing
 *
 *	Check if another volume is doing it's indexing: if yes, put it back on the
 *  queue and try later.  If no one else is indexing, start indexing this volume
 *
 */
AFPSTATUS FASTCALL
AfpVolumeBeginIndexing(
    IN  PVOLDESC            pVolDesc
)
{

    KIRQL           OldIrql;
    UNICODE_STRING  RootName;
    BOOLEAN         fVolumeStopped=FALSE;
	LARGE_INTEGER	IndexStartTime;


    // is the volume stopped or deleted?  ignore this then
    ACQUIRE_SPIN_LOCK(&pVolDesc->vds_VolLock, &OldIrql);
    if (pVolDesc->vds_Flags & (VOLUME_DELETED | VOLUME_STOPPED))
    {
	    DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_ERR,
    	    ("AfpVolumeBeginIndexing: volume %Z stopping, cancelling indexing\n",&pVolDesc->vds_Name));
        fVolumeStopped = TRUE;
    }
    RELEASE_SPIN_LOCK(&pVolDesc->vds_VolLock, OldIrql);


    if (fVolumeStopped)
    {
	    // Remove the Indexing reference
	    AfpVolumeDereference(pVolDesc);

        return(AFP_ERR_NONE);
    }

	KeQuerySystemTime (&IndexStartTime);
	pVolDesc->vds_IndxStTime = IndexStartTime;

	DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_ERR,
	    ("AfpVolumeBeginIndexing: indexing volume %Z at %8lx%08lx\n",&pVolDesc->vds_Name, 
		 0xffffffff*IndexStartTime.HighPart,
		 0xffffffff*IndexStartTime.LowPart));

	// scan the entire directory tree and sync disk with iddb.  Must be
	// done AFTER initializing the Desktop since we may add APPL mappings
	// while enumerating the disk.  Also we need to know if we read an
	// old style desktop off the disk, and if so, need to rebuild all the
	// APPL mappings so they have the parentID.
	
	AfpSetEmptyUnicodeString(&RootName, 0, NULL);
	AfpQueuePrivateChangeNotify(pVolDesc,
								&RootName,
								&RootName,
								AFP_ID_ROOT);

	// mark the volume as 'officially' added.
	AfpInterlockedClearDword(&pVolDesc->vds_Flags,
							VOLUME_INTRANSITION,
							&pVolDesc->vds_VolLock);

	// Remove the Indexing reference
	AfpVolumeDereference(pVolDesc);

    return(AFP_ERR_NONE);
}



/***	AfpVolumePostChangeNotify
 *
 *	Post a change notify on the root of the volume.  If the current size of
 *  the notify buffer for this volume is not large enough to accomodate a path
 *  containing n+1 macintosh filename components, (where n is the maximum
 *  depth of the directory tree and a component is a maximum of 31 unicode
 *  chars plus 1 char path separator), then the buffer is reallocated.
 *  The notify buffer does not ever shrink in size since we cannot keep track
 *  of the maximum depth of each branch of the directory tree whenever a
 *  directory is deleted.
 *
 *  Note that the initial size of the notify buffer is
 *  AFP_VOLUME_NOTIFY_STARTING_BUFSIZE.  When a volume is added, the change
 *  notify is posted *before* the Id Index database is constructed so we do
 *  not know what the maximum depth of the tree is yet.  In most cases this
 *  buffer length is sufficient and will probably never get reallocated unless
 *  some sadistic test is running that creates very deep directories.  Note
 *  that since the maximum path in win32 is 260 chars, the initial buffer
 *  size is adequate to handle any changes notified from PC side.
 *
 */
NTSTATUS FASTCALL
AfpVolumePostChangeNotify(
	IN	PVOLDESC		pVolDesc
)
{
	PIRP				pIrp = NULL;
	PMDL				pMdl = NULL;
	PBYTE				pNotifyBuf = NULL;
	DWORD				NotifyBufSize = 0;
	NTSTATUS			Status = STATUS_SUCCESS;
	PDEVICE_OBJECT		pDeviceObject;
	PIO_STACK_LOCATION	pIrpSp;

	PAGED_CODE ();

	ASSERT (KeGetCurrentIrql() < DISPATCH_LEVEL);

	ASSERT(pVolDesc->vds_pFileObject != NULL);

	do
	{
		// Get the address of the target device object.
		pDeviceObject = IoGetRelatedDeviceObject(AfpGetRealFileObject(pVolDesc->vds_pFileObject));

        // free that irp: we need to allocate a new one, in case some
        // filter driver chained itself in
		if ((pIrp = pVolDesc->vds_pIrp) != NULL)
        {
            if (pIrp->MdlAddress != NULL)
            {
			    pNotifyBuf = MmGetSystemAddressForMdlSafe(
						pIrp->MdlAddress,
						NormalPagePriority);

			    AfpFreeMdl(pIrp->MdlAddress);

				if (pNotifyBuf != NULL)
				{
					AfpFreeMemory(pNotifyBuf);

					pNotifyBuf = NULL;
				}
            }

            pVolDesc->vds_pIrp = NULL;
            AfpFreeIrp(pIrp);
        }

		// Allocate and initialize the IRP for this operation, if we do not already
		// have an Irp allocated for this volume.
		if ((pIrp = AfpAllocIrp(pDeviceObject->StackSize)) == NULL)
		{
			Status = STATUS_INSUFFICIENT_RESOURCES;
			break;
		}

		pVolDesc->vds_pIrp = pIrp;

		
		// Re-initialize the stack location.
		pIrp->CurrentLocation = (CCHAR)(pIrp->StackCount + 1);
		pIrp->Tail.Overlay.CurrentStackLocation =
										((PIO_STACK_LOCATION)((UCHAR *)(pIrp) +
										sizeof(IRP) +
										((pDeviceObject->StackSize) * sizeof(IO_STACK_LOCATION))));

        //
		// If we aren't going to resue the buffer and the mdl, allocate a buffer for
        // Notify information and create an Mdl for it.
        //
        if (pNotifyBuf == NULL)
        {
		    NotifyBufSize = pVolDesc->vds_RequiredNotifyBufLen;

		    if (((pNotifyBuf = AfpAllocNonPagedMemory(NotifyBufSize)) == NULL) ||
			    ((pMdl = AfpAllocMdl(pNotifyBuf, NotifyBufSize, pIrp)) == NULL))
		    {
			    Status = STATUS_INSUFFICIENT_RESOURCES;
			    break;
		    }
        }
        else
        {
            ASSERT(pMdl != NULL);
            pIrp->MdlAddress = pMdl;
        }

        ASSERT(NotifyBufSize > 0);

		// Set up the completion routine.
		IoSetCompletionRoutine( pIrp,
								afpVolumeChangeNotifyComplete,
								pVolDesc,
								True,
								True,
								True);

		pIrp->Tail.Overlay.OriginalFileObject = AfpGetRealFileObject(pVolDesc->vds_pFileObject);
		pIrp->Tail.Overlay.Thread = AfpThread;
		pIrp->RequestorMode = KernelMode;

		// Get a pointer to the stack location for the first driver. This will be
		// used to pass the original function codes and the parameters.
		pIrpSp = IoGetNextIrpStackLocation(pIrp);
		pIrpSp->MajorFunction = IRP_MJ_DIRECTORY_CONTROL;
		pIrpSp->MinorFunction = IRP_MN_NOTIFY_CHANGE_DIRECTORY;
		pIrpSp->FileObject = AfpGetRealFileObject(pVolDesc->vds_pFileObject);
		pIrpSp->DeviceObject = pDeviceObject;

		// Copy the parameters to the service-specific portion of the IRP.
		pIrpSp->Parameters.NotifyDirectory.Length = NotifyBufSize;

		// We do not try to catch FILE_NOTIFY_CHANGE_SECURITY since it will
		// complete with FILE_ACTION_MODIFIED, and we can't tell that it was
		// actually security that changed.  A change in security will update
		// the last ChangeTime, but we can't pick this up for every
		// FILE_ACTION_MODIFIED that comes in!  So the result will be that
		// if PC changes security, we will not update the modified time on
		// a directory (nor the VolumeModified time so that mac would
		// reenumerate any open windows to display the change in security).
		pIrpSp->Parameters.NotifyDirectory.CompletionFilter =
												FILE_NOTIFY_CHANGE_NAME			|
												FILE_NOTIFY_CHANGE_ATTRIBUTES	|
												FILE_NOTIFY_CHANGE_SIZE			|
												FILE_NOTIFY_CHANGE_CREATION	|
												FILE_NOTIFY_CHANGE_STREAM_SIZE	|
												FILE_NOTIFY_CHANGE_LAST_WRITE;

		pIrpSp->Flags = SL_WATCH_TREE;

		ASSERT(!(pVolDesc->vds_Flags & VOLUME_DELETED));

		INTERLOCKED_INCREMENT_LONG( &afpNumPostedNotifies );

		AfpInterlockedSetDword( &pVolDesc->vds_Flags,
								VOLUME_NOTIFY_POSTED,
								&pVolDesc->vds_VolLock);

		Status = IoCallDriver(pDeviceObject, pIrp);
		DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_INFO,
				("AfpVolumePostChangeNotify: Posted ChangeNotify on %Z (status 0x%lx)\n",
				  &pVolDesc->vds_Name, Status));
	} while (False);

	ASSERTMSG("Post of Volume change notify failed!", NT_SUCCESS(Status));

	if (Status == STATUS_INSUFFICIENT_RESOURCES)
	{
		AFPLOG_DDERROR( AFPSRVMSG_NONPAGED_POOL,
						STATUS_NO_MEMORY,
						NULL,
						0,
						NULL);

		if (pNotifyBuf != NULL)
			AfpFreeMemory(pNotifyBuf);

		if (pIrp != NULL)
			AfpFreeIrp(pIrp);

		if (pMdl != NULL)
			AfpFreeMdl(pMdl);
	}

	return Status;
}



/***	afpVolumeChangeNotifyComplete
 *
 *	This is the completion routine for a posted change notify request. Queue
 *	this Volume for ChangeNotify processing. No items should be processed
 *  until the volume is marked as started because the volume may be in the
 *  middle of its initial sync with disk of the entire tree, and we don't
 *  want to 'discover' a part of the tree that we may not have seen yet but
 *  that somebody just changed.
 *
 *	LOCKS:		AfpServerGlobalLock (SPIN), vds_VolLock (SPIN)
 */
NTSTATUS
afpVolumeChangeNotifyComplete(
	IN	PDEVICE_OBJECT	pDeviceObject,
	IN	PIRP			pIrp,
	IN	PVOLDESC		pVolDesc
)
{
	PVOL_NOTIFY	pVolNotify = NULL;
	PBYTE		pBuf;
	NTSTATUS	status = STATUS_SUCCESS;

	ASSERT (KeGetCurrentIrql() < DISPATCH_LEVEL);

	ASSERT(VALID_VOLDESC(pVolDesc));

	ASSERT(pIrp == pVolDesc->vds_pIrp);

	ASSERT(pIrp->MdlAddress != NULL);

	pBuf = MmGetSystemAddressForMdlSafe(
			pIrp->MdlAddress,
			NormalPagePriority);

	AfpInterlockedClearDword(&pVolDesc->vds_Flags,
							 VOLUME_NOTIFY_POSTED,
							 &pVolDesc->vds_VolLock);

	INTERLOCKED_DECREMENT_LONG(&afpNumPostedNotifies);

	if (((AfpServerState == AFP_STATE_SHUTTINGDOWN) ||
		 (AfpServerState == AFP_STATE_STOP_PENDING)) &&
		 (afpNumPostedNotifies == 0))
	{
		// If we are getting out, unblock the the admin thread
		KeSetEvent(&AfpStopConfirmEvent, IO_NETWORK_INCREMENT, False);
	}

	if (((pIrp->IoStatus.Status != STATUS_CANCELLED) &&
		((pVolDesc->vds_Flags & (VOLUME_STOPPED | VOLUME_DELETED)) == 0)) &&
			(pBuf != NULL)
		)
	{
		if ((NT_SUCCESS(pIrp->IoStatus.Status)) &&
			(pIrp->IoStatus.Information > 0))
		{
			// Allocate a notify structure and copy the data into it.
			// Post another notify before we process this one
			pVolNotify = (PVOL_NOTIFY)AfpAllocNonPagedMemory(sizeof(VOL_NOTIFY) +
															 (ULONG)(pIrp->IoStatus.Information) +
															 (AFP_LONGNAME_LEN + 1)*sizeof(WCHAR));
			if (pVolNotify != NULL)
			{
				AfpGetCurrentTimeInMacFormat(&pVolNotify->vn_TimeStamp);
				pVolNotify->vn_pVolDesc = pVolDesc;
				pVolNotify->vn_Processor = AfpProcessChangeNotify;
				RtlCopyMemory((PCHAR)pVolNotify + sizeof(VOL_NOTIFY),
							  pBuf,
							  pIrp->IoStatus.Information);
			}
			else
			{
                DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_ERR,("Out of memory!!\n"));
                ASSERT(0);
				status = STATUS_INSUFFICIENT_RESOURCES;
			}
		}
		else
		{
            if (pIrp->IoStatus.Status == STATUS_NOTIFY_ENUM_DIR)
            {
                pVolDesc->vds_RequiredNotifyBufLen *= 2;

                if (pVolDesc->vds_RequiredNotifyBufLen > AFP_VOLUME_NOTIFY_MAX_BUFSIZE)
                {
                    DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_ERR,
                        ("afpVolumeChangeNotifyComplete: even %d isn't enough (%d,%lx)??\n",
                        AFP_VOLUME_NOTIFY_MAX_BUFSIZE,pVolDesc->vds_RequiredNotifyBufLen,pBuf));
                    ASSERT(0);

                    pVolDesc->vds_RequiredNotifyBufLen = AFP_VOLUME_NOTIFY_MAX_BUFSIZE;
                }
            }
            else
            {
                DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_ERR,
                    ("afpVolumeChangeNotifyComplete: Status %lx, Info %d\n",
                    pIrp->IoStatus.Status,pIrp->IoStatus.Information));
                ASSERT(0);
            }

			status = pIrp->IoStatus.Status;
		}

		// Repost our ChangeNotify request if the last one completed
		// without an error
		if (NT_SUCCESS(pIrp->IoStatus.Status))
		{
			AfpVolumePostChangeNotify(pVolDesc);
		}
		else
		{
			// If this notify completed with an error, we cannot recursively
			// repost another one, since it will just keep completing with
			// the same error and we will run out of stack space recursing.
			// We will have to queue up a work item so that the
			// change notify request will get reposted for this volume.
			// Note that in the time it takes to do this, many changes could
			// pile up so the next completion would have multiple entries
			// returned in the list.
			AfpScavengerScheduleEvent(AfpVolumePostChangeNotify,
									  (PVOID)pVolDesc,
									  0,
									  True);
		}

		if (pVolNotify != NULL)
		{
			if (AfpShouldWeIgnoreThisNotification(pVolNotify))
			{
				AfpFreeMemory(pVolNotify);
			}
			else
			{
				PFILE_NOTIFY_INFORMATION pFNInfo;

				// Reference the volume for Notify processing
				if (AfpVolumeReference(pVolDesc))
                {
				    AfpVolumeInsertChangeNotifyList(pVolNotify, pVolDesc);
	
				    pFNInfo = (PFILE_NOTIFY_INFORMATION)(pVolNotify + 1);
				    if ((pFNInfo->Action == FILE_ACTION_REMOVED) ||
					    (pFNInfo->Action == FILE_ACTION_RENAMED_OLD_NAME))
				    {
					    // Chain all the rename and delete changes off of the
					    // volume descriptor in case we ever need to lookahead
					    // for one.  We only look at the first change in each
					    // FILE_NOTIFY_INFORMATION since normally there will only
					    // be one entry per buffer since we repost our changenotify
					    // within our completion routine.
					    ExInterlockedInsertTailList(&pVolDesc->vds_ChangeNotifyLookAhead,
						    						&pVolNotify->vn_DelRenLink,
							    					&(pVolDesc->vds_VolLock.SpinLock));
				    }
				    else
				    {
					    // Just set links to initialized state. These will never be looked at.
					    InitializeListHead(&pVolNotify->vn_DelRenLink);
				    }
                }
                else
                {
		            DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_ERR,
    			        ("afpVolumeChangeNotifyComplete: couldn't reference volume %Z!!\n",
                        &pVolDesc->vds_Name));

				    AfpFreeMemory(pVolNotify);
                }
			}
		}
		else
		{
			AFPLOG_ERROR(AFPSRVMSG_MISSED_NOTIFY,
						 status,
						 NULL,
						 0,
						 &pVolDesc->vds_Name);
		}
	}
	else
	{
		// Free the resources and get out
		AfpFreeMdl(pIrp->MdlAddress);

		if (pBuf != NULL)
			AfpFreeMemory(pBuf);
		AfpFreeIrp(pIrp);
		pVolDesc->vds_pIrp = NULL;

		AfpVolumeDereference(pVolDesc);
	}

	// Return STATUS_MORE_PROCESSING_REQUIRED so that IoCompleteRequest
	// will stop working on the IRP.

	return STATUS_MORE_PROCESSING_REQUIRED;
}

/***	afpAllocNotify
 *
 *	Allocate a Notify from the Notify Blocks. The Notify's are allocated 
 *  in 4K chunks and internally managed. The idea is primarily to reduce 
 *  the dependency we may have on non-paged/paged memory during posting 
 *  private notify code.
 *
 *	The Notify's are allocated out of virtual memory.
 *
 *	LOCKS:	afpNotifyBlockLock (SWMR, Exclusive)
 *
 */
PVOL_NOTIFY 
afpAllocNotify(
	IN	LONG	Index,
	IN	BOOLEAN	fDir
)
{
	PVOL_NOTIFY_BLOCK	pDfb;
	PVOL_NOTIFY	pVolNotify = NULL;

	PAGED_CODE( );

	ASSERT ((Index >= 0) && (Index < NOTIFY_MAX_BLOCK_TYPE));

	AfpSwmrAcquireExclusive(&afpNotifyBlockLock);


	// If the block head has no free entries then there are none !!
	// Pick the right block based on whether it is file or dir
	pDfb = afpDirNotifyPartialBlockHead[Index];
	if (pDfb == NULL)
	{
		// Currently we will directly allocate it instead of managing
		// the free list and assigning out of it
		//
		// There are no partial blocks. Check if there any free ones 
		// and if there move them to partial
		// since we about to allocate from them
		//
			pDfb = afpDirNotifyFreeBlockHead[Index];
			if (pDfb != NULL)
			{
				AfpUnlinkDouble(pDfb, dfb_Next, dfb_Prev);
				AfpLinkDoubleAtHead(afpDirNotifyPartialBlockHead[Index],
									pDfb,
									dfb_Next,
									dfb_Prev);
			}
	}

	if (pDfb != NULL)

	{
		ASSERT(VALID_NOTIFY_BLOCK(pDfb));
		ASSERT((pDfb->dfb_NumFree <= afpNotifyNumDirBlocks[Index]));

		ASSERT (pDfb->dfb_NumFree != 0);
		DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_INFO,
				("afpAllocDfe: Found space in Block %lx\n", pDfb));
	}

	if (pDfb == NULL)
	{

		if ((pDfb = (PVOL_NOTIFY_BLOCK)AfpAllocateVirtualMemoryPage()) != NULL)
		{
			USHORT	i;
			USHORT 	MaxDfes, NotifySize;

			afpNotifyBlockAllocCount ++;
			// update max notify block alloc count
			if (afpNotifyBlockAllocCount > afpMaxNotifyBlockAllocCount)
			{
				afpMaxNotifyBlockAllocCount = afpNotifyBlockAllocCount;
			}

			DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_WARN,
					("afpAllocNotify: No free blocks. Allocated a new block %lx , count=%ld\n",
					pDfb, afpNotifyBlockAllocCount));

			//
           		// Link it in the partial list as we are about to 
			// allocate one block out of it anyway.
			//
			AfpLinkDoubleAtHead(afpDirNotifyPartialBlockHead[Index],
								pDfb,
								dfb_Next,
								dfb_Prev);
			NotifySize = afpNotifyDirBlockSize[Index];
			pDfb->dfb_NumFree = MaxDfes = afpNotifyNumDirBlocks[Index];

			ASSERT(QUAD_SIZED(NotifySize));
			pDfb->dfb_Age = 0;

			// Initialize the list of free notify entries
			for (i = 0, pVolNotify = pDfb->dfb_FreeHead = (PVOL_NOTIFY)((PBYTE)pDfb + sizeof(VOL_NOTIFY_BLOCK));
				 i < MaxDfes;
				 i++, pVolNotify = pVolNotify->Notify_NextFree)
			{
				pVolNotify->Notify_NextFree = (i == (MaxDfes - 1)) ?
											NULL :
											(PVOL_NOTIFY)((PBYTE)pVolNotify + NotifySize);
			}
		}
        	else
        	{
			DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_ERR,
					("afpAllocDfe: AfpAllocateVirtualMemoryPage failed\n"));

            		AFPLOG_ERROR(AFPSRVMSG_VIRTMEM_ALLOC_FAILED,
                         	STATUS_INSUFFICIENT_RESOURCES,
                         	NULL,
                         	0,
                         	NULL);
        	}
	}

	if (pDfb != NULL)
	{
		PVOL_NOTIFY_BLOCK	pTmp;

		ASSERT(VALID_NOTIFY_BLOCK(pDfb));

		pVolNotify = pDfb->dfb_FreeHead;
		afpNotifyAllocCount ++;
		pDfb->dfb_FreeHead = pVolNotify->Notify_NextFree;
		pDfb->dfb_NumFree --;

		//
		// If the block is now empty (completely used), unlink it 
		// from here and move it to the Used list.
		//
		if (pDfb->dfb_NumFree == 0)
		{
			AfpUnlinkDouble(pDfb, dfb_Next, dfb_Prev);
				AfpLinkDoubleAtHead(afpDirNotifyUsedBlockHead[Index],
									pDfb,
									dfb_Next,
									dfb_Prev);
		}

	}

	AfpSwmrRelease(&afpNotifyBlockLock);

	return pVolNotify;
}


/***	afpFreeNotify
 *
 *	Return a Notify to the allocation block.
 *
 *	LOCKS:	afpNotifyBlockLock (SWMR, Exclusive)
 */
VOID 
afpFreeNotify(
	IN	PVOL_NOTIFY	pVolNotify
)
{
	PVOL_NOTIFY_BLOCK	pDfb;
	ULONG		NumBlks, index;

	PAGED_CODE( );

	// NOTE: The following code *depends* on the fact that we allocate DFBs as
	//		 64K blocks and also that these are allocated *at* 64K boundaries
	//		 This lets us *cheaply* get to the owning DFB from the DFE.
	pDfb = (PVOL_NOTIFY_BLOCK)((ULONG_PTR)pVolNotify & ~(PAGE_SIZE-1));
	ASSERT(VALID_NOTIFY_BLOCK(pDfb));

	AfpSwmrAcquireExclusive(&afpNotifyBlockLock);

	afpNotifyAllocCount --;

	index = NOTIFY_USIZE_TO_INDEX(pVolNotify->vn_VariableLength);
	NumBlks = afpNotifyNumDirBlocks[index];

	ASSERT(pDfb->dfb_NumFree < NumBlks);

#if DBG
	DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_WARN,
			("AfpFreeDfe: Returning Notify %lx to Block %lx, index=%ld, dfb=%ld, alloc=%ld\n",
			pVolNotify, pDfb, index, pDfb->dfb_NumFree+1, afpNotifyAllocCount));
#endif

	pDfb->dfb_NumFree ++;
	pVolNotify->Notify_NextFree = pDfb->dfb_FreeHead;
	pDfb->dfb_FreeHead = pVolNotify;

	if (pDfb->dfb_NumFree == 1)
	{
		ULONG		Index;

		//
		// The block is now partially free (it used to be completely used). move it to the partial list.
		//

		Index = NOTIFY_USIZE_TO_INDEX(pVolNotify->vn_VariableLength);
		AfpUnlinkDouble(pDfb, dfb_Next, dfb_Prev);
		AfpLinkDoubleAtHead(afpDirNotifyPartialBlockHead[Index],
							pDfb,
							dfb_Next,
							dfb_Prev);
	}
	else if (pDfb->dfb_NumFree == NumBlks)
	{
		ULONG		Index;

		//
		// The block is now completely free (used to be partially used). move it to the free list
		//

		Index = NOTIFY_USIZE_TO_INDEX(pVolNotify->vn_VariableLength);
		pDfb->dfb_Age = 0;
		AfpUnlinkDouble(pDfb, dfb_Next, dfb_Prev);

		DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_WARN,
				("afpFreeDfe: Freeing Block %lx, Index=%ld\n", pDfb, Index));

		AfpLinkDoubleAtHead(afpDirNotifyFreeBlockHead[Index],
							pDfb,
							dfb_Next,
							dfb_Prev);
	}

	AfpSwmrRelease(&afpNotifyBlockLock);

}

/***	afpNotifyBlockAge
 *
 *	Age out Notify Blocks
 *
 *	LOCKS:	afpNotifyBlockLock (SWMR, Exclusive)
 */
AFPSTATUS FASTCALL
afpNotifyBlockAge(
	IN	PPVOL_NOTIFY_BLOCK	ppBlockHead
)
{
	int			index, MaxDfes;
	PVOL_NOTIFY_BLOCK	pDfb;

	PAGED_CODE( );

	AfpSwmrAcquireExclusive(&afpNotifyBlockLock);

	for (index = 0; index < NOTIFY_MAX_BLOCK_TYPE; index++)
	{
		pDfb = ppBlockHead[index];
		if (pDfb != NULL)
		{
			MaxDfes = afpNotifyNumDirBlocks[index];
		}

		while (pDfb != NULL)
		{
			PVOL_NOTIFY_BLOCK pFree;

			ASSERT(VALID_NOTIFY_BLOCK(pDfb));

			pFree = pDfb;
			pDfb = pDfb->dfb_Next;

			ASSERT (pFree->dfb_NumFree == MaxDfes);

			DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_WARN,
					("afpNotifyBlockAge: Aging Block %lx, Size %d\n", pFree,
					afpNotifyDirBlockSize[index]));
			if (++(pFree->dfb_Age) >= NOTIFY_MAX_BLOCK_AGE)
			{
				DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_WARN,
						("afpNotifyBlockAge: Freeing Block %lx, Size %d\n", pFree,
						afpNotifyDirBlockSize[index]));
				AfpUnlinkDouble(pFree, dfb_Next, dfb_Prev);
				AfpFreeVirtualMemoryPage(pFree);
				afpNotifyBlockAllocCount--;
			}
		}
	}

	AfpSwmrRelease(&afpNotifyBlockLock);

	return AFP_ERR_REQUEUE;
}

/***	afpFreeNotifyBlockMemory
 *
 *	Forced Freeing of Notify Blocks
 *
 *	LOCKS:	afpNotifyBlockLock (SWMR, Exclusive)
 */
VOID afpFreeNotifyBlockMemory (
)
{
	int			index, MaxDfes;
	PVOL_NOTIFY_BLOCK	pDfb;

	PAGED_CODE( );

	AfpSwmrAcquireExclusive(&afpNotifyBlockLock);

	for (index = 0; index < NOTIFY_MAX_BLOCK_TYPE; index++)
	{
		pDfb = afpDirNotifyFreeBlockHead[index];
		if (pDfb != NULL)
		{
			MaxDfes = afpNotifyNumDirBlocks[index];
		}

		while (pDfb != NULL)
		{
			PVOL_NOTIFY_BLOCK pFree;

			ASSERT(VALID_NOTIFY_BLOCK(pDfb));

			pFree = pDfb;
			pDfb = pDfb->dfb_Next;

			DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_WARN,
					("afpFreeNotifyBlockMemory: Cleaningup Free Block %lx, Size %d\n", 
					 pFree, afpNotifyDirBlockSize[index]));
				AfpUnlinkDouble(pFree, dfb_Next, dfb_Prev);
				AfpFreeVirtualMemoryPage(pFree);
				afpNotifyBlockAllocCount--;
		}

		pDfb = afpDirNotifyPartialBlockHead[index];
		while (pDfb != NULL)
		{
			PVOL_NOTIFY_BLOCK pFree;

			ASSERT(VALID_NOTIFY_BLOCK(pDfb));

			pFree = pDfb;
			pDfb = pDfb->dfb_Next;

			DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_WARN,
					("afpFreeNotifyBlockMemory: Cleaningup Partial Block %lx, Size %d\n", 
					 pFree, afpNotifyDirBlockSize[index]));
				AfpUnlinkDouble(pFree, dfb_Next, dfb_Prev);
				AfpFreeVirtualMemoryPage(pFree);
				afpNotifyBlockAllocCount--;
		}

		pDfb = afpDirNotifyUsedBlockHead[index];
		while (pDfb != NULL)
		{
			PVOL_NOTIFY_BLOCK pFree;

			ASSERT(VALID_NOTIFY_BLOCK(pDfb));

			pFree = pDfb;
			pDfb = pDfb->dfb_Next;

			DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_WARN,
					("afpFreeNotifyBlockMemory: Cleaningup Used Block %lx, Size %d\n", 
					 pFree, afpNotifyDirBlockSize[index]));
				AfpUnlinkDouble(pFree, dfb_Next, dfb_Prev);
				AfpFreeVirtualMemoryPage(pFree);
				afpNotifyBlockAllocCount--;
		}
	}

	AfpSwmrRelease(&afpNotifyBlockLock);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\service\client\client.h ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.	   **/
/********************************************************************/

//***
//
// Filename:
//
// Description: 
//
// History:
//	May 11,1992.	NarenG		Created original version.
//
#ifndef _CLIENT_
#define _CLIENT_

#include <nt.h>
#include <ntrtl.h>
#include <ntseapi.h>
#include <ntlsa.h>
#include <ntsam.h>
#include <ntsamp.h>
#include <nturtl.h>     // needed for winbase.h

#include <windows.h>
#include <rpc.h>
#include <string.h>
#include <afpsvc.h>
#include <afpcomn.h>
#include <admin.h>
#include <macfile.h>
#include <rpcasync.h>



DWORD
AfpRPCBind( 
	IN  LPWSTR 	       lpwsServerName, 
	OUT PAFP_SERVER_HANDLE phAfpServer 
);

#endif  // _CLIENT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\server\volume.h ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	volume.h

Abstract:

	This module contains volume related data structures.

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	25 Apr 1992		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef _VOLUME_
#define _VOLUME_

#define IDINDEX_BUCKETS_DIR_MIN     16
#define IDINDEX_BUCKETS_FILE_MIN    32
#define IDINDEX_BUCKETS_DIR_INIT    64          // no index info? assume ~1000 dirs
#define IDINDEX_BUCKETS_FILE_INIT   1024        // no index info? assume ~20000 files
#define IDINDEX_BUCKETS_32K         32768
#define IDINDEX_BUCKETS_MAX		    65536
#define IDINDEX_CACHE_ENTRIES		512
#define APPL_BUCKETS				16
#define ICON_BUCKETS				16

#define AFP_VOLUME_FIXED_DIR		2		// Volume Signature

// These flags should be consistent with AFP
// The UI (registry) visible definitions are in macfile.h

// #define AFP_VOLUME_READONLY			0x00000001
// #define VOLUME_GUESTACCESS			0x00008000
// #define VOLUME_EXCLUSIVE				0x00010000
// #define AFP_VOLUME_HAS_CUSTOM_ICON	0x00020000
// #define AFP_VOLUME_4GB				0x00040000
// #define AFP_VOLUME_AGE_DFES			0x00080000

#define AFP_VOLUME_HASPASSWORD			0x00000002
#define AFP_VOLUME_SUPPORTS_FILEID		0x00000004
#define AFP_VOLUME_SUPPORTS_CATSRCH		0x00000008
#define AFP_VOLUME_SUPPORTS_BLANKPRV	0x00000010
#define	AFP_VOLUME_MASK_AFP				0x0000001F	// This is all AFP can see

#define	VOLUME_PROCESSING_NOTIFY		0x00000020	// Notify processing under way
#define	VOLUME_NOTIFY_POSTED			0x00000040	// Notify has been posted

#define	VOLUME_STOPPED					0x00000080	// The volume is about to stop
													// Set when server is stopping
#define	VOLUME_DELETED					0x00000100	// This volume is about to be
													// deleted, set when volume is
													// deleted by admin
#define	VOLUME_IDDBHDR_DIRTY			0x00000200	// The header needs to be written ASAP

#define	VOLUME_NTFS						0x00000400	// Volume is an NTFS volume
#define	VOLUME_INTRANSITION				0x00000800	// VolumeAdd is in progress
													// Is not usable still.
#define	VOLUME_SCAVENGER_RUNNING		0x00001000	// Volume is referenced for scavenger
#define	VOLUME_CDFS_INVALID				0x00002000	// If this is set, then no go
#define	VOLUME_INITIAL_CACHE			0x00004000	// Set initially when caching
#define VOLUME_CD_HFS					0x00200000	// volume is a CD with HFS support
#define VOLUME_DISKQUOTA_ENABLED        0x00400000  // diskquota is enabled on this volume
#define VOLUME_NEW_FIRST_PASS           0x00800000  // first pass of id db building
#define VOLUME_SRVR_NOTIF_PENDING       0x01000000  // server notification is pending


// Values for scavenger routines
#define	VOLUME_NTFS_SCAVENGER_INTERVAL	60		// # of seconds
#define	VOLUME_CDFS_SCAVENGER_INTERVAL	60		// # of seconds
//#define	VOLUME_IDDB_UPDATE_INTERVAL	600		// # of seconds
//#define	MAX_INVOCATIONS_TO_SKIP		60		// # of passes
//#define	MAX_CHANGES_BEFORE_WRITE	1000	// # of changes
#define VOLUME_OURCHANGE_AGE			30		// # of seconds
#define OURCHANGE_AGE					10		// # of seconds
//
// The ChangeNotify delay is introduced to prevent the problem where
// the PC side is doing a copyfile or forkize of a macfile, and as
// soon as we receive the notification of the initial create we will
// slap on our AFPInfo stream.  Then when the CopyFile or forkize operation
// gets around to writing its AFPInfo, we do not get notified and will not
// reread the information.  In this case, a mac file copied from one volume
// to another (e.g.) will not show up with the correct finder info.
//
#define	VOLUME_NTFY_DELAY				3		// # of seconds
#define	VOLUME_IDDB_AGE_DELAY			60*60	// # of seconds
#define	VOLUME_IDDB_AGE_GRANULARITY		30		// # of invocations

#define VOLUME_STARTUP_WAIT             5       // # of seconds to wait

// make sure there is enough room to hold a change notification for a
// rename operation on a maximum length win32 path (which is 260 chars)
#define	AFP_VOLUME_NOTIFY_STARTING_BUFSIZE		(2048 - POOL_OVERHEAD)
#define	AFP_VOLUME_NOTIFY_MAX_BUFSIZE		    8*16384

// List of these structures hangs off the volume descriptor to list the
// changes initiated by us that should be filtered from the ChangeNotify
// list of changes.
typedef struct _OurChange
{
	LIST_ENTRY			oc_Link;
	UNICODE_STRING		oc_Path;
	AFPTIME				oc_Time;	// Time when this was queued.
} OUR_CHANGE, *POUR_CHANGE;

// defines for indices into vds_OurChangeList
#define AFP_CHANGE_ACTION_ADDED				0
#define AFP_CHANGE_ACTION_REMOVED			1
#define AFP_CHANGE_ACTION_MODIFIED			2
#define AFP_CHANGE_ACTION_RENAMED			3
#define AFP_CHANGE_ACTION_MODIFIED_STREAM	4
#define	AFP_CHANGE_ACTION_MAX				AFP_CHANGE_ACTION_MODIFIED_STREAM
#define NUM_AFP_CHANGE_ACTION_LISTS			(AFP_CHANGE_ACTION_MAX + 1)

// Convert an NT FILE_ACTION_xxx (ntioapi.h) to an array index into
// vds_OurChangeList array.  Note the close tie between the first 4
// AFP_CHANGE_ACTION_xxx and the values of FILE_ACTION_xxx in ntioapi.h
#define AFP_CHANGE_ACTION(NTAction)	\
	(NTAction == FILE_ACTION_MODIFIED_STREAM ? AFP_CHANGE_ACTION_MODIFIED_STREAM : (NTAction - 1))

/*
 * All changes to the volume descriptor should be protected by vds_VolLock
 * Changes to the Id Db and the desktop Db should be protected by their
 * respective locks.
 *
 * NOTE:  The volume path and name (unicode) must be uppercased, since when
 *		 looking up or adding a volume, we will be holding a spinlock, and
 *		 case insensitive string compares cannot be done at DPC level since
 *		 the codepages are kept in paged memory, and we can't take a page
 *		 fault at DPC level.
 */
#if DBG
#define	VOLDESC_SIGNATURE		*(DWORD *)"VDS"
#define	VALID_VOLDESC(pVolDesc)	(((pVolDesc) != NULL) && \
								 ((pVolDesc)->Signature == VOLDESC_SIGNATURE))
#else
#define	VALID_VOLDESC(pVolDesc)	((pVolDesc) != NULL)
#endif

typedef struct _VolDesc
{
#if	DBG
	DWORD				Signature;
	DWORD				QuadAlign1;
#endif
	struct _VolDesc *	vds_Next;			// Pointer to next volume
	DWORD				vds_UseCount;		// Number of active connections
	DWORD				vds_RefCount;		// Number of references.
											// Cannot be freed till both of the
											// above go to ZERO. Of course there
											// is a RefCount for every UseCount
	// Configuration information.
	DWORD				vds_Flags;			// Volume flags
	LONG				vds_VolId;			// Volume Id for FPOpenVol
	DWORD				vds_MaxUses;		// Maximum opens on a volume
	UNICODE_STRING		vds_Name;			// Volume name in unicode
	UNICODE_STRING		vds_UpCaseName;		// Volume name in UPPER CASE unicode
	ANSI_STRING			vds_MacName;		// Volume name in Mac Ansi
	ANSI_STRING			vds_MacPassword;	// Volume password in Mac Ansi
	UNICODE_STRING		vds_Path;			// File system path to the volume root;
											//  Path is always upper cased


	LARGE_INTEGER		vds_VolumeSize;		// Size of volume
	LARGE_INTEGER		vds_FreeBytes;		// Free space on the volume
#define	vds_pFileObject	vds_hRootDir.fsh_FileObject
	FILESYSHANDLE		vds_hRootDir;		// Handle to open root directory
											// in the servers context. All
											// subsequent opens are relative
											// to this handle
	FILESYSHANDLE		vds_hNWT;			// Handle to Network Trash so it can't
											// be deleted from under us (NTFS)

    DWORD               vds_AllocationBlockSize;
                                            // Bytes per sector

	// The following fields are used by the Id database code and are copied
	// to/from the on-disk idDb header. Protected by vds_VolLock.
	DWORD				vds_LastId;			// Highest id that is assigned
	AFPTIME				vds_CreateTime;		// Creation time for this volume
	AFPTIME				vds_ModifiedTime;	// Modified time for this volume
	AFPTIME				vds_BackupTime;		// Backup time for this volume

#ifdef	AGE_DFES
	DWORD				vds_ScavengerInvocationCnt;
											// Used by the volume scavenger to fire off
											// AfpAgeDfEntries
#endif
	DWORD				vds_RequiredNotifyBufLen;
											// How deep is the tree. This is used by
											// the afpVolumePostnotify to allocate an
											// appropriate buffer.
#ifdef	BLOCK_MACS_DURING_NOTIFYPROC
	DWORD				vds_QueuedNotifyCount;
											// How many change notify buffers
											// have moved into the global queue
											// for this volume -- This value is
											// ONLY touched by the Change
											// Notify thread.
#endif
	SWMR				vds_IdDbAccessLock;	// Access cookie for the id db
											// Protects the vds_pDfexxxBuckets.
	LONG				vds_cScvgrIdDb;		// # of times the update to the Id
											// database was passed up
	DWORD				vds_NumDirDfEntries;// Number of directory DfEntries in this volume
	DWORD				vds_NumFileDfEntries;// Number of file DfEntries in this volume
	struct _DirFileEntry * vds_pDfeRoot;	// Pointer to DFE of root

    DWORD               vds_DirHashTableSize;
    DWORD               vds_FileHashTableSize;
	struct _DirFileEntry ** vds_pDfeDirBucketStart;
	struct _DirFileEntry ** vds_pDfeFileBucketStart;
											// IdDb DfEntry hash buckets
	struct _DirFileEntry * vds_pDfeCache[IDINDEX_CACHE_ENTRIES];
											// IdDb DfEntry cache

	// The following fields are used by the desktop database code
	LONG				vds_cScvgrDt;		// # of times the update to the desktop
											// database was passed up
	SWMR				vds_DtAccessLock;	// Access cookie for the desktop db
											// Protects the following FIVE fields

	// The following fields are copied to/from the on-disk Desktop header.
	// Protected by vds_VolLock.
	LONG				vds_cApplEnts;		// Number of APPL entries
	LONG				vds_cIconEnts;		// Number of ICON entries

	struct _ApplInfo2 *	vds_pApplBuckets[APPL_BUCKETS];
											// APPL hash buckets
	struct _IconInfo *	vds_pIconBuckets[ICON_BUCKETS];
											// ICON hash buckets
	SWMR				vds_ExchangeFilesLock; // Access to the FileId stored
											// in an OpenForkDesc, used by
											// FpExchangeFiles and fork APIs

	LIST_ENTRY			vds_OurChangeList[NUM_AFP_CHANGE_ACTION_LISTS];
											// ^^^
											// Lists of create/delete/move/rename
											// operations initiated by this server

	LIST_ENTRY			vds_ChangeNotifyLookAhead;
											// ^^^
											// List of all completed (but not yet
											// processed) DELETE or RENAME changes
											// on this Volume.

	LIST_ENTRY			vds_DelayedNotifyList;

	struct _OpenForkDesc * vds_pOpenForkDesc;
											// List of open forks for this volume

	LONG				vds_cPrivateNotifies;
											// Count of private notifies
	LONG				vds_maxPrivateNotifies;
											// Keep track of max private notifies
	PBYTE				vds_EnumBuffer;		// Used during notify processing to cache in the tree
	LONG				vds_cOutstandingNotifies;
											// Used in conjunction with above
	PIRP				vds_pIrp;			// Irp used by Notify, we never
											// free this until its time to
											// delete or stop
	DWORD				vds_TimeMustSendNotify;  // time at which we *must* send the notif
	DWORD  				vds_TimeToSendNotify;  // when to send the next notification
	AFP_SPIN_LOCK		vds_VolLock;		// Lock for this volume
    BOOLEAN             MacLimitExceeded;   // True if # folders or volume size exceeds Apple limits
	LARGE_INTEGER			vds_IndxStTime;
} VOLDESC, *PVOLDESC;

// AppleShare limit for files+folders in a volume: 65535
#define APLIMIT_MAX_FOLDERS     0xffff

#define	IS_VOLUME_NTFS(pVolDesc)		(((pVolDesc)->vds_Flags & VOLUME_NTFS) ? True : False)
#define	IS_VOLUME_RO(pVolDesc)			(((pVolDesc)->vds_Flags & AFP_VOLUME_READONLY) ? True : False)
#define	IS_VOLUME_CD_HFS(pVolDesc)		(((pVolDesc)->vds_Flags & VOLUME_CD_HFS) ? True : False)
#define	EXCLUSIVE_VOLUME(pVolDesc)		(((pVolDesc)->vds_Flags & AFP_VOLUME_EXCLUSIVE) ? True : False)
#define IS_VOLUME_AGING_DFES(pVolDesc)	(((pVolDesc)->vds_Flags & AFP_VOLUME_AGE_DFES) ? True : False)

#define	CONN_DESKTOP_CLOSED			0x0000
#define	CONN_DESKTOP_OPENED			0x0001
#define	CONN_CLOSING				0x8000

#if DBG
#define	CONNDESC_SIGNATURE			*(DWORD *)"CDS"
#define	VALID_CONNDESC(pConnDesc)	\
								(((pConnDesc) != NULL) && \
								 ((pConnDesc)->Signature == CONNDESC_SIGNATURE))
#else
#define	VALID_CONNDESC(pConnDesc)	((pConnDesc) != NULL)
#endif

typedef struct _ConnDesc
{
#if	DBG
	DWORD				Signature;
#endif
	LONG				cds_RefCount;	// Number of references to the open volume
	DWORD				cds_Flags;		// One or more of the bits defined above
	struct _ConnDesc *	cds_Next;		// Link to next open volume for this
										// session. Starts from the SDA
	struct _ConnDesc *	cds_NextGlobal;	// Link to next for global list.
										// Starts from AfpConnList
	struct _VolDesc *	cds_pVolDesc;	// Pointer to volume structure
	PSDA				cds_pSda;		// Session that opened this volume
    LARGE_INTEGER       cds_QuotaLimit; // how much is the DiskQuota limit
    LARGE_INTEGER       cds_QuotaAvl;   // how much DiskQuota is available
	DWORD				cds_ConnId;		// Connection Id assigned by the server
	AFPTIME				cds_TimeOpened;	// Time stamp when volume opened
										// in macintosh time
	LONG				cds_cOpenForks;	// Number of open forks from this conn
	PENUMDIR			cds_pEnumDir;	// Current enumerated directory
	AFP_SPIN_LOCK			cds_ConnLock;	// Lock for this connection
} CONNDESC, *PCONNDESC;

#define	IS_CONN_NTFS(pConnDesc)	IS_VOLUME_NTFS((pConnDesc)->cds_pVolDesc)
#define	IS_CONN_CD_HFS(pConnDesc)	IS_VOLUME_CD_HFS((pConnDesc)->cds_pVolDesc)

// Volume parameters bitmap definitions
#define	VOL_BITMAP_ATTR				0x0001
#define	VOL_BITMAP_SIGNATURE		0x0002
#define	VOL_BITMAP_CREATETIME		0x0004
#define	VOL_BITMAP_MODIFIEDTIME		0x0008
#define	VOL_BITMAP_BACKUPTIME		0x0010
#define	VOL_BITMAP_VOLUMEID			0x0020
#define	VOL_BITMAP_BYTESFREE		0x0040
#define	VOL_BITMAP_VOLUMESIZE		0x0080
#define	VOL_BITMAP_VOLUMENAME		0x0100
#define VOL_BITMAP_EXTBYTESFREE     0x0200
#define VOL_BITMAP_EXTBYTESTOTAL    0x0400
#define VOL_BITMAP_ALLOCBLKSIZE     0x0800
#define	VOL_BITMAP_MASK				0x0FFF

typedef	VOID	(FASTCALL *NOTIFYPROCESSOR)(IN PVOID);

// Structure of a notify buffer. The Mdl describes only the Buffer following the struct.
typedef	struct _VolumeNotify
{
#define Notify_NextFree        Notify_NextOverflow
	struct _VolumeNotify *  Notify_NextOverflow;   // Overflow links

	LIST_ENTRY			vn_List;		// Chained from AfpVolumeNotifyQueue[i]
	union
	{
		LIST_ENTRY		vn_DelRenLink;	// Chained from vds_ChangeNotifyLookAhead
										// - VALID ONLY IFF THE ACTION HAS THE PRIVATE BIT CLEAR
		struct
		{
			DWORD		vn_ParentId;	// Afp Id of the parent
										// - VALID ONLY IFF THE ACTION HAS THE PRIVATE BIT SET
			DWORD		vn_TailLength;	// Length in bytes of the last component of the path
										// - VALID ONLY IFF THE ACTION HAS THE PRIVATE BIT SET
		};
	};
	NOTIFYPROCESSOR		vn_Processor;	// Routine that processes the notification
	AFPTIME				vn_TimeStamp;	// When the notify came in
	PVOLDESC			vn_pVolDesc;	// Volume being watched
	DWORD 				vn_StreamId;	// Stream Id
	LONG				vn_VariableLength;	
	// followed by FILE_NOTIFY_INFORMATION
} VOL_NOTIFY, *PVOL_NOTIFY;

// Notify's come in four sizes. This helps in efficiently managing them in a block
// package (see later). THESE SIZES NEED TO BE 4*N, else we run into alignment
// faults on architectures that require it.
#define	NOTIFY_INDEX_TINY			0
#define	NOTIFY_INDEX_SMALL			1
#define	NOTIFY_INDEX_MEDIUM			2
#define	NOTIFY_INDEX_LARGE			3

//
// Make sure each of the sizes below (XXX_U) are multiple of 8
//
#define	NOTIFY_SIZE_TINY			128		// These are lengths for ANSI names
#define	NOTIFY_SIZE_SMALL			256		//		- ditto -
#define	NOTIFY_SIZE_MEDIUM			512		//		- ditto -
#define	NOTIFY_SIZE_LARGE			1024		//		- ditto -	corres. to AFP_FILENAME_LEN

#define	NOTIFY_SIZE_TINY_U			NOTIFY_SIZE_TINY*sizeof(WCHAR)		// These are lengths for UNICODE names
#define	NOTIFY_SIZE_SMALL_U			NOTIFY_SIZE_SMALL*sizeof(WCHAR)	//		- ditto -
#define	NOTIFY_SIZE_MEDIUM_U		NOTIFY_SIZE_MEDIUM*sizeof(WCHAR)	//		- ditto -
#define	NOTIFY_SIZE_LARGE_U			NOTIFY_SIZE_LARGE*sizeof(WCHAR)	//		- ditto -	corres. to AFP_FILENAME_LEN

#define	NOTIFY_USIZE_TO_INDEX(_Size)												\
		(((_Size) <= NOTIFY_SIZE_TINY_U) ? NOTIFY_INDEX_TINY :					\
						(((_Size) <= NOTIFY_SIZE_SMALL_U) ? NOTIFY_INDEX_SMALL :	\
						 (((_Size) <= NOTIFY_SIZE_MEDIUM_U) ? NOTIFY_INDEX_MEDIUM : NOTIFY_INDEX_LARGE)))



// Notify Blocks are aged after NOTIFY_MAX_BLOCK_AGE*NOTIFY_DIR_BLOCK_AGE_TIME seconds (currently 1 min/s)
#define	NOTIFY_MAX_BLOCK_AGE			1
#define	NOTIFY_DIR_BLOCK_AGE_TIME		60		// # of seconds
#define	NOTIFY_MAX_BLOCK_TYPE			4			// For TINY, SMALL, MEDIUM & LARGE

#define VALID_NOTIFY_BLOCK(pDfeBlock)	((pDfeBlock) != NULL)

typedef	struct _Notify_Block
{
	struct _Notify_Block *	dfb_Next;			// Link to next
	struct _Notify_Block **	dfb_Prev;			// Link to previous
	USHORT				dfb_NumFree;		// # of free DFEs in this block
	BYTE				dfb_Age;			// Age of the Block if all are free
	BOOLEAN				dfb_fDir;			// TRUE if it is a Dir DFB - else a file DFB
	PVOL_NOTIFY			dfb_FreeHead;		// Head of the list of free DFEs
} VOL_NOTIFY_BLOCK, *PVOL_NOTIFY_BLOCK, **PPVOL_NOTIFY_BLOCK;

GLOBAL	PVOL_NOTIFY_BLOCK	afpDirNotifyFreeBlockHead[NOTIFY_MAX_BLOCK_TYPE] EQU  { NULL, NULL, NULL };
GLOBAL	PVOL_NOTIFY_BLOCK	afpDirNotifyPartialBlockHead[NOTIFY_MAX_BLOCK_TYPE] EQU  { NULL, NULL, NULL };
GLOBAL	PVOL_NOTIFY_BLOCK	afpDirNotifyUsedBlockHead[NOTIFY_MAX_BLOCK_TYPE] EQU  { NULL, NULL, NULL };

GLOBAL	SHORT	afpNotifyUnicodeBufSize[NOTIFY_MAX_BLOCK_TYPE] EQU		\
	{																	\
		NOTIFY_SIZE_TINY_U, NOTIFY_SIZE_SMALL_U,						\
		NOTIFY_SIZE_MEDIUM_U, NOTIFY_SIZE_LARGE_U						\
	};

GLOBAL	USHORT		afpNotifyDirBlockSize[NOTIFY_MAX_BLOCK_TYPE] EQU		    \
	{																    \
		(USHORT)(sizeof(VOL_NOTIFY) + sizeof(FILE_NOTIFY_INFORMATION) + (AFP_LONGNAME_LEN+1)*sizeof(WCHAR) + NOTIFY_SIZE_TINY_U),	\
		(USHORT)(sizeof(VOL_NOTIFY) + sizeof(FILE_NOTIFY_INFORMATION) + (AFP_LONGNAME_LEN+1)*sizeof(WCHAR) + NOTIFY_SIZE_SMALL_U),	\
		(USHORT)(sizeof(VOL_NOTIFY) + sizeof(FILE_NOTIFY_INFORMATION) + (AFP_LONGNAME_LEN+1)*sizeof(WCHAR) + NOTIFY_SIZE_MEDIUM_U),	\
		(USHORT)(sizeof(VOL_NOTIFY) + sizeof(FILE_NOTIFY_INFORMATION) + (AFP_LONGNAME_LEN+1)*sizeof(WCHAR) + NOTIFY_SIZE_LARGE_U)	\
	};

GLOBAL	USHORT      afpNotifyNumDirBlocks[NOTIFY_MAX_BLOCK_TYPE] EQU		\
	{																\
		(PAGE_SIZE - sizeof(VOL_NOTIFY_BLOCK))/						        \
			(sizeof(VOL_NOTIFY) + sizeof(FILE_NOTIFY_INFORMATION) + (AFP_LONGNAME_LEN+1)*sizeof(WCHAR) + NOTIFY_SIZE_TINY_U),	\
		(PAGE_SIZE - sizeof(VOL_NOTIFY_BLOCK))/						        \
			(sizeof(VOL_NOTIFY) + sizeof(FILE_NOTIFY_INFORMATION) + (AFP_LONGNAME_LEN+1)*sizeof(WCHAR) + NOTIFY_SIZE_SMALL_U),\
		(PAGE_SIZE - sizeof(VOL_NOTIFY_BLOCK))/						        \
			(sizeof(VOL_NOTIFY) + sizeof(FILE_NOTIFY_INFORMATION) + (AFP_LONGNAME_LEN+1)*sizeof(WCHAR) + NOTIFY_SIZE_MEDIUM_U),\
		(PAGE_SIZE - sizeof(VOL_NOTIFY_BLOCK))/						        \
			(sizeof(VOL_NOTIFY) + sizeof(FILE_NOTIFY_INFORMATION) + (AFP_LONGNAME_LEN+1)*sizeof(WCHAR) + NOTIFY_SIZE_LARGE_U)	\
	};

GLOBAL  SWMR    afpNotifyBlockLock EQU { 0 };

GLOBAL	LONG		afpNotifyAllocCount	EQU 0;
GLOBAL	LONG		afpNotifyBlockAllocCount	EQU 0;
GLOBAL	LONG		afpMaxNotifyBlockAllocCount	EQU 0;
GLOBAL	LONG		afpNotify64kBlockCount	EQU 0;


// For maintaining track of delayed transactions
typedef struct _DELAYED_NOTIFY {
	    LIST_ENTRY dn_List;
		UNICODE_STRING filename;
} DELAYED_NOTIFY, *PDELAYED_NOTIFY;

// largest volume id that's currently in use.
GLOBAL	LONG	                afpLargestVolIdInUse    EQU  0;

GLOBAL	LONG			AfpVolCount			EQU 0;		// Total number of volumes
GLOBAL	PVOLDESC		AfpVolumeList		EQU NULL;	// List of volumes
GLOBAL	AFP_SPIN_LOCK		AfpVolumeListLock	EQU {0};	// Lock for AfpVolumeList,
GLOBAL 	SWMR				AfpVolumeListSwmr;	// Access cookie VolumeNotifyList 
														// AfpVolCount,
														// AfpVolumeNotifyList,
														// AfpVolumeNotifyCount

GLOBAL	PCONNDESC		AfpConnList			EQU NULL;	// Global connection list
GLOBAL	AFP_SPIN_LOCK		AfpConnLock			EQU { 0 };	// Lock for AfpConnList

GLOBAL	UNICODE_STRING	AfpNetworkTrashNameU EQU { 0 };

GLOBAL	KQUEUE			AfpVolumeNotifyQueue[NUM_NOTIFY_QUEUES] EQU { 0 };
GLOBAL	LIST_ENTRY		AfpVolumeNotifyList[NUM_NOTIFY_QUEUES] EQU { 0 };
GLOBAL	LIST_ENTRY		AfpVirtualMemVolumeNotifyList[NUM_NOTIFY_QUEUES] EQU { 0 };

// Count of change notification buffers that are in the list
GLOBAL	LONG			AfpNotifyListCount[NUM_NOTIFY_QUEUES] EQU { 0 };
// Count of change notification buffers that have transitioned into the queue.
GLOBAL	LONG			AfpNotifyQueueCount[NUM_NOTIFY_QUEUES] EQU { 0 };
GLOBAL	VOL_NOTIFY		AfpTerminateNotifyThread EQU { 0 };

GLOBAL  LONG            ChangeNotifyQueueLimit EQU 200000;

#define	AfpVolumeQueueChangeNotify(pVolNotify, pNotifyQueue)			\
	{																	\
		KeInsertQueue(pNotifyQueue,										\
					  &(pVolNotify)->vn_List);							\
	}

// Used for PRIVATE notifies of directory ADDED
#define AFP_QUEUE_NOTIFY_IMMEDIATELY	BEGINNING_OF_TIME

#define	AfpVolumeInsertChangeNotifyList(pVolNotify, pVolDesc)			\
	{																	\
		PLIST_ENTRY	pListHead;											\
																		\
		pListHead = &AfpVolumeNotifyList[(pVolDesc)->vds_VolId % NUM_NOTIFY_QUEUES]; \
		if (pVolNotify->vn_TimeStamp != AFP_QUEUE_NOTIFY_IMMEDIATELY)	\
		{																\
			ExInterlockedInsertTailList(pListHead,						\
										&(pVolNotify)->vn_List,			\
										&(AfpVolumeListLock.SpinLock));			\
		}																\
		else															\
		{																\
			ExInterlockedInsertHeadList(pListHead,						\
										&(pVolNotify)->vn_List,			\
										&(AfpVolumeListLock.SpinLock));			\
		}																\
		INTERLOCKED_ADD_ULONG(&AfpNotifyListCount[(pVolDesc)->vds_VolId % NUM_NOTIFY_QUEUES], \
							  1,										\
										&AfpVolumeListLock);			\
	}

#define	AfpIdDbHdrToVolDesc(_pIdDbHdr, _pVolDesc)						\
	{																	\
		(_pVolDesc)->vds_LastId = (_pIdDbHdr)->idh_LastId;				\
		(_pVolDesc)->vds_CreateTime   = (_pIdDbHdr)->idh_CreateTime;	\
		(_pVolDesc)->vds_ModifiedTime = (_pIdDbHdr)->idh_ModifiedTime;	\
		(_pVolDesc)->vds_BackupTime   = (_pIdDbHdr)->idh_BackupTime;	\
	}

#define	AfpVolDescToIdDbHdr(_pVolDesc, _pIdDbHdr)						\
	{																	\
		(_pIdDbHdr)->idh_Signature = AFP_SERVER_SIGNATURE;				\
		(_pIdDbHdr)->idh_Version = AFP_IDDBHDR_VERSION;					\
		(_pIdDbHdr)->idh_LastId = (_pVolDesc)->vds_LastId;				\
		(_pIdDbHdr)->idh_CreateTime   = (_pVolDesc)->vds_CreateTime;	\
		(_pIdDbHdr)->idh_ModifiedTime = (_pVolDesc)->vds_ModifiedTime;	\
		(_pIdDbHdr)->idh_BackupTime   = (_pVolDesc)->vds_BackupTime;	\
	}

#define	AfpDtHdrToVolDesc(_pDtHdr, _pVolDesc)							\
	{																	\
		(_pVolDesc)->vds_cApplEnts = (_pDtHdr)->dtp_cApplEnts;			\
		(_pVolDesc)->vds_cIconEnts = (_pDtHdr)->dtp_cIconEnts;			\
	}

#define	AfpVolDescToDtHdr(_pVolDesc, _pDtHdr)							\
	{																	\
		(_pDtHdr)->dtp_Signature = AFP_SERVER_SIGNATURE;				\
		(_pDtHdr)->dtp_Version = AFP_DESKTOP_VERSION;					\
		(_pDtHdr)->dtp_cApplEnts = (_pVolDesc)->vds_cApplEnts;			\
		(_pDtHdr)->dtp_cIconEnts = (_pVolDesc)->vds_cIconEnts;			\
	}

extern
NTSTATUS
AfpVolumeInit(
	VOID
);

extern
PCONNDESC FASTCALL
AfpConnectionReference(
	IN	PSDA			pSda,
	IN	LONG			VolId
);


extern
PCONNDESC FASTCALL
AfpConnectionReferenceAtDpc(
	IN  PSDA		pSda,
	IN  LONG		VolId
);

extern
PCONNDESC FASTCALL
AfpConnectionReferenceByPointer(
	IN	PCONNDESC		pConnDesc
);


extern
PCONNDESC FASTCALL
AfpReferenceConnectionById(
	IN	 DWORD			ConnId
);


extern
VOID FASTCALL
AfpConnectionDereference(
	IN	PCONNDESC		pConnDesc
);


extern
BOOLEAN FASTCALL
AfpVolumeReference(
	IN	PVOLDESC		pVolDesc
);

extern
PVOLDESC FASTCALL
AfpVolumeReferenceByUpCaseName(
	IN	PUNICODE_STRING	pTargetName
);

extern
AFPSTATUS FASTCALL
AfpVolumeReferenceByPath(
	IN	PUNICODE_STRING	pFDPath,
	OUT	PVOLDESC	*	ppVolDesc
);

extern
VOID FASTCALL
AfpVolumeDereference(
	IN	PVOLDESC		pVolDesc
);

extern
BOOLEAN
AfpVolumeMarkDt(
	IN	PSDA			pSda,
	IN	PCONNDESC		pConnDesc,
	IN	DWORD			OpenState
);


extern
VOID FASTCALL
AfpVolumeSetModifiedTime(
	IN	PVOLDESC		pVolDesc
);


extern
AFPSTATUS FASTCALL
AfpSendServerNotification(
	IN	PVOLDESC		pVolDesc
);

extern
AFPSTATUS
AfpConnectionOpen(
	IN	PSDA			pSda,
	IN	PANSI_STRING	pVolName,
	IN	PANSI_STRING	pVolPass,
	IN	DWORD			Bitmap,
	OUT	PBYTE			pVolParms
);


extern
VOID FASTCALL
AfpConnectionClose(
	IN	PCONNDESC		pConnDesc
);

extern
USHORT FASTCALL
AfpVolumeGetParmsReplyLength(
	IN	DWORD			Bitmap,
	IN	USHORT			NameLen
);


extern
VOID
AfpVolumePackParms(
	IN	PSDA			pSda,
	IN	PVOLDESC		pVolDesc,
	IN	DWORD			Bitmap,
	IN	PBYTE			pVolParms
);

extern
AFPSTATUS
AfpAdmWVolumeAdd(
	IN	OUT	PVOID		Inbuf		OPTIONAL,
	IN	LONG			OutBufLen	OPTIONAL,
	OUT	PVOID			Outbuf		OPTIONAL
);

extern
AFPSTATUS
AfpAdmWVolumeDelete(
	IN	OUT	PVOID		InBuf		OPTIONAL,
	IN	LONG			OutBufLen	OPTIONAL,
	OUT	PVOID			OutBuf		OPTIONAL
);


extern
AFPSTATUS
AfpAdmWConnectionClose(
	IN	OUT	PVOID		InBuf		OPTIONAL,
	IN	LONG			OutBufLen	OPTIONAL,
	OUT	PVOID			OutBuf		OPTIONAL
);

extern
VOID
AfpVolumeStopAllVolumes(
	VOID
);

extern
AFPSTATUS FASTCALL
AfpVolumeBeginIndexing(
    IN  PVOLDESC            pVolDesc
);

extern
NTSTATUS FASTCALL
AfpVolumePostChangeNotify(
	IN	PVOLDESC		pVolDesc
);

extern
VOID FASTCALL
AfpUpdateVolFreeSpaceAndModTime(
	IN	PVOLDESC	pVolDesc,
    IN  BOOLEAN     fUpdateModTime
);

extern
AFPSTATUS FASTCALL
AfpVolumeScavenger(
	IN	PVOLDESC		pVolDesc
);

extern
BOOLEAN FASTCALL
AfpVolumeAbortIndexing(
    IN  PVOLDESC    pVolDesc
);

extern
BOOLEAN FASTCALL
AfpVolumeStopIndexing(
    IN  PVOLDESC    pVolDesc,
	IN  PVOL_NOTIFY pVolNotify
);

extern
PVOL_NOTIFY 
afpAllocNotify(
	IN	LONG						Index,
	IN	BOOLEAN						fDir
);

extern
VOID 
afpFreeNotify(					
	IN	PVOID					pDfEntry
);

extern
AFPSTATUS FASTCALL
afpNotifyBlockAge(
    IN  PPVOL_NOTIFY_BLOCK		pBlockHead
);

extern
VOID
afpFreeNotifyBlockMemory(
);

VOID
AfpVolumeUpdateIdDbAndDesktop(
	IN	PVOLDESC		pVolDesc,
	IN	BOOLEAN			WriteDt,
	IN	BOOLEAN			WriteIdDb,
	IN	PIDDBHDR		pIdDbHdr	OPTIONAL
);

extern
VOID FASTCALL
afpActivateVolume(
    IN  struct _VolDesc *           pVolDesc
);


#ifdef	VOLUME_LOCALS
//
// private routines
//

LOCAL AFPSTATUS FASTCALL
afpVolumeCloseHandleAndFreeDesc(
	IN	PVOLDESC		pVolDesc
);

LOCAL AFPSTATUS FASTCALL
afpVolumeAdd(
	IN	PVOLDESC		pVolDesc
);

LOCAL AFPSTATUS FASTCALL
afpVolumeCheckForDuplicate(
	IN	PVOLDESC		pNewVol
);

LOCAL VOID FASTCALL
afpVolumeGetNewIdAndLinkToList(
	IN	PVOLDESC		pVolDesc
);

LOCAL VOID FASTCALL
afpNudgeCdfsVolume(
	IN	PVOLDESC		pVolDesc
);

LOCAL PCONNDESC FASTCALL
afpConnectionReferenceById(
	IN	DWORD			ConnId
);

LOCAL VOID FASTCALL
afpConnectionGetNewIdAndLinkToList(
	IN	PCONNDESC		pConnDesc
);

LOCAL NTSTATUS
afpVolumeChangeNotifyComplete(
	IN	PDEVICE_OBJECT	pDeviceObject,
	IN	PIRP			pIrp,
	IN	PVOLDESC		pVolDesc
);

LOCAL	DWORD	afpNextConnId = 1;	// Next conn id to assign to an open volume

LOCAL	LONG	afpNumPostedNotifies = 0;

// This is the smallest free volume id that is guaranteed to be free. Access
// to this is via the AfpVolumeListLock.

LOCAL	LONG	afpSmallestFreeVolId = 1;

#endif	// VOLUME_LOCALS

#endif	// _VOLUME_


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\service\client\rpcbind.c ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.	   **/
/********************************************************************/

//***
//
// Filename:	rpcbind.c
//
// Description: Contains the RPC bind and un-bind routines for the AFP
//    		Admin. client-side APIs.
//
// History:
//	June 11,1992.	NarenG		Created original version.
//
#include "client.h"

//**
//
// Call:	AFPSVC_HANDLE_bind
//
// Returns: 	The binding handle is returned to the stub routine.  If the
//	    	binding is unsuccessful, a NULL will be returned.
//
// Description: This routine will simply return what was passed to it. The
//		RPC runtime will pass it a handle of the binding that was
//		obtained by calling AfpRpcBind.
//
handle_t
AFPSVC_HANDLE_bind( 
	IN AFPSVC_HANDLE hServer 
) 
{
    return( (handle_t)hServer );
}

//**
//
// Call:	AFPSVC_HANDLE_unbind
//
// Returns:	none
//
// Description: Unbinds from the RPC interface.
//
void
AFPSVC_HANDLE_unbind( 
	IN AFPSVC_HANDLE   hServer,
    	IN handle_t        hBinding
)
{

    AFP_UNREFERENCED( hServer );
    AFP_UNREFERENCED( hBinding );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\service\client\apistub.c ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.	   **/
/********************************************************************/

//***
//
// Filename:	apistub.c
//
// Description: This module contains the AFP server service API RPC
//		client stubs.
//
// History:
//	June 11,1992.	NarenG		Created original version.
//
#include "client.h"

//**
//
// Call:	AfpAdminConnect
//
// Returns:	NO_ERROR - success
//		non-zero returns from the AfpRPCBind routine.
//		
//
// Description: This is the DLL entrypoint for AfpAdminConnect
//
DWORD
AfpAdminConnect(
	IN  LPWSTR 		lpwsServerName,
	OUT PAFP_SERVER_HANDLE  phAfpServer
)
{
    // Bind with the server
    //
    return( AfpRPCBind( lpwsServerName, phAfpServer ) );

}

//**
//
// Call:	AfpAdminDisconnect
//
// Returns:	none.
//
// Description: This is the DLL entrypoint for AfpAdminDisconnect
//
VOID
AfpAdminDisconnect(
	IN AFP_SERVER_HANDLE hAfpServer
)
{
    RpcBindingFree( (handle_t *)&hAfpServer );
}

//**
//
// Call:	AfpAdminBufferFree
//
// Returns:	none
//
// Description: This is the DLL entrypoint for AfpAdminBufferFree
//
VOID
AfpAdminBufferFree(
	IN PVOID		pBuffer
)
{
    MIDL_user_free( pBuffer );
}

//**
//
// Call:	AfpAdminVolumeEnum
//
// Returns:	NO_ERROR	- success
//		ERROR_INVALID_PARAMETER
//		non-zero returns from AdpAdminrVolumeEnum
//
// Description: This is the DLL entry point for AfpAdminVolumeEnum.
//
DWORD
AfpAdminVolumeEnum(
	IN  AFP_SERVER_HANDLE   hAfpServer,
	OUT LPBYTE  	  	*ppbBuffer,
	IN  DWORD		dwPrefMaxLen,
	OUT LPDWORD		lpdwEntriesRead,
	OUT LPDWORD 	  	lpdwTotalEntries,
	IN  LPDWORD 	  	lpdwResumeHandle
)
{
DWORD			dwRetCode;
VOLUME_INFO_CONTAINER   InfoStruct;

    // Touch all pointers
    //
    try {
	
	*ppbBuffer 	  = NULL;
	*lpdwEntriesRead  = 0;
	*lpdwTotalEntries = 0;

	if ( lpdwResumeHandle )
	    *lpdwResumeHandle;
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {
	return( ERROR_INVALID_PARAMETER );
    }

    InfoStruct.dwEntriesRead = 0;
    InfoStruct.pBuffer       = NULL;

    RpcTryExcept{
	
	dwRetCode = AfpAdminrVolumeEnum( hAfpServer,
    					 &InfoStruct,
					 dwPrefMaxLen,
					 lpdwTotalEntries,
					 lpdwResumeHandle );

	if ( InfoStruct.pBuffer != NULL ) {
    	    *ppbBuffer 	     = (LPBYTE)(InfoStruct.pBuffer);
	    *lpdwEntriesRead = InfoStruct.dwEntriesRead;
	}
	else
	    *lpdwEntriesRead = 0;

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
	dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    return( dwRetCode );
}

//**
//
// Call:	AfpAdminVolumeSetInfo
//
// Returns:	NO_ERROR	- success
//		ERROR_INVALID_PARAMETER
//		non-zero return codes from AfpAdminrVolumeSetInfo
//
// Description: This is the DLL entrypoint for AfpAdminSetInfo
//
DWORD
AfpAdminVolumeSetInfo(
	IN  AFP_SERVER_HANDLE hAfpServer,
	IN  LPBYTE  	      pbBuffer,
    	IN  DWORD	      dwParmNum
)
{
DWORD	dwRetCode;

    if ( dwParmNum == 0 )
	return( ERROR_INVALID_PARAMETER );
	
    if ( !IsAfpVolumeInfoValid( dwParmNum, (PAFP_VOLUME_INFO)pbBuffer ) )
	return( ERROR_INVALID_PARAMETER );

    RpcTryExcept{
	
	dwRetCode = AfpAdminrVolumeSetInfo( hAfpServer,
		       			    (PAFP_VOLUME_INFO)pbBuffer,
					    dwParmNum );

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
	dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    return( dwRetCode );

}

//**
//
// Call:	AfpAdminVolumeGetInfo
//
// Returns:	NO_ERROR	- success
//		ERROR_INVALID_PARAMETER
//		non-zero return codes from AfpAdminrVolumeGetInfo
//
// Description: This is the DLL entrypoint for AfpAdminVolumeGetInfo
//
DWORD
AfpAdminVolumeGetInfo(
	IN  AFP_SERVER_HANDLE hAfpServer,
	IN  LPWSTR	      lpwsVolumeName ,
	OUT LPBYTE  	      *ppbBuffer
)
{
DWORD	dwRetCode;

    if ( !IsAfpVolumeNameValid( lpwsVolumeName ) )
	return( ERROR_INVALID_PARAMETER );

    // Make sure that all pointers passed in are valid
    //
    try {
    	*ppbBuffer = NULL;
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {
	return( ERROR_INVALID_PARAMETER );
    }

    RpcTryExcept{
	
	dwRetCode = AfpAdminrVolumeGetInfo( hAfpServer,
					    lpwsVolumeName,
					    (PAFP_VOLUME_INFO*)ppbBuffer );

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
	dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    return( dwRetCode );
}

//**
//
// Call:	AfpAdminVolumeDelete
//
// Returns:	NO_ERROR	- success
//		ERROR_INVALID_PARAMETER
//		non-zero return codes from AfpAdminrVolumeDelete
//
// Description: This is the DLL entrypoint for AfpAdminVolumeDelete
//
DWORD
AfpAdminVolumeDelete(
	IN  AFP_SERVER_HANDLE hAfpServer,
	IN  LPWSTR	      lpwsVolumeName
)
{
DWORD	dwRetCode;

    if ( !IsAfpVolumeNameValid( lpwsVolumeName ) )
	return( ERROR_INVALID_PARAMETER );

    RpcTryExcept{
	
	dwRetCode = AfpAdminrVolumeDelete( hAfpServer, lpwsVolumeName );

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
	dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    return( dwRetCode );
}

//**
//
// Call:	AfpAdminVolumeAdd
//
// Returns:	NO_ERROR	- success
//		ERROR_INVALID_PARAMETER
//		non-zero return codes from AfpAdminrVolumeAdd
//
// Description: This is the DLL entrypoint for AfpAdminVolumeAdd
//
DWORD
AfpAdminVolumeAdd(
	IN  AFP_SERVER_HANDLE    hAfpServer,
	IN  LPBYTE  	         pbBuffer
)
{
DWORD	dwRetCode;

    if ( !IsAfpVolumeInfoValid( AFP_VALIDATE_ALL_FIELDS,
				(PAFP_VOLUME_INFO)pbBuffer ) )
	return( ERROR_INVALID_PARAMETER );

    RpcTryExcept{
	
	dwRetCode = AfpAdminrVolumeAdd(hAfpServer, (PAFP_VOLUME_INFO)pbBuffer);

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
	dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    return( dwRetCode );
}

//**
//
// Call:	AfpAdminInvalidVolumeEnum
//
// Returns:	NO_ERROR	- success
//		ERROR_INVALID_PARAMETER
//		non-zero returns from AdpAdminrInvalidVolumeEnum
//
// Description: This is the DLL entry point for AfpAdminInvalidVolumeEnum.
//
DWORD
AfpAdminInvalidVolumeEnum(
	IN  AFP_SERVER_HANDLE   hAfpServer,
	OUT LPBYTE  	  	*ppbBuffer,
	OUT LPDWORD		lpdwEntriesRead
)
{
DWORD			dwRetCode;
VOLUME_INFO_CONTAINER   InfoStruct;

    // Touch all pointers
    //
    try {
	
	*ppbBuffer 	  = NULL;
	*lpdwEntriesRead  = 0;

    }
    except( EXCEPTION_EXECUTE_HANDLER ) {
	return( ERROR_INVALID_PARAMETER );
    }

    InfoStruct.dwEntriesRead = 0;
    InfoStruct.pBuffer       = NULL;

    RpcTryExcept{
	
	dwRetCode = AfpAdminrInvalidVolumeEnum( hAfpServer, &InfoStruct );

	if ( InfoStruct.pBuffer != NULL ) {
    	    *ppbBuffer 	     = (LPBYTE)(InfoStruct.pBuffer);
	    *lpdwEntriesRead = InfoStruct.dwEntriesRead;
	}
	else
	    *lpdwEntriesRead = 0;

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
	dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    return( dwRetCode );
}

//**
//
// Call:	AfpAdminInvalidVolumeDelete
//
// Returns:	NO_ERROR	- success
//		ERROR_INVALID_PARAMETER
//		non-zero return codes from AfpAdminrInvalidVolumeDelete
//
// Description: This is the DLL entrypoint for AfpAdminInvalidVolumeDelete
//
DWORD
AfpAdminInvalidVolumeDelete(
	IN  AFP_SERVER_HANDLE hAfpServer,
	IN  LPWSTR	      lpwsVolumeName
)
{
DWORD	dwRetCode;

    if ( !IsAfpVolumeNameValid( lpwsVolumeName ) )
	return( ERROR_INVALID_PARAMETER );

    RpcTryExcept{
	
	dwRetCode = AfpAdminrInvalidVolumeDelete( hAfpServer, lpwsVolumeName );

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
	dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    return( dwRetCode );
}

//**
//
// Call:	AfpAdminDirectoryGetInfo
//
// Returns:	NO_ERROR	- success
//		ERROR_INVALID_PARAMETER
//		non-zero return codes from AfpAdminrDirectoryGetInfo
//
// Description: This is the DLL entrypoint for AfpAdminDirectoryGetInfo
//
DWORD
AfpAdminDirectoryGetInfo(
	IN  AFP_SERVER_HANDLE   hAfpServer,
	IN  LPWSTR		lpwsPath,
	OUT LPBYTE  	        *ppbBuffer
)
{
DWORD	dwRetCode;

    // Make sure that all pointers passed in are valid
    //
    try {
	STRLEN( lpwsPath );
    	*ppbBuffer = NULL;
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {
	return( ERROR_INVALID_PARAMETER );
    }

    RpcTryExcept{
	
	dwRetCode = AfpAdminrDirectoryGetInfo(hAfpServer,
			  	              lpwsPath,
					      (PAFP_DIRECTORY_INFO*)ppbBuffer);

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
	dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    return( dwRetCode );
}

//**
//
// Call:	AfpAdminDirectorySetInfo
//
// Returns:	NO_ERROR	- success
//		ERROR_INVALID_PARAMETER
//		non-zero return codes from AfpAdminrDirectorySetInfo
//
// Description: This is the DLL entrypoint for AfpAdminDirectorySetInfo
//
DWORD
AfpAdminDirectorySetInfo(
	IN  AFP_SERVER_HANDLE   hAfpServer,
	IN  LPBYTE  	        pbBuffer,
	IN  DWORD		dwParmNum
)
{
DWORD	dwRetCode;

    if ( dwParmNum == 0 )
	return( ERROR_INVALID_PARAMETER );

    if ( !IsAfpDirInfoValid( dwParmNum, (PAFP_DIRECTORY_INFO)pbBuffer ) )
	return( ERROR_INVALID_PARAMETER );

    RpcTryExcept{
	
	dwRetCode = AfpAdminrDirectorySetInfo(hAfpServer,
					      (PAFP_DIRECTORY_INFO)pbBuffer,
					      dwParmNum );

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
	dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    return( dwRetCode );
}

//**
//
// Call:	AfpAdminServerGetInfo
//
// Returns:	NO_ERROR	- success
//		ERROR_INVALID_PARAMETER
//		non-zero return codes from AfpAdminrServerGetInfo
//
// Description: This is the DLL entrypoint for AfpAdminServerGetInfo
//
DWORD
AfpAdminServerGetInfo(
	IN  AFP_SERVER_HANDLE   hAfpServer,
	OUT LPBYTE  	        *ppbBuffer
)
{
DWORD	dwRetCode;

    // Make sure that all pointers passed in are valid
    //
    try {
    	*ppbBuffer = NULL;
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {
	return( ERROR_INVALID_PARAMETER );
    }

    RpcTryExcept{
	
	dwRetCode = AfpAdminrServerGetInfo( hAfpServer,
					    (PAFP_SERVER_INFO*)ppbBuffer);

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
	dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    return( dwRetCode );
}

//**
//
// Call:	AfpAdminServerSetInfo
//
// Returns:	NO_ERROR	- success
//		ERROR_INVALID_PARAMETER
//		non-zero return codes from AfpAdminrServerSetInfo
//
// Description: This is the DLL entrypoint for AfpAdminServerSetInfo
//
DWORD
AfpAdminServerSetInfo(
	IN  AFP_SERVER_HANDLE   hAfpServer,
	IN  LPBYTE  	        pbBuffer,
	IN  DWORD		dwParmNum
)
{
DWORD	dwRetCode;

    if ( dwParmNum == 0 )
	return( ERROR_INVALID_PARAMETER );

    if ( !IsAfpServerInfoValid( dwParmNum, (PAFP_SERVER_INFO)pbBuffer ) )
	return( ERROR_INVALID_PARAMETER );

    RpcTryExcept{
	
	dwRetCode = AfpAdminrServerSetInfo( hAfpServer,
					    (PAFP_SERVER_INFO)pbBuffer,
					    dwParmNum );

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
	dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    return( dwRetCode );
}

//**
//
// Call:	AfpAdminSessionEnum
//
// Returns:	NO_ERROR	- success
//		ERROR_INVALID_PARAMETER
//		non-zero return codes from AfpAdminrSessionEnum
//
// Description: This is the DLL entry point for AfpAdminSessionEnum.
//
DWORD
AfpAdminSessionEnum(
	IN  AFP_SERVER_HANDLE 	hAfpServer,
	OUT LPBYTE  	      	*ppbBuffer,
	IN  DWORD		dwPrefMaxLen,
	OUT LPDWORD	   	lpdwEntriesRead,
	OUT LPDWORD 	   	lpdwTotalEntries,
	IN  LPDWORD 	   	lpdwResumeHandle
)
{
DWORD			 dwRetCode;
SESSION_INFO_CONTAINER   InfoStruct;

    // Touch all pointers
    //
    try {
	
	*ppbBuffer 	  = NULL;
	*lpdwEntriesRead  = 0;
	*lpdwTotalEntries = 0;

	if ( lpdwResumeHandle )
	    *lpdwResumeHandle;
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {
	return( ERROR_INVALID_PARAMETER );
    }

    InfoStruct.dwEntriesRead = 0;
    InfoStruct.pBuffer       = NULL;

    RpcTryExcept{
	
	dwRetCode = AfpAdminrSessionEnum( hAfpServer,
					  &InfoStruct,
					  dwPrefMaxLen,
					  lpdwTotalEntries,
					  lpdwResumeHandle );

	if ( InfoStruct.pBuffer != NULL ) {
    	    *ppbBuffer 	     = (LPBYTE)(InfoStruct.pBuffer);
	    *lpdwEntriesRead = InfoStruct.dwEntriesRead;
	}
	else
	    *lpdwEntriesRead = 0;

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
	dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    return( dwRetCode );
}

//**
//
// Call:	AfpAdminSessionClose
//
// Returns:	NO_ERROR	- success
//		non-zero return codes from AfpAdminrSessionClose
//
// Description: This is the DLL entrypoint for AfpAdminSessionClose
//
DWORD
AfpAdminSessionClose(
	IN  AFP_SERVER_HANDLE 	hAfpServer,
	IN  DWORD		dwSessionId
)
{
DWORD	dwRetCode;

    RpcTryExcept{
	
	dwRetCode = AfpAdminrSessionClose( hAfpServer, dwSessionId );

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
	dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    return( dwRetCode );
}

//**
//
// Call:	AfpAdminConnectionEnum
//
// Returns:	NO_ERROR	- success
//		ERROR_INVALID_PARAMETER
//		non-zero return codes from AfpAdminrConnectionEnum
//
// Description: This is the DLL entry point for AfpAdminConnectionEnum.
//
DWORD
AfpAdminConnectionEnum(
	IN  AFP_SERVER_HANDLE 	hAfpServer,
	OUT LPBYTE  	   	*ppbBuffer,
	IN  DWORD		dwFilter,
	IN  DWORD		dwId,
	IN  DWORD		dwPrefMaxLen,
	OUT LPDWORD	   	lpdwEntriesRead,
	OUT LPDWORD 	   	lpdwTotalEntries,
	IN  LPDWORD 	   	lpdwResumeHandle
)
{
DWORD		      dwRetCode;
CONN_INFO_CONTAINER   InfoStruct;

    switch( dwFilter ){

    case AFP_FILTER_ON_VOLUME_ID:
    case AFP_FILTER_ON_SESSION_ID:
	
	if ( dwId == 0 )
	    return( ERROR_INVALID_PARAMETER );
	
	break;

    case AFP_NO_FILTER:
	break;

    default:
	return( ERROR_INVALID_PARAMETER );
	
    }

    // Touch all pointers
    //
    try {
	
	*ppbBuffer 	  = NULL;
	*lpdwEntriesRead  = 0;
	*lpdwTotalEntries = 0;


	if ( lpdwResumeHandle )
	    *lpdwResumeHandle;
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {
	return( ERROR_INVALID_PARAMETER );
    }

    InfoStruct.dwEntriesRead = 0;
    InfoStruct.pBuffer       = NULL;

    RpcTryExcept{
	
	dwRetCode = AfpAdminrConnectionEnum( hAfpServer,
					     &InfoStruct,
					     dwFilter,		
					     dwId,
					     dwPrefMaxLen,
					     lpdwTotalEntries,
					     lpdwResumeHandle );

	if ( InfoStruct.pBuffer != NULL ) {
    	    *ppbBuffer       = (LPBYTE)(InfoStruct.pBuffer);
	    *lpdwEntriesRead = InfoStruct.dwEntriesRead;
	}
	else
	    *lpdwEntriesRead = 0;
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
	dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    return( dwRetCode );
}

//**
//
// Call:	AfpAdminConnectionClose
//
// Returns:	NO_ERROR	- success
//		non-zero return codes from AfpAdminrConnectionClose
//
// Description: This is the DLL entrypoint for AfpAdminConnectionClose
//
DWORD
AfpAdminConnectionClose(
	IN  AFP_SERVER_HANDLE   hAfpServer,
	IN  DWORD		dwConnectionId
)
{
DWORD	dwRetCode;

    RpcTryExcept{
	
	dwRetCode = AfpAdminrConnectionClose( hAfpServer, dwConnectionId );

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
	dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    return( dwRetCode );
}

//**
//
// Call:	AfpAdminFileEnum
//
// Returns:	NO_ERROR	- success
//		ERROR_INVALID_PARAMETER
//		non-zero return codes from AfpAdminrFileEnum
//
// Description: This is the DLL entry point for AfpAdminFileEnum.
//
DWORD
AfpAdminFileEnum(
	IN  AFP_SERVER_HANDLE   hAfpServer,
	OUT LPBYTE  	   	*ppbBuffer,
	IN  DWORD		dwPrefMaxLen,
	OUT LPDWORD	   	lpdwEntriesRead,
	OUT LPDWORD 	   	lpdwTotalEntries,
	IN  LPDWORD 	   	lpdwResumeHandle
)
{
DWORD		      dwRetCode;
FILE_INFO_CONTAINER   InfoStruct;

    // Touch all pointers
    //
    try {
	
	*ppbBuffer 	  = NULL;
	*lpdwEntriesRead  = 0;
	*lpdwTotalEntries = 0;

	if ( lpdwResumeHandle )
	    *lpdwResumeHandle;
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {
	return( ERROR_INVALID_PARAMETER );
    }

    InfoStruct.dwEntriesRead = 0;
    InfoStruct.pBuffer       = NULL;


    RpcTryExcept{
	
	dwRetCode = AfpAdminrFileEnum(   hAfpServer,
					 &InfoStruct,
					 dwPrefMaxLen,
					 lpdwTotalEntries,
					 lpdwResumeHandle );

	if ( InfoStruct.pBuffer != NULL ) {
    	    *ppbBuffer       = (LPBYTE)(InfoStruct.pBuffer);
	    *lpdwEntriesRead = InfoStruct.dwEntriesRead;
	}
	else
	    *lpdwEntriesRead = 0;
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
	dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    return( dwRetCode );
}

//**
//
// Call:	AfpAdminFileClose
//
// Returns:	NO_ERROR	- success
//		non-zero return codes from AfpAdminrFileClose
//
// Description: This is the DLL entrypoint for AfpAdminFileClose
//
DWORD
AfpAdminFileClose(
	IN  AFP_SERVER_HANDLE    hAfpServer,
	IN  DWORD		 dwFileId
)
{
DWORD	dwRetCode;

    RpcTryExcept{
	
	dwRetCode = AfpAdminrFileClose( hAfpServer, dwFileId );

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
	dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    return( dwRetCode );
}

//**
//
// Call:	AfpAdminETCMapGetInfo
//
// Returns:	NO_ERROR	- success
//		ERROR_INVALID_PARAMETER
//		non-zero return codes from AfpAdminrETCMapGetInfo
//
// Description: This is the DLL entry point for AfpAdminETCMapGetInfo.
//
DWORD
AfpAdminETCMapGetInfo(
	IN  AFP_SERVER_HANDLE   hAfpServer,
	OUT LPBYTE  	   	*ppbBuffer
)
{
DWORD	dwRetCode;

    try {

    	*ppbBuffer = NULL;
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {
	return( ERROR_INVALID_PARAMETER );
    }

    RpcTryExcept{
	
	dwRetCode = AfpAdminrETCMapGetInfo( hAfpServer,
					    (PAFP_ETCMAP_INFO*)ppbBuffer
					  );

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
	dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    return( dwRetCode );
}

//**
//
// Call:	AfpAdminETCMapAdd
//
// Returns:	NO_ERROR	- success
//		ERROR_INVALID_PARAMETER
//		non-zero return codes from AfpAdminrETCMapAdd
//
// Description: This is the DLL entrypoint for AfpAdminETCMapAdd
//
DWORD
AfpAdminETCMapAdd(
	IN  AFP_SERVER_HANDLE   hAfpServer,
      	IN  PAFP_TYPE_CREATOR   pAfpTypeCreator
)
{
DWORD	dwRetCode;

    if ( !IsAfpTypeCreatorValid( pAfpTypeCreator ) )
	return( ERROR_INVALID_PARAMETER );

    RpcTryExcept{
	
	dwRetCode =  AfpAdminrETCMapAdd( hAfpServer, pAfpTypeCreator );

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
	dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    return( dwRetCode );
}

//**
//
// Call:	AfpAdminETCMapDelete
//
// Returns:	NO_ERROR	- success
//		ERROR_INVALID_PARAMETER
//		non-zero return codes from AfpAdminrETCMapDelete
//
// Description: This is the DLL entrypoint for AfpAdminETCMapDelete
//
DWORD
AfpAdminETCMapDelete(
	IN  AFP_SERVER_HANDLE   hAfpServer,
      	IN  PAFP_TYPE_CREATOR   pAfpTypeCreator
)
{
DWORD	dwRetCode;

    if ( !IsAfpTypeCreatorValid( pAfpTypeCreator ) )
	return( ERROR_INVALID_PARAMETER );

    RpcTryExcept{
	
	dwRetCode =  AfpAdminrETCMapDelete( hAfpServer, pAfpTypeCreator );

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
	dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    return( dwRetCode );

}

//**
//
// Call:	AfpAdminrETCMapSetInfo
//
// Returns:	NO_ERROR	- success
//		ERROR_INVALID_PARAMETER
//		non-zero return codes from AfpAdminrETCMapSetInfo
//
// Description: This is the DLL entrypoint for AfpAdminETCMapSetInfo
//
DWORD
AfpAdminETCMapSetInfo(
	IN  AFP_SERVER_HANDLE   hAfpServer,
      	IN  PAFP_TYPE_CREATOR   pAfpTypeCreator
)
{
DWORD	dwRetCode;

    if ( !IsAfpTypeCreatorValid( pAfpTypeCreator ) )
	return( ERROR_INVALID_PARAMETER );

    RpcTryExcept{
	
	dwRetCode =  AfpAdminrETCMapSetInfo( hAfpServer, pAfpTypeCreator );

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
	dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    return( dwRetCode );
}

//**
//
// Call:	AfpAdminETCMapAssociate
//
// Returns:	NO_ERROR	- success
//		ERROR_INVALID_PARAMETER
//		non-zero return codes from AfpAdminrETCMapAssociate
//
// Description: This is the DLL entrypoint for AfpAdminETCMapAssociate
//
DWORD
AfpAdminETCMapAssociate(
	IN  AFP_SERVER_HANDLE   hAfpServer,
      	IN  PAFP_TYPE_CREATOR   pAfpTypeCreator,
      	IN  PAFP_EXTENSION      pAfpExtension
)
{
DWORD	dwRetCode;

    if ( !IsAfpTypeCreatorValid( pAfpTypeCreator ) )
	return( ERROR_INVALID_PARAMETER );

    if ( !IsAfpExtensionValid( pAfpExtension ) )
	return( ERROR_INVALID_PARAMETER );

    RpcTryExcept{
	
	dwRetCode =  AfpAdminrETCMapAssociate(  hAfpServer,
						pAfpTypeCreator,
						pAfpExtension
				 	     );

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
	dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    return( dwRetCode );
}

//**
//
// Call:	AfpAdminStatisticsGet
//
// Returns:	NO_ERROR	- success
//		ERROR_INVALID_PARAMETER
//		non-zero return codes from AfpAdminrStatisticsGet
//
// Description: This is the DLL entrypoint for AfpAdminStatisticsGet
//
DWORD
AfpAdminStatisticsGet(
	IN  AFP_SERVER_HANDLE   hAfpServer,
	OUT LPBYTE  	   	*ppbBuffer
)
{
DWORD	dwRetCode;

    try {

    	*ppbBuffer = NULL;
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {
	return( ERROR_INVALID_PARAMETER );
    }

    RpcTryExcept{
	
	dwRetCode =  AfpAdminrStatisticsGet( hAfpServer,
					     (PAFP_STATISTICS_INFO*)ppbBuffer );

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
	dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    return( dwRetCode );
}

//**
//
// Call:	AfpAdminStatisticsGetEx
//
// Returns:	NO_ERROR	- success
//		ERROR_INVALID_PARAMETER
//		non-zero return codes from AfpAdminrStatisticsGetEx
//
// Description: This is the DLL entrypoint for AfpAdminStatisticsGetEx
//
DWORD
AfpAdminStatisticsGetEx(
	IN  AFP_SERVER_HANDLE   hAfpServer,
	OUT LPBYTE  	   	*ppbBuffer
)
{
DWORD	dwRetCode;

    try {

    	*ppbBuffer = NULL;
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {
	return( ERROR_INVALID_PARAMETER );
    }

    RpcTryExcept{
	
	dwRetCode =  AfpAdminrStatisticsGetEx( hAfpServer,
					     (PAFP_STATISTICS_INFO_EX *)ppbBuffer );

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
	dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    return( dwRetCode );
}

//**
//
// Call:	AfpAdminStatisticsClear
//
// Returns:	NO_ERROR	- success
//		ERROR_INVALID_PARAMETER
//		non-zero return codes from AfpAdminrStatisticsClear
//
// Description: This is the DLL entrypoint for AfpAdminStatisticsClear
//
DWORD
AfpAdminStatisticsClear(
	IN  AFP_SERVER_HANDLE   hAfpServer
)
{
DWORD	dwRetCode;

    RpcTryExcept{
	
	dwRetCode =  AfpAdminrStatisticsClear( hAfpServer );

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
	dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    return( dwRetCode );
}

//**
//
// Call:	AfpAdminProfileGet
//
// Returns:	NO_ERROR	- success
//		ERROR_INVALID_PARAMETER
//		non-zero return codes from AfpAdminrProfileGet
//
// Description: This is the DLL entrypoint for AfpAdminProfileGet
//
DWORD
AfpAdminProfileGet(
	IN  AFP_SERVER_HANDLE   hAfpServer,
	OUT LPBYTE  	   	*ppbBuffer
)
{
DWORD	dwRetCode;

    try {

    	*ppbBuffer = NULL;
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {
	return( ERROR_INVALID_PARAMETER );
    }

    RpcTryExcept{
	
	dwRetCode =  AfpAdminrProfileGet( hAfpServer,
					     (PAFP_PROFILE_INFO*)ppbBuffer );

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
	dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    return( dwRetCode );
}

//**
//
// Call:	AfpAdminProfileClear
//
// Returns:	NO_ERROR	- success
//		ERROR_INVALID_PARAMETER
//		non-zero return codes from AfpAdminrProfileClear
//
// Description: This is the DLL entrypoint for AfpAdminProfileClear
//
DWORD
AfpAdminProfileClear(
	IN  AFP_SERVER_HANDLE   hAfpServer
)
{
DWORD	dwRetCode;

    RpcTryExcept{
	
	dwRetCode =  AfpAdminrProfileClear( hAfpServer );

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
	dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    return( dwRetCode );
}

//**
//
// Call:	AfpAdminMessageSend
//
// Returns:	NO_ERROR	- success
//		ERROR_INVALID_PARAMETER
//		non-zero return codes from AfpAdminrMessageSend
//
// Description: This is the DLL entrypoint for AfpAdminMessageSend
//
DWORD
AfpAdminMessageSend(
	IN  AFP_SERVER_HANDLE   hAfpServer,
	IN  PAFP_MESSAGE_INFO 	pAfpMessageInfo
)
{
DWORD	dwRetCode;


    try {

    	*pAfpMessageInfo;
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {
	return( ERROR_INVALID_PARAMETER );
    }

    if ( !IsAfpMsgValid( pAfpMessageInfo->afpmsg_text ) )
	return( ERROR_INVALID_PARAMETER );

    RpcTryExcept{
	
	dwRetCode =  AfpAdminrMessageSend( hAfpServer, 	
					   pAfpMessageInfo );

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
	dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    return( dwRetCode );
}

//**
//
// Call:	AfpAdminFinderSetInfo
//
// Returns:	NO_ERROR	- success
//		ERROR_INVALID_PARAMETER
//		non-zero return codes from AfpAdminrFinderSetInfo
//
// Description: This is the DLL entrypoint for AfpAdminFinderSetInfo
//
DWORD
AfpAdminFinderSetInfo(
	IN  AFP_SERVER_HANDLE   hAfpServer,
	IN  LPWSTR	 	pType,
	IN  LPWSTR	 	pCreator,
	IN  LPWSTR	 	pData,
	IN  LPWSTR	 	pResource,
	IN  LPWSTR	 	pTarget,
 	IN  DWORD		dwParmNum
)
{
DWORD	dwRetCode;

    if ( !IsAfpFinderInfoValid( pType, 
				pCreator, 
				pData, 
				pResource, 
				pTarget, 
				dwParmNum ) )
	return( ERROR_INVALID_PARAMETER );

    if ( pType == NULL )
	pType = (LPWSTR)TEXT("");

    if ( pCreator == NULL )
	pCreator = (LPWSTR)TEXT("");

    if ( pData == NULL )
	pData = (LPWSTR)TEXT("");

    if ( pResource == NULL )
	pResource = (LPWSTR)TEXT("");

    RpcTryExcept{
	
	dwRetCode =  AfpAdminrFinderSetInfo( hAfpServer, 
					     pType, 
					     pCreator, 
					     pData,
					     pResource,
					     pTarget,
					     dwParmNum );

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
	dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    return( dwRetCode );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\service\client\rpcutil.c ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.	   **/
/********************************************************************/

//***
//
// Filename:	rpcutil.c
//
// Description: Contains RPC utiliry routines.
//
// History:
//	May 11,1992.	NarenG		Created original version.
//
#include "client.h"


//**
//
// Call:	AfpRPCBind
//
// Returns:	NO_ERROR			- success
//		ERROR_NOT_ENOUGH_MEMORY
//	        AFPERR_InvalidComputername 
//		non-sero returns from RPC calls.
//
// Description: This routine is called when it is necessary to bind to a server.
//    		The binding is done to allow impersonation by the server since 
//		that is necessary for the API calls.
//
DWORD
AfpRPCBind( 
	IN  LPWSTR 		lpwsServerName, 
	OUT PAFP_SERVER_HANDLE  phAfpServer 
)
{
RPC_STATUS  RpcStatus;
LPWSTR      lpwsStringBinding;
LPWSTR      lpwsEndpoint;

    // We need to concatenate \pipe\ to the front of the service
    // name.
    //
    lpwsEndpoint = (LPWSTR)LocalAlloc( 0, sizeof(NT_PIPE_PREFIX) +  
				((STRLEN(AFP_SERVICE_NAME)+1)*sizeof(WCHAR)));
    if ( lpwsEndpoint == NULL) 
       return( ERROR_NOT_ENOUGH_MEMORY );

    STRCPY( lpwsEndpoint, NT_PIPE_PREFIX );
    STRCAT( lpwsEndpoint, AFP_SERVICE_NAME );

    RpcStatus = RpcStringBindingCompose( 
				NULL, 
				TEXT("ncacn_np"), 
				lpwsServerName,
                    		lpwsEndpoint, 
			 	TEXT("Security=Impersonation Static True"),
				&lpwsStringBinding);
    LocalFree( lpwsEndpoint );

    if ( RpcStatus != RPC_S_OK ) 
       return( I_RpcMapWin32Status( RpcStatus ) );

    RpcStatus = RpcBindingFromStringBinding( lpwsStringBinding, 
					     (handle_t *)phAfpServer );

    RpcStringFree( &lpwsStringBinding );

    if ( RpcStatus != RPC_S_OK ) {
	
	if ( ( RpcStatus == RPC_S_INVALID_ENDPOINT_FORMAT ) 
	     ||
	     ( RpcStatus == RPC_S_INVALID_NET_ADDR ) ) 

	    return( (DWORD)AFPERR_InvalidComputername );
	else
       	    return( I_RpcMapWin32Status( RpcStatus ) );
	
    }
	
    return( NO_ERROR );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\service\idl\import.h ===
/********************************************************************/
/**               Copyright(c) 1991 Microsoft Corporation.	   **/
/********************************************************************/

//***
//
// Filename: 	import.h
//
// Description: This file allows us to include standard system header files 
//		in the .idl file.  The main .idl file imports a file called 
//		import.idl. This allows the .idl file to use the types defined 
//		in these header files. It also causes the following line to 
//		be added in the MIDL generated header file:
//
//    		#include "import.h"
//
//   		Thus these types are available to the RPC stub routines as well.
//
// History:
//	June 11,1992.	NarenG		Created original version.
//


#include <windef.h>

#ifdef MIDL_PASS
#define LPWSTR      [string] wchar_t*
#define BOOL        DWORD
#endif

#include <macfile.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\service\idl\afpcomn.h ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.	   **/
/********************************************************************/

//***
//
// Filename:	afpcomn.h
//
// Description: This file contains definitions common to the client
//		and server compoents.
// History:
//	June 11,1992.	NarenG		Created original version.
//
#ifndef _AFPCOMN_
#define _AFPCOMN_

#define AFP_UNREFERENCED( x )		( x )		

#define NT_PIPE_PREFIX      		TEXT("\\PIPE\\")

// All string functions are multibyte
//
#define STRCPY				wcscpy
#define STRLEN				wcslen	
#define STRCAT				wcscat	
#define STRCMP				wcscmp	
#define STRICMP				_wcsicmp	
#define STRNICMP			_wcsnicmp	
#define STRUPR				_wcsupr	
#define STRNCPY				wcsncpy	

#define AFP_VALIDATE_ALL_FIELDS		0

//
//	Prototypes of validation functions.
//
BOOL
IsAfpServerInfoValid(
        IN DWORD		dwParmNum,
	IN PAFP_SERVER_INFO	pAfpServerInfo
);

BOOL
IsAfpServerNameValid(
	IN LPVOID
);

BOOL
IsAfpServerOptionsValid(
	IN LPVOID
);

BOOL
IsAfpMaxSessionsValid(
	IN LPVOID
);

BOOL
IsAfpMsgValid(
	IN LPVOID
);

BOOL
IsAfpCodePageValid(
	IN LPVOID pCodePagePath
);

BOOL
IsAfpTypeCreatorValid(
	IN PAFP_TYPE_CREATOR	pAfpTypeCreator
);

BOOL
IsAfpExtensionValid(
	IN PAFP_EXTENSION pAfpExtension
);

BOOL
IsAfpMaxPagedMemValid(
	IN LPVOID pMaxPagedMem
);

BOOL
IsAfpMaxNonPagedMemValid(
	IN LPVOID pMaxNonPagedMem
);

BOOL
IsAfpNumThreadsValid(
	IN LPVOID pNumThreads
);

BOOL
IsAfpVolumeInfoValid(
	IN DWORD		dwParmNum,
        IN PAFP_VOLUME_INFO     pAfpVolume
);

BOOL
IsAfpVolumeNameValid(
	IN LPWSTR 	lpwsVolumeName
);

BOOL
IsAfpDirInfoValid(
	IN DWORD		dwParmNum,
	IN PAFP_DIRECTORY_INFO  pAfpDirInfo
);

BOOL
IsAfpIconValid(
	IN PAFP_ICON_INFO	pAfpIconInfo
);

BOOL
IsAfpFinderInfoValid(
	IN LPWSTR		pType,
	IN LPWSTR		pCreator,
	IN LPWSTR		pData,
	IN LPWSTR		pResource,
	IN LPWSTR		pPath,
	IN DWORD		dwParmNum
);

#endif // _AFPCOMN_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\service\server\afpsvc_s_stub.c ===
#include "afpsvc_s.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\service\server\conn.c ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.	   **/
/********************************************************************/

//***
//
// Filename:	conn.c
//
// Description: This module contains support routines for the connection
//		category API's for the AFP server service. These routines
//		are called directly by the RPC runtime.
//
// History:
//		June 21,1992.	NarenG		Created original version.
//
#include "afpsvcp.h"

//**
//
// Call:	AfpAdminrConnectionEnum
//
// Returns:	NO_ERROR
//		ERROR_ACCESS_DENIED
//		non-zero returns from AfpServerIOCtrlaGetInfo
//
// Description: This routine communicates with the AFP FSD to implement
//		the AfpAdminConnectionEnum function.
//
DWORD
AfpAdminrConnectionEnum(
	IN     AFP_SERVER_HANDLE      	hServer,
	IN OUT PCONN_INFO_CONTAINER     pInfoStruct,
	IN     DWORD			dwFilter,
	IN     DWORD			dwId,
	IN     DWORD 		  	dwPreferedMaximumLength,
	OUT    LPDWORD 		  	lpdwTotalEntries,
	OUT    LPDWORD 		  	lpdwResumeHandle
)
{
AFP_REQUEST_PACKET AfpSrp;
DWORD		   dwRetCode=0;
DWORD		   dwAccessStatus=0;


    // Check if caller has access
    //
    if ( dwRetCode = AfpSecObjAccessCheck( AFPSVC_ALL_ACCESS, &dwAccessStatus))
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrConnectionEnum, AfpSecObjAccessCheck failed %ld\n",dwRetCode));
	    AfpLogEvent( AFPLOG_CANT_CHECK_ACCESS, 0, NULL,
		     dwRetCode, EVENTLOG_ERROR_TYPE );
        return( ERROR_ACCESS_DENIED );
    }

    if ( dwAccessStatus )
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrConnectionEnum, AfpSecObjAccessCheck returned %ld\n",dwAccessStatus));
        return( ERROR_ACCESS_DENIED );
    }

    // Set up request packet and make IOCTL to the FSD
    //
    AfpSrp.dwRequestCode 		= OP_CONNECTION_ENUM;
    AfpSrp.dwApiType     		= AFP_API_TYPE_ENUM;
    AfpSrp.Type.Enum.cbOutputBufSize    = dwPreferedMaximumLength;

    if ( lpdwResumeHandle )
     	AfpSrp.Type.Enum.EnumRequestPkt.erqp_Index = *lpdwResumeHandle;
    else
     	AfpSrp.Type.Enum.EnumRequestPkt.erqp_Index = 0;

    AfpSrp.Type.Enum.EnumRequestPkt.erqp_Filter = dwFilter;
    AfpSrp.Type.Enum.EnumRequestPkt.erqp_ID = dwId;

    dwRetCode = AfpServerIOCtrlGetInfo( &AfpSrp );

    if ( dwRetCode != ERROR_MORE_DATA && dwRetCode != NO_ERROR )
	return( dwRetCode );

    *lpdwTotalEntries 	       = AfpSrp.Type.Enum.dwTotalAvail;
    pInfoStruct->pBuffer = (PAFP_CONNECTION_INFO)(AfpSrp.Type.Enum.pOutputBuf);
    pInfoStruct->dwEntriesRead = AfpSrp.Type.Enum.dwEntriesRead;

    if ( lpdwResumeHandle )
    	*lpdwResumeHandle = AfpSrp.Type.Enum.EnumRequestPkt.erqp_Index;

    // Convert all offsets to pointers
    //
    AfpBufOffsetToPointer( (LPBYTE)(pInfoStruct->pBuffer),
			   pInfoStruct->dwEntriesRead,
			   AFP_CONNECTION_STRUCT );

    return( dwRetCode );
}

//**
//
// Call:	AfpAdminrConnectionClose
//
// Returns:	NO_ERROR
//		ERROR_ACCESS_DENIED
//		non-zero returns from AfpServerIOCtrl
//
// Description: This routine communicates with the AFP FSD to implement
//		the AfpAdminConnectionClose function.
//
DWORD
AfpAdminrConnectionClose(
	IN AFP_SERVER_HANDLE 	hServer,
	IN DWORD 		dwConnectionId
)
{
AFP_REQUEST_PACKET  AfpSrp;
AFP_CONNECTION_INFO AfpConnInfo;
DWORD		    dwAccessStatus=0;
DWORD		    dwRetCode=0;

    // Check if caller has access
    //
    if ( dwRetCode = AfpSecObjAccessCheck( AFPSVC_ALL_ACCESS, &dwAccessStatus))
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrConnectionClose, AfpSecObjAccessCheck failed %ld\n",dwRetCode));
	    AfpLogEvent( AFPLOG_CANT_CHECK_ACCESS, 0, NULL,
		     dwRetCode, EVENTLOG_ERROR_TYPE );
        return( ERROR_ACCESS_DENIED );
    }

    if ( dwAccessStatus )
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrConnectionClose, AfpSecObjAccessCheck returned %ld\n",dwAccessStatus));
        return( ERROR_ACCESS_DENIED );
    }

    // The FSD expects an AFP_CONNECTION_INFO structure with only the id field
    // filled in.
    //
    AfpConnInfo.afpconn_id = dwConnectionId;

    // IOCTL the FSD to close the session
    //
    AfpSrp.dwRequestCode 		= OP_CONNECTION_CLOSE;
    AfpSrp.dwApiType     		= AFP_API_TYPE_DELETE;
    AfpSrp.Type.Delete.pInputBuf     	= &AfpConnInfo;
    AfpSrp.Type.Delete.cbInputBufSize   = sizeof(AFP_CONNECTION_INFO);

    return ( AfpServerIOCtrl( &AfpSrp ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\service\server\buffer.c ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.	   **/
/********************************************************************/

//***
//
// Filename:	buffer.c
//
// Description: This module contains routines to manipulate cached
//		information. ie volume info, server properties and
//		ETC mappings info.
//
// History:
//		May 11,1992.	NarenG		Created original version.
//
#include "afpsvcp.h"

// This should be more than the size (in bytes) all the value names
// each AfpMultSzInfo structure. It will be used to calculate the amount
// of memory needed to create a multi-sz.
//
#define AFP_CUMULATIVE_VALNAME_SIZE	150

// This data structure will be used by AfpBufParseMultiSz and
// AfpBufMakeMultiSz.
//
typedef struct _AfpMultiSzInfo {

    DWORD	dwType;			// Type of data, string or DWORD
    DWORD	dwOffset;		// Offset of this field from the start
    LPWSTR	lpwsValueName;		// Value name for this field.
					// If this is NULL then it does not
					// have a value name. It is the
					// value name for this MULT_SZ.
    DWORD	fIsInPlace;		// If string, is it a pointer or a
					// buffer.
    DWORD	cch;			// If fIsInPlace is TRUE, then how
					// big (in UNICODE chars.) is the
					// buffer.

} AFP_MULTISZ_INFO, *PAFP_MULTISZ_INFO;

static AFP_MULTISZ_INFO AfpVolumeMultiSz[] = {

	REG_SZ,
	AFP_FIELD_OFFSET( AFP_VOLUME_INFO, afpvol_name ),
	NULL,
	FALSE,
	0,

	REG_SZ,
	AFP_FIELD_OFFSET( AFP_VOLUME_INFO, afpvol_password ),
	AFPREG_VALNAME_PASSWORD,
	FALSE,
	0,

	REG_DWORD,
	AFP_FIELD_OFFSET( AFP_VOLUME_INFO, afpvol_max_uses ),
	AFPREG_VALNAME_MAXUSES,
	FALSE,
	0,
	
	REG_DWORD,
	AFP_FIELD_OFFSET( AFP_VOLUME_INFO, afpvol_props_mask ),
	AFPREG_VALNAME_PROPS,
	FALSE,
	0,

	REG_SZ,
	AFP_FIELD_OFFSET( AFP_VOLUME_INFO, afpvol_path ),
	AFPREG_VALNAME_PATH,
	FALSE,
	0,

	REG_NONE, 0, 0, 0, 0
	};

static AFP_MULTISZ_INFO AfpExtensionMultiSz[] = {

	REG_SZ,
	AFP_FIELD_OFFSET( AFP_EXTENSION, afpe_extension[0] ),
	NULL,
	TRUE,
	AFP_FIELD_SIZE( AFP_EXTENSION, afpe_extension ),

	REG_DWORD,
	AFP_FIELD_OFFSET( AFP_EXTENSION, afpe_tcid ),
	AFPREG_VALNAME_ID,
	FALSE,
	0,

	REG_NONE, 0, 0, 0, 0
	};


static AFP_MULTISZ_INFO AfpTypeCreatorMultiSz[] = {

	REG_SZ,
	AFP_FIELD_OFFSET(AFP_TYPE_CREATOR, afptc_creator[0] ),
	AFPREG_VALNAME_CREATOR,
	TRUE,
	AFP_FIELD_SIZE(AFP_TYPE_CREATOR, afptc_creator ),

	REG_SZ,
	AFP_FIELD_OFFSET( AFP_TYPE_CREATOR, afptc_type[0] ),
	AFPREG_VALNAME_TYPE,
	TRUE,
	AFP_FIELD_SIZE( AFP_TYPE_CREATOR, afptc_type ),

	REG_SZ,
	AFP_FIELD_OFFSET( AFP_TYPE_CREATOR, afptc_comment[0] ),
	AFPREG_VALNAME_COMMENT,
	TRUE,
	AFP_FIELD_SIZE( AFP_TYPE_CREATOR, afptc_comment ),

	REG_DWORD,
	AFP_FIELD_OFFSET( AFP_TYPE_CREATOR, afptc_id ),
	NULL,
	FALSE,
	0,

	REG_NONE, 0, 0, 0, 0
	};

static AFP_MULTISZ_INFO AfpIconMultiSz[] = {

	REG_SZ,
	AFP_FIELD_OFFSET( AFP_ICON_INFO, afpicon_type[0] ),
	AFPREG_VALNAME_TYPE,
	TRUE,
	AFP_FIELD_SIZE( AFP_ICON_INFO, afpicon_type ),

	REG_SZ,
	AFP_FIELD_OFFSET( AFP_ICON_INFO, afpicon_creator[0] ),
	AFPREG_VALNAME_CREATOR,
	TRUE,
	AFP_FIELD_SIZE( AFP_ICON_INFO, afpicon_creator ),

	REG_DWORD,
	AFP_FIELD_OFFSET( AFP_ICON_INFO, afpicon_icontype ),
	AFPREG_VALNAME_ICONTYPE,
	FALSE,
	0,

	REG_DWORD,
	AFP_FIELD_OFFSET( AFP_ICON_INFO, afpicon_length ),
	AFPREG_VALNAME_LENGTH,
	FALSE,
	0,

	REG_SZ,
	AFP_FIELD_OFFSET( AFP_ICON_INFO, afpicon_data ),
	AFPREG_VALNAME_DATA,
	FALSE,
	0,

	REG_NONE, 0, 0, 0, 0
	};

// These arrays represents the byte offsets, from the beginning of the
// structure, of the LPWSTR fields.
//
static BYTE ServerOffsetTable[] = {
	AFP_FIELD_OFFSET( AFP_SERVER_INFO, afpsrv_name ),
	AFP_FIELD_OFFSET( AFP_SERVER_INFO, afpsrv_login_msg ),
	AFP_FIELD_OFFSET( AFP_SERVER_INFO, afpsrv_codepage ),
	0xFF
	};

static BYTE VolumeOffsetTable[] = {
	AFP_FIELD_OFFSET( AFP_VOLUME_INFO, afpvol_name ),
	AFP_FIELD_OFFSET( AFP_VOLUME_INFO, afpvol_password ),
	AFP_FIELD_OFFSET( AFP_VOLUME_INFO, afpvol_path ),
	0xFF
	};

static BYTE DirOffsetTable[] = {
	AFP_FIELD_OFFSET( AFP_DIRECTORY_INFO, afpdir_path ),
	AFP_FIELD_OFFSET( AFP_DIRECTORY_INFO, afpdir_owner ),
	AFP_FIELD_OFFSET( AFP_DIRECTORY_INFO, afpdir_group ),
	0xFF
	};

static BYTE SessionOffsetTable[] = {
	AFP_FIELD_OFFSET( AFP_SESSION_INFO, afpsess_ws_name ),
	AFP_FIELD_OFFSET( AFP_SESSION_INFO, afpsess_username ),
	0xFF
	};

static BYTE FileOffsetTable[] = {
	AFP_FIELD_OFFSET( AFP_FILE_INFO, afpfile_path ),
	AFP_FIELD_OFFSET( AFP_FILE_INFO, afpfile_username ),
	0xFF
	};

static BYTE ConnectionOffsetTable[] = {
	AFP_FIELD_OFFSET( AFP_CONNECTION_INFO, afpconn_username ),
	AFP_FIELD_OFFSET( AFP_CONNECTION_INFO, afpconn_volumename ),
	0xFF
	};

static BYTE MessageOffsetTable[] = {
	AFP_FIELD_OFFSET( AFP_MESSAGE_INFO, afpmsg_text ),
	0xFF
	};

static BYTE FinderOffsetTable[] = {
	AFP_FIELD_OFFSET( AFP_FINDER_INFO, afpfd_path ),
	0xFF
	};


//**
//
// Call:	AfpBufStructureSize
//
// Returns:	The size (in bytes) of the data withing the structure.
//
// Description:	It will calculate the size of all the variable data and
//		add that to the fixed size of the structure.
//
DWORD
AfpBufStructureSize(
	IN AFP_STRUCTURE_TYPE	dwStructureType,
	IN LPBYTE		lpbStructure
)
{
DWORD	cbStructureSize;
DWORD	dwIndex;
DWORD	cbBufSize;
LPWSTR* plpwsStringField;
PBYTE	OffsetTable;

    switch( dwStructureType ) {

    case AFP_VOLUME_STRUCT:
	OffsetTable 	= VolumeOffsetTable;
	cbStructureSize = sizeof( AFP_VOLUME_INFO );
	break;

    case AFP_SERVER_STRUCT:
	OffsetTable 	= ServerOffsetTable;
	cbStructureSize = sizeof( AFP_SERVER_INFO );
	break;

    case AFP_DIRECTORY_STRUCT:
	OffsetTable 	= DirOffsetTable;
	cbStructureSize = sizeof( AFP_DIRECTORY_INFO );
	break;

    case AFP_EXTENSION_STRUCT:
	return( sizeof(AFP_EXTENSION) );
	break;

    case AFP_TYPECREATOR_STRUCT:
	return( sizeof(AFP_TYPE_CREATOR) );
	break;

    case AFP_MESSAGE_STRUCT:
	OffsetTable 	= MessageOffsetTable;
	cbStructureSize = sizeof( AFP_MESSAGE_INFO );
	break;

    case AFP_ICON_STRUCT:
	return( sizeof(AFP_ICON_INFO) +
		((PAFP_ICON_INFO)lpbStructure)->afpicon_length );
	break;

    case AFP_FINDER_STRUCT:
	OffsetTable 	= FinderOffsetTable;
	cbStructureSize = sizeof( AFP_FINDER_INFO );
	break;

    default:
	return( 0 );
    }

    // First calculate the amount of memory that will be needed to
    // store all the string information.
    //
    for( dwIndex = 0, cbBufSize = 0;

	 OffsetTable[dwIndex] != 0xFF;

	 dwIndex++

	) {
	
   	plpwsStringField=(LPWSTR*)((ULONG_PTR)lpbStructure + OffsetTable[dwIndex]);

        cbBufSize += ( ( *plpwsStringField == NULL ) ? 0 :
		         STRLEN( *plpwsStringField ) + 1 );
    }

    // Convert to UNICODE size
    //
    cbBufSize *= sizeof( WCHAR );

    // Add size of fixed part of the structure
    //
    cbBufSize += cbStructureSize;

    return( cbBufSize );

}

//**
//
// Call:	AfpBufMakeFSDRequest
//
// Returns:	NO_ERROR	
//		ERROR_NOT_ENOUGH_MEMORY	
//
// Description: This routine is called by the worker routines for the client
//		API calls. The purpose of this routine is to convert a
//		AFP_XXX_INFO structure passed by the client API into a
//		contiguous self-relative buffer. This has to be done because
//		the FSD cannot reference pointers to user space.
//
//		This routine will allocate the required amount of memory to
//		store all the information in self relative form. It is
//		the reponsibility of the caller to free this memory.
//
//		All pointer fields will be converted to offsets from the
//		beginning of the structure.
//		
//		The cbReqPktSize parameter specifies how many bytes of space
//		should be allocated before the self relative data structure.
//		i.e.
//				|------------|
//				|cbReqPktSize|
//				|   bytes    |
//				|------------|
//				|   Self     |
//				|  relative  |
//				| structure  |
//				|------------|
//
DWORD
AfpBufMakeFSDRequest(

	// Buffer as received by the client API	
	//
	IN  LPBYTE  		pBuffer,

	// Size of FSD request packet.
	//
	IN  DWORD		cbReqPktSize,

	IN  AFP_STRUCTURE_TYPE dwStructureType,

	// Self-relative form of I/P buf
	//
	OUT LPBYTE 		*ppSelfRelativeBuf,

	// Size of self relative buf
	//
	OUT LPDWORD		lpdwSelfRelativeBufSize
)
{
LPBYTE		 lpbSelfRelBuf;
DWORD		 cbSRBufSize;
DWORD		 dwIndex;
LPWSTR		 lpwsVariableData;
LPWSTR *	 plpwsStringField;
LPWSTR *	 plpwsStringFieldSR;
PBYTE		 OffsetTable;
DWORD		 cbStructureSize;


    // Initialize the offset table and the structure size values
    //
    switch( dwStructureType ) {

    case AFP_VOLUME_STRUCT:
	OffsetTable     = VolumeOffsetTable;
	cbStructureSize = sizeof( AFP_VOLUME_INFO );
	break;

    case AFP_SERVER_STRUCT:
	OffsetTable     = ServerOffsetTable;
	cbStructureSize = sizeof( AFP_SERVER_INFO );
	break;

    case AFP_DIRECTORY_STRUCT:
	OffsetTable = DirOffsetTable;
	cbStructureSize = sizeof( AFP_DIRECTORY_INFO );
	break;

    case AFP_MESSAGE_STRUCT:
	OffsetTable = MessageOffsetTable;
	cbStructureSize = sizeof( AFP_MESSAGE_INFO );
	break;

    case AFP_FINDER_STRUCT:
	OffsetTable = FinderOffsetTable;
	cbStructureSize = sizeof( AFP_FINDER_INFO );
	break;

    default:
	return( ERROR_INVALID_PARAMETER );
    }

    cbSRBufSize = cbReqPktSize + AfpBufStructureSize(dwStructureType, pBuffer);

    // Allocate space for self relative buffer
    //
    if ( ( lpbSelfRelBuf = (LPBYTE)LocalAlloc( LPTR, cbSRBufSize ) ) == NULL )
	return( ERROR_NOT_ENOUGH_MEMORY );

    *ppSelfRelativeBuf       = lpbSelfRelBuf;
    *lpdwSelfRelativeBufSize = cbSRBufSize;

    // Advance this pointer beyond the request packet
    //
    lpbSelfRelBuf += cbReqPktSize;

    // memcpy to fill in the non-string data
    //
    CopyMemory( lpbSelfRelBuf, pBuffer, cbStructureSize );

    // Now copy all the strings
    //
    for( dwIndex = 0,
	 lpwsVariableData = (LPWSTR)((ULONG_PTR)lpbSelfRelBuf + cbStructureSize);

	 OffsetTable[dwIndex] != 0xFF;

	 dwIndex++ ) {

	
	// This will point to a string pointer field in the non self-relative
	// structure.
	//
   	plpwsStringField = (LPWSTR*)((ULONG_PTR)pBuffer + OffsetTable[dwIndex]);

	// This will point to the corresponding string pointer field in the
	// self-relative structure
	//
   	plpwsStringFieldSR=(LPWSTR*)((ULONG_PTR)lpbSelfRelBuf+OffsetTable[dwIndex]);

	// If there is no string to be copied, then just set to NULL
  	//
    	if ( *plpwsStringField == NULL )
       	    *plpwsStringFieldSR = NULL;
	else {

	    // There is a string so copy it
	    //
            STRCPY( lpwsVariableData, *plpwsStringField );

	    // Store the pointer value
	    //
            *plpwsStringFieldSR = lpwsVariableData;

	    // Convert the pointer to this data to an offset
	    //
            POINTER_TO_OFFSET( *plpwsStringFieldSR, lpbSelfRelBuf );
	
	    // Update the pointer to where the next variable length data
	    // will be stored.
	    //
    	    lpwsVariableData += ( STRLEN( *plpwsStringField ) + 1 );

	}

    }

    return( NO_ERROR );

}

//**
//
// Call:	AfpBufOffsetToPointer
//
// Returns:	none.
//
// Description:	Will walk a list of structures, converting all offsets
//		within each structure to pointers.
//
VOID
AfpBufOffsetToPointer(
	IN OUT LPBYTE	          pBuffer,
	IN     DWORD		  dwNumEntries,
	IN     AFP_STRUCTURE_TYPE dwStructureType
)
{
PBYTE		OffsetTable;
DWORD		cbStructureSize;
LPWSTR 	       *plpwsStringField;
DWORD		dwIndex;


    // Initialize the offset table and the structure size values
    //
    switch( dwStructureType ) {

    case AFP_VOLUME_STRUCT:
	OffsetTable 	= VolumeOffsetTable;
	cbStructureSize = sizeof( AFP_VOLUME_INFO );
 	break;

    case AFP_SESSION_STRUCT:
	OffsetTable 	= SessionOffsetTable;
	cbStructureSize = sizeof( AFP_SESSION_INFO );
 	break;

    case AFP_CONNECTION_STRUCT:
	OffsetTable 	= ConnectionOffsetTable;
	cbStructureSize = sizeof( AFP_CONNECTION_INFO );
 	break;

    case AFP_FILE_STRUCT:
	OffsetTable 	= FileOffsetTable;
	cbStructureSize = sizeof( AFP_FILE_INFO );
 	break;

    case AFP_DIRECTORY_STRUCT:
	OffsetTable 	= DirOffsetTable;
	cbStructureSize = sizeof( AFP_DIRECTORY_INFO );
 	break;

    case AFP_MESSAGE_STRUCT:
	OffsetTable 	= MessageOffsetTable;
	cbStructureSize = sizeof( AFP_MESSAGE_INFO );
 	break;

    case AFP_SERVER_STRUCT:
	OffsetTable 	= ServerOffsetTable;
	cbStructureSize = sizeof( AFP_SERVER_INFO );
 	break;

    default:
	return;
    }

    // Walk the list and convert each structure.
    //
    while( dwNumEntries-- ) {

	// Convert every LPWSTR from an offset to a pointer
	//
        for( dwIndex = 0;  OffsetTable[dwIndex] != 0xFF;  dwIndex++ ) {
	
	    plpwsStringField = (LPWSTR*)( (ULONG_PTR)pBuffer
					  + (DWORD)OffsetTable[dwIndex] );

	    OFFSET_TO_POINTER( *plpwsStringField, pBuffer );
	
	}

	pBuffer += cbStructureSize;
	
    }

    return;
}

//**
//
// Call:	AfpBufMakeMultiSz
//
// Returns:	NO_ERROR	- success
//		ERROR_NOT_ENOUGH_MEMORY
//
// Description: This routine will take a give structure and create a
//		REG_MULTI_SZ from it. This can then be set directly into the
//		registry. It is the caller's responsibility to free
//		the memory allocated for *ppbMultiSz.
//
DWORD
AfpBufMakeMultiSz(
	IN  AFP_STRUCTURE_TYPE  dwStructureType,
	IN  LPBYTE		lpbStructure,
	OUT LPBYTE *		ppbMultiSz,
	OUT LPDWORD		lpdwMultiSzSize
)
{
PAFP_MULTISZ_INFO	pAfpMultiSz;
PWCHAR			lpwchWalker;			
PVOID			pData;
DWORD			dwIndex;
DWORD			cbStructureSize;

    switch( dwStructureType ) {

    case AFP_VOLUME_STRUCT:
	pAfpMultiSz = AfpVolumeMultiSz;
	break;

    case AFP_EXTENSION_STRUCT:
	pAfpMultiSz = AfpExtensionMultiSz;
	break;

    case AFP_TYPECREATOR_STRUCT:
	pAfpMultiSz = AfpTypeCreatorMultiSz;
	break;

    case AFP_ICON_STRUCT:
	pAfpMultiSz = AfpIconMultiSz;
	break;

    default:
	return( ERROR_INVALID_PARAMETER );
    }

    // Allocate enough memory to create the multi-sz.
    // AFP_CUMULATIVE_VALNAME_SIZE should be greater than the sum of all the
    // value names of all the structures.
    //
    cbStructureSize = AfpBufStructureSize( dwStructureType, lpbStructure )
		      + AFP_CUMULATIVE_VALNAME_SIZE;

    if ( ( *ppbMultiSz = (LPBYTE)LocalAlloc( LPTR, cbStructureSize ) ) == NULL )
	return( ERROR_NOT_ENOUGH_MEMORY );

    ZeroMemory( *ppbMultiSz, cbStructureSize );

    // For every field, we create a string
    //
    for ( dwIndex = 0,
	  lpwchWalker = (PWCHAR)*ppbMultiSz;

	  pAfpMultiSz[dwIndex].dwType != REG_NONE;

	  dwIndex++

	){
	
	// This is the value name so do not put it in the buffer.
	//
	if ( pAfpMultiSz[dwIndex].lpwsValueName == NULL )
	    continue;

	STRCPY( lpwchWalker, pAfpMultiSz[dwIndex].lpwsValueName );
	STRCAT( lpwchWalker, TEXT("="));

	lpwchWalker += STRLEN( lpwchWalker );

	pData = lpbStructure + pAfpMultiSz[dwIndex].dwOffset;

	// Convert to string and concatenate
	//
	if ( pAfpMultiSz[dwIndex].dwType == REG_DWORD ) {

	    UCHAR chAnsiBuf[12];
	
	    _itoa( *((LPDWORD)pData), chAnsiBuf, 10 );
	
	    mbstowcs( lpwchWalker, chAnsiBuf, sizeof(chAnsiBuf) );
	}

	if ( pAfpMultiSz[dwIndex].dwType == REG_SZ ) {

	    // Check if this is a pointer or an in-place buffer
	    //
	    if ( pAfpMultiSz[dwIndex].fIsInPlace )
	     	STRCPY( lpwchWalker, (LPWSTR)pData );
	    else {

		if ( *(LPWSTR*)pData != NULL )
	    	    STRCPY( lpwchWalker, *((LPWSTR*)pData) );
	    }
	}

	lpwchWalker += ( STRLEN( lpwchWalker ) + 1 );
	
    }

    *lpdwMultiSzSize = (DWORD)((ULONG_PTR)lpwchWalker - (ULONG_PTR)(*ppbMultiSz) ) + sizeof(WCHAR);

    return( NO_ERROR );
}

//**
//
// Call:	AfpBufParseMultiSz
//
// Returns:	NO_ERROR		- success
//		ERROR_INVALID_PARAMETER
//
// Description: This routine will parse a REG_MULTI_SZ and fill in the
//		appropriate data structure. All pointers will point to
//		the pbMultiSz input parameter.
//
DWORD
AfpBufParseMultiSz(
	IN  AFP_STRUCTURE_TYPE  dwStructureType,
	IN  LPBYTE		pbMultiSz,
	OUT LPBYTE		pbStructure
)
{
PAFP_MULTISZ_INFO	pAfpMultiSz;
DWORD			dwIndex;
DWORD			cbStructSize;
LPWSTR			lpwchWalker;
PVOID			pData;
UCHAR           chAnsiBuf[12];
DWORD           dwDisableCatsearch=0;

    switch( dwStructureType ) {

    case AFP_VOLUME_STRUCT:
	pAfpMultiSz  = AfpVolumeMultiSz;
	cbStructSize = sizeof( AFP_VOLUME_INFO );

    //
    // The following "quick fix" is for Disabling CatSearch support.  Read in the
    // DisableCatsearch parameter if it's put in.  In most cases, this parm won't
    // be there.  If it is, the server disables CatSearch
    //
    for ( (lpwchWalker = (LPWSTR)pbMultiSz);
          (*lpwchWalker != TEXT('\0') );
          (lpwchWalker += ( STRLEN( lpwchWalker ) + 1 ) ))
    {
	    if ( STRNICMP( AFPREG_VALNAME_CATSEARCH,
			           lpwchWalker,
			           STRLEN( AFPREG_VALNAME_CATSEARCH ) ) == 0 )
        {
	        lpwchWalker += ( STRLEN( AFPREG_VALNAME_CATSEARCH ) + 1 );
           	wcstombs( chAnsiBuf, lpwchWalker, sizeof(chAnsiBuf) );
	    	dwDisableCatsearch = atoi( chAnsiBuf );
            break;
        }
    }

	break;

    case AFP_EXTENSION_STRUCT:
	pAfpMultiSz = AfpExtensionMultiSz;
	cbStructSize = sizeof( AFP_EXTENSION );
	break;

    case AFP_TYPECREATOR_STRUCT:
	pAfpMultiSz = AfpTypeCreatorMultiSz;
	cbStructSize = sizeof( AFP_TYPE_CREATOR );
	break;

    case AFP_ICON_STRUCT:
	pAfpMultiSz = AfpIconMultiSz;
	cbStructSize = sizeof( AFP_ICON_INFO );
	break;

    default:
	return( ERROR_INVALID_PARAMETER );
    }

    ZeroMemory( pbStructure, cbStructSize );

    // For every field in the structure
    //
    for ( dwIndex = 0; pAfpMultiSz[dwIndex].dwType != REG_NONE; dwIndex++ ){
	
	// This is the value name so do not try to retrieve it from the
	// buffer.
	//
	if ( pAfpMultiSz[dwIndex].lpwsValueName == NULL )
	    continue;

	// Search for valuename for this field
	//
        for (  lpwchWalker = (LPWSTR)pbMultiSz;

	       ( *lpwchWalker != TEXT('\0') )
	       &&
	       ( STRNICMP( pAfpMultiSz[dwIndex].lpwsValueName,
			   lpwchWalker,
			   STRLEN(pAfpMultiSz[dwIndex].lpwsValueName) ) != 0 );

	       lpwchWalker += ( STRLEN( lpwchWalker ) + 1 ) );

	// Could not find parameter
	//
	if ( *lpwchWalker == TEXT('\0') )
	    return( ERROR_INVALID_PARAMETER );

	// Otherwise we found it so get the value
	//
	lpwchWalker += ( STRLEN( pAfpMultiSz[dwIndex].lpwsValueName ) + 1 );

	pData = pbStructure + pAfpMultiSz[dwIndex].dwOffset;

	// If there is no value after the value name then ignore this field
	// It defaults to zero.
	//
        if ( *lpwchWalker != TEXT( '\0' ) ) {

	    // Convert to integer
	    //
	    if ( pAfpMultiSz[dwIndex].dwType == REG_DWORD ) {
	
            	wcstombs( chAnsiBuf, lpwchWalker, sizeof(chAnsiBuf) );

	    	*((LPDWORD)pData) = atoi( chAnsiBuf );
	
	    }

        //
        // CatSearch hack continued: if we are looking at the volume mask
        // parameter, see if we must turn the bit off.
        //
        if( dwStructureType == AFP_VOLUME_STRUCT && dwDisableCatsearch )
        {
	        if ( STRNICMP( pAfpMultiSz[dwIndex].lpwsValueName,
			              AFPREG_VALNAME_PROPS,
			              STRLEN(pAfpMultiSz[dwIndex].lpwsValueName) ) == 0 )
            {
                *((LPDWORD)pData) |= AFP_VOLUME_DISALLOW_CATSRCH;
            }
        }

	    if ( pAfpMultiSz[dwIndex].dwType == REG_SZ ) {

	    	// Check if this is a pointer or an in-place buffer
	    	//
	    	if ( pAfpMultiSz[dwIndex].fIsInPlace ) {

		    if ( STRLEN( lpwchWalker ) > pAfpMultiSz[dwIndex].cch )
    			return( ERROR_INVALID_PARAMETER );

		    STRCPY( (LPWSTR)pData, lpwchWalker );
		}
	    	else
		    *((LPWSTR*)pData) = lpwchWalker;
	    }

	}

    }

    return( NO_ERROR );

}

//**
//
// Call:	AfpBufMakeFSDETCMappings
//
// Returns:	NO_ERROR	
//		ERROR_NOT_ENOUGH_MEMORY	
//
// Description: This routine will convert all the mappings in the
//		form stored in AfpGlobals.AfpETCMapInfo to the form
//		required by the FSD, ie. the ETCMAPINFO structure.
//		It is the responsibility for the caller to free
//		allocated memory.
//
DWORD
AfpBufMakeFSDETCMappings(
	OUT PSRVETCPKT		*ppSrvSetEtc,
	OUT LPDWORD		lpdwSrvSetEtcBufSize
)
{
DWORD			dwIndex;
PETCMAPINFO2		pETCMapInfo;
PAFP_EXTENSION		pExtensionWalker;
PAFP_TYPE_CREATOR	pTypeCreator;
AFP_TYPE_CREATOR	AfpTypeCreatorKey;
DWORD			dwNumTypeCreators;


    // Allocate space to hold the ETCMaps in the form required by the FSD.
    //
    *ppSrvSetEtc = (PSRVETCPKT)LocalAlloc( LPTR,
	  AFP_FIELD_SIZE( SRVETCPKT, retc_NumEtcMaps ) +
          (AfpGlobals.AfpETCMapInfo.afpetc_num_extensions*sizeof(ETCMAPINFO2)));

    if ( *ppSrvSetEtc == NULL )
	return( ERROR_NOT_ENOUGH_MEMORY );

    // Walk through the extension list
    //
    for( dwIndex 	   = 0,
	 pETCMapInfo       = (*ppSrvSetEtc)->retc_EtcMaps,
	 pExtensionWalker  = AfpGlobals.AfpETCMapInfo.afpetc_extension,
	 pTypeCreator      = AfpGlobals.AfpETCMapInfo.afpetc_type_creator,
	 dwNumTypeCreators = AfpGlobals.AfpETCMapInfo.afpetc_num_type_creators,
    	 (*ppSrvSetEtc)->retc_NumEtcMaps = 0;

	 dwIndex < AfpGlobals.AfpETCMapInfo.afpetc_num_extensions;

	 dwIndex++,
	 dwNumTypeCreators = AfpGlobals.AfpETCMapInfo.afpetc_num_type_creators,
	 pExtensionWalker++

	) {

	
	// Ignore any extensions that are associated with the default
	// type/creator. They shouldnt be in the registry to begin with.
	//
	if ( pExtensionWalker->afpe_tcid == AFP_DEF_TCID )
	    continue;
	
	// Find the type/creator associated with this extension.
	//
  	AfpTypeCreatorKey.afptc_id = pExtensionWalker->afpe_tcid;

    	pTypeCreator = _lfind(  &AfpTypeCreatorKey,
			       AfpGlobals.AfpETCMapInfo.afpetc_type_creator,
			       (unsigned int *)&dwNumTypeCreators,
			       sizeof(AFP_TYPE_CREATOR),
			       AfpLCompareTypeCreator );
	

	// If there is a type/creator associated with this extension
	//
	if ( pTypeCreator != NULL ) {

	    AfpBufCopyFSDETCMapInfo( pTypeCreator,
				     pExtensionWalker,
				     pETCMapInfo );

	    pETCMapInfo++;
    	    (*ppSrvSetEtc)->retc_NumEtcMaps++;
	}

    }

    *lpdwSrvSetEtcBufSize = AFP_FIELD_SIZE( SRVETCPKT, retc_NumEtcMaps ) +
    	    ((*ppSrvSetEtc)->retc_NumEtcMaps * sizeof(ETCMAPINFO2));

    return( NO_ERROR );
}

//**
//
// Call:	AfpBufMakeFSDIcon
//
// Returns:	none.
//
// Description: This routine will copy the icon information from the
//		AFP_ICON_INFO data structure to an SRVICONINFO data
//		structure viz. the form that the FSD needs.
//
VOID
AfpBufMakeFSDIcon(
	IN  PAFP_ICON_INFO pIconInfo,
	OUT LPBYTE	   lpbFSDIcon,
	OUT LPDWORD	   lpcbFSDIconSize
)
{
UCHAR	chBuffer[sizeof(AFP_ICON_INFO)]; // Need enough space to translate

    // Blank out the whole structure so that type and creator will
    // be padded with blanks
    //
    memset( lpbFSDIcon, ' ', sizeof(SRVICONINFO) );

    // Convert to ANSI and copy type
    //
    wcstombs(chBuffer,pIconInfo->afpicon_type,sizeof(chBuffer));

    CopyMemory( ((PSRVICONINFO)lpbFSDIcon)->icon_type,
	    	chBuffer,
	    	STRLEN(pIconInfo->afpicon_type));

    // Convert to ANSI copy creator
    //
    wcstombs(chBuffer,pIconInfo->afpicon_creator,sizeof(chBuffer));

    CopyMemory( ((PSRVICONINFO)lpbFSDIcon)->icon_creator,
	      	chBuffer,
	    	STRLEN(pIconInfo->afpicon_creator));

    // Set icon type
    //
    ((PSRVICONINFO)lpbFSDIcon)->icon_icontype = pIconInfo->afpicon_icontype;

    // Set icon data length
    //
    ((PSRVICONINFO)lpbFSDIcon)->icon_length = pIconInfo->afpicon_length;

    CopyMemory( lpbFSDIcon + sizeof(SRVICONINFO),
	        pIconInfo->afpicon_data,
	    	((PSRVICONINFO)lpbFSDIcon)->icon_length );

    *lpcbFSDIconSize = sizeof(SRVICONINFO) + pIconInfo->afpicon_length;

    return;
}

//**
//
// Call:	AfpBufCopyFSDETCMapInfo
//
// Returns:	none
//
// Description: This routine will copu information from the AFP_TYPE_CREATOR
//		and AFP_EXTENSION data structures into a ETCMAPINFO data
//		structure viz. in the form as required by the FSD.
//
VOID
AfpBufCopyFSDETCMapInfo( 	
	IN  PAFP_TYPE_CREATOR 	pAfpTypeCreator,
	IN  PAFP_EXTENSION	pAfpExtension,
	OUT PETCMAPINFO2         pFSDETCMapInfo
)
{
    CHAR	Buffer[sizeof(AFP_TYPE_CREATOR)];


    // Insert blanks which will be used to pad type/creators less
    // than their max. lengths.
    //
    memset( (LPBYTE)pFSDETCMapInfo, ' ', sizeof(ETCMAPINFO2) );
    ZeroMemory( (LPBYTE)(pFSDETCMapInfo->etc_extension),
            	AFP_FIELD_SIZE( ETCMAPINFO2, etc_extension ) );

    CopyMemory( pFSDETCMapInfo->etc_extension,
                pAfpExtension->afpe_extension,
	    	    wcslen(pAfpExtension->afpe_extension) * sizeof(WCHAR));

    wcstombs( Buffer, pAfpTypeCreator->afptc_type, sizeof(Buffer) );
    CopyMemory( pFSDETCMapInfo->etc_type,
	      	Buffer,
	    	STRLEN(pAfpTypeCreator->afptc_type));

    wcstombs( Buffer, pAfpTypeCreator->afptc_creator, sizeof(Buffer) );
    CopyMemory( pFSDETCMapInfo->etc_creator,
	    	Buffer,
	    	STRLEN(pAfpTypeCreator->afptc_creator));

    return;

}

//**
//
// Call:	AfpBufUnicodeToNibble
//
// Returns:	NO_ERROR
//		ERROR_INVALID_PARAMETER
//
// Description: This routine will take a pointer to a UNCODE string and
//		convert each UNICODE char to a the corresponding nibble.
//		it char. 'A' will be converted to a nibble having value 0xA
//		This conversion is done in-place.
//
DWORD
AfpBufUnicodeToNibble(
	IN OUT LPWSTR	lpwsData
)
{
DWORD 	dwIndex;
BYTE	bData;
LPBYTE  lpbData = (LPBYTE)lpwsData;

    // Convert each UNICODE character to nibble. (in place)
    //
    for ( dwIndex = 0; *lpwsData != TEXT('\0'); dwIndex++, lpwsData++ ) {

	if ( iswalpha( *lpwsData ) ) {
	
	    if ( iswupper( *lpwsData ) )
            	bData = *lpwsData - TEXT('A');
	    else
            	bData = *lpwsData - TEXT('a');

	    bData += 10;
	
	    if ( bData > 0x0F )
		return( ERROR_INVALID_PARAMETER );
	}
	else if ( iswdigit( *lpwsData ) )
	    bData = *lpwsData - TEXT('0');
	else
	    return( ERROR_INVALID_PARAMETER );

	// Multipy so that data is in the most significant nibble.
	// Do this every other time.
	//
	if ( ( dwIndex % 2 ) == 0 )
	    *lpbData = bData * 16;
	else {
	    *lpbData += bData;
	    lpbData++;
	}
				
				
    }

    return( NO_ERROR );
}

//**
//
// Call:	AfpBCompareTypeCreator
//
// Returns:	< 0  if pAfpTypeCreator1 comes before pAfpTypeCreator2
// 		> 0  if pAfpTypeCreator1 comes before pAfpTypeCreator2
//		== 0 if pAfpTypeCreator1 is equal to  pAfpTypeCreator2
//
// Description: This routine is called by qsort to sort the list of
//		type creators in the cache. The list is sorted in
//		ascending alphabetical order of the concatenation of the
//		creator and type. This list is sorted to facilitate quick
//		lookup (binary search). This routine is also called by
//		bsearch to do a binary search on the list.
//
int
_cdecl
AfpBCompareTypeCreator(
	IN const void * pAfpTypeCreator1,
	IN const void * pAfpTypeCreator2
)
{
WCHAR	wchTypeCreator1[ sizeof( AFP_TYPE_CREATOR )];
WCHAR	wchTypeCreator2[ sizeof( AFP_TYPE_CREATOR )];
		

    STRCPY(wchTypeCreator1,
	   ((PAFP_TYPE_CREATOR)pAfpTypeCreator1)->afptc_creator);

    if (STRLEN(((PAFP_TYPE_CREATOR)pAfpTypeCreator1)->afptc_creator) == 0)
        wchTypeCreator1[0]=L'\0';

    STRCAT(wchTypeCreator1,((PAFP_TYPE_CREATOR)pAfpTypeCreator1)->afptc_type );

    STRCPY(wchTypeCreator2,
	   ((PAFP_TYPE_CREATOR)pAfpTypeCreator2)->afptc_creator);

    STRCAT(wchTypeCreator2,((PAFP_TYPE_CREATOR)pAfpTypeCreator2)->afptc_type );

    return( STRCMP( wchTypeCreator1, wchTypeCreator2 ) );
}

//**
//
// Call:	AfpLCompareTypeCreator
//
// Returns:	< 0  if pAfpTypeCreator1 comes before pAfpTypeCreator2
// 		> 0  if pAfpTypeCreator1 comes before pAfpTypeCreator2
//		== 0 if pAfpTypeCreator1 is equal to  pAfpTypeCreator2
//
// Description: This routine is called by lfind to do a linear search of
//		the type/creator list.
//
int
_cdecl
AfpLCompareTypeCreator(
	IN const void * pAfpTypeCreator1,
	IN const void * pAfpTypeCreator2
)
{

    return( ( ((PAFP_TYPE_CREATOR)pAfpTypeCreator1)->afptc_id ==
    	      ((PAFP_TYPE_CREATOR)pAfpTypeCreator2)->afptc_id ) ? 0 : 1 );
}

//**
//
// Call:	AfpBCompareExtension
//
// Returns:	< 0  if pAfpExtension1 comes before pAfpExtension2
// 		> 0  if pAfpExtension1 comes before pAfpExtension2
//		== 0 if pAfpExtension1 is equal to  pAfpExtension2
//
// Description: This is called by qsort to sort the list of extensions in the
//		cache. The list is sorted by ID. This routine is also called
//		by bserach to do a binary lookup of this list.
//
int
_cdecl
AfpBCompareExtension(
	IN const void * pAfpExtension1,
	IN const void * pAfpExtension2
)
{
    return((((PAFP_EXTENSION)pAfpExtension1)->afpe_tcid ==
    	    ((PAFP_EXTENSION)pAfpExtension2)->afpe_tcid ) ? 0 :
          ((((PAFP_EXTENSION)pAfpExtension1)->afpe_tcid <
    	    ((PAFP_EXTENSION)pAfpExtension2)->afpe_tcid ) ? -1 : 1 ));

}

//**
//
// Call:	AfpLCompareExtension
//
// Returns:	< 0  if pAfpExtension1 comes before pAfpExtension2
// 		> 0  if pAfpExtension1 comes before pAfpExtension2
//		== 0 if pAfpExtension1 is equal to  pAfpExtension2
//
// Description: This routine is called by lfind to do a linear lookup of the
//		list of extensions in the cache.
//
int
_cdecl
AfpLCompareExtension(
	IN const void * pAfpExtension1,
	IN const void * pAfpExtension2
)
{
    return( STRICMP( ((PAFP_EXTENSION)pAfpExtension1)->afpe_extension,
    		     ((PAFP_EXTENSION)pAfpExtension2)->afpe_extension ) );
}

//**
//
// Call:	AfpBinarySearch
//
// Returns:	Pointer to first occurance of element that matches pKey.
//
// Description: This is a wrapper around bsearch. Since bsearch does not
//		return the first occurance of an element within the array,
//		this routine will back up to point to the first occurance
//		of a record with a particular key is reached.
//
void *
AfpBinarySearch(
	IN const void * pKey,
	IN const void * pBase,
	IN size_t num,
	IN size_t width,
	IN int (_cdecl *compare)(const void * pElem1, const void * pElem2 )
)
{
void * pCurrElem = bsearch( pKey, pBase, num, width, compare);


    if ( pCurrElem == NULL )
	return( NULL );

    // Backup until first occurance is reached
    //
    while ( ( (ULONG_PTR)pCurrElem > (ULONG_PTR)pBase )
	    &&
	    ( (*compare)( pKey, (void*)((ULONG_PTR)pCurrElem - width) ) == 0 ) )

	pCurrElem = (void *)((ULONG_PTR)pCurrElem - width);

    return( pCurrElem );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\service\server\afpsvcp.h ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.	   **/
/********************************************************************/

//***
//
// Filename: 	afpsvcp.h
//
// Description: This is the main header file for the AFP Server Service.
//
// History:
//		May 11,1992.	NarenG		Created original version.
//
#ifndef _AFPSVCP_
#define _AFPSVCP_

#include <nt.h>
#include <ntrtl.h>
#include <ntseapi.h>
#include <ntlsa.h>
#include <ntsam.h>
#include <ntsamp.h>
#include <nturtl.h>     // needed for winbase.h
#include <ntmsv1_0.h>
#include <samrpc.h>
#include <align.h>

#include <windows.h>	// Win32 base API's
#include <winuser.h>	// Needed for LoadString
#include <winsvc.h>	// Win32 service control stuff
#include <winreg.h>	// Win32 registry API's
#include <lm.h>
#include <srvann.h>
#include <rpc.h>	// RPC api's
#include <devioctl.h>	// FILE_DEVICE_NETWORK, METHOD_BUFFERD constants
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <wchar.h>
#include <search.h>

#if DBG
#define DEBUG	TRUE
#endif

#include <afpsvc.h>	// Generated by MIDL
#include <admin.h>
#include <macfile.h>
#include <afpcomn.h>
#include "events.h"
#include "ioctl.h"
#include "rasfmsub.h"
#include "debug.h"


#define LOGON_PROCESS_NAME  "SFM_SERVICE"

#define AFPSTATE_RPC_STARTED		0x1
#define AFPSTATE_FSD_LOADED		    0x2
#define AFPSTATE_BLOCKED_ON_DOMINFO 0x4

// Id's of the various data structures
//
typedef enum _AFP_STRUCTURE_TYPE {

    AFP_EXTENSION_STRUCT,
    AFP_TYPECREATOR_STRUCT,
    AFP_ICON_STRUCT,
    AFP_VOLUME_STRUCT,
    AFP_SERVER_STRUCT,
    AFP_DIRECTORY_STRUCT,
    AFP_SESSION_STRUCT,
    AFP_CONNECTION_STRUCT,
    AFP_MESSAGE_STRUCT,
    AFP_FILE_STRUCT,
    AFP_FINDER_STRUCT

} AFP_STRUCTURE_TYPE;

// The approximate times (in milliseconds) taken to respond to various
// service control requests.
//
#define AFP_SERVICE_INSTALL_TIME	15*60000	// 15 minutes
#define AFP_SERVICE_STOP_TIME		5*60000		// 5 minutes
#define AFP_SERVICE_CONTINUE_TIME	5000
#define AFP_SERVICE_PAUSE_TIME		1000

// Macro to calculate the byte offset of a field in a structure of type type.
//
#define AFP_FIELD_OFFSET(type, field)    ((LONG)((LONG_PTR)&(((type *)0)->field)))

// Macro to calculate the size of a given field within a structure.
//
#define AFP_FIELD_SIZE(type, field)    sizeof(((type *)0)->field)


// Access mask values
//
#define 	AFPSVC_ALL_ACCESS	0x0001

// All global variables are packaged within this structure.
//
typedef struct _AFP_GLOBALS {

    // Handle to the key that contains the server parameters
    //
    HKEY 		hkeyServerParams;

    // Handle to the key that contains the volumes list.
    //
    HKEY 		hkeyVolumesList;

    // Handle to the key that contains the list of Type/Creator/Comment tupples
    //
    HKEY 		hkeyTypeCreators;

    // Handle to the key that contains the list mapped extensions.
    //
    HKEY 		hkeyExtensions;

    // Handle to the key that contains the icon list.
    //
    HKEY 		hkeyIcons;

    // Service parameters
    //
    WCHAR		wchServerName[AFP_SERVERNAME_LEN+1];
    DWORD		dwServerOptions;
    DWORD		dwMaxSessions;
    WCHAR		wchLoginMsg[AFP_MESSAGE_LEN+1];
    DWORD		dwMaxPagedMem;
    DWORD		dwMaxNonPagedMem;
    WCHAR		wchCodePagePath[MAX_PATH+1];

    // Localizable strings
    //
    WCHAR		wchInvalid[100];
    WCHAR		wchDeleted[100];
    WCHAR		wchUnknown[100];
    WCHAR		wchDefTCComment[AFP_ETC_COMMENT_LEN+1];

    // Contains information about what components were initialized
    // successfully
    //
    DWORD		dwServerState;

    // Handle to the AFP Server FSD
    //
    HANDLE 		hFSD;

    // Handle used to announce the service status
    //
    SERVICE_STATUS_HANDLE hServiceStatus;

    SERVICE_STATUS	ServiceStatus;

    // This is a cache of ext/type/creator mappings
    //
    AFP_ETCMAP_INFO	AfpETCMapInfo;

    // Will contain the Id of the next type/creator that will be added to the
    // registry via the AfpAdminAddETCMap API.
    //
    DWORD		dwCurrentTCId;

    // Mutex handle for mutual exclusion around volume SetInfo/ Add/ Delete
    // ETC mappings registry and cache operations.
    //
    HANDLE		hmutexETCMap;

    // Mutex handle for mutual exclusion around volume SetInfo/ Add/ Delete
    // volume registry operations.
    //
    HANDLE		hmutexVolume;

    // This will be used by the server helper thread to inicate its
    // success or failure while initializing itself. The parent thread
    // can then take appropriate action.
    //
    HANDLE		heventSrvrHlprThread;

	// This is used by the server helper thread(s) to indicate that they have terminated
    //
	HANDLE		heventSrvrHlprThreadTerminate;

    // This is used in special case: if we have to terminate the helper thread when
    // it's blocked trying to get domain info
	HANDLE		heventSrvrHlprSpecial;

	DWORD		nThreadCount;

    DWORD		dwSrvrHlprCode;

	DWORD		dwSrvrHlprCount;

	NT_PRODUCT_TYPE	NtProductType;
	PSID		pSidNone;

} AFP_GLOBALS, *PAFP_GLOBALS;

#ifdef DEFINE_AFP_GLOBALS
AFP_GLOBALS		AfpGlobals;
HANDLE          SfmLsaHandle;
DWORD           SfmAuthPkgId;
#else
extern AFP_GLOBALS	AfpGlobals;
extern HANDLE       SfmLsaHandle;
extern DWORD        SfmAuthPkgId;
#endif

// prototypes of functions used across modules
//
VOID
AfpAnnounceServiceStatus(
	VOID
);

DWORD
AfpInitialize(
	VOID
);

VOID
AfpTerminate(
	VOID
);

DWORD
AfpRegGetKeyInfo(
	IN  HKEY    hKey,
	OUT LPDWORD lpdwMaxValNameLen,   // Longest valuename in this key
	OUT LPDWORD lpdwNumValues,	 // Number of values in this key
	OUT LPDWORD lpdwMaxValueDataSize // Max. size of value data.
);

DWORD
AfpRegOpen(
	VOID
);

VOID
AfpRegClose(
	VOID
);

DWORD
AfpRegVolumeAdd(
	IN PAFP_VOLUME_INFO  	pVolumeInfo
);

DWORD
AfpRegVolumeDelete(
	IN LPWSTR 		lpwsVolumeName
);

DWORD
AfpRegVolumeSetInfo(
	IN PAFP_VOLUME_INFO    	pVolumeInfo
);

DWORD
AfpRegExtensionEnum(
	VOID
);

DWORD
AfpRegTypeCreatorEnum(
	VOID
);

DWORD
AfpRegExtensionAdd(
	IN PAFP_EXTENSION	pAfpExtension
);

DWORD
AfpRegExtensionSetInfo(
	IN PAFP_EXTENSION	pAfpExtension
);

DWORD
AfpRegExtensionDelete(
	IN PAFP_EXTENSION	pAfpExtension
);

DWORD
AfpRegTypeCreatorSetInfo(
	IN PAFP_TYPE_CREATOR    pAfpTypeCreator
);

DWORD
AfpRegTypeCreatorAdd(
	IN PAFP_TYPE_CREATOR   	pAfpTypeCreator
);

DWORD
AfpRegTypeCreatorDelete(
	IN PAFP_TYPE_CREATOR 	pAfpTypeCreator
);

DWORD
AfpRegServerGetInfo(
	VOID
);

DWORD
AfpRegServerSetInfo(
	IN PAFP_SERVER_INFO 	pServerInfo,
	IN DWORD 		dwParmnum
);

DWORD
AfpRegServerGetCodePagePath(
	VOID
);

DWORD
AfpSecObjCreate(
	VOID
);

DWORD
AfpSecObjDelete(
	VOID
);

DWORD
AfpSecObjAccessCheck(
	IN  DWORD 		DesiredAccess,
	OUT LPDWORD 		pfAccessStatus 		
);

DWORD
AfpBufMakeFSDRequest(
	IN  LPBYTE  		pBuffer,
	IN  DWORD	        cbReqPktSize,	
	IN  AFP_STRUCTURE_TYPE	dwStructureId,	
	OUT LPBYTE 		*ppSelfRelativeBuf,	
	OUT LPDWORD		lpdwSelfRelativeBufSize
);

DWORD
AfpBufMakeFSDETCMappings(
	OUT PSRVETCPKT		*ppSrvSetEtc,
	OUT LPDWORD		lpdwSrvSetEtcBufSize
);

VOID
AfpBufOffsetToPointer(
	IN OUT LPBYTE		  pBuffer,
	IN     DWORD		  dwNumEntries,
	IN     AFP_STRUCTURE_TYPE dwStructureType
);

VOID
AfpBufCopyFSDETCMapInfo(
	IN  PAFP_TYPE_CREATOR 	pAfpTypeCreator,
	IN  PAFP_EXTENSION	pAfpExtension,
	OUT PETCMAPINFO2        pFSDETCMapInfo
);

VOID
AfpBufMakeFSDIcon(
	IN  PAFP_ICON_INFO 	pIconInfo,
	OUT LPBYTE	  	lpbFSDIcon,
	OUT LPDWORD	  	lpcbFSDIconSize
);

DWORD
AfpBufMakeMultiSz(
	IN  AFP_STRUCTURE_TYPE	dwStructureId,	
	IN  LPBYTE		pbStructure,
	OUT LPBYTE*		ppbMultiSz,
	OUT LPDWORD		lpdwMultiSzSize
);

DWORD
AfpBufParseMultiSz(
	IN  AFP_STRUCTURE_TYPE	dwStructureId,	
	IN  LPBYTE		pbMultiSz,
	OUT LPBYTE		pbStructure
);

DWORD
AfpBufStructureSize(
	IN  AFP_STRUCTURE_TYPE	dwStructureId,	
	IN LPBYTE		lpbStructure
);

DWORD
AfpBufUnicodeToNibble(
	IN OUT LPWSTR		lpwsData
);

void *
AfpBinarySearch(
	IN const void * pKey,
	IN const void * pBase,
	IN size_t num,
	IN size_t width,
	IN int (_cdecl *compare)(const void * pElem1, const void * pElem2 )
);

int
_cdecl
AfpBCompareTypeCreator(
	IN const void * pAfpTypeCreator1,
	IN const void * pAfpTypeCreatro2
);

int
_cdecl
AfpLCompareTypeCreator(
	IN const void * pAfpTypeCreator1,
	IN const void * pAfpTypeCreatro2
);

int
_cdecl
AfpBCompareExtension(
	IN const void * pAfpExtension1,
	IN const void * pAfpExtension2
);

int
_cdecl
AfpLCompareExtension(
	IN const void * pAfpExtension1,
	IN const void * pAfpExtension2
);


DWORD
AfpFSDOpen(
	OUT PHANDLE pFSD
);

DWORD
AfpFSDClose(
	IN HANDLE hFSD
);

DWORD
AfpFSDUnload(
	VOID
);

DWORD
AfpFSDLoad(
	VOID
);

DWORD
AfpFSDIOControl(
	IN  HANDLE	hFSD,
	IN  DWORD 	dwOpCode,
	IN  PVOID	pInbuf 		OPTIONAL,
	IN  DWORD	cbInbufLen,
	OUT PVOID	pOutbuf 	OPTIONAL,
	IN  DWORD	cbOutbuflen,
	OUT LPDWORD	cbBytesTransferred
);

DWORD
AfpCreateServerHelperThread(
	BOOL fIsFirstThread
);

VOID
AfpTerminateCurrentThread(
	VOID
);

DWORD
AfpInitServerHelper(
	VOID
);

DWORD
AfpServerHelper(
	IN LPVOID Parameter
);

VOID
AfpLogEvent(
    	IN DWORD    dwMessageId,
    	IN WORD     cNumberOfSubStrings,
        IN LPWSTR*  plpwsSubStrings,
     	IN DWORD    dwErrorCode,
     	IN WORD     wSeverity
);

VOID
AfpLogServerEvent(
	IN	PAFP_FSD_CMD_PKT	pAfpFsdCmd
);

VOID
AfpAddInvalidVolume(
	IN LPWSTR	lpwsName,
	IN LPWSTR	lpwsPath
);

VOID
AfpDeleteInvalidVolume(
	IN LPWSTR	lpwsVolumeName
);

DWORD
I_DirectorySetInfo(
	IN PAFP_DIRECTORY_INFO 	pAfpDirectoryInfo,
	IN DWORD	 	dwParmNum
);

DWORD
I_DirectoryGetInfo(
	IN LPWSTR 		  lpwsPath,
	OUT PAFP_DIRECTORY_INFO * ppAfpDirectoryInfo
);


RPC_STATUS  RPC_ENTRY
AfpRpcSecurityCallback( 
	IN  RPC_IF_HANDLE *InterfaceUuid,
	IN	VOID	*pvContext
);

#endif // _AFPSVCP_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\service\server\debug.c ===
/*****************************************************************************/
/**			 Microsoft LAN Manager				    **/
/**		   Copyright (C) Microsoft Corp., 1992			    **/
/*****************************************************************************/

//***
//	File Name:  debug.c
//
//	Function:   debug functions
//
//	History:
//
//	    05/21/92	Narendra Gidwani	- Original Version 1.0
//***


#include <ctype.h>
#include <stdarg.h>
#include <stdio.h>
#include <string.h>
#include "afpsvcp.h"

#include "debug.h"


#ifdef DBG
VOID
AfpAssert(
    IN PVOID FailedAssertion,
    IN PVOID FileName,
    IN ULONG LineNumber
    )
{
    BOOL ok;
    CHAR choice[16];
    DWORD bytes;
    DWORD error;

    AfpPrintf( "\nAssertion failed: %s\n  at line %ld of %s\n",
                FailedAssertion, LineNumber, FileName );
    do {
        AfpPrintf( "Break or Ignore [bi]? " );
        bytes = sizeof(choice);
        ok = ReadFile(
                GetStdHandle(STD_INPUT_HANDLE),
                &choice,
                bytes,
                &bytes,
                NULL
                );
        if ( ok ) {
            if ( toupper(choice[0]) == 'I' ) {
                break;
            }
            if ( toupper(choice[0]) == 'B' ) {
                DbgUserBreakPoint( );
            }
        } else {
            error = GetLastError( );
        }
    } while ( TRUE );

    return;

} // AfpAssert


VOID
AfpPrintf (
    char *Format,
    ...
    )

{
    va_list arglist;
    char OutputBuffer[1024];
    ULONG length;

    va_start( arglist, Format );

    vsprintf( OutputBuffer, Format, arglist );

    va_end( arglist );

    length = strlen( OutputBuffer );

    WriteFile( GetStdHandle(STD_OUTPUT_HANDLE), (LPVOID )OutputBuffer, length, &length, NULL );

} // AfpPrintf

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\service\server\debug.h ===
/*******************************************************************/
/*	      Copyright(c)  1992 Microsoft Corporation		   */
/*******************************************************************/


//***
//
// Filename:	debug.h
//
// Description: This module debug definitions for
//		the supervisor module.
//
// Author:	Narendra Gidwani (nareng)    May 22, 1992.
//
// Revision History:
//
//***



#ifndef _DEBUG_
#define _DEBUG_


#ifdef DBG

VOID
DbgUserBreakPoint(VOID);

#define DEBUG_INITIALIZATION            0x00000001
#define DEBUG_TERMINATION		0x00000002
#define DEBUG_FSM			0x00000004
#define DEBUG_TIMER			0x00000008

extern DWORD	AfpDebug;

//#define DEBUG if ( TRUE )
// #define IF_DEBUG(flag) if (SDebug & (DEBUG_ ## flag))

VOID
AfpPrintf (
    char *Format,
    ...
    );
#define AFP_PRINT(args) DbgPrint args

VOID
AfpAssert(
    IN PVOID FailedAssertion,
    IN PVOID FileName,
    IN ULONG LineNumber
    );
#define AFP_ASSERT(exp) if (!(exp)) AfpAssert( #exp, __FILE__, __LINE__ )

#else

#define AFP_PRINT(args)

#define AFP_ASSERT(exp)


#endif

#endif // ndef _DEBUG_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\service\server\file.c ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.	   **/
/********************************************************************/

//***
//
// Filename:	file.c
//
// Description: This module contains support routines for the file
//		category API's for the AFP server service. These routines
//		are called by the RPC runtime.
//
// History:
//		June 21,1992.	NarenG		Created original version.
//
#include "afpsvcp.h"

//**
//
// Call:	AfpAdminrFileEnum
//
// Returns:	NO_ERROR
//		ERROR_ACCESS_DENIED
//		non-zero returns from AfpServerIOCtrlGetInfo
//
// Description: This routine communicates with the AFP FSD to implement
//		the AfpAdminFileEnum function.
//
DWORD
AfpAdminrFileEnum(
	IN     AFP_SERVER_HANDLE    hServer,
	IN OUT PFILE_INFO_CONTAINER pInfoStruct,
	IN     DWORD 		    dwPreferedMaximumLength,
	OUT    LPDWORD 		    lpdwTotalEntries,
	OUT    LPDWORD 		    lpdwResumeHandle
)
{
AFP_REQUEST_PACKET AfpSrp;
DWORD		   dwRetCode=0;
DWORD		   dwAccessStatus=0;


    // Check if caller has access
    //
    if ( dwRetCode = AfpSecObjAccessCheck( AFPSVC_ALL_ACCESS, &dwAccessStatus))
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrFileEnum, AfpSecObjAccessCheck failed %ld\n",dwRetCode));
	    AfpLogEvent( AFPLOG_CANT_CHECK_ACCESS, 0, NULL,
		     dwRetCode, EVENTLOG_ERROR_TYPE );
        return( ERROR_ACCESS_DENIED );
    }

    if ( dwAccessStatus )
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrFileEnum, AfpSecObjAccessCheck returned %ld\n",dwAccessStatus));
        return( ERROR_ACCESS_DENIED );
    }

    // Set up request packet and make IOCTL to the FSD
    //
    AfpSrp.dwRequestCode 		= OP_FORK_ENUM;
    AfpSrp.dwApiType     		= AFP_API_TYPE_ENUM;
    AfpSrp.Type.Enum.cbOutputBufSize    = dwPreferedMaximumLength;

    if ( lpdwResumeHandle )
     	AfpSrp.Type.Enum.EnumRequestPkt.erqp_Index = *lpdwResumeHandle;
    else
     	AfpSrp.Type.Enum.EnumRequestPkt.erqp_Index = 0;

    dwRetCode = AfpServerIOCtrlGetInfo( &AfpSrp );

    if ( dwRetCode != ERROR_MORE_DATA && dwRetCode != NO_ERROR )
	return( dwRetCode );

    *lpdwTotalEntries 		= AfpSrp.Type.Enum.dwTotalAvail;
    pInfoStruct->pBuffer        = (PAFP_FILE_INFO)(AfpSrp.Type.Enum.pOutputBuf);
    pInfoStruct->dwEntriesRead  = AfpSrp.Type.Enum.dwEntriesRead;

    if ( lpdwResumeHandle )
    	*lpdwResumeHandle = AfpSrp.Type.Enum.EnumRequestPkt.erqp_Index;

    // Convert all offsets to pointers
    //
    AfpBufOffsetToPointer( (LPBYTE)(pInfoStruct->pBuffer),
			   pInfoStruct->dwEntriesRead,
			   AFP_FILE_STRUCT );

    return( dwRetCode );
}

//**
//
// Call:	AfpAdminrFileClose
//
// Returns:	NO_ERROR
//		ERROR_ACCESS_DENIED
//		non-zero returns from AfpServerIOCtrl
//
// Description: This routine communicates with the AFP FSD to implement
//		the AfpAdminFileClose function.
//
DWORD
AfpAdminrFileClose(
	IN AFP_SERVER_HANDLE 	hServer,
	IN DWORD 		dwFileId
)
{
AFP_REQUEST_PACKET AfpSrp;
AFP_FILE_INFO	   AfpFileInfo;
DWORD		   dwAccessStatus=0;
DWORD		   dwRetCode=0;

    // Check if caller has access
    //
    if ( dwRetCode = AfpSecObjAccessCheck( AFPSVC_ALL_ACCESS, &dwAccessStatus))
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrFileClose, AfpSecObjAccessCheck failed %ld\n",dwRetCode));
	    AfpLogEvent( AFPLOG_CANT_CHECK_ACCESS, 0, NULL,
		     dwRetCode, EVENTLOG_ERROR_TYPE );
        return( ERROR_ACCESS_DENIED );
    }

    if ( dwAccessStatus )
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrFileClose, AfpSecObjAccessCheck returned %ld\n",dwAccessStatus));
        return( ERROR_ACCESS_DENIED );
    }

    // The FSD expects an AFP_FILE_INFO structure with only the id field
    // filled in.
    //
    AfpFileInfo.afpfile_id = dwFileId;

    // IOCTL the FSD to close the file
    //
    AfpSrp.dwRequestCode 		= OP_FORK_CLOSE;
    AfpSrp.dwApiType     		= AFP_API_TYPE_DELETE;
    AfpSrp.Type.Delete.pInputBuf     	= &AfpFileInfo;
    AfpSrp.Type.Delete.cbInputBufSize   = sizeof(AFP_FILE_INFO);

    return ( AfpServerIOCtrl( &AfpSrp ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\service\server\ioctl.c ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.	   **/
/********************************************************************/

//***
//
// Filename:	ioctl.c
//
// Description: This module contains wrappers around the actual ioctl
//		call to the kernel mode FSD.
//
// History:
//	May 11,1992.	NarenG		Created original version.
//	
//	For Enums the FSD should use zero-based indexing.
//

#include "afpsvcp.h"

//**
//
// Call:	AfpServerIOCtrl
//
// Returns:	NO_ERROR	- success
//		non-zero returns from AfpFSDIOControl
//		ERROR_INVALID_PARAMETER 	
//
// Description: This procedure is a wrapper around the I/O control to the
//	 	AFP kernel mode FSD. It unmarshals the information in the
//		AFP_REQUEST_PACKET calls the driver and then marshalls the
//		returned information back into the AFP_REQUEST_PACKET and
//		returns.
//		
//		NOTE: This should never be called directly for Enum and
//		      GetInfo type requests. AfpServerIOCtrlGetInfo should
//		      be called. It will take care of buffer manipulation.
//
DWORD
AfpServerIOCtrl(
	IN PAFP_REQUEST_PACKET pAfpSrp
)
{
DWORD		cbBytesReturned;
PVOID		pInputBuffer       = NULL;
PVOID		pOutputBuffer      = NULL;
DWORD		cbInputBufferSize  = 0;
DWORD		cbOutputBufferSize = 0;
DWORD		dwRetCode;

    // Set up the input and output buffers depending on the type of operation
    //
    switch( pAfpSrp->dwApiType ) {
	
    // No input or output buffers requred for this type of API
    //
    case AFP_API_TYPE_COMMAND:
	break;

    // Input buffer contains information to be set.
    // No output buffer required.
    //
    case AFP_API_TYPE_SETINFO:

	pInputBuffer      = pAfpSrp->Type.SetInfo.pInputBuf;
	cbInputBufferSize = pAfpSrp->Type.SetInfo.cbInputBufSize;

        ((PSETINFOREQPKT)pInputBuffer)->sirqp_parmnum =
					pAfpSrp->Type.SetInfo.dwParmNum;
	break;

    case AFP_API_TYPE_ADD:

	pInputBuffer      = pAfpSrp->Type.Add.pInputBuf;
	cbInputBufferSize = pAfpSrp->Type.Add.cbInputBufSize;

	break;

    case AFP_API_TYPE_DELETE:

	pInputBuffer      = pAfpSrp->Type.Delete.pInputBuf;
	cbInputBufferSize = pAfpSrp->Type.Delete.cbInputBufSize;

	break;

    // Input buffer contains resume handle
    // Output buffer needed to hold returned data
    //
    case AFP_API_TYPE_ENUM:

        pInputBuffer       = (PVOID)&( pAfpSrp->Type.Enum.EnumRequestPkt );
	cbInputBufferSize  = sizeof( pAfpSrp->Type.Enum.EnumRequestPkt );

	pOutputBuffer      = pAfpSrp->Type.Enum.pOutputBuf;
	cbOutputBufferSize = pAfpSrp->Type.Enum.cbOutputBufSize;

	break;

    // Input buffer contains information regarding the entity for
    // which information is requested.
    // Output buffer will contain information regarding that entity.
    //
    case AFP_API_TYPE_GETINFO:

        pInputBuffer       = pAfpSrp->Type.GetInfo.pInputBuf;
	cbInputBufferSize  = pAfpSrp->Type.GetInfo.cbInputBufSize;

	pOutputBuffer      = pAfpSrp->Type.GetInfo.pOutputBuf;
	cbOutputBufferSize = pAfpSrp->Type.GetInfo.cbOutputBufSize;

	break;

    default:
	return( ERROR_INVALID_PARAMETER );

    }
	
    dwRetCode = AfpFSDIOControl( AfpGlobals.hFSD,
				 pAfpSrp->dwRequestCode,
			   	 pInputBuffer,
			         cbInputBufferSize,
			         pOutputBuffer,
			         cbOutputBufferSize,
				 &cbBytesReturned
				);

    if ( (dwRetCode != ERROR_MORE_DATA) && (dwRetCode != NO_ERROR) )
	return( dwRetCode );

    // If API was of Enum type store the Total number of entries read,
    // total number of available entries and resumable handle into the
    // Srp
    //
    if ( pAfpSrp->dwApiType == AFP_API_TYPE_ENUM ) {

	pAfpSrp->Type.Enum.dwEntriesRead =
				((PENUMRESPPKT)pOutputBuffer)->ersp_cInBuf;
	pAfpSrp->Type.Enum.dwTotalAvail =
				((PENUMRESPPKT)pOutputBuffer)->ersp_cTotEnts;
	pAfpSrp->Type.Enum.EnumRequestPkt.erqp_Index =
				((PENUMRESPPKT)pOutputBuffer)->ersp_hResume;

	// Shift the data to the start of the buffer, over-writing the
	// enum reponse information.
	//
	CopyMemory( pOutputBuffer,
		    (PVOID)((ULONG_PTR)pOutputBuffer+sizeof(ENUMRESPPKT)),
		    cbBytesReturned - sizeof(ENUMRESPPKT) );
    }

    // If API type was GetInfo, store the Total number of bytes available
    // and the total number of bytes read.
    //
    if ( pAfpSrp->dwApiType == AFP_API_TYPE_GETINFO )
	pAfpSrp->Type.GetInfo.cbTotalBytesAvail = cbBytesReturned;

    return( dwRetCode );
}

//**
//
// Call:	AfpServerIOCtrlGetInfo
//
// Returns:	NO_ERROR		- success
//		non-zero returns from DeviceIOCtrl
//		Non-zero returns from CreateEvent
//		ERROR_NOT_ENOUGH_MEMORY
//		ERROR_INVALID_PARAMETER 	
//
// Description: This is a wrapper around the AfpServerIOCtrl call for GetInfo
//		and Enum type calls that can return variable amounts of data.
//
//		For Enum calls, if AfpSrp.Enum.dwOutputBufSize == -1 it will
//		allocate and return ALL information that is available.
//		Otherwise it will allocate and return as much data that can
//		be contained in the AfpSrp.Enum.dwOutputBufSize parameter. The
//		caller of this procedure will set the value in
//		AfpSrp.Enum.dwOutputBufSize to be equal to the value of
//		MaxPreferredLength which was set by the caller of the Enum or
//		GetInfo API.
//
//		For GetInfo type calls AfpSrp.Enum.dwOutputBufSize == -1 always,
//		so this routine will always try to get ALL the available
//		information.
//
DWORD
AfpServerIOCtrlGetInfo(
	IN OUT PAFP_REQUEST_PACKET pAfpSrp
)
{
DWORD		dwRetCode;
BOOL		fGetEverything = FALSE;
PVOID		pOutputBuf;

    // Set up the output buffers
    //
    switch( pAfpSrp->dwApiType ) {
	
    case AFP_API_TYPE_ENUM:

	// Find out how much data the client wants.
  	//
 	if ( pAfpSrp->Type.Enum.cbOutputBufSize == -1 ) {

	    // Client wants everything, so allocate a default size buffer
	    //
	    pAfpSrp->Type.Enum.cbOutputBufSize = AFP_INITIAL_BUFFER_SIZE +
					         sizeof(ENUMRESPPKT);
	    fGetEverything = TRUE;

	}
	else {
	
	    // Otherwise just allocate enough for what the client wants
	    //
	    pAfpSrp->Type.Enum.cbOutputBufSize += sizeof(ENUMRESPPKT);
	}

	pOutputBuf = MIDL_user_allocate( pAfpSrp->Type.Enum.cbOutputBufSize );

	if ( pOutputBuf == NULL )
	    return( ERROR_NOT_ENOUGH_MEMORY );
	
	pAfpSrp->Type.Enum.pOutputBuf = pOutputBuf;

	break;

    case AFP_API_TYPE_GETINFO:

	// Client will ALWAYS want everything
	//
	pAfpSrp->Type.GetInfo.cbOutputBufSize = AFP_INITIAL_BUFFER_SIZE;

	pOutputBuf = MIDL_user_allocate(pAfpSrp->Type.GetInfo.cbOutputBufSize);

	if ( pOutputBuf == NULL )
	    return( ERROR_NOT_ENOUGH_MEMORY );

	pAfpSrp->Type.GetInfo.pOutputBuf = pOutputBuf;

	fGetEverything = TRUE;

    	break;

    default:
	return( ERROR_INVALID_PARAMETER );

    }

    // Make the IOCTL to the FSD
    //
    dwRetCode = AfpServerIOCtrl( pAfpSrp );

    if ( (dwRetCode != NO_ERROR) && (dwRetCode != ERROR_MORE_DATA) ) {
     	MIDL_user_free( pOutputBuf );
        return( dwRetCode );
    }
	
    // If we have obtained all requested data then we are done
    //
    if ( !(( dwRetCode == ERROR_MORE_DATA ) && fGetEverything ))
        return( dwRetCode );

    // Otherwise the client wants more data and there is more to be obtained
    //
    if ( pAfpSrp->dwApiType == AFP_API_TYPE_ENUM ) {

	// Increase the buffer size using a heuristic.
	//
	MIDL_user_free( pOutputBuf );
	pAfpSrp->Type.Enum.cbOutputBufSize = pAfpSrp->Type.Enum.dwTotalAvail
					   * AFP_AVG_STRUCT_SIZE
			  		   + AFP_INITIAL_BUFFER_SIZE
					   + sizeof(ENUMRESPPKT);

	pOutputBuf = MIDL_user_allocate( pAfpSrp->Type.Enum.cbOutputBufSize );

	if ( pOutputBuf == NULL )
	    return( ERROR_NOT_ENOUGH_MEMORY );
		
	pAfpSrp->Type.Enum.pOutputBuf = pOutputBuf;

	// If we are trying to get all the information then we reset the
	// resume handle to 0
	//
	if ( fGetEverything )
	    pAfpSrp->Type.Enum.EnumRequestPkt.erqp_Index = 0;
    }


    if ( pAfpSrp->dwApiType == AFP_API_TYPE_GETINFO ) {

    	// Increase the buffer size using the total available number
	// of bytes + Fudge Factor.
	//
	MIDL_user_free( pOutputBuf );

	pAfpSrp->Type.GetInfo.cbOutputBufSize =
			     pAfpSrp->Type.GetInfo.cbTotalBytesAvail +
			     AFP_INITIAL_BUFFER_SIZE;

	pOutputBuf=MIDL_user_allocate( pAfpSrp->Type.GetInfo.cbOutputBufSize );

	if ( pOutputBuf == NULL )
	    return( ERROR_NOT_ENOUGH_MEMORY );
		
	pAfpSrp->Type.GetInfo.pOutputBuf = pOutputBuf;
    }

	
    // Make the IOCTL to the FSD, if we dont get all the data this time
    // we give up and return to the caller.
    //
    dwRetCode = AfpServerIOCtrl( pAfpSrp );
	
    if ( (dwRetCode != NO_ERROR) && (dwRetCode != ERROR_MORE_DATA) )
        MIDL_user_free( pOutputBuf );

    return( dwRetCode );
		
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\service\server\init.c ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.	   **/
/********************************************************************/

//***
//
// Filename:	init.c
//
// Description: This module contains code to intialize and de-initialize
//		the AFP Server, RPC server, the security object and
//		other global vriables.
//
// History:
//		May 11,1992.	NarenG		Created original version.
//
//
#include "afpsvcp.h"

// Prototypes of functions used only within this module.
//
DWORD
AfpInitServerVolumes(
	VOID
);

DWORD
AfpInitServerParameters(
	VOID
);

DWORD
AfpInitServerIcons(
	VOID
);

DWORD
AfpInitETCMaps(
	VOID
);

DWORD
AfpInitRPC(
	VOID
);

DWORD
AfpInitServerDomainOffsets(
	VOID
);

VOID
AfpTerminateRPC(
	VOID
);


VOID
AfpIniLsa(
	VOID
);


BOOL
IsAfpGuestAccountEnabled(
    VOID
);

//**
//
// Call:	AfpInitialize
//
// Returns:	NO_ERROR
//
// Description:	Will do all server intialization.
//		1) Create the security object.
//		2) Set up the server for RPC.
//		3) Open all the registry keys that store AFP data.
//		4) Get the handle to the FSD.
//		5) Get default server parameters
//		6) It will initialize the AFP Server with volume, ETC, icon
//		   and server parameter information.
//		7) IOCTL the FSD to start the server.
//
DWORD
AfpInitialize(
	VOID
)
{
AFP_REQUEST_PACKET	AfpRequestPkt;
DWORD			dwRetCode;
BOOL			fFirstThread;
DWORD			nThreads;




    // Load strings from resource file
    //
    if (( !LoadString( GetModuleHandle( NULL ), 1, AfpGlobals.wchUnknown, 100 ))
	||
        ( !LoadString( GetModuleHandle( NULL ), 2, AfpGlobals.wchInvalid, 100 ))
	||
        ( !LoadString( GetModuleHandle( NULL ), 3, AfpGlobals.wchDeleted, 100 ))
	||
        ( !LoadString( GetModuleHandle( NULL ), 4, AfpGlobals.wchDefTCComment,
    		       AFP_ETC_COMMENT_LEN+1 )))
	AfpLogEvent( AFPLOG_CANT_LOAD_RESOURCE, 0, NULL,
		     GetLastError(), EVENTLOG_WARNING_TYPE );

    //
    // Create the security object
    //
    if ( dwRetCode = AfpSecObjCreate() ) {
	AfpLogEvent( AFPLOG_CANT_CREATE_SECOBJ, 0, NULL,
		     dwRetCode, EVENTLOG_ERROR_TYPE );
	return( dwRetCode );
    }

    // Initialize the server to accept RPC calls
    //
    if ( dwRetCode = AfpInitRPC() ) {
	AfpLogEvent( AFPLOG_CANT_INIT_RPC, 0, NULL,
		     dwRetCode, EVENTLOG_ERROR_TYPE );
	return( dwRetCode );
    }

    AfpGlobals.dwServerState |= AFPSTATE_RPC_STARTED;

    // Open the registry keys where AFP Server information is stored
    //
    if ( dwRetCode = AfpRegOpen() ) {
	AfpLogEvent( AFPLOG_CANT_OPEN_REGKEY, 0, NULL,
		     dwRetCode, EVENTLOG_ERROR_TYPE );
	return( dwRetCode );
    }

    AfpGlobals.ServiceStatus.dwCheckPoint++;
    AfpAnnounceServiceStatus();

    // Open and load the AFP Server FSD and obtain a handle to it
    //
    if ( dwRetCode = AfpFSDLoad() ) {
	AfpLogEvent( AFPLOG_CANT_LOAD_FSD, 0, NULL,
		     dwRetCode, EVENTLOG_ERROR_TYPE );
	return( dwRetCode );
    }

    AfpGlobals.dwServerState |= AFPSTATE_FSD_LOADED;

    if ( dwRetCode = AfpFSDOpen( &(AfpGlobals.hFSD) ) ) {
	AfpLogEvent( AFPLOG_CANT_OPEN_FSD, 0, NULL,
		     dwRetCode, EVENTLOG_ERROR_TYPE );
	return( dwRetCode );
    }

	// Query the product type of server.
	//
	AfpGlobals.pSidNone = NULL;
	RtlGetNtProductType ( &(AfpGlobals.NtProductType) );

    // Create the event object for the server helper thread.
    //
    if ( (AfpGlobals.heventSrvrHlprThread =
					CreateEvent( NULL, FALSE, FALSE, NULL ) ) == NULL){
	AfpLogEvent( AFPLOG_CANT_START, 0, NULL, GetLastError(),
		     EVENTLOG_ERROR_TYPE );
	return( GetLastError() );
    }

    // Create the event object for the server helper thread termination.
    //
    if ( (AfpGlobals.heventSrvrHlprThreadTerminate =
                                CreateEvent( NULL, FALSE, FALSE, NULL ) ) == NULL){
	AfpLogEvent( AFPLOG_CANT_START, 0, NULL, GetLastError(),
		     EVENTLOG_ERROR_TYPE );
	return( GetLastError() );
    }

    // Create the event object for the "special case" unblocking of server helper thread
    //
    if ( (AfpGlobals.heventSrvrHlprSpecial =
                                CreateEvent( NULL, FALSE, FALSE, NULL ) ) == NULL){
	AfpLogEvent( AFPLOG_CANT_START, 0, NULL, GetLastError(),
		     EVENTLOG_ERROR_TYPE );
	return( GetLastError() );
    }

    // Create server helper threads. The parameter indicates if this is the
    // first thread that is being created.
    //
    fFirstThread = TRUE;
    nThreads     = 0;

    do {

    	if ( ( dwRetCode = AfpCreateServerHelperThread( fFirstThread ) )
								!= NO_ERROR ) {
	    AfpLogEvent( AFPLOG_CANT_CREATE_SRVRHLPR, 0, NULL,
			 dwRetCode, EVENTLOG_ERROR_TYPE );

	    if ( fFirstThread ) {
	        AfpLogEvent( AFPLOG_CANT_START, 0, NULL,
			     dwRetCode, EVENTLOG_ERROR_TYPE );
	    	return( dwRetCode );
	    }
        }

        // Wait for the server helper thread to indicate if it successfully
        // initialized itself.
        //
        WaitForSingleObject( AfpGlobals.heventSrvrHlprThread, INFINITE );

        if ( AfpGlobals.dwSrvrHlprCode != NO_ERROR ) {
	        AfpLogEvent(AFPLOG_CANT_INIT_SRVRHLPR,
			            0,	
			            NULL,
			            AfpGlobals.dwSrvrHlprCode,
			            EVENTLOG_ERROR_TYPE );

	        if ( fFirstThread )
            {
    	        AFP_PRINT( ( "SFMSVC: can't start macfile, first thread failed %ld\n",
                        AfpGlobals.dwSrvrHlprCode));	
	            AfpLogEvent( AFPLOG_CANT_START, 0, NULL, dwRetCode,
			                 EVENTLOG_ERROR_TYPE );
            	return( AfpGlobals.dwSrvrHlprCode );
	        }
    	}

	    fFirstThread = FALSE;

    }while( ++nThreads < NUM_SECURITY_UTILITY_THREADS );

    // Read in server parameters from the registry and intialize the
    // server with them.
    //
    if ( dwRetCode = AfpInitServerParameters())
    {
        AFP_PRINT( ( "SFMSVC: AfpInitServerParameters failed %ld\n",dwRetCode));
	    AfpLogEvent( AFPLOG_CANT_INIT_SRVR_PARAMS, 0, NULL, dwRetCode,EVENTLOG_ERROR_TYPE );
	    return( dwRetCode );
    }


    AfpGlobals.ServiceStatus.dwCheckPoint++;
    AfpAnnounceServiceStatus();


    // Read in the ETC Mappings and initialize the AFP Server with them
    // Also create a private cache of this information.
    //
    if ( dwRetCode = AfpInitETCMaps() )
    {
        AFP_PRINT( ( "SFMSVC: AfpInitETCMaps failed %ld\n",dwRetCode));
	    AfpLogEvent( AFPLOG_CANT_INIT_ETCINFO, 0, NULL, dwRetCode,EVENTLOG_ERROR_TYPE );
	    return( dwRetCode );
    }


    if ( dwRetCode = AfpInitServerIcons() )
    {
        AFP_PRINT( ( "SFMSVC: AfpInitServerIcons failed %ld\n",dwRetCode));
	    AfpLogEvent( AFPLOG_CANT_INIT_ICONS, 0, NULL, dwRetCode ,EVENTLOG_ERROR_TYPE );
	    return( dwRetCode );
    }


    AfpGlobals.ServiceStatus.dwCheckPoint++;
    AfpAnnounceServiceStatus();

    // Read in any volumes and initialize the server with them
    //
    if ( dwRetCode = AfpInitServerVolumes() )
    {
        AFP_PRINT( ( "SFMSVC: AfpInitServerVolumes failed %ld\n",dwRetCode));
	    AfpLogEvent( AFPLOG_CANT_INIT_VOLUMES, 0, NULL, dwRetCode,EVENTLOG_ERROR_TYPE );
	    return( dwRetCode );
    }


    // Create mutex objects around volume operations to avoid simultaneous
    // writing in the registry.
    //
    if ( (AfpGlobals.hmutexVolume = CreateMutex( NULL, FALSE, NULL ) ) == NULL)
    {
        AFP_PRINT( ( "SFMSVC: CreateMutex failed in AfpInitialize\n"));
	    AfpLogEvent( AFPLOG_CANT_START, 0, NULL, dwRetCode,EVENTLOG_ERROR_TYPE );
	    return( GetLastError() );
    }

    // Create mutex objects around ETCMap operations.
    //
    if ( (AfpGlobals.hmutexETCMap = CreateMutex( NULL, FALSE, NULL ) ) == NULL)
    {
        AFP_PRINT( ( "SFMSVC: CreateMutex 2 failed in AfpInitialize\n"));
	    AfpLogEvent( AFPLOG_CANT_START, 0, NULL, GetLastError(),EVENTLOG_ERROR_TYPE );
	    return( GetLastError() );
    }

    // OK we are all set to go so lets tell the AFP Server to start
    //
    AfpRequestPkt.dwRequestCode = OP_SERVICE_START;
    AfpRequestPkt.dwApiType     = AFP_API_TYPE_COMMAND;

     AFP_PRINT( ( "SFMSVC: ioctling sfmsrv to start\n"));

    if ( dwRetCode = AfpServerIOCtrl( &AfpRequestPkt ) )
    {
        AFP_PRINT( ( "SFMSVC: AfpServerIOCtrl to start sfmsrv failed %ld\n",dwRetCode));
	    AfpLogEvent( AFPLOG_CANT_START,0,NULL,dwRetCode,EVENTLOG_ERROR_TYPE);
	    return( dwRetCode );
    }


    AfpIniLsa();

    return( NO_ERROR );

}

//**
//
// Call:	AfpTerminate
//
// Returns:	none.
//
// Description: This procedure will shut down the server, and do any
//		clean up if required.
//
VOID
AfpTerminate(
	VOID
)
{
AFP_REQUEST_PACKET	AfpRequestPkt;
DWORD			dwRetCode;


    // If the FSD was loaded
    //
    if ( AfpGlobals.dwServerState & AFPSTATE_FSD_LOADED ) {

    	// Tell the server to shut down
    	//
    	AfpRequestPkt.dwRequestCode = OP_SERVICE_STOP;
    	AfpRequestPkt.dwApiType     = AFP_API_TYPE_COMMAND;

    	if ( dwRetCode = AfpServerIOCtrl( &AfpRequestPkt ) )
	    AfpLogEvent( AFPLOG_CANT_STOP, 0, NULL,
			 dwRetCode, EVENTLOG_ERROR_TYPE );
    }

    AfpGlobals.ServiceStatus.dwCheckPoint++;
    AfpAnnounceServiceStatus();

    // Try to close the FSD
    //
    if ( AfpGlobals.hFSD != NULL )
    {
    	if ( dwRetCode = AfpFSDClose( AfpGlobals.hFSD ) )
        {
	        AfpLogEvent( AFPLOG_CANT_STOP, 0, NULL,
			                dwRetCode, EVENTLOG_ERROR_TYPE );
        }

        // Try to unload the FSD
        //
        if ( dwRetCode = AfpFSDUnload() )
        {
	        AfpLogEvent( AFPLOG_CANT_STOP, 0, NULL,
                            dwRetCode, EVENTLOG_ERROR_TYPE);
        }
    }
	
    AfpGlobals.ServiceStatus.dwCheckPoint++;
    AfpAnnounceServiceStatus();

    // Delete the security object.
    //
    AfpSecObjDelete();

    // De-initialize the RPC server
    //
    AfpTerminateRPC();

    // Close the registry keys.
    //
    AfpRegClose();

	// Free the pSidNone if we allocated it for standalone
	//
	if (AfpGlobals.pSidNone != NULL)
	{
		LocalFree(AfpGlobals.pSidNone);
		AfpGlobals.pSidNone = NULL;
	}

    if (SfmLsaHandle != NULL)
    {
        LsaDeregisterLogonProcess( SfmLsaHandle );
        SfmLsaHandle = NULL;
    }

    return;

}

//**
//
// Call:	AfpInitServerParameters
//
// Returns:	NO_ERROR
//		non-zero return codes from the IOCTL or other system calls.
//
// Description: This procedure will set default values for parameters. It
//		will then call AfpRegServerGetInfo to override these defaults
//		with any parameters that may be stored in the registry. It
//		will then initialize the FSD with these parameters.
//
DWORD
AfpInitServerParameters(
	VOID
)
{
AFP_SERVER_INFO	 	AfpServerInfo;
DWORD			cbServerNameSize;
DWORD			dwRetCode;
AFP_REQUEST_PACKET	AfpRequestPkt;


    // Initialize all the server parameters with defaults
    //
    cbServerNameSize = sizeof( AfpGlobals.wchServerName );
    if ( !GetComputerName( AfpGlobals.wchServerName, &cbServerNameSize ) )
	return( GetLastError() );

    AfpGlobals.dwMaxSessions     	= AFP_DEF_MAXSESSIONS;
    AfpGlobals.dwServerOptions   	= AFP_DEF_SRVOPTIONS;
    AfpGlobals.wchLoginMsg[0]    	= TEXT('\0');
    AfpGlobals.dwMaxPagedMem		= AFP_DEF_MAXPAGEDMEM;
    AfpGlobals.dwMaxNonPagedMem		= AFP_DEF_MAXNONPAGEDMEM;

    // Read in any server parameters in the registry. Registry parameters
    // will override the defaults set above.
    //
    if ( dwRetCode = AfpRegServerGetInfo() )
	return( dwRetCode );

    if (IsAfpGuestAccountEnabled())
    {
        AfpGlobals.dwServerOptions |= AFP_SRVROPT_GUESTLOGONALLOWED;
    }
    else
    {
        AfpGlobals.dwServerOptions &= ~AFP_SRVROPT_GUESTLOGONALLOWED;
    }

    // Get the path to the codepage
    //
    if ( dwRetCode = AfpRegServerGetCodePagePath() )
	return( dwRetCode );

    // Set up server info structure
    //
    AfpServerInfo.afpsrv_name 		  = AfpGlobals.wchServerName;
    AfpServerInfo.afpsrv_max_sessions     = AfpGlobals.dwMaxSessions;
    AfpServerInfo.afpsrv_options          = AfpGlobals.dwServerOptions;
	if (AfpGlobals.NtProductType != NtProductLanManNt)
	{
		AfpServerInfo.afpsrv_options |= AFP_SRVROPT_STANDALONE;
	}
	AfpServerInfo.afpsrv_login_msg        = AfpGlobals.wchLoginMsg;
    AfpServerInfo.afpsrv_max_paged_mem    = AfpGlobals.dwMaxPagedMem;
    AfpServerInfo.afpsrv_max_nonpaged_mem = AfpGlobals.dwMaxNonPagedMem;
    AfpServerInfo.afpsrv_codepage	  = AfpGlobals.wchCodePagePath;

    // Make this buffer self-relative.
    //
    if ( dwRetCode = AfpBufMakeFSDRequest(
			(LPBYTE)&AfpServerInfo,
			sizeof(SETINFOREQPKT),
			AFP_SERVER_STRUCT,
			(LPBYTE*)&(AfpRequestPkt.Type.SetInfo.pInputBuf),
		        &(AfpRequestPkt.Type.SetInfo.cbInputBufSize)))
    {
	return( dwRetCode );
    }

    // IOCTL the FSD to set the server parameters
    //
    AfpRequestPkt.dwRequestCode 	 = OP_SERVER_SET_INFO;
    AfpRequestPkt.dwApiType 		 = AFP_API_TYPE_SETINFO;
    AfpRequestPkt.Type.SetInfo.dwParmNum = AFP_SERVER_PARMNUM_ALL;

    dwRetCode = AfpServerIOCtrl( &AfpRequestPkt );

    LocalFree( AfpRequestPkt.Type.SetInfo.pInputBuf );

    return( dwRetCode );

}

//**
//
// Call:	AfpInitServerVolumes
//
// Returns:	NO_ERROR - success
//		ERROR_NOT_ENOUGH_MEMORY
//		non-zero return codes from registry apis.
//
// Description: This procedure will read in a volume at a time from the
//		registry, and then register this volume with the server.
//		This procedure will only return fatal errors that will
//		require that the service to fail initialization. All other
//		error will be logged by this routine. All returns from the
//		the FSD are treated as non-fatal.
//
DWORD
AfpInitServerVolumes(
	VOID
)
{
DWORD		 	dwRetCode;
LPWSTR  	 	lpwsValName, lpwsSrcIconPath, lpwsDstIconPath;
DWORD		 	dwMaxValNameLen;
DWORD			dwValNameBufSize;
DWORD		 	dwNumValues;
DWORD		 	dwMaxValueDataSize;
DWORD		 	dwIndex;
DWORD		 	dwType;
DWORD			dwBufSize;
AFP_REQUEST_PACKET	AfpRequestPkt;
AFP_VOLUME_INFO 	VolumeInfo;
LPBYTE			lpbMultiSz;
LPBYTE			lpbFSDBuf;
DWORD			dwLength;
DWORD			dwCount;
WCHAR wchServerIconFile[AFPSERVER_VOLUME_ICON_FILE_SIZE] = AFPSERVER_VOLUME_ICON_FILE;
BOOLEAN			fCopiedIcon;
DWORD			dwLastDstCharIndex;

    // Find out the size of the largest data value and the largest
    // value name.
    //
    if ( dwRetCode = AfpRegGetKeyInfo( AfpGlobals.hkeyVolumesList,
				       &dwMaxValNameLen,
				       &dwNumValues,
				       &dwMaxValueDataSize
				      ))
   	return( dwRetCode );

    // If there are no volumes to add then simply return
    //
    if ( dwNumValues == 0 )
	return( NO_ERROR );
	
    if (( lpwsValName = (LPWSTR)LocalAlloc( LPTR, dwMaxValNameLen ) ) == NULL )
	return( ERROR_NOT_ENOUGH_MEMORY );

    if ((lpbMultiSz = (LPBYTE)LocalAlloc( LPTR, dwMaxValueDataSize )) == NULL ){
	LocalFree( lpwsValName );
	return( ERROR_NOT_ENOUGH_MEMORY );
    }

    if (( lpwsSrcIconPath = (LPWSTR)LocalAlloc( LPTR, (MAX_PATH+1) * sizeof(WCHAR) ) ) == NULL )
	{
		LocalFree( lpwsValName );
		LocalFree( lpbMultiSz );
		return( ERROR_NOT_ENOUGH_MEMORY );
	}

    if (( lpwsDstIconPath = (LPWSTR)LocalAlloc( LPTR, (MAX_PATH +
						   AFPSERVER_VOLUME_ICON_FILE_SIZE + 1 +
						   (sizeof(AFPSERVER_RESOURCE_STREAM)/sizeof(WCHAR))) *
						   sizeof(WCHAR)) ) == NULL )
	{
		LocalFree( lpwsValName );
		LocalFree( lpbMultiSz );
		LocalFree( lpwsSrcIconPath );
		return( ERROR_NOT_ENOUGH_MEMORY );
	}

	// Construct a path to the NTSFM volume custom icon
	//
	*lpwsSrcIconPath = 0;
	if ( GetSystemDirectory( lpwsSrcIconPath, MAX_PATH+1 ))
	{
		wcscat( lpwsSrcIconPath, AFP_DEF_VOLICON_SRCNAME );
	}
	else
	{
		LocalFree( lpwsValName );
		LocalFree( lpbMultiSz );
		LocalFree( lpwsSrcIconPath );
		LocalFree( lpwsDstIconPath );
		return( GetLastError() );
	}


    for ( dwIndex 		= 0,
	  dwBufSize 		= dwMaxValueDataSize,
	  dwValNameBufSize 	= dwMaxValNameLen;

	  dwIndex < dwNumValues;

	  dwIndex++,
	  dwBufSize 		= dwMaxValueDataSize,
	  dwValNameBufSize 	= dwMaxValNameLen ) {
				
	ZeroMemory( lpbMultiSz, dwBufSize );

	// Get the volume info from the registry in multi-sz form.
  	//
	if ( dwRetCode = RegEnumValue( AfpGlobals.hkeyVolumesList,
				       dwIndex,
				       lpwsValName,
				       &dwValNameBufSize,
				       NULL,
				       &dwType,
				       lpbMultiSz,
				       &dwBufSize
				      ))
	    break;

	// Parse the mult sz and extract info into volume info structure
 	//
	if ( dwRetCode = AfpBufParseMultiSz(
					AFP_VOLUME_STRUCT,
					lpbMultiSz,
					(LPBYTE)&VolumeInfo ) ) {

	    // If this volume contained invalid registry information then log
	    // it and store the volume name in the list of invalid volumes.
	    //
	    AfpAddInvalidVolume( lpwsValName, NULL );

	    AfpLogEvent( AFPLOG_INVALID_VOL_REG,1,&lpwsValName,
			 dwRetCode, EVENTLOG_WARNING_TYPE );
	    dwRetCode = NO_ERROR;
	    continue;
	}

	// Insert the volume name viz. the valuename
	//
	VolumeInfo.afpvol_name = lpwsValName;

	// Validate the volume info structure
	//
	if ( !IsAfpVolumeInfoValid( AFP_VALIDATE_ALL_FIELDS, &VolumeInfo ) ) {

	    // If this volume contained invalid registry information then log
	    // it and store the volume name in the list of invalid volumes.
	    //
	    AfpAddInvalidVolume( lpwsValName, NULL );

	    AfpLogEvent( AFPLOG_INVALID_VOL_REG,1,&lpwsValName,
			 dwRetCode, EVENTLOG_WARNING_TYPE );
	    dwRetCode = NO_ERROR;
	    continue;
	}

	// If there is a password then decrypt it
	//
	if ( VolumeInfo.afpvol_password != (LPWSTR)NULL ){
	
	    dwLength = STRLEN( VolumeInfo.afpvol_password );

	    for ( dwCount = 0; dwCount < dwLength; dwCount++ )
	    	VolumeInfo.afpvol_password[dwCount] ^= 0xF000;
	}

	//
	// Construct a path to the destination volume "Icon<0D>" file
	//

	fCopiedIcon = FALSE;

	wcscpy( lpwsDstIconPath, VolumeInfo.afpvol_path );
	if (lpwsDstIconPath[wcslen(lpwsDstIconPath) - 1] != TEXT('\\'))
	{
		wcscat( lpwsDstIconPath, TEXT("\\") );
	}
	wcscat( lpwsDstIconPath, wchServerIconFile );
	// Keep track of end of name without the resource fork tacked on
	//
	dwLastDstCharIndex = wcslen(lpwsDstIconPath);
	wcscat( lpwsDstIconPath, AFPSERVER_RESOURCE_STREAM );

	// Copy the icon file to the root of the volume (do not overwrite)
	//
	if ((fCopiedIcon = (BOOLEAN)CopyFile( lpwsSrcIconPath, lpwsDstIconPath, TRUE )) ||
	   (GetLastError() == ERROR_FILE_EXISTS))
	{
		VolumeInfo.afpvol_props_mask |= AFP_VOLUME_HAS_CUSTOM_ICON;

	    // Make sure the file is hidden
		SetFileAttributes( lpwsDstIconPath,
						   FILE_ATTRIBUTE_HIDDEN |
						    FILE_ATTRIBUTE_ARCHIVE );
	}


	// Make this a self relative buffer
	//
	if ( dwRetCode = AfpBufMakeFSDRequest(
					(LPBYTE)&VolumeInfo,
					0,
					AFP_VOLUME_STRUCT,
					&lpbFSDBuf,
					&dwBufSize
				        ))
	    break;

	// Initialize the FSD with this volume
	//
    	AfpRequestPkt.dwRequestCode 	      = OP_VOLUME_ADD;
        AfpRequestPkt.dwApiType 	      = AFP_API_TYPE_ADD;	
    	AfpRequestPkt.Type.Add.pInputBuf      = lpbFSDBuf;
    	AfpRequestPkt.Type.Add.cbInputBufSize = dwBufSize;

    	dwRetCode = AfpServerIOCtrl( &AfpRequestPkt );

		if ( dwRetCode ) {
	
			// If this volume could not be added by the FSD then we errorlog
			// this and insert this volume into the list of invalid volumes.
			//
			AfpAddInvalidVolume( lpwsValName, VolumeInfo.afpvol_path );
	
			AfpLogEvent( AFPLOG_CANT_ADD_VOL, 1, &lpwsValName,
				 dwRetCode, EVENTLOG_WARNING_TYPE );
			dwRetCode = NO_ERROR;

			// Delete the icon file we just copied if the volume add failed
			//
			if ( fCopiedIcon )
			{
				// Truncate the resource fork name so we delete the whole file
				lpwsDstIconPath[dwLastDstCharIndex] = 0;
				DeleteFile( lpwsDstIconPath );
			}

		}
	
    	LocalFree( lpbFSDBuf );
    }

    LocalFree( lpwsValName );
    LocalFree( lpbMultiSz );
	LocalFree( lpwsSrcIconPath );
	LocalFree( lpwsDstIconPath );

    return( dwRetCode );
}

//**
//
// Call:	AfpInitETCMaps
//
// Returns:	NO_ERROR	success
//		non-zero returns from the IOCTL
//		non-zero returns from the AfpRegXXX apis.
//		
//
// Description: This routine will read in all the type/creators and extensions
//		from the registry and store them in a cache. It will then
//		create a list of mappings from the cache and then IOCTL the
//		the FSD to add them. If the default is not in the registry,
//		a hardcoded one is used. All non-zero returns from this
//		routine are fatal. All non-fatal errors will be logged.
//		
//
DWORD
AfpInitETCMaps(
	VOID
)
{
DWORD 			dwRetCode;
AFP_REQUEST_PACKET	AfpSrp;
AFP_EXTENSION		DefExtension;
AFP_TYPE_CREATOR	DefTypeCreator;
BYTE			bDefaultETC[sizeof(ETCMAPINFO2)+sizeof(SETINFOREQPKT)];
PAFP_TYPE_CREATOR	pTypeCreator;
DWORD	    		dwNumTypeCreators;
AFP_TYPE_CREATOR	AfpTypeCreatorKey;

    // Get all type-creators from the registry and store them in a global cache.
    //
    if ( dwRetCode = AfpRegTypeCreatorEnum() )
	return( dwRetCode );

    // Get all extensions from the registry and store them in a global cache.
    //
    if ( dwRetCode = AfpRegExtensionEnum() )
	return( dwRetCode );

    // If there are no mappings do not IOCTL.
    //
    if ( AfpGlobals.AfpETCMapInfo.afpetc_num_extensions > 0 ) {

    	// IOCTL the FSD to Add these mappings
    	//
    	AfpSrp.dwRequestCode   = OP_SERVER_ADD_ETC;
    	AfpSrp.dwApiType       = AFP_API_TYPE_ADD;

    	// Make a buffer with the type/creator mappings in the form as required
    	// by the FSD
    	//
    	if ( dwRetCode = AfpBufMakeFSDETCMappings(
				(PSRVETCPKT*)&(AfpSrp.Type.Add.pInputBuf),
    				&(AfpSrp.Type.Add.cbInputBufSize) ) )
	    return( dwRetCode );

	if ( AfpSrp.Type.Add.cbInputBufSize > 0 ) {

    	    dwRetCode = AfpServerIOCtrl( &AfpSrp );

    	    LocalFree( AfpSrp.Type.Add.pInputBuf );

	    if ( dwRetCode )
	    	return( dwRetCode );
	}
	else
    	    LocalFree( AfpSrp.Type.Add.pInputBuf );
    }

    // Check to see if the default type/creator is in the registry
    //
    AfpTypeCreatorKey.afptc_id = AFP_DEF_TCID;

    dwNumTypeCreators = AfpGlobals.AfpETCMapInfo.afpetc_num_type_creators;

    pTypeCreator = _lfind(  &AfpTypeCreatorKey,
			   AfpGlobals.AfpETCMapInfo.afpetc_type_creator,
			   (unsigned int *)&dwNumTypeCreators,
			   sizeof(AFP_TYPE_CREATOR),
			   AfpLCompareTypeCreator );
	
    // If the default is not in the registry use the hard-coded defaults.
    //
    if ( pTypeCreator == NULL ) {

        STRCPY( DefTypeCreator.afptc_type,    AFP_DEF_TYPE );
        STRCPY( DefTypeCreator.afptc_creator, AFP_DEF_CREATOR );
        STRCPY( DefTypeCreator.afptc_comment, AfpGlobals.wchDefTCComment );
        DefTypeCreator.afptc_id = AFP_DEF_TCID;
    }
    else
	DefTypeCreator = *pTypeCreator;

    ZeroMemory( (LPBYTE)(DefExtension.afpe_extension),
		AFP_FIELD_SIZE( AFP_EXTENSION, afpe_extension) );

    STRCPY( DefExtension.afpe_extension,  AFP_DEF_EXTENSION_W );

    AfpBufCopyFSDETCMapInfo( &DefTypeCreator,
			     &DefExtension,
 			     (PETCMAPINFO2)(bDefaultETC+sizeof(SETINFOREQPKT)));

    // IOCTL the FSD to set the default
    //
    AfpSrp.dwRequestCode  		= OP_SERVER_SET_ETC;
    AfpSrp.dwApiType 	  		= AFP_API_TYPE_SETINFO;
    AfpSrp.Type.SetInfo.pInputBuf	= bDefaultETC;
    AfpSrp.Type.SetInfo.cbInputBufSize  = sizeof( bDefaultETC );

    if ( dwRetCode = AfpServerIOCtrl( &AfpSrp ) )
	return( dwRetCode );

    // If the default was not in the cache, add it now.
    //
    if ( pTypeCreator == NULL ) {

        PAFP_TYPE_CREATOR   pTmpTypeCreator = NULL;

        // Grow the cache size by one entry.
        //
        pTypeCreator      = AfpGlobals.AfpETCMapInfo.afpetc_type_creator;
        dwNumTypeCreators = AfpGlobals.AfpETCMapInfo.afpetc_num_type_creators;

        pTmpTypeCreator = (PAFP_TYPE_CREATOR)LocalReAlloc(
				 pTypeCreator,
    			         (dwNumTypeCreators+1)*sizeof(AFP_TYPE_CREATOR),
			         LMEM_MOVEABLE );

        if ( pTmpTypeCreator == NULL )
        {
	        return( ERROR_NOT_ENOUGH_MEMORY );
        }

        pTypeCreator = pTmpTypeCreator;

    	pTypeCreator[dwNumTypeCreators++] = DefTypeCreator;

    	AfpGlobals.AfpETCMapInfo.afpetc_num_type_creators = dwNumTypeCreators;
    	AfpGlobals.AfpETCMapInfo.afpetc_type_creator      = pTypeCreator;

        // Sort the table
        //
        qsort(  pTypeCreator,
	   	dwNumTypeCreators,
	   	sizeof(AFP_TYPE_CREATOR),
	   	AfpBCompareTypeCreator );
    }

    return( NO_ERROR );

}

//**
//
// Call:	AfpInitServerIcons
//
// Returns:	NO_ERROR - success
//		ERROR_NOT_ENOUGH_MEMORY
//		non-zero return codes from registry apis.
//
// Description: This procedure will read in an icon at a time from the
//		registry, and then register this icon with the server.
//		This procedure will only return fatal errors that will
//		require that the service fail initialization. All other
//		error will be logged by this routine. All returns from the
//		the FSD are treated as non-fatal.
//
//
DWORD
AfpInitServerIcons(
	VOID
)
{
DWORD		 	dwRetCode;
LPWSTR  	 	lpwsValName;
DWORD		 	dwMaxValNameLen;
DWORD		 	dwNumValues;
DWORD		 	dwMaxValueDataSize;
DWORD		 	dwIndex;
DWORD		 	dwType;
DWORD			dwBufSize;
DWORD			dwValNameBufSize;
AFP_REQUEST_PACKET	AfpRequestPkt;
LPBYTE			lpbMultiSz;
AFP_ICON_INFO 	        IconInfo;

    // Find out the size of the largest data value and the largest
    // value name.
    //
    if ( dwRetCode = AfpRegGetKeyInfo( AfpGlobals.hkeyIcons,
				       &dwMaxValNameLen,
				       &dwNumValues,
				       &dwMaxValueDataSize
					))
   	return( dwRetCode );
	
    // If there are no icons in the registry then simply return
    //
    if ( dwNumValues == 0 )
	return( NO_ERROR );

    if (( lpwsValName = (LPWSTR)LocalAlloc( LPTR, dwMaxValNameLen )) == NULL )
	return( ERROR_NOT_ENOUGH_MEMORY );

    if (( lpbMultiSz = (LPBYTE)LocalAlloc( LPTR, dwMaxValueDataSize))== NULL){
	LocalFree( lpwsValName );
	return( ERROR_NOT_ENOUGH_MEMORY );
    }

    for ( dwIndex 		= 0,
	  dwBufSize 		= dwMaxValueDataSize,
	  dwValNameBufSize 	= dwMaxValNameLen;

	  dwIndex < dwNumValues;

	  dwIndex++,
	  dwBufSize 		= dwMaxValueDataSize,
	  dwValNameBufSize 	= dwMaxValNameLen ) {
				
	ZeroMemory( lpbMultiSz, dwBufSize );

	// Get the icon from the registry.
  	//
	if ( dwRetCode = RegEnumValue(  AfpGlobals.hkeyIcons,
				  	dwIndex,
				  	lpwsValName,
				  	&dwValNameBufSize,
				  	NULL,
				  	&dwType,
				  	lpbMultiSz,
				        &dwBufSize
				     ))
	    break;
				
	// Parse the mult sz and extract info into icon info structure
 	//
	if ( dwRetCode = AfpBufParseMultiSz(
					AFP_ICON_STRUCT,
					lpbMultiSz,
					(LPBYTE)&IconInfo
				      )) {
	    AfpLogEvent( AFPLOG_CANT_ADD_ICON, 1, &lpwsValName,
			 dwRetCode, EVENTLOG_WARNING_TYPE );
	    dwRetCode = NO_ERROR;
	    continue;
	}

	if ( dwRetCode = AfpBufUnicodeToNibble((LPWSTR)IconInfo.afpicon_data)){
	    AfpLogEvent( AFPLOG_CANT_ADD_ICON, 1, &lpwsValName,
			 dwRetCode, EVENTLOG_WARNING_TYPE );
	    dwRetCode = NO_ERROR;
	    continue;
	}

	// Validate the icon info structure
	//
	if ( !IsAfpIconValid( &IconInfo ) ) {
	    AfpLogEvent( AFPLOG_CANT_ADD_ICON, 1, &lpwsValName,
			 dwRetCode, EVENTLOG_WARNING_TYPE );
	    dwRetCode = NO_ERROR;
	    continue;
	}

	// Copy the icon info into an FSD icon structure.
	// NOTE: Re-use lpbMultiSz to store the FSD Icon structure. We know
	// it is big enough, because the FSD icon structure HAS to be
	// smaller than the MultiSz that contains the same information.
	//
	AfpBufMakeFSDIcon( &IconInfo, lpbMultiSz, &dwBufSize );

	// Initialize the FSD with this icon
	//
    	AfpRequestPkt.dwRequestCode             = OP_SERVER_ADD_ICON;
        AfpRequestPkt.dwApiType     	        = AFP_API_TYPE_ADD;	
    	AfpRequestPkt.Type.Add.pInputBuf 	= lpbMultiSz;
    	AfpRequestPkt.Type.Add.cbInputBufSize   = dwBufSize;

    	if ( dwRetCode = AfpServerIOCtrl( &AfpRequestPkt ) ) {
	    AfpLogEvent( AFPLOG_CANT_ADD_ICON, 1, &lpwsValName,
			 dwRetCode, EVENTLOG_WARNING_TYPE );
	    dwRetCode = NO_ERROR;
	    continue;
	}
    }

    LocalFree( lpwsValName );
    LocalFree( lpbMultiSz );

    return( dwRetCode );
}

//**
//
// Call:	AfpInitRPC
//
// Returns:	NO_ERROR	- success
//		ERROR_NOT_ENOUGH_MEMORY
//		nonzero returns from RPC APIs
//                 	RpcServerRegisterIf()
//                 	RpcServerUseProtseqEp()
//
// Description: Starts an RPC Server, adds the address (or port/pipe),
//		and adds the interface (dispatch table).
//
DWORD
AfpInitRPC( VOID )
{
RPC_STATUS           RpcStatus;
LPWSTR               lpwsEndpoint = NULL;
BOOL                 Bool;


    // We need to concatenate \pipe\ to the front of the interface name.
    //
    lpwsEndpoint = (LPWSTR)LocalAlloc( LPTR, sizeof(NT_PIPE_PREFIX) +
				((STRLEN(AFP_SERVICE_NAME)+1)*sizeof(WCHAR)));
    if ( lpwsEndpoint == NULL)
       return( ERROR_NOT_ENOUGH_MEMORY );

    STRCPY( lpwsEndpoint, NT_PIPE_PREFIX );
    STRCAT( lpwsEndpoint, AFP_SERVICE_NAME );


    // Ignore the second argument for now.
    //
    RpcStatus = RpcServerUseProtseqEpW( TEXT("ncacn_np"), 	
					                    10, 	
				                        lpwsEndpoint,
				                        NULL );

    if ( RpcStatus != RPC_S_OK )
    {
	    LocalFree( lpwsEndpoint );
     	return( I_RpcMapWin32Status( RpcStatus ) );
    }

    RpcStatus = RpcServerRegisterIfEx( afpsvc_v0_0_s_ifspec, 
                                        0,
                                        0,
                                        RPC_IF_ALLOW_CALLBACKS_WITH_NO_AUTH,
                                        RPC_C_LISTEN_MAX_CALLS_DEFAULT,
                                        AfpRpcSecurityCallback );

    LocalFree( lpwsEndpoint );

    if ( RpcStatus == RPC_S_OK )
	return( NO_ERROR );
    else
     	return( I_RpcMapWin32Status( RpcStatus ) );

}

//**
//
// Call: 	AfpTerminateRPC
//
// Returns:	none
//
// Description: Deletes the interface.
//
VOID
AfpTerminateRPC(
	VOID
)
{
    RPC_STATUS           RpcStatus;

    if ( AfpGlobals.dwServerState & AFPSTATE_RPC_STARTED )
    {
    	RpcStatus = RpcServerUnregisterIf( afpsvc_v0_0_s_ifspec, 0, 0 );

        if (RpcStatus != RPC_S_OK)
        {
            AFP_PRINT(("RpcServerUnregisterIf failed %ld\n", I_RpcMapWin32Status( RpcStatus )));
        }
    }

    return;
}

//**
//
// Call:	AfpIniLsa
//
// Returns:	none.
//
// Description: This procedure will register our process with LSA, needed for
//              change-password
//
VOID
AfpIniLsa(
	VOID
)
{
    NTSTATUS                ntstatus;
    STRING                  LsaName;
    LSA_OPERATIONAL_MODE    SecurityMode;


    //
    // register with Lsa as a logon process
    //

    RtlInitString(&LsaName, LOGON_PROCESS_NAME);

    ntstatus = LsaRegisterLogonProcess(&LsaName, &SfmLsaHandle, &SecurityMode);
    if (ntstatus != STATUS_SUCCESS)
    {
        SfmLsaHandle = NULL;
        return;
    }

    //
    // call Lsa to get the MSV1_0's pkg id, which we need during logon
    //

    RtlInitString(&LsaName, MSV1_0_PACKAGE_NAME);

    ntstatus = LsaLookupAuthenticationPackage(SfmLsaHandle, &LsaName, &SfmAuthPkgId);
    if (ntstatus != STATUS_SUCCESS)
    {
        LsaDeregisterLogonProcess( SfmLsaHandle );
        SfmLsaHandle = NULL;
        return;
    }

    return;

}


BOOL
IsAfpGuestAccountEnabled(
    VOID
)
{

    NTSTATUS                    rc;
    LSA_HANDLE                  hLsa;
    PPOLICY_ACCOUNT_DOMAIN_INFO pAcctDomainInfo;
    SECURITY_QUALITY_OF_SERVICE QOS;
    OBJECT_ATTRIBUTES           ObjAttribs;
    NTSTATUS                    status;
    SAM_HANDLE                  SamHandle;
    SAM_HANDLE                  DomainHandle;
    PUSER_ACCOUNT_INFORMATION   UserAccount = NULL;
    BOOLEAN                     fGuestEnabled;
    SAMPR_HANDLE                GuestAcctHandle;



    // for now
    fGuestEnabled = FALSE;

    //
    // Open the LSA and obtain a handle to it.
    //
    QOS.Length = sizeof(QOS);
    QOS.ImpersonationLevel = SecurityImpersonation;
    QOS.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    QOS.EffectiveOnly = FALSE;

    InitializeObjectAttributes(&ObjAttribs, NULL, 0L, NULL, NULL);

    ObjAttribs.SecurityQualityOfService = &QOS;

    status = LsaOpenPolicy(NULL,
                           &ObjAttribs,
                           POLICY_VIEW_LOCAL_INFORMATION | POLICY_LOOKUP_NAMES,
                           &hLsa);

    if (!NT_SUCCESS(status))
    {
        AFP_PRINT(("LsaOpenPolicy failed %lx\n",status));
        return(fGuestEnabled);
    }

    //
    // get the Domain Sid for the local domain: we'll need it very shortly
    //
    rc = LsaQueryInformationPolicy(hLsa,
                                   PolicyAccountDomainInformation,
                                   (PVOID) &pAcctDomainInfo);
    if (!NT_SUCCESS(rc))
    {
        AFP_PRINT(("InitLSA: LsaQueryInfo... failed (%lx)\n",rc));
        LsaClose(hLsa);
        return(fGuestEnabled);
    }

    InitializeObjectAttributes(&ObjAttribs, NULL, 0L, NULL, NULL);

    status = SamConnect(NULL, &SamHandle, MAXIMUM_ALLOWED, &ObjAttribs);

    if (!NT_SUCCESS(status))
    {
        AFP_PRINT(("SamConnect failed %lx\n",status));
        LsaFreeMemory(pAcctDomainInfo);
        LsaClose(hLsa);
        return(fGuestEnabled);
    }

    status = SamOpenDomain(
                SamHandle,
                MAXIMUM_ALLOWED,
                pAcctDomainInfo->DomainSid,
                &DomainHandle);

    LsaFreeMemory(pAcctDomainInfo);

    LsaClose(hLsa);

    if (!NT_SUCCESS(status))
    {
        AFP_PRINT(("SamOpenDomain failed %lx\n",status));
        SamCloseHandle(SamHandle);
        return(fGuestEnabled);
    }

    status = SamOpenUser(
                DomainHandle,
                MAXIMUM_ALLOWED,
                DOMAIN_USER_RID_GUEST,
                &GuestAcctHandle);

    if (!NT_SUCCESS(status))
    {
        AFP_PRINT(("SamOpenUser failed %lx\n",status));
        SamCloseHandle(SamHandle);
        return(fGuestEnabled);
    }

    status = SamQueryInformationUser(
                GuestAcctHandle,
                UserAccountInformation,
                (PVOID *) &UserAccount );

    if (!NT_SUCCESS(status))
    {
        AFP_PRINT(("SamQueryInformationUser failed %lx\n",status));
        SamCloseHandle(SamHandle);
        return(fGuestEnabled);
    }

    //
    // now, see if the guest account is enabled.
    //
    if (!(UserAccount->UserAccountControl & USER_ACCOUNT_DISABLED))
    {
        fGuestEnabled = TRUE;
    }

    SamFreeMemory(UserAccount);

    SamCloseHandle(GuestAcctHandle);

    SamCloseHandle(SamHandle);

    return(fGuestEnabled);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\service\server\finder.c ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.	   **/
/********************************************************************/

//***
//
// Filename:	finder.c
//
// Description: This module contains support routines for the finder
//		category API's for the AFP server service
//
// History:
//		Sept 30,1993.	NarenG		Created original version.
//
#include "afpsvcp.h"

BOOL
IsTargetNTFS(
	IN     LPWSTR lpwsPath
);

DWORD
CopyStream(
    	IN	HANDLE hSrc,
	IN	HANDLE hDst
);

#define	AFP_RESC_STREAM			TEXT(":AFP_Resource")

//**
//
// Call:	AfpAdminrFinderSetInfo
//
// Returns:	NO_ERROR
//		ERROR_ACCESS_DENIED
//		non-zero returns from AfpServerIOCtrl
//
// Description: This routine communicates with the AFP FSD to implement
//		the AfpAdminFinderSetInfo function.
//
DWORD
AfpAdminrFinderSetInfo(
	IN AFP_SERVER_HANDLE 	hServer,
	IN LPWSTR     		pType,
	IN LPWSTR     		pCreator,
	IN LPWSTR     		pData,
	IN LPWSTR     		pResource,
	IN LPWSTR     		pTarget,
	IN DWORD		dwParmNum
)
{
AFP_REQUEST_PACKET 	AfpSrp;
DWORD			dwRetCode = NO_ERROR, dwRetryCount = 0;
AFP_FINDER_INFO	AfpFinderInfo;
LPBYTE 			pAfpFinderInfoSR = NULL;
DWORD			cbAfpFinderInfoSRSize;
DWORD		    dwAccessStatus=0;
HANDLE			hTarget = INVALID_HANDLE_VALUE;
HANDLE		    hDataSrc = INVALID_HANDLE_VALUE;
HANDLE		    hResourceSrc = INVALID_HANDLE_VALUE;
LPWSTR			lpwsResourceFork;
BOOLEAN			fCreatedFile = FALSE;


    // Check if caller has access
    //
    if ( dwRetCode = AfpSecObjAccessCheck( AFPSVC_ALL_ACCESS, &dwAccessStatus))
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrFinderSetInfo, AfpSecObjAccessCheck failed %ld\n",dwRetCode));
		AfpLogEvent( AFPLOG_CANT_CHECK_ACCESS, 0, NULL,
					 dwRetCode, EVENTLOG_ERROR_TYPE );
        return( ERROR_ACCESS_DENIED );
    }

    if ( dwAccessStatus )
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrFinderSetInfo, AfpSecObjAccessCheck returned %ld\n",dwAccessStatus));
        return( ERROR_ACCESS_DENIED );
    }

    if ( wcsstr( pTarget, (LPWSTR)TEXT(":\\") ) == NULL )
		return( ERROR_INVALID_NAME );

    if ( !IsTargetNTFS( pTarget ) )
		return( (DWORD)AFPERR_UnsupportedFS );


	//
	// Impersonate the client while we read/write the fork data
	//
	dwRetCode = RpcImpersonateClient( NULL );
	if ( dwRetCode != RPC_S_OK )
	{
		return(I_RpcMapWin32Status( dwRetCode ));
	}

    // open the data source file if one was specified
    //
	if ( STRLEN( pData ) > 0 ){
		hDataSrc = CreateFile(pData, GENERIC_READ, FILE_SHARE_READ, NULL,
					  OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	
		if (hDataSrc == INVALID_HANDLE_VALUE) {
			RpcRevertToSelf();
			return( GetLastError() );
		}
	
	
		// open the target file's data stream if the file exists,
		// otherwise create the file
		//
		hTarget = CreateFile(pTarget, GENERIC_WRITE, FILE_SHARE_READ, NULL,
					 OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
	
		if (hTarget == INVALID_HANDLE_VALUE) {
			dwRetCode = GetLastError();
			CloseHandle(hDataSrc);
			RpcRevertToSelf();
			return( dwRetCode );
			}

        // Figure out if we just created a new file
	    if (GetLastError() == 0)
		{
			fCreatedFile = TRUE;
		}

		SetFilePointer(hTarget,0,NULL,FILE_BEGIN);
		SetEndOfFile(hTarget);
	
		// Read the source data and write it to target data stream
		//
		SetLastError(NO_ERROR);
		dwRetCode = CopyStream(hDataSrc, hTarget);
	
		CloseHandle(hDataSrc);
		CloseHandle(hTarget);
	
		if (dwRetCode != NO_ERROR) {
			RpcRevertToSelf();
			return( dwRetCode );
		}
	}

    // open the resource source file if one was specified
    //
    if ( STRLEN( pResource ) > 0 ) {

		hResourceSrc = CreateFile( pResource, GENERIC_READ, FILE_SHARE_READ,
					   NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
					   NULL);
	
		if (hResourceSrc == INVALID_HANDLE_VALUE) {
			RpcRevertToSelf();
			return( GetLastError() );
		}
	
		lpwsResourceFork = LocalAlloc( LPTR,
						   (STRLEN(pTarget)+
							STRLEN(AFP_RESC_STREAM)+1)
						* sizeof( WCHAR ) );
	
		if ( lpwsResourceFork == NULL ) {
			CloseHandle(hResourceSrc);
			RpcRevertToSelf();
			return( ERROR_NOT_ENOUGH_MEMORY );
		}
	
		// Open the target resource fork
		//
		STRCPY(lpwsResourceFork, pTarget );
		STRCAT(lpwsResourceFork, AFP_RESC_STREAM);
	
		hTarget = CreateFile(lpwsResourceFork, GENERIC_WRITE, FILE_SHARE_READ,
					 NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
	
		if (hTarget == INVALID_HANDLE_VALUE) {
			dwRetCode = GetLastError();
			LocalFree( lpwsResourceFork );
			CloseHandle(hResourceSrc);
			RpcRevertToSelf();
			return( dwRetCode );
		}
	
		LocalFree( lpwsResourceFork );
	
		// Assume we created a new file (datafork) in the process, there is
		// no way to tell for sure since creating a new resource fork will
		// not tell us whether or not the datafork already existed or not
		fCreatedFile = TRUE;

		// Read the source resource and write it to target resource stream
		//
		SetLastError(NO_ERROR);
		dwRetCode = CopyStream(hResourceSrc, hTarget);
	
		CloseHandle(hResourceSrc);
		CloseHandle(hTarget);
	
		if (dwRetCode != NO_ERROR) {
			RpcRevertToSelf();
			return( dwRetCode );
		}
	
	}

	//
	// Revert back to LocalSystem context
	//
	RpcRevertToSelf();

    if ( dwParmNum & ( AFP_FD_PARMNUM_TYPE | AFP_FD_PARMNUM_CREATOR ) ){

		dwRetCode = NO_ERROR;
	
		AfpFinderInfo.afpfd_path = pTarget;
	
		if ( dwParmNum & AFP_FD_PARMNUM_TYPE )
			STRCPY( AfpFinderInfo.afpfd_type, pType );
			else
			AfpFinderInfo.afpfd_type[0] = TEXT( '\0' );
		
		if ( dwParmNum & AFP_FD_PARMNUM_CREATOR )
			STRCPY( AfpFinderInfo.afpfd_creator, pCreator );
		else
			AfpFinderInfo.afpfd_creator[0] = TEXT( '\0' );
	
		// Make this buffer self-relative.
		//
		if ( dwRetCode = AfpBufMakeFSDRequest((LPBYTE)&AfpFinderInfo,
						   sizeof(SETINFOREQPKT),
						   AFP_FINDER_STRUCT,
						   &pAfpFinderInfoSR,
						   &cbAfpFinderInfoSRSize ))
	        return( dwRetCode );

		// Make IOCTL to set info
		//
		AfpSrp.dwRequestCode 		    = OP_FINDER_SET;
		AfpSrp.dwApiType     		    = AFP_API_TYPE_SETINFO;
		AfpSrp.Type.SetInfo.pInputBuf       = pAfpFinderInfoSR;
		AfpSrp.Type.SetInfo.cbInputBufSize  = cbAfpFinderInfoSRSize;
		AfpSrp.Type.SetInfo.dwParmNum       = dwParmNum;


		// Since there will be a delay between the time the change
		// notify comes into the server for the new file, and the
		// time it is actually processed by the server, we need to
		// put in a delay and retry to give the server a chance to
		// cache the new file
		if (fCreatedFile)
		{
			Sleep( 2000 );
		}

		do
		{

			dwRetCode = AfpServerIOCtrl( &AfpSrp );

			if (dwRetCode != ERROR_PATH_NOT_FOUND)
			{
				break;
			}

			Sleep( 2000);

		} while ( ++dwRetryCount < 4 );

		LocalFree( pAfpFinderInfoSR );
	
    }

    return( dwRetCode );
}



DWORD
CopyStream(
    	IN	HANDLE hSrc,
	IN	HANDLE hDst
)
{
    DWORD bytesread, byteswritten, Status = NO_ERROR;
    BYTE		Buffer[1024 * 16];

    do
    {
	bytesread = byteswritten = 0;

	// read from src, write to dst
	//
	if (ReadFile(hSrc, Buffer, sizeof(Buffer), &bytesread, NULL))
	{
	    if (bytesread == 0)
	    {
		break;
	    }
	}
	else
	{
	    Status = GetLastError();
	    break;
	}

	if (!WriteFile(hDst, Buffer, bytesread, &byteswritten, NULL))
	{
	    Status = GetLastError();
	    break;
	}

    } while (TRUE);

    return(Status);
}

BOOL
IsTargetNTFS(
	IN     LPWSTR lpwsPath
)
{
WCHAR	wchDrive[5];
DWORD   dwMaxCompSize;
DWORD   dwFlags;
WCHAR   wchFileSystem[10];

    // Get the drive letter, : and backslash
    //
    ZeroMemory( wchDrive, sizeof( wchDrive ) );

    STRNCPY( wchDrive, lpwsPath, 3 );

    if ( !( GetVolumeInformation( (LPWSTR)wchDrive,
			          NULL,
			          0,
 			          NULL,
			          &dwMaxCompSize,
			          &dwFlags,
				  (LPWSTR)wchFileSystem,
				  sizeof( wchFileSystem ) / sizeof( wchFileSystem[0] ) ) ) ){
	return( FALSE );
    }

    if ( STRICMP( wchFileSystem, TEXT("NTFS") ) == 0 )
   	return( TRUE );
    else
	return( FALSE );
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\service\server\etcmap.c ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.       **/
/********************************************************************/

//***
//
// Filename:    etcmap.c
//
// Description: This module contains support routines for the extension/
//        	type/creator mappings category API's for the AFP server
//        	service. These routines are called directly by the RPC
//		runtime.
//
// History:
//    		June 11,1992.    NarenG        Created original version.
//
#include "afpsvcp.h"

//**
//
// Call:    	AfpAdminrETCMapGetInfo
//
// Returns:	NO_ERROR
//		ERROR_ACCESS_DENIED
//		ERROR_NOT_ENOUGH_MEMORY
//
// Description: Will alllocate enough memory to contain all mappings, copy
//        	the information and return.
//
DWORD
AfpAdminrETCMapGetInfo(
        IN  AFP_SERVER_HANDLE    hServer,
        OUT PAFP_ETCMAP_INFO     *ppAfpETCMapInfo
)
{
DWORD            dwRetCode=0;
DWORD            dwAccessStatus=0;


    // Check if caller has access
    //
    if ( dwRetCode = AfpSecObjAccessCheck( AFPSVC_ALL_ACCESS, &dwAccessStatus))
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrETCMapGetInfo, AfpSecObjAccessCheck failed %ld\n",dwRetCode));
        AfpLogEvent( AFPLOG_CANT_CHECK_ACCESS, 0, NULL, 	
		     dwRetCode, EVENTLOG_ERROR_TYPE );
        return( ERROR_ACCESS_DENIED );
    }

    if ( dwAccessStatus )
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrETCMapGetInfo, AfpSecObjAccessCheck returned %ld\n",dwAccessStatus));
        return( ERROR_ACCESS_DENIED );
    }

    // MUTEX start
    //
    WaitForSingleObject( AfpGlobals.hmutexETCMap, INFINITE );

    // This loop is used to allow break's instead of goto's to be used
    // on an error condition.
    //
    do {

	dwRetCode = NO_ERROR;

    	// Allocate memory and copy ETC mappings information
    	//
    	*ppAfpETCMapInfo = MIDL_user_allocate( sizeof(AFP_ETCMAP_INFO) );

    	if ( *ppAfpETCMapInfo == NULL ) {
	    dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
	    break;
	}

    	(*ppAfpETCMapInfo)->afpetc_num_type_creators =
	     		     AfpGlobals.AfpETCMapInfo.afpetc_num_type_creators;

    	(*ppAfpETCMapInfo)->afpetc_type_creator = MIDL_user_allocate(
			     sizeof(AFP_TYPE_CREATOR)
    			    *AfpGlobals.AfpETCMapInfo.afpetc_num_type_creators);

    	if ( (*ppAfpETCMapInfo)->afpetc_type_creator == NULL ) {
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
	    break;
        }

    	(*ppAfpETCMapInfo)->afpetc_num_extensions =
	     		     AfpGlobals.AfpETCMapInfo.afpetc_num_extensions;

    	(*ppAfpETCMapInfo)->afpetc_extension = MIDL_user_allocate(
			      sizeof(AFP_EXTENSION)
    			     *AfpGlobals.AfpETCMapInfo.afpetc_num_extensions);

        if ( (*ppAfpETCMapInfo)->afpetc_extension == NULL ) {
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
	    break;
	}

        CopyMemory( (LPBYTE)(*ppAfpETCMapInfo)->afpetc_type_creator,
            	    (LPBYTE)(AfpGlobals.AfpETCMapInfo.afpetc_type_creator),
	    	    sizeof(AFP_TYPE_CREATOR)
	    	    * AfpGlobals.AfpETCMapInfo.afpetc_num_type_creators);

    	CopyMemory( (LPBYTE)(*ppAfpETCMapInfo)->afpetc_extension,
            	    (LPBYTE)(AfpGlobals.AfpETCMapInfo.afpetc_extension),
	    	    sizeof(AFP_EXTENSION)
	    	    * AfpGlobals.AfpETCMapInfo.afpetc_num_extensions);

    } while( FALSE );

    // MUTEX end
    //
    ReleaseMutex( AfpGlobals.hmutexETCMap );

    if ( dwRetCode ) {

	if ( *ppAfpETCMapInfo != NULL ) {

	    if ( (*ppAfpETCMapInfo)->afpetc_type_creator != NULL )
	    	MIDL_user_free( (*ppAfpETCMapInfo)->afpetc_type_creator );

	    MIDL_user_free( *ppAfpETCMapInfo );
        }
    }

    return( dwRetCode );
}

//**
//
// Call:    	AfpAdminrETCMapAdd
//
// Returns:	NO_ERROR
//		ERROR_ACCESS_DENIED
//	        AFPERR_DuplicateTypeCreator;
//		non-zero returns from the registry API's
//
// Description: This routine will add a type/creator/comment tupple to the
//        	registry and the cache.
//
DWORD
AfpAdminrETCMapAdd(
    IN  AFP_SERVER_HANDLE    hServer,
    IN  PAFP_TYPE_CREATOR    pAfpTypeCreator
)
{
DWORD               dwRetCode=0;
DWORD               dwAccessStatus=0;
PAFP_TYPE_CREATOR   pTypeCreator;
PAFP_TYPE_CREATOR   pTmpTypeCreator=NULL;
DWORD		    dwNumTypeCreators;


    // Check if caller has access
    //
    if ( dwRetCode = AfpSecObjAccessCheck( AFPSVC_ALL_ACCESS, &dwAccessStatus))
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrETCMapAdd, AfpSecObjAccessCheck failed %ld\n",dwRetCode));
        AfpLogEvent( AFPLOG_CANT_CHECK_ACCESS, 0, NULL,
		    dwRetCode, EVENTLOG_ERROR_TYPE );
        return( ERROR_ACCESS_DENIED );
    }

    if ( dwAccessStatus )
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrETCMapAdd, AfpSecObjAccessCheck returned %ld\n",dwAccessStatus));
        return( ERROR_ACCESS_DENIED );
    }

    // MUTEX start
    //
    WaitForSingleObject( AfpGlobals.hmutexETCMap, INFINITE );

    // This loop is used to allow break's instead of goto's to be used
    // on an error condition.
    //
    do {

	dwRetCode = NO_ERROR;

        // First check to see if the type already exists.
    	//
    	pTypeCreator = AfpBinarySearch(
			      pAfpTypeCreator,
			      AfpGlobals.AfpETCMapInfo.afpetc_type_creator,
    			      AfpGlobals.AfpETCMapInfo.afpetc_num_type_creators,
			      sizeof(AFP_TYPE_CREATOR),
			      AfpBCompareTypeCreator );

        // It exists so return error
        //
        if ( pTypeCreator != NULL ) {
	    dwRetCode = (DWORD)AFPERR_DuplicateTypeCreator;
	    break;
	}

	// Set the ID for this type/creator	
	//
        pAfpTypeCreator->afptc_id = ++AfpGlobals.dwCurrentTCId;

        // It does not exist so add it to the registry and the cache.
        //
        if ( dwRetCode = AfpRegTypeCreatorAdd( pAfpTypeCreator ) )
	    break;

        // Grow the cache size by one entry.
        //
        pTypeCreator      = AfpGlobals.AfpETCMapInfo.afpetc_type_creator;
        dwNumTypeCreators = AfpGlobals.AfpETCMapInfo.afpetc_num_type_creators;

        pTmpTypeCreator = (PAFP_TYPE_CREATOR)LocalReAlloc(
				 pTypeCreator,
    			         (dwNumTypeCreators+1)*sizeof(AFP_TYPE_CREATOR),
			         LMEM_MOVEABLE );

        if ( pTmpTypeCreator == NULL ) {
	    dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
	    break;
	}
        pTypeCreator = pTmpTypeCreator;

    	pTypeCreator[dwNumTypeCreators++] = *pAfpTypeCreator;

    	AfpGlobals.AfpETCMapInfo.afpetc_num_type_creators = dwNumTypeCreators;
    	AfpGlobals.AfpETCMapInfo.afpetc_type_creator      = pTypeCreator;

        // Sort the table
        //
        qsort(  pTypeCreator,
	   	dwNumTypeCreators,
	   	sizeof(AFP_TYPE_CREATOR),
	   	AfpBCompareTypeCreator );

    } while( FALSE );

    // MUTEX end
    //
    ReleaseMutex( AfpGlobals.hmutexETCMap );

    return( dwRetCode );
}

//**
//
// Call:    	AfpAdminrETCMapDelete
//
// Returns:	NO_ERROR
//		ERROR_ACCESS_DENIED
//		AFPERR_TypeCreatorNotExistant
//		non-zero returns from registry api's.
//		non-zero returns from the FSD.
//		
//
// Description: This routine will delete a type/creator tupple from the
//		registry and the cache. If there are any extensions that map
//		to this tupple, they are deleted.
//		Shrinking by reallocating is not done. This will be done the
//		next time an extension is added or if the server is restarted.
//		
DWORD
AfpAdminrETCMapDelete(
    IN  AFP_SERVER_HANDLE    hServer,
    IN  PAFP_TYPE_CREATOR    pAfpTypeCreator
)
{
AFP_REQUEST_PACKET  AfpSrp;
DWORD               dwRetCode=0;
DWORD               dwAccessStatus=0;
PAFP_TYPE_CREATOR   pTypeCreator;
AFP_EXTENSION	    AfpExtensionKey;
PAFP_EXTENSION	    pExtension;
PAFP_EXTENSION	    pExtensionWalker;
DWORD		    cbSize;
DWORD		    dwIndex;
ETCMAPINFO2	    ETCMapFSDBuf;
DWORD		    dwCount;


    // Check if caller has access
    //
    if ( dwRetCode = AfpSecObjAccessCheck( AFPSVC_ALL_ACCESS, &dwAccessStatus))
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrETCMapDelete, AfpSecObjAccessCheck failed %ld\n",dwRetCode));
        AfpLogEvent( AFPLOG_CANT_CHECK_ACCESS, 0, NULL,
		     dwRetCode, EVENTLOG_ERROR_TYPE );
        return( ERROR_ACCESS_DENIED );
    }

    if ( dwAccessStatus )
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrETCMapDelete, AfpSecObjAccessCheck returned %ld\n",dwAccessStatus));
        return( ERROR_ACCESS_DENIED );
    }

    // MUTEX start
    //
    WaitForSingleObject( AfpGlobals.hmutexETCMap, INFINITE );

    // This loop is used to allow break's instead of goto's to be used
    // on an error condition.
    //
    do {

	dwRetCode = NO_ERROR;

    	// First check to see if the type/creator exists.
    	//
    	pTypeCreator = AfpBinarySearch(
			      pAfpTypeCreator,
			      AfpGlobals.AfpETCMapInfo.afpetc_type_creator,
    			      AfpGlobals.AfpETCMapInfo.afpetc_num_type_creators,
			      sizeof(AFP_TYPE_CREATOR),
			      AfpBCompareTypeCreator );

    	// It does not exist so return error
    	//
    	if ( pTypeCreator == NULL ) {
	    dwRetCode = (DWORD)AFPERR_TypeCreatorNotExistant;
	    break;
	}

  	// If this is the default type/creator
	//
    	if ( pTypeCreator->afptc_id == AFP_DEF_TCID ) {
	    dwRetCode = (DWORD)AFPERR_CannotDeleteDefaultTC;
	    break;
  	}

	// Store the id of this type/creator. All extensions with this
	// id will have to be deleted.
	//
    	AfpExtensionKey.afpe_tcid = pTypeCreator->afptc_id;

        // Walk the list of extensions and delete all entries with
    	// the corresponding type/creator ID
    	//
    	pExtension = AfpBinarySearch(
				&AfpExtensionKey,
			        AfpGlobals.AfpETCMapInfo.afpetc_extension,
    			        AfpGlobals.AfpETCMapInfo.afpetc_num_extensions,
			        sizeof(AFP_EXTENSION),
			    	AfpBCompareExtension );

    	if ( pExtension != NULL ) {
	
            for ( dwIndex = (DWORD)(((ULONG_PTR)pExtension -
			     (ULONG_PTR)(AfpGlobals.AfpETCMapInfo.afpetc_extension)) / sizeof(AFP_EXTENSION)),
		         pExtensionWalker = pExtension,
		         dwCount = 0;
	
		         ( dwIndex < AfpGlobals.AfpETCMapInfo.afpetc_num_extensions )
		         &&
		         ( pExtensionWalker->afpe_tcid == AfpExtensionKey.afpe_tcid );

	      	     dwIndex++,
		         dwCount++,
		         pExtensionWalker++ )
            {
		
	   	        // IOCTL the FSD to delete this tupple
  	    	    //
	    	    AfpBufCopyFSDETCMapInfo( pAfpTypeCreator,
				             pExtensionWalker,
				             &ETCMapFSDBuf );

    	        AfpSrp.dwRequestCode 	           = OP_SERVER_DELETE_ETC;
            	AfpSrp.dwApiType 	       	   = AFP_API_TYPE_DELETE;
                AfpSrp.Type.Delete.pInputBuf       = &ETCMapFSDBuf;
                AfpSrp.Type.Delete.cbInputBufSize  = sizeof(ETCMAPINFO2);

                if ( dwRetCode = AfpServerIOCtrl( &AfpSrp ) )
                {
		            break;
                }

	            // Delete this extension from the registry
	            //
    	        if ( dwRetCode = AfpRegExtensionDelete( pExtensionWalker ))
                {
		            break;
                }
	        }

	    if ( dwRetCode )
	    	break;

	    // Remove the extensions from the cache
	    //
            AfpGlobals.AfpETCMapInfo.afpetc_num_extensions -= dwCount;

	    // Remove these extensions from the cache too
	    //
            cbSize = AfpGlobals.AfpETCMapInfo.afpetc_num_extensions
		     * sizeof(AFP_EXTENSION);

            cbSize -= (DWORD)((ULONG_PTR)pExtension -
		       (ULONG_PTR)(AfpGlobals.AfpETCMapInfo.afpetc_extension));

	    CopyMemory( (LPBYTE)pExtension, (LPBYTE)pExtensionWalker, cbSize );

	}

        // Delete the type/creator from the registry
        //
        if ( dwRetCode = AfpRegTypeCreatorDelete( pTypeCreator ) )
	    break;

        // Delete the type/creator from the cache
        //
        AfpGlobals.AfpETCMapInfo.afpetc_num_type_creators--;

        cbSize = AfpGlobals.AfpETCMapInfo.afpetc_num_type_creators
	         * sizeof(AFP_TYPE_CREATOR);

        cbSize -= (DWORD)((ULONG_PTR)pTypeCreator -
		   (ULONG_PTR)AfpGlobals.AfpETCMapInfo.afpetc_type_creator);

        CopyMemory( (LPBYTE)pTypeCreator,
	            (LPBYTE)((ULONG_PTR)pTypeCreator+sizeof(AFP_TYPE_CREATOR)),
    	        cbSize );

    } while( FALSE );

    // MUTEX end
    //
    ReleaseMutex( AfpGlobals.hmutexETCMap );

    return( dwRetCode );
}

//**
//
// Call:    	AfpAdminrETCMapSetInfo
//
// Returns:	NO_ERROR
//		ERROR_ACCESS_DENIED
//		AFPERR_TypeCreatorNotExistant
//	        AFPERR_CannotEditDefaultTC;
//		non-zero returns from registry api's.
//
// Description: This routine will simply change the comment for a type/creator
//		tupple.
//
DWORD
AfpAdminrETCMapSetInfo(
    IN  AFP_SERVER_HANDLE    hServer,
    IN  PAFP_TYPE_CREATOR    pAfpTypeCreator
)
{
DWORD            	dwRetCode=0;
DWORD            	dwAccessStatus=0;
PAFP_TYPE_CREATOR    	pTypeCreator;


    // Check if caller has access
    //
    if ( dwRetCode = AfpSecObjAccessCheck( AFPSVC_ALL_ACCESS, &dwAccessStatus))
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrETCMapSetInfo, AfpSecObjAccessCheck failed %ld\n",dwRetCode));
        AfpLogEvent( AFPLOG_CANT_CHECK_ACCESS, 0, NULL,
		     dwRetCode, EVENTLOG_ERROR_TYPE );
        return( ERROR_ACCESS_DENIED );
    }

    if ( dwAccessStatus )
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrETCMapSetInfo, AfpSecObjAccessCheck returned %ld\n",dwAccessStatus));
        return( ERROR_ACCESS_DENIED );
    }

    // MUTEX start
    //
    WaitForSingleObject( AfpGlobals.hmutexETCMap, INFINITE );

    // This loop is used to allow break's instead of goto's to be used
    // on an error condition.
    //
    do {
	dwRetCode = NO_ERROR;


    	// First check to see if the type/creator exists.
    	//
    	pTypeCreator = AfpBinarySearch(
			      pAfpTypeCreator,
			      AfpGlobals.AfpETCMapInfo.afpetc_type_creator,
    			      AfpGlobals.AfpETCMapInfo.afpetc_num_type_creators,
			      sizeof(AFP_TYPE_CREATOR),
			      AfpBCompareTypeCreator );

    	// It does not exist so return error
    	//
    	if ( pTypeCreator == NULL ) {
	    dwRetCode = (DWORD)AFPERR_TypeCreatorNotExistant;
	    break;
	}

	// If this is the default type/creator
	//
    	if ( pTypeCreator->afptc_id == AFP_DEF_TCID ) {
	    dwRetCode = (DWORD)AFPERR_CannotEditDefaultTC;
	    break;
  	}

	// Copy the id.
	//
    	pAfpTypeCreator->afptc_id = pTypeCreator->afptc_id;
	
        // Set the comment in the registry
        //
    	if ( dwRetCode = AfpRegTypeCreatorSetInfo( pAfpTypeCreator ) ) {
	    break;
	}

    	// Set the comment in the cache.
    	//
    	STRCPY( pTypeCreator->afptc_comment, pAfpTypeCreator->afptc_comment );

    } while( FALSE );

    // MUTEX end
    //
    ReleaseMutex( AfpGlobals.hmutexETCMap );

    return( dwRetCode );
}

//**
//
// Call:    	AfpAdminrETCMapAssociate
//
// Returns:	NO_ERROR
//		ERROR_ACCESS_DENIED
//		AFPERR_TypeCreatorNotExistant
//		non-zero returns from registry api's.
//		non-zero returns from the FSD
//
//
// Description: This routine will associate the given extension with the
//		specified type/creator if it exists. If the extension is
//		being mapped to the default type/creator, it will be
//		deleted.
//
DWORD
AfpAdminrETCMapAssociate(
    IN  AFP_SERVER_HANDLE   hServer,
    IN  PAFP_TYPE_CREATOR   pAfpTypeCreator,
    IN  PAFP_EXTENSION	    pAfpExtension
)
{
AFP_REQUEST_PACKET  AfpSrp;
DWORD               dwRetCode=0;
DWORD               dwAccessStatus=0;
PAFP_TYPE_CREATOR   pTypeCreator;
PAFP_EXTENSION	    pExtension;
PAFP_EXTENSION	    pTmpExtension=NULL;
SRVETCPKT	    SrvETCPkt;
DWORD		    dwNumExtensions;
DWORD		    cbSize;
BYTE		    bETCMapFSDBuf[sizeof(ETCMAPINFO2)+sizeof(SETINFOREQPKT)];


    // Check if caller has access
    //
    if ( dwRetCode = AfpSecObjAccessCheck( AFPSVC_ALL_ACCESS, &dwAccessStatus))
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrETCMapAssociate, AfpSecObjAccessCheck failed %ld\n",dwRetCode));
        AfpLogEvent( AFPLOG_CANT_CHECK_ACCESS, 0, NULL,
		     dwRetCode, EVENTLOG_ERROR_TYPE );
        return( ERROR_ACCESS_DENIED );
    }

    if ( dwAccessStatus )
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrETCMapAssociate, AfpSecObjAccessCheck returned %ld\n",dwAccessStatus));
        return( ERROR_ACCESS_DENIED );
    }

    // MUTEX start
    //
    WaitForSingleObject( AfpGlobals.hmutexETCMap, INFINITE );

    // This loop is used to allow break's instead of goto's to be used
    // on an error condition.
    //
    do {
	dwRetCode = NO_ERROR;

    	// First check to see if the type/creator pair that the
	// new extension is to be associated with, exists.
      	//
    	pTypeCreator = AfpBinarySearch(
			      pAfpTypeCreator,
			      AfpGlobals.AfpETCMapInfo.afpetc_type_creator,
    			      AfpGlobals.AfpETCMapInfo.afpetc_num_type_creators,
			      sizeof(AFP_TYPE_CREATOR),
			      AfpBCompareTypeCreator );

    	// It does not exist so return error
    	//
    	if ( pTypeCreator == NULL ) {
	    dwRetCode =  (DWORD)AFPERR_TypeCreatorNotExistant;
	    break;
	}

    	// Now check to see if the extension is already associated with
    	// a type/creator pair.
    	//
        dwNumExtensions = AfpGlobals.AfpETCMapInfo.afpetc_num_extensions;
    	pExtension = _lfind( pAfpExtension,
			    AfpGlobals.AfpETCMapInfo.afpetc_extension,
    			    (unsigned int *)&dwNumExtensions,
			    sizeof(AFP_EXTENSION),
			    AfpLCompareExtension );

    	// Not currently associated so we need to add an entry
    	//
    	if ( pExtension == NULL ) {
	
	    // If this extension is being associated with the default
  	    // then simply return.
 	    //
    	    if ( pTypeCreator->afptc_id == AFP_DEF_TCID ) {
		dwRetCode = NO_ERROR;
		break;
	    }

	    // Add mapping to FSD
	    //
	    AfpBufCopyFSDETCMapInfo(  pAfpTypeCreator,
				      pAfpExtension,
				      &(SrvETCPkt.retc_EtcMaps[0]) );

            SrvETCPkt.retc_NumEtcMaps = 1;
	
    	    AfpSrp.dwRequestCode 	    = OP_SERVER_ADD_ETC;
            AfpSrp.dwApiType 		    = AFP_API_TYPE_ADD;
            AfpSrp.Type.Add.pInputBuf       = &SrvETCPkt;
            AfpSrp.Type.Add.cbInputBufSize  = sizeof(SRVETCPKT);

            if ( dwRetCode = AfpServerIOCtrl( &AfpSrp ) )
		break;

	    // Add extension to registry.
	    //
            pAfpExtension->afpe_tcid = pTypeCreator->afptc_id;

    	    if ( dwRetCode = AfpRegExtensionSetInfo( pAfpExtension ) ) {
		break;
	    }
	
	    // Add extension to cache.
	    //
            pExtension      = AfpGlobals.AfpETCMapInfo.afpetc_extension;
            dwNumExtensions = AfpGlobals.AfpETCMapInfo.afpetc_num_extensions;

            pTmpExtension = (PAFP_EXTENSION)LocalReAlloc(
				  pExtension,
    			          (dwNumExtensions+1)*sizeof(AFP_EXTENSION),
			          LMEM_MOVEABLE );

            if ( pTmpExtension == NULL ) {
	        dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
		break;
	    }

            pExtension = pTmpExtension;

            pExtension[dwNumExtensions++] = *pAfpExtension;

            AfpGlobals.AfpETCMapInfo.afpetc_num_extensions = dwNumExtensions;
            AfpGlobals.AfpETCMapInfo.afpetc_extension      = pExtension;

    	}

    	// Extension is already mapped.
    	//
    	else {

	    // If this extension is being associated with the default
  	    // then delete this extension from the registry and cache and
	    // delete the mapping from the FSD
 	    //
  	    if ( pTypeCreator->afptc_id == AFP_DEF_TCID ) {
	
	   	// IOCTL the FSD to delete this tupple
  	    	//
	    	AfpBufCopyFSDETCMapInfo( pAfpTypeCreator,
				     	 pAfpExtension,
				     	 (PETCMAPINFO2)bETCMapFSDBuf );

    	    	AfpSrp.dwRequestCode 	           = OP_SERVER_DELETE_ETC;
            	AfpSrp.dwApiType 		   = AFP_API_TYPE_DELETE;
            	AfpSrp.Type.Delete.pInputBuf       = bETCMapFSDBuf;
            	AfpSrp.Type.Delete.cbInputBufSize  = sizeof(ETCMAPINFO2);

            	if ( dwRetCode = AfpServerIOCtrl( &AfpSrp ) )
		    break;

	        // Delete this extension from the registry
	    	//
    	    	if ( dwRetCode = AfpRegExtensionDelete( pAfpExtension ) ) {
		    break;
		}

	       	// Remove this extensions from the cache too
	        //
                AfpGlobals.AfpETCMapInfo.afpetc_num_extensions--;

                cbSize = AfpGlobals.AfpETCMapInfo.afpetc_num_extensions
		         * sizeof(AFP_EXTENSION);

                cbSize -= (DWORD)((ULONG_PTR)pExtension -
			   (ULONG_PTR)(AfpGlobals.AfpETCMapInfo.afpetc_extension));

	        CopyMemory( (LPBYTE)pExtension,
		            (LPBYTE)((ULONG_PTR)pExtension+sizeof(AFP_EXTENSION)),
		            cbSize );

	    }
	    else {

		// Otherwise simply change the mapping in the FSD
		//
        	pExtension->afpe_tcid = pTypeCreator->afptc_id;

		AfpBufCopyFSDETCMapInfo(pTypeCreator,
				  	pExtension,
 			    (PETCMAPINFO2)(bETCMapFSDBuf+sizeof(SETINFOREQPKT)));

    		AfpSrp.dwRequestCode 	            = OP_SERVER_SET_ETC;
        	AfpSrp.dwApiType 		    = AFP_API_TYPE_SETINFO;
        	AfpSrp.Type.SetInfo.pInputBuf       = bETCMapFSDBuf;
        	AfpSrp.Type.SetInfo.cbInputBufSize  = sizeof(bETCMapFSDBuf);

        	if ( dwRetCode = AfpServerIOCtrl( &AfpSrp ) )
		    break;

		// Change the registry
		//
    		if ( dwRetCode = AfpRegExtensionSetInfo( pExtension ) ) {
		    break;
		}
	    }

        }

    	// Sort the table
    	//
    	qsort(  AfpGlobals.AfpETCMapInfo.afpetc_extension,
            	AfpGlobals.AfpETCMapInfo.afpetc_num_extensions,
	    	sizeof(AFP_EXTENSION),
	    	AfpBCompareExtension );

    } while( FALSE );

    // MUTEX end
    //
    ReleaseMutex( AfpGlobals.hmutexETCMap );

    return( dwRetCode );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\service\server\errorlog.c ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.	   **/
/********************************************************************/

//***
//
// Filename:	errorlog.c
//
// Description:
//
// History:
//		May 11,1992.	NarenG		Created original version.
//		Feb  2,1993		SueA		Added routine to handle server's event
//									logging (from FSCTL by service)
//
#include "afpsvcp.h"

//**
//
// Call: 	AfpLogEvent
//
// Returns:	none
//
// Description:
//
VOID
AfpLogEvent(
    	IN DWORD    dwMessageId,
    	IN WORD     cNumberOfSubStrings,
        IN LPWSTR * plpwsSubStrings,
     	IN DWORD    dwErrorCode,
	IN WORD     wSeverity
)
{
HANDLE 	hLog;
PSID 	pSidUser = NULL;

    hLog = RegisterEventSource( NULL, AFP_SERVICE_NAME );

    AFP_ASSERT( hLog != NULL );

    // Log the error code specified
    //
    ReportEvent( hLog,
                 wSeverity,
                 0,            		// event category
                 dwMessageId,
                 pSidUser,
                 cNumberOfSubStrings,
                 sizeof(DWORD),
                 plpwsSubStrings,
                 (PVOID)&dwErrorCode
                 );

    DeregisterEventSource( hLog );

    AFP_PRINT( ("AFPSVC_Errorlog: dwMessageId = %d\n", dwMessageId ));

    return;
}

//**
//
// Call: 	AfpLogServerEvent
//
// Returns:	none
//
// Description: Gets an error or audit log packet from the Afp Server FSD
// and does the event logging on its behalf.  (See AfpServerHelper thread
// routine in srvrhlpr.c)
//
VOID
AfpLogServerEvent(
	IN	PAFP_FSD_CMD_PKT	pAfpFsdCmd
)
{
	PAFP_EVENTLOG_DESC	pEventData;
	HANDLE			 	hLog;
	PSID 				pSidUser = NULL;
	int					i;

    hLog = RegisterEventSource( NULL, AFP_SERVICE_NAME );

    AFP_ASSERT( hLog != NULL );

	pEventData = &pAfpFsdCmd->Data.Eventlog;

	OFFSET_TO_POINTER(pEventData->ppStrings, pAfpFsdCmd);

	for (i = 0; i < pEventData->StringCount; i++)
	{
		OFFSET_TO_POINTER(pEventData->ppStrings[i], pAfpFsdCmd);
	}

	OFFSET_TO_POINTER(pEventData->pDumpData, pAfpFsdCmd);

	ReportEvent( hLog,
				 pEventData->EventType,
				 0,						// event category
				 pEventData->MsgID,
				 pSidUser,
				 pEventData->StringCount,
				 pEventData->DumpDataLen,
				 pEventData->ppStrings,
				 pEventData->pDumpData
			   );

    DeregisterEventSource( hLog );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\service\server\dir.c ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.         **/
/********************************************************************/

//***
//
// Filename:    dir.c
//
// Description: This module contains support routines for the diretory
//              category API's for the AFP server service. These routines
//              are called by the RPC runtime.
//
// History:
//              June 11,1992.   NarenG          Created original version.
//
#include <nt.h>
#include <ntrtl.h>
#include <ntlsa.h>
#include <nturtl.h>     // needed for winbase.h
#include "afpsvcp.h"

//**
//
// Call:        AfpDirConvertSidsToNames
//
// Returns:     NO_ERROR
//              error return codes from LsaOpenPolicy and LsaLookupSids
//
// Description: Will convert the directory structure returned by the FSD
//              which contains pointers to owner and groups SIDS to their
//              respective names. The caller is responsible for freeing up
//              the memory allocated to hold the converted dir structure.
//
DWORD
AfpDirConvertSidsToNames(
        IN  PAFP_DIRECTORY_INFO  pAfpDirInfo,
        OUT PAFP_DIRECTORY_INFO* ppAfpConvertedDirInfo
)
{
LSA_HANDLE                      hLsa            = NULL;
NTSTATUS                        ntStatus;
PLSA_REFERENCED_DOMAIN_LIST     pDomainList     = NULL;
PLSA_TRANSLATED_NAME            pNames          = NULL;
PSID                            pSidArray[2];
SECURITY_QUALITY_OF_SERVICE     QOS;
OBJECT_ATTRIBUTES               ObjectAttributes;
DWORD                           dwRetCode       = NO_ERROR;
PAFP_DIRECTORY_INFO             pOutputBuf      = NULL;
DWORD                           cbOutputBuf;
LPBYTE                          pbVariableData;
DWORD                           dwIndex;
WCHAR *                         pWchar;
BOOL                            fUseUnknownAccount = FALSE;
DWORD                           dwUse, dwCount = 0;
SID                             AfpBuiltInSid = { 1, 1, SECURITY_NT_AUTHORITY,
                                                  SECURITY_BUILTIN_DOMAIN_RID };

    // First open the LSA and obtain a handle to it.
    //
    QOS.Length              = sizeof( QOS );
    QOS.ImpersonationLevel  = SecurityImpersonation;
    QOS.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    QOS.EffectiveOnly       = FALSE;

    InitializeObjectAttributes( &ObjectAttributes,
                                NULL,
                                0L,
                                NULL,
                                NULL );

    ObjectAttributes.SecurityQualityOfService = &QOS;

    ntStatus = LsaOpenPolicy(   NULL,
                                &ObjectAttributes,
                                POLICY_LOOKUP_NAMES,
                                &hLsa );

    if ( !NT_SUCCESS( ntStatus ))
        return( RtlNtStatusToDosError( ntStatus ) );

    // This is not a loop
    //
    do {


        // Set up the owner and group sid into the array.
        //
                if ((PSID)(pAfpDirInfo->afpdir_owner) != NULL)
                {
                        pSidArray[dwCount++] = (PSID)(pAfpDirInfo->afpdir_owner);
                }
                if ((PSID)(pAfpDirInfo->afpdir_group) != NULL)
                {
                        pSidArray[dwCount++] = (PSID)(pAfpDirInfo->afpdir_group);
                }
                    
        // Try to get the names of the owner and primary group.
        //
                if (dwCount > 0)
                {
                        ntStatus = LsaLookupSids( hLsa, dwCount, pSidArray, &pDomainList, &pNames );
        
                        if ( !NT_SUCCESS( ntStatus ) ) {
        
                                if ( ntStatus == STATUS_NONE_MAPPED ) {
        
                                        fUseUnknownAccount = TRUE;
        
                                        dwRetCode = NO_ERROR;
        
                                }
                                else {
        
                                        dwRetCode = RtlNtStatusToDosError( ntStatus );
        
                    AFP_PRINT(( "SFMSVC: AfpDirConvertSidsToNames, LsaLookupSids failed with error (%ld)\n", dwRetCode));

                                        break;
                                }
                        }
                }

        // We need to calculate the length of the buffer we need to allocate.
        //
        for( dwIndex = 0,
                 dwRetCode = NO_ERROR,
             cbOutputBuf = sizeof( AFP_DIRECTORY_INFO );

             dwIndex < dwCount;

             dwIndex++ ) {

             if ( fUseUnknownAccount )
                         dwUse = SidTypeUnknown;
             else
                         dwUse = pNames[dwIndex].Use;

             switch( dwUse ) {

             case SidTypeInvalid:
                cbOutputBuf += ((wcslen((LPWSTR)(AfpGlobals.wchInvalid))+1)
                                * sizeof(WCHAR));
                break;

             case SidTypeDeletedAccount:
                cbOutputBuf += ((wcslen((LPWSTR)(AfpGlobals.wchDeleted))+1)
                                * sizeof(WCHAR));
                break;

             case SidTypeUnknown:
                cbOutputBuf += ((wcslen((LPWSTR)(AfpGlobals.wchUnknown))+1)
                                * sizeof(WCHAR));
                break;

             case SidTypeWellKnownGroup:
                cbOutputBuf += (pNames[dwIndex].Name.Length+sizeof(WCHAR));
                break;

             case SidTypeDomain:
                cbOutputBuf +=
                ((pDomainList->Domains[pNames[dwIndex].DomainIndex]).Name.Length                + sizeof(WCHAR) );
                break;

             default:
                if ( ( pNames[dwIndex].DomainIndex != -1 ) &&   
                     ( pNames[dwIndex].Name.Buffer != NULL ) ) {

                    PSID                pDomainSid;
                    PUNICODE_STRING     pDomain;

                    pDomain =
                    &((pDomainList->Domains[pNames[dwIndex].DomainIndex]).Name);

                    pDomainSid =
                        (pDomainList->Domains[pNames[dwIndex].DomainIndex]).Sid;

                    if ( !RtlEqualSid( &AfpBuiltInSid, pDomainSid ))
                        cbOutputBuf += ( pDomain->Length + sizeof( TEXT('\\')));

                    cbOutputBuf += (pNames[dwIndex].Name.Length+sizeof(WCHAR));
                }
                else
                    dwRetCode = ERROR_NONE_MAPPED;
                break;
            }
        }

        pOutputBuf = (PAFP_DIRECTORY_INFO)MIDL_user_allocate( cbOutputBuf );

        if ( pOutputBuf == NULL ) {
                dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            AFP_PRINT(( "SFMSVC: AfpDirConvertSidsToNames, MIDL_user_allocate 1 failed with error (%ld)\n", dwRetCode));
                break;
        }

        ZeroMemory( (LPBYTE)pOutputBuf, cbOutputBuf );

        // Copy the fixed part of the structure.
        //
        CopyMemory( (LPBYTE)pOutputBuf,
                    (LPBYTE)pAfpDirInfo,
                    sizeof(AFP_DIRECTORY_INFO) );

        // Now we need to copy the names
        //
        for( dwIndex = 0,
             pbVariableData = (LPBYTE)((ULONG_PTR)pOutputBuf + cbOutputBuf);

             dwIndex < dwCount;

             dwIndex++ ) {

             if ( fUseUnknownAccount )
                         dwUse = SidTypeUnknown;
             else
                         dwUse = pNames[dwIndex].Use;

             switch( dwUse ) {

             case SidTypeInvalid:
                pbVariableData -= ((wcslen(AfpGlobals.wchInvalid)+1)
                                  * sizeof(WCHAR));
                wcscpy( (LPWSTR)pbVariableData, AfpGlobals.wchInvalid );
                break;

             case SidTypeDeletedAccount:
                pbVariableData -= ((wcslen(AfpGlobals.wchDeleted)+1)
                                  * sizeof(WCHAR));
                wcscpy( (LPWSTR)pbVariableData, AfpGlobals.wchDeleted );
                break;

             case SidTypeUnknown:
                pbVariableData -= ((wcslen(AfpGlobals.wchUnknown)+1)
                                  * sizeof(WCHAR));
                wcscpy( (LPWSTR)pbVariableData, AfpGlobals.wchUnknown );
                break;

             case SidTypeWellKnownGroup:
                pbVariableData -= (pNames[dwIndex].Name.Length+sizeof(WCHAR));
                CopyMemory( pbVariableData,
                            pNames[dwIndex].Name.Buffer,
                            pNames[dwIndex].Name.Length );
                break;

             case SidTypeDomain:
                cbOutputBuf +=
                ((pDomainList->Domains[pNames[dwIndex].DomainIndex]).Name.Length);
                CopyMemory( pbVariableData,
                ((pDomainList->Domains[pNames[dwIndex].DomainIndex]).Name.Buffer),
                ((pDomainList->Domains[pNames[dwIndex].DomainIndex]).Name.Length));
                break;

             default:

                {
                
                PSID pDomainSid;

                PUNICODE_STRING pDomain;

                pDomain =
                    &((pDomainList->Domains[pNames[dwIndex].DomainIndex]).Name);

                pDomainSid =
                       (pDomainList->Domains[pNames[dwIndex].DomainIndex]).Sid;

                pbVariableData -= ((pNames[dwIndex].Name.Length+sizeof(WCHAR)));

                pWchar = (WCHAR*)pbVariableData;

                // Copy the domain name if it is not BUILTIN
                //
                if ( !RtlEqualSid( &AfpBuiltInSid, pDomainSid ) ) {

                    pbVariableData -= ( pDomain->Length + sizeof( TEXT('\\')));

                    CopyMemory(pbVariableData,pDomain->Buffer,pDomain->Length);

                    wcscat((LPWSTR)pbVariableData, (LPWSTR)TEXT("\\"));

                    pWchar = (WCHAR*)pbVariableData;

                    pWchar += wcslen( (LPWSTR)pbVariableData );

                }

                CopyMemory( pWchar,
                            pNames[dwIndex].Name.Buffer,
                            pNames[dwIndex].Name.Length );
                }

            }

            // If this is the first time this loop executes then set the
            // owner.
            //
            if ( (dwIndex == 0) && (pAfpDirInfo->afpdir_owner != NULL) )
                pOutputBuf->afpdir_owner = (LPWSTR)pbVariableData;
            else
                pOutputBuf->afpdir_group = (LPWSTR)pbVariableData;
        }

    } while( FALSE );

    if ( pNames != NULL )
        LsaFreeMemory( pNames );

    if ( pDomainList != NULL )
        LsaFreeMemory( pDomainList );

    if ( hLsa != NULL )
        LsaClose( hLsa );

    if ( dwRetCode != NO_ERROR ) {

        AFP_PRINT(( "SFMSVC: AfpDirConvertSidsToNames, failed, error = (%ld)\n"
                    , dwRetCode));

        if ( pOutputBuf != NULL )
            MIDL_user_free( pOutputBuf );
    }
    else
    {
        *ppAfpConvertedDirInfo = pOutputBuf;
    }

    return( dwRetCode );
}

//**
//
// Call:        AfpGetDirInfo
//
// Returns:     NO_ERROR        - success
//              ERROR_NOT_ENOUGH_MEMORY
//              Non-zero returns from NtOpenFile, NtQuerySecurityObject,
//              NtQueryInformationFile.
//
// Description: Read the security descriptor for this directory and obtain the
//              SIDs for Owner and Primary group. Finally obtain Owner, Group
//              and World permissions.
DWORD
AfpGetDirInfo(
        LPWSTR                lpwsDirPath,
        PAFP_DIRECTORY_INFO * lppDirInfo
)
{
NTSTATUS                ntStatus;
DWORD                   dwSizeNeeded;
PBYTE                   pBuffer = NULL;
PBYTE                   pAbsBuffer = NULL;
PISECURITY_DESCRIPTOR   pSecDesc;
PBYTE                   pAbsSecDesc = NULL; // Used in conversion of
                                                                                                // sec descriptor to 
                                                                                                // absolute format
BOOL                    fSawOwnerAce = FALSE;
BOOL                    fSawGroupAce = FALSE;
BYTE                    bOwnerRights = 0;
BYTE                    bGroupRights = 0;
BYTE                    bWorldRights = 0;
FILE_BASIC_INFORMATION  FileBasicInfo;
IO_STATUS_BLOCK         IOStatusBlock;
OBJECT_ATTRIBUTES       ObjectAttributes;
UNICODE_STRING          DirectoryName;
HANDLE                  hDirectory;
PAFP_DIRECTORY_INFO     pAfpDir;
DWORD           dwAlignedSizeAfpDirInfo = sizeof (AFP_DIRECTORY_INFO);
LPWSTR                  pDirPath;
SID                     AfpSidNull = { 1, 1, SECURITY_NULL_SID_AUTHORITY,
                                             SECURITY_NULL_RID };
SID                     AfpSidWorld = { 1, 1, SECURITY_WORLD_SID_AUTHORITY,
                                              SECURITY_WORLD_RID };

    pDirPath = (LPWSTR)LocalAlloc( LPTR,
                                   ( STRLEN(lpwsDirPath) +
                                     STRLEN(TEXT("\\DOSDEVICES\\"))+1)
                                     * sizeof( WCHAR ) );
    if ( pDirPath == NULL )
        return( ERROR_NOT_ENOUGH_MEMORY );

    STRCPY( pDirPath, TEXT("\\DOSDEVICES\\") );
    STRCAT( pDirPath, lpwsDirPath );

    RtlInitUnicodeString( &DirectoryName, pDirPath );

    InitializeObjectAttributes( &ObjectAttributes,
                                &DirectoryName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );

    ntStatus = NtOpenFile( &hDirectory,
                           GENERIC_READ | READ_CONTROL | SYNCHRONIZE,
                           &ObjectAttributes,
                           &IOStatusBlock,
                           FILE_SHARE_READ |
                           FILE_SHARE_WRITE |
                           FILE_SHARE_DELETE,
                           FILE_DIRECTORY_FILE |
                           FILE_SYNCHRONOUS_IO_NONALERT );

    LocalFree( pDirPath );

    if ( !NT_SUCCESS( ntStatus ) )
        return( RtlNtStatusToDosError( ntStatus ) );
        
    // Read the security descriptor for this directory. First get the owner
    // and group security descriptors. We want to optimize on how much memory
    // we need to read this in. Its a pain to make a call just to get that.
    // So just make a guess. If that turns out to be short then do the exact
    // allocation.
    //
    dwSizeNeeded = 2048;

    do {

        if ( pBuffer != NULL )
            MIDL_user_free( pBuffer );

        if ((pBuffer = MIDL_user_allocate( dwSizeNeeded +
                                           dwAlignedSizeAfpDirInfo ))==NULL)
            return( ERROR_NOT_ENOUGH_MEMORY );

        ZeroMemory( pBuffer, dwSizeNeeded + dwAlignedSizeAfpDirInfo );

        pSecDesc = (PSECURITY_DESCRIPTOR)(pBuffer + dwAlignedSizeAfpDirInfo);

        ntStatus = NtQuerySecurityObject( hDirectory,
                                          OWNER_SECURITY_INFORMATION |
                                          GROUP_SECURITY_INFORMATION |
                                          DACL_SECURITY_INFORMATION,
                                          pSecDesc,
                                          dwSizeNeeded,
                                          &dwSizeNeeded);

    } while ((ntStatus != STATUS_SUCCESS) &&
             ((ntStatus == STATUS_BUFFER_OVERFLOW) ||
              (ntStatus == STATUS_BUFFER_TOO_SMALL) ||
              (ntStatus == STATUS_MORE_ENTRIES)));

    if (!NT_SUCCESS(ntStatus)) {
        NtClose( hDirectory );
        MIDL_user_free( pBuffer );
        return( RtlNtStatusToDosError( ntStatus ) );
    }

    pSecDesc = (PISECURITY_DESCRIPTOR)((PBYTE)pSecDesc);

    // If the security descriptor is in self-relative form, convert to absolute
    //
    if (pSecDesc->Control & SE_SELF_RELATIVE)
    {
                    NTSTATUS Status;

            DWORD dwAbsoluteSizeNeeded;

            AFP_PRINT (("AfpGetDirInfo: SE_SELF_RELATIVE security desc\n"));

                        // An absolute SD is not necessarily the same size as a relative
                        // SD, so an in-place conversion may not be possible.
                                                
                        dwAbsoluteSizeNeeded = dwSizeNeeded;            
            Status = RtlSelfRelativeToAbsoluteSD2(pSecDesc, &dwAbsoluteSizeNeeded);
            // Buffer will be small only for 64-bit

                        if (Status == STATUS_BUFFER_TOO_SMALL)
                        {
                                        // Allocate a new buffer in which to store the absolute
                                        // security descriptor, copy the contents of the relative
                                        // descriptor in and try again

                        if ((pAbsBuffer = MIDL_user_allocate( dwAbsoluteSizeNeeded +
                                            dwAlignedSizeAfpDirInfo ))==NULL)
                    {
                        Status = STATUS_NO_MEMORY;
                        AFP_PRINT (("AfpGetDirInfo: MIDL_user_allocate failed for pAbsBuffer\n"));
                    }
                    else
                    {

                            ZeroMemory( pAbsBuffer, dwAbsoluteSizeNeeded + dwAlignedSizeAfpDirInfo );

                            memcpy (pAbsBuffer, pBuffer, sizeof(AFP_DIRECTORY_INFO));

                                pAbsSecDesc = (PSECURITY_DESCRIPTOR)(pAbsBuffer + dwAlignedSizeAfpDirInfo);

                                                        RtlCopyMemory((VOID *)pAbsSecDesc, (VOID *)pSecDesc, dwSizeNeeded);
                                    
                            // All operations hereon will be performed on 
                            // pAbsBuffer. Free earlier memory

                            MIDL_user_free(pBuffer);
                            pBuffer = NULL;
                            pBuffer = pAbsBuffer;

                                                        Status = RtlSelfRelativeToAbsoluteSD2 (pAbsSecDesc,
                                                                                        &dwAbsoluteSizeNeeded);
                                                        if (NT_SUCCESS(Status))
                                                        {
                                                                        // We don't need relative form anymore, 
                                                                        // we will work with the Absolute form
                                                                        pSecDesc = (PISECURITY_DESCRIPTOR)pAbsSecDesc;
                                                        }
                                                        else
                                                        {
                                    AFP_PRINT (("AfpGetDirInfo: RtlSelfRelativeToAbsoluteSD2 2 failed with error %ld\n", Status));
                                                        }
                    }
                        }
            else
            {
                    AFP_PRINT (("AfpGetDirInfo: RtlSelfRelativeToAbsoluteSD2 failed with error %ld\n", Status));
            }

            if (!NT_SUCCESS(Status))
            {
                                AFP_PRINT (("AfpGetDirInfo: RtlSelfRelativeToAbsoluteSD2: returned error %lx\n", Status));
                                if (pBuffer != NULL)
                                {
                                    MIDL_user_free( pBuffer );
                                        pBuffer = NULL;
                                }
                                NtClose( hDirectory );
                        return( RtlNtStatusToDosError( ntStatus ));
            }
    }

    pAfpDir = (PAFP_DIRECTORY_INFO)pBuffer;


    // Walk through the ACL list and determine Owner/Group and World
    // permissions. For Owner and Group, if the specific ace's are not
    // present then they inherit the world permissions.
    //
    // A NULL Acl => All rights to everyone. An empty Acl on the other
    // hand => no access for anyone.
    //
    // Should we be checking for creater owner/creater group well-defined
    // sids or the Owner and Group fields in the security descriptor ?
    //
    bWorldRights = DIR_ACCESS_ALL;
    if (pSecDesc->Control & SE_DACL_PRESENT)
        bWorldRights = 0;

        
    if (pSecDesc->Dacl != NULL ) {

        DWORD               dwCount;
        PSID                pSid;
        PACL                pAcl;
        PACCESS_ALLOWED_ACE pAce;
        
        bWorldRights = 0;
        pAcl = pSecDesc->Dacl;
        pAce = (PACCESS_ALLOWED_ACE)((PBYTE)pAcl + sizeof(ACL));

        for ( dwCount = 0; dwCount < pSecDesc->Dacl->AceCount; dwCount++) {

            pSid = (PSID)(&pAce->SidStart);

            if ( (pSecDesc->Owner != NULL) &&
                 RtlEqualSid(pSid, pSecDesc->Owner ) ){

                AfpAccessMaskToAfpPermissions( bOwnerRights,
                                               pAce->Mask,
                                               pAce->Header.AceType);

                fSawOwnerAce = TRUE;
            }

            if ( ( pSecDesc->Group != NULL ) && 
                   RtlEqualSid(pSid, pSecDesc->Group)){

                AfpAccessMaskToAfpPermissions( bGroupRights,
                                               pAce->Mask,
                                               pAce->Header.AceType);
                fSawGroupAce = TRUE;
            }

            if (RtlEqualSid(pSid, (PSID)&AfpSidWorld)) {

                AfpAccessMaskToAfpPermissions( bWorldRights,
                                               pAce->Mask,
                                               pAce->Header.AceType);
            }

            pAce = (PACCESS_ALLOWED_ACE)((PBYTE)pAce + pAce->Header.AceSize);
        }

    }
        
    if (!fSawOwnerAce)
                bOwnerRights = bWorldRights;

        if (!fSawGroupAce)
                bGroupRights = bWorldRights;

        if (RtlEqualSid(pSecDesc->Group, &AfpSidNull) ||
                ((AfpGlobals.NtProductType != NtProductLanManNt) &&
                  RtlEqualSid(pSecDesc->Group, AfpGlobals.pSidNone)))
        {
                bGroupRights = 0;
                pSecDesc->Group = NULL;
        }

    ntStatus = NtQueryInformationFile( hDirectory,
                                       &IOStatusBlock,
                                       &FileBasicInfo,
                                       sizeof( FileBasicInfo ),
                                       FileBasicInformation );


    NtClose( hDirectory );

    if ( !NT_SUCCESS( ntStatus ) ) {
        MIDL_user_free( pBuffer );
        return( RtlNtStatusToDosError( ntStatus ) );
    }

    pAfpDir->afpdir_perms = (bOwnerRights << OWNER_RIGHTS_SHIFT) +
                            (bGroupRights << GROUP_RIGHTS_SHIFT) +
                            (bWorldRights << WORLD_RIGHTS_SHIFT);

    if ( FileBasicInfo.FileAttributes & FILE_ATTRIBUTE_READONLY )
        pAfpDir->afpdir_perms |= AFP_PERM_INHIBIT_MOVE_DELETE;


    pAfpDir->afpdir_owner = pSecDesc->Owner;
    pAfpDir->afpdir_group = pSecDesc->Group;
                    

    *lppDirInfo = pAfpDir;

        return( NO_ERROR );
}

//**
//
// Call:        AfpValidatePartition
//
// Returns:     NO_ERROR
//              non-zero returns from GetVolumeInformation.
//              AFPERR_UnsupportedFS
//              
//
// Description: Will check to see if the directory is in an NTFS/CDFS
//              partition not.
//
DWORD
AfpValidatePartition(
        IN     LPWSTR lpwsPath
)
{
WCHAR   wchDrive[5];
DWORD   dwMaxCompSize;
DWORD   dwFlags;
WCHAR   wchFileSystem[10];

    // Get the drive letter, : and backslash
    //
    ZeroMemory( wchDrive, sizeof( wchDrive ) );

    STRNCPY( wchDrive, lpwsPath, 3 );

    if ( !( GetVolumeInformation( (LPWSTR)wchDrive,
                                  NULL,
                                  0,
                                  NULL,
                                  &dwMaxCompSize,
                                  &dwFlags,
                                  (LPWSTR)wchFileSystem,
                                  sizeof( wchFileSystem ) / sizeof( wchFileSystem[0] ) ) ) ){
        return GetLastError();
    }

    if ( STRICMP( wchFileSystem, TEXT("CDFS") ) == 0 )
        return( (DWORD)AFPERR_SecurityNotSupported );

    if ( STRICMP( wchFileSystem, TEXT("NTFS") ) == 0 )
        return( NO_ERROR );
    else
        return( (DWORD)AFPERR_UnsupportedFS );
        
}

//**
//
// Call:        AfpAdminrDirectoryGetInfo
//
// Returns:     NO_ERROR
//              ERROR_ACCESS_DENIED
//              non-zero retunrs from I_DirectoryGetInfo
//
// Description: This routine communicates with the AFP FSD to implement
//              the AfpAdminDirectoryGetInfo function. The real work is done
//              by I_DirectoryGetInfo
//
DWORD
AfpAdminrDirectoryGetInfo(
        IN  AFP_SERVER_HANDLE    hServer,
        IN  LPWSTR               lpwsPath,
        OUT PAFP_DIRECTORY_INFO* ppAfpDirectoryInfo
)
{
DWORD   dwRetCode=0;
DWORD   dwAccessStatus=0;

    // Check if caller has access
    //
    if ( dwRetCode = AfpSecObjAccessCheck( AFPSVC_ALL_ACCESS, &dwAccessStatus))
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrDirectoryGetInfo, AfpSecObjAccessCheck failed %ld\n",dwRetCode));
            AfpLogEvent( AFPLOG_CANT_CHECK_ACCESS, 0, NULL,
                     dwRetCode, EVENTLOG_ERROR_TYPE );
        return( ERROR_ACCESS_DENIED );
    }

    if ( dwAccessStatus )
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrDirectoryGetInfo, AfpSecObjAccessCheck returned error (%ld)\n",dwAccessStatus));
        return( ERROR_ACCESS_DENIED );
    }

    dwRetCode = I_DirectoryGetInfo( lpwsPath, ppAfpDirectoryInfo );

    return( dwRetCode );
}

//**
//
// Call:        I_DirectoryGetInfo
//
// Returns:     NO_ERROR
//
// Description: This does the real work to get the directory information.
//              The reason for this worker routine is so that it may be
//              called without the RPC handle and access checking by
//              AfpAdminVolumeAdd API.
//
DWORD
I_DirectoryGetInfo(
        IN LPWSTR                 lpwsPath,
        OUT PAFP_DIRECTORY_INFO * ppAfpDirectoryInfo
)
{
DWORD                           dwRetCode;
AFP_REQUEST_PACKET              AfpSrp;
AFP_DIRECTORY_INFO              AfpDirInfo;
PAFP_DIRECTORY_INFO             pAfpDirInfoSR;
PAFP_DIRECTORY_INFO             pAfpDirInfo;
DWORD                           cbAfpDirInfoSRSize;

    // The FSD expects AFP_VOLUME_INFO structure with only the dir path field
    // filled in.
    //
    AfpDirInfo.afpdir_path  = lpwsPath;
    AfpDirInfo.afpdir_owner = NULL;
    AfpDirInfo.afpdir_group = NULL;

    // Make buffer self relative.
    //
    if ( dwRetCode = AfpBufMakeFSDRequest(  (LPBYTE)&AfpDirInfo,
                                            0,
                                            AFP_DIRECTORY_STRUCT,
                                            (LPBYTE*)&pAfpDirInfoSR,
                                            &cbAfpDirInfoSRSize ) )
        return( dwRetCode );

    // Make IOCTL to get info
    //
    AfpSrp.dwRequestCode                = OP_DIRECTORY_GET_INFO;
    AfpSrp.dwApiType                    = AFP_API_TYPE_GETINFO;
    AfpSrp.Type.GetInfo.pInputBuf       = pAfpDirInfoSR;
    AfpSrp.Type.GetInfo.cbInputBufSize  = cbAfpDirInfoSRSize;

    dwRetCode = AfpServerIOCtrlGetInfo( &AfpSrp );

    LocalFree( pAfpDirInfoSR );

    if ( ( dwRetCode != ERROR_MORE_DATA ) &&
         ( dwRetCode != NO_ERROR ) &&
         ( dwRetCode != AFPERR_DirectoryNotInVolume ) )
        return( dwRetCode );

    // If the directory is not part of a volume, then there server does not
    // return any information back. So we have to do the work here.
    //
    if ( dwRetCode == AFPERR_DirectoryNotInVolume ) {

        // First check to see if the directory is in an NTFS/CDFS partition
        //
        if ( ( dwRetCode = AfpValidatePartition( AfpDirInfo.afpdir_path ))
                                                                != NO_ERROR )
            return( dwRetCode );

        if ( ( dwRetCode = AfpGetDirInfo( AfpDirInfo.afpdir_path,
                                          &pAfpDirInfo ) ) != NO_ERROR )
            return( dwRetCode );

        pAfpDirInfo->afpdir_in_volume = FALSE;
    }
    else {

        pAfpDirInfo = AfpSrp.Type.GetInfo.pOutputBuf;

        // Convert all offsets to pointers
        //
        AfpBufOffsetToPointer( (LPBYTE)pAfpDirInfo, 1, AFP_DIRECTORY_STRUCT );

        pAfpDirInfo->afpdir_in_volume = TRUE;
    }

    // Now convert the owner and group SIDs to names
    //
    dwRetCode = AfpDirConvertSidsToNames( pAfpDirInfo, ppAfpDirectoryInfo );
                                        
    MIDL_user_free( pAfpDirInfo );

    return( dwRetCode );
}

//**
//
// Call:        AfpDirMakeFSDRequest
//
// Returns:     NO_ERROR
//              non-zero returnd from LsaLookupNames
//              ERROR_NOT_ENOUGH_MEMORY
//
// Description: Given a AFP_DIRECTORY_INFO structure, will create a
//              self-relative buffer that is used to IOCTL the directory
//              information down to the FSD. If there are any SIDs names
//              (owner or group) they will be converted to their
//              SIDs.
//
DWORD
AfpDirMakeFSDRequest(
        IN     PAFP_DIRECTORY_INFO      pAfpDirectoryInfo,
        IN     DWORD                    dwParmNum,
        IN OUT PAFP_DIRECTORY_INFO *    ppAfpDirInfoSR,
        OUT    LPDWORD                  pcbAfpDirInfoSRSize )
{
UNICODE_STRING                  Names[2];
DWORD                           dwIndex     = 0;
DWORD                           dwCount     = 0;
PLSA_REFERENCED_DOMAIN_LIST     pDomainList = NULL;
PLSA_TRANSLATED_SID             pSids       = NULL;
LPBYTE                          pbVariableData;
NTSTATUS                        ntStatus;
LSA_HANDLE                      hLsa        = NULL;
SECURITY_QUALITY_OF_SERVICE     QOS;
OBJECT_ATTRIBUTES               ObjectAttributes;
PSID                            pDomainSid;
DWORD                           AuthCount;
PAFP_DIRECTORY_INFO             pAfpDirInfo;

    *pcbAfpDirInfoSRSize = (DWORD)(sizeof( SETINFOREQPKT ) +
                                       sizeof( AFP_DIRECTORY_INFO ) +
                                       (( wcslen( pAfpDirectoryInfo->afpdir_path ) + 1 )
                                        * sizeof(WCHAR)));

    // If the client wants to set the owner or the group
    // then we need to translate the names to sids
    //
    if ( ( dwParmNum & AFP_DIR_PARMNUM_OWNER ) ||
         ( dwParmNum & AFP_DIR_PARMNUM_GROUP ) )
    {

        // First open the LSA and obtain a handle to it.
        //
        QOS.Length              = sizeof( QOS );
        QOS.ImpersonationLevel  = SecurityImpersonation;
        QOS.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
        QOS.EffectiveOnly       = FALSE;

        InitializeObjectAttributes(     &ObjectAttributes,
                                        NULL,
                                        0L,
                                        NULL,
                                        NULL );

        ObjectAttributes.SecurityQualityOfService = &QOS;

        ntStatus = LsaOpenPolicy(       NULL,
                                        &ObjectAttributes,
                                        POLICY_LOOKUP_NAMES,
                                        &hLsa );

        if ( !NT_SUCCESS( ntStatus ))
        {
            return( RtlNtStatusToDosError( ntStatus ) );
        }

        //
            // Translate the owner
            //
        if ( dwParmNum & AFP_DIR_PARMNUM_OWNER )
        {
                RtlInitUnicodeString( &(Names[dwCount++]),
                                                  pAfpDirectoryInfo->afpdir_owner );
            }

        //
            // Translate the group
            //
        if ( dwParmNum & AFP_DIR_PARMNUM_GROUP )
        {
                RtlInitUnicodeString( &(Names[dwCount++]),
                                  pAfpDirectoryInfo->afpdir_group );
            }

        ntStatus = LsaLookupNames(hLsa, dwCount, Names, &pDomainList, &pSids);

        if ( !NT_SUCCESS( ntStatus ) )
        {
            LsaClose( hLsa );

                if ( ntStatus == STATUS_NONE_MAPPED )
            {
                        return( (DWORD)AFPERR_NoSuchUserGroup );
            }
                else
            {
                return( RtlNtStatusToDosError( ntStatus ) );
            }
            }

            for ( dwIndex = 0; dwIndex < dwCount; dwIndex++ )
        {

                if ( ( pSids[dwIndex].Use == SidTypeInvalid ) ||
                     ( pSids[dwIndex].Use == SidTypeUnknown ) ||
                     ( pSids[dwIndex].Use == SidTypeDomain )  ||
                     ( pSids[dwIndex].DomainIndex == -1 ) )
            {

                    LsaFreeMemory( pDomainList );
                    LsaClose( hLsa );

                        if ( ( pSids[dwIndex].Use == SidTypeUnknown ) ||
                             ( pSids[dwIndex].Use == SidTypeInvalid ) )
                {

                        LsaFreeMemory( pSids );

                    if ((dwParmNum & AFP_DIR_PARMNUM_OWNER)&&(dwIndex == 0 ))
                    {
                            return( (DWORD)AFPERR_NoSuchUser );
                    }
                            else
                    {
                            return( (DWORD)AFPERR_NoSuchGroup );
                    }
                        }
                        else
                {

                        LsaFreeMemory( pSids );
                
                        return( (DWORD)AFPERR_NoSuchUserGroup );
                        }
                }

                pDomainSid = pDomainList->Domains[pSids[dwIndex].DomainIndex].Sid;

            AuthCount = *RtlSubAuthorityCountSid( pDomainSid ) + 1;

                *pcbAfpDirInfoSRSize += RtlLengthRequiredSid(AuthCount);
            }
    }

    *ppAfpDirInfoSR=(PAFP_DIRECTORY_INFO)LocalAlloc(LPTR,*pcbAfpDirInfoSRSize);

    if ( *ppAfpDirInfoSR == NULL )
    {
            LsaFreeMemory( pDomainList );
            LsaFreeMemory( pSids );
            LsaClose( hLsa );
            return( ERROR_NOT_ENOUGH_MEMORY );
    }

    pbVariableData = (LPBYTE)((ULONG_PTR)(*ppAfpDirInfoSR) + *pcbAfpDirInfoSRSize);

    pAfpDirInfo = (PAFP_DIRECTORY_INFO)((ULONG_PTR)( *ppAfpDirInfoSR) +
                                                 sizeof( SETINFOREQPKT ));
    // First copy the fixed part
    //
    CopyMemory( pAfpDirInfo, pAfpDirectoryInfo, sizeof(AFP_DIRECTORY_INFO) );

    // Now copy the path
    //
    pbVariableData-=((wcslen(pAfpDirectoryInfo->afpdir_path)+1)*sizeof(WCHAR));

    wcscpy( (LPWSTR)pbVariableData, pAfpDirectoryInfo->afpdir_path );

    pAfpDirInfo->afpdir_path = (LPWSTR)pbVariableData;

    POINTER_TO_OFFSET( pAfpDirInfo->afpdir_path, pAfpDirInfo );

    // Now copy the SIDs if there are any to be copied
    //
    dwCount = 0;

    if ( dwParmNum & AFP_DIR_PARMNUM_OWNER )
    {

            pDomainSid = pDomainList->Domains[pSids[dwCount].DomainIndex].Sid;

        AuthCount = *RtlSubAuthorityCountSid( pDomainSid ) + 1;

            pbVariableData -= RtlLengthRequiredSid(AuthCount);
                        
        // Copy the Domain Sid.
        //
            RtlCopySid( RtlLengthRequiredSid(AuthCount),
                            (PSID)pbVariableData,
                            pDomainSid );


        // Append the Relative Id.
        //
        *RtlSubAuthorityCountSid( (PSID)pbVariableData ) += 1;
        *RtlSubAuthoritySid( (PSID)(pbVariableData), AuthCount - 1) =
                                        pSids[dwCount].RelativeId;

            pAfpDirInfo->afpdir_owner = (LPWSTR)pbVariableData;

        POINTER_TO_OFFSET( pAfpDirInfo->afpdir_owner, pAfpDirInfo );

            dwCount++;
    }

    if ( dwParmNum & AFP_DIR_PARMNUM_GROUP )
    {
            pDomainSid = pDomainList->Domains[pSids[dwCount].DomainIndex].Sid;

        AuthCount = *RtlSubAuthorityCountSid( pDomainSid ) + 1;

            pbVariableData -= RtlLengthRequiredSid(AuthCount);

        // Copy the Domain Sid.
        //
            RtlCopySid( RtlLengthRequiredSid(AuthCount),
                            (PSID)pbVariableData,
                            pDomainSid );

        // Append the Relative Id.
        //
        *RtlSubAuthorityCountSid( (PSID)pbVariableData ) += 1;
        *RtlSubAuthoritySid( (PSID)(pbVariableData), AuthCount - 1) =
                                                pSids[dwCount].RelativeId;

            pAfpDirInfo->afpdir_group = (LPWSTR)pbVariableData;

        POINTER_TO_OFFSET( pAfpDirInfo->afpdir_group, pAfpDirInfo );
    }

    LsaFreeMemory( pDomainList );
    LsaFreeMemory( pSids );
    LsaClose( hLsa );

    return( NO_ERROR );
}

//**
//
// Call:        AfpSetDirPermission
//
// Returns:     NO_ERROR
//              non-zero returns from AfpserverIOCtrl.
//
// Description: Given a directory path, will try to set permissions on it
//
DWORD
AfpSetDirPermission(
        IN LPWSTR               lpwsDirPath,
        IN PAFP_DIRECTORY_INFO  pAfpDirInfo,
        IN DWORD                dwParmNum
)
{
AFP_REQUEST_PACKET  AfpSrp;
PAFP_DIRECTORY_INFO pAfpDirInfoSR;
DWORD               cbAfpDirInfoSRSize;
DWORD               dwRetCode;


    pAfpDirInfo->afpdir_path = lpwsDirPath;

    // Make a self relative buffer and translate any names to SIDs
    //
    if ( dwRetCode = AfpDirMakeFSDRequest( pAfpDirInfo,
                                           dwParmNum,
                                           &pAfpDirInfoSR,
                                           &cbAfpDirInfoSRSize ) )
        return( dwRetCode );

    // Make IOCTL to set info
    //
    AfpSrp.dwRequestCode                = OP_DIRECTORY_SET_INFO;
    AfpSrp.dwApiType                    = AFP_API_TYPE_SETINFO;
    AfpSrp.Type.SetInfo.pInputBuf       = pAfpDirInfoSR;
    AfpSrp.Type.SetInfo.cbInputBufSize  = cbAfpDirInfoSRSize;
    AfpSrp.Type.SetInfo.dwParmNum       = dwParmNum;

    dwRetCode = AfpServerIOCtrl( &AfpSrp );

    LocalFree( pAfpDirInfoSR );

    return( dwRetCode );

}

//**
//
// Call:        AfpRecursePermissions
//
// Returns:     NO_ERROR
//              non-zero returns from FindFirstFile and FindNextFile.
//              non-zero returns from AfpSetDirPermissions
//              ERROR_NOT_ENOUGH_MEMORY.
//
// Description: Will recursively set permissions on a given directory.
//
DWORD
AfpRecursePermissions(
        IN HANDLE               hFile,
        IN LPWSTR               lpwsDirPath,
        IN PAFP_DIRECTORY_INFO  pAfpDirInfo,
        IN DWORD                dwParmNum
)
{
WIN32_FIND_DATA FileInfo;
DWORD           dwRetCode = NO_ERROR;
LPWSTR          lpwsPath;
WCHAR *         pwchPath;
DWORD           dwRetryCount;


    do  {

        lpwsPath = LocalAlloc(LPTR,
                              (STRLEN(lpwsDirPath)+MAX_PATH)*sizeof(WCHAR));

        if ( lpwsPath == NULL ) {
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        STRCPY( lpwsPath, lpwsDirPath );

        if ( hFile != INVALID_HANDLE_VALUE ) {

            // Search for the next sub-directory
            //
            do {

                if ( !FindNextFile( hFile, &FileInfo ) ) {
                    dwRetCode = GetLastError();
                    AFP_PRINT( ( "AFPSVC_dir: Closing handle %x\n", hFile ) );
                    FindClose( hFile );
                    break;
                }

                if ( ( FileInfo.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) &&
                     (!( FileInfo.dwFileAttributes & FILE_ATTRIBUTE_SYSTEM )) &&
                     (!( FileInfo.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN )) &&
                     ( STRCMP( FileInfo.cFileName, TEXT(".") ) != 0 )     &&
                     ( STRCMP( FileInfo.cFileName, TEXT("..") ) != 0 ) )
                    break;
        
            } while( TRUE );

            if ( dwRetCode != NO_ERROR )
                break;

            pwchPath = wcsrchr( lpwsPath, TEXT('\\') );

            STRCPY( pwchPath+1, FileInfo.cFileName );

        }else{

            STRCAT( lpwsPath, TEXT("\\*") );

            hFile = FindFirstFile( lpwsPath, &FileInfo );

            // If there are no more files, we return to the previous
            // level in the recursion.
            //
            if ( hFile == INVALID_HANDLE_VALUE ){

                dwRetCode = GetLastError();
                break;
            }


            // Search for the first sub-directory
            //
            do {

                if ( ( FileInfo.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) &&
                     (!( FileInfo.dwFileAttributes & FILE_ATTRIBUTE_SYSTEM )) &&
                     (!( FileInfo.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN )) &&
                     ( STRCMP( FileInfo.cFileName, TEXT(".") ) != 0 )     &&
                     ( STRCMP( FileInfo.cFileName, TEXT("..") ) != 0 ) )
                    break;

                if ( !FindNextFile( hFile, &FileInfo ) ) {
                    dwRetCode = GetLastError();

                    AFP_PRINT( ( "AFPSVC_dir: Closing handle %x\n", hFile ) );
                    FindClose( hFile );

                    break;
                }

            } while( TRUE );

            if ( dwRetCode != NO_ERROR )
                break;

            pwchPath = lpwsPath + STRLEN(lpwsDirPath) + 1;

            STRCPY( pwchPath, FileInfo.cFileName );
        }


        // Don't send the \\?\ down to the server
        pwchPath = lpwsPath + 4;

        // Set the information
        //
        dwRetryCount = 0;

        do
        {
            dwRetCode = AfpSetDirPermission( pwchPath, pAfpDirInfo, dwParmNum );

            if ( dwRetCode != ERROR_PATH_NOT_FOUND )
                break;

            Sleep( 1000 );

        } while( ++dwRetryCount < 4 );

        if ( dwRetCode != NO_ERROR )
            break;

        // Recurse on the directory
        //
        dwRetCode = AfpRecursePermissions(  hFile,
                                            lpwsPath,
                                            pAfpDirInfo,
                                            dwParmNum );


        if ( dwRetCode != NO_ERROR )
            break;

        // Recurse on the sub-directory
        //
        dwRetCode = AfpRecursePermissions(  INVALID_HANDLE_VALUE,
                                            lpwsPath,
                                            pAfpDirInfo,
                                            dwParmNum );
            break;

        if ( dwRetCode != NO_ERROR )
            break;


    } while( FALSE );

    if ( lpwsPath != (LPWSTR)NULL )
    {
        LocalFree( lpwsPath );
    }

    if ( dwRetCode == ERROR_NO_MORE_FILES )
    {
        dwRetCode = NO_ERROR;
    }

    return( dwRetCode );
}

//**
//
// Call:        AfpAdminrDirectorySetInfo
//
// Returns:     NO_ERROR
//              ERROR_ACCESS_DENIED
//              non-zero retunrs from I_DirectorySetInfo.
//
// Description: This routine communicates with the AFP FSD to implement
//              the AfpAdminDirectorySetInfo function. The real work is done
//              by I_DirectorySetInfo
//
DWORD
AfpAdminrDirectorySetInfo(
        IN  AFP_SERVER_HANDLE    hServer,
        IN  PAFP_DIRECTORY_INFO  pAfpDirectoryInfo,
        IN  DWORD                dwParmNum
)
{
DWORD               dwRetCode=0;
DWORD               dwAccessStatus=0;
                                        

    // Check if caller has access
    //
    if ( dwRetCode = AfpSecObjAccessCheck( AFPSVC_ALL_ACCESS, &dwAccessStatus))
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrDirectorySetInfo, AfpSecObjAccessCheck failed %ld\n",dwRetCode));
            AfpLogEvent( AFPLOG_CANT_CHECK_ACCESS, 0, NULL,
                     dwRetCode, EVENTLOG_ERROR_TYPE );
        return( ERROR_ACCESS_DENIED );
    }

    if ( dwAccessStatus )
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrDirectorySetInfo, AfpSecObjAccessCheck returned %ld\n",dwAccessStatus));
        return( ERROR_ACCESS_DENIED );
    }

    dwRetCode = I_DirectorySetInfo( pAfpDirectoryInfo, dwParmNum );

    return( dwRetCode );
}

//**
//
// Call:        I_DirectorySetInfo
//
// Returns:     NO_ERROR
//              
//
// Description: This routine does the real work. The existance of this
//              worker is so that it may be called from the AfpAfdminVolmeAdd
//              API without the RPC handle and access checking.
//
DWORD
I_DirectorySetInfo(
        IN PAFP_DIRECTORY_INFO  pAfpDirectoryInfo,
        IN DWORD                dwParmNum
)
{
DWORD   dwRetCode;

    if (pAfpDirectoryInfo->afpdir_path == NULL)
    {
        AFP_PRINT(( "SFMSVC: I_DirectorySetInfo, pAfpDirectoryInfo->afpdir_path == NULL\n"));
        return ERROR_INVALID_DATA;
    }

    // Set the permissions on the directory
    //
    if ( ( dwRetCode = AfpSetDirPermission( pAfpDirectoryInfo->afpdir_path,
                                            pAfpDirectoryInfo,
                                            dwParmNum ) ) != NO_ERROR )
        return( dwRetCode );

    // If the user wants to set these permissions recursively
    //
    if ( pAfpDirectoryInfo->afpdir_perms & AFP_PERM_SET_SUBDIRS )
    {
        LPWSTR NTDirName;

        // We must use the \\?\ notation for the path in order to bypass
        // the Win32 path length limitation of 260 chars
        NTDirName = LocalAlloc( LPTR,
                                (STRLEN(pAfpDirectoryInfo->afpdir_path) + 4 + 1)
                                * sizeof(WCHAR));

        if (NTDirName == NULL)
            return( ERROR_NOT_ENOUGH_MEMORY );

        STRCPY( NTDirName, TEXT("\\\\?\\"));
        STRCAT( NTDirName, pAfpDirectoryInfo->afpdir_path);

        dwRetCode = AfpRecursePermissions( INVALID_HANDLE_VALUE,
                                           NTDirName,
                                           pAfpDirectoryInfo,
                                           dwParmNum );
        LocalFree( NTDirName );

    }

    return( dwRetCode );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\service\server\ioctl.h ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.	   **/
/********************************************************************/

//***
//
// Filename:	ioctl.h
//
// Description: Contains the security function prototypes and
//		defintion of AFP_REQUEST_PACKET data structure.
//
// History:
//	May 11,1992.	NarenG		Created original version.
//

#ifndef _IOCTL_
#define _IOCTL_

// This is the size of the buffer sent to the FSD to enumerate entities.
//
#define AFP_INITIAL_BUFFER_SIZE 	4096


// This value in a heuristic to calculate the amount of memory required to
// hold all enumerated entities. This value represents the avg size of all
// entities.
//
#define AFP_AVG_STRUCT_SIZE			512

// Id's of the various API types
//
typedef enum _AFP_API_TYPE {

    AFP_API_TYPE_COMMAND,
    AFP_API_TYPE_SETINFO,
    AFP_API_TYPE_DELETE,
    AFP_API_TYPE_GETINFO,
    AFP_API_TYPE_ENUM,
    AFP_API_TYPE_ADD

} AFP_API_TYPE;



typedef struct _AFP_REQUEST_PACKET {

    // Command code
    //
    DWORD		dwRequestCode;

    AFP_API_TYPE	dwApiType;

    union {

    	struct {

    	    PVOID	pInputBuf;
    	    DWORD	cbInputBufSize;

	    DWORD	dwParmNum;

	} SetInfo;

    	struct {

    	    PVOID	pInputBuf;
    	    DWORD	cbInputBufSize;

	} Add;

    	struct {

    	    PVOID	pInputBuf;

	    // This parameter will be set to indicate the maximum amount of
	    // data that may be returned to the client.
	    // -1 indicates all available data.
	    //
    	    DWORD	cbInputBufSize;

    	    PVOID	pOutputBuf;
    	    DWORD	cbOutputBufSize;

	    DWORD	cbTotalBytesAvail;

	} GetInfo;

    	struct {

    	    // Will be pointer to an output buffer for Enum calls
	    //
    	    PVOID	pOutputBuf;

	    // This parameter will be set to indicate the maximum amount of
	    // data that may be returned to the client.
	    // -1 indicates all available data.
	    //
    	    DWORD	cbOutputBufSize;

    	    DWORD	dwEntriesRead;

    	    // Will contain the total number of entries available from the
	    // current position (pointed to by dwResumeHandle)
    	    //
    	    DWORD	dwTotalAvail;

	    // This information will get sent to the FSD as the Enum
	    // request packet.
	    //
 	    ENUMREQPKT  EnumRequestPkt;
	
	} Enum;

    	struct  {

	    // Will point to structure representing the entity to be
	    // closed, deleted or removed.
            //
    	    PVOID	pInputBuf;
    	    DWORD	cbInputBufSize;

	} Delete;

    } Type;

} AFP_REQUEST_PACKET, *PAFP_REQUEST_PACKET;

// Function prototypes
//
DWORD
AfpServerIOCtrl(
	PAFP_REQUEST_PACKET pAfpSrp
);

DWORD
AfpServerIOCtrlGetInfo(
	PAFP_REQUEST_PACKET pAfpSrp
);

#endif // ifndef _IOCTL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\service\server\message.c ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.	   **/
/********************************************************************/

//***
//
// Filename:	message.c
//
// Description: This module contains support routines for the message
//		category API's for the AFP server service. These routines
//		will be called by the RPC runtime.
//
// History:
//		July 21,1992.	NarenG		Created original version.
//
#include "afpsvcp.h"

//**
//
// Call:	AfpAdminrMessageSend
//
// Returns:	NO_ERROR	- success
//		ERROR_ACCESS_DENIED
//		non-zero returns from the IOCTL
//
// Description: This routine communicates with the AFP FSD to implement
//		the AfpAdminMessageSend function.
//
DWORD
AfpAdminrMessageSend(
	IN  AFP_SERVER_HANDLE     hServer,
	IN  PAFP_MESSAGE_INFO     pAfpMessageInfo
)
{
AFP_REQUEST_PACKET AfpSrp;
DWORD		   dwAccessStatus=0;
DWORD		   dwRetCode=0;
PAFP_MESSAGE_INFO  pAfpMessageInfoSR;	
DWORD		   cbAfpMessageInfoSRSize;


    // Check if caller has access
    //
    if ( dwRetCode = AfpSecObjAccessCheck( AFPSVC_ALL_ACCESS, &dwAccessStatus))
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrMessageSend, AfpSecObjAccessCheck failed %ld\n",dwRetCode));
	    AfpLogEvent( AFPLOG_CANT_CHECK_ACCESS, 0, NULL,
		     dwRetCode, EVENTLOG_ERROR_TYPE );
        return( ERROR_ACCESS_DENIED );
    }

    if ( dwAccessStatus )
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrMessageSend, AfpSecObjAccessCheck returned %ld\n",dwAccessStatus));
        return( ERROR_ACCESS_DENIED );
    }

    // Make this buffer self-relative.
    //
    if ( dwRetCode = AfpBufMakeFSDRequest((LPBYTE)pAfpMessageInfo,
					  0,
					  AFP_MESSAGE_STRUCT,
					  (LPBYTE*)&pAfpMessageInfoSR,
					  &cbAfpMessageInfoSRSize ))
	return( dwRetCode );

        // Make IOCTL to set info

    // Set up request packet and make IOCTL to the FSD
    //
    AfpSrp.dwRequestCode 		= OP_MESSAGE_SEND;
    AfpSrp.dwApiType     		= AFP_API_TYPE_ADD;
    AfpSrp.Type.Add.pInputBuf		= pAfpMessageInfoSR;
    AfpSrp.Type.Add.cbInputBufSize	= cbAfpMessageInfoSRSize;

    dwRetCode = AfpServerIOCtrl( &AfpSrp );

    LocalFree( pAfpMessageInfoSR );

    return( dwRetCode );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\service\server\main.c ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.	   **/
/********************************************************************/

//***
//
// Filename: 	main.c
//
// Description: This module contains the main procedure of the AFP server
//		service. It will contain code to initialize and install
//		itself and the kernel-mode AFP Server. It also contains
//		code to respond to the server controller. It will also
//		handle service shutdown.
//
//		??? Does the service controller log start/stop events etc ??
//		    if not log it.
//		
// History:
//		May 11,1990.	NarenG		Created original version.
//
#define DEFINE_AFP_GLOBALS	// This will cause AfpGlobals to be defined.
#include "afpsvcp.h"

// Prototypes of functions used only within this module.
//
VOID
AfpMain(
	IN DWORD 	argc,
	IN LPWSTR * 	lpwsServiceArgs
);

VOID
AfpCleanupAndExit(
	IN DWORD 	dwError
);

VOID
AfpControlResponse(
	IN DWORD 	dwControlCode
);


//**
//
// Call:	main.c
//
// Returns:	none.
//
// Description: Will simply register the entry point of the AFP server
//		service with the service controller. The service controller
//		will capture this thread. It will be freed only when
//		the service is shutdown. At that point we will simply exit
//		the process.
//
void
_cdecl
main( int argc, unsigned char * argv[] )
{
SERVICE_TABLE_ENTRY	AfpServiceDispatchTable[2];

#ifdef DBG

    CONSOLE_SCREEN_BUFFER_INFO csbi;
    COORD coord;
    (VOID)AllocConsole( );
    (VOID)GetConsoleScreenBufferInfo( GetStdHandle(STD_OUTPUT_HANDLE),
                		      &csbi
                 		    );
    coord.X = (SHORT)(csbi.srWindow.Right - csbi.srWindow.Left + 1);
    coord.Y = (SHORT)((csbi.srWindow.Bottom - csbi.srWindow.Top + 1) * 20);
    (VOID)SetConsoleScreenBufferSize( GetStdHandle(STD_OUTPUT_HANDLE),
                		      coord
                		    );
#endif

    AFP_UNREFERENCED( argc );
    AFP_UNREFERENCED( argv );


    AfpServiceDispatchTable[0].lpServiceName = AFP_SERVICE_NAME;
    AfpServiceDispatchTable[0].lpServiceProc = AfpMain;
    AfpServiceDispatchTable[1].lpServiceName = NULL;
    AfpServiceDispatchTable[1].lpServiceProc = NULL;

    if ( !StartServiceCtrlDispatcher( AfpServiceDispatchTable ) )
	AfpLogEvent( AFPLOG_CANT_START, 0, NULL,
		     GetLastError(), EVENTLOG_ERROR_TYPE );

    ExitProcess(0);

}

//**
//
// Call:	AfpMain
//
// Returns:	none.
//
// Description: This is the main procedure for the Afp Server Service. It
//		will be called when the service is supposed to start itself.
//		It will do all service wide initialization.
//
VOID
AfpMain( DWORD	  argc,		// Command line arguments. Will be ignored.
	 LPWSTR * lpwsServiceArgs
)
{
DWORD	dwRetCode;


    AFP_UNREFERENCED( argc );
    AFP_UNREFERENCED( lpwsServiceArgs );

    // NULL out all the globals
    //
    ZeroMemory( (LPBYTE)&AfpGlobals, sizeof(AfpGlobals) );

    // Register the service control handler with the service controller
    //
    AfpGlobals.hServiceStatus = RegisterServiceCtrlHandler(AFP_SERVICE_NAME,
							   AfpControlResponse );

    if ( AfpGlobals.hServiceStatus == (SERVICE_STATUS_HANDLE)0 ) {
	    AfpLogEvent( AFPLOG_CANT_START, 0, NULL,
                    GetLastError(), EVENTLOG_ERROR_TYPE );
	    AfpCleanupAndExit( GetLastError() );
        return;
    }

    AfpGlobals.ServiceStatus.dwServiceType  	      = SERVICE_WIN32;
    AfpGlobals.ServiceStatus.dwCurrentState 	      = SERVICE_START_PENDING;
    AfpGlobals.ServiceStatus.dwControlsAccepted       = 0;
    AfpGlobals.ServiceStatus.dwWin32ExitCode 	      = NO_ERROR;
    AfpGlobals.ServiceStatus.dwServiceSpecificExitCode= 0;
    AfpGlobals.ServiceStatus.dwCheckPoint 	      = 1;
    AfpGlobals.ServiceStatus.dwWaitHint 	      =AFP_SERVICE_INSTALL_TIME;

    AfpAnnounceServiceStatus();

    // Read in registry information and initialize the kernel-mode
    // server. Initialize the server to accept RPC calls. Initialize
    // all global vriables etc.
    //
    if ( dwRetCode = AfpInitialize() )
    {
        if (AfpGlobals.dwServerState & AFPSTATE_BLOCKED_ON_DOMINFO)
        {
	        AfpCleanupAndExit( NO_ERROR );
        }
        else
        {
	        AfpCleanupAndExit( dwRetCode );
        }
        return;
    }


    // Set the MAC bit for NetServerEnum
    //
    if ( !I_ScSetServiceBits( AfpGlobals.hServiceStatus,
			      SV_TYPE_AFP,
			      TRUE,
	                      TRUE,
			      NULL ))
    {

	    dwRetCode = GetLastError();
	    AfpLogEvent( AFPLOG_CANT_START, 0, NULL,
		                    GetLastError(), EVENTLOG_ERROR_TYPE );
        AfpCleanupAndExit( dwRetCode );
        return;
    }

    // now tell the service controller that we are up
    //
    if (AfpGlobals.ServiceStatus.dwCurrentState == SERVICE_START_PENDING)
    {
        AfpGlobals.ServiceStatus.dwCurrentState     = SERVICE_RUNNING;
        AfpGlobals.ServiceStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP |
		    			          SERVICE_ACCEPT_PAUSE_CONTINUE;
        AfpGlobals.ServiceStatus.dwCheckPoint       = 0;
        AfpGlobals.ServiceStatus.dwWaitHint         = 0;

        AfpAnnounceServiceStatus();
    }


    // Start listening for RPC admin client calls. This will block
    // until RpcMgmtStopServerListening is called while processing a
    // STOP_SERVICE control request.
    //
    if ( dwRetCode = RpcServerListen( 1,
				      RPC_C_LISTEN_MAX_CALLS_DEFAULT,
				      0 ) )	// Blocking mode
    {

	    AfpLogEvent( AFPLOG_CANT_INIT_RPC, 0, NULL,
		                        dwRetCode, EVENTLOG_ERROR_TYPE );
    }

    AfpCleanupAndExit( dwRetCode );

}

//**
//
// Call:	AfpCleanupAndExit
//
// Returns:	none
//
// Description: Will free any allocated memory, deinitialize RPC, deinitialize
//		the kernel-mode server and unload it if it was loaded.
//		This could have been called due to an error on SERVICE_START
//		or normal termination.
//
VOID
AfpCleanupAndExit(
	IN DWORD dwError
)
{

    AFP_PRINT( ("AFPSVC_main: Cleaning up and exiting Code = %d\n", dwError));

    // Tear down and free everything
    //
    AfpTerminate();

    if ( dwError == NO_ERROR )
    	AfpGlobals.ServiceStatus.dwWin32ExitCode = NO_ERROR;
    else {
    	AfpGlobals.ServiceStatus.dwWin32ExitCode = ERROR_SERVICE_SPECIFIC_ERROR;
	//AFP_ASSERT(0);
    }

    AfpGlobals.ServiceStatus.dwCurrentState 		= SERVICE_STOPPED;
    AfpGlobals.ServiceStatus.dwCheckPoint   		= 0;
    AfpGlobals.ServiceStatus.dwWaitHint     		= 0;
    AfpGlobals.ServiceStatus.dwServiceSpecificExitCode 	= dwError;

    AfpAnnounceServiceStatus();

    return;
}

//**
//
// Call:	AfpControlResponse
//
// Returns:	none
//
// Description: Will respond to control requests from the service controller.
//
VOID
AfpControlResponse( IN DWORD dwControlCode )
{
AFP_REQUEST_PACKET	AfpRequestPkt;
DWORD			dwRetCode;

    switch( dwControlCode ) {

    case SERVICE_CONTROL_STOP:

	if ( (AfpGlobals.ServiceStatus.dwCurrentState == SERVICE_STOP_PENDING)
	     ||
	     (AfpGlobals.ServiceStatus.dwCurrentState == SERVICE_STOPPED ))
	    break;

	// Announce that we are stopping
	//
    	AfpGlobals.ServiceStatus.dwCurrentState        = SERVICE_STOP_PENDING;
    	AfpGlobals.ServiceStatus.dwControlsAccepted    = 0;
    	AfpGlobals.ServiceStatus.dwCheckPoint          = 1;
    	AfpGlobals.ServiceStatus.dwWaitHint            = AFP_SERVICE_STOP_TIME;

    	AfpAnnounceServiceStatus();

        // if srvrhlpr thread is blocked retrying to get domain info, unblock it
        SetEvent(AfpGlobals.heventSrvrHlprSpecial);

        // if srvrhlpr thread was blocked, no more init was done, so we're done
        if (AfpGlobals.dwServerState & AFPSTATE_BLOCKED_ON_DOMINFO)
        {
            return;
        }

	// This call will unblock the main thread that had called
	// RpcServerListen. We let that thread do the announcing
	// while cleaning up.
	//
    if ( (dwRetCode = 
            RpcMgmtStopServerListening( (RPC_BINDING_HANDLE)NULL ))
            != RPC_S_OK )
    {
        ASSERT (0);
    }


	return;

    case SERVICE_CONTROL_PAUSE:

	if ( (AfpGlobals.ServiceStatus.dwCurrentState == SERVICE_PAUSE_PENDING)
	     ||
	     (AfpGlobals.ServiceStatus.dwCurrentState == SERVICE_PAUSED ))
	    break;

    	AfpGlobals.ServiceStatus.dwCurrentState     = SERVICE_PAUSE_PENDING;
    	AfpGlobals.ServiceStatus.dwControlsAccepted = 0;
    	AfpGlobals.ServiceStatus.dwCheckPoint       = 0;
    	AfpGlobals.ServiceStatus.dwWaitHint 	    = AFP_SERVICE_PAUSE_TIME;

    	AfpAnnounceServiceStatus();


	// Tell the kernel-mode that we want to pause.
  	//
	AfpRequestPkt.dwRequestCode = OP_SERVICE_PAUSE;
        AfpRequestPkt.dwApiType     = AFP_API_TYPE_COMMAND;

	dwRetCode = AfpServerIOCtrl( &AfpRequestPkt );

	AFP_ASSERT( dwRetCode == NO_ERROR );

    	AfpGlobals.ServiceStatus.dwCheckPoint       = 0;
    	AfpGlobals.ServiceStatus.dwWaitHint         = 0;
    	AfpGlobals.ServiceStatus.dwCurrentState     = SERVICE_PAUSED;
    	AfpGlobals.ServiceStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP |
					          SERVICE_ACCEPT_PAUSE_CONTINUE;
	break;

    case SERVICE_CONTROL_CONTINUE:

	if ( (AfpGlobals.ServiceStatus.dwCurrentState==SERVICE_CONTINUE_PENDING)
	     ||
	     (AfpGlobals.ServiceStatus.dwCurrentState == SERVICE_RUNNING ))
	    break;

    	AfpGlobals.ServiceStatus.dwCurrentState     = SERVICE_CONTINUE_PENDING;
    	AfpGlobals.ServiceStatus.dwControlsAccepted = 0;
    	AfpGlobals.ServiceStatus.dwCheckPoint       = 0;
    	AfpGlobals.ServiceStatus.dwWaitHint         = AFP_SERVICE_CONTINUE_TIME;

    	AfpAnnounceServiceStatus();

	// Tell the kernel-mode that we want to continue.
  	//
	AfpRequestPkt.dwRequestCode = OP_SERVICE_CONTINUE;
        AfpRequestPkt.dwApiType     = AFP_API_TYPE_COMMAND;

	dwRetCode = AfpServerIOCtrl( &AfpRequestPkt );

	AFP_ASSERT( dwRetCode == NO_ERROR );

    	AfpGlobals.ServiceStatus.dwCheckPoint       = 0;
    	AfpGlobals.ServiceStatus.dwWaitHint 	    = 0;
    	AfpGlobals.ServiceStatus.dwCurrentState     = SERVICE_RUNNING;
    	AfpGlobals.ServiceStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP |
					          SERVICE_ACCEPT_PAUSE_CONTINUE;

	break;

    case SERVICE_CONTROL_INTERROGATE:
	break;

    default:
	break;

    }

    AfpAnnounceServiceStatus();
}

//**
//
// Call:	AfpAnnounceServiceStatus
//
// Returns:	none
//
// Description: Will simly call SetServiceStatus to inform the service
//		control manager of this service's current status.
//
VOID
AfpAnnounceServiceStatus( VOID )
{
BOOL dwRetCode;


    dwRetCode = SetServiceStatus( AfpGlobals.hServiceStatus,
				  &(AfpGlobals.ServiceStatus) );

    AFP_ASSERT( dwRetCode == TRUE );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\service\server\registry.c ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.	   **/
/********************************************************************/

//***
//
// Filename:	registry.c
//
// Description: This module contains routines to manupilate information
//		in the registry.
//
// History:
//		May 11,1992.	NarenG		Created original version.
//

#include "afpsvcp.h"

// AFP Server Service registry parameter structure
//
typedef struct _AFP_SERVER_REG_PARAMS {

    LPWSTR	lpwValueName;
    PVOID	pValue;
    DWORD	dwDataType;
    DWORD	dwErrorLogId;
    BOOL 	(*pfuncIsValid)( LPVOID );

} AFP_SERVER_REG_PARAMS, *PAFP_SERVER_REG_PARAMS;

AFP_SERVER_REG_PARAMS AfpServerRegParams[] = {

    AFPREG_VALNAME_SVRNAME, 
    AfpGlobals.wchServerName,
    REG_SZ,
    AFPLOG_INVALID_SERVERNAME,
    IsAfpServerNameValid, 

    AFPREG_VALNAME_SRVOPTIONS, 
    &(AfpGlobals.dwServerOptions),
    REG_DWORD,
    AFPLOG_INVALID_SRVOPTION,
    IsAfpServerOptionsValid, 

    AFPREG_VALNAME_MAXSESSIONS, 
    &(AfpGlobals.dwMaxSessions),
    REG_DWORD,
    AFPLOG_INVALID_MAXSESSIONS,
    IsAfpMaxSessionsValid, 

    AFPREG_VALNAME_LOGINMSG, 
    AfpGlobals.wchLoginMsg,
    REG_SZ,
    AFPLOG_INVALID_LOGINMSG,
    IsAfpMsgValid, 

    AFPREG_VALNAME_MAXPAGEDMEM,
    &(AfpGlobals.dwMaxPagedMem),
    REG_DWORD,
    AFPLOG_INVALID_MAXPAGEDMEM,
    IsAfpMaxPagedMemValid, 

    AFPREG_VALNAME_MAXNONPAGEDMEM,
    &(AfpGlobals.dwMaxNonPagedMem),
    REG_DWORD,
    AFPLOG_INVALID_MAXNONPAGEDMEM,
    IsAfpMaxNonPagedMemValid, 

    NULL, NULL, 0, 0, FALSE
};

//**
//
// Call:	AfpRegOpen
//
// Returns:	NO_ERROR	- success	
//		non-zero returns from registry API's
//
// Description:	Will simply open and handles to keys in the registry
//		where the server parameters, volumes list and ETC list
//		are stored. These open handles will be stored in global
//		variables.
//
DWORD
AfpRegOpen( 
	VOID 
)
{
DWORD	dwRetCode;

    AfpGlobals.hkeyServerParams = NULL;
    AfpGlobals.hkeyVolumesList  = NULL;
    AfpGlobals.hkeyIcons	= NULL;
    AfpGlobals.hkeyTypeCreators = NULL;
    AfpGlobals.hkeyExtensions   = NULL;

    // The do - while( FALSE ) loop is used here to avoid using a goto to
    // do a cleanup and exit.
    //
    do {

    	// Obtain handle to the ..\PARAMETERS key.
    	//
    	if ( dwRetCode = RegOpenKeyEx(
				  HKEY_LOCAL_MACHINE,
				  AFP_KEYPATH_SERVER_PARAMS,
				  0,
				  KEY_ALL_ACCESS,
				  &AfpGlobals.hkeyServerParams
				))
	    break;

    	// Obtain handle to the ..\PARAMETERS\VOLUMES volume list key
        //
    	if ( dwRetCode = RegOpenKeyEx(
				  HKEY_LOCAL_MACHINE,
				  AFP_KEYPATH_VOLUMES,
				  0,
				  KEY_ALL_ACCESS,
				  &AfpGlobals.hkeyVolumesList
				)) 
	    break;

    	// Obtain handle to the ..\PARAMETERS\TYPE_CREATORS key
    	//
    	if ( dwRetCode = RegOpenKeyEx(
				  HKEY_LOCAL_MACHINE,
			          AFP_KEYPATH_TYPE_CREATORS,
				  0,
				  KEY_ALL_ACCESS,
			          &AfpGlobals.hkeyTypeCreators
			   	 )) 
	    break;

    	// Obtain handle to the ..\PARAMETERS\EXTENSIONS key
    	//
    	if ( dwRetCode = RegOpenKeyEx(
				  HKEY_LOCAL_MACHINE,
			          AFP_KEYPATH_EXTENSIONS,
				  0,
				  KEY_ALL_ACCESS,
			          &AfpGlobals.hkeyExtensions
			   	 )) 
	    break;

    	// Obtain handle to the ..\PARAMETERS\ICONS key
    	//
    	if ( dwRetCode = RegOpenKeyEx(
				  HKEY_LOCAL_MACHINE,
			          AFP_KEYPATH_ICONS,
				  0,
				  KEY_ALL_ACCESS,
			          &AfpGlobals.hkeyIcons
			   	 )) 
	    break;

    } while( FALSE );

    return( dwRetCode );
}

//**
//
// Call:	AfpRegClose
//
// Returns:	none
//
// Description: Simply closes all handles opened by AfpRegOpen
//
VOID
AfpRegClose( 
	VOID 
)
{
    if ( AfpGlobals.hkeyServerParams )
   	RegCloseKey( AfpGlobals.hkeyServerParams );

    if ( AfpGlobals.hkeyVolumesList )
   	RegCloseKey( AfpGlobals.hkeyVolumesList );

    if ( AfpGlobals.hkeyTypeCreators )
    	RegCloseKey( AfpGlobals.hkeyTypeCreators );

    if ( AfpGlobals.hkeyExtensions )
    	RegCloseKey( AfpGlobals.hkeyExtensions );

    if ( AfpGlobals.hkeyIcons )
    	RegCloseKey( AfpGlobals.hkeyIcons );

    return;
}

//**
//
// Call:	AfpRegServerGetInfo
//
// Returns:	NO_ERROR	- success
//		non-zero returns from registry calls.
//		ERROR_NOT_ENOUGH_MEMORY
//
// Description: This procedure is called to obtain server parameters.
//		It is assumed that before this procedure is called the 
//		default values for these parameters are already set.
//		If the parameter is not in the registry the default will 
//		be used ie. this procedure will not change it.
//		If a parameter exists in the registry, it will be retrieved.
//		If the retrieved parameter is invalid, an error event will
//		be logged and the default value will be used.
//
//		
DWORD
AfpRegServerGetInfo( 
	VOID 
)
{
DWORD 	dwRetCode;
DWORD 	dwTitle	= 0;
DWORD  	dwType;
LPBYTE  lpbValueBuf;
DWORD 	dwMaxValNameLen;
DWORD 	dwNumValues;
DWORD 	dwMaxValueDataSize;
DWORD	dwBufSize;
DWORD	dwIndex;

    // First find out the number of values and the max. size of them.
    //
    if ( dwRetCode = AfpRegGetKeyInfo(  AfpGlobals.hkeyServerParams,
		  		        &dwMaxValNameLen,    
		  		  	&dwNumValues,
		  			&dwMaxValueDataSize  
					))
	return( dwRetCode );

    // Allocate enough memory to hold the max. variable length data.
    //
    if ( ( lpbValueBuf = (LPBYTE)LocalAlloc(LPTR, dwMaxValueDataSize)) == NULL )
	return( ERROR_NOT_ENOUGH_MEMORY );

    // Run through ad get all the server parameters.
    // 
    for ( dwIndex   = 0, 
	  dwBufSize = dwMaxValueDataSize; 

	  AfpServerRegParams[dwIndex].lpwValueName != NULL;

	  dwIndex++, 
	  dwBufSize = dwMaxValueDataSize ) {

	ZeroMemory( lpbValueBuf, dwMaxValueDataSize );

    	// Get the server parameter.
    	//    
    	dwRetCode = RegQueryValueEx( AfpGlobals.hkeyServerParams,
	  			     AfpServerRegParams[dwIndex].lpwValueName, 
				     NULL,
				     &dwType,
				     lpbValueBuf,
				     &dwBufSize );

 	// If the parameter was present then read it in otherwise just
  	// skip it and let the default value stand. 
        //
    	if ( dwRetCode == NO_ERROR ) {

	     // If the parameter was valid we use it
	     //
	     if ( (*(AfpServerRegParams[dwIndex].pfuncIsValid))(lpbValueBuf) ){

		switch( AfpServerRegParams[dwIndex].dwDataType ) {
		
		case REG_SZ:

		    if ( STRLEN( (LPWSTR)lpbValueBuf ) > 0 ) 
		    	STRCPY( (LPWSTR)(AfpServerRegParams[dwIndex].pValue),
			        (LPWSTR)lpbValueBuf );
		    else
		    	((LPWSTR)(AfpServerRegParams[dwIndex].pValue))[0] = 
								     TEXT('\0');

		    break;

		case REG_DWORD:
    		    *(LPDWORD)(AfpServerRegParams[dwIndex].pValue) = 
						*(LPDWORD)lpbValueBuf;
		    break;

		default:
		    AFP_ASSERT( FALSE );
		    break;
		}
	     }
	     else {
		
		// Otherwise we log this error
		//
	        AfpLogEvent( AfpServerRegParams[dwIndex].dwErrorLogId, 
			     0, NULL, dwRetCode, EVENTLOG_WARNING_TYPE );
	    }
	}
	else if ( dwRetCode == ERROR_FILE_NOT_FOUND ) 
	    dwRetCode = NO_ERROR;
	else
	    break;
    }

    LocalFree( lpbValueBuf );
    return( dwRetCode );
}

//**
//
// Call:	AfpRegVolumeAdd
//
// Returns:	NO_ERROR		- success
//		non-zero returns from registry API's
//
// Description: This routine takes a AFP_VOLUME_INFO, creates a REG_MULTI_SZ
//		from it and stores it in the registry.
//
DWORD
AfpRegVolumeAdd( 
	IN PAFP_VOLUME_INFO    pVolumeInfo  
)
{
DWORD	dwRetCode;
DWORD	cbMultiSzSize;
LPBYTE  lpbMultiSz;
DWORD	dwLength;
DWORD   dwIndex;
WCHAR   wchEncryptedPass[AFP_VOLPASS_LEN+1];
			    
    // Before we add the volume we encrypt the password if there is one
    //
    if ( ( pVolumeInfo->afpvol_password != (LPWSTR)NULL ) &&
         ( STRLEN( pVolumeInfo->afpvol_password ) > 0 ) ) {

	ZeroMemory( wchEncryptedPass, sizeof( wchEncryptedPass ) );

    	dwLength = STRLEN( pVolumeInfo->afpvol_password );

    	for ( dwIndex = 0; dwIndex < AFP_VOLPASS_LEN; dwIndex++ ) {

	    wchEncryptedPass[dwIndex] =  ( dwIndex < dwLength )   
			? pVolumeInfo->afpvol_password[dwIndex] ^ 0xF000
	    		: (wchEncryptedPass[dwIndex] ^= 0xF000); 
	}

    	pVolumeInfo->afpvol_password = wchEncryptedPass;

    }
 
    if ( dwRetCode = AfpBufMakeMultiSz( AFP_VOLUME_STRUCT,
				        (LPBYTE)pVolumeInfo,
				        &lpbMultiSz,
					&cbMultiSzSize ))
	return( dwRetCode );

    // Set the data.
    //
    dwRetCode = RegSetValueEx(  AfpGlobals.hkeyVolumesList,
				pVolumeInfo->afpvol_name,
				0,
				REG_MULTI_SZ,
				lpbMultiSz,
				cbMultiSzSize
				);

    LocalFree( lpbMultiSz );

    return( dwRetCode );
}

//**
//
// Call:	AfpRegVolumeDelete
//
// Returns:	NO_ERROR	- success
//		non-zero returns from registry calls.
//
// Description: Will delete a volume from the Volume list in the registry.
//
DWORD
AfpRegVolumeDelete( 
	IN LPWSTR lpwsVolumeName 
)
{
    return( RegDeleteValue( AfpGlobals.hkeyVolumesList, lpwsVolumeName ) );
}

//**
//
// Call:	AfpRegVolumeSetInfo
//
// Returns:	NO_ERROR		- success
//		non-zero returns from registry API's
//
// Description: 
//		
//
DWORD
AfpRegVolumeSetInfo( 	
	IN PAFP_VOLUME_INFO    pVolumeInfo  
)
{
    return( AfpRegVolumeAdd( pVolumeInfo ) );
}

//**
//
// Call:	AfpRegTypeCreatorEnum
//
// Returns:	NO_ERROR	- success
//	   	ERROR_NOT_ENOUGH_MEMORY 
//		non-zero returns from registry APIs.
//
// Description: This procedure will read in type/creator/comment information
//		from the registry and store it in memory in the
//		AfpGlobals.AfpETCMapInfo structure. Only fatal errors will
//		be returned. Non-fatal errors will be errorlogged.
//
DWORD
AfpRegTypeCreatorEnum( 
	VOID 
)
{
DWORD 	     	   dwRetCode;
DWORD 	     	   cbMaxValNameLen;   
DWORD		   cbValNameBufSize;
DWORD 	     	   dwNumValues;	
DWORD 	     	   cbMaxValueDataSize;
DWORD	     	   dwValueIndex;
DWORD	     	   cbBufSize;
DWORD	     	   dwType;
PAFP_TYPE_CREATOR  pTypeCreatorWalker;
PAFP_TYPE_CREATOR  pTypeCreator;
LPWSTR	           lpwsValName;
LPBYTE		   lpbMultiSz;
CHAR		   chAnsiBuf[10];
   

    // Read in the type/creators
    //
    if ( dwRetCode = AfpRegGetKeyInfo( 	AfpGlobals.hkeyTypeCreators,
		  			&cbMaxValNameLen,    
		  			&dwNumValues,	
		  			&cbMaxValueDataSize 
				  	))
	return( dwRetCode );


    // Allocate space for the number of values in this key.
    //
    AfpGlobals.AfpETCMapInfo.afpetc_type_creator=(PAFP_TYPE_CREATOR)LocalAlloc(
 					LPTR, 
					sizeof(AFP_TYPE_CREATOR) * dwNumValues);

    if ( AfpGlobals.AfpETCMapInfo.afpetc_type_creator == NULL ) 
	return( ERROR_NOT_ENOUGH_MEMORY );

    AfpGlobals.AfpETCMapInfo.afpetc_num_type_creators = 0;

    if ( dwNumValues == 0 ) 
	return( NO_ERROR );

    if (( lpwsValName = (LPWSTR)LocalAlloc( LPTR, cbMaxValNameLen )) == NULL){
	LocalFree(AfpGlobals.AfpETCMapInfo.afpetc_type_creator );
	return( ERROR_NOT_ENOUGH_MEMORY );
    }

    if (( lpbMultiSz = (LPBYTE)LocalAlloc( LPTR, cbMaxValueDataSize )) == NULL){
	LocalFree(AfpGlobals.AfpETCMapInfo.afpetc_type_creator );
	LocalFree( lpwsValName );
	return( ERROR_NOT_ENOUGH_MEMORY );
    }

    // Read in the type/creator/comment tuples
    //
    for ( dwValueIndex 		   = 0, 
	  AfpGlobals.dwCurrentTCId = AFP_DEF_TCID + 1,
	  cbBufSize        	   = cbMaxValueDataSize, 
          cbValNameBufSize         = cbMaxValNameLen,
	  pTypeCreatorWalker    = AfpGlobals.AfpETCMapInfo.afpetc_type_creator;

	  dwValueIndex < dwNumValues;

	  dwValueIndex++, 
	  cbBufSize        	   = cbMaxValueDataSize, 
          cbValNameBufSize         = cbMaxValNameLen
	) {
	
	if ( dwRetCode = RegEnumValue(	AfpGlobals.hkeyTypeCreators,
				  	dwValueIndex,
				  	lpwsValName,
				  	&cbValNameBufSize,
				  	NULL,
				  	&dwType,
					lpbMultiSz,
					&cbBufSize
				 	))
	    break;


	// Parse the mult sz and extract info into volume info structure
 	//
	if ( dwRetCode = AfpBufParseMultiSz( 
    				        AFP_TYPECREATOR_STRUCT,
					lpbMultiSz,
					(LPBYTE)pTypeCreatorWalker
				      )) {
	    LPWSTR lpwsNames[2]; 

	    lpwsNames[0] = pTypeCreatorWalker->afptc_type;
	    lpwsNames[1] = pTypeCreatorWalker->afptc_creator;

	    AfpLogEvent( AFPLOG_INVALID_TYPE_CREATOR,
			 2,
			 lpwsNames,
			 (DWORD)AFPERR_InvalidTypeCreator,
			 EVENTLOG_WARNING_TYPE );
	    dwRetCode = NO_ERROR;
	    continue;
	}

	// Id is value name, so copy it in
        //
	wcstombs( chAnsiBuf, lpwsValName, sizeof( chAnsiBuf ) );
        pTypeCreatorWalker->afptc_id = atoi( chAnsiBuf ); 

        if ( !IsAfpTypeCreatorValid( pTypeCreatorWalker ) ) { 

	    LPWSTR lpwsNames[2]; 

	    lpwsNames[0] = pTypeCreatorWalker->afptc_type;
	    lpwsNames[1] = pTypeCreatorWalker->afptc_creator;

	    AfpLogEvent( AFPLOG_INVALID_TYPE_CREATOR,
			 2,
			 lpwsNames,
			 (DWORD)AFPERR_InvalidTypeCreator,
			 EVENTLOG_WARNING_TYPE );
	    dwRetCode = NO_ERROR;
	    continue;
	}

	// Check to see if this is a duplicate.
  	//
    	pTypeCreator = AfpBinarySearch( 
			      pTypeCreatorWalker,  
			      AfpGlobals.AfpETCMapInfo.afpetc_type_creator,
    			      AfpGlobals.AfpETCMapInfo.afpetc_num_type_creators,
			      sizeof(AFP_TYPE_CREATOR),
			      AfpBCompareTypeCreator );

	if ( pTypeCreator != NULL ) {

	    LPWSTR lpwsNames[2]; 

	    lpwsNames[0] = pTypeCreatorWalker->afptc_type;
	    lpwsNames[1] = pTypeCreatorWalker->afptc_creator;

	    AfpLogEvent( AFPLOG_INVALID_TYPE_CREATOR,
			 2,
			 lpwsNames,
			 (DWORD)AFPERR_InvalidTypeCreator,
			 EVENTLOG_WARNING_TYPE );
	    dwRetCode = NO_ERROR;
	    continue;
	}

 	// Keep the Current id the max of all ids
	//
	AfpGlobals.dwCurrentTCId = 
	( AfpGlobals.dwCurrentTCId < pTypeCreatorWalker->afptc_id ) ? 
	pTypeCreatorWalker->afptc_id  :  AfpGlobals.dwCurrentTCId;

        AfpGlobals.AfpETCMapInfo.afpetc_num_type_creators++;
	pTypeCreatorWalker++;

    }

    LocalFree( lpwsValName );
    LocalFree( lpbMultiSz );

    if ( dwRetCode ) {
	LocalFree( AfpGlobals.AfpETCMapInfo.afpetc_type_creator );
	return( dwRetCode );
    }

    // Sort the type/creator table
    //
    qsort(  AfpGlobals.AfpETCMapInfo.afpetc_type_creator,
            AfpGlobals.AfpETCMapInfo.afpetc_num_type_creators,
	    sizeof(AFP_TYPE_CREATOR), 
	    AfpBCompareTypeCreator );

    return( NO_ERROR );

}

//**
//
// Call:	AfpRegExtensionEnum
//
// Returns:	NO_ERROR	- success
//	   	ERROR_NOT_ENOUGH_MEMORY 
//		non-zero returns from registry APIs.
//
// Description: This procedure will read in extension information
//		from the registry and store it in memory in the
//		AfpGlobals.AfpETCMapInfo structure. Only fatal errors will
//		be returned. Non-fatal errors will be errorlogged.
//
DWORD
AfpRegExtensionEnum(
	VOID
)
{
DWORD 	     	   dwRetCode;
DWORD 	     	   cbMaxValNameLen;   
DWORD		   cbValNameBufSize;
DWORD 	     	   dwNumValues;	
DWORD 	     	   cbMaxValueDataSize;
DWORD	     	   dwValueIndex;
DWORD	     	   cbBufSize;
DWORD	     	   dwType;
PAFP_EXTENSION	   pExtensionWalker;
PAFP_EXTENSION     pExtension;
LPWSTR	           lpwsValName;
LPBYTE		   lpbMultiSz;
DWORD		   dwNumExtensions;
PAFP_TYPE_CREATOR  pTypeCreator;
AFP_TYPE_CREATOR   AfpTypeCreator;
DWORD		   dwNumTypeCreators;
   

    // Read in the extensions
    //
    if ( dwRetCode = AfpRegGetKeyInfo( 	AfpGlobals.hkeyExtensions,
		  			&cbMaxValNameLen,    
		  			&dwNumValues,	
		  			&cbMaxValueDataSize 
				  	))
	return( dwRetCode );

    AfpGlobals.AfpETCMapInfo.afpetc_extension = (PAFP_EXTENSION)LocalAlloc(  
					LPTR, 
					sizeof(AFP_EXTENSION) *dwNumValues );

    if ( AfpGlobals.AfpETCMapInfo.afpetc_extension == NULL ) 
	return( ERROR_NOT_ENOUGH_MEMORY );

    AfpGlobals.AfpETCMapInfo.afpetc_num_extensions = 0;
        
    if ( dwNumValues == 0 )
	return( NO_ERROR );

    // Read in the extensions
    //
    if (( lpwsValName = (LPWSTR)LocalAlloc( LPTR, cbMaxValNameLen )) == NULL) {
        LocalFree( AfpGlobals.AfpETCMapInfo.afpetc_extension ); 
	return( ERROR_NOT_ENOUGH_MEMORY );
    }

    if (( lpbMultiSz = (LPBYTE)LocalAlloc( LPTR, cbMaxValueDataSize )) == NULL){
        LocalFree( AfpGlobals.AfpETCMapInfo.afpetc_extension ); 
	LocalFree( lpwsValName );
	return( ERROR_NOT_ENOUGH_MEMORY );
    }
    
    for ( dwValueIndex 	   = 0, 
	  pExtensionWalker = AfpGlobals.AfpETCMapInfo.afpetc_extension,
	  cbBufSize        = cbMaxValueDataSize, 
          cbValNameBufSize = cbMaxValNameLen;

	  dwValueIndex < dwNumValues;

	  dwValueIndex++, 
	  cbBufSize        = cbMaxValueDataSize, 
          cbValNameBufSize = cbMaxValNameLen
	) {
	
	if ( dwRetCode = RegEnumValue(  AfpGlobals.hkeyExtensions,
				  	dwValueIndex,
				  	lpwsValName,
					&cbValNameBufSize,
				  	NULL,
				  	&dwType,
					lpbMultiSz,
					&cbBufSize
				 	)) 
	    break;

	// Parse the mult sz and extract info into volume info structure
 	//
	if ( dwRetCode = AfpBufParseMultiSz( 
					AFP_EXTENSION_STRUCT,
					lpbMultiSz,
				  	(LPBYTE)pExtensionWalker
				      )) {
	    LPWSTR lpwsName = pExtensionWalker->afpe_extension;
	    AfpLogEvent( AFPLOG_INVALID_EXTENSION,
			 1,
			 &lpwsName,
			 (DWORD)AFPERR_InvalidExtension,
			 EVENTLOG_WARNING_TYPE );
	    dwRetCode = NO_ERROR;
	    continue;
	}

	// Value name is extension, so copy it in
	//
	STRCPY( pExtensionWalker->afpe_extension, lpwsValName );
	
        if ( !IsAfpExtensionValid( pExtensionWalker ) ) {
	    LPWSTR lpwsName = pExtensionWalker->afpe_extension;
	    AfpLogEvent( AFPLOG_INVALID_EXTENSION,
			 1,
			 &lpwsName,
			 (DWORD)AFPERR_InvalidExtension,
			 EVENTLOG_WARNING_TYPE );
	    dwRetCode = NO_ERROR;
	    continue;
        }

 	// Check to see if this extension is associated with a vaid type/creator
	// pair
 	//
	dwNumTypeCreators = AfpGlobals.AfpETCMapInfo.afpetc_num_type_creators;
	AfpTypeCreator.afptc_id = pExtensionWalker->afpe_tcid;

    	pTypeCreator = _lfind( &AfpTypeCreator,  
			      AfpGlobals.AfpETCMapInfo.afpetc_type_creator,
    			      (unsigned int *)&dwNumTypeCreators,
			      sizeof(AFP_TYPE_CREATOR),
			      AfpLCompareTypeCreator );

	if ( pTypeCreator == NULL ) {
	    LPWSTR lpwsName = pExtensionWalker->afpe_extension;
	    AfpLogEvent( AFPLOG_INVALID_EXTENSION,
			 1,
			 &lpwsName,
			 (DWORD)AFPERR_InvalidExtension,
			 EVENTLOG_WARNING_TYPE );
	    dwRetCode = NO_ERROR;
	    continue;
	}

 	// Check to see if this extension is a duplicate
 	//
	dwNumExtensions = AfpGlobals.AfpETCMapInfo.afpetc_num_extensions; 

    	pExtension = _lfind( pExtensionWalker,  
			    AfpGlobals.AfpETCMapInfo.afpetc_extension,
    			    (unsigned int *)&dwNumExtensions,
			    sizeof(AFP_EXTENSION),
			    AfpLCompareExtension );

	if ( pExtension != NULL ) {
	    LPWSTR lpwsName = pExtensionWalker->afpe_extension;
	    AfpLogEvent( AFPLOG_INVALID_EXTENSION,
			 1,
			 &lpwsName,
			 (DWORD)AFPERR_DuplicateExtension,
			 EVENTLOG_WARNING_TYPE );
	    dwRetCode = NO_ERROR;
	    continue;
	}

        AfpGlobals.AfpETCMapInfo.afpetc_num_extensions++;
	pExtensionWalker++;

    }

    LocalFree( lpwsValName );
    LocalFree( lpbMultiSz );

    if ( dwRetCode ) {
        LocalFree( AfpGlobals.AfpETCMapInfo.afpetc_extension );
	return( dwRetCode );
    }

    // Sort the extension table
    //
    qsort(  AfpGlobals.AfpETCMapInfo.afpetc_extension,
            AfpGlobals.AfpETCMapInfo.afpetc_num_extensions,
	    sizeof(AFP_EXTENSION), 
	    AfpBCompareExtension );

    return( NO_ERROR );
}

//**
//
// Call:	AfpRegTypeCreatorAdd 
//
// Returns:	NO_ERROR	- success
//		non-zero returns from the registry
//
// Description: This routine will add a tupple to the registry. The value
//		name for the tupple will be id of the type creator.
//
DWORD
AfpRegTypeCreatorAdd( 
	IN PAFP_TYPE_CREATOR     pAfpTypeCreator
) 
{
DWORD			cbMultiSzSize;
LPBYTE  		lpbMultiSz;
DWORD   		dwRetCode;
WCHAR			wchValueName[10];
CHAR			chValueName[10];

    _itoa( pAfpTypeCreator->afptc_id, chValueName, 10 );
    mbstowcs( wchValueName, chValueName, sizeof(wchValueName)/sizeof(WCHAR) );
			    
    if ( dwRetCode = AfpBufMakeMultiSz( AFP_TYPECREATOR_STRUCT,
				   	(LPBYTE)pAfpTypeCreator,
				   	&lpbMultiSz,
				   	&cbMultiSzSize ))
	return( dwRetCode );

    dwRetCode =  RegSetValueEx( AfpGlobals.hkeyTypeCreators,
				wchValueName,
				0,
				REG_MULTI_SZ,
				lpbMultiSz,
				cbMultiSzSize
				);

    LocalFree( lpbMultiSz );

    return( dwRetCode );
	
}

//**
//
// Call:	AfpRegTypeCreatorSetInfo
//
// Returns:	NO_ERROR	- success
//		non-zero returns from the registry
//
// Description: Will change the value of a particular tupple.
//
DWORD
AfpRegTypeCreatorSetInfo( 
	IN PAFP_TYPE_CREATOR     pAfpTypeCreator
) 
{
    return( AfpRegTypeCreatorAdd( pAfpTypeCreator ) );
}

//**
//
// Call:	AfpRegTypeCreatorDelete 
//
// Returns:	NO_ERROR	- success
//		non-zero returns from the registry apis
//
// Description:	Will delete a type creator entry from the registry key.
//
DWORD
AfpRegTypeCreatorDelete( 
	IN PAFP_TYPE_CREATOR     pAfpTypeCreator
) 
{
WCHAR	wchValueName[10];
CHAR	chValueName[10];

    _itoa( pAfpTypeCreator->afptc_id, chValueName, 10 );
    mbstowcs( wchValueName, chValueName, sizeof(wchValueName)/sizeof(WCHAR) );

    return( RegDeleteValue( AfpGlobals.hkeyTypeCreators, wchValueName ));
}

//**
//
// Call:	AfpRegExtensionAdd 
//
// Returns:	NO_ERROR	- success
//		non-zero returns from the registry
//
// Description: This routine will add a tupple to the registry. The value
//		name for the tupple will be the concatenation of the
//		type, creator and the extension. This is done to keep the
//		value name unique so that it may be accessed directly.
//
DWORD
AfpRegExtensionAdd( 
	IN PAFP_EXTENSION     pAfpExtension
) 
{
DWORD			cbMultiSzSize;
LPBYTE  		lpbMultiSz;
DWORD   		dwRetCode;
			    
    if ( dwRetCode = AfpBufMakeMultiSz( AFP_EXTENSION_STRUCT,
				   	(LPBYTE)pAfpExtension,
				   	&lpbMultiSz,
				   	&cbMultiSzSize ))
	return( dwRetCode );

    dwRetCode =  RegSetValueEx( AfpGlobals.hkeyExtensions,
				pAfpExtension->afpe_extension,
				0,
				REG_MULTI_SZ,
				lpbMultiSz,
				cbMultiSzSize );
    LocalFree( lpbMultiSz );

    return( dwRetCode );
}

//**
//
// Call:	AfpRegExtensionSetInfo
//
// Returns:	NO_ERROR	- success
//		non-zero returns from the registry
//
// Description: Will change the value of a particular tupple.
//
DWORD
AfpRegExtensionSetInfo( 
	IN PAFP_EXTENSION     pAfpExtension
) 
{
    // Make a Mult-sz of this and add it to the registry
    //
    return( AfpRegExtensionAdd( pAfpExtension ) );
}

//**
//
// Call:	AfpRegExtensionDelete 
//
// Returns:	NO_ERROR	- success
//		non-zero returns from the registry
//
// Description: Deletes an extension from the registry.
//
DWORD
AfpRegExtensionDelete( 
	IN PAFP_EXTENSION     pAfpExtension
) 
{
    return( RegDeleteValue( AfpGlobals.hkeyExtensions, 
			    pAfpExtension->afpe_extension ));
}

//**
//
// Call:	AfpRegGetKeyInfo
//
// Returns:	NO_ERROR		- success
//		non-zero returns from registry API's
//
// Description: Will retrieve the number of values in this key and the
//		maximum size of the value data. It will also return the
//		length IN BYTES of the largest value name (including the
//		NULL character ).
//
DWORD
AfpRegGetKeyInfo( 
	IN  HKEY    hKey,
	OUT LPDWORD lpdwMaxValNameLen,    // Longest valuename in this key
	OUT LPDWORD lpdwNumValues,	  // Number of values in this key
	OUT LPDWORD lpdwMaxValueDataSize  // Max. size of value data.
)
{
WCHAR		wchClassName[256];// This should be large enough to hold the
				  // class name for this key.
DWORD		dwClassSize = sizeof( wchClassName ) / sizeof( wchClassName[0] );
DWORD 		dwNumSubKeys;
DWORD   	dwMaxSubKeySize;
DWORD		dwMaxClassSize;
DWORD		dwSecDescLen;
FILETIME   	LastWrite;
DWORD		dwRetCode;

    dwRetCode = RegQueryInfoKey(hKey,
				wchClassName,
				&dwClassSize,
				NULL,
				&dwNumSubKeys,
				&dwMaxSubKeySize,
				&dwMaxClassSize,
				lpdwNumValues,
				lpdwMaxValNameLen,
				lpdwMaxValueDataSize,
				&dwSecDescLen,
				&LastWrite
				);

    if ( dwRetCode == NO_ERROR ) {

	if ( *lpdwMaxValNameLen > 0 )
	    *lpdwMaxValNameLen = (*lpdwMaxValNameLen + 1) * sizeof(WCHAR);
	
    }

    return( dwRetCode );
}

//**
//
// Call:	AfpRegServerGetCodePagePath
//
// Returns:	NO_ERROR
//	    	ERROR_PATH_NOT_FOUND
//		other errors returned from registry APIs
//
// Description: Will get the path to the Mac codepage and store it in
//		AfpGlobals.wchCodePagePath. 
//		It will first get the system directory. It will then get
//		the codepage filename and concatenate it to the system 
//		directory.
//
DWORD
AfpRegServerGetCodePagePath( 
	VOID
)
{
DWORD 	dwRetCode;
HKEY	hkeyCodepagePath;
DWORD   dwType;
DWORD   dwBufSize;
WCHAR   wchCodepageNum[20];
WCHAR   wchCodePageFile[MAX_PATH];

    // Open the key
    //
    if ( dwRetCode = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
			           AFP_KEYPATH_CODEPAGE,
				   0,
				   KEY_QUERY_VALUE,
			           &hkeyCodepagePath
			   	  )) 
	return( dwRetCode );


    // This is not a loop
    //
    do { 

	// First get the system directory path
	//
	if ( !GetSystemDirectory( AfpGlobals.wchCodePagePath,
				  sizeof( AfpGlobals.wchCodePagePath ) / sizeof( AfpGlobals.wchCodePagePath[0] ))) {
	    dwRetCode = ERROR_PATH_NOT_FOUND;
	    break;
	}

	// Get the Code page number value for the Mac
 	//
	dwBufSize = sizeof( wchCodepageNum );
	if ( dwRetCode = RegQueryValueEx( hkeyCodepagePath,
	  			          AFPREG_VALNAME_CODEPAGE,
				          NULL,
				          &dwType,
				          (LPBYTE)wchCodepageNum,
				          &dwBufSize ))
	    break;

	// Finally get the codepage filename
	//
	dwBufSize = sizeof( wchCodePageFile );
	if ( dwRetCode = RegQueryValueEx( hkeyCodepagePath,
	  			          wchCodepageNum, 
				          NULL,
				          &dwType,
					  (LPBYTE)wchCodePageFile,
				          &dwBufSize ))
	    break;

	// Concatenate the filename to the system directory path
	//
	wcscat( AfpGlobals.wchCodePagePath, (LPWSTR)TEXT("\\") );
	wcscat( AfpGlobals.wchCodePagePath, wchCodePageFile );

    } while( FALSE );

    // Close the key
    //
    RegCloseKey( hkeyCodepagePath );

    return( dwRetCode );
    
}
//**
//
// Call:	AfpRegServerSetInfo
//
// Returns:	NO_ERROR	- success
//		non-zero returns from registry APIs.
//
// Description:	This procedure will set specific server parameters in the 
//		registy depending on what bit is set the the dwParmnum
//		parameter. The input will be a AFP_SERVER_INFO self relative
//		structure that contains the parameter to set.
//
DWORD
AfpRegServerSetInfo( 
	IN PAFP_SERVER_INFO pServerInfo, 
	IN DWORD 	    dwParmnum 
)
{
DWORD	dwRetCode;
LPWSTR  lpwsPtr;


    // Set the server name
    //
    if ( dwParmnum & AFP_SERVER_PARMNUM_NAME ) {

	DWORD Length = 0;

	lpwsPtr = pServerInfo->afpsrv_name;

	if ( lpwsPtr != NULL ) {

	    OFFSET_TO_POINTER( lpwsPtr, pServerInfo );
	    Length = STRLEN(lpwsPtr)+1;
	}

	if ( dwRetCode=RegSetValueEx(
				AfpGlobals.hkeyServerParams,
    				AFPREG_VALNAME_SVRNAME, 
				0,
				REG_SZ,
				(LPBYTE)lpwsPtr,
				Length * sizeof(WCHAR)))
	    return( dwRetCode );
    }

    // Set Max sessions
    //
    if ( dwParmnum & AFP_SERVER_PARMNUM_MAX_SESSIONS ) {

	if ( dwRetCode=RegSetValueEx(
				AfpGlobals.hkeyServerParams,
				AFPREG_VALNAME_MAXSESSIONS,
				0,
				REG_DWORD,
				(LPBYTE)&(pServerInfo->afpsrv_max_sessions),
				sizeof( DWORD )))
	    return( dwRetCode );
    }

    // Set server options
    //
    if ( dwParmnum & AFP_SERVER_PARMNUM_OPTIONS	) {

	if ( dwRetCode = RegSetValueEx(
				AfpGlobals.hkeyServerParams,
				AFPREG_VALNAME_SRVOPTIONS,
				0,
				REG_DWORD,
				(LPBYTE)&(pServerInfo->afpsrv_options),
				sizeof( DWORD )
				))
	    return( dwRetCode );
    }

    // Set Login message
    //
    if ( dwParmnum & AFP_SERVER_PARMNUM_LOGINMSG ) {

	DWORD Length = 0;

	lpwsPtr = pServerInfo->afpsrv_login_msg;

	if ( lpwsPtr != NULL ) {

	    OFFSET_TO_POINTER( lpwsPtr, pServerInfo );
	    Length = STRLEN(lpwsPtr)+1;
	}

	if ( dwRetCode = RegSetValueEx( 
				AfpGlobals.hkeyServerParams,
				AFPREG_VALNAME_LOGINMSG,
				0,
				REG_SZ,
				(LPBYTE)lpwsPtr,
				 Length * sizeof(WCHAR)))
	    return( dwRetCode );
    }
   
    return( NO_ERROR );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\service\server\server.c ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.	   **/
/********************************************************************/

//***
//
// Filename:	server.c
//
// Description: This module contains support routines for the server
//		category API's for the AFP server service. These routines
//		are called by the RPC runtime.
//
// History:
//		December 15,1992.	NarenG	   Created original version.
//
#include "afpsvcp.h"

//**
//
// Call:	AfpAdminrServerGetInfo
//
// Returns:	NO_ERROR
//		ERROR_ACCESS_DENIED
//		non-zero retunrs from AfpServerIOCtrlGetInfo
//
// Description: This routine communicates with the AFP FSD to implement
//		the AfpAdminServerGetInfo function.
//
DWORD
AfpAdminrServerGetInfo(
	IN  AFP_SERVER_HANDLE    hServer,
    	OUT PAFP_SERVER_INFO*    ppAfpServerInfo
)
{
AFP_REQUEST_PACKET  AfpSrp;
DWORD		    dwRetCode=0;
DWORD		    dwAccessStatus=0;


    // Check if caller has access
    //
    if ( dwRetCode = AfpSecObjAccessCheck( AFPSVC_ALL_ACCESS, &dwAccessStatus))
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrServerGetInfo, AfpSecObjAccessCheck failed %ld\n",dwRetCode));
	    AfpLogEvent( AFPLOG_CANT_CHECK_ACCESS, 0, NULL,
		     dwRetCode, EVENTLOG_ERROR_TYPE );
        return( ERROR_ACCESS_DENIED );
    }

    if ( dwAccessStatus )
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrServerGetInfo, AfpSecObjAccessCheck returned %ld\n",dwRetCode));
        return( ERROR_ACCESS_DENIED );
    }

    // Make IOCTL to get info
    //
    AfpSrp.dwRequestCode 		= OP_SERVER_GET_INFO;
    AfpSrp.dwApiType     		= AFP_API_TYPE_GETINFO;
    AfpSrp.Type.GetInfo.pInputBuf	= NULL;
    AfpSrp.Type.GetInfo.cbInputBufSize  = 0;

    dwRetCode = AfpServerIOCtrlGetInfo( &AfpSrp );

    if ( dwRetCode != ERROR_MORE_DATA && dwRetCode != NO_ERROR )
	return( dwRetCode );

    *ppAfpServerInfo = (PAFP_SERVER_INFO)(AfpSrp.Type.GetInfo.pOutputBuf);

    // Convert all offsets to pointers
    //
    AfpBufOffsetToPointer((LPBYTE)*ppAfpServerInfo,1,AFP_SERVER_STRUCT);

    return( dwRetCode );
}

//**
//
// Call:	AfpAdminrServerSetInfo
//
// Returns:	NO_ERROR
//		ERROR_ACCESS_DENIED
//		non-zero retunrs from AfpServerIOCtrl
//
// Description: This routine communicates with the AFP FSD to implement
//		the AfpAdminServerSetInfo function.
//
DWORD
AfpAdminrServerSetInfo(
	IN  AFP_SERVER_HANDLE    hServer,
    	IN  PAFP_SERVER_INFO     pAfpServerInfo,
	IN  DWORD		 dwParmNum
)
{
AFP_REQUEST_PACKET  AfpSrp;
PAFP_SERVER_INFO    pAfpServerInfoSR;
DWORD 		    cbAfpServerInfoSRSize;
DWORD		    dwRetCode=0;
DWORD		    dwAccessStatus=0;
LPWSTR		    lpwsServerName = NULL;



    //
    // if this is a "notification" that Guest account changed (disable to enable
    // or vice versa), don't bother checking access for caller: see if guest
    // account was indeed flipped, and let afp server know.
    // NOTICE we don't do (dwParmNum & AFP_SERVER_GUEST_ACCT_NOTIFY) here, as an
    // extra precaution.
    //
    if (dwParmNum == AFP_SERVER_GUEST_ACCT_NOTIFY)
    {
        if (pAfpServerInfo->afpsrv_options ^
                (AfpGlobals.dwServerOptions & AFP_SRVROPT_GUESTLOGONALLOWED))
        {
            AfpGlobals.dwServerOptions ^= AFP_SRVROPT_GUESTLOGONALLOWED;
        }
        else
        {
            AFP_PRINT(( "AFPSVC_server: no change in GuestAcct, nothing done\n"));	
            return(NO_ERROR);
        }
    }

    // Check if caller has access
    //
    if ( dwRetCode = AfpSecObjAccessCheck( AFPSVC_ALL_ACCESS, &dwAccessStatus))
    {
        AFP_PRINT(( "AFPSVC_server: Sorry, accessCheck failed! %ld\n",dwRetCode));	
	    AfpLogEvent( AFPLOG_CANT_CHECK_ACCESS, 0, NULL,
                     dwRetCode, EVENTLOG_ERROR_TYPE );
        return( ERROR_ACCESS_DENIED );
    }

    if ( dwAccessStatus )
    {
        AFP_PRINT(("AFPSVC_server: Sorry, accessCheck failed at 2! %ld\n",dwAccessStatus));
        return( ERROR_ACCESS_DENIED );
    }

    // Check to see if the client wants to set the server name as well
    //
    if ( dwParmNum & AFP_SERVER_PARMNUM_NAME )
    {
	    lpwsServerName = pAfpServerInfo->afpsrv_name;
	    pAfpServerInfo->afpsrv_name = NULL;
	    dwParmNum &= (~AFP_SERVER_PARMNUM_NAME);
    }

    // Make buffer self relative.
    //
    if ( dwRetCode = AfpBufMakeFSDRequest(  (LPBYTE)pAfpServerInfo,
					    sizeof(SETINFOREQPKT),
					    AFP_SERVER_STRUCT,
					    (LPBYTE*)&pAfpServerInfoSR,
					    &cbAfpServerInfoSRSize ) )
    {
	    return( dwRetCode );
    }

    // Make IOCTL to set info
    //
    AfpSrp.dwRequestCode 		= OP_SERVER_SET_INFO;
    AfpSrp.dwApiType     		= AFP_API_TYPE_SETINFO;
    AfpSrp.Type.SetInfo.pInputBuf     	= pAfpServerInfoSR;
    AfpSrp.Type.SetInfo.cbInputBufSize  = cbAfpServerInfoSRSize;
    AfpSrp.Type.SetInfo.dwParmNum       = dwParmNum;

    dwRetCode = AfpServerIOCtrl( &AfpSrp );

    if ( dwRetCode == NO_ERROR )
    {

   	    LPBYTE pServerInfo;

        // guest-account notification? nothing to write to registry, done here
        if (dwParmNum == AFP_SERVER_GUEST_ACCT_NOTIFY)
        {
            LocalFree( pAfpServerInfoSR );
            return( dwRetCode );
        }

	    // If the client wants to set the servername as well
	    //
	    if ( lpwsServerName != NULL ) {

	        LocalFree( pAfpServerInfoSR );

    	    // Make another self relative buffer with the server name.
    	    //
	        pAfpServerInfo->afpsrv_name = lpwsServerName;

	        dwParmNum |= AFP_SERVER_PARMNUM_NAME;
	
    	    if ( dwRetCode = AfpBufMakeFSDRequest(
			    	    (LPBYTE)pAfpServerInfo,
				        sizeof(SETINFOREQPKT),
				        AFP_SERVER_STRUCT,
    				    (LPBYTE*)&pAfpServerInfoSR,
	    			    &cbAfpServerInfoSRSize ) )
            {
		        return( dwRetCode );
            }
            AfpSrp.dwRequestCode 		= OP_SERVER_SET_INFO;
            AfpSrp.dwApiType     		= AFP_API_TYPE_SETINFO;
            AfpSrp.Type.SetInfo.pInputBuf     	= pAfpServerInfoSR;
            AfpSrp.Type.SetInfo.cbInputBufSize  = cbAfpServerInfoSRSize;
            AfpSrp.Type.SetInfo.dwParmNum       = dwParmNum;

            dwRetCode = AfpServerIOCtrl( &AfpSrp );
	    }

   	    pServerInfo = ((LPBYTE)pAfpServerInfoSR)+sizeof(SETINFOREQPKT);

        if (dwRetCode == NO_ERROR)
        {
 	        dwRetCode = AfpRegServerSetInfo( (PAFP_SERVER_INFO)pServerInfo,
		    		         dwParmNum );
        }
        else
        {
            AFP_PRINT(("AFPSVC_server: AfpServerIOCtrl failed %lx\n",dwRetCode));
        }
    }


    LocalFree( pAfpServerInfoSR );

    return( dwRetCode );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\service\server\session.c ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.	   **/
/********************************************************************/

//***
//
// Filename:	session.c
//
// Description: This module contains support routines for the session
//		category API's for the AFP server service. These routines
//		will be called by the RPC runtime.
//
// History:
//		June 21,1992.	NarenG		Created original version.
//
#include "afpsvcp.h"


//**
//
// Call:	AfpAdminrSessionEnum
//
// Returns:	NO_ERROR
//		ERROR_ACCESS_DENIED
//		non-zero returns from AfpServerIOCtrlGetInfo
//
// Description: This routine communicates with the AFP FSD to implement
//		the AfpAdminSessionEnum function.
//
DWORD
AfpAdminrSessionEnum(
	IN     AFP_SERVER_HANDLE 	hServer,
	IN OUT PSESSION_INFO_CONTAINER  pInfoStruct,
	IN     DWORD 		  	dwPreferedMaximumLength,
	OUT    LPDWORD 		  	lpdwTotalEntries,
	IN OUT LPDWORD 		  	lpdwResumeHandle
)
{
AFP_REQUEST_PACKET AfpSrp;
DWORD		   dwRetCode=0;
DWORD		   dwAccessStatus=0;

    AFP_PRINT( ( "AFPSVC_session: Received enum request\n"));	

    // Check if caller has access
    //
    if ( dwRetCode = AfpSecObjAccessCheck( AFPSVC_ALL_ACCESS, &dwAccessStatus))
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrSessionEnum, AfpSecObjAccessCheck failed %ld\n",dwRetCode));
	    AfpLogEvent( AFPLOG_CANT_CHECK_ACCESS, 0, NULL,
		     dwRetCode, EVENTLOG_ERROR_TYPE );
        return( ERROR_ACCESS_DENIED );
    }

    if ( dwAccessStatus )
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrSessionEnum, AfpSecObjAccessCheck returned %ld\n",dwAccessStatus));
        return( ERROR_ACCESS_DENIED );
    }

    // Set up request packet and make IOCTL to the FSD
    //
    AfpSrp.dwRequestCode 		= OP_SESSION_ENUM;
    AfpSrp.dwApiType     		= AFP_API_TYPE_ENUM;
    AfpSrp.Type.Enum.cbOutputBufSize    = dwPreferedMaximumLength;

    if ( lpdwResumeHandle )
     	AfpSrp.Type.Enum.EnumRequestPkt.erqp_Index = *lpdwResumeHandle;
    else
     	AfpSrp.Type.Enum.EnumRequestPkt.erqp_Index = 0;

    dwRetCode = AfpServerIOCtrlGetInfo( &AfpSrp );

    if ( dwRetCode != ERROR_MORE_DATA && dwRetCode != NO_ERROR )
	return( dwRetCode );

    *lpdwTotalEntries          = AfpSrp.Type.Enum.dwTotalAvail;
    pInfoStruct->pBuffer     = (PAFP_SESSION_INFO)(AfpSrp.Type.Enum.pOutputBuf);
    pInfoStruct->dwEntriesRead = AfpSrp.Type.Enum.dwEntriesRead;

    if ( lpdwResumeHandle )
    	*lpdwResumeHandle = AfpSrp.Type.Enum.EnumRequestPkt.erqp_Index;

    // Convert all offsets to pointers
    //
    AfpBufOffsetToPointer( (LPBYTE)(pInfoStruct->pBuffer),
			   pInfoStruct->dwEntriesRead,
			   AFP_SESSION_STRUCT );

    return( dwRetCode );
}

//**
//
// Call:	AfpAdminrSessionClose
//
// Returns:	NO_ERROR
//		ERROR_ACCESS_DENIED
//		non-zero returns from AfpServerIOCtrl
//
// Description: This routine communicates with the AFP FSD to implement
//		the AfpAdminSessionClose function.
//
DWORD
AfpAdminrSessionClose( IN AFP_SERVER_HANDLE 	hServer,
		       IN DWORD 		dwSessionId
)
{
AFP_REQUEST_PACKET AfpSrp;
DWORD		   dwAccessStatus=0;
AFP_SESSION_INFO   AfpSessionInfo;
DWORD	           dwRetCode=0;

    // Check if caller has access
    //
    if ( dwRetCode = AfpSecObjAccessCheck( AFPSVC_ALL_ACCESS, &dwAccessStatus))
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrSessionClose, AfpSecObjAccessCheck failed %ld\n",dwRetCode));
	    AfpLogEvent( AFPLOG_CANT_CHECK_ACCESS, 0, NULL,
		     dwRetCode, EVENTLOG_ERROR_TYPE );
        return( ERROR_ACCESS_DENIED );
    }

    if ( dwAccessStatus )
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrSessionClose, AfpSecObjAccessCheck returned %ld\n",dwAccessStatus));
        return( ERROR_ACCESS_DENIED );
    }

    // The FSD expects an AFP_SESSION_INFO structure with only the id field
    // filled in.
    //
    AfpSessionInfo.afpsess_id = dwSessionId;

    // IOCTL the FSD to close the session
    //
    AfpSrp.dwRequestCode 		= OP_SESSION_CLOSE;
    AfpSrp.dwApiType     		= AFP_API_TYPE_DELETE;
    AfpSrp.Type.Delete.pInputBuf     	= &AfpSessionInfo;
    AfpSrp.Type.Delete.cbInputBufSize   = sizeof(AFP_SESSION_INFO);

    return ( AfpServerIOCtrl( &AfpSrp ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\service\server\security.c ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.	   **/
/********************************************************************/

//***
//
// Filename:	security.c
//
// Description: This module contains code that will create and delete the
//		security object. It will also contain access checking calls.
//
// History:
//	June 21,1992.	NarenG		Created original version.
//
// NOTE: ??? The lpdwAccessStatus parameter for AccessCheckAndAuditAlarm
//	     returns junk. ???
//
#include "afpsvcp.h"

typedef struct _AFP_SECURITY_OBJECT {

    LPWSTR		  lpwsObjectName;
    LPWSTR		  lpwsObjectType;
    GENERIC_MAPPING	  GenericMapping;
    PSECURITY_DESCRIPTOR  pSecurityDescriptor;

} AFP_SECURITY_OBJECT, PAFP_SECURITY_OBJECT;

static AFP_SECURITY_OBJECT	AfpSecurityObject;

#define AFPSVC_SECURITY_OBJECT		TEXT("AfpSvcAdminApi");
#define AFPSVC_SECURITY_OBJECT_TYPE	TEXT("Security");



//**
//
// Call:	AfpSecObjCreate
//
// Returns:	NO_ERROR	- success
//		ERROR_NOT_ENOUGH_MEMORY
//		non-zero returns from security functions
//
// Description: This procedure will set up the security object that will
//		be used to check to see if an RPC client is an administrator
//		for the local machine.
//
DWORD
AfpSecObjCreate(
	VOID
)
{
PSID			 pAdminSid 	  = NULL;
PSID			 pLocalSystemSid  = NULL;
PSID 			 pServerOpSid     = NULL;
PSID             pPwrUserSid = NULL;
PACL			 pDacl		  = NULL;
HANDLE			 hProcessToken    = NULL;
PULONG			 pSubAuthority;
SID_IDENTIFIER_AUTHORITY SidIdentifierNtAuth = SECURITY_NT_AUTHORITY;
SECURITY_DESCRIPTOR	 SecurityDescriptor;
DWORD			 dwRetCode;
DWORD			 cbDaclSize;


    // Set up security object
    //
    AfpSecurityObject.lpwsObjectName = AFPSVC_SECURITY_OBJECT;
    AfpSecurityObject.lpwsObjectType = AFPSVC_SECURITY_OBJECT_TYPE;

    // Generic mapping structure for the security object
    // All generic access types are allowed API access.
    //
    AfpSecurityObject.GenericMapping.GenericRead =  STANDARD_RIGHTS_READ |
	    					    AFPSVC_ALL_ACCESS;

    AfpSecurityObject.GenericMapping.GenericWrite = STANDARD_RIGHTS_WRITE |
	    					    AFPSVC_ALL_ACCESS;

    AfpSecurityObject.GenericMapping.GenericExecute =
						    STANDARD_RIGHTS_EXECUTE |
						    AFPSVC_ALL_ACCESS;

    AfpSecurityObject.GenericMapping.GenericAll =   AFPSVC_ALL_ACCESS;

    // The do - while(FALSE) statement is used so that the break statement
    // maybe used insted of the goto statement, to execute a clean up and
    // and exit action.
    //
    do {

	    dwRetCode = NO_ERROR;

    	// Set up the SID for the admins that will be allowed to have
    	// access. This SID will have 2 sub-authorities
    	// SECURITY_BUILTIN_DOMAIN_RID and DOMAIN_ALIAS_ADMIN_RID.
    	//
    	pAdminSid = (PSID)LocalAlloc( LPTR, GetSidLengthRequired( 2 ) );

    	if ( pAdminSid == NULL ) {
	    dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
	    break;
	}

    	if ( !InitializeSid( pAdminSid, &SidIdentifierNtAuth, 2 ) )
        {
	        dwRetCode = GetLastError();
	        break;
	    }

    	// Set the sub-authorities
    	//
    	pSubAuthority  = GetSidSubAuthority( pAdminSid, 0 );
    	*pSubAuthority = SECURITY_BUILTIN_DOMAIN_RID;

    	pSubAuthority  = GetSidSubAuthority( pAdminSid, 1 );
    	*pSubAuthority = DOMAIN_ALIAS_RID_ADMINS;

	    // Create the server operators SID
	    //
    	pServerOpSid = (PSID)LocalAlloc( LPTR, GetSidLengthRequired( 2 ) );

    	if ( pServerOpSid == NULL )
        {
	        dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
	        break;
	    }

    	if ( !InitializeSid( pServerOpSid, &SidIdentifierNtAuth, 2 ) )
        {
	        dwRetCode = GetLastError();
	        break;
	    }

    	// Set the sub-authorities
    	//
    	pSubAuthority  = GetSidSubAuthority( pServerOpSid, 0 );
    	*pSubAuthority = SECURITY_BUILTIN_DOMAIN_RID;

    	pSubAuthority  = GetSidSubAuthority( pServerOpSid, 1 );
    	*pSubAuthority = DOMAIN_ALIAS_RID_SYSTEM_OPS;

        //
	    // Create the Power user operators SID
	    //
    	pPwrUserSid = (PSID)LocalAlloc( LPTR, GetSidLengthRequired( 2 ) );

    	if ( pPwrUserSid == NULL )
        {
	        dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
	        break;
	    }

    	if ( !InitializeSid( pPwrUserSid, &SidIdentifierNtAuth, 2 ) )
        {
	        dwRetCode = GetLastError();
	        break;
	    }

    	// Set the sub-authorities
    	//
    	pSubAuthority  = GetSidSubAuthority( pPwrUserSid, 0 );
    	*pSubAuthority = SECURITY_BUILTIN_DOMAIN_RID;

    	pSubAuthority  = GetSidSubAuthority( pPwrUserSid, 1 );
    	*pSubAuthority = DOMAIN_ALIAS_RID_POWER_USERS;

    	// Create the LocalSystemSid which will be the owner and the primary
    	// group of the security object.
    	//
    	pLocalSystemSid = (PSID)LocalAlloc( LPTR, GetSidLengthRequired( 1 ) );

    	if ( pLocalSystemSid == NULL )
        {
	        dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
	        break;
	    }

    	if ( !InitializeSid( pLocalSystemSid, &SidIdentifierNtAuth, 1 ) )
        {
	        dwRetCode = GetLastError();
	        break;
	    }

    	// Set the sub-authorities
    	//
    	pSubAuthority = GetSidSubAuthority( pLocalSystemSid, 0 );
    	*pSubAuthority = SECURITY_LOCAL_SYSTEM_RID;

    	// Set up the DACL that will allow admins with the above SID all access
    	// It should be large enough to hold all ACEs.
    	//
    	cbDaclSize = sizeof(ACL) + ( sizeof(ACCESS_ALLOWED_ACE) * 2 ) +
		     GetLengthSid(pAdminSid) + GetLengthSid(pServerOpSid) + GetLengthSid(pPwrUserSid);
		
    	if ( (pDacl = (PACL)LocalAlloc( LPTR, cbDaclSize ) ) == NULL )
        {
	        dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
	        break;
	    }
	
        if ( !InitializeAcl( pDacl,  cbDaclSize, ACL_REVISION2 ) )
        {
	        dwRetCode = GetLastError();
	        break;
 	    }

        // Add the ACE to the DACL
    	//
    	if ( !AddAccessAllowedAce( pDacl,
			           ACL_REVISION2,
			           AFPSVC_ALL_ACCESS, // What the admin can do
			           pAdminSid ))
        {
	        dwRetCode = GetLastError();
	        break;
	    }

    	if ( !AddAccessAllowedAce( pDacl,
			           ACL_REVISION2,
			           AFPSVC_ALL_ACCESS, // What the admin can do
			           pServerOpSid ))
        {
	        dwRetCode = GetLastError();
	        break;
	    }

    	if ( !AddAccessAllowedAce( pDacl,
			           ACL_REVISION2,
			           AFPSVC_ALL_ACCESS, // What the power user can do
			           pPwrUserSid ))
        {
	        dwRetCode = GetLastError();
	        break;
	    }

        // Create the security descriptor an put the DACL in it.
    	//
    	if ( !InitializeSecurityDescriptor( &SecurityDescriptor, 1 ))
        {
	        dwRetCode = GetLastError();
	        break;
    	}

    	if ( !SetSecurityDescriptorDacl( &SecurityDescriptor,
					 TRUE,
					 pDacl,
					 FALSE ) )
        {
	        dwRetCode = GetLastError();
	        break;
	    }
	

	    // Set owner for the descriptor
   	    //
    	if ( !SetSecurityDescriptorOwner( &SecurityDescriptor,
					  pLocalSystemSid,
					  FALSE ) )
        {
	        dwRetCode = GetLastError();
	        break;
	    }


	    // Set group for the descriptor
   	    //
    	if ( !SetSecurityDescriptorGroup( &SecurityDescriptor,
					  pLocalSystemSid,
					  FALSE ) )
        {
	        dwRetCode = GetLastError();
	        break;
	    }

    	// Get token for the current process
    	//
    	if ( !OpenProcessToken( GetCurrentProcess(),
				TOKEN_QUERY,
				&hProcessToken ))
        {
	        dwRetCode = GetLastError();
	        break;
    	}

    	// Create a security object. This is really just a security descriptor
    	// is self-relative form. This procedure will allocate memory for this
    	// security descriptor and copy all in the information passed in. This
    	// allows us to free all dynamic memory allocated.
    	//
    	if ( !CreatePrivateObjectSecurity(
				      NULL,
				      &SecurityDescriptor,
				      &(AfpSecurityObject.pSecurityDescriptor),
				      FALSE,
				      hProcessToken,
    				      &(AfpSecurityObject.GenericMapping)
				     ))
	     dwRetCode = GetLastError();

    } while( FALSE );

	
    // Free up the dynamic memory
    //
    if ( pLocalSystemSid != NULL )
    	LocalFree( pLocalSystemSid );

    if ( pAdminSid != NULL )
    	LocalFree( pAdminSid );

    if ( pServerOpSid != NULL )
    	LocalFree( pServerOpSid );

    if ( pPwrUserSid != NULL )
    	LocalFree( pPwrUserSid );

    if ( pDacl != NULL )
    	LocalFree( pDacl );

    if ( hProcessToken != NULL )
    	CloseHandle( hProcessToken );

    return( dwRetCode );

}

//**
//
// Call:	AfpSecObjDelete
//
// Returns:	NO_ERROR	- success
//		non-zero returns from security functions
//
// Description: Will destroy a valid security descriptor.
//
DWORD
AfpSecObjDelete( VOID )
{
    if ( !IsValidSecurityDescriptor( AfpSecurityObject.pSecurityDescriptor))
    	return( NO_ERROR );

    if (!DestroyPrivateObjectSecurity( &AfpSecurityObject.pSecurityDescriptor))
	return( GetLastError() );

    return( NO_ERROR );
}

//**
//
// Call:	AfpSecObjAccessCheck
//
// Returns:	NO_ERROR	- success
//		non-zero returns from security functions
//
// Description: This procedure will first impersonate the client, then
//		check to see if the client has the desired access to the
//		security object. If he/she does then the AccessStatus
//		variable will be set to NO_ERROE otherwise it will be
//		set to ERROR_ACCESS_DENIED. It will the revert to self and
//		return.
//
DWORD
AfpSecObjAccessCheck( IN  DWORD 		DesiredAccess,
		      OUT LPDWORD 		lpdwAccessStatus 		
)
{
DWORD		dwRetCode;
ACCESS_MASK	GrantedAccess;
BOOL		fGenerateOnClose;

    // Impersonate the client
    //
    dwRetCode = RpcImpersonateClient( NULL );

    if ( dwRetCode != RPC_S_OK )
	return( I_RpcMapWin32Status( dwRetCode ));

    dwRetCode = AccessCheckAndAuditAlarm(
				    AFP_SERVICE_NAME,
				    NULL,
    				    AfpSecurityObject.lpwsObjectType,
				    AfpSecurityObject.lpwsObjectName,
				    AfpSecurityObject.pSecurityDescriptor,
				    DesiredAccess,
				    &(AfpSecurityObject.GenericMapping),
				    FALSE,
 			 	    &GrantedAccess,	
				    (LPBOOL)lpdwAccessStatus,
				    &fGenerateOnClose
				  );

    RpcRevertToSelf();

    if ( !dwRetCode )
	return( GetLastError() );

    // Check if desired access == granted Access
    //
    if ( DesiredAccess != GrantedAccess )
    {
        AFP_PRINT(( "SFMSVC: AfpSecObjAccessCheck: granted = 0x%x, desired = 0x%x\n",
            GrantedAccess,DesiredAccess));
	    *lpdwAccessStatus = ERROR_ACCESS_DENIED;
    }
    else
    {
	    *lpdwAccessStatus = NO_ERROR;
    }

    return( NO_ERROR );
}


//**
//
// Call:	AfpRpcSecurityCallback
//
// Returns:	NO_ERROR	- success
//		non-zero returns from security functions
//
// Description: This procedure is the security callback function for RPC
//
RPC_STATUS  RPC_ENTRY
AfpRpcSecurityCallback( 
	IN  RPC_IF_HANDLE *InterfaceUuid,
	IN	VOID	*pvContext
)
{
	DWORD 		DesiredAccess =  AFPSVC_ALL_ACCESS;
	DWORD		dwAccessStatus = 0;
	DWORD		dwRetCode = NO_ERROR;
	RPC_STATUS	Status;
	BOOL		fSuccess = TRUE;
	ACCESS_MASK	GrantedAccess;
	BOOL		fGenerateOnClose;

    // Impersonate the client
    //
    Status = RpcImpersonateClient( NULL );

    if ( Status != RPC_S_OK )
	return( Status );

    fSuccess = AccessCheckAndAuditAlarm(
				    AFP_SERVICE_NAME,
				    NULL,
    				    AfpSecurityObject.lpwsObjectType,
				    AfpSecurityObject.lpwsObjectName,
				    AfpSecurityObject.pSecurityDescriptor,
				    DesiredAccess,
				    &(AfpSecurityObject.GenericMapping),
				    FALSE,
 			 	    &GrantedAccess,	
				    (LPBOOL)&dwAccessStatus,
				    &fGenerateOnClose
				  );

    RpcRevertToSelf();

    if ( !fSuccess )
	return( RPC_S_CALL_FAILED );

    // Check if desired access == granted Access
    //
    if ( DesiredAccess != GrantedAccess )
    {
        AFP_PRINT(( "SFMSVC: AfpRpcSecurityCallback: Failed: granted = 0x%x, desired = 0x%x\n",
            GrantedAccess,DesiredAccess));
	    Status = RPC_S_ACCESS_DENIED;
    }
    else
    {
	    Status = RPC_S_OK;
    }

    return( Status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\service\server\srvrhlpr.c ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.     **/
/********************************************************************/

//***
//
// Filename:    srvrhlpr.c
//
// Description: This module will contain code to process specific security
//      information requests by the server. This is done because
//      the api's required to obtain this information cannot be
//      called from kernel mode. The following functionality is
//      supported:
//
//      1) Name to Sid Lookup.
//      2) Sid to Name lookup.
//      3) Enumerate Posix offsets of all domains.
//      4) Change password.
//      5) Log an event.
//
// History:     August 18,1992.    NarenG     Created original version.
//
#include <afpsvcp.h>
#include <lm.h>
#include <logonmsv.h>   // prototype of I_NetGetDCList
#include <seposix.h>
#include <dsgetdc.h>

static PPOLICY_ACCOUNT_DOMAIN_INFO pAccountDomainInfo = NULL;
static PPOLICY_PRIMARY_DOMAIN_INFO pPrimaryDomainInfo = NULL;

static HANDLE hmutexThreadCount = NULL;


NTSTATUS
AfpNameToSid(
    IN  LSA_HANDLE              hLsa,
    IN  PAFP_FSD_CMD_PKT        pAfpFsdCmd,
    OUT PAFP_FSD_CMD_PKT        *ppAfpFsdCmdResponse,
    OUT LPDWORD         pcbResponse
);

NTSTATUS
AfpSidToName(
    IN  LSA_HANDLE              hLsa,
    IN  PPOLICY_ACCOUNT_DOMAIN_INFO pAccountDomainInfo,
    IN  PPOLICY_PRIMARY_DOMAIN_INFO pPrimaryDomainInfo,
    IN  PAFP_FSD_CMD_PKT        pAfpFsdCmd,
    OUT PAFP_FSD_CMD_PKT        *ppAfpFsdCmdResponse,
    OUT LPDWORD         pcbResponse
);

NTSTATUS
AfpChangePassword(
    IN  LSA_HANDLE                  hLsa,
    IN  PPOLICY_ACCOUNT_DOMAIN_INFO pAccountDomainInfo,
    IN  PPOLICY_PRIMARY_DOMAIN_INFO pPrimaryDomainInfo,
    IN  PAFP_FSD_CMD_PKT        pAfpFsdCmd,
    OUT PAFP_FSD_CMD_PKT        *ppAfpFsdCmdResponse,
    OUT LPDWORD         pcbResponse
);

NTSTATUS
AfpChangePasswordOnDomain(
        IN PAFP_PASSWORD_DESC       pPassword,
        IN PUNICODE_STRING      pDomainName,
        IN PSID             pDomainSid
);

NTSTATUS
AfpCreateWellknownSids(
    OUT AFP_SID_OFFSET      pWellKnownSids[]
);

NTSTATUS
AfpInsertSidOffset(
    IN PAFP_SID_OFFSET      pSidOffset,
    IN LPBYTE           pbVariableData,
    IN PSID             pSid,
    IN DWORD            Offset,
    IN AFP_SID_TYPE         SidType
);

DWORD
AfpGetDomainInfo(
    IN     LSA_HANDLE           hLsa,
    IN OUT PLSA_HANDLE          phLsaController,
    IN OUT PPOLICY_ACCOUNT_DOMAIN_INFO* ppAccountDomainInfo,
    IN OUT PPOLICY_PRIMARY_DOMAIN_INFO* ppPrimaryDomainInfo
);

DWORD
AfpIOCTLDomainOffsets(
    IN LSA_HANDLE           hLsa,
    IN PPOLICY_ACCOUNT_DOMAIN_INFO  pAccountDomainInfo,
    IN PPOLICY_PRIMARY_DOMAIN_INFO  pPrimaryDomainInfo
);

DWORD
AfpOpenLsa(
    IN PUNICODE_STRING      pSystem OPTIONAL,
    IN OUT PLSA_HANDLE      phLsa
);


NTSTATUS
AfpChangePwdArapStyle(
        IN PAFP_PASSWORD_DESC   pPassword,
        IN PUNICODE_STRING  pDomainName,
        IN PSID         pDomainSid
);


//**
//
// Call:    AfpServerHelper
//
// Returns: NO_ERROR
//
// Description: This is the main function for each helper thread. If sits
//      in a loop processing commands from the server. It is terminated
//      by command from the server.
//
DWORD
AfpServerHelper(
    IN LPVOID fFirstThread
)
{
NTSTATUS                ntStatus;
DWORD                       dwRetCode;
PAFP_FSD_CMD_PKT            pAfpFsdCmdResponse;
AFP_FSD_CMD_HEADER          AfpCmdHeader;
PAFP_FSD_CMD_PKT            pAfpFsdCmd;
PBYTE                   pOutputBuffer;
DWORD                   cbOutputBuffer;
PBYTE                   pInputBuffer;
DWORD                   cbInputBuffer;
IO_STATUS_BLOCK             IoStatus;
BYTE                    OutputBuffer[MAX_FSD_CMD_SIZE];
HANDLE                  hFSD           = NULL;
LSA_HANDLE              hLsa           = NULL;
BOOLEAN                 fFirstLoop=TRUE;


    // Open the AFP Server FSD and obtain a handle to it
    //
    if ( ( dwRetCode = AfpFSDOpen( &hFSD ) ) != NO_ERROR ) {
    AfpGlobals.dwSrvrHlprCode = dwRetCode;
    AfpLogEvent( AFPLOG_OPEN_FSD, 0, NULL, dwRetCode, EVENTLOG_ERROR_TYPE );
    SetEvent( AfpGlobals.heventSrvrHlprThread );
    return( dwRetCode );
    }

    // Open the Local LSA
    //
    if ( ( dwRetCode = AfpOpenLsa( NULL, &hLsa ) ) != NO_ERROR ) {

        AfpFSDClose( hFSD );
    AfpGlobals.dwSrvrHlprCode = dwRetCode;
    AfpLogEvent( AFPLOG_OPEN_LSA, 0, NULL, dwRetCode, EVENTLOG_ERROR_TYPE );
    SetEvent( AfpGlobals.heventSrvrHlprThread );
    return( dwRetCode );
    }

    // If this is the first server helper thread then enumerate and
    // IOCTL down the list of domains and their offsets.
    //
    if ( (BOOL)(ULONG_PTR)fFirstThread )
    {

        LSA_HANDLE hLsaController = NULL;

        //
        // Create the event object for mutual exclusion around the thread
        // count
        //
        if ( (hmutexThreadCount = CreateMutex( NULL, FALSE, NULL ) ) == NULL)
        {
            AFP_PRINT( ( "SFMSVC: CreateMutex failed\n"));
            return( GetLastError() );
        }

        while (1)
        {
            // Get the account, primary and all trusted domain info
            //
            dwRetCode = AfpGetDomainInfo( hLsa,
                            &hLsaController,
                            &pAccountDomainInfo,
                            &pPrimaryDomainInfo);

            AfpGlobals.dwSrvrHlprCode = dwRetCode;

            if (dwRetCode == NO_ERROR)
            {
                break;
            }
            else if (dwRetCode != ERROR_CANT_ACCESS_DOMAIN_INFO)
            {
                AFP_PRINT( ( "SFMSVC: Get Domain Info failed %ld\n",dwRetCode));
                AfpLogEvent( AFPLOG_CANT_GET_DOMAIN_INFO, 0, NULL,
                            dwRetCode, EVENTLOG_ERROR_TYPE );
                AfpFSDClose( hFSD );
                LsaClose( hLsa );
                SetEvent( AfpGlobals.heventSrvrHlprThread );
                return( dwRetCode );
            }

            // ok, we couldn't access domain info.  keep retrying until we
            // are successful (or until the service is stopped!)
            AfpGlobals.dwServerState |= AFPSTATE_BLOCKED_ON_DOMINFO;

            if (fFirstLoop)
            {
                fFirstLoop = FALSE;

                AFP_PRINT( ( "SFMSVC: first loop, telling service controller to go ahead\n"));

                // tell the service controller we're running, so the user
                // doesn't have to wait as long as we're blocked here!
                //
                AfpGlobals.ServiceStatus.dwCurrentState     = SERVICE_RUNNING;
                AfpGlobals.ServiceStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP |
                                      SERVICE_ACCEPT_PAUSE_CONTINUE;
                AfpGlobals.ServiceStatus.dwCheckPoint       = 0;
                AfpGlobals.ServiceStatus.dwWaitHint         = 0;

                AfpAnnounceServiceStatus();

                // log an event to give the bad news..
                AfpLogEvent( AFPLOG_DOMAIN_INFO_RETRY, 0, NULL,
                                dwRetCode, EVENTLOG_WARNING_TYPE );
            }

            AFP_PRINT( ( "SFMSVC: sleeping 20 sec before retrying domain info\n"));

            // wait for 20 seconds before retrying for the domain info
            // Meanwhile, watch to see if the service is stopping.  If so, we
            // must do the necessary setevent and get out
            if (WaitForSingleObject( AfpGlobals.heventSrvrHlprSpecial, 20000 ) == 0)
            {
                AfpFSDClose( hFSD );
                LsaClose( hLsa );
                SetEvent( AfpGlobals.heventSrvrHlprThread );
                return( dwRetCode );
            }

            AFP_PRINT( ( "SFMSVC: retrying getdomain info\n"));
        }

        // if we were blocked retrying the domain-info, log an event that we
        // are ok now
        if (AfpGlobals.dwServerState & AFPSTATE_BLOCKED_ON_DOMINFO)
        {
            AFP_PRINT( ( "SFMSVC: domain info stuff finally worked\n"));

            AfpGlobals.dwServerState &= ~AFPSTATE_BLOCKED_ON_DOMINFO;

            AfpLogEvent( AFPLOG_SFM_STARTED_OK, 0, NULL, 0, EVENTLOG_SUCCESS );
        }

        //
        // IOCTL all the domain offsets
        // if hLsaController is NULL, the server is in a WorkGroup, not domain
        //
        if ( ( dwRetCode = AfpIOCTLDomainOffsets(
                                hLsaController,
                                pAccountDomainInfo,
                                pPrimaryDomainInfo) ) != NO_ERROR )
        {

            AFP_PRINT( ( "SFMSVC: Ioctl Domain Offsets failed.\n"));

            AfpLogEvent( AFPLOG_CANT_INIT_DOMAIN_INFO, 0, NULL,
                         dwRetCode, EVENTLOG_ERROR_TYPE );

            // First clean up
            //
            AfpFSDClose( hFSD );

            // If the local machine is not a controller
            //
            if ( (hLsaController != NULL) && (hLsa != hLsaController) )
            {
                LsaClose( hLsaController );
            }

            LsaClose( hLsa );

            if ( pAccountDomainInfo != NULL )
            {
                LsaFreeMemory( pAccountDomainInfo );
            }

            if ( pPrimaryDomainInfo != NULL )
            {
                LsaFreeMemory( pPrimaryDomainInfo );
            }

            AfpGlobals.dwSrvrHlprCode = dwRetCode;
            SetEvent( AfpGlobals.heventSrvrHlprThread );

            return( dwRetCode );
        }

        // If the local machine is not a controller, then close the handle
        // since we have all the information we need.
        //
        if ( (hLsaController != NULL) && (hLsa != hLsaController) )
        {
            LsaClose( hLsaController );
        }

    }

    // OK everything initialize OK. Tell parent (init) thread that it may
    // continue.
    //
    AfpGlobals.dwSrvrHlprCode = dwRetCode;
    SetEvent( AfpGlobals.heventSrvrHlprThread );

    WaitForSingleObject( hmutexThreadCount, INFINITE );
    AfpGlobals.nThreadCount++;
    ReleaseMutex( hmutexThreadCount );

    pOutputBuffer   = OutputBuffer;
    cbOutputBuffer  = sizeof( OutputBuffer );
    pAfpFsdCmd      = (PAFP_FSD_CMD_PKT)pOutputBuffer;

    pInputBuffer        = NULL;
    cbInputBuffer       = 0;
    pAfpFsdCmdResponse  = (PAFP_FSD_CMD_PKT)NULL;

    while( TRUE ) {


    // IOCTL the FSD
    //
    ntStatus = NtFsControlFile( hFSD,
                    NULL,
                    NULL,
                    NULL,
                    &IoStatus,
                    OP_GET_FSD_COMMAND,
                    pInputBuffer,
                    cbInputBuffer,
                    pOutputBuffer,
                    cbOutputBuffer
                    );

    if (!NT_SUCCESS(ntStatus))
        AFP_PRINT(("SFMSVC: NtFsControlFile Returned %lx\n",
            ntStatus));

        ASSERT( NT_SUCCESS( ntStatus ));

    // Free previous call's input buffer
    //
    if ( pAfpFsdCmdResponse != NULL )
        LocalFree( pAfpFsdCmdResponse );

    // Process the command
    //
    switch( pAfpFsdCmd->Header.FsdCommand ) {

    case AFP_FSD_CMD_NAME_TO_SID:

            ntStatus = AfpNameToSid(    hLsa,
                    pAfpFsdCmd,
                    &pAfpFsdCmdResponse,
                    &cbInputBuffer );

            if ( NT_SUCCESS( ntStatus ))
            pInputBuffer    = (PBYTE)pAfpFsdCmdResponse;
        else {
            pInputBuffer    = (PBYTE)&AfpCmdHeader;
            cbInputBuffer   = sizeof( AFP_FSD_CMD_HEADER );
            pAfpFsdCmdResponse  = NULL;
        }

        break;

    case AFP_FSD_CMD_SID_TO_NAME:

            ntStatus = AfpSidToName(    hLsa,
                    pAccountDomainInfo,
                    pPrimaryDomainInfo,
                    pAfpFsdCmd,
                    &pAfpFsdCmdResponse,
                    &cbInputBuffer );

            if ( NT_SUCCESS( ntStatus ))
            pInputBuffer    = (PBYTE)pAfpFsdCmdResponse;
        else {
            pInputBuffer    = (PBYTE)&AfpCmdHeader;
            cbInputBuffer   = sizeof( AFP_FSD_CMD_HEADER );
            pAfpFsdCmdResponse  = NULL;
        }

        break;

    case AFP_FSD_CMD_CHANGE_PASSWORD:

            ntStatus = AfpChangePassword(
                    hLsa,
                    pAccountDomainInfo,
                    pPrimaryDomainInfo,
                    pAfpFsdCmd,
                    &pAfpFsdCmdResponse,
                    &cbInputBuffer );

        pInputBuffer    = (PBYTE)&AfpCmdHeader;
        cbInputBuffer   = sizeof( AFP_FSD_CMD_HEADER );
        pAfpFsdCmdResponse  = NULL;

        break;

    case AFP_FSD_CMD_LOG_EVENT:

        AfpLogServerEvent(pAfpFsdCmd);

        pInputBuffer    = (PBYTE)&AfpCmdHeader;
        cbInputBuffer   = sizeof( AFP_FSD_CMD_HEADER );
        pAfpFsdCmdResponse  = NULL;
        ntStatus        = STATUS_SUCCESS;

        break;

    case AFP_FSD_CMD_TERMINATE_THREAD:

        // Do clean up
        //
            LsaClose( hLsa );
            AfpFSDClose( hFSD );

            WaitForSingleObject( hmutexThreadCount, INFINITE );

        AfpGlobals.nThreadCount --;
        // This is the last thread so clean up all the global stuff.
        //
        if ( AfpGlobals.nThreadCount == 0 ) {

            if ( pAccountDomainInfo != NULL )
            {
                LsaFreeMemory( pAccountDomainInfo );
                pAccountDomainInfo = NULL;
            }

            if ( pPrimaryDomainInfo != NULL )
                LsaFreeMemory( pPrimaryDomainInfo );

            SetEvent(AfpGlobals.heventSrvrHlprThreadTerminate);
        }

            ReleaseMutex( hmutexThreadCount );

        return( NO_ERROR );

        break;

    default:
        ntStatus        = STATUS_NOT_SUPPORTED;
        pInputBuffer    = (PBYTE)&AfpCmdHeader;
        cbInputBuffer   = sizeof( AFP_FSD_CMD_HEADER );
        pAfpFsdCmdResponse  = NULL;
        break;

    }


    CopyMemory( pInputBuffer, pAfpFsdCmd, sizeof( AFP_FSD_CMD_HEADER ) );

    ((PAFP_FSD_CMD_HEADER)pInputBuffer)->ntStatus = ntStatus;
    }

    return( NO_ERROR );
}

//**
//
// Call:    AfpGetDomainInfo
//
// Returns: LsaQueryInformationPolicy, I_NetGetDCList and AfpOpenLsa
//
// Description: Will retrieve information regarding the account, primary and
//      trusted domains.
//
DWORD
AfpGetDomainInfo(
    IN     LSA_HANDLE           hLsa,
    IN OUT PLSA_HANDLE          phLsaController,
    IN OUT PPOLICY_ACCOUNT_DOMAIN_INFO* ppAccountDomainInfo,
    IN OUT PPOLICY_PRIMARY_DOMAIN_INFO* ppPrimaryDomainInfo
)
{
    DWORD                       dwRetCode = 0;
    NTSTATUS                    ntStatus  = STATUS_SUCCESS;
    LSA_ENUMERATION_HANDLE      hLsaEnum  = 0;
    LPWSTR                      DomainName = NULL;
    PDOMAIN_CONTROLLER_INFO     pDCInfo = NULL;
    UNICODE_STRING              DCName;

    // This is not a loop.
    //
    do {

        *phLsaController     = NULL;
        *ppAccountDomainInfo = NULL;
        *ppPrimaryDomainInfo = NULL;


        // Get the account domain
        //
        ntStatus = LsaQueryInformationPolicy(
                    hLsa,
                    PolicyAccountDomainInformation,
                    (PVOID*)ppAccountDomainInfo
                    );

        if ( !NT_SUCCESS( ntStatus ) )
        {
            AFP_PRINT( ( "SFMSVC: Lsa..Policy for Acct dom failed %lx\n",ntStatus));
            break;
        }

    // Get the primary domain
    //
        ntStatus = LsaQueryInformationPolicy(
                    hLsa,
                    PolicyPrimaryDomainInformation,
                    (PVOID*)ppPrimaryDomainInfo
                    );
        if ( !NT_SUCCESS( ntStatus ) )
        {
            AFP_PRINT( ( "SFMSVC: Lsa..Policy for Primary dom failed %lx\n",ntStatus));
            break;
        }

        // If this machine is part of a domain (not standalone), then we need
        // to get a list of trusted domains. Note that a workstation and a
        // member server can both join a domain, but they don't have to.
        //
        if ( (*ppPrimaryDomainInfo)->Sid != NULL )
        {

            // To obtain a list of trusted domains, we need to first open
            // the LSA on a domain controller. If we are an PDC/BDC
            // (NtProductLanManNt) then the local LSA will do, otherwise we need
            // to search for domain controllers (NtProductServer, NtProductWinNt).
            //
            if ( AfpGlobals.NtProductType != NtProductLanManNt )
            {

                ULONG           ulCount;
                ULONG           ControllerCount  = 0;
                PUNICODE_STRING ControllerNames  = NULL;
                PUNICODE_STRING DomainController = NULL;

                DomainName = (LPWSTR)LocalAlloc(
                                        LPTR,
                                        (*ppPrimaryDomainInfo)->Name.Length+sizeof(WCHAR));

                if ( DomainName == NULL )
                {
                    dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }

                CopyMemory( DomainName,
                            (*ppPrimaryDomainInfo)->Name.Buffer,
                            (*ppPrimaryDomainInfo)->Name.Length );

                DomainName[(*ppPrimaryDomainInfo)->Name.Length/sizeof(WCHAR)] = 0;

                dwRetCode = DsGetDcName(
                                 NULL,
                                 (LPWSTR)DomainName,
                                 NULL,               // domain
                                 NULL,               // site name
                                 DS_DIRECTORY_SERVICE_PREFERRED,
                                 &pDCInfo);

                if ( dwRetCode != NO_ERROR )
                {
                    AFP_PRINT( ( "SFMSVC: DsGetDcName failed 0x%lx\n",dwRetCode));
                    dwRetCode = ERROR_CANT_ACCESS_DOMAIN_INFO;
                    break;
                }

                AFP_PRINT(("SFMSVC: AfpOpenLsa on DC %ws for domain %ws\n",
                    pDCInfo->DomainControllerName,DomainName));

                RtlInitUnicodeString(&DCName, pDCInfo->DomainControllerName);

                dwRetCode = AfpOpenLsa(&DCName, phLsaController );

                //
                // it's possible that this DC is down: force discovery
                //
                if (dwRetCode != NO_ERROR)
                {

                    AFP_PRINT(("SFMSVC: DC %ws unreachable, forcing discovery\n",
                                pDCInfo->DomainControllerName));

                    NetApiBufferFree(pDCInfo);

                    pDCInfo = NULL;

                    dwRetCode = DsGetDcName(
                                     NULL,
                                     (LPWSTR)DomainName,
                                     NULL,
                                     NULL,
                                     (DS_DIRECTORY_SERVICE_PREFERRED | DS_FORCE_REDISCOVERY),
                                     &pDCInfo);

                    if ( dwRetCode != NO_ERROR )
                    {
                        AFP_PRINT(("SFMSVC: second DsGetDcName failed %lx\n",dwRetCode));
                        dwRetCode = ERROR_CANT_ACCESS_DOMAIN_INFO;
                        break;
                    }

                    RtlInitUnicodeString(&DCName, pDCInfo->DomainControllerName);

                    dwRetCode = AfpOpenLsa(&DCName, phLsaController );
                }

            }
            else
            {

                *phLsaController = hLsa;

                // Since the local server is an PDC/BDC, it's account
                // domain is the same as it's primary domain so set the
                // account domain info to NULL
                //
                LsaFreeMemory( *ppAccountDomainInfo );
                *ppAccountDomainInfo = NULL;
            }


        }
        else
        {
            LsaFreeMemory( *ppPrimaryDomainInfo );
            *ppPrimaryDomainInfo = NULL;
        }

    } while( FALSE );


    if (DomainName)
    {
        LocalFree( DomainName );
    }

    if (pDCInfo)
    {
        NetApiBufferFree(pDCInfo);
    }


    if ( !NT_SUCCESS( ntStatus ) || ( dwRetCode != NO_ERROR ) )
    {
        if ( *ppAccountDomainInfo != NULL )
        {
            LsaFreeMemory( *ppAccountDomainInfo );
        }

        if ( *ppPrimaryDomainInfo != NULL )
        {
            LsaFreeMemory( *ppPrimaryDomainInfo );
        }

        if ( *phLsaController != NULL )
        {
            LsaClose( *phLsaController );
        }

        if ( dwRetCode == NO_ERROR )
        {
            dwRetCode = RtlNtStatusToDosError( ntStatus );
        }
    }


    return( dwRetCode );

}

//**
//
// Call:    AfpOpenLsa
//
// Returns: Returns from LsaOpenPolicy.
//
// Description: The LSA will be opened.
//
DWORD
AfpOpenLsa(
    IN PUNICODE_STRING  pSystem OPTIONAL,
    IN OUT PLSA_HANDLE  phLsa
)
{
SECURITY_QUALITY_OF_SERVICE QOS;
OBJECT_ATTRIBUTES       ObjectAttributes;
NTSTATUS            ntStatus;

    // Open the LSA and obtain a handle to it.
    //
    QOS.Length          = sizeof( QOS );
    QOS.ImpersonationLevel  = SecurityImpersonation;
    QOS.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    QOS.EffectiveOnly       = FALSE;

    InitializeObjectAttributes( &ObjectAttributes,
                NULL,
                0L,
                NULL,
                NULL );

    ObjectAttributes.SecurityQualityOfService = &QOS;

    ntStatus = LsaOpenPolicy(   pSystem,
                    &ObjectAttributes,
                    POLICY_VIEW_LOCAL_INFORMATION |
                POLICY_LOOKUP_NAMES,
                    phLsa );

    if ( !NT_SUCCESS( ntStatus ))
    {
        AFP_PRINT(("SFMSVC: AfpOpenLsa: LsaOpenPolicy failed %lx\n",ntStatus));
        return( RtlNtStatusToDosError( ntStatus ) );
    }

    return( NO_ERROR );
}

//
// Call:    AfpNameToSid
//
// Returns: NT_SUCCESS
//      error return codes from LSA apis.
//
// Description: Will use LSA API's to translate a name to a SID. On a
//      successful return, the pSid should be freed using LocalFree.
//
NTSTATUS
AfpNameToSid(
    IN  LSA_HANDLE              hLsa,
    IN  PAFP_FSD_CMD_PKT        pAfpFsdCmd,
    OUT PAFP_FSD_CMD_PKT        *ppAfpFsdCmdResponse,
    OUT LPDWORD             pcbResponse
)
{
NTSTATUS            ntStatus;
UNICODE_STRING          Name;
PLSA_REFERENCED_DOMAIN_LIST pDomainList;
PLSA_TRANSLATED_SID     pSids;
UCHAR               AuthCount;
PSID                pDomainSid;
PSID                pSid;

    // This do - while(FALSE) loop facilitates a single exit and clean-up point.
    //
    do {

    *ppAfpFsdCmdResponse = NULL;
    pDomainList          = NULL;
    pSids                = NULL;

        RtlInitUnicodeString( &Name, (LPWSTR)(pAfpFsdCmd->Data.Name) );

        ntStatus = LsaLookupNames( hLsa, 1, &Name, &pDomainList, &pSids );

        if ( !NT_SUCCESS( ntStatus ) )
        return( ntStatus );

    if ( pSids->Use == SidTypeDeletedAccount ){
        ntStatus = STATUS_NO_SUCH_USER;
        break;
    }

    if ( ( pDomainList->Entries == 0 )       ||
         ( pSids->Use == SidTypeDomain )         ||
         ( pSids->Use == SidTypeInvalid )        ||
         ( pSids->Use == SidTypeUnknown )        ||
         ( pSids->DomainIndex == -1 )) {

        ntStatus = STATUS_NONE_MAPPED;
        break;
    }

    pDomainSid = pDomainList->Domains[pSids->DomainIndex].Sid;

        AuthCount = *RtlSubAuthorityCountSid( pDomainSid ) + 1;

        *pcbResponse = sizeof(AFP_FSD_CMD_PKT)+RtlLengthRequiredSid(AuthCount);

        *ppAfpFsdCmdResponse = (PAFP_FSD_CMD_PKT)LocalAlloc(LPTR,*pcbResponse);
        if ( *ppAfpFsdCmdResponse == NULL ) {
        ntStatus = STATUS_NO_MEMORY ;
        break;
    }

    pSid = (*ppAfpFsdCmdResponse)->Data.Sid;

        // Copy the Domain Sid.
        //
        RtlCopySid( RtlLengthRequiredSid(AuthCount), pSid, pDomainSid );

        // Append the Relative Id.
        //
        *RtlSubAuthorityCountSid( pSid ) += 1;
        *RtlSubAuthoritySid( pSid, AuthCount - 1) = pSids->RelativeId;

    } while( FALSE );

    if ( (!NT_SUCCESS( ntStatus )) && ( *ppAfpFsdCmdResponse != NULL ) )
        LocalFree( *ppAfpFsdCmdResponse );

    if ( pSids != NULL )
        LsaFreeMemory( pSids );

    if ( pDomainList != NULL )
        LsaFreeMemory( pDomainList );

    return( ntStatus );

}

//**
//
// Call:    AfpSidToName
//
// Returns: NT_SUCCESS
//      error return codes from LSA apis.
//
// Description: Given a SID, this routine will find the corresponding
//      UNICODE name.
//
NTSTATUS
AfpSidToName(
    IN  LSA_HANDLE              hLsa,
    IN  PPOLICY_ACCOUNT_DOMAIN_INFO pAccountDomainInfo,
    IN  PPOLICY_PRIMARY_DOMAIN_INFO pPrimaryDomainInfo,
    IN  PAFP_FSD_CMD_PKT        pAfpFsdCmd,
    OUT PAFP_FSD_CMD_PKT        *ppAfpFsdCmdResponse,
    OUT LPDWORD             pcbResponse
)
{
NTSTATUS            ntStatus;
PLSA_REFERENCED_DOMAIN_LIST pDomainList = NULL;
PLSA_TRANSLATED_NAME        pNames      = NULL;
PSID                pSid        = (PSID)&(pAfpFsdCmd->Data.Sid);
WCHAR *             pWchar;
BOOL                    fDoNotCopyDomainName = TRUE;
DWORD               cbResponse;
DWORD               dwUse;
SID                 AfpBuiltInSid = { 1, 1, SECURITY_NT_AUTHORITY,
                              SECURITY_BUILTIN_DOMAIN_RID };

    do {

    *ppAfpFsdCmdResponse = NULL;

        ntStatus = LsaLookupSids( hLsa, 1, &pSid, &pDomainList, &pNames );

        if ( !NT_SUCCESS( ntStatus ) ) {

        if ( ntStatus == STATUS_NONE_MAPPED ) {

        dwUse = SidTypeUnknown;
        ntStatus = STATUS_SUCCESS;
        }
        else
            break;
    }
    else
        dwUse = pNames->Use;

    cbResponse = sizeof( AFP_FSD_CMD_PKT );

    switch( dwUse ){

    case SidTypeInvalid:
        cbResponse += ((wcslen(AfpGlobals.wchInvalid)+1) * sizeof(WCHAR));
        break;

    case SidTypeDeletedAccount:
        cbResponse += ((wcslen(AfpGlobals.wchDeleted)+1) * sizeof(WCHAR));
        break;

    case SidTypeUnknown:
        cbResponse += ((wcslen(AfpGlobals.wchUnknown)+1) * sizeof(WCHAR));
        break;

    case SidTypeWellKnownGroup:
        cbResponse += ( pNames->Name.Length + sizeof(WCHAR) );
        break;

    case SidTypeDomain:
        cbResponse += ( pDomainList->Domains->Name.Length + sizeof(WCHAR) );
        break;

    default:

        if ((pNames->DomainIndex == -1) || (pNames->Name.Buffer == NULL)){
            ntStatus = STATUS_NONE_MAPPED;
            break;
        }

        // Do not copy the domain name if the name is either a well known
        // group or if the SID belongs to the ACCOUNT or BUILTIN domains.
        // Note, the pAccountDomainInfo is NULL is this is an advanced
        // server, in that case we check to see if the domain name is
        // the primary domain name.
        //
        if (( RtlEqualSid( &AfpBuiltInSid, pDomainList->Domains->Sid )) ||
           (( pAccountDomainInfo != NULL ) &&
           (RtlEqualUnicodeString( &(pAccountDomainInfo->DomainName),
                        &(pDomainList->Domains->Name),
                        TRUE ))) ||
           ((pAccountDomainInfo == NULL) && (pPrimaryDomainInfo != NULL) &&
           (RtlEqualUnicodeString( &(pPrimaryDomainInfo->Name),
                       &(pDomainList->Domains->Name),
                       TRUE )))){

        cbResponse += ( pNames->Name.Length + sizeof(WCHAR) );

            fDoNotCopyDomainName = TRUE;
        }
        else {

            fDoNotCopyDomainName = FALSE;

            cbResponse += ( pDomainList->Domains->Name.Length +
                        sizeof(TEXT('\\')) +
                        pNames->Name.Length +
                        sizeof(WCHAR) );
        }
    }

        if ( !NT_SUCCESS( ntStatus ) )
        break;

    *pcbResponse = cbResponse;

        *ppAfpFsdCmdResponse = (PAFP_FSD_CMD_PKT)LocalAlloc(LPTR,cbResponse);

    if ( *ppAfpFsdCmdResponse == NULL ){
        ntStatus = STATUS_NO_MEMORY ;
        break;
    }

    pWchar = (WCHAR*)((*ppAfpFsdCmdResponse)->Data.Name);

    switch( dwUse ){

    case SidTypeInvalid:
        wcscpy( pWchar, AfpGlobals.wchInvalid );
        break;

    case SidTypeDeletedAccount:
        wcscpy( pWchar, AfpGlobals.wchDeleted );
        break;

    case SidTypeUnknown:
        wcscpy( pWchar, AfpGlobals.wchUnknown );
        break;

    case SidTypeWellKnownGroup:
        CopyMemory( pWchar, pNames->Name.Buffer, pNames->Name.Length );
        break;

    case SidTypeDomain:
        CopyMemory( pWchar,
                pDomainList->Domains->Name.Buffer,
                pDomainList->Domains->Name.Length );
        break;

    default:

        if ( !fDoNotCopyDomainName ) {

            CopyMemory( pWchar,
                    pDomainList->Domains->Name.Buffer,
                    pDomainList->Domains->Name.Length );

            pWchar += wcslen( pWchar );

            CopyMemory( pWchar, TEXT("\\"), sizeof(TEXT("\\")) );

            pWchar += wcslen( pWchar );
        }

        CopyMemory( pWchar, pNames->Name.Buffer, pNames->Name.Length );
    }

    } while( FALSE );

    if ( (!NT_SUCCESS( ntStatus )) && ( *ppAfpFsdCmdResponse != NULL ) )
        LocalFree( *ppAfpFsdCmdResponse );

    if ( pNames != NULL )
        LsaFreeMemory( pNames );

    if ( pDomainList != NULL )
        LsaFreeMemory( pDomainList );

    return( ntStatus );

}

//**
//
// Call:    AfpChangePassword
//
// Returns: NT_SUCCESS
//      error return codes from LSA apis.
//
// Description: Given the AFP_PASSWORD_DESC data structure, this procedure
//      will change the password of a given user.
//      If the passwords are supplied in clear text, then it calculate
//      the OWF's (encrypt OWF = One Way Function) them.
//      If the domain name that the user
//      belongs to is not supplied then a list of domains are tried
//      in sequence. The sequence is 1) ACCOUNT domain
//                       2) PRIMARY domain
//                       3) All trusted domains.
//
NTSTATUS
AfpChangePassword(
    IN  LSA_HANDLE                  hLsa,
    IN  PPOLICY_ACCOUNT_DOMAIN_INFO pAccountDomainInfo,
    IN  PPOLICY_PRIMARY_DOMAIN_INFO pPrimaryDomainInfo,
    IN  PAFP_FSD_CMD_PKT        pAfpFsdCmd,
    OUT PAFP_FSD_CMD_PKT        *ppAfpFsdCmdResponse,
    OUT LPDWORD         pcbResponse
)
{



    PAFP_PASSWORD_DESC              pPassword = &(pAfpFsdCmd->Data.Password);
    NTSTATUS                        ntStatus=STATUS_SUCCESS;
    PSID                            pDomainSid;
    UNICODE_STRING                  TargetDomainName;
    WCHAR                           RefDomainName[DNLEN+1];
    DWORD                           cbRefDomainNameLen;
    DWORD                           cbSidLen;
    PSID                            pUserSid=NULL;
    PLSA_TRANSLATED_SID             pTransSids;
    SID_NAME_USE                    peUse;
    PLSA_REFERENCED_DOMAIN_LIST     pDomainList=NULL;
    DWORD                           dwRetCode;

    AFP_PRINT(("SFMSVC: entered AfpChangePassword for user %ws\n",(LPWSTR)pPassword->UserName));

    do
    {

        //
        // Was the domain on which the account name exists specified ??
        //
        if ( pPassword->DomainName[0] != TEXT('\0') )
        {
            RtlInitUnicodeString(&TargetDomainName, (LPWSTR)pPassword->DomainName);
        }

        //
        // hmmm, no domain name.  We must first find which domain this user belongs to
        //
        else
        {
            cbRefDomainNameLen = DNLEN+1;

            cbSidLen = 100;

            do
            {
                dwRetCode = ERROR_SUCCESS;
                if (pUserSid)
                {
                    LocalFree(pUserSid);
                }

                pUserSid = (PSID)LocalAlloc(LPTR, cbSidLen);

                if (pUserSid == NULL)
                {
                    dwRetCode = ERROR_NO_SYSTEM_RESOURCES;
                    break;
                }

                if (!LookupAccountName(
                        NULL,
                        (LPWSTR)pPassword->UserName,
                        pUserSid,
                        &cbSidLen,
                        RefDomainName,
                        &cbRefDomainNameLen,
                        &peUse))
                {
                    ntStatus = (NTSTATUS)GetLastError();
                }

                AFP_PRINT(("SFMSVC: LookupAccountName in loop: %#x\n",GetLastError()));

            } while ( dwRetCode == ERROR_INSUFFICIENT_BUFFER );

            if (dwRetCode != ERROR_SUCCESS)
            {
                AFP_PRINT(("SFMSVC: LookupAccountName on %ws failed with %ld\n",(LPWSTR)pPassword->UserName,dwRetCode));
                ntStatus = (NTSTATUS)dwRetCode;
                break;
            }

            LocalFree(pUserSid);

            RtlInitUnicodeString(&TargetDomainName, RefDomainName);
        }


        AFP_PRINT(("SFMSVC: changing pwd for user (%ws), domain (%ws)\n",
                    (LPWSTR)pPassword->UserName,TargetDomainName.Buffer));

        //
        // now, we must find the sid for this domain
        //
        ntStatus = LsaLookupNames(hLsa, 1, &TargetDomainName, &pDomainList, &pTransSids);

        if (!NT_SUCCESS(ntStatus))
        {
            AFP_PRINT(("SFMSVC: LsaLookupNames failed %lx\n",ntStatus));
            break;
        }

        if ((pDomainList->Entries == 0) ||
            (pTransSids->DomainIndex == -1) ||
            (pTransSids->Use != SidTypeDomain) ||
            (pTransSids->Use == SidTypeInvalid) ||
            (pTransSids->Use == SidTypeUnknown))
        {
            AFP_PRINT(("SFMSVC: invalide type? Entries = %d, DomIndex = %d, Use = %d\n",
                    pDomainList->Entries,pTransSids->DomainIndex,pTransSids->Use));
            ntStatus = STATUS_NONE_MAPPED;
            break;
        }

        pDomainSid = pDomainList->Domains[pTransSids->DomainIndex].Sid;


        //
        // call our function to change the password
        //
        ntStatus = AfpChangePasswordOnDomain(
                        pPassword,
                        &TargetDomainName,
                        pDomainSid );

AFP_PRINT(("SFMSVC: AfpChangePasswordOnDomain returned %lx\n",ntStatus));

    } while ( FALSE );


    if (pDomainList)
    {
        LsaFreeMemory( pDomainList );
    }

    return( ntStatus );
}

//**
//
// Call:    AfpChangePasswordOnDomain
//
// Returns: NT_SUCCESS
//      STATUS_NONE_MAPPED  - If the user account does not
//                    exist in the specified domain.
//      error return codes from LSA apis.
//
// Description: This procedure will try to change the user's password on a
//      specified domain. It is assumed that this procedure will be
//      called with either the pDomainName pointing to the domain, or
//      the pPassword->DomainName field containing the domain.
//
NTSTATUS
AfpChangePasswordOnDomain(
        IN PAFP_PASSWORD_DESC   pPassword,
        IN PUNICODE_STRING  pDomainName,
        IN PSID         pDomainSid
)
{

    LPWSTR                          DCName  = (LPWSTR)NULL;
    SAM_HANDLE                      hServer = (SAM_HANDLE)NULL;
    SAM_HANDLE                      hDomain = (SAM_HANDLE)NULL;
    SAM_HANDLE                      hUser   = (SAM_HANDLE)NULL;
    PULONG                          pUserId = (PULONG)NULL;
    PSID_NAME_USE                   pUse    = (PSID_NAME_USE)NULL;
    OBJECT_ATTRIBUTES               ObjectAttributes;
    UNICODE_STRING                  UserName;
    ANSI_STRING                     AOldPassword;
    UNICODE_STRING                  UOldPassword;
    ANSI_STRING                     ANewPassword;
    UNICODE_STRING                  UNewPassword;
    POEM_STRING                     pOemSrvName;
    OEM_STRING                      OemServerName;
    OEM_STRING                      OemUserName;
    SECURITY_QUALITY_OF_SERVICE     QOS;
    PPOLICY_ACCOUNT_DOMAIN_INFO     pDomainInfo    = NULL;
    NTSTATUS                        ntStatus;
    UNICODE_STRING                  PDCServerName;
    PUNICODE_STRING                 pPDCServerName = &PDCServerName;
    PDOMAIN_PASSWORD_INFORMATION    pPasswordInfo = NULL;
    BYTE                            EncryptedPassword[LM_OWF_PASSWORD_LENGTH];
    WCHAR                           wchDomain[DNLEN+1];
    PDOMAIN_CONTROLLER_INFO         pDCInfo = NULL;
    PUSER_INFO_1                    pUserInfo = NULL;
    BOOLEAN                         fNeedToResolveDCName = FALSE;
    DWORD                           dwRetCode;



    if ((pPassword->AuthentMode == RANDNUM_EXCHANGE) ||
        (pPassword->AuthentMode == TWOWAY_EXCHANGE))
    {

        AFP_PRINT(("SFMSVC: Entering AfpChangePwdArapStyle for RANDNUM_EXCHANGE || TWOWAY_EXCHANGE\n"));
        ntStatus = AfpChangePwdArapStyle(pPassword, pDomainName, pDomainSid);
        AFP_PRINT(("SFMSVC: Returned from AfpChangePwdArapStyle with error %lx\n", ntStatus));
        return(ntStatus);
    }

    OemServerName.Buffer = NULL;
    OemUserName.Buffer = NULL;

    InitializeObjectAttributes( &ObjectAttributes,
                NULL,
                0L,
                NULL,
                NULL );

    QOS.Length          = sizeof( QOS );
    QOS.ImpersonationLevel  = SecurityImpersonation;
    QOS.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    QOS.EffectiveOnly       = FALSE;

    ObjectAttributes.SecurityQualityOfService = &QOS;

    // If the domain was not the account domain then we try to get the
    // primary domain controller for the domain.
    //
    if ((pDomainName != NULL) &&
        (pAccountDomainInfo != NULL) &&
        !(RtlEqualUnicodeString( &(pAccountDomainInfo->DomainName),pDomainName, TRUE)))
    {
        fNeedToResolveDCName = TRUE;
    }
    if ((pAccountDomainInfo == NULL) && (pDomainName != NULL))
    {
        fNeedToResolveDCName = TRUE;
    }
    if (fNeedToResolveDCName)
    {
        ZeroMemory( wchDomain, sizeof( wchDomain ) );

        CopyMemory( wchDomain, pDomainName->Buffer, pDomainName->Length );

        // Get the PDC for the domain if this is not the account domain
        //
        dwRetCode = DsGetDcName(
                         NULL,
                         wchDomain,
                         NULL,
                         NULL,
                         (DS_DIRECTORY_SERVICE_PREFERRED | DS_WRITABLE_REQUIRED),
                         &pDCInfo);

        if ( dwRetCode != NO_ERROR )
        {
            AFP_PRINT (("SFMSVC: AfpChange... DsGetDcName failed %lx\n",dwRetCode));
            return( STATUS_CANT_ACCESS_DOMAIN_INFO );
        }
        else
        {
            AFP_PRINT (("SFMSVC: AfpChange... DsGetDcName succeeded\n"));
        }

        AFP_PRINT (("SFMSVC: AfpChange... DsGetDcName: Got DC Name (%ws)\n",
                    pDCInfo->DomainControllerName));

        RtlInitUnicodeString(pPDCServerName, pDCInfo->DomainControllerName);

        DCName = pDCInfo->DomainControllerName;
    }
    else
    {
        AFP_PRINT (("SFMSVC: AfpChange... Do *not* require to call DsGetDcName\n"));

        pPDCServerName = NULL;

        DCName = NULL;
    }


    do
    {
        //
        // first and foremost: make sure this user can actually change pwd
        //
        if ((ntStatus= NetUserGetInfo( (LPWSTR)DCName,
                             pPassword->UserName,
                             1,
                             (LPBYTE*)&pUserInfo )) == NO_ERROR )
        {

            if ( ( pUserInfo->usri1_flags & UF_PASSWD_CANT_CHANGE )     ||
                 ( pUserInfo->usri1_flags & UF_LOCKOUT ) )
            {
                AFP_PRINT(("SFMSVC: can't change pwd: %s\n",
                    (pUserInfo->usri1_flags & UF_LOCKOUT) ?
                    "account is locked out" : "user not allowed to change pwd"));

                ntStatus = STATUS_ACCESS_DENIED;
                break;
            }
            else if ( pUserInfo->usri1_flags & UF_ACCOUNTDISABLE )
            {
                AFP_PRINT(("SFMSVC: can't change pwd: user account is disabled\n"));
                ntStatus = STATUS_ACCOUNT_DISABLED;
                break;
            }
        }
        else
        {
            AFP_PRINT(("SFMSVC: can't change pwd: NetUserGetInfo failed with error %ld\n", ntStatus));

            if (ntStatus == ERROR_ACCESS_DENIED)
            {
                ntStatus = STATUS_SUCCESS;
            }
            else
            {
                ntStatus = STATUS_PASSWORD_RESTRICTION;
                break;
            }
        }

        //
        // if this is a password change request coming from MSUAM Version 2 or 3
        // then we are getting passwords (and not OWFs) encrypted.  Use a
        // different scheme of changing password
        //
        if (pPassword->AuthentMode == CUSTOM_UAM_V2)
        {
            OemServerName.MaximumLength = OemServerName.Length = 0;
            OemUserName.MaximumLength = OemUserName.Length = 0;

            RtlInitUnicodeString( &UserName, pPassword->UserName );

            if (pPDCServerName)
            {
                ntStatus = RtlUnicodeStringToOemString(
                                    &OemServerName,
                                    pPDCServerName,
                                    TRUE             // allocate buffer
                                    );
                if (!NT_SUCCESS(ntStatus))
                {
                    AFP_PRINT(("SFMSVC: 1st Rtl..OemString failed %lx\n",ntStatus));
                    break;
                }

                pOemSrvName = &OemServerName;
            }
            else
            {
                pOemSrvName = NULL;
            }

            ntStatus = RtlUnicodeStringToOemString(
                                &OemUserName,
                                &UserName,
                                TRUE             // allocate buffer
                                );
            if (!NT_SUCCESS(ntStatus))
            {
                AFP_PRINT(("SFMSVC: 2nd Rtl..OemString failed %lx\n",ntStatus));
                break;
            }

            ntStatus = SamiOemChangePasswordUser2(
                            pOemSrvName,
                            &OemUserName,
                            (PSAMPR_ENCRYPTED_USER_PASSWORD)pPassword->NewPassword,
                            (PENCRYPTED_LM_OWF_PASSWORD)pPassword->OldPassword);

            AFP_PRINT(("SFMSVC: change pwd for MSUAM V2.0 user done, status = %lx\n",ntStatus));

            // done here
            break;
        }
        else if (pPassword->AuthentMode == CUSTOM_UAM_V3)
        {
            BOOLEAN LmPresent;

            RtlInitUnicodeString( &UserName, pPassword->UserName );

            if (pPassword->NtEncryptedBuff.Ciphers.h.Version != 1 && pPassword->NtEncryptedBuff.Ciphers.h.Version != 2)
            {
                ntStatus = STATUS_INVALID_PARAMETER;
                break;
            }

            LmPresent = pPassword->NtEncryptedBuff.Ciphers.h.Version == 2 ? TRUE : FALSE;

            ntStatus = SamiChangePasswordUser2(
                           pPDCServerName,
                           &UserName,
                           &pPassword->NtEncryptedBuff.Ciphers.m1.NewPasswordEncryptedWithOldNt,
                           &pPassword->NtEncryptedBuff.Ciphers.m1.OldNtOwfPasswordEncryptedWithNewNt,
                           LmPresent,
                           LmPresent ? &pPassword->NtEncryptedBuff.Ciphers.m2.NewPasswordEncryptedWithOldLm : NULL,
                           LmPresent ? &pPassword->NtEncryptedBuff.Ciphers.m2.OldLmOwfPasswordEncryptedWithNewLmOrNt : NULL
                           );
            AFP_PRINT(("SFMSVC: change pwd for MSUAM V3.0 user done, status = %#x\n", ntStatus));

            // done here
            break;
        }

        AFP_PRINT(("SFMSVC: AuthMode != MSUAM\n"));

        // Connect to the PDC of that domain
        //

        ntStatus = SamConnect(
                        pPDCServerName,
                        &hServer,
                        SAM_SERVER_EXECUTE,
                        &ObjectAttributes);

        if ( !NT_SUCCESS( ntStatus ))
        {
            AFP_PRINT(("SFMSVC: SamConnect to %ws failed %lx\n",
                (pPDCServerName)?pPDCServerName->Buffer:L"LOCAL",ntStatus));
            break;
        }

        // Get Sid of Domain and open the domain
        //
        ntStatus = SamOpenDomain(
                hServer,
                DOMAIN_EXECUTE,
                pDomainSid,
                &hDomain
                    );

        if ( !NT_SUCCESS( ntStatus ))
        {
            AFP_PRINT(("SFMSVC: SamOpenDomain failed %lx\n",ntStatus));
            break;
        }

        // Get this user's ID
        //
        RtlInitUnicodeString( &UserName, pPassword->UserName );

        ntStatus = SamLookupNamesInDomain(
                hDomain,
                1,
                &UserName,
                &pUserId,
                &pUse
                );

        if ( !NT_SUCCESS( ntStatus ))
        {
            AFP_PRINT(("SFMSVC: SamLookupNamesInDomain failed %lx\n",ntStatus));
            break;
        }

        // Open the user account for this user
        //
        ntStatus = SamOpenUser( hDomain,
                USER_CHANGE_PASSWORD,
                *pUserId,
                &hUser
                    );


        if ( !NT_SUCCESS( ntStatus ))
        {
            AFP_PRINT(("SFMSVC: SamOpenUser failed %lx\n",ntStatus));
            break;
        }

        // First get the minimum password length requred
        //
        ntStatus = SamQueryInformationDomain(
                    hDomain,
                    DomainPasswordInformation,
                    &pPasswordInfo
                    );

        if ( !NT_SUCCESS( ntStatus ) )
        {
            AFP_PRINT(("SFMSVC: SamQueryInformationDomain failed %lx\n",ntStatus));
            break;
        }


        // First we check to see if the passwords passed are in cleartext.
        // If they are, we need to calculate the OWF's for them.
        // (OWF = "One Way Function")
        //
        if ( pPassword->AuthentMode == CLEAR_TEXT_AUTHENT )
        {
            AFP_PRINT(("SFMSVC: AuthentMode == CLEAR_TEXT_AUTHENT\n"));


            // First check to see if the new password is long enough
            //

            if ( wcslen ( (PWCHAR)pPassword->NewPassword )
                < pPasswordInfo->MinPasswordLength ) {
                AFP_PRINT (("SFMSVC: NewPwdLen (%ld) < MinPwdLen (%ld)\n",
                            wcslen ( (PWCHAR)pPassword->NewPassword ),
                            pPasswordInfo->MinPasswordLength));
                ntStatus = STATUS_PWD_TOO_SHORT;
                break;
            }


            UOldPassword.Buffer = (PWCHAR)pPassword->OldPassword;
            UOldPassword.Length = UOldPassword.MaximumLength =
                (USHORT)pPassword->OldPasswordLen;

            UNewPassword.Buffer = (PWCHAR)pPassword->NewPassword;
            UNewPassword.Length = UNewPassword.MaximumLength =
                (USHORT)pPassword->NewPasswordLen;

#if 0
            AFP_PRINT (("SFMSVC: OldPwd = %Z, OldLen = (%ld), NewPwd = %Z, NewLen = (%ld)\n",
                        &UOldPassword,
                        UOldPassword.Length,
                        &UNewPassword,
                        UNewPassword.Length));
#endif

            AFP_PRINT(("SFMSVC: Calling SamChangePasswordUser2\n"));

            // Change the password for this user
            //
            ntStatus = SamChangePasswordUser2 (
                    pPDCServerName,
                    &UserName,
                    &UOldPassword,
                    &UNewPassword
                    );

            AFP_PRINT(("SFMSVC: SamChangePasswordUser2 returned %lx\n", ntStatus));

            break;
        }
        else
        {

            if (pPassword->bPasswordLength < pPasswordInfo->MinPasswordLength)
            {
                AFP_PRINT(("SFMSVC: AfpChangePasswordOnDomain: pwd is too short\n"));
                ntStatus = STATUS_PWD_TOO_SHORT;
                break;
            }
        }


        AFP_PRINT(("SFMSVC: Invalid UAM type\n"));
        ntStatus = STATUS_INVALID_PARAMETER;
        break;



    } while( FALSE );

    if ( pUserInfo != NULL )
    {
        NetApiBufferFree( pUserInfo );
    }

    if ( hServer != (SAM_HANDLE)NULL )
    {
        SamCloseHandle( hServer );
    }

    if ( hDomain != (SAM_HANDLE)NULL )
    {
        SamCloseHandle( hDomain );
    }

    if ( hUser != (SAM_HANDLE)NULL )
    {
        SamCloseHandle( hUser );
    }

    if ( pDomainInfo != NULL )
    {
        LsaFreeMemory( pDomainInfo );
    }

    if ( pUserId != (PULONG)NULL )
    {
        SamFreeMemory( pUserId );
    }

    if ( pUse != (PSID_NAME_USE)NULL )
    {
        SamFreeMemory( pUse );
    }

    if ( pPasswordInfo != (PDOMAIN_PASSWORD_INFORMATION)NULL )
    {
        SamFreeMemory( pPasswordInfo );
    }

    if (pDCInfo)
    {
        NetApiBufferFree(pDCInfo);
    }

    if (OemServerName.Buffer)
    {
        RtlFreeAnsiString(&OemServerName);
    }

    if (OemUserName.Buffer)
    {
        RtlFreeAnsiString(&OemUserName);
    }

    return( ntStatus );
}

//**
//
// Call:    AfpIOCTLDomainOffsets
//
// Returns: NT_SUCCESS
//      error return codes from LSA apis.
//
// Description: Will IOCTL a list of SIDs and corresponding POSIX offsets
//      of all trusted domains and other well known domains.
//
//
DWORD
AfpIOCTLDomainOffsets(
    IN LSA_HANDLE           hLsa,
    IN PPOLICY_ACCOUNT_DOMAIN_INFO  pAccountDomainInfo,
    IN PPOLICY_PRIMARY_DOMAIN_INFO  pPrimaryDomainInfo
)
{
    NTSTATUS            ntStatus;
    LSA_HANDLE          hLsaDomain;
    PTRUSTED_POSIX_OFFSET_INFO  pPosixOffset;
    PAFP_SID_OFFSET         pSidOffset;
    ULONG               cbSids;
    PBYTE               pbVariableData;
    AFP_SID_OFFSET          pWellKnownSids[20];
    DWORD               dwIndex;
    DWORD               dwCount;
    AFP_REQUEST_PACKET      AfpRequestPkt;
    PAFP_SID_OFFSET_DESC        pAfpSidOffsets  = NULL;
    DWORD               cbSidOffsets;
    DWORD               dwRetCode;


    // Null this array out.
    //
    ZeroMemory( pWellKnownSids, sizeof(AFP_SID_OFFSET)*20 );

    // This is a dummy loop used only so that the break statement may
    // be used to localize all the clean up in one place.
    //
    do {

        // Create all the well known SIDs
        //
        ntStatus = AfpCreateWellknownSids( pWellKnownSids );

        if ( !NT_SUCCESS( ntStatus ) )
        {
            break;
        }

        // Add the size of the all the well known SIDS
        //
        for( dwCount = 0, cbSids = 0;
             pWellKnownSids[dwCount].pSid != (PBYTE)NULL;
             dwCount++ )
        {
            cbSids += RtlLengthSid( (PSID)(pWellKnownSids[dwCount].pSid) );
        }

        // Insert the SID of the Account domain if is is not an advanced server
        //
        if ( pAccountDomainInfo != NULL )
        {
            cbSids += RtlLengthSid( pAccountDomainInfo->DomainSid );
            dwCount++;
        }

        // Add the primary domain Sids only if this machine
        // is a member of a domain.
        //
        if ( pPrimaryDomainInfo != NULL )
        {
            cbSids += RtlLengthSid( pPrimaryDomainInfo->Sid );
            dwCount++;
        }

        // OK, now allocate space for all these SIDS plus their offsets
        //
        cbSidOffsets = (dwCount * sizeof(AFP_SID_OFFSET)) + cbSids +
                   (sizeof(AFP_SID_OFFSET_DESC) - sizeof(AFP_SID_OFFSET));


        pAfpSidOffsets = (PAFP_SID_OFFSET_DESC)LocalAlloc( LPTR, cbSidOffsets );

        if ( pAfpSidOffsets == NULL )
        {
            ntStatus = STATUS_NO_MEMORY ;
            break;
        }

        // First insert all the well known SIDS
        //
        for( dwIndex = 0,
             pAfpSidOffsets->CountOfSidOffsets = dwCount,
             pSidOffset = pAfpSidOffsets->SidOffsetPairs,
             pbVariableData = (LPBYTE)pAfpSidOffsets + cbSidOffsets;

             pWellKnownSids[dwIndex].pSid != (PBYTE)NULL;

             dwIndex++ )
        {

            pbVariableData-=RtlLengthSid((PSID)(pWellKnownSids[dwIndex].pSid));

            ntStatus = AfpInsertSidOffset(
                        pSidOffset++,
                            pbVariableData,
                        (PSID)(pWellKnownSids[dwIndex].pSid),
                        pWellKnownSids[dwIndex].Offset,
                        pWellKnownSids[dwIndex].SidType );

            if ( !NT_SUCCESS( ntStatus ) )
            {
                break;
            }
        }

        if ( !NT_SUCCESS( ntStatus ) )
        {
            break;
        }

        // Now insert the Account domain's SID/OFFSET pair if there is one
        //
        if ( pAccountDomainInfo != NULL )
        {
            pbVariableData -= RtlLengthSid( pAccountDomainInfo->DomainSid );

            ntStatus = AfpInsertSidOffset(
                        pSidOffset++,
                        pbVariableData,
                        pAccountDomainInfo->DomainSid,
                        SE_ACCOUNT_DOMAIN_POSIX_OFFSET,
                        AFP_SID_TYPE_DOMAIN );

            if ( !NT_SUCCESS( ntStatus ) )
            {
                break;
            }

            // Construct the "None" sid if we are a standalone server (i.e. not
            // a PDC or BDC).  This will be used when querying the group ID of
            // a directory so the the UI will never show this group to the user.
            //
            if ( AfpGlobals.NtProductType != NtProductLanManNt )
            {
                ULONG SubAuthCount, SizeNoneSid = 0;

                SubAuthCount = *RtlSubAuthorityCountSid(pAccountDomainInfo->DomainSid);

                SizeNoneSid = RtlLengthRequiredSid(SubAuthCount + 1);

                if ((AfpGlobals.pSidNone = (PSID)LocalAlloc(LPTR,SizeNoneSid)) == NULL)
                {
                    ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                    break;
                }

                RtlCopySid(SizeNoneSid, AfpGlobals.pSidNone, pAccountDomainInfo->DomainSid);

                // Add the relative ID
                *RtlSubAuthorityCountSid(AfpGlobals.pSidNone) = (UCHAR)(SubAuthCount+1);

                // Note that the "None" sid on standalone is the same as the
                // "Domain Users" Sid on PDC/BDC. (On PDC/BDC the primary
                // domain is the same as the account domain).
                *RtlSubAuthoritySid(AfpGlobals.pSidNone, SubAuthCount) = DOMAIN_GROUP_RID_USERS;

            }

        }

        // Now insert the primary domain if this machine is a member of a domain
        //
        if ( pPrimaryDomainInfo != NULL )
        {

            // Insert the primary domain's SID/OFFSET pair
            //
            pbVariableData -= RtlLengthSid( pPrimaryDomainInfo->Sid );

            ntStatus = AfpInsertSidOffset(
                        pSidOffset++,
                        pbVariableData,
                        pPrimaryDomainInfo->Sid,
                        SE_PRIMARY_DOMAIN_POSIX_OFFSET,
                        AFP_SID_TYPE_PRIMARY_DOMAIN );

            if ( !NT_SUCCESS( ntStatus ) )
            {
                break;
            }
        }

    } while( FALSE );


    // IOCTL down the information if all was OK
    //
    if ( NT_SUCCESS( ntStatus ) )
    {
        AfpRequestPkt.dwRequestCode           = OP_SERVER_ADD_SID_OFFSETS;
        AfpRequestPkt.dwApiType           = AFP_API_TYPE_ADD;
        AfpRequestPkt.Type.SetInfo.pInputBuf  = pAfpSidOffsets;
        AfpRequestPkt.Type.Add.cbInputBufSize = cbSidOffsets;

        dwRetCode = AfpServerIOCtrl( &AfpRequestPkt );
    }
    else
    {
        dwRetCode = RtlNtStatusToDosError( ntStatus );
    }

    if ( pAfpSidOffsets != NULL )
    {
        LocalFree( pAfpSidOffsets );
    }

    // Free all the well known SIDS
    //
    for( dwIndex = 0;
         pWellKnownSids[dwIndex].pSid != (PBYTE)NULL;
         dwIndex++ )
    {
        RtlFreeSid( (PSID)(pWellKnownSids[dwIndex].pSid) );
    }

    return( dwRetCode );

}

//**
//
// Call:    AfpInsertSidOffset
//
// Returns: NT_SUCCESS
//      error return codes from RtlCopySid
//
// Description: Will insert a SID/OFFSET pair in the slot pointed to by
//      pSidOffset. The pbVariableData will point to where the
//      SID will be stored.
//
NTSTATUS
AfpInsertSidOffset(
    IN PAFP_SID_OFFSET pSidOffset,
    IN LPBYTE      pbVariableData,
    IN PSID        pSid,
    IN DWORD       Offset,
    IN AFP_SID_TYPE    afpSidType
)
{
NTSTATUS ntStatus;

    // Copy the offset
    //
    pSidOffset->Offset = Offset;

    // Set the SID type
    //
    pSidOffset->SidType = afpSidType;

    // Copy Sid at the end of the buffer and set the offset to it
    //
    ntStatus = RtlCopySid( RtlLengthSid( pSid ), pbVariableData, pSid );

    if ( !NT_SUCCESS( ntStatus ) )
     return( ntStatus );

    pSidOffset->pSid = pbVariableData;

    POINTER_TO_OFFSET( (pSidOffset->pSid), pSidOffset );

    return( STATUS_SUCCESS );

}

//**
//
// Call:    AfpCreateWellknownSids
//
// Returns: NT_SUCCESS
//      STATUS_NO_MEMORY
//      non-zero returns from RtlAllocateAndInitializeSid
//
// Description: Will allocate and initialize all well known SIDs.
//      The array is terminated by a NULL pointer.
//
NTSTATUS
AfpCreateWellknownSids(
    OUT AFP_SID_OFFSET pWellKnownSids[]
)
{
PSID                pSid;
DWORD               dwIndex = 0;
NTSTATUS            ntStatus;
SID_IDENTIFIER_AUTHORITY    NullSidAuthority   = SECURITY_NULL_SID_AUTHORITY;
SID_IDENTIFIER_AUTHORITY    WorldSidAuthority  = SECURITY_WORLD_SID_AUTHORITY;
SID_IDENTIFIER_AUTHORITY    LocalSidAuthority  = SECURITY_LOCAL_SID_AUTHORITY;
SID_IDENTIFIER_AUTHORITY    CreatorSidAuthority= SECURITY_CREATOR_SID_AUTHORITY;
SID_IDENTIFIER_AUTHORITY    NtAuthority        = SECURITY_NT_AUTHORITY;

    do {

    //
        // OK, create all the well known SIDS
        //

    // Create NULL SID
    //
    ntStatus = RtlAllocateAndInitializeSid(
                    &NullSidAuthority,
                        1,
                    SECURITY_NULL_RID,
                    0,0,0,0,0,0,0,
                        &pSid );

        if ( !NT_SUCCESS( ntStatus ) )
        break;

    pWellKnownSids[dwIndex].pSid    = (PBYTE)pSid;
    pWellKnownSids[dwIndex].Offset  = SE_NULL_POSIX_ID;
    pWellKnownSids[dwIndex].SidType = AFP_SID_TYPE_WELL_KNOWN;
    dwIndex++;

    // Create WORLD SID
    //
    ntStatus = RtlAllocateAndInitializeSid(
                    &WorldSidAuthority,
                        1,
                    SECURITY_WORLD_RID,
                    0,0,0,0,0,0,0,
                        &pSid );

        if ( !NT_SUCCESS( ntStatus ) )
        break;

    pWellKnownSids[dwIndex].pSid    = (PBYTE)pSid;
    pWellKnownSids[dwIndex].Offset  = SE_WORLD_POSIX_ID;
    pWellKnownSids[dwIndex].SidType = AFP_SID_TYPE_WELL_KNOWN;
    dwIndex++;

    // Create LOCAL SID
    //
    ntStatus = RtlAllocateAndInitializeSid(
                    &LocalSidAuthority,
                        1,
                    SECURITY_LOCAL_RID,
                    0,0,0,0,0,0,0,
                        &pSid );

        if ( !NT_SUCCESS( ntStatus ) )
        break;

    pWellKnownSids[dwIndex].pSid    = (PBYTE)pSid;
    pWellKnownSids[dwIndex].Offset  = SE_LOCAL_POSIX_ID;
    pWellKnownSids[dwIndex].SidType = AFP_SID_TYPE_WELL_KNOWN;
    dwIndex++;

    // Create CREATOR OWNER SID
    //
    ntStatus = RtlAllocateAndInitializeSid(
                    &CreatorSidAuthority,
                        1,
                    SECURITY_CREATOR_OWNER_RID,
                    0,0,0,0,0,0,0,
                        &pSid );

        if ( !NT_SUCCESS( ntStatus ) )
        break;

    pWellKnownSids[dwIndex].pSid    = (PBYTE)pSid;
    pWellKnownSids[dwIndex].Offset  = SE_CREATOR_OWNER_POSIX_ID;
    pWellKnownSids[dwIndex].SidType = AFP_SID_TYPE_WELL_KNOWN;
    dwIndex++;

    // Create CREATOR GROUP SID
    //
    ntStatus = RtlAllocateAndInitializeSid(
                    &CreatorSidAuthority,
                        1,
                    SECURITY_CREATOR_GROUP_RID,
                    0,0,0,0,0,0,0,
                        &pSid );

        if ( !NT_SUCCESS( ntStatus ) )
        break;

    pWellKnownSids[dwIndex].pSid    = (PBYTE)pSid;
    pWellKnownSids[dwIndex].Offset  = SE_CREATOR_GROUP_POSIX_ID;
    pWellKnownSids[dwIndex].SidType = AFP_SID_TYPE_WELL_KNOWN;
    dwIndex++;

    // Create SECURITY_NT_AUTHORITY Sid
    //
    ntStatus = RtlAllocateAndInitializeSid(
                    &NtAuthority,
                    0,0,0,0,0,0,0,0,0,
                        &pSid );

        if ( !NT_SUCCESS( ntStatus ) )
        break;

    pWellKnownSids[dwIndex].pSid    = (PBYTE)pSid;
    pWellKnownSids[dwIndex].Offset  = SE_AUTHORITY_POSIX_ID;
    pWellKnownSids[dwIndex].SidType = AFP_SID_TYPE_WELL_KNOWN;
    dwIndex++;

    // Create SECURITY_DIALUP Sid
    //
    ntStatus = RtlAllocateAndInitializeSid(
                    &NtAuthority,
                    1,
                    SECURITY_DIALUP_RID,
                    0,0,0,0,0,0,0,
                        &pSid );

        if ( !NT_SUCCESS( ntStatus ) )
        break;

    pWellKnownSids[dwIndex].pSid    = (PBYTE)pSid;
    pWellKnownSids[dwIndex].Offset  = SE_DIALUP_POSIX_ID;
    pWellKnownSids[dwIndex].SidType = AFP_SID_TYPE_WELL_KNOWN;
    dwIndex++;

    // Create SECURITY_NETWORK Sid
    //
    ntStatus = RtlAllocateAndInitializeSid(
                    &NtAuthority,
                    1,
                    SECURITY_NETWORK_RID,
                    0,0,0,0,0,0,0,
                        &pSid );

        if ( !NT_SUCCESS( ntStatus ) )
        break;

    pWellKnownSids[dwIndex].pSid    = (PBYTE)pSid;
    pWellKnownSids[dwIndex].Offset  = SE_NETWORK_POSIX_ID;
    pWellKnownSids[dwIndex].SidType = AFP_SID_TYPE_WELL_KNOWN;
    dwIndex++;

    // Create SECURITY_BATCH Sid
    //
    ntStatus = RtlAllocateAndInitializeSid(
                    &NtAuthority,
                    1,
                    SECURITY_BATCH_RID,
                    0,0,0,0,0,0,0,
                        &pSid );

        if ( !NT_SUCCESS( ntStatus ) )
        break;

    pWellKnownSids[dwIndex].pSid    = (PBYTE)pSid;
    pWellKnownSids[dwIndex].Offset  = SE_NETWORK_POSIX_ID;
    pWellKnownSids[dwIndex].SidType = AFP_SID_TYPE_WELL_KNOWN;
    dwIndex++;

    // Create SECURITY_INTERACTIVE Sid
    //
    ntStatus = RtlAllocateAndInitializeSid(
                    &NtAuthority,
                    1,
                    SECURITY_INTERACTIVE_RID,
                    0,0,0,0,0,0,0,
                        &pSid );

        if ( !NT_SUCCESS( ntStatus ) )
        break;

    pWellKnownSids[dwIndex].pSid    = (PBYTE)pSid;
    pWellKnownSids[dwIndex].Offset  = SE_INTERACTIVE_POSIX_ID;
    pWellKnownSids[dwIndex].SidType = AFP_SID_TYPE_WELL_KNOWN;
    dwIndex++;

    // Create SECURITY_SERVICE Sid
    //
    ntStatus = RtlAllocateAndInitializeSid(
                    &NtAuthority,
                    1,
                    SECURITY_SERVICE_RID,
                    0,0,0,0,0,0,0,
                        &pSid );

        if ( !NT_SUCCESS( ntStatus ) )
        break;

    pWellKnownSids[dwIndex].pSid    = (PBYTE)pSid;
    pWellKnownSids[dwIndex].Offset  = SE_SERVICE_POSIX_ID;
    pWellKnownSids[dwIndex].SidType = AFP_SID_TYPE_WELL_KNOWN;
    dwIndex++;

    // Create the built in domain SID
    //
    ntStatus = RtlAllocateAndInitializeSid(
                    &NtAuthority,
                    1,
                        SECURITY_BUILTIN_DOMAIN_RID,
                    0,0,0,0,0,0,0,
                        &pSid );

        if ( !NT_SUCCESS( ntStatus ) )
        break;

    pWellKnownSids[dwIndex].pSid    = (PBYTE)pSid;
    pWellKnownSids[dwIndex].Offset  = SE_BUILT_IN_DOMAIN_POSIX_OFFSET;
    pWellKnownSids[dwIndex].SidType = AFP_SID_TYPE_DOMAIN;
    dwIndex++;

    pWellKnownSids[dwIndex].pSid   = (PBYTE)NULL;


    } while( FALSE );

    if ( !NT_SUCCESS( ntStatus ) ) {

    while( dwIndex > 0 )
        RtlFreeSid( pWellKnownSids[--dwIndex].pSid );
    }

    return( ntStatus );
}



//**
//
// Call:    AfpChangePwdArapStyle
//
// Returns: return code
//
// Description: This procedure will try to change the user's password on a
//      specified domain. This does it only for native Apple UAM clients
//      i.e., the user's password is stored in the DS in a reversibly-encrypted
//      form, and the client sends the old and the new password (not owf as in
//      MS-UAM case).  This is what ARAP does, that's why the name.
//      This function is big time cut-n-paste from the ARAP code
//
NTSTATUS
AfpChangePwdArapStyle(
        IN PAFP_PASSWORD_DESC   pPassword,
        IN PUNICODE_STRING      pDomainName,
        IN PSID                 pDomainSid
)
{

    NTSTATUS                        status;
    NTSTATUS                        PStatus;
    PMSV1_0_PASSTHROUGH_REQUEST     pPassThruReq;
    PMSV1_0_SUBAUTH_REQUEST         pSubAuthReq;
    PMSV1_0_PASSTHROUGH_RESPONSE    pPassThruResp;
    PMSV1_0_SUBAUTH_RESPONSE        pSubAuthResp;
    DWORD                           dwSubmitBufLen;
    DWORD                           dwSubmitBufOffset;
    PRAS_SUBAUTH_INFO               pRasSubAuthInfo;
    PARAP_SUBAUTH_REQ               pArapSubAuthInfo;
    ARAP_SUBAUTH_RESP               ArapResp;
    PARAP_SUBAUTH_RESP              pArapRespBuffer;
    PVOID                           RetBuf;
    DWORD                           dwRetBufLen;



    // if our registeration with lsa process failed at init time, or if
    // there is no domain name for this user, just fail the succer
    // (if the user logged on successfully using native Apple UAM, then
    // there had better be a domain!)
    if ((SfmLsaHandle == NULL) ||(pDomainName == NULL))
    {
        return(STATUS_LOGON_FAILURE);
    }

    if (pDomainName != NULL)
    {
        if (pDomainName->Length == 0)
        {
            return(STATUS_LOGON_FAILURE);
        }
    }

    dwSubmitBufLen = sizeof(MSV1_0_PASSTHROUGH_REQUEST)         +
                        sizeof(WCHAR)*(MAX_ARAP_USER_NAMELEN+1) +  // domain name
                        sizeof(TEXT(MSV1_0_PACKAGE_NAME))       +  // package name
                        sizeof(MSV1_0_SUBAUTH_REQUEST)          +
                        sizeof(RAS_SUBAUTH_INFO)                +
                        sizeof(ARAP_SUBAUTH_REQ)                +
                        ALIGN_WORST;                               // for alignment

    pPassThruReq = (PMSV1_0_PASSTHROUGH_REQUEST)
                    GlobalAlloc(GMEM_FIXED, dwSubmitBufLen);

    if (!pPassThruReq)
    {
        return (STATUS_INSUFFICIENT_RESOURCES);
    }

    RtlZeroMemory((PBYTE)pPassThruReq, dwSubmitBufLen);

    //
    // Set up the MSV1_0_PASSTHROUGH_REQUEST structure
    //

    // tell MSV that it needs to visit our subauth pkg (for change pwd)
    pPassThruReq->MessageType = MsV1_0GenericPassthrough;


    pPassThruReq->DomainName.Length = pDomainName->Length;

    pPassThruReq->DomainName.MaximumLength =
            (sizeof(WCHAR) * (MAX_ARAP_USER_NAMELEN+1));

    pPassThruReq->DomainName.Buffer = (PWSTR) (pPassThruReq + 1);

    RtlMoveMemory(pPassThruReq->DomainName.Buffer,
                  pDomainName->Buffer,
                  pPassThruReq->DomainName.Length);

    pPassThruReq->PackageName.Length =
                        (sizeof(WCHAR) * wcslen(TEXT(MSV1_0_PACKAGE_NAME)));

    pPassThruReq->PackageName.MaximumLength = sizeof(TEXT(MSV1_0_PACKAGE_NAME));

    pPassThruReq->PackageName.Buffer =
        (PWSTR)((PBYTE)(pPassThruReq->DomainName.Buffer) +
                 pPassThruReq->DomainName.MaximumLength);

    RtlMoveMemory(pPassThruReq->PackageName.Buffer,
                  TEXT(MSV1_0_PACKAGE_NAME),
                  sizeof(TEXT(MSV1_0_PACKAGE_NAME)));

    pPassThruReq->DataLength = sizeof(MSV1_0_SUBAUTH_REQUEST) +
                    sizeof(RAS_SUBAUTH_INFO) + sizeof(ARAP_SUBAUTH_REQ);

    pPassThruReq->LogonData =
            ROUND_UP_POINTER( ((PBYTE)pPassThruReq->PackageName.Buffer +
                                pPassThruReq->PackageName.MaximumLength),
                                ALIGN_WORST );

    if (pPassThruReq->LogonData >= ((PCHAR)pPassThruReq + dwSubmitBufLen))
    {
            AFP_PRINT (("srvrhlpr.c: Error in ROUND_UP_POINTER\n"));
            GlobalFree((HGLOBAL)pPassThruReq);
            return STATUS_INVALID_BUFFER_SIZE;
    }

    pSubAuthReq = (PMSV1_0_SUBAUTH_REQUEST)pPassThruReq->LogonData;

    pSubAuthReq->MessageType = MsV1_0SubAuth;
    pSubAuthReq->SubAuthPackageId = MSV1_0_SUBAUTHENTICATION_DLL_RAS;

    pSubAuthReq->SubAuthInfoLength =
                        sizeof(RAS_SUBAUTH_INFO) + sizeof(ARAP_SUBAUTH_REQ);

    //
    // this pointer is self-relative
    //
    pSubAuthReq->SubAuthSubmitBuffer = (PUCHAR)sizeof(MSV1_0_SUBAUTH_REQUEST);


    //
    // copy the structure our subauth pkg will use at the other end
    //
    pRasSubAuthInfo = (PRAS_SUBAUTH_INFO)(pSubAuthReq + 1);


    pRasSubAuthInfo->ProtocolType = RAS_SUBAUTH_PROTO_ARAP;
    pRasSubAuthInfo->DataSize = sizeof(ARAP_SUBAUTH_REQ);

    pArapSubAuthInfo = (PARAP_SUBAUTH_REQ)&pRasSubAuthInfo->Data[0];

    pArapSubAuthInfo->PacketType = SFM_SUBAUTH_CHGPWD_PKT;

    if (wcslen(pPassword->UserName) > MAX_ARAP_USER_NAMELEN)
    {
            AFP_PRINT (("srvrhlpr.c: Username greater than 32 characters\n"));
            GlobalFree((HGLOBAL)pPassThruReq);
            return STATUS_INVALID_PARAMETER;
    }

    wcsncpy(pArapSubAuthInfo->ChgPwd.UserName, pPassword->UserName, MAX_ARAP_USER_NAMELEN);
    pArapSubAuthInfo->ChgPwd.UserName[wcslen(pPassword->UserName)] = L'\0';

    RtlCopyMemory(pArapSubAuthInfo->ChgPwd.OldMunge,
                  pPassword->OldPassword,
                  MAX_MAC_PWD_LEN);

    pArapSubAuthInfo->ChgPwd.OldMunge[MAX_MAC_PWD_LEN] = 0;

    RtlCopyMemory(pArapSubAuthInfo->ChgPwd.NewMunge,
                  pPassword->NewPassword,
                  MAX_MAC_PWD_LEN);

    pArapSubAuthInfo->ChgPwd.NewMunge[MAX_MAC_PWD_LEN] = 0;

    //
    // whew! finally done setting up all the parms: now call that api
    //

    status = LsaCallAuthenticationPackage (
                        SfmLsaHandle,
                        SfmAuthPkgId,
                        pPassThruReq,
                        dwSubmitBufLen,
                        &RetBuf,
                        &dwRetBufLen,
                        &PStatus);

    if (status != STATUS_SUCCESS || PStatus != STATUS_SUCCESS)
    {
        GlobalFree((HGLOBAL)pPassThruReq);

        if (status == STATUS_SUCCESS)
        {
            status = PStatus;
        }
        return(status);
    }


    pPassThruResp = (PMSV1_0_PASSTHROUGH_RESPONSE)RetBuf;

    pSubAuthResp = (PMSV1_0_SUBAUTH_RESPONSE)(pPassThruResp->ValidationData);


    // our return buffer is in self-relative format
    pArapRespBuffer = (PARAP_SUBAUTH_RESP)((PBYTE)pSubAuthResp +
                           (ULONG_PTR)(pSubAuthResp->SubAuthReturnBuffer));


    RtlCopyMemory(&ArapResp,
                  (PUCHAR)pArapRespBuffer,
                  pSubAuthResp->SubAuthInfoLength);


    GlobalFree((HGLOBAL)pPassThruReq);

    LsaFreeReturnBuffer(RetBuf);

    if(ArapResp.Result != 0)
    {
        return(STATUS_UNSUCCESSFUL);
    }

    return(STATUS_SUCCESS);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\service\server\stats.c ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.	   **/
/********************************************************************/

//***
//
// Filename:	stats.c
//
// Description: This module contains support routines for the statistics
//		category API's for the AFP server service. These routines
//		are called by the RPC runtime.
//
// History:
//		July 21,1992.	NarenG		Created original version.
//
#include "afpsvcp.h"

//**
//
// Call:	AfpAdminrStatisticsGet
//
// Returns:	NO_ERROR
//		ERROR_ACCESS_DENIED
//		non-zero returns from AfpServerIOCtrlGetInfo
//
// Description: This routine communicates with the AFP FSD to implement
//		the AfpAdminStatisticsGet function.
//
DWORD
AfpAdminrStatisticsGet(
	IN  AFP_SERVER_HANDLE     hServer,
	OUT PAFP_STATISTICS_INFO* ppAfpStatisticsInfo
)
{
AFP_REQUEST_PACKET AfpSrp;
DWORD		    dwRetCode=0;
DWORD		    dwAccessStatus=0;
AFP_STATISTICS_INFO afpStats;


    // Check if caller has access
    //
    if ( dwRetCode = AfpSecObjAccessCheck( AFPSVC_ALL_ACCESS, &dwAccessStatus))
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrStatisticsGet, AfpSecObjAccessCheck failed %ld\n",dwRetCode));
	    AfpLogEvent( AFPLOG_CANT_CHECK_ACCESS, 0, NULL,
		     dwRetCode, EVENTLOG_ERROR_TYPE );
        return( ERROR_ACCESS_DENIED );
    }

    if ( dwAccessStatus )
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrStatisticsGet, AfpSecObjAccessCheck returned %ld\n",dwAccessStatus));
        return( ERROR_ACCESS_DENIED );
    }

    // Set up request packet and make IOCTL to the FSD
    //
    AfpSrp.dwRequestCode 		= OP_GET_STATISTICS;
    AfpSrp.dwApiType     		= AFP_API_TYPE_GETINFO;
    AfpSrp.Type.GetInfo.pInputBuf     	= &afpStats;
    AfpSrp.Type.GetInfo.cbInputBufSize  = sizeof( afpStats );

    dwRetCode = AfpServerIOCtrlGetInfo( &AfpSrp );

    if ( dwRetCode != ERROR_MORE_DATA && dwRetCode != NO_ERROR )
	return( dwRetCode );

    *ppAfpStatisticsInfo = (PAFP_STATISTICS_INFO)AfpSrp.Type.GetInfo.pOutputBuf;

    return( dwRetCode );
}

//**
//
// Call:	AfpAdminrStatisticsGetEx
//
// Returns:	NO_ERROR
//		ERROR_ACCESS_DENIED
//		non-zero returns from AfpServerIOCtrlGetInfo
//
// Description: This routine communicates with the AFP FSD to implement
//		the AfpAdminStatisticsGet function.
//
DWORD
AfpAdminrStatisticsGetEx(
	IN  AFP_SERVER_HANDLE     hServer,
	OUT PAFP_STATISTICS_INFO_EX* ppAfpStatisticsInfo
)
{
AFP_REQUEST_PACKET AfpSrp;
DWORD		    dwRetCode=0;
DWORD		    dwAccessStatus=0;
AFP_STATISTICS_INFO_EX afpStats;


    // Check if caller has access
    //
    if ( dwRetCode = AfpSecObjAccessCheck( AFPSVC_ALL_ACCESS, &dwAccessStatus))
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrStatisticsGetEx, AfpSecObjAccessCheck failed %ld\n",dwRetCode));
	    AfpLogEvent( AFPLOG_CANT_CHECK_ACCESS, 0, NULL,
		     dwRetCode, EVENTLOG_ERROR_TYPE );
        return( ERROR_ACCESS_DENIED );
    }

    if ( dwAccessStatus )
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrStatisticsGetEx, AfpSecObjAccessCheck returned %ld\n",dwAccessStatus));
        return( ERROR_ACCESS_DENIED );
    }

    // Set up request packet and make IOCTL to the FSD
    //
    AfpSrp.dwRequestCode 		= OP_GET_STATISTICS_EX;
    AfpSrp.dwApiType     		= AFP_API_TYPE_GETINFO;
    AfpSrp.Type.GetInfo.pInputBuf     	= &afpStats;
    AfpSrp.Type.GetInfo.cbInputBufSize  = sizeof( afpStats );

    dwRetCode = AfpServerIOCtrlGetInfo( &AfpSrp );

    if ( dwRetCode != ERROR_MORE_DATA && dwRetCode != NO_ERROR )
	return( dwRetCode );

    *ppAfpStatisticsInfo = (PAFP_STATISTICS_INFO_EX)AfpSrp.Type.GetInfo.pOutputBuf;

    return( dwRetCode );
}

//**
//
// Call:	AfpAdminrStatisticsClear
//
// Returns:	NO_ERROR
//		ERROR_ACCESS_DENIED
//		non-zero returns from AfpServerIOCtrlGetInfo
//
// Description: This routine communicates with the AFP FSD to implement
//		the AfpAdminFileClose function.
//
DWORD
AfpAdminrStatisticsClear(
	IN AFP_SERVER_HANDLE 	hServer
)
{
AFP_REQUEST_PACKET AfpSrp;
DWORD		   dwAccessStatus=0;
DWORD		   dwRetCode=0;

    // Check if caller has access
    //
    if ( dwRetCode = AfpSecObjAccessCheck( AFPSVC_ALL_ACCESS, &dwAccessStatus))
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrStatisticsClear, AfpSecObjAccessCheck failed %ld\n",dwRetCode));
	    AfpLogEvent( AFPLOG_CANT_CHECK_ACCESS, 0, NULL,
		     dwRetCode, EVENTLOG_ERROR_TYPE );
        return( ERROR_ACCESS_DENIED );
    }

    if ( dwAccessStatus )
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrStatisticsClear, AfpSecObjAccessCheck returned %ld\n",dwAccessStatus));
        return( ERROR_ACCESS_DENIED );
    }

    // IOCTL the FSD to clear the statistics
    //
    AfpSrp.dwRequestCode = OP_CLEAR_STATISTICS;
    AfpSrp.dwApiType     = AFP_API_TYPE_COMMAND;

    return ( AfpServerIOCtrl( &AfpSrp ) );
}



//**
//
// Call:	AfpAdminrProfileGet
//
// Returns:	NO_ERROR
//		ERROR_ACCESS_DENIED
//		non-zero returns from AfpServerIOCtrlGetInfo
//
// Description: This routine communicates with the AFP FSD to implement
//		the AfpAdminProfileGet function.
//
DWORD
AfpAdminrProfileGet(
	IN  AFP_SERVER_HANDLE     hServer,
	OUT PAFP_PROFILE_INFO *   ppAfpProfileInfo
)
{
AFP_REQUEST_PACKET AfpSrp;
DWORD		    dwRetCode=0;
DWORD		    dwAccessStatus=0;
AFP_PROFILE_INFO afpProfs;


    // Check if caller has access
    //
    if ( dwRetCode = AfpSecObjAccessCheck( AFPSVC_ALL_ACCESS, &dwAccessStatus))
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrProfileGet, AfpSecObjAccessCheck failed %ld\n",dwRetCode));
	    AfpLogEvent( AFPLOG_CANT_CHECK_ACCESS, 0, NULL,
		     dwRetCode, EVENTLOG_ERROR_TYPE );
        return( ERROR_ACCESS_DENIED );
    }

    if ( dwAccessStatus )
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrProfileGet, AfpSecObjAccessCheck returned %ld\n",dwAccessStatus));
        return( ERROR_ACCESS_DENIED );
    }

    // Set up request packet and make IOCTL to the FSD
    //
    AfpSrp.dwRequestCode 		= OP_GET_PROF_COUNTERS;
    AfpSrp.dwApiType     		= AFP_API_TYPE_GETINFO;
    AfpSrp.Type.GetInfo.pInputBuf     	= &afpProfs;
    AfpSrp.Type.GetInfo.cbInputBufSize  = sizeof( afpProfs );

    dwRetCode = AfpServerIOCtrlGetInfo( &AfpSrp );

    if ( dwRetCode != ERROR_MORE_DATA && dwRetCode != NO_ERROR )
	return( dwRetCode );

    *ppAfpProfileInfo = (PAFP_PROFILE_INFO)AfpSrp.Type.GetInfo.pOutputBuf;

    return( dwRetCode );
}

//**
//
// Call:	AfpAdminrProfileClear
//
// Returns:	NO_ERROR
//		ERROR_ACCESS_DENIED
//		non-zero returns from AfpServerIOCtrlGetInfo
//
// Description: This routine communicates with the AFP FSD to implement
//		the AfpAdminProfileClear function.
//
DWORD
AfpAdminrProfileClear(
	IN AFP_SERVER_HANDLE 	hServer
)
{
AFP_REQUEST_PACKET AfpSrp;
DWORD		   dwAccessStatus=0;
DWORD		   dwRetCode=0;

    // Check if caller has access
    //
    if ( dwRetCode = AfpSecObjAccessCheck( AFPSVC_ALL_ACCESS, &dwAccessStatus))
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrProfileClear, AfpSecObjAccessCheck failed %ld\n",dwRetCode));
	    AfpLogEvent( AFPLOG_CANT_CHECK_ACCESS, 0, NULL,
		     dwRetCode, EVENTLOG_ERROR_TYPE );
        return( ERROR_ACCESS_DENIED );
    }

    if ( dwAccessStatus )
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrProfileClear, AfpSecObjAccessCheck returned %ld\n",dwAccessStatus));
        return( ERROR_ACCESS_DENIED );
    }

    // IOCTL the FSD to clear the statistics
    //
    AfpSrp.dwRequestCode = OP_CLEAR_PROF_COUNTERS;
    AfpSrp.dwApiType     = AFP_API_TYPE_COMMAND;

    return ( AfpServerIOCtrl( &AfpSrp ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\service\server\util.c ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.	   **/
/********************************************************************/

//***
//
// Filename:	util.c
//
// Description: This module contains misc. utility routines.
//		
// History: 	May 11,1992.	NarenG		Created original version.
//
#include <nt.h>
#include <ntioapi.h>
#include <ntrtl.h>
#include <ntobapi.h>
#include <nturtl.h>     // needed for winbase.h
#include <afpsvcp.h>

#define PRIVILEGE_BUF_SIZE  512

//**
//
// Call:	AfpFSDOpen
//
// Returns:	0		- success
//		non-zero returns mapped to WIN32 errors.
//
// Description: Opens the AFP file system driver. It is opened in exclusive
//		mode.
//		NTOpenFile is used instead of it's WIN32 counterpart, since
//		WIN32 always prpends \Dos\devices to the file name. The AFP FSD
//		driver is not a dos device.
//
DWORD
AfpFSDOpen(
	OUT PHANDLE	phFSD
)
{
NTSTATUS		ntRetCode;
OBJECT_ATTRIBUTES	ObjectAttributes;
UNICODE_STRING	 	FSDName;
IO_STATUS_BLOCK		IoStatus;

    RtlInitUnicodeString( &FSDName, AFPSERVER_DEVICE_NAME );

    InitializeObjectAttributes( &ObjectAttributes,
				&FSDName,
				OBJ_CASE_INSENSITIVE,
				NULL,
				NULL );
			
			
    ntRetCode = NtOpenFile(phFSD,
			   SYNCHRONIZE,
			   &ObjectAttributes,
			   &IoStatus,
#ifdef DBG
			   FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,
#else
			   0,
#endif
			   FILE_SYNCHRONOUS_IO_NONALERT );

    if ( NT_SUCCESS( ntRetCode ) )
	return( NO_ERROR );
    else
        return( RtlNtStatusToDosError( ntRetCode ) );
	
}

//**
//
// Call:	AfpFSDClose
//
// Returns:	0		- success
//		non-zero returns mapped to WIN32 errors.
//
// Description: Closes and the AFP file system driver.
//
DWORD
AfpFSDClose(
	IN HANDLE	hFSD
)
{
NTSTATUS	ntStatus;

    ntStatus = NtClose( hFSD );

    if ( !NT_SUCCESS( ntStatus ) )
        return( RtlNtStatusToDosError( ntStatus ) );

    return( NO_ERROR );
}

//**
//
// Call:	AfpFSDUnload
//
// Returns:	0		- success
//		non-zero returns mapped to WIN32 errors.
//
// Description: Unloads the AFP file system driver.
//
DWORD
AfpFSDUnload(
	VOID
)
{
NTSTATUS status;
LPWSTR registryPathBuffer;
UNICODE_STRING registryPath;

    registryPathBuffer = (LPWSTR)MIDL_user_allocate(
                                    sizeof(AFPSERVER_REGISTRY_KEY) );

    if ( registryPathBuffer == NULL )
        return ERROR_NOT_ENOUGH_MEMORY;

    wcscpy( registryPathBuffer, AFPSERVER_REGISTRY_KEY );

    RtlInitUnicodeString( &registryPath, registryPathBuffer );

	// Wait here for all the server helper threads to terminate
	if (AfpGlobals.nThreadCount > 0)
        WaitForSingleObject( AfpGlobals.heventSrvrHlprThreadTerminate, INFINITE );

    status = NtUnloadDriver( &registryPath );

    MIDL_user_free( registryPathBuffer );

    return( RtlNtStatusToDosError( status ));
}

//**
//
// Call:	AfpFSDLoad
//
// Returns:	0		- success
//		non-zero returns mapped to WIN32 errors.
//
// Description: Loads the AFP file system driver.
//
DWORD
AfpFSDLoad(
	VOID
)
{
NTSTATUS status;
LPWSTR registryPathBuffer;
UNICODE_STRING registryPath;
BOOLEAN fEnabled;

    registryPathBuffer = (LPWSTR)MIDL_user_allocate(
                                    sizeof(AFPSERVER_REGISTRY_KEY) );

    if ( registryPathBuffer == NULL )
        return ERROR_NOT_ENOUGH_MEMORY;

    status = RtlAdjustPrivilege( SE_LOAD_DRIVER_PRIVILEGE,
				 TRUE,
				 FALSE,
				 &fEnabled );

    if ( !NT_SUCCESS( status ) ) {
        MIDL_user_free( registryPathBuffer );
    	return( RtlNtStatusToDosError( status ));
    }

    wcscpy( registryPathBuffer, AFPSERVER_REGISTRY_KEY );

    RtlInitUnicodeString( &registryPath, registryPathBuffer );

    status = NtLoadDriver( &registryPath );

    MIDL_user_free( registryPathBuffer );

    if ( status == STATUS_IMAGE_ALREADY_LOADED )
	status = STATUS_SUCCESS;

    return( RtlNtStatusToDosError( status ));
}

//**
//
// Call:	AfpFSDIOControl
//
// Returns:	0		- success
//		AFPERR		- Macintosh specific errors.
//		non-zero returns mapped to WIN32 errors.
//		
//
// Description: Will ioctl the AFP FSD.
//		NtDeviceIoControlFile api is used to communicate with the FSD
//		instead of it's WIN32 counterpart because the WIN32 version
//		maps all return codes to WIN32 error codes. This runs into
//		problems when AFPERR_XXX error codes are returned.
//
DWORD
AfpFSDIOControl(
	IN  HANDLE	hFSD,
	IN  DWORD 	dwOpCode,
	IN  PVOID	pInbuf 		OPTIONAL,
	IN  DWORD	cbInbufLen,
	OUT PVOID	pOutbuf 	OPTIONAL,
	IN  DWORD	cbOutbufLen,
	OUT LPDWORD	lpcbBytesTransferred
)
{
NTSTATUS	 ntRetCode;
IO_STATUS_BLOCK	 IOStatus;


    ntRetCode = NtDeviceIoControlFile( 	   hFSD,
					   NULL,
					   NULL,
					   NULL,
					   &IOStatus,
					   dwOpCode,
					   pInbuf,
					   cbInbufLen,
					   pOutbuf,
					   cbOutbufLen );

    *lpcbBytesTransferred = (DWORD)(IOStatus.Information);

    if ( ntRetCode ) {

    	// If it is not an AFPERR_* then map it
    	//
    	if ( ( ntRetCode < AFPERR_BASE ) && ( ntRetCode >= AFPERR_MIN ) )
	    return( ntRetCode );
    	else
	    return( RtlNtStatusToDosError( ntRetCode ) );
    }
    else
	return( NO_ERROR );
}

//**
//
// Call:
//
// Returns:
//
// Description:
//
DWORD
AfpCreateServerHelperThread(
	BOOL fIsFirstThread
)
{
DWORD	dwId;

    if ( CreateThread(  NULL,
			0,
			AfpServerHelper,
			(LPVOID)((ULONG_PTR)fIsFirstThread),
			0,
			&dwId ) == NULL )
	return( GetLastError() );
    else
	return( NO_ERROR );
}

//**
//
// Call:
//
// Returns:
//
// Description:
//
VOID
AfpTerminateCurrentThread(
	VOID
)
{
    TerminateThread( GetCurrentThread(), NO_ERROR );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\sfmctrs\datasfm.c ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992  Microsoft Corporation

Module Name:

    datasfm.c

Abstract:

    a file containing the constant data structures used by the Performance
    Monitor data for the MacFile extensible counters.

    This file contains a set of constant data structures which are
    currently defined for the MacFile extensible counters.

Created:

    Russ Blake  26 Feb 93
	Sue Adams	03 Jun 93 - Adapt for use by MacFile counters

Revision History:

    Sue Adams	23 Feb 94 - Hard code counter and help indexes since these
							values are now part of the NT base system counter
	                        index values.

--*/
//
//  Include Files
//

#include <windows.h>
#include <winperf.h>
#include "datasfm.h"

//
//  Constant structure initializations
//      defined in datasfm.h
//

SFM_DATA_DEFINITION SfmDataDefinition = {

    {
		// TotalByteLength
		sizeof(SFM_DATA_DEFINITION) + SIZE_OF_SFM_PERFORMANCE_DATA,

		// DefinitionLength
		sizeof(SFM_DATA_DEFINITION),

		// HeaderLength
		sizeof(PERF_OBJECT_TYPE),

		// ObjectNameTitleIndex
		1000,

		// ObjectNameTitle
		0,

	   // ObjectHelpTitleIndex
	   1001,

	   // ObjectHelpTitle
	   0,

	   // DetailLevel
	   PERF_DETAIL_NOVICE,

	   // NumCounters
	   (sizeof(SFM_DATA_DEFINITION)-sizeof(PERF_OBJECT_TYPE)) / sizeof(PERF_COUNTER_DEFINITION),

	   // DefaultCounter
	   0,

	   // NumInstances
	   PERF_NO_INSTANCES,

	   // CodePage
	   0,

	   // PerfTime
	   {0,0},

	   // PerfFreq
	   {0,0}
   },
   {
	   // ByteLength
	   sizeof(PERF_COUNTER_DEFINITION),

	   // CounterNameTitleIndex
	   1002,

	   // CounterNameTitle
	   0,

	   // CounterHelpTitleIndex
	   1003,

	   // CounterHelpTitle
	   0,

	   // DefaultScale
	   -4,

	   // DetailLevel
	   PERF_DETAIL_NOVICE,

	   // CounterType
	   PERF_COUNTER_RAWCOUNT,

	   // CounterSize
	   sizeof(DWORD),

	   // CounterOffset
	   NUM_MAXPAGD_OFFSET
   },
   {
	   // ByteLength
	   sizeof(PERF_COUNTER_DEFINITION),

	   // CounterNameTitleIndex
	   1004,

	   // CounterNameTitle
	   0,

	   // CounterHelpTitleIndex
	   1005,

	   // CounterHelpTitle
	   0,

	   // DefaultScale
	   -4,

	   // DetailLevel
	   PERF_DETAIL_NOVICE,

	   // CounterType
	   PERF_COUNTER_RAWCOUNT,

	   // CounterSize
	   sizeof(DWORD),

	   // CounterOffset
	   NUM_CURPAGD_OFFSET
   },
   {
	   // ByteLength
	   sizeof(PERF_COUNTER_DEFINITION),

	   // CounterNameTitleIndex
	   1006,

	   // CounterNameTitle
	   0,

	   // CounterHelpTitleIndex
	   1007,

	   // CounterHelpTitle
	   0,

	   // DefaultScale
	   -4,

	   // DetailLevel
	   PERF_DETAIL_NOVICE,

	   // CounterType
	   PERF_COUNTER_RAWCOUNT,

	   // CounterSize
	   sizeof(DWORD),

	   // CounterOffset
	   NUM_MAXNONPAGD_OFFSET
   },
   {
	   // ByteLength
	   sizeof(PERF_COUNTER_DEFINITION),

	   // CounterNameTitleIndex
	   1008,

	   // CounterNameTitle
	   0,

	   // CounterHelpTitleIndex
	   1009,

	   // CounterHelpTitle
	   0,

	   // DefaultScale
	   -4,

	   // DetailLevel
	   PERF_DETAIL_NOVICE,

	   // CounterType
	   PERF_COUNTER_RAWCOUNT,

	   // CounterSize
	   sizeof(DWORD),

	   // CounterOffset
	   NUM_CURNONPAGD_OFFSET
   },
   {
	   // ByteLength
	   sizeof(PERF_COUNTER_DEFINITION),

	   // CounterNameTitleIndex
	   1010,

	   // CounterNameTitle
	   0,

	   // CounterHelpTitleIndex
	   1011,

	   // CounterHelpTitle
	   0,

	   // DefaultScale
	   0,

	   // DetailLevel
	   PERF_DETAIL_NOVICE,

	   // CounterType
	   PERF_COUNTER_RAWCOUNT,

	   // CounterSize
	   sizeof(DWORD),

	   // CounterOffset
	   NUM_CURSESSIONS_OFFSET
   },
   {
	   // ByteLength
	   sizeof(PERF_COUNTER_DEFINITION),

	   // CounterNameTitleIndex
	   1012,

	   // CounterNameTitle
	   0,

	   // CounterHelpTitleIndex
	   1013,

	   // CounterHelpTitle
	   0,

	   // DefaultScale
	   0,

	   // DetailLevel
	   PERF_DETAIL_NOVICE,

	   // CounterType
	   PERF_COUNTER_RAWCOUNT,

	   // CounterSize
	   sizeof(DWORD),

	   // CounterOffset
	   NUM_MAXSESSIONS_OFFSET
   },
   {
	   // ByteLength
	   sizeof(PERF_COUNTER_DEFINITION),

	   // CounterNameTitleIndex
	   1014,

	   // CounterNameTitle
	   0,

	   // CounterHelpTitleIndex
	   1015,

	   // CounterHelpTitle
	   0,

	   // DefaultScale
	   0,

	   // DetailLevel
	   PERF_DETAIL_WIZARD,

	   // CounterType
	   PERF_COUNTER_RAWCOUNT,

	   // CounterSize
	   sizeof(DWORD),

	   // CounterOffset
	   NUM_CURFILESOPEN_OFFSET
   },
   {
	   // ByteLength
	   sizeof(PERF_COUNTER_DEFINITION),

	   // CounterNameTitleIndex
	   1016,

	   // CounterNameTitle
	   0,

	   // CounterHelpTitleIndex
	   1017,

	   // CounterHelpTitle
	   0,

	   // DefaultScale
	   0,

	   // DetailLevel
	   PERF_DETAIL_WIZARD,

	   // CounterType
	   PERF_COUNTER_RAWCOUNT,

	   // CounterSize
	   sizeof(DWORD),

	   // CounterOffset
	   NUM_MAXFILESOPEN_OFFSET
   },
   {
	   // ByteLength
	   sizeof(PERF_COUNTER_DEFINITION),

	   // CounterNameTitleIndex
	   1018,

	   // CounterNameTitle
	   0,

	   // CounterHelpTitleIndex
	   1019,

	   // CounterHelpTitle
	   0,

	   // DefaultScale
	   0,

	   // DetailLevel
	   PERF_DETAIL_NOVICE,

	   // CounterType
	   PERF_COUNTER_RAWCOUNT,

	   // CounterSize
	   sizeof(DWORD),

	   // CounterOffset
	   NUM_NUMFAILEDLOGINS_OFFSET
   },
   {
	   // ByteLength
	   sizeof(PERF_COUNTER_DEFINITION),

	   // CounterNameTitleIndex
	   1020,

	   // CounterNameTitle
	   0,

	   // CounterHelpTitleIndex
	   1021,

	   // CounterHelpTitle
	   0,

	   // DefaultScale
	   -4,

	   // DetailLevel
	   PERF_DETAIL_NOVICE,

	   // CounterType
	   PERF_COUNTER_BULK_COUNT,

	   // CounterSize
	   sizeof(LARGE_INTEGER),

	   // CounterOffset
	   NUM_DATAREAD_OFFSET
   },
   {
	   // ByteLength
	   sizeof(PERF_COUNTER_DEFINITION),

	   // CounterNameTitleIndex
	   1022,

	   // CounterNameTitle
	   0,

	   // CounterHelpTitleIndex
	   1023,

	   // CounterHelpTitle
	   0,

	   // DefaultScale
	   -4,

	   // DetailLevel
	   PERF_DETAIL_NOVICE,

	   // CounterType
	   PERF_COUNTER_BULK_COUNT,

	   // CounterSize
	   sizeof(LARGE_INTEGER),

	   // CounterOffset
	   NUM_DATAWRITTEN_OFFSET
   },
   {
	   // ByteLength
	   sizeof(PERF_COUNTER_DEFINITION),

	   // CounterNameTitleIndex
	   1024,

	   // CounterNameTitle
	   0,

	   // CounterHelpTitleIndex
	   1025,

	   // CounterHelpTitle
	   0,

	   // DefaultScale
	   -4,

	   // DetailLevel
	   PERF_DETAIL_NOVICE,

	   // CounterType
	   PERF_COUNTER_BULK_COUNT,

	   // CounterSize
	   sizeof(LARGE_INTEGER),

	   // CounterOffset
	   NUM_DATAIN_OFFSET
   },
   {
	   // ByteLength
	   sizeof(PERF_COUNTER_DEFINITION),

	   // CounterNameTitleIndex
	   1026,

	   // CounterNameTitle
	   0,

	   // CounterHelpTitleIndex
	   1027,

	   // CounterHelpTitle
	   0,

	   // DefaultScale
	   -4,

	   // DetailLevel
	   PERF_DETAIL_NOVICE,

	   // CounterType
	   PERF_COUNTER_BULK_COUNT,

	   // CounterSize
	   sizeof(LARGE_INTEGER),

	   // CounterOffset
	   NUM_DATAOUT_OFFSET
   },
   {
	   // ByteLength
	   sizeof(PERF_COUNTER_DEFINITION),

	   // CounterNameTitleIndex
	   1028,

	   // CounterNameTitle
	   0,

	   // CounterHelpTitleIndex
	   1029,

	   // CounterHelpTitle
	   0,

	   // DefaultScale
	   0,

	   // DetailLevel
	   PERF_DETAIL_NOVICE,

	   // CounterType
	   PERF_COUNTER_RAWCOUNT,

	   // CounterSize
	   sizeof(DWORD),

	   // CounterOffset
	   NUM_CURQUEUELEN_OFFSET
   },
   {
	   // ByteLength
	   sizeof(PERF_COUNTER_DEFINITION),

	   // CounterNameTitleIndex
	   1030,

	   // CounterNameTitle
	   0,

	   // CounterHelpTitleIndex
	   1031,

	   // CounterHelpTitle
	   0,

	   // DefaultScale
	   0,

	   // DetailLevel
	   PERF_DETAIL_NOVICE,

	   // CounterType
	   PERF_COUNTER_RAWCOUNT,

	   // CounterSize
	   sizeof(DWORD),

	   // CounterOffset
	   NUM_MAXQUEUELEN_OFFSET
   },
   {
	   // ByteLength
	   sizeof(PERF_COUNTER_DEFINITION),

	   // CounterNameTitleIndex
	   1032,

	   // CounterNameTitle
	   0,

	   // CounterHelpTitleIndex
	   1033,

	   // CounterHelpTitle
	   0,

	   // DefaultScale
	   0,

	   // DetailLevel
	   PERF_DETAIL_NOVICE,

	   // CounterType
	   PERF_COUNTER_RAWCOUNT,

	   // CounterSize
	   sizeof(DWORD),

	   // CounterOffset
	   NUM_CURTHREADS_OFFSET
   },
   {
	   // ByteLength
	   sizeof(PERF_COUNTER_DEFINITION),

	   // CounterNameTitleIndex
	   1034,

	   // CounterNameTitle
	   0,

	   // CounterHelpTitleIndex
	   1035,

	   // CounterHelpTitle
	   0,

	   // DefaultScale
	   0,

	   // DetailLevel
	   PERF_DETAIL_NOVICE,

	   // CounterType
	   PERF_COUNTER_RAWCOUNT,

	   // CounterSize
	   sizeof(DWORD),

	   // CounterOffset
	   NUM_MAXTHREADS_OFFSET
   }
};

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\sfmctrs\perfutil.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992 Microsoft Corporation

Module Name:

    perfutil.h  

Abstract:

    This file supports routines used to parse and
    create Performance Monitor Data Structures.
    It actually supports Performance Object types with
    multiple instances

Author:

    Russ Blake  7/30/92

Revision History:


--*/
#ifndef _PERFUTIL_H_
#define _PERFUTIL_H_

// enable this define to log process heap data to the event log
#ifdef PROBE_HEAP_USAGE
#undef PROBE_HEAP_USAGE
#endif
//
//  Utility macro.  This is used to reserve a DWORD multiple of
//  bytes for Unicode strings embedded in the definitional data,
//  viz., object instance names.
//
#define DWORD_MULTIPLE(x) (((x+sizeof(DWORD)-1)/sizeof(DWORD))*sizeof(DWORD))

//    (assumes dword is 4 bytes long and pointer is a dword in size)
#define ALIGN_ON_DWORD(x) ((VOID *)( ((DWORD) x & 0x00000003) ? ( ((DWORD) x & 0xFFFFFFFC) + 4 ) : ( (DWORD) x ) ))

extern WCHAR  GLOBAL_STRING[];      // Global command (get all local ctrs)
extern WCHAR  FOREIGN_STRING[];           // get data from foreign computers
extern WCHAR  COSTLY_STRING[];      
extern WCHAR  NULL_STRING[];

#define QUERY_GLOBAL    1
#define QUERY_ITEMS     2
#define QUERY_FOREIGN   3
#define QUERY_COSTLY    4

//
// The definition of the only routine of perfutil.c, It builds part of a 
// performance data instance (PERF_INSTANCE_DEFINITION) as described in 
// winperf.h
//

HANDLE MonOpenEventLog ();
VOID MonCloseEventLog ();
DWORD GetQueryType (IN LPWSTR);
BOOL IsNumberInUnicodeList (DWORD, LPWSTR);

typedef struct _LOCAL_HEAP_INFO_BLOCK {
    DWORD   AllocatedEntries;
    DWORD   AllocatedBytes;
    DWORD   FreeEntries;
    DWORD   FreeBytes;
} LOCAL_HEAP_INFO, *PLOCAL_HEAP_INFO;


//
//  Memory Probe macro
//
#ifdef PROBE_HEAP_USAGE

#define HEAP_PROBE()    { \
    DWORD   dwHeapStatus[5]; \
    NTSTATUS CallStatus; \
    dwHeapStatus[4] = __LINE__; \
    if (!(CallStatus = memprobe (dwHeapStatus, 16L, NULL))) { \
        REPORT_INFORMATION_DATA (TCP_HEAP_STATUS, LOG_DEBUG,    \
            &dwHeapStatus, sizeof(dwHeapStatus));  \
    } else {  \
        REPORT_ERROR_DATA (TCP_HEAP_STATUS_ERROR, LOG_DEBUG, \
            &CallStatus, sizeof (DWORD)); \
    } \
}

#else

#define HEAP_PROBE()    ;

#endif

#endif  //_PERFUTIL_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\sfmctrs\perfmsg.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992 Microsoft Corporation

Module Name:

    perfmsg.h

Abstract:

    This file provides the macros and definitions used by the extensible
    counters for reporting events to the event logging facility

Author:

      Bob Watson (a-robw) 5 Oct 92

Revision History:


--*/
#ifndef  _PERFMSG_H_
#define  _PERFMSG_H_
//
// Report error message ID's for Counters
//

#define APP_NAME  "sfmctrs"

//
// The constant below defines how many (if any) messages will be reported
// to the event logger. As the number goes up in value more and more events
// will be reported. The purpose of this is to allow lots of messages during
// development and debugging (e.g. a message level of 3) to a minimum of
// messages (e.g. operational messages with a level of 1) or no messages if
// message logging inflicts too much of a performance penalty. Right now
// this is a compile time constant, but could later become a registry entry.
//
//    Levels:  LOG_NONE = No event log messages ever
//             LOG_USER = User event log messages (e.g. errors)
//             LOG_DEBUG = Minimum Debugging
//             LOG_VERBOSE = Maximum Debugging
//

#define  LOG_NONE     0
#define  LOG_USER     1
#define  LOG_DEBUG    2
#define  LOG_VERBOSE  3

#define  MESSAGE_LEVEL_DEFAULT  LOG_USER

// define macros
//
// Format for event log calls without corresponding insertion strings is:
//    REPORT_xxx (message_value, message_level)
//       where:
//          xxx is the severity to be displayed in the event log
//          message_value is the numeric ID from above
//          message_level is the "filtering" level of error reporting
//             using the error levels above.
//
// if the message has a corresponding insertion string whose symbol conforms
// to the format CONSTANT = numeric value and CONSTANT_S = string constant for
// that message, then the
//
//    REPORT_xxx_STRING (message_value, message_level)
//
// macro may be used.
//

//
// REPORT_SUCCESS was intended to show Success in the error log, rather it
// shows "N/A" so for now it's the same as information, though it could
// (should) be changed  in the future
//


#define REPORT_SUCCESS(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_INFORMATION_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_INFORMATION(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_INFORMATION_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_WARNING(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_WARNING_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_ERROR(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_ERROR_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_INFORMATION_DATA(i,l,d,s) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_INFORMATION_TYPE, \
   0, i, (PSID)NULL, 0, s, NULL, (PVOID)(d)) : FALSE)

#define REPORT_WARNING_DATA(i,l,d,s) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_WARNING_TYPE, \
   0, i, (PSID)NULL, 0, s, NULL, (PVOID)(d)) : FALSE)

#define REPORT_ERROR_DATA(i,l,d,s) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_ERROR_TYPE, \
   0, i, (PSID)NULL, 0, s, NULL, (PVOID)(d)) : FALSE)

// External Variables

extern HANDLE hEventLog;   // handle to event log
extern DWORD  dwLogUsers;  // counter of event log using routines
extern DWORD  MESSAGE_LEVEL; // event logging detail level

#endif //_PERFMSG_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\service\server\volume.c ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.	   **/
/********************************************************************/

//***
//
// Filename:	volume.c
//
// Description: This module contains support routines for the volume
//		category API's for the AFP server service
//
// History:
//		June 11,1992.	NarenG		Created original version.
//
#include "afpsvcp.h"

static HANDLE hmutexInvalidVolume;

// Invalid volume structure
//
typedef struct _AFP_BADVOLUME {

    LPWSTR	    lpwsName;

    LPWSTR	    lpwsPath;

    DWORD 	    cbVariableData; // Number of bytes of name+path.

    struct _AFP_BADVOLUME * Next;

} AFP_BADVOLUME, * PAFP_BADVOLUME;

// Singly linked list of invalid volumes
//
typedef struct _AFP_INVALID_VOLUMES {

    DWORD 	    cbTotalData;

    PAFP_BADVOLUME  Head;

} AFP_INVALID_VOLUMES;

static AFP_INVALID_VOLUMES InvalidVolumeList;


//**
//
// Call:	AfpAdminrVolumeEnum
//
// Returns:	NO_ERROR
//		ERROR_ACCESS_DENIED
//		non-zero returns from AfpServerIOCtrlGetInfo
//
// Description: This routine communicates with the AFP FSD to implement
//		the AfpAdminrVolumeEnum function.
//
DWORD
AfpAdminrVolumeEnum(
	IN     AFP_SERVER_HANDLE 	hServer,
	IN OUT PVOLUME_INFO_CONTAINER   pInfoStruct,
  	IN     DWORD 		    	dwPreferedMaximumLength,
	OUT    LPDWORD 		        lpdwTotalEntries,
	IN OUT LPDWORD 		        lpdwResumeHandle  OPTIONAL
)
{
AFP_REQUEST_PACKET AfpSrp;
DWORD		   dwRetCode=0;
DWORD		   dwAccessStatus=0;


    // Check if caller has access
    //
    if ( dwRetCode = AfpSecObjAccessCheck( AFPSVC_ALL_ACCESS, &dwAccessStatus))
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrVolumeEnum, AfpSecObjAccessCheck failed %ld\n",dwRetCode));
	    AfpLogEvent( AFPLOG_CANT_CHECK_ACCESS,
		     0, NULL, dwRetCode, EVENTLOG_ERROR_TYPE );
        return( ERROR_ACCESS_DENIED );
    }

    if ( dwAccessStatus )
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrVolumeEnum, AfpSecObjAccessCheck returned %ld\n",dwAccessStatus));
        return( ERROR_ACCESS_DENIED );
    }

    // Set up request packet and make IOCTL to the FSD
    //
    AfpSrp.dwRequestCode 		= OP_VOLUME_ENUM;
    AfpSrp.dwApiType     		= AFP_API_TYPE_ENUM;
    AfpSrp.Type.Enum.cbOutputBufSize    = dwPreferedMaximumLength;

    // If resume handle was not passed then we set it to zero, cause caller
    // wants all information starting from the beginning.
    //
    if ( lpdwResumeHandle )
     	AfpSrp.Type.Enum.EnumRequestPkt.erqp_Index = *lpdwResumeHandle;
    else
     	AfpSrp.Type.Enum.EnumRequestPkt.erqp_Index = 0;

    dwRetCode = AfpServerIOCtrlGetInfo( &AfpSrp );

    if ( dwRetCode != ERROR_MORE_DATA && dwRetCode != NO_ERROR )
	return( dwRetCode );

    *lpdwTotalEntries 	       = AfpSrp.Type.Enum.dwTotalAvail;
    pInfoStruct->pBuffer       =(PAFP_VOLUME_INFO)(AfpSrp.Type.Enum.pOutputBuf);
    pInfoStruct->dwEntriesRead = AfpSrp.Type.Enum.dwEntriesRead;

    if ( lpdwResumeHandle )
    	*lpdwResumeHandle = AfpSrp.Type.Enum.EnumRequestPkt.erqp_Index;

    // Convert all offsets to pointers
    //
    AfpBufOffsetToPointer( (LPBYTE)(pInfoStruct->pBuffer),
			   pInfoStruct->dwEntriesRead,
			   AFP_VOLUME_STRUCT );

    return( dwRetCode );
}

//**
//
// Call:	AfpAdminrVolumeSetInfo
//
// Returns:	NO_ERROR
//		ERROR_ACCESS_DENIED
//		non-zero returns from AfpServerIOCtrl
//
// Description: This routine communicates with the AFP FSD to implement
//		the AfpAdminVolumeSetInfo function.
//
DWORD
AfpAdminrVolumeSetInfo(
	IN AFP_SERVER_HANDLE 	hServer,
	IN PAFP_VOLUME_INFO     pAfpVolumeInfo,
	IN DWORD		dwParmNum
)
{
AFP_REQUEST_PACKET 	AfpSrp;
DWORD			dwRetCode=0;
LPBYTE 			pAfpVolumeInfoSR = NULL;
DWORD			cbAfpVolumeInfoSRSize;
DWORD		        dwAccessStatus=0;
					

    // Check if caller has access
    //
    if ( dwRetCode = AfpSecObjAccessCheck( AFPSVC_ALL_ACCESS, &dwAccessStatus))
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrVolumeSetInfo, AfpSecObjAccessCheck failed %ld\n",dwRetCode));
	    AfpLogEvent( AFPLOG_CANT_CHECK_ACCESS, 0, NULL,
		     dwRetCode, EVENTLOG_ERROR_TYPE );
        return( ERROR_ACCESS_DENIED );
    }

    if ( dwAccessStatus )
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrVolumeSetInfo, AfpSecObjAccessCheck returned %ld\n",dwAccessStatus));
        return( ERROR_ACCESS_DENIED );
    }

    // MUTEX start
    //
    WaitForSingleObject( AfpGlobals.hmutexVolume, INFINITE );

    // This loop is used to allow break's instead of goto's to be used
    // on an error condition.
    //
    do {

	dwRetCode = NO_ERROR;

        // Make this buffer self-relative.
    	//
    	if ( dwRetCode = AfpBufMakeFSDRequest((LPBYTE)pAfpVolumeInfo,
					       sizeof(SETINFOREQPKT),
					       AFP_VOLUME_STRUCT,
					       &pAfpVolumeInfoSR,
					       &cbAfpVolumeInfoSRSize ))
	    break;

        // Make IOCTL to set info
    	//
    	AfpSrp.dwRequestCode 		    = OP_VOLUME_SET_INFO;
    	AfpSrp.dwApiType     		    = AFP_API_TYPE_SETINFO;
    	AfpSrp.Type.SetInfo.pInputBuf       = pAfpVolumeInfoSR;
    	AfpSrp.Type.SetInfo.cbInputBufSize  = cbAfpVolumeInfoSRSize;
    	AfpSrp.Type.SetInfo.dwParmNum       = dwParmNum;

        if ( dwRetCode = AfpServerIOCtrl( &AfpSrp ) )
	    break;

	// Now IOCTL the FSD to get information to set in the registry
	// The input buffer for a GetInfo type call should point to a volume
	// structure with the volume name filled in. Since we already have
	// this from the previos SetInfo call, we use the same buffer with
	// the pointer advances by sizeof(SETINFOREQPKT) bytes.
	//
    	AfpSrp.dwRequestCode 		    = OP_VOLUME_GET_INFO;
    	AfpSrp.dwApiType     		    = AFP_API_TYPE_GETINFO;
    	AfpSrp.Type.GetInfo.pInputBuf       = pAfpVolumeInfoSR +
					      sizeof(SETINFOREQPKT);
    	AfpSrp.Type.GetInfo.cbInputBufSize  = cbAfpVolumeInfoSRSize -
					      sizeof(SETINFOREQPKT);

	if ( dwRetCode = AfpServerIOCtrlGetInfo( &AfpSrp ) )
	    break;
	
        // Update the registry if the IOCTL was successful
        //
	AfpBufOffsetToPointer( AfpSrp.Type.GetInfo.pOutputBuf,
			       1,
		               AFP_VOLUME_STRUCT
			     );

	dwRetCode = AfpRegVolumeSetInfo( AfpSrp.Type.GetInfo.pOutputBuf );

	LocalFree( AfpSrp.Type.GetInfo.pOutputBuf );

    } while( FALSE );

    // MUTEX end
    //
    ReleaseMutex( AfpGlobals.hmutexVolume );

    if ( pAfpVolumeInfoSR )
    	LocalFree( pAfpVolumeInfoSR );

    return( dwRetCode );

}

//**
//
// Call:	AfpAdminrVolumeDelete
//
// Returns:	NO_ERROR
//		ERROR_ACCESS_DENIED
//		non-zero returns from AfpServerIOCtrl
//
// Description: This routine communicates with the AFP FSD to implement
//		the AfpAdminVolumeDelete function.
//
DWORD
AfpAdminrVolumeDelete(
	IN AFP_SERVER_HANDLE 	hServer,
	IN LPWSTR 		lpwsVolumeName
)
{
AFP_REQUEST_PACKET AfpSrp;
PAFP_VOLUME_INFO   pAfpVolumeInfoSR;
AFP_VOLUME_INFO    AfpVolumeInfo;
DWORD		   cbAfpVolumeInfoSRSize;
DWORD		   dwRetCode=0;
DWORD		   dwAccessStatus=0;

    // Check if caller has access
    //
    if ( dwRetCode = AfpSecObjAccessCheck( AFPSVC_ALL_ACCESS, &dwAccessStatus))
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrVolumeDelete, AfpSecObjAccessCheck failed %ld\n",dwRetCode));
	    AfpLogEvent( AFPLOG_CANT_CHECK_ACCESS, 0, NULL,
		     dwRetCode, EVENTLOG_ERROR_TYPE );
        return( ERROR_ACCESS_DENIED );
    }

    if ( dwAccessStatus )
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrVolumeDelete, AfpSecObjAccessCheck returned %ld\n",dwAccessStatus));
        return( ERROR_ACCESS_DENIED );
    }

    // Delete FSD request expects a AFP_VOLUME_INFO structure with only
    // the volume name field filled in.
    //
    AfpVolumeInfo.afpvol_name     = lpwsVolumeName;
    AfpVolumeInfo.afpvol_password = NULL;
    AfpVolumeInfo.afpvol_path     = NULL;

    // MUTEX start
    //
    WaitForSingleObject( AfpGlobals.hmutexVolume, INFINITE );

    // This loop is used to allow break's instead of goto's to be used
    // on an error condition.
    //
    do {

	dwRetCode = NO_ERROR;

    	// Make this buffer self-relative.
    	//
    	if ( dwRetCode = AfpBufMakeFSDRequest((LPBYTE)&AfpVolumeInfo,
					      0,
					      AFP_VOLUME_STRUCT,
					      (LPBYTE*)&pAfpVolumeInfoSR,
					      &cbAfpVolumeInfoSRSize ) )
	    break;

        // IOCTL the FSD to delete the volume
        //
        AfpSrp.dwRequestCode 		    = OP_VOLUME_DELETE;
        AfpSrp.dwApiType     		    = AFP_API_TYPE_DELETE;
        AfpSrp.Type.Delete.pInputBuf        = pAfpVolumeInfoSR;
        AfpSrp.Type.Delete.cbInputBufSize   = cbAfpVolumeInfoSRSize;

        dwRetCode = AfpServerIOCtrl( &AfpSrp );

    	LocalFree( pAfpVolumeInfoSR );

	if ( dwRetCode )
	    break;

    	// Update the registry if the IOCTL was successful
    	//
	dwRetCode = AfpRegVolumeDelete( lpwsVolumeName );

    } while( FALSE );

    // MUTEX end
    //
    ReleaseMutex( AfpGlobals.hmutexVolume );

    return( dwRetCode );
}

//**
//
// Call:	AfpAdminrVolumeAdd
//
// Returns:	NO_ERROR
//		ERROR_ACCESS_DENIED
//		non-zero returns from AfpServerIOCtrl
//
// Description: This routine communicates with the AFP FSD to implement
//		the AfpAdminVolumeAdd function.
//
DWORD
AfpAdminrVolumeAdd(
	IN AFP_SERVER_HANDLE 	hServer,
	IN PAFP_VOLUME_INFO     pAfpVolumeInfo
)
{
AFP_REQUEST_PACKET 	AfpSrp;
DWORD				dwRetCode=0, dwLastDstCharIndex = 0;
PAFP_VOLUME_INFO 	pAfpVolumeInfoSR = NULL;
DWORD			cbAfpVolumeInfoSRSize;
DWORD			dwAccessStatus=0;
BOOL			fCopiedIcon = FALSE;
WCHAR			wchSrcIconPath[MAX_PATH];
WCHAR wchDstIconPath[MAX_PATH + AFPSERVER_VOLUME_ICON_FILE_SIZE + 1 + (sizeof(AFPSERVER_RESOURCE_STREAM)/sizeof(WCHAR))];
WCHAR wchServerIconFile[AFPSERVER_VOLUME_ICON_FILE_SIZE] = AFPSERVER_VOLUME_ICON_FILE;

	// Check if caller has access
    //
    if ( dwRetCode = AfpSecObjAccessCheck( AFPSVC_ALL_ACCESS, &dwAccessStatus))
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrVolumeAdd, AfpSecObjAccessCheck failed %ld\n",dwRetCode));
	    AfpLogEvent( AFPLOG_CANT_CHECK_ACCESS, 0,
		     NULL, dwRetCode, EVENTLOG_ERROR_TYPE );
        return( ERROR_ACCESS_DENIED );
    }

    if ( dwAccessStatus )
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrVolumeAdd, AfpSecObjAccessCheck returned %ld\n",dwAccessStatus));
        return( ERROR_ACCESS_DENIED );
    }

	if ( pAfpVolumeInfo == NULL)
	{
        AFP_PRINT(( "SFMSVC: AfpAdminrVolumeAdd, pAfpVolumeInfo == NULL\n"));
        return( ERROR_INVALID_DATA );
	}

    // MUTEX start
    //
    WaitForSingleObject( AfpGlobals.hmutexVolume, INFINITE );

    // This loop is used to allow break's instead of goto's to be used
    // on an error condition.
    //
    do {

		// Copy the server icon to the volume root
		//

		// Construct a path to the NTSFM volume custom icon
		//
		if ( GetSystemDirectory( wchSrcIconPath, MAX_PATH ) )
		{
			wcscat( wchSrcIconPath, AFP_DEF_VOLICON_SRCNAME );

			if ( pAfpVolumeInfo->afpvol_path == NULL )
			{
        			AFP_PRINT(( "SFMSVC: AfpAdminrVolumeAdd, pAfpVolumeInfo->afpvol_path == NULL\n"));
        			dwRetCode = ERROR_INVALID_DATA;
				    break;
			}

			// Construct a path to the destination volume "Icon<0D>" file
			//
			wcscpy( wchDstIconPath, pAfpVolumeInfo->afpvol_path );

			if ( wcslen(wchDstIconPath) == 0 )
			{
        			AFP_PRINT(( "SFMSVC: AfpAdminrVolumeAdd, wcslen(wchDstIconPath) == 0\n"));
        			dwRetCode = ERROR_INVALID_DATA;
				break;
			}

			if (wchDstIconPath[wcslen(wchDstIconPath) - 1] != TEXT('\\'))
			{
				wcscat( wchDstIconPath, TEXT("\\") );
			}
			wcscat( wchDstIconPath, wchServerIconFile );
			// Keep track of end of name without the resource fork tacked on
			//
			dwLastDstCharIndex = wcslen(wchDstIconPath);
			wcscat( wchDstIconPath, AFPSERVER_RESOURCE_STREAM );

			// Copy the icon file to the root of the volume (do not overwrite)
			//
			if ((fCopiedIcon = CopyFile( wchSrcIconPath, wchDstIconPath, TRUE )) ||
			   (GetLastError() == ERROR_FILE_EXISTS))
			{
				pAfpVolumeInfo->afpvol_props_mask |= AFP_VOLUME_HAS_CUSTOM_ICON;

			    // Make sure the file is hidden
				SetFileAttributes( wchDstIconPath,
								   FILE_ATTRIBUTE_HIDDEN |
								    FILE_ATTRIBUTE_ARCHIVE );
			}
		}
        else
        {
            dwRetCode = GetLastError ();
            break;
        }

    	// Make this buffer self-relative.
    	//
    	if ( dwRetCode = AfpBufMakeFSDRequest( (LPBYTE)pAfpVolumeInfo,
					       0,
					       AFP_VOLUME_STRUCT,
					       (LPBYTE*)&pAfpVolumeInfoSR,
					       &cbAfpVolumeInfoSRSize ) )
	    break;

    	// IOCTL the FSD to add the volume
    	//
    	AfpSrp.dwRequestCode 		= OP_VOLUME_ADD;
    	AfpSrp.dwApiType     		= AFP_API_TYPE_ADD;
    	AfpSrp.Type.Add.pInputBuf     	= pAfpVolumeInfoSR;
    	AfpSrp.Type.Add.cbInputBufSize  = cbAfpVolumeInfoSRSize;

        dwRetCode = AfpServerIOCtrl( &AfpSrp );

		// Don't allow icon bit to be written to the registry if it was set
		pAfpVolumeInfo->afpvol_props_mask &= ~AFP_VOLUME_HAS_CUSTOM_ICON;

		if ( dwRetCode )
		{
			// Delete the icon file we just copied if the volume add failed
			//
			if ( fCopiedIcon )
			{
				// Truncate the resource fork name so we delete the whole file
				wchDstIconPath[dwLastDstCharIndex] = 0;
				DeleteFile( wchDstIconPath );
			}

			break;
        }

        // Update the registry if the IOCTL was successful
        //
		dwRetCode = AfpRegVolumeAdd( pAfpVolumeInfo );

		if ( dwRetCode )
			break;

		// Delete this volume if it exists in the invalid volume list
		//
    	AfpDeleteInvalidVolume( pAfpVolumeInfo->afpvol_name );

    } while( FALSE );

    // MUTEX end
    //
    ReleaseMutex( AfpGlobals.hmutexVolume );

    if ( pAfpVolumeInfoSR != NULL )
		LocalFree( pAfpVolumeInfoSR );

    return( dwRetCode );

}

//**
//
// Call:	AfpAdminrVolumeGetInfo
//
// Returns:	NO_ERROR
//		ERROR_ACCESS_DENIED
//		non-zero returns from AfpServerIOCtrlGetInfo
//
// Description: This routine communicates with the AFP FSD to implement
//		the AfpAdminVolumeGetInfo function.
//
DWORD
AfpAdminrVolumeGetInfo(
	IN  AFP_SERVER_HANDLE 	hServer,
	IN  LPWSTR 		lpwsVolumeName,
    	OUT PAFP_VOLUME_INFO*   ppAfpVolumeInfo
)
{
AFP_REQUEST_PACKET AfpSrp;
PAFP_VOLUME_INFO   pAfpVolumeInfoSR;
AFP_VOLUME_INFO    AfpVolumeInfo;
DWORD		   cbAfpVolumeInfoSRSize;
DWORD		   dwRetCode=0;
DWORD		   dwAccessStatus=0;

    // Check if caller has access
    //
    if ( dwRetCode = AfpSecObjAccessCheck( AFPSVC_ALL_ACCESS, &dwAccessStatus))
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrVolumeGetInfo, AfpSecObjAccessCheck failed %ld\n",dwRetCode));
	    AfpLogEvent( AFPLOG_CANT_CHECK_ACCESS, 0, NULL,
		     dwRetCode, EVENTLOG_ERROR_TYPE );
        return( ERROR_ACCESS_DENIED );
    }

    if ( dwAccessStatus )
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrVolumeGetInfo, AfpSecObjAccessCheck returned %ld\n",dwAccessStatus));
        return( ERROR_ACCESS_DENIED );
    }


    // MUTEX start
    //
    WaitForSingleObject( AfpGlobals.hmutexVolume, INFINITE );

    // This loop is used to allow break's instead of goto's to be used
    // on an error condition.
    //
    do {

	dwRetCode = NO_ERROR;

    	// Get info FSD request expects a AFP_VOLUME_INFO structure with only
    	// the volume name field filled in.
    	//
    	AfpVolumeInfo.afpvol_name     = lpwsVolumeName;
    	AfpVolumeInfo.afpvol_password = NULL;
    	AfpVolumeInfo.afpvol_path     = NULL;

    	// Make this buffer self-relative.
    	//
    	if ( dwRetCode = AfpBufMakeFSDRequest((LPBYTE)&AfpVolumeInfo,
					      0,
					      AFP_VOLUME_STRUCT,
					      (LPBYTE*)&pAfpVolumeInfoSR,
					      &cbAfpVolumeInfoSRSize ) )
	    break;

    	AfpSrp.dwRequestCode 	           = OP_VOLUME_GET_INFO;
    	AfpSrp.dwApiType     	           = AFP_API_TYPE_GETINFO;
    	AfpSrp.Type.GetInfo.pInputBuf      = pAfpVolumeInfoSR;
    	AfpSrp.Type.GetInfo.cbInputBufSize = cbAfpVolumeInfoSRSize;

	dwRetCode = AfpServerIOCtrlGetInfo( &AfpSrp );

    	if ( dwRetCode != ERROR_MORE_DATA && dwRetCode != NO_ERROR )
	    break;

    	LocalFree( pAfpVolumeInfoSR );

    	*ppAfpVolumeInfo = AfpSrp.Type.GetInfo.pOutputBuf;

    	// Convert all offsets to pointers
    	//
    	AfpBufOffsetToPointer( (LPBYTE)*ppAfpVolumeInfo, 1, AFP_VOLUME_STRUCT);

    } while( FALSE );

    // MUTEX end
    //
    ReleaseMutex( AfpGlobals.hmutexVolume );

    return( dwRetCode );
}

//**
//
// Call:	AfpAdminrInvalidVolumeEnum
//
// Returns:	NO_ERROR
//		ERROR_ACCESS_DENIED
//
// Description: This routine will return a list of all invalid volumes. This
//		List is stored in a cache that is local to this module.
//
DWORD
AfpAdminrInvalidVolumeEnum(
	IN     AFP_SERVER_HANDLE 	hServer,
	IN OUT PVOLUME_INFO_CONTAINER   pInfoStruct
)
{
DWORD		   dwRetCode=0;
DWORD		   dwAccessStatus=0;
PAFP_VOLUME_INFO   pOutputBuf;
PAFP_VOLUME_INFO   pOutputWalker;
WCHAR *   	   pwchVariableData;
PAFP_BADVOLUME     pAfpBadVolWalker;


    // Check if caller has access
    //
    if ( dwRetCode = AfpSecObjAccessCheck( AFPSVC_ALL_ACCESS, &dwAccessStatus))
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrInvalidVolumeEnum, AfpSecObjAccessCheck failed %ld\n",dwRetCode));
	    AfpLogEvent( AFPLOG_CANT_CHECK_ACCESS, 0, NULL,
		     dwRetCode, EVENTLOG_ERROR_TYPE );
        return( ERROR_ACCESS_DENIED );
    }

    if ( dwAccessStatus )
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrInvalidVolumeEnum, AfpSecObjAccessCheck returned %ld\n",dwAccessStatus));
        return( ERROR_ACCESS_DENIED );
    }

    // MUTEX start
    //
    WaitForSingleObject( hmutexInvalidVolume, INFINITE );

    // Allocate enough space to hold all the information.
    //
    pOutputBuf = MIDL_user_allocate( InvalidVolumeList.cbTotalData );

    if ( pOutputBuf == NULL ){
    	ReleaseMutex( hmutexInvalidVolume );
	return( ERROR_NOT_ENOUGH_MEMORY );
    }

    ZeroMemory( pOutputBuf, InvalidVolumeList.cbTotalData );

    // Variable data begins from the end of the buffer.
    //
    pwchVariableData=(WCHAR*)((ULONG_PTR)pOutputBuf+InvalidVolumeList.cbTotalData);

    // Walk the list and create the array of volume structures
    //
    for( pAfpBadVolWalker = InvalidVolumeList.Head,
         pInfoStruct->dwEntriesRead = 0,
	 pOutputWalker = pOutputBuf;

         pAfpBadVolWalker != NULL;

	 pOutputWalker++,
         (pInfoStruct->dwEntriesRead)++,
         pAfpBadVolWalker = pAfpBadVolWalker->Next ) {

	pwchVariableData -= (STRLEN(pAfpBadVolWalker->lpwsName) + 1);

        STRCPY( (LPWSTR)pwchVariableData, pAfpBadVolWalker->lpwsName );

	pOutputWalker->afpvol_name = (LPWSTR)pwchVariableData;

	if ( pAfpBadVolWalker->lpwsPath != NULL ) {

	    pwchVariableData -=( STRLEN(pAfpBadVolWalker->lpwsPath)+1 );

            STRCPY( (LPWSTR)pwchVariableData, pAfpBadVolWalker->lpwsPath );

	    pOutputWalker->afpvol_path = (LPWSTR)pwchVariableData;

	}

    }

    // MUTEX end
    //
    ReleaseMutex( hmutexInvalidVolume );

    pInfoStruct->pBuffer = pOutputBuf;

    return( dwRetCode );
}

//**
//
// Call:	AfpAdminrInvalidVolumeDelete
//
// Returns:	NO_ERROR
//		ERROR_ACCESS_DENIED
//
// Description: This routine will remove an invalid volume from the registry
//		and the list of invalid volumes.
//
DWORD
AfpAdminrInvalidVolumeDelete(
	IN AFP_SERVER_HANDLE 	hServer,
	IN LPWSTR 		lpwsVolumeName
)
{
DWORD		   dwRetCode=0;
DWORD		   dwAccessStatus=0;

    // Check if caller has access
    //
    if ( dwRetCode = AfpSecObjAccessCheck( AFPSVC_ALL_ACCESS, &dwAccessStatus))
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrInvalidVolumeDelete, AfpSecObjAccessCheck failed %ld\n",dwRetCode));
	    AfpLogEvent( AFPLOG_CANT_CHECK_ACCESS, 0, NULL,
		     dwRetCode, EVENTLOG_ERROR_TYPE );
        return( ERROR_ACCESS_DENIED );
    }

    if ( dwAccessStatus )
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrInvalidVolumeDelete, AfpSecObjAccessCheck returned %ld\n",dwAccessStatus));
        return( ERROR_ACCESS_DENIED );
    }


    // Remove this volume from the registry
    //
    if ( dwRetCode = AfpRegVolumeDelete( lpwsVolumeName  ) ) {

	if ( dwRetCode == ERROR_FILE_NOT_FOUND )
	    dwRetCode = (DWORD)AFPERR_VolumeNonExist;
    }

    // MUTEX start
    //
    WaitForSingleObject( hmutexInvalidVolume, INFINITE );

    AfpDeleteInvalidVolume( lpwsVolumeName );

    // MUTEX end
    //
    ReleaseMutex( hmutexInvalidVolume );

    return( dwRetCode );
}

//**
//
// Call:	AfpAddInvalidVolume
//
// Returns:	none
//
// Description: Will add a volume structure to a sigly linked list of volumes.
//
VOID
AfpAddInvalidVolume(
	IN LPWSTR	lpwsName,
	IN LPWSTR	lpwsPath
)
{
DWORD		 dwRetCode = NO_ERROR;
WCHAR* 	 	 pwchVariableData = NULL;
PAFP_BADVOLUME   pAfpVolumeInfo = NULL;
DWORD		 cbVariableData;

    // MUTEX start
    //
    WaitForSingleObject( hmutexInvalidVolume, INFINITE );

    do {

    	cbVariableData = (STRLEN(lpwsName)+1) * sizeof(WCHAR);

    	if ( lpwsPath != NULL )
    	    cbVariableData += ( (STRLEN(lpwsPath)+1)*sizeof(WCHAR) );

    	pwchVariableData = (WCHAR*)LocalAlloc( LPTR, cbVariableData );

    	if ( pwchVariableData == NULL ) {
	    dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
	    break;
    	}

    	pAfpVolumeInfo = (PAFP_BADVOLUME)LocalAlloc( LPTR,
						     sizeof(AFP_BADVOLUME));
    	if ( pAfpVolumeInfo == NULL ) {
	    dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
	    break;
    	}

	// Add the volume strucutre
        //
	pAfpVolumeInfo->Next = InvalidVolumeList.Head;

        InvalidVolumeList.Head = pAfpVolumeInfo;

	// Add the name and the path
	//
	STRCPY( (LPWSTR)pwchVariableData, lpwsName );
	pAfpVolumeInfo->lpwsName = (LPWSTR)pwchVariableData;

	if ( lpwsPath != NULL ) {

	    pwchVariableData += ( STRLEN( lpwsName ) + 1);
	    STRCPY( (LPWSTR)pwchVariableData, lpwsPath );
	    pAfpVolumeInfo->lpwsPath = (LPWSTR)pwchVariableData;
	}

	pAfpVolumeInfo->cbVariableData = cbVariableData;

	InvalidVolumeList.cbTotalData +=  ( sizeof( AFP_VOLUME_INFO ) +
					    cbVariableData );
	
    } while( FALSE );

    if ( dwRetCode != NO_ERROR ) {

    	if ( pAfpVolumeInfo != NULL )
	    LocalFree( pAfpVolumeInfo );

    	if ( pwchVariableData != NULL ) {
	    LocalFree( pwchVariableData );
	}
    }

    // MUTEX end
    //
    ReleaseMutex( hmutexInvalidVolume );
}

//**
//
// Call:	AfpDeleteInvalidVolume
//
// Returns:	none
//
// Description: Will delete a volume structure from the list of invalid
//		volumes, if it is found.
//
VOID
AfpDeleteInvalidVolume(
	IN LPWSTR	lpwsVolumeName
)
{
PAFP_BADVOLUME	   pTmp;
PAFP_BADVOLUME     pBadVolWalker;

    // Walk the list and delete the volume structure
    //
    if ( InvalidVolumeList.Head != NULL ) {
	
	if ( STRICMP( InvalidVolumeList.Head->lpwsName, lpwsVolumeName ) == 0 ){
	
	    pTmp = InvalidVolumeList.Head;

	    InvalidVolumeList.cbTotalData -= ( sizeof( AFP_VOLUME_INFO )
					       + pTmp->cbVariableData );
	
	    InvalidVolumeList.Head = pTmp->Next;

	    LocalFree( pTmp->lpwsName );
	    LocalFree( pTmp );
	}
	else {

	    for( pBadVolWalker = InvalidVolumeList.Head;
		 pBadVolWalker->Next != NULL;
		 pBadVolWalker = pBadVolWalker->Next ) {

		if ( STRICMP( pBadVolWalker->Next->lpwsName, lpwsVolumeName )
			      == 0 ) {

		    pTmp = pBadVolWalker->Next;

    	    	    InvalidVolumeList.cbTotalData -= ( sizeof( AFP_VOLUME_INFO )
						       + pTmp->cbVariableData );

		    pBadVolWalker->Next = pTmp->Next;

		    LocalFree( pTmp->lpwsName );
		    LocalFree( pTmp);

		    break;
		}

	    }
	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\service\server\validate.c ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.	   **/
/********************************************************************/

//***
//
// Filename:	validate.c
//
// Description: Contains routines to validate AFP_***_INFO structure
//		fields. These routines are called to validate information
//		passed by the user and information read from the registry.
//
// History:
//		July 11,1992.	NarenG		Created original version.
//
#include "afpsvcp.h"
#include <lmcons.h>		// UNLEN and GNLEN

//**
//
// Call:	IsAfpServerNameValid
//
// Returns:	TRUE	- valid
//		FALSE	- invalid
//
// Description: Validated server name field.
//
BOOL
IsAfpServerNameValid(
	IN LPVOID pAfpServerName
)
{
BOOL  fValid = TRUE;
DWORD dwLength;

    try {

	dwLength = STRLEN( (LPWSTR)pAfpServerName );

	if ( ( dwLength > AFP_SERVERNAME_LEN ) || ( dwLength == 0 ) )
	    fValid = FALSE;
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {
	fValid = FALSE;
    }

    return( fValid );
}

//**
//
// Call:	IsAfpServerOptionsValid
//
// Returns:	TRUE	- valid
//		FALSE	- invalid
//
// Description: Validates Server options field.
//
BOOL
IsAfpServerOptionsValid(
	IN LPVOID pServerOptions
)
{
DWORD ServerOptions = *((LPDWORD)pServerOptions);
BOOL  fValid = TRUE;

    try {

    	// Make sure only valid bits are set
    	//
    	if ( ServerOptions & ~( AFP_SRVROPT_GUESTLOGONALLOWED       |
			                    AFP_SRVROPT_CLEARTEXTLOGONALLOWED   |
			                    AFP_SRVROPT_4GB_VOLUMES             |
                                AFP_SRVROPT_MICROSOFT_UAM           |
                                AFP_SRVROPT_NATIVEAPPLEUAM          |
			                    AFP_SRVROPT_ALLOWSAVEDPASSWORD ))
	    fValid = FALSE;
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {
	fValid = FALSE;
    }

    return( fValid );
	
}

//**
//
// Call:	IsAfpMaxSessionsValid
//
// Returns:	TRUE	- valid
//		FALSE	- invalid
//
// Description: Validates Max sessions field.
//
BOOL
IsAfpMaxSessionsValid(
	IN LPVOID pMaxSessions
)
{
BOOL fValid = TRUE;

    try {

    	if ( *((LPDWORD)pMaxSessions) > AFP_MAX_ALLOWED_SRV_SESSIONS )
	    fValid = FALSE;
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {
	fValid = FALSE;
    }

    return( fValid );
}

//**
//
// Call:	IsAfpMsgValid
//
// Returns:	TRUE	- valid
//		FALSE	- invalid
//
// Description: Validates message field.
//
BOOL
IsAfpMsgValid(
	IN LPVOID pMsg
)
{
BOOL fValid = TRUE;

    try {
    	if ( STRLEN( (LPWSTR)pMsg ) > AFP_MESSAGE_LEN )
	    fValid = FALSE;
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {
	fValid = FALSE;
    }

    return( fValid );
}

//**
//
// Call:	IsAfpCodePageValid
//
// Returns:	TRUE	- valid
//		FALSE	- invalid
//
// Description: Validates code page path.
//
BOOL
IsAfpCodePageValid(
	IN LPVOID pCodePagePath
)
{
BOOL  fValid = TRUE;
DWORD dwLength;

    try {

  	dwLength = STRLEN( (LPWSTR)pCodePagePath );

	if ( ( dwLength == 0 ) || ( dwLength > MAX_PATH ) )
	    fValid = FALSE;

    }
    except( EXCEPTION_EXECUTE_HANDLER ) {
	fValid = FALSE;
    }

    return( fValid );
}

//**
//
// Call:	IsAfpExtensionValid
//
// Returns:	TRUE	- valid
//		FALSE	- invalid
//
// Description: Validated the extension field in the AFP_EXTENSION structure.
//
BOOL
IsAfpExtensionValid(
	IN PAFP_EXTENSION pAfpExtension
)
{
BOOL  fValid = TRUE;
DWORD dwLength;

    try {

	// NULL extensions are not allowed
	//
	dwLength = STRLEN( pAfpExtension->afpe_extension );

	if ( ( dwLength == 0  ) || ( dwLength > AFP_EXTENSION_LEN ) )
	    fValid = FALSE;

        STRUPR( pAfpExtension->afpe_extension );
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {
	fValid = FALSE;
    }

    return( fValid );
}

//**
//
// Call:	IsAfpMaxPagedMemValid
//
// Returns:	TRUE	- valid
//		FALSE	- invalid
//
// Description: Validates Max. pages memory field.
//
BOOL
IsAfpMaxPagedMemValid(
	IN LPVOID pMaxPagedMem
)
{
BOOL fValid = TRUE;

    try {

    	if ((*((LPDWORD)pMaxPagedMem) < AFP_MIN_ALLOWED_PAGED_MEM ) ||
	    (*((LPDWORD)pMaxPagedMem) > AFP_MAX_ALLOWED_PAGED_MEM ))
	    fValid = FALSE;
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {
	fValid = FALSE;
    }

    return( fValid );
}

//**
//
// Call:	IsAfpServerInfoValid
//
// Returns:	TRUE	- valid
//		FALSE	- invalid
//
// Description: Validates the AFP_SERER_INFO structure.
//
BOOL
IsAfpServerInfoValid(
        IN DWORD		dwParmNum,
	IN PAFP_SERVER_INFO	pAfpServerInfo
)
{

    // Can only set 5 fields
    //
    if ( dwParmNum & ~( AFP_SERVER_PARMNUM_MAX_SESSIONS |
			AFP_SERVER_PARMNUM_OPTIONS      |
			AFP_SERVER_PARMNUM_NAME         |
			AFP_SERVER_PARMNUM_LOGINMSG     |
            AFP_SERVER_GUEST_ACCT_NOTIFY ))
	return( FALSE );

    // Null out the fields the are not allowed to be set so that RPC does
    // not think that they are valid pointers.
    //
    pAfpServerInfo->afpsrv_codepage = NULL;

    if ( dwParmNum & AFP_SERVER_PARMNUM_NAME ){

	if ( pAfpServerInfo->afpsrv_name != NULL ) {

	    if ( !IsAfpServerNameValid( pAfpServerInfo->afpsrv_name ) )
	    	return( FALSE );
	}
    }
    else
	pAfpServerInfo->afpsrv_name = NULL;

    if ( dwParmNum & AFP_SERVER_PARMNUM_MAX_SESSIONS ) {

	if ( !IsAfpMaxSessionsValid( &(pAfpServerInfo->afpsrv_max_sessions) ))
	    return( FALSE );
    }

    if ( dwParmNum & AFP_SERVER_PARMNUM_OPTIONS ){

	if ( !IsAfpServerOptionsValid( &(pAfpServerInfo->afpsrv_options) ))
	    return( FALSE );
    }

    if ( dwParmNum & AFP_SERVER_PARMNUM_LOGINMSG ){

	if ( pAfpServerInfo->afpsrv_login_msg != NULL ) {

	    if( !IsAfpMsgValid( pAfpServerInfo->afpsrv_login_msg ) )
	    	return( FALSE );
	}
    }
    else
	pAfpServerInfo->afpsrv_login_msg = NULL;

    return( TRUE );
}

//**
//
// Call:	IsAfpTypeCreatorValid
//
// Returns:	TRUE	- valid
//		FALSE	- invalid
//
// Description: Validates the AFP_TYPE_CREATOR structure.
//
BOOL
IsAfpTypeCreatorValid(
	IN PAFP_TYPE_CREATOR	pAfpTypeCreator
)
{
BOOL  fValid = TRUE;
DWORD dwLength;

    try {

	dwLength = STRLEN( pAfpTypeCreator->afptc_type );

	if ( ( dwLength == 0 ) || ( dwLength > AFP_TYPE_LEN ) )
	    fValid = FALSE;

	dwLength =  STRLEN( pAfpTypeCreator->afptc_creator );

	if ( ( dwLength == 0 ) || ( dwLength > AFP_CREATOR_LEN ) )
	    fValid = FALSE;

	dwLength = STRLEN(pAfpTypeCreator->afptc_comment);

	if ( dwLength > AFP_ETC_COMMENT_LEN )
	    fValid = FALSE;

    }
    except( EXCEPTION_EXECUTE_HANDLER ) {
	fValid = FALSE;
    }

    return( fValid );

}

//**
//
// Call:	IsAfpMaxNonPagedMemValid
//
// Returns:	TRUE	- valid
//		FALSE	- invalid
//
// Description: Validates the max non-paged memory field.
//
BOOL
IsAfpMaxNonPagedMemValid(
	IN LPVOID pMaxNonPagedMem
)
{
BOOL fValid = TRUE;

    try {

    	if ((*((LPDWORD)pMaxNonPagedMem) < AFP_MIN_ALLOWED_NONPAGED_MEM )  ||
	    (*((LPDWORD)pMaxNonPagedMem) > AFP_MAX_ALLOWED_NONPAGED_MEM ))
	    fValid = FALSE;
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {
	fValid = FALSE;
    }

    return( fValid );
}

//**
//
// Call:	IsAfpVolumeInfoValid
//
// Returns:	TRUE	- valid
//		FALSE	- invalid
//
// Description: Wil validate a volume info structure and the associated
//		parm number. If the parm number is zero it is assume that
//		the user is trying to add a volume vs. trying to set
//		information for that volume. If the parm number is not
//		zero, then all string pointer values that are not being
//		set by the user, are set to NULL, otherwise RPC might mistake
//		these fields for valid string poiters.
//		
//
BOOL
IsAfpVolumeInfoValid(
	IN DWORD		dwParmNum,
        IN PAFP_VOLUME_INFO     pAfpVolume
)
{
BOOL fValid = TRUE;

    if ( !IsAfpVolumeNameValid( pAfpVolume->afpvol_name ) )
	return( FALSE );
	
    try {

	// User is wants to set info
	//
  	if ( dwParmNum != AFP_VALIDATE_ALL_FIELDS ) {

    	    if ( ~AFP_VOL_PARMNUM_ALL & dwParmNum )
		fValid = FALSE;

            if ( dwParmNum & AFP_VOL_PARMNUM_PASSWORD  ){
		
		// Validate password
		//
	        if ( pAfpVolume->afpvol_password != NULL
		     &&
		     ( STRLEN(pAfpVolume->afpvol_password) > AFP_VOLPASS_LEN ))
		    fValid = FALSE;
	    }
	    else
    	    	pAfpVolume->afpvol_password = NULL;
	
            if ( dwParmNum & AFP_VOL_PARMNUM_PROPSMASK ) {
		
	        if ( ~AFP_VOLUME_ALL & pAfpVolume->afpvol_props_mask )
		    fValid = FALSE;
	    }

	    // Set path to NULL since user cannot change this
	    //
            pAfpVolume->afpvol_path = NULL;

	}
	else {

	    if ( pAfpVolume->afpvol_password != NULL
		 &&
		 ( STRLEN(pAfpVolume->afpvol_password) > AFP_VOLPASS_LEN ))
		fValid = FALSE;

	    if ( ~AFP_VOLUME_ALL & pAfpVolume->afpvol_props_mask )
		fValid = FALSE;

	    // Just make sure this is a valid string pointer
	    //
	    STRLEN( pAfpVolume->afpvol_path );

	}
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {
	fValid = FALSE;
    }

    return( fValid );

}

//**
//
// Call:	IsAfpVolumeNameValid
//
// Returns:	TRUE	- valid
//		FALSE	- invalid
//
// Description: Will validate the volume name
//
BOOL
IsAfpVolumeNameValid(
	IN LPWSTR 	lpwsVolumeName
)
{
BOOL  fValid = TRUE;
DWORD dwLength;

    try {

	dwLength = STRLEN( lpwsVolumeName );

	if ( ( dwLength > AFP_VOLNAME_LEN ) || ( dwLength == 0 ) )
	    fValid = FALSE;
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {
	fValid = FALSE;
    }

    return( fValid );
}

//**
//
// Call:	IsAfpDirInfoValid
//
// Returns:	TRUE	- valid
//		FALSE	- invalid
//
// Description: Will validate various field in the AFP_VOLUME_INFO
//		structure depending on the parm number.
//
BOOL
IsAfpDirInfoValid(
	IN DWORD		dwParmNum,
	IN PAFP_DIRECTORY_INFO  pAfpDirInfo
)
{
BOOL  fValid = TRUE;
DWORD dwLength;

    if ( ~AFP_DIR_PARMNUM_ALL & dwParmNum )
	return( FALSE );

    try {

	// Make sure path is a valid string
	//
	dwLength = STRLEN( pAfpDirInfo->afpdir_path );

	if ( ( dwLength == 0 ) || ( dwLength > MAX_PATH ) )
	    fValid = FALSE;

	if ( dwParmNum & AFP_DIR_PARMNUM_OWNER ) {

	    dwLength = STRLEN( pAfpDirInfo->afpdir_owner );

	    if ( ( dwLength == 0 ) || ( dwLength > UNLEN ) )
		fValid = FALSE;
	}
	else
	    pAfpDirInfo->afpdir_owner = NULL;

	if ( dwParmNum & AFP_DIR_PARMNUM_GROUP ){

	    dwLength = STRLEN( pAfpDirInfo->afpdir_group );

	    if ( ( dwLength == 0 ) || ( dwLength > GNLEN ) )
		fValid = FALSE;
	}
	else
	    pAfpDirInfo->afpdir_group = NULL;

	if ( dwParmNum & AFP_DIR_PARMNUM_PERMS ) {

	    if ( ~( AFP_PERM_OWNER_MASK  	 |
		    AFP_PERM_GROUP_MASK  	 |
		    AFP_PERM_WORLD_MASK 	 |
		    AFP_PERM_INHIBIT_MOVE_DELETE |
		    AFP_PERM_SET_SUBDIRS ) &
		pAfpDirInfo->afpdir_perms )

	    fValid = FALSE;
	
	}

    }
    except( EXCEPTION_EXECUTE_HANDLER ) {
	fValid = FALSE;
    }

    return( fValid );
}

//**
//
// Call:	IsAfpIconValid
//
// Returns:	TRUE  - valid
//		FALSE - invalid
//
// Description:	Will validate a AFP_ICON_INFO data structure.
//
BOOL
IsAfpIconValid(
	IN PAFP_ICON_INFO	pAfpIconInfo
)
{
BOOL  fValid = TRUE;
DWORD dwLength;

    try {

	dwLength = STRLEN( pAfpIconInfo->afpicon_type );

	if ( ( dwLength == 0 ) || ( dwLength > AFP_TYPE_LEN ) )
	    fValid = FALSE;

	dwLength = STRLEN( pAfpIconInfo->afpicon_creator );

	if ( ( dwLength == 0 ) || ( dwLength > AFP_CREATOR_LEN ) )
	    fValid = FALSE;

	switch( pAfpIconInfo->afpicon_icontype ) {
	
	case ICONTYPE_SRVR:
	case ICONTYPE_ICN:
	    if ( pAfpIconInfo->afpicon_length == ICONSIZE_ICN )
	 	pAfpIconInfo->afpicon_data[pAfpIconInfo->afpicon_length-1];
	    else
	    	fValid = FALSE;
	    break;

	case ICONTYPE_ICS:
	    if ( pAfpIconInfo->afpicon_length == ICONSIZE_ICS )
	 	pAfpIconInfo->afpicon_data[pAfpIconInfo->afpicon_length-1];
	    else
	    	fValid = FALSE;
	    break;

	case ICONTYPE_ICN4:
	    if ( pAfpIconInfo->afpicon_length == ICONSIZE_ICN4 )
	 	pAfpIconInfo->afpicon_data[pAfpIconInfo->afpicon_length-1];
	    else
	    	fValid = FALSE;
	    break;

	case ICONTYPE_ICN8:
	    if ( pAfpIconInfo->afpicon_length == ICONSIZE_ICN8 )
	 	pAfpIconInfo->afpicon_data[pAfpIconInfo->afpicon_length-1];
	    else
	    	fValid = FALSE;
	    break;

	case ICONTYPE_ICS4:
	    if ( pAfpIconInfo->afpicon_length == ICONSIZE_ICS4 )
	 	pAfpIconInfo->afpicon_data[pAfpIconInfo->afpicon_length-1];
	    else
	    	fValid = FALSE;
	    break;

	case ICONTYPE_ICS8:
	    if ( pAfpIconInfo->afpicon_length == ICONSIZE_ICS8 )
	 	pAfpIconInfo->afpicon_data[pAfpIconInfo->afpicon_length-1];
	    else
	    	fValid = FALSE;
	    break;

	default:
	    fValid = FALSE;

	}
	
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {
	fValid = FALSE;
    }

    return( fValid );
}

//**
//
// Call:	IsAfpFinderInfoValid
//
// Returns:	TRUE	- valid
//		FALSE	- invalid
//
// Description: Validates the Type, Creator, Path and ParmNum values
//
BOOL
IsAfpFinderInfoValid(
	IN LPWSTR		pType,
	IN LPWSTR		pCreator,
	IN LPWSTR		pData,
	IN LPWSTR		pResource,
	IN LPWSTR		pPath,
	IN DWORD		dwParmNum
)
{
BOOL  fValid = TRUE;

    try {

	if ( dwParmNum & ~AFP_FD_PARMNUM_ALL )
	    return( FALSE );

    	if ( STRLEN( pPath ) == 0 )
	    return( FALSE );

	if ( pData != NULL ) {
    	    if ( STRLEN( pData ) == 0 )
	    	return( FALSE );
	}

	if ( pResource != NULL ) {
    	    if ( STRLEN( pResource ) == 0 )
	    	return( FALSE );
	}

	if ( pType != NULL ) {
	    if ( ( STRLEN( pType ) == 0 ) ||
		 ( STRLEN( pType ) > AFP_TYPE_LEN ) )
	    	return( FALSE );
    	}

	if ( pCreator != NULL ) {

	    if ( ( STRLEN( pCreator ) == 0 ) ||
	         ( STRLEN( pCreator ) > AFP_CREATOR_LEN ) )
	    	return( FALSE );
    	}

        return( TRUE );
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {
	fValid = FALSE;
    }

    return( fValid );
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\sfmctrs\perfsfm.c ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992  Microsoft Corporation

Module Name:

    perfsfm.c

Abstract:

    This file implements the Extensible Objects for  the Sfm object type

Created:

    Russ Blake			24 Feb 93
	Sue Adams			07 Jun 93

Revision History
	Sue Adams			23 Feb 94 - no longer need to open \MacSrv\... registry
						key to query for FirstCounter and FirstHelp.  These
	                    are now hardcoded values in the base NT system.
						SFMOBJ = 1000, SFMOBJ_HELP = 1001
	Jameel Hyder		Use SFM Apis instead of Nt apis to get the counters.

--*/

//
//  Include Files
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <string.h>
#include <wcstr.h>
#include <winperf.h>
#include "sfmctrs.h" // error message definition
#include "perfmsg.h"
#include "perfutil.h"
#include "datasfm.h"
#include <macfile.h>
#include <admin.h>

//
//  References to constants which initialize the Object type definitions
//  (see datasfm.h & .c)
//

extern SFM_DATA_DEFINITION SfmDataDefinition;

DWORD   dwOpenCount = 0;        // count of "Open" threads
BOOL    bInitOK = FALSE;        // true = DLL initialized OK

//
// Sfm data structures
//

PPERF_COUNTER_BLOCK pCounterBlock;

AFP_SERVER_HANDLE	SfmRpcHandle;

//
//  Function Prototypes
//
//      these are used to insure that the data collection functions
//      accessed by Perflib will have the correct calling format.
//

PM_OPEN_PROC		OpenAfpPerformanceData;
PM_COLLECT_PROC		CollectAfpPerformanceData;
PM_CLOSE_PROC		CloseAfpPerformanceData;


DWORD
OpenAfpPerformanceData(
    LPWSTR lpDeviceNames
    )

/*++

Routine Description:

    This routine will open the Sfmsrv FSD/FSP driver to
    pass performance data back. This routine also initializes the data
    structures used to pass data back to the registry

Arguments:

    Pointer to object ID of each device to be opened.  (Will be null for
	MacFile).


Return Value:

    None.

--*/

{
    LONG status;

    OBJECT_ATTRIBUTES SfmObjectAttributes;

    //
    //  Since SCREG is multi-threaded and will call this routine in
    //  order to service remote performance queries, this library
    //  must keep track of how many times it has been opened (i.e.
    //  how many threads have accessed it). the registry routines will
    //  limit access to the initialization routine to only one thread
    //  at a time so synchronization (i.e. reentrancy) should not be
    //  a problem
    //
#if DBG
	OutputDebugString("sfmctr.dll: Open routine entered...\n");
#endif

	if (!dwOpenCount) {
        // open Eventlog interface

        hEventLog = MonOpenEventLog();

        pCounterBlock = NULL;   // initialize pointer to memory

		status = AfpAdminConnect(L"", &SfmRpcHandle);
		
        if (!NT_SUCCESS(status)) {
            REPORT_ERROR (SFMPERF_OPEN_FILE_DRIVER_ERROR, LOG_USER);
            // this is fatal, if we can't open the driver then there's no
            // point in continuing.
            goto OpenExitPoint;
        }

        bInitOK = TRUE; // ok to use this function
    }

    dwOpenCount++;  // increment OPEN counter

    status = ERROR_SUCCESS; // for successful exit

OpenExitPoint:

    return status;
}


DWORD
CollectAfpPerformanceData(
    IN      LPWSTR  lpValueName,
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes
)
/*++

Routine Description:

    This routine will return the data for the SFM counters.

Arguments:

	IN		LPWSTR   lpValueName
			pointer to a wide character string passed by registry.

	IN OUT	LPVOID   *lppData
	IN:		pointer to the address of the buffer to receive the completed
            PerfDataBlock and subordinate structures. This routine will
            append its data to the buffer starting at the point referenced
            by *lppData.
    OUT:	points to the first byte after the data structure added by this
            routine. This routine updated the value at lppdata after appending
            its data.

	IN OUT	LPDWORD  lpcbTotalBytes
	IN:		the address of the DWORD that tells the size in bytes of the
            buffer referenced by the lppData argument
	OUT:	the number of bytes added by this routine is written to the
            DWORD pointed to by this argument

	IN OUT	LPDWORD  NumObjectTypes
	IN:		the address of the DWORD to receive the number of objects added
            by this routine
	OUT:	the number of objects added by this routine is written to the
            DWORD pointed to by this argument

Return Value:

      ERROR_MORE_DATA if buffer passed is too small to hold data
         any error conditions encountered are reported to the event log if
         event logging is enabled.

      ERROR_SUCCESS  if success or any other error. Errors, however are
         also reported to the event log.

--*/
{
    //  Variables for reformating the data

	PAFP_STATISTICS_INFO_EX	pAfpStats;
    NTSTATUS			Status;
    ULONG 				SpaceNeeded;
    PDWORD 				pdwCounter;
	LARGE_INTEGER UNALIGNED * pliCounter;
	PERF_COUNTER_BLOCK 		* pPerfCounterBlock;
    SFM_DATA_DEFINITION 	* pSfmDataDefinition;

    // variables used for error logging

    DWORD                               dwQueryType;

    //
    // before doing anything else, see if Open went OK
    //
    if (!bInitOK) {
        // unable to continue because open failed.
	    *lpcbTotalBytes = (DWORD) 0;
	    *lpNumObjectTypes = (DWORD) 0;
        return ERROR_SUCCESS; // yes, this is a successful exit
    }

    // see if this is a foreign (i.e. non-NT) computer data request
    //
    dwQueryType = GetQueryType (lpValueName);

    if (dwQueryType == QUERY_FOREIGN) {
        // this routine does not service requests for data from
        // Non-NT computers
	    *lpcbTotalBytes = (DWORD) 0;
	    *lpNumObjectTypes = (DWORD) 0;
        return ERROR_SUCCESS;
    }

    if (dwQueryType == QUERY_ITEMS){
	if ( !(IsNumberInUnicodeList (SfmDataDefinition.SfmObjectType.ObjectNameTitleIndex, lpValueName))) {

            // request received for data object not provided by this routine
            *lpcbTotalBytes = (DWORD) 0;
    	    *lpNumObjectTypes = (DWORD) 0;
            return ERROR_SUCCESS;
        }
    }

    pSfmDataDefinition = (SFM_DATA_DEFINITION *) *lppData;

    SpaceNeeded = sizeof(SFM_DATA_DEFINITION) +
		  SIZE_OF_SFM_PERFORMANCE_DATA;

    if ( *lpcbTotalBytes < SpaceNeeded ) {
	    *lpcbTotalBytes = (DWORD) 0;
	    *lpNumObjectTypes = (DWORD) 0;
        return ERROR_MORE_DATA;
    }

	//
    // Copy the (constant, initialized) Object Type and counter definitions
    //  to the caller's data buffer
    //

    memmove(pSfmDataDefinition,
	   &SfmDataDefinition,
	   sizeof(SFM_DATA_DEFINITION));

    //
    //	Format and collect SFM data from IOCTL
    //
	Status =  AfpAdminStatisticsGetEx( SfmRpcHandle, (LPBYTE *)&pAfpStats);

	if (Status != NO_ERROR)
	{
		AfpAdminDisconnect(SfmRpcHandle);
		SfmRpcHandle = 0;
		bInitOK = FALSE;
	    *lpcbTotalBytes = (DWORD) 0;
	    *lpNumObjectTypes = (DWORD) 0;
        return ERROR_SUCCESS;
	}

    //
	// Go to end of SfmDataDefinitionStructure to get to PerfCounterBlock
	//
	pPerfCounterBlock = (PERF_COUNTER_BLOCK *) &pSfmDataDefinition[1];

    pPerfCounterBlock->ByteLength = SIZE_OF_SFM_PERFORMANCE_DATA;

    // Go to end of PerfCounterBlock to get to array of counters
	pdwCounter = (PDWORD) (&pPerfCounterBlock[1]);

    *pdwCounter++ = pAfpStats->stat_MaxPagedUsage;
    *pdwCounter++ = pAfpStats->stat_CurrPagedUsage;

    *pdwCounter++ = pAfpStats->stat_MaxNonPagedUsage;
    *pdwCounter++ = pAfpStats->stat_CurrNonPagedUsage;

	*pdwCounter++ = pAfpStats->stat_CurrentSessions;
	*pdwCounter++ = pAfpStats->stat_MaxSessions;

	*pdwCounter++ = pAfpStats->stat_CurrentInternalOpens;
	*pdwCounter++ = pAfpStats->stat_MaxInternalOpens;

	*pdwCounter++ = pAfpStats->stat_NumFailedLogins;

	pliCounter = (LARGE_INTEGER UNALIGNED *) pdwCounter;
	pliCounter->QuadPart = pAfpStats->stat_DataRead.QuadPart +
						   pAfpStats->stat_DataReadInternal.QuadPart;
	pliCounter++;
	pliCounter->QuadPart = pAfpStats->stat_DataWritten.QuadPart +
						   pAfpStats->stat_DataWrittenInternal.QuadPart;

	pliCounter++;
    *pliCounter++ = pAfpStats->stat_DataIn;
	*pliCounter++ = pAfpStats->stat_DataOut;

	pdwCounter = (PDWORD) pliCounter;
	*pdwCounter++ = pAfpStats->stat_CurrQueueLength;
	*pdwCounter++ = pAfpStats->stat_MaxQueueLength;

	*pdwCounter++ = pAfpStats->stat_CurrThreadCount;
	*pdwCounter++ = pAfpStats->stat_MaxThreadCount;

	*lppData = (PVOID) pdwCounter;

    // update arguments for return

    *lpNumObjectTypes = 1;

    *lpcbTotalBytes = (DWORD)((PBYTE) pdwCounter - (PBYTE) pSfmDataDefinition);

    AfpAdminBufferFree(pAfpStats);

    return ERROR_SUCCESS;
}


DWORD
CloseAfpPerformanceData(
)

/*++

Routine Description:

    This routine closes the open handles to MacFile device performance counters

Arguments:

    None.


Return Value:

    ERROR_SUCCESS

--*/

{
    if (!(--dwOpenCount))
	{
		// when this is the last thread...

		if (SfmRpcHandle != 0)
			AfpAdminDisconnect(SfmRpcHandle);

        pCounterBlock = NULL;

        MonCloseEventLog();
    }

    return ERROR_SUCCESS;

}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\sfmctrs\datasfm.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992 Microsoft Corporation

Module Name:

      datasfm.h

Abstract:

    Header file for the SFM Extensible Object data definitions

    This file contains definitions to construct the dynamic data
    which is returned by the Configuration Registry.  Data from
    various system API calls is placed into the structures shown
    here.

Author:

   Russ Blake  02/24/93
   Sue Adams 	6/03/93

Revision History:


--*/

#ifndef _DATASFM_H_
#define _DATASFM_H_

//
//  The routines that load these structures assume that all fields
//  are packed and aligned on DWORD boundries. Alpha support may
//  change this assumption so the pack pragma is used here to insure
//  the DWORD packing assumption remains valid.
//
#pragma pack (4)

//
//  Extensible Object definitions
//

//  Update the following sort of define when adding an object type.

#define SFM_NUM_PERF_OBJECT_TYPES 1

//----------------------------------------------------------------------------

//
//  SFM Resource object type counter definitions.
//
//  These are used in the counter definitions to describe the relative
//  position of each counter in the returned data.
//

#define NUM_MAXPAGD_OFFSET	    sizeof(PERF_COUNTER_BLOCK)
#define NUM_CURPAGD_OFFSET	    NUM_MAXPAGD_OFFSET + sizeof(DWORD) // sizeof previous counter
#define NUM_MAXNONPAGD_OFFSET	NUM_CURPAGD_OFFSET + sizeof(DWORD)
#define NUM_CURNONPAGD_OFFSET	NUM_MAXNONPAGD_OFFSET + sizeof(DWORD)
#define NUM_CURSESSIONS_OFFSET 	NUM_CURNONPAGD_OFFSET + sizeof(DWORD)
#define NUM_MAXSESSIONS_OFFSET  NUM_CURSESSIONS_OFFSET + sizeof(DWORD)
#define NUM_CURFILESOPEN_OFFSET NUM_MAXSESSIONS_OFFSET + sizeof(DWORD)
#define NUM_MAXFILESOPEN_OFFSET NUM_CURFILESOPEN_OFFSET + sizeof(DWORD)
#define NUM_NUMFAILEDLOGINS_OFFSET	NUM_MAXFILESOPEN_OFFSET + sizeof(DWORD)
#define NUM_DATAREAD_OFFSET 	NUM_NUMFAILEDLOGINS_OFFSET + sizeof(DWORD)
#define NUM_DATAWRITTEN_OFFSET 	NUM_DATAREAD_OFFSET + sizeof(LARGE_INTEGER)
#define NUM_DATAIN_OFFSET 		NUM_DATAWRITTEN_OFFSET + sizeof(LARGE_INTEGER)
#define NUM_DATAOUT_OFFSET 		NUM_DATAIN_OFFSET + sizeof(LARGE_INTEGER)
#define NUM_CURQUEUELEN_OFFSET 	NUM_DATAOUT_OFFSET + sizeof(LARGE_INTEGER)
#define NUM_MAXQUEUELEN_OFFSET 	NUM_CURQUEUELEN_OFFSET + sizeof(DWORD)

#define NUM_CURTHREADS_OFFSET 	NUM_MAXQUEUELEN_OFFSET + sizeof(DWORD)
#define NUM_MAXTHREADS_OFFSET 	NUM_CURTHREADS_OFFSET + sizeof(DWORD)

#define SIZE_OF_SFM_PERFORMANCE_DATA \
				    NUM_MAXTHREADS_OFFSET + sizeof(DWORD)


//
//  This is the counter structure presently returned by Sfm for
//  each Resource.  Each Resource is an Instance, named by its number.
//  (Sfm has no instances)
//

typedef struct _SFM_DATA_DEFINITION {
    PERF_OBJECT_TYPE		SfmObjectType;
    PERF_COUNTER_DEFINITION	MaxPagdMem;
	PERF_COUNTER_DEFINITION CurPagdMem;
    PERF_COUNTER_DEFINITION	MaxNonPagdMem;
	PERF_COUNTER_DEFINITION	CurNonPagdMem;
	PERF_COUNTER_DEFINITION CurSessions;
	PERF_COUNTER_DEFINITION MaxSessions;
	PERF_COUNTER_DEFINITION CurFilesOpen;
	PERF_COUNTER_DEFINITION MaxFilesOpen;
	PERF_COUNTER_DEFINITION FailedLogins;
	PERF_COUNTER_DEFINITION DataRead;
	PERF_COUNTER_DEFINITION DataWritten;
	PERF_COUNTER_DEFINITION DataIn;
	PERF_COUNTER_DEFINITION DataOut;
	PERF_COUNTER_DEFINITION CurQueueLen;
	PERF_COUNTER_DEFINITION MaxQueueLen;
	PERF_COUNTER_DEFINITION CurThreads;
	PERF_COUNTER_DEFINITION MaxThreads;

} SFM_DATA_DEFINITION;

#pragma pack ()

#endif //_DATASFM_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\sfmctrs\perfutil.c ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992  Microsoft Corporation

Module Name:

    perfutil.c

Abstract:

    This file implements the utility routines used to construct the
	common parts of a PERF_INSTANCE_DEFINITION (see winperf.h) and
    perform event logging functions.

Created:

    Russ Blake  07/30/92
	Sue Adams	06/07/93
Revision History:

--*/
//
//  include files
//
#include <windows.h>
#include <string.h>
#include <winperf.h>
#include "sfmctrs.h"	 // error message definition
#include "perfmsg.h"
#include "perfutil.h"

#define INITIAL_SIZE     1024L
#define EXTEND_SIZE      1024L

//
// Global data definitions.
//

ULONG                   ulInfoBufferSize = 0;

HANDLE hEventLog = NULL;      // event log handle for reporting events
                              // initialized in Open... routines
DWORD  dwLogUsers = 0;        // count of functions using event log

DWORD MESSAGE_LEVEL = 0;

WCHAR GLOBAL_STRING[] = L"Global";
WCHAR FOREIGN_STRING[] = L"Foreign";
WCHAR COSTLY_STRING[] = L"Costly";

WCHAR NULL_STRING[] = L"\0";    // pointer to null string

// test for delimiter, end of line and non-digit characters
// used by IsNumberInUnicodeList routine
//
#define DIGIT       1
#define DELIMITER   2
#define INVALID     3

#define EvalThisChar(c,d) ( \
     (c == d) ? DELIMITER : \
     (c == 0) ? DELIMITER : \
     (c < (WCHAR)'0') ? INVALID : \
     (c > (WCHAR)'9') ? INVALID : \
     DIGIT)


HANDLE
MonOpenEventLog (
)
/*++

Routine Description:

    Reads the level of event logging from the registry and opens the
        channel to the event logger for subsequent event log entries.

Arguments:

      None

Return Value:

    Handle to the event log for reporting events.
    NULL if open not successful.

--*/
{
    HKEY hAppKey;
    TCHAR LogLevelKeyName[] = "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib";
    TCHAR LogLevelValueName[] = "EventLogLevel";

    LONG lStatus;

    DWORD dwLogLevel;
    DWORD dwValueType;
    DWORD dwValueSize;

    // if global value of the logging level not initialized or is disabled,
    //  check the registry to see if it should be updated.

    if (!MESSAGE_LEVEL) {

       lStatus = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                               LogLevelKeyName,
                               0,
                               KEY_READ,
                               &hAppKey);

       dwValueSize = sizeof (dwLogLevel);

       if (lStatus == ERROR_SUCCESS) {
            lStatus = RegQueryValueEx (hAppKey,
                               LogLevelValueName,
                               (LPDWORD)NULL,
                               &dwValueType,
                               (LPBYTE)&dwLogLevel,
                               &dwValueSize);

            if (lStatus == ERROR_SUCCESS) {
               MESSAGE_LEVEL = dwLogLevel;
            } else {
               MESSAGE_LEVEL = MESSAGE_LEVEL_DEFAULT;
            }
            RegCloseKey (hAppKey);
       } else {
         MESSAGE_LEVEL = MESSAGE_LEVEL_DEFAULT;
       }
    }

    if (hEventLog == NULL){
         hEventLog = RegisterEventSource (
            (LPTSTR)NULL,            // Use Local Machine
            APP_NAME);               // event log app name to find in registry

         if (hEventLog != NULL) {
            REPORT_INFORMATION (UTIL_LOG_OPEN, LOG_DEBUG);
         }
    }

    if (hEventLog != NULL) {
         dwLogUsers++;           // increment count of perfctr log users
    }
    return (hEventLog);
}


VOID
MonCloseEventLog (
)
/*++

Routine Description:

      Closes the handle to the event logger if this is the last caller

Arguments:

      None

Return Value:

      None

--*/
{
    if (hEventLog != NULL) {
        dwLogUsers--;         // decrement usage
        if (dwLogUsers <= 0) {    // and if we're the last, then close up log
            REPORT_INFORMATION (UTIL_CLOSING_LOG, LOG_DEBUG);
            DeregisterEventSource (hEventLog);
        }
    }
}

DWORD
GetQueryType (
    IN LPWSTR lpValue
)
/*++

GetQueryType

    returns the type of query described in the lpValue string so that
    the appropriate processing method may be used

Arguments

    IN lpValue
        string passed to PerfRegQuery Value for processing

Return Value

    QUERY_GLOBAL
        if lpValue == 0 (null pointer)
           lpValue == pointer to Null string
           lpValue == pointer to "Global" string

    QUERY_FOREIGN
        if lpValue == pointer to "Foriegn" string

    QUERY_COSTLY
        if lpValue == pointer to "Costly" string

    otherwise:

    QUERY_ITEMS

--*/
{
    WCHAR   *pwcArgChar, *pwcTypeChar;
    BOOL    bFound;

    if (lpValue == 0) {
        return QUERY_GLOBAL;
    } else if (*lpValue == 0) {
        return QUERY_GLOBAL;
    }

    // check for "Global" request

    pwcArgChar = lpValue;
    pwcTypeChar = GLOBAL_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_GLOBAL;

    // check for "Foreign" request

    pwcArgChar = lpValue;
    pwcTypeChar = FOREIGN_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_FOREIGN;

    // check for "Costly" request

    pwcArgChar = lpValue;
    pwcTypeChar = COSTLY_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_COSTLY;

    // if not Global and not Foreign and not Costly,
    // then it must be an item list

    return QUERY_ITEMS;

}

BOOL
IsNumberInUnicodeList (
    IN DWORD   dwNumber,
    IN LPWSTR  lpwszUnicodeList
)
/*++

IsNumberInUnicodeList

Arguments:

    IN dwNumber
        DWORD number to find in list

    IN lpwszUnicodeList
        Null terminated, Space delimited list of decimal numbers

Return Value:

    TRUE:
            dwNumber was found in the list of unicode number strings

    FALSE:
            dwNumber was not found in the list.

--*/
{
    DWORD   dwThisNumber;
    WCHAR   *pwcThisChar;
    BOOL    bValidNumber;
    BOOL    bNewItem;
    WCHAR   wcDelimiter;    // could be an argument to be more flexible

    if (lpwszUnicodeList == 0) return FALSE;    // null pointer, # not founde

    pwcThisChar = lpwszUnicodeList;
    dwThisNumber = 0;
    wcDelimiter = (WCHAR)' ';
    bValidNumber = FALSE;
    bNewItem = TRUE;

    while (TRUE) {
        switch (EvalThisChar (*pwcThisChar, wcDelimiter)) {
            case DIGIT:
                // if this is the first digit after a delimiter, then
                // set flags to start computing the new number
                if (bNewItem) {
                    bNewItem = FALSE;
                    bValidNumber = TRUE;
                }
                if (bValidNumber) {
                    dwThisNumber *= 10;
                    dwThisNumber += (*pwcThisChar - (WCHAR)'0');
                }
                break;

            case DELIMITER:
                // a delimter is either the delimiter character or the
                // end of the string ('\0') if when the delimiter has been
                // reached a valid number was found, then compare it to the
                // number from the argument list. if this is the end of the
                // string and no match was found, then return.
                //
                if (bValidNumber) {
                    if (dwThisNumber == dwNumber) return TRUE;
                    bValidNumber = FALSE;
                }
                if (*pwcThisChar == 0) {
                    return FALSE;
                } else {
                    bNewItem = TRUE;
                    dwThisNumber = 0;
                }
                break;

            case INVALID:
                // if an invalid character was encountered, ignore all
                // characters up to the next delimiter and then start fresh.
                // the invalid number is not compared.
                bValidNumber = FALSE;
                break;

            default:
                break;

        }
        pwcThisChar++;
    }

}   // IsNumberInUnicodeList
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\atalk\messages\dummy.c ===
void
DummyEntryPoint(void)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\sfmctrs\sfmctrnm.h ===
//
//  sfmctrnm.h
//
//  Offset definition file for exensible counter objects and counters
//
//  These "relative" offsets must start at 0 and be multiples of 2 (i.e.
//  even numbers). In the Open Procedure, they will be added to the
//  "First Counter" and "First Help" values fo the device they belong to,
//  in order to determine the  absolute location of the counter and
//  object names and corresponding help text in the registry.
//
//  this file is used by the extensible counter DLL code as well as the
//  counter name and help text definition file (.INI) file that is used
//  by LODCTR to load the names into the registry.
//
#define SFMOBJ 0

#define MAXPAGD 2
#define CURPAGD 4

#define MAXNONPAGD 6
#define CURNONPAGD 8

#define CURSESSIONS	10
#define MAXSESSIONS	12

#define CURFILESOPEN	14
#define MAXFILESOPEN	16

#define NUMFAILEDLOGINS		18

#define	DATAREAD	20
#define DATAWRITTEN	22

#define	DATAIN	24
#define DATAOUT	26

#define CURQUEUELEN	28
#define MAXQUEUELEN	30

#define CURTHREADS	32
#define MAXTHREADS	34




=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\ui\cmdline\parse.c ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-1991          **/
/********************************************************************/

//***
//
// Filename: Parse.c
//
// Description:
//	This module contains the entry point of DIAL.EXE.
//	This module will parse the command line. It will validate the syntax
//	and the arguments on the command line. On any error, the exit
//	module will be invoked with the appropriate error code.
//	If any default values are required, they will be supplied by
//	this module.
//
// History:
//	September 1, 1990	Narendra Gidwani 	Created original version
//

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#ifdef DBCS
#include <locale.h>
#endif /* DBCS */
#include "cmd.h"

//** Global data structures and variables used. **

//*  These variables are pointers to ASCIIZ which will be set to
//   point to switch values of the command line by GetSwitchValue.
//   These pointers are global within this module.

CHAR * gblEntity    		= NULL;
CHAR * gblCommand    		= NULL;
CHAR * gblServer  		= NULL;
CHAR * gblName     		= NULL;
CHAR * gblPath     		= NULL;
CHAR * gblPassword  		= NULL;
CHAR * gblReadOnly      	= NULL;
CHAR * gblMaxUses 		= NULL;
CHAR * gblOwnerName		= NULL;
CHAR * gblGroupName		= NULL;
CHAR * gblPermissions		= NULL;
CHAR * gblLoginMessage		= NULL;
CHAR * gblMaxSessions		= NULL;
CHAR * gblGuestsAllowed	 	= NULL;
CHAR * gblMacServerName	 	= NULL;
CHAR * gblUAMRequired		= NULL;
CHAR * gblAllowSavedPasswords	= NULL;
CHAR * gblType			= NULL;
CHAR * gblCreator		= NULL;
CHAR * gblDataFork		= NULL;
CHAR * gblResourceFork		= NULL;
CHAR * gblTargetFile		= NULL;
CHAR * gblHelp		        = NULL;


// Non translatable text
//

CHAR * pszVolume 	= "Volume";
CHAR * pszAdd 	 	= "/Add";
CHAR * pszDelete 	= "/Remove";
CHAR * pszSet    	= "/Set";
CHAR * pszDirectory 	= "Directory";
CHAR * pszServer 	= "Server";
CHAR * pszForkize 	= "Forkize";

CMD_FMT DelVolArgFmt[] = {

{ "/Server", 		(CHAR *)&gblServer,		0},
{ "/Name",        	(CHAR *)&gblName,		0},
{ "/Help",        	(CHAR *)&gblHelp,		0},
{ "/?",        	        (CHAR *)&gblHelp,	        0},
{ NULL,			(CHAR *)NULL,			0}
};

CMD_FMT AddVolArgFmt[] = {

{ "/Server", 	  	(CHAR *)&gblServer,		0},
{ "/Name",        	(CHAR *)&gblName,		0},
{ "/Path",        	(CHAR *)&gblPath,		0},
{ "/Password",    	(CHAR *)&gblPassword,		0},
{ "/ReadOnly",    	(CHAR *)&gblReadOnly,		0},
{ "/MaxUsers",		(CHAR *)&gblMaxUses,		0},
{ "/Help",        	(CHAR *)&gblHelp,		0},
{ "/?",        	        (CHAR *)&gblHelp,	        0},
{ NULL,			(CHAR *)NULL,			0}
};

CMD_FMT SetVolArgFmt[] = {

{ "/Server", 	  	(CHAR *)&gblServer,		0},
{ "/Name",        	(CHAR *)&gblName,		0},
{ "/Password",    	(CHAR *)&gblPassword,		0},
{ "/ReadOnly",    	(CHAR *)&gblReadOnly,		0},
{ "/MaxUsers",		(CHAR *)&gblMaxUses,		0},
{ "/Help",        	(CHAR *)&gblHelp,		0},
{ "/?",        	        (CHAR *)&gblHelp,	        0},
{ NULL,			(CHAR *)NULL,			0}
};

CMD_FMT DirArgFmt[] = {

{ "/Server", 	  	(CHAR *)&gblServer,		0},
{ "/Path",        	(CHAR *)&gblPath,		0},
{ "/Owner",    		(CHAR *)&gblOwnerName,		0},
{ "/Group",    		(CHAR *)&gblGroupName,		0},
{ "/Permissions",	(CHAR *)&gblPermissions,	0},
{ "/Help",        	(CHAR *)&gblHelp,		0},
{ "/?",        	        (CHAR *)&gblHelp,	        0},
{ NULL,			(CHAR *)NULL,			0}
};

CMD_FMT ServerArgFmt[] = {

{ "/Server", 	  	(CHAR *)&gblServer,		0},
{ "/MaxSessions",       (CHAR *)&gblMaxSessions,	0},
{ "/LoginMessage",    	(CHAR *)&gblLoginMessage,	0},
{ "/UAMRequired",	(CHAR *)&gblUAMRequired,	0},
{ "/AllowSavedPasswords",(CHAR *)&gblAllowSavedPasswords,0},
{ "/MacServerName",	(CHAR *)&gblMacServerName,	0},
{ "/Help",        	(CHAR *)&gblHelp,		0},
{ "/?",        	        (CHAR *)&gblHelp,	        0},
{ NULL,			(CHAR *)NULL,			0}
};

CMD_FMT ForkizeArgFmt[] = {		

{ "/Server", 	  	(CHAR *)&gblServer,		0},
{ "/Type", 	  	(CHAR *)&gblType,		0},
{ "/Creator",       	(CHAR *)&gblCreator,		0},
{ "/DataFork",    	(CHAR *)&gblDataFork,		0},
{ "/ResourceFork",    	(CHAR *)&gblResourceFork,	0},
{ "/TargetFile",	(CHAR *)&gblTargetFile,		0},
{ "/Help",        	(CHAR *)&gblHelp,		0},
{ "/?",        	        (CHAR *)&gblHelp,	        0},
{ NULL,			(CHAR *)NULL,			0}
};


//**
//
// Call: 	main
//
// Entry:  	int argc; 	- Number of command line arguments	
//		char *argv[];	- Array of pointers to ASCIIZ command line
//				  arguments.
//
// Exit:	none.
//
// Returns:	none.
//
// Description: Calls the command line parser with the command line
//		arguments.
//
VOID _cdecl
main( INT argc, CHAR * argv[] )
{

#ifdef DBCS
    setlocale( LC_ALL, "" );
#endif /* DBCS */

    // This will act like xacc or yacc. It will parse the command line
    // and call the appropriate function to carry out an action.
    // Thus this procedure will never return.

    ParseCmdArgList( argc, argv );
}

//**
//
// Call:	ParseCmdArgList
//
// Entry:	int argc;	- Number of command line arguments.
//		char *argv[];   - Array of pointers to ASCIIZ command line
//				  arguments.
//
// Exit:	none.
//
// Returns:	none.
//
// Description:
//	 	Will parse command line for any errors and determine
//		from the syntax what the user wishes to do. Command
//		line arguments will be validated.
//
VOID
ParseCmdArgList(
    INT argc,
    CHAR * argv[]
)
{
    DWORD   ArgCount = 0;

    if ( argc == 1 )
	PrintMessageAndExit( IDS_GENERAL_SYNTAX, NULL );

    //
    // What is the entity being operated on ?
    //

    gblEntity = argv[++ArgCount];

    if ( _strnicmp( pszVolume, gblEntity, strlen( gblEntity ) ) == 0 )
    {
	if ( argc == 2 )
	    PrintMessageAndExit( IDS_VOLUME_SYNTAX, NULL );

    	gblCommand = argv[++ArgCount];

    	if ( _strnicmp( pszAdd, gblCommand, strlen( gblCommand ) ) == 0 )
	{
	    GetArguments( AddVolArgFmt, argv, argc, ArgCount );

            if ( gblHelp != (CHAR*)NULL )
	        PrintMessageAndExit( IDS_VOLUME_SYNTAX, NULL );

	    DoVolumeAdd( gblServer, gblName, gblPath, gblPassword, gblReadOnly,
			 gblGuestsAllowed, gblMaxUses );
     	}
    	else if ( _strnicmp( pszDelete, gblCommand, strlen( gblCommand ) ) == 0 )
	{
	    GetArguments( DelVolArgFmt, argv, argc, ArgCount );

            if ( gblHelp != (CHAR*)NULL )
	        PrintMessageAndExit( IDS_VOLUME_SYNTAX, NULL );

	    DoVolumeDelete( gblServer, gblName );
	}
    	else if ( _strnicmp( pszSet, gblCommand, strlen( gblCommand ) ) == 0 )
	{
	    GetArguments( SetVolArgFmt, argv, argc, ArgCount );

            if ( gblHelp != (CHAR*)NULL )
	        PrintMessageAndExit( IDS_VOLUME_SYNTAX, NULL );

	    DoVolumeSet( gblServer, gblName, gblPassword, gblReadOnly,
			 gblGuestsAllowed, gblMaxUses );
	}
	else
	    PrintMessageAndExit( IDS_VOLUME_SYNTAX, NULL );
    }
    else if ( _strnicmp( pszDirectory, gblEntity, strlen( gblEntity ) ) == 0 )
    {
	if ( argc == 2 )
	    PrintMessageAndExit( IDS_DIRECTORY_SYNTAX, NULL );

	GetArguments( DirArgFmt, argv, argc, ArgCount );

        if ( gblHelp != (CHAR*)NULL )
	    PrintMessageAndExit( IDS_DIRECTORY_SYNTAX, NULL );

	DoDirectorySetInfo( gblServer, gblPath, gblOwnerName, gblGroupName,
			    gblPermissions );
    }

    else if ( _strnicmp( pszServer, gblEntity, strlen( gblEntity ) ) == 0 )
    {
	if ( argc == 2 )
	    PrintMessageAndExit( IDS_SERVER_SYNTAX, NULL );

	GetArguments( ServerArgFmt, argv, argc, ArgCount );

        if ( gblHelp != (CHAR*)NULL )
	    PrintMessageAndExit( IDS_SERVER_SYNTAX, NULL );

	DoServerSetInfo( gblServer, gblMaxSessions, gblLoginMessage,
			 gblGuestsAllowed, gblUAMRequired,
			 gblAllowSavedPasswords, gblMacServerName );
    }
    else if ( _strnicmp( pszForkize, gblEntity, strlen( gblEntity ) ) == 0 )
    {
	GetArguments( ForkizeArgFmt, argv, argc, ArgCount );

        if ( gblHelp != (CHAR*)NULL )
	    PrintMessageAndExit( IDS_FORKIZE_SYNTAX, NULL );

	DoForkize( gblServer, gblType, gblCreator, gblDataFork,
		   gblResourceFork, gblTargetFile );
    }
    else
	PrintMessageAndExit( IDS_GENERAL_SYNTAX, NULL );
}

VOID
GetArguments(
    CMD_FMT * pArgFmt,
    CHAR *    argv[],
    DWORD     argc,
    DWORD     ArgCount
)
{

    //
    //  To determine by the syntax what the user wishes to do we first
    //  run through the arguments and get switch values.
    //

    while ( ++ArgCount < argc )
    {
	//
	// If it is a switch, get its value.
	//

	if ( argv[ArgCount][0] == '/' )
	    GetSwitchValue( pArgFmt, argv[ArgCount] );
	else
	    PrintMessageAndExit( IDS_GENERAL_SYNTAX, NULL );
    }
}

//**
//
// Call:	GetSwitchValue
//
// Entry:	CHAR * SwitchPtr; - Pointer to ASCIIZ containing a command
//				    line argument.
//				    ex. - /phoneb:c:\subdir
//
//		CHAR ** LastArg;  - Nothing.
//
// Exit:	CHAR * SwitchPtr; - same as entry.
//
//		CHAR ** LastArg;  - Pointer to a pointer to ASCIIZ containig
//				    the text of the first bad switch if
//				    there were any.
//
// Returns:	0 - Success.
//		AMBIGIOUS_SWITCH_ERRROR  - failure.
//		UNKNOWN_SWITCH_ERROR 	 - failure.
//		MEM_ALLOC_ERROR 	 - failure.
//		MULTIPLE_SWITCH_ERROR 	 - failure.
//
// Description: This procedure will run through all the valid switches
//		in the cmdfmt structure and retrieve the value of the
//		the switch. The value of the switch will be inserted into the
//		cmdfmt structure. It will expand abbreviated switches. If
//		the switch had no value, it will insert a null character
//		as the value. If the switch did not appear, the value
//		pointer of the switch (in the cmdfmt structure)
//	 	will remain unchanged ( should be initialized to NULL ).
//		This procedure uses the same data structure as GetCmdArgs5,
//		hence some fields may be ignored. This is done to make the
//		functionality of this procedure extendable.
//		
//
VOID
GetSwitchValue(
    CMD_FMT * pArgFmt,
    IN CHAR * pchSwitchPtr
)
{
    INT     intFound = -1;
    DWORD   dwIndex;
    DWORD   dwSwitchLen;
    CHAR *  pchSeparatorPtr;

    //
    // Get length of the switch part of the argument.
    //

    if ( ( pchSeparatorPtr = strchr( pchSwitchPtr, ':' )) != NULL )
        dwSwitchLen = (DWORD)(pchSeparatorPtr - pchSwitchPtr);
    else
	//
	// If the switch had no value.
	//

    	dwSwitchLen = strlen( pchSwitchPtr );


    //
    // Run through all switches.
    //

    for ( dwIndex = 0; pArgFmt[dwIndex].cf_parmstr != NULL; dwIndex++ )
    {

	//
	// If this switch matches (partly or completely) one of the
	// valid switches.
	//

	if ( !_strnicmp(  pArgFmt[dwIndex].cf_parmstr,
			 pchSwitchPtr,
			 dwSwitchLen ) )
	{

	    if ( intFound < 0 )
	    	intFound = dwIndex;
	    else
	    {
		//
		// If this argument has matched another switch also.
		//

		if ( pchSeparatorPtr )
		    *pchSeparatorPtr = '\0';

	        PrintMessageAndExit( IDS_AMBIGIOUS_SWITCH_ERROR, pchSwitchPtr );
	    }
	}
    }

    //
    // If we could not find a match for this switch.
    //

    if ( intFound < 0 )
    {

	if ( pchSeparatorPtr )
	    *pchSeparatorPtr = '\0';

	PrintMessageAndExit( IDS_UNKNOWN_SWITCH_ERROR, pchSwitchPtr );
    }

    //
    // If this switch is appearing for the second time.
    //

    if ( pArgFmt[intFound].cf_usecount > 0 )
    {
	if ( pchSeparatorPtr )
	    *pchSeparatorPtr = '\0';

	PrintMessageAndExit( IDS_DUPLICATE_SWITCH_ERROR, pchSwitchPtr );
    }
    else
        pArgFmt[intFound].cf_usecount++;

    //
    // Get the switch value if there is one.
    //

    if ( ( pchSeparatorPtr ) && ((CHAR *)(pchSeparatorPtr + 1)) )
    {
	*(CHAR **)pArgFmt[intFound].cf_ptr =  ++pchSeparatorPtr;
    }
    else
    {
	*(CHAR **)pArgFmt[intFound].cf_ptr = (CHAR *)"";
    }

}


/*******************************************************************

    NAME:	IsDriveGreaterThan2Gig

    SYNOPSIS:	Determines if the disk is bigger than 2Gig.  If it, return
		TRUE so that a warning can be displayed to the user

    RETURNS:	TRUE if disk is larger than 2Gig
		FALSE otherwise

    HISTORY:
	NarenG		11/18/92	Modified for AFPMGR

********************************************************************/

BOOL IsDriveGreaterThan2Gig( LPSTR lpDrivePath )
{
    DWORD         SectorsPerCluster;
    DWORD         BytesPerSector;
    DWORD         NumberOfFreeClusters;
    DWORD         TotalNumberOfClusters;
    DWORDLONG       DriveSize;
    DWORDLONG       TwoGig = MAXLONG;


    //
    // If this drive volume is greater than 2G then we print warning
    //

    if ( !GetDiskFreeSpace( lpDrivePath,
                              &SectorsPerCluster,
                              &BytesPerSector,
                              &NumberOfFreeClusters,
                              &TotalNumberOfClusters
                            ))
    {
        // some error: can't do much, so just assume this drive is smaller than 2GB.  That's
        // probably better than alarming the customer by putting the warning?
	    return FALSE;
    }

    DriveSize = UInt32x32To64( SectorsPerCluster * BytesPerSector,
                               TotalNumberOfClusters ) ;

    if ( DriveSize > TwoGig )
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\ui\cmdline\cmd.h ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.	   **/
/********************************************************************/

//***
//
// Filename:    cmd.h
//
// Description:
//
// History:
//	Nov 11,1993.	NarenG		Created original version.
//

#define MACFILE_IDS_BASE        1000

//
// Do not change the ID numbers of these strings. AFPERR_*
// map to these string ids via the formula:
// -(AFPERR_*) + MACFILE_IDS_BASE + AFPERR_BASE = IDS_*
//

#define AFPERR_TO_STRINGID( AfpErr )                            \
                                                                \
    ((( AfpErr <= AFPERR_BASE ) && ( AfpErr >= AFPERR_MIN )) ?  \
    (MACFILE_IDS_BASE+AFPERR_BASE-AfpErr) : AfpErr )


#define IDS_AFPERR_InvalidVolumeName            (MACFILE_IDS_BASE+1)
#define IDS_AFPERR_InvalidId                    (MACFILE_IDS_BASE+2)
#define IDS_AFPERR_InvalidParms                 (MACFILE_IDS_BASE+3)
#define IDS_AFPERR_CodePage                     (MACFILE_IDS_BASE+4)
#define IDS_AFPERR_InvalidServerName            (MACFILE_IDS_BASE+5)
#define IDS_AFPERR_DuplicateVolume              (MACFILE_IDS_BASE+6)
#define IDS_AFPERR_VolumeBusy                   (MACFILE_IDS_BASE+7)
#define IDS_AFPERR_VolumeReadOnly               (MACFILE_IDS_BASE+8)
#define IDS_AFPERR_DirectoryNotInVolume         (MACFILE_IDS_BASE+9)
#define IDS_AFPERR_SecurityNotSupported         (MACFILE_IDS_BASE+0)
#define IDS_AFPERR_BufferSize                   (MACFILE_IDS_BASE+10)
#define IDS_AFPERR_DuplicateExtension           (MACFILE_IDS_BASE+12)
#define IDS_AFPERR_UnsupportedFS                (MACFILE_IDS_BASE+13)
#define IDS_AFPERR_InvalidSessionType           (MACFILE_IDS_BASE+14)
#define IDS_AFPERR_InvalidServerState           (MACFILE_IDS_BASE+15)
#define IDS_AFPERR_NestedVolume                 (MACFILE_IDS_BASE+16)
#define IDS_AFPERR_InvalidComputername          (MACFILE_IDS_BASE+17)
#define IDS_AFPERR_DuplicateTypeCreator         (MACFILE_IDS_BASE+18)
#define IDS_AFPERR_TypeCreatorNotExistant       (MACFILE_IDS_BASE+19)
#define IDS_AFPERR_CannotDeleteDefaultTC        (MACFILE_IDS_BASE+20)
#define IDS_AFPERR_CannotEditDefaultTC          (MACFILE_IDS_BASE+21)
#define IDS_AFPERR_InvalidTypeCreator           (MACFILE_IDS_BASE+22)
#define IDS_AFPERR_InvalidExtension             (MACFILE_IDS_BASE+23)
#define IDS_AFPERR_TooManyEtcMaps               (MACFILE_IDS_BASE+24)
#define IDS_AFPERR_InvalidPassword              (MACFILE_IDS_BASE+25)
#define IDS_AFPERR_VolumeNonExist               (MACFILE_IDS_BASE+26)
#define IDS_AFPERR_NoSuchUserGroup              (MACFILE_IDS_BASE+27)
#define IDS_AFPERR_NoSuchUser                   (MACFILE_IDS_BASE+28)
#define IDS_AFPERR_NoSuchGroup                  (MACFILE_IDS_BASE+29)
#define IDS_GENERAL_SYNTAX                      (MACFILE_IDS_BASE+30)
#define IDS_VOLUME_SYNTAX                       (MACFILE_IDS_BASE+31)
#define IDS_DIRECTORY_SYNTAX                    (MACFILE_IDS_BASE+32)
#define IDS_SERVER_SYNTAX                       (MACFILE_IDS_BASE+33)
#define IDS_FORKIZE_SYNTAX                      (MACFILE_IDS_BASE+34)
#define IDS_AMBIGIOUS_SWITCH_ERROR              (MACFILE_IDS_BASE+35)
#define IDS_UNKNOWN_SWITCH_ERROR                (MACFILE_IDS_BASE+36)
#define IDS_DUPLICATE_SWITCH_ERROR              (MACFILE_IDS_BASE+37)
#define IDS_API_ERROR                           (MACFILE_IDS_BASE+38)
#define IDS_SUCCESS                             (MACFILE_IDS_BASE+39)
#define IDS_VOLUME_TOO_BIG                      (MACFILE_IDS_BASE+40)

//  This structure is required by GetSwitchValue. It will store the
//  information of the switches on the command line. This structure is
//  global within this module.

typedef struct cmdfmt {

    CHAR *   cf_parmstr;
    CHAR *   cf_ptr;
    DWORD    cf_usecount;

} CMD_FMT, * PCMD_FMT;


VOID
ParseCmdArgList(
    INT argc,
    CHAR * argv[]
);


BOOL
IsDriveGreaterThan2Gig( LPSTR lpwsDrivePath );

VOID
GetArguments(
    CMD_FMT * pArgFmt,
    CHAR *    argv[],
    DWORD     argc,
    DWORD     ArgCount
);

VOID
GetSwitchValue(
    CMD_FMT * pArgFmt,
    IN CHAR * pchSwitchPtr
);

VOID
PrintMessageAndExit(
    DWORD  ids,
    CHAR * pchInsertString
);

VOID
DoVolumeAdd(
    CHAR * gblServer,
    CHAR * gblName,
    CHAR * gblPath,
    CHAR * gblPassword,
    CHAR * gblReadOnly,
    CHAR * gblGuestsAllowed,
    CHAR * gblMaxUses
);

VOID
DoVolumeDelete(
    CHAR * gblServer,
    CHAR * gblName
);

VOID
DoVolumeSet(
    CHAR * gblServer,
    CHAR * gblName,
    CHAR * gblPassword,
    CHAR * gblReadOnly,
    CHAR * gblGuestsAllowed,
    CHAR * gblMaxUses
);

VOID
DoServerSetInfo(
    CHAR * gblServer,
    CHAR * gblMaxSessions,
    CHAR * gblLoginMessage,
    CHAR * gblGuestsAllowed,
    CHAR * gblUAMRequired,
    CHAR * pchAllowSavedPasswords,
    CHAR * pchMacServerName
);

VOID
DoForkize(
    CHAR * gblServer,
    CHAR * gblType,
    CHAR * gblCreator,
    CHAR * gblDataFork,
    CHAR * gblResourceFork,
    CHAR * gblTargetFile
);

VOID
DoDirectorySetInfo(
    CHAR * gblServer,
    CHAR * gblPath,
    CHAR * gblOwnerName,
    CHAR * gblGroupName,
    CHAR * gblPermissions
);

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\ui\cmdline\cmd.c ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.	   **/
/********************************************************************/

//***
//
// Filename:	cmd.c
//
// Description:
//
// History:
//		Oct 1,1993.	NarenG		Created original version.
//

#include <client.h>
#include <stdio.h>
#include <stdlib.h>
#include "cmd.h"

CHAR * pszTRUE  	= "TRUE";
CHAR * pszFALSE 	= "FALSE";
CHAR * pszUnlimited = "UNLIMITED";


VOID
PrintMessageAndExit(
    DWORD  ids,
    CHAR * pchInsertString
)
{
    CHAR    Error[10];
    CHAR    MsgBuf[1000];
    DWORD   cbMessage;
    LPSTR   pszMessage = NULL;

    switch( ids )
    {
    case IDS_GENERAL_SYNTAX:
    case IDS_VOLUME_SYNTAX:
    case IDS_DIRECTORY_SYNTAX:
    case IDS_SERVER_SYNTAX:
    case IDS_FORKIZE_SYNTAX:
    case IDS_VOLUME_TOO_BIG:
    case IDS_SUCCESS:

        cbMessage = FormatMessageA(
                                FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                FORMAT_MESSAGE_FROM_HMODULE,
                                NULL,
                                (DWORD)ids,
                                LANG_NEUTRAL,
                                (LPSTR)&pszMessage,
                                128,
                                NULL );


        break;

    case IDS_AMBIGIOUS_SWITCH_ERROR:
    case IDS_UNKNOWN_SWITCH_ERROR:
    case IDS_DUPLICATE_SWITCH_ERROR:

        cbMessage = FormatMessageA(
                                FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                FORMAT_MESSAGE_FROM_HMODULE    |
                                FORMAT_MESSAGE_IGNORE_INSERTS,
                                NULL,
                                (DWORD)ids,
                                LANG_NEUTRAL,
                                (LPSTR)&pszMessage,
                                128,
                                NULL );

        if ( cbMessage > 0 )
        {
            sprintf( MsgBuf, pszMessage, pchInsertString );

            CharToOem( MsgBuf, MsgBuf );

            LocalFree( pszMessage );

            fprintf( stdout, MsgBuf );

            fprintf( stdout, "\n" );

            pszMessage = NULL;
        }

        exit( 0 );

        break;

    case IDS_API_ERROR:

        _itoa( (int)((ULONG_PTR)pchInsertString), Error, 10 );

        cbMessage = FormatMessageA(
                                FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                FORMAT_MESSAGE_FROM_HMODULE    |
                                FORMAT_MESSAGE_IGNORE_INSERTS,
                                NULL,
                                (DWORD)ids,
                                LANG_NEUTRAL,
                                (LPSTR)&pszMessage,
                                128,
                                NULL );

        if ( cbMessage > 0 )
        {
            sprintf( MsgBuf, pszMessage, Error );

            CharToOem( MsgBuf, MsgBuf );

            fprintf( stdout, MsgBuf );

            fprintf( stdout, "\n" );

            LocalFree( pszMessage );

            pszMessage = NULL;
        }

        if ( ((LONG)((LONG_PTR)pchInsertString)) > 0 )
        {
            cbMessage = FormatMessageA(
                                FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                FORMAT_MESSAGE_FROM_SYSTEM,
                                NULL,
                                (LONG)((LONG_PTR)pchInsertString),
                                LANG_NEUTRAL,
                                (LPSTR)&pszMessage,
                                128,
                                NULL );
        }

        if ( ((LONG)((LONG_PTR)pchInsertString)) < 0 )
        {
            cbMessage = FormatMessageA(
                                FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                FORMAT_MESSAGE_FROM_HMODULE,
                                NULL,
                                AFPERR_TO_STRINGID( (LONG)((LONG_PTR)pchInsertString) ),
                                LANG_NEUTRAL,
                                (LPSTR)&pszMessage,
                                128,
                                NULL );

        }

        break;

    default:
        exit( 0 );
    }

    if (( cbMessage > 0 ) && (pszMessage != NULL ))
    {
        CharToOem( pszMessage, pszMessage );

        fprintf( stdout, pszMessage );

        fprintf( stdout, "\n" );

        LocalFree( pszMessage );
    }

    exit(0);
}

VOID
DoVolumeAdd(
    CHAR * pchServer,
    CHAR * pchName,
    CHAR * pchPath,
    CHAR * pchPassword,
    CHAR * pchReadOnly,
    CHAR * pchGuestsAllowed,
    CHAR * pchMaxUses
)
{
    PAFP_DIRECTORY_INFO pAfpDirInfo;
    AFP_VOLUME_INFO 	AfpVolInfo;
    DWORD	  	dwRetCode;
    AFP_SERVER_HANDLE   hServer;
    WCHAR		wchName[AFP_VOLNAME_LEN+1];
    WCHAR		wchPassword[AFP_VOLPASS_LEN+1];
    WCHAR		wchServer[CNLEN+3];
    LPWSTR		lpwsPath;
    LPSTR		lpDrivePath;
    DWORD       dwParmNum = AFP_DIR_PARMNUM_PERMS;

    ZeroMemory( &AfpVolInfo, sizeof( AfpVolInfo ) );

    //
    // Check to see if the mandatory values are not supplied
    //

    if ( ( pchName == NULL ) || ( pchPath == NULL ) || ( *pchName == (CHAR)NULL)
	 || ( *pchPath == (CHAR)NULL ) )
	PrintMessageAndExit( IDS_VOLUME_SYNTAX, NULL );
	
    mbstowcs(wchName, pchName, sizeof(wchName)/sizeof(wchName[0]));

    AfpVolInfo.afpvol_name = wchName;

    lpwsPath = LocalAlloc(LPTR, (strlen(pchPath) + 1) * sizeof(WCHAR));

    if (lpwsPath == NULL)
	    PrintMessageAndExit(IDS_API_ERROR, (CHAR*)ERROR_NOT_ENOUGH_MEMORY);

    lpDrivePath = LocalAlloc(LPTR, (CNLEN + 6 + 1));
    if (lpDrivePath == NULL)
	    PrintMessageAndExit(IDS_API_ERROR, (CHAR*)ERROR_NOT_ENOUGH_MEMORY);

    mbstowcs(lpwsPath, pchPath, strlen(pchPath)+1);

    AfpVolInfo.afpvol_path = lpwsPath;

    if ( pchServer )
    {
	    if (*pchServer)
    	    mbstowcs(wchServer, pchServer, sizeof(wchServer)/sizeof(WCHAR));
	    else
	        PrintMessageAndExit(IDS_VOLUME_SYNTAX, NULL);
    }

    if ( (pchPassword) && ( strlen( pchPassword ) > 0 ) )
    {
        mbstowcs(wchPassword, pchPassword, sizeof(wchPassword)/sizeof(WCHAR));

        AfpVolInfo.afpvol_password = wchPassword;
    }
    else
        AfpVolInfo.afpvol_password = NULL;

    if ( pchMaxUses )
    {
        if ( *pchMaxUses )
        {
	    if (_strnicmp(pchMaxUses, pszUnlimited, strlen(pchMaxUses)) == 0)
    	        AfpVolInfo.afpvol_max_uses  = AFP_VOLUME_UNLIMITED_USES;
	    else if ( strspn(pchMaxUses, "1234567890") != strlen(pchMaxUses) )
	        PrintMessageAndExit(IDS_VOLUME_SYNTAX, NULL);
            else if ( strlen( pchMaxUses ) > strlen( "4294967295" ) )
    	        AfpVolInfo.afpvol_max_uses  = AFP_VOLUME_UNLIMITED_USES;
            else if ( ( strlen( pchMaxUses ) == strlen( "4294967295" ) ) &&
                      ( _stricmp( pchMaxUses, "4294967295" ) > 0 ) )
    	        AfpVolInfo.afpvol_max_uses  = AFP_VOLUME_UNLIMITED_USES;
	    else
    	        AfpVolInfo.afpvol_max_uses  = atoi(pchMaxUses);

            if ( AfpVolInfo.afpvol_max_uses == 0 )
                PrintMessageAndExit(IDS_VOLUME_SYNTAX, NULL);
        }
        else
            PrintMessageAndExit(IDS_VOLUME_SYNTAX, NULL);
    }
    else
    	AfpVolInfo.afpvol_max_uses = AFP_VOLUME_UNLIMITED_USES;

    AfpVolInfo.afpvol_props_mask = 0;

    if (pchReadOnly != NULL)
    {
        if ( *pchReadOnly )
        {
            if (_strnicmp(pchReadOnly, pszTRUE, strlen(pchReadOnly) ) == 0)
                AfpVolInfo.afpvol_props_mask |= AFP_VOLUME_READONLY;
	    else if (_strnicmp(pchReadOnly, pszFALSE, strlen(pchReadOnly))!=0)
	        PrintMessageAndExit(IDS_VOLUME_SYNTAX, NULL);
        }
        else
	    PrintMessageAndExit(IDS_VOLUME_SYNTAX, NULL);
    }

    if (pchGuestsAllowed != NULL)
    {
        if ( *pchGuestsAllowed )
        {
            if (_strnicmp(pchGuestsAllowed,pszTRUE,strlen(pchGuestsAllowed))==0)
                AfpVolInfo.afpvol_props_mask |= AFP_VOLUME_GUESTACCESS;
	    else if(_strnicmp(pchGuestsAllowed,
                             pszFALSE,strlen(pchGuestsAllowed))!=0)
	        PrintMessageAndExit(IDS_VOLUME_SYNTAX, NULL);
        }
        else
            PrintMessageAndExit(IDS_VOLUME_SYNTAX, NULL);
    }
    else
    	AfpVolInfo.afpvol_props_mask |= AFP_VOLUME_GUESTACCESS;


    //
    // Connect with the server
    //

    dwRetCode = AfpAdminConnect(pchServer ? wchServer : NULL, &hServer);

    if (dwRetCode != NO_ERROR)
	PrintMessageAndExit(IDS_API_ERROR, (CHAR *)((ULONG_PTR)dwRetCode));

    //
    // First get and set directory information.
    //


    dwRetCode = AfpAdminDirectoryGetInfo(hServer,
					    lpwsPath,
					    (LPBYTE*)&pAfpDirInfo);

    if (dwRetCode == NO_ERROR)
    {
        pAfpDirInfo->afpdir_path = lpwsPath;

        if ( pAfpDirInfo->afpdir_owner != (LPWSTR)NULL )
        {
            dwParmNum |= AFP_DIR_PARMNUM_OWNER;
        }

        if ( pAfpDirInfo->afpdir_group != (LPWSTR)NULL )
        {
            dwParmNum |= AFP_DIR_PARMNUM_GROUP;
        }

        dwRetCode = AfpAdminVolumeAdd(hServer, (LPBYTE)&AfpVolInfo);
		
		// Directory permissions need not be changed here

#if 0
        if (dwRetCode == NO_ERROR)
        {
		    dwRetCode = AfpAdminDirectorySetInfo(hServer,
                                          	  (LPBYTE)pAfpDirInfo,
                                              dwParmNum);
        }
#endif

	    if (dwRetCode != NO_ERROR)
	    {
		    printf ("AfpAdminVolumeAdd failed with error %ld\n", 
			    dwRetCode);
	    }	

        AfpAdminBufferFree(pAfpDirInfo);
    }

    // we will get this if it's a CDROM.  UI ignores this error: why not macfile?
    else if (dwRetCode == AFPERR_SecurityNotSupported)
    {
        dwRetCode = AfpAdminVolumeAdd(hServer, (LPBYTE)&AfpVolInfo);
    }

    if (dwRetCode != NO_ERROR)
	PrintMessageAndExit(IDS_API_ERROR, (CHAR *)((ULONG_PTR)dwRetCode));

    AfpAdminDisconnect(hServer);

    LocalFree(lpwsPath);

    if (pchServer)
    {
        DWORD   dwLen;

        // using the server name, form a path like \\foobar\d$\
        // (the +2 for the leading \\)
        for (dwLen=0; dwLen < CNLEN+2; dwLen++ )
        {
            lpDrivePath[dwLen] = pchServer[dwLen];
            if (pchServer[dwLen] == 0)
            {
                break;
            }
        }
        lpDrivePath[CNLEN] = 0;          // just to be sure
        strcat(lpDrivePath,"\\");
        dwLen = strlen(lpDrivePath);
        lpDrivePath[dwLen] = pchPath[0];
        lpDrivePath[dwLen+1] = 0;
        strcat(lpDrivePath,"$\\");
    }
    else
    {
        strncpy(lpDrivePath, pchPath, 3);
        lpDrivePath[2] = '\\';
        lpDrivePath[3] = 0;
    }

    if (IsDriveGreaterThan2Gig(lpDrivePath))
    {
        LocalFree(lpDrivePath);
        PrintMessageAndExit(IDS_VOLUME_TOO_BIG, NULL);
    }

    LocalFree(lpDrivePath);

    if (dwRetCode != NO_ERROR)
        PrintMessageAndExit(IDS_API_ERROR, (CHAR *)((ULONG_PTR)dwRetCode));
    else
        PrintMessageAndExit(IDS_SUCCESS, NULL);
	
}

VOID
DoVolumeDelete(
    CHAR * pchServer,
    CHAR * pchName
)
{
    WCHAR 		 wchName[AFP_VOLNAME_LEN+1];
    DWORD 		 dwRetCode;
    AFP_SERVER_HANDLE    hServer;
    WCHAR		 wchServer[CNLEN+3];
    PAFP_VOLUME_INFO     pAfpVolumeInfo;
    PAFP_CONNECTION_INFO pAfpConnections;
    PAFP_CONNECTION_INFO pAfpConnInfoIter;
    DWORD                cEntriesRead;
    DWORD                cTotalAvail;
    DWORD                dwIndex;

    ZeroMemory (wchName, (AFP_VOLNAME_LEN+1)*sizeof(WCHAR));
    if ( ( pchName == NULL ) || ( *pchName == (CHAR)NULL ) )
	PrintMessageAndExit( IDS_VOLUME_SYNTAX, NULL );

    mbstowcs(wchName, pchName, sizeof(wchName)/sizeof(WCHAR));

    if (pchServer)
    {
        if (*pchServer)
    	    mbstowcs(wchServer, pchServer, sizeof(wchServer)/sizeof(WCHAR));
	    else
	        PrintMessageAndExit(IDS_VOLUME_SYNTAX, NULL);
    }

    dwRetCode = AfpAdminConnect(pchServer ? wchServer : NULL, &hServer);

    if (dwRetCode != NO_ERROR)
	PrintMessageAndExit(IDS_API_ERROR, (CHAR *)((ULONG_PTR)dwRetCode));


    dwRetCode = AfpAdminVolumeGetInfo(  hServer,
                                        (LPWSTR)wchName,
                                        (LPBYTE*)&pAfpVolumeInfo );

    if (dwRetCode != NO_ERROR)
	PrintMessageAndExit(IDS_API_ERROR, (CHAR *)((ULONG_PTR)dwRetCode));

    //
    // Check if there are any users connected to the volume
    // by enumerating the connections to this volume.
    //

    dwRetCode = AfpAdminConnectionEnum( hServer,
                                        (LPBYTE*)&pAfpConnections,
                                        AFP_FILTER_ON_VOLUME_ID,
                                        pAfpVolumeInfo->afpvol_id,
                                        (DWORD)-1,    // Get all conenctions
                                        &cEntriesRead,
                                        &cTotalAvail,
                                        NULL );

    AfpAdminBufferFree( pAfpVolumeInfo );

    if (dwRetCode != NO_ERROR)
	PrintMessageAndExit(IDS_API_ERROR, (CHAR *)((ULONG_PTR)dwRetCode));

    for ( dwIndex = 0, pAfpConnInfoIter = pAfpConnections;
          dwIndex < cEntriesRead;
          dwIndex++, pAfpConnInfoIter++ )
    {
        dwRetCode = AfpAdminConnectionClose( hServer,
                                             pAfpConnInfoIter->afpconn_id );

        if ( dwRetCode != NO_ERROR )
	    PrintMessageAndExit( IDS_API_ERROR, (CHAR *)((ULONG_PTR)dwRetCode) );
    }

    AfpAdminBufferFree( pAfpConnections );

    dwRetCode = AfpAdminVolumeDelete( hServer, wchName );

    if (dwRetCode != NO_ERROR)
	PrintMessageAndExit(IDS_API_ERROR, (CHAR *)((ULONG_PTR)dwRetCode));

    AfpAdminDisconnect( hServer );

    PrintMessageAndExit(IDS_SUCCESS, NULL);
}

VOID
DoVolumeSet(
    CHAR * pchServer,
    CHAR * pchName,
    CHAR * pchPassword,
    CHAR * pchReadOnly,
    CHAR * pchGuestsAllowed,
    CHAR * pchMaxUses
)
{
    DWORD		dwParmNum = 0;
    AFP_VOLUME_INFO 	AfpVolInfo;
    DWORD	  	dwRetCode;
    AFP_SERVER_HANDLE   hServer;
    WCHAR		wchName[AFP_VOLNAME_LEN+1];
    WCHAR		wchPassword[AFP_VOLPASS_LEN+1];
    WCHAR		wchServer[CNLEN+3];

    ZeroMemory (&AfpVolInfo, sizeof(AFP_VOLUME_INFO));

    //
    // Check to see if the mandatory values are not supplied
    //

    if ( ( pchName == NULL ) || ( *pchName == (CHAR)NULL ) )
	PrintMessageAndExit( IDS_VOLUME_SYNTAX, NULL );
	
    mbstowcs(wchName, pchName, sizeof(wchName)/sizeof(WCHAR));

    AfpVolInfo.afpvol_name = wchName;

    if (pchServer)
    {
	if (*pchServer)
    	    mbstowcs(wchServer, pchServer, sizeof(wchServer)/sizeof(WCHAR));
	else
	    PrintMessageAndExit(IDS_VOLUME_SYNTAX, NULL);
    }

    if (pchPassword)
    {
        dwParmNum |= AFP_VOL_PARMNUM_PASSWORD;

	if (*pchPassword)
	{
	    mbstowcs(wchPassword, pchPassword, sizeof(wchPassword)/sizeof(WCHAR));
            AfpVolInfo.afpvol_password = wchPassword;
	}
	else
            AfpVolInfo.afpvol_password = NULL;
    }

    if (pchMaxUses)
    {
	if (*pchMaxUses)
        {
            dwParmNum |= AFP_VOL_PARMNUM_MAXUSES;

	    if (_strnicmp(pchMaxUses, pszUnlimited, strlen(pchMaxUses))== 0)
    	    	AfpVolInfo.afpvol_max_uses  = AFP_VOLUME_UNLIMITED_USES;
	    else if ( strspn(pchMaxUses, "1234567890") != strlen(pchMaxUses) )
	    	PrintMessageAndExit(IDS_VOLUME_SYNTAX, NULL);
            else if ( strlen( pchMaxUses ) > strlen( "4294967295" ) )
    	    	AfpVolInfo.afpvol_max_uses  = AFP_VOLUME_UNLIMITED_USES;
            else if ( ( strlen( pchMaxUses ) == strlen( "4294967295" ) ) &&
                      ( _stricmp( pchMaxUses, "4294967295" ) > 0 ) )
    	    	AfpVolInfo.afpvol_max_uses  = AFP_VOLUME_UNLIMITED_USES;
	    else
    	    	AfpVolInfo.afpvol_max_uses = atoi(pchMaxUses);

            if ( AfpVolInfo.afpvol_max_uses == 0 )
                PrintMessageAndExit(IDS_VOLUME_SYNTAX, NULL);
	}
	else
	    PrintMessageAndExit(IDS_VOLUME_SYNTAX, NULL);
    }
    else
    	AfpVolInfo.afpvol_max_uses  = 0;

    AfpVolInfo.afpvol_props_mask = 0;

    if (pchReadOnly)
    {
	if (*pchReadOnly)
	{
            dwParmNum |= AFP_VOL_PARMNUM_PROPSMASK;

	    if (_strnicmp(pchReadOnly, pszTRUE, strlen(pchReadOnly) ) == 0)
    		AfpVolInfo.afpvol_props_mask |= AFP_VOLUME_READONLY;
	    else if (_strnicmp(pchReadOnly, pszFALSE, strlen(pchReadOnly))!=0)
	    	PrintMessageAndExit(IDS_VOLUME_SYNTAX, NULL);
	}
	else
	    PrintMessageAndExit(IDS_VOLUME_SYNTAX, NULL);
    }

    if (pchGuestsAllowed)
    {
	if (*pchGuestsAllowed)
	{
            dwParmNum |= AFP_VOL_PARMNUM_PROPSMASK;

	    if (_strnicmp(pchGuestsAllowed, pszTRUE,
                                                strlen(pchGuestsAllowed))==0)
    		AfpVolInfo.afpvol_props_mask |= AFP_VOLUME_GUESTACCESS;
	    else if (_strnicmp(pchGuestsAllowed,
                        pszFALSE,strlen(pchGuestsAllowed)) != 0)
	    	PrintMessageAndExit(IDS_VOLUME_SYNTAX, NULL);
	}
	else
	    PrintMessageAndExit(IDS_VOLUME_SYNTAX, NULL);
    }

    if (dwParmNum == 0)
	PrintMessageAndExit( IDS_VOLUME_SYNTAX, NULL );

    //
    // Connect with the server
    //

    dwRetCode = AfpAdminConnect(pchServer ? wchServer : NULL, &hServer);

    if (dwRetCode != NO_ERROR)
	PrintMessageAndExit(IDS_API_ERROR, (CHAR *)((ULONG_PTR)dwRetCode));

    dwRetCode = AfpAdminVolumeSetInfo( hServer,
					(LPBYTE)&AfpVolInfo,
					dwParmNum);

    if (dwRetCode != NO_ERROR)
	PrintMessageAndExit(IDS_API_ERROR, (CHAR *)((ULONG_PTR)dwRetCode));

    AfpAdminDisconnect(hServer);
	
    PrintMessageAndExit(IDS_SUCCESS, NULL);
}

VOID
DoServerSetInfo(
    CHAR * pchServer,
    CHAR * pchMaxSessions,
    CHAR * pchLoginMessage,
    CHAR * pchGuestsAllowed,
    CHAR * pchUAMRequired,
    CHAR * pchAllowSavedPasswords,
    CHAR * pchMacServerName
)
{
    DWORD	  	dwRetCode;
    AFP_SERVER_HANDLE   hServer;
    WCHAR		wchServer[CNLEN+3];
    DWORD		dwParmNum = 0;
    AFP_SERVER_INFO	AfpServerInfo;
    WCHAR		wchLoginMsg[AFP_MESSAGE_LEN+1];
    WCHAR		wchMacServerName[AFP_SERVERNAME_LEN+1];

    ZeroMemory (&AfpServerInfo, sizeof(AFP_SERVER_INFO));
    if (pchMaxSessions)
    {
	if (*pchMaxSessions)
	{
	    dwParmNum |= AFP_SERVER_PARMNUM_MAX_SESSIONS;

	    if (_strnicmp(pchMaxSessions,
			   pszUnlimited,
			   strlen(pchMaxSessions)) == 0)
		AfpServerInfo.afpsrv_max_sessions = AFP_MAXSESSIONS;
	    else if (strspn(pchMaxSessions, "1234567890")
						!= strlen(pchMaxSessions))
	    	PrintMessageAndExit(IDS_SERVER_SYNTAX, NULL);
	    else
		AfpServerInfo.afpsrv_max_sessions = atoi(pchMaxSessions);
	}
	else
	    PrintMessageAndExit(IDS_SERVER_SYNTAX, NULL);
    }

    if (pchLoginMessage)
    {
 	if (*pchLoginMessage)
	{
	    dwParmNum |= AFP_SERVER_PARMNUM_LOGINMSG;

	    if (strlen(pchLoginMessage) > AFP_MESSAGE_LEN)
	    	PrintMessageAndExit(IDS_SERVER_SYNTAX, NULL);
	    else
	    {
		mbstowcs(wchLoginMsg, pchLoginMessage, sizeof(wchLoginMsg)/sizeof(WCHAR));
		AfpServerInfo.afpsrv_login_msg = wchLoginMsg;
	    }
	}
	else
        {
	    dwParmNum |= AFP_SERVER_PARMNUM_LOGINMSG;
	    AfpServerInfo.afpsrv_login_msg = NULL;
        }
    }

    AfpServerInfo.afpsrv_options = 0;

#if 0
    if (pchGuestsAllowed)
    {
	if (*pchGuestsAllowed)
	{
	    dwParmNum |= AFP_SERVER_PARMNUM_OPTIONS;

	    if (_strnicmp(pchGuestsAllowed,
			   pszTRUE,
			   strlen(pchGuestsAllowed)) == 0)
    		AfpServerInfo.afpsrv_options |= AFP_SRVROPT_GUESTLOGONALLOWED;
	    else if (_strnicmp(pchGuestsAllowed,
				pszFALSE,
			        strlen(pchGuestsAllowed)) != 0)
	    	PrintMessageAndExit(IDS_SERVER_SYNTAX, NULL);
	}
	else
	    PrintMessageAndExit(IDS_SERVER_SYNTAX, NULL);
    }
    else
    	AfpServerInfo.afpsrv_options |= AFP_SRVROPT_GUESTLOGONALLOWED;
#endif


    if (pchUAMRequired)
    {
	if (*pchUAMRequired)	
	{
	    dwParmNum |= AFP_SERVER_PARMNUM_OPTIONS;

	    if (_strnicmp(pchUAMRequired,
			   pszFALSE,
			   strlen(pchGuestsAllowed)) == 0)
    		AfpServerInfo.afpsrv_options|=AFP_SRVROPT_CLEARTEXTLOGONALLOWED;
	    else if (_strnicmp(pchUAMRequired,
				pszTRUE,
			        strlen(pchUAMRequired)) != 0)
	    	PrintMessageAndExit(IDS_SERVER_SYNTAX, NULL);
	}
	else
	    PrintMessageAndExit(IDS_SERVER_SYNTAX, NULL);
    }

    if (pchAllowSavedPasswords)
    {
	if (*pchAllowSavedPasswords)	
	{
	    dwParmNum |= AFP_SERVER_PARMNUM_OPTIONS;

	    if (_strnicmp(pchAllowSavedPasswords,
			   pszTRUE,
			   strlen(pchAllowSavedPasswords)) == 0)
    		AfpServerInfo.afpsrv_options|=AFP_SRVROPT_ALLOWSAVEDPASSWORD;
	    else if (_strnicmp(pchAllowSavedPasswords,
				pszFALSE,
			        strlen(pchAllowSavedPasswords)) != 0)
	    	PrintMessageAndExit(IDS_SERVER_SYNTAX, NULL);
	}
	else
	    PrintMessageAndExit(IDS_SERVER_SYNTAX, NULL);
    }

    if (pchMacServerName)
    {
	if (*pchMacServerName)
	{
	    dwParmNum |= AFP_SERVER_PARMNUM_NAME;

	    if (strlen(pchMacServerName) > AFP_SERVERNAME_LEN)
	    	PrintMessageAndExit(IDS_SERVER_SYNTAX, NULL);
	    else
	    {
		mbstowcs(wchMacServerName,
			  pchMacServerName,
			  sizeof(wchMacServerName)/sizeof(WCHAR));
	
		AfpServerInfo.afpsrv_name = wchMacServerName;
	    }
	}
	else
	    PrintMessageAndExit(IDS_SERVER_SYNTAX, NULL);
    }

    if (dwParmNum == 0)
        PrintMessageAndExit(IDS_SERVER_SYNTAX, NULL);

    if (pchServer)
    {
	if (*pchServer)
    	    mbstowcs(wchServer, pchServer, sizeof(wchServer)/sizeof(WCHAR));
	else
	    PrintMessageAndExit(IDS_SERVER_SYNTAX, NULL);
    }

    dwRetCode = AfpAdminConnect(pchServer ? wchServer : NULL, &hServer);

    if (dwRetCode != NO_ERROR)
	PrintMessageAndExit(IDS_API_ERROR, (CHAR *)((ULONG_PTR)dwRetCode));

    dwRetCode = AfpAdminServerSetInfo( hServer,
				        (LPBYTE)&AfpServerInfo,
					dwParmNum);

    if (dwRetCode != NO_ERROR)
	PrintMessageAndExit(IDS_API_ERROR, (CHAR *)((ULONG_PTR)dwRetCode));

    AfpAdminDisconnect(hServer);

    PrintMessageAndExit(IDS_SUCCESS, NULL);
}

VOID
DoDirectorySetInfo(
    CHAR * pchServer,
    CHAR * pchPath,
    CHAR * pchOwnerName,
    CHAR * pchGroupName,
    CHAR * pchPermissions
)
{
    DWORD	  	dwRetCode;
    AFP_SERVER_HANDLE   hServer;
    WCHAR		wchServer[CNLEN+3];
    LPWSTR		lpwsPath;
    WCHAR		wchOwner[UNLEN+1];
    WCHAR		wchGroup[GNLEN+1];
    DWORD               dwPerms;

    AFP_DIRECTORY_INFO  AfpDirInfo;
    DWORD               dwParmNum = 0;

    if ( ( pchPath == NULL ) || ( *pchPath == (CHAR)NULL ) )
	PrintMessageAndExit( IDS_DIRECTORY_SYNTAX, NULL );

    lpwsPath = LocalAlloc(LPTR, (strlen(pchPath) + 1) * sizeof(WCHAR));

    if (lpwsPath == NULL)
	PrintMessageAndExit(IDS_API_ERROR, (CHAR*)ERROR_NOT_ENOUGH_MEMORY);

    mbstowcs(lpwsPath, pchPath, strlen(pchPath)+1);
    AfpDirInfo.afpdir_path  = lpwsPath;

    if (pchServer)
    {
	if (*pchServer)
    	    mbstowcs(wchServer, pchServer, sizeof(wchServer)/sizeof(WCHAR));
	else
	    PrintMessageAndExit(IDS_DIRECTORY_SYNTAX, NULL);
    }

    if (pchOwnerName)
    {
	if (*pchOwnerName)
	{
	    if (strlen(pchOwnerName) > UNLEN)
	    	PrintMessageAndExit(IDS_GENERAL_SYNTAX, NULL);

	    mbstowcs(wchOwner, pchOwnerName, sizeof(wchOwner)/sizeof(WCHAR));
            AfpDirInfo.afpdir_owner = wchOwner;
            dwParmNum |= AFP_DIR_PARMNUM_OWNER;

	}
	else
	    PrintMessageAndExit(IDS_DIRECTORY_SYNTAX, NULL);
    }

    if (pchGroupName)
    {
	if (*pchGroupName)
	{
	    mbstowcs(wchGroup, pchGroupName, sizeof(wchGroup)/sizeof(WCHAR));
            AfpDirInfo.afpdir_group = wchGroup;
            dwParmNum |= AFP_DIR_PARMNUM_GROUP;
   	}
	else
	    PrintMessageAndExit(IDS_DIRECTORY_SYNTAX, NULL);
    }

    if (pchPermissions)
    {
	if (*pchPermissions)
	{
	    if (strspn(pchPermissions, "10") != strlen(pchPermissions))
	    	PrintMessageAndExit(IDS_DIRECTORY_SYNTAX, NULL);

	    if (strlen(pchPermissions) != 11)
	    	PrintMessageAndExit(IDS_DIRECTORY_SYNTAX, NULL);

            dwPerms = 0;

	    if (pchPermissions[0] == '1')
    		dwPerms |= AFP_PERM_OWNER_SFI;
	    if (pchPermissions[1] == '1')
    		dwPerms |= AFP_PERM_OWNER_SFO;
	    if (pchPermissions[2] == '1')
    		dwPerms |= AFP_PERM_OWNER_MC;
	    if (pchPermissions[3] == '1')
    		dwPerms |= AFP_PERM_GROUP_SFI;
	    if (pchPermissions[4] == '1')
    		dwPerms |= AFP_PERM_GROUP_SFO;
	    if (pchPermissions[5] == '1')
    		dwPerms |= AFP_PERM_GROUP_MC;
	    if (pchPermissions[6] == '1')
    		dwPerms |= AFP_PERM_WORLD_SFI;
	    if (pchPermissions[7] == '1')
    		dwPerms |= AFP_PERM_WORLD_SFO;
	    if (pchPermissions[8] == '1')
    		dwPerms |= AFP_PERM_WORLD_MC;
	    if (pchPermissions[9] == '1')
    		dwPerms |= AFP_PERM_INHIBIT_MOVE_DELETE;
	    if (pchPermissions[10] == '1')
    		dwPerms |= AFP_PERM_SET_SUBDIRS;

            AfpDirInfo.afpdir_perms = dwPerms;
            dwParmNum |= AFP_DIR_PARMNUM_PERMS;
	}
	else
	    PrintMessageAndExit(IDS_DIRECTORY_SYNTAX, NULL);
    }

    dwRetCode = AfpAdminConnect(pchServer ? wchServer : NULL, &hServer);

    if (dwRetCode != NO_ERROR)
	PrintMessageAndExit(IDS_API_ERROR, (CHAR *)((ULONG_PTR)dwRetCode));

    dwRetCode = AfpAdminDirectorySetInfo(hServer,
                                      	  (LPBYTE)&AfpDirInfo,
                                          dwParmNum);

    if (dwRetCode != NO_ERROR)
	PrintMessageAndExit(IDS_API_ERROR, (CHAR *)((ULONG_PTR)dwRetCode));

    AfpAdminDisconnect(hServer);

    LocalFree(lpwsPath);

    PrintMessageAndExit(IDS_SUCCESS, NULL);
}

VOID
DoForkize(
    CHAR * pchServer,
    CHAR * pchType,
    CHAR * pchCreator,
    CHAR * pchDataFork,
    CHAR * pchResourceFork,
    CHAR * pchTargetFile
)
{
    DWORD	  	dwRetCode;
    AFP_SERVER_HANDLE   hServer;
    WCHAR		wchServer[CNLEN+3];
    LPWSTR		lpwsTarget;
    LPWSTR		lpwsResource;
    LPWSTR		lpwsData;
    WCHAR		wchType[AFP_TYPE_LEN+1];
    WCHAR		wchCreator[AFP_CREATOR_LEN+1];
    DWORD		dwParmNum = 0;

    if ( ( pchTargetFile == NULL ) || ( *pchTargetFile == (CHAR)NULL ) )
	PrintMessageAndExit( IDS_FORKIZE_SYNTAX, NULL );

    lpwsTarget = LocalAlloc(LPTR, (strlen(pchTargetFile) + 1) * sizeof(WCHAR));

    if (lpwsTarget == NULL)
	PrintMessageAndExit(IDS_API_ERROR, (CHAR*)ERROR_NOT_ENOUGH_MEMORY);

    mbstowcs(lpwsTarget,pchTargetFile,strlen(pchTargetFile)+1);

    if (pchServer)
    {
	if (*pchServer)
    	    mbstowcs(wchServer, pchServer, sizeof(wchServer)/sizeof(WCHAR));
	else
	    PrintMessageAndExit(IDS_FORKIZE_SYNTAX, NULL);
    }

    if (pchType != NULL)
    {
	if ( ( *pchType == (CHAR)NULL ) || ( strlen( pchType ) > AFP_TYPE_LEN ))
	    PrintMessageAndExit(IDS_API_ERROR,(LPSTR)AFPERR_InvalidTypeCreator);
	else
    	    mbstowcs(wchType, pchType, sizeof(wchType)/sizeof(WCHAR));

    	dwParmNum |= AFP_FD_PARMNUM_TYPE;
    }

    if (pchCreator != NULL)
    {
	if ((*pchCreator == (CHAR)NULL) || (strlen(pchCreator)>AFP_CREATOR_LEN))
	    PrintMessageAndExit(IDS_API_ERROR,(LPSTR)AFPERR_InvalidTypeCreator);
	else
    	    mbstowcs(wchCreator, pchCreator, sizeof(wchCreator)/sizeof(WCHAR));

    	dwParmNum |= AFP_FD_PARMNUM_CREATOR;
    }

    if (pchResourceFork != NULL)
    {
	if ( *pchResourceFork == (CHAR)NULL )
	    PrintMessageAndExit( IDS_FORKIZE_SYNTAX, NULL );

    	lpwsResource=LocalAlloc(LPTR,(strlen(pchResourceFork)+1)*sizeof(WCHAR));

    	if (lpwsResource == NULL)
	    PrintMessageAndExit(IDS_API_ERROR, (CHAR*)ERROR_NOT_ENOUGH_MEMORY);

        mbstowcs(lpwsResource,pchResourceFork,
		 strlen(pchResourceFork)+1);
    }
    else
	lpwsResource = NULL;

    if (pchDataFork != NULL)
    {
	if ( *pchDataFork == (CHAR)NULL )
	    PrintMessageAndExit( IDS_FORKIZE_SYNTAX, NULL );

    	lpwsData = LocalAlloc(LPTR,(strlen(pchDataFork)+1)*sizeof(WCHAR));

    	if (lpwsData == NULL)
	    PrintMessageAndExit(IDS_API_ERROR, (CHAR*)ERROR_NOT_ENOUGH_MEMORY);

        mbstowcs(lpwsData,pchDataFork,
		 strlen(pchDataFork)+1);
    }
    else
    	lpwsData = NULL;

    if ((pchType == NULL) && (pchCreator == NULL) &&
	 (pchResourceFork == NULL) && (pchDataFork == NULL))
	PrintMessageAndExit(IDS_FORKIZE_SYNTAX, NULL);

    dwRetCode = AfpAdminConnect(pchServer ? wchServer : NULL, &hServer);

    if (dwRetCode != NO_ERROR)
	PrintMessageAndExit(IDS_API_ERROR, (CHAR *)((ULONG_PTR)dwRetCode));

    dwRetCode = AfpAdminFinderSetInfo(	hServer,
    				       	wchType,
    				       	wchCreator,
    				       	lpwsData,
    				     	lpwsResource,
    					lpwsTarget,
					dwParmNum);

    if (dwRetCode != NO_ERROR)
	PrintMessageAndExit(IDS_API_ERROR, (CHAR *)((ULONG_PTR)dwRetCode));

    AfpAdminDisconnect(hServer);

    PrintMessageAndExit(IDS_SUCCESS, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\atalk\messages\makefile.inc ===
..\driver\h\atkmsg.h atkmsg.rc: atkmsg.mc
    mc -v -h ..\driver\h atkmsg.mc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\atalk\perfctrs\atkctrnm.h ===
//
//  atkctrnm.h
//
//  Offset definition file for exensible counter objects and counters
//
//  These "relative" offsets must start at 0 and be multiples of 2 (i.e.
//  even numbers). In the Open Procedure, they will be added to the
//  "First Counter" and "First Help" values fo the device they belong to,
//  in order to determine the  absolute location of the counter and
//  object names and corresponding help text in the registry.
//
//  this file is used by the extensible counter DLL code as well as the
//  counter name and help text definition file (.INI) file that is used
//  by LODCTR to load the names into the registry.
//
#define ATKOBJ				0

#define PKTSIN				2
#define PKTSOUT				4

#define DATAIN				6
#define DATAOUT				8

#define DDPAVGTIME			10
#define DDPPKTIN			12

#define AARPAVGTIME			14
#define AARPPKTIN			16

#define	ATPAVGTIME			18
#define ATPPKTIN			20

#define NBPAVGTIME			22
#define NBPPKTIN			24

#define ZIPAVGTIME			26
#define ZIPPKTIN			28

#define RTMPAVGTIME			30
#define RTMPPKTIN			32

#define ATPRETRIESLOCAL		34
#define ATPRETRIESREMOTE	36
#define ATPRESPTIMEOUT		38
#define ATPXORESP			40
#define ATPALORESP			42
#define ATPRECDREL			44

#define CURPOOL				46

#define PKTROUTEDIN			48
#define PKTROUTEDOUT		50
#define PKTDROPPED			52



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\atalk\perfctrs\dataatk.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1993 Microsoft Corporation

Module Name:

      dataatk.h

Abstract:

    Header file for the VGA Extensible Object data definitions

    This file contains definitions to construct the dynamic data
    which is returned by the Configuration Registry.  Data from
    various system API calls is placed into the structures shown
    here.

Author:

   Sue Adams

Revision History:

	04-Oct-93	Sue Adams (suea)	- Created based on datavga.h

--*/

#ifndef _DATAATK_H_
#define _DATAATK_H_

/****************************************************************************\
								   18 Jan 92
								   russbl

           Adding a Counter to the Extensible Objects Code



1.  Modify the object definition in extdata.h:

    a.	Add a define for the offset of the counter in the
	data block for the given object type.

    b.	Add a PERF_COUNTER_DEFINITION to the <object>_DATA_DEFINITION.

2.  Add the Titles to the Registry in perfctrs.ini and perfhelp.ini:

    a.	Add Text for the Counter Name and the Text for the Help.

    b.	Add them to the bottom so we don't have to change all the
        numbers.

    c.  Change the Last Counter and Last Help entries under
        PerfLib in software.ini.

    d.  To do this at setup time, see section in pmintrnl.txt for
        protocol.

3.  Now add the counter to the object definition in extdata.c.
    This is the initializing, constant data which will actually go
    into the structure you added to the <object>_DATA_DEFINITION in
    step 1.b.	The type of the structure you are initializing is a
    PERF_COUNTER_DEFINITION.  These are defined in winperf.h.

4.  Add code in extobjct.c to collect the data.

Note: adding an object is a little more work, but in all the same
places.  See the existing code for examples.  In addition, you must
increase the *NumObjectTypes parameter to Get<object>PerfomanceData
on return from that routine.

\****************************************************************************/

//
//  The routines that load these structures assume that all fields
//  are packed and aligned on DWORD boundries. Alpha support may
//  change this assumption so the pack pragma is used here to insure
//  the DWORD packing assumption remains valid.
//
#pragma pack (4)

//
//  Extensible Object definitions
//

//  Update the following sort of define when adding an object type.

#define ATK_NUM_PERF_OBJECT_TYPES 2

//----------------------------------------------------------------------------

//
//  Atk Resource object type counter definitions.
//
//  These are used in the counter definitions to describe the relative
//  position of each counter in the returned data.
//

#define NUM_PKTS_IN_OFFSET	 	   	sizeof(PERF_COUNTER_BLOCK)
#define NUM_PKTS_OUT_OFFSET	    	NUM_PKTS_IN_OFFSET + sizeof(DWORD)
#define	NUM_DATAIN_OFFSET			NUM_PKTS_OUT_OFFSET + sizeof(DWORD)
#define NUM_DATAOUT_OFFSET			NUM_DATAIN_OFFSET + sizeof(LARGE_INTEGER)

#define DDP_PKT_PROCTIME_OFFSET		NUM_DATAOUT_OFFSET + sizeof(LARGE_INTEGER)
#define NUM_DDP_PKTS_IN_OFFSET		DDP_PKT_PROCTIME_OFFSET + sizeof(LARGE_INTEGER)

#define AARP_PKT_PROCTIME_OFFSET	NUM_DDP_PKTS_IN_OFFSET + sizeof(DWORD)
#define NUM_AARP_PKTS_IN_OFFSET		AARP_PKT_PROCTIME_OFFSET + sizeof(LARGE_INTEGER)

#define ATP_PKT_PROCTIME_OFFSET		NUM_AARP_PKTS_IN_OFFSET + sizeof(DWORD)
#define NUM_ATP_PKTS_IN_OFFSET		ATP_PKT_PROCTIME_OFFSET + sizeof(LARGE_INTEGER)

#define NUM_ATP_RESP_TIMEOUT_OFFSET	NUM_ATP_PKTS_IN_OFFSET + sizeof(DWORD)
#define NUM_ATP_LOCAL_RETRY_OFFSET	NUM_ATP_RESP_TIMEOUT_OFFSET + sizeof(DWORD)
#define NUM_ATP_REMOTE_RETRY_OFFSET	NUM_ATP_LOCAL_RETRY_OFFSET + sizeof(DWORD)

#define NUM_ATP_XO_RESPONSE_OFFSET	NUM_ATP_REMOTE_RETRY_OFFSET + sizeof(DWORD)
#define NUM_ATP_ALO_RESPONSE_OFFSET	NUM_ATP_XO_RESPONSE_OFFSET + sizeof(DWORD)
#define NUM_ATP_RECD_REL_OFFSET		NUM_ATP_ALO_RESPONSE_OFFSET + sizeof(DWORD)
		
#define NBP_PKT_PROCTIME_OFFSET		NUM_ATP_RECD_REL_OFFSET + sizeof(DWORD)
#define NUM_NBP_PKTS_IN_OFFSET		NBP_PKT_PROCTIME_OFFSET + sizeof(LARGE_INTEGER)

#define ZIP_PKT_PROCTIME_OFFSET		NUM_NBP_PKTS_IN_OFFSET + sizeof(DWORD)
#define NUM_ZIP_PKTS_IN_OFFSET		ZIP_PKT_PROCTIME_OFFSET + sizeof(LARGE_INTEGER)

#define RTMP_PKT_PROCTIME_OFFSET	NUM_ZIP_PKTS_IN_OFFSET + sizeof(DWORD)
#define NUM_RTMP_PKTS_IN_OFFSET		RTMP_PKT_PROCTIME_OFFSET + sizeof(LARGE_INTEGER)

#define CUR_MEM_USAGE_OFFSET		NUM_RTMP_PKTS_IN_OFFSET + sizeof(DWORD)

#define NUM_PKT_ROUTED_IN_OFFSET	CUR_MEM_USAGE_OFFSET + sizeof(DWORD)
#define NUM_PKT_ROUTED_OUT_OFFSET	NUM_PKT_ROUTED_IN_OFFSET + sizeof(DWORD)
#define NUM_PKT_DROPPED_OFFSET		NUM_PKT_ROUTED_OUT_OFFSET + sizeof(DWORD)

#define SIZE_ATK_PERFORMANCE_DATA	NUM_PKT_DROPPED_OFFSET + sizeof(DWORD) + sizeof(DWORD)

// Last DWORD is for 8-byte alignment


//
//  This is the counter structure presently returned by Nbf for
//  each Resource.  Each Resource is an Instance, named by its number.
//

typedef struct _ATK_DATA_DEFINITION {
    PERF_OBJECT_TYPE		AtkObjectType;

	PERF_COUNTER_DEFINITION	NumPacketsIn;		// per second
    PERF_COUNTER_DEFINITION	NumPacketsOut;		// per second
    PERF_COUNTER_DEFINITION	DataBytesIn;		// per second
    PERF_COUNTER_DEFINITION	DataBytesOut;		// per second

    PERF_COUNTER_DEFINITION	AverageDDPTime;		// millisec/packet
	PERF_COUNTER_DEFINITION	NumDDPPacketsIn;	// per second

    PERF_COUNTER_DEFINITION	AverageAARPTime;	// millisec/packet
	PERF_COUNTER_DEFINITION	NumAARPPacketsIn;	// per second

    PERF_COUNTER_DEFINITION	AverageATPTime;		// millisec/packet
	PERF_COUNTER_DEFINITION	NumATPPacketsIn;	// per second

    PERF_COUNTER_DEFINITION	AverageNBPTime;		// millisec/packet
	PERF_COUNTER_DEFINITION	NumNBPPacketsIn;	// per second

    PERF_COUNTER_DEFINITION	AverageZIPTime;		// millisec/packet
	PERF_COUNTER_DEFINITION	NumZIPPacketsIn;	// per second

    PERF_COUNTER_DEFINITION	AverageRTMPTime;	// millisec/packet
	PERF_COUNTER_DEFINITION	NumRTMPPacketsIn;	// per second

	PERF_COUNTER_DEFINITION	NumATPLocalRetries;	// number
	PERF_COUNTER_DEFINITION	NumATPRemoteRetries;// number
    PERF_COUNTER_DEFINITION	NumATPRespTimeout;	// number
    PERF_COUNTER_DEFINITION	ATPXoResponse;		// per second
    PERF_COUNTER_DEFINITION	ATPAloResponse;		// per second
    PERF_COUNTER_DEFINITION	ATPRecdRelease;		// per second

	PERF_COUNTER_DEFINITION	CurNonPagedPoolUsage;

	PERF_COUNTER_DEFINITION	NumPktRoutedIn;		// Packets in to be routed
	PERF_COUNTER_DEFINITION	NumPktRoutedOut;	// packets routed out
	PERF_COUNTER_DEFINITION	NumPktDropped;		// Packets dropped
	
} ATK_DATA_DEFINITION;

#pragma pack ()

#endif //_DATAATK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\atalk\perfctrs\dataatk.c ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992  Microsoft Corporation

Module Name:

    dataatk.c

Abstract:

    a file containing the constant data structures
    for the Performance Monitor data for the Appletalk
    Extensible Objects.

    This file contains a set of constant data structures which are
    currently defined for the Appletalk Extensible Objects.  This is an
    example of how other such objects could be defined.

Created:

    Russ Blake  07/31/92

Revision History:

    Sue Adams 02/23/94	- Hard code the Counter and Help indices as these are
						  now defined values in the base NT system.

--*/
//
//  Include Files
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winperf.h>
#include "dataatk.h"

//
//  Constant structure initializations defined in dataatk.h
//

ATK_DATA_DEFINITION AtkDataDefinition = {

    {
		// TotalByteLength
		sizeof(ATK_DATA_DEFINITION) + SIZE_ATK_PERFORMANCE_DATA,

		// DefinitionLength
		sizeof(ATK_DATA_DEFINITION),

		// HeaderLength
		sizeof(PERF_OBJECT_TYPE),

		// ObjectNameTitleIndex
		1050,

		// ObjectNameTitle
        0,

		// ObjectHelpTitleIndex
        1051,

		// ObjectHelpTitle
        0,

		// DetailLevel
        PERF_DETAIL_ADVANCED,

		// NumCounters
		(sizeof(ATK_DATA_DEFINITION)-sizeof(PERF_OBJECT_TYPE)) / sizeof(PERF_COUNTER_DEFINITION),

		// Defaultcounter
		0,

		// NumInstances
        0,

		// CodePage
        0,

		// PerfTime
		{0,0},

		// PerfFreq
		{0,0}
    },
	{
		// ByteLength
		sizeof(PERF_COUNTER_DEFINITION),

		// CounterNameTitleIndex
		1052,

		// CounterNameTitle
		0,

		// CounterHelpTitleIndex
		1053,

		// CounterHelpTitle
		0,

		// DefaultScale
		-1,

		// DetailLevel
		PERF_DETAIL_NOVICE,

		// CounterType
		PERF_COUNTER_COUNTER,

		// CounterSize
		sizeof(DWORD),

		// CounterOffset
		NUM_PKTS_IN_OFFSET
    },
	{
		// ByteLength
		sizeof(PERF_COUNTER_DEFINITION),

		// CounterNameTitleIndex
		1054,

		// CounterNameTitle
		0,

		// CounterHelpTitleIndex
		1055,

		// CounterHelpTitle
		0,

		// DefaultScale
		-1,

		// DetailLevel
		PERF_DETAIL_NOVICE,

		// CounterType
		PERF_COUNTER_COUNTER,

		// CounterSize
		sizeof(DWORD),

		// CounterOffset
		NUM_PKTS_OUT_OFFSET
    },
	{
		// ByteLength
		sizeof(PERF_COUNTER_DEFINITION),

		// CounterNameTitleIndex
		1056,

		// CounterNameTitle
		0,

		// CounterHelpTitleIndex
		1057,

		// CounterHelpTitle
		0,

		// DefaultScale
		-4,

		// DetailLevel
		PERF_DETAIL_NOVICE,

		// CounterType
		PERF_COUNTER_BULK_COUNT,

		// CounterSize
		sizeof(LARGE_INTEGER),

		// CounterOffset
		NUM_DATAIN_OFFSET
    },
	{
		// ByteLength
		sizeof(PERF_COUNTER_DEFINITION),

		// CounterNameTitleIndex
		1058,

		// CounterNameTitle
		0,

		// CounterHelpTitleIndex
		1059,

		// CounterHelpTitle
		0,

		// DefaultScale
		-4,

		// DetailLevel
		PERF_DETAIL_NOVICE,

		// CounterType
		PERF_COUNTER_BULK_COUNT,

		// CounterSize
		sizeof(LARGE_INTEGER),

		// CounterOffset
		NUM_DATAOUT_OFFSET
    },
	{
		// ByteLength
		sizeof(PERF_COUNTER_DEFINITION),

		// CounterNameTitleIndex
		1060,

		// CounterNameTitle
		0,

		// CounterHelpTitleIndex
		1061,

		// CounterHelpTitle
		0,

		// DefaultScale
		0,

		// DetailLevel
		PERF_DETAIL_NOVICE,

		// CounterType
		PERF_AVERAGE_BULK,

		// CounterSize
		sizeof(LARGE_INTEGER),

		// CounterOffset
		DDP_PKT_PROCTIME_OFFSET
    },
	{
		// ByteLength
		sizeof(PERF_COUNTER_DEFINITION),

		// CounterNameTitleIndex
		1062,

		// CounterNameTitle
		0,

		// CounterHelpTitleIndex
		1063,

		// CounterHelpTitle
		0,

		// DefaultScale
		-1,

		// DetailLevel
		PERF_DETAIL_NOVICE,

		// CounterType
		PERF_COUNTER_COUNTER,

		// CounterSize
		sizeof(DWORD),

		// CounterOffset
		NUM_DDP_PKTS_IN_OFFSET
    },
	{
		// ByteLength
		sizeof(PERF_COUNTER_DEFINITION),

		// CounterNameTitleIndex
		1064,

		// CounterNameTitle
		0,

		// CounterHelpTitleIndex
		1065,

		// CounterHelpTitle
		0,

		// DefaultScale
		0,

		// DetailLevel
		PERF_DETAIL_NOVICE,

		// CounterType
		PERF_AVERAGE_BULK,

		// CounterSize
		sizeof(LARGE_INTEGER),

		// CounterOffset
		AARP_PKT_PROCTIME_OFFSET
    },
	{
		// ByteLength
		sizeof(PERF_COUNTER_DEFINITION),

		// CounterNameTitleIndex
		1066,

		// CounterNameTitle
		0,

		// CounterHelpTitleIndex
		1067,

		// CounterHelpTitle
		0,

		// DefaultScale
		-1,

		// DetailLevel
		PERF_DETAIL_NOVICE,

		// CounterType
		PERF_COUNTER_COUNTER,

		// CounterSize
		sizeof(DWORD),

		// CounterOffset
		NUM_AARP_PKTS_IN_OFFSET
    },
	{
		// ByteLength
		sizeof(PERF_COUNTER_DEFINITION),

		// CounterNameTitleIndex
		1068,

		// CounterNameTitle
		0,

		// CounterHelpTitleIndex
		1069,

		// CounterHelpTitle
		0,

		// DefaultScale
		0,

		// DetailLevel
		PERF_DETAIL_NOVICE,

		// CounterType
		PERF_AVERAGE_BULK,

		// CounterSize
		sizeof(LARGE_INTEGER),

		// CounterOffset
		ATP_PKT_PROCTIME_OFFSET
    },
	{
		// ByteLength
		sizeof(PERF_COUNTER_DEFINITION),

		// CounterNameTitleIndex
		1070,

		// CounterNameTitle
		0,

		// CounterHelpTitleIndex
		1071,

		// CounterHelpTitle
		0,

		// DefaultScale
		-1,

		// DetailLevel
		PERF_DETAIL_NOVICE,

		// CounterType
		PERF_COUNTER_COUNTER,

		// CounterSize
		sizeof(DWORD),

		// CounterOffset
		NUM_ATP_PKTS_IN_OFFSET
    },
	{
		// ByteLength
		sizeof(PERF_COUNTER_DEFINITION),

		// CounterNameTitleIndex
		1072,

		// CounterNameTitle
		0,

		// CounterHelpTitleIndex
		1073,

		// CounterHelpTitle
		0,

		// DefaultScale
		0,

		// DetailLevel
		PERF_DETAIL_NOVICE,

		// CounterType
		PERF_AVERAGE_BULK,

		// CounterSize
		sizeof(LARGE_INTEGER),

		// CounterOffset
		NBP_PKT_PROCTIME_OFFSET
    },
	{
		// ByteLength
		sizeof(PERF_COUNTER_DEFINITION),

		// CounterNameTitleIndex
		1074,

		// CounterNameTitle
		0,

		// CounterHelpTitleIndex
		1075,

		// CounterHelpTitle
		0,

		// DefaultScale
		-1,

		// DetailLevel
		PERF_DETAIL_NOVICE,

		// CounterType
		PERF_COUNTER_COUNTER,

		// CounterSize
		sizeof(DWORD),

		// CounterOffset
		NUM_NBP_PKTS_IN_OFFSET
    },
	{
		// ByteLength
		sizeof(PERF_COUNTER_DEFINITION),

		// CounterNameTitleIndex
		1076,

		// CounterNameTitle
		0,

		// CounterHelpTitleIndex
		1077,

		// CounterHelpTitle
		0,

		// DefaultScale
		0,

		// DetailLevel
		PERF_DETAIL_NOVICE,

		// CounterType
		PERF_AVERAGE_BULK,

		// CounterSize
		sizeof(LARGE_INTEGER),

		// CounterOffset
		ZIP_PKT_PROCTIME_OFFSET
    },
	{
		// ByteLength
		sizeof(PERF_COUNTER_DEFINITION),

		// CounterNameTitleIndex
		1078,

		// CounterNameTitle
		0,

		// CounterHelpTitleIndex
		1079,

		// CounterHelpTitle
		0,

		// DefaultScale
		-1,

		// DetailLevel
		PERF_DETAIL_NOVICE,

		// CounterType
		PERF_COUNTER_COUNTER,

		// CounterSize
		sizeof(DWORD),

		// CounterOffset
		NUM_ZIP_PKTS_IN_OFFSET
    },
	{
		// ByteLength
		sizeof(PERF_COUNTER_DEFINITION),

		// CounterNameTitleIndex
		1080,

		// CounterNameTitle
		0,

		// CounterHelpTitleIndex
		1081,

		// CounterHelpTitle
		0,

		// DefaultScale
		0,

		// DetailLevel
		PERF_DETAIL_NOVICE,

		// CounterType
		PERF_AVERAGE_BULK,

		// CounterSize
		sizeof(LARGE_INTEGER),

		// CounterOffset
		RTMP_PKT_PROCTIME_OFFSET
    },
	{
		// ByteLength
		sizeof(PERF_COUNTER_DEFINITION),

		// CounterNameTitleIndex
		1082,

		// CounterNameTitle
		0,

		// CounterHelpTitleIndex
		1083,

		// CounterHelpTitle
		0,

		// DefaultScale
		-1,

		// DetailLevel
		PERF_DETAIL_NOVICE,

		// CounterType
		PERF_COUNTER_COUNTER,

		// CounterSize
		sizeof(DWORD),

		// CounterOffset
		NUM_RTMP_PKTS_IN_OFFSET
    },
	{
		// ByteLength
		sizeof(PERF_COUNTER_DEFINITION),

		// CounterNameTitleIndex
		1084,

		// CounterNameTitle
		0,

		// CounterHelpTitleIndex
		1085,

		// CounterHelpTitle
		0,

		// DefaultScale
		-1,

		// DetailLevel
		PERF_DETAIL_NOVICE,

		// CounterType
		PERF_COUNTER_RAWCOUNT,

		// CounterSize
		sizeof(DWORD),

		// CounterOffset
		NUM_ATP_LOCAL_RETRY_OFFSET
    },
	{
		// ByteLength
		sizeof(PERF_COUNTER_DEFINITION),

		// CounterNameTitleIndex
		1100,

		// CounterNameTitle
		0,

		// CounterHelpTitleIndex
		1101,

		// CounterHelpTitle
		0,

		// DefaultScale
		-1,

		// DetailLevel
		PERF_DETAIL_NOVICE,

		// CounterType
		PERF_COUNTER_RAWCOUNT,

		// CounterSize
		sizeof(DWORD),

		// CounterOffset
		NUM_ATP_REMOTE_RETRY_OFFSET
    },
	{
		// ByteLength
		sizeof(PERF_COUNTER_DEFINITION),

		// CounterNameTitleIndex
		1086,

		// CounterNameTitle
		0,

		// CounterHelpTitleIndex
		1087,

		// CounterHelpTitle
		0,

		// DefaultScale
		0,

		// DetailLevel
		PERF_DETAIL_NOVICE,

		// CounterType
		PERF_COUNTER_RAWCOUNT,

		// CounterSize
		sizeof(DWORD),

		// CounterOffset
		NUM_ATP_RESP_TIMEOUT_OFFSET
    },
	{
		// ByteLength
		sizeof(PERF_COUNTER_DEFINITION),

		// CounterNameTitleIndex
		1088,

		// CounterNameTitle
		0,

		// CounterHelpTitleIndex
		1089,

		// CounterHelpTitle
		0,

		// DefaultScale
		-1,

		// DetailLevel
		PERF_DETAIL_NOVICE,

		// CounterType
		PERF_COUNTER_COUNTER,

		// CounterSize
		sizeof(DWORD),

		// CounterOffset
		NUM_ATP_XO_RESPONSE_OFFSET
    },
	{
		// ByteLength
		sizeof(PERF_COUNTER_DEFINITION),

		// CounterNameTitleIndex
		1090,

		// CounterNameTitle
		0,

		// CounterHelpTitleIndex
		1091,

		// CounterHelpTitle
		0,

		// DefaultScale
		0,

		// DetailLevel
		PERF_DETAIL_NOVICE,

		// CounterType
		PERF_COUNTER_COUNTER,

		// CounterSize
		sizeof(DWORD),

		// CounterOffset
		NUM_ATP_ALO_RESPONSE_OFFSET
    },
	{
		// ByteLength
		sizeof(PERF_COUNTER_DEFINITION),

		// CounterNameTitleIndex
		1092,

		// CounterNameTitle
		0,

		// CounterHelpTitleIndex
		1093,

		// CounterHelpTitle
		0,

		// DefaultScale
		-1,

		// DetailLevel
		PERF_DETAIL_NOVICE,

		// CounterType
		PERF_COUNTER_COUNTER,

		// CounterSize
		sizeof(DWORD),

		// CounterOffset
		NUM_ATP_RECD_REL_OFFSET
    },
	{
		// ByteLength
		sizeof(PERF_COUNTER_DEFINITION),

		// CounterNameTitleIndex
		1094,

		// CounterNameTitle
		0,

		// CounterHelpTitleIndex
		1095,

		// CounterHelpTitle
		0,

		// DefaultScale
		-4,

		// DetailLevel
		PERF_DETAIL_NOVICE,

		// CounterType
		PERF_COUNTER_RAWCOUNT,

		// CounterSize
		sizeof(DWORD),

		// CounterOffset
		CUR_MEM_USAGE_OFFSET
    },
	{
		// ByteLength
		sizeof(PERF_COUNTER_DEFINITION),

		// CounterNameTitleIndex
		1096,

		// CounterNameTitle
		0,

		// CounterHelpTitleIndex
		1097,

		// CounterHelpTitle
		0,

		// DefaultScale
		0,

		// DetailLevel
		PERF_DETAIL_NOVICE,

		// CounterType
		PERF_COUNTER_COUNTER,

		// CounterSize
		sizeof(DWORD),

		// CounterOffset
		NUM_PKT_ROUTED_IN_OFFSET
    },
	{
		// ByteLength
		sizeof(PERF_COUNTER_DEFINITION),

		// CounterNameTitleIndex
		1102,

		// CounterNameTitle
		0,

		// CounterHelpTitleIndex
		1103,

		// CounterHelpTitle
		0,

		// DefaultScale
		0,

		// DetailLevel
		PERF_DETAIL_NOVICE,

		// CounterType
		PERF_COUNTER_COUNTER,

		// CounterSize
		sizeof(DWORD),

		// CounterOffset
		NUM_PKT_ROUTED_OUT_OFFSET
    },
	{
		// ByteLength
		sizeof(PERF_COUNTER_DEFINITION),

		// CounterNameTitleIndex
		1098,

		// CounterNameTitle
		0,

		// CounterHelpTitleIndex
		1099,

		// CounterHelpTitle
		0,

		// DefaultScale
		0,

		// DetailLevel
		PERF_DETAIL_NOVICE,

		// CounterType
		PERF_COUNTER_RAWCOUNT,

		// CounterSize
		sizeof(DWORD),

		// CounterOffset
		NUM_PKT_DROPPED_OFFSET
    }
};






=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\atalk\perfctrs\perfatk.c ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992  Microsoft Corporation

Module Name:

    perfatk.c

Abstract:

    This file implements the Extensible Objects for
    the Appletalk object types

Created:

    10/11/93	Sue Adams (suea)

Revision History

	02/23/94	Sue Adams - No longer need to open registry key
							\AppleTalk\Performance to query FirstCounter and
							FirstHelp indices.  These are now hardcoded as
							part of the base NT system.
							ATKOBJ = 1050, ATKOBJ_HELP = 1051,
							PKTDROPPED = 1096, PKTDROPPED_HELP = 1097
--*/

//
//  Include Files
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntprfctr.h>
#include <windows.h>
#include <string.h>
#include <wcstr.h>
#include <winperf.h>

#define GLOBAL	extern
#define EQU ; /##/
#define ATALK_SPIN_LOCK LONG
#define	PMDL			PVOID
#include <atkstat.h>
#include <tdi.h>

#include <atalktdi.h>

#include "atkctrs.h" // error message definition
#include "perfmsg.h"
#include "perfutil.h"
#include "dataatk.h"
#include <atkstat.h>

//
//  References to constants which initialize the Object type definitions
//	(see dataatk.h & .c)
//

#define	MAX_PORTS	32
extern ATK_DATA_DEFINITION AtkDataDefinition;

DWORD   dwOpenCount = 0;        // count of "Open" threads
BOOL    bInitOK = FALSE;        // true = DLL initialized OK
HANDLE	AddressHandle = NULL;	// handle to appletalk driver
DWORD	LengthOfInstanceNames = 0;	// including padding to DWORD length
int     NumOfDevices = 0;		// Number of appletalk ports with stats

PATALK_STATS				pAtalkStats;
PATALK_PORT_STATS			pAtalkPortStats;
CHAR						Buffer[ sizeof(ATALK_STATS) +
									sizeof(ATALK_PORT_STATS) * MAX_PORTS +
									sizeof(GET_STATISTICS_ACTION)];
PGET_STATISTICS_ACTION		GetStats = (PGET_STATISTICS_ACTION)Buffer;

//
//  Function Prototypes
//

PM_OPEN_PROC    OpenAtkPerformanceData;
PM_COLLECT_PROC CollectAtkPerformanceData;
PM_CLOSE_PROC   CloseAtkPerformanceData;

DWORD
OpenAtkPerformanceData(
    LPWSTR lpDeviceNames
    )

/*++

Routine Description:

    This routine will open the Appletalk driver and remember the handle
    returned to be used in subsequent Ioctls for performance data to the
	driver.  Each device name exported by Appletalk will be mapped to an
	array index into the performance data arrays for all the ports handled
	by Appletalk.  These indices will then be used in the collect routine
	to know which set of performance data belongs to which device.

Arguments:

    Pointer to each device to be opened.  Note that for Appletalk, we do not
	actually open each device (port), we only open one Tdi provider name to
	use when ioctling the driver for performance data on all ports.

Return Value:

    None.

--*/

{
    NTSTATUS Status = ERROR_SUCCESS;
    UNICODE_STRING  DriverName;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES ObjectAttributes;
    LPWSTR   lpLocalDeviceNames;
    int      i;

	if (!dwOpenCount)
	{

		if ((lpLocalDeviceNames = lpDeviceNames) == NULL)
			return ERROR_INVALID_NAME; // There are no devices to query

		MonOpenEventLog();

		// Open the Appletalk driver and obtain the device (port)/index
		// mappings for performance data table
		RtlInitUnicodeString(&DriverName, ATALKPAP_DEVICENAME);
		InitializeObjectAttributes (
			&ObjectAttributes,
			&DriverName,
			0,
			NULL,
			NULL);
	
		Status = NtCreateFile(
					 &AddressHandle,
					 GENERIC_READ | SYNCHRONIZE,	// desired access.
					 &ObjectAttributes,			 	// object attributes.
					 &IoStatusBlock,				// returned status information.
					 0,							 	// block size (unused).
					 0,							 	// file attributes.
					 FILE_SHARE_READ,				// share access.
					 FILE_OPEN,					 	// create disposition.
					 FILE_SYNCHRONOUS_IO_NONALERT,	// create options.
					 NULL,
					 0);
	
		if (!NT_SUCCESS(Status))
		{
            REPORT_ERROR_DATA (ATK_OPEN_FILE_ERROR, LOG_USER,
                &IoStatusBlock, sizeof(IoStatusBlock));
			return RtlNtStatusToDosError(Status);
		}
			
		//
		//	Now make a NtDeviceIoControl file (corresponding to TdiAction) to
		//	get the statistics - here we are only interested in the array
		//  of device/port names
		//
	
		GetStats->ActionHeader.ActionCode = COMMON_ACTION_GETSTATISTICS;
		GetStats->ActionHeader.TransportId = MATK;
		Status = NtDeviceIoControlFile(
						AddressHandle,
						NULL,
						NULL,
						NULL,
						&IoStatusBlock,
						IOCTL_TDI_ACTION,
						NULL,
						0,
						(PVOID)GetStats,
						sizeof(Buffer));
		if (!NT_SUCCESS(Status))
		{
			REPORT_ERROR_DATA (ATK_IOCTL_FILE_ERROR, LOG_DEBUG,
                       &IoStatusBlock, sizeof(IoStatusBlock));
			NtClose(AddressHandle);
			return RtlNtStatusToDosError(Status);
		}

		pAtalkStats = (PATALK_STATS)(Buffer + sizeof(GET_STATISTICS_ACTION));
		pAtalkPortStats = (PATALK_PORT_STATS)(  Buffer +
												sizeof(GET_STATISTICS_ACTION) +
												sizeof(ATALK_STATS));
		NumOfDevices = pAtalkStats->stat_NumActivePorts;
		for (i = 0; i < NumOfDevices; i++, pAtalkPortStats ++)
		{
			LengthOfInstanceNames +=
				DWORD_MULTIPLE((lstrlenW(pAtalkPortStats->prtst_PortName) * sizeof(WCHAR)));
		}


        bInitOK = TRUE; // ok to use this function

	} // end if dwOpenCount is zero (first opener)


	if (!NT_SUCCESS(Status))
	{
		if (AddressHandle != NULL)
		{
			NtClose(AddressHandle);
		}
		return RtlNtStatusToDosError(Status);

	}
	else
	{
		dwOpenCount++; // increment OPEN counter
		REPORT_INFORMATION (ATK_OPEN_PERFORMANCE_DATA, LOG_DEBUG);
	}

	return Status;
}

DWORD
CollectAtkPerformanceData(
    IN      LPWSTR  lpValueName,
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes
)


/*++

Routine Description:

    This routine will return the data for the AppleTalk counters.

Arguments:

   IN       LPWSTR   lpValueName
         pointer to a wide character string passed by registry.

   IN OUT   LPVOID   *lppData
         IN: pointer to the address of the buffer to receive the completed
            PerfDataBlock and subordinate structures. This routine will
            append its data to the buffer starting at the point referenced
            by *lppData.
         OUT: points to the first byte after the data structure added by this
            routine. This routine updates the value at lppdata after appending
            its data.

   IN OUT   LPDWORD  lpcbTotalBytes
         IN: the address of the DWORD that tells the size in bytes of the
            buffer referenced by the lppData argument
         OUT: the number of bytes added by this routine is writted to the
            DWORD pointed to by this argument

   IN OUT   LPDWORD  NumObjectTypes
         IN: the address of the DWORD to receive the number of objects added
            by this routine
         OUT: the number of objects added by this routine is writted to the
            DWORD pointed to by this argument

Return Value:

      ERROR_MORE_DATA if buffer passed is too small to hold data
         any error conditions encountered are reported to the event log if
         event logging is enabled.

      ERROR_SUCCESS  if success or any other error. Errors, however are
         also reported to the event log.

--*/
{
    //  Variables for reformating the data

    ULONG SpaceNeeded;
    PDWORD pdwCounter;
    LARGE_INTEGER UNALIGNED *pliCounter;
    LARGE_INTEGER	li1000;
    PERF_COUNTER_BLOCK *pPerfCounterBlock;
    ATK_DATA_DEFINITION *pAtkDataDefinition;
    PERF_INSTANCE_DEFINITION *pPerfInstanceDefinition;
	int i;
	UNICODE_STRING UCurDeviceName;

    // Variables for collecting the data from Appletalk

    NTSTATUS		Status;
    IO_STATUS_BLOCK IoStatusBlock;
    DWORD           dwQueryType;


	li1000.QuadPart = 1000;
    //
    // before doing anything else, see if Open went OK
    //
    if (!bInitOK) {
        // unable to continue because open failed.
	    *lpcbTotalBytes = (DWORD) 0;
	    *lpNumObjectTypes = (DWORD) 0;
        return ERROR_SUCCESS; // yes, this is a successful exit
    }

	if (lpValueName == NULL) {
        REPORT_INFORMATION (ATK_COLLECT_ENTERED, LOG_VERBOSE);
    } else {
        REPORT_INFORMATION_DATA (ATK_COLLECT_ENTERED,
                                 LOG_VERBOSE,
                                 lpValueName,
                                 (DWORD)(lstrlenW(lpValueName)*sizeof(WCHAR)));
    }

    //
    // see if this is a foreign (i.e. non-NT) computer data request
    //
    dwQueryType = GetQueryType (lpValueName);

    if ((dwQueryType == QUERY_COSTLY) || (dwQueryType == QUERY_FOREIGN)) {
        // ATK foreign data requests are not supported so bail out
        REPORT_INFORMATION (ATK_FOREIGN_DATA_REQUEST, LOG_VERBOSE);
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        return ERROR_SUCCESS;
    }

    if (dwQueryType == QUERY_ITEMS){
        if ( !(IsNumberInUnicodeList (AtkDataDefinition.AtkObjectType.ObjectNameTitleIndex,
                                      lpValueName)))
        {
            // request received for data object not provided by this routine
            REPORT_INFORMATION (ATK_UNSUPPORTED_ITEM_REQUEST, LOG_VERBOSE);

            *lpcbTotalBytes = (DWORD) 0;
            *lpNumObjectTypes = (DWORD) 0;
            return ERROR_SUCCESS;
        }
    }

    pAtkDataDefinition = (ATK_DATA_DEFINITION *) *lppData;

    // Compute space needed to hold AppleTalk performance Data
	SpaceNeeded = sizeof(ATK_DATA_DEFINITION) +
				  (NumOfDevices *
					(SIZE_ATK_PERFORMANCE_DATA +
					 sizeof(PERF_INSTANCE_DEFINITION))) +
				  LengthOfInstanceNames;

    if ( *lpcbTotalBytes < SpaceNeeded ) {
        *lpcbTotalBytes = (DWORD) SpaceNeeded;
        *lpNumObjectTypes = (DWORD) 0;
        return ERROR_MORE_DATA;
    }

    //
    // Copy the (constant, initialized) Object Type and counter definitions
    //

    RtlMoveMemory(pAtkDataDefinition,
				  &AtkDataDefinition,
				  sizeof(ATK_DATA_DEFINITION));

    //
	// Format and collect SFM data from IOCTL
	//

	GetStats->ActionHeader.ActionCode = COMMON_ACTION_GETSTATISTICS;
	GetStats->ActionHeader.TransportId = MATK;
	Status = NtDeviceIoControlFile(
					AddressHandle,
					NULL,
					NULL,
					NULL,
					&IoStatusBlock,
					IOCTL_TDI_ACTION,
					NULL,
					0,
					(PVOID)GetStats,
					sizeof(Buffer));
	if ((!NT_SUCCESS(Status)) || (!NT_SUCCESS(IoStatusBlock.Status)))
	{
		REPORT_ERROR_DATA (ATK_IOCTL_FILE_ERROR, LOG_DEBUG,
                   &IoStatusBlock, sizeof(IoStatusBlock));
		*lpcbTotalBytes = (DWORD) 0;
		*lpNumObjectTypes = (DWORD) 0;
		return ERROR_SUCCESS;
	}
	// The real statistics data starts after the TDI action header
	pAtalkStats = (ATALK_STATS *)(Buffer + sizeof(GET_STATISTICS_ACTION));
	pAtalkPortStats = (PATALK_PORT_STATS)(  Buffer +
											sizeof(GET_STATISTICS_ACTION) +
											sizeof(ATALK_STATS));

    //
    // due to some PnP event, if one more adapter has come in, make adjustments!
    //
    if (pAtalkStats->stat_NumActivePorts > (DWORD)NumOfDevices)
    {
        NumOfDevices = pAtalkStats->stat_NumActivePorts;
        LengthOfInstanceNames = 0;

		for (i = 0; i < NumOfDevices; i++, pAtalkPortStats ++)
		{
			LengthOfInstanceNames +=
				DWORD_MULTIPLE((lstrlenW(pAtalkPortStats->prtst_PortName) * sizeof(WCHAR)));
		}

	    SpaceNeeded = sizeof(ATK_DATA_DEFINITION) +
				      (NumOfDevices * (SIZE_ATK_PERFORMANCE_DATA +
                                       sizeof(PERF_INSTANCE_DEFINITION))) +
				      LengthOfInstanceNames;

        if ( *lpcbTotalBytes < SpaceNeeded ) {
            *lpcbTotalBytes = (DWORD) SpaceNeeded;
            *lpNumObjectTypes = (DWORD) 0;
            return ERROR_MORE_DATA;
        }
    }


    // Now point to the location where the first instance definition will go
    pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)&pAtkDataDefinition[1];
	
    for (i = 0; i < NumOfDevices; i++, pAtalkPortStats ++)
	{
		//
        //  Format Appletalk statistics for each active port (instance)
        //

		RtlInitUnicodeString(&UCurDeviceName, pAtalkPortStats->prtst_PortName);
        MonBuildInstanceDefinition(
            pPerfInstanceDefinition,
            (PVOID *)&pPerfCounterBlock,
			0,
			0,
            i,
            &UCurDeviceName);


        pPerfCounterBlock->ByteLength = SIZE_ATK_PERFORMANCE_DATA;

        pdwCounter = (PDWORD) (&pPerfCounterBlock[1]);

		// Begin filling in the actual counter data
        *pdwCounter++ = pAtalkPortStats->prtst_NumPacketsIn;
        *pdwCounter++ = pAtalkPortStats->prtst_NumPacketsOut;

        pliCounter = (LARGE_INTEGER UNALIGNED *) pdwCounter;
        *pliCounter++ = pAtalkPortStats->prtst_DataIn;
        *pliCounter++ = pAtalkPortStats->prtst_DataOut;

		*pliCounter = pAtalkPortStats->prtst_DdpPacketInProcessTime;
		// convert this to 1msec time base
		pliCounter->QuadPart = li1000.QuadPart * (pliCounter->QuadPart/pAtalkStats->stat_PerfFreq.QuadPart);
		pdwCounter  = (PDWORD) ++pliCounter;
        *pdwCounter++ = pAtalkPortStats->prtst_NumDdpPacketsIn;

        pliCounter = (LARGE_INTEGER UNALIGNED *) pdwCounter;
		*pliCounter = pAtalkPortStats->prtst_AarpPacketInProcessTime;
		// convert this  to 1msec time base
		pliCounter->QuadPart = li1000.QuadPart * (pliCounter->QuadPart/pAtalkStats->stat_PerfFreq.QuadPart);
		pdwCounter  = (PDWORD) ++pliCounter;
        *pdwCounter++ = pAtalkPortStats->prtst_NumAarpPacketsIn;

        pliCounter = (LARGE_INTEGER UNALIGNED *) pdwCounter;
		*pliCounter = pAtalkStats->stat_AtpPacketInProcessTime;
		// convert this  to 1msec time base
		pliCounter->QuadPart = li1000.QuadPart * (pliCounter->QuadPart, pAtalkStats->stat_PerfFreq.QuadPart);
		pdwCounter  = (PDWORD) ++pliCounter;
        *pdwCounter++ = pAtalkStats->stat_AtpNumPackets;

		*pdwCounter++ = pAtalkStats->stat_AtpNumRespTimeout;
		*pdwCounter++ = pAtalkStats->stat_AtpNumLocalRetries;
		*pdwCounter++ = pAtalkStats->stat_AtpNumRemoteRetries;
		*pdwCounter++ = pAtalkStats->stat_AtpNumXoResponse;
		*pdwCounter++ = pAtalkStats->stat_AtpNumAloResponse;
		*pdwCounter++ = pAtalkStats->stat_AtpNumRecdRelease;

		pliCounter = (LARGE_INTEGER UNALIGNED *) pdwCounter;
		*pliCounter = pAtalkPortStats->prtst_NbpPacketInProcessTime;
		// convert this  to 1msec time base
		pliCounter->QuadPart = li1000.QuadPart * (pliCounter->QuadPart, pAtalkStats->stat_PerfFreq.QuadPart);
        pdwCounter  = (PDWORD) ++pliCounter;
        *pdwCounter++ = pAtalkPortStats->prtst_NumNbpPacketsIn;

        pliCounter = (LARGE_INTEGER UNALIGNED *) pdwCounter;
		*pliCounter = pAtalkPortStats->prtst_ZipPacketInProcessTime;
		// convert this  to 1msec time base
		pliCounter->QuadPart = li1000.QuadPart * (pliCounter->QuadPart, pAtalkStats->stat_PerfFreq.QuadPart);
        pdwCounter  = (PDWORD) ++pliCounter;
        *pdwCounter++ = pAtalkPortStats->prtst_NumZipPacketsIn;

        pliCounter = (LARGE_INTEGER UNALIGNED *) pdwCounter;
		*pliCounter = pAtalkPortStats->prtst_RtmpPacketInProcessTime;
		// convert this  to 1msec time base
		pliCounter->QuadPart = li1000.QuadPart * (pliCounter->QuadPart, pAtalkStats->stat_PerfFreq.QuadPart);
        pdwCounter  = (PDWORD) ++pliCounter;
        *pdwCounter++ = pAtalkPortStats->prtst_NumRtmpPacketsIn;

        *pdwCounter++ = pAtalkStats->stat_CurAllocSize;

        *pdwCounter++ = pAtalkPortStats->prtst_NumPktRoutedIn;
        *pdwCounter++ = pAtalkPortStats->prtst_NumPktRoutedOut;
        *pdwCounter++ = pAtalkPortStats->prtst_NumPktDropped;
        pdwCounter++; // 8-byte-alignment pad

		pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)
                                  ((PBYTE) pPerfCounterBlock +
                                   SIZE_ATK_PERFORMANCE_DATA);
    }

    pAtkDataDefinition->AtkObjectType.NumInstances = NumOfDevices;
    pAtkDataDefinition->AtkObjectType.TotalByteLength =
						(DWORD)((PBYTE) pdwCounter - (PBYTE) pAtkDataDefinition);

    *lppData = pdwCounter;
    *lpcbTotalBytes = (DWORD)((PBYTE) pdwCounter - (PBYTE) pAtkDataDefinition);
	*lpNumObjectTypes = 1;

    REPORT_INFORMATION (ATK_COLLECT_DATA, LOG_DEBUG);
    return ERROR_SUCCESS;
}

DWORD
CloseAtkPerformanceData(
)

/*++

Routine Description:

    This routine closes the open handles to Appletalk driver and eventlog.

Arguments:

    None.


Return Value:

    ERROR_SUCCESS

--*/

{
    REPORT_INFORMATION (ATK_CLOSE_ENTERED, LOG_VERBOSE);

   if (!(--dwOpenCount)) { // when this is the last thread...

	    NtClose(AddressHandle);
		MonCloseEventLog();
   }

    return ERROR_SUCCESS;

}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\atalk\perfctrs\perfutil.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992 Microsoft Corporation

Module Name:

    perfutil.h

Abstract:

    This file supports routines used to parse and
    create Performance Monitor Data Structures.
    It actually supports Performance Object types with
    multiple instances

Author:

    Russ Blake  7/30/92

Revision History:


--*/
#ifndef _PERFUTIL_H_
#define _PERFUTIL_H_

// enable this define to log process heap data to the event log
#ifdef PROBE_HEAP_USAGE
#undef PROBE_HEAP_USAGE
#endif
//
//  Utility macro.  This is used to reserve a DWORD multiple of
//  bytes for Unicode strings embedded in the definitional data,
//  viz., object instance names.
//
#define DWORD_MULTIPLE(x) (((x+sizeof(DWORD)-1)/sizeof(DWORD))*sizeof(DWORD))

//    (assumes dword is 4 bytes long and pointer is a dword in size)
#define ALIGN_ON_DWORD(x) ((VOID *)( ((DWORD) x & 0x00000003) ? ( ((DWORD) x & 0xFFFFFFFC) + 4 ) : ( (DWORD) x ) ))

extern WCHAR  GLOBAL_STRING[];      // Global command (get all local ctrs)
extern WCHAR  FOREIGN_STRING[];           // get data from foreign computers
extern WCHAR  COSTLY_STRING[];
extern WCHAR  NULL_STRING[];

#define QUERY_GLOBAL    1
#define QUERY_ITEMS     2
#define QUERY_FOREIGN   3
#define QUERY_COSTLY    4

//
// The definition of the only routine of perfutil.c, It builds part of a
// performance data instance (PERF_INSTANCE_DEFINITION) as described in
// winperf.h
//

HANDLE MonOpenEventLog ();
VOID MonCloseEventLog ();
DWORD GetQueryType (IN LPWSTR);
BOOL IsNumberInUnicodeList (DWORD, LPWSTR);

BOOL
MonBuildInstanceDefinition(
    PERF_INSTANCE_DEFINITION *pBuffer,
    PVOID *pBufferNext,
    DWORD ParentObjectTitleIndex,
    DWORD ParentObjectInstance,
    DWORD UniqueID,
    PUNICODE_STRING Name
);

typedef struct _LOCAL_HEAP_INFO_BLOCK {
    DWORD   AllocatedEntries;
    DWORD   AllocatedBytes;
    DWORD   FreeEntries;
    DWORD   FreeBytes;
} LOCAL_HEAP_INFO, *PLOCAL_HEAP_INFO;


//
//  Memory Probe macro
//
#ifdef PROBE_HEAP_USAGE

#define HEAP_PROBE()    { \
    DWORD   dwHeapStatus[5]; \
    NTSTATUS CallStatus; \
    dwHeapStatus[4] = __LINE__; \
    if (!(CallStatus = memprobe (dwHeapStatus, 16L, NULL))) { \
        REPORT_INFORMATION_DATA (TCP_HEAP_STATUS, LOG_DEBUG,    \
            &dwHeapStatus, sizeof(dwHeapStatus));  \
    } else {  \
        REPORT_ERROR_DATA (TCP_HEAP_STATUS_ERROR, LOG_DEBUG, \
            &CallStatus, sizeof (DWORD)); \
    } \
}

#else

#define HEAP_PROBE()    ;

#endif

#endif  //_PERFUTIL_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\atalk\sys\aarp.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	aarp.h

Abstract:

	This module contains information for the Appletalk Address Resolution Protocol.

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	19 Jun 1992		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef	_AARP_
#define	_AARP_

#define	AARP_MAX_HW_ADDR_LEN 				(MAX_HW_ADDR_LEN)
#define AARP_MIN_HW_ADDR_LEN 				1

#define	AARP_PROTO_ADDR_LEN 				4

// AARP offsets (skipping Link/Hardware headers):
#define AARP_HW_TYPE_OFFSET        			0
#define AARP_PROTO_TYPE_OFFSET         		2
#define AARP_HW_LEN_OFFSET       			4
#define AARP_PROTO_LEN_OFFSET       		5
#define AARP_COMMAND_OFFSET              	6
#define AARP_SRC_ADDR_OFFSET     	   		8

// AARP Command types:
#define AARP_REQUEST  						1
#define AARP_RESPONSE 						2
#define AARP_PROBE    						3

// 	Supposed to be (for AppleTalk phase II) 10 * 1/5 seconds... but we'll be
//  a little more patient.
#define AARP_PROBETIMER			 			20	// In 100ths of a second
#define	AARP_PROBE_TIMER_MS					200	// In milliseconds
#define AARP_NUM_PROBES	        			15

#define	AARP_OFFCABLE_MASK					0x0F

VOID
AtalkAarpPacketIn(
	IN	OUT	PPORT_DESCRIPTOR		pPortDesc,
	IN		PBYTE					pLinkHdr,
	IN		PBYTE					pPkt,				// Only Aarp data
	IN		USHORT					Length);

VOID
AtalkAarpSendComplete(
	NDIS_STATUS						Status,
	PBUFFER_DESC					pBufDesc,
	struct _SEND_COMPL_INFO	*		pSendInfo);

BOOLEAN
AtalkAarpGleanInfo(
	IN	OUT	PPORT_DESCRIPTOR		pPortDesc,
	IN		PBYTE 					SrcAddr,
	IN		SHORT 					AddrLen,
	IN	OUT	PBYTE 					RouteInfo,
	IN		USHORT					RouteInfoLen,
	IN		PBYTE 					Pkt,
	IN		USHORT 					Length);

VOID
AtalkAarpOptGleanInfo(
	IN	OUT	PPORT_DESCRIPTOR		pPortDesc,
	IN		PBYTE					pLinkHdr,
	IN		PATALK_ADDR				pSrcAddr,
	IN		PATALK_ADDR				pDestAddr,
	IN		BOOLEAN					OffCablePkt);

ATALK_ERROR
AtalkInitAarpForNodeOnPort(
	IN		PPORT_DESCRIPTOR		pPortDesc,
	IN		BOOLEAN 				AllowStartupRange,
	IN		ATALK_NODEADDR 			DesiredNode,
	IN	OUT	struct _ATALK_NODE	**	ppAtalkNode);

BOOLEAN
AtalkInitAarpForNodeInRange(
	IN	PPORT_DESCRIPTOR			pPortDesc,
    IN  PVOID                       pRasConn,
    IN  BOOLEAN                     fThisIsPPP,
	IN	ATALK_NETWORKRANGE 			NetworkRange,
	OUT	PATALK_NODEADDR 			Node);

VOID
AtalkAarpReleaseAmt(
	IN	OUT	PPORT_DESCRIPTOR		pPortDesc);

VOID
AtalkAarpReleaseBrc(
	IN	OUT	PPORT_DESCRIPTOR		pPortDesc);

PBUFFER_DESC
AtalkAarpBuildPacket(
	IN		PPORT_DESCRIPTOR		pPortDesc,
	IN		USHORT 					Type,
	IN		USHORT              	HardwareLen,
	IN		PBYTE					SrcHardwareAddr,
	IN		ATALK_NODEADDR 			SrcLogicalAddr,
	IN		PBYTE 					DestHardwareAddr,
	IN		ATALK_NODEADDR 			DestLogicalAddr,
	IN		PBYTE					TrueDest,
	IN		PBYTE					RouteInfo,
	IN		USHORT					RouteInfoLen);

#define	BUILD_AARPPROBE(pPortDesc,hardwareLength,Node)					\
		AtalkAarpBuildPacket(											\
			pPortDesc,													\
			AARP_PROBE,													\
			hardwareLength, 											\
			pPortDesc->pd_PortAddr,										\
			Node,														\
			NULL,														\
			Node,														\
			NULL,														\
			NULL,														\
			0);


#define	BUILD_AARPRESPONSE(pPortDesc,hardwareLength,hardwareAddress,	\
							RoutingInfo,RoutingInfoLength,SourceNode,	\
							destinationNode) 							\
																		\
		AtalkAarpBuildPacket( 											\
			pPortDesc,													\
			AARP_RESPONSE,												\
			hardwareLength,												\
			pPortDesc->pd_PortAddr,										\
			SourceNode,													\
			hardwareAddress,											\
			destinationNode,											\
			hardwareAddress,											\
			RoutingInfo,												\
			RoutingInfoLength);

#define	BUILD_AARPREQUEST(pPortDesc,hardwareLength,SourceNode,			\
							destinationNode )							\
        AtalkAarpBuildPacket(											\
			pPortDesc,													\
			AARP_REQUEST,												\
			hardwareLength,												\
			pPortDesc->pd_PortAddr,										\
			SourceNode,													\
			NULL,														\
			destinationNode,											\
			NULL,														\
			NULL,														\
			0);

LONG FASTCALL
AtalkAarpAmtTimer(
	IN	PTIMERLIST					pTimer,
	IN	BOOLEAN						TimerShuttingDown);

LONG FASTCALL
AtalkAarpBrcTimer(
	IN	PTIMERLIST					pTimer,
	IN	BOOLEAN						TimerShuttingDown);

LOCAL VOID
atalkAarpEnterIntoAmt(
	IN		PPORT_DESCRIPTOR		pPortDesc,
	IN		PATALK_NODEADDR 		pSrcNode,
	IN		PBYTE					SrcAddr,
	IN		SHORT					AddrLen,
	IN		PBYTE					RouteInfo,
	IN		SHORT					RouteInfoLen);

LOCAL BOOLEAN
atalkInitAarpForNode(
	IN	PPORT_DESCRIPTOR	        pPortDesc,
    IN  PVOID                       pRasConn,
    IN  BOOLEAN                     fThisIsPPP,
	IN	USHORT				        Network,
	IN	BYTE				        Node);

LOCAL VOID FASTCALL
atalkAarpTuneRouteInfo(
	IN		PPORT_DESCRIPTOR		pPortDesc,
	IN	OUT	PBYTE					RouteInfo);


#define GET_RANDOM(min, max) (((long)AtalkRandomNumber() %              \
                              (long)(((max+1) - (min))) + (min)))

#endif	// _AARP_


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\atalk\perfctrs\perfmsg.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992 Microsoft Corporation

Module Name:

    perfmsg.h

Abstract:

    This file provides the macros and definitions used by the extensible
    counters for reporting events to the event logging facility

Author:

      Bob Watson (a-robw) 5 Oct 92

Revision History:


--*/
#ifndef  _PERFMSG_H_
#define  _PERFMSG_H_
//
// Report error message ID's for Counters
//

#define APP_NAME  "atkctrs"

//
// The constant below defines how many (if any) messages will be reported
// to the event logger. As the number goes up in value more and more events
// will be reported. The purpose of this is to allow lots of messages during
// development and debugging (e.g. a message level of 3) to a minimum of
// messages (e.g. operational messages with a level of 1) or no messages if
// message logging inflicts too much of a performance penalty. Right now
// this is a compile time constant, but could later become a registry entry.
//
//    Levels:  LOG_NONE = No event log messages ever
//             LOG_USER = User event log messages (e.g. errors)
//             LOG_DEBUG = Minimum Debugging
//             LOG_VERBOSE = Maximum Debugging
//

#define  LOG_NONE     0
#define  LOG_USER     1
#define  LOG_DEBUG    2
#define  LOG_VERBOSE  3

#define  MESSAGE_LEVEL_DEFAULT  LOG_USER

// define macros
//
// Format for event log calls without corresponding insertion strings is:
//    REPORT_xxx (message_value, message_level)
//       where:
//          xxx is the severity to be displayed in the event log
//          message_value is the numeric ID from above
//          message_level is the "filtering" level of error reporting
//             using the error levels above.
//
// if the message has a corresponding insertion string whose symbol conforms
// to the format CONSTANT = numeric value and CONSTANT_S = string constant for
// that message, then the
//
//    REPORT_xxx_STRING (message_value, message_level)
//
// macro may be used.
//

//
// REPORT_SUCCESS was intended to show Success in the error log, rather it
// shows "N/A" so for now it's the same as information, though it could
// (should) be changed  in the future
//


#define REPORT_SUCCESS(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_INFORMATION_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_INFORMATION(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_INFORMATION_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_WARNING(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_WARNING_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_ERROR(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_ERROR_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_INFORMATION_DATA(i,l,d,s) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_INFORMATION_TYPE, \
   0, i, (PSID)NULL, 0, s, NULL, (PVOID)(d)) : FALSE)

#define REPORT_WARNING_DATA(i,l,d,s) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_WARNING_TYPE, \
   0, i, (PSID)NULL, 0, s, NULL, (PVOID)(d)) : FALSE)

#define REPORT_ERROR_DATA(i,l,d,s) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_ERROR_TYPE, \
   0, i, (PSID)NULL, 0, s, NULL, (PVOID)(d)) : FALSE)

// External Variables

extern HANDLE hEventLog;   // handle to event log
extern DWORD  dwLogUsers;  // counter of event log using routines
extern DWORD  MESSAGE_LEVEL; // event logging detail level

#endif //_PERFMSG_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\atalk\perfctrs\perfutil.c ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1993  Microsoft Corporation

Module Name:

    perfutil.c

Abstract:

    This file implements the utility routines used to construct the
	common parts of a PERF_INSTANCE_DEFINITION (see winperf.h) and
    perform event logging functions.

Created:

    Russ Blake  07/30/92
	Sue Adams	06/07/93
Revision History:

--*/
//
//  include files
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <string.h>
#include <winperf.h>
#include "atkctrs.h"	 // error message definition
#include "perfmsg.h"
#include "perfutil.h"

#define INITIAL_SIZE     1024L
#define EXTEND_SIZE      1024L

//
// Global data definitions.
//

ULONG                   ulInfoBufferSize = 0;

HANDLE hEventLog = NULL;      // event log handle for reporting events
                              // initialized in Open... routines
DWORD  dwLogUsers = 0;        // count of functions using event log

DWORD MESSAGE_LEVEL = 0;

WCHAR GLOBAL_STRING[] = L"Global";
WCHAR FOREIGN_STRING[] = L"Foreign";
WCHAR COSTLY_STRING[] = L"Costly";

WCHAR NULL_STRING[] = L"\0";    // pointer to null string

// test for delimiter, end of line and non-digit characters
// used by IsNumberInUnicodeList routine
//
#define DIGIT       1
#define DELIMITER   2
#define INVALID     3

#define EvalThisChar(c,d) ( \
     (c == d) ? DELIMITER : \
     (c == 0) ? DELIMITER : \
     (c < (WCHAR)'0') ? INVALID : \
     (c > (WCHAR)'9') ? INVALID : \
     DIGIT)


BOOL
MonBuildInstanceDefinition(
    PERF_INSTANCE_DEFINITION *pBuffer,
    PVOID *pBufferNext,
    DWORD ParentObjectTitleIndex,
    DWORD ParentObjectInstance,
    DWORD UniqueID,
    PUNICODE_STRING Name
    )
/*++

    MonBuildInstanceDefinition  -   Build an instance of an object

        Inputs:

            pBuffer         -   pointer to buffer where instance is to
                                be constructed

            pBufferNext     -   pointer to a pointer which will contain
                                next available location, DWORD aligned

            ParentObjectTitleIndex
                            -   Title Index of parent object type; 0 if
                                no parent object

            ParentObjectInstance
                            -   Index into instances of parent object
                                type, starting at 0, for this instances
                                parent object instance

            UniqueID        -   a unique identifier which should be used
                                instead of the Name for identifying
                                this instance

            Name            -   Name of this instance
--*/
{
    DWORD NameLength;
    WCHAR *pName;

    //
    //  Include trailing null in name size
    //

    NameLength = Name->Length;
    if ( !NameLength ||
         Name->Buffer[(NameLength/sizeof(WCHAR))-1] != UNICODE_NULL ) {
        NameLength += sizeof(WCHAR);
    }

    pBuffer->ByteLength = sizeof(PERF_INSTANCE_DEFINITION) +
                          DWORD_MULTIPLE(NameLength);

    pBuffer->ParentObjectTitleIndex = ParentObjectTitleIndex;
    pBuffer->ParentObjectInstance = ParentObjectInstance;
    pBuffer->UniqueID = UniqueID;
    pBuffer->NameOffset = sizeof(PERF_INSTANCE_DEFINITION);
    pBuffer->NameLength = NameLength;

    pName = (PWCHAR)&pBuffer[1];
    RtlMoveMemory(pName,Name->Buffer,Name->Length);

    //  Always null terminated.  Space for this reserved above.

    pName[(NameLength/sizeof(WCHAR))-1] = UNICODE_NULL;

    *pBufferNext = (PVOID) ((PCHAR) pBuffer + pBuffer->ByteLength);
    return 0;
}


HANDLE
MonOpenEventLog (
)
/*++

Routine Description:

    Reads the level of event logging from the registry and opens the
        channel to the event logger for subsequent event log entries.

Arguments:

      None

Return Value:

    Handle to the event log for reporting events.
    NULL if open not successful.

--*/
{
    HKEY hAppKey;
    TCHAR LogLevelKeyName[] = "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib";
    TCHAR LogLevelValueName[] = "EventLogLevel";

    LONG lStatus;

    DWORD dwLogLevel;
    DWORD dwValueType;
    DWORD dwValueSize;

    // if global value of the logging level not initialized or is disabled,
    //  check the registry to see if it should be updated.

    if (!MESSAGE_LEVEL) {

       lStatus = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                               LogLevelKeyName,
                               0,
                               KEY_READ,
                               &hAppKey);

       dwValueSize = sizeof (dwLogLevel);

       if (lStatus == ERROR_SUCCESS) {
            lStatus = RegQueryValueEx (hAppKey,
                               LogLevelValueName,
                               (LPDWORD)NULL,
                               &dwValueType,
                               (LPBYTE)&dwLogLevel,
                               &dwValueSize);

            if (lStatus == ERROR_SUCCESS) {
               MESSAGE_LEVEL = dwLogLevel;
            } else {
               MESSAGE_LEVEL = MESSAGE_LEVEL_DEFAULT;
            }
            RegCloseKey (hAppKey);
       } else {
         MESSAGE_LEVEL = MESSAGE_LEVEL_DEFAULT;
       }
    }

    if (hEventLog == NULL){
         hEventLog = RegisterEventSource (
            (LPTSTR)NULL,            // Use Local Machine
            APP_NAME);               // event log app name to find in registry

         if (hEventLog != NULL) {
            REPORT_INFORMATION (UTIL_LOG_OPEN, LOG_DEBUG);
         }
    }

    if (hEventLog != NULL) {
         dwLogUsers++;           // increment count of perfctr log users
    }
    return (hEventLog);
}


VOID
MonCloseEventLog (
)
/*++

Routine Description:

      Closes the handle to the event logger if this is the last caller

Arguments:

      None

Return Value:

      None

--*/
{
    if (hEventLog != NULL) {
        dwLogUsers--;         // decrement usage
        if (dwLogUsers <= 0) {    // and if we're the last, then close up log
            REPORT_INFORMATION (UTIL_CLOSING_LOG, LOG_DEBUG);
            DeregisterEventSource (hEventLog);
        }
    }
}

DWORD
GetQueryType (
    IN LPWSTR lpValue
)
/*++

GetQueryType

    returns the type of query described in the lpValue string so that
    the appropriate processing method may be used

Arguments

    IN lpValue
        string passed to PerfRegQuery Value for processing

Return Value

    QUERY_GLOBAL
        if lpValue == 0 (null pointer)
           lpValue == pointer to Null string
           lpValue == pointer to "Global" string

    QUERY_FOREIGN
        if lpValue == pointer to "Foriegn" string

    QUERY_COSTLY
        if lpValue == pointer to "Costly" string

    otherwise:

    QUERY_ITEMS

--*/
{
    WCHAR   *pwcArgChar, *pwcTypeChar;
    BOOL    bFound;

    if (lpValue == 0) {
        return QUERY_GLOBAL;
    } else if (*lpValue == 0) {
        return QUERY_GLOBAL;
    }

    // check for "Global" request

    pwcArgChar = lpValue;
    pwcTypeChar = GLOBAL_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_GLOBAL;

    // check for "Foreign" request

    pwcArgChar = lpValue;
    pwcTypeChar = FOREIGN_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_FOREIGN;

    // check for "Costly" request

    pwcArgChar = lpValue;
    pwcTypeChar = COSTLY_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_COSTLY;

    // if not Global and not Foreign and not Costly,
    // then it must be an item list

    return QUERY_ITEMS;

}

BOOL
IsNumberInUnicodeList (
    IN DWORD   dwNumber,
    IN LPWSTR  lpwszUnicodeList
)
/*++

IsNumberInUnicodeList

Arguments:

    IN dwNumber
        DWORD number to find in list

    IN lpwszUnicodeList
        Null terminated, Space delimited list of decimal numbers

Return Value:

    TRUE:
            dwNumber was found in the list of unicode number strings

    FALSE:
            dwNumber was not found in the list.

--*/
{
    DWORD   dwThisNumber;
    WCHAR   *pwcThisChar;
    BOOL    bValidNumber;
    BOOL    bNewItem;
    WCHAR   wcDelimiter;    // could be an argument to be more flexible

    if (lpwszUnicodeList == 0) return FALSE;    // null pointer, # not founde

    pwcThisChar = lpwszUnicodeList;
    dwThisNumber = 0;
    wcDelimiter = (WCHAR)' ';
    bValidNumber = FALSE;
    bNewItem = TRUE;

    while (TRUE) {
        switch (EvalThisChar (*pwcThisChar, wcDelimiter)) {
            case DIGIT:
                // if this is the first digit after a delimiter, then
                // set flags to start computing the new number
                if (bNewItem) {
                    bNewItem = FALSE;
                    bValidNumber = TRUE;
                }
                if (bValidNumber) {
                    dwThisNumber *= 10;
                    dwThisNumber += (*pwcThisChar - (WCHAR)'0');
                }
                break;

            case DELIMITER:
                // a delimter is either the delimiter character or the
                // end of the string ('\0') if when the delimiter has been
                // reached a valid number was found, then compare it to the
                // number from the argument list. if this is the end of the
                // string and no match was found, then return.
                //
                if (bValidNumber) {
                    if (dwThisNumber == dwNumber) return TRUE;
                    bValidNumber = FALSE;
                }
                if (*pwcThisChar == 0) {
                    return FALSE;
                } else {
                    bNewItem = TRUE;
                    dwThisNumber = 0;
                }
                break;

            case INVALID:
                // if an invalid character was encountered, ignore all
                // characters up to the next delimiter and then start fresh.
                // the invalid number is not compared.
                bValidNumber = FALSE;
                break;

            default:
                break;

        }
        pwcThisChar++;
    }

}   // IsNumberInUnicodeList
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\atalk\sys\adsp.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	adsp.c

Abstract:

	This module implements the ADSP protocol.

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	30 Mar 1993		Initial Version

Notes:	Tab stop: 4
--*/

#include <atalk.h>
#pragma hdrstop
#define	FILENUM		ADSP

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, AtalkInitAdspInitialize)
#pragma alloc_text(PAGE, AtalkAdspCreateAddress)
#pragma alloc_text(PAGEADSP, AtalkAdspCreateConnection)
#pragma alloc_text(PAGEADSP, AtalkAdspCleanupAddress)
#pragma alloc_text(PAGEADSP, AtalkAdspCloseAddress)
#pragma alloc_text(PAGEADSP, AtalkAdspCloseConnection)
#pragma alloc_text(PAGEADSP, AtalkAdspCleanupConnection)
#pragma alloc_text(PAGEADSP, AtalkAdspAssociateAddress)
#pragma alloc_text(PAGEADSP, AtalkAdspDissociateAddress)
#pragma alloc_text(PAGEADSP, AtalkAdspPostListen)
#pragma alloc_text(PAGEADSP, AtalkAdspCancelListen)
#pragma alloc_text(PAGEADSP, AtalkAdspPostConnect)
#pragma alloc_text(PAGEADSP, AtalkAdspDisconnect)
#pragma alloc_text(PAGEADSP, AtalkAdspRead)
#pragma alloc_text(PAGEADSP, AtalkAdspProcessQueuedSend)
#pragma alloc_text(PAGEADSP, AtalkAdspWrite)
#pragma alloc_text(PAGEADSP, AtalkAdspQuery)
#pragma alloc_text(PAGEADSP, atalkAdspPacketIn)
#pragma alloc_text(PAGEADSP, atalkAdspHandleOpenControl)
#pragma alloc_text(PAGEADSP, atalkAdspHandleAttn)
#pragma alloc_text(PAGEADSP, atalkAdspHandlePiggyBackAck)
#pragma alloc_text(PAGEADSP, atalkAdspHandleControl)
#pragma alloc_text(PAGEADSP, atalkAdspHandleData)
#pragma alloc_text(PAGEADSP, atalkAdspHandleOpenReq)
#pragma alloc_text(PAGEADSP, atalkAdspListenIndicateNonInterlock)
#pragma alloc_text(PAGEADSP, atalkAdspSendExpedited)
#pragma alloc_text(PAGEADSP, atalkAdspSendOpenControl)
#pragma alloc_text(PAGEADSP, atalkAdspSendControl)
#pragma alloc_text(PAGEADSP, atalkAdspSendDeny)
#pragma alloc_text(PAGEADSP, atalkAdspSendAttn)
#pragma alloc_text(PAGEADSP, atalkAdspSendData)
#pragma alloc_text(PAGEADSP, atalkAdspRecvData)
#pragma alloc_text(PAGEADSP, atalkAdspRecvAttn)
#pragma alloc_text(PAGEADSP, atalkAdspConnSendComplete)
#pragma alloc_text(PAGEADSP, atalkAdspAddrSendComplete)
#pragma alloc_text(PAGEADSP, atalkAdspSendAttnComplete)
#pragma alloc_text(PAGEADSP, atalkAdspSendDataComplete)
#pragma alloc_text(PAGEADSP, atalkAdspConnMaintenanceTimer)
#pragma alloc_text(PAGEADSP, atalkAdspRetransmitTimer)
#pragma alloc_text(PAGEADSP, atalkAdspAttnRetransmitTimer)
#pragma alloc_text(PAGEADSP, atalkAdspOpenTimer)
#pragma alloc_text(PAGEADSP, atalkAdspAddrRefNonInterlock)
#pragma alloc_text(PAGEADSP, atalkAdspConnRefByPtrNonInterlock)
#pragma alloc_text(PAGEADSP, atalkAdspConnRefByCtxNonInterlock)
#pragma alloc_text(PAGEADSP, atalkAdspConnRefBySrcAddr)
#pragma alloc_text(PAGEADSP, atalkAdspConnRefNextNc)
#pragma alloc_text(PAGEADSP, atalkAdspMaxSendSize)
#pragma alloc_text(PAGEADSP, atalkAdspMaxNextReadSize)
#pragma alloc_text(PAGEADSP, atalkAdspDescribeFromBufferQueue)
#pragma alloc_text(PAGEADSP, atalkAdspBufferQueueSize)
#pragma alloc_text(PAGEADSP, atalkAdspMessageSize)
#pragma alloc_text(PAGEADSP, atalkAdspAllocCopyChunk)
#pragma alloc_text(PAGEADSP, atalkAdspGetLookahead)
#pragma alloc_text(PAGEADSP, atalkAdspAddToBufferQueue)
#pragma alloc_text(PAGEADSP, atalkAdspReadFromBufferQueue)
#pragma alloc_text(PAGEADSP, atalkAdspDiscardFromBufferQueue)
#pragma alloc_text(PAGEADSP, atalkAdspBufferChunkReference)
#pragma alloc_text(PAGEADSP, atalkAdspBufferChunkDereference)
#pragma alloc_text(PAGEADSP, atalkAdspDecodeHeader)
#pragma alloc_text(PAGEADSP, atalkAdspGetNextConnId)
#pragma alloc_text(PAGEADSP, atalkAdspConnDeQueueAssocList)
#pragma alloc_text(PAGEADSP, atalkAdspConnDeQueueConnectList)
#pragma alloc_text(PAGEADSP, atalkAdspConnDeQueueListenList)
#pragma alloc_text(PAGEADSP, atalkAdspConnDeQueueActiveList)
#pragma alloc_text(PAGEADSP, atalkAdspAddrDeQueueGlobalList)
#pragma alloc_text(PAGEADSP, atalkAdspAddrDeQueueGlobalList)
#pragma alloc_text(PAGEADSP, atalkAdspConnDeQueueGlobalList)
#pragma alloc_text(PAGEADSP, atalkAdspAddrDeQueueOpenReq)
#pragma alloc_text(PAGEADSP, atalkAdspIsDuplicateOpenReq)
#pragma alloc_text(PAGEADSP, atalkAdspGenericComplete)
#pragma alloc_text(PAGEADSP, atalkAdspConnFindInConnect)
#endif

//
//	The model for ADSP calls in this module is as follows:
//	- For create calls (CreateAddress & CreateSession), a pointer to the created
//	 object is returned. This structure is referenced for creation.
//	- For all other calls, it expects a referenced pointer to the object.
//




VOID
AtalkInitAdspInitialize(
	VOID
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	INITIALIZE_SPIN_LOCK(&atalkAdspLock);
}




ATALK_ERROR
AtalkAdspCreateAddress(
	IN	PATALK_DEV_CTX		pDevCtx	OPTIONAL,
	IN	BYTE				SocketType,
	OUT	PADSP_ADDROBJ	*	ppAdspAddr
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PADSP_ADDROBJ		pAdspAddr = NULL;
	ATALK_ERROR			error;

	do
	{
		// Allocate memory for the Adsp address object
		if ((pAdspAddr = AtalkAllocZeroedMemory(sizeof(ADSP_ADDROBJ))) == NULL)
		{
			error = ATALK_RESR_MEM;
			break;
		}

		// Create a Ddp Socket on the port
		error = AtalkDdpOpenAddress(AtalkDefaultPort,
									0,					// Dynamic socket
									NULL,
									atalkAdspPacketIn,
									pAdspAddr,			// Context for packet in.
									DDPPROTO_ADSP,
									pDevCtx,
									&pAdspAddr->adspao_pDdpAddr);

		if (!ATALK_SUCCESS(error))
		{
			DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_ERR,
					("AtalkAdspCreateAddress: AtalkDdpOpenAddress fail %ld\n", error));
			break;
		}

		// Initialize the Adsp address object
		pAdspAddr->adspao_Signature = ADSPAO_SIGNATURE;

		INITIALIZE_SPIN_LOCK(&pAdspAddr->adspao_Lock);

		//	Is this a message mode socket?
		if (SocketType != SOCKET_TYPE_STREAM)
		{
			pAdspAddr->adspao_Flags	|= ADSPAO_MESSAGE;
		}

		//	Creation reference
		pAdspAddr->adspao_RefCount = 1;

	} while (FALSE);

	if (ATALK_SUCCESS(error))
	{
		//	Insert into the global address list.
		atalkAdspAddrQueueGlobalList(pAdspAddr);

		*ppAdspAddr = pAdspAddr;
	}
	else if (pAdspAddr != NULL)
	{
		AtalkFreeMemory(pAdspAddr);
	}

	return error;
}




ATALK_ERROR
AtalkAdspCleanupAddress(
	IN	PADSP_ADDROBJ			pAdspAddr
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	USHORT			i;
	KIRQL			OldIrql;
	PADSP_CONNOBJ	pAdspConn, pAdspConnNext;
	ATALK_ERROR		error;

	ACQUIRE_SPIN_LOCK(&pAdspAddr->adspao_Lock, &OldIrql);

	//	Shutdown all connections on this address object.
	for (i = 0; i < ADSP_CONN_HASH_SIZE; i++)
	{
		if ((pAdspConn = pAdspAddr->adspao_pActiveHash[i]) == NULL)
		{
			//	If empty, go on to the next index in hash table.
			continue;
		}

		//	Includes the one we are starting with.
		atalkAdspConnRefNextNc(pAdspConn, &pAdspConnNext, &error);
		if (!ATALK_SUCCESS(error))
		{
			//	No connections left on this index. Go to the next one.
			continue;
		}

		while (TRUE)
		{
			if ((pAdspConn = pAdspConnNext) == NULL)
			{
				break;
			}

			if ((pAdspConnNext = pAdspConn->adspco_pNextActive) != NULL)
			{
				atalkAdspConnRefNextNc(pAdspConnNext, &pAdspConnNext, &error);
				if (!ATALK_SUCCESS(error))
				{
					//	No requests left on this index. Go to the next one.
					pAdspConnNext = NULL;
				}
			}

			//	Shutdown this connection
			RELEASE_SPIN_LOCK(&pAdspAddr->adspao_Lock, OldIrql);

			DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
					("AtalkAdspCloseAddress: Stopping conn %lx\n", pAdspConn));

			AtalkAdspCleanupConnection(pAdspConn);

			AtalkAdspConnDereference(pAdspConn);
			ACQUIRE_SPIN_LOCK(&pAdspAddr->adspao_Lock, &OldIrql);
		}
	}
	RELEASE_SPIN_LOCK(&pAdspAddr->adspao_Lock, OldIrql);

	return ATALK_NO_ERROR;
}




ATALK_ERROR
AtalkAdspCloseAddress(
	IN	PADSP_ADDROBJ			pAdspAddr,
	IN	GENERIC_COMPLETION		CompletionRoutine,
	IN	PVOID					pCloseCtx
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	KIRQL	OldIrql;
	PADSP_CONNOBJ	pAdspConn;
	PADSP_CONNOBJ	pAdspConnNext;
    DWORD           dwAssocRefCounts=0;


	ACQUIRE_SPIN_LOCK(&pAdspAddr->adspao_Lock, &OldIrql);
	if (pAdspAddr->adspao_Flags & ADSPAO_CLOSING)
	{
		//	We are already closing! This should never happen!
		ASSERT(0);
	}
	pAdspAddr->adspao_Flags |= ADSPAO_CLOSING;

	//	Set the completion info.
	pAdspAddr->adspao_CloseComp	= CompletionRoutine;
	pAdspAddr->adspao_CloseCtx	= pCloseCtx;

	// Implicitly dissociate any connection objects
	for (pAdspConn = pAdspAddr->adspao_pAssocConn;
		 pAdspConn != NULL;
		 pAdspConn = pAdspConnNext)
	{
		ACQUIRE_SPIN_LOCK_DPC(&pAdspConn->adspco_Lock);
		pAdspConnNext = pAdspConn->adspco_pNextAssoc;

		// reset associated flag
		if (pAdspConn->adspco_Flags & ADSPCO_ASSOCIATED)
        {
            dwAssocRefCounts++;
            pAdspConn->adspco_Flags	&= ~ADSPCO_ASSOCIATED;
        }

		pAdspConn->adspco_pAssocAddr	= NULL;

		RELEASE_SPIN_LOCK_DPC(&pAdspConn->adspco_Lock);
	}

    // ok to subtract: at least Creation refcount is still around
    pAdspAddr->adspao_RefCount -= dwAssocRefCounts;

	RELEASE_SPIN_LOCK(&pAdspAddr->adspao_Lock, OldIrql);

	//	Remove the creation reference count
	AtalkAdspAddrDereference(pAdspAddr);

	return ATALK_PENDING;
}




ATALK_ERROR
AtalkAdspCreateConnection(
	IN	PVOID					pConnCtx,	// Context to associate with the session
	IN	PATALK_DEV_CTX			pDevCtx		OPTIONAL,
	OUT	PADSP_CONNOBJ	*		ppAdspConn
	)
/*++

Routine Description:

	Create an ADSP session. The created session starts off being an orphan, i.e.
	it has no parent address object. It gets one when it is associated.

Arguments:


Return Value:


--*/
{
	KIRQL			OldIrql;
	PADSP_CONNOBJ	pAdspConn;

	// Allocate memory for a connection object
	if ((pAdspConn = AtalkAllocZeroedMemory(sizeof(ADSP_CONNOBJ))) == NULL)
	{
		return ATALK_RESR_MEM;
	}

	pAdspConn->adspco_Signature = ADSPCO_SIGNATURE;

	INITIALIZE_SPIN_LOCK(&pAdspConn->adspco_Lock);
	pAdspConn->adspco_ConnCtx	= pConnCtx;
	// pAdspConn->adspco_Flags		= 0;
	pAdspConn->adspco_RefCount	= 1;					// Creation reference

	*ppAdspConn = pAdspConn;

	// Delay remote disconnects to avoid race condn. between rcv/disconnect since
	// this can cause AFD to get extremely unhappy.
	AtalkTimerInitialize(&pAdspConn->adspco_DisconnectTimer,
						 atalkAdspDisconnectTimer,
						 ADSP_DISCONNECT_DELAY);

	//	Insert into the global connection list.
	ACQUIRE_SPIN_LOCK(&atalkAdspLock, &OldIrql);
	pAdspConn->adspco_pNextGlobal	= atalkAdspConnList;
	atalkAdspConnList				= pAdspConn;
	RELEASE_SPIN_LOCK(&atalkAdspLock, OldIrql);

	return ATALK_NO_ERROR;
}




ATALK_ERROR
AtalkAdspCloseConnection(
	IN	PADSP_CONNOBJ			pAdspConn,
	IN	GENERIC_COMPLETION		CompletionRoutine,
	IN	PVOID					pCloseCtx
	)
/*++

Routine Description:

	Shutdown a session.

Arguments:


Return Value:


--*/
{
	KIRQL	OldIrql;

	ASSERT(VALID_ADSPCO(pAdspConn));

	DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
			("AtalkAdspStopConnection: Close for %lx.%lx\n", pAdspConn, pAdspConn->adspco_Flags));

	ACQUIRE_SPIN_LOCK(&pAdspConn->adspco_Lock, &OldIrql);
	if (pAdspConn->adspco_Flags & ADSPCO_CLOSING)
	{
		//	We are already closing! This should never happen!
		KeBugCheck(0);
	}
	pAdspConn->adspco_Flags |= ADSPCO_CLOSING;

	//	Set the completion info.
	pAdspConn->adspco_CloseComp	= CompletionRoutine;
	pAdspConn->adspco_CloseCtx	= pCloseCtx;
	RELEASE_SPIN_LOCK(&pAdspConn->adspco_Lock, OldIrql);

	//	Remove the creation reference count
	AtalkAdspConnDereference(pAdspConn);
	return ATALK_PENDING;
}




ATALK_ERROR
AtalkAdspCleanupConnection(
	IN	PADSP_CONNOBJ			pAdspConn
	)
/*++

Routine Description:

	Shutdown a session.

Arguments:


Return Value:


--*/
{
	KIRQL		OldIrql;
	BOOLEAN		stopping	= FALSE;
	ATALK_ERROR	error		= ATALK_NO_ERROR;

	ASSERT(VALID_ADSPCO(pAdspConn));

	DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
			("AtalkAdspStopConnection: Cleanup for %lx.%lx\n", pAdspConn, pAdspConn->adspco_Flags));

	ACQUIRE_SPIN_LOCK(&pAdspConn->adspco_Lock, &OldIrql);
	if ((pAdspConn->adspco_Flags & ADSPCO_STOPPING) == 0)
	{
		//	So Deref can complete cleanup irp.
		pAdspConn->adspco_Flags |= ADSPCO_STOPPING;

		//	If already effectively stopped, just return.
		if (pAdspConn->adspco_Flags & ADSPCO_ASSOCIATED)
		{
			stopping = TRUE;
		}
		else
		{
			DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_ERR,
					("AtalkAdspStopConnection: Called for a stopped conn %lx.%lx\n",
					pAdspConn, pAdspConn->adspco_Flags));
		}
	}
	RELEASE_SPIN_LOCK(&pAdspConn->adspco_Lock, OldIrql);

	//	Close the DDP Address Object if this was a server connection and
	//	opened its own socket.
	if (stopping)
	{
		//	If we are already disconnecting this will return an error which
		//	we ignore. But if we were only in the ASSOCIATED state, then we
		//	need to call disassociate here.
		error = AtalkAdspDisconnect(pAdspConn,
									ATALK_LOCAL_DISCONNECT,
									NULL,
									NULL);

		//	We were already disconnected.
		if (error == ATALK_INVALID_REQUEST)
		{
			AtalkAdspDissociateAddress(pAdspConn);
		}
	}

	return ATALK_NO_ERROR;
}




ATALK_ERROR
AtalkAdspAssociateAddress(
	IN	PADSP_ADDROBJ			pAdspAddr,
	IN	PADSP_CONNOBJ			pAdspConn
	)
/*++

Routine Description:

	Removed reference for the address for this connection. Causes deadlock in AFD where
	AFD blocks on close of the address object and we wait for connections to be closed
	first

Arguments:


Return Value:


--*/
{
	ATALK_ERROR		error;
	KIRQL			OldIrql;

	ASSERT(VALID_ADSPAO(pAdspAddr));
	ASSERT(VALID_ADSPCO(pAdspConn));

	ACQUIRE_SPIN_LOCK(&pAdspAddr->adspao_Lock, &OldIrql);
	ACQUIRE_SPIN_LOCK_DPC(&pAdspConn->adspco_Lock);

	error = ATALK_ALREADY_ASSOCIATED;
	if ((pAdspConn->adspco_Flags & ADSPCO_ASSOCIATED) == 0)
	{
		error = ATALK_NO_ERROR;

		//	Link it in.
		pAdspConn->adspco_pNextAssoc	= pAdspAddr->adspao_pAssocConn;
		pAdspAddr->adspao_pAssocConn	= pAdspConn;

		//	Remove not associated flag.
		pAdspConn->adspco_Flags |= ADSPCO_ASSOCIATED;
		pAdspConn->adspco_pAssocAddr = pAdspAddr;

        // put Association refcount
        pAdspAddr->adspao_RefCount++;
	}

	RELEASE_SPIN_LOCK_DPC(&pAdspConn->adspco_Lock);
	RELEASE_SPIN_LOCK(&pAdspAddr->adspao_Lock, OldIrql);

	return error;
}




ATALK_ERROR
AtalkAdspDissociateAddress(
	IN	PADSP_CONNOBJ			pAdspConn
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PADSP_ADDROBJ	pAdspAddr;
	KIRQL			OldIrql;
	ATALK_ERROR		error = ATALK_NO_ERROR;

	ASSERT(VALID_ADSPCO(pAdspConn));

	ACQUIRE_SPIN_LOCK(&pAdspConn->adspco_Lock, &OldIrql);
	if ((pAdspConn->adspco_Flags & (ADSPCO_LISTENING	|
									ADSPCO_CONNECTING	|
									ADSPCO_ACTIVE		|
									ADSPCO_ASSOCIATED)) != ADSPCO_ASSOCIATED)
	{
		//	ASSERTMSG("AtalkAdspDissociateAddress: Disassociate not valid\n", 0);
		error = ATALK_INVALID_CONNECTION;
	}
	else
	{
		pAdspAddr = pAdspConn->adspco_pAssocAddr ;

        if (pAdspAddr == NULL)
        {
		    ASSERT(0);
            error = ATALK_CANNOT_DISSOCIATE;
        }

		//	Set not associated flag. Don't reset the stopping flag.
		pAdspConn->adspco_Flags	&= ~ADSPCO_ASSOCIATED;

        // don't null it out yet: we'll do when we disconnect the connection
		// pAdspConn->adspco_pAssocAddr	= NULL;
	}
	RELEASE_SPIN_LOCK(&pAdspConn->adspco_Lock, OldIrql);

	//	Unlink it if ok.
	if (ATALK_SUCCESS(error))
	{
		ACQUIRE_SPIN_LOCK(&pAdspAddr->adspao_Lock, &OldIrql);
		ACQUIRE_SPIN_LOCK_DPC(&pAdspConn->adspco_Lock);
		atalkAdspConnDeQueueAssocList(pAdspAddr, pAdspConn);
		RELEASE_SPIN_LOCK_DPC(&pAdspConn->adspco_Lock);
		RELEASE_SPIN_LOCK(&pAdspAddr->adspao_Lock, OldIrql);

        // remove the Association refcount
        AtalkAdspAddrDereference(pAdspAddr);
	}
	return error;
}




ATALK_ERROR
AtalkAdspPostListen(
	IN	PADSP_CONNOBJ			pAdspConn,
	IN	PVOID					pListenCtx,
	IN	GENERIC_COMPLETION		CompletionRoutine
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PADSP_ADDROBJ	pAdspAddr = pAdspConn->adspco_pAssocAddr;
	KIRQL			OldIrql;
	ATALK_ERROR		error;

	//	This will also insert the connection object in the address objects
	//	list of connection which have a listen posted on them. When open
	//	connection requests come in, the first connection is taken off the list
	//	and the request satisfied.

	ASSERT(VALID_ADSPCO(pAdspConn));
	ASSERT(VALID_ADSPAO(pAdspAddr));

	ACQUIRE_SPIN_LOCK(&pAdspAddr->adspao_Lock, &OldIrql);
	ACQUIRE_SPIN_LOCK_DPC(&pAdspConn->adspco_Lock);
	do
	{
		if ((pAdspConn->adspco_Flags & (ADSPCO_LISTENING	|
										ADSPCO_CONNECTING	|
										ADSPCO_HALF_ACTIVE	|
										ADSPCO_ACTIVE		|
										ADSPCO_ASSOCIATED)) != ADSPCO_ASSOCIATED)
		{
			error = ATALK_INVALID_CONNECTION;
			break;
		}

		//	Verify the address object is not a connect address type.
		if (pAdspAddr->adspao_Flags & ADSPAO_CONNECT)
		{
			error = ATALK_INVALID_PARAMETER;
			break;
		}

		//	Make the address object a listener.
		pAdspAddr->adspao_Flags			|= ADSPAO_LISTENER;

		pAdspConn->adspco_Flags			|= ADSPCO_LISTENING;
		pAdspConn->adspco_ListenCtx		= pListenCtx;
		pAdspConn->adspco_ListenCompletion	= CompletionRoutine;

		//	Insert into the listen list.
		pAdspConn->adspco_pNextListen		= pAdspAddr->adspao_pListenConn;
		pAdspAddr->adspao_pListenConn		= pAdspConn;

		//	Inherits the address objects ddp address
		pAdspConn->adspco_pDdpAddr			= pAdspAddr->adspao_pDdpAddr;

		//	Initialize pended sends list
		InitializeListHead(&pAdspConn->adspco_PendedSends);

		error = ATALK_PENDING;
	} while (FALSE);
	RELEASE_SPIN_LOCK_DPC(&pAdspConn->adspco_Lock);
	RELEASE_SPIN_LOCK(&pAdspAddr->adspao_Lock, OldIrql);

	return error;
}




ATALK_ERROR
AtalkAdspCancelListen(
	IN	PADSP_CONNOBJ			pAdspConn
	)
/*++

Routine Description:

	Cancel a previously posted listen.

Arguments:


Return Value:


--*/
{
	PADSP_ADDROBJ		pAdspAddr	= pAdspConn->adspco_pAssocAddr;
	KIRQL				OldIrql;
	ATALK_ERROR			error		= ATALK_NO_ERROR;
	GENERIC_COMPLETION	completionRoutine = NULL;
	PVOID				completionCtx = NULL;

	ASSERT(VALID_ADSPCO(pAdspConn));
	ASSERT(VALID_ADSPAO(pAdspAddr));
	ACQUIRE_SPIN_LOCK(&pAdspAddr->adspao_Lock, &OldIrql);
	if (!atalkAdspConnDeQueueListenList(pAdspAddr, pAdspConn))
	{
		error = ATALK_INVALID_CONNECTION;
	}
	else
	{
		//	We complete the listen routine
		ASSERT(pAdspConn->adspco_Flags & ADSPCO_LISTENING);
		pAdspConn->adspco_Flags	&= ~ADSPCO_LISTENING;
		completionRoutine	= pAdspConn->adspco_ListenCompletion;
		completionCtx		= pAdspConn->adspco_ListenCtx;
	}
	RELEASE_SPIN_LOCK(&pAdspAddr->adspao_Lock, OldIrql);

	if (*completionRoutine != NULL)
	{
		(*completionRoutine)(ATALK_REQUEST_CANCELLED, completionCtx);
	}

	return error;
}




ATALK_ERROR
AtalkAdspPostConnect(
	IN	PADSP_CONNOBJ			pAdspConn,
	IN	PATALK_ADDR				pRemote_Addr,
	IN	PVOID					pConnectCtx,
	IN	GENERIC_COMPLETION		CompletionRoutine
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	ATALK_ERROR		error;
	KIRQL			OldIrql;
	BOOLEAN			DerefConn = FALSE;
	PADSP_ADDROBJ	pAdspAddr = pAdspConn->adspco_pAssocAddr;

	ASSERT(VALID_ADSPCO(pAdspConn));
	ASSERT(VALID_ADSPAO(pAdspAddr));
	ACQUIRE_SPIN_LOCK(&pAdspAddr->adspao_Lock, &OldIrql);
	ACQUIRE_SPIN_LOCK_DPC(&pAdspConn->adspco_Lock);
	do
	{
		if ((pAdspConn->adspco_Flags & (ADSPCO_LISTENING	|
										ADSPCO_CONNECTING	|
										ADSPCO_HALF_ACTIVE	|
										ADSPCO_ACTIVE		|
										ADSPCO_ASSOCIATED)) != ADSPCO_ASSOCIATED)
		{
			error = ATALK_INVALID_CONNECTION;
			break;
		}

		//	Verify the address object is not a listener address type.
		if (pAdspAddr->adspao_Flags & ADSPAO_LISTENER)
		{
			error = ATALK_INVALID_ADDRESS;
			break;
		}

		//	Reference the connection for this call and for the timer.
		AtalkAdspConnReferenceByPtrNonInterlock(pAdspConn, 2, &error);
		if (!ATALK_SUCCESS(error))
		{
			ASSERTMSG("AtalkAdspPostConnect: Connection ref failed\n", 0);
			break;
		}

		DerefConn = TRUE;

		pAdspConn->adspco_LocalConnId = atalkAdspGetNextConnId(pAdspAddr,
															   &error);

		if (ATALK_SUCCESS(error))
		{
			pAdspConn->adspco_Flags |= (ADSPCO_CONNECTING | ADSPCO_OPEN_TIMER);
			pAdspConn->adspco_ConnectCtx		= pConnectCtx;
			pAdspConn->adspco_ConnectCompletion = CompletionRoutine;
			pAdspConn->adspco_RemoteAddr		= *pRemote_Addr;
			pAdspConn->adspco_ConnectAttempts	= ADSP_MAX_OPEN_ATTEMPTS;

			//	Insert into the connect list.
			pAdspConn->adspco_pNextConnect		= pAdspAddr->adspao_pConnectConn;
			pAdspAddr->adspao_pConnectConn		= pAdspConn;
			pAdspAddr->adspao_Flags			   |= ADSPAO_CONNECT;

			pAdspConn->adspco_RecvWindow=
			pAdspConn->adspco_SendQueueMax	=
			pAdspConn->adspco_RecvQueueMax	= ADSP_DEF_SEND_RX_WINDOW_SIZE;

			//	Inherits the address objects ddp address
			pAdspConn->adspco_pDdpAddr			= pAdspAddr->adspao_pDdpAddr;

			//	Initialize pended sends list
			InitializeListHead(&pAdspConn->adspco_PendedSends);

			//	Start the open timer
			AtalkTimerInitialize(&pAdspConn->adspco_OpenTimer,
								 atalkAdspOpenTimer,
								 ADSP_OPEN_INTERVAL);
			AtalkTimerScheduleEvent(&pAdspConn->adspco_OpenTimer);
		}
		else
		{
			ASSERTMSG("AtalkAdspPostConnect: Unable to get conn id\n", 0);
			error = ATALK_RESR_MEM;
			RES_LOG_ERROR();
			break;
		}

	} while (FALSE);
	RELEASE_SPIN_LOCK_DPC(&pAdspConn->adspco_Lock);
	RELEASE_SPIN_LOCK(&pAdspAddr->adspao_Lock, OldIrql);

	if (ATALK_SUCCESS(error))
	{
		//	Send connect packet to the remote end. This will add its
		//	own references.
		atalkAdspSendOpenControl(pAdspConn);

		error = ATALK_PENDING;
	}
	else
	{
		if (DerefConn)
		{
			//	Remove the reference for timer only if error.
			AtalkAdspConnDereference(pAdspConn);
		}
	}

	if (DerefConn)
	{
		//	Remove the reference for call
		AtalkAdspConnDereference(pAdspConn);
	}

	return error;
}


#define	atalkAdspCompleteQueuedSends(_pAdspConn, _error)								\
	{																					\
		ULONG		writeBufLen;														\
		PVOID		writeCtx;															\
																						\
		while (!IsListEmpty(&(_pAdspConn)->adspco_PendedSends))							\
		{                                                                               \
			writeCtx = LIST_ENTRY_TO_WRITECTX((_pAdspConn)->adspco_PendedSends.Flink);  \
			writeBufLen = WRITECTX_SIZE(writeCtx);                                      \
	                                                                                    \
			DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_WARN,                                     \
					("AtalkAdspCompleteQueuedSends: %lx WriteLen %x\n",                 \
					writeCtx, writeBufLen));                                            \
	                                                                                    \
			RemoveEntryList(WRITECTX_LINKAGE(writeCtx));                                \
	                                                                                    \
			RELEASE_SPIN_LOCK(&(_pAdspConn)->adspco_Lock, OldIrql);                     \
			atalkTdiGenericWriteComplete(_error,                                        \
										 (PAMDL)(WRITECTX_TDI_BUFFER(writeCtx)),        \
										 (USHORT)writeBufLen,                           \
										 WRITECTX(writeCtx));                           \
			ACQUIRE_SPIN_LOCK(&(_pAdspConn)->adspco_Lock, &OldIrql);                    \
		}                                                                               \
	}


ATALK_ERROR
AtalkAdspDisconnect(
	IN	PADSP_CONNOBJ			pAdspConn,
	IN	ATALK_DISCONNECT_TYPE	DisconnectType,
	IN	PVOID					pDisconnectCtx,
	IN	GENERIC_COMPLETION		DisconnectRoutine
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PAMDL						readBuf					= NULL,
								exReadBuf				= NULL;
	GENERIC_READ_COMPLETION		readCompletion			= NULL,
								exReadCompletion		= NULL;
	PVOID						readCtx					= NULL,
								exReadCtx				= NULL;
	PAMDL						exWriteBuf				= NULL;
	GENERIC_WRITE_COMPLETION	exWriteCompletion		= NULL;
	PVOID						exWriteCtx				= NULL;
	PBYTE						exWriteChBuf			= NULL,
								exRecdBuf				= NULL;
	GENERIC_COMPLETION			completionRoutine		= NULL;
	PVOID						completionCtx			= NULL;
	ATALK_ERROR					error					= ATALK_PENDING;
	BOOLEAN						connTimerCancelled		= FALSE,
								openTimerCancelled	= FALSE,
								sendAttnTimerCancelled	= FALSE,
								rexmitTimerCancelled	= FALSE,
								connectCancelled		= FALSE;
	KIRQL						OldIrql;

	ASSERT(VALID_ADSPCO(pAdspConn));

	DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
			("AtalkAdspDisconnectConnection: %lx.%lx\n", pAdspConn, DisconnectType));

	ACQUIRE_SPIN_LOCK(&pAdspConn->adspco_Lock, &OldIrql);

	//	Support for graceful disconnect. We only drop the received
	//	data when the local end does a disconnect. This will happen
	//	regardless of whether this routine was previously called or
	//	not. Note that attentions are not acknowledged until our client
	//	reads them, so there isnt an issue with them. Also, this means
	//	that we must satisfy a read if disconnect is pending.
	if ((DisconnectType == ATALK_LOCAL_DISCONNECT) ||
		(DisconnectType == ATALK_TIMER_DISCONNECT))
	{
		atalkAdspDiscardFromBufferQueue(&pAdspConn->adspco_RecvQueue,
										atalkAdspBufferQueueSize(&pAdspConn->adspco_RecvQueue),
										NULL,
										DISCONN_STATUS(DisconnectType),
										NULL);
	}

	if ((pAdspConn->adspco_Flags & ADSPCO_DISCONNECTING) == 0)
	{
		if ((pAdspConn->adspco_Flags & (ADSPCO_LISTENING	|
										ADSPCO_CONNECTING	|
										ADSPCO_HALF_ACTIVE	|
										ADSPCO_ACTIVE)) == 0)
		{
			error = ATALK_INVALID_REQUEST;
		}
		else
		{
			pAdspConn->adspco_Flags |= ADSPCO_DISCONNECTING;
			if (DisconnectType == ATALK_LOCAL_DISCONNECT)
				pAdspConn->adspco_Flags |= ADSPCO_LOCAL_DISCONNECT;
			if (DisconnectType == ATALK_REMOTE_DISCONNECT)
				pAdspConn->adspco_Flags |= ADSPCO_REMOTE_DISCONNECT;

			if (pAdspConn->adspco_Flags & ADSPCO_LISTENING)
			{
				RELEASE_SPIN_LOCK(&pAdspConn->adspco_Lock, OldIrql);
				AtalkAdspCancelListen(pAdspConn);
				ACQUIRE_SPIN_LOCK(&pAdspConn->adspco_Lock, &OldIrql);
			}
			else if (pAdspConn->adspco_Flags & ADSPCO_CONNECTING)
			{
				//	Cancel open timer
				ASSERT(pAdspConn->adspco_Flags & ADSPCO_OPEN_TIMER);
				openTimerCancelled = AtalkTimerCancelEvent(&pAdspConn->adspco_OpenTimer,
															NULL);

				completionRoutine	= pAdspConn->adspco_ConnectCompletion;
				completionCtx		= pAdspConn->adspco_ConnectCtx;

				//	We can only be here if the connect is not done yet. Complete
				//	as if timer is done, always.
				pAdspConn->adspco_DisconnectStatus = ATALK_TIMEOUT;
				RELEASE_SPIN_LOCK(&pAdspConn->adspco_Lock, OldIrql);
				connectCancelled = atalkAdspConnDeQueueConnectList(pAdspConn->adspco_pAssocAddr,
																   pAdspConn);

				if (!connectCancelled)
				{
					completionRoutine	= NULL;
					completionCtx		= NULL;
				}

				ACQUIRE_SPIN_LOCK(&pAdspConn->adspco_Lock, &OldIrql);
			}

			//	Both of the above could have failed as the connection
			//	might have become active before the cancel succeeded.
			//	In that case (or if we were active to begin with), do
			//	a disconnect here.
			if (pAdspConn->adspco_Flags & (ADSPCO_HALF_ACTIVE | ADSPCO_ACTIVE))
			{
				//	Get the completion routines for a pending accept
				if (pAdspConn->adspco_Flags & ADSPCO_ACCEPT_IRP)
				{
					completionRoutine		= pAdspConn->adspco_ListenCompletion;
					completionCtx			= pAdspConn->adspco_ListenCtx;

					//	Dequeue the open request that must be queued on
					//	this connection object to filter duplicates.

					pAdspConn->adspco_Flags	&= ~ADSPCO_ACCEPT_IRP;
				}

				//	First cancel the conection maintainance timer. Only if
				//	we are not called from the timer.
				if ((DisconnectType != ATALK_TIMER_DISCONNECT) &&
					(connTimerCancelled =
						AtalkTimerCancelEvent(&pAdspConn->adspco_ConnTimer,
											  NULL)))
				{
					DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_WARN,
							("AtalkAdspDisconnect: Cancelled timer successfully\n"));
				}

				//	Cancel retransmit timer if started. Could be called from
				//	OpenTimer.
				if	(pAdspConn->adspco_Flags & ADSPCO_RETRANSMIT_TIMER)
				{
					rexmitTimerCancelled =
						AtalkTimerCancelEvent(&pAdspConn->adspco_RetransmitTimer,
											  NULL);
				}

				//	Remember completion routines as appropriate.
				if (DisconnectType == ATALK_INDICATE_DISCONNECT)
				{
					if (pAdspConn->adspco_DisconnectInform == NULL)
					{
						pAdspConn->adspco_DisconnectInform		= DisconnectRoutine;
						pAdspConn->adspco_DisconnectInformCtx	= pDisconnectCtx;
					}
					else
					{
						DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_ERR,
								("AtalkAdspDisconnect: duplicate disc comp rou%lx\n", pAdspConn));

						error = ATALK_TOO_MANY_COMMANDS;
					}
				}
				else if (DisconnectType == ATALK_LOCAL_DISCONNECT)
				{
					//	Replace completion routines only if previous ones are
					//	NULL.
					if (*pAdspConn->adspco_DisconnectCompletion == NULL)
					{
						pAdspConn->adspco_DisconnectCompletion	= DisconnectRoutine;
						pAdspConn->adspco_DisconnectCtx			= pDisconnectCtx;
					}
					else
					{
						DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_ERR,
								("AtalkAdspDisconnect: duplicate disc comp rou%lx\n", pAdspConn));

						error = ATALK_TOO_MANY_COMMANDS;
					}
				}

				//	Figure out the disconnect status and remember it in the
				//	connection object.
				pAdspConn->adspco_DisconnectStatus = DISCONN_STATUS(DisconnectType);

				if (pAdspConn->adspco_Flags & ADSPCO_ATTN_DATA_RECD)
				{
					exRecdBuf			= pAdspConn->adspco_ExRecdData;
					pAdspConn->adspco_Flags	&= ~ADSPCO_ATTN_DATA_RECD;
				}

				//	Is there a pending send attention?
				if (pAdspConn->adspco_Flags & ADSPCO_EXSEND_IN_PROGRESS)
				{
					exWriteCompletion	= pAdspConn->adspco_ExWriteCompletion;
					exWriteCtx			= pAdspConn->adspco_ExWriteCtx;
					exWriteBuf			= pAdspConn->adspco_ExWriteBuf;
					exWriteChBuf		= pAdspConn->adspco_ExWriteChBuf;

					ASSERT(exWriteChBuf	!= NULL);
					sendAttnTimerCancelled =
							AtalkTimerCancelEvent(&pAdspConn->adspco_ExRetryTimer,
												  NULL);

					pAdspConn->adspco_Flags &= ~ADSPCO_EXSEND_IN_PROGRESS;
				}


				//	Are there any pending receives?
				if (pAdspConn->adspco_Flags & ADSPCO_READ_PENDING)
				{
					readBuf			= pAdspConn->adspco_ReadBuf;
					readCompletion	= pAdspConn->adspco_ReadCompletion;
					readCtx			= pAdspConn->adspco_ReadCtx;

					pAdspConn->adspco_Flags &= ~ADSPCO_READ_PENDING;
				}

				if (pAdspConn->adspco_Flags & ADSPCO_EXREAD_PENDING)
				{
					exReadBuf			= pAdspConn->adspco_ExReadBuf;
					exReadCompletion	= pAdspConn->adspco_ExReadCompletion;
					exReadCtx			= pAdspConn->adspco_ExReadCtx;

					pAdspConn->adspco_Flags &= ~ADSPCO_EXREAD_PENDING;
				}

				//	Discard the send queue. This will complete pending sends.
				atalkAdspDiscardFromBufferQueue(&pAdspConn->adspco_SendQueue,
												atalkAdspBufferQueueSize(&pAdspConn->adspco_SendQueue),
												NULL,
												pAdspConn->adspco_DisconnectStatus,
												pAdspConn);

				atalkAdspCompleteQueuedSends(pAdspConn,
											 pAdspConn->adspco_DisconnectStatus);

				RELEASE_SPIN_LOCK(&pAdspConn->adspco_Lock, OldIrql);

				//	Send out disconnect packet if this was a timer or local close.
				if ((DisconnectType == ATALK_LOCAL_DISCONNECT) ||
					(DisconnectType == ATALK_TIMER_DISCONNECT))
				{

					ACQUIRE_SPIN_LOCK(&pAdspConn->adspco_Lock, &OldIrql);
					atalkAdspSendControl(pAdspConn,
										 ADSP_CONTROL_FLAG + ADSP_CLOSE_CONN_CODE);
					RELEASE_SPIN_LOCK(&pAdspConn->adspco_Lock, OldIrql);
				}

				//	Call the send attention completion
				if (*exWriteCompletion != NULL)
				{
					DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
							("atalkDisconnect: ExWrite\n"));

					(*exWriteCompletion)(pAdspConn->adspco_DisconnectStatus,
										 exWriteBuf,
										 0,
										 exWriteCtx);

					AtalkFreeMemory(exWriteChBuf);
				}

				//	If we had received an attention packet, and had
				//	saved it away, free it.
				if (exRecdBuf != NULL)
				{
					AtalkFreeMemory(exRecdBuf);
				}

				if (*readCompletion != NULL)
				{
					DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
							("atalkDisconnect: Read %lx\n", pAdspConn->adspco_DisconnectStatus));

					(*readCompletion)(pAdspConn->adspco_DisconnectStatus,
									  readBuf,
									  0,
									  0,
									  readCtx);

					//	Deref connection for the read
					AtalkAdspConnDereference(pAdspConn);
				}

				if (*exReadCompletion != NULL)
				{
					DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
							("atalkDisconnect: ExRead\n"));

					(*exReadCompletion)(pAdspConn->adspco_DisconnectStatus,
										exReadBuf,
										0,
										0,
										exReadCtx);

					//	Deref connection for the read
					AtalkAdspConnDereference(pAdspConn);
				}

				//	Call the disconnect indication routine if present for a timer/
				//	remote disconnect.
				if ((DisconnectType == ATALK_REMOTE_DISCONNECT) ||
					(DisconnectType == ATALK_TIMER_DISCONNECT))
				{
					PTDI_IND_DISCONNECT	discHandler;
					PVOID					discCtx;
					PADSP_ADDROBJ			pAdspAddr = pAdspConn->adspco_pAssocAddr;

					ASSERT(VALID_ADSPAO(pAdspAddr));

					//	Acquire lock so we get a consistent handler/ctx.
					ACQUIRE_SPIN_LOCK(&pAdspAddr->adspao_Lock, &OldIrql);
					discHandler = pAdspAddr->adspao_DisconnectHandler;
					discCtx	= pAdspAddr->adspao_DisconnectHandlerCtx;
					RELEASE_SPIN_LOCK(&pAdspAddr->adspao_Lock, OldIrql);

					if (*discHandler != NULL)
					{
						(*discHandler)(discCtx,
									   pAdspConn->adspco_ConnCtx,
									   0,						//	DisconnectDataLength
									   NULL,					//	DisconnectData
									   0,						//	DisconnectInfoLength
									   NULL,					//	DisconnectInfo
									   TDI_DISCONNECT_ABORT);	//	Disconnect flags.
					}
				}

				//	Stop the ddp address.
				AtalkDdpCleanupAddress(pAdspConn->adspco_pDdpAddr);
				ACQUIRE_SPIN_LOCK(&pAdspConn->adspco_Lock, &OldIrql);
			}
		}
	}
	else
	{
		//	Do we need to remember the completion routines?
		//	Yes, if this is a disconnect or a indicate disconnect request,
		//	and our current disconnect was started due to the address object
		//	being closed.
		if (DisconnectType == ATALK_INDICATE_DISCONNECT)
		{
			if (pAdspConn->adspco_DisconnectInform == NULL)
			{
				pAdspConn->adspco_DisconnectInform		= DisconnectRoutine;
				pAdspConn->adspco_DisconnectInformCtx	= pDisconnectCtx;
			}
			else
			{
				error = ATALK_TOO_MANY_COMMANDS;
			}
		}
		else if (DisconnectType == ATALK_LOCAL_DISCONNECT)
		{
			//	Replace completion routines only if previous ones are
			//	NULL.
			if (*pAdspConn->adspco_DisconnectCompletion == NULL)
			{
				pAdspConn->adspco_DisconnectCompletion	= DisconnectRoutine;
				pAdspConn->adspco_DisconnectCtx			= pDisconnectCtx;
			}
			else
			{
				error = ATALK_TOO_MANY_COMMANDS;
			}
		}
	}
	RELEASE_SPIN_LOCK(&pAdspConn->adspco_Lock, OldIrql);

	//	If there was a completion routine to call, call it now.
	if (*completionRoutine != NULL)
	{
		(*completionRoutine)(pAdspConn->adspco_DisconnectStatus,
							 completionCtx);
	}

	//	If we cancelled any timers, remove their references.
	if (connTimerCancelled)
	{
		AtalkAdspConnDereference(pAdspConn);
	}

	if (sendAttnTimerCancelled)
	{
		AtalkAdspConnDereference(pAdspConn);
	}

	if (openTimerCancelled)
	{
		AtalkAdspConnDereference(pAdspConn);
	}

	if (rexmitTimerCancelled)
	{
		AtalkAdspConnDereference(pAdspConn);
	}

	return error;
}




ATALK_ERROR
AtalkAdspRead(
	IN	PADSP_CONNOBJ			pAdspConn,
	IN	PAMDL					pReadBuf,
	IN	USHORT					ReadBufLen,
	IN	ULONG					ReadFlags,
	IN	PVOID					pReadCtx,
	IN	GENERIC_READ_COMPLETION	CompletionRoutine
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	KIRQL			OldIrql;
	ATALK_ERROR		error;

	ASSERT(VALID_ADSPCO(pAdspConn));

	ACQUIRE_SPIN_LOCK(&pAdspConn->adspco_Lock, &OldIrql);
	do
	{
		//	We allow reads when disconnecting if the receive data
		//	queue is non-empty. Since none of the receive chunks ref
		//	the connection, the active flag and the disconnect
		//	flags could have gone away. So we cue of the receive buffer
		//	size. We also dont allow exdata recvs unless we are active.
		if (((pAdspConn->adspco_Flags & (ADSPCO_CLOSING | ADSPCO_STOPPING)))	||
			((((pAdspConn->adspco_Flags & ADSPCO_ACTIVE) == 0) ||
			   (pAdspConn->adspco_Flags & ADSPCO_DISCONNECTING)) &&
				(((atalkAdspBufferQueueSize(&pAdspConn->adspco_RecvQueue) == 0)) ||
				 (ReadFlags & TDI_RECEIVE_EXPEDITED))))
		{
			DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_WARN,
					("AtalkAdspRead: Failing on %lx Flg %lx.%lx\n",
					pAdspConn, pAdspConn->adspco_Flags, ReadFlags));

			error = ATALK_ADSP_CONN_NOT_ACTIVE;
			break;
		}

		//	Depending on the kind of read we are posting...
		if (((ReadFlags & TDI_RECEIVE_NORMAL) &&
			 (pAdspConn->adspco_Flags & ADSPCO_READ_PENDING)) ||
			 ((ReadFlags & TDI_RECEIVE_EXPEDITED) &&
			  (pAdspConn->adspco_Flags & ADSPCO_EXREAD_PENDING)))
		{
			error = ATALK_TOO_MANY_COMMANDS;
			break;
		}

		AtalkAdspConnReferenceByPtrNonInterlock(pAdspConn, 1, &error);
		if (!ATALK_SUCCESS(error))
		{
			DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_ERR,
					("AtalkAdspRead: ConnRef Failing on %lx Flg %lx.%lx\n",
					pAdspConn, pAdspConn->adspco_Flags, ReadFlags));
			break;
		}

		//	Remember the read completion information
		if (ReadFlags & TDI_RECEIVE_NORMAL)
		{
			pAdspConn->adspco_Flags			   |= ADSPCO_READ_PENDING;
			pAdspConn->adspco_ReadFlags			= ReadFlags;
			pAdspConn->adspco_ReadBuf			= pReadBuf;
			pAdspConn->adspco_ReadBufLen		= ReadBufLen;
			pAdspConn->adspco_ReadCompletion	= CompletionRoutine;
			pAdspConn->adspco_ReadCtx			= pReadCtx;
		}
		else
		{
			ASSERT(ReadFlags & TDI_RECEIVE_EXPEDITED);
			pAdspConn->adspco_Flags			   |= ADSPCO_EXREAD_PENDING;
			pAdspConn->adspco_ExReadFlags		= ReadFlags;
			pAdspConn->adspco_ExReadBuf			= pReadBuf;
			pAdspConn->adspco_ExReadBufLen		= ReadBufLen;
			pAdspConn->adspco_ExReadCompletion	= CompletionRoutine;
			pAdspConn->adspco_ExReadCtx			= pReadCtx;
		}
	} while (FALSE);

	if (ATALK_SUCCESS(error))
	{
		//	Try to complete the read. This will also handle received
		//	attention data.
		atalkAdspRecvData(pAdspConn);
		error = ATALK_PENDING;
	}

	RELEASE_SPIN_LOCK(&pAdspConn->adspco_Lock, OldIrql);
	return error;
}




VOID
AtalkAdspProcessQueuedSend(
	IN	PADSP_CONNOBJ				pAdspConn
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	ULONG			sendSize, windowSize, writeBufLen, writeFlags;
	KIRQL			OldIrql;
	PVOID			writeCtx;
	ATALK_ERROR		error;
	BOOLEAN			eom;
	PBUFFER_CHUNK	pChunk	  = NULL;

	PTDI_IND_SEND_POSSIBLE  sendPossibleHandler;
	PVOID			sendPossibleHandlerCtx;

	//	Walk through pended list.
	while (!IsListEmpty(&pAdspConn->adspco_PendedSends))
	{
		writeCtx = LIST_ENTRY_TO_WRITECTX(pAdspConn->adspco_PendedSends.Flink);
		writeBufLen = WRITECTX_SIZE(writeCtx);
		writeFlags	= WRITECTX_FLAGS(writeCtx);

		eom = (writeFlags & TDI_SEND_PARTIAL) ? FALSE : TRUE;
		eom = (eom && (pAdspConn->adspco_pAssocAddr->adspao_Flags & ADSPAO_MESSAGE));

		windowSize	= (LONG)(pAdspConn->adspco_SendWindowSeq	-
							 pAdspConn->adspco_SendSeq			+
							 (LONG)1);

		sendSize =	MIN(atalkAdspMaxSendSize(pAdspConn), windowSize);

		DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_WARN,
				("AtalkAdspProcessQueuedSend: %lx SendSize %lx, WriteBufLen %x Flags %lx\n",
				writeCtx, sendSize, writeBufLen, writeFlags));

		//	While looping through requests, we might exhaust window.
		if (sendSize == 0)
		{
			//	Call send possible handler indicating sends are not ok.
			//	Needs to be within spinlock to avoid raceconditions where
			//	an ack has come in and opened the window. And it needs to
			//	be before atalkAdspSendData() as that will release the lock.
			sendPossibleHandler		=
						pAdspConn->adspco_pAssocAddr->adspao_SendPossibleHandler;
			sendPossibleHandlerCtx	=
						pAdspConn->adspco_pAssocAddr->adspao_SendPossibleHandlerCtx;

			if (*sendPossibleHandler != NULL)
			{
				(*sendPossibleHandler)(sendPossibleHandlerCtx,
									   pAdspConn->adspco_ConnCtx,
									   0);

				pAdspConn->adspco_Flags	|= ADSPCO_SEND_WINDOW_CLOSED;
			}
			break;
		}

		//	!!!	The client can do a send with 0 bytes and eom only also.
		if ((ULONG)(writeBufLen + BYTECOUNT(eom)) > sendSize)
		{
			DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_WARN,
					("AtalkAdspProcessQueuedSend: WriteBufLen %lx > sendsize %lx\n",
					writeBufLen, sendSize));

			//	Adjust send to send as much as it can. Winsock loop will pend
			//	it again with remaining data.
			writeBufLen = (USHORT)(sendSize - BYTECOUNT(eom));

			//	If we hit the weird case where now we are trying to send 0 bytes and
			//	no eom, while the actual send does have an eom, then we just wait
			//	for window to open up more.
			if (eom && (writeBufLen == 0))
			{
				DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_ERR,
						("AtalkAdspProcessQueuedSend: WriteBufLen %lx.%d.%lx %lx\n",
						writeBufLen, eom, sendSize, pAdspConn));
				break;
			}

			ASSERT(writeBufLen > 0);
			eom	= FALSE;
		}

		ASSERT((writeBufLen > 0) || eom);

		//	Yippee, can send it now. Either it goes in send queue or is completed
		//	right away.
		RemoveEntryList(WRITECTX_LINKAGE(writeCtx));

		DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_WARN,
				("AtalkAdspProcessQueuedSend: Processing queued send %lx.%lx\n",
				pAdspConn, writeCtx));

		//	Think positive! Assume everything will go well and allocate
		//	the buffer chunk that would be needed for this data. Copy the
		//	data into the buffer chunk. We cant do this in the beginning as
		//	we need to get WriteBufLen set up.
		pChunk = (PBUFFER_CHUNK)
					atalkAdspAllocCopyChunk((PAMDL)(WRITECTX_TDI_BUFFER(writeCtx)),
											(USHORT)writeBufLen,
											eom,
											FALSE);

		error = ATALK_RESR_MEM;
		if (pChunk != NULL)
		{
			//	Set the completion information in the chunk. This will
			//	be called when the last reference on the chunk goes away.
			pChunk->bc_Flags			|= BC_SEND;
			pChunk->bc_WriteBuf			 = (PAMDL)(WRITECTX_TDI_BUFFER(writeCtx));
			pChunk->bc_WriteCompletion	 = atalkTdiGenericWriteComplete;
			pChunk->bc_WriteCtx			 = writeCtx;
			pChunk->bc_ConnObj			 = pAdspConn;

			atalkAdspAddToBufferQueue(&pAdspConn->adspco_SendQueue,
									  pChunk,
									  &pAdspConn->adspco_NextSendQueue);

			//	Try to send the data
			atalkAdspSendData(pAdspConn);
			error = ATALK_PENDING;
		}

		if (!ATALK_SUCCESS(error))
		{
			DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_ERR,
					("AtalkAdspProcessQueuedSend: Error queued send %lx.%lx\n",
					pAdspConn, writeCtx));

#if DBG
            (&pAdspConn->adspco_Lock)->FileLineLock |= 0x80000000;
#endif
			//	Complete send request with insufficient resources error.
			RELEASE_SPIN_LOCK_DPC(&pAdspConn->adspco_Lock);
			atalkTdiGenericWriteComplete(error,
										 (PAMDL)(WRITECTX_TDI_BUFFER(writeCtx)),
										 (USHORT)writeBufLen,
										 WRITECTX(writeCtx));
			ACQUIRE_SPIN_LOCK_DPC(&pAdspConn->adspco_Lock);
#if DBG
            (&pAdspConn->adspco_Lock)->FileLineLock &= ~0x80000000;
#endif
		}
	}
}




ATALK_ERROR
AtalkAdspWrite(
	IN	PADSP_CONNOBJ				pAdspConn,
	IN	PAMDL						pWriteBuf,
	IN	USHORT						WriteBufLen,
	IN	ULONG						SendFlags,
	IN	PVOID						pWriteCtx,
	IN	GENERIC_WRITE_COMPLETION	CompletionRoutine
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	ATALK_ERROR				error;
	BOOLEAN					eom;
	ULONG					sendSize, windowSize;
	PTDI_IND_SEND_POSSIBLE  sendPossibleHandler;
	PVOID					sendPossibleHandlerCtx;
	KIRQL					OldIrql;
	PBUFFER_CHUNK			pChunk	  = NULL;
	BOOLEAN					DerefConn = FALSE,
							callComp  = FALSE;


	ASSERT(VALID_ADSPCO(pAdspConn));

	eom = (SendFlags & TDI_SEND_PARTIAL) ? FALSE : TRUE;
	if ((WriteBufLen == 0) && !eom)
	{
		return ATALK_BUFFER_TOO_SMALL;
	}

	if (SendFlags & TDI_SEND_EXPEDITED)
	{
		return (atalkAdspSendExpedited(pAdspConn,
									   pWriteBuf,
									   WriteBufLen,
									   SendFlags,
									   pWriteCtx,
									   CompletionRoutine));
	}

	//	We atleast have one byte of data or eom to send.
	ASSERT(eom || (WriteBufLen != 0));

	ACQUIRE_SPIN_LOCK(&pAdspConn->adspco_Lock, &OldIrql);
	do
	{
		if ((pAdspConn->adspco_Flags & (ADSPCO_ACTIVE	|
										ADSPCO_CLOSING	|
										ADSPCO_STOPPING	|
										ADSPCO_DISCONNECTING)) != ADSPCO_ACTIVE)
		{
			error = ATALK_ADSP_CONN_NOT_ACTIVE;
			break;
		}

		if (pAdspConn->adspco_Flags & ADSPCO_SEND_IN_PROGRESS)
		{
			error = ATALK_TOO_MANY_COMMANDS;
			break;
		}

		AtalkAdspConnReferenceByPtrNonInterlock(pAdspConn, 1, &error);
		if (!ATALK_SUCCESS(error))
		{
			break;
		}

		eom = (eom && (pAdspConn->adspco_pAssocAddr->adspao_Flags & ADSPAO_MESSAGE));

		DerefConn = TRUE;

		windowSize	= (LONG)(pAdspConn->adspco_SendWindowSeq	-
							 pAdspConn->adspco_SendSeq			+
							 (LONG)1);

		sendSize =	MIN(atalkAdspMaxSendSize(pAdspConn), windowSize);

		DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
				("AtalkAdspWrite: SendSize %lx, WriteBufLen %x\n", sendSize, WriteBufLen));

		//	For a blocking send, queue in any sends that exceed window size.
		if ((SendFlags & TDI_SEND_NON_BLOCKING) == 0)
		{
			if ((!IsListEmpty(&pAdspConn->adspco_PendedSends)) ||
				(sendSize < (WriteBufLen + BYTECOUNT(eom))))
			{
				//	Stop sends whenever a send gets queued.
				sendPossibleHandler		=
							pAdspConn->adspco_pAssocAddr->adspao_SendPossibleHandler;
				sendPossibleHandlerCtx	=
							pAdspConn->adspco_pAssocAddr->adspao_SendPossibleHandlerCtx;

				if (*sendPossibleHandler != NULL)
				{
					(*sendPossibleHandler)(sendPossibleHandlerCtx,
										   pAdspConn->adspco_ConnCtx,
										   0);

					pAdspConn->adspco_Flags	|= ADSPCO_SEND_WINDOW_CLOSED;
				}

				DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
						("AtalkAdspWrite: Wdw %lx, WriteLen %x on BLOCKING QUEUEING !\n",
						sendSize, WriteBufLen));

				InsertTailList(&pAdspConn->adspco_PendedSends, WRITECTX_LINKAGE(pWriteCtx));

				if (sendSize > 0)
				{
					AtalkAdspProcessQueuedSend(pAdspConn);
				}
				error = ATALK_PENDING;
				break;
			}
		}
		else
		{
			//	If there are pended blocking sends complete them with
			//	ATALK_REQUEST_NOT_ACCEPTED (WSAEWOULDBLOCK).
			//
			//	!!!This is data corruption, but app shouldn't be doing this.
			//
			if (!IsListEmpty(&pAdspConn->adspco_PendedSends))
			{
				DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_ERR,
						("AtalkAdspWrite: ABORTING PENDED SENDS CORRUPTION %lx\n", pAdspConn));

				atalkAdspCompleteQueuedSends(pAdspConn, ATALK_REQUEST_NOT_ACCEPTED);
			}
		}

		if (sendSize == 0)
		{
			//	Call send possible handler indicating sends are not ok.
			//	Needs to be within spinlock to avoid raceconditions where
			//	an ack has come in and opened the window. And it needs to
			//	be before atalkAdspSendData() as that will release the lock.
			sendPossibleHandler		=
						pAdspConn->adspco_pAssocAddr->adspao_SendPossibleHandler;
			sendPossibleHandlerCtx	=
						pAdspConn->adspco_pAssocAddr->adspao_SendPossibleHandlerCtx;

			if (*sendPossibleHandler != NULL)
			{
				(*sendPossibleHandler)(sendPossibleHandlerCtx,
									   pAdspConn->adspco_ConnCtx,
									   0);

				pAdspConn->adspco_Flags	|= ADSPCO_SEND_WINDOW_CLOSED;
			}

			if (SendFlags & TDI_SEND_NON_BLOCKING)
			{
				//	!!!NOTE!!!
				//	To avoid the race condition in AFD where an incoming
				//	send data indication setting send's possible to true
				//	is overwritten by this read's unwinding and setting it
				//	to false, we return ATALK_REQUEST_NOT_ACCEPTED, which
				//	will map to STATUS_REQUEST_NOT_ACCEPTED and then to
				//	WSAEWOULDBLOCK.
				//	error = ATALK_DEVICE_NOT_READY;

				error = ATALK_REQUEST_NOT_ACCEPTED;
			}

			//	We have no open send window, try to send data in the retransmit
			//	queue.
			atalkAdspSendData(pAdspConn);
			break;
		}

		//	Because of the sequence numbers, we need to copy the data
		//	into our buffers while holding the spinlock. If we cant send it all
		//	send as much as we can.

		//	!!! TDI doesn't count the eom as taking up a count, so we need to
		//		make allowances for that. If we are able to send just the data
		//		but not the eom, we should send one less byte than requested, so
		//		the client retries again.

		//	!!!	The client can do a send with 0 bytes and eom only also.
		if ((ULONG)(WriteBufLen + BYTECOUNT(eom)) > sendSize)
		{
			DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
					("AtalkAdspSend: WriteBufLen being decreased %x.%lx\n",
					WriteBufLen, sendSize-BYTECOUNT(eom)));

			WriteBufLen = (USHORT)(sendSize - BYTECOUNT(eom));
			eom			= FALSE;
		}

		if ((WriteBufLen == 0) && !eom)
		{
			DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_ERR,
					("AtalkAdspSend: SEND 0 bytes NO EOM %lx\n", pAdspConn));

			callComp	= TRUE;
			error		= ATALK_PENDING;
			break;
		}

		//	pAdspConn->adspco_Flags	|= ADSPCO_SEND_IN_PROGRESS;
		//	If we release the spin lock here we have a race condition
		//	where the sendsize is still not accounting for this send,
		//	and so another posted send could come in when it really
		//	shouldn't. We avoid it using the flag above, which when
		//	set will prevent further sends from happening.
		//	RELEASE_SPIN_LOCK(&pAdspConn->adspco_Lock, OldIrql);

		//	Think positive! Assume everything will go well and allocate
		//	the buffer chunk that would be needed for this data. Copy the
		//	data into the buffer chunk. We cant do this in the beginning as
		//	we need to get WriteBufLen set up.
		pChunk = (PBUFFER_CHUNK)atalkAdspAllocCopyChunk(pWriteBuf,
														WriteBufLen,
														eom,
														FALSE);

		//	ACQUIRE_SPIN_LOCK(&pAdspConn->adspco_Lock, &OldIrql);
		//	pAdspConn->adspco_Flags	&= ~ADSPCO_SEND_IN_PROGRESS;

		error = ATALK_RESR_MEM;
		if (pChunk != NULL)
		{
			//	Set the completion information in the chunk. This will
			//	be called when the last reference on the chunk goes away.
			pChunk->bc_Flags			|= BC_SEND;
			pChunk->bc_WriteBuf			 = pWriteBuf;
			pChunk->bc_WriteCompletion	 = CompletionRoutine;
			pChunk->bc_WriteCtx			 = pWriteCtx;
			pChunk->bc_ConnObj			 = pAdspConn;

			atalkAdspAddToBufferQueue(&pAdspConn->adspco_SendQueue,
									  pChunk,
									  &pAdspConn->adspco_NextSendQueue);

			//	Try to send the data
			atalkAdspSendData(pAdspConn);
			error = ATALK_PENDING;
		}
	} while (FALSE);

	RELEASE_SPIN_LOCK(&pAdspConn->adspco_Lock, OldIrql);

	if ((error == ATALK_PENDING) && callComp)
	{
		ASSERT(WriteBufLen	== 0);
		ASSERT(pChunk		== NULL);

		(*CompletionRoutine)(ATALK_NO_ERROR,
							 pWriteBuf,
							 WriteBufLen,
							 pWriteCtx);
	}
	else if (!ATALK_SUCCESS(error) && (pChunk != NULL))
	{
	   AtalkFreeMemory(pChunk);
	}

	if (DerefConn)
	{
		AtalkAdspConnDereference(pAdspConn);
	}

	return error;
}




VOID
AtalkAdspQuery(
	IN	PVOID			pObject,
	IN	ULONG			ObjectType,
	IN	PAMDL			pAmdl,
	OUT	PULONG			BytesWritten
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	switch (ObjectType)
	{
	case TDI_TRANSPORT_ADDRESS_FILE :
		ASSERT(VALID_ADSPAO((PADSP_ADDROBJ)pObject));
		AtalkDdpQuery(AtalkAdspGetDdpAddress((PADSP_ADDROBJ)pObject),
					  pAmdl,
					  BytesWritten);

		break;

	case TDI_CONNECTION_FILE :
		{
			KIRQL			OldIrql;
			PADSP_CONNOBJ	pAdspConn;

			pAdspConn	= (PADSP_CONNOBJ)pObject;
			ASSERT(VALID_ADSPCO(pAdspConn));

			*BytesWritten = 0;
			//	Get the address from the associated address if any.
			ACQUIRE_SPIN_LOCK(&pAdspConn->adspco_Lock, &OldIrql);
			if (pAdspConn->adspco_Flags & ADSPCO_ASSOCIATED)
			{
				AtalkDdpQuery(AtalkAdspGetDdpAddress(pAdspConn->adspco_pAssocAddr),
							  pAmdl,
							  BytesWritten);
			}
			RELEASE_SPIN_LOCK(&pAdspConn->adspco_Lock, OldIrql);
		}
		break;

	case TDI_CONTROL_CHANNEL_FILE :
	default:
		break;
	}

}



//
//	ADSP PACKET IN (HANDLE ROUTINES)
//

VOID
atalkAdspPacketIn(
	IN	PPORT_DESCRIPTOR	pPortDesc,
	IN	PDDP_ADDROBJ		pDdpAddr,
	IN	PBYTE				pPkt,
	IN	USHORT				PktLen,
	IN	PATALK_ADDR			pSrcAddr,
	IN	PATALK_ADDR			pDestAddr,
	IN	ATALK_ERROR			ErrorCode,
	IN	BYTE				DdpType,
	IN	PADSP_ADDROBJ		pAdspAddr,
	IN	BOOLEAN				OptimizedPath,
	IN	PVOID				OptimizeCtx
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	ATALK_ERROR		error;
	PADSP_CONNOBJ	pAdspConn;
	USHORT			remoteConnId;
	ULONG			remoteFirstByteSeq, remoteNextRecvSeq;
	LONG			remoteRecvWindow;
	BYTE			descriptor, controlCode;
	BOOLEAN			DerefConn = FALSE;

	do
	{
		if ((!ATALK_SUCCESS(ErrorCode))	||
			(DdpType != DDPPROTO_ADSP)	||
			(PktLen  <  ADSP_DATA_OFF))
		{
			ASSERT(0);
			break;
		}

		//	Decode the header.
		atalkAdspDecodeHeader(pPkt,
							  &remoteConnId,
							  &remoteFirstByteSeq,
							  &remoteNextRecvSeq,
							  &remoteRecvWindow,
							  &descriptor);

		controlCode = (descriptor & ADSP_CONTROL_MASK);

		DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
				("atalkAdspPacketIn: Recd packet %lx.%x\n", remoteConnId, descriptor));


		//	If this is a open connection request we handle it in here,
		//	else we find the connection it is meant for and pass it on.
		if ((descriptor & ADSP_CONTROL_FLAG) &&
			(controlCode == ADSP_OPENCONN_REQ_CODE))
		{
			//	Handle the open connection.
			if (PktLen < (ADSP_NEXT_ATTEN_SEQNUM_OFF + sizeof(ULONG)))
			{
				DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_ERR,
						("atalkAdspPacketIn: Incorrect len for pkt\n"));

				break;
			}

			atalkAdspHandleOpenReq(pAdspAddr,
								   pPkt,
								   PktLen,
								   pSrcAddr,
								   remoteConnId,
								   remoteFirstByteSeq,
								   remoteNextRecvSeq,
								   remoteRecvWindow,
								   descriptor);

			break;
		}


		if ((descriptor & ADSP_CONTROL_FLAG) &&
			(controlCode >	ADSP_OPENCONN_REQ_CODE) &&
			(controlCode <= ADSP_OPENCONN_DENY_CODE))
		{
			//	Handle the open connection.
			if (PktLen < (ADSP_NEXT_ATTEN_SEQNUM_OFF + sizeof(ULONG)))
			{
				DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_ERR,
						("atalkAdspPacketIn: Incorrect len for pkt\n"));
				break;
			}

			atalkAdspHandleOpenControl(pAdspAddr,
									   pPkt,
									   PktLen,
									   pSrcAddr,
									   remoteConnId,
									   remoteFirstByteSeq,
									   remoteNextRecvSeq,
									   remoteRecvWindow,
									   descriptor);

			break;
		}

		//	This was not an open connection request, find the connection
		//	this is meant for.
		ACQUIRE_SPIN_LOCK_DPC(&pAdspAddr->adspao_Lock);
		atalkAdspConnRefBySrcAddr(pAdspAddr,
								  pSrcAddr,
								  remoteConnId,
								  &pAdspConn,
								  &error);
		RELEASE_SPIN_LOCK_DPC(&pAdspAddr->adspao_Lock);

		if (!ATALK_SUCCESS(error))
		{
			//	Not one of our active/half open connections.
			break;
		}

		DerefConn = TRUE;
		pAdspConn->adspco_LastContactTime	= AtalkGetCurrentTick();

		if (descriptor & ADSP_ATTEN_FLAG)
		{
			//	Handle attention packets
			atalkAdspHandleAttn(pAdspConn,
								pPkt,
								PktLen,
								pSrcAddr,
								remoteFirstByteSeq,
								remoteNextRecvSeq,
								remoteRecvWindow,
								descriptor);
			break;
		}

		//	Check if we got a piggybacked ack. This will call the
		//	send possible handler too if the send window opens up.
		//	It will also change the send sequence number.
		atalkAdspHandlePiggyBackAck(pAdspConn,
									remoteNextRecvSeq,
									remoteRecvWindow);

		if (descriptor & ADSP_CONTROL_FLAG)
		{
			//	Handle the other control packets
			atalkAdspHandleControl(pAdspConn,
								   pPkt,
								   PktLen,
								   pSrcAddr,
								   remoteFirstByteSeq,
								   remoteNextRecvSeq,
								   remoteRecvWindow,
								   descriptor);

			break;
		}

		//	If we got something that didnt fit any of the above, we might
		//	have some data.
		atalkAdspHandleData(pAdspConn,
							pPkt,
							PktLen,
							pSrcAddr,
							remoteFirstByteSeq,
							remoteNextRecvSeq,
							remoteRecvWindow,
							descriptor);
	} while (FALSE);

	if (DerefConn)
	{
		AtalkAdspConnDereference(pAdspConn);
	}
}



LOCAL VOID
atalkAdspHandleOpenControl(
	IN	PADSP_ADDROBJ	pAdspAddr,
	IN	PBYTE			pPkt,
	IN	USHORT			PktLen,
	IN	PATALK_ADDR		pSrcAddr,
	IN	USHORT			RemoteConnId,
	IN	ULONG			RemoteFirstByteSeq,
	IN	ULONG			RemoteNextRecvSeq,
	IN	ULONG			RemoteRecvWindow,
	IN	BYTE			Descriptor
	)
/*++

Routine Description:

	!!!WE ONLY SUPPORT THE LISTENER PARADIGM FOR CONNECTION ESTABLISHMENT!!!
	!!!A OpenConnectionRequest will always open a new connection! Remote !!!
	!!!MUST send a Open Connection Request & Acknowledgement			 !!!

Arguments:


Return Value:


--*/
{
	PADSP_CONNOBJ		pAdspConn;
	BYTE				controlCode;
	USHORT				adspVersionStamp, destConnId;
	KIRQL				OldIrql;
	ULONG				recvAttnSeq;
	PADSP_OPEN_REQ		pOpenReq			= NULL;
	ATALK_ERROR			error				= ATALK_NO_ERROR;
	GENERIC_COMPLETION	completionRoutine	= NULL;
	PVOID				completionCtx		= NULL;
	BOOLEAN				sendAck			= FALSE,
						openTimerCancelled	= FALSE,
						relAddrLock		= FALSE;
	PTDI_IND_SEND_POSSIBLE  sendPossibleHandler	= NULL;
	PVOID			sendPossibleHandlerCtx;

	controlCode = (Descriptor & ADSP_CONTROL_MASK);

	ASSERT(controlCode !=  ADSP_OPENCONN_REQ_CODE);

	//	Get the other information from the adsp header
	GETSHORT2SHORT(&adspVersionStamp,
				   pPkt + ADSP_VERSION_STAMP_OFF);

	GETSHORT2SHORT(&destConnId,
				   pPkt + ADSP_DEST_CONNID_OFF);

	GETDWORD2DWORD(&recvAttnSeq,
				   pPkt + ADSP_NEXT_ATTEN_SEQNUM_OFF);

	DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
			("atalkAdspHandleOpenControl: OpenControl %lx.%lx.%lx.%lx.%lx\n",
			RemoteConnId, RemoteFirstByteSeq, RemoteNextRecvSeq, RemoteRecvWindow, recvAttnSeq));

	//	Drop request if version isnt right.
	if (adspVersionStamp != ADSP_VERSION)
	{
		DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_ERR,
				("atalkAdspPacketIn: Version incorrect\n"));

		return;
	}

	//	Find the connection, since this could be a deny, we cant
	//	use the remote values as they would not be valid. The
	//	connection should be in the connecting list for a reqandack/deny.
	//	For ack the remote values should be valid and the
	//	connection will be in the active list with the flags indicating
	//	that it is only half open.

	ACQUIRE_SPIN_LOCK(&pAdspAddr->adspao_Lock, &OldIrql);
	relAddrLock = TRUE;

	if (controlCode == ADSP_OPENCONN_ACK_CODE)
	{
		//	The connection will be in the active list.
		atalkAdspConnRefBySrcAddr(pAdspAddr,
								  pSrcAddr,
								  RemoteConnId,
								  &pAdspConn,
								  &error);
	}
	else
	{
		atalkAdspConnFindInConnect(pAdspAddr,
								   destConnId,
								   pSrcAddr,
								   &pAdspConn,
								   &error);
	}

	if (ATALK_SUCCESS(error))
	{
		ACQUIRE_SPIN_LOCK_DPC(&pAdspConn->adspco_Lock);

		switch (controlCode)
		{
		case ADSP_OPENCONN_DENY_CODE:

			//	Cancel open timer if this was a CONNECTING connection. If
			//	we had send out a ACK&REQ and then received a DENY just drop
			//	this and let the connection age out.
			if ((pAdspConn->adspco_Flags & ADSPCO_CONNECTING) &&
				((pAdspConn->adspco_Flags & ADSPCO_DISCONNECTING) == 0))
			{
				ASSERT(pAdspConn->adspco_Flags & ADSPCO_OPEN_TIMER);

				//	Turn of the connecting flag as we are completing the request.
				//	If OpenTimer calls disconnect, then we wont end up trying to
				//	complete the request twice.
				pAdspConn->adspco_Flags &=	~ADSPCO_CONNECTING;
				openTimerCancelled = AtalkTimerCancelEvent(&pAdspConn->adspco_OpenTimer,
															NULL);

				//	Connection Denied.
				atalkAdspConnDeQueueConnectList(pAdspAddr, pAdspConn);
				completionRoutine	= pAdspConn->adspco_ConnectCompletion;
				completionCtx		= pAdspConn->adspco_ConnectCtx;
				error				= ATALK_ADSP_SERVER_BUSY;
			}

			break;

		case ADSP_OPENCONN_REQANDACK_CODE:

			//	Connection Request Accepted By Remote. If we are disconnecting
			//	drop this.
			if ((pAdspConn->adspco_Flags & (ADSPCO_SEEN_REMOTE_OPEN |
											ADSPCO_DISCONNECTING)) == 0)
			{
				ULONG	index;

				//	If the connecting connection has not already seen
				//	the remote open request, then get all the relevent
				//	remote info for the connection.
				pAdspConn->adspco_Flags |= (ADSPCO_SEEN_REMOTE_OPEN |
											ADSPCO_HALF_ACTIVE);

				atalkAdspConnDeQueueConnectList(pAdspAddr, pAdspConn);

				pAdspConn->adspco_RemoteConnId	= RemoteConnId;
				pAdspConn->adspco_RemoteAddr	= *pSrcAddr;
				pAdspConn->adspco_SendSeq		= RemoteNextRecvSeq;
				pAdspConn->adspco_FirstRtmtSeq	= RemoteNextRecvSeq;
				pAdspConn->adspco_RecvAttnSeq	= recvAttnSeq;
				pAdspConn->adspco_SendWindowSeq	= RemoteNextRecvSeq +
												  RemoteRecvWindow	-
												  (ULONG)1;

				//	Thread the connection object into addr lookup by session id.
				index	= HASH_ID_SRCADDR(RemoteConnId, pSrcAddr);

				index  %= ADSP_CONN_HASH_SIZE;

				pAdspConn->adspco_pNextActive = pAdspAddr->adspao_pActiveHash[index];
				pAdspAddr->adspao_pActiveHash[index] = pAdspConn;
			}
			else
			{
				//	We've already seen the remote request.
				break;
			}

		case ADSP_OPENCONN_ACK_CODE:

			//	Ensure we are not closing, so we can reference properly. Drop
			//	if we are disconnecting.
			if ((pAdspConn->adspco_Flags & ADSPCO_HALF_ACTIVE) &&
				((pAdspConn->adspco_Flags & (	ADSPCO_DISCONNECTING	|
												ADSPCO_STOPPING		|
												ADSPCO_CLOSING)) == 0))
			{
				//	Cancel open timer
				ASSERT(pAdspConn->adspco_Flags & ADSPCO_OPEN_TIMER);
				openTimerCancelled = AtalkTimerCancelEvent(&pAdspConn->adspco_OpenTimer,
															NULL);

				DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
						("atalkAdspHandleOpenControl: OpenTimer %d\n", openTimerCancelled));

				pAdspConn->adspco_Flags &= ~(ADSPCO_HALF_ACTIVE |
											 ADSPCO_CONNECTING	|
											 ADSPCO_LISTENING);

				pAdspConn->adspco_Flags |=	ADSPCO_ACTIVE;

				//	Prepare to say sends ok
				sendPossibleHandler	=
						pAdspConn->adspco_pAssocAddr->adspao_SendPossibleHandler;
				sendPossibleHandlerCtx =
						pAdspConn->adspco_pAssocAddr->adspao_SendPossibleHandlerCtx;

				//	Get the completion routines
				if (pAdspConn->adspco_Flags &
						(ADSPCO_ACCEPT_IRP | ADSPCO_LISTEN_IRP))
				{
					atalkAdspAddrDeQueueOpenReq(pAdspAddr,
												pAdspConn->adspco_RemoteConnId,
												&pAdspConn->adspco_RemoteAddr,
												&pOpenReq);

					pAdspConn->adspco_Flags	&= ~(ADSPCO_ACCEPT_IRP |
												 ADSPCO_LISTEN_IRP);
					completionRoutine		= pAdspConn->adspco_ListenCompletion;
					completionCtx			= pAdspConn->adspco_ListenCtx;
				}
				else
				{
					ASSERT(pAdspConn->adspco_pAssocAddr->adspao_Flags & ADSPAO_CONNECT);

					completionRoutine		= pAdspConn->adspco_ConnectCompletion;
					completionCtx			= pAdspConn->adspco_ConnectCtx;
				}

				//	Start the probe and the retransmit timers
				//	Set the flags
				pAdspConn->adspco_Flags |= (ADSPCO_CONN_TIMER | ADSPCO_RETRANSMIT_TIMER);
				AtalkAdspConnReferenceByPtrNonInterlock(pAdspConn, 2, &error);
				if (!ATALK_SUCCESS(error))
				{
					KeBugCheck(0);
				}
				AtalkTimerInitialize(&pAdspConn->adspco_ConnTimer,
									 atalkAdspConnMaintenanceTimer,
									 ADSP_PROBE_INTERVAL);
				AtalkTimerScheduleEvent(&pAdspConn->adspco_ConnTimer);

				AtalkTimerInitialize(&pAdspConn->adspco_RetransmitTimer,
									 atalkAdspRetransmitTimer,
									 ADSP_RETRANSMIT_INTERVAL);
				AtalkTimerScheduleEvent(&pAdspConn->adspco_RetransmitTimer);
			}
			break;

		default:
			KeBugCheck(0);
			break;
		}

		RELEASE_SPIN_LOCK_DPC(&pAdspConn->adspco_Lock);
		RELEASE_SPIN_LOCK(&pAdspAddr->adspao_Lock, OldIrql);
		relAddrLock = FALSE;

		//	If a open request was dequeue free it now
		if (pOpenReq != NULL)
		{
			AtalkFreeMemory(pOpenReq);
		}

		//	Set last contact time. ConnMaintenanceTimer is in order of seconds.
		pAdspConn->adspco_LastContactTime = AtalkGetCurrentTick();

		if (controlCode == ADSP_OPENCONN_REQANDACK_CODE)
		{
			//	If we received a req&ack
			atalkAdspSendOpenControl(pAdspConn);
		}

		//	Call connect routine
		if (*completionRoutine != NULL)
		{
			(*completionRoutine)(error, completionCtx);
		}

		//	Are sends ok?
		if (*sendPossibleHandler != NULL)
		{
			(*sendPossibleHandler)(sendPossibleHandlerCtx,
								   pAdspConn->adspco_ConnCtx,
								   atalkAdspMaxSendSize(pAdspConn));
		}

		if (openTimerCancelled)
		{
			AtalkAdspConnDereference(pAdspConn);
		}

		AtalkAdspConnDereference(pAdspConn);
	}
#if DBG
	else
	{
		ASSERT(0);
	}
#endif

	if (relAddrLock)
	{
		RELEASE_SPIN_LOCK(&pAdspAddr->adspao_Lock, OldIrql);
	}
}




LOCAL VOID
atalkAdspHandleAttn(
	IN	PADSP_CONNOBJ	pAdspConn,
	IN	PBYTE			pPkt,
	IN	USHORT			PktLen,
	IN	PATALK_ADDR		pSrcAddr,
	IN	ULONG			RemoteAttnSendSeq,
	IN	ULONG			RemoteAttnRecvSeq,
	IN	ULONG			RemoteRecvWindow,
	IN	BYTE			Descriptor
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	BYTE						controlCode;
	KIRQL						OldIrql;
	PIRP						exRecvIrp;
	PTDI_IND_RECEIVE_EXPEDITED	exRecvHandler;
	PVOID						exRecvHandlerCtx;
	ULONG						exIndicateFlags;
	NTSTATUS					ntStatus;
	PBYTE						exReadBuf;
	ULONG						bytesTaken;
	USHORT						exWriteBufLen;
	PBYTE						exWriteChBuf		= NULL;
	BOOLEAN						freeBuf				= FALSE,
								timerCancelled		= FALSE;
	PAMDL						exWriteBuf			= NULL;
	GENERIC_WRITE_COMPLETION	exWriteCompletion	= NULL;
	PVOID						exWriteCtx			= NULL;

	UNREFERENCED_PARAMETER(RemoteRecvWindow);

	controlCode = (Descriptor & ADSP_CONTROL_MASK);

	//	Skip the adsp header
	pPkt	+= ADSP_DATA_OFF;
	PktLen	-= ADSP_DATA_OFF;

	DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
			("atalkAdspHandleAttn: PktLen %d\n", PktLen));

	//	Drop if we are not active! Pkt must atleast contain
	//	attention code if it is not a control packet.
	if (((pAdspConn->adspco_Flags & ADSPCO_ACTIVE) == 0) ||
		(controlCode != 0)	||
		(((Descriptor & ADSP_CONTROL_FLAG) == 0) &&
		 (PktLen < ADSP_MIN_ATTEN_PKT_SIZE)))
	{
		return;
	}

	//	Allocate if we have some data, ie. we are not just an ack.
	if ((Descriptor & ADSP_CONTROL_FLAG) == 0)
	{
		if ((exReadBuf = AtalkAllocMemory(PktLen)) == NULL)
		{
			return;
		}

		freeBuf	= TRUE;

		//	Copy the attention code from wire-to-host format
		GETSHORT2SHORT((PUSHORT)exReadBuf, pPkt);

		DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
				("atalkAdspHandleAttn: Recd Attn Code %lx\n", *(PUSHORT)exReadBuf));

		//	Copy the rest of the data
		RtlCopyMemory(exReadBuf + sizeof(USHORT),
					  pPkt + sizeof(USHORT),
					  PktLen - sizeof(USHORT));
	}

	ACQUIRE_SPIN_LOCK(&pAdspConn->adspco_Lock, &OldIrql);

	do
	{
		if (RemoteAttnRecvSeq == (pAdspConn->adspco_SendAttnSeq + 1))
		{
			//	This implies an ack of our last attention
			pAdspConn->adspco_SendAttnSeq += 1;

			//	Check if we are waiting for an attention ack.
			if (pAdspConn->adspco_Flags & ADSPCO_EXSEND_IN_PROGRESS)
			{
				exWriteCompletion	= pAdspConn->adspco_ExWriteCompletion;
				exWriteCtx			= pAdspConn->adspco_ExWriteCtx;
				exWriteBuf			= pAdspConn->adspco_ExWriteBuf;
				exWriteBufLen		= pAdspConn->adspco_ExWriteBufLen;
				exWriteChBuf		= pAdspConn->adspco_ExWriteChBuf;

				timerCancelled = AtalkTimerCancelEvent(&pAdspConn->adspco_ExRetryTimer,
														NULL);

				pAdspConn->adspco_Flags &= ~ADSPCO_EXSEND_IN_PROGRESS;
			}
		}

		if (RemoteAttnSendSeq != pAdspConn->adspco_RecvAttnSeq)
		{
			break;
		}

		if (Descriptor & ADSP_CONTROL_FLAG)
		{
			//	Ack only, no data to handle
			break;
		}

		//	Get the expedited receive handler.
		exRecvHandler		= pAdspConn->adspco_pAssocAddr->adspao_ExpRecvHandler;
		exRecvHandlerCtx	= pAdspConn->adspco_pAssocAddr->adspao_ExpRecvHandlerCtx;

		if (((pAdspConn->adspco_Flags & ADSPCO_ATTN_DATA_RECD) == 0) &&
			(*exRecvHandler != NULL))
		{
			exIndicateFlags				 = TDI_RECEIVE_EXPEDITED |
										   TDI_RECEIVE_PARTIAL;

			pAdspConn->adspco_Flags		|= ADSPCO_ATTN_DATA_RECD;
			if (Descriptor & ADSP_EOM_FLAG)
			{
				exIndicateFlags			&= ~TDI_RECEIVE_PARTIAL;
				exIndicateFlags			|= TDI_RECEIVE_ENTIRE_MESSAGE;
				pAdspConn->adspco_Flags	|= ADSPCO_ATTN_DATA_EOM;
			}

			pAdspConn->adspco_ExRecdData = exReadBuf;
			pAdspConn->adspco_ExRecdLen	 = PktLen;
			freeBuf						 = FALSE;

			DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
					("atalkAdspHandleAttn: Indicating exp data %ld\n", PktLen));

			RELEASE_SPIN_LOCK(&pAdspConn->adspco_Lock, OldIrql);
			ntStatus = (*exRecvHandler)(exRecvHandlerCtx,
										pAdspConn->adspco_ConnCtx,
										exIndicateFlags,
										PktLen,
										PktLen,
										&bytesTaken,
										pPkt,
										&exRecvIrp);

			ASSERT((bytesTaken == 0) || (bytesTaken == PktLen));
			if (ntStatus == STATUS_MORE_PROCESSING_REQUIRED)
			{
				if (exRecvIrp != NULL)
				{
					//  Post the receive as if it came from the io system
					ntStatus = AtalkDispatchInternalDeviceControl(
									(PDEVICE_OBJECT)AtalkDeviceObject[ATALK_DEV_ADSP],
									exRecvIrp);

					ASSERT(ntStatus == STATUS_PENDING);
				}
				else
				{
					ASSERTMSG("atalkAdspReadComplete: No receive irp!\n", 0);
					KeBugCheck(0);
				}
				ACQUIRE_SPIN_LOCK(&pAdspConn->adspco_Lock, &OldIrql);
			}
			else if (ntStatus == STATUS_SUCCESS)
			{
				ACQUIRE_SPIN_LOCK(&pAdspConn->adspco_Lock, &OldIrql);
				if (bytesTaken != 0)
				{
					//	Assume all of the data was read.
					ASSERT(bytesTaken == PktLen);
					DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
							("atalkAdspHandleAttn: All bytes read %lx\n", bytesTaken));

					//	Attention has been accepted, we need to ack it.
					//	Since spinlock was released, recheck flag.
					if (pAdspConn->adspco_Flags & ADSPCO_ATTN_DATA_RECD)
					{
						pAdspConn->adspco_Flags		&= ~(ADSPCO_ATTN_DATA_RECD |
														 ADSPCO_ATTN_DATA_EOM);
						freeBuf = TRUE;
					}

					//	Send ack for the attention
					atalkAdspSendControl(pAdspConn,
										 ADSP_CONTROL_FLAG + ADSP_ATTEN_FLAG);
				}
			}
			else if (ntStatus == STATUS_DATA_NOT_ACCEPTED)
			{
				//	Client may have posted a receive in the indication. Or
				//	it will post a receive later on. Do nothing here.
				DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
						("atalkAdspHandleAttn: Indication status %lx\n", ntStatus));

				ACQUIRE_SPIN_LOCK(&pAdspConn->adspco_Lock, &OldIrql);
			}
		}

		if (pAdspConn->adspco_Flags & ADSPCO_ATTN_DATA_RECD)
		{
			atalkAdspRecvAttn(pAdspConn);
		}

	} while (FALSE);
	RELEASE_SPIN_LOCK(&pAdspConn->adspco_Lock, OldIrql);

	if (*exWriteCompletion != NULL)
	{
		if (exWriteChBuf != NULL)
		{
			AtalkFreeMemory(exWriteChBuf);
		}

		(*exWriteCompletion)(ATALK_NO_ERROR,
							 exWriteBuf,
							 exWriteBufLen,
							 exWriteCtx);
	}

	if (timerCancelled)
	{
		AtalkAdspConnDereference(pAdspConn);
	}

	if (freeBuf)
	{
		ASSERT(exReadBuf != NULL);
		AtalkFreeMemory(exReadBuf);
	}
}




LOCAL VOID
atalkAdspHandlePiggyBackAck(
	IN	PADSP_CONNOBJ	pAdspConn,
	IN	ULONG			RemoteNextRecvSeq,
	IN	ULONG			RemoteRecvWindow
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	ULONG					newSendWindowSeq, sendSize, windowSize;
	PTDI_IND_SEND_POSSIBLE  sendPossibleHandler;
	KIRQL					OldIrql;
	PVOID					sendPossibleHandlerCtx;

	DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
			("atalkAdspHandlePiggyBackAck: Recd ack %lx - %lx.%lx\n",
			pAdspConn, RemoteNextRecvSeq, RemoteRecvWindow));

	ACQUIRE_SPIN_LOCK(&pAdspConn->adspco_Lock, &OldIrql);
	if (UNSIGNED_BETWEEN_WITH_WRAP(pAdspConn->adspco_FirstRtmtSeq,
								   pAdspConn->adspco_SendSeq,
								   RemoteNextRecvSeq))
	{
		ULONG	size;

		//	Discard acked data from the send queue
		size = (ULONG)(RemoteNextRecvSeq - pAdspConn->adspco_FirstRtmtSeq);
		pAdspConn->adspco_FirstRtmtSeq = RemoteNextRecvSeq;

		atalkAdspDiscardFromBufferQueue(&pAdspConn->adspco_SendQueue,
										size,
										&pAdspConn->adspco_NextSendQueue,
										ATALK_NO_ERROR,
										pAdspConn);
	}


	//	We almost always can use the header values to update the
	//	sendwindowseqnum
	newSendWindowSeq =	RemoteNextRecvSeq			+
						(ULONG)RemoteRecvWindow	-
						(ULONG)1;

	if (UNSIGNED_GREATER_WITH_WRAP(newSendWindowSeq,
								   pAdspConn->adspco_SendWindowSeq))
	{
		pAdspConn->adspco_SendWindowSeq = newSendWindowSeq;
	}

	if (!IsListEmpty(&pAdspConn->adspco_PendedSends))
	{
		AtalkAdspProcessQueuedSend(pAdspConn);
	}

	sendPossibleHandler		=
				pAdspConn->adspco_pAssocAddr->adspao_SendPossibleHandler;
	sendPossibleHandlerCtx	=
				pAdspConn->adspco_pAssocAddr->adspao_SendPossibleHandlerCtx;

	//	Call sendok handler for the size of the connection if non-zero
	windowSize	= (LONG)(pAdspConn->adspco_SendWindowSeq	-
						 pAdspConn->adspco_SendSeq			+
						 (LONG)1);

	sendSize =	MIN(atalkAdspMaxSendSize(pAdspConn), windowSize);

	if ((sendSize != 0) &&
		IsListEmpty(&pAdspConn->adspco_PendedSends) &&
		(pAdspConn->adspco_Flags & ADSPCO_SEND_WINDOW_CLOSED) &&
		(*sendPossibleHandler != NULL))
	{
		(*sendPossibleHandler)(sendPossibleHandlerCtx,
							   pAdspConn->adspco_ConnCtx,
							   sendSize);

		pAdspConn->adspco_Flags	&= ~ADSPCO_SEND_WINDOW_CLOSED;
	}

	RELEASE_SPIN_LOCK(&pAdspConn->adspco_Lock, OldIrql);
}




LOCAL VOID
atalkAdspHandleControl(
	IN	PADSP_CONNOBJ	pAdspConn,
	IN	PBYTE			pPkt,
	IN	USHORT			PktLen,
	IN	PATALK_ADDR		pSrcAddr,
	IN	ULONG			RemoteFirstByteSeq,
	IN	ULONG			RemoteNextRecvSeq,
	IN	ULONG			RemoteRecvWindow,
	IN	BYTE			Descriptor
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	BYTE		controlCode;
	KIRQL		OldIrql;
	ATALK_ERROR	Error;

	//	The ack request flag can be set in any control packet. Send
	//	an immediately. We will also send any data if possible.
	if (Descriptor & ADSP_ACK_REQ_FLAG)
	{
		DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
				("atalkAdspHandleControl: Recd ackreq for %lx\n", pAdspConn));

		ACQUIRE_SPIN_LOCK(&pAdspConn->adspco_Lock, &OldIrql);
		atalkAdspSendData(pAdspConn);
		RELEASE_SPIN_LOCK(&pAdspConn->adspco_Lock, OldIrql);
	}

	controlCode = (Descriptor & ADSP_CONTROL_MASK);
	switch (controlCode)
	{
	  case ADSP_PROBE_OR_ACK_CODE:
		DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
				("atalkAdspHandleControl: Recd probe for %lx\n", pAdspConn));

		//	A PROBE has its ACKRequest flag set, so we would have handled
		//	that above. Also, we've already set the lastContactTime in the
		//	packet in routine. So if this is an ack we've handled it.
		//	Check to see if some data was acked and if we have data to send.
		ACQUIRE_SPIN_LOCK(&pAdspConn->adspco_Lock, &OldIrql);
		if (!(Descriptor & ADSP_ACK_REQ_FLAG) &&
			 (atalkAdspBufferQueueSize(&pAdspConn->adspco_NextSendQueue) != 0) &&
			 (pAdspConn->adspco_SendSeq != (pAdspConn->adspco_SendWindowSeq + 1)))
		{
			atalkAdspSendData(pAdspConn);
		}
		RELEASE_SPIN_LOCK(&pAdspConn->adspco_Lock, OldIrql);
		break;

	  case ADSP_CLOSE_CONN_CODE:
		DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
				("atalkAdspHandleControl: Recd CLOSE for %lx\n", pAdspConn));

		AtalkAdspConnReferenceByPtr(pAdspConn, &Error);
		if (ATALK_SUCCESS(Error))
		{
			AtalkTimerScheduleEvent(&pAdspConn->adspco_DisconnectTimer);
		}
		else
		{
			AtalkAdspDisconnect(pAdspConn,
								ATALK_REMOTE_DISCONNECT,
								NULL,
								NULL);
		}
		break;

	  case ADSP_FORWARD_RESET_CODE:
		DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_ERR,
				("atalkAdspHandleControl: Recd FWDRESET for %lx\n", pAdspConn));

		pAdspConn->adspco_Flags	|= ADSPCO_FORWARD_RESET_RECD;
		AtalkAdspDisconnect(pAdspConn,
							ATALK_LOCAL_DISCONNECT,
							NULL,
							NULL);
		break;

	  case ADSP_FORWARD_RESETACK_CODE:
		//	We never send forward resets (interface not exposed), so
		//	we should never be getting these. Drop if we do.
		DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_ERR,
				("atalkAdspHandleControl: Recd ForwardReset ACK!!\n"));
		break;

	  case ADSP_RETRANSMIT_CODE:
		//	Any acks should have been processed by now. Back up and
		//	do a retransmit by rewinding sequence number.
		ACQUIRE_SPIN_LOCK(&pAdspConn->adspco_Lock, &OldIrql);
		if (UNSIGNED_BETWEEN_WITH_WRAP(pAdspConn->adspco_FirstRtmtSeq,
									   pAdspConn->adspco_SendSeq,
									   RemoteNextRecvSeq))
		{
			pAdspConn->adspco_SendSeq		= pAdspConn->adspco_FirstRtmtSeq;
			pAdspConn->adspco_NextSendQueue = pAdspConn->adspco_SendQueue;
			atalkAdspSendData(pAdspConn);
		}
		RELEASE_SPIN_LOCK(&pAdspConn->adspco_Lock, OldIrql);
		break;

	  default:
		break;
	}
}




LOCAL VOID
atalkAdspHandleData(
	IN	PADSP_CONNOBJ	pAdspConn,
	IN	PBYTE			pPkt,
	IN	USHORT			PktLen,
	IN	PATALK_ADDR		pSrcAddr,
	IN	ULONG			RemoteFirstByteSeq,
	IN	ULONG			RemoteNextRecvSeq,
	IN	ULONG			RemoteRecvWindow,
	IN	BYTE			Descriptor
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	BOOLEAN			eom, tdiEom;
	PBUFFER_CHUNK	pBufferChunk;
	KIRQL			OldIrql;
	ULONG			dataSize;
	BOOLEAN			freeChunk = FALSE,
					sendAck = (Descriptor & ADSP_ACK_REQ_FLAG);

	eom		= (Descriptor & ADSP_EOM_FLAG) ? TRUE : FALSE;
	dataSize	= PktLen - ADSP_DATA_OFF;

	ACQUIRE_SPIN_LOCK(&pAdspConn->adspco_Lock, &OldIrql);

	do
	{
		//	Drop if we are not active! And if there is no data
		if ((pAdspConn->adspco_Flags & ADSPCO_ACTIVE) == 0)
		{
			sendAck = FALSE;
			break;
		}

		tdiEom = (eom && (pAdspConn->adspco_pAssocAddr->adspao_Flags & ADSPAO_MESSAGE));

		//	We can only access addr object when active.
		if ((dataSize == 0) && !tdiEom)
		{
			//	Increment seqnumbers and we have consumed this packet.
			pAdspConn->adspco_RecvSeq		+= (ULONG)(BYTECOUNT(eom));
			pAdspConn->adspco_RecvWindow	-= (LONG)(BYTECOUNT(eom));
			break;
		}

		//	Preallocate the buffer chunk
		DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
				("Recd Data %d Eom %d\n", dataSize, eom));

		pBufferChunk = atalkAdspAllocCopyChunk(pPkt + ADSP_DATA_OFF,
											   (USHORT)dataSize,
											   tdiEom,
											   TRUE);
		if (pBufferChunk == NULL)
			break;

		freeChunk = TRUE;

		if (RemoteFirstByteSeq != pAdspConn->adspco_RecvSeq)
		{
			DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_WARN,
					("atalkAdspHandleData: Dropping out of sequence adsp packet\n"));

			if ((pAdspConn->adspco_OutOfSeqCount += 1) >= ADSP_OUT_OF_SEQ_PACKETS_MAX)
			{
				atalkAdspSendControl(pAdspConn,
									 ADSP_CONTROL_FLAG + ADSP_RETRANSMIT_CODE);

				pAdspConn->adspco_OutOfSeqCount = 0;
			}

			break;
		}

		//	Handle a > receive window packet
		if ((dataSize + BYTECOUNT(eom)) > (ULONG)pAdspConn->adspco_RecvWindow)
		{
			DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
					("atalkAdspHandleData: Recd > window data %d.%ld\n",
					dataSize, pAdspConn->adspco_RecvWindow));

			break;
		}

		//	Accept the data
		DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
				("atalkAdspHandleData: accepting data adsp packet %d\n", dataSize));

		atalkAdspAddToBufferQueue(&pAdspConn->adspco_RecvQueue,
								  pBufferChunk,
								  NULL);

		//	Put it in the queue successfully
		freeChunk = FALSE;

		//	Update the receive sequence numbers
		pAdspConn->adspco_RecvSeq		+= (ULONG)(dataSize + BYTECOUNT(eom));
		pAdspConn->adspco_RecvWindow	-= (LONG)(dataSize + BYTECOUNT(eom));

		//	The receive windows should never go below zero! If it does, we could have
		//	memory overruns.
		ASSERT(pAdspConn->adspco_RecvWindow >= 0);
		if (pAdspConn->adspco_RecvWindow < 0)
		{
			KeBugCheck(0);
		}

		//	Do indications/handle pending receives etc.
		atalkAdspRecvData(pAdspConn);

	} while (FALSE);

	//	ACK if requested, and send any data at the same time too.
	if (sendAck)
	{
		atalkAdspSendData(pAdspConn);
	}

	RELEASE_SPIN_LOCK(&pAdspConn->adspco_Lock, OldIrql);

	if (freeChunk)
	{
		ASSERT(pBufferChunk != NULL);
		AtalkFreeMemory(pBufferChunk);
	}
}



//
//	ADSP SUPPORT ROUTINES
//


#define		SLS_OPEN_CONN_REF			0x0008
#define		SLS_ACCEPT_IRP				0x0010
#define		SLS_CONN_TIMER_REF			0x0040
#define		SLS_LISTEN_DEQUEUED			0x0080

LOCAL VOID
atalkAdspHandleOpenReq(
	IN	PADSP_ADDROBJ	pAdspAddr,
	IN	PBYTE			pPkt,
	IN	USHORT			PktLen,
	IN	PATALK_ADDR		pSrcAddr,
	IN	USHORT			RemoteConnId,
	IN	ULONG			RemoteFirstByteSeq,
	IN	ULONG			RemoteNextRecvSeq,
	IN	ULONG			RemoteRecvWindow,
	IN	BYTE			Descriptor
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PADSP_CONNOBJ			pAdspConn;

	PTDI_IND_SEND_POSSIBLE  sendPossibleHandler;
	PVOID					sendPossibleHandlerCtx;

	USHORT					adspVersionStamp, destConnId, localConnId;
	ULONG					recvAttnSeq;
	ULONG					index;

	BOOLEAN					DerefConn	= FALSE;
	PADSP_OPEN_REQ			pOpenReq	= NULL;
	USHORT					openResr	= 0;
	KIRQL					OldIrql;
	ATALK_ERROR				error = ATALK_NO_ERROR;

	//	Are there any listening connections? Or do we have a
	//	set handler?
	ACQUIRE_SPIN_LOCK(&pAdspAddr->adspao_Lock, &OldIrql);
	do
	{
		//	Get the other information from the adsp header
		GETSHORT2SHORT(&adspVersionStamp, pPkt + ADSP_VERSION_STAMP_OFF);

		GETSHORT2SHORT(&destConnId, pPkt + ADSP_DEST_CONNID_OFF);

		GETDWORD2DWORD(&recvAttnSeq, pPkt + ADSP_NEXT_ATTEN_SEQNUM_OFF);

		//	Drop request if version isnt right.
		if (adspVersionStamp != ADSP_VERSION)
		{
			DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_ERR,
					("atalkAdspPacketIn: Version incorrect\n"));

			error = ATALK_INVALID_REQUEST;
			break;
		}

		//	Is this a duplicate request - same remote address/id?
		if (atalkAdspIsDuplicateOpenReq(pAdspAddr,
										RemoteConnId,
										pSrcAddr))
		{
			DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_ERR,
					("atalkAdspPacketIn: Duplicate open req\n"));

			error = ATALK_INVALID_REQUEST;
			break;
		}

		//	Allocate the open request structure. Do it here to avoid
		//	sending in a whole lot of parameters.
		if ((pOpenReq = (PADSP_OPEN_REQ)AtalkAllocMemory(sizeof(ADSP_OPEN_REQ))) == NULL)
		{
			DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_ERR,
					("atalkAdspPacketIn: Could not alloc\n"));

			error = ATALK_RESR_MEM;
			RES_LOG_ERROR();
			break;
		}

		//	Initialize the structure. This will be queued into the address
		//	object by listenindicate if successful.
		pOpenReq->or_Next			= NULL;
		pOpenReq->or_RemoteAddr	= *pSrcAddr;
		pOpenReq->or_RemoteConnId	= RemoteConnId;
		pOpenReq->or_FirstByteSeq	= RemoteFirstByteSeq;
		pOpenReq->or_NextRecvSeq	= RemoteNextRecvSeq;
		pOpenReq->or_RecvWindow		= RemoteRecvWindow;

		localConnId	= atalkAdspGetNextConnId(pAdspAddr, &error);
		ASSERT(ATALK_SUCCESS(error));

		if (ATALK_SUCCESS(error))
		{
			atalkAdspListenIndicateNonInterlock(pAdspAddr,
												pOpenReq,
												&pAdspConn,
												&error);
		}

	} while (FALSE);

	//	If either the indication or listen didnt happen well,
	//	break out of the main while loop.
	if (!ATALK_SUCCESS(error))
	{
		RELEASE_SPIN_LOCK(&pAdspAddr->adspao_Lock, OldIrql);

		if (pOpenReq != NULL)
		{
			AtalkFreeMemory(pOpenReq);
		}
		return;
	}

	ASSERT(ATALK_SUCCESS(error));

	//	Common for both listen and indicate. The connection object
	//	should be referenced.
	DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
			("atalkAdspOpenReq: ConnId %lx Rem %lx.%lx.%lx\n",
			pOpenReq->or_RemoteConnId,
			pOpenReq->or_RemoteAddr.ata_Network,
			pOpenReq->or_RemoteAddr.ata_Node,
			pOpenReq->or_RemoteAddr.ata_Socket));

	//	Thread the connection object into addr lookup by session id.
	index	= HASH_ID_SRCADDR(pOpenReq->or_RemoteConnId,
							  &pOpenReq->or_RemoteAddr);

	index  %= ADSP_CONN_HASH_SIZE;

	ACQUIRE_SPIN_LOCK_DPC(&pAdspConn->adspco_Lock);

	pAdspConn->adspco_Flags &= ~ADSPCO_LISTENING;
	pAdspConn->adspco_Flags |= (ADSPCO_HALF_ACTIVE		|
								ADSPCO_SEEN_REMOTE_OPEN	|
								ADSPCO_OPEN_TIMER);

	pAdspConn->adspco_ConnectAttempts	= ADSP_MAX_OPEN_ATTEMPTS;

	//	Store the information in the connection structure given by
	//	the connection object thats passed back in the indication
	//	or is part of the listen structure.
	pAdspConn->adspco_RecvWindow=
	pAdspConn->adspco_SendQueueMax	=
	pAdspConn->adspco_RecvQueueMax	= ADSP_DEF_SEND_RX_WINDOW_SIZE;

	//	Store the remote information
	pAdspConn->adspco_RemoteAddr	= pOpenReq->or_RemoteAddr;
	pAdspConn->adspco_RemoteConnId	= pOpenReq->or_RemoteConnId;
	pAdspConn->adspco_LocalConnId	= localConnId;

	pAdspConn->adspco_SendSeq		= pOpenReq->or_FirstByteSeq;
	pAdspConn->adspco_FirstRtmtSeq	= pOpenReq->or_NextRecvSeq;
	pAdspConn->adspco_SendWindowSeq	= pOpenReq->or_NextRecvSeq	+
										pOpenReq->or_RecvWindow	- 1;

	pAdspConn->adspco_RecvAttnSeq	= recvAttnSeq;

	pAdspConn->adspco_pNextActive	= pAdspAddr->adspao_pActiveHash[index];
	pAdspAddr->adspao_pActiveHash[index] = pAdspConn;

	//	Remember the ddp socket.
	pAdspConn->adspco_pDdpAddr		= pAdspAddr->adspao_pDdpAddr;

	//	Initialize pended sends list
	InitializeListHead(&pAdspConn->adspco_PendedSends);

	//	Call the send data event handler on the associated address with
	//	0 to turn off selects on writes. We do this before we complete the
	//	accept.
	sendPossibleHandler	= pAdspAddr->adspao_SendPossibleHandler;
	sendPossibleHandlerCtx	= pAdspAddr->adspao_SendPossibleHandlerCtx;

	//	Start open timer. Reference is the reference
	//	at the beginning.
	AtalkTimerInitialize(&pAdspConn->adspco_OpenTimer,
						 atalkAdspOpenTimer,
						 ADSP_OPEN_INTERVAL);
	AtalkTimerScheduleEvent(&pAdspConn->adspco_OpenTimer);

	RELEASE_SPIN_LOCK_DPC(&pAdspConn->adspco_Lock);
	RELEASE_SPIN_LOCK(&pAdspAddr->adspao_Lock, OldIrql);

	//	Connection is all set up, send ack to remote and wait
	//	for its ack before switching state to active.
	if (*sendPossibleHandler != NULL)
	{
		(*sendPossibleHandler)(sendPossibleHandlerCtx,
							   pAdspConn->adspco_ConnCtx,
							   0);
	}

	//	Send the open control.
	atalkAdspSendOpenControl(pAdspConn);

	//	Remove the reference on the connection added during
	//	indicate/listen if we did not start the open timer.
	if (DerefConn)
	{
		AtalkAdspConnDereference(pAdspConn);
	}
}



LOCAL VOID
atalkAdspListenIndicateNonInterlock(
	IN	PADSP_ADDROBJ	pAdspAddr,
	IN	PADSP_OPEN_REQ	pOpenReq,
	IN	PADSP_CONNOBJ *	ppAdspConn,
	IN	PATALK_ERROR	pError
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	ATALK_ERROR				error;
	TA_APPLETALK_ADDRESS	tdiAddr;
	PTDI_IND_CONNECT		indicationRoutine;
	PVOID					indicationCtx;
	NTSTATUS				status;
	CONNECTION_CONTEXT	ConnCtx;
	PIRP					acceptIrp;
	PADSP_CONNOBJ			pAdspConn;
	ATALK_ADDR				remoteAddr;
	USHORT					remoteConnId;
	BOOLEAN					indicate	= TRUE;

	//	If no listens posted, no handler, drop the request.
	error	= ATALK_RESR_MEM;

	//	Queue in the open request to the address. Cant release the
	//	addrlock without doing this.
	pOpenReq->or_Next = pAdspAddr->adspao_OpenReq;
	pAdspAddr->adspao_OpenReq = pOpenReq;

	pAdspConn		= pAdspAddr->adspao_pListenConn;
	remoteAddr		= pOpenReq->or_RemoteAddr;
	remoteConnId	= pOpenReq->or_RemoteConnId;
	if (pAdspConn != NULL)
	{
		ASSERT(VALID_ADSPCO(pAdspConn));

		indicate	= FALSE;

		ACQUIRE_SPIN_LOCK_DPC(&pAdspConn->adspco_Lock);

		//	Ok, now its possible the connection object is already
		//	disconnecting/closing. Check for that, if so,
		//	drop this request
		if (pAdspConn->adspco_Flags & (	ADSPCO_CLOSING	|
										ADSPCO_STOPPING |
										ADSPCO_DISCONNECTING))
		{
			//	dequeue open request, still first in list.
			pAdspAddr->adspao_OpenReq = pAdspAddr->adspao_OpenReq->or_Next;

			*pError = ATALK_INVALID_CONNECTION;
			RELEASE_SPIN_LOCK_DPC(&pAdspConn->adspco_Lock);
			return;
		}

		//	There a connection with a pending listen. use it.
		pAdspAddr->adspao_pListenConn = pAdspConn->adspco_pNextListen;

		//	Reference the connection object with a listen posted on it.
		AtalkAdspConnReferenceByPtrNonInterlock(pAdspConn, 1, &error);
		if (!ATALK_SUCCESS(error))
		{
			KeBugCheck(0);
		}

		//	The listen request will also be completed when the
		//	ack is received.
		pAdspConn->adspco_Flags	|= ADSPCO_LISTEN_IRP;

		RELEASE_SPIN_LOCK_DPC(&pAdspConn->adspco_Lock);
	}
	else if ((indicationRoutine = pAdspAddr->adspao_ConnHandler) != NULL)
	{
		indicationCtx	= pAdspAddr->adspao_ConnHandlerCtx;

		//	Convert remote atalk address to tdi address
		ATALKADDR_TO_TDI(&tdiAddr, &pOpenReq->or_RemoteAddr);

#if DBG
        (&pAdspAddr->adspao_Lock)->FileLineLock |= 0x80000000;
#endif
		RELEASE_SPIN_LOCK_DPC(&pAdspAddr->adspao_Lock);
		status = (*indicationRoutine)(indicationCtx,
									  sizeof(tdiAddr),
									  (PVOID)&tdiAddr,
									  0,					  // User data length
									  NULL,				   // User data
									  0,					  // Option length
									  NULL,				   // Options
									  &ConnCtx,
									  &acceptIrp);

		ACQUIRE_SPIN_LOCK_DPC(&pAdspAddr->adspao_Lock);
#if DBG
        (&pAdspAddr->adspao_Lock)->FileLineLock &= ~0x80000000;
#endif

		ASSERT(acceptIrp != NULL);
		DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
				("atalkAdspSlsHandler: indicate status %lx\n", status));

		error = ATALK_RESR_MEM;
		if (status == STATUS_MORE_PROCESSING_REQUIRED)
		{
			//  Find the connection and accept the connection using that
			//	connection object.

			AtalkAdspConnReferenceByCtxNonInterlock(pAdspAddr,
													ConnCtx,
													&pAdspConn,
													&error);

			if (!ATALK_SUCCESS(error))
			{
				//	The connection object is closing, or is not found
				//	in our list. The accept irp must have had the same
				//	connection object. AFD isnt behaving well.
				KeBugCheck(0);
			}

			if (acceptIrp != NULL)
			{
				// AFD re-uses connection objects. Make sure ths one is in
				// the right state
				pAdspConn->adspco_Flags &= ~(ADSPCO_LISTENING			|
											 ADSPCO_CONNECTING			|
											 ADSPCO_ACCEPT_IRP			|
											 ADSPCO_LISTEN_IRP			|
											 ADSPCO_ACTIVE				|
											 ADSPCO_HALF_ACTIVE			|
											 ADSPCO_SEEN_REMOTE_OPEN	|
											 ADSPCO_DISCONNECTING		|
											 ADSPCO_REMOTE_CLOSE		|
											 ADSPCO_SEND_IN_PROGRESS	|
											 ADSPCO_SEND_DENY			|
											 ADSPCO_SEND_OPENACK		|
											 ADSPCO_SEND_WINDOW_CLOSED	|
											 ADSPCO_READ_PENDING		|
											 ADSPCO_EXREAD_PENDING		|
											 ADSPCO_FORWARD_RESET_RECD	|
											 ADSPCO_ATTN_DATA_RECD		|
											 ADSPCO_ATTN_DATA_EOM		|
											 ADSPCO_EXSEND_IN_PROGRESS	|
											 ADSPCO_OPEN_TIMER			|
											 ADSPCO_RETRANSMIT_TIMER	|
											 ADSPCO_CONN_TIMER);



				pAdspConn->adspco_ListenCompletion	= atalkAdspGenericComplete;
				pAdspConn->adspco_ListenCtx			= (PVOID)acceptIrp;

				//	This will be completed when we receive an ack
				//	for the open from the remote, i.e. both ends of the
				//	connection are open.
				pAdspConn->adspco_Flags |= ADSPCO_ACCEPT_IRP;
			}
		}
	}

	if (ATALK_SUCCESS(*pError = error))
	{
		*ppAdspConn = pAdspConn;
	}
	else
	{
		DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_ERR,
				("atalkAdspListenIndicateNonInterlock: No listen %lx\n", status));

		if (indicate)
		{
			//	Dequeue the open request.
			atalkAdspAddrDeQueueOpenReq(pAdspAddr,
										remoteConnId,
										&remoteAddr,
										&pOpenReq);
		}

#if DBG
        (&pAdspAddr->adspao_Lock)->FileLineLock |= 0x80000000;
#endif
		RELEASE_SPIN_LOCK_DPC(&pAdspAddr->adspao_Lock);
		atalkAdspSendDeny(pAdspAddr,
						  &remoteAddr,
						  remoteConnId);
		ACQUIRE_SPIN_LOCK_DPC(&pAdspAddr->adspao_Lock);
#if DBG
        (&pAdspAddr->adspao_Lock)->FileLineLock &= ~0x80000000;
#endif
	}
}




ATALK_ERROR
atalkAdspSendExpedited(
	IN	PADSP_CONNOBJ				pAdspConn,
	IN	PAMDL						pWriteBuf,
	IN	USHORT						WriteBufLen,
	IN	ULONG						SendFlags,
	IN	PVOID						pWriteCtx,
	IN	GENERIC_WRITE_COMPLETION	CompletionRoutine
	)
/*++

Routine Description:


Arguments:

	The first two bytes of the writebuffer will contain the ushort
	attention code. We need to put this back in the on-the-wire format
	before sending it out.

Return Value:


--*/
{
	ATALK_ERROR		error;
	KIRQL			OldIrql;
	PBYTE			pExWriteChBuf;
	USHORT			attnCode;
	NTSTATUS		status;
	ULONG			bytesCopied;
	BOOLEAN			DerefConn = FALSE;

	if ((WriteBufLen < ADSP_MIN_ATTEN_PKT_SIZE) ||
		(WriteBufLen > ADSP_MAX_ATTEN_PKT_SIZE))
	{
		return ATALK_BUFFER_TOO_SMALL;
	}

	if ((pExWriteChBuf = AtalkAllocMemory(WriteBufLen)) == NULL)
	{
		return ATALK_RESR_MEM;
	}

	status = TdiCopyMdlToBuffer((PMDL)pWriteBuf,
								0,
								pExWriteChBuf,
								0,
								WriteBufLen,
								&bytesCopied);

	ASSERT(!NT_ERROR(status) && (bytesCopied == (ULONG)WriteBufLen));

	ACQUIRE_SPIN_LOCK(&pAdspConn->adspco_Lock, &OldIrql);
	do
	{
		if (((pAdspConn->adspco_Flags & ADSPCO_ACTIVE) == 0) ||
			 ((pAdspConn->adspco_Flags & (ADSPCO_CLOSING |
										  ADSPCO_STOPPING|
										  ADSPCO_DISCONNECTING))))
		{
			error = ATALK_ADSP_CONN_NOT_ACTIVE;
			break;
		}

		if (pAdspConn->adspco_Flags & ADSPCO_EXSEND_IN_PROGRESS)
		{
			if (SendFlags & TDI_SEND_NON_BLOCKING)
			{
				//	!!!NOTE!!!
				//	To avoid the race condition in AFD where an incoming
				//	send data indication setting send's possible to true
				//	is overwritten by this read's unwinding and setting it
				//	to false, we return ATALK_REQUEST_NOT_ACCEPTED, which
				//	will map to STATUS_REQUEST_NOT_ACCEPTED and then to
				//	WSAEWOULDBLOCK.
				//	error = ATALK_DEVICE_NOT_READY;

				error = ATALK_REQUEST_NOT_ACCEPTED;
			}
			else
			{
				error		= ATALK_TOO_MANY_COMMANDS;
			}

			break;
		}

		//	Verify the attention code, this will a ushort in the first
		//	two bytes of the buffer, in host format.
		attnCode = *(PUSHORT)pExWriteChBuf;

		DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
				("atalkAdspSendExpedited: attnCode %lx\n", attnCode));

		if ((attnCode < ADSP_MIN_ATTENCODE) ||
			(attnCode > ADSP_MAX_ATTENCODE))
		{
			error = ATALK_INVALID_PARAMETER;
			break;
		}

		//	Put it back in machine format
		PUTSHORT2SHORT(pExWriteChBuf, attnCode);

		//	Try to reference for the attention retransmit timer
		AtalkAdspConnReferenceByPtrNonInterlock(pAdspConn, 1, &error);
		if (!ATALK_SUCCESS(error))
		{
			break;
		}

		DerefConn	= TRUE;

		//	Remember all the information in the connection object
		pAdspConn->adspco_ExWriteFlags		= SendFlags;
		pAdspConn->adspco_ExWriteBuf		= pWriteBuf;
		pAdspConn->adspco_ExWriteBufLen		= WriteBufLen;
		pAdspConn->adspco_ExWriteCompletion	= CompletionRoutine;
		pAdspConn->adspco_ExWriteCtx		= pWriteCtx;
		pAdspConn->adspco_ExWriteChBuf		= pExWriteChBuf;

		pAdspConn->adspco_Flags			   |= ADSPCO_EXSEND_IN_PROGRESS;

		//	Start the retry timer
		AtalkTimerInitialize(&pAdspConn->adspco_ExRetryTimer,
							 atalkAdspAttnRetransmitTimer,
							 ADSP_ATTENTION_INTERVAL);
		AtalkTimerScheduleEvent(&pAdspConn->adspco_ExRetryTimer);

		error = ATALK_PENDING;

	} while (FALSE);
	RELEASE_SPIN_LOCK(&pAdspConn->adspco_Lock, OldIrql);

	if (ATALK_SUCCESS(error))
	{
		atalkAdspSendAttn(pAdspConn);
		error	= ATALK_PENDING;
	}
	else
	{
		if (DerefConn)
		{
			AtalkAdspConnDereference(pAdspConn);
		}

		AtalkFreeMemory(pExWriteChBuf);
	}

	return error;
}




LOCAL VOID
atalkAdspSendOpenControl(
	IN	PADSP_CONNOBJ	pAdspConn
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	ATALK_ERROR		error;
	PBUFFER_DESC	pBuffDesc;
	BYTE			descriptor;
	KIRQL			OldIrql;
	BOOLEAN			DerefConn = FALSE;
	USHORT			remoteConnId = 0;
	SEND_COMPL_INFO	SendInfo;

	descriptor = ADSP_CONTROL_FLAG;
	if (pAdspConn->adspco_Flags & ADSPCO_SEND_DENY)
	{
		descriptor += ADSP_OPENCONN_DENY_CODE;
		remoteConnId = pAdspConn->adspco_RemoteConnId;
	}
	else if (pAdspConn->adspco_Flags & ADSPCO_ACTIVE)
	{
		descriptor += ADSP_OPENCONN_ACK_CODE;
		remoteConnId = pAdspConn->adspco_RemoteConnId;
	}
	else  if (pAdspConn->adspco_Flags & ADSPCO_SEEN_REMOTE_OPEN)
	{
		descriptor += ADSP_OPENCONN_REQANDACK_CODE;
		remoteConnId = pAdspConn->adspco_RemoteConnId;
	}
	else
	{
		descriptor += ADSP_OPENCONN_REQ_CODE;
	}

	//	Allocate the datagram buffer
	pBuffDesc = AtalkAllocBuffDesc(NULL,
								   ADSP_NEXT_ATTEN_SEQNUM_OFF + sizeof(ULONG),
								   BD_CHAR_BUFFER | BD_FREE_BUFFER);

	if (pBuffDesc == NULL)
	{
		DBGPRINT(DBG_COMP_RTMP, DBG_LEVEL_ERR,
			("AtalkAdspSendOpenControl: AtalkAllocBuffDesc failed\n"));

		RES_LOG_ERROR();
		return;
	}

	ACQUIRE_SPIN_LOCK(&pAdspConn->adspco_Lock, &OldIrql);

	//	Try to reference connection for this call.
	AtalkAdspConnReferenceByPtrNonInterlock(pAdspConn, 1, &error);
	if (ATALK_SUCCESS(error))
	{
		DerefConn = TRUE;

		PUTSHORT2SHORT(pBuffDesc->bd_CharBuffer + ADSP_SRC_CONNID_OFF,
					   pAdspConn->adspco_LocalConnId);

		PUTDWORD2DWORD(pBuffDesc->bd_CharBuffer + ADSP_FIRST_BYTE_SEQNUM_OFF,
					   pAdspConn->adspco_SendSeq);

		PUTDWORD2DWORD(pBuffDesc->bd_CharBuffer + ADSP_NEXT_RX_BYTESEQNUM_OFF,
					   pAdspConn->adspco_RecvSeq);

		PUTSHORT2SHORT(pBuffDesc->bd_CharBuffer + ADSP_RX_WINDOW_SIZE_OFF,
					   pAdspConn->adspco_RecvWindow);

		//	Set the descriptor
		pBuffDesc->bd_CharBuffer[ADSP_DESCRIPTOR_OFF] = descriptor;

		PUTSHORT2SHORT(pBuffDesc->bd_CharBuffer + ADSP_VERSION_STAMP_OFF,
					   ADSP_VERSION);

		PUTSHORT2SHORT(pBuffDesc->bd_CharBuffer + ADSP_DEST_CONNID_OFF,
					   remoteConnId);

		PUTDWORD2DWORD(pBuffDesc->bd_CharBuffer + ADSP_NEXT_ATTEN_SEQNUM_OFF,
					   pAdspConn->adspco_RecvAttnSeq);
	}
	RELEASE_SPIN_LOCK(&pAdspConn->adspco_Lock, OldIrql);

	if (ATALK_SUCCESS(error))
	{
		//	We let the completion routine Deref the conn.
		DerefConn = FALSE;

		SendInfo.sc_TransmitCompletion = atalkAdspConnSendComplete;
		SendInfo.sc_Ctx1 = pAdspConn;
		SendInfo.sc_Ctx2 = pBuffDesc;
		// SendInfo.sc_Ctx3 = NULL;
		if(!ATALK_SUCCESS(AtalkDdpSend(pAdspConn->adspco_pDdpAddr,
									   &pAdspConn->adspco_RemoteAddr,
									   DDPPROTO_ADSP,
									   FALSE,
									   pBuffDesc,
									   NULL,
									   0,
									   NULL,
									   &SendInfo)))
		{
			atalkAdspConnSendComplete(NDIS_STATUS_FAILURE, &SendInfo);
		}
	}
	else
	{
		//	Free the buffer descriptor
		AtalkFreeBuffDesc(pBuffDesc);
	}

	if (DerefConn)
	{
		AtalkAdspConnDereference(pAdspConn);
	}
}



LOCAL VOID
atalkAdspSendControl(
	IN	PADSP_CONNOBJ	pAdspConn,
	IN	BYTE			Descriptor
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	ATALK_ERROR		error;
	PBUFFER_DESC	pBuffDesc;
	ULONG			sendSeq, recvSeq, recvWindow;
	BOOLEAN			DerefConn = FALSE;
	SEND_COMPL_INFO	SendInfo;

	//	Try to reference connection for this call.
	AtalkAdspConnReferenceByPtrNonInterlock(pAdspConn, 1, &error);
	if (ATALK_SUCCESS(error))
	{
		DerefConn	= TRUE;
		if ((Descriptor & ADSP_ATTEN_FLAG) == 0)
		{
			sendSeq		= pAdspConn->adspco_SendSeq;
			recvSeq		= pAdspConn->adspco_RecvSeq;
			recvWindow	= pAdspConn->adspco_RecvWindow;
		}
		else
		{
			sendSeq		= pAdspConn->adspco_SendAttnSeq;
			recvSeq		= pAdspConn->adspco_RecvAttnSeq;
			recvWindow	= 0;
		}

		//	Allocate the datagram buffer
		if ((pBuffDesc = AtalkAllocBuffDesc(NULL,
											ADSP_DATA_OFF,
											BD_CHAR_BUFFER | BD_FREE_BUFFER)) != NULL)
		{
			PUTSHORT2SHORT(pBuffDesc->bd_CharBuffer + ADSP_SRC_CONNID_OFF,
						   pAdspConn->adspco_LocalConnId);

			PUTDWORD2DWORD(pBuffDesc->bd_CharBuffer + ADSP_FIRST_BYTE_SEQNUM_OFF,
						   sendSeq);

			PUTDWORD2DWORD(pBuffDesc->bd_CharBuffer + ADSP_NEXT_RX_BYTESEQNUM_OFF,
						   recvSeq);

			PUTSHORT2SHORT(pBuffDesc->bd_CharBuffer + ADSP_RX_WINDOW_SIZE_OFF,
						   recvWindow);

			//	Set the descriptor
			pBuffDesc->bd_CharBuffer[ADSP_DESCRIPTOR_OFF] = Descriptor;
		}
		else
		{
			error = ATALK_RESR_MEM;
		}
	}

#if DBG
    (&pAdspConn->adspco_Lock)->FileLineLock |= 0x80000000;
#endif
	RELEASE_SPIN_LOCK_DPC(&pAdspConn->adspco_Lock);

	if (ATALK_SUCCESS(error))
	{
		DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
			("AtalkAdspSendControl: %lx.%lx\n", pAdspConn, Descriptor));

		//	We let the completion routine Deref the conn.
		SendInfo.sc_TransmitCompletion = atalkAdspConnSendComplete;
		SendInfo.sc_Ctx1 = pAdspConn;
		SendInfo.sc_Ctx2 = pBuffDesc;
		// SendInfo.sc_Ctx3 = NULL;
		if (!ATALK_SUCCESS(AtalkDdpSend(pAdspConn->adspco_pDdpAddr,
										&pAdspConn->adspco_RemoteAddr,
										DDPPROTO_ADSP,
										FALSE,
										pBuffDesc,
										NULL,
										0,
										NULL,
										&SendInfo)))
		{
			atalkAdspConnSendComplete(NDIS_STATUS_FAILURE, &SendInfo);
		}
	}
	else
	{
		if (DerefConn)
		{
			AtalkAdspConnDereference(pAdspConn);
		}
	}

	ACQUIRE_SPIN_LOCK_DPC(&pAdspConn->adspco_Lock);
#if DBG
    (&pAdspConn->adspco_Lock)->FileLineLock &= ~0x80000000;
#endif
}



LOCAL VOID
atalkAdspSendDeny(
	IN	PADSP_ADDROBJ	pAdspAddr,
	IN	PATALK_ADDR		pRemoteAddr,
	IN	USHORT			RemoteConnId
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	ATALK_ERROR		error;
	PBUFFER_DESC	pBuffDesc;
	SEND_COMPL_INFO	SendInfo;

	//	Allocate the datagram buffer
	if ((pBuffDesc = AtalkAllocBuffDesc(NULL,
										ADSP_NEXT_ATTEN_SEQNUM_OFF + sizeof(ULONG),
										BD_CHAR_BUFFER | BD_FREE_BUFFER)) == NULL)
	{
		DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_ERR,
			("AtalkAdspSendControl: AtalkAllocBuffDesc failed\n"));

		RES_LOG_ERROR();
		return;
	}

	//	Try to reference address for this call.
	AtalkAdspAddrReference(pAdspAddr, &error);
	if (!ATALK_SUCCESS(error))
	{
		AtalkFreeBuffDesc(pBuffDesc);
		return;
	}

	PUTSHORT2SHORT(pBuffDesc->bd_CharBuffer + ADSP_SRC_CONNID_OFF, 0);

	PUTDWORD2DWORD(pBuffDesc->bd_CharBuffer + ADSP_FIRST_BYTE_SEQNUM_OFF, 0);

	PUTDWORD2DWORD(pBuffDesc->bd_CharBuffer + ADSP_NEXT_RX_BYTESEQNUM_OFF, 0);

	PUTSHORT2SHORT(pBuffDesc->bd_CharBuffer + ADSP_RX_WINDOW_SIZE_OFF, 0);

	//	Set the descriptor
	pBuffDesc->bd_CharBuffer[ADSP_DESCRIPTOR_OFF] = ADSP_CONTROL_FLAG |
													ADSP_OPENCONN_DENY_CODE;

	PUTSHORT2SHORT(pBuffDesc->bd_CharBuffer + ADSP_VERSION_STAMP_OFF,
				   ADSP_VERSION);

	PUTSHORT2SHORT(pBuffDesc->bd_CharBuffer + ADSP_DEST_CONNID_OFF,
				   RemoteConnId);

	PUTDWORD2DWORD(pBuffDesc->bd_CharBuffer + ADSP_NEXT_ATTEN_SEQNUM_OFF,
				   0);

	DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
			("AtalkAdspSendDeny: %lx.%lx\n", pAdspAddr, pBuffDesc));

	//	We let the completion routine Deref the conn.
	SendInfo.sc_TransmitCompletion = atalkAdspAddrSendComplete;
	SendInfo.sc_Ctx1 = pAdspAddr;
	SendInfo.sc_Ctx2 = pBuffDesc;
	// SendInfo.sc_Ctx3 = NULL;
	if(!ATALK_SUCCESS(AtalkDdpSend(AtalkAdspGetDdpAddress(pAdspAddr),
								   pRemoteAddr,
								   DDPPROTO_ADSP,
								   FALSE,
								   pBuffDesc,
								   NULL,
								   0,
								   NULL,
								   &SendInfo)))
	{
		atalkAdspAddrSendComplete(NDIS_STATUS_FAILURE, &SendInfo);
	}
}




LOCAL VOID
atalkAdspSendAttn(
	IN	PADSP_CONNOBJ	pAdspConn
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	KIRQL				OldIrql;
	PBYTE				adspHeader;
	ATALK_ERROR			error		= ATALK_NO_ERROR;
	PBUFFER_DESC		pBuffDesc	= NULL;
	SEND_COMPL_INFO		SendInfo;

	do
	{
		pBuffDesc = AtalkAllocBuffDesc(NULL,
									   ADSP_DATA_OFF + ADSP_MAX_DATA_SIZE,
									   BD_CHAR_BUFFER | BD_FREE_BUFFER);

		if (pBuffDesc == NULL)
		{
			DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_ERR,
				("AtalkAdspSendAttn: AtalkAllocBuffDesc failed\n"));

			RES_LOG_ERROR();
			break;
		}

		adspHeader	= pBuffDesc->bd_CharBuffer;

		ACQUIRE_SPIN_LOCK(&pAdspConn->adspco_Lock, &OldIrql);
		if (pAdspConn->adspco_Flags & ADSPCO_EXSEND_IN_PROGRESS)
		{
			PUTSHORT2SHORT(adspHeader + ADSP_SRC_CONNID_OFF,
						   pAdspConn->adspco_LocalConnId);

			PUTDWORD2DWORD(adspHeader + ADSP_THIS_ATTEN_SEQNUM_OFF,
						   pAdspConn->adspco_SendAttnSeq);

			PUTDWORD2DWORD(adspHeader + ADSP_NEXT_RX_ATTNSEQNUM_OFF,
						   pAdspConn->adspco_RecvAttnSeq);

			PUTSHORT2SHORT(adspHeader + ADSP_RX_ATTEN_SIZE_OFF, 0);

			//	Set the descriptor
			adspHeader[ADSP_DESCRIPTOR_OFF] = ADSP_ATTEN_FLAG + ADSP_ACK_REQ_FLAG;

			//	Send eom?
			if (((pAdspConn->adspco_ExWriteFlags & TDI_SEND_PARTIAL) == 0) &&
				(pAdspConn->adspco_pAssocAddr->adspao_Flags & ADSPAO_MESSAGE))
			{
				adspHeader[ADSP_DESCRIPTOR_OFF]	+= ADSP_EOM_FLAG;
			}

			//	Copy the attention data
			RtlCopyMemory(&adspHeader[ADSP_DATA_OFF],
						  pAdspConn->adspco_ExWriteChBuf,
						  pAdspConn->adspco_ExWriteBufLen);

			//	Set the size in the buffer descriptor
			AtalkSetSizeOfBuffDescData(pBuffDesc,
									   ADSP_DATA_OFF +
											pAdspConn->adspco_ExWriteBufLen);
		}
		else
		{
			error = ATALK_FAILURE;
		}
		RELEASE_SPIN_LOCK(&pAdspConn->adspco_Lock, OldIrql);

		if (ATALK_SUCCESS(error))
		{
			//	Send the packet
			SendInfo.sc_TransmitCompletion = atalkAdspSendAttnComplete;
			SendInfo.sc_Ctx1 = pAdspConn;
			SendInfo.sc_Ctx2 = pBuffDesc;
			// SendInfo.sc_Ctx3 = NULL;
			error = AtalkDdpSend(pAdspConn->adspco_pDdpAddr,
								 &pAdspConn->adspco_RemoteAddr,
								 (BYTE)DDPPROTO_ADSP,
								 FALSE,
								 pBuffDesc,
								 NULL,
								 0,
								 NULL,
								 &SendInfo);

			if (!ATALK_SUCCESS(error))
			{
				DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_ERR,
					("AtalkAdspSendAttn: DdpSend failed %ld\n", error));

				atalkAdspSendAttnComplete(NDIS_STATUS_FAILURE, &SendInfo);
			}

			error = ATALK_PENDING;
		}

	} while (FALSE);

	if (!ATALK_SUCCESS(error) && (pBuffDesc != NULL))
	{
		AtalkFreeBuffDesc(pBuffDesc);
	}
}




LOCAL VOID
atalkAdspSendData(
	IN	PADSP_CONNOBJ	pAdspConn
	)
/*++

Routine Description:

	MUST BE ENTERED WITH CONNECTION LOCK HELD !!!

Arguments:


Return Value:


--*/
{
	ATALK_ERROR				error;
	BYTE					descriptor;
	ULONG					dataSize;
	BOOLEAN					eom;
	BYTE					adspHeader[ADSP_DATA_OFF];
	LONG					windowSize		= 0;
	PBUFFER_CHUNK			pBufferChunk	= NULL;
	PBUFFER_DESC			pBuffDesc		= NULL;
	SEND_COMPL_INFO			SendInfo;


	//	If there is no data to send or if the remote cannot handle any more
	//	data, just send an ack.

	SendInfo.sc_TransmitCompletion = atalkAdspSendDataComplete;
	SendInfo.sc_Ctx1 = pAdspConn;

	while (TRUE)
	{
		if ((pAdspConn->adspco_Flags & (ADSPCO_ACTIVE	|
										ADSPCO_CLOSING	|
										ADSPCO_STOPPING	|
										ADSPCO_DISCONNECTING)) != ADSPCO_ACTIVE)
		{
			break;
		}

		//	dataSize includes count of eom if present
		dataSize	= atalkAdspBufferQueueSize(&pAdspConn->adspco_NextSendQueue);
		windowSize	= (LONG)(pAdspConn->adspco_SendWindowSeq	-
							 pAdspConn->adspco_SendSeq			+
							 (LONG)1);

		ASSERTMSG("WindowSize incorrect!\n",
					((windowSize >= 0) || (dataSize == 0)));

		if ((dataSize == 0) || (windowSize == 0))
		{
			//	Send a ack request to the remote end.
			descriptor = ADSP_CONTROL_FLAG + ADSP_PROBE_OR_ACK_CODE +
						 ((windowSize == 0) ? ADSP_ACK_REQ_FLAG : 0);

			atalkAdspSendControl(pAdspConn, descriptor);
			break;
		}

		ASSERTMSG("WindowSize incorrect!\n", (windowSize >= 0));
		if (windowSize < 0)
		{
			//	This should never happen. It can be negative, but only if
			//	the datasize is 0.
		}


		//	We have some data to send
		windowSize = MIN((ULONG)windowSize, dataSize);

		//	compute the amount of data to be sent. This will only get
		//	the data in one buffer chunk, i.e. if the current buffer chunk
		//	has only one byte to be sent, it will return just that, although
		//	the next buffer chunk might still have some data to be sent. It will
		//	return a built buffer chunk with the proper amount of data in it.
		//	Given checks above there is guaranteed to be dataSize amount of data
		//	in queue.
		dataSize = atalkAdspDescribeFromBufferQueue(&pAdspConn->adspco_NextSendQueue,
													&eom,
													windowSize,
													&pBufferChunk,
													&pBuffDesc);

		DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
				("atalkAdspSendData: DataSize %ld\n", dataSize));

		ASSERT(dataSize <= (ULONG)windowSize);

		descriptor = (eom ? ADSP_EOM_FLAG : 0);
		if (windowSize == (LONG)(dataSize + BYTECOUNT(eom)))
		{
			descriptor += ADSP_ACK_REQ_FLAG;
		}

		PUTSHORT2SHORT(adspHeader + ADSP_SRC_CONNID_OFF,
					   pAdspConn->adspco_LocalConnId);

		PUTDWORD2DWORD(adspHeader + ADSP_FIRST_BYTE_SEQNUM_OFF,
					   pAdspConn->adspco_SendSeq);

		PUTDWORD2DWORD(adspHeader + ADSP_NEXT_RX_BYTESEQNUM_OFF,
					   pAdspConn->adspco_RecvSeq);

		PUTSHORT2SHORT(adspHeader + ADSP_RX_WINDOW_SIZE_OFF,
					   pAdspConn->adspco_RecvWindow);

		//	Set the descriptor
		adspHeader[ADSP_DESCRIPTOR_OFF] = descriptor;

		//	Move up our seq num. We should do it before we release the lock
		//	so that other calls to this routine do not mess it up.
		//	!!!NOTE!!! Due to calling describe, dataSize *does not* include
		//	eom in its count.
		pAdspConn->adspco_SendSeq	+= (ULONG)dataSize + BYTECOUNT(eom);

		windowSize					-= dataSize;


#if DBG
        (&pAdspConn->adspco_Lock)->FileLineLock |= 0x80000000;
#endif
		RELEASE_SPIN_LOCK_DPC(&pAdspConn->adspco_Lock);

		//	Send the packet
		SendInfo.sc_Ctx2 = pBuffDesc;
		SendInfo.sc_Ctx3 = pBufferChunk;
		error = AtalkDdpSend(pAdspConn->adspco_pDdpAddr,
							 &pAdspConn->adspco_RemoteAddr,
							 (BYTE)DDPPROTO_ADSP,
							 FALSE,
							 pBuffDesc,
							 adspHeader,
							 sizeof(adspHeader),
							 NULL,
							 &SendInfo);

		if (!ATALK_SUCCESS(error))
		{
			DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_ERR,
					("AtalkAdspSendData: DdpSend failed %ld\n", error));

			atalkAdspSendDataComplete(NDIS_STATUS_FAILURE, &SendInfo);
		}

		ACQUIRE_SPIN_LOCK_DPC(&pAdspConn->adspco_Lock);
#if DBG
        (&pAdspConn->adspco_Lock)->FileLineLock &= ~0x80000000;
#endif
	}
}




LOCAL VOID
atalkAdspRecvData(
	IN	PADSP_CONNOBJ	pAdspConn
	)
/*++

Routine Description:

	MUST HAVE THE CONNECTION LOCK HELD BEFORE ENTERING HERE !!!

	SHOULD THIS ROUTINE HAVE ITS OWN REFERENCE FOR THE CONNECTION?

Arguments:


Return Value:


--*/
{
	BOOLEAN					eom;
	ULONG					msgSize, readSize, bytesTaken, bytesRead;
	ULONG					lookaheadSize;
	PBYTE					lookaheadData;
	ULONG					readFlags;
	PAMDL					readBuf;
	USHORT					readBufLen;
	GENERIC_READ_COMPLETION	readCompletion;
	PVOID					readCtx;
	PIRP					recvIrp;
	PTDI_IND_RECEIVE		recvHandler;
	PVOID					recvHandlerCtx;
	NTSTATUS				ntStatus;
	BOOLEAN					callComp = FALSE, fWdwChanged = FALSE;
        ATALK_ERROR                             ErrorCode;

	do
	{
		if ((pAdspConn->adspco_Flags &
				(ADSPCO_READ_PENDING | ADSPCO_FORWARD_RESET_RECD)) ==
				(ADSPCO_READ_PENDING | ADSPCO_FORWARD_RESET_RECD))
		{
			readFlags	= pAdspConn->adspco_ReadFlags;
			readBuf		= pAdspConn->adspco_ReadBuf;
			readBufLen	= pAdspConn->adspco_ReadBufLen;
			readCompletion	= pAdspConn->adspco_ReadCompletion;
			readCtx			= pAdspConn->adspco_ReadCtx;

			pAdspConn->adspco_Flags &= ~ADSPCO_READ_PENDING;

#if DBG
            (&pAdspConn->adspco_Lock)->FileLineLock |= 0x80000000;
#endif
			RELEASE_SPIN_LOCK_DPC(&pAdspConn->adspco_Lock);

			if (*readCompletion != NULL)
			{
				(*readCompletion)(ATALK_ADSP_CONN_RESET,
								  readBuf,
								  readBufLen,
								  readFlags,
								  readCtx);
			}

			//	Deref connection for the read
			AtalkAdspConnDereference(pAdspConn);

			ACQUIRE_SPIN_LOCK_DPC(&pAdspConn->adspco_Lock);
#if DBG
            (&pAdspConn->adspco_Lock)->FileLineLock &= ~0x80000000;
#endif
			break;
		}

		//	Check for pending attention data
		if (pAdspConn->adspco_Flags & ADSPCO_ATTN_DATA_RECD)
		{
			atalkAdspRecvAttn(pAdspConn);
		}

		//	Get the receive handler.
		recvHandler	= pAdspConn->adspco_pAssocAddr->adspao_RecvHandler;
		recvHandlerCtx	= pAdspConn->adspco_pAssocAddr->adspao_RecvHandlerCtx;

		//	!!!NOTE!!!
		//	Its possible that when we get a disconnect packet before we
		//	get previously sent data, we could end up indicating disconnect
		//	to afd before indicating the received data. This hits an assertion
		//	in afd on a checked build, but afd still behaves as it should.
		msgSize	= atalkAdspMessageSize(&pAdspConn->adspco_RecvQueue, &eom);
		bytesRead	= 1;	// A Non-zero value so we enter the loop
		while (((msgSize > 0) || eom) && (bytesRead > 0))
		{
			bytesRead	= 0;

			//	Check for no pending reads, but we have new data to indicate, and the
			//	client has read all the previously indicated data.
			if (((pAdspConn->adspco_Flags & ADSPCO_READ_PENDING) == 0) &&
				(*recvHandler != NULL) &&
				(pAdspConn->adspco_PrevIndicatedData == 0))
			{
				pAdspConn->adspco_PrevIndicatedData = msgSize;

				DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
						("atalkAdspRecvData: PrevInd1 %d\n", pAdspConn->adspco_PrevIndicatedData));

				lookaheadData	= atalkAdspGetLookahead(&pAdspConn->adspco_RecvQueue,
														&lookaheadSize);

				readFlags	= ((eom) ?
								(TDI_RECEIVE_NORMAL  | TDI_RECEIVE_ENTIRE_MESSAGE) :
								(TDI_RECEIVE_PARTIAL | TDI_RECEIVE_NORMAL));

				if (*recvHandler != NULL)
				{
					DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
							("atalkAdspRecvData: Indicating data %ld.%ld!\n", lookaheadSize, msgSize));

#if DBG
                    (&pAdspConn->adspco_Lock)->FileLineLock |= 0x80000000;
#endif
					RELEASE_SPIN_LOCK_DPC(&pAdspConn->adspco_Lock);
					ntStatus = (*recvHandler)(recvHandlerCtx,
											  pAdspConn->adspco_ConnCtx,
											  readFlags,
											  lookaheadSize,
											  msgSize,
											  &bytesTaken,
											  lookaheadData,
											  &recvIrp);

					ASSERT((bytesTaken == 0) || (bytesTaken == msgSize));
					if (ntStatus == STATUS_MORE_PROCESSING_REQUIRED)
					{
						if (recvIrp != NULL)
						{
							//  Post the receive as if it came from the io system
							ntStatus = AtalkDispatchInternalDeviceControl(
											(PDEVICE_OBJECT)AtalkDeviceObject[ATALK_DEV_ADSP],
											recvIrp);

							ASSERT(ntStatus == STATUS_PENDING);
						}
						else
						{
							ASSERTMSG("atalkAdspRecvData: No receive irp!\n", 0);
							KeBugCheck(0);
						}
					}
					else if (ntStatus == STATUS_SUCCESS)
					{
						if (bytesTaken != 0)
						{
							//	Assume all of the data was read.
							ASSERT(bytesTaken == msgSize);
							DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
									("atalkAdspRecvData: All bytes read %lx\n", bytesTaken));

							//	Discard data from queue (msgSize + BYTECOUNT(eom))
							//	amount of data).
						}
					}
					else if (ntStatus == STATUS_DATA_NOT_ACCEPTED)
					{
						//	Client may have posted a receive in the indication. Or
						//	it will post a receive later on. Do nothing here.
						DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
								("atalkAdspRecvData: Indication status %lx\n", ntStatus));
					}
					ACQUIRE_SPIN_LOCK_DPC(&pAdspConn->adspco_Lock);
#if DBG
                    (&pAdspConn->adspco_Lock)->FileLineLock &= ~0x80000000;
#endif
				}
			}

			//	Check for any posted receives, this may have happened during
			//	the receive indication.
			if (pAdspConn->adspco_Flags & ADSPCO_READ_PENDING)
			{
				readFlags		= pAdspConn->adspco_ReadFlags;
				readBuf			= pAdspConn->adspco_ReadBuf;
				readBufLen		= pAdspConn->adspco_ReadBufLen;
				readCompletion	= pAdspConn->adspco_ReadCompletion;
				readCtx			= pAdspConn->adspco_ReadCtx;

				//	For a message-based socket, we do not complete
				//	a read until eom, or the buffer fills up.
				if ((pAdspConn->adspco_pAssocAddr->adspao_Flags & ADSPAO_MESSAGE) &&
					(!eom && (msgSize < readBufLen)))
				{
					DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
							("atalkAdspRecv: MsgSize < readLen %lx.%lx\n", msgSize, readBufLen));

					//	If we are disconnected and this data is just the last
					//	remnant from remote, we just copy what we got and leave.
					//	There may not have been an EOM from the remote.
                                        //  Also, if the msg is bigger than what transport can hold (8K),
                                        //  give whatever we have so far to the app so that our recv window
                                        //  can open up.  That is, break out of the loop only if recv window
                                        //  has room to accept more data
					if ( (pAdspConn->adspco_Flags & ADSPCO_ACTIVE) &&
                                             (pAdspConn->adspco_RecvWindow > 1))
					{
						break;
					}

					DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_WARN,
							("AtalkAdspRead: READ AFTER DISC %lx Flg %lx\n",
							pAdspConn, pAdspConn->adspco_Flags));
				}


				//	This will return the data in the mdl from the
				//	receive queue.
				readSize = atalkAdspReadFromBufferQueue(&pAdspConn->adspco_RecvQueue,
														readFlags,
														readBuf,
														&readBufLen,
														&eom);

				if ((readSize == 0) && !eom)
				{
					pAdspConn->adspco_PrevIndicatedData = 0;
					break;
				}

				bytesRead	+= (readSize + BYTECOUNT(eom));
				pAdspConn->adspco_Flags &= ~ADSPCO_READ_PENDING;

				//	If this is not a PEEK receive, the data will be
				//	discarded from the queue. If so, increase our window size, do a
				//	senddata to let remote know of the change.
				if ((readFlags & TDI_RECEIVE_PEEK) == 0)
				{
					pAdspConn->adspco_RecvWindow += (readSize + BYTECOUNT(eom));

					ASSERT(pAdspConn->adspco_RecvWindow <=
							pAdspConn->adspco_RecvQueueMax);

					fWdwChanged = TRUE;
				}

#if DBG
                (&pAdspConn->adspco_Lock)->FileLineLock |= 0x80000000;
#endif
				RELEASE_SPIN_LOCK_DPC(&pAdspConn->adspco_Lock);
				if (*readCompletion != NULL)
				{
					DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
							("atalkAdspRecvData: Read for %d, %x\n", readBufLen, readFlags));

					ErrorCode = ATALK_NO_ERROR;

		                        if ((pAdspConn->adspco_pAssocAddr->adspao_Flags & ADSPAO_MESSAGE) && !eom)
                                        {
					    ErrorCode = ATALK_ADSP_PARTIAL_RECEIVE;
                                        }
					(*readCompletion)(ErrorCode,
							  readBuf,
							  readBufLen,
							  readFlags,
							  readCtx);
				}

				//	Deref connection for the read
				AtalkAdspConnDereference(pAdspConn);

				ACQUIRE_SPIN_LOCK_DPC(&pAdspConn->adspco_Lock);
#if DBG
                (&pAdspConn->adspco_Lock)->FileLineLock &= ~0x80000000;
#endif

				//	Now change our prev indicated field. Until we
				//	complete the read, we musn't indicate new data.
				//	If the read was PEEK, then we don't want to do
				//	any more indications until a *real* read happens.
				if ((readFlags & TDI_RECEIVE_PEEK) == 0)
				{
					pAdspConn->adspco_PrevIndicatedData	-=
						MIN(readSize, pAdspConn->adspco_PrevIndicatedData);
				}

				DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
						("atalkAdspRecvData: PrevInd2 %d\n",
						pAdspConn->adspco_PrevIndicatedData));
			}

			msgSize	= atalkAdspMessageSize(&pAdspConn->adspco_RecvQueue, &eom);
			DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
					("Second msg %d.%d\n", msgSize, eom));
		}

	} while (FALSE);

	if (fWdwChanged &&
		(pAdspConn->adspco_PrevIndicatedData == 0))
	{
		atalkAdspSendData(pAdspConn);
	}
}




LOCAL VOID
atalkAdspRecvAttn(
	IN	PADSP_CONNOBJ	pAdspConn
	)
/*++

Routine Description:

	!!!THIS ROUTINE MUST PRESERVE THE STATE OF THE CONNECTION LOCK!!!

	SHOULD THIS ROUTINE HAVE ITS OWN REFERENCE FOR THE CONNECTION?

Arguments:


Return Value:


--*/
{
	ATALK_ERROR				error;
	PAMDL					readBuf;
	USHORT					readBufLen;
	ULONG					readFlags;
	GENERIC_READ_COMPLETION	readCompletion;
	PVOID					readCtx;
	PBYTE					attnData;
	USHORT					attnDataSize;
	ULONG					bytesRead;
	NTSTATUS				status;

	do
	{
		if ((pAdspConn->adspco_Flags & ADSPCO_ATTN_DATA_RECD) == 0)
		{
			break;
		}

		if (pAdspConn->adspco_Flags & ADSPCO_EXREAD_PENDING)
		{
			//	Use the expedited receive posted
			readFlags		= pAdspConn->adspco_ExReadFlags;
			readBuf			= pAdspConn->adspco_ExReadBuf;
			readBufLen		= pAdspConn->adspco_ExReadBufLen;
			readCompletion	= pAdspConn->adspco_ExReadCompletion;
			readCtx			= pAdspConn->adspco_ExReadCtx;

			pAdspConn->adspco_Flags &= ~ADSPCO_EXREAD_PENDING;
		}
		else if ((pAdspConn->adspco_Flags & ADSPCO_READ_PENDING) &&
				 (pAdspConn->adspco_ReadFlags & TDI_RECEIVE_EXPEDITED))
		{
			//	Use the normal receive
			readFlags		= pAdspConn->adspco_ReadFlags;
			readBuf			= pAdspConn->adspco_ReadBuf;
			readBufLen		= pAdspConn->adspco_ReadBufLen;
			readCompletion	= pAdspConn->adspco_ReadCompletion;
			readCtx			= pAdspConn->adspco_ReadCtx;

			pAdspConn->adspco_Flags &= ~ADSPCO_READ_PENDING;
		}
		else
		{
			break;
		}

		attnData		= pAdspConn->adspco_ExRecdData;
		attnDataSize	= pAdspConn->adspco_ExRecdLen;

		//	Copy received attention data into the read buffer
		error	= ATALK_ADSP_PAREXPED_RECEIVE;
		if (pAdspConn->adspco_Flags & ADSPCO_ATTN_DATA_EOM)
		{
			error = ATALK_ADSP_EXPED_RECEIVE;
		}

		if (attnDataSize > readBufLen)
		{
			attnDataSize	= readBufLen;
		}

		status = TdiCopyBufferToMdl(attnData,
									0,
									attnDataSize,
									readBuf,
									0,
									&bytesRead);

		ASSERT(NT_SUCCESS(status) && (attnDataSize == bytesRead));

		//	Update sequence number etc., only if this was not a peek.
		if ((readFlags & TDI_RECEIVE_PEEK) == 0)
		{
			pAdspConn->adspco_ExRecdData	= NULL;

			//	Advance our receive attention sequence number
			pAdspConn->adspco_RecvAttnSeq  += 1;

			pAdspConn->adspco_Flags		   &= ~(ADSPCO_ATTN_DATA_RECD |
												ADSPCO_ATTN_DATA_EOM);
		}

#if DBG
        (&pAdspConn->adspco_Lock)->FileLineLock |= 0x80000000;
#endif
		RELEASE_SPIN_LOCK_DPC(&pAdspConn->adspco_Lock);

		//	Complete receive
		ASSERT(*readCompletion != NULL);
		(*readCompletion)(error,
						  readBuf,
						  attnDataSize,
						  TDI_RECEIVE_EXPEDITED,
						  readCtx);

		//	Free the allocated buffer if this was not a peek
		if ((readFlags & TDI_RECEIVE_PEEK) == 0)
		{
			AtalkFreeMemory(attnData);
		}

		//	Deref connection for the read
		AtalkAdspConnDereference(pAdspConn);

		ACQUIRE_SPIN_LOCK_DPC(&pAdspConn->adspco_Lock);
#if DBG
        (&pAdspConn->adspco_Lock)->FileLineLock &= ~0x80000000;
#endif

		//	Send ack for the attention only if this was not a peek
		if ((readFlags & TDI_RECEIVE_PEEK) == 0)
		{
			atalkAdspSendControl(pAdspConn,
								 ADSP_CONTROL_FLAG + ADSP_ATTEN_FLAG);
		}

	} while (FALSE);
}




VOID FASTCALL
atalkAdspConnSendComplete(
	IN	NDIS_STATUS			Status,
	IN	PSEND_COMPL_INFO	pSendInfo
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	if (pSendInfo->sc_Ctx2 != NULL)
	{
		AtalkFreeBuffDesc((PBUFFER_DESC)(pSendInfo->sc_Ctx2));
	}

	AtalkAdspConnDereference((PADSP_CONNOBJ)(pSendInfo->sc_Ctx1));
}



VOID FASTCALL
atalkAdspAddrSendComplete(
	IN	NDIS_STATUS			Status,
	IN	PSEND_COMPL_INFO	pSendInfo
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	if (pSendInfo->sc_Ctx2 != NULL)
	{
		AtalkFreeBuffDesc((PBUFFER_DESC)(pSendInfo->sc_Ctx2));
	}

	AtalkAdspAddrDereference((PADSP_ADDROBJ)(pSendInfo->sc_Ctx1));
}




VOID FASTCALL
atalkAdspSendAttnComplete(
	IN	NDIS_STATUS			Status,
	IN	PSEND_COMPL_INFO	pSendInfo
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	if (pSendInfo->sc_Ctx2 != NULL)
	{
		AtalkFreeBuffDesc((PBUFFER_DESC)(pSendInfo->sc_Ctx2));
	}
}



VOID FASTCALL
atalkAdspSendDataComplete(
	IN	NDIS_STATUS			Status,
	IN	PSEND_COMPL_INFO	pSendInfo
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	if (pSendInfo->sc_Ctx2 != NULL)
	{
		AtalkFreeBuffDesc((PBUFFER_DESC)(pSendInfo->sc_Ctx2));
	}

	if (pSendInfo->sc_Ctx3 != NULL)
	{
		atalkAdspBufferChunkDereference((PBUFFER_CHUNK)(pSendInfo->sc_Ctx3),
										FALSE,
										NULL);
	}
}



//
//	ADSP TIMER ROUTINES
//

LOCAL LONG FASTCALL
atalkAdspConnMaintenanceTimer(
	IN	PTIMERLIST		pTimer,
	IN	BOOLEAN			TimerShuttingDown
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PADSP_CONNOBJ	pAdspConn;
	LONG			now;
	BOOLEAN			done = FALSE;

	pAdspConn = (PADSP_CONNOBJ)CONTAINING_RECORD(pTimer, ADSP_CONNOBJ, adspco_ConnTimer);

	ASSERT(VALID_ADSPCO(pAdspConn));

	if (TimerShuttingDown)
	{
		done = TRUE;
	}
	else
	{
		ASSERT(VALID_ADSPCO(pAdspConn));
		ACQUIRE_SPIN_LOCK_DPC(&pAdspConn->adspco_Lock);
		if (pAdspConn->adspco_Flags & (	ADSPCO_CLOSING	|
										ADSPCO_STOPPING |
										ADSPCO_DISCONNECTING))
		{
			done = TRUE;
		}
		RELEASE_SPIN_LOCK_DPC(&pAdspConn->adspco_Lock);
	}

	if (done)
	{
		//	Dereference connection for the timer.
		AtalkAdspConnDereference(pAdspConn);
		return ATALK_TIMER_NO_REQUEUE;
	}

	now = AtalkGetCurrentTick();
	if ((now - pAdspConn->adspco_LastContactTime) > ADSP_CONNECTION_INTERVAL)
	{
		//	Connection has expired.
		DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_ERR,
				("atalkAdspConnMaintenanceTimer: Connection %lx.%lx expired\n",
				pAdspConn, pAdspConn->adspco_LocalConnId));

		AtalkAdspDisconnect(pAdspConn,
							ATALK_TIMER_DISCONNECT,
							NULL,
							NULL);

		//	Dereference connection for the timer.
		AtalkAdspConnDereference(pAdspConn);
		return ATALK_TIMER_NO_REQUEUE;
	}

	//	If we have not heard from the other side recently, send out a
	//	probe.
	if ((now - pAdspConn->adspco_LastContactTime) > (ADSP_PROBE_INTERVAL/ATALK_TIMER_FACTOR))
	{
		KIRQL		OldIrql;

		DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_WARN,
				("atalkAdspConnMaintenanceTimer: Connection %lx.%lx sending probe\n",
				pAdspConn, pAdspConn->adspco_LocalConnId));

		ACQUIRE_SPIN_LOCK(&pAdspConn->adspco_Lock, &OldIrql);
		atalkAdspSendControl(pAdspConn,
							 ADSP_CONTROL_FLAG + ADSP_ACK_REQ_FLAG + ADSP_PROBE_OR_ACK_CODE);
		RELEASE_SPIN_LOCK(&pAdspConn->adspco_Lock, OldIrql);
	}

	return ATALK_TIMER_REQUEUE;
}




LOCAL LONG FASTCALL
atalkAdspRetransmitTimer(
	IN	PTIMERLIST		pTimer,
	IN	BOOLEAN			TimerShuttingDown
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PADSP_CONNOBJ	pAdspConn;
	BOOLEAN			done = FALSE;
	KIRQL			OldIrql;

	pAdspConn = (PADSP_CONNOBJ)CONTAINING_RECORD(pTimer, ADSP_CONNOBJ, adspco_RetransmitTimer);

	ASSERT(VALID_ADSPCO(pAdspConn));

	//	BUG #19777: Since this routine could end up calling SendData which
	//	releases/acquires lock and assumes lock was acquired using the normal
	//	acquire spin lock, we can't use ACQUIRE_SPIN_LOCK_DPC here. Not a big
	//	deal as this is the retransmit case.
	//	ACQUIRE_SPIN_LOCK_DPC(&pAdspConn->adspco_Lock);

	ACQUIRE_SPIN_LOCK(&pAdspConn->adspco_Lock, &OldIrql);
	if (TimerShuttingDown)
	{
		done = TRUE;
	}
	else
	{
		ASSERT(VALID_ADSPCO(pAdspConn));
		if (pAdspConn->adspco_Flags & (	ADSPCO_CLOSING	|
										ADSPCO_STOPPING |
										ADSPCO_DISCONNECTING))
		{
			done = TRUE;
		}
	}

	if (done)
	{
		RELEASE_SPIN_LOCK(&pAdspConn->adspco_Lock, OldIrql);

		//	Dereference connection for the timer.
		AtalkAdspConnDereference(pAdspConn);
		return ATALK_TIMER_NO_REQUEUE;
	}

	//	We only send data if the remote has not accepted any data from the last
	//	time we fired. AND we have previously sent but still unacked data pending.
	if ((pAdspConn->adspco_FirstRtmtSeq == pAdspConn->adspco_LastTimerRtmtSeq) &&
		(atalkAdspBufferQueueSize(&pAdspConn->adspco_SendQueue) >
			atalkAdspBufferQueueSize(&pAdspConn->adspco_NextSendQueue)))
	{
		DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
				("atalkAdspConnRetransmitTimer: Conn %lx Sending Data from %lx\n",
				pAdspConn, pAdspConn->adspco_FirstRtmtSeq));

		//	Rewind sequence number and resend
		pAdspConn->adspco_SendSeq		= pAdspConn->adspco_FirstRtmtSeq;
		pAdspConn->adspco_NextSendQueue = pAdspConn->adspco_SendQueue;
		atalkAdspSendData(pAdspConn);
	}
	else
	{
		pAdspConn->adspco_LastTimerRtmtSeq	= pAdspConn->adspco_FirstRtmtSeq;
	}
	RELEASE_SPIN_LOCK(&pAdspConn->adspco_Lock, OldIrql);

	return ATALK_TIMER_REQUEUE;
}




LOCAL LONG FASTCALL
atalkAdspAttnRetransmitTimer(
	IN	PTIMERLIST		pTimer,
	IN	BOOLEAN			TimerShuttingDown
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PADSP_CONNOBJ	pAdspConn;

	pAdspConn = (PADSP_CONNOBJ)CONTAINING_RECORD(pTimer, ADSP_CONNOBJ, adspco_ExRetryTimer);

	ASSERT(VALID_ADSPCO(pAdspConn));

	if (TimerShuttingDown)
	{
		return ATALK_TIMER_NO_REQUEUE;
	}

	atalkAdspSendAttn(pAdspConn);

	return ATALK_TIMER_REQUEUE;
}




LOCAL LONG FASTCALL
atalkAdspOpenTimer(
	IN	PTIMERLIST		pTimer,
	IN	BOOLEAN			TimerShuttingDown
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PADSP_CONNOBJ	pAdspConn;
	ATALK_ERROR		error;
	BOOLEAN			done = FALSE;

	pAdspConn = (PADSP_CONNOBJ)CONTAINING_RECORD(pTimer, ADSP_CONNOBJ, adspco_OpenTimer);

	ASSERT(VALID_ADSPCO(pAdspConn));

	DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
			("atalkAdspOpenTimer: Entered \n"));


	ACQUIRE_SPIN_LOCK_DPC(&pAdspConn->adspco_Lock);
	//	If the timer is shutting down, or if we have gone active, return
	if ((TimerShuttingDown) ||
		(pAdspConn->adspco_Flags & ADSPCO_ACTIVE) ||
		((pAdspConn->adspco_Flags & ADSPCO_OPEN_TIMER) == 0))
	{
		pAdspConn->adspco_Flags &= ~ADSPCO_OPEN_TIMER;
		RELEASE_SPIN_LOCK_DPC(&pAdspConn->adspco_Lock);

		AtalkAdspConnDereference(pAdspConn);
		return ATALK_TIMER_NO_REQUEUE;
	}

	if ((pAdspConn->adspco_Flags & (ADSPCO_CLOSING	|
									ADSPCO_STOPPING |
									ADSPCO_DISCONNECTING))	||

		(pAdspConn->adspco_ConnectAttempts == 0))
	{
		done = TRUE;
	}
	else
	{
		DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
				("atalkAdspOpenTimer: Connect attempt %d\n", pAdspConn->adspco_ConnectAttempts));

		ASSERT(pAdspConn->adspco_ConnectAttempts > 0);
		pAdspConn->adspco_ConnectAttempts--;
	}
	RELEASE_SPIN_LOCK_DPC(&pAdspConn->adspco_Lock);

	if (!done)
	{
		//	Resend the open request.
		atalkAdspSendOpenControl(pAdspConn);
	}
	else
	{
		error = AtalkAdspDisconnect(pAdspConn,
									ATALK_TIMER_DISCONNECT,
									NULL,
									NULL);

		DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_ERR,
				("atalkAdspOpenTimer: Disconnect %lx\n", error));

		AtalkAdspConnDereference(pAdspConn);
	}

	return (done ? ATALK_TIMER_NO_REQUEUE : ATALK_TIMER_REQUEUE);
}



LOCAL LONG FASTCALL
atalkAdspDisconnectTimer(
	IN	PTIMERLIST		pTimer,
	IN	BOOLEAN			TimerShuttingDown
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PADSP_CONNOBJ	pAdspConn;

	pAdspConn = (PADSP_CONNOBJ)CONTAINING_RECORD(pTimer, ADSP_CONNOBJ, adspco_DisconnectTimer);

	ASSERT(VALID_ADSPCO(pAdspConn));

	DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
			("atalkAdspDisconnectTimer: Entered \n"));

	AtalkAdspDisconnect(pAdspConn,
						ATALK_REMOTE_DISCONNECT,
						NULL,
						NULL);
	AtalkAdspConnDereference(pAdspConn);

	return ATALK_TIMER_NO_REQUEUE;
}


//
//	ADSP REFERENCE/DerefERENCE ROUTINES
//

VOID
atalkAdspAddrRefNonInterlock(
	IN	PADSP_ADDROBJ		pAdspAddr,
	OUT	PATALK_ERROR		pError
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	*pError = ATALK_NO_ERROR;

    if (pAdspAddr == NULL)
    {
        *pError = ATALK_INVALID_ADDRESS;
        return;
    }

	if ((pAdspAddr->adspao_Flags & ADSPAO_CLOSING) == 0)
	{
		ASSERT(pAdspAddr->adspao_RefCount >= 1);
		pAdspAddr->adspao_RefCount++;
	}
	else
	{
		*pError = ATALK_ADSP_ADDR_CLOSING;
	}
}




VOID
atalkAdspAddrDeref(
	IN	PADSP_ADDROBJ		pAdspAddr
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	BOOLEAN			done = FALSE;
	KIRQL			OldIrql;

	ACQUIRE_SPIN_LOCK(&pAdspAddr->adspao_Lock, &OldIrql);
	ASSERT(pAdspAddr->adspao_RefCount > 0);
	if (--pAdspAddr->adspao_RefCount == 0)
	{
		done = TRUE;
		ASSERT(pAdspAddr->adspao_Flags & ADSPAO_CLOSING);
	}

	RELEASE_SPIN_LOCK(&pAdspAddr->adspao_Lock, OldIrql);

	if (done)
	{
		DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
				("atalkAdspAddrDeref: Addr %lx done with.\n", pAdspAddr));

		//	Close the DDP Address Object. This should only be done after
		//	all the connections are gone.
		AtalkDdpCloseAddress(pAdspAddr->adspao_pDdpAddr, NULL, NULL);

		if (*pAdspAddr->adspao_CloseComp != NULL)
		{
			(*pAdspAddr->adspao_CloseComp)(ATALK_NO_ERROR,
										   pAdspAddr->adspao_CloseCtx);
		}

		//	Remove from the global list.
		atalkAdspAddrDeQueueGlobalList(pAdspAddr);

		AtalkFreeMemory(pAdspAddr);

		AtalkUnlockAdspIfNecessary();
	}
}




VOID
atalkAdspConnRefByPtrNonInterlock(
	IN	PADSP_CONNOBJ		pAdspConn,
	IN	ULONG				NumCount,
	OUT	PATALK_ERROR		pError
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	*pError = ATALK_NO_ERROR;
	ASSERT(VALID_ADSPCO(pAdspConn));

    if (pAdspConn == NULL)
    {
        *pError = ATALK_INVALID_CONNECTION;
        return;
    }

	if ((pAdspConn->adspco_Flags & ADSPCO_CLOSING) == 0)
	{
		ASSERT(pAdspConn->adspco_RefCount >= 1);
		ASSERT(NumCount > 0);

		pAdspConn->adspco_RefCount += NumCount;
	}
	else
	{
		*pError = ATALK_ADSP_CONN_CLOSING;
	}
}




VOID
atalkAdspConnRefByCtxNonInterlock(
	IN	PADSP_ADDROBJ		pAdspAddr,
	IN	CONNECTION_CONTEXT	Ctx,
	OUT	PADSP_CONNOBJ	*	pAdspConn,
	OUT	PATALK_ERROR		pError
	)
/*++

Routine Description:

	!!!MUST BE CALLED WITH THE ADDRESS LOCK HELD!!!

Arguments:


Return Value:


--*/
{
	PADSP_CONNOBJ	pAdspChkConn;

	*pError = ATALK_ADSP_CONN_NOT_FOUND;

	for (pAdspChkConn = pAdspAddr->adspao_pAssocConn;
		 pAdspChkConn != NULL;
		 pAdspChkConn = pAdspChkConn->adspco_pNextAssoc)
	{
		if (pAdspChkConn->adspco_ConnCtx == Ctx)
		{
			AtalkAdspConnReferenceByPtr(pAdspChkConn, pError);
			if (ATALK_SUCCESS(*pError))
			{
				*pAdspConn = pAdspChkConn;
			}

			break;
		}
	}
}




VOID
atalkAdspConnRefBySrcAddr(
	IN	PADSP_ADDROBJ	pAdspAddr,
	IN	PATALK_ADDR		pRemoteAddr,
	IN	USHORT			RemoteConnId,
	OUT	PADSP_CONNOBJ *	ppAdspConn,
	OUT	PATALK_ERROR	pError
	)
/*++

Routine Description:

	!!!MUST BE CALLED WITH THE ADDRESS LOCK HELD!!!

Arguments:


Return Value:


--*/
{
	ULONG			index;
	PADSP_CONNOBJ	pAdspConn;

	//	Thread the connection object into addr lookup by session id.
	index	= HASH_ID_SRCADDR(RemoteConnId, pRemoteAddr);

	index  %= ADSP_CONN_HASH_SIZE;

	for (pAdspConn = pAdspAddr->adspao_pActiveHash[index];
		 pAdspConn != NULL;
		 pAdspConn = pAdspConn->adspco_pNextActive)
	{
		if ((pAdspConn->adspco_RemoteConnId == RemoteConnId) &&
			(ATALK_ADDRS_EQUAL(&pAdspConn->adspco_RemoteAddr, pRemoteAddr)))
		{
			DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
					("atalkAdspConnRefBySrcAddr: Found %lx\n", pAdspConn));
			break;
		}
	}

	*pError = ATALK_INVALID_CONNECTION;
	if (pAdspConn != NULL)
	{
		KIRQL	OldIrql;

		//	Check state to make sure we are not disconnecting/stopping/closing.
		ACQUIRE_SPIN_LOCK(&pAdspConn->adspco_Lock, &OldIrql);
		if ((pAdspConn->adspco_Flags & (ADSPCO_ACTIVE | ADSPCO_HALF_ACTIVE)) &&
			((pAdspConn->adspco_Flags & (ADSPCO_CLOSING |
										ADSPCO_STOPPING|
										ADSPCO_DISCONNECTING)) == 0))
		{
			pAdspConn->adspco_RefCount++;
			*pError = ATALK_NO_ERROR;
			*ppAdspConn = pAdspConn;
		}
		RELEASE_SPIN_LOCK(&pAdspConn->adspco_Lock, OldIrql);
	}
}




VOID
atalkAdspConnRefNextNc(
	IN		PADSP_CONNOBJ		pAdspConn,
	IN		PADSP_CONNOBJ	*	ppAdspConnNext,
	OUT		PATALK_ERROR		pError
	)
/*++

Routine Description:

	MUST BE CALLED WITH THE ASSOCIATED ADDRESS LOCK HELD!

Arguments:


Return Value:


--*/
{
	PADSP_CONNOBJ	pNextConn	= NULL;

	*pError		= ATALK_FAILURE;

	ASSERT(VALID_ADSPCO(pAdspConn));

	for (; pAdspConn != NULL; pAdspConn = pAdspConn->adspco_pNextActive)
	{
		AtalkAdspConnReferenceByPtr(pAdspConn, pError);
		if (ATALK_SUCCESS(*pError))
		{
			//	Ok, this connection is referenced!
			*ppAdspConnNext = pAdspConn;
			break;
		}
	}
}



VOID
atalkAdspConnDeref(
	IN	PADSP_CONNOBJ		pAdspConn
	)
/*++

Routine Description:

	Disconnect completion happens when the reference count goes from
	2->1 if the creation reference is not already removed. If the creation
	reference is already removed, it will be done when the refcount goes
	from 1->0.

	Creation reference is never removed until cleanup completes.

Arguments:


Return Value:


--*/
{
	BOOLEAN			fEndProcessing = FALSE;
	KIRQL			OldIrql;

	ASSERT(VALID_ADSPCO(pAdspConn));
	ACQUIRE_SPIN_LOCK(&pAdspConn->adspco_Lock, &OldIrql);

	ASSERT(pAdspConn->adspco_RefCount > 0);
	--pAdspConn->adspco_RefCount;

	if (pAdspConn->adspco_RefCount > 1)
	{
		fEndProcessing = TRUE;
	}
	RELEASE_SPIN_LOCK(&pAdspConn->adspco_Lock, OldIrql);

	if (fEndProcessing)
	{
		return;
	}
	else
	{
		ATALK_ERROR				disconnectStatus;
		PADSP_ADDROBJ			pAdspAddr	= pAdspConn->adspco_pAssocAddr;
		BOOLEAN					done		= FALSE;
		BOOLEAN					disconnDone = FALSE;
		BOOLEAN					pendingRead = FALSE;
		BOOLEAN					pendingWrite= FALSE;
		BOOLEAN					stopping	= FALSE;
		GENERIC_COMPLETION		disconnectInform		= NULL;
		PVOID					disconnectInformCtx		= NULL;
		GENERIC_COMPLETION		disconnectCompletion	= NULL;
		PVOID					disconnectCtx			= NULL;
		PVOID					cleanupCtx				= NULL;
		GENERIC_COMPLETION		cleanupCompletion		= NULL;

		//	We allow stopping phase to happen only after disconnecting is done.
		//	If disconnecting is not set and stopping is, it implies we are only
		//	in an associated state.
		ACQUIRE_SPIN_LOCK(&pAdspConn->adspco_Lock, &OldIrql);
		stopping	= (pAdspConn->adspco_Flags & ADSPCO_STOPPING) ? TRUE : FALSE;
		if (pAdspConn->adspco_Flags & ADSPCO_DISCONNECTING)
		{
			DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
					("atalkAdspConnDeref: Disconnect set for %lx\n", pAdspConn));

			//	Are we done disconnecting? Since cleanup wont complete until disc
			//	does, we don't have to worry about the creation ref having gone
			//	away.
			if (pAdspConn->adspco_RefCount == 1)
			{
				DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
						("atalkAdspConnDeref: Disconnect done (1) %lx\n", pAdspConn));

				//	Avoid multiple disconnect completions/close atp addresses
				//	Remember all the disconnect info before we release the lock
				disconnectInform		= pAdspConn->adspco_DisconnectInform;
				disconnectInformCtx		= pAdspConn->adspco_DisconnectInformCtx;
				disconnectStatus		= pAdspConn->adspco_DisconnectStatus;
				disconnectCompletion	= pAdspConn->adspco_DisconnectCompletion;
				disconnectCtx			= pAdspConn->adspco_DisconnectCtx;

				//	Reset all the be null, so next request doesnt get any
				pAdspConn->adspco_DisconnectInform		= NULL;
				pAdspConn->adspco_DisconnectInformCtx	= NULL;
				pAdspConn->adspco_DisconnectCompletion	= NULL;
				pAdspConn->adspco_DisconnectCtx			= NULL;

				disconnDone = TRUE;
				stopping	= (pAdspConn->adspco_Flags & ADSPCO_STOPPING) ? TRUE : FALSE;
			}
			else
			{
				//	Set stopping to false as disconnect is not done yet.
				stopping = FALSE;
			}
		}

		if (pAdspConn->adspco_RefCount == 0)
		{
			done = TRUE;
			ASSERT(pAdspConn->adspco_Flags & ADSPCO_CLOSING);
		}
		RELEASE_SPIN_LOCK(&pAdspConn->adspco_Lock, OldIrql);

		if (disconnDone)
		{
			//	Remove from the active queue.
			//	Reset all relevent flags.
			ACQUIRE_SPIN_LOCK(&pAdspAddr->adspao_Lock, &OldIrql);
			ACQUIRE_SPIN_LOCK_DPC(&pAdspConn->adspco_Lock);

			pAdspConn->adspco_Flags	&=	~(ADSPCO_LISTENING	|
										  ADSPCO_CONNECTING	|
										  ADSPCO_HALF_ACTIVE|
										  ADSPCO_ACTIVE		|
										  ADSPCO_DISCONNECTING);

			atalkAdspConnDeQueueActiveList(pAdspAddr, pAdspConn);

            // if the address has been disassociated, time to unlink it.
            if (!(pAdspConn->adspco_Flags & ADSPCO_ASSOCIATED))
            {
		        pAdspConn->adspco_pAssocAddr = NULL;
            }

			RELEASE_SPIN_LOCK_DPC(&pAdspConn->adspco_Lock);
			RELEASE_SPIN_LOCK(&pAdspAddr->adspao_Lock, OldIrql);

			//	Call the disconnect completion routines.
			if (*disconnectInform != NULL)
			{
				(*disconnectInform)(disconnectStatus, disconnectInformCtx);
			}

			if (*disconnectCompletion != NULL)
			{
				(*disconnectCompletion)(disconnectStatus, disconnectCtx);
			}
		}

		if (stopping)
		{
			ACQUIRE_SPIN_LOCK(&pAdspConn->adspco_Lock, &OldIrql);
			if ((pAdspConn->adspco_Flags & ADSPCO_STOPPING) != 0)
			{
				BOOLEAN	fDisassoc = FALSE;

				//	See if we do the cleanup irp completion.
				if (pAdspConn->adspco_RefCount == 1)
				{
					cleanupCtx			= pAdspConn->adspco_CleanupCtx;
					cleanupCompletion	= pAdspConn->adspco_CleanupComp;
					pAdspConn->adspco_CleanupComp = NULL;
					pAdspConn->adspco_Flags &= ~ADSPCO_STOPPING;

					DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
							("atalkAdspConnDeref: Cleanup on %lx.%lx\n", pAdspConn, cleanupCtx));

					if ((pAdspConn->adspco_Flags & (ADSPCO_LISTENING	|
													ADSPCO_CONNECTING	|
													ADSPCO_ACTIVE)) == 0)
					{
						DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
								("atalkAdspConnDeref: Stopping - do disassoc for %lx\n", pAdspConn));

						fDisassoc = (pAdspConn->adspco_Flags & ADSPCO_ASSOCIATED) ? TRUE: FALSE;
					}
				}
				RELEASE_SPIN_LOCK(&pAdspConn->adspco_Lock, OldIrql);

				if (fDisassoc)
				{
					//	Call the disassociate routine. This should just fail, if the
					//	connection is still active or any other state than just
					//	plain associated.
					AtalkAdspDissociateAddress(pAdspConn);
				}
			}
			else
			{
				RELEASE_SPIN_LOCK(&pAdspConn->adspco_Lock, OldIrql);
			}
		}

		if (done)
		{
			DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
					("atalkAdspConnDeref: Close done for %lx\n", pAdspConn));

			//	Call the close completion routines
			ASSERT(*pAdspConn->adspco_CloseComp != NULL);
			if (*pAdspConn->adspco_CloseComp != NULL)
			{
				(*pAdspConn->adspco_CloseComp )(ATALK_NO_ERROR,
												pAdspConn->adspco_CloseCtx);
			}

			//	Remove from the global list.
			atalkAdspConnDeQueueGlobalList(pAdspConn);

			//	Free up the connection memory.
			DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
					("atalkAdspConnDeref: Freeing up connection %lx\n", pAdspConn));

			AtalkUnlockAdspIfNecessary();
			AtalkFreeMemory(pAdspConn);
		}

		if (*cleanupCompletion != NULL)
		{
			(*cleanupCompletion)(ATALK_NO_ERROR, cleanupCtx);
		}
	}
}




//
//	ADSP BUFFER QUEUE MANAGEMENT ROUTINES
//

ULONG
atalkAdspMaxSendSize(
	IN	PADSP_CONNOBJ		pAdspConn
	)
/*++

Routine Description:

	The answer is the remaining available (to fill) space in the retransmit
	queue -- this includes data we're saving for possible retransmit as well
	as data we haven't sent yet.  Actually, this could go negative because
	BufferQueueSize counts EOMs and sendQueueMax doesn't -- answer with zero
	if this happens.

Arguments:


Return Value:


--*/
{
	LONG	sendSize;

	sendSize = pAdspConn->adspco_SendQueueMax -
			   atalkAdspBufferQueueSize(&pAdspConn->adspco_SendQueue);

	if (sendSize < 0)
	{
		sendSize = 0;
	}

	return ((ULONG)sendSize);
}




ULONG
atalkAdspMaxNextReadSize(
	IN	PBUFFER_QUEUE	pQueue,
	OUT	PBOOLEAN		pEom,
	OUT	PBUFFER_CHUNK *	pBufferChunk
	)
/*++

Routine Description:

	Return the size of data in a buffer queue; upto the end of the
	current chunk, or to the eom.

Arguments:


Return Value:


--*/
{
	PBUFFER_CHUNK	pCurrentChunk;
	ULONG			nextReadSize;
	ULONG			startIndex		= pQueue->bq_StartIndex;

	ASSERT(((pQueue->bq_Head == NULL) && (pQueue->bq_Tail == NULL)) ||
		   ((pQueue->bq_Head != NULL) && (pQueue->bq_Tail != NULL)));

	*pEom = FALSE;

	//	Walk the queue.
	for (pCurrentChunk = pQueue->bq_Head;
		 pCurrentChunk != NULL;
		 pCurrentChunk = pCurrentChunk->bc_Next)
	{
		//	Check for nothing in the current chunk
		if (startIndex == (ULONG)(pCurrentChunk->bc_DataSize +
									BYTECOUNT(pCurrentChunk->bc_Flags & BC_EOM)))
		{
			startIndex = 0;
			continue;
		}

		nextReadSize = pCurrentChunk->bc_DataSize - startIndex;
		if (pCurrentChunk->bc_Flags & BC_EOM)
		{
			*pEom	   = TRUE;
		}

		*pBufferChunk = pCurrentChunk;
		break;
	}

	//	Return the size.
	return nextReadSize;
}




ULONG
atalkAdspDescribeFromBufferQueue(
	IN	PBUFFER_QUEUE	pQueue,
	OUT	PBOOLEAN		pEom,
	IN	ULONG			WindowSize,
	OUT	PBUFFER_CHUNK *	ppBufferChunk,
	OUT	PBUFFER_DESC  * ppBuffDesc
	)
/*++

Routine Description:

	In order to avoid pQueue (nextSendQueue) to go to null when all the data available
	is being sent, we make it logically be at the end while still pointing to the
	buffer chunk. This is the reason, we have all the datasize == (startindex + eom)
	checks. This is where such a condition will be created.

	NO! We let pQueue go to null when all the data is done, otherwise we will have
	pointers to a buffer chunk that will be freed during discard, and we dont want to
	make discard dependent upon the auxqueue.

Arguments:


Return Value:


--*/
{
	PBUFFER_CHUNK	pCurrentChunk;
	PBUFFER_DESC	pBuffDesc;
	ULONG			nextReadSize	= 0;
	ULONG			startIndex		= pQueue->bq_StartIndex;

	*pEom			= FALSE;
	*ppBufferChunk	= NULL;
	*ppBuffDesc		= NULL;

	ASSERT(((pQueue->bq_Head == NULL) && (pQueue->bq_Tail == NULL)) ||
		   ((pQueue->bq_Head != NULL) && (pQueue->bq_Tail != NULL)));

	//	Walk the queue.
	for (pCurrentChunk = pQueue->bq_Head;
		 pCurrentChunk != NULL;
		 pCurrentChunk = pCurrentChunk->bc_Next)
	{
		//	Check for nothing in the current chunk
		if (startIndex == (ULONG)(pCurrentChunk->bc_DataSize +
									BYTECOUNT(pCurrentChunk->bc_Flags & BC_EOM)))
		{
			ASSERT(0);
			startIndex = 0;
			continue;
		}

		nextReadSize	= pCurrentChunk->bc_DataSize - startIndex;

		//	Look at eom only if chunk is consumed.
		*pEom			= FALSE;
		ASSERT(nextReadSize <= pCurrentChunk->bc_DataSize);

		//	Make sure dataSize is within bounds
		if (nextReadSize > ADSP_MAX_DATA_SIZE)
		{
			nextReadSize = ADSP_MAX_DATA_SIZE;
		}

		if (nextReadSize > (ULONG)WindowSize)
		{
			nextReadSize = (ULONG)WindowSize;
		}

		if (nextReadSize > 0)
		{
			//	First try to reference the buffer chunk. This should always succeed.
			atalkAdspBufferChunkReference(pCurrentChunk);

			//	Create a descriptor for the data. The above reference goes away in a send
			//	complete.
			pBuffDesc = AtalkDescribeBuffDesc((PBYTE)pCurrentChunk + sizeof(BUFFER_CHUNK) + startIndex,
											   NULL,
											   (USHORT)nextReadSize,
											   BD_CHAR_BUFFER);

			*ppBufferChunk	= pCurrentChunk;
			*ppBuffDesc		= pBuffDesc;
		}

		//	Also update the queue for this data. Either we have consumed
		//	this chunk or we have just used a portion of it.
		if ((nextReadSize + startIndex) == pCurrentChunk->bc_DataSize)
		{
			DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
					("atalkAdspDescribeFromBufferQueue: Chunk consumed %d\n",
					pCurrentChunk->bc_DataSize));

			ASSERT(pQueue->bq_Head != NULL);

			//	Set EOM if chunk had one.
			if (pCurrentChunk->bc_Flags & BC_EOM)
			{
				*pEom	   = TRUE;
			}

			if (pQueue->bq_Head == pQueue->bq_Tail)
			{
				ASSERT(pQueue->bq_Head->bc_Next == NULL);
				pQueue->bq_Tail = pQueue->bq_Head->bc_Next;
				ASSERT(pQueue->bq_Tail == NULL);
			}

			pQueue->bq_Head		= pQueue->bq_Head->bc_Next;
			pQueue->bq_StartIndex	= (ULONG)0;
		}
		else
		{
			DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
					("atalkAdspDescribeFromBufferQueue: Chunk not consumed %d.%d\n",
					pCurrentChunk->bc_DataSize, nextReadSize+startIndex));

			//	Just set the start index
			pQueue->bq_StartIndex  += (ULONG)nextReadSize;
		}

		break;
	}

	//	Return the size.
	return nextReadSize;
}



ULONG
atalkAdspBufferQueueSize(
	IN	PBUFFER_QUEUE	pQueue
	)
/*++

Routine Description:

	Return the total size of a buffer queue; each EOM counts as a single
	byte.

Arguments:


Return Value:


--*/
{
	PBUFFER_CHUNK	pCurrentChunk;
	ULONG			startIndex;
	ULONG			queueSize;

	ASSERT(((pQueue->bq_Head == NULL) && (pQueue->bq_Tail == NULL)) ||
		   ((pQueue->bq_Head != NULL) && (pQueue->bq_Tail != NULL)));

	//	Walk the queue.
	for (queueSize	= 0, startIndex	= pQueue->bq_StartIndex, pCurrentChunk = pQueue->bq_Head;
		 pCurrentChunk != NULL;
		 pCurrentChunk = pCurrentChunk->bc_Next)
	{
		//	Check for nothing in the current chunk.
		if (startIndex == (ULONG)(pCurrentChunk->bc_DataSize +
									BYTECOUNT(pCurrentChunk->bc_Flags & BC_EOM)))
		{
			startIndex = 0;
			continue;
		}

		queueSize += (	pCurrentChunk->bc_DataSize -
						startIndex +
						BYTECOUNT(pCurrentChunk->bc_Flags & BC_EOM));

		//	StartIndex only counts in first chunk
		startIndex = 0;
	}

	//	Return the size.
	return queueSize;
}




ULONG
atalkAdspMessageSize(
	IN	PBUFFER_QUEUE	pQueue,
	OUT	PBOOLEAN		pEom
	)
/*++

Routine Description:

	Return the total size of the data in the buffer queue, stopping at eom
	or end of data. EOM is not part of the count.

Arguments:


Return Value:


--*/
{
	PBUFFER_CHUNK	pCurrentChunk;
	ULONG			msgSize	= 0;
	ULONG			startIndex	= pQueue->bq_StartIndex;

	ASSERT(((pQueue->bq_Head == NULL) && (pQueue->bq_Tail == NULL)) ||
		   ((pQueue->bq_Head != NULL) && (pQueue->bq_Tail != NULL)));

	*pEom	= FALSE;

	//	Walk the queue.
	for (pCurrentChunk = pQueue->bq_Head;
		 pCurrentChunk != NULL;
		 pCurrentChunk = pCurrentChunk->bc_Next)
	{
		//	Check for nothing in the current chunk.
		if (startIndex == (ULONG)(pCurrentChunk->bc_DataSize +
									BYTECOUNT(pCurrentChunk->bc_Flags & BC_EOM)))
		{
			startIndex = 0;
			continue;
		}

		msgSize += (pCurrentChunk->bc_DataSize - startIndex);
		if (pCurrentChunk->bc_Flags & BC_EOM)
		{
			*pEom	= TRUE;
			break;
		}

		//	StartIndex only counts in first chunk
		startIndex = 0;
	}

	//	Return the size.
	return msgSize;
}




PBUFFER_CHUNK
atalkAdspAllocCopyChunk(
	IN	PVOID	pWriteBuf,
	IN	USHORT	WriteBufLen,
	IN	BOOLEAN	Eom,
	IN	BOOLEAN	IsCharBuffer
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PBUFFER_CHUNK	pChunk;
	PBYTE			pData;
	NTSTATUS		status;
	ULONG			bytesCopied;

	if ((pChunk = (PBUFFER_CHUNK)AtalkAllocMemory(sizeof(BUFFER_CHUNK) + WriteBufLen)) != NULL)
	{

		pChunk->bc_DataSize = WriteBufLen;
		pChunk->bc_Flags	= (Eom ? BC_EOM : 0);
		pChunk->bc_Next		= NULL;
		pChunk->bc_RefCount	= 1;			// Creation ref count

		INITIALIZE_SPIN_LOCK(&pChunk->bc_Lock);

		//	Copy the data over if its greater than zero
		if (WriteBufLen > 0)
		{
			pData = (PBYTE)pChunk + sizeof(BUFFER_CHUNK);
			if (IsCharBuffer)
			{
				RtlCopyMemory(pData,
							  (PBYTE)pWriteBuf,
							  WriteBufLen);
			}
			else
			{
				status = TdiCopyMdlToBuffer((PMDL)pWriteBuf,
											0,
											pData,
											0,
											WriteBufLen,
											&bytesCopied);

				ASSERT(!NT_ERROR(status) && (bytesCopied == (ULONG)WriteBufLen));
			}
		}
	}

	return pChunk;
}




PBYTE
atalkAdspGetLookahead(
	IN	PBUFFER_QUEUE	pQueue,
	OUT	PULONG			pLookaheadSize
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PBUFFER_CHUNK	pCurrentChunk;
	ULONG			startIndex	= pQueue->bq_StartIndex;

	ASSERT(((pQueue->bq_Head == NULL) && (pQueue->bq_Tail == NULL)) ||
		   ((pQueue->bq_Head != NULL) && (pQueue->bq_Tail != NULL)));

	pCurrentChunk = pQueue->bq_Head;
	if (pCurrentChunk != NULL)
	{
		//	Do we need to go past the current chunk?
		if (startIndex == (ULONG)(pCurrentChunk->bc_DataSize +
									BYTECOUNT(pCurrentChunk->bc_Flags & BC_EOM)))
		{
			pCurrentChunk	= pCurrentChunk->bc_Next;
			startIndex		= 0;
		}
	}

	ASSERT(pCurrentChunk != NULL);
	if (pCurrentChunk == NULL)
	{
		KeBugCheck(0);
	}

	*pLookaheadSize = pCurrentChunk->bc_DataSize - startIndex;
	return((*pLookaheadSize == 0) ?
			NULL	:
			(PBYTE)pCurrentChunk + sizeof(BUFFER_CHUNK) + startIndex);
}




VOID
atalkAdspAddToBufferQueue(
	IN	OUT	PBUFFER_QUEUE	pQueue,
	IN		PBUFFER_CHUNK	pChunk,
	IN	OUT	PBUFFER_QUEUE	pAuxQueue	OPTIONAL
	)
/*++

Routine Description:

	!!!MUST BE CALLED WITH THE CONNECTION LOCK HELD!!!

Arguments:


Return Value:


--*/
{
	ASSERT(((pQueue->bq_Head == NULL) && (pQueue->bq_Tail == NULL)) ||
		   ((pQueue->bq_Head != NULL) && (pQueue->bq_Tail != NULL)));

	if (pQueue->bq_Head != NULL)
	{
		//	Add the chunk to the end of the queue
		ASSERT(pQueue->bq_Tail != NULL);
		pQueue->bq_Tail->bc_Next = pChunk;
		pQueue->bq_Tail	= pChunk;

		ASSERT(pChunk->bc_Next == NULL);

		//	The auxiliary queue is the nextsend queue, which can go to null
		//	if we have sent all the data. If that is the case, we need to
		//	reset the head also.
		if (ARGUMENT_PRESENT(pAuxQueue))
		{
			if (pAuxQueue->bq_Head	== NULL)
			{
				pAuxQueue->bq_Head	= pChunk;
			}

			pAuxQueue->bq_Tail	= pChunk;
		}
	}
	else
	{
		pQueue->bq_Head			= pQueue->bq_Tail	= pChunk;
		pQueue->bq_StartIndex	= (ULONG)0;
		if (ARGUMENT_PRESENT(pAuxQueue))
		{
			//	Initialize the next send queue only if this is a send queue
			pAuxQueue->bq_Head		= pAuxQueue->bq_Tail = pChunk;
			pAuxQueue->bq_StartIndex= (ULONG)0;
		}
	}
}




ULONG
atalkAdspReadFromBufferQueue(
	IN		PBUFFER_QUEUE	pQueue,
	IN		ULONG			ReadFlags,
	OUT		PAMDL			pReadBuf,
	IN	OUT	PUSHORT			pReadLen,
	OUT		PBOOLEAN		pEom
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PBUFFER_CHUNK	pCurrentChunk;
	ULONG			bytesRead, copySize, dataIndex, dataSize, lastReadIndex;
	NTSTATUS		status;
	LONG			startIndex	= pQueue->bq_StartIndex;
	ATALK_ERROR		error		= ATALK_NO_ERROR;
	ULONG			readSize	= 0;					// size counting eom

	ASSERT(((pQueue->bq_Head == NULL) && (pQueue->bq_Tail == NULL)) ||
		   ((pQueue->bq_Head != NULL) && (pQueue->bq_Tail != NULL)));

	*pEom			= FALSE;
	readSize		= 0;
	pCurrentChunk	= pQueue->bq_Head;
	if ((pCurrentChunk == NULL) ||
		((pCurrentChunk->bc_Next == NULL) &&
		 ((ULONG)startIndex ==	pCurrentChunk->bc_DataSize +
									BYTECOUNT(pCurrentChunk->bc_Flags & BC_EOM))))
	{
		*pReadLen	= 0;
		return 0;
	}

	dataIndex	= 0;
	dataSize	= *pReadLen;

	//	Copy data until we exhaust src/dest buffers or hit an eom
	for (;
		 pCurrentChunk != NULL;
		 pCurrentChunk = pCurrentChunk->bc_Next)
	{
		if ((ULONG)startIndex == pCurrentChunk->bc_DataSize +
									BYTECOUNT(pCurrentChunk->bc_Flags & BC_EOM))
		{
			ASSERT(0);
			startIndex = 0;
			continue;
		}

		copySize = MIN((ULONG)(pCurrentChunk->bc_DataSize - startIndex), dataSize);
		if (copySize > 0)
		{
			status = TdiCopyBufferToMdl((PBYTE)pCurrentChunk +
											sizeof(BUFFER_CHUNK) +
											startIndex,
										0,
										copySize,
										pReadBuf,
										dataIndex,
										&bytesRead);

			ASSERT(NT_SUCCESS(status) && (copySize == bytesRead));
		}

		dataIndex		+= copySize;
		readSize		+= copySize;
		dataSize		-= copySize;
		lastReadIndex	=  startIndex + copySize;

		//	Check for terminating conditions
		startIndex = 0;

		//	Check EOM only if chunk consumed.
		if ((lastReadIndex == pCurrentChunk->bc_DataSize) &&
			(pCurrentChunk->bc_Flags & BC_EOM))
		{
			readSize	+= 1;
			*pEom = TRUE;
			break;
		}

		if (dataSize == 0)		//	Is the user buffer full?
		{
			break;
		}
	}

	*pReadLen	= (USHORT)dataIndex;

	//	Free any chunks that we are done with, only if this was not a peek request.
	if ((ReadFlags & TDI_RECEIVE_PEEK) == 0)
	{
		DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
				("atalkAdspReadFromBufferQueue: Discarding data %lx\n", dataIndex));

		atalkAdspDiscardFromBufferQueue(pQueue,
										readSize,
										NULL,
										ATALK_NO_ERROR,
										NULL);
	}

	return dataIndex;
}




BOOLEAN
atalkAdspDiscardFromBufferQueue(
	IN		PBUFFER_QUEUE	pQueue,
	IN		ULONG			DataSize,
	OUT		PBUFFER_QUEUE	pAuxQueue,
	IN		ATALK_ERROR		Error,
	IN		PADSP_CONNOBJ	pAdspConn	OPTIONAL	//	Required for send queue
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PBUFFER_CHUNK	pCurrentChunk, pNextChunk;
	ULONG			chunkSize, startIndex = pQueue->bq_StartIndex;

	//	BUBBUG:	error checks

	//	Walk along the queue discarding the data we have already read
	for (pCurrentChunk = pQueue->bq_Head, pNextChunk = NULL;
		 pCurrentChunk != NULL;
		 pCurrentChunk = pNextChunk)
	{
		pNextChunk = pCurrentChunk->bc_Next;

		chunkSize = pCurrentChunk->bc_DataSize -
						startIndex + BYTECOUNT(pCurrentChunk->bc_Flags & BC_EOM);

		DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
				("atalkAdspDiscardFromBufferQueue: Discarding %ld.%ld\n", DataSize, chunkSize));

		//	If we finished discarding but there is still some data left in the
		//	current chunk, just reset the start index.
		if (DataSize < chunkSize)
		{
			// Already done: pQueue->bq_Head = pCurrentChunk;
			pQueue->bq_StartIndex	= startIndex + DataSize;

			ASSERT((pQueue->bq_Head != pQueue->bq_Tail) ||
					(pCurrentChunk->bc_Next == NULL));

			return TRUE;
		}

		//	Otherwise, we have discarded a whole chunk
		if ((pAuxQueue != NULL) &&
			(pAuxQueue->bq_Head == pCurrentChunk) &&
			((pAuxQueue->bq_Head->bc_Next != NULL) ||
			 (pAuxQueue->bq_StartIndex <
				(pAuxQueue->bq_Head->bc_DataSize +
					(ULONG)BYTECOUNT(pAuxQueue->bq_Head->bc_Flags & BC_EOM)))))
		{
			ASSERT(0);
			pAuxQueue->bq_Head			= pAuxQueue->bq_Tail = NULL;
			pAuxQueue->bq_StartIndex	= (ULONG)0;
		}

		//	If SEND chunk, set error for the send to be success
		if (pCurrentChunk->bc_Flags & BC_SEND)
		{
			pCurrentChunk->bc_WriteError	= Error;
			ASSERT(pAdspConn != NULL);
		}

                //
                // make our head point to the next guy since this chunk is going away.
                //
                pQueue->bq_Head = pNextChunk;
                pQueue->bq_StartIndex = 0;

                if (pQueue->bq_Tail == pCurrentChunk)
                {
                    pQueue->bq_Tail = NULL;
                }

		//	Deref for creation.
		atalkAdspBufferChunkDereference(pCurrentChunk,
										TRUE,
										pAdspConn);

		//	Move on to the next chunk
		DataSize	-= chunkSize;
		startIndex	 = 0;
	}

	//	If we are here, then the whole queue has been discarded, mark
	//	it as empty
	ASSERT(DataSize == 0);

	//pQueue->bq_Head = pQueue->bq_Tail = NULL;
	//pQueue->bq_StartIndex = 0;

        //
        // if the last chunk gets freed above, we release the spinlock to complete the
        // irp associated with the chunk and then grab it again.  It's possible to get
        // a new send in that window, so bq_head may not necessarily be NULL at this
        // point (in fact, bug #16660 turned out to be exactly this!!)
        //
	if (pQueue->bq_Head == NULL)
        {
            ASSERT(pQueue->bq_Tail == NULL);

            if (pAuxQueue != NULL)
	    {
		pAuxQueue->bq_Head = pAuxQueue->bq_Tail = NULL;
		pAuxQueue->bq_StartIndex = (LONG)0;
            }
	}

	return TRUE;
}




VOID
atalkAdspBufferChunkReference(
	IN	PBUFFER_CHUNK		pBufferChunk
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	KIRQL	OldIrql;

	ACQUIRE_SPIN_LOCK(&pBufferChunk->bc_Lock, &OldIrql);
	if ((pBufferChunk->bc_Flags & BC_CLOSING) == 0)
	{
		pBufferChunk->bc_RefCount++;
	}
	else
	{
		//	Should never be trying to reference this when closing. The retransmit
		//	timer should have been cancelled.
		KeBugCheck(0);
	}
	RELEASE_SPIN_LOCK(&pBufferChunk->bc_Lock, OldIrql);
}




VOID
atalkAdspBufferChunkDereference(
	IN	PBUFFER_CHUNK		pBufferChunk,
	IN	BOOLEAN				CreationDeref,
	IN	PADSP_CONNOBJ		pAdspConn	OPTIONAL	//	Required for send chunk
													//	If spinlock held
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	BOOLEAN	done		= FALSE;
	BOOLEAN	sendChunk	= FALSE;
	KIRQL	OldIrql;


	ACQUIRE_SPIN_LOCK(&pBufferChunk->bc_Lock, &OldIrql);
	if (!CreationDeref ||
		((pBufferChunk->bc_Flags & BC_CLOSING) == 0))
	{
		if (CreationDeref)
		{
			pBufferChunk->bc_Flags |= BC_CLOSING;
		}

		if (--pBufferChunk->bc_RefCount == 0)
		{
			ASSERT(pBufferChunk->bc_Flags & BC_CLOSING);
			done		= TRUE;
			sendChunk	= (pBufferChunk->bc_Flags & BC_SEND) ? TRUE : FALSE;
		}
	}
	RELEASE_SPIN_LOCK(&pBufferChunk->bc_Lock, OldIrql);

	if (done)
	{
		//	Call send completion if this is a send buffer chunk
		if (sendChunk)
		{
			DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
					("atalkChunkDereference: Completing send %lx. %lx - %d.%d\n",
					pAdspConn, pBufferChunk->bc_WriteCtx,
					pBufferChunk->bc_DataSize, pBufferChunk->bc_WriteError));

			if (pAdspConn != NULL)
			{
				DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
						("atalkChunkDereference: Completing send %lx.%lx\n",
						pAdspConn, pBufferChunk->bc_WriteCtx));

				//	Release connection lock
				RELEASE_SPIN_LOCK(&pAdspConn->adspco_Lock, OldIrql);
			}

			//	Call the completion routine. We complete with no error, but
			//	need to return pending.
			ASSERT((*pBufferChunk->bc_WriteCompletion) != NULL);
			(*pBufferChunk->bc_WriteCompletion)(pBufferChunk->bc_WriteError,
												pBufferChunk->bc_WriteBuf,
												pBufferChunk->bc_DataSize,
												pBufferChunk->bc_WriteCtx);

			if (pAdspConn != NULL)
			{
				ACQUIRE_SPIN_LOCK(&pAdspConn->adspco_Lock, &OldIrql);
			}
		}


		//	This better not be part of the queues at this point, we should
		//	just be able to free it up. The idea is that if a particular
		//	buffer descriptor has its creation reference removed, its only
		//	because the data is being discarded or the connection is shutting
		//	down, in both cases, the data previous to this must be also being
		//	discarded and the buffer queue pointers will be set to the chunks
		//	following the ones being discarded. If this wont be true, walk the
		//	list (need more info coming in) and unlink this chunk before freeing
		//	it.
		AtalkFreeMemory(pBufferChunk);
	}
}




//
//	ADSP UTILITY ROUTINES
//


VOID
atalkAdspDecodeHeader(
	IN	PBYTE	Datagram,
	OUT	PUSHORT	RemoteConnId,
	OUT	PULONG	FirstByteSeq,
	OUT	PULONG	NextRecvSeq,
	OUT	PLONG	Window,
	OUT	PBYTE	Descriptor
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	GETSHORT2SHORT(RemoteConnId, Datagram + ADSP_SRC_CONNID_OFF);

	GETDWORD2DWORD(FirstByteSeq, Datagram + ADSP_FIRST_BYTE_SEQNUM_OFF);

	GETDWORD2DWORD(NextRecvSeq, Datagram + ADSP_NEXT_RX_BYTESEQNUM_OFF);

	GETSHORT2DWORD(Window, Datagram + ADSP_RX_WINDOW_SIZE_OFF);

	//	Set the descriptor
	*Descriptor = Datagram[ADSP_DESCRIPTOR_OFF];
}




LOCAL USHORT
atalkAdspGetNextConnId(
	IN	PADSP_ADDROBJ	pAdspAddr,
	OUT	PATALK_ERROR	pError
	)
/*++

Routine Description:

	CALLED WITH THE ADDRESS SPIN LOCK HELD!

Arguments:


Return Value:


--*/
{
	PADSP_CONNOBJ	pAdspConn;
	USHORT			i;
	USHORT			startConnId, connId;
	ATALK_ERROR		error = ATALK_NO_ERROR;

	startConnId = connId = ++pAdspAddr->adspao_NextConnId;
	while (TRUE)
	{
		for (i = 0; i < ADSP_CONN_HASH_SIZE; i++)
		{
			for (pAdspConn = pAdspAddr->adspao_pActiveHash[i];
				((pAdspConn != NULL) && (pAdspConn->adspco_LocalConnId != connId));
				pAdspConn = pAdspConn->adspco_pNextActive);

			if (pAdspConn != NULL)
				break;
		}

		if (pAdspConn == NULL)
		{
			break;
		}
		else
		{
			if (connId == (startConnId - 1))
			{
				ASSERT(0);

				//	We wrapped around and there are no more conn ids.
				error = ATALK_RESR_MEM;
				break;
			}
			connId++;
		}
	}

	DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
			("atalkAdspGetNextConnId: ConnId %lx for %lx\n", connId, pAdspAddr));

	*pError = error;
	return(ATALK_SUCCESS(error) ? connId : 0);
}




LOCAL	BOOLEAN
atalkAdspConnDeQueueAssocList(
	IN	PADSP_ADDROBJ	pAdspAddr,
	IN	PADSP_CONNOBJ	pAdspConn
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PADSP_CONNOBJ	pAdspRemConn, *ppAdspRemConn;
	BOOLEAN			removed = FALSE;

	for (ppAdspRemConn = &pAdspAddr->adspao_pAssocConn;
		 ((pAdspRemConn = *ppAdspRemConn) != NULL); )
	{
		if (pAdspRemConn == pAdspConn)
		{
			removed = TRUE;
			*ppAdspRemConn = pAdspRemConn->adspco_pNextAssoc;
			break;
		}
		else
		{
			ppAdspRemConn = &pAdspRemConn->adspco_pNextAssoc;
		}
	}

	return removed;
}




LOCAL	BOOLEAN
atalkAdspConnDeQueueConnectList(
	IN	PADSP_ADDROBJ	pAdspAddr,
	IN	PADSP_CONNOBJ	pAdspConn
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PADSP_CONNOBJ	pAdspRemConn, *ppAdspRemConn;
	BOOLEAN			removed = FALSE;

	ASSERT(pAdspAddr->adspao_Flags & ADSPAO_CONNECT);

	for (ppAdspRemConn = &pAdspAddr->adspao_pConnectConn;
			((pAdspRemConn = *ppAdspRemConn) != NULL); )
	{
		if (pAdspRemConn == pAdspConn)
		{
			removed = TRUE;
			*ppAdspRemConn = pAdspRemConn->adspco_pNextConnect;

			DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
					("atalkAdspConnDeQueueConnectList: Removed connect conn %lx\n", pAdspConn));
			break;
		}
		else
		{
			ppAdspRemConn = &pAdspRemConn->adspco_pNextConnect;
		}
	}

	return removed;
}




LOCAL	BOOLEAN
atalkAdspConnDeQueueListenList(
	IN	PADSP_ADDROBJ	pAdspAddr,
	IN	PADSP_CONNOBJ	pAdspConn
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PADSP_CONNOBJ	pAdspRemConn, *ppAdspRemConn;
	BOOLEAN			removed = FALSE;

	ASSERT(pAdspAddr->adspao_Flags & ADSPAO_LISTENER);

	for (ppAdspRemConn = &pAdspAddr->adspao_pListenConn;
			((pAdspRemConn = *ppAdspRemConn) != NULL); )
	{
		if (pAdspRemConn == pAdspConn)
		{
			removed = TRUE;
			*ppAdspRemConn = pAdspRemConn->adspco_pNextListen;

			DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
					("atalkAdspConnDeQueueListenList: Removed listen conn %lx\n", pAdspConn));
		}
		else
		{
			ppAdspRemConn = &pAdspRemConn->adspco_pNextListen;
		}
	}

	return removed;
}




LOCAL	BOOLEAN
atalkAdspConnDeQueueActiveList(
	IN	PADSP_ADDROBJ	pAdspAddr,
	IN	PADSP_CONNOBJ	pAdspConn
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PADSP_CONNOBJ	pAdspRemConn, *ppAdspRemConn;
	ULONG			index;
	BOOLEAN			removed = FALSE;

	index	= HASH_ID_SRCADDR(
				pAdspConn->adspco_RemoteConnId,
				&pAdspConn->adspco_RemoteAddr);

	index  %= ADSP_CONN_HASH_SIZE;

	for (ppAdspRemConn = &pAdspAddr->adspao_pActiveHash[index];
			((pAdspRemConn = *ppAdspRemConn) != NULL); )
	{
		if (pAdspRemConn == pAdspConn)
		{
			removed = TRUE;
			*ppAdspRemConn = pAdspRemConn->adspco_pNextActive;

			DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
					("atalkAdspConnDeQueueActiveList: Removed active conn %lx\n", pAdspConn));
			break;
		}
		else
		{
			ppAdspRemConn = &pAdspRemConn->adspco_pNextActive;
		}
	}

	return removed;
}




LOCAL	VOID
atalkAdspAddrQueueGlobalList(
	IN	PADSP_ADDROBJ	pAdspAddr
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	KIRQL	OldIrql;

	ACQUIRE_SPIN_LOCK(&atalkAdspLock, &OldIrql);
	pAdspAddr->adspao_pNextGlobal	= atalkAdspAddrList;
	atalkAdspAddrList				= pAdspAddr;
	RELEASE_SPIN_LOCK(&atalkAdspLock, OldIrql);
}


LOCAL	VOID
atalkAdspAddrDeQueueGlobalList(
	IN	PADSP_ADDROBJ	pAdspAddr
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	KIRQL			OldIrql;
	PADSP_ADDROBJ	pAdspRemAddr, *ppAdspRemAddr;

	ACQUIRE_SPIN_LOCK(&atalkAdspLock, &OldIrql);
	for (ppAdspRemAddr = &atalkAdspAddrList;
			((pAdspRemAddr = *ppAdspRemAddr) != NULL); )
	{
		if (pAdspRemAddr == pAdspAddr)
		{
			*ppAdspRemAddr = pAdspRemAddr->adspao_pNextGlobal;

			DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
					("atalkAdspAddrDeQueueGlobalList: Removed global conn %lx\n",pAdspAddr));
			break;
		}
		else
		{
			ppAdspRemAddr = &pAdspRemAddr->adspao_pNextGlobal;
		}
	}
	RELEASE_SPIN_LOCK(&atalkAdspLock, OldIrql);
}




LOCAL	VOID
atalkAdspConnDeQueueGlobalList(
	IN	PADSP_CONNOBJ	pAdspConn
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	KIRQL			OldIrql;
	PADSP_CONNOBJ	pAdspRemConn, *ppAdspRemConn;

	ACQUIRE_SPIN_LOCK(&atalkAdspLock, &OldIrql);
	for (ppAdspRemConn = &atalkAdspConnList;
			((pAdspRemConn = *ppAdspRemConn) != NULL); )
	{
		if (pAdspRemConn == pAdspConn)
		{
			*ppAdspRemConn = pAdspRemConn->adspco_pNextGlobal;

			DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
					("atalkAdspConnDeQueueGlobalList: Removed global conn %lx\n", pAdspConn));
			break;
		}
		else
		{
			ppAdspRemConn = &pAdspRemConn->adspco_pNextGlobal;
		}
	}
	RELEASE_SPIN_LOCK(&atalkAdspLock, OldIrql);
}




LOCAL	BOOLEAN
atalkAdspAddrDeQueueOpenReq(
	IN	PADSP_ADDROBJ	pAdspAddr,
	IN	USHORT			RemoteConnId,
	IN	PATALK_ADDR		pSrcAddr,
	OUT	PADSP_OPEN_REQ *ppAdspOpenReq
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PADSP_OPEN_REQ	pOpenReq, *ppOpenReq;
	BOOLEAN			removed = FALSE;

	for (ppOpenReq = &pAdspAddr->adspao_OpenReq;
			((pOpenReq = *ppOpenReq) != NULL); )
	{
		if ((pOpenReq->or_RemoteConnId == RemoteConnId) &&
			(ATALK_ADDRS_EQUAL(&pOpenReq->or_RemoteAddr, pSrcAddr)))
		{
			removed = TRUE;
			*ppOpenReq = pOpenReq->or_Next;

			DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
					("atalkAdspAddrDeQueueOpenReq: Removed OpenReq %lx\n", pOpenReq));
			break;
		}
		else
		{
			ppOpenReq = &pOpenReq->or_Next;
		}
	}

	*ppAdspOpenReq	= NULL;
	if (removed)
	{
		*ppAdspOpenReq	= pOpenReq;
	}

	return removed;
}




LOCAL	BOOLEAN
atalkAdspIsDuplicateOpenReq(
	IN	PADSP_ADDROBJ	pAdspAddr,
	IN	USHORT			RemoteConnId,
	IN	PATALK_ADDR		pSrcAddr
	)
/*++

Routine Description:

	!!!MUST BE CALLED WITH THE ADDRESS LOCK HELD!!!

Arguments:


Return Value:


--*/
{
	PADSP_OPEN_REQ	pOpenReqChk;
	BOOLEAN			found = FALSE;

	for (pOpenReqChk = pAdspAddr->adspao_OpenReq;
		 pOpenReqChk != NULL;
		 pOpenReqChk = pOpenReqChk->or_Next)
	{
		if ((pOpenReqChk->or_RemoteConnId == RemoteConnId) &&
			(ATALK_ADDRS_EQUAL(&pOpenReqChk->or_RemoteAddr, pSrcAddr)))
		{
			DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
					("atalkAdspIsDuplicateOpenReq: Found\n"));
			found = TRUE;
			break;
		}
	}

	return found;
}




LOCAL VOID
atalkAdspGenericComplete(
	IN	ATALK_ERROR	ErrorCode,
	IN	PIRP		pIrp
	)
{
	DBGPRINT(DBG_COMP_TDI, DBG_LEVEL_INFO,
			("atalkTdiGenericComplete: Completing %lx with %lx\n",
			pIrp, AtalkErrorToNtStatus(ErrorCode)));

	ASSERT (ErrorCode != ATALK_PENDING);
	TdiCompleteRequest(pIrp, AtalkErrorToNtStatus(ErrorCode));
}




VOID
atalkAdspConnFindInConnect(
	IN	PADSP_ADDROBJ	pAdspAddr,
	IN	USHORT			DestConnId,
	IN	PATALK_ADDR		pRemoteAddr,
	OUT	PADSP_CONNOBJ *	ppAdspConn,
	IN	PATALK_ERROR	pError
	)
/*++

Routine Description:

	The MAC could respond with a REQ&ACK from a different socket than
	the one we sent the REQ to. But the network/node id must be the
	same. We don't check for that though, and only use the destination
	connection id.

	This routine will replace the remote address with the new remote
	address passed in.

Arguments:


Return Value:


--*/
{
	PADSP_CONNOBJ	pAdspRemConn;

	ASSERT(pAdspAddr->adspao_Flags & ADSPAO_CONNECT);

	*pError = ATALK_INVALID_CONNECTION;
	for (pAdspRemConn = pAdspAddr->adspao_pConnectConn;
			pAdspRemConn != NULL; )
	{
		if (pAdspRemConn->adspco_LocalConnId == DestConnId)
		{
			DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
					("atalkAdspFindInConnectList: connect conn %lx\n",
					pAdspRemConn));

			//	Try to reference this.
			AtalkAdspConnReferenceByPtr(pAdspRemConn, pError);
			if (ATALK_SUCCESS(*pError))
			{
				//	Change remote address to be the passed in address
				pAdspRemConn->adspco_RemoteAddr = *pRemoteAddr;
				*ppAdspConn = pAdspRemConn;
			}
			break;
		}
		else
		{
			pAdspRemConn = pAdspRemConn->adspco_pNextConnect;
		}
	}
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\atalk\sys\aep.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	aep.c

Abstract:

	This module contains the echo protocol support code.

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	19 Jun 1992		Initial Version

Notes:	Tab stop: 4
--*/

#define	FILENUM		AEP
#include <atalk.h>
#pragma hdrstop


VOID
AtalkAepPacketIn(
	IN	PPORT_DESCRIPTOR	pPortDesc,
	IN	PDDP_ADDROBJ		pDdpAddr,
	IN	PBYTE				pPkt,
	IN	USHORT				PktLen,
	IN	PATALK_ADDR			pSrcAddr,
	IN	PATALK_ADDR			pDestAddr,
	IN	ATALK_ERROR			ErrorCode,
	IN	BYTE				DdpType,
	IN	PVOID				pHandlerCtx,
	IN	BOOLEAN				OptimizedPath,
	IN	PVOID				OptimizeCtx
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PBUFFER_DESC	pBufDesc;
	SEND_COMPL_INFO	SendInfo;

	ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

	//	Turn around and send the packet back to the destination address.
	if (ATALK_SUCCESS(ErrorCode))
	{
		if ((DdpType == DDPPROTO_EP) &&
			(PktLen > 0))
		{
			if (*pPkt == EP_COMMAND_REQUEST)
			{
				//	This is an echo request, we have some data that needs
				//	to be echoed back! Do it.
				pBufDesc = AtalkAllocBuffDesc(
										NULL,
										PktLen,
										(BD_CHAR_BUFFER | BD_FREE_BUFFER));

                if (pBufDesc)
                {
				    //	Change command to be Reply
				    *pPkt = EP_COMMAND_REPLY;

				    //	This *does not* set the PktLen in pBufDesc. Set it.
				    AtalkCopyBufferToBuffDesc(
    					pPkt,
	    				PktLen,
		    			pBufDesc,
			    		0);

				    AtalkSetSizeOfBuffDescData(pBufDesc, PktLen);

				    //	Call AtalkDdpSend.
				    SendInfo.sc_TransmitCompletion = atalkAepSendComplete;
				    SendInfo.sc_Ctx1 = pBufDesc;
				    // SendInfo.sc_Ctx2 = NULL;
				    // SendInfo.sc_Ctx3 = NULL;
				    if (!ATALK_SUCCESS(AtalkDdpSend(pDdpAddr,
					    							pSrcAddr,
						    						(BYTE)DDPPROTO_EP,
							    					FALSE,
								    				pBufDesc,
									    			NULL,
										    		0,
											    	NULL,
												    &SendInfo)))
				    {
					    AtalkFreeBuffDesc(pBufDesc);
				    }
                }
			}
		}
	}
	else
	{
		DBGPRINT(DBG_COMP_AEP, DBG_LEVEL_ERR,
				("AtalkAepPacketIn: Ignoring incoming packet AepPacketIn %lx\n",
				ErrorCode));
	}

}




VOID FASTCALL
atalkAepSendComplete(
	IN	NDIS_STATUS			Status,
	IN	PSEND_COMPL_INFO	pSendInfo
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	AtalkFreeBuffDesc((PBUFFER_DESC)(pSendInfo->sc_Ctx1));
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\atalk\sys\aarp.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	aarp.c

Abstract:

	This module contains the Appletalk Address Resolution Protocol code.

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	19 Jun 1992		Initial Version

Notes:	Tab stop: 4
--*/

#include <atalk.h>
#pragma hdrstop

//	Define the file number for this module for errorlogging.
#define	FILENUM	AARP

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGEINIT, AtalkInitAarpForNodeOnPort)
#pragma alloc_text(PAGEINIT, AtalkInitAarpForNodeInRange)
#pragma alloc_text(PAGEINIT, atalkInitAarpForNode)
#endif

VOID
AtalkAarpPacketIn(
	IN	OUT	PPORT_DESCRIPTOR	pPortDesc,
	IN		PBYTE				pLinkHdr,
	IN		PBYTE				pPkt,				// Only aarp data
	IN		USHORT				Length
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PBYTE				srcAddr;
	PBYTE				startOfPkt;
	ATALK_NODEADDR		srcNode, dstNode;

	PBYTE				pRouteInfo 		= NULL;
	USHORT				routeInfoLen 	= 0;
	ULONG				logEventPlace 	= 0;

	USHORT				hardwareLen, protocolLength, aarpCommand;
	PBUFFER_DESC		pBuffDesc;
	ATALK_ERROR			error;
    PVOID               pRasConn;
    PATCPCONN           pAtcpConn=NULL;
    PARAPCONN           pArapConn=NULL;
    DWORD               dwFlags;
    BOOLEAN             fDialInNode=TRUE;
    BOOLEAN             fThisIsPPP;

	TIME				TimeS, TimeE, TimeD;

	ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

	TimeS = KeQueryPerformanceCounter(NULL);

	if (PORT_CLOSING(pPortDesc))
	{
		//	If we are not active, return!
		return;
	}

	if (pPortDesc->pd_NdisPortType == NdisMedium802_5)
	{
		if (pLinkHdr[TLAP_SRC_OFFSET] & TLAP_SRC_ROUTING_MASK)
		{
			routeInfoLen = (pLinkHdr[TLAP_ROUTE_INFO_OFFSET] & TLAP_ROUTE_INFO_SIZE_MASK);

			//  First, glean any AARP information that we can, then handle the DDP
			//  packet.  This guy also makes sure we have a good 802.2 header...
			//
			//  Need to make a localcopy of the source address and then turn
			//  the source routing bit off before calling AarpGleanInfo
			//
			//	(HdrBuf)[TLAP_SRC_OFFSET] =	((HdrBuf)[TLAP_SRC_OFFSET] & ~TLAP_SRC_ROUTING_MASK);
		
			pLinkHdr[TLAP_SRC_OFFSET] &= ~TLAP_SRC_ROUTING_MASK;
			pRouteInfo = pLinkHdr + TLAP_ROUTE_INFO_OFFSET;
		}
	}

	startOfPkt = pPkt;

	ASSERT(routeInfoLen <= TLAP_MAX_ROUTING_BYTES);

	//	Pull out the information we'll be playing with. All three valid AARP
	//  commands use the same packet format. But have some variable length
	//	fields.

	//	The packet will not include the 802.2 header!
	//	pPkt	+= IEEE8022_HDR_LEN;
	//	Length	-= IEEE8022_HDR_LEN;

	pPkt += AARP_HW_LEN_OFFSET;			// Skip the hardware type

	do
	{
		GETBYTE2SHORT (&hardwareLen, pPkt);
        pPkt++ ;
	
		if ((hardwareLen < AARP_MIN_HW_ADDR_LEN ) ||
			(hardwareLen > AARP_MAX_HW_ADDR_LEN))
		{
			logEventPlace = (FILENUM | __LINE__);
			break;
		}
	
		GETBYTE2SHORT(&protocolLength, pPkt);
		pPkt ++;

		if (protocolLength != AARP_PROTO_ADDR_LEN)
		{
			logEventPlace = (FILENUM | __LINE__);
			break;
		}
	
		GETSHORT2SHORT(&aarpCommand, pPkt);
		pPkt += 2;
	
		//	Remember where the source address is in the packet for
		//	entering it into the mapping table
		srcAddr = pPkt;

		// Skip over the source hardware length
		// Skip over to leading null pad on logical address.
		pPkt += (hardwareLen + 1);
	
		GETSHORT2SHORT(&srcNode.atn_Network, pPkt);
		pPkt += 2;
	
		srcNode.atn_Node = *pPkt++;
	
		// Skip the destination hardware address
		// Skip over to leading null pad on logical destination address.
		pPkt += (hardwareLen + 1);

		GETSHORT2SHORT(&dstNode.atn_Network, pPkt);
		pPkt += 2;
	
		dstNode.atn_Node = *pPkt++;
		
		// We should have eaten the whole packet...
		if ((ULONG)(pPkt - startOfPkt) != Length)
		{
			logEventPlace = (FILENUM | __LINE__);
			break;
		}
		
		// Ignore any AARPs from us.

		ASSERT(hardwareLen == TLAP_ADDR_LEN);
		if (AtalkFixedCompareCaseSensitive(srcAddr,
										   hardwareLen,
										   pPortDesc->pd_PortAddr,
										   hardwareLen))
		{
			break;
		}

		// Handle the Aarp command packets
		switch(aarpCommand)
		{
		  case AARP_REQUEST:
	
			// We can get valid mapping info from a request, use it!
			// We are guaranteed routing info is positive and is not odd
			// (atleast 2 bytes).

			ASSERT((routeInfoLen >= 0) && (routeInfoLen != 1));
			if (routeInfoLen > 0)
				atalkAarpTuneRouteInfo(pPortDesc, pRouteInfo);
			
			atalkAarpEnterIntoAmt(pPortDesc,
								  &srcNode,
								  srcAddr,
								  hardwareLen,
								  pRouteInfo,
								  routeInfoLen);
			
			// After that, we can ignore any request not destined for us.
			if (!AtalkNodeExistsOnPort(pPortDesc, &dstNode))
			{
                // our dial-in clients can only be in the network range of the
                // default port.  If another adapter is plugged into the same net
                // as the default adapter, we don't want dial-in clients to
                // mess things up: ignore anything not coming on default adapter
                // (as far as dial-in clients go)
                if (pPortDesc != AtalkDefaultPort)
                {
                    break;
                }

                //
			    // is this one of our dial-in "nodes"?  If so, we must send out
                // a proxy response from our DefaultPort.
                //
			    if ((pRasConn = FindAndRefRasConnByAddr(dstNode,
                                                        &dwFlags,
                                                        &fThisIsPPP)) != NULL)
			    {
                    if (fThisIsPPP)
                    {
                        ASSERT(((PATCPCONN)pRasConn)->Signature == ATCPCONN_SIGNATURE);
                        DerefPPPConn((PATCPCONN)pRasConn);
                    }
                    else
                    {
                        ASSERT(((PARAPCONN)pRasConn)->Signature == ARAPCONN_SIGNATURE);
                        DerefArapConn((PARAPCONN)pRasConn);
                    }
			    }

                //
                // nope, a dial-in client with such a node addr doesn't exist either..
                //
                else
                {
				    break;
                }
			}

			// The're asking about us, speak the truth.
			pBuffDesc = BUILD_AARPRESPONSE(pPortDesc,
										   hardwareLen,
										   srcAddr,
										   pRouteInfo,
										   routeInfoLen,
										   dstNode,
										   srcNode);

			if (pBuffDesc == NULL)
			{
				DBGPRINT(DBG_COMP_AARP, DBG_LEVEL_ERR,
						("AtalkAarpPacketIn: Mem alloc failed %d\n", __LINE__));

				break;
			}

			if (!ATALK_SUCCESS(AtalkNdisSendPacket(pPortDesc,
												   pBuffDesc,
												   AtalkAarpSendComplete,
												   NULL)))
			{
				DBGPRINT(DBG_COMP_AARP, DBG_LEVEL_ERR,
						("AtalkAarpPacketIn: SendPkt %lx failed %d\n",
						pBuffDesc->bd_CharBuffer, __LINE__));

				LOG_ERRORONPORT(pPortDesc,
								EVENT_ATALK_AARP_SEND_FAIL,
								STATUS_INSUFFICIENT_RESOURCES,
								pBuffDesc->bd_CharBuffer,
								Length);

				//	We allocated the packet.
				AtalkAarpSendComplete(NDIS_STATUS_FAILURE,
									  pBuffDesc,
									  NULL);

			}
			break;
		
		  case AARP_RESPONSE:

			ACQUIRE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
			if (pPortDesc->pd_Flags & PD_FINDING_NODE)
			{
				//	No doubt, this is a response to our probe, check to make sure
				//  the address matches, if so set the "used" flag.
				if (ATALK_NODES_EQUAL(&dstNode, &pPortDesc->pd_TentativeNodeAddr))
				{
					pPortDesc->pd_Flags |= PD_NODE_IN_USE;

					//	Wakeup the blocking thread...
					KeSetEvent(&pPortDesc->pd_NodeAcquireEvent, IO_NETWORK_INCREMENT, FALSE);
				}
			}
			RELEASE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);

			// is this one of our dial-in "nodes"?  If so, check if we are probing
			if ((pRasConn = FindAndRefRasConnByAddr(dstNode,
                                                    &dwFlags,
                                                    &fThisIsPPP)) != NULL)
			{
                //
                // our dial-in clients can only be in the network range of the
                // default port
                //
                ASSERT(pPortDesc == AtalkDefaultPort);

                pAtcpConn = NULL;
                pArapConn = NULL;

                if (fThisIsPPP)
                {
                    pAtcpConn = (PATCPCONN)pRasConn;
                    ASSERT(pAtcpConn->Signature == ATCPCONN_SIGNATURE);
                }
                else
                {
                    pArapConn = (PARAPCONN)pRasConn;
                    ASSERT(pArapConn->Signature == ARAPCONN_SIGNATURE);
                }

                // PPP client?
                if (pAtcpConn)
                {
                    if (dwFlags & ATCP_FINDING_NODE)
                    {
                        ACQUIRE_SPIN_LOCK_DPC(&pAtcpConn->SpinLock);

				        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_WARN,
						    ("AtalkAarpPacketIn: PPP: someone owns %lx %x, retrying\n",
                                dstNode.atn_Network,dstNode.atn_Node));

                        pAtcpConn->Flags |= ATCP_NODE_IN_USE;

				        //	Wakeup the blocking thread...
				        KeSetEvent(&pAtcpConn->NodeAcquireEvent,
                                   IO_NETWORK_INCREMENT,
                                   FALSE);

                        RELEASE_SPIN_LOCK_DPC(&pAtcpConn->SpinLock);
                    }

                    // remove refcount put by FindAndRefRasConnByAddr
                    DerefPPPConn(pAtcpConn);
                }
                // nope, ARAP client
                else
                {
                    if (dwFlags & ARAP_FINDING_NODE)
                    {
                        ACQUIRE_SPIN_LOCK_DPC(&pArapConn->SpinLock);

				        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_WARN,
						    ("AtalkAarpPacketIn: ARAP: someone owns %lx %x, retrying\n",
                                dstNode.atn_Network,dstNode.atn_Node));

                        pArapConn->Flags |= ARAP_NODE_IN_USE;

				        //	Wakeup the blocking thread...
				        KeSetEvent(&pArapConn->NodeAcquireEvent,
                                   IO_NETWORK_INCREMENT,
                                   FALSE);

                        RELEASE_SPIN_LOCK_DPC(&pArapConn->SpinLock);
                    }

                    // remove refcount put by FindAndRefRasConnByAddr
                    DerefArapConn(pArapConn);
                }
            }

			//	This must have been a response to a probe or request... update our
			//  mapping table.
			if (routeInfoLen != 0)
			{
				atalkAarpTuneRouteInfo(pPortDesc, pRouteInfo);
			}

			atalkAarpEnterIntoAmt(pPortDesc,
								  &srcNode,
								  srcAddr,
								  hardwareLen,
								  pRouteInfo,
								  routeInfoLen);
			break;
	
		  case AARP_PROBE:

			ACQUIRE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
			if (pPortDesc->pd_Flags & PD_FINDING_NODE)
			{
				// If we get a probe for our current tentative address, set the
				// "used" flag.
				if (ATALK_NODES_EQUAL(&dstNode, &pPortDesc->pd_TentativeNodeAddr))
				{
					pPortDesc->pd_Flags |= PD_NODE_IN_USE;

					KeSetEvent(&pPortDesc->pd_NodeAcquireEvent,
							   IO_NETWORK_INCREMENT,
							   FALSE);
				}
			}
			RELEASE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
	
            if (pPortDesc != AtalkDefaultPort)
            {
                break;
            }

            fDialInNode = FALSE;

            // is the probe asking about one of our dial-in nodes? if so, we
            // must defend that address (or, if we are trying to acquire this
            // node addr, stop that since someone else is doing the same)
            //
            // our dial-in clients can only be in the network range of the
            // default port.  If another adapter is plugged into the same net
            // as the default adapter, we don't want dial-in clients to
            // mess things up: ignore anything not coming on default adapter
            // (as far as dial-in clients go)
			if ((pPortDesc == AtalkDefaultPort) &&
                ((pRasConn = FindAndRefRasConnByAddr(dstNode,
                                                     &dwFlags,
                                                     &fThisIsPPP)) != NULL))
			{

                pAtcpConn = NULL;
                pArapConn = NULL;

                if (fThisIsPPP)
                {
                    pAtcpConn = (PATCPCONN)pRasConn;
                    ASSERT(pAtcpConn->Signature == ATCPCONN_SIGNATURE);
                }
                else
                {
                    pArapConn = (PARAPCONN)pRasConn;
                    ASSERT(pArapConn->Signature == ARAPCONN_SIGNATURE);
                }

                // PPP client?
                if (pAtcpConn)
                {
                    if (dwFlags & ATCP_FINDING_NODE)
                    {
                        ACQUIRE_SPIN_LOCK_DPC(&pAtcpConn->SpinLock);

				        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_WARN,
						    ("AtalkAarpPacketIn: PPP: someone trying to acquire %lx %x, retrying\n",
                                dstNode.atn_Network,dstNode.atn_Node));

                        pAtcpConn->Flags |= ATCP_NODE_IN_USE;

				        //	Wakeup the blocking thread...
				        KeSetEvent(&pAtcpConn->NodeAcquireEvent,
                                   IO_NETWORK_INCREMENT,
                                   FALSE);

                        RELEASE_SPIN_LOCK_DPC(&pAtcpConn->SpinLock);
                    }
                    else
                    {
                        fDialInNode = TRUE;
                    }

                    // remove refcount put by FindAndRefRasConnByAddr
                    DerefPPPConn(pAtcpConn);

                }
                // nope, ARAP client
                else
                {
                    if (dwFlags & ARAP_FINDING_NODE)
                    {
                        ACQUIRE_SPIN_LOCK_DPC(&pArapConn->SpinLock);

				        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_WARN,
						    ("AtalkAarpPacketIn: ARAP: someone trying to acquire %lx %x, retrying\n",
                                dstNode.atn_Network,dstNode.atn_Node));

                        pArapConn->Flags |= ARAP_NODE_IN_USE;

				        //	Wakeup the blocking thread...
				        KeSetEvent(&pArapConn->NodeAcquireEvent,
                                   IO_NETWORK_INCREMENT,
                                   FALSE);

                        RELEASE_SPIN_LOCK_DPC(&pArapConn->SpinLock);
                    }
                    else
                    {
                        fDialInNode = TRUE;
                    }

                    // remove refcount put by FindAndRefRasConnByAddr
                    DerefArapConn(pArapConn);
                }
            }

			//	If the probe isn't asking about one of our AppleTalk addresses,
			//  and it's not one of our dial-in nodes either, drop it on the floor.
			if (!fDialInNode && !AtalkNodeExistsOnPort(pPortDesc, &dstNode))
			{
				break;
			}

			// The're talking to us! Build and send the response.
			if (routeInfoLen != 0)
			{
				atalkAarpTuneRouteInfo(pPortDesc, pRouteInfo);
			}

            if (fDialInNode)
            {
				DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
						("AtalkAarpPacketIn: defending dial-in client's addr %x %x\n",
                        dstNode.atn_Network,dstNode.atn_Node));
            }

			pBuffDesc = BUILD_AARPRESPONSE(pPortDesc,
										   hardwareLen,
										   srcAddr,
										   pRouteInfo,
										   routeInfoLen,
										   dstNode,
										   srcNode);
												
			if (pBuffDesc == NULL)
			{
				DBGPRINT(DBG_COMP_AARP, DBG_LEVEL_ERR,
						("AtalkAarpPacketIn: Mem alloc failed %d\n", __LINE__));

				break;
			}

			if (!ATALK_SUCCESS(AtalkNdisSendPacket(pPortDesc,
												  pBuffDesc,
												  AtalkAarpSendComplete,
												  NULL)))
			{
				DBGPRINT(DBG_COMP_AARP, DBG_LEVEL_ERR,
						("AtalkAarpPacketIn: SendPkt %lx failed %d\n",
						pBuffDesc->bd_CharBuffer, __LINE__));

				LOG_ERRORONPORT(pPortDesc,
								EVENT_ATALK_AARP_SEND_FAIL,
								STATUS_INSUFFICIENT_RESOURCES,
								pBuffDesc->bd_CharBuffer,
								Length);

				//	We allocated the packet. This will free it up.
				AtalkAarpSendComplete(NDIS_STATUS_FAILURE,
									  pBuffDesc,
									  NULL);

			}
			break;
	
		  default:
			logEventPlace = (FILENUM | __LINE__);
			break;
		}
	} while (FALSE);

	if (logEventPlace)
	{
		LOG_ERRORONPORT(pPortDesc,
						EVENT_ATALK_INVALIDAARPPACKET,
						logEventPlace,
						startOfPkt,
						Length);
	}

	TimeE = KeQueryPerformanceCounter(NULL);

	TimeD.QuadPart = TimeE.QuadPart - TimeS.QuadPart;

	INTERLOCKED_ADD_LARGE_INTGR_DPC(
		&pPortDesc->pd_PortStats.prtst_AarpPacketInProcessTime,
		TimeD,
		&AtalkStatsLock.SpinLock);

	INTERLOCKED_INCREMENT_LONG_DPC(
		&pPortDesc->pd_PortStats.prtst_NumAarpPacketsIn,
		&AtalkStatsLock.SpinLock);
}




VOID
AtalkAarpSendComplete(
	NDIS_STATUS				Status,
	PBUFFER_DESC			pBuffDesc,
	PSEND_COMPL_INFO		pSendInfo
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	ASSERT(pBuffDesc->bd_Next == NULL);
	ASSERT(pBuffDesc->bd_Flags & BD_CHAR_BUFFER);

	AtalkNdisFreeBuf(pBuffDesc);
}




#define	AtalkAarpUpdateBre(_pPortDesc,									\
						   _Network,									\
						   _SrcAddr,									\
						   _AddrLen,									\
						   _RouteInfo,									\
						   _RouteInfoLen)								\
{																		\
	PBRE	pBre, *ppBre;												\
	int		index;														\
	BLKID	BlkId;														\
																		\
	DBGPRINT(DBG_COMP_AARP, DBG_LEVEL_INFO,								\
			("AtalkAarpUpdateBre: Entering %x in brc\n", _Network));	\
																		\
	index = (int)((_Network) & (PORT_BRC_HASH_SIZE - 1));				\
																		\
	ACQUIRE_SPIN_LOCK_DPC(&(_pPortDesc)->pd_Lock);						\
																		\
	for (ppBre = &(_pPortDesc)->pd_Brc[index];							\
		 (pBre = *ppBre) != NULL;										\
		 ppBre = &pBre->bre_Next)										\
	{																	\
		if (pBre->bre_Network == (_Network))							\
		{																\
			 /*															\
			 * Unlink it from the list since it could potentially		\
			 * be freed if the routeinfolen grew and also we want		\
			 * to link it again at the head of the list					\
			 */															\
			*ppBre = pBre->bre_Next;									\
			break;														\
		}																\
	}																	\
																		\
	if ((pBre != NULL) &&												\
		(pBre->bre_RouteInfoLen < (BYTE)(_RouteInfoLen)))				\
	{																	\
		AtalkBPFreeBlock(pBre);											\
		pBre = NULL;													\
	}																	\
																		\
	if (pBre == NULL)													\
	{																	\
		BlkId = BLKID_BRE;												\
		if ((_RouteInfoLen) != 0)										\
			BlkId = BLKID_BRE_ROUTE;									\
		pBre = (PBRE)AtalkBPAllocBlock(BlkId);							\
	}																	\
																		\
	if (pBre != NULL)													\
	{																	\
		pBre->bre_Age = 0;												\
		pBre->bre_Network = (_Network);									\
																		\
		COPY_NETWORK_ADDR(pBre->bre_RouterAddr,							\
						  _SrcAddr);									\
																		\
		pBre->bre_RouteInfoLen =(BYTE)(_RouteInfoLen);					\
																		\
		if ((_RouteInfoLen) > 0)										\
			RtlCopyMemory((PBYTE)pBre + sizeof(BRE),					\
						  _RouteInfo,									\
						  _RouteInfoLen);								\
																		\
		pBre->bre_Next = *ppBre;										\
		*ppBre = pBre;													\
	}																	\
																		\
	RELEASE_SPIN_LOCK_DPC(&(_pPortDesc)->pd_Lock);						\
}

BOOLEAN
AtalkAarpGleanInfo(
	IN	OUT	PPORT_DESCRIPTOR	pPortDesc,
	IN		PBYTE				SrcAddr,
	IN		SHORT				AddrLen,
	IN  OUT	PBYTE				RouteInfo,
	IN		USHORT				RouteInfoLen,
	IN		PBYTE				pPkt,
	IN		USHORT				Length
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	ATALK_NODEADDR		srcNode, dstNode;
	PBYTE				startOfPkt;
	ULONG				logEventPlace = 0;
	BYTE				offCableInfo;
	BOOLEAN				result = TRUE;
	
	if (PORT_CLOSING(pPortDesc))
	{
		//	If we are not active, return!
		return FALSE;
	}

	//	Packet will not include the 802.2 header!
	//	pPkt += IEEE8022_HDR_LEN;
	//	Length -= IEEE8022_HDR_LEN;

	//	Remember the start of the packet
	startOfPkt = pPkt;

	//	Get the off cable information
	offCableInfo = *pPkt;

	//	Skip the datagram length and checksum fields
	pPkt += (2 + 2);

	//	Get the destination network number
	GETSHORT2SHORT(&dstNode.atn_Network, pPkt);
	pPkt += sizeof(USHORT);

	//	Get the source network number
	GETSHORT2SHORT(&srcNode.atn_Network, pPkt);
	pPkt += sizeof(USHORT);

	//	Get the destination node id
	dstNode.atn_Node = *pPkt++;

	//	Get the source node id
	srcNode.atn_Node = *pPkt++;

	do
	{
		//	Do a little verification.
		if ((srcNode.atn_Node < MIN_USABLE_ATALKNODE) ||
			(srcNode.atn_Node > MAX_USABLE_ATALKNODE) ||
			(srcNode.atn_Network < FIRST_VALID_NETWORK) ||
			(srcNode.atn_Network > LAST_VALID_NETWORK))
		{
			//	Only bother logging this if we are in some routing capacity,
			//  otherwise, let A-ROUTER worry about it
			if (AtalkRouter)
			{
				DBGPRINT(DBG_COMP_AARP, DBG_LEVEL_ERR,
						("AtalkAarpGleanInfo: dstNode invalid %x.%x\n",
						srcNode.atn_Network, srcNode.atn_Node));
				logEventPlace = FILENUM | __LINE__;
			}
			break;
		}
	
		if (dstNode.atn_Network > LAST_VALID_NETWORK)
		{
			DBGPRINT(DBG_COMP_AARP, DBG_LEVEL_ERR,
					("AtalkAarpGleanInfo: srcNode invalid %x.%x\n",
					dstNode.atn_Network, dstNode.atn_Node));
			logEventPlace = FILENUM | __LINE__;
			break;
		}
		
		//	Did the packet come from off this cable?  Look at the hop count.  If so,
		//  enter it into our best-router cache.
		//
		//	**NOTE** We assume that the RouteInfo buffer can be written to!

		if (RouteInfoLen > 0)
			atalkAarpTuneRouteInfo(pPortDesc, RouteInfo);

		if ((offCableInfo >> 2) & AARP_OFFCABLE_MASK)
		{
			AtalkAarpUpdateBre(pPortDesc,
							   srcNode.atn_Network,
							   SrcAddr,
							   AddrLen,
							   RouteInfo,
							   RouteInfoLen);
		}
		else
		{
			DBGPRINT(DBG_COMP_AARP, DBG_LEVEL_INFO,
					("AtalkAarpGleanInfo: Entering %x.%x info in Amt tables\n",
					srcNode.atn_Network, srcNode.atn_Node));

			// "Glean" AARP information from on-cable packets.
			atalkAarpEnterIntoAmt(pPortDesc,
								  &srcNode,
								  SrcAddr,
								  AddrLen,
								  RouteInfo,
								  RouteInfoLen);
		}
	} while (FALSE);

	if (logEventPlace)
	{
		LOG_ERRORONPORT(pPortDesc,
						EVENT_ATALK_INVALIDAARPPACKET,
						logEventPlace,
						startOfPkt,
						Length);
	}
	
	return (logEventPlace == 0);
}


VOID
AtalkAarpOptGleanInfo(
	IN	OUT	PPORT_DESCRIPTOR	pPortDesc,
	IN		PBYTE				pLinkHdr,
	IN		PATALK_ADDR			pSrcAddr,
	IN		PATALK_ADDR			pDestAddr,
	IN		BOOLEAN				OffCablePkt
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	ATALK_NODEADDR		srcNode, dstNode;
	int					index;
	PBYTE				pRouteInfo;
	USHORT				routeLen = 0, srcOffset;
	
	if (PORT_CLOSING(pPortDesc))
	{
		//	If we are not active, return!
		return;
	}

	switch (pPortDesc->pd_NdisPortType)
	{
	  case NdisMedium802_5:

		if (pLinkHdr[TLAP_SRC_OFFSET] & TLAP_SRC_ROUTING_MASK)
		{
			routeLen = (pLinkHdr[TLAP_ROUTE_INFO_OFFSET] & TLAP_ROUTE_INFO_SIZE_MASK);

			//
			//  First, glean any AARP information that we can, then handle the DDP
			//  packet.  This guy also makes sure we have a good 802.2 header...
			//
			//  Need to make a localcopy of the source address and then turn
			//  the source routing bit off before calling AarpGleanInfo
			//
			//	(HdrBuf)[TLAP_SRC_OFFSET] = ((HdrBuf)[TLAP_SRC_OFFSET] & ~TLAP_SRC_ROUTING_MASK);
			//
		
			pLinkHdr[TLAP_SRC_OFFSET] &= ~TLAP_SRC_ROUTING_MASK;
			pRouteInfo = pLinkHdr + TLAP_ROUTE_INFO_OFFSET;
		}
		srcOffset = TLAP_SRC_OFFSET;
		break;

	  case NdisMedium802_3:
		srcOffset	 = ELAP_SRC_OFFSET;
		break;

	  case NdisMediumFddi:
		srcOffset	 = FDDI_SRC_OFFSET;
		break;

	  default:
		KeBugCheck(0);
		break;
	}

	//	Get the destination network number
	dstNode.atn_Network	= pDestAddr->ata_Network;
	dstNode.atn_Node	= pDestAddr->ata_Node;
	srcNode.atn_Network	= pSrcAddr->ata_Network;
	srcNode.atn_Node	= pSrcAddr->ata_Node;

	do
	{
		//	Do a little verification.
		if ((srcNode.atn_Node < MIN_USABLE_ATALKNODE) ||
			(srcNode.atn_Node > MAX_USABLE_ATALKNODE) ||
			(srcNode.atn_Network < FIRST_VALID_NETWORK) ||
			(srcNode.atn_Network > LAST_VALID_NETWORK))
		{
			break;
		}
	
		if (dstNode.atn_Network > LAST_VALID_NETWORK)
		{
			break;
		}
		
		//	Did the packet come from off this cable?  Look at the hop count.  If so,
		//  enter it into our best-router cache.
		//
		//	**NOTE** We assume that the pRouteInfo buffer can be written to!

		if (routeLen > 0)
			atalkAarpTuneRouteInfo(pPortDesc, pRouteInfo);

		if (OffCablePkt)
		{
			AtalkAarpUpdateBre(pPortDesc,
							   srcNode.atn_Network,
							   pLinkHdr + srcOffset,
							   ELAP_ADDR_LEN,
							   pRouteInfo,
							   routeLen);
		}
		else
		{
			DBGPRINT(DBG_COMP_AARP, DBG_LEVEL_INFO,
					("AtalkAarpGleanInfo: Entering %x.%x info in Amt tables\n",
					srcNode.atn_Network, srcNode.atn_Node));

			// "Glean" AARP information from on-cable packets.
			atalkAarpEnterIntoAmt(pPortDesc,
								  &srcNode,
								  pLinkHdr + srcOffset,
								  ELAP_ADDR_LEN,
								  pRouteInfo,
								  routeLen);
		}

	} while (FALSE);
}


ATALK_ERROR
AtalkInitAarpForNodeOnPort(
	IN		PPORT_DESCRIPTOR	pPortDesc,
	IN		BOOLEAN				AllowStartupRange,
	IN		ATALK_NODEADDR		DesiredNode,
	IN OUT	PATALK_NODE		*	ppAtalkNode
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	ATALK_ERROR			error;
	PDDP_ADDROBJ		pDdpAddr;
	ATALK_NODEADDR		newNode;
	PATALK_NODE			pAtalkNode;
	KIRQL				OldIrql;
	BOOLEAN				foundNode = FALSE;
	BOOLEAN				inStartupRange = FALSE, result = TRUE;

	if (!ATALK_SUCCESS(AtalkInitNodeAllocate(pPortDesc, &pAtalkNode)))
	{
		return ATALK_RESR_MEM;
	}

	//	Try to find a new extended Node on the given port; first try for the
	//  requested address (if specified), else try in this port's cable range
	//  (if it's known) or in the default cable range (if any), then try the
	//  start-up range (if allowed).

	do
	{
		if (DesiredNode.atn_Network != UNKNOWN_NETWORK)
		{
			if (((pPortDesc->pd_Flags & PD_SEEN_ROUTER_RECENTLY) == 0) ||
				(WITHIN_NETWORK_RANGE(DesiredNode.atn_Network, &pPortDesc->pd_NetworkRange)))
			{
				foundNode = atalkInitAarpForNode(pPortDesc,
                                                 NULL,      // not a dial-in client
                                                 FALSE,     // don't care
												 DesiredNode.atn_Network,
												 DesiredNode.atn_Node);
	
			}
			// leave if we found a node.
			if (foundNode)
			{
				newNode = DesiredNode;
				break;
			}
		}
	
		if (pPortDesc->pd_Flags & PD_SEEN_ROUTER_RECENTLY)
		{
			foundNode = AtalkInitAarpForNodeInRange(pPortDesc,
                                                    NULL,   // not a dial-in client
                                                    FALSE,  // don't care
													pPortDesc->pd_NetworkRange,
													&newNode);

			// leave if we found a node.
			if (foundNode)
			{
				break;
			}
		}

		if (pPortDesc->pd_InitialNetworkRange.anr_FirstNetwork != UNKNOWN_NETWORK)
		{
			foundNode = AtalkInitAarpForNodeInRange(pPortDesc,
                                                    NULL,   // not a dial-in client
                                                    FALSE,  // don't care
													pPortDesc->pd_InitialNetworkRange,
													&newNode);

			// leave if we found a node.
			if (foundNode)
			{
				break;
			}
		}

		//	If no place else to try, try the start-up range.  Do this even if
		//  we don't want to end up there.
		//
		//	The idea is that this happens only when we are starting the router
		//	on one of our ports. So we do not want the router started in the
		//	startup range. If we do start in the startup range, and we see later
		//	that we did not see a router in the process,
		//	we will release the node. Of course, if we are a seed router, we will
		//	never be here, as the if statement above will be true.
		//
	
		inStartupRange = TRUE;
		foundNode = AtalkInitAarpForNodeInRange(pPortDesc,
                                                NULL,   // not a dial-in client
                                                FALSE,  // don't care
												AtalkStartupNetworkRange,
												&newNode);
		break;

	} while (FALSE);
	
	//	If we have a tentative Node, go on.
	if (foundNode)
	{
		do
		{
			//	Use the allocated structure to set the info.
			//	Thread this into the port structure.
			pAtalkNode->an_NodeAddr = newNode;

			ACQUIRE_SPIN_LOCK(&pPortDesc->pd_Lock, &OldIrql);

			//	Reference the port for this node.
			AtalkPortRefByPtrNonInterlock(pPortDesc, &error);
			if (!ATALK_SUCCESS(error))
			{
				result = FALSE;
				RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);
				AtalkFreeMemory(pAtalkNode);
				break;
			}

			//	Now put it in the port descriptor
            pAtalkNode->an_Next = pPortDesc->pd_Nodes;
            pPortDesc->pd_Nodes = pAtalkNode;
			RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);
	
			//	See who's out there.  We need to open the ZIP socket in order to be
			//  able to hear replies.
			if (!ATALK_SUCCESS(AtalkDdpOpenAddress(pPortDesc,
												   ZONESINFORMATION_SOCKET,
												   &newNode,
												   AtalkZipPacketIn,
												   NULL,
												   DDPPROTO_ANY,
												   NULL,
												   &pDdpAddr)))
			{
				LOG_ERRORONPORT(pPortDesc,
								EVENT_ATALK_OPENZIPSOCKET,
								0,
								NULL,
								0);
	
				AtalkNodeReleaseOnPort(pPortDesc, pAtalkNode);
	
				result = FALSE;
				break;
			}

            // mark the fact that this is an "internal" socket
            pDdpAddr->ddpao_Flags |= DDPAO_SOCK_INTERNAL;


			if (!(pPortDesc->pd_Flags & PD_SEEN_ROUTER_RECENTLY))
			{
				// Get the default zone
				AtalkZipGetNetworkInfoForNode(pPortDesc, &pAtalkNode->an_NodeAddr, TRUE);

				// Validate the desired zone
				AtalkZipGetNetworkInfoForNode(pPortDesc, &pAtalkNode->an_NodeAddr, FALSE);
			}
			
			//	If nobody was out there and our tentative Node was in the
			//	startup range and our caller doesn't want to be there, return
			//	an error now.
			//
			//	Note: this means that we were trying to start the router on
			//	a non-seeding port, and since there is not router on the net,
			//	it means the net is not seeded and so, we exit.
			
			if (inStartupRange &&
				!(pPortDesc->pd_Flags & PD_SEEN_ROUTER_RECENTLY) &&
				!AllowStartupRange)
			{
				LOG_ERRORONPORT(pPortDesc,
								EVENT_ATALK_STARTUPRANGENODE,
								0,
								NULL,
								0);
	
				AtalkNodeReleaseOnPort(pPortDesc, pAtalkNode);
	
				result = FALSE;
				break;
			}
	
			//	If we have seen SeenRouterRecently is not true, that means we have
			//	used the InitialNetworkRange to AARP. If now SeenRouterRecently is
			//	true that means we have gotten the address in the InitialNetworkRange,
			//	but now there is a seeded range on the net that we must use. So redo
			//	the GetNode work.
			
			if ((pPortDesc->pd_Flags & PD_SEEN_ROUTER_RECENTLY) &&
				!WITHIN_NETWORK_RANGE(newNode.atn_Network,
									  &pPortDesc->pd_NetworkRange))
			{
				LOG_ERRORONPORT(pPortDesc,
								EVENT_ATALK_INITIALRANGENODE,
								0,
								NULL,
								0);
	
				// Release the node we obtained.
				AtalkNodeReleaseOnPort(pPortDesc, pAtalkNode);

				// Get another node and retry in the correct range.
				ASSERTMSG("NetworkRange still set to startup!\n",
							pPortDesc->pd_NetworkRange.anr_FirstNetwork != UNKNOWN_NETWORK);

				foundNode = AtalkInitAarpForNodeInRange(pPortDesc,
                                                        NULL,   // not a dial-in client
                                                        FALSE,  // don't care
														pPortDesc->pd_NetworkRange,
														&newNode);

				if (foundNode)
				{
					ASSERTMSG("New node is not within NetworkRange!\n",
								WITHIN_NETWORK_RANGE(newNode.atn_Network,
													 &pPortDesc->pd_NetworkRange));

					if (!ATALK_SUCCESS(AtalkInitNodeAllocate(pPortDesc, &pAtalkNode)))
					{
						result = FALSE;
						break;
					}

					//	Use the allocated structure to set the info.
					//	Thread this into the port structure.
					pAtalkNode->an_NodeAddr = newNode;
			
					//	Reference the port for this node.
					AtalkPortReferenceByPtr(pPortDesc, &error);
					if (!ATALK_SUCCESS(error))
					{
						result = FALSE;
						AtalkFreeMemory(pAtalkNode);
						break;
					}
		
					//	Now put it in the port descriptor
					ACQUIRE_SPIN_LOCK(&pPortDesc->pd_Lock, &OldIrql);
					pAtalkNode->an_Next = pPortDesc->pd_Nodes;
					pPortDesc->pd_Nodes = pAtalkNode;
					RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);
			
					//	Open the zip socket to be consistent
					if (!ATALK_SUCCESS(AtalkDdpOpenAddress(pPortDesc,
														   ZONESINFORMATION_SOCKET,
														   &newNode,
														   AtalkZipPacketIn,
														   NULL,
														   DDPPROTO_ANY,
														   NULL,
														   &pDdpAddr)))
					{
						LOG_ERRORONPORT(pPortDesc,
										EVENT_ATALK_OPENZIPSOCKET,
										0,
										NULL,
										0);
			
						AtalkNodeReleaseOnPort(pPortDesc, pAtalkNode);
			
						result = FALSE;
						break;
					}

                    // mark the fact that this is an "internal" socket
                    pDdpAddr->ddpao_Flags |= DDPAO_SOCK_INTERNAL;
				}
			}

		} while (FALSE);
	}
	else
	{
		//	Free the allocated node structure. This has not yet been
		//	inserted into the port descriptor, so we can just free it.
		AtalkFreeMemory(pAtalkNode);
	}

	if (foundNode && result)
	{
		// All set!
		ASSERT(ppAtalkNode != NULL);
		*ppAtalkNode = pAtalkNode;

		// atalkAarpEnterIntoAmt() expects to be called at DISPATCH_LEVEL. Make it so.
		KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);

		atalkAarpEnterIntoAmt(pPortDesc,
							  &newNode,
							  pPortDesc->pd_PortAddr,
							  MAX_HW_ADDR_LEN,
							  NULL,
							  0);
		KeLowerIrql(OldIrql);


	}

	return ((foundNode && result) ? ATALK_NO_ERROR : ATALK_FAILURE);
}



BOOLEAN
AtalkInitAarpForNodeInRange(
	IN	PPORT_DESCRIPTOR	pPortDesc,
    IN  PVOID               pRasConn,
    IN  BOOLEAN             fThisIsPPP,
	IN	ATALK_NETWORKRANGE	NetworkRange,
	OUT	PATALK_NODEADDR		Node
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	BYTE	currentNode;
	USHORT	currentNetwork;
	int		firstNode, lastNode;
	long	netTry;
	int		nodeTry;
	USHORT	nodeWidth, nodeChange, nodeIndex;
	USHORT	netWidth, netChange, netIndex;
	BOOLEAN	found = FALSE;
	
	//	Pick the node number range we'll try for (we do not pay attention to the
	//	"ServerNode" concept for LocalTalk). Our node is obtained by the
	//	localtalk driver anyways.
	firstNode = MIN_USABLE_ATALKNODE;
	lastNode = MAX_EXT_ATALKNODE;
	
	//	Okay, now some fun starts. Plow through our options trying to find an
	//  unused extended node number.
	
	//	Compute the width of our network range, and pick a random start point.
	netWidth = (USHORT)((NetworkRange.anr_LastNetwork + 1) - NetworkRange.anr_FirstNetwork);
	netTry = GET_RANDOM(NetworkRange.anr_FirstNetwork, NetworkRange.anr_LastNetwork);
	
	//	Come up with a random decrement, making sure it's odd (to avoid repeats)
	//  and large enough to appear pretty random.
	netChange = (USHORT)(GET_RANDOM(1, netWidth) | 1);
	while ((netWidth % netChange == 0) ||
			(!AtalkIsPrime((long)netChange)))
	{
		netChange += 2;
	}
	
	//	Now walk trough the range decrementing the starting network by the
	//  choosen change (with wrap, of course) until we find an address or
	//  we've processed every available network in the range.
	for (netIndex = 0; netIndex < netWidth; netIndex ++)
	{
		currentNetwork = (USHORT) netTry;
	
		// Compute the width of our node range, and pick a random start point.
		nodeWidth = (USHORT)((lastNode + 1) - firstNode);
		nodeTry = (int)GET_RANDOM(firstNode, lastNode);

		//	Come up with a random decrement, making sure it's odd (to avoid repeats)
		//  and large enough to appear pretty random.
		nodeChange = (USHORT)(GET_RANDOM(1, nodeWidth) | 1);
		while ((nodeWidth % nodeChange == 0) || !(AtalkIsPrime((long)nodeChange)))
			nodeChange += 2;
	
		//	Now walk trough the range decrementing the starting network by the
		//  choosen change (with wrap, of course) until we find an address or
		//  we've processed every available node in the range.
		for (nodeIndex = 0; nodeIndex < nodeWidth; nodeIndex ++)
		{
			currentNode = (BYTE )nodeTry;

			// Let AARP have a crack at it.
			if ((found = atalkInitAarpForNode(pPortDesc,
                                              pRasConn,
                                              fThisIsPPP,
                                              currentNetwork,
                                              currentNode)))
            {
				break;
            }
	
			// Okay, try again, bump down with wrap.
			nodeTry -= nodeChange;
			while (nodeTry < firstNode)
				nodeTry += nodeWidth;
	
		}  // Node number loop

		//	If we found a node, break on thru to the other side.
		if (found)
			break;
	
		// Okay, try again, bump down with wrap.
		netTry -= netChange;
		while (netTry < (long)NetworkRange.anr_FirstNetwork)
			netTry += netWidth;
	
	}  // Network number loop

	// Okay if we found one return all's well, otherwise no luck.
	if (found)
	{
		if (Node != NULL)
		{
			Node->atn_Network = currentNetwork;
			Node->atn_Node	= currentNode;
		}
	}
	return found;
	
}  // AarpForNodeInRange



LOCAL BOOLEAN
atalkInitAarpForNode(
	IN	PPORT_DESCRIPTOR	pPortDesc,
    IN  PVOID               pRasConn,
    IN  BOOLEAN             fThisIsPPP,
	IN	USHORT				Network,
	IN	BYTE				Node
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	SHORT			probeAttempt;
	PBUFFER_DESC	pBuffDesc;
    PVOID           pTmpConn;
    PATCPCONN       pAtcpConn;
    PARAPCONN       pArapConn;
	ATALK_NODEADDR	tryNode;
	KIRQL			OldIrql;
    PKEVENT         pWaitEvent;
    DWORD           dwFlags;
	BOOLEAN			nodeInUse;
    BOOLEAN         fNoOneHasResponded=TRUE;
    BOOLEAN         fPPPConn;


	DBGPRINT(DBG_COMP_AARP, DBG_LEVEL_INFO,
			("atalkAarpForNode: AARPing for %x.%x on port %Z\n",
			Network, Node, &pPortDesc->pd_AdapterKey));

	// First make sure we don't own this node.
	tryNode.atn_Network = Network;
	tryNode.atn_Node	= Node;

	KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);

	nodeInUse = AtalkNodeExistsOnPort(pPortDesc, &tryNode);

	KeLowerIrql(OldIrql);

	if (nodeInUse)
	{
		return(FALSE);
	}

    // is this node used by one of the dial in clients?
	if ((pTmpConn = FindAndRefRasConnByAddr(tryNode, &dwFlags, &fPPPConn)) != NULL)
	{
	    DBGPRINT(DBG_COMP_AARP, DBG_LEVEL_INFO,
		    ("atalkAarpForNode: %x.%x already a dial in client (%lx)\n",
			    Network, Node, pTmpConn));

        // our dial-in clients can only be in the network range of the
        // default port
        ASSERT(pPortDesc == AtalkDefaultPort);

        if (fPPPConn)
        {
            ASSERT(((PATCPCONN)pTmpConn)->Signature == ATCPCONN_SIGNATURE);
            DerefPPPConn((PATCPCONN)pTmpConn);
        }
        else
        {
            ASSERT(((PARAPCONN)pTmpConn)->Signature == ARAPCONN_SIGNATURE);
            DerefArapConn((PARAPCONN)pTmpConn);
        }
		return(FALSE);
	}

    pAtcpConn = NULL;
    pArapConn = NULL;

    //
    // if we are acquiring a node addr for a dial-in client...
    //

    if (pRasConn != NULL)
    {
        if (fThisIsPPP)
        {
            pAtcpConn = (PATCPCONN)pRasConn;
        }
        else
        {
            pArapConn = (PARAPCONN)pRasConn;
        }
    }

    // PPP client?
    if (pAtcpConn)
    {
        ACQUIRE_SPIN_LOCK(&pAtcpConn->SpinLock, &OldIrql);
        pAtcpConn->NetAddr.atn_Network = Network;
        pAtcpConn->NetAddr.atn_Node = Node;
        pAtcpConn->Flags &= ~ATCP_NODE_IN_USE;
        pWaitEvent = &pAtcpConn->NodeAcquireEvent;
        RELEASE_SPIN_LOCK(&pAtcpConn->SpinLock, OldIrql);
    }

    // nope, ARAP client?
    else if (pArapConn)
    {
        ACQUIRE_SPIN_LOCK(&pArapConn->SpinLock, &OldIrql);
        pArapConn->NetAddr.atn_Network = Network;
        pArapConn->NetAddr.atn_Node = Node;
        pArapConn->Flags &= ~ARAP_NODE_IN_USE;
        pWaitEvent = &pArapConn->NodeAcquireEvent;
        RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);
    }
    // no, this is node acquisition for one of the server nodes
    else
    {
	    // Use AARP to probe for a particular network/node address.
	    ACQUIRE_SPIN_LOCK(&pPortDesc->pd_Lock, &OldIrql);
	    pPortDesc->pd_Flags &= ~PD_NODE_IN_USE;
	    pPortDesc->pd_TentativeNodeAddr.atn_Network = Network;
	    pPortDesc->pd_TentativeNodeAddr.atn_Node = Node;
        pWaitEvent = &pPortDesc->pd_NodeAcquireEvent;
	    RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);
    }
	
    fNoOneHasResponded = TRUE;

	// Build the packet and blast it out the specified number of times.
	for (probeAttempt = 0;
		 ((probeAttempt < pPortDesc->pd_AarpProbes) && (fNoOneHasResponded));
		 probeAttempt ++)
	{
		pBuffDesc = BUILD_AARPPROBE(pPortDesc, MAX_HW_ADDR_LEN, tryNode);

		if (pBuffDesc == NULL)
		{
			RES_LOG_ERROR();
			break;
		}

		if (!ATALK_SUCCESS(AtalkNdisSendPacket(pPortDesc,
											   pBuffDesc,
											   AtalkAarpSendComplete,
											   NULL)))
		{
	        DBGPRINT(DBG_COMP_AARP, DBG_LEVEL_ERR,
			    ("atalkAarpForNode: AtalkNdisSendPacket failed while AARPing for %x.%x\n",
			    Network, Node));

			//	We allocated the packet.		
			AtalkAarpSendComplete(NDIS_STATUS_FAILURE, pBuffDesc, NULL);
			break;
		}

		AtalkWaitTE(pWaitEvent, AARP_PROBE_TIMER_MS);

        // node addr for a PPP client?
        if (pAtcpConn)
        {
            ACQUIRE_SPIN_LOCK(&pAtcpConn->SpinLock, &OldIrql);
            if (pAtcpConn->Flags & ATCP_NODE_IN_USE)
            {
                fNoOneHasResponded = FALSE;
            }
            RELEASE_SPIN_LOCK(&pAtcpConn->SpinLock, OldIrql);
        }
        // node addr for a ARAP client?
        else if (pArapConn)
        {
            ACQUIRE_SPIN_LOCK(&pArapConn->SpinLock, &OldIrql);
            if (pArapConn->Flags & ARAP_NODE_IN_USE)
            {
                fNoOneHasResponded = FALSE;
            }
            RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);
        }
        // nope, node addr for one of the server nodes
        else
        {
            ACQUIRE_SPIN_LOCK(&pPortDesc->pd_Lock, &OldIrql);
            if (pPortDesc->pd_Flags & PD_NODE_IN_USE)
            {
                fNoOneHasResponded = FALSE;
            }
            RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);
        }

	}  // Probe attempts loop


	// We win if the current tentenative node has not been used
    // (i.e. no one responds to our probes)

	return (fNoOneHasResponded);
	
}  // atalkAarpForNode



LOCAL VOID
atalkAarpEnterIntoAmt(
	IN		PPORT_DESCRIPTOR	pPortDesc,
	IN		PATALK_NODEADDR		pSrcNode,
	IN		PBYTE				SrcAddr,
	IN		SHORT				AddrLen,
	IN		PBYTE				RouteInfo,
	IN		SHORT				RouteInfoLen
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	int					index;
	PAMT				pAmt, *ppAmt;

	if ((pSrcNode->atn_Node < MIN_USABLE_ATALKNODE)	||
		(pSrcNode->atn_Node > MAX_USABLE_ATALKNODE)	||
		(pSrcNode->atn_Network < FIRST_VALID_NETWORK) ||
		(pSrcNode->atn_Network > LAST_VALID_NETWORK))
	{
		UCHAR	AtalkAndMacAddress[sizeof(ATALK_NODEADDR) + MAX_HW_ADDR_LEN];
		DBGPRINT(DBG_COMP_AARP, DBG_LEVEL_ERR,
				("atalkAarpEnterIntoAmt: Bad Node %x, %x\n",
				pSrcNode->atn_Node, pSrcNode->atn_Network));
			
		RtlCopyMemory(AtalkAndMacAddress, pSrcNode, sizeof(ATALK_NODEADDR));
		RtlCopyMemory(AtalkAndMacAddress + sizeof(ATALK_NODEADDR), SrcAddr, MAX_HW_ADDR_LEN);
		LOG_ERRORONPORT(pPortDesc,
						EVENT_ATALK_AMT_INVALIDSOURCE,
						0,
						AtalkAndMacAddress,
						sizeof(AtalkAndMacAddress));
		return;
	}
	
	DBGPRINT(DBG_COMP_AARP, DBG_LEVEL_INFO,
			("AtalkAarpEnterIntoAmt: Entering %x.%x in amt\n",
				pSrcNode->atn_Network, pSrcNode->atn_Node));

	// Do we already know about this mapping?
	index = HASH_ATALK_NODE(pSrcNode) & (PORT_AMT_HASH_SIZE - 1);

	ACQUIRE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);

	for (ppAmt = &pPortDesc->pd_Amt[index];
		 (pAmt = *ppAmt) != NULL;
		 ppAmt = &pAmt->amt_Next)
	{
		ASSERT(VALID_AMT(pAmt));
		if (ATALK_NODES_EQUAL(pSrcNode, &pAmt->amt_Target))
		{
			DBGPRINT(DBG_COMP_AARP, DBG_LEVEL_INFO,
					("atalkAarpEnterIntoAmt: Address %x.%x exists in tables\n",
					pSrcNode->atn_Network, pSrcNode->atn_Node));

			if ((pAmt->amt_RouteInfoLen == 0) ^ (RouteInfoLen == 0))
			{
				DBGPRINT(DBG_COMP_AARP, DBG_LEVEL_WARN,
						("atalkAarpEnterIntoAmt: %x.%x has wrong routing info\n",
						pSrcNode->atn_Network, pSrcNode->atn_Node));

				*ppAmt = pAmt->amt_Next;
				AtalkBPFreeBlock(pAmt);
				pAmt = NULL;
			}
			break;
		}
	}
	
	// If not, allocate a new mapping Node.
	if (pAmt == NULL)
	{
		BLKID	BlkId;

		DBGPRINT(DBG_COMP_AARP, DBG_LEVEL_WARN,
				("atalkAarpEnterIntoAmt: Address %x.%x DOES NOT exist in tables\n",
				pSrcNode->atn_Network, pSrcNode->atn_Node));

		ASSERT(RouteInfoLen <= TLAP_MAX_ROUTING_BYTES);
	
		BlkId = BLKID_AMT;
		if (RouteInfoLen != 0)
			BlkId = BLKID_AMT_ROUTE;
		if ((pAmt = (PAMT)AtalkBPAllocBlock(BlkId)) != NULL)
		{
#if	DBG
			pAmt->amt_Signature = AMT_SIGNATURE;
#endif
			// Link it in. Fill in below
			pAmt->amt_Target.atn_Network = pSrcNode->atn_Network;
			pAmt->amt_Target.atn_Node = pSrcNode->atn_Node;
			pAmt->amt_Next = pPortDesc->pd_Amt[index];
			pPortDesc->pd_Amt[index] = pAmt;
		}
	}

	if (pAmt != NULL)
	{
		// Update mapping table! Do this if we knew about the mapping OR
		// if we allocated a new node

		ASSERTMSG("HWAddrLen is not right!\n", (AddrLen == MAX_HW_ADDR_LEN));

		RtlCopyMemory(pAmt->amt_HardwareAddr, SrcAddr, AddrLen);

		ASSERTMSG("RouteLen is not right!\n", (RouteInfoLen <= MAX_ROUTING_BYTES));

		if (RouteInfoLen > 0)
			RtlCopyMemory((PBYTE)pAmt + sizeof(AMT), RouteInfo, RouteInfoLen);

		pAmt->amt_RouteInfoLen = (BYTE)RouteInfoLen;
		pAmt->amt_Age = 0;
	}

	RELEASE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
}




VOID
AtalkAarpReleaseAmt(
	IN	OUT	PPORT_DESCRIPTOR	pPortDesc
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	int		index;
	PAMT	pAmt, *ppAmt;

	//	Free up all the AMT entries. No need to acquire spinlock at this
	//	point. We are unloading and all binding etc are gone.
	for (index = 0; index < PORT_AMT_HASH_SIZE; index ++)
	{
		for (ppAmt = &pPortDesc->pd_Amt[index];
			 (pAmt = *ppAmt) != NULL;
			 NOTHING)
		{
			ASSERT(VALID_AMT(pAmt));
			*ppAmt = pAmt->amt_Next;
			AtalkBPFreeBlock(pAmt);
		}
	}
}




VOID
AtalkAarpReleaseBrc(
	IN	OUT	PPORT_DESCRIPTOR	pPortDesc
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	int		index;
	PBRE	pBre, *ppBre;

	//	Free up all the BRC entries. No need to acquire spinlock at this
	//	point. We are unloading and all binding etc are gone.
	for (index = 0; index < PORT_BRC_HASH_SIZE; index ++)
	{
		for (ppBre = &pPortDesc->pd_Brc[index];
			 (pBre = *ppBre) != NULL;
			 NOTHING)
		{
			*ppBre = pBre->bre_Next;
			AtalkBPFreeBlock(pBre);
		}
	}
}




LONG FASTCALL
AtalkAarpAmtTimer(
	IN	PTIMERLIST			pTimer,
	IN	BOOLEAN				TimerShuttingDown
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PAMT					pAmt, *ppAmt;
    PPORT_DESCRIPTOR		pPortDesc;
	int						index;

	pPortDesc = (PPORT_DESCRIPTOR)CONTAINING_RECORD(pTimer, PORT_DESCRIPTOR, pd_AmtTimer);
	ASSERT(VALID_PORT(pPortDesc));

	ASSERT(EXT_NET(pPortDesc));

	//	Walk though all address mapping entries on this port aging the entries.
	//	We need to protect the mapping tables with critical sections, but don't
	//	stay in a critical section too long.

	ACQUIRE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);

	if (TimerShuttingDown ||
		((pPortDesc->pd_Flags & PD_CLOSING) != 0))
	{
		RELEASE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);

		//	Remove the reference we added to this port at the time of
		//	starting the timer. Return;
		AtalkPortDereferenceDpc(pPortDesc);
		return ATALK_TIMER_NO_REQUEUE;
	}

	for (index = 0; index < PORT_AMT_HASH_SIZE; index ++)
	{
		for (ppAmt = &pPortDesc->pd_Amt[index];
			 (pAmt = *ppAmt) != NULL;
			 NOTHING)
		{
			ASSERT(VALID_AMT(pAmt));
			if (pAmt->amt_Age < AMT_MAX_AGE)
			{
				DBGPRINT(DBG_COMP_AARP, DBG_LEVEL_INFO,
						("atalkAarpAmtTimer: Entry for %x.%x %lx OK\n",
						pAmt->amt_Target.atn_Network, pAmt->amt_Target.atn_Node,
						pAmt));
				pAmt->amt_Age ++;
				ppAmt = &pAmt->amt_Next;
			}
			else
			{
				DBGPRINT(DBG_COMP_AARP, DBG_LEVEL_WARN,
						("atalkAarpAmtTimer: Freeing node %x.%x from list\n",
						pAmt->amt_Target.atn_Network,
						pAmt->amt_Target.atn_Node));
				*ppAmt = pAmt->amt_Next;
				AtalkBPFreeBlock(pAmt);
			}
		}
	}

	RELEASE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);

	return ATALK_TIMER_REQUEUE;
}




LONG FASTCALL
AtalkAarpBrcTimer(
	IN	PTIMERLIST			pTimer,
	IN	BOOLEAN				TimerShuttingDown
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	int					index;
    PPORT_DESCRIPTOR	pPortDesc;
	BOOLEAN				DerefPort = FALSE;

	pPortDesc = (PPORT_DESCRIPTOR)CONTAINING_RECORD(pTimer, PORT_DESCRIPTOR, pd_BrcTimer);
	
	ASSERT(VALID_PORT(pPortDesc));
	ASSERT(EXT_NET(pPortDesc));

	//	Walk though all best router entries on this port aging the entries.
	//	We need to protect the brc tables with critical sections, but don't
	//	stay in a critical section too long.

	ACQUIRE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);

	if (TimerShuttingDown ||
		((pPortDesc->pd_Flags & PD_CLOSING) != 0))
	{
		RELEASE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);

		//	Remove the reference we added to this port at the time of
		//	starting the timer. Return;
		AtalkPortDereferenceDpc(pPortDesc);
		return ATALK_TIMER_NO_REQUEUE;
	}

	for (index = 0; index < PORT_BRC_HASH_SIZE; index ++)
	{
		PBRE	pBre, *ppBre;

		for (ppBre = &pPortDesc->pd_Brc[index];
			 (pBre = *ppBre) != NULL;
			 NOTHING)
		{
			if (pBre->bre_Age < BRC_MAX_AGE)
			{
				pBre->bre_Age ++;
				ppBre = &pBre->bre_Next;
			}
			else
			{
				*ppBre = pBre->bre_Next;
				AtalkBPFreeBlock(pBre);
			}
		}
	}

	RELEASE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);

	return ATALK_TIMER_REQUEUE;
}




PBUFFER_DESC
AtalkAarpBuildPacket(
	IN		PPORT_DESCRIPTOR	pPortDesc,
	IN		USHORT				Type,
	IN		USHORT				HardwareLen,
	IN		PBYTE				SrcHardwareAddr,
	IN		ATALK_NODEADDR		SrcLogicalAddr,
	IN		PBYTE				DestHardwareAddr,
	IN		ATALK_NODEADDR		DestLogicalAddr,
	IN		PBYTE				TrueDest,
	IN		PBYTE				RouteInfo,
	IN		USHORT				RouteInfoLen
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PBYTE			aarpData;
	USHORT			linkLen;

	PBUFFER_DESC	pBuffDesc = NULL;
	BYTE			protocolLength 	= AARP_PROTO_ADDR_LEN;
    PVOID           pRasConn;
    DWORD           dwFlags;
    BOOLEAN         fThisIsPPP;


	//	Read only.
	static	BYTE	zeroAddr[MAX_HW_ADDR_LEN] =
	{
		0, 0, 0, 0, 0, 0
	};

#if DBG
    // make sure we aren't sending AARP request/probe for our own dial-in client
    if ((Type == AARP_REQUEST) || (Type == AARP_PROBE))
    {
        pRasConn = FindAndRefRasConnByAddr(DestLogicalAddr, &dwFlags, &fThisIsPPP);
        if (pRasConn)
        {
            if (fThisIsPPP)
            {
                ASSERT(((PATCPCONN)pRasConn)->Signature == ATCPCONN_SIGNATURE);

                if (dwFlags & ATCP_NODE_IN_USE)
                {
			        DBGPRINT(DBG_COMP_AARP, DBG_LEVEL_ERR,
				    ("AtalkAarpBuildPacket: PPP client (%lx) owns %x.%x (Type=%x)\n",
			        pRasConn,DestLogicalAddr.atn_Network, DestLogicalAddr.atn_Node,Type));
                }

                DerefPPPConn((PATCPCONN)pRasConn);
            }
            else
            {
                ASSERT(((PARAPCONN)pRasConn)->Signature == ARAPCONN_SIGNATURE);

                if (dwFlags & ARAP_NODE_IN_USE)
                {
			        DBGPRINT(DBG_COMP_AARP, DBG_LEVEL_ERR,
				    ("AtalkAarpBuildPacket: ARA client (%lx) owns %x.%x (Type=%x)\n",
			        pRasConn,DestLogicalAddr.atn_Network, DestLogicalAddr.atn_Node,Type));
                }

                DerefArapConn((PARAPCONN)pRasConn);
            }
        }
    }
#endif

	//	If no destination hardware address is specified, set it
	//	to all zeros.
	if (DestHardwareAddr == NULL)
	{
		DestHardwareAddr = zeroAddr;
	}

	//	Get a header buffer allocated from link routines. Tell it we want
	//	maximum aarp data size as the required size.
	AtalkNdisAllocBuf(&pBuffDesc);
	if (pBuffDesc == NULL)
	{
		return(pBuffDesc);
	}

	//	Build the LAP header.
	AtalkNdisBuildHdr(pPortDesc,
					  pBuffDesc->bd_CharBuffer,
					  linkLen,
					  AARP_MIN_DATA_SIZE,
					  TrueDest,
					  RouteInfo,
					  RouteInfoLen,
					  AARP_PROTOCOL);

	aarpData	=	pBuffDesc->bd_CharBuffer + linkLen;

	//	Build the specified type of AARP packet with the specified information;
	PUTSHORT2SHORT((PUSHORT)aarpData,
					pPortDesc->pd_AarpHardwareType);

	aarpData	+= sizeof(USHORT);

	PUTSHORT2SHORT((PUSHORT)aarpData,
					pPortDesc->pd_AarpProtocolType);

	aarpData	+= sizeof(USHORT);

	*aarpData++	= (BYTE)HardwareLen;
	*aarpData++ = (BYTE)AARP_PROTO_ADDR_LEN;
	
	PUTSHORT2SHORT((PUSHORT)aarpData, Type);
	
	aarpData	+= sizeof(USHORT);

	// Source hardware address.
	RtlCopyMemory(aarpData, SrcHardwareAddr, HardwareLen);

	aarpData += HardwareLen;

	// Source logical address pad
	*aarpData++ = 0;

	// Network number
	PUTSHORT2SHORT(aarpData, SrcLogicalAddr.atn_Network);

	aarpData += sizeof(USHORT);

	// Node number
	*aarpData++ = SrcLogicalAddr.atn_Node;

	// Destination hardware address.
	RtlCopyMemory(aarpData, DestHardwareAddr, HardwareLen);

	aarpData += HardwareLen;
	
	// Destination logical address, null pad
	*aarpData++ = 0;

	// Network number
	PUTSHORT2SHORT(aarpData, DestLogicalAddr.atn_Network);

	aarpData += sizeof(USHORT);

	// Node number
	*aarpData++ = DestLogicalAddr.atn_Node;

	//	Set length in the buffer descriptor. Pad it to max data size. Some devices seem
	// to drop the aarp responses if they see less, Macs dictate their behavior.
	// Also zero out the extra space.
	AtalkSetSizeOfBuffDescData(pBuffDesc,
							   (SHORT)(aarpData - pBuffDesc->bd_CharBuffer + AARP_MAX_DATA_SIZE - AARP_MIN_DATA_SIZE));
	RtlZeroMemory(aarpData, AARP_MAX_DATA_SIZE - AARP_MIN_DATA_SIZE);

	return pBuffDesc;
}




LOCAL VOID FASTCALL
atalkAarpTuneRouteInfo(
	IN		PPORT_DESCRIPTOR	pPortDesc,
	IN	OUT	PBYTE				RouteInfo
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	//	Given an incoming TokenRing routing info, tune it to make it valid
	//  for outing routing info.  Do this in place!
	ASSERT(pPortDesc->pd_PortType == TLAP_PORT);
	
	// Set to "non-broadcast" and invert "direction".
	RouteInfo[0] &= TLAP_NON_BROADCAST_MASK;
	RouteInfo[1] ^= TLAP_DIRECTION_MASK;
}


#if DBG

VOID
AtalkAmtDumpTable(
	VOID
)
{
	int					j, k;
	KIRQL				OldIrql;
	PPORT_DESCRIPTOR	pPortDesc;
	PAMT				pAmt;

	ACQUIRE_SPIN_LOCK(&AtalkPortLock, &OldIrql);

	for (pPortDesc = AtalkPortList;
		 pPortDesc != NULL;
		 pPortDesc = pPortDesc = pPortDesc->pd_Next)
	{
		DBGPRINT(DBG_COMP_DUMP, DBG_LEVEL_FATAL,
				("AMT Table for port %Z\n", &pPortDesc->pd_AdapterKey));

		ACQUIRE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);

		for (j = 0; j < PORT_AMT_HASH_SIZE; j++)
		{
			for (pAmt = pPortDesc->pd_Amt[j];
				 pAmt != NULL;
				 pAmt = pAmt->amt_Next)
			{
				DBGPRINTSKIPHDR(DBG_COMP_DUMP, DBG_LEVEL_FATAL,
								("\t%d:  %lx.%lx", j,
								pAmt->amt_Target.atn_Network, pAmt->amt_Target.atn_Node));

				for (k = 0; k < MAX_HW_ADDR_LEN; k++)
				{
					DBGPRINTSKIPHDR(DBG_COMP_DUMP, DBG_LEVEL_FATAL,
						("%02x", pAmt->amt_HardwareAddr[k]));
				}

				if (pAmt->amt_RouteInfoLen != 0)
				{
					PBYTE	pRouteInfo;

					pRouteInfo = (PBYTE)pAmt + sizeof(AMT);

					DBGPRINTSKIPHDR(DBG_COMP_DUMP, DBG_LEVEL_FATAL,
									(" ("));
					for (k = 0; k < pAmt->amt_RouteInfoLen; k++)
					{
						DBGPRINTSKIPHDR(DBG_COMP_DUMP, DBG_LEVEL_FATAL,
							(" %02x", pRouteInfo[k]));
					}
					DBGPRINTSKIPHDR(DBG_COMP_DUMP, DBG_LEVEL_FATAL, (" )"));
				}
				DBGPRINTSKIPHDR(DBG_COMP_DUMP, DBG_LEVEL_FATAL, ("\n"));
			}
		}
		RELEASE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
		DBGPRINTSKIPHDR(DBG_COMP_DUMP, DBG_LEVEL_FATAL, ("\n"));
	}

	RELEASE_SPIN_LOCK(&AtalkPortLock, OldIrql);
}

#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\atalk\sys\aep.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	aep.h

Abstract:

	This module contains the echo protocol definitions

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	19 Jun 1992		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef	_AEP_
#define	_AEP_

#define		EP_COMMAND_OFFSET		0
#define		EP_COMMAND_REQUEST		1
#define		EP_COMMAND_REPLY		2

VOID
AtalkAepPacketIn(
	IN	PPORT_DESCRIPTOR	pPortDesc,
	IN	PDDP_ADDROBJ		pDdpAddr,
	IN	PBYTE				pPkt,
	IN	USHORT				PktLen,
	IN	PATALK_ADDR			pSrcAddr,
	IN	PATALK_ADDR			pDestAddr,
	IN	ATALK_ERROR			ErrorCode,
	IN	BYTE				DdpType,
	IN	PVOID				pHandlerCtx,
	IN	BOOLEAN				OptimizePath,
	IN	PVOID				OptimizeCtx
);

VOID FASTCALL
atalkAepSendComplete(
	IN	NDIS_STATUS			Status,
	IN	PSEND_COMPL_INFO	pSendInfo
);


#endif	// _AEP_


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\atalk\sys\adsp.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	adsp.h

Abstract:

	This module contains definitions for the ADSP code.

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	20 May 1993		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef	_ADSP_
#define	_ADSP_

// ADSP_ version.

#define ADSP_VERSION	 				0x0100

// ADSP_ field offsets within a Ddp datagram.
#define ADSP_SRC_CONNID_OFF				0
#define ADSP_FIRST_BYTE_SEQNUM_OFF		2
#define ADSP_THIS_ATTEN_SEQNUM_OFF		2
#define ADSP_NEXT_RX_BYTESEQNUM_OFF		6
#define ADSP_NEXT_RX_ATTNSEQNUM_OFF		6
#define ADSP_RX_WINDOW_SIZE_OFF			10
#define ADSP_RX_ATTEN_SIZE_OFF			10
#define ADSP_DESCRIPTOR_OFF				12
#define ADSP_DATA_OFF					13
#define ADSP_VERSION_STAMP_OFF			13
#define ADSP_ATTEN_CODE_OFF				13
#define ADSP_ATTEN_DATA_OFF				15
#define ADSP_DEST_CONNID_OFF			15
#define ADSP_NEXT_ATTEN_SEQNUM_OFF		17

// Bit fields in the ADSP_ descriptor
#define ADSP_CONTROL_FLAG	    		0x80
#define ADSP_ACK_REQ_FLAG				0x40
#define ADSP_EOM_FLAG 					0x20
#define ADSP_ATTEN_FLAG					0x10

// Control codes in the ADSP_ descriptor:
#define ADSP_CONTROL_MASK				0x0F
#define ADSP_PROBE_OR_ACK_CODE			0
#define ADSP_OPENCONN_REQ_CODE			1
#define ADSP_OPENCONN_ACK_CODE			2
#define ADSP_OPENCONN_REQANDACK_CODE	3
#define ADSP_OPENCONN_DENY_CODE			4
#define ADSP_CLOSE_CONN_CODE			5
#define ADSP_FORWARD_RESET_CODE			6
#define ADSP_FORWARD_RESETACK_CODE		7
#define ADSP_RETRANSMIT_CODE			8

// Data sizes:
#define ADSP_MAX_DATA_SIZE				572
#define ADSP_MAX_ATTEN_DATA_SIZE		570
#define ADSP_MAX_ATTEN_PKT_SIZE			572
#define	ADSP_MIN_ATTEN_PKT_SIZE			sizeof(USHORT)

// Largest allowed send/receive window size.
#define ADSP_MAX_SEND_RX_WINDOW_SIZE	0xFFFF
#define ADSP_DEF_SEND_RX_WINDOW_SIZE	((1024*8)+1)		// 8K + 1 (EOM)

// Attention code info:
#define ADSP_MIN_ATTENCODE			    0x0000
#define ADSP_MAX_ATTENCODE			    0xEFFF

// How long do we try Open's for?
#define ADSP_MAX_OPEN_ATTEMPTS			10
#define ADSP_OPEN_INTERVAL				20		// In 100ms units

// Connection maintenance timer values:
#define ADSP_PROBE_INTERVAL 			30
#define ADSP_CONNECTION_INTERVAL		1200	// In 100ms units

// Retransmit timer values:
#define ADSP_RETRANSMIT_INTERVAL		20		// In 100ms units

// How often do we retransmit attentions?
#define ADSP_ATTENTION_INTERVAL			20		// In 100ms units

#define ADSP_DISCONNECT_DELAY			7		// In 100ms units

// How often do we retransmit forward resets?
#define ADSP_FORWARD_RESET_INTERVAL		20		// In 100ms units

// How many out of sequence packets do we allow before requesting a retransmition.
#define ADSP_OUT_OF_SEQ_PACKETS_MAX		3

// For resolving forward references
struct _ADSP_CONNOBJ;
struct _ADSP_ADDROBJ;

typedef	enum
{
	ADSP_SEND_QUEUE,
	ADSP_RECV_QUEUE

} ADSP_QUEUE_TYPE;


#define		BC_EOM			(USHORT)0x0001
#define		BC_SEND			(USHORT)0x0002
#define		BC_DISCONNECT	(USHORT)0x4000
#define		BC_CLOSING		(USHORT)0x8000

//	We use buffer chunks for the send receive queues
typedef	struct _BUFFER_CHUNK
{
	struct _BUFFER_CHUNK *	bc_Next;
	ATALK_SPIN_LOCK			bc_Lock;
	ULONG					bc_RefCount;

	//	Size of data copied over from the users mdl. This
	//	could be less than the size of the users data.
	USHORT					bc_DataSize;
	USHORT					bc_Flags;

	//	Write completion information. This is only valid if
	//	the BC_SEND bit is set. With a week left to ship, i'm
	//	wimping out and making a copy to keep things as consistent
	//	and stable as possible. Eventually though, we should just
	//	use the User's buffer to make mdl's out of.
	PAMDL						bc_WriteBuf;
	GENERIC_WRITE_COMPLETION	bc_WriteCompletion;
	PVOID						bc_WriteCtx;
	ATALK_ERROR					bc_WriteError;

	//	Backpointer to the connection object on which this is queued
	struct _ADSP_CONNOBJ 	*	bc_ConnObj;

	//
	//	BYTE	bc_Data[]
	//

} BUFFER_CHUNK, *PBUFFER_CHUNK;



//	Buffer queues used for send/receive
typedef struct _BUFFER_QUEUE
{
	ULONG					bq_StartIndex;
	PBUFFER_CHUNK			bq_Head;
	PBUFFER_CHUNK			bq_Tail;

} BUFFER_QUEUE, *PBUFFER_QUEUE;


#define	ADSP_CONN_HASH_SIZE		23


// ADSP ADDRESS OBJECT STATES
#define	ADSPAO_LISTENER			0x00000001
#define	ADSPAO_CONNECT			0x00000002
#define	ADSPAO_MESSAGE			0x00000010
#define	ADSPAO_CLOSING			0x80000000

#define	ADSPAO_SIGNATURE		(*(PULONG)"ADAO")

#define	VALID_ADSPAO(pAdspAddr)	(((pAdspAddr) != NULL) && \
		(((struct _ADSP_ADDROBJ *)(pAdspAddr))->adspao_Signature == ADSPAO_SIGNATURE))

typedef struct _ADSP_ADDROBJ
{
	ULONG					adspao_Signature;

	//	Global list of address objects.
	struct _ADSP_ADDROBJ  *	adspao_pNextGlobal;

	ULONG					adspao_Flags;
	ULONG					adspao_RefCount;
	ATALK_SPIN_LOCK			adspao_Lock;
	PATALK_DEV_CTX			adspao_pDevCtx;

	//	List of connections associated with this address object.
	//	Potentially greater than one if this address object is a listener.
	struct	_ADSP_CONNOBJ *	adspao_pAssocConn;

	//	List of connections that are associated, but also have a listen/connect
	//	posted on them.
	union
	{
		struct	_ADSP_CONNOBJ *	adspao_pListenConn;
		struct	_ADSP_CONNOBJ *	adspao_pConnectConn;
	};

	//	List of indicated connections waiting for acceptance.
	struct _ADSP_OPEN_REQ *	adspao_OpenReq;

	//	Lookup list of all active connections hashed by connId and remote
	//	address.
	struct	_ADSP_CONNOBJ *	adspao_pActiveHash[ADSP_CONN_HASH_SIZE];

	//	Next connection to use.
	USHORT					adspao_NextConnId;

	//	Event support routines.
    //
    // This function pointer points to a connection indication handler for this
    // Address. Any time a connect request is received on the address, this
    // routine is invoked.
    PTDI_IND_CONNECT 			adspao_ConnHandler;
    PVOID 						adspao_ConnHandlerCtx;

    PTDI_IND_DISCONNECT 		adspao_DisconnectHandler;
    PVOID 						adspao_DisconnectHandlerCtx;

    PTDI_IND_RECEIVE 			adspao_RecvHandler;
    PVOID 						adspao_RecvHandlerCtx;

    PTDI_IND_RECEIVE_EXPEDITED	adspao_ExpRecvHandler;
    PVOID 						adspao_ExpRecvHandlerCtx;

    PTDI_IND_SEND_POSSIBLE  	adspao_SendPossibleHandler;
    PVOID   					adspao_SendPossibleHandlerCtx;

	//	DDP Address for this adsp address. If this is a listener, then the DDP
	//	address will be what the listens effectively will be posted on. This
	//	will also be the address over which the connections will be active.
    //	if this is a connect address object, then this ddp address will be what the
	//	associated connection be active over.
	PDDP_ADDROBJ				adspao_pDdpAddr;

	// Completion routine to be called when address is closed
	GENERIC_COMPLETION		adspao_CloseComp;
	PVOID					adspao_CloseCtx;

} ADSP_ADDROBJ, *PADSP_ADDROBJ;


#define	ADSPCO_ASSOCIATED			0x00000001
#define	ADSPCO_IND_RECV				0x00000002
#define	ADSPCO_LISTENING			0x00000004
#define	ADSPCO_CONNECTING			0x00000008
#define	ADSPCO_ACCEPT_IRP			0x00000010
#define	ADSPCO_LISTEN_IRP			0x00000020
#define	ADSPCO_HALF_ACTIVE			0x00000040
#define	ADSPCO_ACTIVE				0x00000080
#define	ADSPCO_SEEN_REMOTE_OPEN		0x00000100
#define	ADSPCO_DISCONNECTING		0x00000200
#define	ADSPCO_SERVER_JOB			0x00000400
#define	ADSPCO_REMOTE_CLOSE			0x00000800
#define	ADSPCO_SEND_IN_PROGRESS		0x00001000
#define	ADSPCO_SEND_DENY			0x00002000
#define	ADSPCO_SEND_OPENACK			0x00004000
#define	ADSPCO_SEND_WINDOW_CLOSED	0x00008000
#define	ADSPCO_READ_PENDING			0x00010000
#define	ADSPCO_EXREAD_PENDING		0x00020000
#define	ADSPCO_FORWARD_RESET_RECD	0x00040000
#define	ADSPCO_ATTN_DATA_RECD		0x00080000
#define	ADSPCO_ATTN_DATA_EOM		0x00100000
#define	ADSPCO_EXSEND_IN_PROGRESS	0x00200000
#define	ADSPCO_OPEN_TIMER			0x01000000
#define	ADSPCO_RETRANSMIT_TIMER		0x02000000
#define	ADSPCO_CONN_TIMER			0x04000000
#define	ADSPCO_LOCAL_DISCONNECT		0x08000000
#define	ADSPCO_REMOTE_DISCONNECT	0x10000000
#define	ADSPCO_DELAYED_DISCONNECT	0x20000000
#define	ADSPCO_STOPPING				0x40000000
#define	ADSPCO_CLOSING				0x80000000

#define	ADSPCO_SIGNATURE			(*(PULONG)"ADCO")

#define	VALID_ADSPCO(pAdspConn)	(((pAdspConn) != NULL) && \
		(((struct _ADSP_CONNOBJ *)(pAdspConn))->adspco_Signature == ADSPCO_SIGNATURE))

// This will represent a 'job' on the Pap address. This could either be a
// workstation job or a server job. In the latter case it could either
// be in a 'listen' state or active state. In the former case it is either
// active or 'waiting'
typedef struct _ADSP_CONNOBJ
{
	ULONG						adspco_Signature;

	//	Used to queue into the address object's associated list.
	struct	_ADSP_CONNOBJ *		adspco_pNextAssoc;

	ULONG						adspco_Flags;
	ULONG						adspco_RefCount;
	ATALK_SPIN_LOCK				adspco_Lock;
	PATALK_DEV_CTX				adspco_pDevCtx;

	//	!!!NOTE!!!
	//	The address this connection uses will be the address object's DDP address.
	PDDP_ADDROBJ				adspco_pDdpAddr;

	//	Used to queue into the address object's listen/connect list. When it
	//	is removed from the listen/connect, it goes into the active list of the
	//	address object.
	union
	{
		struct	_ADSP_CONNOBJ *	adspco_pNextListen;
		struct	_ADSP_CONNOBJ *	adspco_pNextConnect;
		struct	_ADSP_CONNOBJ *	adspco_pNextActive;
	};

	//	Global list of connection objects.
	struct _ADSP_CONNOBJ	*	adspco_pNextGlobal;

	//	Used to queue into the lookup by remote connid/remote address
	//	list in address obj.
	struct	_ADSP_CONNOBJ *		adspco_pHashNext;

	//	Backpointer to the associated address
	struct _ADSP_ADDROBJ  *		adspco_pAssocAddr;

	//	Address of remote end of the connection
	ATALK_ADDR					adspco_RemoteAddr;

	//	Connection ids
	USHORT						adspco_LocalConnId;
	USHORT						adspco_RemoteConnId;

	//	Connection timer. During open time this will be the open timer.
	union
	{
		TIMERLIST				adspco_ConnTimer;
		TIMERLIST				adspco_OpenTimer;
	};

	TIMERLIST					adspco_RetransmitTimer;
	ULONG						adspco_LastTimerRtmtSeq;
	LONG						adspco_LastContactTime;

	//	Connection context
	PVOID						adspco_ConnCtx;

	//	List of pended sends
	LIST_ENTRY					adspco_PendedSends;

	//	Sequence numbers
	ULONG						adspco_SendSeq;
	ULONG						adspco_FirstRtmtSeq;
	ULONG						adspco_SendWindowSeq;
	ULONG						adspco_SendAttnSeq;

	ULONG						adspco_RecvSeq;
	ULONG						adspco_RecvAttnSeq;

	//	Window/buffers
	LONG						adspco_RecvWindow;
	LONG						adspco_SendQueueMax;
	LONG						adspco_RecvQueueMax;

	//	Previously indicated data
	ULONG						adspco_PrevIndicatedData;

	//	Buffer queues
	BUFFER_QUEUE				adspco_SendQueue;
	BUFFER_QUEUE				adspco_NextSendQueue;
	BUFFER_QUEUE				adspco_RecvQueue;

	//	Number of out of sequence packets received
	ULONG						adspco_OutOfSeqCount;

	//	The connection object can have either a CONNECT or a LISTEN posted
	//	on it, but not both.
	union
	{
		struct
		{
			//	Pending Listen routine.
			GENERIC_COMPLETION	adspco_ListenCompletion;
			PVOID				adspco_ListenCtx;
		};

		struct
		{
			//	Pending Connect routine. The status buffer is remember and
			//	returned via socket options. The pConnectRespBuf is remembered
			//	to avoid having to get the system address for it. It is freed
			//	when connection is taken off the connectlist.
			GENERIC_COMPLETION	adspco_ConnectCompletion;
			PVOID				adspco_ConnectCtx;
			ULONG				adspco_ConnectAttempts;
		};
	};

	//	Read completion information
	ULONG						adspco_ReadFlags;
	PAMDL						adspco_ReadBuf;
	USHORT						adspco_ReadBufLen;
	GENERIC_READ_COMPLETION		adspco_ReadCompletion;
	PVOID						adspco_ReadCtx;

	PBYTE						adspco_ExRecdData;
	USHORT						adspco_ExRecdLen;

	//	Expedited Read completion information
	ULONG						adspco_ExReadFlags;
	USHORT						adspco_ExReadBufLen;
	PAMDL						adspco_ExReadBuf;
	GENERIC_READ_COMPLETION		adspco_ExReadCompletion;
	PVOID						adspco_ExReadCtx;

	//	Expedited Write completion information
	TIMERLIST					adspco_ExRetryTimer;
	PBYTE						adspco_ExWriteChBuf;

	ULONG						adspco_ExWriteFlags;
	USHORT						adspco_ExWriteBufLen;
	PAMDL						adspco_ExWriteBuf;
	GENERIC_WRITE_COMPLETION	adspco_ExWriteCompletion;
	PVOID						adspco_ExWriteCtx;

	//	Disconnect inform routine
	GENERIC_COMPLETION			adspco_DisconnectInform;
	PVOID						adspco_DisconnectInformCtx;

	//	Disconnect request completion
	ATALK_ERROR					adspco_DisconnectStatus;
	GENERIC_COMPLETION			adspco_DisconnectCompletion;
	PVOID						adspco_DisconnectCtx;

	// The following is a hack to get around the problem of rcv/disconnet race condn.
	// Since this involves major rework, a safe approach is taken
	TIMERLIST					adspco_DisconnectTimer;

	//	Cleanup irp completion
	GENERIC_COMPLETION			adspco_CleanupComp;
	PVOID						adspco_CleanupCtx;

	// Completion routine to be called when socket is closed
	GENERIC_COMPLETION			adspco_CloseComp;
	PVOID						adspco_CloseCtx;

} ADSP_CONNOBJ, *PADSP_CONNOBJ;


//	Used for the list of indicated connections waiting acceptance
typedef struct _ADSP_OPEN_REQ
{
    struct _ADSP_OPEN_REQ  *	or_Next;
	ATALK_ADDR					or_RemoteAddr;
	ULONG						or_FirstByteSeq;
	ULONG						or_NextRecvSeq;
	LONG						or_RecvWindow;
	USHORT						or_RemoteConnId;

} ADSP_OPEN_REQ, *PADSP_OPEN_REQ;



//	Routine prototypes
VOID
AtalkInitAdspInitialize(
	VOID);

ATALK_ERROR
AtalkAdspCreateAddress(
	IN	PATALK_DEV_CTX			pDevCtx	OPTIONAL,
	IN	BYTE					SocketType,
	OUT	PADSP_ADDROBJ	*		ppAdspAddr);

ATALK_ERROR
AtalkAdspCleanupAddress(
	IN	PADSP_ADDROBJ			pAdspAddr);

ATALK_ERROR
AtalkAdspCloseAddress(
	IN	PADSP_ADDROBJ			pAdspAddr,
	IN	GENERIC_COMPLETION		CompletionRoutine,
	IN	PVOID					pCloseCtx);

ATALK_ERROR
AtalkAdspCreateConnection(
	IN	PVOID					pConnCtx,	// Context to associate with the session
	IN	PATALK_DEV_CTX			pDevCtx		OPTIONAL,
	OUT	PADSP_CONNOBJ 	*		ppAdspConn);

ATALK_ERROR
AtalkAdspCloseConnection(
	IN	PADSP_CONNOBJ			pAdspConn,
	IN	GENERIC_COMPLETION		CompletionRoutine,
	IN	PVOID					pCloseCtx);

ATALK_ERROR
AtalkAdspCleanupConnection(
	IN	PADSP_CONNOBJ			pAdspConn);

ATALK_ERROR
AtalkAdspAssociateAddress(
	IN	PADSP_ADDROBJ			pAdspAddr,
	IN	PADSP_CONNOBJ			pAdspConn);

ATALK_ERROR
AtalkAdspDissociateAddress(
	IN	PADSP_CONNOBJ			pAdspConn);

ATALK_ERROR
AtalkAdspPostListen(
	IN	PADSP_CONNOBJ			pAdspConn,
	IN	PVOID					pListenCtx,
	IN	GENERIC_COMPLETION		CompletionRoutine);

ATALK_ERROR
AtalkAdspCancelListen(
	IN	PADSP_CONNOBJ			pAdspConn)		;

ATALK_ERROR
AtalkAdspPostConnect(
	IN	PADSP_CONNOBJ			pAdspConn,
	IN	PATALK_ADDR				pRemoteAddr,
	IN	PVOID					pConnectCtx,
	IN	GENERIC_COMPLETION		CompletionRoutine);

ATALK_ERROR
AtalkAdspDisconnect(
	IN	PADSP_CONNOBJ			pAdspConn,
	IN	ATALK_DISCONNECT_TYPE	DisconnectType,
	IN	PVOID					pDisconnectCtx,
	IN	GENERIC_COMPLETION		CompletionRoutine);

ATALK_ERROR
AtalkAdspRead(
	IN	PADSP_CONNOBJ			pAdspConn,
	IN	PAMDL					pReadBuf,
	IN	USHORT					ReadBufLen,
	IN	ULONG					ReadFlags,
	IN	PVOID					pReadCtx,
	IN	GENERIC_READ_COMPLETION	CompletionRoutine);

ATALK_ERROR
AtalkAdspWrite(
	IN	PADSP_CONNOBJ			pAdspConn,
	IN	PAMDL					pWriteBuf,
	IN	USHORT					WriteBufLen,
	IN	ULONG					SendFlags,
	IN	PVOID					pWriteCtx,
	IN	GENERIC_WRITE_COMPLETION CompletionRoutine);

VOID
AtalkAdspQuery(
	IN	PVOID					pObject,
	IN	ULONG					ObjectType,
	IN	PAMDL					pAmdl,
	OUT	PULONG					BytesWritten);

VOID
atalkAdspAddrRefNonInterlock(
	IN	PADSP_ADDROBJ			pAdspAddr,
	OUT	PATALK_ERROR			pError);

VOID
atalkAdspAddrDeref(
	IN	PADSP_ADDROBJ			pAdspAddr);

VOID
atalkAdspConnRefByPtrNonInterlock(
	IN	PADSP_CONNOBJ			pAdspConn,
	IN	ULONG					NumCount,
	OUT	PATALK_ERROR			pError);

VOID
atalkAdspConnRefByCtxNonInterlock(
	IN	PADSP_ADDROBJ			pAdspAddr,
	IN	CONNECTION_CONTEXT		Ctx,
	OUT	PADSP_CONNOBJ	*		pAdspConn,
	OUT	PATALK_ERROR			pError);

VOID
atalkAdspConnRefBySrcAddr(
	IN	PADSP_ADDROBJ			pAdspAddr,
	IN	PATALK_ADDR				pRemoteAddr,
	IN	USHORT					RemoteConnId,
	OUT	PADSP_CONNOBJ *			ppAdspConn,
	OUT	PATALK_ERROR			pError);

VOID
atalkAdspConnRefNextNc(
	IN		PADSP_CONNOBJ		pAdspConn,
	IN		PADSP_CONNOBJ	*	ppAdspConnNext,
	OUT		PATALK_ERROR		pError);

VOID
AtalkAdspProcessQueuedSend(
	IN	PADSP_CONNOBJ			pAdspConn);

VOID
atalkAdspConnDeref(
	IN	PADSP_CONNOBJ			pAdspConn);




//	MACROS
#define	UNSIGNED_BETWEEN_WITH_WRAP(Low, High, Target)				\
		((Low <= High) ? ((Target >= Low) && (Target <= High))	:	\
						 ((Target >= Low) || (Target <= High)))

//	This didnt make sense until JameelH explained what was going on.
//	This is with the assumption that the window size will never be greater
//	than the difference of 0x80000 and 0x10000. If High is < 10000 and Low
//	is > 80000 then we can assume a wrap happened. Otherwise, we assume no
//	wrap and do a straight compare.
#define UNSIGNED_GREATER_WITH_WRAP(High, Low)							\
		(((High < 0x10000) && (Low > 0x80000)) ? TRUE : (High > Low))
		//	(((High < 0x80000) && (Low > 0x10000)) ? TRUE : (High > Low))


#define	AtalkAdspGetDdpAddress(pAdspAddr)								\
		((pAdspAddr)->adspao_pDdpAddr)

#define	AtalkAdspAddrReferenceNonInterlock(pAdspAddr, pError)			\
		{																\
			DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO, ("RefAddr %lx at %s %d - %d\n",	\
			pAdspAddr, __FILE__, __LINE__, ((pAdspAddr)->adspao_RefCount)));		\
			atalkAdspAddrRefNonInterlock(pAdspAddr, pError);			\
		}

#define	AtalkAdspAddrReference(pAdspAddr, pError)						\
		{																\
			KIRQL	OldIrql;											\
																		\
			ACQUIRE_SPIN_LOCK(&(pAdspAddr)->adspao_Lock, &OldIrql);		\
			AtalkAdspAddrReferenceNonInterlock(pAdspAddr, pError);		\
			RELEASE_SPIN_LOCK(&(pAdspAddr)->adspao_Lock, OldIrql);		\
		}

#define	AtalkAdspAddrDereference(pAdspAddr)											\
		{																			\
			DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO, ("DerefAddr %lx at %s %d - %d\n",\
			pAdspAddr, __FILE__, __LINE__, ((pAdspAddr)->adspao_RefCount)));	\
			atalkAdspAddrDeref(pAdspAddr);											\
		}

#define	AtalkAdspConnReferenceByPtrNonInterlock(pAdspConn, NumCount, pError)		\
		{																			\
			atalkAdspConnRefByPtrNonInterlock(pAdspConn, NumCount, pError);			\
		}

#define	AtalkAdspConnReferenceByPtr(pAdspConn, pError)					\
		{																\
			KIRQL	OldIrql;											\
																		\
			ACQUIRE_SPIN_LOCK(&(pAdspConn)->adspco_Lock, &OldIrql);		\
			AtalkAdspConnReferenceByPtrNonInterlock(pAdspConn, 1, pError);\
			RELEASE_SPIN_LOCK(&(pAdspConn)->adspco_Lock, OldIrql);		\
		}

#define	AtalkAdspConnReferenceByCtxNonInterlock(pAdspAddr, Ctx, ppAdspConn, pError)	\
		atalkAdspConnRefByCtxNonInterlock(pAdspAddr, Ctx, ppAdspConn, pError)

#define	AtalkAdspConnReferenceBySrcAddr(pAdspAddr, pSrc, SessId, pErr)		\
		atalkAdspConnRefBySrcAddr(pAdspAddr, pSrc, SessId, pErr)

#define	AtalkAdspConnDereference(pAdspConn)							\
		{															\
			DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,					\
					("DerefConn %lx at %s %d - %d\n",				\
					pAdspConn, __FILE__, __LINE__,					\
					(pAdspConn)->adspco_RefCount));					\
			atalkAdspConnDeref(pAdspConn);							\
		}

//	How many bytes/seqnums does eom occupy?
#define	BYTECOUNT(eom)		((ULONG)((eom) ? 1 : 0))

//
// PLIST_ENTRY
// WRITECTX_LINKAGE(
//     IN PVOID WriteCtx
// );
//
// Returns a pointer to a linkage field in the write context (Assumed to be IRP).
//

#define WRITECTX_LINKAGE(_Request) \
    (&(((PIRP)_Request)->Tail.Overlay.ListEntry))


#define	WRITECTX(_Request)	((PIRP)(_Request))

//
// PVOID
// LIST_ENTRY_TO_WRITECTX(
//     IN PLIST_ENTRY ListEntry
// );
//
// Returns a request given a linkage field in it.
//

#define LIST_ENTRY_TO_WRITECTX(_ListEntry) \
    ((PVOID)(CONTAINING_RECORD(_ListEntry, IRP, Tail.Overlay.ListEntry)))

//
// PVOID
// WRITECTX_TDI_BUFFER
//     IN PVOID Request
// );
//
// Returns the TDI buffer chain associated with a request.
//

#define WRITECTX_TDI_BUFFER(_Request) \
    ((PVOID)(((PIRP)(_Request))->MdlAddress))


//
// ULONG
// WRITECTX_SIZE(
//     IN PVOID Request
// );
//
// Obtains size of send
//

#define WRITECTX_SIZE(_Request) 		\
	(((PTDI_REQUEST_KERNEL_SEND)(&((IoGetCurrentIrpStackLocation((PIRP)_Request))->Parameters)))->SendLength)

//
// ULONG
// WRITECTX_FLAGS(
//     IN PVOID Request
// );
//
// Obtains size of send
//

#define WRITECTX_FLAGS(_Request) 		\
	(((PTDI_REQUEST_KERNEL_SEND)(&((IoGetCurrentIrpStackLocation((PIRP)_Request))->Parameters)))->SendFlags)

extern	PADSP_ADDROBJ	atalkAdspAddrList;
extern	PADSP_CONNOBJ	atalkAdspConnList;
extern	ATALK_SPIN_LOCK	atalkAdspLock;

PBUFFER_CHUNK
atalkAdspAllocCopyChunk(
	IN	PVOID					pWriteBuf,
	IN	USHORT					WriteBufLen,
	IN	BOOLEAN					Eom,
	IN	BOOLEAN					IsCharBuffer);

VOID
atalkAdspPacketIn(
	IN	PPORT_DESCRIPTOR		pPortDesc,
	IN	PDDP_ADDROBJ			pDdpAddr,
	IN	PBYTE					pPkt,
	IN	USHORT					PktLen,
	IN	PATALK_ADDR				pSrcAddr,
	IN	PATALK_ADDR				pDestAddr,
	IN	ATALK_ERROR				ErrorCode,
	IN	BYTE					DdpType,
	IN	PADSP_ADDROBJ			pAdspAddr,
	IN	BOOLEAN					OptimizePath,
	IN	PVOID               	OptimizeCtx);

LOCAL VOID
atalkAdspHandleOpenControl(
	IN	PADSP_ADDROBJ			pAdspAddr,
	IN	PBYTE					pPkt,
	IN	USHORT					PktLen,
	IN	PATALK_ADDR				pSrcAddr,
	IN	USHORT					RemoteConnId,
	IN	ULONG					RemoteFirstByteSeq,
	IN	ULONG					RemoteNextRecvSeq,
	IN	ULONG					RemoteRecvWindow,
	IN	BYTE					Descriptor);

LOCAL VOID
atalkAdspHandleAttn(
	IN	PADSP_CONNOBJ			pAdspConn,
	IN	PBYTE					pPkt,
	IN	USHORT					PktLen,
	IN	PATALK_ADDR				pSrcAddr,
	IN	ULONG					RemoteFirstByteSeq,
	IN	ULONG					RemoteNextRecvSeq,
	IN	ULONG					RemoteRecvWindow,
	IN	BYTE					Descriptor);

LOCAL VOID
atalkAdspHandlePiggyBackAck(
	IN	PADSP_CONNOBJ			pAdspConn,
	IN	ULONG					RemoteNextRecvSeq,
	IN	ULONG					RemoteRecvWindow);

LOCAL VOID
atalkAdspHandleControl(
	IN	PADSP_CONNOBJ			pAdspConn,
	IN	PBYTE					pPkt,
	IN	USHORT					PktLen,
	IN	PATALK_ADDR				pSrcAddr,
	IN	ULONG					RemoteFirstByteSeq,
	IN	ULONG					RemoteNextRecvSeq,
	IN	ULONG					RemoteRecvWindow,
	IN	BYTE					Descriptor);

LOCAL VOID
atalkAdspHandleData(
	IN	PADSP_CONNOBJ			pAdspConn,
	IN	PBYTE					pPkt,
	IN	USHORT					PktLen,
	IN	PATALK_ADDR				pSrcAddr,
	IN	ULONG					RemoteFirstByteSeq,
	IN	ULONG					RemoteNextRecvSeq,
	IN	ULONG					RemoteRecvWindow,
	IN	BYTE					Descriptor);

LOCAL VOID
atalkAdspHandleOpenReq(
	IN	PADSP_ADDROBJ			pAdspAddr,
	IN	PBYTE					pPkt,
	IN	USHORT					PktLen,
	IN	PATALK_ADDR				pSrcAddr,
	IN	USHORT					RemoteConnId,
	IN	ULONG					RemoteFirstByteSeq,
	IN	ULONG					RemoteNextRecvSeq,
	IN	ULONG					RemoteRecvWindow,
	IN	BYTE					Descriptor);

LOCAL VOID
atalkAdspListenIndicateNonInterlock(
	IN	PADSP_ADDROBJ			pAdspAddr,
	IN	PADSP_OPEN_REQ			pOpenReq,
	IN	PADSP_CONNOBJ *			ppAdspConn,
	IN	PATALK_ERROR			pError);

ATALK_ERROR
atalkAdspSendExpedited(
	IN	PADSP_CONNOBJ			pAdspConn,
	IN	PAMDL					pWriteBuf,
	IN	USHORT					WriteBufLen,
	IN	ULONG					SendFlags,
	IN	PVOID					pWriteCtx,
	IN	GENERIC_WRITE_COMPLETION CompletionRoutine);

LOCAL VOID
atalkAdspSendOpenControl(
	IN	PADSP_CONNOBJ			pAdspConn);

LOCAL VOID
atalkAdspSendControl(
	IN	PADSP_CONNOBJ			pAdspConn,
	IN	BYTE					Descriptor);

LOCAL VOID
atalkAdspSendAttn(
	IN	PADSP_CONNOBJ			pAdspConn);

LOCAL VOID
atalkAdspSendData(
	IN	PADSP_CONNOBJ			pAdspConn);

LOCAL VOID
atalkAdspRecvAttn(
	IN	PADSP_CONNOBJ			pAdspConn);

LOCAL VOID
atalkAdspRecvData(
	IN	PADSP_CONNOBJ			pAdspConn);

LOCAL VOID
atalkAdspSendDeny(
	IN	PADSP_ADDROBJ			pAdspAddr,
	IN	PATALK_ADDR				pRemoteAddr,
	IN	USHORT					pRemoteConnId);

VOID FASTCALL
atalkAdspSendAttnComplete(
	IN	NDIS_STATUS				Status,
	IN	PSEND_COMPL_INFO		pSendInfo);

VOID FASTCALL
atalkAdspConnSendComplete(
	IN	NDIS_STATUS				Status,
	IN	PSEND_COMPL_INFO		pSendInfo);

VOID FASTCALL
atalkAdspAddrSendComplete(
	IN	NDIS_STATUS				Status,
	IN	PSEND_COMPL_INFO		pSendInfo);

VOID FASTCALL
atalkAdspSendDataComplete(
	IN	NDIS_STATUS				Status,
	IN	PSEND_COMPL_INFO		pSendInfo);

LOCAL LONG FASTCALL
atalkAdspConnMaintenanceTimer(
	IN	PTIMERLIST				pTimer,
	IN	BOOLEAN					TimerShuttingDown);

LOCAL LONG FASTCALL
atalkAdspRetransmitTimer(
	IN	PTIMERLIST				pTimer,
	IN	BOOLEAN					TimerShuttingDown);

LOCAL LONG FASTCALL
atalkAdspAttnRetransmitTimer(
	IN	PTIMERLIST				pTimer,
	IN	BOOLEAN					TimerShuttingDown);

LOCAL LONG FASTCALL
atalkAdspOpenTimer(
	IN	PTIMERLIST				pTimer,
	IN	BOOLEAN					TimerShuttingDown);

LOCAL LONG FASTCALL
atalkAdspDisconnectTimer(
	IN	PTIMERLIST				pTimer,
	IN	BOOLEAN					TimerShuttingDown);

VOID
atalkAdspDecodeHeader(
	IN	PBYTE					Datagram,
	OUT	PUSHORT					RemoteConnId,
	OUT	PULONG					FirstByteSeq,
	OUT	PULONG					NextRecvSeq,
	OUT	PLONG					Window,
	OUT	PBYTE					Descriptor);

LOCAL USHORT
atalkAdspGetNextConnId(
	IN	PADSP_ADDROBJ			pAdspAddr,
	OUT	PATALK_ERROR			pError);

LOCAL	BOOLEAN
atalkAdspConnDeQueueAssocList(
	IN	PADSP_ADDROBJ			pAdspAddr,
	IN	PADSP_CONNOBJ			pAdspConn);

LOCAL	BOOLEAN
atalkAdspConnDeQueueConnectList(
	IN	PADSP_ADDROBJ			pAdspAddr,
	IN	PADSP_CONNOBJ			pAdspConn);

LOCAL	BOOLEAN
atalkAdspConnDeQueueListenList(
	IN	PADSP_ADDROBJ			pAdspAddr,
	IN	PADSP_CONNOBJ			pAdspConn);

LOCAL	BOOLEAN
atalkAdspConnDeQueueActiveList(
	IN	PADSP_ADDROBJ			pAdspAddr,
	IN	PADSP_CONNOBJ			pAdspConn);

LOCAL	VOID
atalkAdspAddrQueueGlobalList(
	IN	PADSP_ADDROBJ	pAdspAddr);

LOCAL	VOID
atalkAdspAddrDeQueueGlobalList(
	IN	PADSP_ADDROBJ			pAdspAddr);

LOCAL	VOID
atalkAdspConnDeQueueGlobalList(
	IN	PADSP_CONNOBJ			pAdspConn);

LOCAL	BOOLEAN
atalkAdspAddrDeQueueOpenReq(
	IN	PADSP_ADDROBJ			pAdspAddr,
	IN	USHORT					RemoteConnId,
	IN	PATALK_ADDR				pSrcAddr,
	OUT	PADSP_OPEN_REQ *		ppOpenReq);

LOCAL	BOOLEAN
atalkAdspIsDuplicateOpenReq(
	IN	PADSP_ADDROBJ			pAdspAddr,
	IN	USHORT					RemoteConnId,
	IN	PATALK_ADDR				pSrcAddr);

LOCAL VOID
atalkAdspGenericComplete(
	IN	ATALK_ERROR				ErrorCode,
	IN	PIRP					pIrp);

ULONG
atalkAdspMaxSendSize(
	IN	PADSP_CONNOBJ			pAdspConn);

ULONG
atalkAdspMaxNextReadSize(
	IN	PBUFFER_QUEUE			pQueue,
	OUT	PBOOLEAN				pEom,
	OUT	PBUFFER_CHUNK *			pBufferChunk);

ULONG
atalkAdspBufferQueueSize(
	IN	PBUFFER_QUEUE			pQueue);

ULONG
atalkAdspMessageSize(
	IN	PBUFFER_QUEUE			pQueue,
	IN	PBOOLEAN				pEom);

PBYTE
atalkAdspGetLookahead(
	IN	PBUFFER_QUEUE			pQueue,
	OUT	PULONG					pLookaheadSize);

ULONG
atalkAdspReadFromBufferQueue(
	IN		PBUFFER_QUEUE		pQueue,
	IN		ULONG				pFlags,
	OUT		PAMDL				pReadBuf,
	IN 	OUT	PUSHORT				pReadLen,
	OUT		PBOOLEAN			pEom);

BOOLEAN
atalkAdspDiscardFromBufferQueue(
	IN		PBUFFER_QUEUE		pQueue,
	IN 		ULONG				DataSize,
	OUT		PBUFFER_QUEUE		pAuxQueue,
	IN		ATALK_ERROR			Error,
	IN	PADSP_CONNOBJ			pAdspConn	OPTIONAL);

VOID
atalkAdspAddToBufferQueue(
	IN	OUT	PBUFFER_QUEUE		pQueue,
	IN		PBUFFER_CHUNK		pChunk,
	IN 	OUT	PBUFFER_QUEUE		pAuxQueue	OPTIONAL);

VOID
atalkAdspBufferChunkReference(
	IN	PBUFFER_CHUNK			pBufferChunk);

VOID
atalkAdspBufferChunkDereference(
	IN	PBUFFER_CHUNK			pBufferChunk,
	IN	BOOLEAN					CreationDeref,
	IN	PADSP_CONNOBJ			pAdspConn	OPTIONAL);

VOID
atalkAdspConnFindInConnect(
	IN	PADSP_ADDROBJ			pAdspAddr,
	IN	USHORT					DestConnId,
	IN	PATALK_ADDR				pRemoteAddr,
	OUT	PADSP_CONNOBJ *			ppAdspConn,
	IN	PATALK_ERROR			pError);

ULONG
atalkAdspDescribeFromBufferQueue(
	IN	PBUFFER_QUEUE			pQueue,
	OUT	PBOOLEAN				pEom,
	IN	ULONG					WindowSize,
	OUT	PBUFFER_CHUNK *			ppBufferChunk,
	OUT	PBUFFER_DESC  * 		ppBufDesc);

#endif	// _ADSP_


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\atalk\sys\arapatk.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	arapatk.c

Abstract:

	This module implements routines that directly interface with Atalk stack

Author:

	Shirish Koti

Revision History:
	15 Nov 1996		Initial Version

--*/

#define		ARAP_LOCALS
#include 	<atalk.h>
#pragma hdrstop

#define	FILENUM		ARAPATK

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE_ARAP, ArapRoutePacketFromWan)
#pragma alloc_text(PAGE_ARAP, ArapRoutePacketToWan)
#pragma alloc_text(PAGE_ARAP, ArapOkToForward)
#pragma alloc_text(PAGE_ARAP, ArapAddArapRoute)
#pragma alloc_text(PAGE_ARAP, ArapDeleteArapRoute)
#pragma alloc_text(PAGE_ARAP, ArapGetDynamicAddr)
#pragma alloc_text(PAGE_ARAP, ArapGetStaticAddr)
#pragma alloc_text(PAGE_ARAP, ArapValidNetrange)
#pragma alloc_text(PAGE_ARAP, ArapZipGetZoneStat)
#pragma alloc_text(PAGE_ARAP, ArapZipGetZoneStatCompletion)
#endif


//***
//
// Function: ArapRoutePacketFromWan
//              This routine picks up a packet from the phone line and forwards
//              it on to the lan.  It does some "fixing up" of the packet so that
//              to the stack, it looks like any other packet from the lan
//
// Parameters:  pArapConn - connection element for whom data has come in
//              pArapBuf  - buffer containing the packet
//
// Return:      none
//
//***$

VOID
ArapRoutePacketFromWan(
    IN  PARAPCONN    pArapConn,
    IN  PARAPBUF     pArapBuf
)
{

    PBYTE   packet;
    USHORT  DataSize;
    USHORT  checksum;
    USHORT  RevNet;
    BYTE    RevNode;
    PBYTE   pZoneNamePtr;
    USHORT  BytesToZoneName=0;
    LONG    CurrentTime;


    DBG_ARAP_CHECK_PAGED_CODE();

    DBGDUMPBYTES("ArapRoutePacketFromWan:",&pArapBuf->Buffer[0], pArapBuf->DataSize,4);

    packet  = pArapBuf->CurrentBuffer;
    DataSize = pArapBuf->DataSize;

    ASSERT(packet[2] == 0x50);

    ASSERT(packet[3] == 0 && packet[4] == 0 && packet[5] == 2);

    // skip 3 bytes (past the SrpLen (2) and Dgroup (1) bytes)
    packet += ARAP_DATA_OFFSET;
    DataSize -= ARAP_DATA_OFFSET;

    //
    // see if we need to calculate the checksum.  The LAP header is 0's if
    // checksum is not included in the pkt, 1's otherwise.
    //
    checksum = 0;
    if (*packet == 1 && *(packet+1) == 1)
    {
        checksum = 1;
    }

    // skip the LAP header
    packet += ARAP_LAP_HDRSIZE;
    DataSize -= ARAP_LAP_HDRSIZE;


#if DBG
    if (packet[LDDP_PROTO_TYPE_OFFSET] == DDPPROTO_RTMPRESPONSEORDATA)
    {
        DBGPRINT(DBG_COMP_ROUTER, DBG_LEVEL_ERR,
	        ("ArapRoutePacketFromWan: got RTMPRESPONSEORDATA pkt!!\n"));
        ASSERT(0);
    }

    if (packet[LDDP_PROTO_TYPE_OFFSET] == DDPPROTO_RTMPREQUEST)
    {
        DBGPRINT(DBG_COMP_ROUTER, DBG_LEVEL_ERR,
	        ("ArapRoutePacketFromWan: got RTMPREQUEST pkt!!\n"));
        ASSERT(0);
    }

    if (packet[LDDP_PROTO_TYPE_OFFSET] == DDPPROTO_ZIP)
    {
        DBGPRINT(DBG_COMP_ROUTER, DBG_LEVEL_ERR,
	        ("ArapRoutePacketFromWan: got ZIP pkt!!\n"));
        ASSERT(0);
    }
#endif


    // fill in the length and checksum in the ddp header ("fix-up" ddp hdr)
    PUTSHORT2SHORT(&packet[LDDP_LEN_OFFSET], DataSize);
    PUTSHORT2SHORT(&packet[LDDP_CHECKSUM_OFFSET], 0);

    //
    // we need to "fix up" NBP requests.  If this is a BrRq request (Function=1,
    // and TupleCount=1), we need to patch up the datagram
    //
    if (packet[LDDP_PROTO_TYPE_OFFSET] == DDPPROTO_NBP &&
        packet[LDDP_DGRAM_OFFSET] == ARAP_NBP_BRRQ)
    {

        //
        // let's treat nbp lookups as lower priority items!
        // if we have a lot of stuff sitting on the recv or the send the queue
        // then drop this nbp lookup broadcast (because otherwise it will only
        // generate more packets (and chooser won't deal with them anyway!)
        //
        if ((packet[LDDP_DEST_NODE_OFFSET] == ATALK_BROADCAST_NODE) &&
            ((pArapConn->SendsPending > ARAP_SENDQ_LOWER_LIMIT)  ||
             (pArapConn->RecvsPending > ARAP_SENDQ_LOWER_LIMIT)) )
        {
            DBGPRINT(DBG_COMP_ROUTER, DBG_LEVEL_ERR,
	            ("ArapRoutePacketFromWan: dropping NBP bcast to lan (%d %d bytes)\n",
                    pArapConn->SendsPending,pArapConn->RecvsPending));
            return;
        }


#if 0

need to save old packet.  Drop this packet only if it compares with the old one
        If something changed (say zone name!), send the packet over even if it's less than
        5 sec.  Also, delta should be probably 35 or something (for 3 pkts)

        CurrentTime = AtalkGetCurrentTick();

        //
        // Chooser keeps sending the Brrq request out.  Cut it out!  If we have
        // sent a request out (on Mac's behalf) less than 5 seconds ago, drop this!
        //
        if (CurrentTime - pArapConn->LastNpbBrrq < 50)
        {
            DBGPRINT(DBG_COMP_ROUTER, DBG_LEVEL_ERR,
	            ("ArapRoutePacketFromWan: dropping NBP_BRRQ (last %ld now %ld)\n",
                    pArapConn->LastNpbBrrq,CurrentTime));
            return;
        }

        pArapConn->LastNpbBrrq = CurrentTime;
#endif


#if 0
        // get to where the zone name is

        BytesToZoneName = ARAP_NBP_OBJLEN_OFFSET;

        // skip the object (along with the object len byte)
        BytesToZoneName += packet[ARAP_NBP_OBJLEN_OFFSET] + 1;

        // skip the type (along with the object len byte)
        BytesToZoneName += packet[BytesToZoneName] + 1;

        // this is where the zonelen field starts
        pZoneNamePtr = packet + BytesToZoneName;

        if (*pZoneNamePtr == 0 || *(pZoneNamePtr+1) == '*')
        {
            DBGPRINT(DBG_COMP_ROUTER, DBG_LEVEL_ERR,
	            ("ArapRoutePacketFromWan: * zone name (%lx,%lx)\n",packet,pZoneNamePtr));
        }

#endif

        if (ArapGlobs.NetworkAccess)
        {
            //
            // if router is running, fix the packet so that the router thinks this
            // is a pkt from any other net client on the lan
            //
            if (AtalkDefaultPort->pd_Flags & PD_ROUTER_RUNNING)
            {
                RevNet  = AtalkDefaultPort->pd_RouterNode->an_NodeAddr.atn_Network;
                RevNode = AtalkDefaultPort->pd_RouterNode->an_NodeAddr.atn_Node;
            }

            //
            // router is not running.  Do we know who the router is?
            //
            else if (AtalkDefaultPort->pd_Flags & PD_SEEN_ROUTER_RECENTLY)
            {
                RevNet  = AtalkDefaultPort->pd_ARouter.atn_Network;
                RevNode = AtalkDefaultPort->pd_ARouter.atn_Node;
            }

            //
            // nope, send it to cable-wide bcast
            //
            else
            {
                // "fix-up" the nbp request
                packet[LDDP_DGRAM_OFFSET] = ARAP_NBP_LKRQ;

                RevNet  = CABLEWIDE_BROADCAST_NETWORK;
                RevNode = ATALK_BROADCAST_NODE;
            }
        }

        //
        // hmmm: client is not allowed to access network resources: just pretend
        // it's local broadcast, and pkt-forwarding logic will take care of it
        //
        else
        {
            // "fix-up" the nbp request
            packet[LDDP_DGRAM_OFFSET] = ARAP_NBP_LKRQ;

            RevNet  = CABLEWIDE_BROADCAST_NETWORK;
            RevNode = ATALK_BROADCAST_NODE;
        }

        PUTSHORT2SHORT(&packet[LDDP_DEST_NETWORK_OFFSET], RevNet);
        packet[LDDP_DEST_NODE_OFFSET] = RevNode;
    }

    if (checksum)
    {
        checksum = AtalkDdpCheckSumBuffer(packet, DataSize, 0);
        PUTSHORT2SHORT(&packet[LDDP_CHECKSUM_OFFSET], checksum);
    }

    AtalkDdpPacketIn(AtalkDefaultPort, NULL, packet, DataSize, TRUE);

}




//***
//
// Function: ArapRoutePacketToWan
//              This routine picks up a packet from the lan, checks to see if
//              it must be forwarded to any of the ARAP clients and does the
//              good deed.
//
// Parameters:  pDestAddr - who is this packet addressed to? (potentially bcast)
//              pSrcAddr  - who sent this packet
//              Protocol  - what packet is it? (ATP, NBP, etc.)
//              packet    - buffer containing the packet
//              PktLen    - how big is the packet
//              broadcast - is this a broadcast packet?
//              pDelivered - set on return: did we forward it to any dial-in
//                           client (set to TRUE only for directed dgrams)
//
// Return:      none
//
//***$

VOID
ArapRoutePacketToWan(
	IN  ATALK_ADDR	*pDestAddr,
	IN  ATALK_ADDR	*pSrcAddr,
    IN  BYTE         Protocol,
	IN	PBYTE		 packet,
	IN	USHORT		 PktLen,
    IN  BOOLEAN      broadcast,
    OUT PBOOLEAN     pDelivered
)
{

    KIRQL           OldIrql;
    PARAPCONN       pArapConn;
    PARAPCONN       pPrevArapConn;
    PLIST_ENTRY     pConnList;
    BUFFER_DESC     InBuffDesc;
    BUFFER_DESC     BuffDesc;
    BYTE            ArapHdr[ARAP_LAP_HDRSIZE + ARAP_HDRSIZE];
    PBYTE           pArapHdrPtr;
    ATALK_NODEADDR  DestNode;
    DWORD           StatusCode;
    DWORD           dwFlags;
    USHORT          SrpLen;
    DWORD           Priority;


    DBG_ARAP_CHECK_PAGED_CODE();

    // assume for now
    *pDelivered = FALSE;

    // no network access for dial-in guys?  don't send this out to them
    if (!ArapGlobs.NetworkAccess)
    {
        return;
    }

    //
    // if this is an RTMP or ZIP bcast, drop it since ARAP clients don't
    // care for these packets
    //

    if (broadcast)
    {
        if ((packet[LDDP_PROTO_TYPE_OFFSET] == DDPPROTO_RTMPREQUEST) ||
            (packet[LDDP_PROTO_TYPE_OFFSET] == DDPPROTO_RTMPRESPONSEORDATA) )
        {
            DBGDUMPBYTES("ArapFrmLan: bcast pkt:",packet, LDDP_HDR_LEN+4,6);
            return;
        }

        if (packet[LDDP_PROTO_TYPE_OFFSET] == DDPPROTO_ZIP)
        {
            DBGDUMPBYTES("ArapFrmLan: bcast pkt:",packet, LDDP_HDR_LEN+4,6);
            return;
        }
    }

    //
    // this is a unicast: see if this addr belongs to an ARAP client
    //
    else
    {
        DestNode.atn_Network = pDestAddr->ata_Network;
        DestNode.atn_Node    = pDestAddr->ata_Node;

        pArapConn = FindAndRefArapConnByAddr(DestNode, &dwFlags);

        // no ARAP client for this dest. address?  Done here
        if (pArapConn == NULL)
        {
            return;
        }

        if (!(dwFlags & ARAP_CONNECTION_UP))
        {
            DerefArapConn(pArapConn);
            return;
        }
    }



    // setup a buffer descriptor for the incoming packet
    InBuffDesc.bd_Next = NULL;
    InBuffDesc.bd_Length = PktLen;
    InBuffDesc.bd_CharBuffer = packet;
    InBuffDesc.bd_Flags = BD_CHAR_BUFFER;

    //
    // setup the header
    //
    pArapHdrPtr = &ArapHdr[0];

    // don't count the 2 length bytes
    SrpLen = PktLen + ARAP_LAP_HDRSIZE + ARAP_HDRSIZE - sizeof(USHORT);

    PUTSHORT2SHORT(pArapHdrPtr, SrpLen);
    pArapHdrPtr += sizeof(USHORT);

    // the Dgroup byte
    *pArapHdrPtr++ = (ARAP_SFLAG_PKT_DATA | ARAP_SFLAG_LAST_GROUP);

    // the LAP hdr
    *pArapHdrPtr++ = 0;
    *pArapHdrPtr++ = 0;
    *pArapHdrPtr++ = 2;


    // setup a buffer descriptor for the header we are going to put
    BuffDesc.bd_Next = &InBuffDesc;
    BuffDesc.bd_Length = ARAP_LAP_HDRSIZE + ARAP_HDRSIZE;
    BuffDesc.bd_CharBuffer = &ArapHdr[0];
    BuffDesc.bd_Flags = BD_CHAR_BUFFER;


    //
    // if this datagram is not a broadcast, see if we can find a dial-in client
    // with this destination address
    //
    if (!broadcast)
    {
        //
        // ok, we found a connection: whether or not we actually give data to
        // him, let the caller know that we found who this data was meant for
        //
        *pDelivered = TRUE;

        //
        // some packets can't be sent to the dial-in client: how about this one?
        //
        if (!ArapOkToForward(pArapConn,packet,PktLen, &Priority))
        {
            DerefArapConn(pArapConn);
            return;
        }

        DBGDUMPBYTES("ArapRoutePacketToWan Directed Dgram:",packet,PktLen,4);

        //
        // ok, this packet is for the dial-in guy: send it
        //
        StatusCode = ArapSendPrepare(pArapConn, &BuffDesc, Priority);

        if (StatusCode == ARAPERR_NO_ERROR)
        {
            //  Send the packet(s)
            ArapNdisSend(pArapConn, &pArapConn->HighPriSendQ);
        }
        else
        {
            DBGPRINT(DBG_COMP_ROUTER, DBG_LEVEL_ERR,
	            ("ArapRoutePacketToWan: (%lx) Prep failed %d\n",pArapConn,StatusCode));
        }

        // remove that refcount put in by FindAndRefArapConnByAddr
        DerefArapConn(pArapConn);

        return;
    }

    DBGDUMPBYTES("ArapRoutePacketToWan Broadcast Dgram:",packet,PktLen,4);


    //
    // it's a broadcast packet: must send it to all the dial-in guys
    //

    pArapConn = NULL;
    pPrevArapConn = NULL;

    while (1)
    {
        ACQUIRE_SPIN_LOCK(&RasPortDesc->pd_Lock, &OldIrql);

        //
        // first, let's find the right connection to work on
        //
        while (1)
        {
            // if we're in the middle of the list, get to the next guy
            if (pArapConn != NULL)
            {
                pConnList = pArapConn->Linkage.Flink;
            }
            // we're just starting: get the guy at the head of the list
            else
            {
                pConnList = RasPortDesc->pd_ArapConnHead.Flink;
            }

            // finished all?
            if (pConnList == &RasPortDesc->pd_ArapConnHead)
            {
                RELEASE_SPIN_LOCK(&RasPortDesc->pd_Lock, OldIrql);

                if (pPrevArapConn)
                {
                    DerefArapConn(pPrevArapConn);
                }
                return;
            }

            pArapConn = CONTAINING_RECORD(pConnList, ARAPCONN, Linkage);

            // make sure this connection needs rcv processing
            ACQUIRE_SPIN_LOCK_DPC(&pArapConn->SpinLock);

            //
            // if this connection is being disconnected, skip it
            //
            if (pArapConn->State >= MNP_LDISCONNECTING)
            {
	            DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_WARN,
		            ("ArapRoutePacketToWan: (%lx) invalid state %d, skipping\n",
                        pArapConn,pArapConn->State));

                RELEASE_SPIN_LOCK_DPC(&pArapConn->SpinLock);

                // go try the next connection
                continue;
            }

            // let's make sure this connection stays around till we finish
            pArapConn->RefCount++;

            RELEASE_SPIN_LOCK_DPC(&pArapConn->SpinLock);

            break;
        }

        RELEASE_SPIN_LOCK(&RasPortDesc->pd_Lock, OldIrql);

        //
        // remove the refcount on the previous connection we put in earlier
        //
        if (pPrevArapConn)
        {
            DerefArapConn(pPrevArapConn);
        }

        ASSERT(pPrevArapConn != pArapConn);

        pPrevArapConn = pArapConn;


        //
        // if the connection isn't up yet, don't forward this
        // (note that we don't hold spinlock here, this being a hot path:
        // the worst that can happen is we'll drop a broadcast: big deal!)
        //
        if (!(pArapConn->Flags & ARAP_CONNECTION_UP))
        {
            continue;
        }


        //
        // is it ok for us send this packet to this client ?
        //
        if (!ArapOkToForward(pArapConn,packet,PktLen, &Priority))
        {
            continue;
        }

        StatusCode = ArapSendPrepare(pArapConn, &BuffDesc, Priority);

        if (StatusCode == ARAPERR_NO_ERROR)
        {
            //  Send the packet(s)
            ArapNdisSend(pArapConn, &pArapConn->HighPriSendQ);
        }
        else
        {
            DBGPRINT(DBG_COMP_ROUTER, DBG_LEVEL_ERR,
	            ("Arap...FromLan: (%lx) Arap..Prep failed %d\n",pArapConn,StatusCode));
        }

    }
}



//***
//
// Function: ArapOkToForward
//              This routine checks to see if we can (or must) forward this
//              packet to the dial-in client.  Certain packets (e.g. a bcast pkt
//              that originated from this client) shouldn't be sent back to the
//              client: this routine makes those checks.
//
// Parameters:  pArapConn - the connection in question
//              packet    - buffer containing the packet
//              packetLen - how big is the packet
//              pPriority - set on return:
//                            1 - all non-NBP data directed to this client
//                            2 - all NBP data directed to this client
//                            3 - all broadcast data
//
// Return:      TRUE if it's ok to (or if we must!) forward the packet,
//              FALSE otherwise
//
//***$

BOOLEAN
ArapOkToForward(
    IN  PARAPCONN   pArapConn,
    IN  PBYTE       packet,
    IN  USHORT      packetLen,
    OUT DWORD      *pPriority
)
{

    ATALK_NODEADDR  NetAddr;
    BOOLEAN         fBcastPkt=FALSE;
    BOOLEAN         fNbpPkt=FALSE;



    DBG_ARAP_CHECK_PAGED_CODE();

    GETSHORT2SHORT(&NetAddr.atn_Network, &packet[LDDP_SRC_NETWORK_OFFSET]);
    NetAddr.atn_Node = packet[LDDP_SRC_NODE_OFFSET];

    //
    // packet has client's own addr as DDP src addr?  if so, drop it
    //
    if (NODEADDR_EQUAL(&NetAddr, &pArapConn->NetAddr))
    {
	    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_INFO,
	        ("ArapOkToForward: dropping pkt: DDP src=client's addr (%lx)\n",pArapConn));

        return(FALSE);
    }


    if (packet[LDDP_PROTO_TYPE_OFFSET] == DDPPROTO_NBP)
    {
        fNbpPkt = TRUE;
    }

    if (packet[LDDP_DEST_NODE_OFFSET] == ATALK_BROADCAST_NODE)
    {
        fBcastPkt = TRUE;

        //
        // is this an nbp query packet?
        //
        if (fNbpPkt && (packet[LDDP_DGRAM_OFFSET] == 0x21))
        {
            GETSHORT2SHORT(&NetAddr.atn_Network, &packet[15]);
            NetAddr.atn_Node = packet[17];

            // originated from the client? if so, we shouldn't return this!
            if (NODEADDR_EQUAL(&NetAddr, &pArapConn->NetAddr))
            {
	            DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_INFO,
	                ("ArapOkToForward: dropping pkt originating from client!\n"));

                return(FALSE);
            }
        }
    }

    //
    // if this is a broadcast packet, then we drop it under certain conditions:
    // (no need for spinlock here: if we make a wrong decision, no big deal)
    //
    if (fBcastPkt)
    {

        // are in currently in the retransmit mode?  if so, drop this bcast pkt
        if (pArapConn->MnpState.RetransmitMode)
        {
            return(FALSE);
        }
        //
        // queue getting full? drop this broadcast packet to make room for more
        // important pkts
        //
        if (pArapConn->SendsPending >= ARAP_SENDQ_LOWER_LIMIT)
        {
            // make sure it's not gone negative..
            ASSERT(pArapConn->SendsPending < 0x100000);

	        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
	            ("ArapOkToForward: (%lx) send getting full (%ld), dropping nbp pkt\n",
                    pArapConn,pArapConn->SendsPending));

            return(FALSE);
        }
    }


    //
    // now that we are forwarding the packet to the client, set the priority
    // right. All broadcast packets are lowest priority, no big deal if they are
    // delivered late (or never).  Nbp packets are usually for chooser: put them
    // after the directed data packets
    //

    if (fBcastPkt)
    {
        *pPriority = ARAP_SEND_PRIORITY_LOW;
    }
    else if (fNbpPkt)
    {
        *pPriority = ARAP_SEND_PRIORITY_MED;
    }
    else
    {
        *pPriority = ARAP_SEND_PRIORITY_HIGH;
    }


    return(TRUE);
}



//***
//
// Function: ArapGetDynamicAddr
//              This routine gets a network address for a dial-in client.
//              It does the same AARP logic as if it were acquiring a
//              node-address for the host itself.
//              This routine is called only if we are in the dynamic mode.
//
// Parameters:  pArapConn - the connection for which we need a network addr
//
// Return:      ARAPERR_NO_ERROR if all went well.
//
//***$

DWORD
ArapGetDynamicAddr(
    IN PARAPCONN       pArapConn
)
{
    ATALK_NODEADDR      NetAddr;
    ATALK_NETWORKRANGE  NetRange;
    BOOLEAN             fFound=FALSE;
    KIRQL               OldIrql;
    DWORD               StatusCode=ARAPERR_STACK_NOT_UP;



    DBG_ARAP_CHECK_PAGED_CODE();

    ASSERT(AtalkDefaultPort != NULL);

    //
    // go find a node address on the default port (we'll never get this far if
    // default port isn't up yet)
    //
    ACQUIRE_SPIN_LOCK(&pArapConn->SpinLock, &OldIrql);

    ASSERT(!(pArapConn->Flags & ARAP_FINDING_NODE));

    pArapConn->Flags |= ARAP_FINDING_NODE;

    RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);

    AtalkLockInitIfNecessary();

    // if we are stuck in the startup range, use that range for dial-in guys, too
    if (WITHIN_NETWORK_RANGE(AtalkDefaultPort->pd_NetworkRange.anr_LastNetwork,
                             &AtalkStartupNetworkRange))
    {
        NetRange = AtalkStartupNetworkRange;
    }
    else
    {
        NetRange = AtalkDefaultPort->pd_NetworkRange;
    }

    fFound = AtalkInitAarpForNodeInRange(AtalkDefaultPort,
                                         (PVOID)pArapConn,
                                         FALSE,
                                         NetRange,
                                         &NetAddr);

    AtalkUnlockInitIfNecessary();

    ACQUIRE_SPIN_LOCK(&pArapConn->SpinLock, &OldIrql);

    pArapConn->Flags &= ~ARAP_FINDING_NODE;

    if (fFound)
    {
        // store that adddr!
        pArapConn->NetAddr.atn_Network = NetAddr.atn_Network;
        pArapConn->NetAddr.atn_Node = NetAddr.atn_Node;

        pArapConn->Flags |= ARAP_NODE_IN_USE;
        StatusCode = ARAPERR_NO_ERROR;

	    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_INFO,
    	    ("ArapGetDynamicAddr: found addr for ARAP client = %lx %lx\n",
                NetAddr.atn_Network,NetAddr.atn_Node));
    }
    else
    {
        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
	        ("ArapGetDynamicAddr: ARAP: no more network addr left?\n"));

        pArapConn->Flags &= ~ARAP_NODE_IN_USE;
        pArapConn->NetAddr.atn_Network = 0;
        pArapConn->NetAddr.atn_Node = 0;
        StatusCode = ARAPERR_NO_NETWORK_ADDR;
    }

    RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);

    return(StatusCode);
}



//***
//
// Function: ArapZipGetZoneStat
//              This routine is called to find out the names (or number) of all
//              the zones on the network.
//
// Parameters:  pZoneStat - on return, we fill this structure in with the
//                          requested info (number and/or names of all the zones)
//              Request   - caller wants just the number of zones or names, too
//
// Return:      Nothing
//
//***$

VOID
ArapZipGetZoneStat(
    IN OUT PZONESTAT pZoneStat
)
{
    int                     i;
    PZONE                   pZone;
    DWORD                   NumZones;
    DWORD                   StatusCode;
	KIRQL	                OldIrql;
    PBYTE                   pBufPtr;
    PBYTE                   pAllocedBuf=NULL;
    DWORD                   BufferSize;
    DWORD                   BytesCopied;
    DWORD                   BytesNeeded;
    ATALK_ERROR             Status;
    PZIPCOMPLETIONINFO      pZci;
    PMDL                    pMdl=NULL;
    ACTREQ                  ActReq;
    ZIP_GETZONELIST_PARAMS  ZipParms;
    KEVENT                  ZoneComplEvent;


    DBG_ARAP_CHECK_PAGED_CODE();

    BufferSize = pZoneStat->BufLen;

    pBufPtr = &pZoneStat->ZoneNames[0];

    StatusCode = ARAPERR_NO_ERROR;
    BytesCopied = 0;
    NumZones = 0;

    if (AtalkDefaultPort->pd_Flags & PD_ROUTER_RUNNING)
    {
        BytesNeeded = 0;

	    ACQUIRE_SPIN_LOCK(&AtalkZoneLock, &OldIrql);

        for (i = 0; (i < NUM_ZONES_HASH_BUCKETS); i++)
        {
        	for (pZone = AtalkZonesTable[i]; pZone != NULL; pZone = pZone->zn_Next)
    	    {
                NumZones++;

                BytesNeeded += (pZone->zn_ZoneLen + 1);

                // if there is room, copy it in
                if (BufferSize >= BytesNeeded)
                {
                    RtlCopyMemory(pBufPtr,
                                  &pZone->zn_Zone[0],
                                  pZone->zn_ZoneLen);

                    pBufPtr += pZone->zn_ZoneLen;

                    *pBufPtr++ = '\0';

                    BytesCopied += (pZone->zn_ZoneLen + 1);
                }
                else
                {
                    StatusCode = ARAPERR_BUF_TOO_SMALL;
                    break;
                }
    	    }
        }

        RELEASE_SPIN_LOCK(&AtalkZoneLock, OldIrql);
    }

    //
    // we are not a router: send the request over to the A-router
    //
    else
    {
        BytesNeeded = BufferSize;

        pMdl = AtalkAllocAMdl(pBufPtr,BufferSize);
        if (pMdl == NULL)
        {
            DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                    ("ArapZipGetZoneStat: couldn't allocate Mdl\n"));

            StatusCode = ARAPERR_OUT_OF_RESOURCES;
            goto ArapZipGetZoneStat_Exit;
        }


        KeInitializeEvent(&ZoneComplEvent, NotificationEvent, FALSE);

        pZci = (PZIPCOMPLETIONINFO)AtalkAllocMemory(sizeof(ZIPCOMPLETIONINFO));
        if (pZci == NULL)
        {
            DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                    ("ArapZipGetZoneStat: couldn't allocate pZci\n"));

            StatusCode = ARAPERR_OUT_OF_RESOURCES;
            goto ArapZipGetZoneStat_Exit;
        }

        ZipParms.ZonesAvailable = 0;
        ActReq.ar_StatusCode = ARAPERR_NO_ERROR;

#if	DBG
        ActReq.ar_Signature = ACTREQ_SIGNATURE;
#endif
        ActReq.ar_pIrp = NULL;
        ActReq.ar_pParms = &ZipParms;
        ActReq.ar_pAMdl = NULL;
        ActReq.ar_MdlSize = 0;
        ActReq.ar_ActionCode = 0;
        ActReq.ar_DevType = 0;
        ActReq.ar_Completion = ArapZipGetZoneStatCompletion;
        ActReq.ar_CmplEvent = &ZoneComplEvent;
        ActReq.ar_pZci = (PVOID)pZci;


		// Initialize completion info
#if	DBG
		pZci->zci_Signature = ZCI_SIGNATURE;
#endif
		INITIALIZE_SPIN_LOCK(&pZci->zci_Lock);
		pZci->zci_RefCount = 1;
		pZci->zci_pPortDesc = AtalkDefaultPort;
		pZci->zci_pDdpAddr = NULL;
		pZci->zci_pAMdl = pMdl;
		pZci->zci_BufLen = BufferSize;
		pZci->zci_pActReq = &ActReq;
		pZci->zci_Router.ata_Network = AtalkDefaultPort->pd_ARouter.atn_Network;
		pZci->zci_Router.ata_Node = AtalkDefaultPort->pd_ARouter.atn_Node;
		pZci->zci_Router.ata_Socket = ZONESINFORMATION_SOCKET;
		pZci->zci_ExpirationCount = ZIP_GET_ZONEINFO_RETRIES;
		pZci->zci_NextZoneOff = 0;
		pZci->zci_ZoneCount = 0;
		pZci->zci_AtpRequestType = ZIP_GET_ZONE_LIST;
		AtalkTimerInitialize(&pZci->zci_Timer,
							 atalkZipZoneInfoTimer,
							 ZIP_GET_ZONEINFO_TIMER);

		pZci->zci_Handler = atalkZipGetZoneListReply;

        // completion routine will unlock
        AtalkLockZipIfNecessary();

		Status = atalkZipSendPacket(pZci, TRUE);
		if (!ATALK_SUCCESS(Status))
		{
			DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_ERR,
					("ArapZipGetZoneStat: atalkZipSendPacket failed %ld\n", Status));
			pZci->zci_FinalStatus = Status;
			atalkZipDereferenceZci(pZci);
		}

        KeWaitForSingleObject(&ZoneComplEvent,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);

        NumZones = ZipParms.ZonesAvailable;
        StatusCode = ActReq.ar_StatusCode;

        if (StatusCode == ARAPERR_BUF_TOO_SMALL)
        {
            BytesNeeded = (2*BufferSize);
        }

        BytesCopied = BufferSize;

        AtalkFreeAMdl(pMdl);
    }


ArapZipGetZoneStat_Exit:

    pZoneStat->NumZones = NumZones;
    pZoneStat->BufLen = BytesCopied;
    pZoneStat->BytesNeeded = BytesNeeded;

    pZoneStat->StatusCode = StatusCode;

}



//***
//
// Function: ArapZipGetZoneStatCompletion
//              This routine is the completion routine: after we get all the
//              responses for the zone query, this gets called.  Simply set an
//              event so the caller is unblocked
//
// Parameters:  pActReq - context
//
// Return:      Nothing
//
//***$

VOID
ArapZipGetZoneStatCompletion(
    IN ATALK_ERROR  ErrorCode,
    IN PACTREQ      pActReq
)
{

    PKEVENT                 pEvent;
    PZIPCOMPLETIONINFO      pZci;


    DBG_ARAP_CHECK_PAGED_CODE();

    if (ErrorCode != ATALK_NO_ERROR && ErrorCode != ATALK_BUFFER_TOO_SMALL)
    {
		DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_ERR,
			("ArapZipGetZoneStatCompletion: failure %lx\n", ErrorCode));
    }

    pZci = (PZIPCOMPLETIONINFO)(pActReq->ar_pZci);

    pEvent = pActReq->ar_CmplEvent;

    ASSERT((pZci->zci_FinalStatus == ATALK_NO_ERROR) ||
           (pZci->zci_FinalStatus == ATALK_BUFFER_TOO_SMALL));

    if (pZci->zci_FinalStatus == ATALK_NO_ERROR)
    {
        pActReq->ar_StatusCode = ARAPERR_NO_ERROR;
    }
    else if (pZci->zci_FinalStatus == ATALK_BUFFER_TOO_SMALL)
    {
        pActReq->ar_StatusCode = ARAPERR_BUF_TOO_SMALL;
    }
    else
    {
        pActReq->ar_StatusCode = ARAPERR_UNEXPECTED_RESPONSE;

		DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_ERR,
				("ArapZipGetZoneStat: failure %lx\n", pZci->zci_FinalStatus));
    }

    KeSetEvent(pEvent,IO_NETWORK_INCREMENT,FALSE);
}


#if ARAP_STATIC_MODE

//***
//
// Function: ArapGetStaticAddr
//              Get a network address for the remote client when we are
//              configured for static addressing
//              We represent every client as one bit: if the bit is on, the
//              corresponding address is taken, otherwise it's free.
//              So, 255 clients represented using 32 bytes.  Each pAddrMgmt
//              block represents 255 clients (scalability not a problem here!)
//
// Parameters:  pArapConn - connection element for the remote client in question
//
// Return:      status of the operation (ARAPERR_....)
//
//***$

DWORD
ArapGetStaticAddr(
    IN PARAPCONN  pArapConn
)
{
    KIRQL           OldIrql;
    PADDRMGMT       pAddrMgmt;
    PADDRMGMT       pPrevAddrMgmt;
    USHORT          Network;
    BYTE            Node;
    BOOLEAN         found=FALSE;
    BYTE            BitMask;
    DWORD           i;


    DBG_ARAP_CHECK_PAGED_CODE();

    ARAPTRACE(("Entered ArapGetStaticAddr (%lx)\n",pArapConn));

    ACQUIRE_SPIN_LOCK(&ArapSpinLock, &OldIrql);

    pAddrMgmt = ArapGlobs.pAddrMgmt;

    while (1)
    {
        Network = pAddrMgmt->Network;

        // see if there is any open slot.  255 nodes represented by 32x8 bits
        for (i=0; i<32; i++)
        {
            if (pAddrMgmt->NodeBitMap[i] != 0xff)
            {
                found = TRUE;
                break;
            }
        }

        if (found)
        {
            // find out the first bit in this byte that is off
            BitMask = 0x1;
            Node = 0;
            while (pAddrMgmt->NodeBitMap[i] & BitMask)
            {
                BitMask <<= 1;
                Node += 1;
            }

            // we are taking this node: set that bit!
            pAddrMgmt->NodeBitMap[i] |= BitMask;

            // now, account for all the previous bytes that were full
            Node += (BYTE)(i*8);

            break;
        }

        // all the nodes on this network are taken!  move to the next network
        pPrevAddrMgmt = pAddrMgmt;
        pAddrMgmt = pAddrMgmt->Next;

        // looks like we need to allocate the next network structure
        if (pAddrMgmt == NULL)
        {
            //
            // we just finished looking at the high end of the permissible network
            // range?  well, out of luck then!
            //
            if (Network == ArapGlobs.NetRange.HighEnd)
            {
                RELEASE_SPIN_LOCK(&ArapSpinLock, OldIrql);

	            DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
		            ("ArapGetStaticAddr: no more network addr left\n"));

                return(ARAPERR_NO_NETWORK_ADDR);
            }

            if ( (pAddrMgmt = AtalkAllocZeroedMemory(sizeof(ADDRMGMT))) == NULL)
            {
                RELEASE_SPIN_LOCK(&ArapSpinLock, OldIrql);

	            DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
		            ("ArapGetStaticAddr: alloc failed\n"));

                return(ARAPERR_OUT_OF_RESOURCES);
            }

            Network++;
            pAddrMgmt->Next = NULL;
            pAddrMgmt->Network = Network;
            pPrevAddrMgmt->Next = pAddrMgmt;

            Node = 1;
            //
            // node numbers 0 and 255 are reserved, so mark them as occupied.
            // Also, we just took node 1, so mark that as well
            //
            pAddrMgmt->NodeBitMap[0] |= (0x1 | 0x2);
            pAddrMgmt->NodeBitMap[31] |= 0x80;

            break;
        }

    }

    RELEASE_SPIN_LOCK(&ArapSpinLock, OldIrql);

    // store that adddr!
    ACQUIRE_SPIN_LOCK(&pArapConn->SpinLock, &OldIrql);
    pArapConn->NetAddr.atn_Network = Network;
    pArapConn->NetAddr.atn_Node = Node;
    RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);

    return( ARAPERR_NO_ERROR );
}


//***
//
// Function: ArapAddArapRoute
//              If we are in the static mode of network address allocation, we
//              need to add a route in our table corresponding to the network
//              range allocated for the dial-in clients.
//              This routine does that.  In case of dynamic mode, it's a no-op.
//              This is a one-time thing, and we only do it when the first
//              connection comes in (instead of doing at startup).
//
// Parameters:  None
//
// Return:      None
//
//***$

VOID
ArapAddArapRoute(
    IN VOID
)
{

    ATALK_NETWORKRANGE  NwRange;
    KIRQL               OldIrql;
    BOOLEAN             fAddRoute = FALSE;


    DBG_ARAP_CHECK_PAGED_CODE();

    //
    // add a route only if router is enabled, and we are in the Static mode of
    // network allocation, and we haven't already added it
    //

    ACQUIRE_SPIN_LOCK(&ArapSpinLock, &OldIrql);

    if ((AtalkDefaultPort->pd_Flags & PD_ROUTER_RUNNING) &&
        (!ArapGlobs.DynamicMode) &&
        (!ArapGlobs.RouteAdded))
    {
        ArapGlobs.RouteAdded = TRUE;
        fAddRoute = TRUE;

        ASSERT(ArapConnections >= 1);
    }

    RELEASE_SPIN_LOCK(&ArapSpinLock, OldIrql);


    if (fAddRoute)
    {
        NwRange.anr_FirstNetwork = ArapGlobs.NetRange.LowEnd;
        NwRange.anr_LastNetwork  = ArapGlobs.NetRange.HighEnd;

        atalkRtmpCreateRte(NwRange,
                           RasPortDesc,
                           &AtalkDefaultPort->pd_Nodes->an_NodeAddr,
                           0);
    }
}



//***
//
// Function: ArapDeleteArapRoute
//              If there is a routine called ArapAddArapRoute, we have got to
//              have a routine called ArapDeleteArapRoute.
//
// Parameters:  None
//
// Return:      None
//
//***$

VOID
ArapDeleteArapRoute(
    IN VOID
)
{

    KIRQL               OldIrql;
    BOOLEAN             fDeleteRoute = FALSE;


    DBG_ARAP_CHECK_PAGED_CODE();

    //
    // delete a route only if added it earlier and the connections went to 0
    //
    ACQUIRE_SPIN_LOCK(&ArapSpinLock, &OldIrql);
    if (ArapGlobs.RouteAdded && ArapConnections == 0)
    {
        ArapGlobs.RouteAdded = FALSE;
        fDeleteRoute = TRUE;
    }
    RELEASE_SPIN_LOCK(&ArapSpinLock, OldIrql);

    if (fDeleteRoute)
    {
        atalkRtmpRemoveRte(ArapGlobs.NetRange.LowEnd);
    }

}



//***
//
// Function: ArapValidNetrange
//              This routine is called if we configured to be in the static
//              mode of addr allocation, when the dll first "binds" to us.
//              It verifies that the network range allocated by the admin is
//              valid and doesn't overlap with any of the network ranges known
//              to us through the route table.
//
// Parameters:  NetRange - the network range configured for dial-in clients
//
// Return:      TRUE if the range is valid,
//              FALSE if it overlaps with any of the existing network ranges
//
//***$

BOOLEAN
ArapValidNetrange(
    IN NETWORKRANGE NetRange
)
{
    BOOLEAN     fRangeIsValid=TRUE;
    KIRQL       OldIrql;
	PRTE	    pRte, pNext;
	int		    i;



    DBG_ARAP_CHECK_PAGED_CODE();

    if (NetRange.LowEnd == 0 || NetRange.HighEnd == 0)
    {
	    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
            ("ArapValidNetrange: Invalid network range\n"));
#if DBG
        DbgDumpNetworkNumbers();
#endif

        return(FALSE);
    }

    fRangeIsValid = TRUE;

	ACQUIRE_SPIN_LOCK(&AtalkRteLock, &OldIrql);

	for (i = 0; i < NUM_RTMP_HASH_BUCKETS; i++)
	{
		for (pRte = AtalkRoutingTable[i]; pRte != NULL; pRte = pNext)
		{
			pNext = pRte->rte_Next;

			ACQUIRE_SPIN_LOCK_DPC(&pRte->rte_Lock);

            if ( (IN_NETWORK_RANGE(NetRange.LowEnd,pRte)) ||
                 (IN_NETWORK_RANGE(NetRange.HighEnd,pRte)) )
            {
	            DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                    ("ArapValidNetrange: range in conflict\n"));

                fRangeIsValid = FALSE;
                RELEASE_SPIN_LOCK_DPC(&pRte->rte_Lock);
                break;
            }

            RELEASE_SPIN_LOCK_DPC(&pRte->rte_Lock);
		}

        if (!fRangeIsValid)
        {
            break;
        }
	}

	RELEASE_SPIN_LOCK(&AtalkRteLock, OldIrql);

#if DBG
    if (!fRangeIsValid)
    {
        DbgDumpNetworkNumbers();
    }
#endif

    return(fRangeIsValid);
}
#endif //ARAP_STATIC_MODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\atalk\sys\arap.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	arap.h

Abstract:

	This module has defines, prototypes etc. specific to ARAP functionality

Author:

	Shirish Koti

Revision History:
	15 Nov 1996		Initial Version

--*/


//
// enable asserts when running checked stack on free builds
//
#if DBG
#ifdef ASSERT
#undef ASSERT
#endif
#define ASSERT(exp)                                                     \
{                                                                       \
    if (!(exp))                                                         \
    {                                                                   \
        DbgPrint( "\n*** Assertion failed: %s (File %s, line %ld)\n",   \
              (exp),__FILE__, __LINE__);                                \
                                                                        \
        DbgBreakPoint();                                                \
    }                                                                   \
}
#endif



#define ATALK_CC_METHOD(_ControlCode)  ((_ControlCode) & 0x03)


//
// Possible states for the connection (State field in ARAPCONN structure)
// IMPORTANT: order of these states matters!  (comparisons other than == used)
//
#define MNP_IDLE             0  // creation state, after Ndiswan Line_Up
#define MNP_REQUEST          1  // this state never reached (client-side only)
#define MNP_RESPONSE         2  // sent LR response to the client
#define MNP_UP               3  // MNP connection is in data-phase
#define MNP_LDISCONNECTING   4  // disconnect from local (user ioctl)
#define MNP_RDISC_RCVD       5  // disconnect from remote received
#define MNP_RDISCONNECTING   6  // cleanup underway because of MNP_RDISC_RCVD
#define MNP_DISCONNECTED     7  // cleanup done, waiting for Ndiswan Line_Down

//
// possible header types (from the v42 alternative procedure spec)
//
#define MNP_LR             0x1
#define MNP_LD             0x2
#define MNP_LT             0x4
#define MNP_LT_V20CLIENT   0x84
#define MNP_LA             0x5
#define MNP_LN             0x6
#define MNP_LNA            0x7

#define MNP_MINPKT_SIZE     64
#define MNP_MAXPKT_SIZE     256

#define MNP_LR_CONST1       2
// type values for the various "variable" parms
#define MNP_LR_CONST2       1
#define MNP_LR_FRAMING      2
#define MNP_LR_NUMLTFRMS    3
#define MNP_LR_INFOLEN      4
#define MNP_LR_DATAOPT      8
#define MNP_LR_V42BIS       14

#define MNP_FRMMODE_OCTET   2
#define MNP_FRMMODE_BIT     3

#define MNP_FRMTYPE_OFFSET  4
#define ARAP_DGROUP_OFFSET  2
#define ARAP_DATA_OFFSET    3

// bit 6 is set for appletalk data, is clear for arap data
#define ARAP_SFLAG_PKT_DATA       0x40
#define ARAP_SFLAG_LAST_GROUP     0x10


//
// Flags bits (in ARAPCONN structure)
//
#define MNP_OPTIMIZED_DATA    0x00000001 // MNP negotiated for optimized data
#define MNP_V42BIS_NEGOTIATED 0x00000002 // MNP negotiated v42bis compression
#define ARAP_V20_CONNECTION   0x00000004 // v2.0 if bit set, v1.0 otherwise
#define ARAP_NODE_IN_USE      0x00000008 // used while acquiring node (dynamic mode)
#define ARAP_FINDING_NODE     0x00000010 // used while acquiring node (dynamic mode)
#define ARAP_CALLBACK_MODE    0x00000020 // used if we are calling back
#define ARAP_CONNECTION_UP    0x00000040 // ARAP connection is up, data phase entered
#define ARAP_DATA_WAITING     0x00000080 // data arrived, but no irp to fill it in
#define ARAP_REMOTE_DISCONN   0x00000100 // remote side issued the disconnect
#define DISCONNECT_NO_IRP     0x00000200 // waiting for irp to tell dll about disc.
#define RETRANSMIT_TIMER_ON   0x00000400 // retransmit timer is running
#define ARAP_LINK_DOWN        0x00000800 // link went down
#define ARAP_GOING_AWAY       0x00001000 // the connection is about to be freed!

// BUGBUG: currently set to be 200ms (1 => 100 ms)
#define ARAP_TIMER_INTERVAL   2

#define ARAP_MAX_RETRANSMITS       12
#define ARAP_HALF_MAX_RETRANSMITS  (ARAP_MAX_RETRANSMITS/2)

// retry time will depend on link speed (also on how many retranmits of the
// same send have happened so far), but we'll fix min (1sec) and max (5sec)
#define ARAP_MIN_RETRY_INTERVAL    10
#define ARAP_MAX_RETRY_INTERVAL    50

// our limits (in bytes) for outstanding sends that are sitting on the queue
#define ARAP_SENDQ_LOWER_LIMIT  10000
#define ARAP_SENDQ_UPPER_LIMIT  12000

// our limits (in bytes) for outstanding recvs that are sitting on the queue
#define ARAP_RECVQ_LOWER_LIMIT  20000
#define ARAP_RECVQ_UPPER_LIMIT  30000

// on low-priority sends, we wait until we collect at least these many bytes
#define ARAP_SEND_COALESCE_SIZE_LIMIT  150
// max number of SRPs we will put in a low-priority MNP send
#define ARAP_SEND_COALESCE_SRP_LIMIT   200
// on low-priority sends, we wait until so much time has passed (in 100ms units)
#define ARAP_SEND_COALESCE_TIME_LIMIT  10


// BUGBUG: adjust these numbers for optimum usage/perf
#define ARAP_SMPKT_SIZE     100
#define ARAP_MDPKT_SIZE     300
#define ARAP_LGPKT_SIZE     ARAP_MAXPKT_SIZE_INCOMING+10
#define ARAP_SENDBUF_SIZE   1000
#define ARAP_LGBUF_SIZE     4000
#define ARAP_HGBUF_SIZE     8100

// LAP src byte, LAP dest byte, LAP type byte
#define ARAP_LAP_HDRSIZE    3

// 2 srplen bytes, 1 Dgroup byte
#define ARAP_HDRSIZE        3

#define ARAP_NBP_BRRQ               0x11
#define ARAP_NBP_LKRQ               0x21

// 3rd and 4th bytes in the NBP pkt are the source network bytes
#define ARAP_NBP_SRCNET_OFFSET  LDDP_DGRAM_OFFSET + 2
#define ARAP_NBP_OBJLEN_OFFSET  LDDP_DGRAM_OFFSET + 7

#define ARAP_FAKE_ETHNET_HDRLEN     14
#define MNP_START_FLAG_LEN          3
#define MNP_STOP_FLAG_LEN           2
#define MNP_LT_HDR_LN(_pCon)  ((_pCon->Flags & MNP_OPTIMIZED_DATA)? 3 : 5)

#define ARAP_SEND_PRIORITY_HIGH     1
#define ARAP_SEND_PRIORITY_MED      2
#define ARAP_SEND_PRIORITY_LOW      3

#define MNP_OVERHD(_pConn)                              \
                            ( ARAP_FAKE_ETHNET_HDRLEN + \
                              MNP_START_FLAG_LEN      + \
                              MNP_LT_HDR_LN(_pConn)   + \
                              MNP_STOP_FLAG_LEN  )

#define ADD_ONE(_x)         (_x) = (((_x) == 0xff) ? 0 : ((_x)+1))

// seq num on LT frame: 5th byte if it's an Optimized data phase: 7th otherwise
#define  LT_SEQ_NUM(_p, _pCon)  \
                (((_pCon)->Flags & MNP_OPTIMIZED_DATA) ? (_p)[5] : (_p)[7])

#define  LT_SEQ_OFFSET(_pCon) (((_pCon)->Flags & MNP_OPTIMIZED_DATA) ? 5: 7)

#define  LT_SRP_OFFSET(_pCon) (((_pCon)->Flags & MNP_OPTIMIZED_DATA) ? 6: 8)

// this includes 2 bytes of crc bytes
#define  LT_OVERHEAD(_pCon) (((_pCon)->Flags & MNP_OPTIMIZED_DATA) ? 10 : 12)

// BUGBUG modify this to include any packet in the window
#define  LT_OK_TO_ACCEPT(_sq, _pCon, _ok) \
                (_ok = (_sq == _pCon->MnpState.NextToReceive))

//
// basically, (a > b)? except that a,b are seq numbers and wrap at 255
// Within a window of 8 pkts either side of 0, we have special cases
// we have assumed windowsize to be 8 here.  Even if a different window
// size is negotiated, this should work just fine
// BUGBUG: should we use a bigger range, just to be sure?
//
#define LT_GREATER_THAN(_a,_b,_result)                  \
{                                                       \
    if ( (_a) >= 248 && (_b) >= 0 && (_b) < 8 )         \
    {                                                   \
        _result = FALSE;                                \
    }                                                   \
    else if ( (_a) >= 0  && (_a) < 8 && (_b) >= 248 )   \
    {                                                   \
        _result = TRUE;                                 \
    }                                                   \
    else                                                \
    {                                                   \
        _result = ((_a) > (_b));                        \
    }                                                   \
}

#define LT_LESS_OR_EQUAL(_x,_y,_rslt)                   \
{                                                       \
    LT_GREATER_THAN(_x,_y,_rslt);                       \
    _rslt = !(_rslt);                                   \
}


#define LT_MIN_LENGTH(_pCon)    (((_pCon)->Flags & MNP_OPTIMIZED_DATA) ? 6 : 8)
#define LA_MIN_LENGTH(_pCon)    (((_pCon)->Flags & MNP_OPTIMIZED_DATA) ? 7 : 9)
#define LN_MIN_LENGTH           8

// seq num on LA frame: 5th byte if it's an Optimized data phase: 7th otherwise
#define  LA_SEQ_NUM(_p, _pCon)  \
                (((_pCon)->Flags & MNP_OPTIMIZED_DATA) ? (_p)[5] : (_p)[7])

// rcv credit on LA frame: 6th byte if it's an Optimized data phase: 8th otherwise
#define  LA_CREDIT(_p, _pCon)  \
                (((_pCon)->Flags & MNP_OPTIMIZED_DATA) ? (_p)[6] : (_p)[8])

// overhead for LT (optimized): 8  = 3(start flag)+3(LT hdr)+2(stop flag)
//              (nonoptimized): 10 = 3(start flag)+5(LT hdr)+2(stop flag)


#define LN_ATTN_TYPE(_p)   ((_p)[7])
#define LN_ATTN_SEQ(_p)    ((_p)[4])

#define LN_DESTRUCTIVE     1
#define LN_NON_D_E         2
#define LN_NON_D_NON_E     3


// The states that the stack can assume (with respect to ARAP)
//
// ARAP_STATE_INIT              -- arap engine (dll) hasn't open the stack
// ARAP_STATE_INACTIVE_WAITING  -- stack inactive, but engine not notified yet
// ARAP_STATE_INACTIVE          -- stack inactive, and engine notified
// ARAP_STATE_ACTIVE_WAITING    -- stack ready, engine not notified yet (select not available)
// ARAP_STATE_ACTIVE            -- stack ready, engine notified about it (via select)
//
#define ARAP_STATE_INACTIVE_WAITING     1
#define ARAP_STATE_INACTIVE             2
#define ARAP_STATE_ACTIVE_WAITING       3
#define ARAP_STATE_ACTIVE               4


#define ARAP_PORT_READY ( (AtalkDefaultPort != NULL) &&                 \
                          (AtalkDefaultPort->pd_Flags & PD_ACTIVE) &&   \
                          (RasPortDesc != NULL) &&                      \
                          (RasPortDesc->pd_Flags & PD_ACTIVE) )

#define ARAP_PNP_IN_PROGRESS ( ((AtalkDefaultPort != NULL) &&                           \
                                (AtalkDefaultPort->pd_Flags & PD_PNP_RECONFIGURE)) ||   \
                               ((RasPortDesc != NULL) &&                                \
                               (RasPortDesc->pd_Flags & PD_PNP_RECONFIGURE)) )

#define ARAP_INVALID_CONTEXT    (PVOID)0x01020304

#define ARAP_GET_SNIFF_IRP(_pIrp)                   \
{                                                   \
    KIRQL   _OldIrqlX;                              \
                                                    \
    ACQUIRE_SPIN_LOCK(&ArapSpinLock, &_OldIrqlX);   \
    *(_pIrp) = ArapSniffIrp;                        \
    ArapSniffIrp = NULL;                            \
    RELEASE_SPIN_LOCK(&ArapSpinLock, _OldIrqlX);    \
}



#if DBG
#define ARAP_COMPLETE_IRP(_pIrp, _dwBytesToDll, _status, _returnStatus)                        \
{                                                                               \
    PIO_STACK_LOCATION  _pIrpSp;                                                \
    ULONG _IoControlCode;                                                       \
                                                                                \
	_pIrpSp = IoGetCurrentIrpStackLocation(_pIrp);                              \
    _IoControlCode = _pIrpSp->Parameters.DeviceIoControl.IoControlCode;         \
                                                                                \
    _pIrp->IoStatus.Information = _dwBytesToDll;                                \
    _pIrp->IoStatus.Status = _status;                                           \
                                                                                \
    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_INFO,                                      \
        ("Arap: completing pIrp %lx, Ioctl %lx, Status=%ld, DataLen=%ld\n",     \
                _pIrp,_IoControlCode,_status,_dwBytesToDll));                   \
                                                                                \
    _pIrp->CancelRoutine = NULL;                                                \
    *_returnStatus = _pIrp->IoStatus.Status;                                      \
    IoCompleteRequest(_pIrp,IO_NETWORK_INCREMENT);                              \
}
#else
#define ARAP_COMPLETE_IRP(_pIrp, _dwBytesToDll, _status, _returnStatus)                        \
{                                                                               \
    PIO_STACK_LOCATION  _pIrpSp;                                                \
                                                                                \
	_pIrpSp = IoGetCurrentIrpStackLocation(_pIrp);                              \
                                                                                \
    _pIrp->IoStatus.Information = _dwBytesToDll;                                \
    _pIrp->IoStatus.Status = _status;                                           \
                                                                                \
                                                                                \
    _pIrp->CancelRoutine = NULL;                                                \
    *_returnStatus= _pIrp->IoStatus.Status;                                       \
    IoCompleteRequest(_pIrp,IO_NETWORK_INCREMENT);                              \
}
#endif

#define ARAP_SET_NDIS_CONTEXT(_pSndBuf,_pSndContxt)                            \
{                                                                              \
	PPROTOCOL_RESD  _pResd;                                                    \
	PNDIS_PACKET	_nPkt;                                                     \
                                                                               \
	_nPkt	= (_pSndBuf)->sb_BuffHdr.bh_NdisPkt;                               \
	_pResd = (PPROTOCOL_RESD)&_nPkt->ProtocolReserved;                         \
                                                                               \
	_pResd->Send.pr_Port         = RasPortDesc;                                \
    _pResd->Send.pr_SendCompletion = ArapNdisSendComplete;                     \
	_pResd->Send.pr_BufferDesc   = (PBUFFER_DESC)(_pSndBuf);                   \
	if ((_pSndContxt) != NULL)                                                 \
    {                                                                          \
        RtlCopyMemory(&_pResd->Send.pr_SendInfo,                               \
                      (_pSndContxt),                                           \
                      sizeof(SEND_COMPL_INFO));                                \
    }                                                                          \
	else                                                                       \
    {                                                                          \
        RtlZeroMemory(&_pResd->Send.pr_SendInfo, sizeof(SEND_COMPL_INFO));     \
    }                                                                          \
}

//
// we take a very simplistic view!
//
#define ARAP_ADJUST_RECVCREDIT(_pConn)                                         \
{                                                                              \
    if (_pConn->RecvsPending >= ARAP_RECVQ_UPPER_LIMIT)                        \
    {                                                                          \
		DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,                                  \
        ("ARAP (%lx): recv credit dropped to 0 (%d)\n",_pConn,_pConn->RecvsPending));\
                                                                               \
        _pConn->MnpState.RecvCredit = 0;                                       \
    }                                                                          \
    else if (_pConn->RecvsPending >= ARAP_RECVQ_LOWER_LIMIT)                   \
    {                                                                          \
		DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,                                  \
        ("ARAP (%lx): recv credit dropped to 1 (%d)\n",_pConn,_pConn->RecvsPending));\
                                                                               \
        _pConn->MnpState.RecvCredit = 1;                                       \
    }                                                                          \
    else                                                                       \
    {                                                                          \
        _pConn->MnpState.RecvCredit = _pConn->MnpState.WindowSize;             \
    }                                                                          \
}

#if DBG
#define ARAP_GET_RIGHTSIZE_RCVBUF(_size, _ppNewBuf)                            \
{                                                                              \
    UCHAR       _BlkId;                                                        \
    PARAPBUF    _pRcvBuf;                                                      \
    USHORT      _BufSize;                                                      \
    DWORD       _Signature;                                                    \
                                                                               \
    *(_ppNewBuf) = NULL;                                                       \
    _pRcvBuf = NULL;                                                           \
                                                                               \
    if ((_size) <= ARAP_SMPKT_SIZE)                                            \
    {                                                                          \
        _BlkId = BLKID_ARAP_SMPKT;                                             \
        _BufSize = ARAP_SMPKT_SIZE;                                            \
        _Signature = ARAPSMPKT_SIGNATURE;                                      \
    }                                                                          \
    else if ((_size) <= ARAP_MDPKT_SIZE)                                       \
    {                                                                          \
        _BlkId = BLKID_ARAP_MDPKT;                                             \
        _BufSize = ARAP_MDPKT_SIZE;                                            \
        _Signature = ARAPMDPKT_SIGNATURE;                                      \
    }                                                                          \
    else if ((_size) <= ARAP_LGPKT_SIZE)                                       \
    {                                                                          \
        _BlkId = BLKID_ARAP_LGPKT;                                             \
        _BufSize = ARAP_LGPKT_SIZE;                                            \
        _Signature = ARAPLGPKT_SIGNATURE;                                      \
    }                                                                          \
    else if ((_size) <= ARAP_LGBUF_SIZE)                                       \
    {                                                                          \
        _BlkId = BLKID_ARAP_LGBUF;                                             \
        _BufSize = ARAP_LGBUF_SIZE;                                            \
        _Signature = ARAPLGBUF_SIGNATURE;                                      \
    }                                                                          \
    else                                                                       \
    {                                                                          \
        _BlkId = ARAP_UNLMTD_BUFF_ID;                                          \
        _BufSize = (USHORT)(_size);                                            \
        _Signature = ARAPUNLMTD_SIGNATURE;                                     \
    }                                                                          \
                                                                               \
    if (_BlkId == ARAP_UNLMTD_BUFF_ID)                                         \
    {                                                                          \
        if ((_size) > 5000)                                                    \
        {                                                                      \
            DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,                              \
               ("Arap: allocating %ld bytes rcv buf\n",_size));                \
        }                                                                      \
                                                                               \
        _pRcvBuf = (PARAPBUF)AtalkAllocMemory((_size) + sizeof(ARAPBUF));      \
    }                                                                          \
    else                                                                       \
    {                                                                          \
        _pRcvBuf = (PARAPBUF)AtalkBPAllocBlock(_BlkId);                        \
    }                                                                          \
                                                                               \
    if (_pRcvBuf != NULL)                                                      \
    {                                                                          \
        _pRcvBuf->Signature = _Signature;                                      \
        _pRcvBuf->BlockId = _BlkId;                                            \
        _pRcvBuf->BufferSize = _BufSize;                                       \
	    _pRcvBuf->DataSize = 0;                                                \
	    _pRcvBuf->CurrentBuffer = &(_pRcvBuf->Buffer[0]);                      \
        *(_ppNewBuf) = _pRcvBuf;                                               \
    }                                                                          \
}

#define ARAP_FREE_RCVBUF(_pBuf)                                                \
{                                                                              \
    ASSERT( (_pBuf->Signature == ARAPSMPKT_SIGNATURE) ||                       \
            (_pBuf->Signature == ARAPMDPKT_SIGNATURE) ||                       \
            (_pBuf->Signature == ARAPLGPKT_SIGNATURE) ||                       \
            (_pBuf->Signature == ARAPLGBUF_SIGNATURE) ||                       \
            (_pBuf->Signature == ARAPUNLMTD_SIGNATURE) );                      \
                                                                               \
    _pBuf->Signature -= 0x10210000;                                            \
    if (_pBuf->BlockId == ARAP_UNLMTD_BUFF_ID)                                 \
    {                                                                          \
        AtalkFreeMemory(_pBuf);                                                \
    }                                                                          \
    else                                                                       \
    {                                                                          \
        AtalkBPFreeBlock(_pBuf);                                               \
    }                                                                          \
}

#define ARAP_CHECK_RCVQ_INTEGRITY(_pConn)                                      \
{                                                                              \
    ASSERT( (DbgChkRcvQIntegrity(_pConn)) );                                   \
}

#define MNP_DBG_TRACE(_pConn,_Seq,_FrmType)                                    \
{                                                                              \
    ArapDbgMnpHist(_pConn,_Seq,(_FrmType));                                    \
}                                                                              \

#define ARAP_DBG_TRACE(_pConn,_Loc,_Ptr,_D1,_D2,_D3)                           \
{                                                                              \
    ArapDbgTrace(_pConn,_Loc,_Ptr,_D1,_D2,_D3);                                \
}

#define ARAP_DUMP_DBG_TRACE(_pConn)     ArapDumpSniffInfo(_pConn)

#else
#define ARAP_GET_RIGHTSIZE_RCVBUF(_size, _ppNewBuf)                            \
{                                                                              \
    UCHAR       _BlkId;                                                        \
    PARAPBUF    _pRcvBuf;                                                      \
    USHORT      _BufSize;                                                      \
                                                                               \
    *(_ppNewBuf) = NULL;                                                       \
    _pRcvBuf = NULL;                                                           \
                                                                               \
    if ((_size) <= ARAP_SMPKT_SIZE)                                            \
    {                                                                          \
        _BlkId = BLKID_ARAP_SMPKT;                                             \
        _BufSize = ARAP_SMPKT_SIZE;                                            \
    }                                                                          \
    else if ((_size) <= ARAP_MDPKT_SIZE)                                       \
    {                                                                          \
        _BlkId = BLKID_ARAP_MDPKT;                                             \
        _BufSize = ARAP_MDPKT_SIZE;                                            \
    }                                                                          \
    else if ((_size) <= ARAP_LGPKT_SIZE)                                       \
    {                                                                          \
        _BlkId = BLKID_ARAP_LGPKT;                                             \
        _BufSize = ARAP_LGPKT_SIZE;                                            \
    }                                                                          \
    else if ((_size) <= ARAP_LGBUF_SIZE)                                       \
    {                                                                          \
        _BlkId = BLKID_ARAP_LGBUF;                                             \
        _BufSize = ARAP_LGBUF_SIZE;                                            \
    }                                                                          \
    else                                                                       \
    {                                                                          \
        _BlkId = ARAP_UNLMTD_BUFF_ID;                                          \
        _BufSize = (USHORT)(_size);                                            \
    }                                                                          \
                                                                               \
    if (_BlkId == ARAP_UNLMTD_BUFF_ID)                                         \
    {                                                                          \
        _pRcvBuf = (PARAPBUF)AtalkAllocMemory((_size) + sizeof(ARAPBUF));      \
    }                                                                          \
    else                                                                       \
    {                                                                          \
        _pRcvBuf = (PARAPBUF)AtalkBPAllocBlock(_BlkId);                        \
    }                                                                          \
                                                                               \
    if (_pRcvBuf != NULL)                                                      \
    {                                                                          \
        _pRcvBuf->BlockId = _BlkId;                                            \
        _pRcvBuf->BufferSize = _BufSize;                                       \
	    _pRcvBuf->DataSize = 0;                                                \
	    _pRcvBuf->CurrentBuffer = &(_pRcvBuf->Buffer[0]);                      \
        *(_ppNewBuf) = _pRcvBuf;                                               \
    }                                                                          \
}

#define ARAP_FREE_RCVBUF(_pBuf)                                                \
{                                                                              \
    if (_pBuf->BlockId == ARAP_UNLMTD_BUFF_ID)                                 \
    {                                                                          \
        AtalkFreeMemory(_pBuf);                                                \
    }                                                                          \
    else                                                                       \
    {                                                                          \
        AtalkBPFreeBlock(_pBuf);                                               \
    }                                                                          \
}

#define ARAP_CHECK_RCVQ_INTEGRITY(_pConn)

#define MNP_DBG_TRACE(_pConn,_Seq,_FrmType)
#define ARAP_DBG_TRACE(_pConn,_Loc,_Ptr,_D1,_D2,_D3)
#define ARAP_DUMP_DBG_TRACE(_pConn)

#endif  // #if DBG



#define ARAP_BYTES_ON_RECVQ(_pConn,_BytesOnQ)                                  \
{                                                                              \
    DWORD       _BytesSoFar=0;                                                 \
    PLIST_ENTRY _pList;                                                        \
    PARAPBUF    _pArapBuf;                                                     \
                                                                               \
    *(_BytesOnQ) = 0;                                                          \
                                                                               \
    _pList = _pConn->ReceiveQ.Flink;                                           \
    while (_pList != &_pConn->ReceiveQ)                                        \
    {                                                                          \
        _pArapBuf = CONTAINING_RECORD(_pList, ARAPBUF, Linkage);               \
        _BytesSoFar += _pArapBuf->DataSize;                                    \
                                                                               \
        _pList = _pArapBuf->Linkage.Flink;                                     \
    }                                                                          \
                                                                               \
    *(_BytesOnQ) = _BytesSoFar;                                                \
}


#if DBG
#define  ARAPTRACE(_x)             DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_INFO, _x)
#define  DBGDUMPBYTES(_a,_b,_c,_d) DbgDumpBytes(_a,_b,_c,_d)
#define  DBGTRACK_SEND_SIZE(_pConn,_Size)   DbgTrackInfo(_pConn,_Size,1)
#else
#define  ARAPTRACE(_x)
#define  DBGDUMPBYTES(_a,_b,_c,_d)
#define  DBGTRACK_SEND_SIZE(_pConn,_Size)
#endif

#define ARAPACTION_COMPLETE_IRP     1
#define ARAPACTION_CALL_COMPLETION  2

typedef struct _ADDRMGMT
{
    struct _ADDRMGMT  * Next;
    USHORT              Network;
    BYTE                NodeBitMap[32];    // 255 nodes per net
}ADDRMGMT, *PADDRMGMT;

typedef struct _ARAPGLOB
{
    DWORD           LowVersion;
    DWORD           HighVersion;
    DWORD           MnpInactiveTime;    // tell dll after Mnp is inactive for this time
    BOOLEAN         V42bisEnabled;      //
    BOOLEAN         SmartBuffEnabled;   //
    BOOLEAN         NetworkAccess;      // if FALSE, no routing (only this machine)
    BOOLEAN         DynamicMode;        // we want the stack to get node address
    NETWORKRANGE    NetRange;
    PADDRMGMT       pAddrMgmt;          // addr allocation to clients (in static mode)
    USHORT          OurNetwkNum;        // Network number of our default port
    BYTE            MaxLTFrames;        // max LT frames outstanding (rcv window)
    BOOLEAN         SniffMode;          // if TRUE, all pkts will be given to ARAP to "sniff"
    BOOLEAN         RouteAdded;         // if in static mode, have we added a route?
} ARAPGLOB, *PARAPGLOB;


typedef struct _ARAPSTATS
{
    DWORD   SendPreCompMax;    // largest packet we have sent (before comp)
    DWORD   SendPostCompMax;   // largest packet we have sent (after comp)
    DWORD   SendPreCompMin;    // smallest packet we have sent (before comp)
    DWORD   SendPostCompMin;   // smallest packet we have sent (after comp)
    DWORD   RecvPostDecompMax; // largest packet we have received (after decomp)
    DWORD   RecvPostDecomMin;  // smallest packet we have received (after decomp)
} ARAPSTATS, *PARAPSTATS;


typedef VOID (*PARAP_SEND_COMPLETION)(
              struct _MNPSENDBUF * pMnpSendBuf,
              DWORD                Status
);


typedef struct _MNPSTATE
{
    // sequence numbers when we are receiving
    BYTE    NextToReceive;      // next frame we expect to receive
    BYTE    LastSeqRcvd;        // seq num of last pkt we successfully rcvd
    BYTE    LastAckSent;        // seq num for which we sent the last ack
    BYTE    UnAckedRecvs;       // how many packets we've recvd but not acked yet
    BYTE    RecvCredit;         // how many more we can receive
    BYTE    HoleInSeq;          // TRUE when we get a hole in receive sequence
    BYTE    ReceivingDup;       // TRUE the moment we start receiving dup(s)
    BYTE    FirstDupSeq;        // seq num where we started getting dup's
    BYTE    DupSeqBitMap;       // bitmap of which seq nums we've got dups for
                                // BUGBUG: if we ever want windowsize of more than 8,
                                //         we must make this a DWORD or something!
    // sequence numbers when we are sending
    BYTE    LastAckRcvd;        // last frame we have received ack for
    BYTE    NextToSend;         // next frame we will send
    BYTE    SendCredit;         // how many more we can send
    BYTE    UnAckedSends;       // basically, number of sends on retransmitQ
    BYTE    MustRetransmit;     // TRUE when we want retransmission to occur
    BYTE    RetransmitMode;     // TRUE if we are in retransmit mode

    // when we are processing the receives
    BYTE    NextToProcess;      // next sequence we will process
    BYTE    MustAck;            // if TRUE, send ack

    // static info that we negotiated at connection time
    BYTE    WindowSize;         // max pkts we can buffer (parm k)
    BYTE    UnAckedLimit;       // num of unacked pkts after which we must ack
    USHORT  MaxPktSize;         // N401 parm: this can be max 256
    BYTE    SynByte;
    BYTE    DleByte;
    BYTE    StxByte;
    BYTE    EtxByte;
    BYTE    LTByte;

} MNPSTATE, *PMNPSTATE;


typedef struct _ARAPDBGHISTORY
{
    USHORT      TimeStamp;    // when did this happen (relative to prev event)
    USHORT      Location;     // where did this happen
    BYTE        Info[1];      // info specific to what/where happened
} ARAPDBGHISTORY, *PARAPDBGHISTORY;

#define DBG_HISTORY_BUF_SIZE   4000

typedef struct _DBGMNPHIST
{
    DWORD       TimeStamp;
    DWORD       FrameInfo;
} DBGMNPHIST, *PDBGMNPHIST;

#define DBG_MNP_HISTORY_SIZE   80


typedef struct _ARAPCONN
{
    LIST_ENTRY                Linkage;
#if DBG
    DWORD                     Signature;
#endif
    DWORD                     State;             // connected, connecting etc
    DWORD                     RefCount;          // memory freed when this goes to 0
    MNPSTATE                  MnpState;          // MNP state info
    DWORD                     Flags;             // general flag kind of info
    ATALK_NODEADDR            NetAddr;           // network address of the Arap client
    PVOID                     pDllContext;       // Araps context
    PIRP                      pIoctlIrp;         // irp sent down by the ARAP dll
    PIRP                      pRecvIoctlIrp;     // receive irp from ARAP dll
    LIST_ENTRY                MiscPktsQ;         // pkts other than LT queued here
    LIST_ENTRY                ReceiveQ;          // data indicated but not yet processed
    LIST_ENTRY                ArapDataQ;         // data that's waiting for an irp from Arap
    LIST_ENTRY                HighPriSendQ;      // high priority sends
    LIST_ENTRY                MedPriSendQ;       // medium priority sends
    LIST_ENTRY                LowPriSendQ;       // low priority sends
    LIST_ENTRY                SendAckedQ;        // got ack, need to complete this send
    LIST_ENTRY                RetransmitQ;       // data sent out, but not acked yet
    DWORD                     SendsPending;      // unacked/unsent sends (bytes) pending
    DWORD                     RecvsPending;      // rcvs (bytes) yet to be delivered
    TIMERLIST                 RetryTimer;        // the 401 timer (retransmit timer)
    LONG                      LATimer;           // the 402 timer
    LONG                      T402Duration;      // timer value for the 402 timer
    LONG                      InactivityTimer;   // the 403 timer
    LONG                      T403Duration;      // timer value for the 403 timer
    LONG                      FlowControlTimer;  // the 404 timer
    LONG                      T404Duration;      // timer value for the 404 timer
    BYTE                      NdiswanHeader[14]; // 14 byte ethernet-like header
    BYTE                      BlockId;           // basically what size sends to use
    BYTE                      UnUsed;
    ULONG                     LinkSpeed;         // link speed in 100 bps units
    STAT_INFO                 StatInfo;          // statistics for this connection
    LONG                      SendRetryTime;     // send timer to fire after how much time
    LONG                      SendRetryBaseTime; // send timer interval at init
    ATALK_SPIN_LOCK           SpinLock;
    KEVENT                    NodeAcquireEvent;  // use while acquiring node (dynamic mode)
    LONG                      LastNpbBrrq;       // time we sent out a NBP_BRRQ pkt last
    v42bis_connection_t      *pV42bis;
#if DBG
    LARGE_INTEGER             LastTimeStamp;     // when did we last record history
    DWORD                     DbgMnpIndex;
    DBGMNPHIST                DbgMnpHist[DBG_MNP_HISTORY_SIZE];
    PBYTE                     pDbgTraceBuffer;   // where the sniff buffer starts
    PBYTE                     pDbgCurrPtr;       // currently pointing here in sniff buf
    DWORD                     SniffedBytes;      // how much does sniff buffer contain
#endif

} ARAPCONN, *PARAPCONN;


typedef struct _ARAPSNIFF
{
    DWORD   Signature;
    DWORD   TimeStamp;
    USHORT  Length;
    BYTE    StartSeq;
    BYTE    EndSeq;
    DWORD   UncompBytesSoFar;
} ARAPSNIFF, *PARAPSNIFF;



typedef struct _ARAPQITEM
{
    WORK_QUEUE_ITEM     WorkQItem;
    DWORD               Action;
    PVOID               Context1;
    PVOID               Context2;
} ARAPQITEM, *PARAPQITEM;


#if DBG
#define  DBG_ARAP_CHECK_PAGED_CODE()                           \
{                                                              \
    if (AtalkPgLkSection[ARAP_SECTION].ls_LockCount <= 0)      \
    {                                                          \
        DbgPrint("Arap code section not locked, count=%d\n",   \
            AtalkPgLkSection[ARAP_SECTION].ls_LockCount);      \
        ASSERT(0);                                             \
    }                                                          \
}
#define  DBG_PPP_CHECK_PAGED_CODE()                            \
{                                                              \
    if (AtalkPgLkSection[PPP_SECTION].ls_LockCount <= 0)       \
    {                                                          \
        DbgPrint("PPP code section not locked, count=%d\n",    \
            AtalkPgLkSection[PPP_SECTION].ls_LockCount);       \
        ASSERT(0);                                             \
    }                                                          \
}
#else
#define  DBG_ARAP_CHECK_PAGED_CODE()
#define  DBG_PPP_CHECK_PAGED_CODE()
#endif


#define ARAP_ID_BYTE1   0xAA
#define ARAP_ID_BYTE2   0xBB

#define PPP_ID_BYTE1    0xCC
#define PPP_ID_BYTE2    0xDD

typedef struct _ATCPCONN
{
    LIST_ENTRY                Linkage;
#if DBG
    DWORD                     Signature;
#endif
    DWORD                     Flags;             // general flag kind of info
    DWORD                     RefCount;          // memory freed when this goes to 0
    ATALK_NODEADDR            NetAddr;           // network address of the Arap client
    PVOID                     pDllContext;       // Araps context
    BYTE                      NdiswanHeader[14]; // 14 byte ethernet-like header
    ATALK_SPIN_LOCK           SpinLock;
    KEVENT                    NodeAcquireEvent;  // use while acquiring node (dynamic mode)
} ATCPCONN, *PATCPCONN;

#define ATCP_NODE_IN_USE        0x1
#define ATCP_FINDING_NODE       0x2
#define ATCP_SUPPRESS_RTMP      0x4
#define ATCP_SUPPRESS_ALLBCAST  0x8
#define ATCP_DLL_SETUP_DONE     0x10
#define ATCP_LINE_UP_DONE       0x20
#define ATCP_CONNECTION_UP      0x40
#define ATCP_CONNECTION_CLOSING 0x80

// globals

extern  struct _PORT_DESCRIPTOR  *RasPortDesc;

// spinlock to guard the all the Arap global things
extern  ATALK_SPIN_LOCK ArapSpinLock;

// global configuration info
extern  ARAPGLOB        ArapGlobs;

extern  PIRP            ArapSelectIrp;
extern  DWORD           ArapConnections;
extern  DWORD           ArapStackState;

extern  DWORD           PPPConnections;

#if DBG

extern  PIRP            ArapSniffIrp;
extern  ARAPSTATS       ArapStatistics;
extern  DWORD           ArapDumpLevel;
extern  DWORD           ArapDumpLen;
extern  DWORD           ArapDbgMnpSendSizes[30];
extern  DWORD           ArapDbgMnpRecvSizes[30];
extern  DWORD           ArapDbgArapSendSizes[15];
extern  DWORD           ArapDbgArapRecvSizes[15];
extern  LARGE_INTEGER   ArapDbgLastTraceTime;
extern  UCHAR           ArapDbgLRPacket[30];
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\atalk\sys\arap.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	arap.c

Abstract:

	This module implements routines specific to ARAP

Author:

	Shirish Koti

Revision History:
	15 Nov 1996		Initial Version

--*/


#include 	<atalk.h>
#pragma hdrstop


#define	FILENUM		ARAP

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,      ArapProcessIoctl)
#pragma alloc_text(PAGE_ARAP, ArapMarkConnectionUp)
#pragma alloc_text(PAGE_ARAP, ArapIoctlRecv)
#pragma alloc_text(PAGE_ARAP, ArapExchangeParms)
#pragma alloc_text(PAGE_ARAP, ArapConnect)
#pragma alloc_text(PAGE_ARAP, ArapConnectComplete)
#pragma alloc_text(PAGE_ARAP, ArapDisconnect)
#pragma alloc_text(PAGE_ARAP, ArapGetAddr)
#pragma alloc_text(PAGE_ARAP, ArapGetStats)
#pragma alloc_text(PAGE_ARAP, ArapIoctlSend)
#pragma alloc_text(PAGE_ARAP, ArapSendPrepare)
#pragma alloc_text(PAGE_ARAP, ArapMnpSendComplete)
#pragma alloc_text(PAGE_ARAP, ArapIoctlSendComplete)
#pragma alloc_text(PAGE_ARAP, ArapDataToDll)
#pragma alloc_text(PAGE_ARAP, MnpSendAckIfReqd)
#pragma alloc_text(PAGE_ARAP, MnpSendLNAck)
#pragma alloc_text(PAGE_ARAP, ArapSendLDPacket)
#pragma alloc_text(PAGE_ARAP, ArapRetryTimer)
#endif


//***
//
// Function: ArapProcessIoctl
//              Process all ioctls coming from the Ras-ARAP module
//
// Parameters:  pIrp - the irp to process
//
// Return:      result of the operation
//
//***$

NTSTATUS
ArapProcessIoctl(
	IN PIRP 			pIrp
)
{
	NTSTATUS				status=STATUS_SUCCESS;
	PIO_STACK_LOCATION 		pIrpSp;
    ULONG                   IoControlCode;
    PARAP_SEND_RECV_INFO    pSndRcvInfo=NULL;
    PATCPCONN               pAtcpConn=NULL;
    PARAPCONN               pArapConn=NULL;
    ATALK_NODEADDR          ClientNode;
    DWORD                   dwBytesToDll;
    DWORD                   dwOrgIrql;
    DWORD                   dwFlags;
    DWORD                   dwInputBufLen;
    DWORD                   dwOutputBufLen;
    BOOLEAN                 fDerefDefPort=FALSE;
	NTSTATUS				ReturnStatus=STATUS_SUCCESS;


    PAGED_CODE ();

    dwOrgIrql = KeGetCurrentIrql();

    ASSERT(dwOrgIrql < DISPATCH_LEVEL);

	pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

    IoControlCode = pIrpSp->Parameters.DeviceIoControl.IoControlCode;

    dwInputBufLen = pIrpSp->Parameters.DeviceIoControl.InputBufferLength;

    dwOutputBufLen = pIrpSp->Parameters.DeviceIoControl.OutputBufferLength;

    ARAPTRACE(("Entered ArapProcessIoctl (%lx %lx)\n",pIrp, IoControlCode));

    pSndRcvInfo = (PARAP_SEND_RECV_INFO)pIrp->AssociatedIrp.SystemBuffer;

    if (!pSndRcvInfo)
    {
        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
            ("ArapProcessIoctl: SystemBuffer is NULL!! (ioctl = %lx,pIrp = %lx)\n",
            pIrp,IoControlCode));

        ARAP_COMPLETE_IRP(pIrp, 0, STATUS_INVALID_PARAMETER, &ReturnStatus);
        return( ReturnStatus );
    }

    if (dwInputBufLen < sizeof(ARAP_SEND_RECV_INFO))
    {
        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
            ("ArapProcessIoctl: irp %lx, too small input buffer (%d bytes)!\n",
            pIrp,dwInputBufLen));

        ARAP_COMPLETE_IRP(pIrp, 0, STATUS_INVALID_PARAMETER, &ReturnStatus);
        return( ReturnStatus );
    }

    if (dwOutputBufLen < sizeof(ARAP_SEND_RECV_INFO))
    {
        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
            ("ArapProcessIoctl: irp %lx, too small output buffer (%d bytes)!\n",
            pIrp,dwOutputBufLen));

        ARAP_COMPLETE_IRP(pIrp, 0, STATUS_INVALID_PARAMETER, &ReturnStatus);
        return( ReturnStatus );
    }

    //
    // handle PPP (ATCP) ioctls separately
    //
    if ((IoControlCode == IOCTL_ATCP_SETUP_CONNECTION) ||
        (IoControlCode == IOCTL_ATCP_SUPPRESS_BCAST) ||
        (IoControlCode == IOCTL_ATCP_CLOSE_CONNECTION))
    {
        if (IoControlCode == IOCTL_ATCP_SETUP_CONNECTION)
        {
            AtalkLockPPPIfNecessary();
            ReturnStatus = PPPProcessIoctl(pIrp, pSndRcvInfo, IoControlCode, NULL);
			return (ReturnStatus);
        }
        else
        {
            ClientNode.atn_Network = pSndRcvInfo->ClientAddr.ata_Network;
            ClientNode.atn_Node = (BYTE)pSndRcvInfo->ClientAddr.ata_Node;

            if (ClientNode.atn_Node != 0)
            {
                // find the right connection
                pAtcpConn = FindAndRefPPPConnByAddr(ClientNode, &dwFlags);
            }
            else
            {
                DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                    ("ArapProcessIoctl: excuse me?  Node is 0! Irp=%lx\n",pIrp));
                ASSERT(0);
            }

            if (pAtcpConn)
            {
                PPPProcessIoctl(pIrp, pSndRcvInfo, IoControlCode, pAtcpConn);

                // remove the refcount put in by FindAndRefPPPConnByAddr
                DerefPPPConn(pAtcpConn);
            }
            else
            {
		        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                    ("ArapProcessIoctl: PPP Ioctl %lx but can't find conn %x.%x\n",
                    IoControlCode,pSndRcvInfo->ClientAddr.ata_Network,
                    pSndRcvInfo->ClientAddr.ata_Node));

                pSndRcvInfo->StatusCode = ARAPERR_NO_SUCH_CONNECTION;
                ARAP_COMPLETE_IRP(pIrp, sizeof(ARAP_SEND_RECV_INFO), 
									STATUS_SUCCESS, &ReturnStatus);
				return (ReturnStatus);
            }
        }

        return( STATUS_SUCCESS);
    }

//
// NOTE: ALL THE ARAP CODE IS NOW DEFUNCT.  To minimize code-churn, only small changes
// are done to disable ARAP.  At some point in time, all the code needs to be cleaned up
// so ARAP-specific stuff is completely removed
//
else
{
    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
        ("ArapProcessIoctl: ARAP not supported anymore!!\n"));
    ASSERT(0);

    ARAP_COMPLETE_IRP(pIrp, 0, STATUS_INVALID_PARAMETER, &ReturnStatus);
    return( ReturnStatus );
}


    if (!ArapAcceptIrp(pIrp, IoControlCode, &fDerefDefPort))
    {
        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
            ("ArapProcessIoctl: irp %lx not accepted (%lx)\n", pIrp,IoControlCode));

        ARAP_COMPLETE_IRP(pIrp, sizeof(ARAP_SEND_RECV_INFO), STATUS_SUCCESS, &ReturnStatus);

        // remove that IrpProcess refcount
        if (fDerefDefPort)
        {
            AtalkPortDereference(AtalkDefaultPort);
        }

        return( ReturnStatus);
    }

    if ((IoControlCode != IOCTL_ARAP_EXCHANGE_PARMS) &&
        (IoControlCode != IOCTL_ARAP_GET_ZONE_LIST))
    {
        pArapConn = pSndRcvInfo->AtalkContext;
    }

    //
    // if ths irp is for a specific connection, validate the connection first!
    //
    if ((pArapConn != NULL) && (!ArapConnIsValid(pArapConn)))
    {
        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
            ("ArapProcessIoctl: conn %lx is gone! (ioctl = %lx)\n",
            pArapConn,IoControlCode));

        pSndRcvInfo->StatusCode = ARAPERR_NO_SUCH_CONNECTION;

        ARAP_COMPLETE_IRP(pIrp, sizeof(ARAP_SEND_RECV_INFO), STATUS_SUCCESS, &ReturnStatus);

        // remove that IrpProcess refcount
        if (fDerefDefPort)
        {
            AtalkPortDereference(AtalkDefaultPort);
        }

        return( ReturnStatus);
    }

    dwBytesToDll = sizeof(ARAP_SEND_RECV_INFO);

    // in most likelihood, we're going to return pending: mark it so
    IoMarkIrpPending(pIrp);

    switch (IoControlCode)
    {
        //
        // receive parameters from the user-level, and return some of our own
        //
        case IOCTL_ARAP_EXCHANGE_PARMS:

            // exchange of parms: if not already done, lock arap pages
            AtalkLockArapIfNecessary();

            status = ArapExchangeParms( pIrp );
            dwBytesToDll = sizeof(EXCHGPARMS);

            // exchange of parms done: unlock if possible
            AtalkUnlockArapIfNecessary();
            break;

        case IOCTL_ARAP_SETUP_CONNECTION:

            // new connection being established: if not already done, lock arap pages
            AtalkLockArapIfNecessary();
            pSndRcvInfo->StatusCode = ARAPERR_NO_ERROR;
            status = STATUS_SUCCESS;
            break;

        //
        // setup the low level arap connection link (aka Point-to-Point Link)
        // (first time client dials in, we respond. At callback, we initiate;
        // at callback time, we initiate the connection here)
        //
        case IOCTL_ARAP_MNP_CONN_RESPOND:
        case IOCTL_ARAP_MNP_CONN_INITIATE:

            status = ArapConnect( pIrp, IoControlCode );
            break;

        //
        // obtain (or make up) an appletalk address for the client and return it
        //
        case IOCTL_ARAP_GET_ADDR:

            status = ArapGetAddr( pIrp );
            break;

        //
        // just mark the Arap connection as being established
        //
        case IOCTL_ARAP_CONNECTION_UP:

            status = ArapMarkConnectionUp( pIrp );
            break;

        //
        // dll wants the connection blown away: disconnect it
        //
        case IOCTL_ARAP_DISCONNECT:

            status = ArapDisconnect( pIrp );
            break;

        //
        // send the buffer given by the dll
        //
        case IOCTL_ARAP_SEND:

            status = ArapIoctlSend( pIrp );
            break;

        //
        // "direct irp": get data for the connection specified
        //
        case IOCTL_ARAP_RECV:

            status = ArapIoctlRecv( pIrp );
            break;

        //
        // "select irp": get data if there is for any connection
        //
        case IOCTL_ARAP_SELECT:

            status = ArapProcessSelect( pIrp );
            break;

#if DBG
        //
        // "sniff irp": return all the sniff info
        //
        case IOCTL_ARAP_SNIFF_PKTS:

            status = ArapProcessSniff( pIrp );
            break;
#endif

        //
        // engine wants the select irp unblocked (either because it's shutting
        // down or because we want to shutdown)
        //
        case IOCTL_ARAP_CONTINUE_SHUTDOWN:

            ArapUnblockSelect();
            status = STATUS_SUCCESS;
            break;

        //
        // get names of all the zones in the entire network
        //
        case IOCTL_ARAP_GET_ZONE_LIST:

            ArapZipGetZoneStat( (PZONESTAT)pSndRcvInfo );

            // (-4 to avoid 4 bytes from ZoneNames[1] field)
            dwBytesToDll = ((PZONESTAT)pSndRcvInfo)->BufLen + sizeof(ZONESTAT) - 4;
            status = STATUS_SUCCESS;
            break;

        default:

            DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                    ("ArapProcessIoctl: Invalid Request %lx\n", IoControlCode));

            status = STATUS_INVALID_PARAMETER;
    }


    if( status != STATUS_PENDING )
    {
        pIrpSp->Control &= ~SL_PENDING_RETURNED;

        ARAP_COMPLETE_IRP(pIrp, dwBytesToDll, STATUS_SUCCESS, &ReturnStatus);
		status = ReturnStatus;
    }

    //
    // if this irp was for a specific connection, validation refcount was put
    // on it: take that away
    //
    if (pArapConn)
    {
        DerefArapConn(pArapConn);
    }

    // remove that IrpProcess refcount
    if (fDerefDefPort)
    {
        AtalkPortDereference(AtalkDefaultPort);
    }

    ASSERT(KeGetCurrentIrql() == dwOrgIrql);

    return( status );

}




//***
//
// Function: ArapMarkConnectionUp
//              Set the flags in our connection to mark that Arap connection
//              has been established (by the dll)  (we don't route until this
//              happens)
//
// Parameters:  pIrp - the irp to process
//
// Return:      result of the operation
//
//***$

NTSTATUS
ArapMarkConnectionUp(
    IN PIRP                 pIrp
)
{

    PARAPCONN               pArapConn;
    PARAP_SEND_RECV_INFO    pSndRcvInfo;
    KIRQL                   OldIrql;


    DBG_ARAP_CHECK_PAGED_CODE();

    pSndRcvInfo = (PARAP_SEND_RECV_INFO)pIrp->AssociatedIrp.SystemBuffer;

    pArapConn = (PARAPCONN)pSndRcvInfo->AtalkContext;

    if (pArapConn == NULL)
    {
		DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
            ("ArapMarkConnectionUp: null conn\n"));

        pSndRcvInfo->StatusCode = ARAPERR_NO_SUCH_CONNECTION;
        return(STATUS_SUCCESS);
    }

    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
        ("  Yippeee! %s connection is up! (%x.%x @%lx)\n",
        (pArapConn->Flags & ARAP_V20_CONNECTION)? "ARAP v2.0":"ARAP v1.0",
        pArapConn->NetAddr.atn_Network,pArapConn->NetAddr.atn_Node,pArapConn));

    ACQUIRE_SPIN_LOCK(&pArapConn->SpinLock, &OldIrql);

    pArapConn->Flags |= ARAP_CONNECTION_UP;

    RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);

    pSndRcvInfo->StatusCode = ARAPERR_NO_ERROR;

    return( STATUS_SUCCESS );
}


//***
//
// Function: ArapIoctlRecv
//              Try to get data for the specified connection.  If there is no
//              data available, irp is just "queued"
//
// Parameters:  pIrp - the irp to process
//
// Return:      result of the operation
//
//***$

NTSTATUS
ArapIoctlRecv(
    IN PIRP                 pIrp
)
{

    PARAPCONN               pArapConn;
    PARAP_SEND_RECV_INFO    pSndRcvInfo;
    KIRQL                   OldIrql;



    DBG_ARAP_CHECK_PAGED_CODE();

    pSndRcvInfo = (PARAP_SEND_RECV_INFO)pIrp->AssociatedIrp.SystemBuffer;

    pArapConn = (PARAPCONN)pSndRcvInfo->AtalkContext;

    if (pArapConn == NULL)
    {
		DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
            ("ArapIoctlRecv: null conn\n"));

        pSndRcvInfo->StatusCode = ARAPERR_NO_SUCH_CONNECTION;
        return(STATUS_SUCCESS);
    }

    ARAPTRACE(("Entered ArapIoctlRecv (%lx %lx)\n",pIrp,pArapConn));

    ACQUIRE_SPIN_LOCK(&pArapConn->SpinLock, &OldIrql);

    if (pArapConn->State >= MNP_LDISCONNECTING)
    {
		DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
            ("ArapIoctlRecv: rejecting recv ioctl recvd during disconnect %lx\n", pArapConn));

        pSndRcvInfo->StatusCode = ARAPERR_DISCONNECT_IN_PROGRESS;
        RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);
        return(STATUS_SUCCESS);
    }

    // we only allow one irp to be in progress at a time
    if (pArapConn->pRecvIoctlIrp != NULL)
    {
		DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR, ("ArapIoctlRecv: rejecting recv \
             (irp already in progress) %lx\n", pArapConn));

        pSndRcvInfo->StatusCode = ARAPERR_IRP_IN_PROGRESS;
        RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);
        return(STATUS_SUCCESS);
    }

    pArapConn->pRecvIoctlIrp = pIrp;

    RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);

    // see if we can satisfy this request
    ArapDataToDll( pArapConn );

    return( STATUS_PENDING );
}


//***
//
// Function: ArapExchangeParms
//              Get configuration parameters from the dll, and return some info
//
// Parameters:  pIrp - the irp to process
//
// Return:      result of the operation
//
//***$

NTSTATUS
ArapExchangeParms(
    IN PIRP         pIrp
)
{
    ZONESTAT        ZoneStat;
    KIRQL           OldIrql;
    PADDRMGMT       pAddrMgmt;
    PEXCHGPARMS     pExchgParms;


    DBG_ARAP_CHECK_PAGED_CODE();

    ARAPTRACE(("Entered ArapExchangeParms (%lx)\n",pIrp));

    pExchgParms = (PEXCHGPARMS)pIrp->AssociatedIrp.SystemBuffer;

    // we enter this routine only if AtalkDefaultPort is referenced

    ACQUIRE_SPIN_LOCK(&ArapSpinLock, &OldIrql);

    ArapGlobs.LowVersion       = pExchgParms->Parms.LowVersion;
    ArapGlobs.HighVersion      = pExchgParms->Parms.HighVersion;
    ArapGlobs.MnpInactiveTime  = pExchgParms->Parms.MnpInactiveTime;
    ArapGlobs.V42bisEnabled    = pExchgParms->Parms.V42bisEnabled;
    ArapGlobs.SmartBuffEnabled = pExchgParms->Parms.SmartBuffEnabled;
    ArapGlobs.NetworkAccess    = pExchgParms->Parms.NetworkAccess;
    ArapGlobs.DynamicMode      = pExchgParms->Parms.DynamicMode;
    ArapGlobs.NetRange.LowEnd  = pExchgParms->Parms.NetRange.LowEnd;
    ArapGlobs.NetRange.HighEnd = pExchgParms->Parms.NetRange.HighEnd;
    ArapGlobs.MaxLTFrames      = (BYTE)pExchgParms->Parms.MaxLTFrames;
    ArapGlobs.SniffMode        = pExchgParms->Parms.SniffMode;

    ArapGlobs.pAddrMgmt = NULL;

    // we only support dynamic mode
    ASSERT(ArapGlobs.DynamicMode);

#if ARAP_STATIC_MODE
    //
    // allocate and initialize the bitmap for node allocation
    //
    if (!(ArapGlobs.DynamicMode))
    {
        RELEASE_SPIN_LOCK(&ArapSpinLock, OldIrql);

        if (!ArapValidNetrange(ArapGlobs.NetRange))
        {
		    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                ("ArapExchangeParms: Netrange %lx - %lx is invalid\n",
                ArapGlobs.NetRange.LowEnd,ArapGlobs.NetRange.HighEnd));

            pExchgParms->StatusCode = ARAPERR_BAD_NETWORK_RANGE;

            return (STATUS_SUCCESS);
        }

        ACQUIRE_SPIN_LOCK(&ArapSpinLock, &OldIrql);

        if ( (pAddrMgmt = AtalkAllocZeroedMemory(sizeof(ADDRMGMT))) == NULL)
        {
		    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                ("ArapExchangeParms: alloc for pAddrMgmt failed\n"));

            RELEASE_SPIN_LOCK(&ArapSpinLock, OldIrql);
            pExchgParms->StatusCode = ARAPERR_OUT_OF_RESOURCES;

            return (STATUS_SUCCESS);
        }

        //
        // node numbers 0 and 255 are reserved, so mark them as occupied.
        //
        pAddrMgmt->NodeBitMap[0] |= 0x1;
        pAddrMgmt->NodeBitMap[31] |= 0x80;

        pAddrMgmt->Network = ArapGlobs.NetRange.LowEnd;

        ArapGlobs.pAddrMgmt = pAddrMgmt;
    }
#endif //ARAP_STATIC_MODE


    RELEASE_SPIN_LOCK(&ArapSpinLock, OldIrql);

    //
    // now, time to return some stack info to the dll.
    //

    // just an initial guess: dll will figure out the real number when an
    // actual connection comes in
    //
    pExchgParms->Parms.NumZones = 50;

    pExchgParms->Parms.ServerAddr.ata_Network =
                    AtalkDefaultPort->pd_Nodes->an_NodeAddr.atn_Network;

    pExchgParms->Parms.ServerAddr.ata_Node =
                    AtalkDefaultPort->pd_Nodes->an_NodeAddr.atn_Node;

    // copy the server zone in Pascal string format
    if (AtalkDesiredZone)
    {
        pExchgParms->Parms.ServerZone[0] = AtalkDesiredZone->zn_ZoneLen;

        RtlCopyMemory( &pExchgParms->Parms.ServerZone[1],
                       &AtalkDesiredZone->zn_Zone[0],
                       AtalkDesiredZone->zn_ZoneLen );
    }
    else if (AtalkDefaultPort->pd_DefaultZone)
    {
        pExchgParms->Parms.ServerZone[0] = AtalkDefaultPort->pd_DefaultZone->zn_ZoneLen;

        RtlCopyMemory( &pExchgParms->Parms.ServerZone[1],
                       &AtalkDefaultPort->pd_DefaultZone->zn_Zone[0],
                       AtalkDefaultPort->pd_DefaultZone->zn_ZoneLen );
    }
    else
    {
        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
            ("Arap: Server not in any zone?? Client won't see any zones!!\n"));

        pExchgParms->Parms.ServerZone[0] = 0;
    }

    ArapGlobs.OurNetwkNum =
            AtalkDefaultPort->pd_Nodes->an_NodeAddr.atn_Network;

    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
        ("Arap: ready to accept connections (Router net=%x node=%x)\n",
            AtalkDefaultPort->pd_Nodes->an_NodeAddr.atn_Network,
            AtalkDefaultPort->pd_Nodes->an_NodeAddr.atn_Node));

    pExchgParms->StatusCode = ARAPERR_NO_ERROR;

    // complete the irp successfully
    return (STATUS_SUCCESS);

}


//***
//
// Function: ArapConnect
//              Setup the MNP level connection with the client
//
// Parameters:  pIrp - the irp to process
//
// Return:      result of the operation
//
//***$

NTSTATUS
ArapConnect(
    IN PIRP                 pIrp,
    IN ULONG                IoControlCode
)
{
    KIRQL                   OldIrql;
    PBYTE                   pFrame;
    SHORT                   MnpLen;
    SHORT                   FrameLen;
    DWORD                   StatusCode=ARAPERR_NO_ERROR;
    PMNPSENDBUF             pMnpSendBuf=NULL;
    PARAP_SEND_RECV_INFO    pSndRcvInfo;
    PARAPCONN               pArapConn;
    PNDIS_PACKET            ndisPacket;
    NDIS_STATUS             ndisStatus;


    DBG_ARAP_CHECK_PAGED_CODE();

    ARAPTRACE(("Entered ArapConnect (%lx)\n",pIrp));

    pSndRcvInfo = (PARAP_SEND_RECV_INFO)pIrp->AssociatedIrp.SystemBuffer;

    pArapConn = FindArapConnByContx(pSndRcvInfo->pDllContext);

    if (pArapConn == NULL)
    {
		DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
            ("ArapConnect: couldn't find pArapConn!\n"));
        ASSERT(0);
        pSndRcvInfo->StatusCode = ARAPERR_NO_SUCH_CONNECTION;
        return(STATUS_SUCCESS);
    }

    ACQUIRE_SPIN_LOCK(&ArapSpinLock, &OldIrql);
    ArapConnections++;
    RELEASE_SPIN_LOCK(&ArapSpinLock, OldIrql);

#if ARAP_STATIC_MODE
    // This will add a route (one-time only) for the ARAP network range
    ArapAddArapRoute();
#endif //ARAP_STATIC_MODE


    // first, write stack's context for dll's future use
    pSndRcvInfo->AtalkContext = (PVOID)pArapConn;

    //
    // put a refcount for the connection (deref only when the connection gets
    // disconnected *and* the dll is told about it).
    // Also, initialize the v42bis stuff for this connection
    //
    ACQUIRE_SPIN_LOCK(&pArapConn->SpinLock, &OldIrql);

    if (pArapConn->pIoctlIrp != NULL)
    {
		DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR, ("ArapConnect: rejecting connect \
             (irp already in progress) %lx\n", pArapConn));

        pSndRcvInfo->StatusCode = ARAPERR_IRP_IN_PROGRESS;
        RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);
        return(STATUS_SUCCESS);
    }

    ASSERT(pArapConn->State == MNP_IDLE);

    if (IoControlCode == IOCTL_ARAP_MNP_CONN_RESPOND)
    {
        pArapConn->State = MNP_RESPONSE;
    }

    //
    // we're doing callback: do some fixing up
    //
    else
    {
        pArapConn->State = MNP_REQUEST;
        pArapConn->Flags |= ARAP_CALLBACK_MODE;
        pArapConn->MnpState.SendCredit = 8;
    }


    // Connect refcount: remove only after we tell dll that connection died
    pArapConn->RefCount++;

    // put MNPSend refcount
    pArapConn->RefCount++;

    pArapConn->pIoctlIrp = pIrp;

    RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);

    KeInitializeEvent(&pArapConn->NodeAcquireEvent, NotificationEvent, FALSE);


    StatusCode = ARAPERR_NO_ERROR;

    //
    // allocate buf to send out the connection response/request
    //
	if ((pMnpSendBuf = AtalkBPAllocBlock(BLKID_MNP_SMSENDBUF)) != NULL)
    {
        // get an ndis packet for this puppy
        StatusCode = ArapGetNdisPacket(pMnpSendBuf);
    }

	if ((pMnpSendBuf == NULL) || (StatusCode != ARAPERR_NO_ERROR))
	{
        if (pMnpSendBuf)
        {
            ArapNdisFreeBuf(pMnpSendBuf);
        }
        else
        {
		    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
			    ("ArapConnect: AtalkBPAllocBlock failed on %lx\n", pArapConn));
        }

        ACQUIRE_SPIN_LOCK(&pArapConn->SpinLock, &OldIrql);
        pArapConn->State = MNP_IDLE;
        pSndRcvInfo->StatusCode = ARAPERR_OUT_OF_RESOURCES;
        pSndRcvInfo->AtalkContext = ARAP_INVALID_CONTEXT;
        pArapConn->pIoctlIrp = NULL;

        RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);

        // didn't succeed: remove that connection refcount
        DerefArapConn(pArapConn);

        // and the MNPSend refcount
        DerefArapConn(pArapConn);

        // return success: we have already set our StatusCode to the right thing
        return( STATUS_SUCCESS );
	}

#if DBG
    pMnpSendBuf->Signature = MNPSMSENDBUF_SIGNATURE;
#endif

    // yes, we need this, in case we bail out
    InitializeListHead(&pMnpSendBuf->Linkage);

    pMnpSendBuf->SeqNum = 0;               // Indication code expects this to be 0
    pMnpSendBuf->RetryCount = 1;
    pMnpSendBuf->RefCount = 1;             // 1 MNP refcount
    pMnpSendBuf->pArapConn = pArapConn;
    pMnpSendBuf->ComplRoutine = ArapConnectComplete;
    pMnpSendBuf->Flags = 1;

    // when should we retransmit this pkt?
    pMnpSendBuf->RetryTime = pArapConn->SendRetryTime + AtalkGetCurrentTick();

	pFrame = &pMnpSendBuf->Buffer[0];

	AtalkNdisBuildARAPHdr(pFrame, pArapConn);

    pFrame += WAN_LINKHDR_LEN;

    FrameLen = WAN_LINKHDR_LEN;

    //
    // are we just responding to a connection request?
    //
    if (IoControlCode == IOCTL_ARAP_MNP_CONN_RESPOND)
    {
        //
        // pSndRcvInfo contains the client's connect request.  Parse it and
        // prepare a response as appropriate
        //

        ACQUIRE_SPIN_LOCK(&ArapSpinLock, &OldIrql);

        StatusCode = PrepareConnectionResponse( pArapConn,
                                                &pSndRcvInfo->Data[0],
                                                pSndRcvInfo->DataLen,
                                                pFrame,
                                                &MnpLen);

        RELEASE_SPIN_LOCK(&ArapSpinLock, OldIrql);

        if (StatusCode != ARAPERR_NO_ERROR)
        {
		    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
			    ("ArapConnect: (%lx) response prep failed %ld\n", pArapConn,StatusCode));

            ArapConnectComplete(pMnpSendBuf, StatusCode);

            return( STATUS_PENDING );
        }

        FrameLen += MnpLen;
    }

    //
    // no, actually we are initiating a connection (callback time)
    // copy the frame we used in earlier setup (that dll kindly saved for us)
    //
    else
    {
        RtlCopyMemory(pFrame, (PBYTE)&pSndRcvInfo->Data[0], pSndRcvInfo->DataLen);

        FrameLen += (USHORT)pSndRcvInfo->DataLen;

#if DBG
        pArapConn->MnpState.SynByte = pSndRcvInfo->Data[0];
        pArapConn->MnpState.DleByte = pSndRcvInfo->Data[1];
        pArapConn->MnpState.StxByte = pSndRcvInfo->Data[2];
        pArapConn->MnpState.EtxByte = MNP_ETX;
#endif

    }

	AtalkSetSizeOfBuffDescData(&pMnpSendBuf->sb_BuffDesc, FrameLen);

    pMnpSendBuf->RefCount++;             // 1 ndis count, since we'll send now
    pMnpSendBuf->DataSize = FrameLen;

	NdisAdjustBufferLength(pMnpSendBuf->sb_BuffHdr.bh_NdisBuffer,
                           pMnpSendBuf->DataSize);

    // put this connection response on the retransmission queue
    ACQUIRE_SPIN_LOCK(&pArapConn->SpinLock, &OldIrql);

    InsertTailList(&pArapConn->RetransmitQ, &pMnpSendBuf->Linkage);

    pArapConn->SendsPending += pMnpSendBuf->DataSize;

    pArapConn->MnpState.UnAckedSends++;

    RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);

    ndisPacket = pMnpSendBuf->sb_BuffHdr.bh_NdisPkt;

    NdisSend(&ndisStatus, RasPortDesc->pd_NdisBindingHandle, ndisPacket);

    // if there was a problem sending, call the completion routine here
    // retransmit logic will send it again
    //
    if (ndisStatus != NDIS_STATUS_PENDING)
    {
        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                ("MnpSendAck: NdisSend failed %lx\n",ndisStatus));

        ArapNdisSendComplete(ARAPERR_SEND_FAILED, (PBUFFER_DESC)pMnpSendBuf, NULL);
    }

    //
    // done.  we'll complete the irp when the client responds (acks or response)
    //
    return( STATUS_PENDING );
}


//***
//
// Function: ArapConnectComplete
//              Completion routine for the ArapConnect routine.  This routine
//              is called by the ArapRcvComplete routine when we get an ack
//              for our Connection response (LR) frame
//
// Parameters:  pMnpSendBuf - the send buff that contained the LR response
//              StatusCode - how did it go?
//
// Return:      none
//
//***$

VOID
ArapConnectComplete(
    IN PMNPSENDBUF  pMnpSendBuf,
    IN DWORD        StatusCode
)
{
    KIRQL                   OldIrql;
    PIRP                    pIrp;
    PARAPCONN               pArapConn;
    PARAP_SEND_RECV_INFO    pSndRcvInfo;
	NTSTATUS				ReturnStatus=STATUS_SUCCESS;



    DBG_ARAP_CHECK_PAGED_CODE();

    pArapConn = pMnpSendBuf->pArapConn;

    if (StatusCode != ARAPERR_NO_ERROR)
    {
        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
            ("ArapConnectComplete: (%x): conn setup failed (%d)!\n",
                pArapConn,StatusCode));
        //
        // BUGBUG: change ArapCleanup to accept StatusCode as a parm (currently,
        // the real reason behind disconnect is lost, so dll doesn't get it)
        //
        ArapCleanup(pArapConn);

        DerefMnpSendBuf(pMnpSendBuf, FALSE);

        return;
    }

    ACQUIRE_SPIN_LOCK(&pArapConn->SpinLock, &OldIrql);

    pIrp = pArapConn->pIoctlIrp;

    pArapConn->pIoctlIrp = NULL;

    pArapConn->SendsPending -= pMnpSendBuf->DataSize;

    RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);

    ARAPTRACE(("Entered ArapConnectComplete (%lx %lx)\n",pIrp,pArapConn));

    // if there is an irp (under normal conditions, should be), complete it
    if (pIrp)
    {
        pSndRcvInfo = (PARAP_SEND_RECV_INFO)pIrp->AssociatedIrp.SystemBuffer;

        pSndRcvInfo->StatusCode = StatusCode;

        if (StatusCode != ARAPERR_NO_ERROR)
        {
            pSndRcvInfo->StatusCode = ARAPERR_DISCONNECT_IN_PROGRESS;
        }

        //
        // copy the frame we used to establish the connection.  In case of
        // callback, dll will pass this back to initiate the connection
        //
        if (pSndRcvInfo->IoctlCode == IOCTL_ARAP_MNP_CONN_RESPOND)
        {
            pSndRcvInfo->DataLen = (DWORD)pMnpSendBuf->DataSize;

            RtlCopyMemory((PBYTE)&pSndRcvInfo->Data[0],
                          (PBYTE)&pMnpSendBuf->Buffer[0],
                          (DWORD)pMnpSendBuf->DataSize);
        }

        ARAP_COMPLETE_IRP(pIrp,
                          pSndRcvInfo->DataLen + sizeof(ARAP_SEND_RECV_INFO),
                          STATUS_SUCCESS, &ReturnStatus);
    }
    else
    {
        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
            ("ArapConnectComplete: (%x): no irp available!\n",pArapConn));
    }

    DerefMnpSendBuf(pMnpSendBuf, FALSE);

}



//***
//
// Function: ArapDisconnect
//              Disconnect the connection
//
// Parameters:  pIrp - the irp to process
//
// Return:      result of the operation
//
//***$

NTSTATUS
ArapDisconnect(
    IN PIRP                 pIrp
)
{
    PARAPCONN               pArapConn;
    PARAP_SEND_RECV_INFO    pSndRcvInfo;


    DBG_ARAP_CHECK_PAGED_CODE();

    pSndRcvInfo = (PARAP_SEND_RECV_INFO)pIrp->AssociatedIrp.SystemBuffer;

    pArapConn = (PARAPCONN)pSndRcvInfo->AtalkContext;

    if ((pArapConn == NULL) || (pArapConn == ARAP_INVALID_CONTEXT))
    {
		DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
            ("ArapDisconnect: null conn\n"));

        pSndRcvInfo->StatusCode = ARAPERR_NO_SUCH_CONNECTION;
        return(STATUS_SUCCESS);
    }

    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
        ("ArapDisconnect: rcvd DISCONNECT on %lx (irp=%lx)\n",pArapConn,pIrp));

    // UserCode = 0xFF
    pSndRcvInfo->StatusCode = ArapSendLDPacket(pArapConn, 0xFF);

    ArapCleanup(pArapConn);

    //
    // done.  let this irp complete: we'll notify the dll of
    // 'disconnect-complete' (via select irp) when our cleanup completes
    //
    return(STATUS_SUCCESS);
}


//***
//
// Function: ArapGetAddr
//              Get a network address for the remote client
//              (if doing dynamic addressing, go to the net; otherwise, get one
//              from the table we maintain)
//
// Parameters:  pIrp - the irp to process
//
// Return:      result of the operation
//
//***$

NTSTATUS
ArapGetAddr(
    IN PIRP                 pIrp
)
{
    PARAPCONN               pArapConn;
    PARAP_SEND_RECV_INFO    pSndRcvInfo;
    DWORD                   StatusCode = ARAPERR_NO_NETWORK_ADDR;


    DBG_ARAP_CHECK_PAGED_CODE();

    pSndRcvInfo = (PARAP_SEND_RECV_INFO)pIrp->AssociatedIrp.SystemBuffer;

    pArapConn = (PARAPCONN)pSndRcvInfo->AtalkContext;

    ARAPTRACE(("Entered ArapGetAddr (%lx %lx)\n",pIrp,pArapConn));

    if (pArapConn == NULL)
    {
		DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
            ("ArapGetAddr: null conn\n"));

        pSndRcvInfo->StatusCode = ARAPERR_NO_SUCH_CONNECTION;
        return(STATUS_SUCCESS);
    }

    if (ArapGlobs.DynamicMode)
    {
        StatusCode = ArapGetDynamicAddr(pArapConn);
    }

#if ARAP_STATIC_MODE
    else
    {
        StatusCode = ArapGetStaticAddr(pArapConn);
    }
#endif //ARAP_STATIC_MODE

    pSndRcvInfo->StatusCode = StatusCode;

    if (StatusCode == ARAPERR_NO_ERROR)
    {
        pSndRcvInfo->ClientAddr.ata_Network = pArapConn->NetAddr.atn_Network;
        pSndRcvInfo->ClientAddr.ata_Node = pArapConn->NetAddr.atn_Node;
    }
    else
    {
	    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
		    ("ArapGetAddr: returning %d\n", StatusCode));
    }

    return( STATUS_SUCCESS );

}


// we don't really support this: why have the code!
#if 0

//***
//
// Function: ArapGetStats
//              Return statistics (bytes in, bytes out, compressed etc.) about
//              the specified connection
//
// Parameters:  pIrp - the irp to process
//
// Return:      result of the operation
//
//***$

NTSTATUS
ArapGetStats(
    IN PIRP                 pIrp
)
{

    PARAPCONN               pArapConn;
    PARAP_SEND_RECV_INFO    pSndRcvInfo;
    KIRQL                   OldIrql;
    PSTAT_INFO              pStatInfo;


    DBG_ARAP_CHECK_PAGED_CODE();

    pSndRcvInfo = (PARAP_SEND_RECV_INFO)pIrp->AssociatedIrp.SystemBuffer;

    pArapConn = (PARAPCONN)pSndRcvInfo->AtalkContext;

    if (pArapConn == NULL)
    {
		DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
            ("ArapGetStats: null conn\n"));

        pSndRcvInfo->StatusCode = ARAPERR_NO_SUCH_CONNECTION;
        return(STATUS_SUCCESS);
    }

    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
        ("ArapGetStats: returning stats for (%lx)\n",pArapConn));

    pStatInfo = (PSTAT_INFO)&pSndRcvInfo->Data[0];

    ACQUIRE_SPIN_LOCK(&pArapConn->SpinLock, &OldIrql);

    *pStatInfo = pArapConn->StatInfo;

    RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);

    pSndRcvInfo->StatusCode = ARAPERR_NO_ERROR;

    return( STATUS_SUCCESS );
}

#endif  // #if 0 around ArapGetStats


//***
//
// Function: ArapIoctlSend
//              Send the buffer given by the dll to the remote client.
//              This routine calls the routine to prepare the send (v42bis
//              compression and MNP bookkeeping) and then sends it out
//
// Parameters:  pIrp - the irp to process
//
// Return:      result of the operation
//
//***$

NTSTATUS
ArapIoctlSend(
    IN PIRP                    pIrp
)
{
    KIRQL                   OldIrql;
    BUFFER_DESC             OrgBuffDesc;
    PARAPCONN               pArapConn;
    PARAP_SEND_RECV_INFO    pSndRcvInfo;
    DWORD                   StatusCode=ARAPERR_NO_ERROR;


    DBG_ARAP_CHECK_PAGED_CODE();

    pSndRcvInfo = (PARAP_SEND_RECV_INFO)pIrp->AssociatedIrp.SystemBuffer;

    pArapConn = (PARAPCONN)pSndRcvInfo->AtalkContext;

    if (pArapConn == NULL)
    {
		DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
            ("ArapIoctlSend: null conn\n"));

        pSndRcvInfo->StatusCode = ARAPERR_NO_SUCH_CONNECTION;
        return(STATUS_SUCCESS);
    }

    ARAPTRACE(("Entered ArapIoctlSend (%lx %lx)\n",pIrp,pArapConn));

    // save the irp so we can complete it in the completion routine
    ACQUIRE_SPIN_LOCK(&pArapConn->SpinLock, &OldIrql);

    // we only allow one irp to be in progress at a time
    if (pArapConn->pIoctlIrp != NULL)
    {
		DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR, ("ArapIoctlSend: rejecting send \
             (irp already in progress) %lx\n", pArapConn));

        pSndRcvInfo->StatusCode = ARAPERR_IRP_IN_PROGRESS;
        RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);
        return(STATUS_SUCCESS);
    }

    pArapConn->pIoctlIrp = pIrp;

    RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);

    ASSERT(pSndRcvInfo->DataLen <= 618);

    DBGDUMPBYTES("Dll send:", &pSndRcvInfo->Data[0],pSndRcvInfo->DataLen,1);

    //
    // get the send ready (compression, MNP bookkeeping etc.)
    //
	OrgBuffDesc.bd_Next = NULL;
	OrgBuffDesc.bd_Length = (SHORT)pSndRcvInfo->DataLen;
	OrgBuffDesc.bd_CharBuffer = &pSndRcvInfo->Data[0];
	OrgBuffDesc.bd_Flags = BD_CHAR_BUFFER;

    StatusCode = ArapSendPrepare( pArapConn,
                                  &OrgBuffDesc,
                                  ARAP_SEND_PRIORITY_HIGH );

    if (StatusCode == ARAPERR_NO_ERROR)
    {
        //
        // now, send that send over.  Note that we don't care about the return
        // code here: if this particular send fails, we still tell the dll that
        // the send succeeded because our retransmission logic will take care
        // of ensuring that the send gets there.
        //
        ArapNdisSend( pArapConn, &pArapConn->HighPriSendQ );
    }
    else
    {
		DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
            ("ArapIoctlSend (%lx): ArapSendPrepare failed (%ld)\n",
                pArapConn,StatusCode));
    }

    ArapIoctlSendComplete(StatusCode, pArapConn);

    return( STATUS_PENDING );
}


//***
//
// Function: ArapProcessSelect
//              Process the select irp issued by the dll
//              This routine saves the select irp so that any connection that
//              needs it can take it.  Also, it sees if any of the connections
//              is waiting for an irp to indicate a disconnect-complete or
//              data to the dll.  If so, that is completed here.
//
// Parameters:  pIrp - the select irp to process
//
// Return:      result of the operation
//
//***$

NTSTATUS
ArapProcessSelect(
    IN  PIRP  pIrp
)
{
    KIRQL                   OldIrql;
    KIRQL                   OldIrql2;
    PARAPCONN               pDiscArapConn=NULL;
    PARAPCONN               pRcvArapConn=NULL;
    PARAP_SEND_RECV_INFO    pSndRcvInfo;
    PLIST_ENTRY             pList;
    DWORD                   dwBytesToDll;
    DWORD                   StatusCode;
	NTSTATUS				ReturnStatus;



    ARAPTRACE(("Entered ArapProcessSelect (%lx)\n",pIrp));

    pSndRcvInfo = (PARAP_SEND_RECV_INFO)pIrp->AssociatedIrp.SystemBuffer;


    pDiscArapConn = NULL;
    pRcvArapConn = NULL;

    //
    // it's possible that between the time the last select irp completed and
    // this select came down, some activity that needs a select irp occured
    // (e.g. a disconnect).  See if we have hit such a condition
    //

    ArapDelayedNotify(&pDiscArapConn, &pRcvArapConn);

    //
    // if we found an arapconn that was waiting for a select irp to notify the
    // dll of disconnect, do the good deed!
    //
    if (pDiscArapConn)
    {
		DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
		    ("ArapProcessSelect: completing delayed disconnect on %lx!\n", pDiscArapConn));

        dwBytesToDll = 0;
#if DBG
        //
        // if we have some sniff info that we couldn't deliver earlier through
        // the sniff irp, then give them through this irp: it's going back
        // "empty" anyway!
        //
        if (pDiscArapConn->pDbgTraceBuffer && pDiscArapConn->SniffedBytes > 0)
        {
            dwBytesToDll = ArapFillIrpWithSniffInfo(pDiscArapConn,pIrp);
        }
#endif

        dwBytesToDll += sizeof(ARAP_SEND_RECV_INFO);

        //
        // no need for spinlock here
        //
        if (pDiscArapConn->Flags & ARAP_REMOTE_DISCONN)
        {
            StatusCode = ARAPERR_RDISCONNECT_COMPLETE;
        }
        else
        {
            StatusCode = ARAPERR_LDISCONNECT_COMPLETE;
        }

        pSndRcvInfo = (PARAP_SEND_RECV_INFO)pIrp->AssociatedIrp.SystemBuffer;
        pSndRcvInfo->pDllContext = pDiscArapConn->pDllContext;

        pSndRcvInfo->StatusCode = StatusCode;

        pSndRcvInfo->DataLen = dwBytesToDll;

        // we told (rather, will very shortly tell) dll: remove this link
        pDiscArapConn->pDllContext = NULL;

        // now that we told dll, remove 1 refcount
        DerefArapConn( pDiscArapConn );

        return(STATUS_SUCCESS);
    }



	IoAcquireCancelSpinLock(&OldIrql);

    if (pIrp->Cancel)
	{
		DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
		    ("ArapProcessSelect: select irp %lx already cancelled!\n", pIrp));

	    IoReleaseCancelSpinLock(OldIrql);
        ARAP_COMPLETE_IRP(pIrp, 0, STATUS_CANCELLED, &ReturnStatus);
        return(ReturnStatus);
    }

    ACQUIRE_SPIN_LOCK(&ArapSpinLock, &OldIrql2);

    if (ArapSelectIrp != NULL)
    {
		DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
		    ("ArapProcessSelect: select irp %lx already in progress!\n", ArapSelectIrp));
        ASSERT(0);

        pSndRcvInfo->StatusCode = ARAPERR_IRP_IN_PROGRESS;
        RELEASE_SPIN_LOCK(&ArapSpinLock, OldIrql2);
        IoReleaseCancelSpinLock(OldIrql);
        return( STATUS_SUCCESS );
    }

    //
    // does arap engine need to be told about some change?
    //
    if ( (ArapStackState == ARAP_STATE_ACTIVE_WAITING) ||
         (ArapStackState == ARAP_STATE_INACTIVE_WAITING) )
    {
        if (ArapStackState == ARAP_STATE_ACTIVE_WAITING)
        {
		    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
		        ("ArapProcessSelect: delayed notify: stack is now active!\n"));

            ArapStackState = ARAP_STATE_ACTIVE;
            pSndRcvInfo->StatusCode = ARAPERR_STACK_IS_ACTIVE;
        }
        else if (ArapStackState == ARAP_STATE_INACTIVE_WAITING)
        {
		    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
		        ("ArapProcessSelect: delayed notify: stack is now inactive!\n"));

            ArapStackState = ARAP_STATE_INACTIVE;
            pSndRcvInfo->StatusCode = ARAPERR_STACK_IS_NOT_ACTIVE;
        }

        RELEASE_SPIN_LOCK(&ArapSpinLock, OldIrql2);
	    IoReleaseCancelSpinLock(OldIrql);
        return( STATUS_SUCCESS );
    }

    //
    // ok, most common case: we just need to stash this select irp!
    //
    ArapSelectIrp = pIrp;

    RELEASE_SPIN_LOCK(&ArapSpinLock, OldIrql2);

	IoSetCancelRoutine(pIrp, (PDRIVER_CANCEL)AtalkTdiCancel);

	IoReleaseCancelSpinLock(OldIrql);


    //
    // if there was an arapconn waiting for a select irp, pass on the data!
    //
    if (pRcvArapConn)
    {
		DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_INFO,
		    ("ArapProcessSelect: getting delayed data on %lx at %ld\n",
            pRcvArapConn,AtalkGetCurrentTick()));

        ARAP_DBG_TRACE(pRcvArapConn,11105,0,0,0,0);

        ArapDataToDll( pRcvArapConn );
    }

    return(STATUS_PENDING);
}



//***
//
// Function: ArapDelayedNotify
//              This routine checks to see if any of the arap connections was
//              waiting for a select irp to come down to notify the dll that
//              either the connection went away, or if there was any data waiting on a
//              connection.
//
// Parameters:  ppDiscArapConn - if a "disconnected" connection exists, it's returned
//                               in this pointer.  If many exist, the first one lucks out.
//                               If none exists, null is returned here
//              ppRecvArapConn - same as above except that the connection returned is
//                               the one where some data is waiting
//
// Return:      none
//
//***$
VOID
ArapDelayedNotify(
    OUT PARAPCONN   *ppDiscArapConn,
    OUT PARAPCONN   *ppRecvArapConn
)
{

    KIRQL                   OldIrql;
    PARAPCONN               pArapConn=NULL;
    PLIST_ENTRY             pList;
    PARAPCONN               pDiscArapConn=NULL;
    PARAPCONN               pRecvArapConn=NULL;


    *ppDiscArapConn = NULL;
    *ppRecvArapConn = NULL;

    if (!RasPortDesc)
    {
		DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
            ("ArapDelayedNotify: RasPortDesc is NULL!\n"));
        ASSERT(0);

        return;
    }

    ACQUIRE_SPIN_LOCK(&RasPortDesc->pd_Lock, &OldIrql);

    pList = RasPortDesc->pd_ArapConnHead.Flink;

    while (pList != &RasPortDesc->pd_ArapConnHead)
    {
        pArapConn = CONTAINING_RECORD(pList, ARAPCONN, Linkage);
        pList = pArapConn->Linkage.Flink;

        ACQUIRE_SPIN_LOCK_DPC(&pArapConn->SpinLock);

        //
        // if a connection has been disconnected and is waiting for a select
        // irp to show up, find out who that is and let the caller know
        //
        if ((pArapConn->State == MNP_DISCONNECTED) &&
            (pArapConn->Flags & DISCONNECT_NO_IRP))
        {
            pArapConn->Flags &= ~DISCONNECT_NO_IRP;
            pDiscArapConn = pArapConn;

            RELEASE_SPIN_LOCK_DPC(&pArapConn->SpinLock);
            break;
        }

        //
        // if a connection has some data come in on it while select irp wasn't
        // down yet, note down this connection
        //
        if ((pArapConn->State == MNP_UP) &&
            (pArapConn->Flags & ARAP_CONNECTION_UP) &&
            (!IsListEmpty(&pArapConn->ArapDataQ)))
        {
            pRecvArapConn = pArapConn;
        }

        RELEASE_SPIN_LOCK_DPC(&pArapConn->SpinLock);
    }

    RELEASE_SPIN_LOCK(&RasPortDesc->pd_Lock,OldIrql);

    if (pDiscArapConn)
    {
        *ppDiscArapConn = pDiscArapConn;
    }
    else if (pRecvArapConn)
    {
        *ppRecvArapConn = pRecvArapConn;
    }

}


//***
//
// Function: ArapSendPrepare
//              This routine takes an incoming buffer descriptor, compresses
//              each of the buffers in it and passes the compressed data on to
//              another routine which splits (or stuffs) the compressed bytes
//              into MNP-level packets.
//
// Parameters:  pArapConn    - the connection in question
//              pOrgBuffDesc - the buffer descriptor containing data buffer(s)
//              Priority     - how important is the data (highest priority = 1)
//                               1 - directed DDP dgrams (all except NBP)
//                               2 - directed DDP dgrams (NBP)
//                               3 - all DDP-level broadcast (NBP only)
//
// Return:      ARAPERR_NO_ERROR if things go well, otherwise errorcode
//
//***$

DWORD
ArapSendPrepare(
    IN  PARAPCONN       pArapConn,
    IN  PBUFFER_DESC    pOrgBuffDesc,
    IN  DWORD           Priority
)
{

    KIRQL                   OldIrql;
    DWORD                   StatusCode=ARAPERR_NO_ERROR;
    SHORT                   EthLen, MnpLen;
    PBYTE                   pCurrBuff;
    DWORD                   CurrBuffLen;
    DWORD                   UncompressedDataLen;
    PBYTE                   pCompressedData;
    PBYTE                   pCompressedDataBuffer;
    DWORD                   CompressedDataLen;
    DWORD                   CDataLen;
    PBUFFER_DESC            pBuffDesc;
    DWORD                   CompBufDataSize;



    DBG_ARAP_CHECK_PAGED_CODE();

// BUGBUG: this line put in for now: remove it and make sure priority queue stuff works
Priority = ARAP_SEND_PRIORITY_HIGH;


    ARAPTRACE(("Entered ArapSendPrepare (%lx %lx)\n",pArapConn,pOrgBuffDesc));

    //
    // it's essential to hold this lock until the entire send is compressed and
    // put on the queue (Otherwise, we risk mixing up different sends!)
    //
    ACQUIRE_SPIN_LOCK(&pArapConn->SpinLock, &OldIrql);

    // are we disconnecting (or not up yet)?  if so, don't accept this send
    if (pArapConn->State != MNP_UP)
    {
	    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
            ("ArapSendPrepare: (%lx) state=%d, rejecting send\n",
                pArapConn,pArapConn->State));

        RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);
        return( ARAPERR_DISCONNECT_IN_PROGRESS );
    }

    // do we have too many sends queued up? if so, just drop this send
    if (pArapConn->SendsPending > ARAP_SENDQ_UPPER_LIMIT)
    {
        // make sure it's not gone negative..
        ASSERT(pArapConn->SendsPending < 0x100000);

        RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);
        return( ARAPERR_OUT_OF_RESOURCES );
    }

    //
    // allocate memory to store the compressed data
    //

    pCompressedDataBuffer = AtalkBPAllocBlock(BLKID_ARAP_SNDPKT);

    if (pCompressedDataBuffer == NULL)
    {
	    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
            ("ArapSendPrepare: alloc for compressing data failed (%lx)\n", pArapConn));

        RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);
        return( ARAPERR_OUT_OF_RESOURCES );
    }


    pBuffDesc = pOrgBuffDesc;                  // first buffer
    CompressedDataLen = 0;                     // length of compressed data
    CompBufDataSize = ARAP_SENDBUF_SIZE;       // size of buffer in which to compress
    pCompressedData = pCompressedDataBuffer;   // ptr to buffer in which to compress
    UncompressedDataLen = 0;                   // size of uncompressed data

#if DBG
    //
    // put in a guard signature to catch buffer overrun
    //
    *((DWORD *)&(pCompressedDataBuffer[ARAP_SENDBUF_SIZE-4])) = 0xdeadbeef;
#endif


    //
    // first, walk through the buffer descriptor chain and compress all the
    // buffers.
    //
    while (pBuffDesc)
    {
        //
        // is this a buffer?
        //
        if (pBuffDesc->bd_Flags & BD_CHAR_BUFFER)
        {
            pCurrBuff = pBuffDesc->bd_CharBuffer;
            CurrBuffLen = pBuffDesc->bd_Length;
        }

        //
        // nope, it's an mdl!
        //
        else
        {
            pCurrBuff = MmGetSystemAddressForMdlSafe(
                            pBuffDesc->bd_OpaqueBuffer,
                            NormalPagePriority);

            if (pCurrBuff == NULL)
            {
                ASSERT(0);
                RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);
                AtalkBPFreeBlock(pCompressedDataBuffer);
                return( ARAPERR_OUT_OF_RESOURCES );
            }

            CurrBuffLen = MmGetMdlByteCount(pBuffDesc->bd_OpaqueBuffer);
        }

        DBGDUMPBYTES("ArapSendPrepare (current buffer): ",pCurrBuff,CurrBuffLen,2);

        UncompressedDataLen += CurrBuffLen;

        ASSERT(UncompressedDataLen <= ARAP_LGPKT_SIZE);

        // exclude the 2 srp length bytes
        if (UncompressedDataLen > ARAP_MAXPKT_SIZE_OUTGOING+2)
        {
	        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                ("ArapSendPrepare (%lx): send pkt exceeds limit\n",pArapConn));

            ASSERT(0);
        }

        //
        // compress the packet (if v42bis is on, that is)
        //
        if (pArapConn->Flags & MNP_V42BIS_NEGOTIATED)
        {
            StatusCode = v42bisCompress(pArapConn,
                                        pCurrBuff,
                                        CurrBuffLen,
                                        pCompressedData,
                                        CompBufDataSize,
                                        &CDataLen);

        }

        //
        // hmmm, no v42bis!  just copy it as is and skip compression!
        //
        else
        {
            ASSERT(CompBufDataSize >= CurrBuffLen);

            RtlCopyMemory(pCompressedData,
                          pCurrBuff,
                          CurrBuffLen);

            CDataLen = CurrBuffLen;

            StatusCode = ARAPERR_NO_ERROR;
        }


#if DBG
    // ... and, check our guard signature
    ASSERT (*((DWORD *)&(pCompressedDataBuffer[ARAP_SENDBUF_SIZE-4])) == 0xdeadbeef);
#endif

        if (StatusCode != ARAPERR_NO_ERROR)
        {
	        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR, ("ArapSendPrepare (%lx):\
                 v42bisCompress returned %ld\n", pArapConn,StatusCode));

            ASSERT(0);

            RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);

            AtalkBPFreeBlock(pCompressedDataBuffer);
            return(StatusCode);
        }

        pCompressedData += CDataLen;
        CompressedDataLen += CDataLen;
        CompBufDataSize -= CDataLen;

        pBuffDesc = pBuffDesc->bd_Next;
    }


    // we are about to send so many uncompressed bytes: update stats
    pArapConn->StatInfo.BytesTransmittedUncompressed += UncompressedDataLen;

    // this is how many bytes will go out on the wire: update stats
    pArapConn->StatInfo.BytesTransmittedCompressed += CompressedDataLen;

    //
    // this is how many bytes will go out on the wire: update stats
    // Note that we will be adding the start/stop etc. bytes to this count somewhere else
    //
    pArapConn->StatInfo.BytesSent += CompressedDataLen;

#if DBG
    ArapStatistics.SendPreCompMax =
            (UncompressedDataLen > ArapStatistics.SendPreCompMax)?
            UncompressedDataLen : ArapStatistics.SendPreCompMax;

    ArapStatistics.SendPostCompMax =
            (CompressedDataLen > ArapStatistics.SendPostCompMax)?
            CompressedDataLen : ArapStatistics.SendPostCompMax;

    ArapStatistics.SendPreCompMin =
            (UncompressedDataLen < ArapStatistics.SendPreCompMin)?
            UncompressedDataLen : ArapStatistics.SendPreCompMin;

    ArapStatistics.SendPostCompMin =
            (CompressedDataLen < ArapStatistics.SendPostCompMin)?
            CompressedDataLen : ArapStatistics.SendPostCompMin;
#endif


    ARAP_DBG_TRACE(pArapConn,11205,pOrgBuffDesc,Priority,0,0);

    // now go put the send on the queue (And yes: hold that lock)
    StatusCode = ArapQueueSendBytes(pArapConn,
                                    pCompressedDataBuffer,
                                    CompressedDataLen,
                                    Priority);

    RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);

    AtalkBPFreeBlock(pCompressedDataBuffer);

    return(StatusCode);
}



//***
//
// Function: ArapMnpSendComplete
//              Free up the buffer used for the MNP send.  If the send failed
//              then kill the connection (remember, it's not just one send
//              failing but a failure after all the retransmission jing-bang)
//
// Parameters:  pMnpSendBuf - the send buff that contained the LR response
//              StatusCode  - how did it go?
//
// Return:      none
//
//***$

VOID ArapMnpSendComplete(
    IN PMNPSENDBUF   pMnpSendBuf,
    IN DWORD         StatusCode
)
{
    PARAPCONN           pArapConn;
    DWORD               State;
    KIRQL               OldIrql;


    DBG_ARAP_CHECK_PAGED_CODE();

    pArapConn = pMnpSendBuf->pArapConn;

    ARAPTRACE(("Entered ArapMnpSendComplete (%lx %lx %lx)\n",
        pMnpSendBuf,StatusCode,pArapConn));

    // the send buffer is getting freed up: update the counter
    ACQUIRE_SPIN_LOCK(&pArapConn->SpinLock, &OldIrql);

    State = pArapConn->State;

    pArapConn->SendsPending -= pMnpSendBuf->DataSize;

    RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);

    if ((StatusCode != ARAPERR_NO_ERROR) && (State < MNP_LDISCONNECTING))
    {
        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
            ("ArapMnpSendComplete (%lx %lx): bad link? Tearing down connection\n",
                StatusCode,pArapConn));

        // link must have gone down: kill the connection!
        ArapCleanup(pArapConn);
    }

    // mark that compl. routine has run
#if DBG
    pMnpSendBuf->Signature -= 0x100;
#endif

    // the send has been acked: take away the MNP refcount on the send
    DerefMnpSendBuf(pMnpSendBuf, FALSE);
}



//***
//
// Function: ArapIoctlSendComplete
//              This routine is called right after the send is done in
//              ArapIoctlSend, to let the dll know what happened to the send.
//
// Parameters:  Status    - did the send actually succeed
//              pArapConn - the connection in quesion
//
// Return:      none
//
//***$

VOID
ArapIoctlSendComplete(
	DWORD                   StatusCode,
    PARAPCONN               pArapConn
)
{

    PIRP                    pIrp;
    KIRQL                   OldIrql;
    PARAP_SEND_RECV_INFO    pSndRcvInfo;
	NTSTATUS				ReturnStatus=STATUS_SUCCESS;


    DBG_ARAP_CHECK_PAGED_CODE();

    ACQUIRE_SPIN_LOCK(&pArapConn->SpinLock, &OldIrql);

    pIrp = pArapConn->pIoctlIrp;
    pArapConn->pIoctlIrp = NULL;

    RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);

    ARAPTRACE(("Entered ArapIoctlSendComplete (%lx %lx)\n",pArapConn,pIrp));

    //
    // if there is a user-level irp pending, complete it here
    //
    if (pIrp)
    {
        pSndRcvInfo = (PARAP_SEND_RECV_INFO)pIrp->AssociatedIrp.SystemBuffer;

        pSndRcvInfo->StatusCode = StatusCode;

        // complete the irp (irp always completes successfully!)
        ARAP_COMPLETE_IRP(pIrp, sizeof(ARAP_SEND_RECV_INFO), STATUS_SUCCESS, &ReturnStatus);
    }

}


//***
//
// Function: ArapDataToDll
//              This routine tries to complete a receive posted on a connection.
//              When data arrives, if the Arap connection is established then
//              this routine tries to complete a receive via the "select" irp.
//              If the Arap connection is not yet established, then a receive
//              is completed via a "direct" irp.
//
// Parameters:  pArapConn - connection element in question
//
// Return:      Number of bytes transferred to the dll
//
//***$

DWORD
ArapDataToDll(
	IN	PARAPCONN    pArapConn
)
{

    KIRQL                   OldIrql;
    PLIST_ENTRY             pRcvList;
    PARAPBUF                pArapBuf;
    PARAP_SEND_RECV_INFO    pSndRcvInfo=NULL;
    PIRP                    pIrp;
    USHORT                  SrpModLen;
    DWORD                   dwBytesToDll;
    DWORD                   StatusCode;
	NTSTATUS				ReturnStatus=STATUS_SUCCESS;


    DBG_ARAP_CHECK_PAGED_CODE();

    ARAPTRACE(("Entered ArapDataToDll (%lx)\n",pArapConn));

    ACQUIRE_SPIN_LOCK(&pArapConn->SpinLock, &OldIrql);

    if (IsListEmpty(&pArapConn->ArapDataQ))
    {
        RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);
        return( 0 );
    }

    pRcvList = pArapConn->ArapDataQ.Flink;

    pArapBuf = CONTAINING_RECORD(pRcvList, ARAPBUF, Linkage);

    //
    // if the ARAP connection is established, we can hand the data only
    // to a select irp (dll won't post direct rcv's anymore)
    //
    if ( pArapConn->Flags & ARAP_CONNECTION_UP )
    {
        ArapGetSelectIrp(&pIrp);
        StatusCode = ARAPERR_DATA;
    }

    //
    // if the ARAP connection is not established yet, we must guarantee that
    // we hand the data only to a direct rcv irp for this connection
    //
    else
    {
        pIrp = pArapConn->pRecvIoctlIrp;
        pArapConn->pRecvIoctlIrp = NULL;
        StatusCode = ARAPERR_NO_ERROR;
    }

    // no irp?  just have to wait then
    if (!pIrp)
    {
		DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_INFO,
		    ("ArapDataToDll: no select irp, data waiting %lx at %ld\n", pArapConn,AtalkGetCurrentTick()));

        ARAP_DBG_TRACE(pArapConn,11505,0,0,0,0);

        RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);
        return( 0 );
    }

    //
    // now that we have irp, fill in the info, after unlinking the recv buf
    //
    RemoveEntryList(&pArapBuf->Linkage);

    ASSERT(pArapConn->RecvsPending >= pArapBuf->DataSize);
    pArapConn->RecvsPending -= pArapBuf->DataSize;

    ARAP_ADJUST_RECVCREDIT(pArapConn);

    RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);

    pSndRcvInfo = (PARAP_SEND_RECV_INFO)pIrp->AssociatedIrp.SystemBuffer;

    ASSERT(pSndRcvInfo->DataLen >= pArapBuf->DataSize);

    SrpModLen = pArapBuf->DataSiz