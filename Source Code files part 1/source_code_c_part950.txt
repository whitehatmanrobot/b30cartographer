                                                 pfuncValidation ) ;

    BOOL fOK ;
    err = (pbrowsedlg==NULL) ? WN_OUT_OF_MEMORY : pbrowsedlg->Process( &fOK ) ;

    if ( err )
    {
        DBGEOL( "WNetBrowseDialog - Error code "
                << (ULONG) err << " returned from process." ) ;

        switch ( err )
        {
        case WN_EXTENDED_ERROR:
            MsgExtendedError( hwnd ) ;
            break ;

        default:
            MsgPopup( hwnd, (MSGID) err ) ;
            break ;
        }
    }

    delete pbrowsedlg;

    if ( nlsName.QueryTextLength() + 1 > nNameLength )
        err = ERROR_INSUFFICIENT_BUFFER;
    else
        ::strcpyf( lpszName, nlsName );

    return err ? err : ( !fOK ? 0xffffffff : WN_SUCCESS );
}

#define DEFAULT_NETWORK_HELP_FILE  SZ("network.hlp")

BOOL DummyIsValidFunction (LPWSTR psz) ;

/*******************************************************************

    NAME:       BrowseDialogA0

    SYNOPSIS:   a special browse dialog for WFW to thunk to

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        chuckc  26-Mar-1993     created

********************************************************************/
DWORD BrowseDialogA0( HWND    hwnd,
                      DWORD   nType,
                      CHAR   *pszName,
                      DWORD   cchBufSize)
{
    APIERR err ;
    NLS_STR nlsPath ;
    TCHAR szPath[MAX_PATH] ;

    ::memsetf(pszName,0,cchBufSize) ;

    if ( (err = nlsPath.QueryError()) != NERR_Success)
        return err ;

    err = WNetBrowseDialog( hwnd,
                            nType,
                            szPath,
                            MAX_PATH,
                            DEFAULT_NETWORK_HELP_FILE,
                            HC_GENHELP_BROWSE,
                            DummyIsValidFunction ) ;

    if (err)
        return err ;

    //
    // make use of NLS_STR's handy U to A conversion rotines
    //
    err = nlsPath.CopyFrom(szPath) ;
    if (!err)
        err = nlsPath.MapCopyTo(pszName,cchBufSize) ;

    return  err ;
}

/*******************************************************************

    NAME:       DummyIsValidFunction

    SYNOPSIS:   no validation for WFW, always return TRUE

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        chuckc  26-Mar-1993     created

********************************************************************/
BOOL DummyIsValidFunction (LPWSTR psz)
{
    UNREFERENCED(psz) ;
    return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\mprui\mpr\dlg1.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1995                **/
/**********************************************************************/

/*
    dlg1.cxx
        WNetConnectionDialog1* and WNetDisconnectDialog1* source

    FILE HISTORY:
        BruceFo 19-May-95       Created
*/

#define INCL_NETCONS
#define INCL_NETCONFIG
#define INCL_NETSERVICE
#define INCL_NETLIB
#define INCL_WINDOWS
#define INCL_NETERRORS
#define INCL_DOSERRORS
#include <lmui.hxx>

#define INCL_BLT_CONTROL
#define INCL_BLT_CLIENT
#define INCL_BLT_MSGPOPUP
#include <blt.hxx>

#include <mprconn.h>

//
// Export these using C-style syntax
//

extern "C"
{
    #include <mpr.h>
}

#include <shlobj.h>
#include <shlobjp.h>        // netplwiz.h stuff

//
// Null strings are quite often taken to be either a NULL pointer or a zero
//
#define IS_EMPTY_STRING(pch) ( !(pch) || !*(pch) )

#define MAX_NET_PATH  MAX_PATH


DWORD
MPRUI_WNetConnectionDialog1Help(
    LPCONNECTDLGSTRUCTW lpConnDlgStruct
    );

DWORD
MPRUI_WNetDisconnectDialog1Help(
    HWND hwndOwner,
    LPWSTR lpLocalName,
    LPWSTR lpRemoteName,
    DWORD dwFlags
    );


/*******************************************************************

    NAME:       MPRUI_WNetDisconnectDialog1W

    SYNOPSIS:

    ENTRY:      lpDiscDlgStruct -

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        BruceFo 19-May-1995     Created

********************************************************************/

DWORD
MPRUI_WNetDisconnectDialog1W(
    LPDISCDLGSTRUCTW lpDiscDlgStruct
    )
{
    DWORD status = WN_SUCCESS;

    __try
    {
        if (NULL == lpDiscDlgStruct)
        {
            status = WN_BAD_POINTER;
        }
        else if ((lpDiscDlgStruct->cbStructure < sizeof(DISCDLGSTRUCTW))
                 || ((lpDiscDlgStruct->lpLocalName == NULL) && (lpDiscDlgStruct->lpRemoteName == NULL))
                )
        {
            status = ERROR_INVALID_PARAMETER;
        }
        else
        {
            status = MPRUI_WNetDisconnectDialog1Help(
                                lpDiscDlgStruct->hwndOwner,
                                lpDiscDlgStruct->lpLocalName,
                                lpDiscDlgStruct->lpRemoteName,
                                lpDiscDlgStruct->dwFlags);
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        status = WN_BAD_POINTER;
    }

    if (status != WN_SUCCESS)
    {
        SetLastError(status);
    }
    return status;
}


/*******************************************************************

    NAME:       MPRUI_WNetDisconnectDialog1A

    SYNOPSIS:

    ENTRY:      lpDiscDlgStruct -

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        BruceFo 19-May-1995     Created

********************************************************************/

DWORD
MPRUI_WNetDisconnectDialog1A(
    LPDISCDLGSTRUCTA lpDiscDlgStruct
    )
{
    APIERR err;

    __try
    {
        if (NULL == lpDiscDlgStruct)
        {
            err = WN_BAD_POINTER;
        }
        else if ((lpDiscDlgStruct->cbStructure < sizeof(DISCDLGSTRUCTA))
                 || ((lpDiscDlgStruct->lpLocalName == NULL) && (lpDiscDlgStruct->lpRemoteName == NULL))
                )
        {
            err = ERROR_INVALID_PARAMETER;
        }
        else
        {
            DISCDLGSTRUCTW discDlgStructW;
            NLS_STR nlsLocalName;
            NLS_STR nlsRemoteName;

            if (   (err = nlsRemoteName.MapCopyFrom(lpDiscDlgStruct->lpRemoteName))
                || (err = nlsLocalName.MapCopyFrom(lpDiscDlgStruct->lpLocalName))
                )
            {
                // do nothing
            }

            if ( 0 == err )
            {
                discDlgStructW.cbStructure  = sizeof(DISCDLGSTRUCTW);
                discDlgStructW.hwndOwner    = lpDiscDlgStruct->hwndOwner;
                discDlgStructW.lpLocalName  = (LPWSTR)nlsLocalName.QueryPch();
                discDlgStructW.lpRemoteName = (LPWSTR)nlsRemoteName.QueryPch();
                discDlgStructW.dwFlags      = lpDiscDlgStruct->dwFlags;

                err = MPRUI_WNetDisconnectDialog1W(&discDlgStructW);
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        err = WN_BAD_POINTER;
    }

    return err;
}


/*******************************************************************

    NAME:       MPRUI_WNetConnectionDialog1A

    SYNOPSIS:

    ENTRY:      lpConnDlgStruct -

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        BruceFo 19-May-1995     Created

********************************************************************/

DWORD
MPRUI_WNetConnectionDialog1A(
    LPCONNECTDLGSTRUCTA lpConnDlgStruct
    )
{
    APIERR err = WN_SUCCESS;

    __try
    {
        if ((NULL == lpConnDlgStruct) || (NULL == lpConnDlgStruct->lpConnRes))
        {
            err = WN_BAD_POINTER;
        }
        else
        {
            if ((lpConnDlgStruct->dwFlags & CONNDLG_RO_PATH) &&
                ((lpConnDlgStruct->dwFlags & CONNDLG_USE_MRU)
                 || (IS_EMPTY_STRING(lpConnDlgStruct->lpConnRes->lpRemoteName)))
                 )
            {
                // A read only remote path has been requested with
                // a drop down MRU list or no remote path specified.
                // Neither of these options are valid.

                err = WN_BAD_VALUE;
            }
            else if ((lpConnDlgStruct->dwFlags & CONNDLG_PERSIST) &&
                     (lpConnDlgStruct->dwFlags & CONNDLG_NOT_PERSIST))
            {
                // Caller has specified inconsistent values.

                err = WN_BAD_VALUE;
            }

            if (lpConnDlgStruct->lpConnRes->dwType != RESOURCETYPE_DISK)
            {
                // Only disk dialog is supported

                err = WN_BAD_DEV_TYPE;
            }
        }

        if (WN_SUCCESS == err)
        {
            NLS_STR nlsLocalName;
            NLS_STR nlsRemoteName;
            NLS_STR nlsComment;
            NLS_STR nlsProvider;

            if (    (err = nlsRemoteName.MapCopyFrom(lpConnDlgStruct->lpConnRes->lpRemoteName))
                 || (err = nlsLocalName.MapCopyFrom(lpConnDlgStruct->lpConnRes->lpLocalName))
                 || (err = nlsComment.MapCopyFrom(lpConnDlgStruct->lpConnRes->lpComment))
                 || (err = nlsProvider.MapCopyFrom(lpConnDlgStruct->lpConnRes->lpProvider))
                 )
            {
                // do nothing
            }

            if ( 0 == err )
            {
                NETRESOURCEW      netResourceW;
                CONNECTDLGSTRUCTW connDlgStructW;

                connDlgStructW.cbStructure  = sizeof(CONNECTDLGSTRUCTW);
                connDlgStructW.hwndOwner    = lpConnDlgStruct->hwndOwner;
                connDlgStructW.lpConnRes    = &netResourceW;
                connDlgStructW.dwFlags      = lpConnDlgStruct->dwFlags;
                connDlgStructW.dwDevNum     = lpConnDlgStruct->dwDevNum;

                netResourceW.dwScope        = lpConnDlgStruct->lpConnRes->dwScope;
                netResourceW.dwType         = lpConnDlgStruct->lpConnRes->dwType;
                netResourceW.dwDisplayType  = lpConnDlgStruct->lpConnRes->dwDisplayType;
                netResourceW.dwUsage        = lpConnDlgStruct->lpConnRes->dwUsage;
                netResourceW.lpLocalName    = (LPWSTR)nlsLocalName.QueryPch();
                netResourceW.lpRemoteName   = (LPWSTR)nlsRemoteName.QueryPch();
                netResourceW.lpComment      = (LPWSTR)nlsComment.QueryPch();
                netResourceW.lpProvider     = (LPWSTR)nlsProvider.QueryPch();

                err = MPRUI_WNetConnectionDialog1Help(&connDlgStructW);

                if (err == WN_SUCCESS)
                {
                    // Now copy back the one thing that is an "out" paramter
                    lpConnDlgStruct->dwDevNum = connDlgStructW.dwDevNum;
                }
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        err = WN_BAD_POINTER;
    }

    return err;
}


/*******************************************************************

    NAME:       MPRUI_WNetConnectionDialog1W

    SYNOPSIS:

    ENTRY:      lpConnDlgStruct -

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        BruceFo 19-May-1995     Created

********************************************************************/

DWORD
MPRUI_WNetConnectionDialog1W(
    LPCONNECTDLGSTRUCTW lpConnDlgStruct
    )
{
    APIERR err = WN_SUCCESS;

    __try
    {
        if ((NULL == lpConnDlgStruct) || (NULL == lpConnDlgStruct->lpConnRes))
        {
            err = WN_BAD_POINTER;
        }
        else
        {
            if ((lpConnDlgStruct->dwFlags & CONNDLG_RO_PATH) &&
                ((lpConnDlgStruct->dwFlags & CONNDLG_USE_MRU)
                 || (IS_EMPTY_STRING(lpConnDlgStruct->lpConnRes->lpRemoteName)))
                 )
            {
                // A read only remote path has been requested with
                // a drop down MRU list or no remote path specified.
                // Neither of these options are valid.

                err = WN_BAD_VALUE;
            }
            else if ((lpConnDlgStruct->dwFlags & CONNDLG_PERSIST) &&
                     (lpConnDlgStruct->dwFlags & CONNDLG_NOT_PERSIST))
            {
                // Caller has specified inconsistent values.

                err = WN_BAD_VALUE;
            }

            if (lpConnDlgStruct->lpConnRes->dwType != RESOURCETYPE_DISK)
            {
                // Only disk dialog is supported

                err = WN_BAD_DEV_TYPE;
            }
        }

        if (WN_SUCCESS == err)
        {
            err = MPRUI_WNetConnectionDialog1Help(lpConnDlgStruct);
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        err = WN_BAD_POINTER;
    }

    return err;
}


/*******************************************************************

    NAME:       MPRUI_WNetConnectionDialog

    SYNOPSIS:   Entrypoint for the MPRUI_WNetConnectionDialog API

    ENTRY:      hwnd - Parent window handle suitable for hosting a dialog
                dwType - one of RESOURCETYPE_DISK or RESOURCETYPE_PRINT

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Johnl   22-Jan-1992     Commented, fixed
        beng    31-Mar-1992     Unicode mumble

********************************************************************/

DWORD MPRUI_WNetConnectionDialog( HWND hwnd,
                            DWORD dwType )
{
    NETRESOURCE      netResource;
    CONNECTDLGSTRUCT connDlgStruct;

    if (dwType != RESOURCETYPE_DISK)
    {
        // Only disk dialog is supported

        return WN_BAD_DEV_TYPE;
    }

    connDlgStruct.hwndOwner = hwnd;
    connDlgStruct.lpConnRes = &netResource;
    connDlgStruct.dwFlags   = CONNDLG_USE_MRU;

    ::memsetf((LPSTR)&netResource,0,sizeof(netResource));
    netResource.dwType = dwType;

    return MPRUI_WNetConnectionDialog1Help(&connDlgStruct);
}


/*******************************************************************

    NAME:       MPRUI_WNetConnectionDialog1Help

    SYNOPSIS:   Helper function for MPRUI_WNetConnectionDialog1{A,W}.
                Assumes parameters have been validated.

    ENTRY:      lpConnDlgStruct -

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
    BruceFo 19-May-1995     Created

********************************************************************/

DWORD
MPRUI_WNetConnectionDialog1Help(
    LPCONNECTDLGSTRUCTW lpConnDlgStruct
    )
{
    APIERR                      err;
    HMODULE                     hModule;                   

    ASSERT(lpConnDlgStruct->lpConnRes->dwType == RESOURCETYPE_DISK);

    if ((lpConnDlgStruct->dwFlags &
        (CONNDLG_RO_PATH | CONNDLG_USE_MRU)) == 0)
    {
        // If read-only or drop down MRU list not explicitly
        // requested, then pick a default based upon whether
        // or not the remote name was specified.

        lpConnDlgStruct->dwFlags |=
            (IS_EMPTY_STRING(lpConnDlgStruct->lpConnRes->lpRemoteName))
            ? CONNDLG_USE_MRU : CONNDLG_RO_PATH;
    }

    //
    // Create the wizard.  The third parameter indicates whether or not
    // the user specified a read-only path in lpConnDlgStruct.
    //

    err = NetPlacesWizardDoModal(lpConnDlgStruct,
                                 NETPLACES_WIZARD_MAPDRIVE,
                                 lpConnDlgStruct->dwFlags & CONNDLG_RO_PATH);

    //
    // this should never happen, but just in case, we
    // make sure we never pass internal errors out
    //
    if ( err >= IDS_UI_BASE )
    {
        err = ERROR_UNEXP_NET_ERR ;
    }

    return err;
}


/*******************************************************************

    NAME:       MPRUI_WNetDisconnectDialog1Help

    SYNOPSIS:

    ENTRY:      lpDiscDlgStruct -

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        BruceFo 19-May-1995     Created

********************************************************************/

DWORD
MPRUI_WNetDisconnectDialog1Help(
    HWND hwndOwner,
    LPWSTR lpLocalName,
    LPWSTR lpRemoteName,
    DWORD dwFlags
    )
{
    AUTO_CURSOR cursHourGlass ;
    OWNINGWND wndOwner( hwndOwner ) ;

    DWORD dwCancelFlags = ((dwFlags & DISC_UPDATE_PROFILE) != 0) ? CONNECT_UPDATE_PROFILE : 0;

    WCHAR* pszName = IS_EMPTY_STRING(lpLocalName) ? lpRemoteName : lpLocalName;
    DWORD status = WNetCancelConnection2(pszName, dwCancelFlags, FALSE);

    if (status != WN_SUCCESS)
    {
        // If the caller did not provide the remote name, go and get it.
        // This enables the best error message to be produced (assuming
        // that it is not the case that both the connection to the server
        // has gone down and the provider does not keep the remote name
        // locally).

        WCHAR szRemoteName[MAX_NET_PATH] ;
        ALIAS_STR nlsRemoteName(lpRemoteName ? lpRemoteName : L"");
        ALIAS_STR nlsLocalName(lpLocalName ? lpLocalName : L"");
        DWORD err = WN_SUCCESS;

        if (!IS_EMPTY_STRING(lpLocalName) &&
            IS_EMPTY_STRING(lpRemoteName)
            )
        {
            DWORD dwBufferSize = MAX_NET_PATH;

            err = WNetGetConnection(lpLocalName, szRemoteName, &dwBufferSize);
            if ( (err != WN_SUCCESS) && (err != WN_CONNECTION_CLOSED) )
            {
                // error!
            }
            else
            {
                nlsRemoteName = szRemoteName;
            }
        }

        if ( (err == WN_SUCCESS) || (err == WN_CONNECTION_CLOSED) )
        {
            if ( (status == WN_OPEN_FILES) ||
                 (status == WN_DEVICE_IN_USE) )
            {
                if ((dwFlags & DISC_NO_FORCE ) == 0)
                {
                    // There are open files on this connection - ask user whether
                    // he REALLY wants to destroy it - then apply force.

                    switch ( MsgPopup(
                                wndOwner,
                                IDS_OPENFILES_WITH_NAME_WARNING,
                                MPSEV_WARNING,
                                MP_YESNO,
                                nlsLocalName,
                                nlsRemoteName ))
                    {
                    case IDYES:
                        status = WNetCancelConnection2(pszName, dwCancelFlags, TRUE);
                        break ;

                    case IDNO:
                        status = WN_CANCEL;
                        break ;
                    }
                }
            }
        }
    }

    if ( (status != WN_SUCCESS) && (status != WN_CANCEL) )
    {
        MsgPopup( wndOwner, (MSGID) status );
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\mprui\mpr\mprmisc.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1992                **/
/**********************************************************************/

/*
    MPRMisc.cxx

    This file contains miscellaneous support routines for the MPR DLL.

    FILE HISTORY:
        Johnl   08-Jan-1992     Created
        Congpay 25-Oct-1992     Add ShowReconectDialog,
                                    ErrorDialog,
                                    RECONNECT_INFO_WINDOW class,
                                and ERROR_DIALOG class
        YiHsinS 23-Dec-1992     Added GetNetworkDisplayName

*/

#define INCL_DOSERRORS
#define INCL_NETLIB
#define INCL_NETERRORS
#define INCL_WINDOWS
#include <lmui.hxx>

#define INCL_BLT_MSGPOPUP
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#include <blt.hxx>
#include <dbgstr.hxx>

#include <strnumer.hxx> // DEC_STR

extern "C"
{
    #include <helpnums.h>
    #include <mprconn.h>
    #include <mpr.h>
    #include <uirsrc.h>
    #include <winnetp.h>
    #include <windowsx.h>  // Edit_LimitText
    #include <wincred.h>   // CredUI
}

#include <mprmisc.hxx>

//
// Globals
//
HINSTANCE   g_hInstance;

static ULONG
s_aulHelpIds[] =
{
    IDD_PASSWORD,       IDH_PASSWORD,
    0,0
};


//
// Structures
//
struct ERRORDLGPARAMETERS
{
    HANDLE        hDoneErrorDlg;
    const TCHAR * pchDevice;
    const TCHAR * pchResource;
    const TCHAR * pchProvider;
    DWORD         dwError;
    BOOL          fDisconnect;
    BOOL          fContinue;
    BOOL          fHideErrors;
    DWORD         dwExtError;
    const TCHAR * pchErrorText;
    const TCHAR * pchErrorProvider;
};

typedef struct
{
    LPTSTR  lpRemoteName;
    LPTSTR  lpUserName;
    LPTSTR  lpPassword;
    ULONG   cbPassword;
    LPBOOL  pfDidCancel;
}
PWDPARAMS, *LPPWDPARAMS;


BOOL
MprUIRegister(
    HINSTANCE DllHandle
    );

VOID
MprUIDeregister(
    VOID
    );

INT_PTR CALLBACK
PasswordDlgProc(
    HWND   hWnd,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam
    );

VOID
InvokeWinHelp(
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam,
    LPCWSTR wszHelpFileName,
    ULONG   aulControlIdToHelpIdMap[]
    );

APIERR
ErrorDialog(
    HWND          hwndParent,
    const TCHAR   *pchText1,
    const TCHAR   *pchText2,
    const TCHAR   *pchText3,
    BOOL          fAllowCancel,
    BOOL          *pfDisconnect,
    BOOL          *pfContinue,
    BOOL          *pfHideErrors
    );

DWORD ShowErrorDialog (
    HWND          hwndParent,
    const TCHAR * pchDevice,
    const TCHAR * pchResource,
    const TCHAR * pchProvider,
    DWORD         dwError,
    BOOL          fAllowCancel,
    BOOL *        pfDisconnect,
    BOOL *        pfContinue,
    BOOL *        pfHideErrors,
    DWORD         dwExtError,
    const TCHAR *       pchErrorText,
    const TCHAR *       pchErrorProvider
    )
{
    APIERR err = NERR_Success;

    do  //Error break out.
    {
        NLS_STR nlsDevice ( pchDevice);
        NLS_STR nlsResource( pchResource );
        NLS_STR nlsProvider( pchProvider );
        NLS_STR nlsErrorText;

        if (((err = nlsDevice.QueryError())   != NERR_Success) ||
            ((err = nlsResource.QueryError()) != NERR_Success) ||
            ((err = nlsProvider.QueryError()) != NERR_Success) ||
            ((err = nlsErrorText.QueryError())!= NERR_Success))
        {
            break;
        }

        STACK_NLS_STR (nlsErrNum, CCH_INT);

        const NLS_STR * apnlsParamStrings[6];

        // Find the error text.
        if (dwError == WN_EXTENDED_ERROR)
        {
            DEC_STR nlsError( (ULONG)dwExtError );

            if (((err = nlsError.QueryError()) != NERR_Success) ||
                ((err = nlsErrNum.CopyFrom( nlsError )) != NERR_Success) ||
                ((err = nlsErrorText.CopyFrom( pchErrorText)) != NERR_Success) ||
                ((err = nlsProvider.CopyFrom (pchErrorProvider)) != NERR_Success))
            {
                break;
            }

        }
        else
        {
            if (dwError == WN_CANCEL)
                err = nlsErrorText.Load ((MSGID) IDS_NO_PASSWORD);
            else
                err = nlsErrorText.Load ((MSGID) dwError );

            if (err != NERR_Success)
                break;
        }

        if (nlsDevice.QueryTextLength() == 0)
        {
            if (nlsDevice.Load(IDS_DEVICELESS_CONNECTION_NAME) != NERR_Success)
                nlsDevice = NULL ;   // alwats succeeds.
        }
        apnlsParamStrings[0] = &nlsDevice;
        apnlsParamStrings[1] = &nlsResource;
        apnlsParamStrings[2] = &nlsProvider;
        apnlsParamStrings[3] = &nlsErrNum;
        apnlsParamStrings[4] = &nlsErrorText;
        apnlsParamStrings[5] = NULL;

        if (pfDisconnect == NULL) // Used by winfile.
        {
            MSGID msgid = IERR_ProfileLoadError;
            MsgPopup (hwndParent,
                      msgid,
                      MPSEV_WARNING,
                      (ULONG)HC_NO_HELP,  //HC_CONNECT_ERROR,
                      MP_OK,
                      (NLS_STR **) apnlsParamStrings,
                      MP_OK);
        }
        else  // Used by log on procedure.
        {
            RESOURCE_STR nlsText1((MSGID) IERR_TEXT1);
            nlsText1.InsertParams( apnlsParamStrings );
            RESOURCE_STR nlsText2((MSGID) IERR_TEXT2);
            nlsText2.InsertParams( apnlsParamStrings );
            RESOURCE_STR nlsText3((MSGID) IERR_TEXT3);
            nlsText3.InsertParams( apnlsParamStrings );

            if (((err = nlsText1.QueryError()) != NERR_Success) ||
                ((err = nlsText2.QueryError()) != NERR_Success) ||
                ((err = nlsText3.QueryError()) != NERR_Success))
            {
                break;
            }

            err = ErrorDialog (hwndParent,
                               nlsText1.QueryPch(),
                               nlsText2.QueryPch(),
                               nlsText3.QueryPch(),
                               fAllowCancel,
                               pfDisconnect,
                               pfContinue,
                               pfHideErrors);
        }

    } while (FALSE);

    if (err != NERR_Success)
    {
        MsgPopup (hwndParent, (MSGID) err);
    }

    return (err);
}


/*******************************************************************

    NAME:       DllMain

    SYNOPSIS:   DLL entry point

    ENTRY:      DllHandle - Instance handle of this DLL
                Reason - The reason for which this routine is being called.
                         This might be one of the following:
                                DLL_PROCESS_ATTACH
                                DLL_THREAD_ATTACH
                                DLL_THREAD_DETACH
                                DLL_PROCESS_DETACH
                lpReserved -

    EXIT:

    RETURNS:    TRUE if successful, FALSE otherwise

    NOTES:

    HISTORY:
        ChuckC  27-Jul-1992     Created

********************************************************************/
BOOL
DllMain(
    HINSTANCE    DllHandle,
    DWORD        Reason,
    LPVOID       lpReserved
    )
{
    UNREFERENCED(lpReserved);

    if (Reason == DLL_PROCESS_ATTACH)
    {
        g_hInstance = DllHandle;

        DisableThreadLibraryCalls(DllHandle);

        // initialize BLT, etc.
        if ( !MprUIRegister(DllHandle) )
            return FALSE ;
    }
    else if (Reason == DLL_PROCESS_DETACH)
    {
        MprUIDeregister() ;
    }
    return(TRUE);
}


/*******************************************************************

    NAME:       MprUIRegister

    SYNOPSIS:   UI Side registration function, called upon DLL Initialization

    ENTRY:      DllHandle - Instance handle of this DLL

    EXIT:

    RETURNS:    TRUE if successful, FALSE otherwise

    NOTES:

    HISTORY:
        Johnl       08-Jan-1992 Created
        beng        03-Aug-1992 Changes for dllization of BLT

********************************************************************/

BOOL
MprUIRegister(
    HINSTANCE DllHandle
    )
{
    APIERR err = BLT::Init( DllHandle,
                            IDRSRC_MPRUI_BASE, IDRSRC_MPRUI_LAST,
                            IDS_UI_MPR_BASE, IDS_UI_MPR_LAST ) ;
    if ( err )
    {
        DBGEOL("::MprUIRegister - BLT Failed to initialize, error code "
               << err ) ;
        return FALSE ;
    }

    err = BLT::RegisterHelpFile( DllHandle, IDS_MPRHELPFILENAME,
                                 HC_UI_MPR_BASE, HC_UI_MPR_LAST );
    if ( err )
    {
        DBGEOL("::MprUIRegister - BLT Help File Failed to initialize, error code " << err ) ;
        return FALSE ;
    }

    return TRUE ;
}


/*******************************************************************

    NAME:       MprUIDeregister

    SYNOPSIS:   UI Side uninitialization, called upon DLL process detach

    NOTES:

    HISTORY:
        Johnl       08-Jan-1992 Created
        beng        03-Aug-1992 Changes for dllization of BLT

********************************************************************/

VOID
MprUIDeregister(
    VOID
    )
{
    if (g_hInstance != NULL)
    {
        BLT::DeregisterHelpFile(g_hInstance, 0);
        BLT::Term(g_hInstance);
        g_hInstance = NULL;
    }
}


/*******************************************************************

    NAME:       MsgExtendedError

    SYNOPSIS:   Retrieves the last error using WNetGetLastError and puts
                up a MsgPopup with the error information.

    ENTRY:      This should be called immediately after WN_EXTENDED_ERROR
                is returned from a WNet* API.

                powin - Pointer to owner window we should use for the MsgPopup

    EXIT:

    NOTES:

    HISTORY:
        Johnl   09-Jan-1992        Created

********************************************************************/

void MsgExtendedError( HWND hwndParent )
{
    APIERR err ;
    BUFFER buffErrorText( 256*sizeof(TCHAR) ) ;
    BUFFER buffProviderName( 256*sizeof(TCHAR) ) ;
    if ( (err = buffErrorText.QueryError()) ||
         (err = buffProviderName.QueryError()) )
    {
        MsgPopup( hwndParent, (MSGID) err ) ;
        return ;
    }

    DWORD dwErr ;
    switch ( WNetGetLastError( &dwErr,
                               (LPTSTR) buffErrorText.QueryPtr(),
                               (DWORD)  buffErrorText.QuerySize()/sizeof(TCHAR),
                               (LPTSTR) buffProviderName.QueryPtr(),
                               (DWORD)  buffProviderName.QuerySize()/sizeof(TCHAR) ))
    {
    case WN_SUCCESS:
        break ;

    case WN_BAD_POINTER:
    default:
        MsgPopup( hwndParent, (MSGID) ERROR_GEN_FAILURE ) ;
        return ;
    }

    ALIAS_STR nlsProvider( (const TCHAR *) buffProviderName.QueryPtr() );
    ALIAS_STR nlsErrorText( (const TCHAR *) buffErrorText.QueryPtr() );
    DEC_STR nlsError( dwErr );

    if ( (err = nlsError.QueryError()) != NERR_Success )
    {
        ::MsgPopup( hwndParent, err );
    }
    else
    {
        NLS_STR *apnls[4];
        apnls[0] = &nlsProvider;
        apnls[1] = &nlsError;
        apnls[2] = &nlsErrorText;
        apnls[3] = NULL;

        ::MsgPopup( hwndParent,
                    IDS_WN_EXTENDED_ERROR,
                    MPSEV_ERROR,
                    (ULONG)HC_NO_HELP,
                    MP_OK,
                    apnls  );
    }
}

/*******************************************************************

    NAME:       GetNetworkDisplayName

    SYNOPSIS:   Helper function

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
        YiHsinS 23-Dec-1992     Created

********************************************************************/


APIERR
GetNetworkDisplayName(
    const TCHAR *pszProvider,
    const TCHAR *pszRemoteName,
    DWORD        dwFlags,
    DWORD        dwAveCharPerLine,
    NLS_STR     *pnls )
{
    APIERR err = NERR_Success;

    BUFFER buf( MAX_PATH * sizeof( TCHAR) );
    DWORD  dwbufsize = buf.QuerySize() / sizeof( TCHAR );
    if ( (err = buf.QueryError()) != NERR_Success )
    {
        return err;
    }

    do
    {
         err = WNetFormatNetworkName(
                       pszProvider,
                       pszRemoteName,
                       (LPTSTR) buf.QueryPtr(),
                       &dwbufsize,
                       dwFlags,
                       dwAveCharPerLine );

         if ( err == NERR_Success )
         {
             pnls->CopyFrom( (TCHAR *) buf.QueryPtr() );
             break;
         }
         else if ( err == WN_MORE_DATA )
         {
             err = buf.Resize( (UINT) dwbufsize * sizeof( TCHAR ));
             if ( err != NERR_Success )
             {
                 break;
             }
         }
         else
         {
             err = pnls->CopyFrom( pszRemoteName );
             break;
         }
    }
    while ( TRUE );

    return err;
}


/*******************************************************************

    NAME:       MPRUI_WNetClearConnections

    SYNOPSIS:   Cancels all active connections using force.  No prompting
                is currently performed.

    ENTRY:      hWndParent - Parent window handle in case we ever want to
                    prompt/warn the user

    RETURNS:    Standard windows/winnet error code

    NOTES:

    HISTORY:
        Johnl   19-Mar-1992     Created

********************************************************************/


DWORD
MPRUI_WNetClearConnections(
    HWND hWndParent
    )
{
    UNREFERENCED( hWndParent ) ;

    APIERR err ;
    /* Now, for any UNC connections still connected, disconnect each one
     */
    HANDLE   hEnum;
    DWORD dwErr = WNetOpenEnum( RESOURCE_CONNECTED,
                                RESOURCETYPE_ANY,
                                0,                  // ignored
                                NULL,
                                &hEnum ) ;

    switch (dwErr)
    {
    case WN_SUCCESS:
        {
            DWORD dwEnumErr;
            BUFFER buf( 4096 );
            dwEnumErr = buf.QueryError() ;

            while ( dwEnumErr == NERR_Success )
            {
                DWORD dwCount = 0xffffffff;   // Return as many as possible
                DWORD dwBuffSize = buf.QuerySize() ;

                dwEnumErr = WNetEnumResource( hEnum,
                                              &dwCount,
                                              buf.QueryPtr(),
                                              &dwBuffSize );

                switch ( dwEnumErr )
                {
                case WN_SUCCESS:
                    {
                        NETRESOURCE * pnetres;

                        pnetres = (NETRESOURCE * )buf.QueryPtr();

                        for (INT i = 0; dwCount ; dwCount--, i++ )
                        {
                            //
                            // Ignore these errors. Delete device there is one
                            // else delete UNC.
                            //
                            if ((pnetres+i)->lpLocalName &&
                                (pnetres+i)->lpLocalName[0])
                            {
                                dwEnumErr = (APIERR)
                                    WNetCancelConnection2(
                                        (pnetres+i)->lpLocalName,
                                        0,
                                        TRUE ) ;
                            }
                            else
                            {
                                dwEnumErr = (APIERR)
                                    WNetCancelConnection2(
                                        (pnetres+i)->lpRemoteName,
                                        0,
                                        TRUE ) ;
                            }
                        }

                    }
                    break ;

                /* The buffer wasn't big enough for even one entry
                 * resize it and try again.
                 */
                case WN_MORE_DATA:
                    {
                        if (dwEnumErr = buf.Resize( buf.QuerySize()*2 ))
                            break ;
                    }
                    /* Continue looping
                     */
                    dwEnumErr = WN_SUCCESS ;
                    break ;

                case WN_NO_MORE_ENTRIES:
                    // Success code, fall out of loop and map below
                case WN_EXTENDED_ERROR:
                case WN_NO_NETWORK:
                    break ;

                case WN_BAD_HANDLE:
                default:
                    break;
                } //switch
            } //while

            WNetCloseEnum( hEnum );
            err = (dwEnumErr==WN_NO_MORE_ENTRIES ) ? NERR_Success : dwEnumErr ;
        }
        break;

    case WN_NO_NETWORK:
    case WN_EXTENDED_ERROR:
        err = dwErr ;
        break ;

    case WN_NOT_CONTAINER:
    case WN_BAD_VALUE:
    default:
        //
        // Unknown return code.
        //
        DBGEOL( SZ("MPRUI_WNetClearConnections - Unexpected return code - ") << (ULONG)dwErr );
        err = ERROR_GEN_FAILURE ;
        break;
    }

    return (DWORD) err ;
}


/*******************************************************************

    NAME:       MPRUI_DoPasswordDialog

    SYNOPSIS:   Displays a dialog to get the password for a resource

    ENTRY:      hwndOwner - owner window.
                pchResource - pointer to the name of resource to be connected.
                pchUserName - pointer to the user's net logon name.
                pchPasswordReturnBuffer - buffer in which password returned.
                cbPasswordReturnBuffer - size of buffer (in bytes).
                pfDidCancel - TRUE if user cancelled, FALSE if user pressed OK.

    EXIT:       FALSE if dialog could not be processed

    NOTES:

    HISTORY:
        jonn     02-Apr-1992        Templated from mprconn.cxx
        congpay  28-Jan-1993        Modified it.
        jschwart 24-Sep-1998        Rewritten using Win32 and C-S help

********************************************************************/

DWORD
MPRUI_DoPasswordDialog(
    HWND          hwndOwner,
    LPWSTR        wszResource,
    LPWSTR        wszUserName,
    LPWSTR        wszPasswordReturnBuffer,
    ULONG         cbPasswordReturnBuffer,
    BOOL *        pfDidCancel,
    DWORD         dwError
    )
{
    ASSERT(wszResource != NULL);
    ASSERT(wszPasswordReturnBuffer != NULL);
    ASSERT(cbPasswordReturnBuffer >= sizeof(WCHAR) * (PWLEN + 1));
    ASSERT(pfDidCancel != NULL);

    CREDUI_INFO uiInfo = { sizeof(uiInfo), hwndOwner, NULL, NULL, NULL };

    WCHAR       wszText[MAX_PATH + 71];    // Space for the path and the error text itself
    DWORD       dwCredErr;
    DWORD       dwCredUIFlags = CREDUI_FLAGS_DO_NOT_PERSIST |
                                    CREDUI_FLAGS_GENERIC_CREDENTIALS;

    if (LoadString(GetModuleHandle(L"mprui.dll"),
                   (dwError == ERROR_ACCOUNT_DISABLED) ? IDS_ACCOUNT_DISABLED : IDS_PASSWORD,
                   wszText,
                   70) != 0)
    {
        wcsncat(wszText, wszResource, MAX_PATH);
        wszText[MAX_PATH + 70] = L'\0';

        uiInfo.pszMessageText = wszText;
    }

    dwCredErr = CredUIPromptForCredentials(&uiInfo,
                                           wszResource,
                                           NULL,
                                           dwError,
                                           wszUserName,
                                           CRED_MAX_USERNAME_LENGTH,
                                           wszPasswordReturnBuffer,
                                           cbPasswordReturnBuffer / sizeof(WCHAR) - 1,
                                           NULL,
                                           dwCredUIFlags);

    if ( dwCredErr == ERROR_CANCELLED ) {
        *pfDidCancel = TRUE;
        dwCredErr = NO_ERROR;
    } else {
        *pfDidCancel = FALSE;
    }

    return dwCredErr;
}


/*******************************************************************

    NAME:       ERROR_DIALOG class

    SYNOPSIS:   Used by ErrorDialog function.

    PARENT:     DIALOG_WINDOW.

    Public:     ERROR_DIALOG    constructor

    Entry:      hwndParent      Parent window.
                fAllowCancel    Boolean variable that let you choose one
                                of the two dialogs.
                pchText1        Point to the text string in the first line.
                pchText2        Point to the text string in the second line.
                pchText3        Point to the text string in the third line
                pfDisconnect    TRUE if the checkbox is checked.
                pfHideErrors    TRUE if the checkbox is checked.

    NOTES:

    HISTORY:
        congpay    14-Oct-1992        Created.

********************************************************************/

ERROR_DIALOG::ERROR_DIALOG (HWND        hwndParent,
                            const TCHAR *pchText1,
                            const TCHAR *pchText2,
                            const TCHAR *pchText3,
                            BOOL        *pfDisconnect,
                            BOOL        fAllowCancel,
                            BOOL        *pfHideErrors)
  : DIALOG_WINDOW (MAKEINTRESOURCE(fAllowCancel ? IDD_ERRORWITHCANCEL_DLG
                                                : IDD_ERROR_DLG),
                   hwndParent),
    _sltText1            (this, IDD_TEXT1),
    _sltText2            (this, IDD_TEXT2),
    _sltText3            (this, IDD_TEXT3),
    _chkCancelConnection (this, IDD_CHKCANCELCONNECTION),
    _pchkHideErrors      (NULL),
    _pfDisconnect (pfDisconnect),
    _pfHideErrors (pfHideErrors),
    _fAllowCancel (fAllowCancel)
{
    if (fAllowCancel)
        _pchkHideErrors = new CHECKBOX(this, IDD_CHKHIDEERRORS);

    _sltText1.SetText (pchText1);
    _sltText2.SetText (pchText2);
    _sltText3.SetText (pchText3);

    ::SetFocus(GetDlgItem(QueryHwnd(), IDOK));

    return;
}

ERROR_DIALOG::~ERROR_DIALOG()
{
    delete _pchkHideErrors;
}

BOOL ERROR_DIALOG::OnCancel()
{
    *_pfDisconnect = _chkCancelConnection.QueryCheck();
    Dismiss (!_fAllowCancel);
    return (TRUE);
}

BOOL ERROR_DIALOG::OnOK()
{
    *_pfDisconnect = _chkCancelConnection.QueryCheck();
    if (_pchkHideErrors != NULL)
        *_pfHideErrors = _pchkHideErrors->QueryCheck();
    Dismiss (TRUE);
    return (TRUE);
}

ULONG ERROR_DIALOG::QueryHelpContext()
{
    return HC_RECONNECTDIALOG_ERROR;
}
/*******************************************************************

    NAME:       ErrorDialog

    SYNOPSIS:   Displays a dialog to show the error. The dialog has a
                check box to delete the connection.

    ENTRY:      HWND          hwndParent - Parent Window.
                DWORD         dwResource - dialog ID.
                const TCHAR   *pchText1  - pointer to the string to be printed out.
                const TCHAR   *pchText2  - pointer to the string to be printed out.
                const TCHAR   *pchText3  - pointer to the string to be printed out.
                BOOL          *pfDisconnect - point to TRUE if the checkbox is checked.
                BOOL          *pfContinue  - point to TRUE if OK or Yes button is pressed.
                                             And to FALSE IF No button is pressed.
                BOOL          *pfHideErrors - point to TRUE iff user asks to
                                              hide further errors

    EXIT:       non zero if OK is pressed.
                0 if CANCEL IS pressed.

    NOTES:      Used by RECONNECT_INFO_WINDOW class.

    HISTORY:
        congpay    14-Oct-1992        Created.

********************************************************************/

APIERR ErrorDialog(HWND          hwndParent,
                const TCHAR   *pchText1,
                const TCHAR   *pchText2,
                const TCHAR   *pchText3,
                BOOL          fAllowCancel,
                BOOL          *pfDisconnect,
                BOOL          *pfContinue,
                BOOL          *pfHideErrors)
{
    ERROR_DIALOG *ppdlg = new
        ERROR_DIALOG (hwndParent,
                      pchText1,
                      pchText2,
                      pchText3,
                      pfDisconnect,
                      fAllowCancel,
                      pfHideErrors);

    APIERR err = (ppdlg == NULL)?
        ERROR_NOT_ENOUGH_MEMORY : ppdlg -> QueryError();

    if (err == NERR_Success)
        err = ppdlg->Process(pfContinue);

    delete ppdlg;

    return (err);
}

/*******************************************************************

    NAME:       RECONNECT_INFO_WINDOW class

    SYNOPSIS:   Used by MPRUI_ShowReconnectDialog function.

    PARENT:     DIALOG_WINDOW.

    Public:     RECONNECT_INFO_WINDOW   - constructor

    Entry:      hwndParent      - Parent window.
                pszResource     - pointer of the dialog resource file.
                cidTarget       - the id of LTEXT where the connection is going
                                  to be shown.
                pfCancel        - point to TRUE if Cancel button is pressed.

    NOTES:

    HISTORY:
        congpay    14-Oct-1992        Created.

********************************************************************/

RECONNECT_INFO_WINDOW::RECONNECT_INFO_WINDOW (HWND        hwndParent,
                                              const TCHAR *pszResource,
                                              CID         cidTarget,
                                              BOOL *      pfCancel)
  : DIALOG_WINDOW (pszResource, hwndParent),
    _sltTarget (this, cidTarget),
    _pfCancel (pfCancel)
{
    // Hide this dialog - the UI should be removed ASAP, but JSchwart estimated there isn't time for Whistler
    SetPos(XYPOINT(10000,10000), NULL);
    *_pfCancel = FALSE;
    return;
}

VOID RECONNECT_INFO_WINDOW::SetText (TCHAR *pszResource)
{
    _sltTarget.SetText (pszResource);
}

BOOL RECONNECT_INFO_WINDOW::OnCancel()
{
    *_pfCancel = TRUE;
    Dismiss (FALSE);
    return (TRUE);
}

BOOL RECONNECT_INFO_WINDOW::OnUserMessage(const EVENT &event)
{
    switch (event.QueryMessage())
    {
    case SHOW_CONNECTION:
        SetText ((TCHAR *) event.QueryWParam());
        break;

    case DO_PASSWORD_DIALOG:
        {
            PARAMETERS *Params = (PARAMETERS *) event.QueryWParam();
            Params->status = MPRUI_DoPasswordDialog (QueryHwnd(),
                                               Params->pchResource,
                                               Params->pchUserName,
                                               Params->passwordBuffer,
                                               sizeof (Params->passwordBuffer),
                                               &(Params->fDidCancel),
                                               Params->dwError);
            SetEvent (Params->hDonePassword);
        }
        break;

    case DO_ERROR_DIALOG:
        {
            APIERR err = NERR_Success;
            ERRORDLGPARAMETERS *ErrParams = (ERRORDLGPARAMETERS *) event.QueryWParam();

            err = ShowErrorDialog(QueryHwnd(),
                                  ErrParams->pchDevice,
                                  ErrParams->pchResource,
                                  ErrParams->pchProvider,
                                  ErrParams->dwError,
                                  TRUE,
                                  &(ErrParams->fDisconnect),
                                  &(ErrParams->fContinue),
                                  &(ErrParams->fHideErrors),
                                  ErrParams->dwExtError,
                                  ErrParams->pchErrorText,
                                  ErrParams->pchErrorProvider);

            ErrParams->dwError = err;
            SetEvent (ErrParams->hDoneErrorDlg);
        }
        break;

    default:
        break;
    }
    return (TRUE);
}

/*******************************************************************

    NAME:       MPRUI_ShowReconnectDialog

    SYNOPSIS:   Displays a dialog to show the connection it's trying to
                restore.

    ENTRY:      PARAMETERS Params

    EXIT:       FALSE if dialog could not be processed

    NOTES:

    HISTORY:
        congpay    14-Oct-1992        Created.

********************************************************************/

DWORD
MPRUI_ShowReconnectDialog(
    HWND hwndParent,
    PARAMETERS *Params
    )
{
    BOOL fCancel = FALSE; // record the cancel button in the Info window.

    RECONNECT_INFO_WINDOW *ppdlg = new
        RECONNECT_INFO_WINDOW (hwndParent,
                               MAKEINTRESOURCE(IDD_RECONNECT_DLG),
                               IDD_TEXT,
                               &fCancel);

    APIERR err = (ppdlg == NULL)?
        ERROR_NOT_ENOUGH_MEMORY : ppdlg -> QueryError();

    if (err == NERR_Success)
    {
        Params->hDlg = ppdlg -> QueryHwnd();
        SetEvent (Params->hDlgCreated);
        err = ppdlg->Process();
        if (err == NERR_Success && fCancel == TRUE)
        {
            Params->status = WN_CANCEL;
        }
    }
    else
    {
        SetEvent (Params->hDlgFailed);
    }

    delete ppdlg;

    if (err != NERR_Success)
    {
        MsgPopup (hwndParent, (MSGID) err);
    }

    return (err);
}


/*******************************************************************

    NAME:       MPRUI_DoProfileErrorDialog

    SYNOPSIS:   Displays a dialog to get the password for a resource

    ENTRY:      hwndOwner - owner window
                pchDevice - name of device which could not be reconnected
                pchResource - name of resource which could not be reconnected
                pchProvider - name of provider which registered an error
                dwError - error number (could be WN_EXTENDED_ERROR)
                fAllowCancel - Should user be allowed to stop reconnecting?
                pfDidCancel - TRUE if user cancelled, FALSE if user pressed OK
                pfDisconnect - TRUE if user asked to stop reconnecting this
                               device on logon
                pfHideErrors - TRUE if user asked to stop displaying reconnect
                               errors for this logon

    EXIT:       FALSE if dialog could not be processed

    NOTES:

    HISTORY:
        jonn    08-Apr-1992        Templated from mprconn.cxx
        CongpaY 25-Oct-1992        Modified. More work on Internationalization.

********************************************************************/
DWORD
MPRUI_DoProfileErrorDialog(
    HWND          hwndParent,
    const TCHAR * pchDevice,
    const TCHAR * pchResource,
    const TCHAR * pchProvider,
    DWORD         dwError,
    BOOL          fAllowCancel,
    BOOL *        pfDidCancel,
    BOOL *        pfDisconnect,
    BOOL *        pfHideErrors
    )
{
    ASSERT( pchResource != NULL );
    ASSERT( pchProvider != NULL );
    ASSERT( !fAllowCancel || pfDidCancel != NULL );
    ASSERT( !fAllowCancel || pfHideErrors != NULL );

    APIERR err = NERR_Success;

    TCHAR chNull = TCH('\0');
    if (pchDevice == NULL)
        pchDevice = &chNull;

    if (pchResource == NULL)
        pchResource = &chNull;

    if (pchProvider == NULL)
        pchProvider = &chNull;

    // if dwError is extended error. we have to pass the actual error to
    // the second thread.
    DWORD  dwActualError;
    BUFFER bufErrorText (256*sizeof(TCHAR));
    BUFFER bufProvider  (256*sizeof(TCHAR));
    if (dwError == WN_EXTENDED_ERROR)
    {
        if (((err = bufErrorText.QueryError()) == NERR_Success) &&
            ((err = bufProvider.QueryError()) == NERR_Success))
        {
            err = ::WNetGetLastError (&dwActualError,
                                      (LPTSTR)bufErrorText.QueryPtr(),
                                      256,
                                      (LPTSTR)bufProvider.QueryPtr(),
                                      256);
        }

        if (err != NERR_Success)
        {
            SetLastError (err);
            return (err);
        }
    }

    if (fAllowCancel) // Runs in the second thread. Called by DoRestoreConnection.
    {
        ERRORDLGPARAMETERS ErrParams;

        if ((ErrParams.hDoneErrorDlg = CreateEvent (NULL, FALSE, FALSE, NULL)) == NULL)
        {
            err = GetLastError();
            SetLastError (err);
            return (err);
        }

        ErrParams.pchDevice     = pchDevice;
        ErrParams.pchResource   = pchResource;
        ErrParams.pchProvider   = pchProvider;
        ErrParams.dwError       = dwError;

        if (dwError == WN_EXTENDED_ERROR)
        {
            ErrParams.dwExtError = dwActualError;
            ErrParams.pchErrorText = (const TCHAR *) bufErrorText.QueryPtr();
            ErrParams.pchErrorProvider = (const TCHAR *) bufProvider.QueryPtr();
        }
        else
        {
            ErrParams.dwExtError = 0;
            ErrParams.pchErrorText = NULL;
            ErrParams.pchErrorProvider = NULL;
        }

        PostMessage (hwndParent, DO_ERROR_DIALOG, (WPARAM) &ErrParams, 0);

        HANDLE lpHandle = ErrParams.hDoneErrorDlg;

        WaitForSingleObject (lpHandle, INFINITE);

        // set the value of pfDisconnect, and pfDidCancel.
        if (ErrParams.dwError == NO_ERROR) //ErrorDialog succeed.
        {
            *pfDisconnect = ErrParams.fDisconnect;
            *pfDidCancel =  (ErrParams.fContinue == FALSE);
            *pfHideErrors = (ErrParams.fHideErrors != FALSE);
        }
    }
    else  //Runs in the main thread.
    {
        if (dwError == WN_EXTENDED_ERROR)
        {
            err = ShowErrorDialog (hwndParent,
                                   pchDevice,
                                   pchResource,
                                   pchProvider,
                                   dwError,
                                   FALSE,
                                   pfDisconnect,
                                   NULL,
                                   pfHideErrors,
                                   dwActualError,
                                   (const TCHAR *)bufErrorText.QueryPtr(),
                                   (const TCHAR *)bufProvider.QueryPtr());
        }
        else
        {
            err = ShowErrorDialog (hwndParent,
                                   pchDevice,
                                   pchResource,
                                   pchProvider,
                                   dwError,
                                   FALSE,
                                   pfDisconnect,
                                   NULL,
                                   pfHideErrors,
                                   0,
                                   NULL,
                                   NULL);
        }

    }
    return (err);
}


/*******************************************************************

    NAME:       InvokeWinHelp

    SYNOPSIS:   Helper function to invoke WinHelp.

    ENTRY:      message                 - WM_CONTEXTMENU or WM_HELP
                wParam                  - depends on [message]
                wszHelpFileName         - filename with or without path
                aulControlIdToHelpIdMap - see WinHelp API

    HISTORY:    25-Sep-1998   jschwart   Created

********************************************************************/

VOID
InvokeWinHelp(
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam,
    LPCWSTR wszHelpFileName,
    ULONG   aulControlIdToHelpIdMap[]
    )
{
    ASSERT(wszHelpFileName != NULL);
    ASSERT(aulControlIdToHelpIdMap != NULL);

    switch (message)
    {
        case WM_CONTEXTMENU:                // "What's This" context menu
            WinHelp((HWND) wParam,
                    wszHelpFileName,
                    HELP_CONTEXTMENU,
                    (DWORD_PTR) aulControlIdToHelpIdMap);
            break;

        case WM_HELP:                       // Help from the "?" dialog
        {
            const LPHELPINFO pHelpInfo = (LPHELPINFO) lParam;

            if (pHelpInfo && pHelpInfo->iContextType == HELPINFO_WINDOW)
            {
                WinHelp((HWND) pHelpInfo->hItemHandle,
                        wszHelpFileName,
                        HELP_WM_HELP,
                        (DWORD_PTR) aulControlIdToHelpIdMap);
            }
            break;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\mprui\mpr\mprenum.cxx ===
/**********************************************************************/
/**                       Microsoft LAN Manager                      **/
/**             Copyright(c) Microsoft Corp., 1990, 1991             **/
/**********************************************************************/

/*
    mprenum.cxx
        Contains EnumerateShow.


    FILE HISTORY:
        Yi-HsinS     04-Mar-1993    Separated from mprbrows.cxx

*/

#define INCL_NETERRORS
#define INCL_DOSERRORS
#define INCL_WINDOWS
#define INCL_NETLIB
#define INCL_NETWKSTA
#include <lmui.hxx>

#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MSGPOPUP
#include <blt.hxx>

#include <string.hxx>
#include <uitrace.hxx>
#include <dbgstr.hxx>
#include <uibuffer.hxx>

#include <mprbrows.hxx>

#define MPRDBG(x)     { ; }
#define MPRDBGEOL(x)  { ; }

// prototype
APIERR EnumerateShowHelp(
                        HANDLE            hEnum,
    			MPR_LBI         **ppmprlbiParent,
    			MPR_LBI_CACHE    *plbicache,
                      	LPNETRESOURCE     lpNetResource,
                      	MPR_LBI          *pmprlbi,
                      	MPR_HIER_LISTBOX *pmprlb,
    		      	BOOL	          fDeleteChildren,
                      	BOOL             *pfSearchDialogUsed );

/*******************************************************************

    NAME:       ::EnumerateShow

    SYNOPSIS:   Enumerate the requested data
                (providers, containers or connectable items). 
                (1) If the listbox passed in is not NULL, 
                    then the data is added in the listbox
                (2) If the listbox is NULL, 
                    then return the data in the MPR_LBI_CACHE   
                    

    ENTRY:      uiScope - Scope for enumeration (see WNetOpenEnum)
                uiType  - Type of enumeration   (see WNetOpenEnum)
                uiUsage - Usage of enumeration  (see WNetOpenEnum)
                lpNetResource - Net resource    (see WNetOpenEnum)
                pmprlbi - Parent LBI to add enumeration to
                pmprlb  - Pointer to the MPR_HIER_LISTBOX
                fDeleteChildren - TRUE if we need to delete the children
                pfSearchDialogUsed
                ppmprlbicache 

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Johnl   22-Jan-1992     Broke out from dialog, commented, fixed
        YiHsinS 04-Mar-1993     Support multithread

********************************************************************/

APIERR EnumerateShow( HWND              hwndOwner,
		      UINT              uiScope,
                      UINT              uiType,
                      UINT              uiUsage,
                      LPNETRESOURCE     lpNetResource,
                      MPR_LBI          *pmprlbi,
                      MPR_HIER_LISTBOX *pmprlb,
    		      BOOL	        fDeleteChildren,
                      BOOL             *pfSearchDialogUsed,
                      MPR_LBI_CACHE   **ppmprlbicache )
{
    UIASSERT( WN_SUCCESS == NERR_Success );
    if ( ppmprlbicache != NULL )
        *ppmprlbicache = NULL;

    APIERR err = NERR_Success;

    MPR_LBI *pmprlbiParent = pmprlbi;

    MPR_LBI_CACHE *plbicache = new MPR_LBI_CACHE();
    if (  ( plbicache == NULL )
       || (( err = plbicache->QueryError()) != NERR_Success ) 
       )
    {
        if ( err != NERR_Success )
            delete plbicache;
        return (err? err : ERROR_NOT_ENOUGH_MEMORY);
    }

    HANDLE hEnum;
    err = WNetOpenEnum(uiScope, uiType, uiUsage, lpNetResource, &hEnum);

    if ((err != WN_SUCCESS) && (hwndOwner != NULL))
    {
    	//
    	// If hwndOwner is NULL, we shouldn't put any UI.
    	//

    	//
    	// If it failed because you are not authenticated yet,
    	// we need to let the user loggin to this network resource.
    	//
    	if (err == WN_NOT_AUTHENTICATED
            || err == ERROR_LOGON_FAILURE
            || err == WN_BAD_PASSWORD
            || err == WN_ACCESS_DENIED
            )
        {
            // Retry with password dialog box.
            err = WNetAddConnection3(hwndOwner, lpNetResource, NULL, NULL,
                        CONNECT_TEMPORARY | CONNECT_INTERACTIVE);

            if (err == WN_SUCCESS)
            {
                // Retry WNetOpenEnum.
    		err = WNetOpenEnum(uiScope, uiType, uiUsage, lpNetResource, &hEnum);
            }
        }
    }

    if (err == WN_SUCCESS)
    {
	err = EnumerateShowHelp(
			hEnum,
    			&pmprlbiParent,
			plbicache,
                      	lpNetResource,
                      	pmprlbi,
                      	pmprlb,
    		      	fDeleteChildren,
                      	pfSearchDialogUsed );

    	WNetCloseEnum( hEnum );
    }
    else
    {
	// probable errors: WN_NO_NETWORK, WN_EXTENDED_ERROR, WN_BAD_VALUE,
        // WN_NOT_CONTAINER

        MPRDBGEOL( SZ("EnumerateShow OpenEnum > ") << (ULONG) err );
    }

    //
    //  Add all of the items in a single block to avoid the n^2 sort that would
    //  be done if they were added individually
    //
    if ( plbicache->QueryCount() > 0 )
    {
        plbicache->Sort();
        if ( pmprlb != NULL )
        {
            pmprlb->SetRedraw( FALSE );
            pmprlb->AddSortedItems( (HIER_LBI**) plbicache->QueryPtr(),
                                    plbicache->QueryCount(),
                                    pmprlbiParent );
            pmprlb->SetRedraw( TRUE );
            pmprlb->Invalidate();

            delete plbicache;
            plbicache = NULL;
        }
        else
        {
            UIASSERT( ppmprlbicache != NULL );
            *ppmprlbicache = plbicache;
        }
    }
    else
    {
	// nothing there and it isn't returned; delete the cache.

        delete plbicache;
        plbicache = NULL;
    }

    return err;

}  // ::EnumerateShow


/*******************************************************************

    NAME:       ::EnumerateShowHelp

    SYNOPSIS:   A helper function for EnumerateShow. It handles the
		actual enumeration.

    ENTRY:      
		hEnum - enumeration handle from WNetOpenEnum
    		ppmprlbiParent - parent LBI
    		plbicache - the cache to put elements in
                lpNetResource - Net resource of container (see WNetOpenEnum)
                pmprlbi - Parent LBI to add enumeration to
                pmprlb  - Pointer to the MPR_HIER_LISTBOX
                fDeleteChildren - TRUE if we need to delete the children
                pfSearchDialogUsed

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        BruceFo 13-Sep-1995	Split from EnumerateShow for readability

********************************************************************/

APIERR EnumerateShowHelp(
    		        HANDLE            hEnum,
    			MPR_LBI         **ppmprlbiParent,
    			MPR_LBI_CACHE    *plbicache,
                      	LPNETRESOURCE     lpNetResource,
                      	MPR_LBI          *pmprlbi,
                      	MPR_HIER_LISTBOX *pmprlb,
    		      	BOOL	          fDeleteChildren,
                      	BOOL             *pfSearchDialogUsed )
{
    BUFFER buf( 1024 );
    DWORD err;
    DWORD dwEnumErr = buf.QueryError() ;

    while ( dwEnumErr == NERR_Success )
    {
        DWORD dwCount = 0xffffffff;   // Return as many as possible
        DWORD dwBuffSize = buf.QuerySize() ;

        dwEnumErr = WNetEnumResource( hEnum,
                                      &dwCount,
                                      buf.QueryPtr(),
                                      &dwBuffSize );

        MPRDBGEOL( SZ("EnumerateShow EnumResource >") << (ULONG) dwEnumErr ) ;

        switch ( dwEnumErr )
        {
        case WN_SUCCESS:
        case WN_NO_MORE_ENTRIES:   // Success code, map below
            if ( fDeleteChildren )
            {
                UIASSERT( pmprlb != NULL );
                pmprlb->SetRedraw( FALSE );
                fDeleteChildren = FALSE;
                pmprlb->DeleteChildren( pmprlbi );
                MPR_LBI * pmprlbiTemp = new MPR_LBI( lpNetResource );

                if (  ( pmprlbiTemp == NULL )
                   || ( err = pmprlbiTemp->QueryError() )
		   )
                {
                    delete pmprlbiTemp;
                    pmprlbiTemp = NULL;
                    dwEnumErr = err ? err : ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }
		if ( pmprlb->AddItem( pmprlbiTemp, pmprlbi ) < 0 )
                {
		    // AddItem has already deleted the item we're trying
		    // to add, if it returns -1: don't delete it again.
                    pmprlbiTemp = NULL;
                    dwEnumErr = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }
                *ppmprlbiParent = pmprlbiTemp;
                pmprlb->SetRedraw( TRUE );
            }

            if ( dwEnumErr == WN_SUCCESS )
            {
                //
                // Add the Entries to the listbox with parent pmprlbi
                //

                MPRDBGEOL( SZ("EnumerateShow ")
                        << (ULONG) dwCount << SZ(" Entries returned "));

                NETRESOURCE *pnetres = (NETRESOURCE * )buf.QueryPtr();
                for (INT i = 0; dwCount ; dwCount--, i++ )
                {
                    if ( err = plbicache->AppendItem(
				      new MPR_LBI( &(pnetres[i])))
		       )
                    {
                        dwEnumErr = err ;
                        break ;
                    }

                    // if we are at top (lpNetResource==NULL) and
                    // we've been given a valid pfSearchDialogUsed
                    // pointer, then we go figure out if we need
                    // to display the "Search..." button.
                    if (lpNetResource == NULL &&
                        pfSearchDialogUsed != NULL)
                    {
                        if (::WNetGetSearchDialog(
					pnetres[i].lpProvider) != NULL)
                        {
                            *pfSearchDialogUsed = TRUE ;
                        }
                    }
                }
            }
            break ;

        /* The buffer wasn't big enough for even one entry,
         * resize it and try again.
         */
        case WN_MORE_DATA:
            if ( dwEnumErr = buf.Resize( buf.QuerySize()*2 ))
                break;
            /*
             * Continue looping
             */
            dwEnumErr = WN_SUCCESS;
            break;

        case WN_EXTENDED_ERROR:
        case WN_NO_NETWORK:
            break;

        default:
            MPRDBGEOL(SZ("EnumerateConnections - Unexpected return code from WNetEnumResource"));
            break;
        }  // switch
    } // while

    UIASSERT( sizeof(APIERR) == sizeof( DWORD ));

    return (dwEnumErr==WN_NO_MORE_ENTRIES ) ? NERR_Success : dwEnumErr;

}  // ::EnumerateShowHelp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\mprui\test\makeconn.c ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 2000                **/
/**********************************************************************/

/*
    makeconn.c

    Simple command-line tool to make a deviceless connection given a
    text file containing a username and password

    FILE HISTORY:
        jschwart   24-Apr-2000     Created

*/

#define  STRICT

#include <windows.h>
#include <winnetwk.h>
#include <stdio.h>

#define  MAX_BUFFER    256

int __cdecl
main(
    int  argc,
    char *argv[]
    )
{
    FILE         *fp;
    DWORD        dwErr;
    int          nLen;
    char         szUsername[MAX_BUFFER];
    char         szPassword[MAX_BUFFER];
    NETRESOURCE  nr;

    //
    // Check for the filename and remote name
    //

    if (argc != 3)
    {
        printf("Usage: %s <network share> <filename>\n", argv[0]);
        return 1;
    }

    fp = fopen(argv[2], "r");

    if (fp == NULL)
    {
        printf("Unable to open file %s\n", argv[2]);
        return 1;
    }

    //
    // Username is the first line in the file
    //

    fgets(szUsername, MAX_BUFFER, fp);

    //
    // Password is the second
    //

    fgets(szPassword, MAX_BUFFER, fp);

    fclose(fp);

    //
    // Trim off the trailing newlines that fgets inserts
    //

    szUsername[strlen(szUsername) - 1] = '\0';

    nLen = strlen(szPassword) - 1;

    if (szPassword[nLen] == '\n')
    {
        szPassword[nLen] = '\0';
    }

    ZeroMemory(&nr, sizeof(nr));

    nr.dwType       = RESOURCETYPE_DISK;
    nr.lpRemoteName = argv[1];

    printf("Path %s\n", argv[1]);

    dwErr = WNetAddConnection2(&nr,
                               szPassword,
                               szUsername,
                               0);

    if (dwErr != NO_ERROR)
    {
        printf("Unable to make a connection to %s -- error %d\n", argv[1], dwErr);
        return 1;
    }
    else
    {
        printf("Connection to %s succeeded\n", argv[1]);
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\mprui\mpr\mprbrows.cxx ===
/**********************************************************************/
/**                       Microsoft LAN Manager                      **/
/**             Copyright(c) Microsoft Corp., 1990, 1991             **/
/**********************************************************************/

/*
    mprbrows.cxx
    Browse dialog for mpr.


    FILE HISTORY:
        Yi-HsinS     10-Nov-1992    Separated from mprconn.cxx
        Yi-HsinS     20-Nov-1992    Added support for printer icons
        Yi-HsinS     04-Mar-1993    Added support for multithreading

*/

#include <ntincl.hxx>
extern "C"
{
    #include <ntlsa.h>
}

#define INCL_NETERRORS
#define INCL_WINDOWS_GDI
#define INCL_WINDOWS
#define INCL_DOSERRORS
#define INCL_NETLIB
#define INCL_NETWKSTA
#include <lmui.hxx>

#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MSGPOPUP
#include <blt.hxx>

#include <uitrace.hxx>
#include <regkey.hxx>

extern "C"
{
    #include <mprconn.h>
    #include <npapi.h>
    #include <stdlib.h>     // For qsort()
}

#include <mprmisc.hxx>
#include <mprbrows.hxx>

#define MAX_NET_PATH  MAX_PATH


/*******************************************************************

    NAME:       MPR_BROWSE_BASE::MPR_BROWSE_BASE

    SYNOPSIS:   constructor for base connect dialog

    NOTES:      The use of the ?: operator in DISK vs PRINT means
                that we assume if not DISK, must be PRINT. If more
                types get added, this need to be taken into account.

    HISTORY:
        Kevinl?         ??-Nov-1991         Created
        ChuckC          09-Apr-1992         Added diff MRU keyname support
                                            Added comments/notes.

********************************************************************/
MPR_BROWSE_BASE::MPR_BROWSE_BASE( const TCHAR *pszDialogName,
                                  HWND         hwndOwner,
                                  DEVICE_TYPE  devType,
                                  TCHAR       *lpHelpFile,
                                  DWORD        nHelpContext )
    :   DIALOG_WINDOW         ( pszDialogName, hwndOwner ),
        _uiType               ( (devType == DEV_TYPE_DISK ) ?
                                 RESOURCETYPE_DISK : RESOURCETYPE_PRINT),
        _buttonSearch         ( this, IDC_BUTTON_SEARCH ),
        _buttonOK             ( this, IDOK ),
        _boxExpandDomain      ( this, IDC_CHECKBOX_EXPANDLOGONDOMAIN ),
        _sltShowLBTitle       ( this, IDC_SLT_SHOW_LB_TITLE ),
        _mprhlbShow           ( this, IDC_NET_SHOW,
                                (devType == DEV_TYPE_DISK) ?
                                    RESOURCETYPE_DISK : RESOURCETYPE_PRINT ),
        _sleGetInfo           ( this, IDC_SLE_GETINFO_TEXT ),
        _pMprEnumThread       ( NULL ),
        _nlsProviderToExpand    (),
        _nlsWkstaDomain       (),
        _fSearchDialogUsed    ( FALSE ),

        _nlsHelpFile          ( lpHelpFile ),
        _nHelpContext         ( nHelpContext )
{
    if ( QueryError() != NERR_Success )
        return;

    APIERR err;
    if (  ((err = _nlsHelpFile.QueryError()) != NERR_Success )
       || ((err = _nlsProviderToExpand.QueryError()) != NERR_Success )
       || ((err = _nlsWkstaDomain.QueryError()) != NERR_Success )
       )
    {
        ReportError( err );
        return;
    }

    /* Select the correct text for the device dependent text fields
     */
    MSGID msgidShowLBTitle;
    switch ( QueryType() )
    {
        case RESOURCETYPE_DISK:
            msgidShowLBTitle   = IDS_SERVERS_LISTBOX_DRIVE ;
            break ;
        case RESOURCETYPE_PRINT:
            msgidShowLBTitle   = IDS_SERVERS_LISTBOX_PRINTER ;
            break ;
        default:
            UIASSERT(FALSE) ;
            ReportError( ERROR_INVALID_PARAMETER ) ;
            return ;
    }

    /* Get the top level providers
     */
    err = ::EnumerateShow( QueryHwnd(),
                           RESOURCE_GLOBALNET,
                           _uiType,
                           0,
                           NULL,
                           NULL,
                           &_mprhlbShow,
                           FALSE,
                           &_fSearchDialogUsed,
                           NULL );

    if ( err != NERR_Success )
    {
        ReportError( err );
        return;
    }
    _mprhlbShow.CalcMaxHorizontalExtent() ;
    _buttonSearch.Show( _fSearchDialogUsed );

    /* Set the title of the listbox
     */
    RESOURCE_STR nlsShowLBTitle( msgidShowLBTitle ) ;
    if ( err = nlsShowLBTitle.QueryError() )
    {
        ReportError( err ) ;
        return ;
    }
    _sltShowLBTitle.SetText( nlsShowLBTitle ) ;

    //
    // Get the name of provider to expand and the domain name the
    // workstation is in if we need to.
    //
    BOOL fExpandFirstProvider = IsExpandDomain();
    _boxExpandDomain.SetCheck( fExpandFirstProvider );

    if ( fExpandFirstProvider )
    {
        BOOL fProviderToExpandIsNT ;
        RESOURCE_STR nlsGettingInfo( IDS_GETTING_INFO ) ;

        //
        //   find the first in order and if it is NT
        //
        if (  (( err = nlsGettingInfo.QueryError()) != NERR_Success )
           || ((err = QueryProviderToExpand(&_nlsProviderToExpand,
                                            &fProviderToExpandIsNT))
               != NERR_Success) )
        {
            ReportError( err );
            return;
        }

        //
        //  if it is NT, we special case and need expand domain.
        //  so lets go find out what domain we are in,
        //
        if (fProviderToExpandIsNT)
        {
            err = QueryWkstaDomain( &_nlsWkstaDomain ) ;
            if (err != NERR_Success ||
               (err = _nlsWkstaDomain.QueryError()) != NERR_Success)
            {
                if ( (err = _nlsWkstaDomain.CopyFrom(SZ(""))) != NERR_Success )
                {
                    ReportError( err );
                    return;
                }
            }
        }

        INT index = _mprhlbShow.FindItem( _nlsProviderToExpand, 0 );

        if ( index >= 0 )
        {
            /* Disable the listbox until we get all the data
             */
            _sleGetInfo.SetText( nlsGettingInfo ) ;
            ShowMprListbox( FALSE );
            return;
        }

        // At this point, we cannot find provider in the listbox.
        // Hence, we don't need to expand the listbox.
    }


    /* Don't need to start the second thread here.
     * So, we can show the listbox right away.
     */
    ShowMprListbox( TRUE );

}  // MPR_BROWSE_BASE::MPR_BROWSE_BASE


/*******************************************************************

    NAME:       MPR_BROWSE_BASE::~MPR_BROWSE_BASE

    SYNOPSIS:   desstructor for base connect dialog

    NOTES:

    HISTORY:
        YiHsinS        04-Mar-1993        Created

********************************************************************/
MPR_BROWSE_BASE::~MPR_BROWSE_BASE()
{
    if ( _pMprEnumThread != NULL )
    {
        _pMprEnumThread->ExitThread();

        // Do not delete the thread object, it will delete itself
        _pMprEnumThread = NULL;
    }

}  // MPR_BROWSE_BASE::~MPR_BROWSE_BASE

/*******************************************************************

    NAME:       MPR_BROWSE_BASE::ShowMprListbox

    SYNOPSIS:   Enable and show the listbox

    NOTES:

    HISTORY:
        YiHsinS 04-Mar-1993     Created

********************************************************************/
VOID MPR_BROWSE_BASE::ShowMprListbox( BOOL fShow )
{
    _sltShowLBTitle.Enable( fShow ) ;
    _mprhlbShow.Enable( fShow );
    _sleGetInfo.Show( !fShow );
    _mprhlbShow.Show( fShow );

}

/*******************************************************************

    NAME:       MPR_BROWSE_BASE::MayRun

    SYNOPSIS:   Start the second thread to get the data

    NOTES:

    HISTORY:
        YiHsinS 04-Mar-1993 Created

********************************************************************/
BOOL MPR_BROWSE_BASE::MayRun( VOID )
{
    /* Start the second thread to get the data only if we need to
     * expand the provider and domain
     */
    if ( IsExpandDomain() )
    {
        APIERR err = NERR_Success;

        /*
         * Find the NETRESOURCE of the provider. In the dialog
         * constructor, we already check to make sure that the provider
         * indeed exist in the listbox.
         */
        INT index = _mprhlbShow.FindItem( _nlsProviderToExpand, 0 );
        UIASSERT( index >= 0 );
        MPR_LBI *pmprlbi = (MPR_LBI *) _mprhlbShow.QueryItem( index );
        UIASSERT( pmprlbi != NULL );

        _pMprEnumThread = new MPR_ENUM_THREAD( QueryHwnd(),
                                               QueryType(),
                                               pmprlbi->QueryLPNETRESOURCE(),
                                               _nlsWkstaDomain );

        if (  ( _pMprEnumThread == NULL )
           || ( (err = _pMprEnumThread->QueryError()) != NERR_Success )
           || ( (err = _pMprEnumThread->Resume()) != NERR_Success )
           )
        {
            delete _pMprEnumThread;
            _pMprEnumThread = NULL;

            err = err? err : ERROR_NOT_ENOUGH_MEMORY;
            ::MsgPopup( this, err );
            return FALSE;
        }
    }

    return TRUE;
}

/*******************************************************************

    NAME:       MPR_BROWSE_BASE::OnShowResourcesChange

    SYNOPSIS:   This method is called when the user takes an action in
                the Show Resources listbox.

    ENTRY:      fEnumChildren - TRUE if the children for the current node in
                the "Show" listbox should be enumerated, FALSE otherwise.
                In general, the children are only enumerated on an
                "expansion" event (double click or enter key).

    RETURN:     An error value, which is NERR_Success on success.

    HISTORY:
        rustanl         ??-Nov-1991         Created
        Johnl           10-Jan-1992         Added Wait indicator

********************************************************************/

APIERR MPR_BROWSE_BASE::OnShowResourcesChange( BOOL fEnumChildren )
{
    AUTO_CURSOR hourglass ;
    APIERR err = NERR_Success;

    //  Get the current listbox data item.  This item is a pointer to
    //  an MPR_LBI.     There must be a selection; otherwise, we shouldn't
    //  have been called.
    MPR_LBI * pmprlbi = (MPR_LBI *)_mprhlbShow.QueryItem();

    //  QueryItem() can fail if its call to SendMessage fails

    if (pmprlbi == NULL)
    {
        return ERROR_GEN_FAILURE;
    }

    //  Update the Network Path MRU if an item was selected

    if ( pmprlbi->IsConnectable() )
    {
        SetNetPathString( pmprlbi->QueryRemoteName() );
        SetLastProviderInfo( pmprlbi->QueryLPNETRESOURCE()->lpProvider,
                             pmprlbi->QueryRemoteName());
    }
    else
        ClearNetPathString();

    //  Clear the Resources listbox and turn its redraw switch off.
    //  Then, call the appropriate virtual method to fill it in.
    //  If nothing was added to the listbox, it is disabled; otherwise, it
    //  is enabled.  (Enable/disable affect keyboard and mouse input.)
    //  Lastly, the redraw switch is turned on, and the listbox is invalidated.


    if ( pmprlbi->IsContainer() && fEnumChildren )
    {
        //
        // Fill lb with children if they haven't been added
        // already
        //
        if ( !pmprlbi->QueryExpanded() && pmprlbi->IsRefreshNeeded() )
        {
            _mprhlbShow.DeleteChildren( pmprlbi );
            pmprlbi->SetRefreshNeeded( FALSE );
        }

        if ( !pmprlbi->HasChildren() )
        {
            // Enumerate Children
            err = ::EnumerateShow( QueryHwnd(),
                                   RESOURCE_GLOBALNET,
                                   QueryType(),
                                   0,
                                   pmprlbi->QueryLPNETRESOURCE(),
                                   pmprlbi,
                                   &_mprhlbShow );
        }
    }

    // finally, enanle/disable the search button if need (ie. at least
    // one provider is using it.
    if (_fSearchDialogUsed)
        _buttonSearch.Enable(pmprlbi->IsSearchDialogSupported()) ;

    return err;

}  // MPR_BROWSE_BASE::OnShowResourcesChange

/*******************************************************************

    NAME:       MPR_BROWSE_BASE::OnOK

    SYNOPSIS:   Set the expand domain checkbox

    NOTES:

    HISTORY:
        YiHsinS 04-Mar-1993 Created

********************************************************************/
BOOL MPR_BROWSE_BASE::OnOK( void )
{
    if ( !SetExpandDomain( _boxExpandDomain.QueryCheck() ))
        ::MsgPopup(this, IERR_CANNOT_SET_EXPANDLOGONDOMAIN );

    return TRUE;
}

/*******************************************************************

    NAME:       MPR_BROWSE_BASE::OnCommand

    SYNOPSIS:

    NOTES:

    HISTORY:

********************************************************************/
BOOL MPR_BROWSE_BASE::OnCommand( const CONTROL_EVENT & event )
{
    switch ( event.QueryCid() )
    {
    case IDC_NET_SHOW:
        switch ( event.QueryCode() )
        {
            case LBN_SELCHANGE:
                // No error will occur when not enumerating children
                OnShowResourcesChange();
                return TRUE;

            case LBN_DBLCLK:
                {
                    MPR_LBI * pmprlbi = (MPR_LBI *) _mprhlbShow.QueryItem();

                    if ( ShowSearchDialogOnDoubleClick( pmprlbi ) )
                        return TRUE;

                    APIERR err = OnShowResourcesChange( TRUE );

                    switch ( err )
                    {
                        case WN_SUCCESS:
                            break ;

                        case WN_EXTENDED_ERROR:
                            MsgExtendedError( this->QueryRobustHwnd() ) ;
                            break ;

                        case ERROR_GEN_FAILURE:
                            err = ERROR_UNEXP_NET_ERR ;   // more friendly error
                            // drop thru

                        default:
                            MsgPopup( this, (MSGID) err ) ;
                            break ;
                    }

                    if (( err == NERR_Success )
                           &&
                        ( pmprlbi != NULL ))
                    {
                        if ( pmprlbi->IsContainer())
                        {
                            //
                            // OnDoubleClick may call AddChildren (which does
                            // another enum if there are no children). But
                            // since we have already done the enum and we know
                            // there are no children, skip this.
                            //
                            if ( pmprlbi->HasChildren() )
                            {
                                _mprhlbShow.OnDoubleClick( (HIER_LBI *) pmprlbi );
                                _mprhlbShow.CalcMaxHorizontalExtent() ;
                            }
                        }
                        else
                            return OnOK();
                    }
                }
                return TRUE ;

            default:
                break;
        }
        break;

    case IDC_BUTTON_SEARCH:
        {
            UIDEBUG(SZ("Search button was pressed")) ;
            MPR_LBI * pmprlbi = (MPR_LBI *) QueryShowLB()->QueryItem();
            if (pmprlbi != NULL)
            {
                CallSearchDialog(pmprlbi) ;
            }
        }
        return TRUE ;

    default:
        break;

    }

    return DIALOG_WINDOW::OnCommand( event );

}  // MPR_BROWSE_BASE::OnCommand

/*******************************************************************

    NAME:       MPR_BROWSE_BASE::OnUserMessage

    SYNOPSIS:   Standard on user processing.  Catches the WM_LB_FILLED
                response and fills the listbox

    NOTES:

    HISTORY:
        YiHsinS   07-Mar-1992     Created

********************************************************************/

BOOL MPR_BROWSE_BASE::OnUserMessage( const EVENT & event )
{
    APIERR err = NERR_Success ;

    switch ( event.QueryMessage() )
    {
    case WM_LB_FILLED:
        {
            // If listbox is already enabled, then the user has tried
            // to expand a server that he has typed into the path sle.
            // Hence, the listbox is already filled with the necessary
            // information. So, we just ignore the cache returned to us.

            if ( _mprhlbShow.IsEnabled() )
                return TRUE;

            BOOL fError = (BOOL) event.QueryWParam();

            if ( fError )  // Error occurred in the other thread
            {
                RESOURCE_STR nlsError( (APIERR) event.QueryLParam() );

                if ( (err = nlsError.QueryError()) != NERR_Success )
                    ::MsgPopup( this, err );
                else
                    _sleGetInfo.SetText( nlsError );
                return TRUE;
            }

            //
            // Successfully retrieved data in the other thread
            //
            MPR_RETURN_CACHE *p = (MPR_RETURN_CACHE *) event.QueryLParam() ;

            _mprhlbShow.SetRedraw( FALSE );

            if ( IsExpandDomain() )
            {
                if ( !Expand( _nlsProviderToExpand, 0, p->pcacheDomain ) )
                {
                    // Cannot expand the provider name, set the selection
                    // to the first item
                    _mprhlbShow.SelectItem( 0 );
                }
                else
                {
                    // If this is not successful, then the selection is the
                    // provider name ( expanded ) which is what we want
                    Expand( _nlsWkstaDomain, 1, p->pcacheServer, TRUE );
                }
            }

            _mprhlbShow.CalcMaxHorizontalExtent() ;
            _mprhlbShow.Invalidate( TRUE );
            _mprhlbShow.SetRedraw( TRUE );

            ShowMprListbox( TRUE );

            MPR_LBI *pmprlbi = (MPR_LBI *) _mprhlbShow.QueryItem();

            /* QueryItem() can fail if its call to SendMessage fails
             */
            if ( (pmprlbi != NULL) && _fSearchDialogUsed )
                _buttonSearch.Enable( pmprlbi->IsSearchDialogSupported());

            delete p->pcacheDomain;
            p->pcacheDomain = NULL;
            delete p->pcacheServer;
            p->pcacheServer = NULL;
        }
        break ;

    default:
        return DIALOG_WINDOW::OnUserMessage( event ) ;
    }

    return TRUE;
}

void MPR_BROWSE_BASE::CallSearchDialog( MPR_LBI *pmprlbi )
{
    APIERR err ;
    TCHAR szNetPath[MAX_NET_PATH] ;
    LPNETRESOURCE lpNetRes =  pmprlbi->QueryLPNETRESOURCE() ;

    PF_NPSearchDialog pfn = (PF_NPSearchDialog)
        ::WNetGetSearchDialog(lpNetRes ? lpNetRes->lpProvider : NULL ) ;

    DWORD lpnFlags;

    if (pfn)
    {
        err = (*pfn)(QueryRobustHwnd(),
                     lpNetRes,
                     szNetPath,
                     sizeof(szNetPath)/sizeof(szNetPath[0]),
                     &lpnFlags);
    }
    else
    {
        err = WN_NOT_SUPPORTED;
    }

    if (err == WN_SUCCESS)
    {
        SetNetPathString( szNetPath );
        SetFocusToNetPath();
        if ( lpnFlags == WNSRCH_REFRESH_FIRST_LEVEL )
        {
            AUTO_CURSOR autocur;

            MPR_HIER_LISTBOX *plb = QueryShowLB();
            INT nPrevProvider = plb->FindNextProvider( 0 );
            UIASSERT ( nPrevProvider >= 0 );

            INT nNextProvider = plb->FindNextProvider( nPrevProvider + 1);
            INT nCurrent = plb->QueryCurrentItem();

            do {
                if (  ( nCurrent >= nPrevProvider )
                   && (  ( nCurrent < nNextProvider )
                      || ( nNextProvider < 0 )
                      )
                   )
                {
                    MPR_LBI *plbi = (MPR_LBI *) plb->QueryItem( nPrevProvider );
                    UIASSERT ( plbi != NULL );
                    plb->CollapseItem( plbi );
                    plb->SelectItem( nPrevProvider );
                    plb->DeleteChildren( plbi );

                    // Enumerate Children
                    err = ::EnumerateShow( QueryHwnd(),
                       RESOURCE_GLOBALNET,
                                           QueryType(),
                                           0,
                                           plbi->QueryLPNETRESOURCE(),
                                           plbi,
                                           &_mprhlbShow );
                    err = err ? err : plb->ExpandItem( plbi );
                    break;
                }
                else if ( nPrevProvider < 0 )
                {
                    UIASSERT( FALSE );
                    break;
                }

                nPrevProvider = nNextProvider;
                nNextProvider = plb->FindNextProvider( nPrevProvider + 1);

            } while ( TRUE );
        }
        _mprhlbShow.CalcMaxHorizontalExtent() ;
    }

    if ( err != WN_SUCCESS )
        ::MsgPopup( this, err );
}

/*******************************************************************

    NAME:       MPR_BROWSE_BASE::ShowSearchDialogOnDoubleClick

    SYNOPSIS:   This method is called when the user double clicks
                an item in the listbox or select an time/hit Enter key
                in the listbox.

    ENTRY:  pmprlbi - the item selected in the listbox

    RETURN:     TRUE if we have shown the search dialog, FALSE otherwise.

    NOTES:      We will only show the search dialog only if the item
                is a provider that supports the search dialog but
                not global enumeration.

    HISTORY:
        Yi-HsinS    30-Nov-1992 Created

********************************************************************/

BOOL MPR_BROWSE_BASE::ShowSearchDialogOnDoubleClick( MPR_LBI *pmprlbi )
{
    if (  ( pmprlbi != NULL )
       && ( pmprlbi->IsProvider() )
       )
    {
         if (  !pmprlbi->QueryExpanded()
            && pmprlbi->IsSearchDialogSupported()
            && !WNetSupportGlobalEnum((TCHAR *) pmprlbi->QueryRemoteName())
            )
         {
             CallSearchDialog(pmprlbi) ;
             return TRUE;
         }
    }

    return FALSE;
}

/*******************************************************************

    NAME:       MPR_BROWSE_BASE::QueryWkstaDomain

    SYNOPSIS:   Get the user's logged on domain

    ENTRY:  pnlsWkstaDomain - NLS_STR to receive domain

    EXIT:   pnlsWkstaDomain will contain the user name or the empty string

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
    Yi-HsinS    4-Nov-1992  Created

********************************************************************/

#define NETAPI_DLL_STRING     SZ("netapi32.dll")
#define NETWKSTAUSERGETINFO   ("NetWkstaGetInfo")
#define NETAPIBUFFERFREE      ("NetApiBufferFree")

typedef APIERR (*PNETWKSTAUSERGETINFO)( const TCHAR FAR *, DWORD, BYTE FAR **);
typedef APIERR (*PNETAPIBUFFERFREE)( BYTE * );

APIERR MPR_BROWSE_BASE::QueryWkstaDomain( NLS_STR *pnlsWkstaDomain )
{
    *pnlsWkstaDomain = SZ("");

    HMODULE hmod = ::LoadLibraryEx( NETAPI_DLL_STRING,
                                    NULL,
                                    LOAD_WITH_ALTERED_SEARCH_PATH );
    if ( hmod == NULL )
        return ::GetLastError();

    APIERR err;

    PNETWKSTAUSERGETINFO plpfn;
    plpfn = (PNETWKSTAUSERGETINFO) ::GetProcAddress( hmod, NETWKSTAUSERGETINFO);

    if ( plpfn == NULL )
    {
        err = ::GetLastError();
    }
    else
    {
        WKSTA_INFO_100 *pwki100 = NULL;
        err = (*plpfn)( NULL, 100, (BYTE **) &pwki100 );
        if ( err == NERR_Success )
        {
            err = pnlsWkstaDomain->CopyFrom( pwki100->wki100_langroup );
        }

        PNETAPIBUFFERFREE plpfnBufferFree;
        plpfnBufferFree = (PNETAPIBUFFERFREE) ::GetProcAddress( hmod, NETAPIBUFFERFREE );

        if ( plpfnBufferFree != NULL )
        {
            // The error code is not interesting here
            // We got the logon name and we'll just trying to free the
            // buffer if possible
            (*plpfnBufferFree)( (BYTE *) pwki100 );
        }
    }

    ::FreeLibrary( hmod );
    return err;
}

/*******************************************************************

    NAME:       MPR_BROWSE_BASE::QueryProviderToExpand

    SYNOPSIS:   Get the lanman provider name

    ENTRY:  pnlsProvider - NLS_STR to receive lanman provider name

    EXIT:   pnlsProvider will contain the provider name or the
                empty string

                contents of pfIsNT is TRUE if the provider picked in
                NT Lanman. else tis FALSE

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
    Yi-HsinS    4-Nov-1992  Created

********************************************************************/

#define LANMAN_WORKSTATION_NODE SZ("System\\CurrentControlSet\\Services\\LanmanWorkstation\\networkprovider")
#define PROVIDER_VALUE_NAME SZ("Name")

APIERR MPR_BROWSE_BASE::QueryProviderToExpand( NLS_STR *pnlsProvider,
                                               BOOL    *pfIsNT )
{
    //
    // init some defaults
    //
    *pnlsProvider = SZ("");
    *pfIsNT = FALSE ;

    APIERR err ;
    NLS_STR nlsLanmanProvider;
    if ((err = nlsLanmanProvider.QueryError()) != NERR_Success)
        return err ;

    //
    // get the NT supplied provider if we can
    //
    REG_KEY *pRegKeyLocalMachine = REG_KEY::QueryLocalMachine();
    if (  ( pRegKeyLocalMachine == NULL )
       || ( (err = pRegKeyLocalMachine->QueryError()) != NERR_Success )
       )
    {
        //
        // if an error occurs just set the LM provider to be empty
        //
        err = nlsLanmanProvider.CopyFrom(SZ("")) ;
    }
    else
    {
        //
        // get the name from registry
        //
        ALIAS_STR nlsNode( LANMAN_WORKSTATION_NODE );
        REG_KEY regkey( *pRegKeyLocalMachine, nlsNode );
        if (  ((err = regkey.QueryError()) != NERR_Success )
           || ((err = regkey.QueryValue( PROVIDER_VALUE_NAME,
                                         &nlsLanmanProvider ))
               != NERR_Success )
           )
        {
            //
            // if an error occurs just set the LM provider to be empty
            //
            err = nlsLanmanProvider.CopyFrom(SZ("")) ;
        }
    }

    delete pRegKeyLocalMachine;
    pRegKeyLocalMachine = NULL;
    if (err != NERR_Success)
        return err ;

    //
    // now call WNet to enum the providers, and pick the first in order.
    // this will be the one we choose to expand.
    //
    HANDLE hEnum;
    BOOL   fFoundOne = FALSE ;
    DWORD  dwErr = WNetOpenEnum( RESOURCE_GLOBALNET,
                                 RESOURCETYPE_DISK,
                                 0,
                                 NULL,
                                 &hEnum );
    if (dwErr == WN_SUCCESS)
    {
        BUFFER buf( 1024 );
        DWORD dwEnumErr = buf.QueryError() ;

        while ( dwEnumErr == NERR_Success )
        {
            DWORD dwCount = 0xffffffff;   // Return as many as possible
            DWORD dwBuffSize = buf.QuerySize() ;
            dwEnumErr = WNetEnumResource( hEnum,
                                          &dwCount,
                                          buf.QueryPtr(),
                                          &dwBuffSize );
            switch ( dwEnumErr )
            {
            case WN_SUCCESS:
                //
                // just use the very first entry
                //
                if (dwCount >= 1)
                {
                    NETRESOURCE *pnetres = (NETRESOURCE * )buf.QueryPtr();
                    *pnlsProvider = pnetres->lpRemoteName ;
                    fFoundOne = TRUE ;
                    err = pnlsProvider->QueryError() ;
                }

                //
                // exit the loop by setting this
                //
                dwEnumErr = WN_NO_MORE_ENTRIES ;
                break ;

            //
            // The buffer wasn't big enough for even one entry,
            // resize it and try again.
            //
            case WN_MORE_DATA:

                if ( dwEnumErr = buf.Resize( buf.QuerySize()*2 ))
                   break;

                //
                // Continue looping
                //
                dwEnumErr = WN_SUCCESS;
                break;

            case WN_NO_MORE_ENTRIES:   // Success code, map below
            default:
                //
                // all errors will cause us to exit
                //
                break;

            }  // switch

        } // while

        WNetCloseEnum( hEnum );
    }

    if (err)
        return err ;

    if (fFoundOne)
    {
         //
         // since err was not set, we know pnlsProvider is all setup.
         // all we need do is set fIsNT.
         //
         *pfIsNT = (*pnlsProvider == nlsLanmanProvider) ;
    }

    return NERR_Success ;
}




/*******************************************************************

    NAME:       MPR_BROWSE_BASE::Expand

    SYNOPSIS:   Find the given item in the listbox and expand it

    ENTRY:  psz       - The item to search for
                nLevel    - The indentation level of the item
                fTopIndex - TRUE if we want to set the item to top index

    EXIT:

    RETURNS:    TRUE if we can at least find and select the item requested,
                FALSE otherwise

    NOTES:

    HISTORY:
    Yi-HsinS    4-Nov-1992  Created

********************************************************************/

BOOL MPR_BROWSE_BASE::Expand( const TCHAR *psz,
                              INT nLevel,
                              MPR_LBI_CACHE *pcache,
                              BOOL fTopIndex )
{
    if (psz == NULL || *psz == 0)
        return FALSE ;

    INT index = _mprhlbShow.FindItem( psz, nLevel );

    if ( index < 0 )
        return FALSE;

    _mprhlbShow.SelectItem( index );

    if (  ( pcache != NULL )
       && ( pcache->QueryCount() != 0 )
       )
    {
        MPR_LBI * pmprlbi = (MPR_LBI *) _mprhlbShow.QueryItem();

        UIASSERT( pmprlbi != NULL);

        _mprhlbShow.AddSortedItems( (HIER_LBI **) pcache->QueryPtr(),
                                    pcache->QueryCount(),
                                    pmprlbi );

        if ( pmprlbi->IsContainer() )
            _mprhlbShow.OnDoubleClick( (HIER_LBI *) pmprlbi );
    }

    if ( fTopIndex )
        _mprhlbShow.SetTopIndex( index );

    return TRUE;
}

/*******************************************************************

    NAME:       MPR_BROWSE_BASE::QueryHelpFile

    SYNOPSIS:   overwrites the default QueryHelpFile in DIALOG_WINDOW
        to use an app supplied help rather than NETWORK.HLP if
        we were given onr at construct time.

    ENTRY:

    EXIT:

    RETURNS:    a pointer to a string which is the help file to use.

    NOTES:

    HISTORY:
        ChuckC   26-Cct-1992     Created

********************************************************************/
const TCHAR * MPR_BROWSE_BASE::QueryHelpFile( ULONG nHelpContext )
{
    //
    // if we were given a helpfile at construct time,
    // we use the given help file.
    //
    const TCHAR *pszHelpFile = QuerySuppliedHelpFile() ;

    if (pszHelpFile && *pszHelpFile)
    {
        return pszHelpFile ;
    }
    return DIALOG_WINDOW::QueryHelpFile(nHelpContext) ;
}

/*******************************************************************

    NAME:       MPR_BROWSE_BASE::IsExpandDomain

    SYNOPSIS:   see if user wants to expand the logon domain at startup

    ENTRY:

    EXIT:

    RETURNS:    TRUE or FALSE

    NOTES:

    HISTORY:
        Yi-HsinS    4-Nov-1992     Created

********************************************************************/

BOOL MPR_BROWSE_BASE::IsExpandDomain( VOID )
{
    // By adding the two, we are guaranteed to have enough
    TCHAR szAnswer[(sizeof(MPR_YES_VALUE)+sizeof(MPR_NO_VALUE))/sizeof(TCHAR)];
    ULONG len = sizeof(szAnswer)/sizeof(szAnswer[0]);

    ULONG iRes = ::GetProfileString((const TCHAR *)MPR_NETWORK_SECTION,
                                    (const TCHAR *)MPR_EXPANDLOGONDOMAIN_KEY,
                                    (const TCHAR *)MPR_YES_VALUE,
                                    szAnswer,
                                    len);
    if (iRes == len)  // error
        return(TRUE);

    return( ::stricmpf(szAnswer,(const TCHAR *)MPR_YES_VALUE)==0 );
}

/*******************************************************************

    NAME:       MPR_BROWSE_BASE::SetExpandDomain

    SYNOPSIS:   sets the ExpandLogonDomain bit in user profile

    ENTRY:

    EXIT:

    RETURNS:    BOOL indicating success (TRUE) or failure (FALSE)

    NOTES:

    HISTORY:
        Yi-HsinS   4-Nov-1992     Created

********************************************************************/

BOOL MPR_BROWSE_BASE::SetExpandDomain(BOOL fExpand)
{
    return(::WriteProfileString( (const TCHAR *)MPR_NETWORK_SECTION,
                                 (const TCHAR *)MPR_EXPANDLOGONDOMAIN_KEY,
                                 fExpand? (const TCHAR *)MPR_YES_VALUE
                                        : (const TCHAR *)MPR_NO_VALUE ) != 0) ;
}


/*******************************************************************

    NAME:       MPR_BROWSE_DIALOG::MPR_BROWSE_DIALOG

    SYNOPSIS:   Constructor for the browse dialog.  Almost all of the
                functionality is contained in the base class, we watch
                for the OK button here.

    ENTRY:      hwndOwner - Owner window handle
                devType   - Type of device we are dealing with

    RETURNS:

    NOTES:

    HISTORY:
        Johnl   27-Jan-1992     Created

********************************************************************/

MPR_BROWSE_DIALOG::MPR_BROWSE_DIALOG( HWND         hwndOwner,
                                     DEVICE_TYPE  devType,
                         TCHAR       *lpHelpFile,
                                     DWORD        nHelpContext,
                         NLS_STR     *pnlsPath,
                                     PFUNC_VALIDATION_CALLBACK pfuncValidation)
    : MPR_BROWSE_BASE ( MAKEINTRESOURCE(IDD_NET_BROWSE_DIALOG),
                        hwndOwner,
                        devType,
                lpHelpFile,
                        nHelpContext ),
      _sleNetPath     ( this, IDC_NETPATH_CONTROL ),
      _pnlsPath       ( pnlsPath ),
      _pfuncValidation( pfuncValidation )
{

    UIASSERT( pnlsPath != NULL );

    if ( QueryError() )
        return ;

    RESOURCE_STR nlsTitle( devType==DEV_TYPE_DISK? IDS_BROWSE_DRIVE_CAPTION
                                                 : IDS_BROWSE_PRINTER_CAPTION);
    APIERR err = nlsTitle.QueryError();
    if (err != NERR_Success )
    {
        ReportError( err ) ;
        return ;
    }
    SetText( nlsTitle ) ;

    //  Set focus to the Network Path field
    SetFocusToNetPath();
}

MPR_BROWSE_DIALOG::~MPR_BROWSE_DIALOG()
{
    /* Nothing to do */
}

/*******************************************************************

    NAME:       MPR_BROWSE_DIALOG::OnOK

    SYNOPSIS:   The user pressed the OK button so try the following:

                If net path is not empty,
                    attempt to connect to the server in the net path
                else if current item in show listbox is expandable
                    attempt to expand that item

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Johnl   27-Jan-1992     Created

********************************************************************/

BOOL MPR_BROWSE_DIALOG::OnOK( void )
{
    if ( QueryShowLB()->HasFocus() && ( _sleNetPath.QueryTextLength() == 0 ))
    {
        MPR_LBI * pmprlbi = (MPR_LBI *) QueryShowLB()->QueryItem();
        if ( pmprlbi )
        {
            if ( !ShowSearchDialogOnDoubleClick( pmprlbi ) )
                QueryShowLB()->OnDoubleClick( (HIER_LBI *) pmprlbi );
        }
    }
    else
    {
        APIERR err = _sleNetPath.QueryText( _pnlsPath );
        if ( err == NERR_Success )
        {

            if (  ( _pfuncValidation == NULL )
               || ((*_pfuncValidation)( (LPTSTR) _pnlsPath->QueryPch() ) )
               )
            {
                Dismiss( TRUE );
            }
            else
            {
                err = IERR_INVALID_PATH;
            }
        }

        if ( err != NERR_Success )
        {
            ::MsgPopup( this, err );
            _sleNetPath.SelectString();
            _sleNetPath.ClaimFocus();
        }
    }
    return MPR_BROWSE_BASE::OnOK() ;
}

/*******************************************************************

    NAME:       MPR_BROWSE_DIALOG::QueryHelpContext

    SYNOPSIS:   Typical help context method

    HISTORY:
        Johnl   27-Jan-1992     Created

********************************************************************/

ULONG MPR_BROWSE_DIALOG::QueryHelpContext( void )
{
    return QuerySuppliedHelpContext() ;
}

/*******************************************************************

    NAME:       MPR_HIER_LISTBOX::MPR_HIER_LISTBOX

    SYNOPSIS:   Constructor

    ENTRY:      powin - pointer to owner window
                cid   - control id

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Johnl   30-Jan-1992     Commented

********************************************************************/

MPR_HIER_LISTBOX::MPR_HIER_LISTBOX( OWNER_WINDOW * powin, CID cid, UINT uiType )
    : HIER_LISTBOX( powin, cid, FALSE, FONT_DEFAULT, FALSE ),
      _dmapGeneric        ( BMID_BROWSE_GEN ),
      _dmapGenericExpanded( BMID_BROWSE_GENEX ),
      _dmapGenericNoExpand( BMID_BROWSE_GENNOX ),
      _dmapProvider       ( BMID_BROWSE_PROV),
      _dmapProviderExpanded( BMID_BROWSE_PROVEX ),
      _dmapDomain         ( BMID_BROWSE_DOM ),
      _dmapDomainExpanded ( BMID_BROWSE_DOMEX ),
      _dmapDomainNoExpand ( BMID_BROWSE_DOMNOX ),
      _dmapServer         ( BMID_BROWSE_SRV ),
      _dmapServerExpanded ( BMID_BROWSE_SRVEX ),
      _dmapServerNoExpand ( BMID_BROWSE_SRVNOX ),
      _dmapFile           ( BMID_BROWSE_FILE ),
      _dmapFileExpanded   ( BMID_BROWSE_FILEEX ),
      _dmapFileNoExpand   ( BMID_BROWSE_FILENOX ),
      _dmapTree           ( BMID_BROWSE_TREE ),
      _dmapTreeExpanded   ( BMID_BROWSE_TREEEX ),
      _dmapTreeNoExpand   ( BMID_BROWSE_TREENOX ),
      _dmapGroup          ( BMID_BROWSE_GROUP ),
      _dmapGroupExpanded  ( BMID_BROWSE_GROUPEX ),
      _dmapGroupNoExpand  ( BMID_BROWSE_GROUPNOX ),
      _dmapShare          ( uiType == DEV_TYPE_DISK? BMID_BROWSE_SHR
                           : BMID_BROWSE_PRINT ),
      _dmapShareExpanded  ( uiType == DEV_TYPE_DISK? BMID_BROWSE_SHREX
                           : BMID_BROWSE_PRINTEX ),
      _dmapShareNoExpand  ( uiType == DEV_TYPE_DISK? BMID_BROWSE_SHRNOX
                               : BMID_BROWSE_PRINTNOX ),
      _uiType             ( uiType ),
      _nMaxPelIndent      (0)
{

    if ( QueryError() )
        return ;

    APIERR err ;
    if ( (err = _dmapGeneric.QueryError())         ||
         (err = _dmapGenericExpanded.QueryError()) ||
         (err = _dmapGenericNoExpand.QueryError()) ||
         (err = _dmapDomain.QueryError())          ||
         (err = _dmapDomainExpanded.QueryError())  ||
         (err = _dmapDomainNoExpand.QueryError())  ||
         (err = _dmapShare.QueryError())           ||
         (err = _dmapShareExpanded.QueryError())   ||
         (err = _dmapShareNoExpand.QueryError())   ||
         (err = _dmapServer.QueryError())          ||
         (err = _dmapServerExpanded.QueryError())  ||
         (err = _dmapServerNoExpand.QueryError())  ||
         (err = _dmapFile.QueryError())            ||
         (err = _dmapFileExpanded.QueryError())    ||
         (err = _dmapFileNoExpand.QueryError())    ||
         (err = _dmapTree.QueryError())            ||
         (err = _dmapTreeExpanded.QueryError())    ||
         (err = _dmapTreeNoExpand.QueryError())    ||
         (err = _dmapGroup.QueryError())           ||
         (err = _dmapGroupExpanded.QueryError())   ||
         (err = _dmapGroupNoExpand.QueryError())   ||
         (err = DISPLAY_TABLE::CalcColumnWidths( _adxColumns,
                                                 4,
                                                 powin,
                                                 QueryCid(),
                                                 FALSE ))   )
    {
        ReportError( err ) ;
        return ;
    }

    DISPLAY_CONTEXT dc( QueryHwnd() );
    dc.SelectFont( QueryFont() );
    // JonN 6/18/95 remove unnecessary floating point
    _nAveCharWidth = (dc.QueryAveCharWidth() * 3) / 2;

}

MPR_HIER_LISTBOX::~MPR_HIER_LISTBOX()
{
    /* Nothing to do */
}

/*******************************************************************

    NAME:       MPR_HIER_LISTBOX::AddChildren

    SYNOPSIS:   Redefined virtual to add enumerate the children of the
                passed parent.

    ENTRY:      phlbi - Parent LBI to enumerate children under

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Johnl   30-Jan-1992     Commented, made non-static

********************************************************************/

APIERR MPR_HIER_LISTBOX::AddChildren( HIER_LBI * phlbi )
{
    UIASSERT( phlbi != NULL );

    return ::EnumerateShow( QueryHwnd(),
                RESOURCE_GLOBALNET,
                            QueryType(),
                            0,
                            ((MPR_LBI *)phlbi)->QueryLPNETRESOURCE(),
                            (MPR_LBI *)phlbi,
                            this );

}

/*******************************************************************

    NAME:       MPR_HIER_LISTBOX::FindItem

    SYNOPSIS:   Find an LBI in the given indentation level that
                matches the given string.

    ENTRY:      pszItem - the item we are looking for
                nLevel  - the indentation level of the item

    EXIT:

    RETURNS:    The index of the item we are searching for. -1 if
                we cannot find any.

    NOTES:

    HISTORY:
        Yi-HsinS  04-Nov-1992   Created

********************************************************************/

INT MPR_HIER_LISTBOX::FindItem( const TCHAR *pszItem, INT nLevel )
{
    for ( INT i = 0; i < QueryCount(); i ++ )
    {
        MPR_LBI *plbi = (MPR_LBI *) QueryItem( i );

        /* QueryItem() can fail if its call to SendMessage fails
         */
        if (( plbi != NULL )
              &&
            ( ::stricmpf( pszItem, plbi->QueryRemoteName() ) == 0 )
              &&
            ( plbi->QueryIndentLevel() == nLevel ))
        {
            return i;
        }
    }

    return -1;
}

/*******************************************************************

    NAME:       MPR_HIER_LISTBOX::FindNextProvider

    SYNOPSIS:   Find the next LBI starting at the given index that
                is represents a provider ( top level ).

    ENTRY:      iStart - The place the start the search

    EXIT:

    RETURNS:    The index of the item we are searching for. -1 if
                we cannot find any.

    NOTES:

    HISTORY:
        Yi-HsinS  04-Nov-1992   Created

********************************************************************/

INT MPR_HIER_LISTBOX::FindNextProvider( INT iStart )
{
    UIASSERT( iStart >= 0 );

    for ( INT i = iStart; i < QueryCount(); i++ )
    {
        MPR_LBI *plbi = (MPR_LBI *) QueryItem( i );
        if ( plbi->QueryIndentLevel() == 0 )  // Topmost level
            return i;
    }

    return -1;

}

/*******************************************************************

    NAME:       MPR_HIER_LISTBOX::CalcMaxHorizontalExtent

    SYNOPSIS:   Traverses all items in the listbox and calculates the
                indent level of the deepest item and the total horizontal
                width

    RETURNS:    Count of PELs wher

    NOTES:      _nMaxPelIndent is set by this method

                The container name field width is extended for each LBI to
                the deepest indentation such that the comment will always
                be aligned.

    HISTORY:
        Johnl   17-Mar-1993     Created

********************************************************************/

#define RIGHT_MARGIN    3       // Small white space on right side of Listbox

void MPR_HIER_LISTBOX::CalcMaxHorizontalExtent( void )
{
    //
    //  Find the node that is indented the most and record the indentation
    //  and while we are at it, record the longest comment
    //
    UINT nPelIndent = 0 ;
    UINT nMaxPelIndent = 0 ;
    UINT nCommentSize = 0 ;
    UINT nMaxCommentSize = 0 ;
    DISPLAY_CONTEXT dc( QueryHwnd() ) ;
    dc.SelectFont( QueryFont() ) ;

    for ( int i = 0 ; i < QueryCount() ; i++ )
    {
        MPR_LBI * pmprlbi = (MPR_LBI*) QueryItem( i ) ;
        if ( pmprlbi != NULL )
        {
            if ((nPelIndent = pmprlbi->QueryPelIndent()) > nMaxPelIndent )
            {
                nMaxPelIndent = nPelIndent ;
            }

            if ( pmprlbi->QueryComment() && *pmprlbi->QueryComment() )
            {
                nCommentSize = dc.QueryTextWidth( pmprlbi->QueryComment() ) ;

                if ( nCommentSize > nMaxCommentSize )
                    nMaxCommentSize = nCommentSize ;
            }
        }
        else
        {
            UIASSERT( FALSE ) ;
            return ;
        }
    }

    SetMaxPelIndent( nMaxPelIndent ) ;
    SetHorizontalExtent( QueryMaxPelIndent()     +
                         QueryColWidthArray()[1] +
                         QueryColWidthArray()[2] +
                         nMaxCommentSize + RIGHT_MARGIN ) ;
}

/*******************************************************************

    NAME:       MPR_HIER_LISTBOX::QueryDisplayMap

    SYNOPSIS:   Returns the appropriate display map based on the
                type of the properties

    ENTRY:      fIsContainer - TRUE if this is a container object
                fIsExpanded - TRUE if this is an expanded container object

    EXIT:

    RETURNS:    Display Map for a Container, or an Expanded Container

    NOTES:

    HISTORY:
        Johnl   09-Jan-1992     Created

********************************************************************/

DISPLAY_MAP * MPR_HIER_LISTBOX::QueryDisplayMap( BOOL fIsContainer,
                                                 BOOL fIsExpanded,
                         DWORD dwDisplayType,
                                                 BOOL fIsProvider )
{
    UNREFERENCED( fIsContainer ) ;

    switch (dwDisplayType)
    {
    case RESOURCEDISPLAYTYPE_DOMAIN:
            if ( fIsExpanded )
                return &_dmapDomainExpanded ;
            return ( fIsContainer ? &_dmapDomain : &_dmapDomainNoExpand ) ;

    case RESOURCEDISPLAYTYPE_SERVER:
            if ( fIsExpanded )
                return &_dmapServerExpanded ;
            return ( fIsContainer ? &_dmapServer : &_dmapServerNoExpand ) ;

    case RESOURCEDISPLAYTYPE_SHARE:
            if ( fIsExpanded )
                return &_dmapShareExpanded ;
            return ( fIsContainer ? &_dmapShare : &_dmapShareNoExpand ) ;

    case RESOURCEDISPLAYTYPE_FILE:
            if ( fIsExpanded )
                return &_dmapFileExpanded ;
            return ( fIsContainer ? &_dmapFile : &_dmapFileNoExpand ) ;

    case RESOURCEDISPLAYTYPE_TREE:
            if ( fIsExpanded )
                return &_dmapTreeExpanded ;
            return ( fIsContainer ? &_dmapTree : &_dmapTreeNoExpand ) ;

    case RESOURCEDISPLAYTYPE_GROUP:
            if ( fIsExpanded )
                return &_dmapGroupExpanded ;
            return ( fIsContainer ? &_dmapGroup : &_dmapGroupNoExpand ) ;

    default:
            if ( fIsProvider )
            {
                if ( fIsExpanded )
                    return &_dmapProviderExpanded;
                return &_dmapProvider;
            }
            else
            {
                if ( fIsExpanded )
                return &_dmapGenericExpanded ;
                return ( fIsContainer ? &_dmapGeneric : &_dmapGenericNoExpand ) ;
            }
    }

}

/*******************************************************************

    NAME:       MPR_LBI::MPR_LBI

    SYNOPSIS:   Normal LBI constructor

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Johnl   30-Jan-1992     Commented
        beng    31-Mar-1992     Slight Unicode fix

********************************************************************/

MPR_LBI::MPR_LBI( LPNETRESOURCE lpnetresource )
    : HIER_LBI( FALSE ),
      _nlsDisplayName(),
      _fRefreshNeeded( FALSE )
{
    if ( QueryError() != NERR_Success )
        return;

    if ( _nlsDisplayName.QueryError() != NERR_Success )
    {
        ReportError( _nlsDisplayName.QueryError() );
        return;
    }

    _netres.dwScope = lpnetresource->dwScope;
    _netres.dwType  = lpnetresource->dwType;
    _netres.dwDisplayType = lpnetresource->dwDisplayType;
    _netres.dwUsage = lpnetresource->dwUsage;

    _netres.lpRemoteName = NULL ;
    _netres.lpLocalName  = NULL;
    _netres.lpProvider   = NULL ;
    _netres.lpComment    = NULL ;

    /* Note that we do new(count of characters) because we are using
     * the transmutable type TCHAR.
     */
    if ( lpnetresource->lpRemoteName != NULL )
    {
        if ( (_netres.lpRemoteName = new TCHAR[ ::strlenf( lpnetresource->lpRemoteName ) + 1]) != NULL)
            ::strcpyf( _netres.lpRemoteName, lpnetresource->lpRemoteName);
        else
            ReportError( ERROR_NOT_ENOUGH_MEMORY ) ;
    }

    if ( lpnetresource->lpLocalName != NULL )
    {
        if ((_netres.lpLocalName = new TCHAR[ ::strlenf( lpnetresource->lpLocalName ) + 1]) != NULL)
            ::strcpyf( _netres.lpLocalName, lpnetresource->lpLocalName);
        else
            ReportError( ERROR_NOT_ENOUGH_MEMORY ) ;
    }

    if ( lpnetresource->lpProvider != NULL )
    {
        if ((_netres.lpProvider = new TCHAR[ ::strlenf( lpnetresource->lpProvider ) + 1]) != NULL)
            ::strcpyf( _netres.lpProvider, lpnetresource->lpProvider);
        else
            ReportError( ERROR_NOT_ENOUGH_MEMORY ) ;
    }

    if ( lpnetresource->lpComment != NULL )
    {
        if ((_netres.lpComment = new TCHAR[ ::strlenf( lpnetresource->lpComment ) + 1])!=NULL )
            ::strcpyf( _netres.lpComment, lpnetresource->lpComment);
        else
            ReportError( ERROR_NOT_ENOUGH_MEMORY ) ;
    }

}


MPR_LBI::~MPR_LBI()
{
    delete _netres.lpLocalName;
    delete _netres.lpRemoteName;
    delete _netres.lpProvider;
    delete _netres.lpComment;
    _netres.lpLocalName = _netres.lpRemoteName = NULL;
    _netres.lpProvider  = _netres.lpComment    = NULL;
}

BOOL MPR_LBI::IsContainer( void ) const
{
    if ( _netres.dwScope & RESOURCE_GLOBALNET )
        return !!( _netres.dwUsage & RESOURCEUSAGE_CONTAINER );
    else
        return FALSE;
}

BOOL MPR_LBI::IsSearchDialogSupported( void ) const
{
    return( ::WNetGetSearchDialog( _netres.lpProvider ) != NULL );
}

BOOL MPR_LBI::IsConnectable( void ) const
{
    if ( _netres.dwScope & RESOURCE_GLOBALNET )
        return !!(_netres.dwUsage & RESOURCEUSAGE_CONNECTABLE );
    else
        return FALSE;
}

BOOL MPR_LBI::IsProvider( void ) const
{
    // Topmost level is provider

    return ((MPR_LBI *) this)->QueryIndentLevel() == 0 ;
}

VOID MPR_LBI::Paint( LISTBOX * plb, HDC hdc, const RECT * prect,
                     GUILTT_INFO * pGUILTT ) const
{

    MPR_HIER_LISTBOX * mprhlb = (MPR_HIER_LISTBOX *) plb ;

    //
    //  Copy the master column widths array.  The 0th item will be replaced
    //  by the pel-indent and the container name [2] will be adjusted to keep
    //  the comment aligned.  Note that the base is widened such that the
    //  right edge will always cause the comment to line up in the next
    //  column.
    //
    UINT adxColumns[4];
    for ( INT i = 1; i < 4; i++ )
         adxColumns[ i ] = mprhlb->QueryColWidthArray()[ i ];

//     adxColumns[2] += mprhlb->QueryMaxPelIndent() - QueryPelIndent() ;
    UINT indent = QueryPelIndent();
    adxColumns[0] = indent;
    if (adxColumns[2] < 2 * indent)
    {
        adxColumns[2] = indent;
    }
    else
    {
        adxColumns[2] -= indent;
    }

    if ( _nlsDisplayName.QueryTextLength() == 0 )
    {
        APIERR err = ::GetNetworkDisplayName( _netres.lpProvider,
                       _netres.lpRemoteName,
                       WNFMT_ABBREVIATED | WNFMT_INENUM,
                       adxColumns[2] / mprhlb->QueryAveCharWidth(),
                       (NLS_STR *) & _nlsDisplayName );

        if ( err != NERR_Success )
        {
            ::MsgPopup( plb->QueryOwnerHwnd(), err );
            return;
        }
    }

    DM_DTE  dmdte( mprhlb->QueryDisplayMap( IsContainer(),
                        QueryExpanded(),
                        QueryDisplayType(),
                        IsProvider())) ;
    STR_DTE sdte( _nlsDisplayName.QueryPch() );
    STR_DTE sdteComment( QueryComment() ) ;

    DISPLAY_TABLE dtab( 4, adxColumns );
    dtab[0] = NULL;
    dtab[1] = &dmdte;
    dtab[2] = &sdte;
    dtab[3] = &sdteComment;

    dtab.Paint( plb, hdc, prect, pGUILTT );
}

/*******************************************************************

    NAME:       MPR_LBI::QueryLeadingChar

    SYNOPSIS:   Returns the first non-'\\' character of the remote name

    ENTRY:

    RETURNS:    The first non back slash character of the remote name

    NOTES:      This code is not DBCS safe, which is OK since it should
                only be run with ANSI and UNICODE character sets.

    HISTORY:
        Johnl   09-Jan-1992     Changed to return first non-'\\' character

********************************************************************/

WCHAR MPR_LBI::QueryLeadingChar() const
{
    TCHAR * pchRemoteName = _netres.lpRemoteName ;
    while ( *pchRemoteName && *pchRemoteName == TCH('\\') )
        pchRemoteName++ ;

    return *pchRemoteName ;
}


INT MPR_LBI::Compare( const LBI * plbi ) const
{
    return ::stricmpf( _netres.lpRemoteName,
                        ((const MPR_LBI *)plbi)->_netres.lpRemoteName );
}

MPR_LBI_CACHE::MPR_LBI_CACHE( INT cInitialItems )
    : BASE(),
      _cItems( 0 ),
      _cMaxItems( cInitialItems ),
      _buffArray( cInitialItems * sizeof(MPR_LBI*) )
{
    if ( QueryError() )
        return ;

    if ( _buffArray.QueryError() )
        ReportError( _buffArray.QueryError() ) ;
}

MPR_LBI_CACHE::~MPR_LBI_CACHE()
{
    // Nothing to do
}

/*******************************************************************

    NAME:       MPR_LBI_CACHE::AppendItem

    SYNOPSIS:   Adds an item to the end of the cache

    ENTRY:      plbi - Item to add

    EXIT:       The item will be deleted if an error occurs

    RETURNS:    NERR_Success is successful, error code otherwise

    NOTES:      Behave just like AddItem

    HISTORY:
        Johnl   27-Jan-1993     Created

********************************************************************/

#define CACHE_DELTA     100
APIERR MPR_LBI_CACHE::AppendItem( MPR_LBI * plbi )
{
    APIERR err = ERROR_NOT_ENOUGH_MEMORY ;
    if ( plbi == NULL ||
         (err = plbi->QueryError()) )
    {
        delete plbi ;
        return err ;
    }

    //
    //  Do we need to resize the array?
    //
    if ( _cItems >= _cMaxItems )
    {
        if ( err = _buffArray.Resize( _buffArray.QuerySize() +
                                      CACHE_DELTA * sizeof(MPR_LBI*) ))
        {
            delete plbi ;
            return err ;
        }

        _cMaxItems += CACHE_DELTA ;
    }

    QueryPtr()[_cItems++] = plbi ;

    return err ;
}

void MPR_LBI_CACHE::Sort( void )
{
    if ( QueryCount() > 0 )
    {
        ::qsort( (void *) _buffArray.QueryPtr(),
                 QueryCount(),
                 sizeof(MPR_LBI*),
                 MPR_LBI_CACHE::CompareLbis ) ;
    }
}

INT MPR_LBI_CACHE::FindItem( const TCHAR *psz )
{
   for ( INT i= 0; i < QueryCount(); i++ )
   {
       if ( ::stricmpf( (QueryPtr()[i])->QueryRemoteName(), psz ) == 0 )
           return i;
   }

   return -1;
}

VOID MPR_LBI_CACHE::DeleteAllItems( VOID )
{
   for ( INT i= 0; i < QueryCount(); i++ )
   {
        MPR_LBI *plbi = QueryPtr()[i];
        delete plbi;
        QueryPtr()[i] = NULL;
   }

   _cItems = 0;
}


int __cdecl MPR_LBI_CACHE::CompareLbis( const void * p0,
                                         const void * p1 )
{
    MPR_LBI * plbi = (MPR_LBI*) *((MPR_LBI**)p0) ;
    return plbi->Compare( (LBI*) *((MPR_LBI**)p1) ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\mprui\mpr\mprthred.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**             Copyright(c) Microsoft Corp., 1993                   **/
/**********************************************************************/

/*
    mprthred.cxx
       Second thread for network connection dialog.


    FILE HISTORY:
        YiHsinS		4-Mar-1993	Created

*/

#define INCL_NETERRORS
#define INCL_WINDOWS_GDI
#define INCL_WINDOWS
#define INCL_DOSERRORS
#define INCL_NETLIB
#define INCL_NETWKSTA
#include <lmui.hxx>

#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#include <blt.hxx>

#include <strnumer.hxx> // HEX_STR
#include <uitrace.hxx>

#include <mprbrows.hxx>

/*******************************************************************

    NAME:       MPR_ENUM_THREAD::MPR_ENUM_THREAD

    SYNOPSIS:   Constructor

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        YiHsinS		4-Mar-1993	Created

********************************************************************/

MPR_ENUM_THREAD::MPR_ENUM_THREAD( HWND hwndDlg,
                                  UINT uiType,
                                  LPNETRESOURCE pnetresProvider,
                                  const TCHAR *pszWkstaDomain )
    : WIN32_THREAD( TRUE, 0, SZ("mprui.dll") ),
      _hwndDlg( hwndDlg ),
      _uiType ( uiType ),
      _nlsWkstaDomain( pszWkstaDomain ),
      _eventExitThread( NULL, FALSE ),
      _fThreadIsTerminating( FALSE )
{
    if ( QueryError() )
        return;

    APIERR err = NERR_Success;
    if (  ((err = _eventExitThread.QueryError()) != NERR_Success )
       || ((err = _nlsWkstaDomain.QueryError()) != NERR_Success )
       )
    {
        ReportError( err );
        return;
    }

    UIASSERT( pnetresProvider != NULL );

    _netresProvider.dwScope = pnetresProvider->dwScope;
    _netresProvider.dwType  = pnetresProvider->dwType;
    _netresProvider.dwDisplayType = pnetresProvider->dwDisplayType;
    _netresProvider.dwUsage = pnetresProvider->dwUsage;

    _netresProvider.lpRemoteName = NULL;
    _netresProvider.lpLocalName  = NULL;
    _netresProvider.lpProvider   = NULL;
    _netresProvider.lpComment    = NULL;

    /* Note that we do new(count of characters) because we are using
     * the transmutable type TCHAR.
     */
    if ( pnetresProvider->lpRemoteName != NULL )
    {
        if ( (_netresProvider.lpRemoteName = new TCHAR[ ::strlenf( pnetresProvider->lpRemoteName ) + 1]) != NULL)
            ::strcpyf( _netresProvider.lpRemoteName, pnetresProvider->lpRemoteName);
        else
            ReportError( ERROR_NOT_ENOUGH_MEMORY ) ;
    }

    if ( pnetresProvider->lpLocalName != NULL )
    {
        if ((_netresProvider.lpLocalName = new TCHAR[ ::strlenf( pnetresProvider->lpLocalName ) + 1]) != NULL)
            ::strcpyf( _netresProvider.lpLocalName, pnetresProvider->lpLocalName);
        else
            ReportError( ERROR_NOT_ENOUGH_MEMORY ) ;
    }

    if ( pnetresProvider->lpProvider != NULL )
    {
        if ((_netresProvider.lpProvider = new TCHAR[ ::strlenf( pnetresProvider->lpProvider ) + 1]) != NULL)
            ::strcpyf( _netresProvider.lpProvider, pnetresProvider->lpProvider);
        else
            ReportError( ERROR_NOT_ENOUGH_MEMORY ) ;
    }

    if ( pnetresProvider->lpComment != NULL )
    {
        if ((_netresProvider.lpComment = new TCHAR[ ::strlenf( pnetresProvider->lpComment ) + 1])!=NULL )
            ::strcpyf( _netresProvider.lpComment, pnetresProvider->lpComment);
        else
            ReportError( ERROR_NOT_ENOUGH_MEMORY ) ;
    }
}

/*******************************************************************

    NAME:       MPR_ENUM_THREAD::~MPR_ENUM_THREAD

    SYNOPSIS:   Destructor

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        YiHsinS		4-Mar-1993	Created

********************************************************************/

MPR_ENUM_THREAD::~MPR_ENUM_THREAD()
{
    delete _netresProvider.lpRemoteName;
    delete _netresProvider.lpLocalName;
    delete _netresProvider.lpProvider;
    delete _netresProvider.lpComment;
    _netresProvider.lpRemoteName = NULL;
    _netresProvider.lpLocalName  = NULL;
    _netresProvider.lpProvider   = NULL;
    _netresProvider.lpComment    = NULL;
}

/*******************************************************************

    NAME:       MPR_ENUM_THREAD::Main()

    SYNOPSIS:   Get the information needed to fill in the "Show" listbox
                with the requested data (providers, containers or
                connectable items)

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        YiHsinS		4-Mar-1993	Created

********************************************************************/

APIERR MPR_ENUM_THREAD::Main( VOID )
{
    APIERR err = NERR_Success;

    MPR_LBI_CACHE *pmprlbicacheDomain = NULL;
    MPR_LBI_CACHE *pmprlbicacheServer = NULL;

    INT i = -1;
    if (  !_fThreadIsTerminating  )
    {
        // The errors that happened in the following two EnumerateShow
        // will be ignored. The cache returned will be NULL if error
        // occurred so nothing needs to be added to the listbox.

        // Get the domains
        APIERR err1 = ::EnumerateShow(
			 _hwndDlg,
                         RESOURCE_GLOBALNET,
                         _uiType,
                         0,
                         &_netresProvider,
                         NULL,
                         NULL,
                         FALSE,
                         NULL,
                         &pmprlbicacheDomain );


        if (  !_fThreadIsTerminating
           && ( err1 == NERR_Success )
           && ( _nlsWkstaDomain.QueryTextLength() != 0 )
           && ( (i = pmprlbicacheDomain->FindItem( _nlsWkstaDomain )) >= 0 )
           )
        {
            // Get the servers, ignore the error
            ::EnumerateShow(
                  _hwndDlg,
                  RESOURCE_GLOBALNET,
                  _uiType,
                  0,
                  ((pmprlbicacheDomain->QueryPtr())[i])->QueryLPNETRESOURCE(),
                  NULL,
                  NULL,
                  FALSE,
                  NULL,
                  &pmprlbicacheServer );

        }
    }

    MPR_RETURN_CACHE p;
    p.pcacheDomain = pmprlbicacheDomain;
    p.pcacheServer = pmprlbicacheServer;

    if ( !_fThreadIsTerminating )
    {
        if ( err == NERR_Success )
        {
            ::SendMessage( _hwndDlg,
                           WM_LB_FILLED,
                           (WPARAM) FALSE,    // No error!
                           (LPARAM) &p );
        }
        else
        {
            ::SendMessage( _hwndDlg,
                           WM_LB_FILLED,
                           (WPARAM) TRUE,     // Error occurred!
                           (LPARAM) err );
        }
    }

    // The following cache will have already been freed if the
    // dialog got and processed the SendMessage above.
    if ( p.pcacheDomain != NULL )
    {
        (p.pcacheDomain)->DeleteAllItems();
        delete p.pcacheDomain;
        p.pcacheDomain = NULL;
    }

    if ( p.pcacheServer != NULL )
    {
        (p.pcacheServer)->DeleteAllItems();
        delete p.pcacheServer;
        p.pcacheServer = NULL;
    }

    switch ( ::WaitForSingleObject( _eventExitThread.QueryHandle(), INFINITE ))
    {
        // Time to exit the thread
        case WAIT_OBJECT_0:
            break;

        // These two should not have happened, not a mutex and wait infinite
        case WAIT_ABANDONED:
        case WAIT_TIMEOUT:
            UIASSERT( FALSE );
            break;

        default:
            err = ::GetLastError();
            break;
    }

    return err;

}  // MPR_ENUM_THREAD::Main

/*******************************************************************

    NAME:       MPR_ENUM_THREAD::PostMain()

    SYNOPSIS:   Clean up

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        YiHsinS		4-Mar-1993	Created

********************************************************************/

APIERR MPR_ENUM_THREAD::PostMain( VOID )
{
    TRACEEOL("MPR_ENUM_THREAD::PostMain - Deleting \"this\" for thread "
             << HEX_STR( (ULONG) QueryHandle() )) ;

    DeleteAndExit( NERR_Success ) ; // This method should never return

    UIASSERT( FALSE );

    return NERR_Success;

}  // MPR_ENUM_THREAD::PostMain
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\mprui\test2\nr.cxx ===
#include "headers.hxx"
#pragma hdrstop

#include "nr.hxx"


LPTSTR
NewDup(
    IN const TCHAR* psz
    )
{
    if (NULL == psz)
    {
        return NULL;
    }

    LPTSTR pszRet = new TCHAR[_tcslen(psz) + 1];
    if (NULL == pszRet)
    {
        return NULL;
    }

    _tcscpy(pszRet, psz);
    return pszRet;
}


CNetResource::CNetResource(LPNETRESOURCE pnr)
{
	if (NULL == pnr)
	{
		_bValid = FALSE;
	}
	else
	{
		_bValid = TRUE;

		_nr = *pnr;

		// now copy strings

    	_nr.lpLocalName    = NewDup(pnr->lpLocalName);
    	_nr.lpRemoteName   = NewDup(pnr->lpRemoteName);
    	_nr.lpComment      = NewDup(pnr->lpComment);
    	_nr.lpProvider     = NewDup(pnr->lpProvider);
	}
}


CNetResource::~CNetResource()
{
	if (_bValid)
	{
    	delete[] _nr.lpLocalName;
    	delete[] _nr.lpRemoteName;
    	delete[] _nr.lpComment;
    	delete[] _nr.lpProvider;
	}
}

LPNETRESOURCE
CNetResource::GetNetResource(
	VOID
	)
{
	if (_bValid)
	{
		return &_nr;
	}
	else
	{
		return NULL;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\mprui\test2\enum.cxx ===
#include "headers.hxx"
#pragma hdrstop

#include "resource.h"
#include "nr.hxx"

/////////////////////////////////////////////////////////////////////////////
// Exported from t.cxx
//

VOID
PlaceIt(
    HWND hwnd
    );

/////////////////////////////////////////////////////////////////////////////

TCHAR g_szRoot[] = TEXT("Entire Network");

/////////////////////////////////////////////////////////////////////////////

//
// Timing stuff (stolen from the shell)
//

#if 1
__inline DWORD clockrate() {LARGE_INTEGER li; QueryPerformanceFrequency(&li); return li.LowPart;}
__inline DWORD clock()     {LARGE_INTEGER li; QueryPerformanceCounter(&li);   return li.LowPart;}
#else
__inline DWORD clockrate() {return 1000;}
__inline DWORD clock()     {return GetTickCount();}
#endif

#define TIMEVAR(t)    DWORD t ## T; DWORD t ## N
#define TIMEIN(t)     t ## T = 0, t ## N = 0
#define TIMESTART(t)  t ## T -= clock(), t ## N ++
#define TIMESTOP(t)   t ## T += clock()
#define TIMEFMT(t)    ((DWORD)(t) / clockrate()), (((DWORD)((t) * 1000) / clockrate()) % 1000)
#define TIMEOUT(t)    if (t ## N) { \
                          TCHAR szBuf[1000]; \
                          wsprintf(szBuf, TEXT(#t) TEXT(": %ld calls, time: %ld, total: %ld.%03ld sec, average: %ld.%03ld sec/call\n"), t ## N, t ## T, TIMEFMT(t ## T), TIMEFMT( t ## T / t ## N )); \
                          OutputDebugString(szBuf); \
                          }

//
// Globals
//
HIMAGELIST g_himl;

#define DEFAULT_BUFFER_SIZE 50000
LPBYTE g_pBuffer = NULL;
DWORD  g_dwBufferSize = 0;

BOOL g_bUseWNetFormatNetworkName = FALSE;

DWORD g_dwScope = 0;
DWORD g_dwType = 0;
DWORD g_dwUsage = 0;

DWORD CALLBACK
EnumThreadProc(
    LPVOID lpThreadParameter
    );

INT_PTR CALLBACK
DlgProcStart(
    IN HWND   hwnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR CALLBACK
DlgProcMain(
    IN HWND   hwnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

BOOL
OnInitDialog(
    IN HWND hwnd,
    IN LPNETRESOURCE pRootNR
    );

BOOL
OnTreeNotify(
    IN HWND   hwnd,
    IN LPNM_TREEVIEW ptvn
    );

BOOL
OnExpand(
    IN HWND   hwnd,
    IN LPNM_TREEVIEW ptvn
    );

BOOL
OnGetDispInfo(
    IN HWND   hwnd,
    IN LPNM_TREEVIEW ptvn
    );

VOID
InsertChildren(
    IN HWND hwnd,
    IN HTREEITEM hParent,
    IN CNetResource* pnrParent,
    IN HANDLE hEnum
    );

VOID
InsertItem(
    IN HWND hwnd,
    IN HTREEITEM hParent,
    IN CNetResource* pnrParent,
    IN LPNETRESOURCE pnr
    );

VOID
GetItemText(
    IN LPNETRESOURCE pnr,
    OUT LPTSTR pszBuf           // assume it's big enough
    );

VOID
ErrorPopup(
    IN HWND hwnd,
    IN DWORD dwErr
    );

/////////////////////////////////////////////////////////////////////////////

//
// For image list
//

//
// NOTE: the I_* indices defined in global.hxx MUST MATCH THIS ARRAY!
//

WORD s_IconArray[] =
{
    IDI_GENERIC,
    IDI_DOMAIN,
    IDI_SERVER,
    IDI_SHARE,
    IDI_FILE,
    IDI_GROUP,
    IDI_NETWORK,
    IDI_ROOT,
    IDI_SHAREADMIN,
    IDI_DIRECTORY,
    IDI_TREE
};

int g_IconIndex[ARRAYLEN(s_IconArray)];

/////////////////////////////////////////////////////////////////////////////

ULONG
DoEnumeration(
    IN HWND hwnd
    )
{
    DWORD idThread;
    HANDLE hThread = CreateThread(NULL, 0, EnumThreadProc, (LPVOID)NULL, 0, &idThread);
    if (hThread)
    {
        CloseHandle(hThread);
    }
    else
    {
        MessageBox(hwnd, TEXT("Couldn't create enumeration thread"), TEXT("Error!"), MB_OK);
    }
    return 0;
}


DWORD CALLBACK
EnumThreadProc(
    LPVOID lpThreadParameter
    )
{
    InitCommonControls();

    //
    // Create the image list
    //

    int cxIcon = GetSystemMetrics(SM_CXSMICON);
    int cyIcon = GetSystemMetrics(SM_CYSMICON);

    g_himl = ImageList_Create(cxIcon, cyIcon, ILC_MASK, ARRAYLEN(g_IconIndex), 0);
    if (NULL == g_himl)
    {
        return (ULONG)-1;
    }

    for (UINT i=0; i < ARRAYLEN(g_IconIndex); i++)
    {
        HICON hIcon = LoadIcon(g_hInstance, MAKEINTRESOURCE(s_IconArray[i]));
        if (NULL == hIcon)
        {
            continue;
        }
        g_IconIndex[i] = ImageList_AddIcon(g_himl, hIcon);
        if (-1 == g_IconIndex[i])
        {
            // failed!
        }
        DestroyIcon(hIcon);
    }

    // Now see what the user wants to do

    DWORD finalret = 0;
    INT_PTR ret;

    ret = DialogBox(g_hInstance, MAKEINTRESOURCE(IDD_START), NULL, DlgProcStart);
    if (-1 == ret)
    {
        ErrorPopup(NULL, GetLastError());
        finalret = 1;
    }
    else if (!ret)
    {
        // user cancelled
        finalret = 1;
    }

    //
    // Release image list
    //

    if (NULL != g_himl)
    {
        ImageList_Destroy(g_himl);
    }

    return finalret;
}

/////////////////////////////////////////////////////////////////////////////

class CWaitCursor
{
public:
    CWaitCursor(UINT idResCursor = 0);
    ~CWaitCursor();

private:
    HCURSOR _hcurWait;
    HCURSOR _hcurOld;
};

//----------------------------------------------------------------------------

CWaitCursor::CWaitCursor(UINT idResCursor)
{
    _hcurWait = _hcurOld = NULL;

    if (0 != idResCursor)
    {
        _hcurWait = LoadCursor(g_hInstance, MAKEINTRESOURCE(idResCursor));
        _hcurOld = SetCursor(_hcurWait);
    }
    else
    {
        _hcurOld = SetCursor(LoadCursor(NULL, IDC_WAIT));
    }
}

CWaitCursor::~CWaitCursor()
{
    ::SetCursor( _hcurOld );
    if (_hcurWait)
    {
        ::DestroyCursor( _hcurWait );
    }
}

/////////////////////////////////////////////////////////////////////////////

INT_PTR CALLBACK
DlgProcStart(
    IN HWND   hwnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
    {
        PlaceIt(hwnd);

        // Set default to be enumeration from the root of the network

        SetDlgItemInt(hwnd, IDC_BUFFER_SIZE, DEFAULT_BUFFER_SIZE, FALSE);

        SetDlgItemText(hwnd, IDC_REMOTE_TEXT, TEXT(""));
        EnableWindow(GetDlgItem(hwnd, IDC_REMOTE_TEXT), FALSE);
        CheckDlgButton(hwnd, IDC_REMOTE_TEXT, 0);

        SetDlgItemText(hwnd, IDC_PROVIDER_TEXT, TEXT(""));
        EnableWindow(GetDlgItem(hwnd, IDC_PROVIDER_TEXT), FALSE);
        CheckDlgButton(hwnd, IDC_PROVIDER_TEXT, 0);

        CheckRadioButton(hwnd, IDC_RESOURCE_CONNECTED, IDC_RESOURCE_SHAREABLE, IDC_RESOURCE_GLOBALNET);
        CheckRadioButton(hwnd, IDC_DISK, IDC_RESERVED, IDC_ANY);

        CheckDlgButton(hwnd, IDC_RESOURCEUSAGE_CONNECTABLE, 1);
        CheckDlgButton(hwnd, IDC_RESOURCEUSAGE_CONTAINER, 1);

        return 1;   // didn't call SetFocus
    }

    case WM_COMMAND:
    {
        switch (LOWORD(wParam))
        {
        case IDOK:
        {
            NETRESOURCE nr = {0};
            LPNETRESOURCE pnr = &nr;

            DWORD dwScope = 0;
            if (1 == IsDlgButtonChecked(hwnd, IDC_RESOURCE_CONNECTED))
            {
                dwScope = RESOURCE_CONNECTED;
            }
            else if (1 == IsDlgButtonChecked(hwnd, IDC_RESOURCE_GLOBALNET))
            {
                dwScope = RESOURCE_GLOBALNET;
            }
            else if (1 == IsDlgButtonChecked(hwnd, IDC_RESOURCE_REMEMBERED))
            {
                dwScope = RESOURCE_REMEMBERED;
            }
            else if (1 == IsDlgButtonChecked(hwnd, IDC_RESOURCE_RECENT))
            {
                dwScope = RESOURCE_RECENT;
            }
            else if (1 == IsDlgButtonChecked(hwnd, IDC_RESOURCE_CONTEXT))
            {
                dwScope = RESOURCE_CONTEXT;
            }
            else if (1 == IsDlgButtonChecked(hwnd, IDC_RESOURCE_SHAREABLE))
            {
                dwScope = RESOURCE_SHAREABLE;
            }
            else
            {
                // internal error
            }

            DWORD dwType = 0;
            if (1 == IsDlgButtonChecked(hwnd, IDC_DISK))
            {
                dwType = RESOURCETYPE_DISK;
            }
            else if (1 == IsDlgButtonChecked(hwnd, IDC_PRINTER))
            {
                dwType = RESOURCETYPE_PRINT;
            }
            else if (1 == IsDlgButtonChecked(hwnd, IDC_ANY))
            {
                dwType = RESOURCETYPE_ANY;
            }
            else if (1 == IsDlgButtonChecked(hwnd, IDC_RESERVED))
            {
                dwType = RESOURCETYPE_RESERVED;
            }
            else
            {
                // internal error
            }

            DWORD dwUsage = 0;
            if (1 == IsDlgButtonChecked(hwnd, IDC_RESOURCEUSAGE_CONNECTABLE))
            {
                dwUsage |= RESOURCEUSAGE_CONNECTABLE;
            }
            if (1 == IsDlgButtonChecked(hwnd, IDC_RESOURCEUSAGE_CONTAINER))
            {
                dwUsage |= RESOURCEUSAGE_CONTAINER;
            }

            TCHAR szRemoteName[200];
            LPTSTR pszRemoteName = NULL;
            if (1 == IsDlgButtonChecked(hwnd, IDC_REMOTE))
            {
                GetDlgItemText(hwnd, IDC_REMOTE_TEXT, szRemoteName, ARRAYLEN(szRemoteName));
                pszRemoteName = szRemoteName;
            }

            TCHAR szProviderName[200];
            LPTSTR pszProviderName = NULL;
            if (1 == IsDlgButtonChecked(hwnd, IDC_PROVIDER))
            {
                GetDlgItemText(hwnd, IDC_PROVIDER_TEXT, szProviderName, ARRAYLEN(szProviderName));
                pszProviderName = szProviderName;
            }

            pnr->dwScope         = 0;
            pnr->dwType          = 0;
            pnr->dwDisplayType   = 0;
            pnr->dwUsage         = 0;
            pnr->lpLocalName     = NULL;
            pnr->lpRemoteName    = NewDup(pszRemoteName);
            pnr->lpComment       = NULL;
            pnr->lpProvider      = NewDup(pszProviderName);

            BOOL bTranslated;
            UINT uiSize = GetDlgItemInt(hwnd, IDC_BUFFER_SIZE, &bTranslated, FALSE);
            if (bTranslated)
            {
                g_dwBufferSize = (DWORD)uiSize;
            }
            else
            {
                g_dwBufferSize = DEFAULT_BUFFER_SIZE;
            }

            g_pBuffer = (LPBYTE)LocalAlloc(LMEM_FIXED, g_dwBufferSize);
            if (NULL == g_pBuffer)
            {
                MessageBox(hwnd, TEXT("Error allocating buffer"), TEXT("Error"), MB_OK);
                EndDialog(hwnd, FALSE); // pretend we cancelled
            }
            else
            {
                g_bUseWNetFormatNetworkName = FALSE;
                if (1 == IsDlgButtonChecked(hwnd, IDC_USE_WNETFORMATNETWORKNAME))
                {
                    g_bUseWNetFormatNetworkName = TRUE;
                }

                g_dwScope = dwScope;
                g_dwType  = dwType;
                g_dwUsage = dwUsage;

                if ((NULL == nr.lpRemoteName) && (NULL == nr.lpProvider))
                {
                    pnr = NULL; // root
                }

                INT_PTR ret = DialogBoxParam(g_hInstance,
                                             MAKEINTRESOURCE(IDD_MAIN),
                                             hwnd,
                                             DlgProcMain,
                                             (LPARAM) pnr);

                if (-1 == ret)
                {
                    ErrorPopup(NULL, GetLastError());
                    EndDialog(hwnd, FALSE); // pretend we cancelled
                }

                LocalFree(g_pBuffer);
                g_pBuffer = NULL;
            }

            return TRUE;
        }

        case IDCANCEL:
            EndDialog(hwnd, FALSE);
            return TRUE;

        case IDC_REMOTE:
            EnableWindow(GetDlgItem(hwnd, IDC_REMOTE_TEXT),
                (1 == IsDlgButtonChecked(hwnd, IDC_REMOTE)));
            return TRUE;

        case IDC_PROVIDER:
            EnableWindow(GetDlgItem(hwnd, IDC_PROVIDER_TEXT),
                (1 == IsDlgButtonChecked(hwnd, IDC_PROVIDER)));
            return TRUE;

        } // end switch (LOWORD(wParam))

        return FALSE;
    }

    default:
        return FALSE;   // didn't process
    }
}

INT_PTR CALLBACK
DlgProcMain(
    IN HWND   hwnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        return OnInitDialog(hwnd, (LPNETRESOURCE)lParam);

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDOK:
            EndDialog(hwnd, 0);
            break;
        }
        return 0;

    case WM_NOTIFY:
        return OnTreeNotify(hwnd, (LPNM_TREEVIEW)lParam);

    default:
        return 0;   // didn't process
    }
}

BOOL
OnInitDialog(
    IN HWND hwnd,
    IN LPNETRESOURCE pRootNR
    )
{
    PlaceIt(hwnd);

    // Set the image list
    HIMAGELIST himl = TreeView_SetImageList(GetDlgItem(hwnd, IDC_TREE), g_himl, TVSIL_NORMAL);

    // fill top-level enumeration
    TCHAR szBuf[500];   // for the item name
    szBuf[0] = TEXT('\0');
    GetItemText(pRootNR, szBuf);

    CNetResource* pnr = new CNetResource(pRootNR);

//  appAssert(pnr->GetNetResource()->dwDisplayType >= 0
//         && pnr->GetNetResource()->dwDisplayType < ARRAYLEN(g_IconIndex));
    int iImage = g_IconIndex[RESOURCEDISPLAYTYPE_ROOT];

    TV_ITEM tvi;
    tvi.mask        = TVIF_TEXT | TVIF_PARAM | TVIF_CHILDREN | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
    tvi.hItem       = NULL;
    tvi.state       = 0;
    tvi.stateMask   = 0;
    tvi.pszText     = szBuf;
    tvi.cchTextMax  = 0; // not used
    tvi.iImage      = iImage;
    tvi.iSelectedImage = iImage;
    tvi.cChildren   = 1; // anything >0
    tvi.lParam      = (LPARAM)pnr;

    TV_INSERTSTRUCT tvis;
    tvis.hParent = TVI_ROOT;
    tvis.item = tvi;
    tvis.hInsertAfter = TVI_FIRST;

    HTREEITEM hret = TreeView_InsertItem(GetDlgItem(hwnd, IDC_TREE), &tvis);
    return 1;
}

BOOL
OnTreeNotify(
    IN HWND hwnd,
    IN LPNM_TREEVIEW ptvn
    )
{
    switch (ptvn->hdr.code)
    {
    case TVN_ITEMEXPANDING:
        return OnExpand(hwnd, ptvn);

    case TVN_GETDISPINFO:
        return OnGetDispInfo(hwnd, ptvn);

    case TVN_SETDISPINFO:
        return 0;

    case TVN_DELETEITEM:
    {
        CNetResource* pnr = (CNetResource*)ptvn->itemOld.lParam;
        delete pnr;
        return 1;
    }

    default:
        return 0;
    }
}

BOOL
OnExpand(
    IN HWND   hwnd,
    IN LPNM_TREEVIEW ptvn
    )
{
    HWND hwndTree = GetDlgItem(hwnd, IDC_TREE);
    BOOL b;

    CWaitCursor wait;

    if (ptvn->action == TVE_COLLAPSE)
    {
        // delete all children of ptvn->itemNew.hItem

        HTREEITEM hChild;
        for (;;) // forever
        {
            hChild = TreeView_GetChild(hwndTree, ptvn->itemNew.hItem);
            if (NULL == hChild)
            {
                break;
            }

            TreeView_DeleteItem(hwndTree, hChild);
        }
    }
    else if (ptvn->action == TVE_EXPAND)
    {
        // enumerate and add children

        HTREEITEM hParent = ptvn->itemNew.hItem;
        TV_ITEM tvi;
        tvi.hItem = hParent;
        tvi.mask = TVIF_PARAM;
        b = TreeView_GetItem(hwndTree, &tvi);

        CNetResource* pnrParent = (CNetResource*)tvi.lParam;
        LPNETRESOURCE pnr = pnrParent->GetNetResource();
        HANDLE hEnum;

        TIMEVAR(WNetOpenEnum);
        TIMEIN(WNetOpenEnum);

        TIMESTART(WNetOpenEnum);
        DWORD dwErr = WNetOpenEnum(
                            g_dwScope,
                            g_dwType,
                            g_dwUsage,
                            (g_dwScope == RESOURCE_GLOBALNET || g_dwScope == RESOURCE_SHAREABLE)
                                ? pnr : NULL,
                            &hEnum);

        TIMESTOP(WNetOpenEnum);
        TIMEOUT(WNetOpenEnum);

        if (NO_ERROR == dwErr)
        {
            InsertChildren(hwnd, hParent, pnrParent, hEnum);

            dwErr = WNetCloseEnum(hEnum);
            if (NO_ERROR != dwErr)
            {
                ErrorPopup(hwnd, dwErr);
            }
        }
        else
        {
            ErrorPopup(hwnd, dwErr);
        }
    }
    else
    {
        // nothing interesting
    }

    return 0;
}

BOOL
OnGetDispInfo(
    IN HWND hwnd,
    IN LPNM_TREEVIEW ptvn
    )
{

    // 1. delete all children
    // 2. enumerate and add children

    HWND hwndTree = GetDlgItem(hwnd, IDC_TREE);
    TV_DISPINFO* ptvdi = (TV_DISPINFO*)ptvn;
    if (!(TVIF_CHILDREN & ptvdi->item.mask))
    {
        // not asking for children, so go away
    }

    return 1;
}

TIMEVAR(WNetFormatNetworkName);

VOID
InsertChildren(
    IN HWND hwnd,
    IN HTREEITEM hParent,
    IN CNetResource* pnrParent,
    IN HANDLE hEnum
    )
{
    DWORD cEntries = 0xffffffff; // as many as possible
    DWORD cNewItems = 0;
    NETRESOURCE* pnr;
    DWORD cbBuffer = g_dwBufferSize;
    DWORD dwErr;

    TIMEVAR(WNetEnumResource);
    TIMEVAR(InsertItems);
    TIMEVAR(SortItems);

    TIMEIN(WNetEnumResource);
    TIMEIN(InsertItems);
    TIMEIN(WNetFormatNetworkName);
    TIMEIN(SortItems);

    do
    {
        TIMESTART(WNetEnumResource);
        dwErr = WNetEnumResource(hEnum, &cEntries, g_pBuffer, &cbBuffer);
        TIMESTOP(WNetEnumResource);

        if (NO_ERROR == dwErr)
        {
/////////////////
            TCHAR sz[300];
            wsprintf(sz, TEXT("Got %d entries. Total new: %d\n"), cEntries, cNewItems);
            OutputDebugString(sz);
/////////////////

            TIMEVAR(InsertOnce);
            TIMEIN(InsertOnce);

            pnr = (NETRESOURCE*)g_pBuffer;
            cNewItems += cEntries;

            TIMESTART(InsertItems);
            TIMESTART(InsertOnce);
            for (DWORD i=0; i<cEntries; i++)
            {
                InsertItem(hwnd, hParent, pnrParent, &pnr[i]);
            }
            TIMESTOP(InsertOnce);
            TIMESTOP(InsertItems);

            TIMEOUT(InsertOnce);
        }
        else if (ERROR_NO_MORE_ITEMS != dwErr)
        {
            ErrorPopup(hwnd, GetLastError());
        }

    } while (dwErr == NO_ERROR);

    TIMESTART(SortItems);
    TreeView_SortChildren(GetDlgItem(hwnd, IDC_TREE), hParent, 0);
    TIMESTOP(SortItems);

    TIMEOUT(WNetEnumResource);
    TIMEOUT(InsertItems);
    TIMEOUT(WNetFormatNetworkName);
    TIMEOUT(SortItems);

    if (0 == cNewItems)
    {
        MessageBox(hwnd, TEXT("No items were found"), TEXT("Error"), MB_OK);
    }
}

VOID
InsertItem(
    IN HWND hwnd,
    IN HTREEITEM hParent,
    IN CNetResource* pnrParent,
    IN LPNETRESOURCE pnr
    )
{
    TCHAR szBuf[500];   // for the item name
    szBuf[0] = TEXT('\0');

    if (g_bUseWNetFormatNetworkName)
    {
        TIMESTART(WNetFormatNetworkName);

        DWORD dwLen = ARRAYLEN(szBuf);
        DWORD dwErr = WN_SUCCESS;
        if (NULL == pnr->lpProvider || NULL == pnr->lpRemoteName)
        {
            if (pnr->dwDisplayType == RESOURCEDISPLAYTYPE_ROOT)
            {
                _tcscpy(szBuf, g_szRoot);
            }
            else
            {
                dwErr = WN_NET_ERROR;
            }
        }
        else
        {
            dwErr = WNetFormatNetworkName(
                        pnr->lpProvider,
                        pnr->lpRemoteName,
                        szBuf,
                        &dwLen,
                        WNFMT_ABBREVIATED | WNFMT_INENUM,
                        1000);  // random large #
        }

        TIMESTOP(WNetFormatNetworkName);

        if (NO_ERROR != dwErr)
        {
            ErrorPopup(hwnd, GetLastError());
            return;
        }
    }
    else
    {
        GetItemText(pnr, szBuf);
    }

    CNetResource* pnrChild = new CNetResource(pnr);

//  appAssert(pnrChild->GetNetResource()->dwDisplayType >= 0
//         && pnrChild->GetNetResource()->dwDisplayType < ARRAYLEN(g_IconIndex));
    int iImage = g_IconIndex[pnrChild->GetNetResource()->dwDisplayType];

    TV_ITEM tvi;
    tvi.mask        = TVIF_TEXT | TVIF_PARAM | TVIF_CHILDREN | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
    tvi.hItem       = NULL;
    tvi.state       = 0;
    tvi.stateMask   = 0;
    tvi.pszText     = szBuf;
    tvi.cchTextMax  = 0; // not used
    tvi.iImage      = iImage;
    tvi.iSelectedImage = iImage;
    tvi.cChildren   = (pnr->dwUsage & RESOURCEUSAGE_CONTAINER) ? 1 : 0;
    tvi.lParam      = (LPARAM)pnrChild;

    TV_INSERTSTRUCT tvis;
    tvis.hParent = hParent;
    tvis.item = tvi;
    tvis.hInsertAfter = TVI_LAST;
//     tvis.hInsertAfter = TVI_FIRST;
//     tvis.hInsertAfter = TVI_SORT;

    HTREEITEM hret = TreeView_InsertItem(GetDlgItem(hwnd, IDC_TREE), &tvis);
    if (NULL == hret)
    {
        TCHAR szMess[1000];
        wsprintf(szMess, TEXT("Couldn't insert item %s"), szBuf);
        MessageBox(hwnd, szMess, TEXT("Error"), MB_OK);
    }
}

VOID
GetItemText(
    IN LPNETRESOURCE pnr,
    OUT LPTSTR pszBuf           // assume it's big enough
    )
{
    LPTSTR pszT = NULL;
    TCHAR szTmp[500];

    *pszBuf = TEXT('\0');

    if (NULL == pnr)
    {
        _tcscat(pszBuf, g_szRoot);
        return;
    }

    if (pnr->lpRemoteName == NULL)
    {
        _stprintf(szTmp, TEXT("Null remote"));
        _tcscat(pszBuf, szTmp);
    }
    else if (   (pnr->lpRemoteName != NULL)
             && (*pnr->lpRemoteName != TEXT('\0'))
             )
    {
        _stprintf(szTmp, TEXT("%s"), pnr->lpRemoteName);
        _tcscat(pszBuf, szTmp);
    }

    if (   (pnr->lpLocalName != NULL)
        && (*pnr->lpLocalName != TEXT('\0'))
        )
    {
        _stprintf(szTmp, TEXT(" {%s}"), pnr->lpLocalName);
        _tcscat(pszBuf, szTmp);
    }

    if (   (pnr->lpComment != NULL)
        && (*pnr->lpComment != TEXT('\0'))
        )
    {
        _stprintf(szTmp, TEXT(" [%s]"), pnr->lpComment);
        _tcscat(pszBuf, szTmp);
    }

    if (   (pnr->lpProvider != NULL)
        && (*pnr->lpProvider != TEXT('\0'))
        )
    {
        _stprintf(szTmp, TEXT(" <%s>"), pnr->lpProvider);
        _tcscat(pszBuf, szTmp);
    }

    if (pnr->dwUsage & RESOURCEUSAGE_CONNECTABLE)
    {
        _tcscat(pszBuf, TEXT(" [connectable]"));
    }
    if (pnr->dwUsage & RESOURCEUSAGE_CONTAINER)
    {
        _tcscat(pszBuf, TEXT(" [container]"));
    }

    switch (pnr->dwDisplayType)
    {
    case RESOURCEDISPLAYTYPE_GENERIC:    pszT = TEXT(" {generic}");    break;
    case RESOURCEDISPLAYTYPE_DOMAIN:     pszT = TEXT(" {domain}");     break;
    case RESOURCEDISPLAYTYPE_SERVER:     pszT = TEXT(" {server}");     break;
    case RESOURCEDISPLAYTYPE_SHARE:      pszT = TEXT(" {share}");      break;
    case RESOURCEDISPLAYTYPE_FILE:       pszT = TEXT(" {file}");       break;
    case RESOURCEDISPLAYTYPE_GROUP:      pszT = TEXT(" {group}");      break;
    case RESOURCEDISPLAYTYPE_NETWORK:    pszT = TEXT(" {network}");    break;
    case RESOURCEDISPLAYTYPE_ROOT:       pszT = TEXT(" {root}");       break;
    case RESOURCEDISPLAYTYPE_SHAREADMIN: pszT = TEXT(" {shareadmin}"); break;
    case RESOURCEDISPLAYTYPE_DIRECTORY:  pszT = TEXT(" {directory}");  break;
    case RESOURCEDISPLAYTYPE_TREE:       pszT = TEXT(" {tree}");       break;
    default:                             pszT = TEXT(" {unknown}");    break;
    }
    _tcscat(pszBuf, pszT);
}


VOID
ErrorPopup(
    IN HWND hwnd,
    IN DWORD dwErr
    )
{
    TCHAR sz[500];

    if (dwErr == WN_EXTENDED_ERROR)
    {
        DWORD npErr;
        TCHAR szNpErr[500];
        TCHAR szNpName[500];

        DWORD dw = WNetGetLastError(&npErr, szNpErr, ARRAYLEN(szNpErr), szNpName, ARRAYLEN(szNpName));
        if (dw == WN_SUCCESS)
        {
            wsprintf(sz,
                TEXT("WN_EXTENDED_ERROR: %d, %s (%s)"),
                npErr,
                szNpErr,
                szNpName);
        }
        else
        {
            wsprintf(sz,
                TEXT("WN_EXTENDED_ERROR: WNetGetLastError error %d"),
                dw);
        }

        MessageBox(hwnd, sz, TEXT("Error"), MB_OK);
    }
    else
    {
        wsprintf(sz, TEXT("%d (0x%08lx) "), dwErr, dwErr);

        TCHAR szBuffer[MAX_PATH];
        DWORD dwBufferSize = ARRAYLEN(szBuffer);
        DWORD dwReturn = FormatMessage(
                            FORMAT_MESSAGE_FROM_SYSTEM,
                            NULL,
                            dwErr,
                            LANG_SYSTEM_DEFAULT,
                            szBuffer,
                            dwBufferSize,
                            NULL);
        if (0 == dwReturn)
        {
            // couldn't find message
            _tcscat(sz, TEXT("unknown error"));
        }
        else
        {
            _tcscat(sz, szBuffer);
        }

        MessageBox(hwnd, sz, TEXT("Error"), MB_OK);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\mprui\test2\sources.inc ===
TARGETTYPE=     PROGRAM
TARGETPATH=     obj

UMTYPE=         windows
UMENTRY=        winmain

INCLUDES=       $(NET_INC_PATH);

SOURCES=        ..\app.rc ..\t.cxx ..\nr.cxx ..\enum.cxx

CONDITIONAL_INCLUDES=\
                app.rc2 \
                afxres.h

TARGETLIBS=\
                $(NET_LIB_PATH)\mprp.lib \
                $(SDK_LIB_PATH)\comctl32.lib \
                $(TARGETLIBS)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\mprui\xlate\makefile.inc ===
$(O)\mpr.res: \
        $(SDK_INC_PATH)\windows.h \
        $(SDK_INC_PATH)\common.ver \
        $(SDK_INC_PATH)\ntverp.h \
        $(SDK_INC_PATH)\lmerr.h \
        ..\..\common\h\bltrc.h \
        ..\..\common\h\bltcons.h \
        ..\..\common\xlate\bltapp.rc \
        ..\..\common\xlate\bitmap\printer.bmp \
        ..\..\common\xlate\bitmap\printerd.bmp \
        ..\..\common\xlate\bitmap\drive.bmp \
        ..\..\common\xlate\bitmap\drived.bmp \
        ..\..\common\xlate\bitmap\blankdrv.bmp \
        ..\..\common\xlate\bitmap\gen.bmp \
        ..\..\common\xlate\bitmap\genex.bmp \
        ..\..\common\xlate\bitmap\gennox.bmp \
        ..\..\common\xlate\bitmap\prov.bmp \
        ..\..\common\xlate\bitmap\provex.bmp \
        ..\..\common\xlate\bitmap\shr.bmp \
        ..\..\common\xlate\bitmap\shrex.bmp \
        ..\..\common\xlate\bitmap\shrnox.bmp \
        ..\..\common\xlate\bitmap\srv.bmp \
        ..\..\common\xlate\bitmap\srvex.bmp \
        ..\..\common\xlate\bitmap\srvnox.bmp \
        ..\..\common\xlate\bitmap\dom.bmp \
        ..\..\common\xlate\bitmap\domex.bmp \
        ..\..\common\xlate\bitmap\domnox.bmp \
        ..\..\common\xlate\bitmap\print.bmp \
        ..\..\common\xlate\bitmap\printex.bmp \
        ..\..\common\xlate\bitmap\printnox.bmp \
        ..\..\common\xlate\bitmap\FILE.bmp \
        ..\..\common\xlate\bitmap\FILEex.bmp \
        ..\..\common\xlate\bitmap\FILEnox.bmp \
        ..\..\common\xlate\bitmap\mprgrp.bmp \
        ..\..\common\xlate\bitmap\mprgrpex.bmp \
        ..\..\common\xlate\bitmap\mprgrpnx.bmp \
        ..\..\common\xlate\bitmap\TREE.bmp \
        ..\..\common\xlate\bitmap\TREEex.bmp \
        ..\..\common\xlate\bitmap\TREEnox.bmp \
        ..\h\mprconn.h \
        ..\h\helpnums.h \
        .\bang.ico \
        .\mpr.str \
        .\mpr.dlg
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\mprui\test2\t.cxx ===
#include "headers.hxx"
#pragma hdrstop

// We wouldn't have to do this if C's semantics for the stringizing macro
// weren't so awful.

#define APINAME_WNetConnectionDialog2   "WNetConnectionDialog2"
#define APINAME_WNetDisconnectDialog2   "WNetDisconnectDialog2"

#ifdef UNICODE
    #define APINAME_WNetGetConnection2  "WNetGetConnection2W"
    #define APINAME_WNetGetConnection3  "WNetGetConnection3W"
    #define APINAME_WNetGetProviderType "WNetGetProviderTypeW"
#else
    #define APINAME_WNetGetConnection2  "WNetGetConnection2A"
    #define APINAME_WNetGetConnection3  "WNetGetConnection3A"
    #define APINAME_WNetGetProviderType "WNetGetProviderTypeA"
#endif

////////////////////////////////////////////////////////////////

TCHAR szMprDll[] = TEXT("mpr.dll");
HINSTANCE g_hInstanceMpr = NULL;    // if we need to manually load MPR

typedef
DWORD
(*PFNWNETGETCONNECTION2)(
    LPTSTR  lpLocalName,
    LPVOID  lpBuffer,
    LPDWORD lpBufferSize
    );

PFNWNETGETCONNECTION2 pfnWNetGetConnection2 = NULL;

typedef
DWORD
(*PFNWNETGETCONNECTION3)(
    LPCTSTR lpLocalName,
    LPCTSTR lpProviderName,
    DWORD   dwLevel,
    LPVOID  lpBuffer,
    LPDWORD lpBufferSize
    );

PFNWNETGETCONNECTION3 pfnWNetGetConnection3 = NULL;

typedef
DWORD
(*PFNWNETGETPROVIDERTYPE)(
    LPCTSTR           lpProvider,
    LPDWORD           lpdwNetType
    );

PFNWNETGETPROVIDERTYPE pfnWNetGetProviderType = NULL;

typedef
DWORD
(*PFNWNETCONNECTIONDIALOG2)(
    HWND    hwndParent,
    DWORD   dwType,
    WCHAR  *lpHelpFile,
    DWORD   nHelpContext
    );

PFNWNETCONNECTIONDIALOG2 pfnWNetConnectionDialog2 = NULL;

typedef
DWORD
(*PFNWNETDISCONNECTDIALOG2)(
    HWND    hwndParent,
    DWORD   dwType,
    WCHAR  *lpHelpFile,
    DWORD   nHelpContext
    );

PFNWNETDISCONNECTDIALOG2 pfnWNetDisconnectDialog2 = NULL;

////////////////////////////////////////////////////////////////

TCHAR szMprUIDll[] = TEXT("mprui.dll");
HINSTANCE g_hInstanceMprUI = NULL;    // if we need to manually load MPRUI

typedef
BOOL
(*PFUNC_VALIDATION_CALLBACK)(
    LPWSTR pszName
    );

typedef
DWORD
(*PFNWNETBROWSEDIALOG)(
    HWND    hwndParent,
    DWORD   dwType,
    WCHAR  *lpszName,
    DWORD   cchBufSize,
    WCHAR  *lpszHelpFile,
    DWORD   nHelpContext,
    PFUNC_VALIDATION_CALLBACK pfuncValidation
    );

PFNWNETBROWSEDIALOG pfnWNetBrowseDialog = NULL;

////////////////////////////////////////////////////////////////

HINSTANCE g_hInstance;

////////////////////////////////////////////////////////////////

VOID
PlaceIt(
    HWND hwnd
    )
{
    SetForegroundWindow(hwnd);

    // Use a trick from the property sheet code to properly place the dialog.
    // Basically, we want it to go wherever a new window would have gone, not
    // always in the upper-left corner of the screen. This avoids the problem
    // of multiple dialogs showing up in the same place on the screen,
    // overlapping each other.

    const TCHAR c_szStatic[] = TEXT("Static");

    HWND hwndT = CreateWindowEx(0, c_szStatic, NULL,
                    WS_OVERLAPPED, CW_USEDEFAULT, CW_USEDEFAULT,
                    0, 0, NULL, NULL, g_hInstance, NULL);
    if (hwndT)
    {
        RECT rc;
        GetWindowRect(hwndT, &rc);
        DestroyWindow(hwndT);
        SetWindowPos(hwnd, NULL, rc.left, rc.top, 0, 0, SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);
    }
}

////////////////////////////////////////////////////////////////

// load up the MPR.DLL and get its entrypoints.
// Return WN_SUCCESS if ok, else error. Note that we will return success even
// if we can't find a particular entrypoint. This allows dynamically loading
// entrypoints that exist on one platform/version but not on another.
DWORD
LoadMpr(
    VOID
    )
{
    if (NULL != g_hInstanceMpr)
    {
        return WN_SUCCESS;  // already loaded
    }

    g_hInstanceMpr = LoadLibrary(szMprDll);
    if (NULL == g_hInstanceMpr)
    {
        return GetLastError();
    }

    pfnWNetGetConnection2 = (PFNWNETGETCONNECTION2)GetProcAddress(g_hInstanceMpr, APINAME_WNetGetConnection2);
    pfnWNetGetConnection3 = (PFNWNETGETCONNECTION3)GetProcAddress(g_hInstanceMpr, APINAME_WNetGetConnection3);
    pfnWNetGetProviderType = (PFNWNETGETPROVIDERTYPE)GetProcAddress(g_hInstanceMpr, APINAME_WNetGetProviderType);
    pfnWNetConnectionDialog2 = (PFNWNETCONNECTIONDIALOG2)GetProcAddress(g_hInstanceMpr, APINAME_WNetConnectionDialog2);
    pfnWNetDisconnectDialog2 = (PFNWNETDISCONNECTDIALOG2)GetProcAddress(g_hInstanceMpr, APINAME_WNetDisconnectDialog2);

    return WN_SUCCESS;
}

// load up the MPRUI.DLL and get its entrypoints. Return WN_SUCCESS if ok, else error
DWORD
LoadMprUI(
    VOID
    )
{
    if (NULL != g_hInstanceMprUI)
    {
        return WN_SUCCESS;  // already loaded
    }

    g_hInstanceMprUI = LoadLibrary(szMprUIDll);
    if (NULL == g_hInstanceMprUI)
    {
        return GetLastError();
    }

    pfnWNetBrowseDialog = (PFNWNETBROWSEDIALOG)GetProcAddress(g_hInstanceMprUI, "WNetBrowseDialog");

    return WN_SUCCESS;
}

VOID
GetUsageString(
    IN LPTSTR pszBuf,           // better be big enough!
    IN LPNETRESOURCE pnr
    )
{
    TCHAR szTemp[MAX_PATH];
    pszBuf[0] = TEXT('\0');

    DWORD dwUsage = pnr->dwUsage;

    if (0 != dwUsage)
    {
        wsprintf(szTemp, TEXT("%d: "), dwUsage);
        _tcscat(pszBuf, szTemp);
    }

    if (dwUsage & RESOURCEUSAGE_CONNECTABLE)
    {
        wsprintf(szTemp, TEXT("connectable (%d) "), RESOURCEUSAGE_CONNECTABLE);
        _tcscat(pszBuf, szTemp);
        dwUsage &= ~RESOURCEUSAGE_CONNECTABLE;
    }
    if (dwUsage & RESOURCEUSAGE_CONTAINER)
    {
        wsprintf(szTemp, TEXT("container (%d) "), RESOURCEUSAGE_CONTAINER);
        _tcscat(pszBuf, szTemp);
        dwUsage &= ~RESOURCEUSAGE_CONTAINER;
    }
    if (dwUsage & RESOURCEUSAGE_NOLOCALDEVICE)
    {
        wsprintf(szTemp, TEXT("no local device (%d) "), RESOURCEUSAGE_NOLOCALDEVICE);
        _tcscat(pszBuf, szTemp);
        dwUsage &= ~RESOURCEUSAGE_NOLOCALDEVICE;
    }
    if (dwUsage & RESOURCEUSAGE_SIBLING)
    {
        wsprintf(szTemp, TEXT("sibling (%d) "), RESOURCEUSAGE_SIBLING);
        _tcscat(pszBuf, szTemp);
        dwUsage &= ~RESOURCEUSAGE_SIBLING;
    }
    if (dwUsage & RESOURCEUSAGE_RESERVED)
    {
        wsprintf(szTemp, TEXT("reserved (%d) "), RESOURCEUSAGE_RESERVED);
        _tcscat(pszBuf, szTemp);
        dwUsage &= ~RESOURCEUSAGE_RESERVED;
    }

    if (dwUsage != 0)
    {
        wsprintf(pszBuf, TEXT("UNKNOWN (%d) "), dwUsage);
    }
}

VOID
GetScopeString(
    IN LPTSTR pszBuf,           // better be big enough!
    IN LPNETRESOURCE pnr
    )
{
    LPTSTR pszT;
    switch (pnr->dwScope)
    {
    case RESOURCE_CONNECTED:  pszT = TEXT("connected");  break;
    case RESOURCE_GLOBALNET:  pszT = TEXT("globalnet");  break;
    case RESOURCE_REMEMBERED: pszT = TEXT("remembered"); break;
    case RESOURCE_RECENT:     pszT = TEXT("recent");     break;
    case RESOURCE_CONTEXT:    pszT = TEXT("context");    break;
    default:                  pszT = TEXT("UNKNOWN");    break;
    }
    wsprintf(pszBuf, TEXT("%s (%d)"), pszT, pnr->dwScope);
}


VOID
GetTypeString(
    IN LPTSTR pszBuf,           // better be big enough!
    IN LPNETRESOURCE pnr
    )
{
    LPTSTR pszT;
    switch (pnr->dwType)
    {
    case RESOURCETYPE_ANY:      pszT = TEXT("any");      break;
    case RESOURCETYPE_DISK:     pszT = TEXT("disk");     break;
    case RESOURCETYPE_PRINT:    pszT = TEXT("print");    break;
    case RESOURCETYPE_RESERVED: pszT = TEXT("reserved"); break;
    case RESOURCETYPE_UNKNOWN:  pszT = TEXT("unknown");  break;
    default:                    pszT = TEXT("UNKNOWN");  break;
    }
    wsprintf(pszBuf, TEXT("%s (%d)"), pszT, pnr->dwType);
}

VOID
GetDisplayTypeString(
    IN LPTSTR pszBuf,           // better be big enough!
    IN LPNETRESOURCE pnr
    )
{
    LPTSTR pszT;
    switch (pnr->dwDisplayType)
    {
    case RESOURCEDISPLAYTYPE_GENERIC:    pszT = TEXT("generic");    break;
    case RESOURCEDISPLAYTYPE_DOMAIN:     pszT = TEXT("domain");     break;
    case RESOURCEDISPLAYTYPE_SERVER:     pszT = TEXT("server");     break;
    case RESOURCEDISPLAYTYPE_SHARE:      pszT = TEXT("share");      break;
    case RESOURCEDISPLAYTYPE_FILE:       pszT = TEXT("file");       break;
    case RESOURCEDISPLAYTYPE_GROUP:      pszT = TEXT("group");      break;
    case RESOURCEDISPLAYTYPE_NETWORK:    pszT = TEXT("network");    break;
    case RESOURCEDISPLAYTYPE_ROOT:       pszT = TEXT("root");       break;
    case RESOURCEDISPLAYTYPE_SHAREADMIN: pszT = TEXT("shareadmin"); break;
    case RESOURCEDISPLAYTYPE_DIRECTORY:  pszT = TEXT("directory");  break;
    case RESOURCEDISPLAYTYPE_TREE:       pszT = TEXT("tree");       break;
    default:                             pszT = TEXT("UNKNOWN");    break;
    }
    wsprintf(pszBuf, TEXT("%s (%d)"), pszT, pnr->dwDisplayType);
}


VOID
DoError(
    HWND hwnd,
    DWORD dwErr
    )
{
    TCHAR sz[500];

    if (dwErr == WN_EXTENDED_ERROR)
    {
        DWORD npErr;
        TCHAR szNpErr[500];
        TCHAR szNpName[500];

        DWORD dw = WNetGetLastError(&npErr, szNpErr, ARRAYLEN(szNpErr), szNpName, ARRAYLEN(szNpName));
        if (dw == WN_SUCCESS)
        {
            wsprintf(sz,
                TEXT("WN_EXTENDED_ERROR: %d, %s (%s)"),
                npErr,
                szNpErr,
                szNpName);
        }
        else
        {
            wsprintf(sz,
                TEXT("WN_EXTENDED_ERROR: WNetGetLastError error %d"),
                dw);
        }
        SetDlgItemText(hwnd, IDC_ERROR, sz);
    }
    else
    {
        wsprintf(sz, TEXT("%d (0x%08lx) "), dwErr, dwErr);

        TCHAR szBuffer[MAX_PATH];
        DWORD dwBufferSize = ARRAYLEN(szBuffer);
        DWORD dwReturn = FormatMessage(
                            FORMAT_MESSAGE_FROM_SYSTEM,
                            NULL,
                            dwErr,
                            LANG_SYSTEM_DEFAULT,
                            szBuffer,
                            dwBufferSize,
                            NULL);
        if (0 == dwReturn)
        {
            // couldn't find message
            _tcscat(sz, TEXT("unknown error"));
        }
        else
        {
            _tcscat(sz, szBuffer);
        }

        SetDlgItemText(hwnd, IDC_ERROR, sz);
    }

    if (dwErr != WN_SUCCESS && dwErr != 0xffffffff)
    {
        Beep(1000, 150);
    }
}


INT_PTR CALLBACK
Connection1DlgProc(
    IN HWND   hwnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    static int options[] =
    {
        IDC_RO_PATH,
        IDC_USE_MRU,
        IDC_HIDE_BOX,
        IDC_PERSIST,
        IDC_NOT_PERSIST,
        IDC_CONN_POINT,
        IDC_YESPATH,
        IDC_NOPATH,
        IDC_DISK,
        IDC_PRINTER
    };

    switch (uMsg)
    {
    case WM_INITDIALOG:
        PlaceIt(hwnd);
        SetDlgItemText(hwnd, IDC_REMOTE_TEXT, TEXT("\\\\scratch\\scratch"));
        SetDlgItemText(hwnd, IDC_ERROR,  TEXT(""));
        SetDlgItemText(hwnd, IDC_DEVICE, TEXT(""));
        CheckRadioButton(hwnd, IDC_YESPATH, IDC_NOPATH, IDC_YESPATH);
        CheckRadioButton(hwnd, IDC_DISK, IDC_PRINTER, IDC_DISK);
        return 1;   // didn't call SetFocus

    case WM_COMMAND:
    {
        switch (LOWORD(wParam))
        {
        case IDC_GO:
        {
            LPCONNECTDLGSTRUCT lpConnDlgStruct;
            CONNECTDLGSTRUCT conn;

            if (1 == IsDlgButtonChecked(hwnd, IDC_NULL))
            {
                lpConnDlgStruct = NULL;
            }
            else
            {
                // get the flags
                DWORD dwFlags = 0;

                if (1 == IsDlgButtonChecked(hwnd, IDC_RO_PATH))
                {
                    dwFlags |= CONNDLG_RO_PATH;
                }
                if (1 == IsDlgButtonChecked(hwnd, IDC_USE_MRU))
                {
                    dwFlags |= CONNDLG_USE_MRU;
                }
                if (1 == IsDlgButtonChecked(hwnd, IDC_HIDE_BOX))
                {
                    dwFlags |= CONNDLG_HIDE_BOX;
                }
                if (1 == IsDlgButtonChecked(hwnd, IDC_PERSIST))
                {
                    dwFlags |= CONNDLG_PERSIST;
                }
                if (1 == IsDlgButtonChecked(hwnd, IDC_NOT_PERSIST))
                {
                    dwFlags |= CONNDLG_NOT_PERSIST;
                }
                if (1 == IsDlgButtonChecked(hwnd, IDC_CONN_POINT))
                {
                    dwFlags |= CONNDLG_CONN_POINT;
                }

                TCHAR szRemoteName[200];
                LPTSTR pszRemoteName = NULL;
                if (1 == IsDlgButtonChecked(hwnd, IDC_YESPATH))
                {
                    GetDlgItemText(hwnd, IDC_REMOTE_TEXT, szRemoteName, ARRAYLEN(szRemoteName));
                    pszRemoteName = szRemoteName;
                }
                else
                {
                    pszRemoteName = NULL;
                }

                DWORD dwType = 0;
                if (1 == IsDlgButtonChecked(hwnd, IDC_DISK))
                {
                    dwType = RESOURCETYPE_DISK;
                }
                else if (1 == IsDlgButtonChecked(hwnd, IDC_PRINTER))
                {
                    dwType = RESOURCETYPE_PRINT;
                }
                else
                {
                    // internal error
                }

                NETRESOURCE net;

                conn.cbStructure    = sizeof(conn);
                conn.hwndOwner      = hwnd;
                conn.lpConnRes      = &net;
                conn.dwFlags        = dwFlags;
                conn.dwDevNum       = 999;  // initialize to something recognizable

                net.dwScope         = 0;
                net.dwType          = dwType;
                net.dwDisplayType   = 0;
                net.dwUsage         = 0;
                net.lpLocalName     = NULL;
                net.lpRemoteName    = pszRemoteName;
                net.lpComment       = NULL;
                net.lpProvider      = NULL;

                lpConnDlgStruct = &conn;
            }

            // clear it
            SetDlgItemText(hwnd, IDC_ERROR,  TEXT(""));
            SetDlgItemText(hwnd, IDC_DEVICE, TEXT(""));

            HCURSOR hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
            DWORD dw = WNetConnectionDialog1(lpConnDlgStruct);
            SetCursor(hOldCursor);

            TCHAR sz[500];
            sz[0] = L'\0';
            if (NULL != lpConnDlgStruct)
            {
                wsprintf(sz, TEXT("%d"), lpConnDlgStruct->dwDevNum);
            }
            SetDlgItemText(hwnd, IDC_DEVICE, sz);

            DoError(hwnd, dw);

            return TRUE;
        }

        case IDOK:
            EndDialog(hwnd, TRUE);
            return TRUE;

        case IDC_NULL:
        {
            BOOL bOn = (BST_UNCHECKED == IsDlgButtonChecked(hwnd, IDC_NULL));
            for (int i = 0; i < ARRAYLEN(options); i++)
            {
                EnableWindow(GetDlgItem(hwnd, options[i]), bOn);
            }
            return TRUE;
        }

        }

        return FALSE;
    }

    default:
        return FALSE;   // didn't process
    }
}

INT_PTR CALLBACK
Disconnect1DlgProc(
    IN HWND   hwnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    static int options[] =
    {
        IDC_UPDATE_PROFILE,
        IDC_NO_FORCE,
        IDC_LOCAL,
        IDC_REMOTE
    };

    switch (uMsg)
    {
    case WM_INITDIALOG:
        PlaceIt(hwnd);
        SetDlgItemText(hwnd, IDC_ERROR,  TEXT(""));

        SetDlgItemText(hwnd, IDC_LOCAL_TEXT, TEXT(""));
        EnableWindow(GetDlgItem(hwnd, IDC_LOCAL_TEXT), FALSE);
        CheckDlgButton(hwnd, IDC_LOCAL_TEXT, 0);

        SetDlgItemText(hwnd, IDC_REMOTE_TEXT, TEXT(""));
        EnableWindow(GetDlgItem(hwnd, IDC_REMOTE_TEXT), FALSE);
        CheckDlgButton(hwnd, IDC_REMOTE_TEXT, 0);

        CheckDlgButton(hwnd, IDC_UPDATE_PROFILE, 0);
        CheckDlgButton(hwnd, IDC_NO_FORCE, 0);
        return 1;   // didn't call SetFocus

    case WM_COMMAND:
    {
        switch (LOWORD(wParam))
        {
        case IDC_GO:
        {
            LPDISCDLGSTRUCT lpDiscDlgStruct;
            DISCDLGSTRUCT disc;

            if (1 == IsDlgButtonChecked(hwnd, IDC_NULL))
            {
                lpDiscDlgStruct = NULL;
            }
            else
            {
                // get the flags
                DWORD dwFlags = 0;

                if (1 == IsDlgButtonChecked(hwnd, IDC_UPDATE_PROFILE))
                {
                    dwFlags |= DISC_UPDATE_PROFILE;
                }
                if (1 == IsDlgButtonChecked(hwnd, IDC_NO_FORCE))
                {
                    dwFlags |= DISC_NO_FORCE;
                }

                TCHAR szLocalName[200];
                LPTSTR pszLocalName = NULL;
                if (1 == IsDlgButtonChecked(hwnd, IDC_LOCAL))
                {
                    GetDlgItemText(hwnd, IDC_LOCAL_TEXT, szLocalName, ARRAYLEN(szLocalName));
                    pszLocalName = szLocalName;
                }

                TCHAR szRemoteName[200];
                LPTSTR pszRemoteName = NULL;
                if (1 == IsDlgButtonChecked(hwnd, IDC_REMOTE))
                {
                    GetDlgItemText(hwnd, IDC_REMOTE_TEXT, szRemoteName, ARRAYLEN(szRemoteName));
                    pszRemoteName = szRemoteName;
                }

                disc.cbStructure    = sizeof(disc);
                disc.hwndOwner      = hwnd;
                disc.lpLocalName    = pszLocalName;
                disc.lpRemoteName   = pszRemoteName;
                disc.dwFlags        = dwFlags;

                lpDiscDlgStruct = &disc;
            }

            // clear it
            SetDlgItemText(hwnd, IDC_ERROR,  TEXT(""));

            HCURSOR hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
            DWORD dw = WNetDisconnectDialog1(lpDiscDlgStruct);
            SetCursor(hOldCursor);

            DoError(hwnd, dw);
            return TRUE;
        }

        case IDOK:
            EndDialog(hwnd, TRUE);
            return TRUE;

        case IDC_LOCAL:
            EnableWindow(GetDlgItem(hwnd, IDC_LOCAL_TEXT),
                (1 == IsDlgButtonChecked(hwnd, IDC_LOCAL)));
            break;

        case IDC_REMOTE:
            EnableWindow(GetDlgItem(hwnd, IDC_REMOTE_TEXT),
                (1 == IsDlgButtonChecked(hwnd, IDC_REMOTE)));
            break;

        case IDC_NULL:
        {
            BOOL bOn = (BST_UNCHECKED == IsDlgButtonChecked(hwnd, IDC_NULL));
            for (int i = 0; i < ARRAYLEN(options); i++)
            {
                EnableWindow(GetDlgItem(hwnd, options[i]), bOn);
            }
            // special handling of text fields:
            EnableWindow(GetDlgItem(hwnd, IDC_LOCAL_TEXT),
                bOn && (1 == IsDlgButtonChecked(hwnd, IDC_LOCAL)));
            EnableWindow(GetDlgItem(hwnd, IDC_REMOTE_TEXT),
                bOn && (1 == IsDlgButtonChecked(hwnd, IDC_REMOTE)));

            return TRUE;
        }

        }
        return FALSE;
    }

    default:
        return FALSE;   // didn't process
    }
}

INT_PTR CALLBACK
ConnectionDlgProc(
    IN HWND   hwnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        PlaceIt(hwnd);
        SetDlgItemText(hwnd, IDC_ERROR,  TEXT(""));
        CheckRadioButton(hwnd, IDC_DISK, IDC_PRINTER, IDC_DISK);
        return 1;   // didn't call SetFocus

    case WM_COMMAND:
    {
        switch (LOWORD(wParam))
        {
        case IDC_GO:
        {
            DWORD dwType = 0;
            if (1 == IsDlgButtonChecked(hwnd, IDC_DISK))
            {
                dwType = RESOURCETYPE_DISK;
            }
            else if (1 == IsDlgButtonChecked(hwnd, IDC_PRINTER))
            {
                dwType = RESOURCETYPE_PRINT;
            }
            else
            {
                // internal error
            }

            // clear it
            SetDlgItemText(hwnd, IDC_ERROR,  TEXT(""));

            HCURSOR hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
            DWORD dw = WNetConnectionDialog(hwnd, dwType);
            SetCursor(hOldCursor);

            DoError(hwnd, dw);
            return TRUE;
        }

        case IDOK:
            EndDialog(hwnd, TRUE);
            return TRUE;
        }

        return FALSE;
    }

    default:
        return FALSE;   // didn't process
    }
}

INT_PTR CALLBACK
DisconnectDlgProc(
    IN HWND   hwnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        PlaceIt(hwnd);
        SetDlgItemText(hwnd, IDC_ERROR,  TEXT(""));
        CheckRadioButton(hwnd, IDC_DISK, IDC_PRINTER, IDC_DISK);
        return 1;   // didn't call SetFocus

    case WM_COMMAND:
    {
        switch (LOWORD(wParam))
        {
        case IDC_GO:
        {
            DWORD dwType = 0;
            if (1 == IsDlgButtonChecked(hwnd, IDC_DISK))
            {
                dwType = RESOURCETYPE_DISK;
            }
            else if (1 == IsDlgButtonChecked(hwnd, IDC_PRINTER))
            {
                dwType = RESOURCETYPE_PRINT;
            }
            else
            {
                // internal error
            }

            // clear it
            SetDlgItemText(hwnd, IDC_ERROR,  TEXT(""));

            HCURSOR hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
            DWORD dw = WNetDisconnectDialog(hwnd, dwType);
            SetCursor(hOldCursor);

            DoError(hwnd, dw);
            return TRUE;
        }

        case IDOK:
            EndDialog(hwnd, TRUE);
            return TRUE;
        }

        return FALSE;
    }

    default:
        return FALSE;   // didn't process
    }
}

INT_PTR CALLBACK
Connection2DlgProc(
    IN HWND   hwnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        PlaceIt(hwnd);
        SetDlgItemText(hwnd, IDC_ERROR,     TEXT(""));
        SetDlgItemText(hwnd, IDC_HELPFILE,  TEXT("winfile.hlp"));
        SetDlgItemText(hwnd, IDC_HELPINDEX, TEXT("5205"));
        CheckRadioButton(hwnd, IDC_DISK, IDC_PRINTER, IDC_DISK);
        return 1;   // didn't call SetFocus

    case WM_COMMAND:
    {
        switch (LOWORD(wParam))
        {
        case IDC_GO:
        {
            DWORD dwType = 0;
            if (1 == IsDlgButtonChecked(hwnd, IDC_DISK))
            {
                dwType = RESOURCETYPE_DISK;
            }
            else if (1 == IsDlgButtonChecked(hwnd, IDC_PRINTER))
            {
                dwType = RESOURCETYPE_PRINT;
            }
            else
            {
                // internal error
            }

            WCHAR szHelpFile[200];
            GetDlgItemTextW(hwnd, IDC_HELPFILE, szHelpFile, ARRAYLEN(szHelpFile));

            DWORD nHelpContext = 5205;  // default
            BOOL translated;
            UINT uhelp = GetDlgItemInt(hwnd, IDC_HELPINDEX, &translated, FALSE);
            if (translated)
            {
                nHelpContext = uhelp;
            }

            // clear it
            SetDlgItemText(hwnd, IDC_ERROR,  TEXT(""));

            HCURSOR hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
            DWORD dw = LoadMpr();
            if (dw == WN_SUCCESS)
            {
                if (NULL == pfnWNetConnectionDialog2)
                {
                    dw = ERROR_PROC_NOT_FOUND;
                }
                else
                {
                    dw = (*pfnWNetConnectionDialog2)(hwnd, dwType, szHelpFile, nHelpContext);
                }
            }
            SetCursor(hOldCursor);

            DoError(hwnd, dw);
            return TRUE;
        }

        case IDOK:
            EndDialog(hwnd, TRUE);
            return TRUE;
        }

        return FALSE;
    }

    default:
        return FALSE;   // didn't process
    }
}

INT_PTR CALLBACK
Disconnect2DlgProc(
    IN HWND   hwnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        PlaceIt(hwnd);
        SetDlgItemText(hwnd, IDC_ERROR,     TEXT(""));
        SetDlgItemText(hwnd, IDC_HELPFILE,  TEXT("winfile.hlp"));
        SetDlgItemText(hwnd, IDC_HELPINDEX, TEXT("5206"));
        CheckRadioButton(hwnd, IDC_DISK, IDC_PRINTER, IDC_DISK);
        return 1;   // didn't call SetFocus

    case WM_COMMAND:
    {
        switch (LOWORD(wParam))
        {
        case IDC_GO:
        {
            DWORD dwType = 0;
            if (1 == IsDlgButtonChecked(hwnd, IDC_DISK))
            {
                dwType = RESOURCETYPE_DISK;
            }
            else if (1 == IsDlgButtonChecked(hwnd, IDC_PRINTER))
            {
                dwType = RESOURCETYPE_PRINT;
            }
            else
            {
                // internal error
            }

            WCHAR szHelpFile[200];
            GetDlgItemTextW(hwnd, IDC_HELPFILE, szHelpFile, ARRAYLEN(szHelpFile));

            DWORD nHelpContext = 5206;  // default
            BOOL translated;
            UINT uhelp = GetDlgItemInt(hwnd, IDC_HELPINDEX, &translated, FALSE);
            if (translated)
            {
                nHelpContext = uhelp;
            }

            // clear it
            SetDlgItemText(hwnd, IDC_ERROR,  TEXT(""));

            HCURSOR hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
            DWORD dw = LoadMpr();
            if (dw == WN_SUCCESS)
            {
                if (NULL == pfnWNetDisconnectDialog2)
                {
                    dw = ERROR_PROC_NOT_FOUND;
                }
                else
                {
                    dw = (*pfnWNetDisconnectDialog2)(hwnd, dwType, szHelpFile, nHelpContext);
                }
            }
            SetCursor(hOldCursor);

            DoError(hwnd, dw);
            return TRUE;
        }

        case IDOK:
            EndDialog(hwnd, TRUE);
            return TRUE;
        }

        return FALSE;
    }

    default:
        return FALSE;   // didn't process
    }
}

BOOL
BrowseValidationCallback(
    LPWSTR pszName
    )
{
    return TRUE;
}

INT_PTR CALLBACK
BrowseDlgProc(
    IN HWND   hwnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        PlaceIt(hwnd);
        SetDlgItemText(hwnd, IDC_ERROR,       TEXT(""));
        SetDlgItemText(hwnd, IDC_BROWSE_NAME, TEXT(""));
        CheckRadioButton(hwnd, IDC_DISK, IDC_PRINTER, IDC_DISK);
        return 1;   // didn't call SetFocus

    case WM_COMMAND:
    {
        switch (LOWORD(wParam))
        {
        case IDC_GO:
        {
            DWORD dwType = 0;
            if (1 == IsDlgButtonChecked(hwnd, IDC_DISK))
            {
                dwType = RESOURCETYPE_DISK;
            }
            else if (1 == IsDlgButtonChecked(hwnd, IDC_PRINTER))
            {
                dwType = RESOURCETYPE_PRINT;
            }
            else
            {
                // internal error
            }

            // clear it
            SetDlgItemText(hwnd, IDC_ERROR,       TEXT(""));
            SetDlgItemText(hwnd, IDC_BROWSE_NAME, TEXT(""));

            HCURSOR hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
            WCHAR szName[MAX_PATH];
            DWORD dw = LoadMprUI();
            if (dw == WN_SUCCESS)
            {
                if (NULL == pfnWNetBrowseDialog)
                {
                    dw = ERROR_PROC_NOT_FOUND;
                }
                else
                {
                    dw = (*pfnWNetBrowseDialog)(
                                hwnd,
                                dwType,
                                szName,
                                ARRAYLEN(szName),
                                L"help.hlp",        // help file
                                0,                  // help context
                                &BrowseValidationCallback);
                }
            }
            SetCursor(hOldCursor);

            if (dw == WN_SUCCESS)
            {
                SetDlgItemTextW(hwnd, IDC_BROWSE_NAME, szName);
            }

            DoError(hwnd, dw);
            return TRUE;
        }

        case IDOK:
            EndDialog(hwnd, TRUE);
            return TRUE;
        }

        return FALSE;
    }

    default:
        return FALSE;   // didn't process
    }
}

INT_PTR CALLBACK
GetConnectionDlgProc(
    IN HWND   hwnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        PlaceIt(hwnd);
        SetDlgItemText(hwnd, IDC_ERROR,  TEXT(""));
        SetDlgItemText(hwnd, IDC_REMOTE, TEXT(""));
        SetDlgItemText(hwnd, IDC_LOCAL_TEXT, TEXT(""));
        SetDlgItemText(hwnd, IDC_BUFSIZEIN, TEXT(""));
        SetDlgItemText(hwnd, IDC_BUFSIZE, TEXT(""));
        return 1;   // didn't call SetFocus

    case WM_COMMAND:
    {
        switch (LOWORD(wParam))
        {
        case IDC_GO:
        {
            TCHAR szLocalName[200];
            GetDlgItemText(hwnd, IDC_LOCAL_TEXT, szLocalName, ARRAYLEN(szLocalName));

            TCHAR szReturn[MAX_PATH];
            DWORD bufSize = ARRAYLEN(szReturn);
            DWORD bufSizeIn = bufSize;

            // clear it
            SetDlgItemText(hwnd, IDC_ERROR,      TEXT(""));
            SetDlgItemText(hwnd, IDC_REMOTE,     TEXT(""));
            SetDlgItemText(hwnd, IDC_BUFSIZEIN,  TEXT(""));
            SetDlgItemText(hwnd, IDC_BUFSIZE,    TEXT(""));

            HCURSOR hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
            DWORD dw = WNetGetConnection(szLocalName, szReturn, &bufSize);
            SetCursor(hOldCursor);

            if (dw == WN_SUCCESS ||
                dw == WN_CONNECTION_CLOSED)
            {
                SetDlgItemText(hwnd, IDC_REMOTE, szReturn);
            }
            else
            {
                SetDlgItemText(hwnd, IDC_REMOTE, TEXT(""));
            }

            TCHAR sz[500];
            wsprintf(sz, TEXT("%d"), bufSize);
            SetDlgItemText(hwnd, IDC_BUFSIZE, sz);
            wsprintf(sz, TEXT("%d"), bufSizeIn);
            SetDlgItemText(hwnd, IDC_BUFSIZEIN, sz);

            DoError(hwnd, dw);
            return TRUE;
        }

        case IDOK:
            EndDialog(hwnd, TRUE);
            return TRUE;
        }

        return FALSE;
    }

    default:
        return FALSE;   // didn't process
    }
}

INT_PTR CALLBACK
GetConnectionDlgProc2(
    IN HWND   hwnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        PlaceIt(hwnd);
        SetDlgItemText(hwnd, IDC_ERROR,  TEXT(""));
        SetDlgItemText(hwnd, IDC_REMOTE, TEXT(""));
        SetDlgItemText(hwnd, IDC_PROVIDER, TEXT(""));
        SetDlgItemText(hwnd, IDC_LOCAL_TEXT, TEXT(""));
        SetDlgItemText(hwnd, IDC_BUFSIZE, TEXT(""));
        SetDlgItemText(hwnd, IDC_BUFSIZEIN, TEXT(""));
        return 1;   // didn't call SetFocus

    case WM_COMMAND:
    {
        switch (LOWORD(wParam))
        {
        case IDC_GO:
        {
            TCHAR szLocalName[200];
            GetDlgItemText(hwnd, IDC_LOCAL_TEXT, szLocalName, ARRAYLEN(szLocalName));

            BYTE buf[MAX_PATH*2 + sizeof(WNET_CONNECTIONINFO)];
            WNET_CONNECTIONINFO* pInfo = (WNET_CONNECTIONINFO*)buf;
            DWORD bufSize = sizeof(buf);
            DWORD bufSizeIn = bufSize;

            // clear it
            SetDlgItemText(hwnd, IDC_ERROR,  TEXT(""));
            SetDlgItemText(hwnd, IDC_REMOTE, TEXT(""));
            SetDlgItemText(hwnd, IDC_PROVIDER, TEXT(""));
            SetDlgItemText(hwnd, IDC_BUFSIZE, TEXT(""));
            SetDlgItemText(hwnd, IDC_BUFSIZEIN, TEXT(""));

            HCURSOR hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));

            DWORD dw = LoadMpr();
            if (dw == WN_SUCCESS)
            {
                if (NULL == pfnWNetGetConnection2)
                {
                    dw = ERROR_PROC_NOT_FOUND;
                }
                else
                {
                    dw = (*pfnWNetGetConnection2)(szLocalName, (LPVOID)buf, &bufSize);
                }
            }
            SetCursor(hOldCursor);

            if (dw == WN_SUCCESS ||
                dw == WN_CONNECTION_CLOSED)
            {
                SetDlgItemText(hwnd, IDC_REMOTE,   pInfo->lpRemoteName);
                SetDlgItemText(hwnd, IDC_PROVIDER, pInfo->lpProvider);
            }
            else
            {
                SetDlgItemText(hwnd, IDC_REMOTE,   TEXT(""));
                SetDlgItemText(hwnd, IDC_PROVIDER, TEXT(""));
            }

            TCHAR sz[500];
            wsprintf(sz, TEXT("%d"), bufSize);
            SetDlgItemText(hwnd, IDC_BUFSIZE, sz);
            wsprintf(sz, TEXT("%d"), bufSizeIn);
            SetDlgItemText(hwnd, IDC_BUFSIZEIN, sz);

            DoError(hwnd, dw);
            return TRUE;
        }

        case IDOK:
            EndDialog(hwnd, TRUE);
            return TRUE;
        }

        return FALSE;
    }

    default:
        return FALSE;   // didn't process
    }
}

INT_PTR CALLBACK
GetConnection3DlgProc(
    IN HWND   hwnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        PlaceIt(hwnd);
        SetDlgItemText(hwnd, IDC_ERROR,  TEXT(""));

        SetDlgItemText(hwnd, IDC_LOCAL_TEXT, TEXT(""));
        EnableWindow(GetDlgItem(hwnd, IDC_LOCAL_TEXT), FALSE);
        CheckDlgButton(hwnd, IDC_LOCAL_TEXT, 0);

        SetDlgItemText(hwnd, IDC_PROVIDER_TEXT, TEXT(""));
        EnableWindow(GetDlgItem(hwnd, IDC_PROVIDER_TEXT), FALSE);
        CheckDlgButton(hwnd, IDC_PROVIDER_TEXT, 0);

        SetDlgItemInt (hwnd, IDC_INFOLEVEL,      1, FALSE); // test level 1 only
        SetDlgItemText(hwnd, IDC_RETURNFLAGS,    TEXT(""));
        SetDlgItemInt (hwnd, IDC_BUFSIZEIN,      sizeof(DWORD), FALSE);
        SetDlgItemText(hwnd, IDC_BUFSIZE,        TEXT(""));

        return 1;   // didn't call SetFocus

    case WM_COMMAND:
    {
        switch (LOWORD(wParam))
        {
        case IDC_GO:
        {
            TCHAR szLocalName[200];
            LPTSTR pszLocalName = NULL;
            if (1 == IsDlgButtonChecked(hwnd, IDC_LOCAL))
            {
                GetDlgItemText(hwnd, IDC_LOCAL_TEXT, szLocalName, ARRAYLEN(szLocalName));
                pszLocalName = szLocalName;
            }

            TCHAR szProviderName[200];
            LPTSTR pszProviderName = NULL;
            if (1 == IsDlgButtonChecked(hwnd, IDC_PROVIDER))
            {
                GetDlgItemText(hwnd, IDC_PROVIDER_TEXT, szProviderName, ARRAYLEN(szProviderName));
                pszProviderName = szProviderName;
            }

            WNGC_CONNECTION_STATE ConnState;
            DWORD bufSizeIn = sizeof(ConnState);
            DWORD bufSize = bufSizeIn;

            // clear it
            SetDlgItemText(hwnd, IDC_RETURNFLAGS,    TEXT(""));
            SetDlgItemText(hwnd, IDC_BUFSIZE,        TEXT(""));
            SetDlgItemText(hwnd, IDC_BUFSIZEIN,      TEXT(""));

            HCURSOR hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
            DWORD dw = LoadMpr();
            if (dw == WN_SUCCESS)
            {
                if (NULL == pfnWNetGetConnection3)
                {
                    dw = ERROR_PROC_NOT_FOUND;
                }
                else
                {
                    dw = (*pfnWNetGetConnection3)(
                            pszLocalName,
                            pszProviderName,
                            WNGC_INFOLEVEL_DISCONNECTED,    // level
                            &ConnState,     // buffer
                            &bufSize        // buffer size
                            );
                }
            }
            SetCursor(hOldCursor);

            DoError(hwnd, dw);

            if (WN_SUCCESS == dw)
            {
                TCHAR szBuf[50];
                wsprintf(szBuf, TEXT("%lu (%hs)"), ConnState,
                     (ConnState.dwState == WNGC_CONNECTED) ? "WNGC_CONNECTED" :
                     (ConnState.dwState == WNGC_DISCONNECTED) ? "WNGC_DISCONNECTED" :
                     "Unrecognized"
                     );
                SetDlgItemText(hwnd, IDC_RETURNFLAGS,    szBuf);
            }

            SetDlgItemInt(hwnd, IDC_BUFSIZEIN, bufSizeIn, FALSE);
            SetDlgItemInt(hwnd, IDC_BUFSIZE  , bufSize  , FALSE);

            return TRUE;
        }

        case IDOK:
            EndDialog(hwnd, TRUE);
            return TRUE;

        case IDC_LOCAL:
            EnableWindow(GetDlgItem(hwnd, IDC_LOCAL_TEXT),
                (1 == IsDlgButtonChecked(hwnd, IDC_LOCAL)));
            return TRUE;

        case IDC_PROVIDER:
            EnableWindow(GetDlgItem(hwnd, IDC_PROVIDER_TEXT),
                (1 == IsDlgButtonChecked(hwnd, IDC_PROVIDER)));
            return TRUE;

        } // end switch (LOWORD(wParam))

        return FALSE;
    }

    default:
        return FALSE;   // didn't process
    }
}

INT_PTR CALLBACK
GetConnectionPerformanceDlgProc(
    IN HWND   hwnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        PlaceIt(hwnd);
        SetDlgItemText(hwnd, IDC_ERROR,  TEXT(""));

        SetDlgItemText(hwnd, IDC_LOCAL_TEXT, TEXT(""));
        EnableWindow(GetDlgItem(hwnd, IDC_LOCAL_TEXT), FALSE);
        CheckDlgButton(hwnd, IDC_LOCAL_TEXT, 0);

        SetDlgItemText(hwnd, IDC_REMOTE_TEXT, TEXT(""));
        EnableWindow(GetDlgItem(hwnd, IDC_REMOTE_TEXT), FALSE);
        CheckDlgButton(hwnd, IDC_REMOTE_TEXT, 0);

        SetDlgItemText(hwnd, IDC_PROVIDER_TEXT, TEXT(""));
        EnableWindow(GetDlgItem(hwnd, IDC_PROVIDER_TEXT), FALSE);
        CheckDlgButton(hwnd, IDC_PROVIDER_TEXT, 0);

        SetDlgItemText(hwnd, IDC_RETURNFLAGS,    TEXT(""));
        SetDlgItemText(hwnd, IDC_RETURNSPEED,    TEXT(""));
        SetDlgItemText(hwnd, IDC_RETURNDELAY,    TEXT(""));
        SetDlgItemText(hwnd, IDC_RETURNOPTDATASIZE, TEXT(""));
        SetDlgItemText(hwnd, IDC_BUFSIZE,        TEXT(""));
        SetDlgItemText(hwnd, IDC_BUFSIZEIN,      TEXT(""));

        return 1;   // didn't call SetFocus

    case WM_COMMAND:
    {
        switch (LOWORD(wParam))
        {
        case IDC_GO:
        {
            TCHAR szLocalName[200];
            LPTSTR pszLocalName = NULL;
            if (1 == IsDlgButtonChecked(hwnd, IDC_LOCAL))
            {
                GetDlgItemText(hwnd, IDC_LOCAL_TEXT, szLocalName, ARRAYLEN(szLocalName));
                pszLocalName = szLocalName;
            }

            TCHAR szRemoteName[200];
            LPTSTR pszRemoteName = NULL;
            if (1 == IsDlgButtonChecked(hwnd, IDC_REMOTE))
            {
                GetDlgItemText(hwnd, IDC_REMOTE_TEXT, szRemoteName, ARRAYLEN(szRemoteName));
                pszRemoteName = szRemoteName;
            }

            TCHAR szProviderName[200];
            LPTSTR pszProviderName = NULL;
            if (1 == IsDlgButtonChecked(hwnd, IDC_PROVIDER))
            {
                GetDlgItemText(hwnd, IDC_PROVIDER_TEXT, szProviderName, ARRAYLEN(szProviderName));
                pszProviderName = szProviderName;
            }

            NETRESOURCE net;

            net.dwScope         = 0;
            net.dwType          = 0;
            net.dwDisplayType   = 0;
            net.dwUsage         = 0;
            net.lpLocalName     = pszLocalName;
            net.lpRemoteName    = pszRemoteName;
            net.lpComment       = NULL;
            net.lpProvider      = pszProviderName;

            NETCONNECTINFOSTRUCT inf;

            inf.cbStructure = sizeof(inf);
            DWORD bufSizeIn = inf.cbStructure;

            // clear it
            SetDlgItemText(hwnd, IDC_RETURNFLAGS,    TEXT(""));
            SetDlgItemText(hwnd, IDC_RETURNSPEED,    TEXT(""));
            SetDlgItemText(hwnd, IDC_RETURNDELAY,    TEXT(""));
            SetDlgItemText(hwnd, IDC_RETURNOPTDATASIZE, TEXT(""));
            SetDlgItemText(hwnd, IDC_BUFSIZE,        TEXT(""));
            SetDlgItemText(hwnd, IDC_BUFSIZEIN,      TEXT(""));

            HCURSOR hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
            DWORD dw = MultinetGetConnectionPerformance(
                                &net,
                                &inf);
            SetCursor(hOldCursor);

            DoError(hwnd, dw);

            if (WN_SUCCESS == dw)
            {
                TCHAR szBuf[MAX_PATH];
                wsprintf(szBuf, TEXT("%#lx"), inf.dwFlags);
                SetDlgItemText(hwnd, IDC_RETURNFLAGS,    szBuf);

                SetDlgItemInt (hwnd, IDC_RETURNSPEED,   inf.dwSpeed, FALSE);
                SetDlgItemInt (hwnd, IDC_RETURNDELAY,   inf.dwDelay, FALSE);
                SetDlgItemInt (hwnd, IDC_RETURNOPTDATASIZE,
                                                inf.dwOptDataSize, FALSE);
            }

            SetDlgItemInt(hwnd, IDC_BUFSIZEIN, bufSizeIn, FALSE);
            SetDlgItemInt(hwnd, IDC_BUFSIZE, inf.cbStructure, FALSE);

            return TRUE;
        }

        case IDOK:
            EndDialog(hwnd, TRUE);
            return TRUE;

        case IDC_LOCAL:
            EnableWindow(GetDlgItem(hwnd, IDC_LOCAL_TEXT),
                (1 == IsDlgButtonChecked(hwnd, IDC_LOCAL)));
            return TRUE;

        case IDC_REMOTE:
            EnableWindow(GetDlgItem(hwnd, IDC_REMOTE_TEXT),
                (1 == IsDlgButtonChecked(hwnd, IDC_REMOTE)));
            return TRUE;

        case IDC_PROVIDER:
            EnableWindow(GetDlgItem(hwnd, IDC_PROVIDER_TEXT),
                (1 == IsDlgButtonChecked(hwnd, IDC_PROVIDER)));
            return TRUE;

        } // end switch (LOWORD(wParam))

        return FALSE;
    }

    default:
        return FALSE;   // didn't process
    }
}

INT_PTR CALLBACK
FormatNetworkNameDlgProc(
    IN HWND   hwnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        PlaceIt(hwnd);
        SetDlgItemText(hwnd, IDC_ERROR,  TEXT(""));
        SetDlgItemText(hwnd, IDC_RETURN,  TEXT(""));

        SetDlgItemText(hwnd, IDC_REMOTE_TEXT, TEXT(""));
        EnableWindow(GetDlgItem(hwnd, IDC_REMOTE_TEXT), FALSE);
        CheckDlgButton(hwnd, IDC_REMOTE_TEXT, 0);

        SetDlgItemText(hwnd, IDC_PROVIDER_TEXT, TEXT(""));
        EnableWindow(GetDlgItem(hwnd, IDC_PROVIDER_TEXT), FALSE);
        CheckDlgButton(hwnd, IDC_PROVIDER_TEXT, 0);

        return 1;   // didn't call SetFocus

    case WM_COMMAND:
    {
        switch (LOWORD(wParam))
        {
        case IDC_GO:
        {
            // get the flags
            DWORD dwFlags = 0;

            if (1 == IsDlgButtonChecked(hwnd, IDC_MULTILINE))
            {
                dwFlags |= WNFMT_MULTILINE;
            }
            if (1 == IsDlgButtonChecked(hwnd, IDC_ABBREVIATED))
            {
                dwFlags |= WNFMT_ABBREVIATED;
            }
            if (1 == IsDlgButtonChecked(hwnd, IDC_INENUM))
            {
                dwFlags |= WNFMT_INENUM;
            }

            TCHAR szRemoteName[200];
            LPTSTR pszRemoteName = NULL;
            if (1 == IsDlgButtonChecked(hwnd, IDC_REMOTE))
            {
                GetDlgItemText(hwnd, IDC_REMOTE_TEXT, szRemoteName, ARRAYLEN(szRemoteName));
                pszRemoteName = szRemoteName;
            }

            TCHAR szProviderName[200];
            LPTSTR pszProviderName = NULL;
            if (1 == IsDlgButtonChecked(hwnd, IDC_PROVIDER))
            {
                GetDlgItemText(hwnd, IDC_PROVIDER_TEXT, szProviderName, ARRAYLEN(szProviderName));
                pszProviderName = szProviderName;
            }

            TCHAR szBuf[1024];
            szBuf[0] = TEXT('\0');
            DWORD nLength = ARRAYLEN(szBuf);
            DWORD dwAveCharPerLine = 100000;  // BUGBUG

            // clear it
            SetDlgItemText(hwnd, IDC_ERROR,  TEXT(""));
            SetDlgItemText(hwnd, IDC_RETURN, TEXT(""));

            HCURSOR hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
            DWORD dw = WNetFormatNetworkName(
                                pszProviderName,
                                pszRemoteName,
                                szBuf,
                                &nLength,
                                dwFlags,
                                dwAveCharPerLine);
            SetCursor(hOldCursor);

            SetDlgItemText(hwnd, IDC_RETURN, szBuf);

            DoError(hwnd, dw);

            return TRUE;
        }

        case IDOK:
            EndDialog(hwnd, TRUE);
            return TRUE;

        case IDC_REMOTE:
            EnableWindow(GetDlgItem(hwnd, IDC_REMOTE_TEXT),
                (1 == IsDlgButtonChecked(hwnd, IDC_REMOTE)));
            return TRUE;

        case IDC_PROVIDER:
            EnableWindow(GetDlgItem(hwnd, IDC_PROVIDER_TEXT),
                (1 == IsDlgButtonChecked(hwnd, IDC_PROVIDER)));
            return TRUE;

        } // end switch (LOWORD(wParam))

        return FALSE;
    }

    default:
        return FALSE;   // didn't process
    }
}

INT_PTR CALLBACK
GetProviderTypeDlgProc(
    IN HWND   hwnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        PlaceIt(hwnd);
        SetDlgItemText(hwnd, IDC_ERROR,           TEXT(""));
        SetDlgItemText(hwnd, IDC_PROVIDERTYPE,    TEXT(""));

        SetDlgItemText(hwnd, IDC_PROVIDER_TEXT, TEXT(""));
        EnableWindow(GetDlgItem(hwnd, IDC_PROVIDER_TEXT), FALSE);
        CheckDlgButton(hwnd, IDC_PROVIDER_TEXT, 0);

        return 1;   // didn't call SetFocus

    case WM_COMMAND:
    {
        switch (LOWORD(wParam))
        {
        case IDC_GO:
        {
            TCHAR szProviderName[200];
            LPTSTR pszProviderName = NULL;
            if (1 == IsDlgButtonChecked(hwnd, IDC_PROVIDER))
            {
                GetDlgItemText(hwnd, IDC_PROVIDER_TEXT, szProviderName, ARRAYLEN(szProviderName));
                pszProviderName = szProviderName;
            }

            // clear it
            SetDlgItemText(hwnd, IDC_ERROR,           TEXT(""));
            SetDlgItemText(hwnd, IDC_PROVIDERTYPE,    TEXT(""));

            HCURSOR hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
            DWORD dwNetType;
            DWORD dw = LoadMpr();
            if (dw == WN_SUCCESS)
            {
                if (NULL == pfnWNetGetProviderType)
                {
                    dw = ERROR_PROC_NOT_FOUND;
                }
                else
                {
                    dw = (*pfnWNetGetProviderType)(pszProviderName, &dwNetType);
                }
            }
            SetCursor(hOldCursor);

            if (WN_SUCCESS == dw)
            {
                TCHAR sz[100];

                wsprintf(sz, TEXT("0x%08x"), dwNetType);
                SetDlgItemText(hwnd, IDC_PROVIDERTYPE, sz);
            }

            DoError(hwnd, dw);

            return TRUE;
        }

        case IDOK:
            EndDialog(hwnd, TRUE);
            return TRUE;

        case IDC_PROVIDER:
            EnableWindow(GetDlgItem(hwnd, IDC_PROVIDER_TEXT),
                (1 == IsDlgButtonChecked(hwnd, IDC_PROVIDER)));
            return TRUE;

        } // end switch (LOWORD(wParam))

        return FALSE;
    }

    default:
        return FALSE;   // didn't process
    }
}

INT_PTR CALLBACK
GetProviderNameDlgProc(
    IN HWND   hwnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        PlaceIt(hwnd);
        SetDlgItemText(hwnd, IDC_ERROR,           TEXT(""));
        SetDlgItemText(hwnd, IDC_PROVIDERNAME,    TEXT(""));
        SetDlgItemText(hwnd, IDC_PROVIDER_TEXT,   TEXT(""));

        return 1;   // didn't call SetFocus

    case WM_COMMAND:
    {
        switch (LOWORD(wParam))
        {
        case IDC_GO:
        {
            DWORD dwNetType;
            TCHAR szProviderType[200];
            GetDlgItemText(hwnd, IDC_PROVIDER_TEXT, szProviderType, ARRAYLEN(szProviderType));
            _stscanf(szProviderType, TEXT("%lx"), &dwNetType);

            // clear it
            SetDlgItemText(hwnd, IDC_ERROR,           TEXT(""));
            SetDlgItemText(hwnd, IDC_PROVIDERNAME,    TEXT(""));

            HCURSOR hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
            TCHAR szProviderName[MAX_PATH];
            DWORD cchProviderName = ARRAYLEN(szProviderName);
            DWORD dw = WNetGetProviderName(dwNetType, szProviderName, &cchProviderName);
            SetCursor(hOldCursor);

            if (WN_SUCCESS == dw)
            {
                TCHAR sz[100];

                SetDlgItemText(hwnd, IDC_PROVIDERNAME, szProviderName);
            }

            DoError(hwnd, dw);

            return TRUE;
        }

        case IDOK:
            EndDialog(hwnd, TRUE);
            return TRUE;

        } // end switch (LOWORD(wParam))

        return FALSE;
    }

    default:
        return FALSE;   // didn't process
    }
}

INT_PTR CALLBACK
GetNetworkInformationDlgProc(
    IN HWND   hwnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        PlaceIt(hwnd);
        SetDlgItemText(hwnd, IDC_ERROR,           TEXT(""));
        SetDlgItemText(hwnd, IDC_PROVIDERVERSION, TEXT(""));
        SetDlgItemText(hwnd, IDC_STATUS,          TEXT(""));
        SetDlgItemText(hwnd, IDC_CHARACTERISTICS, TEXT(""));
        SetDlgItemText(hwnd, IDC_HANDLE,          TEXT(""));
        SetDlgItemText(hwnd, IDC_NETTYPE,         TEXT(""));
        SetDlgItemText(hwnd, IDC_PRINTERS,        TEXT(""));
        SetDlgItemText(hwnd, IDC_DRIVES,          TEXT(""));

        SetDlgItemText(hwnd, IDC_PROVIDER_TEXT, TEXT(""));
        EnableWindow(GetDlgItem(hwnd, IDC_PROVIDER_TEXT), FALSE);
        CheckDlgButton(hwnd, IDC_PROVIDER_TEXT, 0);

        return 1;   // didn't call SetFocus

    case WM_COMMAND:
    {
        switch (LOWORD(wParam))
        {
        case IDC_GO:
        {
            TCHAR szProviderName[200];
            LPTSTR pszProviderName = NULL;
            if (1 == IsDlgButtonChecked(hwnd, IDC_PROVIDER))
            {
                GetDlgItemText(hwnd, IDC_PROVIDER_TEXT, szProviderName, ARRAYLEN(szProviderName));
                pszProviderName = szProviderName;
            }

            NETINFOSTRUCT ni;
            ni.cbStructure = sizeof(NETINFOSTRUCT);

            // clear it
            SetDlgItemText(hwnd, IDC_ERROR,           TEXT(""));
            SetDlgItemText(hwnd, IDC_PROVIDERVERSION, TEXT(""));
            SetDlgItemText(hwnd, IDC_STATUS,          TEXT(""));
            SetDlgItemText(hwnd, IDC_CHARACTERISTICS, TEXT(""));
            SetDlgItemText(hwnd, IDC_HANDLE,          TEXT(""));
            SetDlgItemText(hwnd, IDC_NETTYPE,         TEXT(""));
            SetDlgItemText(hwnd, IDC_PRINTERS,        TEXT(""));
            SetDlgItemText(hwnd, IDC_DRIVES,          TEXT(""));

            HCURSOR hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
            DWORD dw = WNetGetNetworkInformation(pszProviderName, &ni);
            SetCursor(hOldCursor);

            if (WN_SUCCESS == dw)
            {
                TCHAR sz[100];

                wsprintf(sz, TEXT("0x%08lx"), ni.dwProviderVersion);
                SetDlgItemText(hwnd, IDC_PROVIDERVERSION, sz);

                wsprintf(sz, TEXT("0x%08lx"), ni.dwStatus);
                SetDlgItemText(hwnd, IDC_STATUS, sz);

                wsprintf(sz, TEXT("0x%08lx"), ni.dwCharacteristics);
                SetDlgItemText(hwnd, IDC_CHARACTERISTICS, sz);

                wsprintf(sz, TEXT("0x%08lx"), ni.dwHandle);
                SetDlgItemText(hwnd, IDC_HANDLE, sz);

                wsprintf(sz, TEXT("0x%04x"), ni.wNetType);
                SetDlgItemText(hwnd, IDC_NETTYPE, sz);

                wsprintf(sz, TEXT("0x%08lx"), ni.dwPrinters);
                SetDlgItemText(hwnd, IDC_PRINTERS, sz);

                wsprintf(sz, TEXT("0x%08lx"), ni.dwDrives);
                SetDlgItemText(hwnd, IDC_DRIVES, sz);
            }

            DoError(hwnd, dw);

            return TRUE;
        }

        case IDOK:
            EndDialog(hwnd, TRUE);
            return TRUE;

        case IDC_PROVIDER:
            EnableWindow(GetDlgItem(hwnd, IDC_PROVIDER_TEXT),
                (1 == IsDlgButtonChecked(hwnd, IDC_PROVIDER)));
            return TRUE;

        } // end switch (LOWORD(wParam))

        return FALSE;
    }

    default:
        return FALSE;   // didn't process
    }
}

INT_PTR CALLBACK
CancelConnectionDlgProc(
    IN HWND   hwnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        PlaceIt(hwnd);
        SetDlgItemText(hwnd, IDC_ERROR,      TEXT(""));
        SetDlgItemText(hwnd, IDC_LOCAL_TEXT, TEXT(""));
        CheckRadioButton(hwnd, IDC_FORCE, IDC_NOFORCE, IDC_NOFORCE);
        return 1;   // didn't call SetFocus

    case WM_COMMAND:
    {
        switch (LOWORD(wParam))
        {
        case IDC_GO:
        {
            BOOL fForce = FALSE;
            if (1 == IsDlgButtonChecked(hwnd, IDC_FORCE))
            {
                fForce = TRUE;
            }
            else if (1 == IsDlgButtonChecked(hwnd, IDC_NOFORCE))
            {
                fForce = FALSE;
            }
            else
            {
                // internal error
            }

            TCHAR szLocalName[200];
            GetDlgItemText(hwnd, IDC_LOCAL_TEXT, szLocalName, ARRAYLEN(szLocalName));

            // clear it
            SetDlgItemText(hwnd, IDC_ERROR, TEXT(""));

            HCURSOR hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
            DWORD dw = WNetCancelConnection(szLocalName, fForce);
            SetCursor(hOldCursor);

            DoError(hwnd, dw);
            return TRUE;
        }

        case IDOK:
            EndDialog(hwnd, TRUE);
            return TRUE;
        }

        return FALSE;
    }

    default:
        return FALSE;   // didn't process
    }
}

INT_PTR CALLBACK
CancelConnection2DlgProc(
    IN HWND   hwnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        PlaceIt(hwnd);
        SetDlgItemText(hwnd, IDC_ERROR,  TEXT(""));
        SetDlgItemText(hwnd, IDC_LOCAL_TEXT, TEXT(""));
        CheckRadioButton(hwnd, IDC_FORCE, IDC_NOFORCE, IDC_NOFORCE);
        CheckDlgButton(hwnd, IDC_UPDATE_PROFILE, 0);
        CheckDlgButton(hwnd, IDC_REFCOUNT, 0);
        return 1;   // didn't call SetFocus

    case WM_COMMAND:
    {
        switch (LOWORD(wParam))
        {
        case IDC_GO:
        {
            // get the flags
            DWORD dwFlags = 0;

            if (1 == IsDlgButtonChecked(hwnd, IDC_UPDATE_PROFILE))
            {
                dwFlags |= CONNECT_UPDATE_PROFILE;
            }
            if (1 == IsDlgButtonChecked(hwnd, IDC_REFCOUNT))
            {
                dwFlags |= CONNECT_REFCOUNT;
            }

            BOOL fForce = FALSE;
            if (1 == IsDlgButtonChecked(hwnd, IDC_FORCE))
            {
                fForce = TRUE;
            }
            else if (1 == IsDlgButtonChecked(hwnd, IDC_NOFORCE))
            {
                fForce = FALSE;
            }
            else
            {
                // internal error
            }

            TCHAR szLocalName[200];
            GetDlgItemText(hwnd, IDC_LOCAL_TEXT, szLocalName, ARRAYLEN(szLocalName));

            // clear it
            SetDlgItemText(hwnd, IDC_ERROR, TEXT(""));

            HCURSOR hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
            DWORD dw = WNetCancelConnection2(szLocalName, dwFlags, fForce);
            SetCursor(hOldCursor);

            DoError(hwnd, dw);
            return TRUE;
        }

        case IDOK:
            EndDialog(hwnd, TRUE);
            return TRUE;
        }

        return FALSE;
    }

    default:
        return FALSE;   // didn't process
    }
}

INT_PTR CALLBACK
AddConnectionDlgProc(
    IN HWND   hwnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        PlaceIt(hwnd);
        SetDlgItemText(hwnd, IDC_ERROR,  TEXT(""));

        SetDlgItemText(hwnd, IDC_LOCAL_TEXT, TEXT(""));
        EnableWindow(GetDlgItem(hwnd, IDC_LOCAL_TEXT), FALSE);
        CheckDlgButton(hwnd, IDC_LOCAL_TEXT, 0);

        SetDlgItemText(hwnd, IDC_REMOTE_TEXT, TEXT(""));
        EnableWindow(GetDlgItem(hwnd, IDC_REMOTE_TEXT), FALSE);
        CheckDlgButton(hwnd, IDC_REMOTE_TEXT, 0);

        SetDlgItemText(hwnd, IDC_PASSWORD_TEXT, TEXT(""));
        EnableWindow(GetDlgItem(hwnd, IDC_PASSWORD_TEXT), FALSE);
        CheckDlgButton(hwnd, IDC_PASSWORD_TEXT, 0);

        return 1;   // didn't call SetFocus

    case WM_COMMAND:
    {
        switch (LOWORD(wParam))
        {
        case IDC_GO:
        {
            TCHAR szLocalName[200];
            LPTSTR pszLocalName = NULL;
            if (1 == IsDlgButtonChecked(hwnd, IDC_LOCAL))
            {
                GetDlgItemText(hwnd, IDC_LOCAL_TEXT, szLocalName, ARRAYLEN(szLocalName));
                pszLocalName = szLocalName;
            }

            TCHAR szRemoteName[200];
            LPTSTR pszRemoteName = NULL;
            if (1 == IsDlgButtonChecked(hwnd, IDC_REMOTE))
            {
                GetDlgItemText(hwnd, IDC_REMOTE_TEXT, szRemoteName, ARRAYLEN(szRemoteName));
                pszRemoteName = szRemoteName;
            }

            TCHAR szPassword[200];
            LPTSTR pszPassword = NULL;
            if (1 == IsDlgButtonChecked(hwnd, IDC_PASSWORD))
            {
                GetDlgItemText(hwnd, IDC_PASSWORD_TEXT, szPassword, ARRAYLEN(szPassword));
                pszPassword = szPassword;
            }

            // clear it
            SetDlgItemText(hwnd, IDC_ERROR, TEXT(""));

            HCURSOR hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
            DWORD dw = WNetAddConnection(
                                pszRemoteName,
                                pszPassword,
                                pszLocalName);
            SetCursor(hOldCursor);

            DoError(hwnd, dw);

            return TRUE;
        }

        case IDOK:
            EndDialog(hwnd, TRUE);
            return TRUE;

        case IDC_LOCAL:
            EnableWindow(GetDlgItem(hwnd, IDC_LOCAL_TEXT),
                (1 == IsDlgButtonChecked(hwnd, IDC_LOCAL)));
            return TRUE;

        case IDC_REMOTE:
            EnableWindow(GetDlgItem(hwnd, IDC_REMOTE_TEXT),
                (1 == IsDlgButtonChecked(hwnd, IDC_REMOTE)));
            return TRUE;

        case IDC_PASSWORD:
            EnableWindow(GetDlgItem(hwnd, IDC_PASSWORD_TEXT),
                (1 == IsDlgButtonChecked(hwnd, IDC_PASSWORD)));
            return TRUE;

        } // end switch (LOWORD(wParam))

        return FALSE;
    }

    default:
        return FALSE;   // didn't process
    }
}

INT_PTR CALLBACK
AddConnection2DlgProc(
    IN HWND   hwnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        PlaceIt(hwnd);
        SetDlgItemText(hwnd, IDC_ERROR,  TEXT(""));

        SetDlgItemText(hwnd, IDC_LOCAL_TEXT, TEXT(""));
        EnableWindow(GetDlgItem(hwnd, IDC_LOCAL_TEXT), FALSE);
        CheckDlgButton(hwnd, IDC_LOCAL_TEXT, 0);

        SetDlgItemText(hwnd, IDC_REMOTE_TEXT, TEXT(""));
        EnableWindow(GetDlgItem(hwnd, IDC_REMOTE_TEXT), FALSE);
        CheckDlgButton(hwnd, IDC_REMOTE_TEXT, 0);

        SetDlgItemText(hwnd, IDC_PROVIDER_TEXT, TEXT(""));
        EnableWindow(GetDlgItem(hwnd, IDC_PROVIDER_TEXT), FALSE);
        CheckDlgButton(hwnd, IDC_PROVIDER_TEXT, 0);

        SetDlgItemText(hwnd, IDC_PASSWORD_TEXT, TEXT(""));
        EnableWindow(GetDlgItem(hwnd, IDC_PASSWORD_TEXT), FALSE);
        CheckDlgButton(hwnd, IDC_PASSWORD_TEXT, 0);

        SetDlgItemText(hwnd, IDC_USER_TEXT,     TEXT(""));
        EnableWindow(GetDlgItem(hwnd, IDC_USER_TEXT), FALSE);
        CheckDlgButton(hwnd, IDC_USER_TEXT, 0);

        CheckRadioButton(hwnd, IDC_DISK, IDC_PRINTER, IDC_DISK);

        return 1;   // didn't call SetFocus

    case WM_COMMAND:
    {
        switch (LOWORD(wParam))
        {
        case IDC_GO:
        {
            // get the flags
            DWORD dwFlags = 0;

            if (1 == IsDlgButtonChecked(hwnd, IDC_CONNECT_UPDATE_PROFILE))
            {
                dwFlags |= CONNECT_UPDATE_PROFILE;
            }

            DWORD dwType = 0;
            if (1 == IsDlgButtonChecked(hwnd, IDC_DISK))
            {
                dwType = RESOURCETYPE_DISK;
            }
            else if (1 == IsDlgButtonChecked(hwnd, IDC_PRINTER))
            {
                dwType = RESOURCETYPE_PRINT;
            }
            else
            {
                // internal error
            }

            TCHAR szLocalName[200];
            LPTSTR pszLocalName = NULL;
            if (1 == IsDlgButtonChecked(hwnd, IDC_LOCAL))
            {
                GetDlgItemText(hwnd, IDC_LOCAL_TEXT, szLocalName, ARRAYLEN(szLocalName));
                pszLocalName = szLocalName;
            }

            TCHAR szRemoteName[200];
            LPTSTR pszRemoteName = NULL;
            if (1 == IsDlgButtonChecked(hwnd, IDC_REMOTE))
            {
                GetDlgItemText(hwnd, IDC_REMOTE_TEXT, szRemoteName, ARRAYLEN(szRemoteName));
                pszRemoteName = szRemoteName;
            }

            TCHAR szProviderName[200];
            LPTSTR pszProviderName = NULL;
            if (1 == IsDlgButtonChecked(hwnd, IDC_PROVIDER))
            {
                GetDlgItemText(hwnd, IDC_PROVIDER_TEXT, szProviderName, ARRAYLEN(szProviderName));
                pszProviderName = szProviderName;
            }

            TCHAR szPassword[200];
            LPTSTR pszPassword = NULL;
            if (1 == IsDlgButtonChecked(hwnd, IDC_PASSWORD))
            {
                GetDlgItemText(hwnd, IDC_PASSWORD_TEXT, szPassword, ARRAYLEN(szPassword));
                pszPassword = szPassword;
            }

            TCHAR szUserName[200];
            LPTSTR pszUserName = NULL;
            if (1 == IsDlgButtonChecked(hwnd, IDC_USER))
            {
                GetDlgItemText(hwnd, IDC_USER_TEXT, szUserName, ARRAYLEN(szUserName));
                pszUserName = szUserName;
            }

            NETRESOURCE net;

            net.dwScope         = 0;
            net.dwType          = dwType;
            net.dwDisplayType   = 0;
            net.dwUsage         = 0;
            net.lpLocalName     = pszLocalName;
            net.lpRemoteName    = pszRemoteName;
            net.lpComment       = NULL;
            net.lpProvider      = pszProviderName;

            // clear it
            SetDlgItemText(hwnd, IDC_ERROR, TEXT(""));

            HCURSOR hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
            DWORD dw = WNetAddConnection2(
                                &net,
                                pszPassword,
                                pszUserName,
                                dwFlags);
            SetCursor(hOldCursor);

            DoError(hwnd, dw);

            return TRUE;
        }

        case IDOK:
            EndDialog(hwnd, TRUE);
            return TRUE;

        case IDC_LOCAL:
            EnableWindow(GetDlgItem(hwnd, IDC_LOCAL_TEXT),
                (1 == IsDlgButtonChecked(hwnd, IDC_LOCAL)));
            return TRUE;

        case IDC_REMOTE:
            EnableWindow(GetDlgItem(hwnd, IDC_REMOTE_TEXT),
                (1 == IsDlgButtonChecked(hwnd, IDC_REMOTE)));
            return TRUE;

        case IDC_PROVIDER:
            EnableWindow(GetDlgItem(hwnd, IDC_PROVIDER_TEXT),
                (1 == IsDlgButtonChecked(hwnd, IDC_PROVIDER)));
            return TRUE;

        case IDC_PASSWORD:
            EnableWindow(GetDlgItem(hwnd, IDC_PASSWORD_TEXT),
                (1 == IsDlgButtonChecked(hwnd, IDC_PASSWORD)));
            return TRUE;

        case IDC_USER:
            EnableWindow(GetDlgItem(hwnd, IDC_USER_TEXT),
                (1 == IsDlgButtonChecked(hwnd, IDC_USER)));
            return TRUE;

        } // end switch (LOWORD(wParam))

        return FALSE;
    }

    default:
        return FALSE;   // didn't process
    }
}

INT_PTR CALLBACK
AddConnection3DlgProc(
    IN HWND   hwnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        PlaceIt(hwnd);
        SetDlgItemText(hwnd, IDC_ERROR,  TEXT(""));

        SetDlgItemText(hwnd, IDC_LOCAL_TEXT, TEXT(""));
        EnableWindow(GetDlgItem(hwnd, IDC_LOCAL_TEXT), FALSE);
        CheckDlgButton(hwnd, IDC_LOCAL_TEXT, 0);

        SetDlgItemText(hwnd, IDC_REMOTE_TEXT, TEXT(""));
        EnableWindow(GetDlgItem(hwnd, IDC_REMOTE_TEXT), FALSE);
        CheckDlgButton(hwnd, IDC_REMOTE_TEXT, 0);

        SetDlgItemText(hwnd, IDC_PROVIDER_TEXT, TEXT(""));
        EnableWindow(GetDlgItem(hwnd, IDC_PROVIDER_TEXT), FALSE);
        CheckDlgButton(hwnd, IDC_PROVIDER_TEXT, 0);

        SetDlgItemText(hwnd, IDC_PASSWORD_TEXT, TEXT(""));
        EnableWindow(GetDlgItem(hwnd, IDC_PASSWORD_TEXT), FALSE);
        CheckDlgButton(hwnd, IDC_PASSWORD_TEXT, 0);

        SetDlgItemText(hwnd, IDC_USER_TEXT,     TEXT(""));
        EnableWindow(GetDlgItem(hwnd, IDC_USER_TEXT), FALSE);
        CheckDlgButton(hwnd, IDC_USER_TEXT, 0);

        CheckRadioButton(hwnd, IDC_HWND_VALID, IDC_HWND_NO, IDC_HWND_VALID);
        CheckRadioButton(hwnd, IDC_DISK, IDC_PRINTER, IDC_DISK);

        return 1;   // didn't call SetFocus

    case WM_COMMAND:
    {
        switch (LOWORD(wParam))
        {
        case IDC_GO:
        {
            // get the flags
            DWORD dwFlags = 0;

            if (1 == IsDlgButtonChecked(hwnd, IDC_CONNECT_TEMPORARY))
            {
                dwFlags |= CONNECT_TEMPORARY;
            }
            if (1 == IsDlgButtonChecked(hwnd, IDC_CONNECT_INTERACTIVE))
            {
                dwFlags |= CONNECT_INTERACTIVE;
            }
            if (1 == IsDlgButtonChecked(hwnd, IDC_CONNECT_PROMPT))
            {
                dwFlags |= CONNECT_PROMPT;
            }
            if (1 == IsDlgButtonChecked(hwnd, IDC_CONNECT_UPDATE_PROFILE))
            {
                dwFlags |= CONNECT_UPDATE_PROFILE;
            }
            if (1 == IsDlgButtonChecked(hwnd, IDC_CONNECT_UPDATE_RECENT))
            {
                dwFlags |= CONNECT_UPDATE_RECENT;
            }

            HWND hwndParent = NULL;
            if (1 == IsDlgButtonChecked(hwnd, IDC_HWND_VALID))
            {
                hwndParent = hwnd;
            }

            DWORD dwType = 0;
            if (1 == IsDlgButtonChecked(hwnd, IDC_DISK))
            {
                dwType = RESOURCETYPE_DISK;
            }
            else if (1 == IsDlgButtonChecked(hwnd, IDC_PRINTER))
            {
                dwType = RESOURCETYPE_PRINT;
            }
            else
            {
                // internal error
            }

            TCHAR szLocalName[200];
            LPTSTR pszLocalName = NULL;
            if (1 == IsDlgButtonChecked(hwnd, IDC_LOCAL))
            {
                GetDlgItemText(hwnd, IDC_LOCAL_TEXT, szLocalName, ARRAYLEN(szLocalName));
                pszLocalName = szLocalName;
            }

            TCHAR szRemoteName[200];
            LPTSTR pszRemoteName = NULL;
            if (1 == IsDlgButtonChecked(hwnd, IDC_REMOTE))
            {
                GetDlgItemText(hwnd, IDC_REMOTE_TEXT, szRemoteName, ARRAYLEN(szRemoteName));
                pszRemoteName = szRemoteName;
            }

            TCHAR szProviderName[200];
            LPTSTR pszProviderName = NULL;
            if (1 == IsDlgButtonChecked(hwnd, IDC_PROVIDER))
            {
                GetDlgItemText(hwnd, IDC_PROVIDER_TEXT, szProviderName, ARRAYLEN(szProviderName));
                pszProviderName = szProviderName;
            }

            TCHAR szPassword[200];
            LPTSTR pszPassword = NULL;
            if (1 == IsDlgButtonChecked(hwnd, IDC_PASSWORD))
            {
                GetDlgItemText(hwnd, IDC_PASSWORD_TEXT, szPassword, ARRAYLEN(szPassword));
                pszPassword = szPassword;
            }

            TCHAR szUserName[200];
            LPTSTR pszUserName = NULL;
            if (1 == IsDlgButtonChecked(hwnd, IDC_USER))
            {
                GetDlgItemText(hwnd, IDC_USER_TEXT, szUserName, ARRAYLEN(szUserName));
                pszUserName = szUserName;
            }

            NETRESOURCE net;

            net.dwScope         = 0;
            net.dwType          = dwType;
            net.dwDisplayType   = 0;
            net.dwUsage         = 0;
            net.lpLocalName     = pszLocalName;
            net.lpRemoteName    = pszRemoteName;
            net.lpComment       = NULL;
            net.lpProvider      = pszProviderName;

            // clear it
            SetDlgItemText(hwnd, IDC_ERROR, TEXT(""));

            HCURSOR hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
            DWORD dw = WNetAddConnection3(
                                hwndParent,
                                &net,
                                pszPassword,
                                pszUserName,
                                dwFlags);
            SetCursor(hOldCursor);

            DoError(hwnd, dw);

            return TRUE;
        }

        case IDOK:
            EndDialog(hwnd, TRUE);
            return TRUE;

        case IDC_LOCAL:
            EnableWindow(GetDlgItem(hwnd, IDC_LOCAL_TEXT),
                (1 == IsDlgButtonChecked(hwnd, IDC_LOCAL)));
            return TRUE;

        case IDC_REMOTE:
            EnableWindow(GetDlgItem(hwnd, IDC_REMOTE_TEXT),
                (1 == IsDlgButtonChecked(hwnd, IDC_REMOTE)));
            return TRUE;

        case IDC_PROVIDER:
            EnableWindow(GetDlgItem(hwnd, IDC_PROVIDER_TEXT),
                (1 == IsDlgButtonChecked(hwnd, IDC_PROVIDER)));
            return TRUE;

        case IDC_PASSWORD:
            EnableWindow(GetDlgItem(hwnd, IDC_PASSWORD_TEXT),
                (1 == IsDlgButtonChecked(hwnd, IDC_PASSWORD)));
            return TRUE;

        case IDC_USER:
            EnableWindow(GetDlgItem(hwnd, IDC_USER_TEXT),
                (1 == IsDlgButtonChecked(hwnd, IDC_USER)));
            return TRUE;

        } // end switch (LOWORD(wParam))

        return FALSE;
    }

    default:
        return FALSE;   // didn't process
    }
}

INT_PTR CALLBACK
UseConnectionDlgProc(
    IN HWND   hwnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        PlaceIt(hwnd);
        SetDlgItemText(hwnd, IDC_ERROR,  TEXT(""));
        SetDlgItemText(hwnd, IDC_BUFSIZE, TEXT(""));
        SetDlgItemText(hwnd, IDC_ACCESSNAME, TEXT(""));
        SetDlgItemText(hwnd, IDC_RESULT, TEXT(""));

        SetDlgItemText(hwnd, IDC_LOCAL_TEXT, TEXT(""));
        EnableWindow(GetDlgItem(hwnd, IDC_LOCAL_TEXT), FALSE);
        CheckDlgButton(hwnd, IDC_LOCAL_TEXT, 0);

        SetDlgItemText(hwnd, IDC_REMOTE_TEXT, TEXT(""));
        EnableWindow(GetDlgItem(hwnd, IDC_REMOTE_TEXT), FALSE);
        CheckDlgButton(hwnd, IDC_REMOTE_TEXT, 0);

        SetDlgItemText(hwnd, IDC_PROVIDER_TEXT, TEXT(""));
        EnableWindow(GetDlgItem(hwnd, IDC_PROVIDER_TEXT), FALSE);
        CheckDlgButton(hwnd, IDC_PROVIDER_TEXT, 0);

        SetDlgItemText(hwnd, IDC_PASSWORD_TEXT, TEXT(""));
        EnableWindow(GetDlgItem(hwnd, IDC_PASSWORD_TEXT), FALSE);
        CheckDlgButton(hwnd, IDC_PASSWORD_TEXT, 0);

        SetDlgItemText(hwnd, IDC_USER_TEXT,     TEXT(""));
        EnableWindow(GetDlgItem(hwnd, IDC_USER_TEXT), FALSE);
        CheckDlgButton(hwnd, IDC_USER_TEXT, 0);

        CheckRadioButton(hwnd, IDC_HWND_VALID, IDC_HWND_NO, IDC_HWND_VALID);
        CheckRadioButton(hwnd, IDC_DISK, IDC_PRINTER, IDC_DISK);
        CheckRadioButton(hwnd, IDC_ACCESS_YES, IDC_ACCESS_NO, IDC_ACCESS_YES);

        return 1;   // didn't call SetFocus

    case WM_COMMAND:
    {
        switch (LOWORD(wParam))
        {
        case IDC_GO:
        {
            // get the flags
            DWORD dwFlags = 0;

            if (1 == IsDlgButtonChecked(hwnd, IDC_CONNECT_TEMPORARY))
            {
                dwFlags |= CONNECT_TEMPORARY;
            }
            if (1 == IsDlgButtonChecked(hwnd, IDC_CONNECT_INTERACTIVE))
            {
                dwFlags |= CONNECT_INTERACTIVE;
            }
            if (1 == IsDlgButtonChecked(hwnd, IDC_CONNECT_PROMPT))
            {
                dwFlags |= CONNECT_PROMPT;
            }
            if (1 == IsDlgButtonChecked(hwnd, IDC_CONNECT_UPDATE_PROFILE))
            {
                dwFlags |= CONNECT_UPDATE_PROFILE;
            }
            if (1 == IsDlgButtonChecked(hwnd, IDC_CONNECT_UPDATE_RECENT))
            {
                dwFlags |= CONNECT_UPDATE_RECENT;
            }
            if (1 == IsDlgButtonChecked(hwnd, IDC_CONNECT_REDIRECT))
            {
                dwFlags |= CONNECT_REDIRECT;
            }
            if (1 == IsDlgButtonChecked(hwnd, IDC_CONNECT_CURRENT_MEDIA))
            {
                dwFlags |= CONNECT_CURRENT_MEDIA;
            }

            HWND hwndParent = NULL;
            if (1 == IsDlgButtonChecked(hwnd, IDC_HWND_VALID))
            {
                hwndParent = hwnd;
            }

            DWORD dwType = 0;
            if (1 == IsDlgButtonChecked(hwnd, IDC_DISK))
            {
                dwType = RESOURCETYPE_DISK;
            }
            else if (1 == IsDlgButtonChecked(hwnd, IDC_PRINTER))
            {
                dwType = RESOURCETYPE_PRINT;
            }
            else
            {
                // internal error
            }

            DWORD dwBufferSize = 0;
            TCHAR szAccessName[MAX_PATH];
            szAccessName[0] = TEXT('\0');
            LPTSTR pszAccessName = NULL;
            if (1 == IsDlgButtonChecked(hwnd, IDC_ACCESS_YES))
            {
                pszAccessName = szAccessName;
                dwBufferSize = ARRAYLEN(szAccessName);
            }

            TCHAR szLocalName[200];
            LPTSTR pszLocalName = NULL;
            if (1 == IsDlgButtonChecked(hwnd, IDC_LOCAL))
            {
                GetDlgItemText(hwnd, IDC_LOCAL_TEXT, szLocalName, ARRAYLEN(szLocalName));
                pszLocalName = szLocalName;
            }

            TCHAR szRemoteName[200];
            LPTSTR pszRemoteName = NULL;
            if (1 == IsDlgButtonChecked(hwnd, IDC_REMOTE))
            {
                GetDlgItemText(hwnd, IDC_REMOTE_TEXT, szRemoteName, ARRAYLEN(szRemoteName));
                pszRemoteName = szRemoteName;
            }

            TCHAR szProviderName[200];
            LPTSTR pszProviderName = NULL;
            if (1 == IsDlgButtonChecked(hwnd, IDC_PROVIDER))
            {
                GetDlgItemText(hwnd, IDC_PROVIDER_TEXT, szProviderName, ARRAYLEN(szProviderName));
                pszProviderName = szProviderName;
            }

            TCHAR szPassword[200];
            LPTSTR pszPassword = NULL;
            if (1 == IsDlgButtonChecked(hwnd, IDC_PASSWORD))
            {
                GetDlgItemText(hwnd, IDC_PASSWORD_TEXT, szPassword, ARRAYLEN(szPassword));
                pszPassword = szPassword;
            }

            TCHAR szUserName[200];
            LPTSTR pszUserName = NULL;
            if (1 == IsDlgButtonChecked(hwnd, IDC_USER))
            {
                GetDlgItemText(hwnd, IDC_USER_TEXT, szUserName, ARRAYLEN(szUserName));
                pszUserName = szUserName;
            }

            NETRESOURCE net;

            net.dwScope         = 0;
            net.dwType          = dwType;
            net.dwDisplayType   = 0;
            net.dwUsage         = 0;
            net.lpLocalName     = pszLocalName;
            net.lpRemoteName    = pszRemoteName;
            net.lpComment       = NULL;
            net.lpProvider      = pszProviderName;

            DWORD dwResult = 0;

            // clear it
            SetDlgItemText(hwnd, IDC_ERROR,  TEXT(""));
            SetDlgItemText(hwnd, IDC_BUFSIZE, TEXT(""));
            SetDlgItemText(hwnd, IDC_ACCESSNAME, TEXT(""));
            SetDlgItemText(hwnd, IDC_RESULT, TEXT(""));

            HCURSOR hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
            DWORD dw = WNetUseConnection(
                                hwndParent,
                                &net,
                                pszUserName,
                                pszPassword,
                                dwFlags,
                                pszAccessName,
                                &dwBufferSize,
                                &dwResult);
            SetCursor(hOldCursor);

            TCHAR sz[500];

            wsprintf(sz, TEXT("%d"), dwBufferSize);
            SetDlgItemText(hwnd, IDC_BUFSIZE, sz);

            if (NULL == pszAccessName)
            {
                SetDlgItemText(hwnd, IDC_ACCESSNAME, TEXT("(null)"));
            }
            else
            {
                SetDlgItemText(hwnd, IDC_ACCESSNAME, pszAccessName);
            }

            wsprintf(sz, TEXT("%d (0x%08lx)"), dwResult, dwResult);
            if (dwResult & CONNECT_REFCOUNT)
            {
                _tcscat(sz, TEXT(" CONNECT_REFCOUNT"));
                dwResult &= ~CONNECT_REFCOUNT;
            }
            if (dwResult & CONNECT_LOCALDRIVE)
            {
                _tcscat(sz, TEXT(" CONNECT_LOCALDRIVE"));
                dwResult &= ~CONNECT_LOCALDRIVE;
            }
            if (dwResult != 0)
            {
                _tcscat(sz, TEXT(" + unknown"));
            }
            SetDlgItemText(hwnd, IDC_RESULT, sz);

            DoError(hwnd, dw);

            return TRUE;
        }

        case IDOK:
            EndDialog(hwnd, TRUE);
            return TRUE;

        case IDC_LOCAL:
            EnableWindow(GetDlgItem(hwnd, IDC_LOCAL_TEXT),
                (1 == IsDlgButtonChecked(hwnd, IDC_LOCAL)));
            return TRUE;

        case IDC_REMOTE:
            EnableWindow(GetDlgItem(hwnd, IDC_REMOTE_TEXT),
                (1 == IsDlgButtonChecked(hwnd, IDC_REMOTE)));
            return TRUE;

        case IDC_PROVIDER:
            EnableWindow(GetDlgItem(hwnd, IDC_PROVIDER_TEXT),
                (1 == IsDlgButtonChecked(hwnd, IDC_PROVIDER)));
            return TRUE;

        case IDC_PASSWORD:
            EnableWindow(GetDlgItem(hwnd, IDC_PASSWORD_TEXT),
                (1 == IsDlgButtonChecked(hwnd, IDC_PASSWORD)));
            return TRUE;

        case IDC_USER:
            EnableWindow(GetDlgItem(hwnd, IDC_USER_TEXT),
                (1 == IsDlgButtonChecked(hwnd, IDC_USER)));
            return TRUE;

        } // end switch (LOWORD(wParam))

        return FALSE;
    }

    default:
        return FALSE;   // didn't process
    }
}

INT_PTR CALLBACK
GetResourceInformationDlgProc(
    IN HWND   hwnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        PlaceIt(hwnd);
        SetDlgItemText(hwnd, IDC_ERROR,  TEXT(""));

        SetDlgItemText(hwnd, IDC_REMOTE_TEXT, TEXT(""));
        EnableWindow(GetDlgItem(hwnd, IDC_REMOTE_TEXT), FALSE);
        CheckDlgButton(hwnd, IDC_REMOTE_TEXT, 0);

        SetDlgItemText(hwnd, IDC_PROVIDER_TEXT, TEXT(""));
        EnableWindow(GetDlgItem(hwnd, IDC_PROVIDER_TEXT), FALSE);
        CheckDlgButton(hwnd, IDC_PROVIDER_TEXT, 0);

        CheckRadioButton(hwnd, IDC_DISK, IDC_ANY, IDC_DISK);

        SetDlgItemText(hwnd, IDC_RETURNREMOTE,      TEXT(""));
        SetDlgItemText(hwnd, IDC_RETURNPROVIDER,    TEXT(""));
        SetDlgItemText(hwnd, IDC_RETURNSCOPE,       TEXT(""));
        SetDlgItemText(hwnd, IDC_RETURNTYPE,        TEXT(""));
        SetDlgItemText(hwnd, IDC_RETURNUSAGE,       TEXT(""));
        SetDlgItemText(hwnd, IDC_RETURNSYSTEM,      TEXT(""));
        SetDlgItemText(hwnd, IDC_RETURNDISPLAYTYPE, TEXT(""));
        SetDlgItemText(hwnd, IDC_RETURNLOCALNAME,   TEXT(""));
        SetDlgItemText(hwnd, IDC_RETURNCOMMENT,     TEXT(""));
        SetDlgItemInt (hwnd, IDC_BUFSIZEIN, sizeof(NETRESOURCE) + MAX_PATH*2, FALSE);
        SetDlgItemText(hwnd, IDC_BUFSIZE,           TEXT(""));

        return 1;   // didn't call SetFocus

    case WM_COMMAND:
    {
        switch (LOWORD(wParam))
        {
        case IDC_GO:
        {
            DWORD dwType = 0;
            if (1 == IsDlgButtonChecked(hwnd, IDC_DISK))
            {
                dwType = RESOURCETYPE_DISK;
            }
            else if (1 == IsDlgButtonChecked(hwnd, IDC_PRINTER))
            {
                dwType = RESOURCETYPE_PRINT;
            }
            else if (1 == IsDlgButtonChecked(hwnd, IDC_ANY))
            {
                dwType = RESOURCETYPE_ANY;
            }
            else
            {
                // internal error
            }

            TCHAR szRemoteName[200];
            LPTSTR pszRemoteName = NULL;
            if (1 == IsDlgButtonChecked(hwnd, IDC_REMOTE))
            {
                GetDlgItemText(hwnd, IDC_REMOTE_TEXT, szRemoteName, ARRAYLEN(szRemoteName));
                pszRemoteName = szRemoteName;
            }

            TCHAR szProviderName[200];
            LPTSTR pszProviderName = NULL;
            if (1 == IsDlgButtonChecked(hwnd, IDC_PROVIDER))
            {
                GetDlgItemText(hwnd, IDC_PROVIDER_TEXT, szProviderName, ARRAYLEN(szProviderName));
                pszProviderName = szProviderName;
            }

            NETRESOURCE net;

            net.dwScope         = 0;
            net.dwType          = dwType;
            net.dwDisplayType   = 0;
            net.dwUsage         = 0;
            net.lpLocalName     = NULL;
            net.lpRemoteName    = pszRemoteName;
            net.lpComment       = NULL;
            net.lpProvider      = pszProviderName;

            DWORD bufSizeIn = GetDlgItemInt(hwnd, IDC_BUFSIZEIN, NULL, FALSE);
            DWORD bufSize = bufSizeIn;
            LPTSTR lpSystem = NULL;

            // clear it
            SetDlgItemText(hwnd, IDC_RETURNREMOTE,      TEXT(""));
            SetDlgItemText(hwnd, IDC_RETURNPROVIDER,    TEXT(""));
            SetDlgItemText(hwnd, IDC_RETURNSCOPE,       TEXT(""));
            SetDlgItemText(hwnd, IDC_RETURNTYPE,        TEXT(""));
            SetDlgItemText(hwnd, IDC_RETURNUSAGE,       TEXT(""));
            SetDlgItemText(hwnd, IDC_RETURNSYSTEM,      TEXT(""));
            SetDlgItemText(hwnd, IDC_RETURNDISPLAYTYPE, TEXT(""));
            SetDlgItemText(hwnd, IDC_RETURNLOCALNAME,   TEXT(""));
            SetDlgItemText(hwnd, IDC_RETURNCOMMENT,     TEXT(""));
            SetDlgItemText(hwnd, IDC_BUFSIZE,           TEXT(""));
            SetDlgItemInt (hwnd, IDC_BUFSIZEIN,         bufSizeIn, FALSE);

            HLOCAL buf = LocalAlloc(0, bufSizeIn);
			if (buf == NULL)
			{
				SetDlgItemText(hwnd, IDC_ERROR,
					TEXT("The test couldn't allocate a heap buffer of that size."));
				Beep(1000, 150);
				return TRUE;
			}

            LPNETRESOURCE pnrOut = (LPNETRESOURCE)buf;

            HCURSOR hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
            DWORD dw = WNetGetResourceInformation(
                                &net,
                                (LPVOID)buf,
                                &bufSize,
                                &lpSystem);
            SetCursor(hOldCursor);

            DoError(hwnd, dw);

            TCHAR szBuf[MAX_PATH];

            if (WN_SUCCESS == dw)
            {
                SetDlgItemText(hwnd, IDC_RETURNREMOTE,
                    (NULL == pnrOut->lpRemoteName) ? TEXT("<none>") : pnrOut->lpRemoteName);

                SetDlgItemText(hwnd, IDC_RETURNPROVIDER,
                    (NULL == pnrOut->lpProvider) ? TEXT("<none>") : pnrOut->lpProvider);


                GetScopeString(szBuf, pnrOut);
                SetDlgItemText(hwnd, IDC_RETURNSCOPE,    szBuf);

                GetTypeString(szBuf, pnrOut);
                SetDlgItemText(hwnd, IDC_RETURNTYPE,     szBuf);

                GetUsageString(szBuf, pnrOut);
                SetDlgItemText(hwnd, IDC_RETURNUSAGE,    szBuf);

                SetDlgItemText(hwnd, IDC_RETURNSYSTEM,
                    (NULL == lpSystem) ? TEXT("<none>") : lpSystem);

                GetDisplayTypeString(szBuf, pnrOut);
                SetDlgItemText(hwnd, IDC_RETURNDISPLAYTYPE,     szBuf);

                SetDlgItemText(hwnd, IDC_RETURNLOCALNAME,
                    (NULL == pnrOut->lpLocalName) ? TEXT("<none>") : pnrOut->lpLocalName);

                SetDlgItemText(hwnd, IDC_RETURNCOMMENT,
                    (NULL == pnrOut->lpComment) ? TEXT("<none>") : pnrOut->lpComment);
            }

            wsprintf(szBuf, TEXT("%d"), bufSize);
            SetDlgItemText(hwnd, IDC_BUFSIZE, szBuf);

			LocalFree(buf);

            return TRUE;
        }

        case IDOK:
            EndDialog(hwnd, TRUE);
            return TRUE;

        case IDC_REMOTE:
            EnableWindow(GetDlgItem(hwnd, IDC_REMOTE_TEXT),
                (1 == IsDlgButtonChecked(hwnd, IDC_REMOTE)));
            return TRUE;

        case IDC_PROVIDER:
            EnableWindow(GetDlgItem(hwnd, IDC_PROVIDER_TEXT),
                (1 == IsDlgButtonChecked(hwnd, IDC_PROVIDER)));
            return TRUE;

        } // end switch (LOWORD(wParam))

        return FALSE;
    }

    default:
        return FALSE;   // didn't process
    }
}

INT_PTR CALLBACK
GetResourceParentDlgProc(
    IN HWND   hwnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        PlaceIt(hwnd);
        SetDlgItemText(hwnd, IDC_ERROR,  TEXT(""));

        SetDlgItemText(hwnd, IDC_REMOTE_TEXT, TEXT(""));
        EnableWindow(GetDlgItem(hwnd, IDC_REMOTE_TEXT), FALSE);
        CheckDlgButton(hwnd, IDC_REMOTE_TEXT, 0);

        SetDlgItemText(hwnd, IDC_PROVIDER_TEXT, TEXT(""));
        EnableWindow(GetDlgItem(hwnd, IDC_PROVIDER_TEXT), FALSE);
        CheckDlgButton(hwnd, IDC_PROVIDER_TEXT, 0);

        CheckRadioButton(hwnd, IDC_DISK, IDC_ANY, IDC_DISK);

        SetDlgItemText(hwnd, IDC_RETURNREMOTE,   TEXT(""));
        SetDlgItemText(hwnd, IDC_RETURNPROVIDER, TEXT(""));
        SetDlgItemText(hwnd, IDC_RETURNTYPE,     TEXT(""));
        SetDlgItemText(hwnd, IDC_RETURNUSAGE,    TEXT(""));
        SetDlgItemText(hwnd, IDC_RETURNSCOPE,    TEXT(""));
        SetDlgItemText(hwnd, IDC_RETURNDISPLAYTYPE, TEXT(""));
        SetDlgItemText(hwnd, IDC_RETURNLOCALNAME,   TEXT(""));
        SetDlgItemText(hwnd, IDC_RETURNCOMMENT,     TEXT(""));
        SetDlgItemText(hwnd, IDC_BUFSIZE,        TEXT(""));
        SetDlgItemText(hwnd, IDC_BUFSIZEIN,      TEXT(""));

        return 1;   // didn't call SetFocus

    case WM_COMMAND:
    {
        switch (LOWORD(wParam))
        {
        case IDC_GO:
        {
            DWORD dwType = 0;
            if (1 == IsDlgButtonChecked(hwnd, IDC_DISK))
            {
                dwType = RESOURCETYPE_DISK;
            }
            else if (1 == IsDlgButtonChecked(hwnd, IDC_PRINTER))
            {
                dwType = RESOURCETYPE_PRINT;
            }
            else if (1 == IsDlgButtonChecked(hwnd, IDC_ANY))
            {
                dwType = RESOURCETYPE_ANY;
            }
            else
            {
                // internal error
            }

            TCHAR szRemoteName[200];
            LPTSTR pszRemoteName = NULL;
            if (1 == IsDlgButtonChecked(hwnd, IDC_REMOTE))
            {
                GetDlgItemText(hwnd, IDC_REMOTE_TEXT, szRemoteName, ARRAYLEN(szRemoteName));
                pszRemoteName = szRemoteName;
            }

            TCHAR szProviderName[200];
            LPTSTR pszProviderName = NULL;
            if (1 == IsDlgButtonChecked(hwnd, IDC_PROVIDER))
            {
                GetDlgItemText(hwnd, IDC_PROVIDER_TEXT, szProviderName, ARRAYLEN(szProviderName));
                pszProviderName = szProviderName;
            }

            NETRESOURCE net;

            net.dwScope         = 0;
            net.dwType          = dwType;
            net.dwDisplayType   = 0;
            net.dwUsage         = 0;
            net.lpLocalName     = NULL;
            net.lpRemoteName    = pszRemoteName;
            net.lpComment       = NULL;
            net.lpProvider      = pszProviderName;

            BYTE buf[sizeof(NETRESOURCE) + MAX_PATH*2];
            DWORD bufSize = sizeof(buf);
            DWORD bufSizeIn = bufSize;
            LPNETRESOURCE pnrOut = (LPNETRESOURCE)buf;

            // clear it
            SetDlgItemText(hwnd, IDC_ERROR,          TEXT(""));
            SetDlgItemText(hwnd, IDC_RETURNREMOTE,   TEXT(""));
            SetDlgItemText(hwnd, IDC_RETURNPROVIDER, TEXT(""));
            SetDlgItemText(hwnd, IDC_RETURNTYPE,     TEXT(""));
            SetDlgItemText(hwnd, IDC_RETURNUSAGE,    TEXT(""));
            SetDlgItemText(hwnd, IDC_RETURNSCOPE,    TEXT(""));
            SetDlgItemText(hwnd, IDC_RETURNDISPLAYTYPE, TEXT(""));
            SetDlgItemText(hwnd, IDC_RETURNLOCALNAME,   TEXT(""));
            SetDlgItemText(hwnd, IDC_RETURNCOMMENT,     TEXT(""));
            SetDlgItemText(hwnd, IDC_BUFSIZE,        TEXT(""));
            SetDlgItemText(hwnd, IDC_BUFSIZEIN,      TEXT(""));

            HCURSOR hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
            DWORD dw = WNetGetResourceParent(
                                &net,
                                (LPVOID)buf,
                                &bufSize);
            SetCursor(hOldCursor);

            DoError(hwnd, dw);

            TCHAR szBuf[MAX_PATH];

            if (WN_SUCCESS == dw)
            {
                SetDlgItemText(hwnd, IDC_RETURNREMOTE,
                    (NULL == pnrOut->lpRemoteName) ? TEXT("<none>") : pnrOut->lpRemoteName);

                SetDlgItemText(hwnd, IDC_RETURNPROVIDER,
                    (NULL == pnrOut->lpProvider) ? TEXT("<none>") : pnrOut->lpProvider);

                GetTypeString(szBuf, pnrOut);
                SetDlgItemText(hwnd, IDC_RETURNTYPE,     szBuf);

                GetUsageString(szBuf, pnrOut);
                SetDlgItemText(hwnd, IDC_RETURNUSAGE,    szBuf);

                GetScopeString(szBuf, pnrOut);
                SetDlgItemText(hwnd, IDC_RETURNSCOPE,    szBuf);

                GetDisplayTypeString(szBuf, pnrOut);
                SetDlgItemText(hwnd, IDC_RETURNDISPLAYTYPE, szBuf);

                SetDlgItemText(hwnd, IDC_RETURNLOCALNAME,
                    (NULL == pnrOut->lpLocalName) ? TEXT("<none>") : pnrOut->lpLocalName);

                SetDlgItemText(hwnd, IDC_RETURNCOMMENT,
                    (NULL == pnrOut->lpComment) ? TEXT("<none>") : pnrOut->lpComment);
            }

            wsprintf(szBuf, TEXT("%d"), bufSize);
            SetDlgItemText(hwnd, IDC_BUFSIZE, szBuf);
            wsprintf(szBuf, TEXT("%d"), bufSizeIn);
            SetDlgItemText(hwnd, IDC_BUFSIZEIN, szBuf);

            return TRUE;
        }

        case IDOK:
            EndDialog(hwnd, TRUE);
            return TRUE;

        case IDC_REMOTE:
            EnableWindow(GetDlgItem(hwnd, IDC_REMOTE_TEXT),
                (1 == IsDlgButtonChecked(hwnd, IDC_REMOTE)));
            return TRUE;

        case IDC_PROVIDER:
            EnableWindow(GetDlgItem(hwnd, IDC_PROVIDER_TEXT),
                (1 == IsDlgButtonChecked(hwnd, IDC_PROVIDER)));
            return TRUE;

        } // end switch (LOWORD(wParam))

        return FALSE;
    }

    default:
        return FALSE;   // didn't process
    }
}

INT_PTR CALLBACK
GetUniversalNameDlgProc(
    IN HWND   hwnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        PlaceIt(hwnd);
        SetDlgItemText(hwnd, IDC_ERROR,  TEXT(""));

        SetDlgItemText(hwnd, IDC_LOCAL_TEXT, TEXT(""));
        EnableWindow(GetDlgItem(hwnd, IDC_LOCAL_TEXT), FALSE);
        CheckDlgButton(hwnd, IDC_LOCAL_TEXT, 0);

        CheckRadioButton(hwnd, IDC_UNIVERSALLEVEL, IDC_REMOTELEVEL, IDC_UNIVERSALLEVEL);

        SetDlgItemText(hwnd, IDC_RETURNUNIVERSAL,  TEXT(""));
        SetDlgItemText(hwnd, IDC_RETURNCONNECTION, TEXT(""));
        SetDlgItemText(hwnd, IDC_RETURNREMAINING,  TEXT(""));
        SetDlgItemText(hwnd, IDC_BUFSIZE,          TEXT(""));
        SetDlgItemText(hwnd, IDC_BUFSIZEIN,        TEXT(""));

        return 1;   // didn't call SetFocus

    case WM_COMMAND:
    {
        switch (LOWORD(wParam))
        {
        case IDC_GO:
        {
            DWORD dwInfoLevel = 0;
            if (1 == IsDlgButtonChecked(hwnd, IDC_UNIVERSALLEVEL))
            {
                dwInfoLevel = UNIVERSAL_NAME_INFO_LEVEL;
            }
            else if (1 == IsDlgButtonChecked(hwnd, IDC_REMOTELEVEL))
            {
                dwInfoLevel = REMOTE_NAME_INFO_LEVEL;
            }
            else
            {
                // internal error
            }

            TCHAR szLocalName[200];
            LPTSTR pszLocalName = NULL;
            if (1 == IsDlgButtonChecked(hwnd, IDC_LOCAL))
            {
                GetDlgItemText(hwnd, IDC_LOCAL_TEXT, szLocalName, ARRAYLEN(szLocalName));
                pszLocalName = szLocalName;
            }

            BYTE buf[MAX_PATH*4];       // a large guess
            DWORD bufSize = sizeof(buf);
            DWORD bufSizeIn = bufSize;

            // clear it
            SetDlgItemText(hwnd, IDC_ERROR,            TEXT(""));
            SetDlgItemText(hwnd, IDC_BUFSIZE,          TEXT(""));
            SetDlgItemText(hwnd, IDC_BUFSIZEIN,        TEXT(""));
            SetDlgItemText(hwnd, IDC_RETURNUNIVERSAL,  TEXT(""));
            SetDlgItemText(hwnd, IDC_RETURNCONNECTION, TEXT(""));
            SetDlgItemText(hwnd, IDC_RETURNREMAINING,  TEXT(""));

            HCURSOR hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
            DWORD dw = WNetGetUniversalName(
                                pszLocalName,
                                dwInfoLevel,
                                (LPVOID)buf,
                                &bufSize);
            SetCursor(hOldCursor);

            DoError(hwnd, dw);

            TCHAR szBuf[MAX_PATH];

            if (WN_SUCCESS == dw || WN_CONNECTION_CLOSED == dw)
            {
                switch (dwInfoLevel)
                {
                case UNIVERSAL_NAME_INFO_LEVEL:
                {
                    LPUNIVERSAL_NAME_INFO pInfo = (LPUNIVERSAL_NAME_INFO)buf;

                    SetDlgItemText(hwnd, IDC_RETURNUNIVERSAL,
                        (NULL == pInfo->lpUniversalName) ? TEXT("<none>") : pInfo->lpUniversalName);
                    SetDlgItemText(hwnd, IDC_RETURNCONNECTION, TEXT("N/A"));
                    SetDlgItemText(hwnd, IDC_RETURNREMAINING,  TEXT("N/A"));
                    break;
                }

                case REMOTE_NAME_INFO_LEVEL:
                {
                    LPREMOTE_NAME_INFO pInfo = (LPREMOTE_NAME_INFO)buf;

                    SetDlgItemText(hwnd, IDC_RETURNUNIVERSAL,
                        (NULL == pInfo->lpUniversalName) ? TEXT("<none>") : pInfo->lpUniversalName);
                    SetDlgItemText(hwnd, IDC_RETURNCONNECTION,
                        (NULL == pInfo->lpConnectionName) ? TEXT("<none>") : pInfo->lpConnectionName);
                    SetDlgItemText(hwnd, IDC_RETURNREMAINING,
                        (NULL == pInfo->lpRemainingPath) ? TEXT("<none>") : pInfo->lpRemainingPath);
                    break;
                }

                default:
                    // a bug!
                    break;
                }
            }

            wsprintf(szBuf, TEXT("%d"), bufSize);
            SetDlgItemText(hwnd, IDC_BUFSIZE, szBuf);
            wsprintf(szBuf, TEXT("%d"), bufSizeIn);
            SetDlgItemText(hwnd, IDC_BUFSIZEIN, szBuf);

            return TRUE;
        }

        case IDOK:
            EndDialog(hwnd, TRUE);
            return TRUE;

        case IDC_LOCAL:
            EnableWindow(GetDlgItem(hwnd, IDC_LOCAL_TEXT),
                (1 == IsDlgButtonChecked(hwnd, IDC_LOCAL)));
            return TRUE;

        } // end switch (LOWORD(wParam))

        return FALSE;
    }

    default:
        return FALSE;   // didn't process
    }
}

INT_PTR CALLBACK
GetUserDlgProc(
    IN HWND   hwnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        PlaceIt(hwnd);
        SetDlgItemText(hwnd, IDC_ERROR,  TEXT(""));

        SetDlgItemText(hwnd, IDC_NAME_TEXT, TEXT(""));
        EnableWindow(GetDlgItem(hwnd, IDC_NAME_TEXT), FALSE);
        CheckDlgButton(hwnd, IDC_NAME_TEXT, 0);

        SetDlgItemText(hwnd, IDC_RETURNUSER, TEXT(""));
        SetDlgItemText(hwnd, IDC_BUFSIZE,    TEXT(""));
        SetDlgItemText(hwnd, IDC_BUFSIZEIN,  TEXT(""));

        return 1;   // didn't call SetFocus

    case WM_COMMAND:
    {
        switch (LOWORD(wParam))
        {
        case IDC_GO:
        {
            TCHAR szName[200];
            LPTSTR pszName = NULL;
            if (1 == IsDlgButtonChecked(hwnd, IDC_NAME))
            {
                GetDlgItemText(hwnd, IDC_NAME_TEXT, szName, ARRAYLEN(szName));
                pszName = szName;
            }

            TCHAR szUserName[MAX_PATH];
            DWORD bufSize = ARRAYLEN(szUserName);
            DWORD bufSizeIn = bufSize;

            // clear it
            SetDlgItemText(hwnd, IDC_ERROR,      TEXT(""));
            SetDlgItemText(hwnd, IDC_RETURNUSER, TEXT(""));
            SetDlgItemText(hwnd, IDC_BUFSIZE,    TEXT(""));
            SetDlgItemText(hwnd, IDC_BUFSIZEIN,  TEXT(""));

            HCURSOR hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
            DWORD dw = WNetGetUser(pszName, szUserName, &bufSize);
            SetCursor(hOldCursor);

            DoError(hwnd, dw);

            TCHAR szBuf[MAX_PATH];

            if (WN_SUCCESS == dw)
            {
                SetDlgItemText(hwnd, IDC_RETURNUSER, szUserName);
            }
            else
            {
                SetDlgItemText(hwnd, IDC_RETURNUSER, TEXT(""));
            }

            wsprintf(szBuf, TEXT("%d"), bufSize);
            SetDlgItemText(hwnd, IDC_BUFSIZE, szBuf);
            wsprintf(szBuf, TEXT("%d"), bufSizeIn);
            SetDlgItemText(hwnd, IDC_BUFSIZEIN, szBuf);

            return TRUE;
        }

        case IDOK:
            EndDialog(hwnd, TRUE);
            return TRUE;

        case IDC_NAME:
            EnableWindow(GetDlgItem(hwnd, IDC_NAME_TEXT),
                (1 == IsDlgButtonChecked(hwnd, IDC_NAME)));
            return TRUE;

        } // end switch (LOWORD(wParam))

        return FALSE;
    }

    default:
        return FALSE;   // didn't process
    }
}

DWORD CALLBACK
DialogThreadProc(
    LPVOID lpThreadParameter
    )
{
    DWORD idCmd = PtrToUlong(lpThreadParameter);

    switch (idCmd)
    {
    case IDC_CONNECTIONDIALOG1:
        DialogBox(g_hInstance, MAKEINTRESOURCE(IDD_CONNECTIONDIALOG1), NULL, Connection1DlgProc);
        break;

    case IDC_DISCONNECTDIALOG1:
        DialogBox(g_hInstance, MAKEINTRESOURCE(IDD_DISCONNECTDIALOG1), NULL, Disconnect1DlgProc);
        break;

    case IDC_CONNECTIONDIALOG:
        DialogBox(g_hInstance, MAKEINTRESOURCE(IDD_CONNECTIONDIALOG), NULL, ConnectionDlgProc);
        break;

    case IDC_DISCONNECTDIALOG:
        DialogBox(g_hInstance, MAKEINTRESOURCE(IDD_DISCONNECTDIALOG), NULL, DisconnectDlgProc);
        break;

    case IDC_CONNECTIONDIALOG2:
        DialogBox(g_hInstance, MAKEINTRESOURCE(IDD_CONNECTIONDIALOG2), NULL, Connection2DlgProc);
        break;

    case IDC_DISCONNECTDIALOG2:
        DialogBox(g_hInstance, MAKEINTRESOURCE(IDD_DISCONNECTDIALOG2), NULL, Disconnect2DlgProc);
        break;

    case IDC_BROWSEDIALOG:
        DialogBox(g_hInstance, MAKEINTRESOURCE(IDD_BROWSEDIALOG), NULL, BrowseDlgProc);
        break;

    case IDC_GETCONNECTION:
        DialogBox(g_hInstance, MAKEINTRESOURCE(IDD_GETCONNECTION), NULL, GetConnectionDlgProc);
        break;

    case IDC_GETCONNECTION2:
        DialogBox(g_hInstance, MAKEINTRESOURCE(IDD_GETCONNECTION2), NULL, GetConnectionDlgProc2);
        break;

    case IDC_GETCONNECTION3:
        DialogBox(g_hInstance, MAKEINTRESOURCE(IDD_GETCONNECTION3), NULL, GetConnection3DlgProc);
        break;

    case IDC_GETCONNECTIONPERFORMANCE:
        DialogBox(g_hInstance, MAKEINTRESOURCE(IDD_GETCONNECTIONPERFORMANCE), NULL, GetConnectionPerformanceDlgProc);
        break;

    case IDC_FORMATNETWORKNAME:
        DialogBox(g_hInstance, MAKEINTRESOURCE(IDD_FORMATNETWORKNAME), NULL, FormatNetworkNameDlgProc);
        break;

    case IDC_GETNETWORKINFORMATION:
        DialogBox(g_hInstance, MAKEINTRESOURCE(IDD_GETNETWORKINFORMATION), NULL, GetNetworkInformationDlgProc);
        break;

    case IDC_GETPROVIDERNAME:
        DialogBox(g_hInstance, MAKEINTRESOURCE(IDD_GETPROVIDERNAME), NULL, GetProviderNameDlgProc);
        break;

    case IDC_GETPROVIDERTYPE:
        DialogBox(g_hInstance, MAKEINTRESOURCE(IDD_GETPROVIDERTYPE), NULL, GetProviderTypeDlgProc);
        break;

    case IDC_CANCELCONNECTION:
        DialogBox(g_hInstance, MAKEINTRESOURCE(IDD_CANCELCONNECTION), NULL, CancelConnectionDlgProc);
        break;

    case IDC_CANCELCONNECTION2:
        DialogBox(g_hInstance, MAKEINTRESOURCE(IDD_CANCELCONNECTION2), NULL, CancelConnection2DlgProc);
        break;

    case IDC_ADDCONNECTION:
        DialogBox(g_hInstance, MAKEINTRESOURCE(IDD_ADDCONNECTION), NULL, AddConnectionDlgProc);
        break;

    case IDC_ADDCONNECTION2:
        DialogBox(g_hInstance, MAKEINTRESOURCE(IDD_ADDCONNECTION2), NULL, AddConnection2DlgProc);
        break;

    case IDC_ADDCONNECTION3:
        DialogBox(g_hInstance, MAKEINTRESOURCE(IDD_ADDCONNECTION3), NULL, AddConnection3DlgProc);
        break;

    case IDC_USECONNECTION:
        DialogBox(g_hInstance, MAKEINTRESOURCE(IDD_USECONNECTION), NULL, UseConnectionDlgProc);
        break;

    case IDC_GETRESOURCEINFORMATION:
        DialogBox(g_hInstance, MAKEINTRESOURCE(IDD_GETRESOURCEINFORMATION), NULL, GetResourceInformationDlgProc);
        break;

    case IDC_GETRESOURCEPARENT:
        DialogBox(g_hInstance, MAKEINTRESOURCE(IDD_GETRESOURCEPARENT), NULL, GetResourceParentDlgProc);
        break;

    case IDC_GETUNIVERSALNAME:
        DialogBox(g_hInstance, MAKEINTRESOURCE(IDD_GETUNIVERSALNAME), NULL, GetUniversalNameDlgProc);
        break;

    case IDC_GETUSER:
        DialogBox(g_hInstance, MAKEINTRESOURCE(IDD_GETUSER), NULL, GetUserDlgProc);
        break;
    }

    return 0;
}


BOOL CALLBACK
DlgProc(
    IN HWND   hwnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
#ifdef UNICODE
        SetWindowText(hwnd, TEXT("WNet tests -- UNICODE strings version"));
#else // UNICODE
        SetWindowText(hwnd, TEXT("WNet tests -- ANSI strings version"));
#endif // UNICODE
        return 1;   // didn't call SetFocus

    case WM_DEVICECHANGE:
    {
        TCHAR sz[500];
        _tcscpy(sz, TEXT("WM_DEVICECHANGE "));

        LPTSTR pszType = NULL;
        switch (wParam)
        {
        case DBT_APPYBEGIN:             pszType = TEXT("DBT_APPYBEGIN "); break;
        case DBT_APPYEND:               pszType = TEXT("DBT_APPYEND "); break;
        case DBT_DEVNODES_CHANGED:      pszType = TEXT("DBT_DEVNODES_CHANGED "); break;
        case DBT_QUERYCHANGECONFIG:     pszType = TEXT("DBT_QUERYCHANGECONFIG "); break;
        case DBT_CONFIGCHANGED:         pszType = TEXT("DBT_CONFIGCHANGED "); break;
        case DBT_CONFIGCHANGECANCELED:  pszType = TEXT("DBT_CONFIGCHANGECANCELED "); break;
        case DBT_MONITORCHANGE:         pszType = TEXT("DBT_MONITORCHANGE "); break;
        case DBT_SHELLLOGGEDON:         pszType = TEXT("DBT_SHELLLOGGEDON "); break;
        case DBT_CONFIGMGAPI32:         pszType = TEXT("DBT_CONFIGMGAPI32 "); break;
        case DBT_VOLLOCKQUERYLOCK:      pszType = TEXT("DBT_VOLLOCKQUERYLOCK "); break;
        case DBT_VOLLOCKLOCKTAKEN:      pszType = TEXT("DBT_VOLLOCKLOCKTAKEN "); break;
        case DBT_VOLLOCKLOCKFAILED:     pszType = TEXT("DBT_VOLLOCKLOCKFAILED "); break;
        case DBT_VOLLOCKQUERYUNLOCK:    pszType = TEXT("DBT_VOLLOCKQUERYUNLOCK "); break;
        case DBT_VOLLOCKLOCKRELEASED:   pszType = TEXT("DBT_VOLLOCKLOCKRELEASED "); break;
        case DBT_VOLLOCKUNLOCKFAILED:   pszType = TEXT("DBT_VOLLOCKUNLOCKFAILED "); break;
        case DBT_NO_DISK_SPACE:         pszType = TEXT("DBT_NO_DISK_SPACE "); break;
        case DBT_DEVICEARRIVAL:         pszType = TEXT("DBT_DEVICEARRIVAL "); break;
        case DBT_DEVICEQUERYREMOVE:     pszType = TEXT("DBT_DEVICEQUERYREMOVE "); break;
        case DBT_DEVICEQUERYREMOVEFAILED:   pszType = TEXT("DBT_DEVICEQUERYREMOVEFAILED "); break;
        case DBT_DEVICEREMOVEPENDING:   pszType = TEXT("DBT_DEVICEREMOVEPENDING "); break;
        case DBT_DEVICEREMOVECOMPLETE:  pszType = TEXT("DBT_DEVICEREMOVECOMPLETE "); break;
        case DBT_DEVICETYPESPECIFIC:    pszType = TEXT("DBT_DEVICETYPESPECIFIC "); break;
        case DBT_VPOWERDAPI:            pszType = TEXT("DBT_VPOWERDAPI "); break;
        case DBT_USERDEFINED:           pszType = TEXT("DBT_USERDEFINED "); break;
        default:                        pszType = TEXT("Unknown "); break;
        }
        _tcscat(sz, pszType);

        switch (wParam)
        {
        case DBT_DEVICEARRIVAL:
        case DBT_DEVICEREMOVECOMPLETE:
        {
            _DEV_BROADCAST_HEADER* phdr = (_DEV_BROADCAST_HEADER*)lParam;
            if (phdr->dbcd_devicetype == DBT_DEVTYP_VOLUME)
            {
                _tcscat(sz, TEXT("DBT_DEVTYP_VOLUME "));
                DEV_BROADCAST_VOLUME* pdbv = (DEV_BROADCAST_VOLUME*)lParam;

                TCHAR szT[4];
                szT[1] = TEXT(':');
                szT[2] = TEXT(' ');
                szT[3] = TEXT('\0');
                DWORD dw = pdbv->dbcv_unitmask;
                DWORD count = 0;
                while (dw > 0)
                {
                    if (dw & 1)
                    {
                        szT[0] = (TCHAR)(TEXT('A') + count);
                        _tcscat(sz, szT);
                    }

                    ++count;
                    dw >>= 1;
                }

                switch (pdbv->dbcv_flags)
                {
                case DBTF_MEDIA: _tcscat(sz, TEXT("DBTF_MEDIA ")); break;
                case DBTF_NET:   _tcscat(sz, TEXT("DBTF_NET "));   break;
                default:         _tcscat(sz, TEXT("Unknown "));    break;
                }
            }
            break;
        }
        }

        _tcscat(sz, TEXT("\r\n"));
        SendDlgItemMessage(hwnd, IDC_MESSAGES, EM_REPLACESEL, (WPARAM)FALSE, (LPARAM)sz);
    }

    case WM_COMMAND:
    {
        switch (LOWORD(wParam))
        {
        case IDC_CONNECTIONDIALOG1:
        case IDC_DISCONNECTDIALOG1:
        case IDC_CONNECTIONDIALOG2:
        case IDC_DISCONNECTDIALOG2:
        case IDC_CONNECTIONDIALOG:
        case IDC_DISCONNECTDIALOG:
        case IDC_BROWSEDIALOG:
        case IDC_GETCONNECTION:
        case IDC_GETCONNECTION2:
        case IDC_GETCONNECTION3:
        case IDC_GETCONNECTIONPERFORMANCE:
        case IDC_FORMATNETWORKNAME:
        case IDC_GETNETWORKINFORMATION:
        case IDC_GETPROVIDERNAME:
        case IDC_GETPROVIDERTYPE:
        case IDC_CANCELCONNECTION:
        case IDC_CANCELCONNECTION2:
        case IDC_ADDCONNECTION:
        case IDC_ADDCONNECTION2:
        case IDC_ADDCONNECTION3:
        case IDC_USECONNECTION:
        case IDC_GETRESOURCEINFORMATION:
        case IDC_GETRESOURCEPARENT:
        case IDC_GETUNIVERSALNAME:
        case IDC_GETUSER:
        {
            DWORD idThread;
            HANDLE hThread = CreateThread(NULL, 0, DialogThreadProc, (LPVOID)(LOWORD(wParam)), 0, &idThread);
            if (hThread)
            {
                CloseHandle(hThread);
            }
            else
            {
                MessageBox(hwnd, TEXT("Couldn't create dialog box thread"), TEXT("Error!"), MB_OK);
            }
            break;
        }

        case IDC_ENUMERATE:
            DoEnumeration(hwnd);
            break;

        case IDOK:
            EndDialog(hwnd, TRUE);
            return TRUE;
        }

        return FALSE;
    }

    default:
        return FALSE;   // didn't process
    }
}

int WINAPI
WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR lpCmdLine,
    int nShowCmd
    )
{
    g_hInstance = hInstance;
    DialogBox(g_hInstance, MAKEINTRESOURCE(IDD_ROOT), NULL, (DLGPROC) DlgProc);

    if (NULL != g_hInstanceMpr)
    {
        FreeLibrary(g_hInstanceMpr);
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\mprui\test2\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by app.rc
//
#define IDD_GETCONNECTION2              100
#define IDC_RO_PATH                     101
#define IDC_USE_MRU                     102
#define IDC_HIDE_BOX                    103
#define IDD_GETRESOURCEINFORMATION      103
#define IDC_PERSIST                     104
#define IDD_GETUNIVERSALNAME            104
#define IDC_NOT_PERSIST                 105
#define IDD_GETUSER                     105
#define IDC_BUFSIZEIN                   106
#define IDD_BROWSEDIALOG                106
#define IDC_YESPATH                     107
#define IDD_GETPROVIDERTYPE             107
#define IDC_NOPATH                      108
#define IDD_GETPROVIDERNAME             108
#define IDD_GETRESOURCEPARENT           109
#define IDD_GETCONNECTION3              111
#define IDC_GO                          112
#define IDD_DISCONNECTDIALOG2           112
#define IDD_CONNECTIONDIALOG2           113
#define IDC_ERROR                       117
#define IDC_DEVICE                      118
#define IDC_CONN_POINT                  123
#define IDD_ROOT                        200
#define IDC_CONNECTIONDIALOG1           201
#define IDC_DISCONNECTDIALOG1           202
#define IDC_CONNECTIONDIALOG            203
#define IDC_DISCONNECTDIALOG            204
#define IDC_GETCONNECTION               205
#define IDC_CANCELCONNECTION2           206
#define IDC_ADDCONNECTION3              207
#define IDC_USECONNECTION               208
#define IDC_ADDCONNECTION2              209
#define IDC_ADDCONNECTION               210
#define IDC_CANCELCONNECTION            211
#define IDC_FORMATNETWORKNAME           212
#define IDC_GETNETWORKINFORMATION       213
#define IDC_GETCONNECTION2              214
#define IDC_ENUMERATE                   215
#define IDC_GETRESOURCEINFORMATION      216
#define IDC_GETRESOURCEPARENT           217
#define IDC_GETUNIVERSALNAME            218
#define IDC_GETUSER                     219
#define IDC_GETCONNECTIONPERFORMANCE    220
#define IDC_BROWSEDIALOG                221
#define IDC_GETPROVIDERTYPE             222
#define IDC_GETPROVIDERNAME             223
#define IDC_GETCONNECTION3              224
#define IDC_CONNECTIONDIALOG2           225
#define IDC_DISCONNECTDIALOG2           226
#define IDD_DISCONNECTDIALOG1           300
#define IDC_UPDATE_PROFILE              301
#define IDC_NO_FORCE                    302
#define IDC_LOCAL                       303
#define IDC_LOCAL_TEXT                  305
#define IDC_NULL                        307
#define IDD_CONNECTIONDIALOG            400
#define IDD_DISCONNECTDIALOG            500
#define IDD_GETCONNECTION               600
#define IDC_BUFSIZE                     601
#define IDD_CANCELCONNECTION2           700
#define IDC_FORCE                       701
#define IDC_NOFORCE                     702
#define IDC_REFCOUNT                    703
#define IDD_USECONNECTION               800
#define IDC_CONNECT_REDIRECT            801
#define IDC_CONNECT_CURRENT_MEDIA       802
#define IDC_RESULT                      803
#define IDC_ACCESSNAME                  806
#define IDC_ACCESS_YES                  807
#define IDC_ACCESS_NO                   808
#define IDD_ADDCONNECTION3              900
#define IDC_HWND_VALID                  901
#define IDC_HWND_NO                     902
#define IDC_PASSWORD                    905
#define IDC_PASSWORD_TEXT               906
#define IDC_USER                        907
#define IDC_USER_TEXT                   908
#define IDC_CONNECT_TEMPORARY           909
#define IDC_CONNECT_INTERACTIVE         910
#define IDC_CONNECT_PROMPT              911
#define IDC_CONNECT_UPDATE_PROFILE      912
#define IDC_CONNECT_UPDATE_RECENT       913
#define IDD_CONNECTIONDIALOG1           1000
#define IDC_RETURNREMOTE                1034
#define IDC_RETURNPROVIDER              1035
#define IDC_RETURNSCOPE                 1036
#define IDC_RETURNTYPE                  1037
#define IDC_RETURNSYSTEM                1038
#define IDC_RETURNDISPLAYTYPE           1039
#define IDC_RETURNLOCALNAME             1040
#define IDC_RETURNUSAGE                 1041
#define IDC_UNIVERSALLEVEL              1042
#define IDC_RETURNCOMMENT               1042
#define IDC_REMOTELEVEL                 1043
#define IDC_RETURNUNIVERSAL             1044
#define IDC_RETURNCONNECTION            1045
#define IDC_RETURNREMAINING             1046
#define IDC_RETURNUSER                  1047
#define IDC_NAME                        1048
#define IDC_NAME_TEXT                   1049
#define IDC_RETURNFLAGS                 1051
#define IDC_RETURNSPEED                 1052
#define IDC_RETURNOPTDATASIZE           1053
#define IDC_RETURNDELAY                 1054
#define IDC_PROVIDERNAME                1055
#define IDC_PROVIDERTYPE                1056
#define IDC_INFOLEVEL                   1057
#define IDC_HELPFILE                    1058
#define IDC_HELPINDEX                   1059
#define IDC_MESSAGES                    1059
#define IDD_ADDCONNECTION               1100
#define IDD_ADDCONNECTION2              1200
#define IDD_CANCELCONNECTION            1300
#define IDD_FORMATNETWORKNAME           1400
#define IDC_MULTILINE                   1401
#define IDC_ABBREVIATED                 1402
#define IDC_RETURN                      1403
#define IDC_INENUM                      1404
#define IDD_GETNETWORKINFORMATION       1500
#define IDC_PROVIDERVERSION             1501
#define IDC_STATUS                      1502
#define IDC_CHARACTERISTICS             1503
#define IDC_HANDLE                      1504
#define IDC_NETTYPE                     1505
#define IDC_PRINTERS                    1506
#define IDC_DRIVES                      1507
#define IDC_TREE                        1600
#define IDC_RESOURCE_CONNECTED          1600
#define IDC_REMOTE                      1604
#define IDC_REMOTE_TEXT                 1605
#define IDC_PROVIDER                    1606
#define IDC_PROVIDER_TEXT               1607
#define IDC_RESOURCE_SHAREABLE          1608
#define IDC_RESOURCE_GLOBALNET          1611
#define IDC_RESOURCE_REMEMBERED         1612
#define IDC_RESOURCE_RECENT             1613
#define IDC_RESOURCE_CONTEXT            1614
#define IDC_DISK                        1615
#define IDC_PRINTER                     1616
#define IDC_ANY                         1617
#define IDC_RESERVED                    1618
#define IDC_BUFFER_SIZE                 1619
#define IDC_RESOURCEUSAGE_CONNECTABLE   1630
#define IDC_RESOURCEUSAGE_CONTAINER     1631
#define IDC_USE_WNETFORMATNETWORKNAME   1632
#define IDC_BROWSE_NAME                 1633
#define IDD_MAIN                        2000
#define IDD_START                       2001
#define IDD_GETCONNECTIONPERFORMANCE    2002
#define IDI_GENERIC                     3000
#define IDI_DOMAIN                      3001
#define IDI_SERVER                      3002
#define IDI_SHARE                       3003
#define IDI_FILE                        3004
#define IDI_GROUP                       3005
#define IDI_NETWORK                     3006
#define IDI_ROOT                        3007
#define IDI_SHAREADMIN                  3008
#define IDI_DIRECTORY                   3009
#define IDI_TREE                        3010

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        114
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1061
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\netui\help.c ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    help.c
    This module implements the "help" command of the NETUI debugger
    extension DLL.


    FILE HISTORY:
        KeithMo     07-Jul-1992 Created.

*/

#include "netui.h"


/*******************************************************************

    NAME:       help

    SYNOPSIS:   Implements the "help" command.

    ENTRY:      hCurrentProcess         - Handle to the current process.

                hCurrentThread          - Handle to the current thread.

                dwCurrentPc             - The current program counter
                                          (EIP for x86, FIR for MIPS).

                lpExtensionApis         - Points to a structure containing
                                          pointers to the debugger functions
                                          that the command may invoke.

                lpArgumentString        - Points to any arguments passed
                                          to the command.

    HISTORY:
        KeithMo     07-Jul-1992 Created.

********************************************************************/
VOID help( HANDLE hCurrentProcess,
           HANDLE hCurrentThread,
           DWORD  dwCurrentPc,
           LPVOID lpExtensionApis,
           LPSTR  lpArgumentString )
{
    //
    //  Grab the debugger entrypoints.
    //

    GrabDebugApis( lpExtensionApis );

    //
    //  Show the help.
    //

    DebugPrint( "NETUI Debugger Extensions:\n" );
    DebugPrint( "  help           - Show this help\n" );
    DebugPrint( "  heapres        - Dump residual heap blocks\n" );
    DebugPrint( "  und (symbol)   - Undecorate symbol name\n" );

    return;

}   // help
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\netui\heapres.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    heapres.cxx
    This module implements the "heapres" command of the NETUI debugger
    extension DLL.

    This command dumps the heap residue left by an unclean app.


    FILE HISTORY:
        KeithMo     13-Aug-1992 Created.

*/


#include "netui.h"

#define HEAPDEBUG
#include <heapdbg.hxx>


//
//  A function prototype is necessary to keep C++
//  from mangling the symbol.
//

extern "C"
{
    VOID heapres( HANDLE hCurrentProcess,
                  HANDLE hCurrentThread,
                  DWORD  dwCurrentPc,
                  LPVOID lpExtensionApis,
                  LPSTR  lpArgumentString );

}   // extern "C"


/*******************************************************************

    NAME:       heapres

    SYNOPSIS:   Displays heap residue.

    ENTRY:      hCurrentProcess         - Handle to the current process.

                hCurrentThread          - Handle to the current thread.

                dwCurrentPc             - The current program counter
                                          (EIP for x86, FIR for MIPS).

                lpExtensionApis         - Points to a structure containing
                                          pointers to the debugger functions
                                          that the command may invoke.

                lpArgumentString        - Points to any arguments passed
                                          to the command.

    NOTES:      The argument string must contain the address of a
                residual heap block.  This can be *any* residual
                heap block, but is typically the first.

    HISTORY:
	KeithMo     13-Aug-1992 Created.
	Johnl	    09-Nov-1992 Added break in case of invalid heap block

********************************************************************/
VOID heapres( HANDLE hCurrentProcess,
              HANDLE hCurrentThread,
              DWORD  dwCurrentPc,
              LPVOID lpExtensionApis,
              LPSTR  lpArgumentString )
{
    //
    //  Grab the debugger entrypoints.
    //

    GrabDebugApis( lpExtensionApis );

    //
    //  Get the initial residual heap block address.
    //

    struct HEAPTAG * pht      = (struct HEAPTAG *)DebugEval( lpArgumentString );
    struct HEAPTAG * phtFirst = pht;

    //
    //  Dump the blocks.
    //

    while( pht != NULL )
    {
        struct HEAPTAG ht;

        //
        //  Read the current header.  Note that since the debugger is
        //  run in a separate process from the debugee, we can't just
        //  dereference the pointers.  We must use ReadProcessMemory to
        //  copy data from the debuggee's process into our process.
        //

        ReadProcessMemory( hCurrentProcess,
                           (LPVOID)pht,
                           (LPVOID)&ht,
                           sizeof(HEAPTAG),
                           (LPDWORD)NULL );

        DebugPrint( "Hdr = %08lX, Blk = %08lX, Size = %lX\n",
                    (ULONG)pht,
                    (ULONG)pht + sizeof(HEAPTAG),
                    (ULONG)ht._usSize );

        if( ht._cFrames > MAX_STACK_DEPTH )
        {
	    DebugPrint( "_cFrames exceeds MAX_STACK_DEPTH, possible invalid or corrupt heap block!\n" );
	    break ;
        }
        else
        if( ht._cFrames > 0 )
        {
            //
            //  Dump the stack backtrace.
            //

            DebugPrint( "Stack Backtrace:\n" );

            for( UINT i = 0 ; i < ht._cFrames ; i++ )
            {
                UCHAR szSymbolName[128];
                DWORD dwDisplacement;

                //
                //  Get the symbol name & displacement from that symbol.
                //  The displacement will be a positive offset from the
                //  specified value (_pvRetAddr[i]) to the returned symbol.
                //

                DebugGetSymbol( (LPVOID)ht._pvRetAddr[i],
                                szSymbolName,
                                &dwDisplacement );

                DebugPrint( "        [%08lX] = ",
                            (ULONG)ht._pvRetAddr[i] );

                //
                //  If it was a know symbol, print it.  Otherwise,
                //  just print "unknown".
                //

                if( szSymbolName[0] == '\0' )
                {
                    DebugPrint( "unknown\n" );
                }
                else
                {
                    DebugPrint( "%s + %lX\n",
                                szSymbolName,
                                (ULONG)dwDisplacement );
                }

                //
                //  Check for CTRL-C, to let the user bag-out early.
                //

                if( DebugCheckCtrlC() )
                {
                    return;
                }
            }
        }

        DebugPrint( "\n" );

        //
        //  Advance to the next residual heap block.  If we've
        //  wrapped around to the original block, then we're done.
        //

        pht = ht._phtRight;

        if( pht == phtFirst )
        {
            break;
        }
    }

}   // heapres
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\netui\netui.c ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    netui.c
    This is the main module for the NETUI debugger extension DLL.  This
    module contains the DLL initialization/termination code and a few
    utility functions.


    FILE HISTORY:
        KeithMo     07-Jul-1992 Created.

*/

#include "netui.h"


//
//  Globals shared by all extension commands.
//

PNTSD_OUTPUT_ROUTINE  DebugPrint;
PNTSD_GET_EXPRESSION  DebugEval;
PNTSD_GET_SYMBOL      DebugGetSymbol;
PNTSD_DISASM          DebugDisassem;
PNTSD_CHECK_CONTROL_C DebugCheckCtrlC;


/*******************************************************************

    NAME:       NetuiDllInitialize

    SYNOPSIS:   This DLL entry point is called when processes & threads
                are initialized and terminated, or upon calls to
                LoadLibrary() and FreeLibrary().

    ENTRY:      hDll                    - A handle to the DLL.

                nReason                 - Indicates why the DLL entry
                                          point is being called.

                pReserved               - Reserved.

    RETURNS:    BOOLEAN                 - TRUE  = DLL init was successful.
                                          FALSE = DLL init failed.

    NOTES:      The return value is only relevant during processing of
                DLL_PROCESS_ATTACH notifications.

    HISTORY:
        KeithMo     07-Jul-1992 Created.

********************************************************************/
BOOLEAN NetuiDllInitialize( HANDLE hDll,
                            DWORD  nReason,
                            LPVOID pReserved )
{
    BOOLEAN fResult = TRUE;

    switch( nReason  )
    {
    case DLL_PROCESS_ATTACH:
        //
        //  This notification indicates that the DLL is attaching to
        //  the address space of the current process.  This is either
        //  the result of the process starting up, or after a call to
        //  LoadLibrary().  The DLL should us this as a hook to
        //  initialize any instance data or to allocate a TLS index.
        //
        //  This call is made in the context of the thread that
        //  caused the process address space to change.
        //

        break;

    case DLL_PROCESS_DETACH:
        //
        //  This notification indicates that the calling process is
        //  detaching the DLL from its address space.  This is either
        //  due to a clean process exit or from a FreeLibrary() call.
        //  The DLL should use this opportunity to return any TLS
        //  indexes allocated and to free any thread local data.
        //
        //  Note that this notification is posted only once per
        //  process.  Individual threads do not invoke the
        //  DLL_THREAD_DETACH notification.
        //

        break;

    case DLL_THREAD_ATTACH:
        //
        //  This notfication indicates that a new thread is being
        //  created in the current process.  All DLLs attached to
        //  the process at the time the thread starts will be
        //  notified.  The DLL should use this opportunity to
        //  initialize a TLS slot for the thread.
        //
        //  Note that the thread that posts the DLL_PROCESS_ATTACH
        //  notification will not post a DLL_THREAD_ATTACH.
        //
        //  Note also that after a DLL is loaded with LoadLibrary,
        //  only threads created after the DLL is loaded will
        //  post this notification.
        //

        break;

    case DLL_THREAD_DETACH:
        //
        //  This notification indicates that a thread is exiting
        //  cleanly.  The DLL should use this opportunity to
        //  free any data stored in TLS indices.
        //

        break;

    default:
        //
        //  Who knows?  Just ignore it.
        //

        break;
    }

    return fResult;

}   // NetuiDllInitialize


/*******************************************************************

    NAME:       GrabDebugApis

    SYNOPSIS:   Initializes the global variables that hold pointers
                to the debugger API functions.

    ENTRY:      lpExtensionApis         - Points to a structure that
                                          contains pointers to the
                                          various debugger APIs.

    HISTORY:
        KeithMo     07-Jul-1992 Created.

********************************************************************/
VOID GrabDebugApis( LPVOID lpExtensionApis )
{
    PNTSD_EXTENSION_APIS lpNtsdApis = (PNTSD_EXTENSION_APIS)lpExtensionApis;

    DebugPrint      = lpNtsdApis->lpOutputRoutine;
    DebugEval       = lpNtsdApis->lpGetExpressionRoutine;
    DebugGetSymbol  = lpNtsdApis->lpGetSymbolRoutine;
    DebugDisassem   = lpNtsdApis->lpDisasmRoutine;
    DebugCheckCtrlC = lpNtsdApis->lpCheckControlCRoutine;

}   // GrabDebugApis
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\netui\undname.c ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    undname.c
    This module implements the "und" command of the NETUI debugger
    extension DLL.


    FILE HISTORY:
        KeithMo     10-Nov-1993 Created.

*/

#include "netui.h"
#include <imagehlp.h>


/*******************************************************************

    NAME:       und

    SYNOPSIS:   Implements the "und" command.

    ENTRY:      hCurrentProcess         - Handle to the current process.

                hCurrentThread          - Handle to the current thread.

                dwCurrentPc             - The current program counter
                                          (EIP for x86, FIR for MIPS).

                lpExtensionApis         - Points to a structure containing
                                          pointers to the debugger functions
                                          that the command may invoke.

                lpArgumentString        - Points to any arguments passed
                                          to the command.

    HISTORY:
        KeithMo     10-Nov-1993 Created.

********************************************************************/
VOID und( HANDLE hCurrentProcess,
          HANDLE hCurrentThread,
          DWORD  dwCurrentPc,
          LPVOID lpExtensionApis,
          LPSTR  lpArgumentString )
{
    char szUndecorated[512];

    //
    //  Grab the debugger entrypoints.
    //

    GrabDebugApis( lpExtensionApis );

    //
    //  Validate argument.
    //

    if( ( lpArgumentString == NULL ) || ( *lpArgumentString == '\0' ) )
    {
        DebugPrint( "use: und decorated_symbol_name\n" );
        return;
    }

    //
    //  Undecorate it.
    //

    UnDecorateSymbolName( lpArgumentString,
                          szUndecorated,
                          sizeof(szUndecorated),
                          UNDNAME_COMPLETE );

    DebugPrint( "%s\n", szUndecorated );

}   // und
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\netui\netui.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    netui.h
    This include file contains the prototypes & manifest constants
    used by the NETUI debugger extension DLL.


    FILE HISTORY:
        KeithMo     07-Jul-1992 Created.

*/


#ifndef _NETUI_H_
#define _NETUI_H_


#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntsdexts.h>
#include <wdbgexts.h>


//
//  Globals shared by all extension commands.
//

extern PNTSD_OUTPUT_ROUTINE  DebugPrint;
extern PNTSD_GET_EXPRESSION  DebugEval;
extern PNTSD_GET_SYMBOL      DebugGetSymbol;
extern PNTSD_DISASM          DebugDisassem;
extern PNTSD_CHECK_CONTROL_C DebugCheckCtrlC;


//
//  Utility functions.
//

VOID GrabDebugApis( LPVOID lpExtensionApis );


//
//  DLL entrypoint.
//
//

BOOLEAN NetuiDllInitialize( HANDLE hDll,
                            DWORD  nReason,
                            LPVOID pReserved );


#ifdef __cplusplus
}       // extern "C"
#endif  // __cplusplus


#endif  // _NETUI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\nwc\h\nwchelp.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    ftphelp.h
    NWC Applet include file for help numbers

    FILE HISTORY:
        ChuckC    25-Oct-1993   Created

*/


#ifndef _NWCHELP_H_
#define _NWCHELP_H_

#include <uihelp.h>

#define  HC_UI_NWCCPL_BASE      7000+42000  // BUGBUG
#define  HC_UI_NWCCPL_LAST      7000+42199  // BUGBUG

#define HC_NWC_DIALOG                 (HC_UI_NWCCPL_BASE + 1)
#define HC_NWC_HELP                   (HC_UI_NWCCPL_BASE + 5)
#define HC_NWC_GATEWAY                (HC_UI_NWCCPL_BASE + 6)
#define HC_NWC_ADDSHARE               (HC_UI_NWCCPL_BASE + 7)

#define HC_NTSHAREPERMS               (HC_UI_NWCCPL_BASE + 11)
#define HC_SHAREADDUSER               (HC_UI_NWCCPL_BASE + 12)
#define HC_SHAREADDUSER_LOCALGROUP    (HC_UI_NWCCPL_BASE + 13)
#define HC_SHAREADDUSER_GLOBALGROUP   (HC_UI_NWCCPL_BASE + 14)
#define HC_SHAREADDUSER_FINDUSER      (HC_UI_NWCCPL_BASE + 15)

#endif  // _NWCHELP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\nwc\h\nwc.h ===
/*****************************************************************/
/**                  Microsoft Windows NT                       **/
/**            Copyright(c) Microsoft Corp., 1993               **/
/*****************************************************************/

/*
 *  nwc.h
 *  This manifests are used by the nwc applat.
 *
 *  History:
 *      ChuckC          7/18/93         Created
 *
 */

#ifndef _NWC_H_
#define _NWC_H_

#include <uirsrc.h>
#include <uimsg.h>

#define IDRSRC_NWCCPL_BASE         13000  // BUGBUG
#define IDRSRC_NWCCPL_LAST         13499  // BUGBUG
#define IDS_UI_NWCCPL_BASE         7000+17000  // BUGBUG
#define IDS_UI_NWCCPL_LAST         7000+17499  // BUGBUG

/*
 *  Resource Ids from 13000-13199 are reserved for nwc.h
 */

/*
 *  Icons - used in the control panel applet only
 */

#define IDI_NWCCPA_ICON                 13001

/*
 *  Bitmaps
 */

/*
 *  Dialog Numbers
 */

#define IDD_NWCDLG                13002
#define IDD_NWC_GW_DLG            13003
#define IDD_NWC_GWADD_DLG         13004
#define IDD_NWC_WINNT_DLG         13005

/*
 *  NWC Applet dialog controls
 */


#define SLT_USERNAME                200
#define SLT_CURRENTPREFERREDSERVER  201
#define COMBO_PREFERREDSERVERS      202
#define CHKBOX_FORMFEED             203
#define CHKBOX_PRINTNOTIFY          204
#define CHKBOX_PRINTBANNER          205
#define IDD_NWC_GATEWAY             206
#define IDD_NWC_HELP                207
#define RB_PREFERRED_SERVER         208
#define RB_DEFAULT_CONTEXT          209
#define SLE_DEFAULT_CONTEXT         210
#define SLE_DEFAULT_TREE            211
#define CHKBOX_LOGONSCRIPT          212

#define GW_CHKBOX_ENABLE            300
#define GW_SLE_ACCOUNT              301
#define GW_SLE_PASSWD               302
#define GW_SLE_CONFIRM_PASSWD       303
#define GW_PB_PERM                  304
#define GW_PB_ADD                   305
#define GW_PB_DELETE                306
#define GW_LB_SHARES                307
#define GW_SLT_SHARE                308
#define GW_SLT_DRIVE                309
#define GW_SLT_USERS                310
#define GW_SLT_PATH                 311

#define GW_SLE_SHARENAME            400
#define GW_SLE_PATH                 401
#define GW_COMBO_DRIVE              402
#define GW_SLE_COMMENT              403
#define GW_RB_UNLIMITED             404
#define GW_RB_USERS                 405
#define GW_SLE_USERS                406
#define GW_SB_USERS_GROUP           407
#define GW_SB_USERS_UP              408
#define GW_SB_USERS_DOWN            409


/*
 *  String IDs
 */

#define IDS_NWCCPA_NAME_STRING                (IDS_UI_NWCCPL_BASE+1)
#define IDS_NWCCPA_INFO_STRING                (IDS_UI_NWCCPL_BASE+2)
#define IDS_CPL_HELPFILENAME                  (IDS_UI_NWCCPL_BASE+3)
#define IDS_CPL_HELPFILENAME_NTAS             (IDS_UI_NWCCPL_BASE+4)
#define IDS_NWC_SERVICE_UNAVAIL               (IDS_UI_NWCCPL_BASE+5)
#define IDS_NONE                              (IDS_UI_NWCCPL_BASE+6)
#define IDS_REGISTRY_UPDATED_ONLY             (IDS_UI_NWCCPL_BASE+7)
#define IDS_AUTHENTICATION_FAILURE_WARNING    (IDS_UI_NWCCPL_BASE+8)
#define IDS_INVALID_SERVER_NAME               (IDS_UI_NWCCPL_BASE+9)
#define IDS_RESTART_SERVER                    (IDS_UI_NWCCPL_BASE+10)
#define IDS_PASSWORD_HAS_EXPIRED              (IDS_UI_NWCCPL_BASE+11)
#define IDS_PASSWORDS_NO_MATCH                (IDS_UI_NWCCPL_BASE+12)
#define IDS_DELETED                           (IDS_UI_NWCCPL_BASE+13)
#define IDS_ACCESS_PROBLEM                    (IDS_UI_NWCCPL_BASE+15)
#define IDS_SHARE                             (IDS_UI_NWCCPL_BASE+16)
#define IDS_SHARE_PERM_GEN_READ               (IDS_UI_NWCCPL_BASE+17)
#define IDS_SHARE_PERM_GEN_MODIFY             (IDS_UI_NWCCPL_BASE+18)
#define IDS_SHARE_PERM_GEN_ALL                (IDS_UI_NWCCPL_BASE+19)
#define IDS_SHARE_PERM_GEN_NO_ACCESS          (IDS_UI_NWCCPL_BASE+20)
#define IDS_GATEWAY_NO_ACCESS                 (IDS_UI_NWCCPL_BASE+21)
#define IDS_CONFIRM_DISABLE                   (IDS_UI_NWCCPL_BASE+22)
#define IDS_UNLIMITED                         (IDS_UI_NWCCPL_BASE+23)
#define IDS_NWC_SERVICE_UNAVAIL_NTAS          (IDS_UI_NWCCPL_BASE+24)
#define IDS_NWCCPA_NAME_STRING_NTAS           (IDS_UI_NWCCPL_BASE+25)
#define IDS_NWCCPA_INFO_STRING_NTAS           (IDS_UI_NWCCPL_BASE+26)
#define IDS_SHARE_NOT_ACCESSIBLE_FROM_DOS     (IDS_UI_NWCCPL_BASE+27)
#define IDS_TREE_NAME_MISSING                 (IDS_UI_NWCCPL_BASE+28)
#define IDS_CONTEXT_MISSING                   (IDS_UI_NWCCPL_BASE+29)
#define IDS_SERVER_MISSING                    (IDS_UI_NWCCPL_BASE+30)
#define IDS_CONTEXT_AUTH_FAILURE_WARNING      (IDS_UI_NWCCPL_BASE+31)


/*
 *  Help Context
 */
#include <nwchelp.h>

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\shell\bin\dummy.cxx ===
extern i ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\nwc\nwc\nwccpl.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    nwccpl.cxx
    This is the main module for the Netware Compat Software Applet.
    It contains the "CplApplet" function.


    FILE HISTORY:
        ChuckC          17-Jul-1993      Templated from ftpmgr

*/



#include <ntincl.hxx>
#define INCL_NET
#define INCL_NETLIB
#define INCL_NETSERVICE
#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETERRORS
#define INCL_DOSERRORS
#include <lmui.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif

#include <uiassert.hxx>
#include <uitrace.hxx>

#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_CLIENT
#define INCL_BLT_MSGPOPUP
#define INCL_BLT_EVENT
#define INCL_BLT_MISC
#define INCL_BLT_TIMER
#define INCL_BLT_CC
#define INCL_BLT_SPIN_GROUP
#define INCL_BLT_GROUP
#include <blt.hxx>

#include <dbgstr.hxx>
#include <uatom.hxx>
#include <regkey.hxx>
#include <lmoloc.hxx>

extern "C"
{
    #include <cpl.h>               // Multimedia CPL defs
    #include <nwc.h>
}


extern "C"
{
    //
    //  Control Panel Applet entry point.
    //

    LONG APIENTRY CPlApplet( HWND hwndCpl,
                             UINT msg,
                             LPARAM lParam1,
                             LPARAM lParam2 );


    //
    //  DLL load/unload entry point.
    //

    BOOL WINAPI NwcCplDllInitialize( HINSTANCE hInstance,
                                     DWORD  nReason,
                                     LPVOID pReserved );

    //
    //  Globals.
    //

    HINSTANCE _hCplInstance = NULL;
    BOOL _fIsWinnt = TRUE ;

}   // extern "C"

#include <nwc.hxx>

//
//  This is the "type" for an applet startup function.
//

typedef APIERR (* PCPL_APPLET_FUNC)( HWND hWnd );


//
//  We'll keep one of these structures for each applet in this DLL.
//

typedef struct _CPL_APPLET
{
    int                 idIcon;
    int                 idName;
    int                 idInfo;
    int                 idHelpFile;
    DWORD               dwHelpContext;
    LONG                lData;
    PCPL_APPLET_FUNC    pfnApplet;

} CPL_APPLET;


//
//  Forward reference prototypes.
//

APIERR RunNwcApplet( HWND hWnd );


//
//  Our applet descriptors.
//

CPL_APPLET CplApplets[] =
                          {
                              {  // NWC Server applet
                                 IDI_NWCCPA_ICON,
                                 IDS_NWCCPA_NAME_STRING,
                                 IDS_NWCCPA_INFO_STRING,
                                 IDS_CPL_HELPFILENAME,
                                 HC_NWC_DIALOG,
                                 0L,
                                 &RunNwcApplet
                              }
                          };

CPL_APPLET CplAppletsNTAS[] =
                          {
                              {  // NWC Server applet
                                 IDI_NWCCPA_ICON,
                                 IDS_NWCCPA_NAME_STRING_NTAS,
                                 IDS_NWCCPA_INFO_STRING_NTAS,
                                 IDS_CPL_HELPFILENAME_NTAS,
                                 HC_NWC_DIALOG,
                                 0L,
                                 &RunNwcApplet
                              }
                          };


#define NUM_APPLETS ( sizeof(CplApplets) / sizeof(CplApplets[0]) )
#define NWC_PARAMETERS_KEY SZ("System\\CurrentControlSet\\Services\\NWCWorkstation\\Parameters")

/*******************************************************************

    NAME:       InitializeDll

    SYNOPSIS:   Perform DLL initialiazation functions on a
                once-per-process basis.

    ENTRY:      hInstance  - Program instance of the caller.

    EXIT:       If this is the first initialization request for this
                process, then all necessary BLT initializers have
                been invoked.

    RETURNS:    BOOL       - TRUE  = Initialization OK.
                             FALSE = Initialization failed.

    HISTORY:
        YiHsinS         22-Mar-1993      Templated from Keithmo's srvmcpl.cxx.

********************************************************************/
BOOL InitializeDll( HINSTANCE hInstance )
{
    NT_PRODUCT_TYPE ProductType ;

    //
    //  Save the instance handle.
    //
    _hCplInstance = hInstance;

    //
    // are we a winnt machine?
    //

    //
    // tommye - MS 176469
    //
    // No longer supporting the Gateway - so just force it to be disabled
    //

#ifdef GATEWAY_ENABLED
    _fIsWinnt = RtlGetNtProductType(&ProductType) ?
                   (ProductType == NtProductWinNt) :
                   FALSE ;
#else
    _fIsWinnt = TRUE;
#endif

    return TRUE;

}   // InitializeDll


/*******************************************************************

    NAME:       TerminateDll

    SYNOPSIS:   Perform DLL termination functions on a
                once-per-process basis.

    EXIT:       All necessary BLT terminators have been invoked.

    HISTORY:
        YiHsinS         22-Mar-1993      Templated from Keithmo's srvmcpl.cxx.

********************************************************************/
VOID TerminateDll( VOID )
{
    //
    //  Just in case we try to do anything goofy.
    //

    _hCplInstance = NULL;

}   // TerminateDll


/*******************************************************************

    NAME:       IsNwcInstalled

    SYNOPSIS:   Determines if the NWC wksta is installed.
                This doesn't necessarily mean the service is actually
                running, just that it is installed on the system.

    RETURNS:    BOOL   - TRUE  = NWC wksta service is installed.
                         FALSE = NWC wksta service isn't installed.

    NOTES:      We could perform this check by trying to open the
                service via the Service Controller, but this would
                cause a lot of extraneous code to get paged in.
                Instead, we'll check for the presence of the registry
                key that controls the service.

    HISTORY:
        KeithMo         09-Apr-1993      Created.

********************************************************************/
BOOL IsNwcInstalled( VOID )
{
    BOOL fInstalled = FALSE;    // until proven otherwise...

    //
    //  Open the registry root.
    //

    REG_KEY RootKey( HKEY_LOCAL_MACHINE );

    APIERR err = RootKey.QueryError();

    if( err == NERR_Success )
    {
        //
        //  Open the NWC registry key.
        //

        ALIAS_STR nlsKeyName( (TCHAR *)NWC_PARAMETERS_KEY );
        UIASSERT( !!nlsKeyName );

        REG_KEY RegKey( RootKey, nlsKeyName );
        err = RegKey.QueryError();

        if( err == NERR_Success )
        {
            //
            //  Since we successfully opened the NWC wksta
            //  parameters key, we'll assume that the service
            //  is indeed installed.
            //

            fInstalled = TRUE;
        }
    }

    return fInstalled;

}


/*******************************************************************

    NAME:       InitializeAllApplets

    SYNOPSIS:   Called before applet runs.

    ENTRY:      hWnd   - Window handle of parent window.

    RETURNS:    BOOL   - TRUE  = Applet should be installed.
                         FALSE = Applet cannot be installed.

    HISTORY:
        YiHsinS         22-Mar-1993      Templated from Keithmo's srvmcpl.cxx.
        KeithMo         09-Apr-1993      Don't init if service not installed.
        JonN            10-Jul-1996      Only called when applet runs

********************************************************************/
BOOL InitializeAllApplets( HWND hWnd )
{
    TRACEEOL( "NWC.CPL: InitializeAllApplets enter" );

/* Don't bother, we already did this at CPL_INIT time.

    //
    //  Before we do anything, check to see if the NWC wksta
    //  is installed.  If it isn't there's not much point in running
    //  this applet.
    //

    if( !IsNwcInstalled() )
    {
        TRACEEOL( "NWC.CPL: InitializeAllApplets: not installed, Initialize failure OK" );
        return FALSE;
    }
*/

    //
    //  Initialize all of the NetUI goodies.
    //

    APIERR err = BLT::Init( _hCplInstance,
                            IDRSRC_NWCCPL_BASE, IDRSRC_NWCCPL_LAST,
                            IDS_UI_NWCCPL_BASE, IDS_UI_NWCCPL_LAST );
    TRACEEOL( "NWC.CPL: InitializeAllApplets BLT::Init returns " << err );

    if( err == NERR_Success )
    {
        TRACEEOL( "NWC.CPL: InitializeAllApplets BLT::_MASTER_TIMER::Init next" );
        err = BLT_MASTER_TIMER::Init();
        TRACEEOL( "NWC.CPL: InitializeAllApplets BLT::_MASTER_TIMER::Init returns " << err );

        if( err != NERR_Success )
        {
            //
            //  BLT initialized OK, but BLT_MASTER_TIMER
            //  failed.  So, before we bag-out, we must
            //  deinitialize BLT.
            //

            BLT::Term( _hCplInstance );
        }
    }

    if( err == NERR_Success )
    {

        if (_fIsWinnt) {
            
            err = BLT::RegisterHelpFile( _hCplInstance,
                                     IDS_CPL_HELPFILENAME,
                                     HC_UI_NWCCPL_BASE,
                                     HC_UI_NWCCPL_LAST );

        } else {

            err = BLT::RegisterHelpFile( _hCplInstance,
                                     IDS_CPL_HELPFILENAME_NTAS,
                                     HC_UI_NWCCPL_BASE,
                                     HC_UI_NWCCPL_LAST );
        }

        if( err != NERR_Success )
        {
            //
            //  This is the only place where we can safely
            //  invoke MsgPopup, since we *know* that all of
            //  the BLT goodies were initialized properly.
            //
            ::MsgPopup( hWnd, err );

            BLT::Term( _hCplInstance );
        }
    }
    TRACEEOL( "NWC.CPL: InitializeAllApplets exit" );

    ASSERT( err == NERR_Success );

    return err == NERR_Success;

}   // InitializeAllApplets


/*******************************************************************

    NAME:       TerminateAllApplets

    SYNOPSIS:   Called after applet runs.

    ENTRY:      hWnd - Window handle of parent window.

    HISTORY:
        YiHsinS         22-Mar-1993      Templated from Keithmo's srvmcpl.cxx.
        JonN            10-Jul-1996      Only called when applet runs

********************************************************************/
VOID TerminateAllApplets( HWND hWnd )
{
    UNREFERENCED( hWnd );

    //
    //  Kill the NetUI goodies.
    //

    TRACEEOL( "NWC.CPL: TerminateAllApplets enter" );
    BLT::DeregisterHelpFile( _hCplInstance, 0 );
    TRACEEOL( "NWC.CPL: TerminateAllApplets BLT::_MASTER_TIMER::Term next" );
    BLT_MASTER_TIMER::Term();
    TRACEEOL( "NWC.CPL: TerminateAllApplets BLT::_MASTER_TIMER::Term complete" );
    BLT::Term( _hCplInstance );
    TRACEEOL( "NWC.CPL: TerminateAllApplets exit" );

}   // TerminateAllApplets

#if 0

/*******************************************************************

    NAME:       AutoStartFtpServer

    SYNOPSIS:   Check the state of the FTP Server service.  If it
                isn't started, ask the user if it should be started.
                If the user wants us to start the service, start it.

    ENTRY:      hWnd    - Window handle of parent window.

    RETURNS:    BOOL - TRUE  == FTP Server service is running.
                       FALSE == FTP Server service isn't running.
                                This may indicate either an error
                                or the user didn't want the service
                                started.  If an error occurs, this
                                routine is responsible for displaying
                                it to the user.

    HISTORY:
        KeithMo         09-Apr-1993     Created.

********************************************************************/
BOOL AutoStartFtpServer( HWND hWnd )
{
    BOOL fStarted = FALSE;      // until proven otherwise...

    //
    //  Get the "display name" for the local machine.
    //

    LOCATION loc( LOC_TYPE_LOCAL );
    NLS_STR  nlsDisplayName;

    APIERR err = loc.QueryError();
    err = err ? err : nlsDisplayName.QueryError();
    err = err ? err : loc.QueryDisplayName( &nlsDisplayName );

    if( err == NERR_Success )
    {
        //
        //  Determine the state of the service.
        //

        GENERIC_SERVICE * psvc = new GENERIC_SERVICE( hWnd,
                                                      NULL,
                                                      nlsDisplayName,
                                                      (TCHAR *)FTPD_SERVICE_NAME );

        err = ( psvc == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
                               : psvc->QueryError();

        if( err == NERR_Success )
        {
            fStarted = psvc->IsInstalled( &err );

            if( !fStarted && ( err == NERR_Success ) )
            {
                //
                //  Service isn't started.  See if the user wants us
                //  to start it.
                //

                if( ::MsgPopup( hWnd,
                                IDS_START_FTPSVC_NOW,
                                MPSEV_WARNING,
                                MP_YESNO,
                                MP_YES ) == IDYES )
                {
                    err = psvc->Start();

                    if( err == NERR_ServiceInstalled )
                    {
                        //
                        //  Somebody must have started the service
                        //  behind our backs...
                        //

                        err = NERR_Success;
                    }

                    if( err == NERR_Success )
                    {
                        //
                        //  Whew!
                        //

                        fStarted = TRUE;
                    }
                }
            }
        }

        delete psvc;
    }

    //
    //  If anything tragic occurred, tell the user.
    //

    if( err != NERR_Success )
    {
        ::MsgPopup( hWnd, err );
    }

    return fStarted;

}   // AutoStartFtpServer

#endif

/*******************************************************************

    NAME:       RunNwcApplet

    SYNOPSIS:   Invoke the main dialog of the FTP Server Control
                Panel Applet.

    ENTRY:      hWnd    - Window handle of parent window.

    RETURNS:    APIERR

    HISTORY:
        YiHsinS         18-Mar-1993     Created
        KeithMo         09-Apr-1993     Autostart FTP service.

********************************************************************/
APIERR RunNwcApplet( HWND hWnd )
{

    AUTO_CURSOR autocur;

    // In the control panel applet, we will only be focusing on
    // the local machine.

    POPUP::SetCaption( _fIsWinnt ?
                       IDS_NWCCPA_INFO_STRING :
                       IDS_NWCCPA_INFO_STRING_NTAS );

    NWC_DIALOG * pDlg = new NWC_DIALOG( hWnd, _fIsWinnt );

    APIERR err = ( pDlg == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
                                  : pDlg->QueryError();

    if ( err == NERR_Success )
        err = pDlg->Process();

    delete pDlg;
    pDlg = NULL;

    if( err != NERR_Success )
    {
        if (  ( err == RPC_S_SERVER_UNAVAILABLE )
           || ( err == ERROR_NO_NETWORK )
           )
        {
            err = _fIsWinnt ? IDS_NWC_SERVICE_UNAVAIL :
                             IDS_NWC_SERVICE_UNAVAIL_NTAS ;
        }
        ::MsgPopup( hWnd, err );
    }

    POPUP::ResetCaption();
    return err;

}


#ifndef QFE_BUILD
BOOL strLoad( INT idString, WCHAR * pszBuffer, INT cchBuffer )
#else
BOOL strLoad( INT idString, CHAR * pszBuffer, INT cchBuffer )
#endif
{
#ifndef QFE_BUILD
    int result = ::LoadString( ::_hCplInstance,
#else
    int result = ::LoadStringA( ::_hCplInstance,
#endif
                                idString,
                                pszBuffer,
                                cchBuffer );

    return ( result > 0 ) && ( result < cchBuffer );

}   // strLoad


/*******************************************************************

    NAME:       CPlApplet

    SYNOPSIS:   Exported function to start the NWC applet
                Panel Applet.

    ENTRY:      hwndCPl   - Window handle of parent.

                nMsg      - CPL user message (see CPL.H
                            in WINDOWS\SHELL\CONTROL\H).

                lParam1   - Message-specific pointer.

                lParam2   - Message-specific pointer.

    RETURNS:    LONG

    HISTORY:
        YiHsinS         22-Mar-1993      Templated from Keithmo's srvmcpl.cxx.
        JonN            10-Jul-1996      InitializeAllApplets only called
                                         when applet runs

********************************************************************/
LONG APIENTRY CPlApplet( HWND   hwndCPl,
                         UINT   nMsg,
                         LPARAM lParam1,
                         LPARAM lParam2 )
{
    LPCPLINFO    pCplInfo;
    LPNEWCPLINFO pNewInfo;
    LONG         nResult = 0;


    switch( nMsg )
    {
    case CPL_INIT:
        //
        //  This message is sent to indicate that CPlApplet() was found.
        //
        //  lParam1 and lParam2 are not used.
        //
        //  Return TRUE if applet should be installed, FALSE otherwise.
        //

        if( !IsNwcInstalled() )
        {
            TRACEEOL( "NWC.CPL: CPL_INIT: not installed, do not show CPL" );
            return FALSE;
        }
        return TRUE;

    case CPL_GETCOUNT:
        //
        //  This message is set to determine the number of applets contained
        //  in this DLL.
        //
        //  lParam1 and lParam2 are not used.
        //
        //  Return the number of applets contained in this DLL.
        //

        return NUM_APPLETS;

    case CPL_INQUIRE:
        //
        //  This message is sent once per applet to retrieve information
        //  about each applet.
        //
        //  lParam1 is the applet number to register.
        //
        //  lParam2 is a pointer to a CPLINFO structure.  The CPLINFO
        //  structure's idIcon, idName, idInfo, and lData fields should
        //  be initialized as appropriate for the applet.
        //
        //  There is no return value.
        //

        
        pCplInfo = (LPCPLINFO)lParam2;

        if( lParam1 < NUM_APPLETS )
        {
            CPL_APPLET * pApplet = _fIsWinnt ?
                                       &CplApplets[lParam1] :
                                       &CplAppletsNTAS[lParam1] ;

            pCplInfo->idIcon = pApplet->idIcon;
            pCplInfo->idName = pApplet->idName;
            pCplInfo->idInfo = pApplet->idInfo;
            pCplInfo->lData  = pApplet->lData;
        }
        break;

    case CPL_SELECT:
        //
        //  This message is sent when the applet's icon has been
        //  selected.
        //
        //  lParam1 is the applet number that was selected.
        //
        //  lParam2 is the applet's lData value.
        //
        //  There is no return value.
        //

        break;

    case CPL_DBLCLK:
        //
        //  This message is sent when the applet's icon has been
        //  double-clicked.  This message should initiate the
        //  applet's dialog box.
        //
        //  lParam1 is the applet number that was selected.
        //
        //  lParam2 is the applet's lData value.
        //
        //  There is no return value.
        //

        if( lParam1 < NUM_APPLETS )
        {
            if ( (LONG)InitializeAllApplets( hwndCPl ) )
            {
                if (_fIsWinnt)
                {
                    (CplApplets[lParam1].pfnApplet)( hwndCPl );
                }
                else
                {
                    (CplAppletsNTAS[lParam1].pfnApplet)( hwndCPl );
                }
                TerminateAllApplets( hwndCPl );
            }
            // initialize failure OK when NWC not installed
        }
        break;

    case CPL_STOP:
        //
        //  This message is sent once for each applet when the
        //  control panel is shutting down.  This message should
        //  initiate applet specific cleanup.
        //
        //  lParam1 is the applet number being stopped.
        //
        //  lParam2 is the applet's lData value.
        //
        //  There is no return value.
        //

        break;

    case CPL_EXIT:
        //
        //  This message is sent just before the control panel calls
        //  FreeLibrary.  This message should initiate non applet
        //  specific cleanup.
        //
        //  lParam1 and lParam2 are not used.
        //
        //  There is no return value.
        //

        break;

    case CPL_NEWINQUIRE:
        //
        //  This message is basically the same as CPL_INQUIRE, except
        //  lParam2 points to a NEWCPLINFO structure.  This message will
        //  be sent *before* CPL_INQUIRE.  If the applet returns a non
        //  zero value, then CPL_INQUIRE will not be sent.
        //
        //  lParam1 is the applet number to register.
        //
        //  lParam2 is a pointer to a NEWCPLINFO structure.
        //
        //  Return TRUE this message was handled, otherwise return FALSE.
        //

        pNewInfo = (LPNEWCPLINFO)lParam2;

        if( lParam1 < NUM_APPLETS )
        {
            CPL_APPLET * pApplet = _fIsWinnt ?
                                       &CplApplets[lParam1] :
                                       &CplAppletsNTAS[lParam1] ;

            pNewInfo->dwSize        = sizeof(*pNewInfo);
            pNewInfo->dwFlags       = 0;
            pNewInfo->dwHelpContext = pApplet->dwHelpContext;
            pNewInfo->lData         = pApplet->lData;

            pNewInfo->hIcon = ::LoadIcon( ::_hCplInstance,
                                          MAKEINTRESOURCE( pApplet->idIcon ) );

            if( ( pNewInfo->hIcon != NULL ) &&
                strLoad( pApplet->idName,
                         pNewInfo->szName,
                         sizeof(pNewInfo->szName) ) &&
                strLoad( pApplet->idInfo,
                         pNewInfo->szInfo,
                         sizeof(pNewInfo->szInfo) ) &&
                strLoad( pApplet->idHelpFile,
                         pNewInfo->szHelpFile,
                         sizeof(pNewInfo->szHelpFile) ) )
            {
                nResult = TRUE;
            }
        }
        break;

    default:
        //
        //  Who knows.  Ignore it.
        //

        break;
    }

    return nResult;

}   // CPlApplet


/*******************************************************************

    NAME:       NwcCplDllInitialize

    SYNOPSIS:   This DLL entry point is called when processes & threads
                are initialized and terminated, or upon calls to
                LoadLibrary() and FreeLibrary().

    ENTRY:      hInstance    - A handle to the DLL.

                nReason      - Indicates why the DLL entry
                               point is being called.

                pReserved    - Reserved.

    RETURNS:    BOOL         - TRUE  = DLL init was successful.
                               FALSE = DLL init failed.

    NOTES:      The return value is only relevant during processing of
                DLL_PROCESS_ATTACH notifications.

    HISTORY:
        YiHsinS         22-Mar-1993      Templated from Keithmo's srvmcpl.cxx.

********************************************************************/

BOOL WINAPI NwcCplDllInitialize( HINSTANCE hInstance,
                                 DWORD  nReason,
                                 LPVOID pReserved )
{
    UNREFERENCED( pReserved );

    BOOL fResult = TRUE;

    switch( nReason  )
    {
    case DLL_PROCESS_ATTACH:
        //
        //  This notification indicates that the DLL is attaching to
        //  the address space of the current process.  This is either
        //  the result of the process starting up, or after a call to
        //  LoadLibrary().  The DLL should us this as a hook to
        //  initialize any instance data or to allocate a TLS index.
        //
        //  This call is made in the context of the thread that
        //  caused the process address space to change.
        //

        fResult = InitializeDll( hInstance );
        break;

    case DLL_PROCESS_DETACH:
        //
        //  This notification indicates that the calling process is
        //  detaching the DLL from its address space.  This is either
        //  due to a clean process exit or from a FreeLibrary() call.
        //  The DLL should use this opportunity to return any TLS
        //  indexes allocated and to free any thread local data.
        //
        //  Note that this notification is posted only once per
        //  process.  Individual threads do not invoke the
        //  DLL_THREAD_DETACH notification.
        //

        TerminateDll();
        break;

    case DLL_THREAD_ATTACH:
        //
        //  This notfication indicates that a new thread is being
        //  created in the current process.  All DLLs attached to
        //  the process at the time the thread starts will be
        //  notified.  The DLL should use this opportunity to
        //  initialize a TLS slot for the thread.
        //
        //  Note that the thread that posts the DLL_PROCESS_ATTACH
        //  notification will not post a DLL_THREAD_ATTACH.
        //
        //  Note also that after a DLL is loaded with LoadLibrary,
        //  only threads created after the DLL is loaded will
        //  post this notification.
        //

        break;

    case DLL_THREAD_DETACH:
        //
        //  This notification indicates that a thread is exiting
        //  cleanly.  The DLL should use this opportunity to
        //  free any data stored in TLS indices.
        //

        break;

    default:
        //
        //  Who knows?  Just ignore it.
        //

        break;
    }


    return fResult;


}   // NwcCplDllInitialize
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\nwc\nwc\nwgate.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    nwc.cxx
       The file contains the classes for the Netware Gateway

    FILE HISTORY:
        ChuckC          30-Oct-1993     Created
*/


#define INCL_NET
#define INCL_NETLIB
#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETERRORS
#define INCL_DOSERRORS
#include <lmui.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif

#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_CLIENT
#define INCL_BLT_MSGPOPUP
#define INCL_BLT_EVENT
#define INCL_BLT_MISC
#define INCL_BLT_CC
#define INCL_BLT_SPIN_GROUP
#define INCL_BLT_GROUP
#include <blt.hxx>

#include <uiassert.hxx>
#include <uitrace.hxx>
#include <lmoshare.hxx>
#include <lmoesh.hxx>
#include <dbgstr.hxx>

extern "C"
{
    #include <npapi.h>
    #include <nwevent.h>
    #include <nwsnames.h>
    #include <nwc.h>
    #include <nwapi.h>
    #include <nwrnames.h>
    #include <shellapi.h>

}

#include <nwc.hxx>

#define SERVER_RESHARE_VALUENAME     SZ("EnableSharedNetDrives")
#define SERVER_OTHERDEPS_VALUENAME   SZ("OtherDependencies")
#define SERVER_PARAMETERS_KEY        SZ("System\\CurrentControlSet\\Services\\LanManServer\\Parameters")
#define SERVER_LINKAGE_KEY           SZ("System\\CurrentControlSet\\Services\\LanManServer\\Linkage")


/*******************************************************************

    NAME:       NWC_GATEWAY_DIALOG::NWC_GATEWAY_DIALOG

    SYNOPSIS:   Constructor for the dialog.

    ENTRY:      hwndOwner - Hwnd of the owner window

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        ChuckC          17-Jul-1993     Created

********************************************************************/

NWC_GATEWAY_DIALOG::NWC_GATEWAY_DIALOG( HWND hwndOwner)
   : DIALOG_WINDOW( MAKEINTRESOURCE( IDD_NWC_GW_DLG), hwndOwner ),
   _lbShares(this, GW_LB_SHARES),
   _chkboxEnable(this, GW_CHKBOX_ENABLE),
   _sleAccount(this, GW_SLE_ACCOUNT, NW_MAX_USERNAME_LEN),
   _slePassword(this, GW_SLE_PASSWD, NW_MAX_PASSWORD_LEN),
   _sleConfirmPassword(this, GW_SLE_CONFIRM_PASSWD, NW_MAX_PASSWORD_LEN),
   _pbAdd(this,GW_PB_ADD), 
   _pbDelete(this,GW_PB_DELETE), 
   _pbPermissions(this,GW_PB_PERM),
   _nlsDeleted(IDS_DELETED)

{
    APIERR       err ;
    BOOL         fReshare ;
    TCHAR Account[UNLEN+1] ;
    TCHAR Password[PWLEN+1] ;

    if ( QueryError() != NERR_Success )
        return;

    //
    // make sure we constructed OK
    //
    if ((err = _nlsDeleted.QueryError()) ||
        (err = _nlsSavedAccount.QueryError()) ||
        (err = _nlsSavedPassword.QueryError()) ||
        (err = _nlsConfirmPassword.QueryError()))
    {
        return ;
    }

    _slePassword.SetMaxLength(NW_MAX_PASSWORD_LEN) ;
    _sleConfirmPassword.SetMaxLength(NW_MAX_PASSWORD_LEN) ;

    //
    // not a loop. error break out
    //
    do 
    {
        DWORD AccountLen, AccountCharsNeeded, 
              PasswordLen, PasswordCharsNeeded ;
        TCHAR *pszInitPasswordDisplay = SZ("              ") ;

        AccountLen = sizeof(Account)/sizeof(Account[0]) ;
        PasswordLen = sizeof(Password)/sizeof(Password[0]) ;
        

        //
        // read the gateway account
        //
        err = NwQueryGatewayAccount(Account,
                                    AccountLen,
                                    &AccountCharsNeeded,
                                    Password,
                                    PasswordLen,
                                    &PasswordCharsNeeded) ;
        if (err)
        {
            ReportError(err) ;
            break ;
        }

        //
        // fill in the SLEs and the listbox
        //

        _sleAccount.SetText(Account) ;
        if (PasswordCharsNeeded > 0)       // read a passwd, even if empty
        {
            _slePassword.SetText(pszInitPasswordDisplay) ;
            _sleConfirmPassword.SetText(pszInitPasswordDisplay) ;
        }
        _fPasswordChanged = FALSE ;
        
        if (err = _lbShares.Fill())
        {
            ReportError(err) ;
            break ;
        }

        if (_lbShares.QueryCount() > 0)
            _lbShares.SelectItem(0) ;

        //
        // read the server paramaters
        //

        if ((err = ReadGatewayParameters(&fReshare))  ||
            (err = EnableControls(fReshare)) ||
            (err = EnableButtons()))
        {
            ReportError(err) ;
            break ;
        }

        if ( (err = _nlsSavedAccount.CopyFrom(Account)) ||
             (err = _nlsSavedPassword.CopyFrom(Password)))
        {
            ReportError(err) ;
            break ;
        }

        _fEnabledInitially = fReshare ;

    } while (FALSE) ;

    //
    // clear the passwd
    //

    memsetf((LPBYTE)Password, 0, sizeof(Password)) ;
}


/*******************************************************************

    NAME:       NWC_GATEWAY_DIALOG::~NWC_GATEWAY_DIALOG

    SYNOPSIS:   Destructor

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        ChuckC          17-Jul-1993     Created

********************************************************************/

NWC_GATEWAY_DIALOG::~NWC_GATEWAY_DIALOG()
{
    //
    // zero out passwords
    //

    TCHAR *psz ;

    if (psz = (TCHAR *)_nlsSavedPassword.QueryPch()) 
        memsetf((LPBYTE)psz, 0, _nlsSavedPassword.QueryTextSize()) ;
}


/*******************************************************************

    NAME:       NWC_GATEWAY_DIALOG::OnCommand

    SYNOPSIS:   Process all commands for Add, Delete and
                Permissions buttons.

    ENTRY:      event - The event that occurred

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        ChuckC          17-Jul-1993     Created

********************************************************************/

BOOL NWC_GATEWAY_DIALOG::OnCommand( const CONTROL_EVENT &event )
{
    APIERR err = NERR_Success;

    switch ( event.QueryCid() )
    {
        case GW_PB_ADD:
            if ((err = OnShareAdd()) ||
                (err = _lbShares.Refresh()) ||
                (err = EnableButtons()))
            {
                ::MsgPopup( this, err ) ;
            }
            break ;
        
        case GW_PB_DELETE:
            OnShareDel() ;
            break;

        case GW_PB_PERM:
            OnSharePerm() ;
            break ;

        case GW_CHKBOX_ENABLE:
        {
            BOOL   CheckState  = _chkboxEnable.QueryCheck() ;
            APIERR err = EnableControls(CheckState) ;

            if (err)
            {
                ::MsgPopup(this,err) ; 
                break ;
            }

            (void) EnableButtons() ;
            
            break ;
        }

        case GW_LB_SHARES:
        {
            //
            //  The LISTBOX is trying to tell us something...
            //
    
            if( event.QueryCode() == LBN_SELCHANGE )
            {
                //
                //  The user changed the selection 
                //
    
                UINT i = _lbShares.QueryCurrentItem() ;
                SHARES_LBI *plbi = _lbShares.QueryItem(i) ;
                
                if (!plbi)
                    return FALSE ;

                _pbPermissions.Enable(
                    _nlsDeleted.strcmp(plbi->QueryShareName()) != 0) ;

                return TRUE;
            }

            return FALSE ;
        }

        case GW_SLE_CONFIRM_PASSWD:
        case GW_SLE_PASSWD:
        
        if ( event.QueryCode() == EN_CHANGE )
            {
                _fPasswordChanged = TRUE ;
            }
            return DIALOG_WINDOW::OnCommand( event );

        default:
            return DIALOG_WINDOW::OnCommand( event );
    }

    return TRUE;
}


/*******************************************************************

    NAME:       NWC_GATEWAY_DIALOG::OnOK

    SYNOPSIS:   Process OnOK when OK button is hit.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        ChuckC          17-Jul-1993     Created

********************************************************************/

BOOL NWC_GATEWAY_DIALOG::OnOK( )
{

    NLS_STR nlsAccount ;
    NLS_STR nlsPassword ;
    NLS_STR nlsConfirmPassword ;
    APIERR err ;
    BOOL   CheckState ;

    //
    // not a loop. error break out loop
    //
    do 
    {
        if ((err = _slePassword.QueryText(&nlsPassword))  ||
            (err = _sleAccount.QueryText(&nlsAccount)) ||
            (err = _sleConfirmPassword.QueryText(&nlsConfirmPassword)))
        {
            ::MsgPopup(this, err) ;
            break ;
        }

        if (nlsPassword._stricmp(nlsConfirmPassword))
        {
            ::MsgPopup(this, (err = IDS_PASSWORDS_NO_MATCH)) ;
            break ;
        }

        if (!_fPasswordChanged)
        {
            // 
            //  passwords untouched. use the original.
            //  the SLE will just be a bunch of spaces
            // 
            if (err = nlsPassword.CopyFrom(_nlsSavedPassword))
            {
                ::MsgPopup(this, err) ;
                break ;
            }
        }

        CheckState = _chkboxEnable.QueryCheck() ;

        if (!CheckState && _fEnabledInitially)
        {
            if (MsgPopup(this, 
                         IDS_CONFIRM_DISABLE,
                         MPSEV_WARNING,
                         MP_YESNO) != IDYES)
            {
                return TRUE ;
            }

            UINT i = _lbShares.QueryCount() ; 

            while (i--) 
            {
                SHARES_LBI *plbi = _lbShares.QueryItem(i) ;

                if (!plbi)
                {
                    ::MsgPopup(this,ERROR_NOT_ENOUGH_MEMORY) ;
                    break ;
                }

                do // error breakout 
                {
                    DWORD dwDeleteFlags = NW_GW_UPDATE_REGISTRY ;
            
                    if (_nlsDeleted.strcmp(plbi->QueryShareName()) != 0)
                    {
                        SHARE_1 share(plbi->QueryShareName()) ;
                        if ((err = share.QueryError()) || 
                            (err = share.GetInfo()) ||
                            (err = share.Delete()))
                        {
                            ::MsgPopup(this,err) ; 
                            break ;
                        }
                    }
                    else 
                    {
                        //
                        // Else this is a *Deleted* share. Set flag to cleanup.
                        //

                        dwDeleteFlags |= NW_GW_CLEANUP_DELETED ;
                    }
             
            
                    (void) NwClearGatewayShare((LPWSTR)plbi->QueryShareName()) ;
                            
                    if (err = NwDeleteGWDevice((LPWSTR)plbi->QueryDrive(),
                                                dwDeleteFlags))
                    {
                        ::MsgPopup(this,err) ; 
                        break ;
                    }

                } while(0) ;
            }
        }

        if (err = WriteGatewayParameters(CheckState))
        {
            ::MsgPopup(this, err) ;
            break ;
        }
    
        if (err = WriteServiceDependencies(CheckState))
        {
            ::MsgPopup(this, err) ;
            break ;
        }
    
        if (err = NwSetGatewayAccount((LPWSTR)nlsAccount.QueryPch(),
                                      (LPWSTR)nlsPassword.QueryPch()))
        {
            ::MsgPopup(this, err) ;
            break ;
        }
    
        if (!CheckState)
        {
            break ; 
        }

        if ( nlsAccount._stricmp(_nlsSavedAccount) ||
             nlsPassword._stricmp(_nlsSavedPassword))
        {
            //
            // credentials have changed. log the new credentials on. 
            //
            err =  NwLogonGatewayAccount((LPWSTR)nlsAccount.QueryPch(),
                                         (LPWSTR)nlsPassword.QueryPch(),
                                         NULL) ;
    
            if (err)
            {
                ::MsgPopup(this, err) ;
                break ;
            }
        }

    } while (FALSE) ;

    if (!err)
        Dismiss() ;

    //
    // zero out passwords
    //

    TCHAR *psz ;

    if (psz = (TCHAR *)nlsPassword.QueryPch()) 
        memsetf((LPBYTE)psz, 0, nlsPassword.QueryTextSize()) ;

    if (psz = (TCHAR *)nlsConfirmPassword.QueryPch()) 
        memsetf((LPBYTE)psz, 0, nlsConfirmPassword.QueryTextSize()) ;

    return TRUE ;
}

/*******************************************************************

    NAME:       NWC_GATEWAY_DIALOG::QueryHelpContext

    SYNOPSIS:   Get the help context for this dialog

    ENTRY:

    EXIT:

    RETURNS:    ULONG - The help context for this dialog

    NOTES:

    HISTORY:
        ChuckC          17-Jul-1993     Created

********************************************************************/

ULONG NWC_GATEWAY_DIALOG::QueryHelpContext( VOID )
{
    return HC_NWC_GATEWAY;
}

/*******************************************************************

    NAME:       NWC_GATEWAY_DIALOG::OnShareAdd

    SYNOPSIS:   

    NOTES:
        This is a private member function.

    HISTORY:
        ChuckC      31-Oct-1993   Created

********************************************************************/

APIERR NWC_GATEWAY_DIALOG::OnShareAdd()
{
    APIERR err ;
    NLS_STR nlsAccount ;
    NLS_STR nlsPassword ;
    NLS_STR nlsConfirmPassword ;

    if ((err = _slePassword.QueryText(&nlsPassword))  ||
        (err = _sleAccount.QueryText(&nlsAccount)) ||
        (err = _sleConfirmPassword.QueryText(&nlsConfirmPassword)))
    {
        return(err) ;
    }

    if (nlsPassword._stricmp(nlsConfirmPassword))
    {
        return( IDS_PASSWORDS_NO_MATCH) ;
    }

    if (!_fPasswordChanged)
    {
        // 
        //  passwords untouched. use the original.
        //  the SLE will just be a bunch of spaces
        // 
        if (err = nlsPassword.CopyFrom(_nlsSavedPassword))
        {
            return(err) ;
        }
    }

    if (nlsAccount._stricmp(_nlsSavedAccount) ||
        nlsPassword._stricmp(_nlsSavedPassword))
    {
        //
        // credentials have changed. log the new credentials on. 
        //
        err =  NwLogonGatewayAccount((LPWSTR)nlsAccount.QueryPch(),
                                     (LPWSTR)nlsPassword.QueryPch(),
                                     NULL) ;

        if (!err)
        {
            if ( (err = _nlsSavedAccount.CopyFrom(nlsAccount)) ||
                 (err = _nlsSavedPassword.CopyFrom(nlsPassword)))
            {
                return(err) ;
            }
        }
    }

    NWC_ADDSHARE_DIALOG *pdlg = 
        new NWC_ADDSHARE_DIALOG(QueryHwnd(), &nlsAccount, &nlsPassword);

    if ( pdlg == NULL )
    {
        err = ERROR_NOT_ENOUGH_MEMORY ;
        return err ;
    }

    if (!(err = pdlg->QueryError()))
    {
        //
        // bring up the dialog 
        //

        err = pdlg->Process() ;
    }

    //
    // delete the dialog and zero out passwd
    //
    TCHAR *psz ;

    delete pdlg ;

    if (psz = (TCHAR *)nlsPassword.QueryPch()) 
        memsetf((LPBYTE)psz, 0, nlsPassword.QueryTextSize()) ;

    return err ;
}

/*******************************************************************

    NAME:       NWC_GATEWAY_DIALOG::OnShareDel

    SYNOPSIS:   

    NOTES:
        This is a private member function.

    HISTORY:
        ChuckC      31-Oct-1993   Created

********************************************************************/

APIERR NWC_GATEWAY_DIALOG::OnShareDel()
{
    APIERR err ; 
    INT i = _lbShares.QueryCurrentItem() ;
    SHARES_LBI *plbi = _lbShares.QueryItem(i) ;

    if (!plbi)
        return ERROR_NOT_ENOUGH_MEMORY ;

    do // error breakout 
    {
        DWORD dwDeleteFlags = NW_GW_UPDATE_REGISTRY ;

        if (_nlsDeleted.strcmp(plbi->QueryShareName()) != 0)
        {
            SHARE_1 share(plbi->QueryShareName()) ;
            if ((err = share.QueryError()) || 
                (err = share.GetInfo()) ||
                (err = share.Delete()))
            {
                ::MsgPopup(this,err) ; 
                break ;
            }
        }
        else 
        {
            //
            // Else this is a *Deleted* share. Set flag to cleanup.
            //

            dwDeleteFlags |= NW_GW_CLEANUP_DELETED ;
        }

        (void) NwClearGatewayShare((LPWSTR)plbi->QueryShareName()) ;
                
        if ((err = NwDeleteGWDevice((LPWSTR)plbi->QueryDrive(),
                                    dwDeleteFlags)) ||
            (err = _lbShares.Refresh()) ||
            (err = EnableButtons()))
        {
            ::MsgPopup(this,err) ; 
            break ;
        }

    } while(0) ;

    return NERR_Success ; 
}

/*******************************************************************

    NAME:       NWC_GATEWAY_DIALOG::OnSharePerm

    SYNOPSIS:   

    NOTES:
        This is a private member function.

    HISTORY:
        ChuckC      31-Oct-1993   Created

********************************************************************/

APIERR NWC_GATEWAY_DIALOG::OnSharePerm()
{
    ::MsgPopup(this, E_NOTIMPL) ;
#if 0 // 130185
// SHAREACL.CXX is hopelessly wrong.  The call to SedDiscretionaryAclEditor
// passes the wrong parameters.  I am just disabling this.
// JonN 7/10/00 re: bug 130185

    APIERR err ; 
    OS_SECURITY_DESCRIPTOR *pOsSecDesc = NULL;
    
    INT i = _lbShares.QueryCurrentItem() ;
    SHARES_LBI *plbi = _lbShares.QueryItem(i) ;

    if (!plbi)
        return ERROR_NOT_ENOUGH_MEMORY ;

    do // error breakout 
    {
        BOOL fModified ; 

        err = ::GetSharePerm(NULL,
                             plbi->QueryShareName(),
                             &pOsSecDesc) ;
        if (err)
        {
            ::MsgPopup(this, err) ;
            break ;
        }

        err = ::EditShareAcl(QueryHwnd(),
                             (const TCHAR *) L"",
                             plbi->QueryShareName(),
                             &fModified, 
                             &pOsSecDesc,
                             0) ;   // not used
     
        if (err)
        {
            ::MsgPopup(this, err) ;
            break ;
        }
                           
        if (fModified)
        {
            err = ::SetSharePerm(NULL,
                                 plbi->QueryShareName(),
                                 pOsSecDesc) ;
        }

        if (err)
        {
            ::MsgPopup(this, err) ;
            break ;
        }
                           
    } while (0) ;
#endif

    return NERR_Success ; 
}

/*******************************************************************

    NAME:       NWC_GATEWAY_DIALOG::ReadGatewayParameters

    SYNOPSIS:   

    NOTES:
        This is a private member function.

    HISTORY:
        ChuckC      31-Oct-1993   Created

********************************************************************/

APIERR NWC_GATEWAY_DIALOG::ReadGatewayParameters(BOOL *pfReshare)
{
    APIERR err ;
    HKEY   hKeyServer, hKeyNwc ;
    DWORD  dwShareDrive, dwGatewayEnabled ;
    DWORD  cb ;
    DWORD  dwType;

    *pfReshare = FALSE ;

    //
    // Read EnableShareNetDrives (server paramater) from the registry.
    //

    if (err = RegOpenKeyEx (HKEY_LOCAL_MACHINE,  
                            SERVER_PARAMETERS_KEY,  
                            NULL,  
                            KEY_READ,  
                            &hKeyServer))
    {
        return err ;
    }

    cb = sizeof(dwShareDrive);
    if (err = RegQueryValueEx (hKeyServer,
                               SERVER_RESHARE_VALUENAME,
                               NULL,
                               &dwType,
                               (LPBYTE) &dwShareDrive,
                               &cb))
    {
        //
        // if cannot read, assume it is not there. return with fReshare
        // still false
        //
        err = NO_ERROR ;
        RegCloseKey(hKeyServer) ;
        return err ; 
    }

    
    //
    // Read GatewayEnabled (NWC parameter) from the registry.
    //

    if (err = RegOpenKeyEx (HKEY_LOCAL_MACHINE,  
                            (LPWSTR) NW_WORKSTATION_REGKEY,  
                            NULL,  
                            KEY_READ,  
                            &hKeyNwc))
    {
        RegCloseKey(hKeyServer) ;
        return err ; 
    }

    cb = sizeof(dwGatewayEnabled);
    if (err = RegQueryValueEx (hKeyNwc,
                               (LPWSTR) NW_GATEWAY_ENABLE,
                               NULL,
                               &dwType,
                               (LPBYTE) &dwGatewayEnabled,
                               &cb))
    {
        //
        // if cannot read, assume it is not there. return with fReshare
        // still false
        //
        err = NO_ERROR ;
        RegCloseKey(hKeyServer) ;
        RegCloseKey(hKeyNwc) ;
        return err ; 
    }


    //
    // require both to be set
    //
    *pfReshare = ( (dwShareDrive != 0) && (dwGatewayEnabled != 0) ) ;

    RegCloseKey(hKeyServer) ;
    RegCloseKey(hKeyNwc) ;
    return NO_ERROR ; 
}

/*******************************************************************

    NAME:       NWC_GATEWAY_DIALOG::WriteGatewayParameters

    SYNOPSIS:   
        Writes the relevant server parameters to the registry.

    NOTES:
        This is a private member function.

    HISTORY:
        ChuckC      31-Oct-1993   Created

********************************************************************/

APIERR NWC_GATEWAY_DIALOG::WriteGatewayParameters(BOOL fReshare)
{
    APIERR err ;
    HKEY   hKey ;
    DWORD  dwShareDrive = fReshare ? 1 : 0 ;
    DWORD  dwGatewayEnabled = dwShareDrive ;

    //
    // Set the value in the registry for NWC.
    //
    if (err = RegOpenKeyEx (HKEY_LOCAL_MACHINE,  
                            (LPWSTR) NW_WORKSTATION_REGKEY,  
                            NULL,  
                            KEY_WRITE,  
                            &hKey))
    {
        return err ;
    }

    err = RegSetValueEx (hKey,
                         (LPWSTR) NW_GATEWAY_ENABLE,
                         (DWORD) NULL,
                         REG_DWORD,
                         (CONST BYTE *) &dwGatewayEnabled,
                         sizeof (dwGatewayEnabled)) ;

    (void) RegCloseKey(hKey) ;

    //
    // if hit error or if disabling we dont go on to write to the server parms.
    // someone else could be using the gateway feature.
    //
    if (err != NO_ERROR || dwShareDrive == 0)
        return err ;

    //
    // Set the value in the registry for the server paramaters.
    //
    if (err = RegOpenKeyEx (HKEY_LOCAL_MACHINE,  
                            SERVER_PARAMETERS_KEY,  
                            NULL,  
                            KEY_WRITE,  
                            &hKey))
    {
        return err ;
    }

    err = RegSetValueEx (hKey,
                         SERVER_RESHARE_VALUENAME,
                         (DWORD) NULL,
                         REG_DWORD,
                         (CONST BYTE *) &dwShareDrive,
                         sizeof (dwShareDrive)) ;

    (void) RegCloseKey(hKey) ;

    return err ;
}


/*******************************************************************

    NAME:       NWC_GATEWAY_DIALOG::WriteServiceDependencies

    SYNOPSIS:   
        If gateway is enabled, make server depend on us. if disable,
        remove the dependency.

    NOTES:
        This is a private member function.

    HISTORY:
        ChuckC      31-Oct-1993   Created

********************************************************************/

APIERR NWC_GATEWAY_DIALOG::WriteServiceDependencies(BOOL fReshare)
{
    SC_HANDLE SCMHandle = NULL ;
    SC_HANDLE SVCHandle = NULL ;
    BUFFER    Buffer(4000) ;
    BUFFER    OtherDepsBuffer(4000) ;
    DWORD     dwBytesNeeded, dwType ;
    APIERR    err = NERR_Success ;
    NLS_STR   nlsServerLinkage(SERVER_LINKAGE_KEY) ;
    HKEY      hKeyServer = NULL ;
    LPTSTR    lpDependencies = NULL ;
    BUFFER    NewString = NULL ;
    

    if ((err = Buffer.QueryError()) || 
        (err = OtherDepsBuffer.QueryError()) || 
        (err = nlsServerLinkage.QueryError()))
    {
        return err ; 
    }

    //
    // Read Server Linkage from the registry.
    //

    if (err = RegOpenKeyEx (HKEY_LOCAL_MACHINE,  
                            nlsServerLinkage.QueryPch(),  
                            NULL,  
                            KEY_READ | KEY_WRITE,  
                            &hKeyServer))
    {
        return err ;
    }

    DWORD cb = OtherDepsBuffer.QuerySize() ;
    memsetf(OtherDepsBuffer.QueryPtr(), 0, cb) ;

    if (err = RegQueryValueEx (hKeyServer,
                               SERVER_OTHERDEPS_VALUENAME,
                               NULL,
                               &dwType,
                               (LPBYTE) OtherDepsBuffer.QueryPtr(),
                               &cb))
    {
        //
        // if not present. OK, we will write new value out. make sure it is 
        // all zero-ed out.
        //
        if (err == ERROR_FILE_NOT_FOUND)
        {
            err = NO_ERROR ;
            memsetf(OtherDepsBuffer.QueryPtr(), 
                    0,
                    OtherDepsBuffer.QuerySize()) ;
        }
        else 
        {
            goto ErrorExit ; 
        }
    }
    
    //
    // Now we have the registry key, lets go open service control manager.
    // We dont want to make any changes to anything until we have open both 
    // successfully with correct access, etc.
    //

    if (!(SCMHandle = OpenSCManager(NULL,
                                    NULL,
                                    GENERIC_READ)))
    {
        err = GetLastError() ;
        goto ErrorExit ;
    }

    //
    // open service
    //
    if (!(SVCHandle = OpenService(SCMHandle,
                                  (WCHAR*)SERVICE_SERVER,
                                  GENERIC_WRITE|GENERIC_READ)))
    {
        err = GetLastError() ;
        goto ErrorExit ;
    }

    //
    // enumerate dependent services
    //
    if (!QueryServiceConfig(SVCHandle,
                            (LPQUERY_SERVICE_CONFIG)Buffer.QueryPtr(),
                            Buffer.QuerySize(),
                            &dwBytesNeeded))
    {
        err = GetLastError() ;

        if (err == ERROR_INSUFFICIENT_BUFFER)
        {
            if ((err = Buffer.Resize((UINT)dwBytesNeeded)) == NERR_Success)
            {
                if (!QueryServiceConfig(SVCHandle,
                                    (LPQUERY_SERVICE_CONFIG)Buffer.QueryPtr(),
                                    Buffer.QuerySize(),
                                    &dwBytesNeeded))
                {
                    err = GetLastError() ;
                }
            }
        }
    }

    if (err != NERR_Success)
    { 
        goto ErrorExit ;
    }
    
    //
    // ok, now we go munge the data. we setup the Service Controller first
    // and then whack the Registry.
    //

    lpDependencies = 
        (((LPQUERY_SERVICE_CONFIG)Buffer.QueryPtr())->lpDependencies) ;

    //
    // munge the dependencies string
    //
    err = ModifyDependencyList(&lpDependencies, fReshare, &NewString) ;
        
    //
    // now set it
    //
    if (!err && !ChangeServiceConfig(SVCHandle,
                              SERVICE_NO_CHANGE,
                              SERVICE_NO_CHANGE,
                              SERVICE_NO_CHANGE,
                              NULL,
                              NULL,
                              NULL,
                              lpDependencies,
                              NULL,
                              NULL,
                              NULL))
    {
        err = GetLastError() ;
    }

    if (err != NERR_Success)
    { 
        goto ErrorExit ;
    }

    //
    // successfully change service controller. now whack registry
    // so that if NCPA rebinds, we dont lose the info.
    //

    lpDependencies = (TCHAR *) OtherDepsBuffer.QueryPtr(),

    //
    // munge the dependencies string
    //
    err = ModifyDependencyList(&lpDependencies, fReshare, &NewString) ;

    if (err != NERR_Success)
        goto ErrorExit ;
        
    //
    // now set it
    //

    err = RegSetValueEx (hKeyServer,
                         (LPWSTR) SERVER_OTHERDEPS_VALUENAME,
                         (DWORD) NULL,
                         REG_MULTI_SZ,
                         (CONST BYTE *) lpDependencies,
                         CalcNullNullSize(lpDependencies) * sizeof(TCHAR)) ;
                         
ErrorExit:

    if (SCMHandle)
        (void) CloseServiceHandle(SCMHandle) ;
    if (SVCHandle)
        (void) CloseServiceHandle(SVCHandle) ;
    if (hKeyServer)
        (void) RegCloseKey(hKeyServer) ;

    return err ;
}


/*******************************************************************

    NAME:       NWC_GATEWAY_DIALOG::ModifyDependencyList

    SYNOPSIS:   
        Munge the REG_MULTI_SZ list to add or remove the 
        NWCWorkstation entry. Add if fReshare is TRUE, remove
        otherwise.

    NOTES:
        This is a private member function.

    HISTORY:
        ChuckC      31-Oct-1993   Created

********************************************************************/
APIERR NWC_GATEWAY_DIALOG::ModifyDependencyList(TCHAR **lplpDependencies,
                                                BOOL    fReshare, 
                                                BUFFER *pBuffer) 
{
    UINT      ulOldCharCount = 0 ;
    UINT      ulNwcCharCount = 0 ;
    TCHAR    *pszNwc = NULL ;
    APIERR    err = NERR_Success ;
    
    //
    // see if NWCWorkstation is already in list.
    //
    pszNwc = FindStringInNullNull(*lplpDependencies,
                                  (WCHAR *)NW_WORKSTATION_SERVICE) ;
    ulOldCharCount = (UINT) CalcNullNullSize(*lplpDependencies) ;
    ulNwcCharCount = strlenf((WCHAR *)NW_WORKSTATION_SERVICE)+1 ;

    if (fReshare)
    {
        //
        // need add the dependency
        //
        if (pszNwc)
        {
            //
            // its already there. nothing more to do.
            //
        }
        else
        {
            //
            // we need add it.
            //

            pBuffer->Resize( (ulOldCharCount + ulNwcCharCount) *
                             sizeof(TCHAR) ) ;
            
            if (!(err = pBuffer->QueryError()))
            {
                memcpyf(pBuffer->QueryPtr(), 
                        (LPBYTE)*lplpDependencies,
                        ulOldCharCount * sizeof(TCHAR)) ;

                TCHAR *pszTmp = (TCHAR *)pBuffer->QueryPtr() ;
                pszTmp += (ulOldCharCount - 1) ;
                strcpyf(pszTmp, (WCHAR *)NW_WORKSTATION_SERVICE) ;
                pszTmp += (ulNwcCharCount) ;
                *pszTmp = 0 ;
                *lplpDependencies = (TCHAR *) pBuffer->QueryPtr() ;
            }
        }
    }
    else
    {
        //
        // need remove the dependency
        //
        if (pszNwc)
        {
            //
            // its there. we need remove it. we do so by shifting mem up.
            //
            TCHAR *pszEnd = *lplpDependencies + ulOldCharCount ;
            TCHAR *pszTmp = pszNwc + ulNwcCharCount ;

            UINT ulBytesToMove = (UINT) ((LPBYTE)pszEnd - (LPBYTE)pszTmp) ; 
    
            memmovef((LPBYTE)pszNwc, 
                     (LPBYTE)pszTmp,
                     ulBytesToMove) ;
        }
        else
        {
            //
            // its not there. nothing more to do.
            //
        }
    }

    return err ;
}


/*******************************************************************

    NAME:       NWC_GATEWAY_DIALOG::CalcNullNullSize

    SYNOPSIS:   
        Calculate the number of chars used by a NULL NULL string,
        including the NULL NULL at the end.

    NOTES:
        This is a private member function.

    HISTORY:
        ChuckC      31-Oct-1993   Created

********************************************************************/
DWORD NWC_GATEWAY_DIALOG::CalcNullNullSize(TCHAR *pszNullNull) 
{

    if (!pszNullNull)
        return 0 ;

    DWORD dwSize = 0 ;
    TCHAR *pszTmp = pszNullNull ;

    while (*pszTmp) 
    {
        DWORD dwLen = ::strlenf(pszTmp) + 1 ;

        dwSize +=  dwLen ;
        pszTmp += dwLen ;
    }

    return (dwSize+1) ;
}

/*******************************************************************

    NAME:       NWC_GATEWAY_DIALOG::FindStringInNullNull

    SYNOPSIS:   
        Walk thru a NULL NULL string, looking for the search string

    NOTES:
        This is a private member function.

    HISTORY:
        ChuckC      31-Oct-1993   Created

********************************************************************/
TCHAR * NWC_GATEWAY_DIALOG::FindStringInNullNull(TCHAR *pszNullNull,
                                                 TCHAR *pszString)
{
    if (!pszNullNull || !*pszNullNull)
        return NULL ;
   
    TCHAR *pszTmp = pszNullNull ;

    do {

        if  (stricmpf(pszTmp,pszString)==0)
            return pszTmp ;
 
        pszTmp +=  ::strlenf(pszTmp) + 1 ;

    } while (*pszTmp) ;

    return NULL ;
}

/*******************************************************************

    NAME:       NWC_GATEWAY_DIALOG::EnableControls

    SYNOPSIS:   

    NOTES:
        This is a private member function.

    HISTORY:
        ChuckC      31-Oct-1993   Created

********************************************************************/

APIERR NWC_GATEWAY_DIALOG::EnableControls(BOOL fReshare)
{
    _chkboxEnable.SetCheck(fReshare) ;

    _lbShares.Enable(fReshare) ;
    _sleAccount.Enable(fReshare) ;
    _slePassword.Enable(fReshare) ;
    _sleConfirmPassword.Enable(fReshare) ;
    _pbAdd.Enable(fReshare) ;
    _pbDelete.Enable(fReshare) ;
    _pbPermissions.Enable(fReshare) ;

    
    if (fReshare && _lbShares.QueryCount() > 0)
        _lbShares.SelectItem(0) ;
    
    return NERR_Success ;
}

/*******************************************************************

    NAME:       NWC_GATEWAY_DIALOG::EnableButtons

    SYNOPSIS:   

    NOTES:
        This is a private member function.

    HISTORY:
        ChuckC      31-Oct-1993   Created

********************************************************************/

APIERR NWC_GATEWAY_DIALOG::EnableButtons(void)
{
    // 
    // enable the perm and delete buttons only if there are entries
    // 
    INT count = _lbShares.IsEnabled() ? _lbShares.QueryCount() : 0 ;

    _pbDelete.Enable(count > 0) ;
    _pbPermissions.Enable(count > 0) ;

    // 
    // if count is zero, nothing more to do
    // 
    if (count == 0)
        return NERR_Success ;  

    // 
    // else, disable the perm button if current selection is a deleted share
    // 
    UINT i = _lbShares.QueryCurrentItem() ;
    SHARES_LBI *plbi = _lbShares.QueryItem(i) ;
                
    if (!plbi)
        return NERR_Success ;  // ignore this (should not happen)

    _pbPermissions.Enable(_nlsDeleted.strcmp(plbi->QueryShareName()) != 0) ;

    return NERR_Success ;
}

/*******************************************************************

    NAME:       SHARES_LBOX::SHARES_LBOX

    SYNOPSIS:   SHARES_LBOX class constructor.

    ENTRY:      powOwner                - The "owning" window.

                cid                     - The listbox CID.

    EXIT:       The object is constructed.

    RETURNS:    No return value.

    NOTES:

    HISTORY:
        KeithMo     01-Aug-1991 Created for the Server Manager.
        ChuckC      09-Oct-1991 Stole and moved to APPLIB.

********************************************************************/

SHARES_LBOX::SHARES_LBOX( OWNER_WINDOW * powOwner,
                        CID            cid) 
  : BLT_LISTBOX( powOwner, cid )
{
    //
    //  Ensure we constructed properly.
    //
    if( QueryError() != NERR_Success)
        return;

    //
    //  calculate the column widths
    //
    DISPLAY_TABLE::CalcColumnWidths(_adx,
                                    4, 
                                    powOwner,
                                    cid,
                                    FALSE) ;
}


/*******************************************************************

    NAME:       SHARES_LBOX::~SHARES_LBOX

    SYNOPSIS:   SHARES_LBOX class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
        KeithMo     20-Aug-1991 Created.
        ChuckC      09-Oct-1991 Stole and moved to APPLIB.

********************************************************************/

SHARES_LBOX::~SHARES_LBOX()
{
    ;  // nothing more to do
}


/*******************************************************************

    NAME:       SHARES_LBOX::Fill

    SYNOPSIS:   Fill the list of open files.

    EXIT:       The listbox is filled.

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
        KeithMo     01-Aug-1991 Created for the Server Manager.
        ChuckC      09-Oct-1991 Stole and moved to APPLIB.

********************************************************************/

APIERR SHARES_LBOX::Fill()
{
    AUTO_CURSOR Cursor;
    APIERR err = NERR_Success ;
    ULONG  i, Index, BytesNeeded, EntriesRead ;
    BUFFER Buffer(16000) ;
    LPNETRESOURCE lpNetResource ;
    SHARE2_ENUM sh2Enum(NULL) ;
    RESOURCE_STR nlsDeleted(IDS_DELETED) ;

    if ((err = Buffer.QueryError()) ||
        (err = nlsDeleted.QueryError()) ||
        (err = sh2Enum.QueryError()) ||
        ((err = sh2Enum.GetInfo()) && err != NERR_ServerNotStarted))
    {
        return  err ;
    }

    //
    //  let's nuke everything in the listbox.
    //
    SetRedraw( FALSE );
    DeleteAllItems();

    if (err == NERR_ServerNotStarted)
    {
        SetRedraw( TRUE );
        Invalidate( TRUE );
        return(NERR_Success) ;
    }

    //
    // enumerate all the gateway devices
    //
    Index = 0 ;
    err = NwEnumGWDevices(&Index,
                          Buffer.QueryPtr(),
                          Buffer.QuerySize(),
                          &BytesNeeded,
                          &EntriesRead) ;

    if (err == ERROR_NO_MORE_ITEMS)
    {
        err = NERR_Success ; 
    }

    if (err != NERR_Success)
        return err ;

    lpNetResource = (LPNETRESOURCE) Buffer.QueryPtr() ;
    for (i = 0; i < EntriesRead; i++)
    {
        
        lpNetResource->lpComment = NULL ;
        lpNetResource++ ;
    }

    //
    // Iterate the shares adding them to the listbox.
    //

    SHARE2_ENUM_ITER sh2EnumIter (sh2Enum) ;
    const SHARE2_ENUM_OBJ *pshi2 ;
    while ( (pshi2 = sh2EnumIter()) != NULL) 
    {
        UINT len  = ::strlenf(pshi2->QueryName()) ;
        if ( (*( pshi2->QueryName() + (len - 1) ) == TCH('$')) &&
             len == 2)
        {
            continue ;
        }
    
        lpNetResource = (LPNETRESOURCE) Buffer.QueryPtr() ;
        for (i = 0; i < EntriesRead; i++)
        {
            if ((strnicmpf(lpNetResource->lpLocalName, 
                          pshi2->QueryPath(),2) == 0)
                 && strlenf(pshi2->QueryPath()) == 3)
            {
                SHARES_LBI *polbi = new SHARES_LBI(pshi2->QueryName(),
                                                   lpNetResource->lpRemoteName,
                                                   lpNetResource->lpLocalName,
                                                   pshi2->QueryMaxUses()) ;

                if ( (polbi == NULL) || (AddItem( polbi ) < 0) )
                {
                    err = ERROR_NOT_ENOUGH_MEMORY;
                    break ;
                }

                lpNetResource->lpComment = (TCHAR *) 1 ;   // mark as used 
            }

            lpNetResource++ ;
        }
    }
    
    //
    //  add the 'deleted' entries so the user knows they are sort of there
    //

    lpNetResource = (LPNETRESOURCE) Buffer.QueryPtr() ;
    for (i = 0; i < EntriesRead; i++)
    {
        //
        // look for unused ones
        //
        if (lpNetResource->lpComment == NULL) 
        {
            SHARES_LBI * polbi = new SHARES_LBI(nlsDeleted.QueryPch(),
                                                lpNetResource->lpRemoteName,
                                                lpNetResource->lpLocalName,
                                                0) ;

            if ( (polbi == NULL) || (AddItem( polbi ) < 0) )
            {
                err = ERROR_NOT_ENOUGH_MEMORY;
                break ;
            }

        }

        lpNetResource++ ;
    }

    SetRedraw( TRUE );
    Invalidate( TRUE );

    return err;
}


/*******************************************************************

    NAME:       SHARES_LBOX::Refresh

    SYNOPSIS:   Refreshes the list of open resources.

    EXIT:       The listbox is refreshed & redrawn.

    RETURNS:    APIERR                  - Any errors encountered.

    NOTES:      This method is now obsolete.  It will be replaced
                as soon as KevinL's WFC refreshing listbox code is
                available.

    HISTORY:
        KeithMo     01-Aug-1991 Created for the Server Manager.
        ChuckC      09-Oct-1991 Stole and moved to APPLIB.

********************************************************************/

APIERR SHARES_LBOX::Refresh()
{
    INT iCurrent = QueryCurrentItem();
    INT iTop     = QueryTopIndex();

    APIERR err = Fill();

    if( err != NERR_Success )
    {
        return err;
    }

    INT cItems = QueryCount();

    if( cItems > 0 )
    {
        SetTopIndex( ( ( iTop < 0 ) || ( iTop >= cItems ) ) ? 0
                                                            : iTop );

        if( iCurrent < 0 )
        {
            iCurrent = 0;
        }
        else if( iCurrent >= cItems )
        {
            iCurrent = cItems - 1;
        }

        SelectItem( iCurrent );
    }

    return NERR_Success;
}


/*******************************************************************

    NAME:       SHARES_LBI::SHARES_LBI

    SYNOPSIS:   SHARES_LBI class constructor.

    ENTRY:      pszUserName             - The user for this entry.

                uPermissions            - Open permissions.

                cLocks                  - Number of locks.

    EXIT:       The object is constructed.

    HISTORY:
        KeithMo     31-May-1991 Created for the Server Manager.
        KeithMo     19-Aug-1991 Use DMID_DTE passed into constructor.
        ChuckC      09-Oct-1991 Stole and moved to APPLIB.
        beng        22-Nov-1991 Ctors for empty strings
        beng        05-Mar-1992 use DEC_STR

********************************************************************/

SHARES_LBI::SHARES_LBI( const TCHAR *pszShareName,
                        const TCHAR *pszPathName,
                        const TCHAR *pszDrive,
                        const ULONG  ulUserLimit)
  : _nlsShareName( pszShareName ),
    _nlsPathName( pszPathName ),
    _nlsDrive( pszDrive ),
    _nlsUserLimit(IDS_UNLIMITED)
{
    TCHAR buffer[16] ;

    if( QueryError() != NERR_Success )
        return;

    APIERR err;
    if( ( ( err = _nlsShareName.QueryError() ) != NERR_Success ) ||
        ( ( err = _nlsPathName.QueryError() )   != NERR_Success ) ||
        ( ( err = _nlsUserLimit.QueryError() )   != NERR_Success ) ||
        ( ( err = _nlsDrive.QueryError() )   != NERR_Success ) )
    {
        ReportError( err );
        return;
    }

    //
    // fixup the limit string to be a real number as need
    //

    if (ulUserLimit != SHI_USES_UNLIMITED)
    {
        wsprintf(buffer, SZ("%lu"), ulUserLimit) ;
        if (err = _nlsUserLimit.CopyFrom(buffer))
        {
            ReportError( err );
            return;
        }
    }
}


/*******************************************************************

    NAME:       SHARES_LBI::~SHARES_LBI

    SYNOPSIS:   SHARES_LBI class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
        KeithMo     31-May-1991 Created for the Server Manager.
        ChuckC      09-Oct-1991 Stole and moved to APPLIB.

********************************************************************/

SHARES_LBI::~SHARES_LBI()
{
    //
    //  This space intentionally left blank.
    //
}


/*******************************************************************

    NAME:       SHARES_LBI::QueryLeadingChar

    SYNOPSIS:   Return the leading character of this item.

    RETURNS:    WCHAR - The leading character.

    HISTORY:
        KeithMo     31-May-1991 Created for the Server Manager.
        ChuckC      09-Oct-1991 Stole and moved to APPLIB.

********************************************************************/

WCHAR SHARES_LBI::QueryLeadingChar() const
{
    ISTR istr( _nlsShareName );

    return _nlsShareName.QueryChar( istr );
}

/*******************************************************************

    NAME:       SHARES_LBI :: Paint

    SYNOPSIS:   Draw an entry in SHARES_LBOX.

    ENTRY:      plb                     - Pointer to a BLT_LISTBOX.

                hdc                     - The DC to draw upon.

                prect                   - Clipping rectangle.

                pGUILTT                 - GUILTT info.

    EXIT:       The item is drawn.

    HISTORY:

********************************************************************/
VOID SHARES_LBI :: Paint( LISTBOX *        plb,
                         HDC              hdc,
                         const RECT     * prect,
                         GUILTT_INFO    * pGUILTT ) const
{
    STR_DTE dteShare( QueryShareName() );
    STR_DTE dtePath( QueryPathName() );
    STR_DTE dteDrive( QueryDrive() );
    STR_DTE dteUsers( QueryUserLimit() );

    DISPLAY_TABLE dtab( 4, ((SHARES_LBOX *)plb)->QueryColumnWidths() );

    dtab[0] = &dteShare;
    dtab[1] = &dteDrive;
    dtab[2] = &dteUsers;
    dtab[3] = &dtePath;

    dtab.Paint( plb, hdc, prect, pGUILTT );

}   // SHARES_LBI :: Paint



/*******************************************************************

    NAME:       SHARES_LBI :: Compare

    SYNOPSIS:   Compare two SHARES_LBI items.

    ENTRY:      plbi                    - The "other" item.

    RETURNS:    INT                     -  0 if the items match.
                                          -1 if we're < the other item.
                                          +1 if we're > the other item.

    HISTORY:
        KeithMo     18-Jun-1991 Created for the Server Manager.

********************************************************************/
INT SHARES_LBI :: Compare( const LBI * plbi ) const
{
    return ::stricmpf( QueryShareName(),
                       ((const SHARES_LBI *)plbi)->QueryShareName() );

}   // SHARES_LBI :: Compare
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\nwc\nwc\nwc.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    nwc.cxx
       The file contains the classes for the Netware Compat Software applet

    FILE HISTORY:
        ChuckC          17-Jul-1993     created based on ftpmgr
*/


#define INCL_NET
#define INCL_NETLIB
#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETERRORS
#define INCL_DOSERRORS
#include <lmui.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif

#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_CLIENT
#define INCL_BLT_MSGPOPUP
#define INCL_BLT_EVENT
#define INCL_BLT_MISC
#define INCL_BLT_CC
#define INCL_BLT_SPIN_GROUP
#define INCL_BLT_GROUP
#include <blt.hxx>

#include <uiassert.hxx>
#include <uitrace.hxx>
#include <dbgstr.hxx>

extern "C"
{
    #include <npapi.h>
    #include <nwevent.h>
    #include <nwc.h>
    #include <nwapi.h>
    #include <shellapi.h>
    #include <nwsnames.h>
    #include <htmlhelp.h>

   extern BOOL _fIsWinnt;
}

#include <nwc.hxx>



/*******************************************************************

    NAME:       NWC_DIALOG::NWC_DIALOG

    SYNOPSIS:   Constructor. 

    ENTRY:      hwndOwner - Hwnd of the owner window

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        ChuckC          17-Jul-1993     Created

********************************************************************/

NWC_DIALOG::NWC_DIALOG( HWND hwndOwner, BOOL fIsWinnt)
   : DIALOG_WINDOW(MAKEINTRESOURCE(fIsWinnt ? IDD_NWC_WINNT_DLG:IDD_NWCDLG),
                                   hwndOwner ),
   _comboPreferredServers(this, COMBO_PREFERREDSERVERS),
   _chkboxFormFeed(this, CHKBOX_FORMFEED),
   _chkboxPrintNotify(this, CHKBOX_PRINTNOTIFY),
   _chkboxPrintBanner(this, CHKBOX_PRINTBANNER),
   _chkboxLogonScript(this, CHKBOX_LOGONSCRIPT),
   _sltUserName(this, SLT_USERNAME),
   _sltCurrentPreferredServer(this, SLT_CURRENTPREFERREDSERVER),
   _pbOverview(this,IDD_NWC_HELP), 
   _pbGateway(this,IDD_NWC_GATEWAY),
   _mgrpPreferred(this, RB_PREFERRED_SERVER, 2),
   _sleTree(this, SLE_DEFAULT_TREE),
   _sleContext(this, SLE_DEFAULT_CONTEXT) 

{
    APIERR       err ;
    LPTSTR       pszPreferred ;
    DWORD        dwPrintOptions ;
    DWORD        dwLogonScriptOptions ;
    RESOURCE_STR nlsNone(IDS_NONE) ;
    WCHAR        szUser[UNLEN+1] ;
    DWORD        dwUserBuffer = sizeof(szUser)/sizeof(szUser[0]) ;

    if ( QueryError() != NERR_Success )
        return;

    if (fIsWinnt)
    {
        _pbGateway.Enable(FALSE) ;
        _pbGateway.Show(FALSE) ;
    }

    if (!::GetUserName(szUser,&dwUserBuffer))
    {
        ReportError(::GetLastError()) ;
        return;
    }
    _sltUserName.SetText( szUser );

    if (err = nlsNone.QueryError())
    {
        ReportError(err) ;
        return;
    }

    //
    // setup the magic group associations.
    //
    if ((err = _mgrpPreferred.AddAssociation(RB_PREFERRED_SERVER, 
                                             &_comboPreferredServers)) ||
        (err = _mgrpPreferred.AddAssociation(RB_DEFAULT_CONTEXT,
                                             &_sleTree)) ||
        (err = _mgrpPreferred.AddAssociation(RB_DEFAULT_CONTEXT,
                                             &_sleContext)))
    {
        ReportError(err) ;
        return;
    }

    SC_HANDLE SCMHandle = NULL ;
    SC_HANDLE SVCHandle = NULL ;
    SERVICE_STATUS ServiceStatus ;

    //
    // open service control manager 
    //
    if (!(SCMHandle = OpenSCManager(NULL, NULL, GENERIC_READ)))
    {
        ReportError(GetLastError()) ;
        return ;
    }

    //
    // open service
    //
    if (!(SVCHandle = OpenService(SCMHandle,
                                  (WCHAR*)NW_WORKSTATION_SERVICE,
                                  GENERIC_READ)))
    {
        ReportError(GetLastError()) ;
        (void) CloseServiceHandle(SCMHandle) ;
        return ;
    }

    // 
    // check that the service is running
    // 
    if (!QueryServiceStatus(SVCHandle,
                            &ServiceStatus))
    {
        ReportError(GetLastError()) ;
        (void) CloseServiceHandle(SCMHandle) ;
        (void) CloseServiceHandle(SVCHandle) ;
        return ;
    }

    (void) CloseServiceHandle(SCMHandle) ;
    (void) CloseServiceHandle(SVCHandle) ;

    if (ServiceStatus.dwCurrentState != SERVICE_RUNNING)
    {
        ReportError(ERROR_SERVICE_NOT_ACTIVE) ;
        return ;
    }

    //
    // Preferred server name is limited to 48 characters.
    // Tree is limited to 32. We limit context to 256 - MAXTREE - 3
    //
    _comboPreferredServers.SetMaxLength( NW_MAX_SERVER_LEN );
    _sleTree.SetMaxLength( NW_MAX_TREE_LEN );
    _sleContext.SetMaxLength( 256 );

    //
    // Fill Preferred Server name with list of servers.
    // Ignore the error if we can't fill the combo.
    // The user can always type in a new server.
    //

    (VOID) FillPreferredServersCombo();

    //
    // Combo-box will contain at least the <NONE> entry in its list.
    //
    INT iLast = _comboPreferredServers.QueryCount() ;
    if ( _comboPreferredServers.InsertItem(iLast, nlsNone.QueryPch()) < 0 )
    {
        ReportError( _comboPreferredServers.QueryError() ) ;
        return ;
    }

    //
    // query NW wksta for print options & preferred server (or context)
    //
    if (err = NwQueryInfo(&dwPrintOptions, &pszPreferred))
    {
        pszPreferred = NULL ;
        dwPrintOptions = 0 ;
    }

    //
    // query NW wksta for logon script options
    //
    if (err = NwQueryLogonOptions(&dwLogonScriptOptions))
    {
        dwLogonScriptOptions = 0 ;
    }

    //
    // Store the existings settings in the class also (used in OnOK code)
    //
    _dwOldPrintOptions = dwPrintOptions;
    _dwOldLogonScriptOptions = dwLogonScriptOptions;
    _nlsOldPreferredServer = pszPreferred;
    if (err = _nlsOldPreferredServer.QueryError())
    {
        MsgPopup(this, err) ;
        return ;
    }

    //
    // select the users' preferred server (if there is one)
    //
    if (pszPreferred && *pszPreferred)
    {
        //
        // we use '*' in front to distinguish between server and nds context
        //
        if (*pszPreferred != TCH('*'))
        {
            _mgrpPreferred.SetSelection(RB_PREFERRED_SERVER) ;

            _sltCurrentPreferredServer.SetText(pszPreferred) ;
            _comboPreferredServers.SetText( pszPreferred );

            INT i = _comboPreferredServers.FindItemExact(pszPreferred) ;
            if (i >= 0)
            {
                _comboPreferredServers.SelectItem(i) ;
            }
            _comboPreferredServers.ClaimFocus();

        }
        else
        {
            _mgrpPreferred.SetSelection(RB_DEFAULT_CONTEXT) ;
            _sltCurrentPreferredServer.SetText(SZ("")) ;

            //
            // we store tree & default as follows:
            //     *TREE\CONTEXT
            //
            TCHAR *pszContext = ::wcschr(pszPreferred, TCH('\\')) ; 
            if (pszContext)
            {
                *pszContext = 0 ;
                _sleContext.SetText(pszContext+1) ;
            }
            else
                _sleContext.SetText(SZ("")) ;

            _sleTree.SetText(pszPreferred+1) ;
            _sleTree.ClaimFocus() ;
        }
    }
    else
    {
        //
        // select the last entry, <none>, since there is no preferred entry
        //
        _mgrpPreferred.SetSelection(RB_PREFERRED_SERVER) ;
        _comboPreferredServers.SelectItem(iLast) ;
        _comboPreferredServers.SetText( nlsNone.QueryPch() );
        _sltCurrentPreferredServer.SetText(nlsNone.QueryPch()) ;
    }

    if (pszPreferred)
        LocalFree((LPBYTE)pszPreferred) ;
   
    //
    // init the checkboxes
    //
    _chkboxFormFeed.SetCheck(!(dwPrintOptions & NW_PRINT_SUPPRESS_FORMFEED));
    _chkboxPrintNotify.SetCheck((BOOL)(dwPrintOptions & NW_PRINT_PRINT_NOTIFY));
    _chkboxPrintBanner.SetCheck((BOOL)(dwPrintOptions & NW_PRINT_PRINT_BANNER));

    _chkboxLogonScript.SetCheck((BOOL)
                           (dwLogonScriptOptions & NW_LOGONSCRIPT_ENABLED));
}


/*******************************************************************

    NAME:       NWC_DIALOG::~NWC_DIALOG

    SYNOPSIS:   Destructor

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        ChuckC          17-Jul-1993     Created

********************************************************************/

NWC_DIALOG::~NWC_DIALOG()
{
    // Nothing to do for now
}

/*******************************************************************

    NAME:       NWC_DIALOG::FillPreferredServerCombo

    SYNOPSIS:   Get servers list

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        ChuckC          17-Jul-1993     Created

********************************************************************/

APIERR NWC_DIALOG::FillPreferredServersCombo(void)
{
    DWORD status = ERROR_NO_NETWORK;
    HANDLE EnumHandle = (HANDLE) NULL;

    LPNETRESOURCE NetR = NULL;
    LPNETRESOURCE SavePtr;

    DWORD BytesNeeded = 4096;
    DWORD EntriesRead;
    DWORD i;

    //
    // Retrieve the list of servers on the network
    //
    status = NPOpenEnum(
                   RESOURCE_GLOBALNET,
                   0,
                   0,
                   NULL,
                   &EnumHandle
                   );

    if (status != NO_ERROR) {
        EnumHandle = (HANDLE) NULL;
        goto CleanExit;
    }

    //
    // Allocate buffer to get server list.
    //
    if ((NetR = (LPNETRESOURCE) LocalAlloc(
                             0,
                             (UINT) BytesNeeded
                             )) == NULL) {

        status = ERROR_NOT_ENOUGH_MEMORY;
        goto CleanExit;
    }

    do {

        EntriesRead = 0xFFFFFFFF;          // Read as many as possible

        status = NPEnumResource(
                     EnumHandle,
                     &EntriesRead,
                     (LPVOID) NetR,
                     &BytesNeeded
                     );

        if (status == WN_SUCCESS) {

            SavePtr = NetR;

            for (i = 0; i < EntriesRead; i++, NetR++) {

                //
                // Add NetR->lpRemoteName + 2 to the combo
                //
                if (NetR->dwDisplayType != RESOURCEDISPLAYTYPE_TREE)
                    _comboPreferredServers.AddItem(
                        (LPWSTR)NetR->lpRemoteName+2) ;

            }

            NetR = SavePtr;

        }
        else if (status != WN_NO_MORE_ENTRIES) {

            status = GetLastError();

            if (status == WN_MORE_DATA) {

                //
                // Original buffer was too small.  Free it and allocate
                // the recommended size and then some to get as many
                // entries as possible.
                //

                (void) LocalFree((HLOCAL) NetR);

                if ((NetR = (LPNETRESOURCE) LocalAlloc(
                                         0,
                                         (UINT) BytesNeeded
                                         )) == NULL) {

                    status = ERROR_NOT_ENOUGH_MEMORY;
                    goto CleanExit;
                }
            }
            else {
                goto CleanExit;
            }
        }

    } while (status != WN_NO_MORE_ENTRIES);

    if (status == WN_NO_MORE_ENTRIES) {
        status = NO_ERROR;
    }

CleanExit:

    if (EnumHandle != (HANDLE) NULL) {
        (void) NPCloseEnum(EnumHandle);
    }

    if (NetR != NULL) {
        (void) LocalFree((HLOCAL) NetR);
    }

    return status;
}

/*******************************************************************

    NAME:       NWC_DIALOG::OnCommand

    SYNOPSIS:   Process all commands for Security, Refresh,
                Disconnect, Disconnect All buttons.

    ENTRY:      event - The event that occurred

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        ChuckC          17-Jul-1993     Created

********************************************************************/

BOOL NWC_DIALOG::OnCommand( const CONTROL_EVENT &event )
{
    APIERR err = NERR_Success;
    switch ( event.QueryCid() )
    {
        case IDD_NWC_HELP:
            OnNWCHelp();
            break;
        case IDD_NWC_GATEWAY:
        {
            NWC_GATEWAY_DIALOG *pdlg = new NWC_GATEWAY_DIALOG(QueryHwnd());

            if ( pdlg == NULL )
            {
                ::MsgPopup(this, ERROR_NOT_ENOUGH_MEMORY) ;
                break ;
            }
            else if (err = pdlg->QueryError()) 
            {
                delete pdlg ;
                ::MsgPopup(this, err) ;
                break ;
            }

            //
            // bring up the dialog 
            //

            if (err = pdlg->Process()) 
            {
                ::MsgPopup(this, err) ;
            }

            delete pdlg ;
            break;
        }
        default:
            return DIALOG_WINDOW::OnCommand( event );
    }

    return TRUE;
}


/*******************************************************************

    NAME:       NWC_DIALOG::OnOK

    SYNOPSIS:   Process OnOK when OK button is hit.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        ChuckC          17-Jul-1993     Created

********************************************************************/

BOOL NWC_DIALOG::OnOK( )
{
    DWORD dwPrintOptions = 0 ;
    DWORD dwLogonScriptOptions = 0 ;
    RESOURCE_STR nlsNone(IDS_NONE) ;
    BOOL fNdsContext = FALSE ;
    AUTO_CURSOR autocur;

    dwPrintOptions |=
        _chkboxFormFeed.QueryCheck() ? 0 : NW_PRINT_SUPPRESS_FORMFEED ;
    dwPrintOptions |=
        _chkboxPrintNotify.QueryCheck() ? NW_PRINT_PRINT_NOTIFY : 0 ;
    dwPrintOptions |=
        _chkboxPrintBanner.QueryCheck() ? NW_PRINT_PRINT_BANNER : 0 ;
    dwLogonScriptOptions =
        _chkboxLogonScript.QueryCheck() ? ( NW_LOGONSCRIPT_ENABLED | NW_LOGONSCRIPT_4X_ENABLED ) : NW_LOGONSCRIPT_DISABLED ;


    NLS_STR nlsPreferred, nlsContext ;
    APIERR err ;

    if (err = nlsNone.QueryError())
    {
        MsgPopup(this, err) ;
        return TRUE ;
    }

    switch (_mgrpPreferred.QuerySelection())
    {
        default:

            UIASSERT(FALSE) ;

        case RB_PREFERRED_SERVER:

            err = _comboPreferredServers.QueryText(&nlsPreferred) ;
            fNdsContext = FALSE ;
            break ;

        case RB_DEFAULT_CONTEXT:

            err = _sleTree.QueryText(&nlsPreferred) ;
            if (err == NERR_Success)
                err = _sleContext.QueryText(&nlsContext) ;
            fNdsContext = TRUE ;
            break ;
    }

    if (err != NERR_Success)
    {
        MsgPopup(this, err) ;
        return TRUE ;
    }

    if ( nlsPreferred._stricmp( nlsNone ) == 0 )
        nlsPreferred.CopyFrom( SZ(""));

    if ( fNdsContext )
    {
        if ( _sleTree.QueryTextLength() == 0 )
        {
            MsgPopup( this, IDS_TREE_NAME_MISSING );
            _sleTree.SelectString();
            _sleTree.ClaimFocus();
            return TRUE;
        }
        
        if ( _sleContext.QueryTextLength() == 0 )
        {
            MsgPopup( this, IDS_CONTEXT_MISSING );
            _sleContext.SelectString();
            _sleContext.ClaimFocus();
            return TRUE;
        }
    }

    if ( nlsPreferred.QueryTextLength() != 0 && !fNdsContext)
    {
        err = NwValidateUser((LPWSTR)nlsPreferred.QueryPch());

        if (err == NW_PASSWORD_HAS_EXPIRED)
        {
            ::MsgPopup( this, 
                        IDS_PASSWORD_HAS_EXPIRED,
                        MPSEV_WARNING,
                        MP_OK,
                        (LPWSTR)nlsPreferred.QueryPch());
            err = NERR_Success ;
        }

        // If the service is not started ( ERROR_NO_NETWORK
        // is returned) , ignore the error and
        // continue. Else popup a warning asking the user
        // whether he/she really wants to set the preferred server
        // to the given one.

        if (  ( err )
           && ( err != ERROR_NO_NETWORK )
           )
        {
            NLS_STR nlsError;
            APIERR  err1;

            //
            // If the server name is invalid, just popup the error.
            // We shouldn't let the users set the preferred server to
            // names that contain invalid characters.
            //
            if ( err == ERROR_INVALID_NAME )
            {
                ::MsgPopup( this, IDS_INVALID_SERVER_NAME );
                _comboPreferredServers.SelectString();
                _comboPreferredServers.ClaimFocus();
                return TRUE;
            }

            //
            // For all other errors, tell the user the error and
            // give the user the choice to select another preferred
            // server or keep going on with the original one.
            //
            if (  (( err1 = nlsError.QueryError()) != NERR_Success )
               || (( err1 = nlsError.LoadSystem( err )) != NERR_Success )
               )
            {
                MsgPopup( this, err ) ;
                return TRUE ;
            }

            if ( MsgPopup( this,
                           IDS_AUTHENTICATION_FAILURE_WARNING,
                           MPSEV_WARNING,
                           MP_YESNO,
                           nlsPreferred,
                           nlsError,
                           MP_NO ) == IDNO )
            {
                _comboPreferredServers.SelectString();
                _comboPreferredServers.ClaimFocus();
                return TRUE;
            }
        }
    }

    //
    // We store tree & default as follows:
    //     *TREE\CONTEXT or SERVER
    // 
    // So we prepend the '*' if NDS context.
    // We then add on the SERVER or TREE.
    // If NDS we add \ and then the context.
    //
    NLS_STR  nlsSetInfo ;
    if (fNdsContext)
    {
        nlsSetInfo = SZ("*") ;
    }
   
    nlsSetInfo += nlsPreferred ;
    if (err = nlsSetInfo.QueryError())
    {
        MsgPopup(this, err) ;
        return TRUE ;
    }

    if (fNdsContext)
    {
        if ((err = nlsSetInfo.Append(SZ("\\"))) ||
            (err = nlsSetInfo.Append(nlsContext)))
        {
            MsgPopup(this, err) ;
            return TRUE ;
        }
    }

    //
    // Now test to see if the current settings are different from
    // those that were previously set. If so, proceed to update the
    // settings in the registry and notify user that the settings
    // will take effect at next logon. Otherwise, dismiss the dialog
    // without doing anything and return OK.
    //

    if ( ( dwLogonScriptOptions == _dwOldLogonScriptOptions ) &&
         ( dwPrintOptions == _dwOldPrintOptions ) &&
         ( nlsSetInfo._stricmp( _nlsOldPreferredServer ) == 0 ) )
    {
        Dismiss() ;

        return TRUE ;
    }

    if (err = NwSetInfoInWksta(dwPrintOptions,
                               (LPWSTR)nlsSetInfo.QueryPch()))
    {
        NLS_STR nlsError;
        NLS_STR nlsErrorLocation = nlsSetInfo+1;
        APIERR  err1;
        WCHAR *pszTmp;

        if (  (( err1 = nlsError.QueryError()) != NERR_Success )
              || (( err1 = nlsError.LoadSystem( err )) != NERR_Success )
           )
        {
            MsgPopup( this, err ) ;
            return TRUE ;
        }

        //
        // This code formats the NDS
        // tree UNC to: Tree(Context)
        //
        if (pszTmp = wcschr((LPWSTR)nlsErrorLocation.QueryPch(), L'\\'))
        {
            *pszTmp = TCH('(') ;
            nlsErrorLocation.Append(SZ(")")) ;
        }

        if ( MsgPopup( this,
                       fNdsContext ? IDS_CONTEXT_AUTH_FAILURE_WARNING : IDS_AUTHENTICATION_FAILURE_WARNING,
                       MPSEV_WARNING,
                       MP_YESNO,
                       fNdsContext ? nlsErrorLocation : nlsPreferred,
                       nlsError,
                       MP_NO ) == IDNO )
        {
            if (fNdsContext)
            {
                _sleContext.SelectString();
                _sleContext.ClaimFocus();
            }
            else
            {
                _comboPreferredServers.SelectString();
                _comboPreferredServers.ClaimFocus();
            }
            return TRUE;
        }
    }

    if (err = NwSetInfoInRegistry(dwPrintOptions,
                                  (LPWSTR)nlsSetInfo.QueryPch()))
    {
        MsgPopup(this, err) ;
        return TRUE ;
    }

    if (err = NwSetLogonOptionsInRegistry(dwLogonScriptOptions))
    {
	    MsgPopup(this, err) ;
        return TRUE ;
    }

    MsgPopup(this, IDS_REGISTRY_UPDATED_ONLY) ;
    Dismiss() ;

    return TRUE ;
}

/*******************************************************************

    NAME:       NWC_DIALOG::QueryHelpContext

    SYNOPSIS:   Get the help context for this dialog

    ENTRY:

    EXIT:

    RETURNS:    ULONG - The help context for this dialog

    NOTES:

    HISTORY:
        ChuckC          17-Jul-1993     Created

********************************************************************/

ULONG NWC_DIALOG::QueryHelpContext( VOID )
{
    return HC_NWC_DIALOG;
}

/*******************************************************************

    NAME:       NWC_DIALOG::OnNWCHelp

    SYNOPSIS:   Actually launches the WinHelp applilcation for the Netware stuff

    NOTES:
        This is a private member function.

    HISTORY:
        beng        07-Oct-1991 Header added
        beng        05-Mar-1992 Removed wsprintf
        beng        22-Jun-1992 Disable help for Prerelease
        KeithMo     16-Aug-1992 Integrated new helpfile management.
        CongpaY     15-Sept-1993 Copied from bltdlg.cxx
        AnoopA      20-May-1998 Replaced WinHelp with HtmlHelp

********************************************************************/

VOID NWC_DIALOG::OnNWCHelp()
{
    const TCHAR * pszHelpFile = QueryHelpFile( HC_NWC_HELP );

    if( pszHelpFile != NULL )
    {
        if( !::HtmlHelpA( QueryHwnd(),
                          (_fIsWinnt)? "nwdoc.chm" : "nwdocgw.chm",
                          (UINT) HH_HELP_FINDER,
                          0 ) )
        {
            ::MsgPopup( QueryHwnd(),
                        IDS_BLT_WinHelpError,
                        MPSEV_ERROR,
                        MP_OK );
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\profext\profext.h ===
#include "uimsg.h"

typedef BOOL (CALLBACK FAR * LPFNADDPROPSHEETPAGES)(LPVOID, LPFNADDPROPSHEETPAGE, LPARAM);

BOOL APIENTRY NetworkPropDlg (HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam);

#define DLG_HWP_EXT     500
#define IDC_DISABLE     501
#define IDC_ENABLE      502
#define IDC_NONET       503
#define IDC_ERROR       504

//
//  JonN 9/20/96
//  All of the strings, including IDS_PROFEXT_ERROR, IDS_PROFEXT_NOADAPTERS,
//  and the Configuration Manager string table, are in NETUI2.DLL.
//  See LMOBJRC.H.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\nwc\nwc\nwshare.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    nwc.cxx
       The file contains the classes for the Netware Gateway Add Share dialog

    FILE HISTORY:
        ChuckC          30-Oct-1993     Created
*/


#define INCL_NET
#define INCL_NETLIB
#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETERRORS
#define INCL_DOSERRORS
#define INCL_ICANON
#include <lmui.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif

#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_CLIENT
#define INCL_BLT_MSGPOPUP
#define INCL_BLT_EVENT
#define INCL_BLT_MISC
#define INCL_BLT_CC
#define INCL_BLT_SPIN_GROUP
#define INCL_BLT_GROUP
#include <blt.hxx>

#include <uiassert.hxx>
#include <uitrace.hxx>
#include <lmoshare.hxx>
#include <dbgstr.hxx>

#define USERS_DEFAULT 32
#define USERS_MIN     1

extern "C"
{
    #include <npapi.h>
    #include <nwevent.h>
    #include <nwc.h>
    #include <nwapi.h>
    #include <shellapi.h>
    #include <mnet.h>
}

#include <nwc.hxx>

/*******************************************************************

    NAME:       NWC_ADDSHARE_DIALOG::NWC_ADDSHARE_DIALOG

    SYNOPSIS:   Constructor for the dialog.

    ENTRY:      hwndOwner - Hwnd of the owner window

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        ChuckC          17-Jul-1993     Created

********************************************************************/

NWC_ADDSHARE_DIALOG::NWC_ADDSHARE_DIALOG( HWND hwndOwner, 
                                          NLS_STR *pnlsAccount,
                                          NLS_STR *pnlsPassword)
   : DIALOG_WINDOW( MAKEINTRESOURCE( IDD_NWC_GWADD_DLG), hwndOwner ),
   _sleShare(this, GW_SLE_SHARENAME, LM20_NNLEN ),
   _slePath(this, GW_SLE_PATH),
   _comboDrives(this,GW_COMBO_DRIVE),
   _sleComment( this, GW_SLE_COMMENT, LM20_MAXCOMMENTSZ ),
   _mgrpUserLimit( this, GW_RB_UNLIMITED, 2, GW_RB_UNLIMITED), // 2 buttons
        _spsleUsers( this, GW_SLE_USERS, USERS_DEFAULT,
                     USERS_MIN, (0xFFFFFFFE - USERS_MIN + 1), TRUE),    
        _spgrpUsers( this, GW_SB_USERS_GROUP, GW_SB_USERS_UP, GW_SB_USERS_DOWN),
   _pnlsAccount(pnlsAccount),
   _pnlsPassword(pnlsPassword)

{
    APIERR       err ;

    if ( QueryError() != NERR_Success )
        return;

    if (  ((err = _mgrpUserLimit.QueryError()) != NERR_Success )
       || ((err = _spgrpUsers.AddAssociation( &_spsleUsers )) != NERR_Success )
       || ((err = _mgrpUserLimit.AddAssociation( GW_RB_USERS, &_spgrpUsers ))
	          != NERR_Success ) )
    {
        ReportError(err) ;
        return ;
    }


    if (err = FillDrivesCombo())
    {
        ReportError(err) ;
        return;
    }

    Invalidate() ;
}


/*******************************************************************

    NAME:       NWC_ADDSHARE_DIALOG::~NWC_ADDSHARE_DIALOG

    SYNOPSIS:   Destructor

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        ChuckC          17-Jul-1993     Created

********************************************************************/

NWC_ADDSHARE_DIALOG::~NWC_ADDSHARE_DIALOG()
{
    // Nothing to do for now
}

/*******************************************************************

    NAME:       NWC_ADDSHARE_DIALOG::FillDrivesCombo

    SYNOPSIS:   Fill combo with list of avail drives

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        ChuckC          17-Jul-1993     Created

********************************************************************/

APIERR NWC_ADDSHARE_DIALOG::FillDrivesCombo(void)
{
    APIERR status = NERR_Success;
    TCHAR szDrive[4] ;
    INT i ;
    UINT res ;

    strcpyf(szDrive, SZ("A:\\")) ;

    for (i = 0; i < 26; i++) 
    {
        szDrive[0] = TCH('Z')-i ;
        res = GetDriveType(szDrive) ;
        if (res == 0 || res == 1)
        {
            szDrive[2] = 0 ;
            if (_comboDrives.AddItem(szDrive) < 0)
                return ERROR_NOT_ENOUGH_MEMORY ;
            szDrive[2] = TCH('\\') ;
        }
    }
    _comboDrives.SelectItem(0) ;

    return status;
}


/*******************************************************************

    NAME:       NWC_ADDSHARE_DIALOG::OnOK

    SYNOPSIS:   Process OnOK when OK button is hit.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        ChuckC          17-Jul-1993     Created

********************************************************************/

BOOL NWC_ADDSHARE_DIALOG::OnOK( )
{
    NLS_STR nlsShare ;
    NLS_STR nlsPath ;
    NLS_STR nlsDrive ;
    NLS_STR nlsComment ;
    NLS_STR nlsDrivePath ;
    ULONG UserLimit ;
    APIERR err ;

    //
    // no need check for contruction from above. let the Query methods fail
    //

    if ((err = _slePath.QueryText(&nlsPath))  ||
        (err = _sleShare.QueryText(&nlsShare)) ||
        (err = _comboDrives.QueryText(&nlsDrive)) ||
        (err = QueryComment(&nlsComment)) ||
        (err = nlsDrivePath.CopyFrom(nlsDrive)) ||
        (err = nlsDrivePath.AppendChar(TCH('\\'))))
    {
        ::MsgPopup(this, err) ;
        return TRUE ;
    }

    UserLimit = QueryUserLimit() ;

    SHARE_2 share(nlsShare.QueryPch()) ;
    if ((err = share.QueryError()) ||
        (err = share.CreateNew()) ||
        (err = share.SetComment(nlsComment)) ||
        (err = share.SetMaxUses(UserLimit)) ||
        (err = share.SetPath(nlsDrivePath.QueryPch())) ||
        (err = share.SetResourceType(STYPE_DISKTREE)))
    {
        ::MsgPopup(this, err) ;
        return TRUE ;
    }

    //
    // Check if the name of the share is accessible from DOS machine
    //
    ULONG nType;
    if ( ::I_MNetPathType(NULL, nlsShare, &nType, INPT_FLAGS_OLDPATHS )
       != NERR_Success )
    {
        if ( ::MsgPopup( this, IDS_SHARE_NOT_ACCESSIBLE_FROM_DOS,
                         MPSEV_INFO, MP_YESNO, nlsShare, MP_NO ) == IDNO )
        {
            _sleShare.SelectString();
            _sleShare.ClaimFocus();
            return TRUE;
        }
    }

    if (err = NwAddGWDevice((LPWSTR)nlsDrive.QueryPch(),
                            (LPWSTR)nlsPath.QueryPch(),
                            (LPWSTR)_pnlsAccount->QueryPch(),
                            (LPWSTR)_pnlsPassword->QueryPch(),
                            TRUE))
    {
        if (err == ERROR_ACCESS_DENIED ||
            err == ERROR_NO_SUCH_USER ||
            err == ERROR_INVALID_PASSWORD)
        {
            RESOURCE_STR nlsErr(err) ;
            APIERR err1 = nlsErr.QueryError() ;

            if (!err1)
                ::MsgPopup(this,
                           IDS_GATEWAY_NO_ACCESS,
                           MPSEV_ERROR,
                           MP_OK,
                           nlsErr.QueryPch()) ;
            else
                ::MsgPopup(this, err1) ;
        }
        else
            ::MsgPopup(this, err) ;
        return TRUE ;
    }
   

    if (err = share.WriteNew()) 
    {
        APIERR err1 = NwDeleteGWDevice((LPWSTR)nlsDrive.QueryPch(),
                            NW_GW_UPDATE_REGISTRY) ;

        if (err == ERROR_INVALID_DRIVE)
            err = IDS_ACCESS_PROBLEM ;

        if (err == ERROR_ACCESS_DENIED ||
            err == ERROR_NO_SUCH_USER ||
            err == ERROR_INVALID_PASSWORD)
        {
            RESOURCE_STR nlsErr(err) ;
            err1 = nlsErr.QueryError() ;

            if (!err1)
                ::MsgPopup(this,
                           IDS_GATEWAY_NO_ACCESS,
                           MPSEV_ERROR,
                           MP_OK,
                           nlsErr.QueryPch()) ;
            else
                ::MsgPopup(this, err1) ;
        }
        else
            ::MsgPopup(this, err) ;
        return TRUE ;
    }

    if (err == NO_ERROR)
    {
        (void) NwRegisterGatewayShare((LPWSTR)nlsShare.QueryPch(),
                                      (LPWSTR)nlsDrive.QueryPch()) ;
    }

    Dismiss() ;
    return TRUE ;
}

/*******************************************************************

    NAME:       NWC_ADDSHARE_DIALOG::QueryHelpContext

    SYNOPSIS:   Get the help context for this dialog

    ENTRY:

    EXIT:

    RETURNS:    ULONG - The help context for this dialog

    NOTES:

    HISTORY:
        ChuckC          17-Jul-1993     Created

********************************************************************/

ULONG NWC_ADDSHARE_DIALOG::QueryHelpContext( VOID )
{
    return HC_NWC_ADDSHARE;
}


/*******************************************************************

    NAME:	NWC_ADDSHARE_DIALOG::QueryUserLimit

    SYNOPSIS:   Get the user limit from the magic group

    ENTRY:

    EXIT:

    RETURNS:    The user limit stored in the user limit magic group

    NOTES:

    HISTORY:
	Yi-HsinS	8/15/91		Created

********************************************************************/

ULONG NWC_ADDSHARE_DIALOG::QueryUserLimit( VOID ) const
{

    ULONG ulUserLimit;

    switch ( _mgrpUserLimit.QuerySelection() )
    {
        case GW_RB_UNLIMITED:
             ulUserLimit = (ULONG) SHI_USES_UNLIMITED;
             break;

        case GW_RB_USERS:
             // We don't need to check whether the value is valid or not
             // because SPIN_BUTTON checks it.

             ulUserLimit = _spsleUsers.QueryValue();
             UIASSERT(   ( ulUserLimit <= _spsleUsers.QueryMax() )
	             &&  ( ulUserLimit >= USERS_MIN )
		     );
             break;

        default:
             UIASSERT(!SZ("User Limit: This shouldn't have happened!\n\r"));
             ulUserLimit = (ULONG) SHI_USES_UNLIMITED;
             break;
    }

    return ulUserLimit;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\profext\profext.cxx ===
//
// includes
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#define INCL_WINDOWS
#define INCL_NETERRORS
#define INCL_NETLIB
#include "lmui.hxx"
#define INCL_BLT_MISC
#include "blt.hxx"              // AUTO_CURSOR
#include "dbgstr.hxx"
#include "strnumer.hxx"
#include "uiassert.hxx"
#include "lmobj.hxx"
#include "lmoenum.hxx"          // SERVICE_ENUM
#include "lmoesvc.hxx"          // SERVICE_ENUM
#include "regkey.hxx"           // REG_KEY
#include "lmobjrc.h"            // IDS_PROFEXT_*

extern "C"
{
    #include <prsht.h>
    #include "profext.h"
    #include <cfgmgr32.h>       // CONFIGRET
    #include <regstr.h>         // CSCONFIGFLAG_DISABLED
    // we have to do this for a clean compile
    #undef DBGOUT
    #include "sysdm.h"          // IDH_HWPROFILE
    #include <regstr.h>         // REGSTR_PATH_SERVICES
    #include <ntddndis.h>       // NdisMedium* constants
}

//
// global data
//
HINSTANCE   hInst = NULL;                        // Module handle

static int HwProfileHelpIds[] = {
   IDC_DISABLE,             IDH_HWPROFILE+IDC_DISABLE,
   IDC_ENABLE,              IDH_HWPROFILE+IDC_ENABLE,
   IDC_NONET,               IDH_HWPROFILE+IDC_NONET,
   IDC_ERROR,               IDH_HWPROFILE+IDC_ERROR,
   0, 0
   };

#define SZ_NDIS SZ("NDIS")
#define TCH_REGSEPERATOR TCH('\\')
#define SZ_REGSEPERATOR SZ("\\")
#define SZ_REGPARAMETERS SZ("\\Parameters")
#define SZ_REGLINKAGE SZ("\\Linkage")
#define SZ_REGMEDIATYPE SZ("MediaType")
#define SZ_REGBIND SZ("Bind")


APIERR MapCfgMgr32Error( CONFIGRET dwCfgMgr32Error )
{
    APIERR err = IDS_CFGMGR32_BASE + dwCfgMgr32Error;
    switch (dwCfgMgr32Error)
    {

        case CR_SUCCESS              :
        // CR_NEED_RESTART is considered to be Success
        case CR_NEED_RESTART         :
            err = NO_ERROR;
            break;

        // Just use the CFGMGR out-of-memory error
        //
        // case CR_OUT_OF_MEMORY        :
        //     err = ERROR_NOT_ENOUGH_MEMORY;
        //     break;

        //
        //  These are supposedly for Windows 95 only!
        //
        case CR_INVALID_ARBITRATOR   :
        case CR_INVALID_NODELIST     :
        case CR_DLVXD_NOT_FOUND      :
        case CR_NOT_SYSTEM_VM        :
        case CR_NO_ARBITRATOR        :
        case CR_DEVLOADER_NOT_READY  :
            ASSERT( FALSE );
            // fall through

        default                      :
            break;
    }

    return err;
}

VOID
HandleError( HWND hDlg, APIERR err, HWND hwndEdit = NULL )
{
    NLS_STR nlsError, nlsTitle;
    if (   nlsError.QueryError() != NERR_Success
        || nlsTitle.QueryError() != NERR_Success
        || nlsError.Load( err ) != NERR_Success
        || nlsTitle.Load( IDS_PROFEXT_ERROR ) != NERR_Success
       )
    {
        TRACEEOL( "PROFEXT.DLL: HandleError failure" );
        ASSERT( FALSE );
        return;
    }

    if (hwndEdit != NULL)
    {
        ::SetWindowText( hwndEdit, nlsError.QueryPch() );
        ::ShowWindow( hwndEdit, SW_SHOW );
    }
    if (err != IDS_PROFEXT_NOADAPTERS)
    {
        REQUIRE( IDOK == ::MessageBox( hDlg,
                                       nlsError.QueryPch(),
                                       nlsTitle.QueryPch(),
                                       MB_ICONSTOP | MB_OK ) );
    }
}

APIERR
IsDisabled( ULONG ulProfileID, DEVINSTID devinst, BOOL* pfIsDisabled )
{
    TRACEEOL( "IsDisabled( " << ulProfileID << ", \"" << devinst << "\") " );
    ASSERT( pfIsDisabled != NULL );
    APIERR err = NERR_Success;
    ULONG ulValue = 0;
    CONFIGRET configret = ::CM_Get_HW_Prof_Flags(
        devinst,
        ulProfileID,
        &ulValue,
        0x0 );
    err = MapCfgMgr32Error( configret );
    if (err != NERR_Success)
    {
        TRACEEOL( "\terror " << configret );
        return err;
    }
    *pfIsDisabled = !!(ulValue & CSCONFIGFLAG_DISABLED);
    TRACEEOL( (CHAR*)((*pfIsDisabled)?"\tis disabled":"\tis enabled") );
    return err;
}

APIERR
Disable( ULONG ulProfileID, DEVINSTID devinst, BOOL fDisable )
{
    APIERR err = NERR_Success;
    ULONG ulValue = 0;
    CONFIGRET configret = ::CM_Get_HW_Prof_Flags(
        devinst,
        ulProfileID,
        &ulValue,
        0x0 );
    err = MapCfgMgr32Error( configret );
    if (err != NERR_Success)
    {
        TRACEEOL( "\tEnable: CM_Get_HW_Prof_Flags error " << configret );
        return err;
    }
    if (fDisable)
    {
        if ( ulValue & CSCONFIGFLAG_DISABLED )
        {
            TRACEEOL( "Disable: \"" << devinst << "\" already disabled" );
            return err;
        }
        ulValue |= CSCONFIGFLAG_DISABLED;
    } else {
        if ( !(ulValue & CSCONFIGFLAG_DISABLED) )
        {
            TRACEEOL( "Disable: \"" << devinst << "\" already enabled" );
            return err;
        }
        ulValue &= ~CSCONFIGFLAG_DISABLED;
    }
    configret = ::CM_Set_HW_Prof_Flags(
        devinst,
        ulProfileID,
        ulValue,
        0x0 );
    err = MapCfgMgr32Error( configret );
    if (err != NERR_Success)
    {
        TRACEEOL( "\tDisable: CM_Set_HW_Prof_Flags error " << configret );
    } else {
        TRACEEOL( "\tDisable: \"" << devinst
            << (CHAR*)((fDisable)?"\" now disabled":"\" now enabled") );
    }
    return err;
}

APIERR BoundServiceIsWanMediaType( NLS_STR& nlsBoundService,
                                   BOOL* pfWANMediaType,
                                   REG_KEY& regkeyHKLM )
{
    const TCHAR * pchBoundService = nlsBoundService.QueryPch();
    ISTR istrBoundService( nlsBoundService );
    if ( nlsBoundService.strrchr( &istrBoundService, TCH_REGSEPERATOR ) )
    {
        ++istrBoundService;
        pchBoundService = nlsBoundService.QueryPch( istrBoundService );
    }

    // open HKLM\CurrentControlSet\Services\<bound service>\Parameters key
    NLS_STR nlsRegPath( REGSTR_PATH_SERVICES );
    nlsRegPath += SZ_REGSEPERATOR;
    nlsRegPath += pchBoundService;
    nlsRegPath += SZ_REGPARAMETERS;
    APIERR err = nlsRegPath.QueryError();
    if ( err != NERR_Success )
    {
        DBGEOL( "BoundServiceIsWanMediaType: string error " << err );
        return err;
    }
    TRACEEOL( "BoundServiceIsWanMediaType: key \"" << nlsRegPath << "\"" );
    REG_KEY regkeyParameters(regkeyHKLM, nlsRegPath, KEY_READ);
    if ( (err = regkeyParameters.QueryError()) != NERR_Success )
    {
        TRACEEOL( "BoundServiceIsWanMediaType: key \"" << nlsRegPath <<
                "\" error " << err );
        return err;
    }

    DWORD dwMediaType = 0;
    if ( (err = regkeyParameters.QueryValue( SZ_REGMEDIATYPE, &dwMediaType))
                        != NERR_Success )
    {
        TRACEEOL( "BoundServiceIsWanMediaType: mediatype error " << err );
        return err;
    }
    TRACEEOL( "BoundServiceIsWanMediaType: media type " << dwMediaType );
    switch (dwMediaType-1)
    {
    case NdisMedium802_3:
    case NdisMedium802_5:
    case NdisMediumFddi:
    case NdisMediumLocalTalk:
    case NdisMediumDix:
    case NdisMediumArcnetRaw:
    case NdisMediumArcnet878_2:
    case NdisMediumAtm:
        *pfWANMediaType = FALSE;
        break;

    case NdisMediumWan:
    case NdisMediumWirelessWan:
    case NdisMediumIrda:
        *pfWANMediaType = TRUE;
        break;

    default:
        DBGEOL(   "BoundServiceIsWanMediaType: invalid media type "
               << dwMediaType );
        *pfWANMediaType = TRUE;
        break;
    }

    return NERR_Success;
}

APIERR IsWanMediaType( const TCHAR * pszServiceName, BOOL* pfWANMediaType)
{
    TRACEEOL( "IsWanMediaType: checking \"" << pszServiceName << "\"" );

    // open HKLM key
    REG_KEY regkeyHKLM(HKEY_LOCAL_MACHINE, NULL, KEY_READ);
    APIERR err = regkeyHKLM.QueryError();
    if ( err != NERR_Success )
    {
        DBGEOL( "IsWanMediaType: HKLM error " << err );
        return err;
    }

    // open HKLM\CurrentControlSet\Services\<service>\Linkage key
    NLS_STR nlsRegPath( REGSTR_PATH_SERVICES );
    nlsRegPath += SZ_REGSEPERATOR;
    nlsRegPath += pszServiceName;
    nlsRegPath += SZ_REGLINKAGE;
    if ( (err = nlsRegPath.QueryError()) != NERR_Success )
    {
        DBGEOL( "IsWanMediaType: string error " << err );
        return err;
    }
    TRACEEOL( "IsWanMediaType: key \"" << nlsRegPath << "\"" );
    REG_KEY regkeyLinkage(regkeyHKLM, nlsRegPath, KEY_READ);
    if ( (err = regkeyLinkage.QueryError()) != NERR_Success )
    {
        TRACEEOL( "IsWanMediaType: key \"" << nlsRegPath <<
                  "\" error " << err );
        return err;
    }

    // get Bind parameter and extract service name(s)
    STRLIST* pstrlistBind = NULL;
    if ( (err = regkeyLinkage.QueryValue( SZ_REGBIND, &pstrlistBind ))
                        != NERR_Success
        || (err = ((pstrlistBind != NULL)
                ? NERR_Success : ERROR_NOT_ENOUGH_MEMORY)) != NERR_Success
       )
    {
        TRACEEOL( "IsWanMediaType: bind value error " << err );
        return err;
    }
    ITER_STRLIST iterslBind( *pstrlistBind );
    NLS_STR* pnlsBind = NULL;
    *pfWANMediaType = FALSE;
    while ( (pnlsBind = iterslBind.Next()) != NULL )
    {
        err = BoundServiceIsWanMediaType( *pnlsBind,
                                          pfWANMediaType,
                                          regkeyHKLM );
        if (err != NERR_Success || *pfWANMediaType )
            break;
    }

    delete pstrlistBind; // CODEWORK I have seen problems with this line
    return err;
}


/*
 * if fSet is FALSE, set *pfNoNetworkProfile to TRUE if no network
 *  device is enabled, set to FALSE otherwise
 *
 * if fSet is TRUE and *pfNoNetworkProfile is FALSE,
 *  enable all network devices
 *
 * if fSet is TRUE and *pfNoNetworkProfile is TRUE,
 *  disable all network devices
 */
APIERR
DoNetworkProfile( ULONG ulProfileID, BOOL fSet, BOOL* pfNoNetworkProfile )
{
    AUTO_CURSOR autocur;

    ASSERT( pfNoNetworkProfile != NULL );
    APIERR err = NERR_Success;
    if (!fSet)
        *pfNoNetworkProfile=TRUE;

    do // false loop
    {
        TRACEEOL( "DoNetworkProfile: enumerating NDIS services");
        SERVICE_ENUM svcenum( NULL, TRUE, SERVICE_KERNEL_DRIVER, SZ_NDIS );
        if (   (err = svcenum.QueryError()) != NERR_Success
            || (err = svcenum.GetInfo()) != NERR_Success
           )
        {
            TRACEEOL( "DoNetworkProfile: error " << err << " opening svcenum" );
            break;
        }

        BOOL fFoundAdapter = FALSE;
        SERVICE_ENUM_ITER svciter( svcenum );
        const SERVICE_ENUM_OBJ* psvc;
        while( ( psvc = svciter() ) != NULL )
        {
            const TCHAR* pszServiceName = psvc->QueryServiceName();
            if ( 0 == ::stricmpf( pszServiceName, SZ_NDIS ) )
                continue;

            BOOL fWANMediaType = FALSE;
            if ( (err = IsWanMediaType(pszServiceName, &fWANMediaType))
                            != NERR_Success)
            {
                //
                // All errors are ignored, and we assume WAN MediaType
                //
                TRACEEOL( "DoNetworkProfile: ignoring error " << err <<
                          " checking mediatype of \"" << pszServiceName <<
                          "\"" );
                err = NERR_Success;
                continue;
            } else if (fWANMediaType) {
                TRACEEOL( "DoNetworkProfile: skipping service \"" <<
                          pszServiceName << "\" due to mediatype" );
                continue;
            }

            ULONG cch = 0;
            CONFIGRET configret = ::CM_Get_Device_ID_List_Size(
                              &cch,
                              pszServiceName,
                              CM_GETIDLIST_FILTER_SERVICE );
            if ( (err = MapCfgMgr32Error( configret )) != NERR_Success )
            {
                TRACEEOL("DoNetworkProfile: Get_Device_ID_List_Size returned " << configret );
                if (configret == CR_NO_SUCH_VALUE)
                {
                    ASSERT( FALSE );
                    continue;
                }
                break;
            }

            BUFFER bufDeviceIDs( cch*sizeof(TCHAR) );
            if ( (err = bufDeviceIDs.QueryError()) != NERR_Success )
                break;
            do {
                configret = ::CM_Get_Device_ID_List(
                              pszServiceName,
                              (TCHAR *)(bufDeviceIDs.QueryPtr()),
                              bufDeviceIDs.QuerySize() / sizeof(TCHAR),
                              CM_GETIDLIST_FILTER_SERVICE );
                if (configret == CR_BUFFER_SMALL)
                {
                    cch *= 2;
                    if ( (err = bufDeviceIDs.Resize(cch*sizeof(TCHAR))) != NERR_Success )
                        break;
                } else if (configret == CR_NO_SUCH_VALUE)
                {
                    ASSERT( FALSE );
                    continue;
                }
            } while (configret == CR_BUFFER_SMALL);
            const TCHAR * pchDeviceID = (const TCHAR *)bufDeviceIDs.QueryPtr();
            while ( *pchDeviceID != TCH('\0') )
            {
                fFoundAdapter = TRUE;
                DEVINSTID devinst = (DEVINSTID)pchDeviceID;
                if (fSet) {
                    if ( (err = Disable( ulProfileID,
                                         devinst,
                                         *pfNoNetworkProfile)) != NERR_Success)
                        break;
                } else {
                    BOOL fIsDisabled = FALSE;
                    if ( (err = IsDisabled( ulProfileID,
                                            devinst,
                                            &fIsDisabled)) != NERR_Success)
                        break;
                    if (!fIsDisabled)
                    {
                        *pfNoNetworkProfile = FALSE;
                        break;
                    }
                }

                pchDeviceID += ::strlenf(pchDeviceID) + 1;
            }
        }
        TRACEEOL( "DoNetworkProfile: enumerated NDIS services");

        if ( !fFoundAdapter && err == NERR_Success )
        {
            TRACEEOL( "DoNetworkProfile: no adapters found" );
            err = IDS_PROFEXT_NOADAPTERS;
        }

    } while (FALSE); // false loop

    return err;
}




BOOL
DllMain(
   PVOID hModule,
   ULONG Reason,
   PCONTEXT pContext
   )

/*++

Routine Description:

   This is the standard DLL entrypoint routine, called whenever a process
   or thread attaches or detaches.
   Arguments:

   hModule -   PVOID parameter that specifies the handle of the DLL

   Reason -    ULONG parameter that specifies the reason this entrypoint
               was called (either PROCESS_ATTACH, PROCESS_DETACH,
               THREAD_ATTACH, or THREAD_DETACH).

   pContext -  ???

Return value:

   Returns true if initialization compeleted successfully, false is not.

--*/

{
   hInst = (HINSTANCE)hModule;

   DBG_UNREFERENCED_PARAMETER(pContext);

   switch(Reason) {
      case DLL_PROCESS_ATTACH:
          DisableThreadLibraryCalls(hInst);
      case DLL_PROCESS_DETACH:
      case DLL_THREAD_ATTACH:
      case DLL_THREAD_DETACH:
         break;
   }

   return TRUE;

} // DllMain



BOOL CALLBACK
ExtensionPropSheetPageProc(
   LPVOID lpv,
   LPFNADDPROPSHEETPAGE  lpfnAddPropSheetPageProc,
   LPARAM  lParam
   )


/*++

Routine Description:


Arguments:

   lpv                        Pointer to an application-defined value that
                              describes an item for which a property sheet
                              page is to be created. This parameter can be NULL.

   lpfnAddPropSheetPageProc   Pointer to the AddPropSheetPageProc function.
                              The extension dynamic-link library (DLL) calls
                              this function to add a page to the property sheet.

   lParam                     Application-defined 32-bit value.

Return Value:

   If the function succeeds, the return value is TRUE.
   If the function fails, the return value is FALSE.

--*/

{
   PROPSHEETPAGE     PropPage;
   HPROPSHEETPAGE    hPropPage;

   PropPage.dwSize        = sizeof(PROPSHEETPAGE);
   PropPage.dwFlags       = PSP_DEFAULT;
   PropPage.hInstance     = hInst;
   PropPage.pszTemplate   = MAKEINTRESOURCE(DLG_HWP_EXT);
   PropPage.pszIcon       = NULL;
   PropPage.pszTitle      = NULL;
   PropPage.pfnDlgProc    = NetworkPropDlg;
   PropPage.lParam        = lParam;
   PropPage.pfnCallback   = NULL;

   hPropPage = CreatePropertySheetPage(&PropPage);
   if (hPropPage == NULL) {
      return FALSE;
   }

   (lpfnAddPropSheetPageProc)(hPropPage, 0);

   return TRUE;

} // ExtensionPropSheetPageProc


typedef struct {
    LONG ulProfile;
    BOOL fNoNet;
    BOOL fError;
} PROFEXT_INTERNAL;


BOOL
APIENTRY
NetworkPropDlg(
      HWND    hDlg,
      UINT    uMessage,
      WPARAM  wParam,
      LPARAM  lParam
      )

{
   ULONG ulProfile = 0;
   APIERR err = NERR_Success;

   switch (uMessage)
   {
      case WM_INITDIALOG:
         {
            PROFEXT_INTERNAL* pprofext = new PROFEXT_INTERNAL;
            // CODEWORK I should free this at some point
            ASSERT( pprofext != NULL );
            ::memsetf( pprofext, '\0', sizeof(PROFEXT_INTERNAL) );
            ::SetWindowLong(hDlg, DWL_USER, (LONG)pprofext);
            //
            // on WM_INITDIALOG call, property sheet's lParam field
            // contains the profile ID, save it in window long word for
            // use with other messages later
            //
            ulProfile = (ULONG)((LPPROPSHEETPAGE)lParam)->lParam;
            ASSERT( (LONG)ulProfile >= 0 );
            pprofext->ulProfile = ulProfile;
            BOOL fNoNetworkProfile = FALSE;
            err = DoNetworkProfile( ulProfile,
                                    FALSE,
                                    &fNoNetworkProfile );
            if (err != NERR_Success) {
                HWND hwndEdit = ::GetDlgItem(hDlg, IDC_ERROR);
                ASSERT( hwndEdit != NULL );
                HandleError( hDlg, err, hwndEdit );
                pprofext->fError = TRUE;
            } else {
                pprofext->fNoNet = (fNoNetworkProfile)?1:0;
            }


            //
            // Call CM_Get_Hardware_Profile_Info to get info about
            // the specified profile (ulProfile).
            //
            return FALSE;
         }


      case WM_NOTIFY:

         if (!lParam) {
            break;
         }

         switch (((NMHDR *)lParam)->code) {

            case PSN_SETACTIVE:
                {
                    PROFEXT_INTERNAL* pprofext =
                        (PROFEXT_INTERNAL*)::GetWindowLong(hDlg, DWL_USER);
                    ASSERT( pprofext != NULL );
                    HWND hwndCheckbox = ::GetDlgItem(hDlg, IDC_NONET);
                    HWND hwndEnableText = ::GetDlgItem(hDlg, IDC_ENABLE);
                    HWND hwndDisableText = ::GetDlgItem(hDlg, IDC_DISABLE);
                    ASSERT(   hwndCheckbox
                           && hwndEnableText && hwndDisableText );
                    ::EnableWindow(
                        hwndEnableText,
                        pprofext->fNoNet && !(pprofext->fError) );
                    ::EnableWindow(
                        hwndDisableText,
                        !(pprofext->fNoNet) && !(pprofext->fError) );
                    if (pprofext->fError)
                    {
                        ::EnableWindow( hwndCheckbox, FALSE );
                    } else {
                        ::SendMessage( hwndCheckbox, BM_SETCHECK,
                                 (pprofext->fNoNet)?1:0, 0 );
                    }
                }
               break;

            case PSN_KILLACTIVE:
                {
                    PROFEXT_INTERNAL* pprofext =
                        (PROFEXT_INTERNAL*)::GetWindowLong(hDlg, DWL_USER);
                    ASSERT( pprofext != NULL );
                    //
                    // validate selections, this page is active until I return FALSE
                    // in DWL_MSGRESULT
                    //
                    if (pprofext->fError)
                        break; // error or no adapter as initial state
                    TRACEEOL( "NetworkPropDlg: pprofext->fNoNet is "
                        << pprofext->fNoNet );
                    HWND hwnd = ::GetDlgItem(hDlg, IDC_NONET);
                    ASSERT( hwnd != NULL );
                    BOOL fCurrentNoNet = (::SendMessage(hwnd, BM_GETCHECK, 0, 0) != 0)
                             ? TRUE : FALSE;
                    TRACEEOL( "NetworkPropDlg: fCurrentNoNet is " << fCurrentNoNet );
                    if (pprofext->fNoNet != fCurrentNoNet)
                    {
                         err = DoNetworkProfile(
                                pprofext->ulProfile, TRUE, &fCurrentNoNet );
                         if (err != NERR_Success) {
                             HandleError( hDlg, err );
                             ::SetWindowLong(hDlg, DWL_MSGRESULT, TRUE); // TRUE if error
                             break;
                         }
                    }

                    pprofext->fNoNet = fCurrentNoNet;
                    ::SetWindowLong(hDlg, DWL_MSGRESULT, FALSE);   // TRUE if error
                }
               break;

            case PSN_RESET:
               //
               // user canceled the property sheet
               //
               break;
         }
         break;


      case WM_HELP:
         WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle, HELP_FILE,
               HELP_WM_HELP, (DWORD)(LPTSTR)HwProfileHelpIds);
         break;

      case WM_CONTEXTMENU:
         WinHelp((HWND)wParam, HELP_FILE, HELP_CONTEXTMENU,
               (DWORD)(LPTSTR)HwProfileHelpIds);
         break;


      case WM_COMMAND:
       default:
          return FALSE;
          break;
    }

    return TRUE;

} // NetworkPropDlg
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\shell\enum\dfsenum.cxx ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:       enumnode.cxx
//
//  Contents:   This has the implementation for enumeration helper classes
//              CDfsEnumNode, CDfsEnumHandleTable.
//
//  Functions:
//
//  History:    21-June-1994    SudK    Created.
//
//-----------------------------------------------------------------------------

extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
}

#include <dfsfsctl.h>
#include <windows.h>
#include <string.h>
#include <wchar.h>
#include <npapi.h>
#include <lm.h>

#define appDebugOut(x)

#define ARRAYLEN(x) (sizeof(x) / sizeof((x)[0]))

#define INCL_NETLIB
#include <lmui.hxx>

#include <dfsutil.hxx>
#include "dfsenum.hxx"

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

//+-------------------------------------------------------------------------
//
//  Method:     CDfsEnumNode::CDfsEnumNode
//
//  Synopsis:   Constructor for this enumeration node.
//
//  Returns:    Nothing
//
//--------------------------------------------------------------------------
CDfsEnumNode::CDfsEnumNode(
    DWORD dwScope,
    DWORD dwType,
    DWORD dwUsage
    )
    :
    _dwScope(dwScope),
    _dwType(dwType),
    _dwUsage(dwUsage)
{
}


//+-------------------------------------------------------------------------
//
//  Method:     CDfsEnumNode::~CDfsEnumNode
//
//  Synopsis:   Destructor.
//
//  Returns:    Nothing
//
//--------------------------------------------------------------------------
CDfsEnumNode::~CDfsEnumNode()
{
    //
    // Nothing to do
    //
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

//+-------------------------------------------------------------------------
//
//  Method:     CDfsEnumConnectedNode::CDfsEnumConnectedNode
//
//  Synopsis:   Constructor for this enumeration node.
//
//  Returns:    Nothing
//
//--------------------------------------------------------------------------

#define OFFSET_TO_POINTER(p, o)                 \
    if ((o)) *((LPBYTE *) &(o)) = (((LPBYTE) (o)) + ((DWORD_PTR) (p)))

CDfsEnumConnectedNode::CDfsEnumConnectedNode(
    DWORD dwScope,
    DWORD dwType,
    DWORD dwUsage,
    LPCTSTR pszProviderName,
    const LPNETRESOURCE lpNetResource
    )
    :
    CDfsEnumNode(dwScope, dwType, dwUsage),
    _iNext(0),
    _cTotal(0),
    _lpNetResource(NULL)
{
    NTSTATUS Status;
    DWORD    cbSize;

    //
    // We are only going to enumerate disk resources.
    //

    if ((dwType != RESOURCETYPE_ANY) &&
            ((dwType & RESOURCETYPE_DISK) == 0))
        return;

    _lpNetResource = (LPNETRESOURCE) _buffer;
    cbSize = sizeof(_buffer);

    do {

        Status = DfsFsctl(
                    FSCTL_DFS_GET_CONNECTED_RESOURCES,
                    (PVOID) pszProviderName,
                    (strlenf( pszProviderName ) + 1) * sizeof(TCHAR),
                    (PVOID) _lpNetResource,
                    cbSize,
                    NULL);

        if (Status == STATUS_BUFFER_OVERFLOW) {

            if (_lpNetResource != (LPNETRESOURCE) _buffer) {

                delete _lpNetResource;
            }

            cbSize *= 2;

            _lpNetResource = (LPNETRESOURCE) new BYTE[ cbSize ];

        }

    } while ( Status == STATUS_BUFFER_OVERFLOW && _lpNetResource != NULL );

    if ( Status == STATUS_SUCCESS && _lpNetResource != NULL ) {

        _cTotal = *((LPDWORD)
                    ( ((PUCHAR) _lpNetResource) + cbSize - sizeof(DWORD) ));

        for(DWORD i = 0; i < _cTotal; i++) {

            LPNETRESOURCE res;

            res = &_lpNetResource[i];

            OFFSET_TO_POINTER(_lpNetResource, res->lpProvider);
            OFFSET_TO_POINTER(_lpNetResource, res->lpComment);
            OFFSET_TO_POINTER(_lpNetResource, res->lpLocalName);
            OFFSET_TO_POINTER(_lpNetResource, res->lpRemoteName);

        }

    }

}


//+-------------------------------------------------------------------------
//
//  Method:     CDfsEnumConnectedNode::~CDfsEnumConnectedNode
//
//  Synopsis:   Destructor.
//
//  Returns:    Nothing
//
//--------------------------------------------------------------------------
CDfsEnumConnectedNode::~CDfsEnumConnectedNode()
{

    if (_lpNetResource != (LPNETRESOURCE) _buffer && _lpNetResource != NULL) {

        delete _lpNetResource;

    }

}


//+-------------------------------------------------------------------------
//
//  Method:     CDfsEnumConnectedNode::Init
//
//  Synopsis:   Do the actual enumeration here
//
//  Returns:    Nothing
//
//--------------------------------------------------------------------------
DWORD
CDfsEnumConnectedNode::Init(
    VOID
    )
{
    return WN_SUCCESS;
}


//+----------------------------------------------------------------------------
//
//  Method:     CDfsEnumConnectedNode::PackString
//
//  Synopsis:   Packs a string into the end of a buffer, returning a pointer
//              to where the string was put.
//
//  Arguments:  [pBuffer] -- The Buffer to stuff into.
//
//              [wszString] -- The string to stuff.
//
//              [cbString] -- Size, in bytes of wszString, including
//                      terminating NULL, if any.
//
//              [lpcbBuf] -- On entry, contains size in bytes of pBuffer. On
//                      return, this size is decremented by cbString.
//
//  Returns:    Pointer (into pBuffer) where wszString was stuffed.
//
//-----------------------------------------------------------------------------

inline LPWSTR
CDfsEnumConnectedNode::PackString(
    IN LPVOID pBuffer,
    IN LPCWSTR wszString,
    IN DWORD cbString,
    IN OUT LPDWORD lpcbBuf)
{
    LPWSTR wszDest;

    ASSERT( cbString <= *lpcbBuf );
    ASSERT( cbString != 0 );

    wszDest = (LPWSTR) ( ((LPBYTE)pBuffer) + *lpcbBuf - cbString);

    MoveMemory( (PVOID) wszDest, wszString, cbString );

    (*lpcbBuf) -= cbString;

    return( wszDest );

}

//+-------------------------------------------------------------------------
//
//  Method:     CDfsEnumConnectedNode::GetNetResource
//
//  Synopsis:   Returns a single NETRESOURCE for a CONNECTED resource.
//
//  Returns:    Same error codes as WNetEnumResources.
//
//--------------------------------------------------------------------------

DWORD
CDfsEnumConnectedNode::GetNetResource(
    LPVOID  lpBuffer,
    LPDWORD lpBufferSize
    )
{
    DWORD               cbRes, cbLocal, cbRemote, cbComment, cbProvider;
    LPNETRESOURCE       res, dest;

    //
    // This call retrieves the next CONNECTED Resource from the list retrieved
    // in the constructor.
    //

    //
    // See if we are done
    //

    if (_iNext == _cTotal) {
        return( WN_NO_MORE_ENTRIES );
    }

    if (_lpNetResource == NULL) {
        return( ERROR_NOT_ENOUGH_MEMORY );
    }

    //
    // We have entries to return, so lets try to.
    //

    ASSERT(_iNext < _cTotal);

    res = &_lpNetResource[_iNext];

    //
    // First, determine the size of the strings and the total NETRESOURCE
    // to see if it will fit in the provided buffer.
    //

    cbLocal = cbRemote = cbComment = cbProvider = 0;

    if (res->lpLocalName) {
        cbLocal = (wcslen(res->lpLocalName) + 1) * sizeof(WCHAR);
    }

    if (res->lpRemoteName) {
        cbRemote = (wcslen(res->lpRemoteName) + 1) * sizeof(WCHAR);
    }

    if (res->lpComment) {
        cbComment = (wcslen(res->lpComment) + 1) * sizeof(WCHAR);
    }

    if (res->lpProvider) {
        cbProvider = (wcslen(res->lpProvider) + 1) * sizeof(WCHAR);
    }

    cbRes = sizeof(NETRESOURCE) + cbLocal + cbRemote + cbComment + cbProvider;

    if (cbRes > *lpBufferSize) {

        *lpBufferSize = cbRes;

        return( WN_MORE_DATA );
    }

    //
    // Ok, looks like this NETRESOURCE will fit. Stuff it into the user
    // buffer, packing strings at the end of the buffer
    //

    dest = (LPNETRESOURCE) lpBuffer;

    *dest = *res;

    if (res->lpProvider) {
        dest->lpProvider = PackString(
                                lpBuffer,
                                res->lpProvider,
                                cbProvider,
                                lpBufferSize);
    }

    if (res->lpComment) {
        dest->lpComment = PackString(
                                lpBuffer,
                                res->lpComment,
                                cbComment,
                                lpBufferSize);
    }

    if (res->lpRemoteName) {
        dest->lpRemoteName = PackString(
                                lpBuffer,
                                res->lpRemoteName,
                                cbRemote,
                                lpBufferSize);
    }

    if (res->lpLocalName) {
        res->lpLocalName = PackString(
                                lpBuffer,
                                res->lpLocalName,
                                cbLocal,
                                lpBufferSize);
    }

    //
    // Update our own records to indicate that we successfully returned one
    // more NETRESOURCE ...
    //

    _iNext++;

    //
    // And return.
    //

    return( WN_SUCCESS );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\shell\h\winlocal.h ===
/*****************************************************************/
/**                      Microsoft Windows NT                   **/
/**            Copyright(c) Microsoft Corp., 1989-1992          **/
/*****************************************************************/

/*
 *      Windows/Network Interface  --  LAN Manager Version
 *
 *      Insert typedef which is excluded from netlib.h when the
 *      OS2_INCLUDED switch is included.  OS2_INCLUDED is necessary
 *      to avoid a redefinition of BYTE.  For this reason, to include
 *      the str[...]f functions, include the following lines:
 *           #include "winlocal.h"
 *           #define OS2_INCLUDED
 *           #include <netlib.h>
 *           #undef OS2_INCLUDED
 *      Note, that winlocal.h must be included before netlib.h.
 *
 *      History:
 *          terryk      08-Nov-1991 change ErrorPopup's WORD to UINT
 *          chuckc      12-Dec-1991 move error message defines elsewhere,
 *                                  misc cleanup.
 *          Yi-HsinS    31-Dec-1991 Unicode work - move string literals
 *                                  defines to strchlit.hxx
 *          beng        21-Feb-1992 Relocate some BMIDs to focusdlg.h
 *          beng        04-Aug-1992 Move resource IDs into official range;
 *                                  dialog IDs return to here
 */

#ifndef _WINLOCAL_H_
#define _WINLOCAL_H_

#ifndef RC_INVOKED

#ifdef __cplusplus
extern "C" {
#endif

/*
 * Error Functions
 */
void SetNetError ( APIERR err );
APIERR GetNetErrorCode ();
UINT MapError( APIERR usNetErr );

#ifdef __cplusplus
}
#endif

/*
 * Manifests used to modify win.ini  - now lives in strchlit.hxx
 */
#include <strchlit.hxx>         // Must include before PROFILE_BUFFER_SIZE
#define PROFILE_BUFFER_SIZE     (max( sizeof(PROFILE_YES_STRING), \
                                      sizeof(PROFILE_NO_STRING)) +1)

/*
 * MAX_TEXT_SIZE defines the maximum length of several of the
 * above strings used several files
 */
#define MAX_TEXT_SIZE              208

/*
 * Convenient macros
 */
#define UNREFERENCED(x)  ((void)(x))


#endif //!RC_INVOKED

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\shell\enum\enumnode.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    ENUMNODE.CXX
        This file contains the implementation of
            NPOpenEnum        - open a resource handle
            NPEnumResource    - walk through all the resource
            NPCloseEnum       - end of walk through

    FILE HISTORY:
        terryk  12-Nov-91       Created
        terryk  18-Nov-91       Code review changed. Attend: chuckc
                                johnl davidhov terryk
        terryk  10-Dec-91       Fixed DOMAIN_ENUMNODE bug
        terryk  10-Dec-91       Added server name in front of the sharename
        terryk  28-Dec-91       changed DWORD to UINT
        terryk  03-Jan-92       Capitalize Resource_XXX manifest and
                                add lpProvider field to NetResource
        Yi-HsinS 3-Jan-92       Unicode work
        terryk  10-Jan-92       Don't return resource with remotename
                                ended with '$'
        JohnL   02-Apr-92       Added support for returning the required
                                buffer size if WN_MORE_DATA is returned
        Johnl   29-Jul-92       Added backup support when buffer fills up
        AnirudhS 22-Mar-95      Added CONTEXT_ENUMNODE
        MilanS  15-Mar-96       Added Dfs functionality
        jschwart 16-Mar-99      Added RESOURCE_SHAREABLE
*/

#define INCL_WINDOWS
#define INCL_DOSERRORS
#define INCL_NETERRORS
#define INCL_NETCONS
#define INCL_NETMESSAGE
#define INCL_NETUSE
#define INCL_NETACCESS          // NetPasswordSet declaration
#define INCL_NETCONFIG
#define INCL_NETREMUTIL
#define INCL_NETSHARE
#define INCL_NETSERVER
#define INCL_NETSERVICE
#define INCL_NETLIB
#define _WINNETWK_
#include <lmui.hxx>
#undef _WINNETWK_

#include <winnetwk.h>
#include <winnetp.h>
#include <npapi.h>
#include <wnetenum.h>
#include <winlocal.h>

#include <lmobj.hxx>
#include <lmoshare.hxx>
#include <lmoesh.hxx>
#include <lmoeuse.hxx>
#include <lmodev.hxx>
#include <lmosrv.hxx>
#include <lmoesrv.hxx>
#include <lmsvc.hxx>
#include <uibuffer.hxx>
#include <uitrace.hxx>
#include <uiassert.hxx>
#include <array.hxx>
#include <string.hxx>
#include <strchlit.hxx>  // for string and character literals
#include <wnetenum.hxx>


/*******************************************************************

    Global variables

********************************************************************/

DEFINE_ARRAY_OF( PNET_ENUMNODE )

NET_ENUM_HANDLE_TABLE   *vpNetEnumArray;

/*******************************************************************

    NAME:       NET_ENUM_HANDLE_TABLE::NET_ENUM_HANDLE_TABLE

    SYNOPSIS:   constructor

    ENTRY:      UINT cNumEntry - number of elements in the array

    HISTORY:
                terryk  05-Nov-91       Created

********************************************************************/

NET_ENUM_HANDLE_TABLE::NET_ENUM_HANDLE_TABLE( UINT cNumEntry )
    : _cNumEntry     ( cNumEntry ),
      _apNetEnumArray( cNumEntry )
{
    if ( _apNetEnumArray.QueryCount() != cNumEntry )
    {
        ReportError( ERROR_NOT_ENOUGH_MEMORY );
    }
    else
    {
        for ( UINT i = 0 ; i < cNumEntry ; i++ )
        {
            _apNetEnumArray[i] = NULL ;
        }
    }
}

/*******************************************************************

    NAME:       NET_ENUM_HANDLE_TABLE::~NET_ENUM_HANDLE_TABLE

    SYNOPSIS:   destructor

    NOTES:      It will destroy all the elements in the array.

    HISTORY:
                terryk  05-Nov-91       Created

********************************************************************/

NET_ENUM_HANDLE_TABLE::~NET_ENUM_HANDLE_TABLE()
{
    for ( UINT i=0; i < _cNumEntry; i++ )
    {
        NET_ENUMNODE * ptmp = _apNetEnumArray[i];
        delete ptmp ;
        _apNetEnumArray[i] = NULL;
    }

}
/*******************************************************************

    NAME:       NET_ENUM_HANDLE_TABLE::QueryNextAvail

    SYNOPSIS:   return the next available slot in the array

    RETURNS:    if the return value is -1, then no slot is available.

    HISTORY:
                terryk  05-Nov-91       Created

********************************************************************/

INT NET_ENUM_HANDLE_TABLE::QueryNextAvail()
{
    // find the next available slot
    for ( UINT i=0; i < _cNumEntry; i++ )
    {
        if ( _apNetEnumArray[i] == NULL )
        {
            return  i;
        }
    }
    return -1;
}


/*******************************************************************

    NAME:       NET_ENUM_HANDLE_TABLE::QueryNode

    SYNOPSIS:   return the NET_ENUMNODE in the specified slot

    ENTRY:      UINT iIndex - slot index

    RETURNS:    NET_ENUMNODE * - return the pointer to the element in
                                the array

    NOTES:      It will check whether the given handle is out of range
                or not

    HISTORY:
                terryk  05-Nov-91       Created

********************************************************************/

NET_ENUMNODE * NET_ENUM_HANDLE_TABLE::QueryNode( UINT iIndex ) const
{
    NET_ENUMNODE * pnetenumnode = NULL ;
    if ( IsValidHandle( iIndex ))
    {
        pnetenumnode = _apNetEnumArray[ iIndex ] ;
    }
    else
    {
        // the index is either out of range or the index position is NULL
        TRACEEOL( "NET_ENUM_HANDLE_TABLE::QueryNode: invalid handle" );
    }
    return pnetenumnode ;
}

/*******************************************************************

    NAME:       NET_ENUM_NODE::SetNode

    SYNOPSIS:   set the slot in the array to the given element

    ENTRY:      UINT iIndex - slot index
                NET_ENUMNODE * pNetEnumNode - pointer to the element to
                                                be stored.

    HISTORY:
                terryk  05-Nov-91       Created

********************************************************************/

VOID NET_ENUM_HANDLE_TABLE::SetNode( UINT iIndex, NET_ENUMNODE *pNetEnumNode )
{
    if ( IsValidRange( iIndex ))
    {
        _apNetEnumArray[ iIndex ] = pNetEnumNode;
    }
    else
    {
        // the index is out of range
        UIASSERT( FALSE );
    }

}

/*******************************************************************

    NAME:       NET_ENUM_HANDLE_TABLE::ClearNode

    SYNOPSIS:   delete the node object and free up the memory

    ENTRY:      UINT iIndex - index location

    HISTORY:
                terryk  12-Nov-91       Created

********************************************************************/

VOID NET_ENUM_HANDLE_TABLE::ClearNode( UINT iIndex )
{
    if ( IsValidRange( iIndex ))
    {
        if ( _apNetEnumArray[ iIndex ] == NULL )
        {
            // the node is empty
            UIASSERT( FALSE )
        }
        else
        {
            NET_ENUMNODE * ptmp = _apNetEnumArray[iIndex];
            delete ptmp ;
            _apNetEnumArray[iIndex] = NULL;
        }
    }
    else
    {
        // out of range
        UIASSERT( FALSE );
    }

}

/*******************************************************************

    NAME:       NET_ENUMNODE::NET_ENUMNODE

    SYNOPSIS:   enumeration node constructor

    ENTRY:      UINT dwScope - the scope
                UINT dwType - type of the node
                UINT dwUsage - usage
                LPNETRESOURCE lpNetResource - pointer to the resource structure

    HISTORY:
                terryk  24-Oct-91       Created

********************************************************************/

NET_ENUMNODE::NET_ENUMNODE( UINT dwScope, UINT dwType, UINT dwUsage,
    const LPNETRESOURCE lpNetResource )
    : BASE(),
    _dwType( dwType ),
    _dwScope( dwScope ),
    _dwUsage( dwUsage ),
    _lpNetResource( lpNetResource ),
    _fFirstGetInfo( TRUE )
{
}

NET_ENUMNODE::~NET_ENUMNODE()
{
    /* Nothing to do
     */
}

/*******************************************************************

    NAME:       NET_ENUMNODE::PackString

    SYNOPSIS:   pack the string to the end of the buffer

    ENTRY:      BYTE * pBuf - beginning of the buffer
                UINT &cbBufSize - orginial buffer size in BYTE
                TCHAR * pszString - the string to be copied

    EXIT:       UINT &cbBufSize - the new bufsize - the string size

    RETURNS:    the location of the new string inside the buffer

    HISTORY:
                terryk  31-Oct-91       Created

********************************************************************/

TCHAR * NET_ENUMNODE::PackString(BYTE * pBuf, UINT *cbBufSize,
    const TCHAR * pszString )
{
    UINT cStrLen = (::strlenf( pszString ) + 1) * sizeof( TCHAR );
    UIASSERT( cStrLen < *cbBufSize );

    TCHAR *pszLoc =(TCHAR *)(( pBuf )+ ((*cbBufSize)- cStrLen ));
    ::strcpyf( pszLoc, pszString );
    *cbBufSize -=(  cStrLen );
    return pszLoc;
}

/*******************************************************************

    NAME:       SHARE_ENUMNODE::SHARE_ENUMNODE

    SYNOPSIS:   constructor

    ENTRY:      UINT dwScope - the scope
                UINT dwType - type of the node
                UINT dwUsage - usage
                LPNETRESOURCE lpNetResource - pointer to the resource structure

    NOTE:       lpNetResource must not be NULL

    HISTORY:
                terryk   05-Nov-91       Created
                jschwart 16-Mar-99       Added support for RESOURCE_SHAREABLE

********************************************************************/

SHARE_ENUMNODE::SHARE_ENUMNODE( UINT dwScope, UINT dwType, UINT
    dwUsage, const LPNETRESOURCE lpNetResource )
     : NET_ENUMNODE( dwScope, dwType, dwUsage, lpNetResource ),
     _ShareEnum( lpNetResource->lpRemoteName ),
     _pShareIter( NULL )
{
    if (QueryError() == NERR_Success && _ShareEnum.QueryError() != NERR_Success)
    {
        ReportError(_ShareEnum.QueryError());
    }
}

/*******************************************************************

    NAME:       SHARE_ENUMNODE::~SHARE_ENUMNODE

    SYNOPSIS:   destructor

    HISTORY:
                terryk  05-Nov-91       Created

********************************************************************/

SHARE_ENUMNODE::~SHARE_ENUMNODE()
{
    delete _pShareIter;
    _pShareIter = NULL;
}

/*******************************************************************

    NAME:       SHARE_ENUMNODE::GetInfo

    SYNOPSIS:   Get the Share enum info and create the share enum
                interator

    RETURNS:    APIERR - NERR_Success for success. Failure otherwise.

    HISTORY:
                terryk  05-Nov-91       Created

********************************************************************/

APIERR SHARE_ENUMNODE::GetInfo()
{
    APIERR err = _ShareEnum.GetInfo();
    if ( err != NERR_Success )
    {
        return err;
    }

    if ( _pShareIter != NULL )
    {
        delete _pShareIter;
        _pShareIter = NULL;
    }

    _pShareIter = new SHARE1_ENUM_ITER ( _ShareEnum );
    if ( _pShareIter == NULL )
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    SetFirstTime();
    return NERR_Success;
}

/*******************************************************************

    NAME:       SHARE_ENUMNODE::GetNetResource

    SYNOPSIS:   construct a NetResource data object and store it in the
                buffer

    ENTRY:      BYTE *pBuffer - beginning of the buffer
                UINT *pdwBufferSize - the current buffer size

    EXIT:       UINT *pdwBufferSize - the orginial buffer size minus
                the string size allocated during construction

    RETURNS:    UINT - WN_SUCCESS for success. Failure otherwise

    HISTORY:
                terryk  05-Nov-91       Created
                terryk  10-Dec-91       Added ServerName in front of the
                                        share name
                beng    06-Apr-92       Remove wsprintf

********************************************************************/

#define DOLLAR_CHAR     TCH('$')

UINT SHARE_ENUMNODE::GetNetResource( BYTE *pBuffer, UINT *pdwBufferSize)
{
    APIERR err = GetLMProviderName();
    if (err != WN_SUCCESS)
        return err;

    if ( QueryUsage() == RESOURCEUSAGE_CONTAINER )
    {
        // if the net usage is a container, return no more entries
        // becuase share cannot have child level
        return WN_NO_MORE_ENTRIES;
    }

    const SHARE1_ENUM_OBJ *pseo1;
    while ( TRUE )
    {
        for ( pseo1 = (*_pShareIter)(); pseo1 != NULL; pseo1 = (*_pShareIter)())
        {
            if (( QueryType() == RESOURCETYPE_ANY ) ||
                (( pseo1->QueryResourceType() == STYPE_DISKTREE ) &&
                (( QueryType() & RESOURCETYPE_DISK ))) ||
                (( pseo1->QueryResourceType() == STYPE_PRINTQ ) &&
                (( QueryType() & RESOURCETYPE_PRINT ))))
            {
                // break the for loop if we find the matched share object
                break;
            }

        }
        if ( pseo1 == NULL )
        {
            return WN_NO_MORE_ENTRIES;
        }

        ALIAS_STR nlsRemoteName = pseo1->QueryName();
        ISTR istrRemoteName( nlsRemoteName );
        istrRemoteName += nlsRemoteName.QueryTextLength() - 1;

        if (QueryScope() != RESOURCE_SHAREABLE)
        {
            if (nlsRemoteName.QueryChar (istrRemoteName ) != DOLLAR_CHAR)
            {
                // We're looking for non-shareable resource and this is
                // a non-shareable resource

                break;
            }
        }
        else
        {
            if (nlsRemoteName.QueryChar( istrRemoteName ) == DOLLAR_CHAR
                 &&
                wcslen(nlsRemoteName) == 2)
            {
                // We're looking for shareable resources and this is
                // a shareable resource (ends in $ and is a drive
                // letter + $ (e.g., C$, D$, etc.) )

                break;
            }
        }
    }

    UINT  cbShareLength = (::strlenf(pseo1->QueryName()) +
                           ::strlenf(_ShareEnum.QueryServer())) * sizeof(TCHAR);

    UINT  cbMinBuffSize = sizeof( NETRESOURCE ) + cbShareLength +
                           (::strlenf( pseo1->QueryComment()) +
                           ::strlenf( pszNTLanMan ) + 4) * sizeof( TCHAR ) ;

    //
    // Add in the backslash and NULL character
    //

    cbShareLength += sizeof(PATHSEP_STRING);

    if ( *pdwBufferSize < cbMinBuffSize )
    {
        *pdwBufferSize = cbMinBuffSize ;
        _pShareIter->Backup() ;
        return WN_MORE_DATA;
    }

    LPNETRESOURCE pNetResource = (LPNETRESOURCE) pBuffer;
    pNetResource->dwScope = RESOURCE_GLOBALNET;

    if ( pseo1->QueryResourceType() == STYPE_DISKTREE )
    {
        pNetResource->dwType = RESOURCETYPE_DISK;
    }
    else if ( pseo1->QueryResourceType() == STYPE_PRINTQ )
    {
        pNetResource->dwType = RESOURCETYPE_PRINT;
    }
    else
    {
        pNetResource->dwType = RESOURCETYPE_ANY;
    }

    pNetResource->lpLocalName = NULL;
    pNetResource->dwDisplayType = RESOURCEDISPLAYTYPE_SHARE ;

    LPTSTR pszName = (LPTSTR) LocalAlloc(LMEM_FIXED, cbShareLength);

    if (pszName == NULL)
    {
        _pShareIter->Backup();
        return WN_OUT_OF_MEMORY;
    }

    ::strcpyf(pszName, _ShareEnum.QueryServer());
    ::strcatf(pszName, PATHSEP_STRING);
    ::strcatf(pszName, pseo1->QueryName());

    pNetResource->lpRemoteName = PackString((BYTE *)pNetResource,
        pdwBufferSize, pszName );
    pNetResource->lpComment = PackString((BYTE *)pNetResource,
        pdwBufferSize, pseo1->QueryComment() );
    pNetResource->lpProvider = PackString((BYTE *)pNetResource,
        pdwBufferSize, pszNTLanMan );
    pNetResource->dwUsage = RESOURCEUSAGE_CONNECTABLE;

    LocalFree(pszName);

    return WN_SUCCESS;
}

/*******************************************************************

    NAME:       SERVER_ENUMNODE::SERVER_ENUMNODE

    SYNOPSIS:   constructor

    ENTRY:      UINT dwScope - the scope
                UINT dwType - type of the node
                UINT dwUsage - usage
                LPNETRESOURCE lpNetResource - pointer to the resource structure

    NOTE:       lpNetResource must not be NULL

    HISTORY:
                terryk  05-Nov-91       Created

********************************************************************/

SERVER_ENUMNODE::SERVER_ENUMNODE( UINT dwScope, UINT dwType, UINT
    dwUsage, const LPNETRESOURCE lpNetResource )
    : NET_ENUMNODE( dwScope, dwType, dwUsage, lpNetResource ),
    _ServerEnum( NULL, lpNetResource->lpRemoteName ),
    _pServerIter( NULL )
{
    if (QueryError() == NERR_Success && _ServerEnum.QueryError() != NERR_Success)
    {
        ReportError(_ServerEnum.QueryError());
    }
}

/*******************************************************************

    NAME:       SERVER_ENUMNODE::~SERVER_ENUMNODE

    SYNOPSIS:   destructor

    HISTORY:
                terryk  05-Nov-91       Created

********************************************************************/

SERVER_ENUMNODE::~SERVER_ENUMNODE()
{
    delete _pServerIter;
    _pServerIter = NULL;
}

/*******************************************************************

    NAME:       SERVER_ENUMNODE::GetInfo

    SYNOPSIS:   Get the Share enum info and create the share enum
                interator

    RETURNS:    APIERR - NERR_Success for success. Failure otherwise.

    HISTORY:
                terryk  05-Nov-91       Created

********************************************************************/

APIERR SERVER_ENUMNODE::GetInfo()
{
    APIERR err = _ServerEnum.GetInfo();
    if ( err != NERR_Success )
    {
        if (err == WN_MORE_DATA)
        {
            // This is a workaround for a browser design limitation.
            // If the browse server is pre-NT 4.0 it can return an
            // incomplete enumeration with a status of ERROR_MORE_DATA.
            // Treat this as a success.
            err = WN_SUCCESS;
        }
        else
        {
            return err;
        }
    }

    if ( _pServerIter != NULL )
    {
        delete _pServerIter;
        _pServerIter = NULL;
    }
    _pServerIter = new SERVER1_ENUM_ITER( _ServerEnum );
    if ( _pServerIter == NULL )
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    SetFirstTime();
    return NERR_Success;
}

/*******************************************************************

    NAME:       SERVER_ENUMNODE::GetNetResource

    SYNOPSIS:   construct a NetResource data object and store it in the
                buffer

    ENTRY:      BYTE *pBuffer - beginning of the buffer
                UINT *pdwBufferSize - the current buffer size

    EXIT:       UINT *pdwBufferSize - the orginial buffer size minus
                the string size allocated during construction

    RETURNS:    APIERR - WN_SUCCESS for success. Failure otherwise

    HISTORY:
        terryk          05-Nov-91       Created
        Yi-HsinS        12-Nov-92       Filter for print servers

********************************************************************/

// The following lanman version number is the first release that
// the server will announce whether it is a print server or not.
#define LM_MAJOR_VER 2
#define LM_MINOR_VER 1

UINT SERVER_ENUMNODE::GetNetResource( BYTE *pBuffer, UINT *pdwBufferSize)
{
    APIERR err = GetLMProviderName ();
    if (err != WN_SUCCESS)
        return err;

    if ( QueryUsage() == RESOURCEUSAGE_CONNECTABLE )
    {
        return WN_NO_MORE_ENTRIES;
    }

    const SERVER1_ENUM_OBJ *pseo1 = NULL;
    for ( pseo1 = (*_pServerIter)(); pseo1 != NULL; pseo1 = (*_pServerIter)() )
    {
         if ( QueryType() != RESOURCETYPE_PRINT )
             break;

         UINT svType     = pseo1->QueryServerType();
         UINT svMajorVer = pseo1->QueryMajorVer();
         UINT svMinorVer = pseo1->QueryMinorVer();

         // RESOURCETYPE_PRINT only
         if (  (  ( svMajorVer > LM_MAJOR_VER )
               || (  ( svMajorVer == LM_MAJOR_VER )
                  && ( svMinorVer >= LM_MINOR_VER )
                  )
               )
            && ( svType & SV_TYPE_PRINTQ_SERVER )
            )
         {
              break;
         }
    }

    if ( pseo1 == NULL )
    {
        return WN_NO_MORE_ENTRIES;
    }

    STACK_NLS_STR(astrRemoteName, MAX_PATH + 1 );
    astrRemoteName = SERVER_INIT_STRING ;
    astrRemoteName.strcat( pseo1->QueryName());
    if ( astrRemoteName.QueryError() != NERR_Success )
    {
        // probably out of memory
        return WN_OUT_OF_MEMORY;
    }

    UINT  cbMinBuffSize = ( sizeof( NETRESOURCE ) +
                            astrRemoteName.QueryTextSize() +
                            (::strlenf( pszNTLanMan ) +
                             ::strlenf( pseo1->QueryComment() ) + 2 )
                            * sizeof(TCHAR)) ;
    if ( *pdwBufferSize < cbMinBuffSize )
    {
        *pdwBufferSize = cbMinBuffSize ;
        _pServerIter->Backup() ;
        return WN_MORE_DATA;
    }
    LPNETRESOURCE pNetResource = (LPNETRESOURCE) pBuffer;
    pNetResource->dwScope = RESOURCE_GLOBALNET;
    pNetResource->dwType = QueryType();
    pNetResource->dwDisplayType = RESOURCEDISPLAYTYPE_SERVER ;
    pNetResource->lpLocalName = NULL;

    pNetResource->lpRemoteName = PackString((BYTE *)pNetResource,
        pdwBufferSize, astrRemoteName.QueryPch());
    pNetResource->lpComment = PackString((BYTE *)pNetResource,
        pdwBufferSize, pseo1->QueryComment() );
    pNetResource->lpProvider = PackString(( BYTE *) pNetResource,
        pdwBufferSize, pszNTLanMan );
    pNetResource->dwUsage = RESOURCEUSAGE_CONTAINER;

    return WN_SUCCESS;
}

/*******************************************************************

    NAME:       CONTEXT_ENUMNODE::CONTEXT_ENUMNODE

    SYNOPSIS:   constructor

    ENTRY:      UINT dwScope - the scope
                UINT dwType - type of the node
                UINT dwUsage - usage
                LPNETRESOURCE lpNetResource - pointer to the resource structure

    NOTE:       lpNetResource must not be NULL

    HISTORY:
                anirudhs 22-Mar-1995    Created from SERVER_ENUMNODE

********************************************************************/

CONTEXT_ENUMNODE::CONTEXT_ENUMNODE( UINT dwScope, UINT dwType, UINT
    dwUsage, const LPNETRESOURCE lpNetResource )
    : NET_ENUMNODE( dwScope, dwType, dwUsage, lpNetResource ),
    _ServerEnum(
        (dwScope == RESOURCE_CONTEXT && dwType != 0)        // flServerType
            ?
               ((dwType & RESOURCETYPE_DISK)  ? SV_TYPE_SERVER : 0)
               |
               ((dwType & RESOURCETYPE_PRINT) ?
                                    (SV_TYPE_PRINTQ_SERVER | SV_TYPE_WFW) : 0)
            :
               SV_TYPE_ALL
        ),
    _pServerIter( NULL )
{
    if (QueryError() == NERR_Success && _ServerEnum.QueryError() != NERR_Success)
    {
        ReportError(_ServerEnum.QueryError());
    }
}

/*******************************************************************

    NAME:       CONTEXT_ENUMNODE::~CONTEXT_ENUMNODE

    SYNOPSIS:   destructor

    HISTORY:
                anirudhs 22-Mar-1995    Created

********************************************************************/

CONTEXT_ENUMNODE::~CONTEXT_ENUMNODE()
{
    delete _pServerIter;
    _pServerIter = NULL;
}

/*******************************************************************

    NAME:       CONTEXT_ENUMNODE::GetInfo

    SYNOPSIS:   Get the Share enum info and create the share enum
                interator

    RETURNS:    APIERR - NERR_Success for success. Failure otherwise.

    HISTORY:
                anirudhs 22-Mar-1995    Created

********************************************************************/

APIERR CONTEXT_ENUMNODE::GetInfo()
{
    APIERR err = _ServerEnum.GetInfo();
    if ( err != NERR_Success )
    {
        if (err == WN_MORE_DATA)
        {
            // This is a workaround for a browser design limitation.
            // If the browse server is pre-NT 4.0 it can return an
            // incomplete enumeration with a status of ERROR_MORE_DATA.
            // Treat this as a success.
            err = WN_SUCCESS;
        }
        else
        {
            return err;
        }
    }

    if ( _pServerIter != NULL )
    {
        delete _pServerIter;
        _pServerIter = NULL;
    }
    _pServerIter = new CONTEXT_ENUM_ITER( _ServerEnum );
    if ( _pServerIter == NULL )
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    SetFirstTime();
    return NERR_Success;
}

/*******************************************************************

    NAME:       CONTEXT_ENUMNODE::GetNetResource

    SYNOPSIS:   construct a NetResource data object and store it in the
                buffer

    ENTRY:      BYTE *pBuffer - beginning of the buffer
                UINT *pdwBufferSize - the current buffer size

    EXIT:       UINT *pdwBufferSize - the orginial buffer size minus
                the string size allocated during construction

    RETURNS:    APIERR - WN_SUCCESS for success. Failure otherwise

    HISTORY:
                anirudhs 22-Mar-1995    Created from SERVER_ENUMNODE

********************************************************************/

// The following lanman version number is the first release that
// the server will announce whether it is a print server or not.
#define LM_MAJOR_VER 2
#define LM_MINOR_VER 1

UINT CONTEXT_ENUMNODE::GetNetResource( BYTE *pBuffer, UINT *pdwBufferSize)
{
    APIERR err = GetLMProviderName ();
    if (err != WN_SUCCESS)
        return err;

    if ( QueryUsage() == RESOURCEUSAGE_CONNECTABLE )
    {
        return WN_NO_MORE_ENTRIES;
    }

    const CONTEXT_ENUM_OBJ *pseo1 = NULL;
    for ( pseo1 = (*_pServerIter)(); pseo1 != NULL; pseo1 = (*_pServerIter)() )
    {
         if ( QueryType() != RESOURCETYPE_PRINT )
             break;

         UINT svType     = pseo1->QueryServerType();
         UINT svMajorVer = pseo1->QueryMajorVer();
         UINT svMinorVer = pseo1->QueryMinorVer();

         // RESOURCETYPE_PRINT only
         if (  (  ( svMajorVer > LM_MAJOR_VER )
               || (  ( svMajorVer == LM_MAJOR_VER )
                  && ( svMinorVer >= LM_MINOR_VER )
                  )
               )
            && ( svType & SV_TYPE_PRINTQ_SERVER )
            )
         {
              break;
         }
    }

    if ( pseo1 == NULL )
    {
        return WN_NO_MORE_ENTRIES;
    }

    STACK_NLS_STR(astrRemoteName, MAX_PATH + 1 );
    astrRemoteName = SERVER_INIT_STRING ;
    astrRemoteName.strcat( pseo1->QueryName());
    if ( astrRemoteName.QueryError() != NERR_Success )
    {
        // probably out of memory
        return WN_OUT_OF_MEMORY;
    }

    UINT  cbMinBuffSize = ( sizeof( NETRESOURCE ) +
                            astrRemoteName.QueryTextSize() +
                            (::strlenf( pszNTLanMan ) +
                             ::strlenf( pseo1->QueryComment() ) + 2 )
                            * sizeof(TCHAR)) ;
    if ( *pdwBufferSize < cbMinBuffSize )
    {
        *pdwBufferSize = cbMinBuffSize ;
        _pServerIter->Backup() ;
        return WN_MORE_DATA;
    }
    LPNETRESOURCE pNetResource = (LPNETRESOURCE) pBuffer;
    pNetResource->dwScope = RESOURCE_GLOBALNET;
    pNetResource->dwType = QueryType();
    pNetResource->dwDisplayType = RESOURCEDISPLAYTYPE_SERVER ;
    pNetResource->lpLocalName = NULL;

    pNetResource->lpRemoteName = PackString((BYTE *)pNetResource,
        pdwBufferSize, astrRemoteName.QueryPch());
    pNetResource->lpComment = PackString((BYTE *)pNetResource,
        pdwBufferSize, pseo1->QueryComment() );
    pNetResource->lpProvider = PackString(( BYTE *) pNetResource,
        pdwBufferSize, pszNTLanMan );
    pNetResource->dwUsage = RESOURCEUSAGE_CONTAINER;

    return WN_SUCCESS;
}

/*******************************************************************

    NAME:       USE_ENUMNODE::USE_ENUMNODE

    SYNOPSIS:   constructor

    ENTRY:      UINT dwScope - the scope
                UINT dwType - type of the node
                UINT dwUsage - usage
                LPNETRESOURCE lpNetResource - pointer to the resource structure

    HISTORY:
                terryk  05-Nov-91       Created

********************************************************************/

USE_ENUMNODE::USE_ENUMNODE( UINT dwScope, UINT dwType, UINT dwUsage,
    const LPNETRESOURCE lpNetResource )
    : NET_ENUMNODE( dwScope, dwType, dwUsage, lpNetResource ),
    _UseEnum( NULL ),
    _pUseIter( NULL ),
    _dfsEnum( dwScope, dwType, dwUsage, pszNTLanMan, lpNetResource )
{
    if (QueryError() == NERR_Success && _UseEnum.QueryError() != NERR_Success)
    {
        ReportError(_UseEnum.QueryError());
    }
}

/*******************************************************************

    NAME:       USE_ENUMNODE::~USE_ENUMNODE

    SYNOPSIS:   destructor

    HISTORY:
                terryk  05-Nov-91       Created

********************************************************************/

USE_ENUMNODE::~USE_ENUMNODE()
{
    delete _pUseIter;
    _pUseIter = NULL;
}

/*******************************************************************

    NAME:       USE_ENUMNODE::GetInfo

    SYNOPSIS:   Get the use enum info and create the use enum
                interator

    RETURNS:    APIERR - NERR_Success for success. Failure otherwise.

    HISTORY:
                terryk  05-Nov-91       Created
                Yi-HsinS 9-Jun-92       Use USE1_ENUM

********************************************************************/

APIERR USE_ENUMNODE::GetInfo()
{
    APIERR err = _UseEnum.GetInfo();
    if ( err != NERR_Success )
        return err;

    if ( _pUseIter != NULL )
    {
        delete _pUseIter;
    }

    _pUseIter = new USE1_ENUM_ITER( _UseEnum );
    if ( _pUseIter == NULL )
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    SetFirstTime();
    return NERR_Success;
}

/*******************************************************************

    NAME:       USE_ENUMNODE::GetNetResource

    SYNOPSIS:   construct a NetResource data object and store it in the
                buffer

    ENTRY:      BYTE *pBuffer - beginning of the buffer
                UINT *pdwBufferSize - the current buffer size

    EXIT:       UINT *pdwBufferSize - the orginial buffer size minus
                the string size allocated during construction

    RETURNS:    UINT - WN_SUCCESS for success. Failure otherwise

    HISTORY:
                terryk  05-Nov-91       Created

********************************************************************/

UINT USE_ENUMNODE::GetNetResource( BYTE *pBuffer, UINT *pdwBufferSize)
{
    APIERR err = GetLMProviderName ();

    if (err != WN_SUCCESS)
        return err;

    err = _dfsEnum.GetNetResource(pBuffer, (LPDWORD) pdwBufferSize);
    if (err != WN_NO_MORE_ENTRIES ) {
        return( err );
    }

    if ( QueryUsage() == RESOURCEUSAGE_CONTAINER )
    {
        // if it is CONTAINER, it cannot have used device
        return WN_NO_MORE_ENTRIES;
    }

    const USE1_ENUM_OBJ *pueo1 = NULL;

    for ( pueo1 = (*_pUseIter)(); pueo1 != NULL; pueo1 = (*_pUseIter)() )
    {
         UINT uiResourceType = pueo1->QueryResourceType();

         if (  ( QueryType() == RESOURCETYPE_ANY )
               //&& (  ( uiResourceType == USE_DISKDEV )
               //   || ( uiResourceType == USE_SPOOLDEV)))
            || (  ( QueryType() & RESOURCETYPE_DISK )
               && ( uiResourceType == USE_DISKDEV ))
            || (  ( QueryType() & RESOURCETYPE_PRINT )
               && ( uiResourceType == USE_SPOOLDEV ))
            )
         {
            if (  ( pueo1->QueryRefCount() != 0 )
               || ( pueo1->QueryUseCount() != 0 )
               || (QueryType() == RESOURCETYPE_ANY)
               )
            {
                break;
            }
         }
    }

    if ( pueo1 == NULL )
    {
        return WN_NO_MORE_ENTRIES;
    }

    UINT cbMinBuffSize;
    BOOL fDeviceLess;

    if (  ( pueo1->QueryLocalDevice() != NULL )
       && ( ::strlenf( pueo1->QueryLocalDevice()) != 0 )
       )
    {
        cbMinBuffSize =  sizeof( NETRESOURCE )+
                                 (::strlenf( pueo1->QueryLocalDevice()) +
                                  ::strlenf( pueo1->QueryRemoteResource()) +
                                  ::strlenf( pszNTLanMan ) + 3 )
                                  * sizeof( TCHAR ) ;
        fDeviceLess = FALSE;
    }
    else
    {
        cbMinBuffSize =  sizeof( NETRESOURCE )+
                                 (::strlenf( pueo1->QueryRemoteResource()) +
                                  ::strlenf( pszNTLanMan ) + 2 )
                                  * sizeof( TCHAR ) ;
        fDeviceLess = TRUE;
    }

    if ( *pdwBufferSize < cbMinBuffSize )
    {
        *pdwBufferSize = cbMinBuffSize ;
        _pUseIter->Backup() ;
        return WN_MORE_DATA;
    }

    LPNETRESOURCE pNetResource = (LPNETRESOURCE) pBuffer;
    pNetResource->lpRemoteName = PackString((BYTE *) pNetResource,
            pdwBufferSize, pueo1->QueryRemoteResource());

    pNetResource->dwScope       = RESOURCE_CONNECTED;
    pNetResource->dwDisplayType = RESOURCEDISPLAYTYPE_GENERIC;

    if (pueo1->QueryResourceType() == USE_DISKDEV)
    {
        pNetResource->dwType        = RESOURCETYPE_DISK;
        pNetResource->dwDisplayType = RESOURCEDISPLAYTYPE_SHARE;
    }
    else if (pueo1->QueryResourceType() == USE_SPOOLDEV)
    {
        pNetResource->dwType        = RESOURCETYPE_PRINT;
        pNetResource->dwDisplayType = RESOURCEDISPLAYTYPE_SHARE;
    }
    else
    {
        pNetResource->dwType = RESOURCETYPE_UNKNOWN;
    }

    if ( fDeviceLess )
    {
        pNetResource->lpLocalName = NULL;
    }
    else
    {
        pNetResource->lpLocalName = PackString((BYTE *)pNetResource,
                                    pdwBufferSize, pueo1->QueryLocalDevice());
    }

    /* Unfortunately we don't get the comment when we do a device
     * enumeration, so we will just set a null comment for now.
     */
    pNetResource->lpComment = NULL;
    pNetResource->lpProvider = PackString(( BYTE * ) pNetResource,
        pdwBufferSize, pszNTLanMan );
    pNetResource->dwUsage = 0;

    return WN_SUCCESS;
}

/*******************************************************************

    NAME:       DOMAIN_ENUMNODE::DOMAIN_ENUMNODE

    SYNOPSIS:   constructor

    ENTRY:      UINT dwScope - the scope
                UINT dwType - type of the node
                UINT dwUsage - usage
                LPNETRESOURCE lpNetResource - pointer to the resource structure

    HISTORY:
                terryk  05-Nov-91       Created
                KeithMo 03-Aug-1992     Now uses new BROWSE_DOMAIN_ENUM
                                        whiz-bang domain enumerator.

********************************************************************/

DOMAIN_ENUMNODE::DOMAIN_ENUMNODE( UINT dwScope, UINT dwType, UINT dwUsage,
    const LPNETRESOURCE lpNetResource )
    : NET_ENUMNODE( dwScope, dwType, dwUsage, lpNetResource ),
    _enumDomains( BROWSE_ALL_DOMAINS ),
    _pbdiNext( NULL )
{
    APIERR err = QueryError();

    if( err == NERR_Success )
    {
        err = _enumDomains.QueryError();

        if( err != NERR_Success )
        {
            ReportError( err );
        }
    }
}

/*******************************************************************

    NAME:       DOMAIN_ENUMNODE::GetInfo

    SYNOPSIS:   Get the local domain info

    RETURNS:    APIERR - NERR_Success for success. Failure otherwise.

    HISTORY:
                terryk  05-Nov-91       Created
                KeithMo 03-Aug-1992     Now uses new BROWSE_DOMAIN_ENUM
                                        whiz-bang domain enumerator.

********************************************************************/

APIERR DOMAIN_ENUMNODE::GetInfo()
{
    // We don't bother working around the browser design limitation
    // in this case

    SetFirstTime();
    return NERR_Success;
}

/*******************************************************************

    NAME:       DOMAIN_ENUMNODE::GetNetResource

    SYNOPSIS:   construct a NetResource data object and store it in the
                buffer

    ENTRY:      BYTE *pBuffer - beginning of the buffer
                UINT *pdwBufferSize - the current buffer size

    EXIT:       UINT *pdwBufferSize - the orginial buffer size minus
                the string size allocated during construction

    RETURNS:    UINT - WN_SUCCESS for success. Failure otherwise

    HISTORY:
                terryk  05-Nov-91       Created
                KeithMo 03-Aug-1992     Now uses new BROWSE_DOMAIN_ENUM
                                        whiz-bang domain enumerator.

********************************************************************/

UINT DOMAIN_ENUMNODE::GetNetResource( BYTE *pBuffer, UINT *pdwBufferSize)
{

    APIERR err = GetLMProviderName ();
    if (err != WN_SUCCESS)
        return err;

    //
    //  Let's see if there are any more domains in the enumerator.
    //

    if( _pbdiNext == NULL )
    {
        _pbdiNext = _enumDomains.Next();

        if( _pbdiNext == NULL )
        {
            return WN_NO_MORE_ENTRIES;
        }
    }

    //
    //  Calculate the minimum buffer requirements.
    //

    UINT cbMinBuffSize = sizeof( NETRESOURCE) +
                         ( ::strlenf( _pbdiNext->QueryDomainName() ) +
                           ::strlenf( pszNTLanMan ) + 2 ) * sizeof(TCHAR);

    if( *pdwBufferSize < cbMinBuffSize )
    {
        *pdwBufferSize = cbMinBuffSize;
        return WN_MORE_DATA;
    }

    //
    //  Save the data for the current domain.
    //

    LPNETRESOURCE pNetRes = (LPNETRESOURCE)pBuffer;

    pNetRes->lpRemoteName  = PackString( (BYTE *)pNetRes,
                                         pdwBufferSize,
                                         _pbdiNext->QueryDomainName() );
    pNetRes->lpComment     = NULL;
    pNetRes->lpLocalName   = NULL;
    pNetRes->dwScope       = RESOURCE_GLOBALNET;
    pNetRes->dwType        = 0;
    pNetRes->dwDisplayType = RESOURCEDISPLAYTYPE_DOMAIN;
    pNetRes->dwUsage       = RESOURCEUSAGE_CONTAINER;
    pNetRes->lpProvider    = PackString( (BYTE *)pNetRes,
                                         pdwBufferSize,
                                         pszNTLanMan );

    _pbdiNext = NULL;

    //
    //  Success!
    //

    return WN_SUCCESS;
}

/*******************************************************************

    NAME:       EMPTY_ENUMNODE::EMPTY_ENUMNODE

    SYNOPSIS:   constructor

    ENTRY:      UINT dwScope - the scope
                UINT dwType - type of the node
                UINT dwUsage - usage
                LPNETRESOURCE lpNetResource - pointer to the resource structure

    NOTE:       lpNetResource must not be NULL

    HISTORY:
                chuckc  01-Aug-92       Created

********************************************************************/

EMPTY_ENUMNODE::EMPTY_ENUMNODE( UINT dwScope, UINT dwType, UINT
    dwUsage, const LPNETRESOURCE lpNetResource )
    : NET_ENUMNODE( dwScope, dwType, dwUsage, lpNetResource )
{
}

/*******************************************************************

    NAME:       EMPTY_ENUMNODE::~EMPTY_ENUMNODE

    SYNOPSIS:   destructor

    HISTORY:
                chuckc  01-Aug-92       Created

********************************************************************/

EMPTY_ENUMNODE::~EMPTY_ENUMNODE()
{
}

/*******************************************************************

    NAME:       EMPTY_ENUMNODE::GetInfo

    SYNOPSIS:   Get the Share enum info and create the share enum
                interator

    RETURNS:    APIERR - NERR_Success for success. Failure otherwise.

    HISTORY:
                chuckc  01-Aug-92       Created

********************************************************************/

APIERR EMPTY_ENUMNODE::GetInfo()
{
    SetFirstTime();
    return NERR_Success;
}

/*******************************************************************

    NAME:       EMPTY_ENUMNODE::GetNetResource

    SYNOPSIS:   construct a NetResource data object and store it in the
                buffer

    ENTRY:      BYTE *pBuffer - beginning of the buffer
                UINT *pdwBufferSize - the current buffer size

    EXIT:       UINT *pdwBufferSize - the orginial buffer size minus
                the string size allocated during construction

    RETURNS:    APIERR - WN_SUCCESS for success. Failure otherwise

    HISTORY:
                chuckc  01-Aug-92       Created

********************************************************************/

UINT EMPTY_ENUMNODE::GetNetResource( BYTE *pBuffer, UINT *pdwBufferSize)
{
    UNREFERENCED( pBuffer ) ;
    UNREFERENCED( pdwBufferSize ) ;
    return WN_NO_MORE_ENTRIES;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\shell\enum\wnetenum.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    WNETENUM.CXX
        This file contains the implementation of
            NPOpenEnum          - open a resource enumeration handle
            NPEnumResource      - walk through all the resource
            NPCloseEnum         - end of walk through

    FILE HISTORY:
        terryk  27-Sep-91       Created
        terryk  01-Nov-91       WIN32 conversion
        terryk  08-Nov-91       Code review changes
        terryk  18-Nov-91       Split to 2 files - wnetenum.cxx and
                                enumnode.cxx
        terryk  10-Dec-91       check parameters in WNetOpenEnum
        terryk  28-Dec-91       changed DWORD to UINT
        Yi-HsinS31-Dec-91       Unicode work
        terryk  03-Jan-92       Capitalize the Resource_XXX manifest
        terryk  10-Jan-92       Returned WN_SUCCESS if the buffer is too
                                small for 1 entry.
*/

#define INCL_WINDOWS
#define INCL_DOSERRORS
#define INCL_NETERRORS
#define INCL_NETCONS
#define INCL_NETUSE
#define INCL_NETWKSTA
#define INCL_NETACCESS          // NetPasswordSet declaration
#define INCL_NETCONFIG
#define INCL_NETREMUTIL
#define INCL_NETSHARE
#define INCL_NETSERVER
#define INCL_NETSERVICE
#define INCL_NETLIB
#define INCL_ICANON
#define _WINNETWK_
#include <lmui.hxx>
#undef _WINNETWK_

#define INCL_BLT_WINDOW
#include <blt.hxx>
#include <dbgstr.hxx>

#include <winnetwk.h>
#include <winnetp.h>
#include <npapi.h>
#include <wnetenum.h>
#include <winlocal.h>
#include <mnet.h>

#include <lmobj.hxx>
#include <lmoshare.hxx>
#include <lmoesh.hxx>
#include <lmoeuse.hxx>
#include <lmodev.hxx>
#include <lmosrv.hxx>
#include <lmowks.hxx>
#include <lmoesrv.hxx>
#include <lmsvc.hxx>
#include <uibuffer.hxx>
#include <uitrace.hxx>
#include <uiassert.hxx>
#include <uatom.hxx>
#include <regkey.hxx>
#include <array.hxx>
#include <string.hxx>
#include <strchlit.hxx> // for SERVER_INIT_STRING
#include <miscapis.hxx>
#include <wnetenum.hxx>

//
//  Macros for rounding a value up/down to a TCHAR boundary.
//  Note:  These macros assume that sizeof(TCHAR) is a power of 2.
//

#define ROUND_DOWN(x)   ((x) & ~(sizeof(TCHAR) - 1))
#define ROUND_UP(x)     (((x) + sizeof(TCHAR) - 1) & ~(sizeof(TCHAR) - 1))


/*******************************************************************

    Global variables

********************************************************************/

#define ARRAY_SIZE      64

extern NET_ENUM_HANDLE_TABLE    *vpNetEnumArray;

/* Winnet locking handle
 */
HANDLE vhSemaphore ;

/* Name of the provider
 */
const TCHAR * pszNTLanMan = NULL ;

#define LM_WKSTA_NODE           SZ("System\\CurrentControlSet\\Services\\LanmanWorkstation\\NetworkProvider")
#define LM_PROVIDER_VALUE_NAME  SZ("Name")


/*******************************************************************

    NAME:       InitWNetEnum

    SYNOPSIS:   Initialize the Enum handle array

    RETURN:     APIERR - it will return ERROR_OUT_OF_MEMORY if it does
                        not have enough space

    HISTORY:
                terryk     24-Oct-91       Created
                davidhov   20-Oct-92       updated REG_KEY usage

********************************************************************/

APIERR InitWNetEnum()
{
    TRACEEOL( "NTLANMAN.DLL: InitWNetEnum()" );
    vpNetEnumArray = new NET_ENUM_HANDLE_TABLE( ARRAY_SIZE );
    if ( vpNetEnumArray == NULL )
    {
        DBGEOL( "NTLANMAN.DLL: InitWNetEnum() ERROR_NOT_ENOUGH_MEMORY" );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    APIERR err = vpNetEnumArray->QueryError();

    if ( !err )
    {
        if ( (vhSemaphore = ::CreateSemaphore( NULL, 1, 1, NULL )) == NULL)
        {
            err = ::GetLastError() ;
            DBGEOL( "NTLANMAN.DLL: InitWNetEnum() semaphore error " << err );
        }
    }
    return err ;
}

/********************************************************************
    NAME:       GetLMProviderName

    SYNOPSIS:   Get Provider Name into the global variable pszNTLanMan

    RETURN:     APIERR - it will return ERROR_OUT_OF_MEMORY if it does
                        not have enough space

    HISTORY:
                congpay     14-Dec-92       Created
 ********************************************************************/
APIERR GetLMProviderName()
{
    if (pszNTLanMan)
    {
        return NERR_Success;
    }

    APIERR err = NERR_Success;
    REG_KEY *pRegKeyFocusServer = NULL;

    do { // error breakout
        /* Traverse the registry and get the list of computer alert
         * names.
         */
        pRegKeyFocusServer = REG_KEY::QueryLocalMachine();

        if (  ( pRegKeyFocusServer == NULL ) ||
              ((err = pRegKeyFocusServer->QueryError())) )
        {
            err = err? err : ERROR_NOT_ENOUGH_MEMORY ;
            break ;
        }

        ALIAS_STR nlsRegKeyName( LM_WKSTA_NODE ) ;
        REG_KEY regkeyLMProviderNode( *pRegKeyFocusServer, nlsRegKeyName );
        REG_KEY_INFO_STRUCT regKeyInfo;
        REG_VALUE_INFO_STRUCT regValueInfo ;

        if (  (err = regkeyLMProviderNode.QueryError())             ||
              (err = regkeyLMProviderNode.QueryInfo( &regKeyInfo ))   )
        {
            break ;
        }

        BUFFER buf( (UINT) regKeyInfo.ulMaxValueLen ) ;
        regValueInfo.nlsValueName = LM_PROVIDER_VALUE_NAME ;
        if ( (err = buf.QueryError() ) ||
             (err = regValueInfo.nlsValueName.QueryError()) )
        {
            break;
        }

        regValueInfo.pwcData = buf.QueryPtr();
        regValueInfo.ulDataLength = buf.QuerySize() ;

        if ( (err = regkeyLMProviderNode.QueryValue( &regValueInfo )))
        {
            break;
        }

        /* Null terminate the computer list string we just retrieved from
         * the registry.
         */
        TCHAR * pszProviderName = (TCHAR *)( buf.QueryPtr() +
                                                  regValueInfo.ulDataLengthOut -
                                                  sizeof(TCHAR) );
        *pszProviderName = TCH('\0') ;
        ALIAS_STR nlsComputerList( (TCHAR *) buf.QueryPtr()) ;

        pszNTLanMan = new TCHAR[ nlsComputerList.QueryTextSize() ] ;
        if ( pszNTLanMan == NULL )
        {
            err = ERROR_NOT_ENOUGH_MEMORY ;
            break ;
        }

        nlsComputerList.CopyTo( (TCHAR *) pszNTLanMan,
                                nlsComputerList.QueryTextSize()) ;
    } while (FALSE) ;

    delete pRegKeyFocusServer ;

    return err;
}

/*******************************************************************

    NAME:       TermWNetEnum

    SYNOPSIS:   clear up the Enum handle array

    HISTORY:
                terryk  24-Oct-91       Created

********************************************************************/

VOID TermWNetEnum()
{
    TRACEEOL( "NTLANMAN.DLL: TermWNetEnum()" );
    delete vpNetEnumArray;
    vpNetEnumArray = NULL;
    REQUIRE( ::CloseHandle( vhSemaphore ) ) ;
    vhSemaphore = NULL ;
    delete (void *) pszNTLanMan ;
    pszNTLanMan = NULL ;
}

/*******************************************************************

    NAME:       NPOpenEnum

    SYNOPSIS:   Create a new Enum handle

    ENTRY:      UINT dwScope - determine the scope of the enumeration.
                    This can be one of:
                    RESOURCE_CONNECTED - all currently connected resource
                    RESOURCE_GLOBALNET - all resources on the network
                    RESOURCE_CONTEXT - resources in the user's current
                        and default network context
                UINT dwType - used to specify the type of resources of
                    interest. This is a bitmask which may be any
                    combination of:
                    RESOURCETYPE_DISK - all disk resources
                    RESOURCETYPE_PRINT - all print resources
                    If this is 0, all types of resources are returned.
                    If a provider does not have the capability to
                    distinguish between print and disk resources at a
                    level, it may return all resources.
                UINT dwUsage - Used to specify the usage of resources
                    of interested. This is a bitmask which may be any
                    combination of:
                    RESOURCEUSAGE_CONNECTABLE - all connectable
                    resources
                    RESOURCEUSAGE_CONTAINER - all container resources
                    The bitmask may be 0 to match all.
                    RESOURCEUSAGE_ATTACHED - signifies that the function
                    should fail if the caller is not authenticated (even
                    if the network allows enumeration without authenti-
                    cation).
                    This parameter is ignored if dwScope is not
                    RESOURCE_GLOBALNET.
                NETRESOURCE * lpNetResource - This specifies the
                    container to perform the enumeration. The
                    NETRESOURCE must have been obtained via
                    NPEnumResource( and must have the
                    RESOURCEUSAGE_Connectable bit set ), or NULL. If it
                    is NULL,the logical root of the network is assumed.
                    An application would normally start off by calling
                    NPOpenEnum with this parameter set to NULL, and
                    then use the returned results for further
                    enumeration. If dwScope is RESOURCE_CONNECTED, this
                    must be NULL.
                    If dwScope is RESOURCE_CONTEXT, this is ignored.
                HANDLE * lphEnum - If function call is successful, this
                    will contain a handle that can then be used for
                    NPEnumResource.

    EXIT:       HANDLE * lphEnum - will contain the handle number

    RETURNS:    WN_SUCCESS if the call is successful. Otherwise,
                GetLastError should be called for extended error
                information. Extened error codes include:
                    WN_NOT_CONTAINER - lpNetResource does not point to a
                    container
                    WN_BAD_VALUE - Invalid dwScope or dwUsage or dwType,
                    or bad combination of parameters is specified
                    WN_NOT_NETWORK - network is not present
                    WN_NET_ERROR - a network specific error occured.
                    WNetGetLastError should be called to obtain further
                    information.

    HISTORY:
                terryk  24-Oct-91       Created
                Johnl   06-Mar-1992     Added Computer validation check
                                        on container enumeration
                JohnL   03-Apr-1992     Fixed dwUsage == CONNECTED|CONTAINER
                                        bug (would return WN_BAD_VALUE)
                ChuckC  01-Aug-1992     Simplified, corrected and commented
                                        the messy cases wrt to dwUsage.
                AnirudhS 03-Mar-1995    Added support for RESOURCE_CONTEXT
                AnirudhS 26-Apr-1996    Simplified, corrected and commented
                                        the messy cases wrt dwScope.

********************************************************************/

DWORD APIENTRY
NPOpenEnum(
    UINT            dwScope,
    UINT            dwType,
    UINT            dwUsage,
    LPNETRESOURCE   lpNetResource,
    HANDLE        * lphEnum )
{
    UIASSERT( lphEnum != NULL );

    APIERR err ;
    if ( err = CheckLMService() )
        return err ;

    if ( dwType & ~( RESOURCETYPE_DISK | RESOURCETYPE_PRINT ) )
    {
        return WN_BAD_VALUE;
    }

    NET_ENUMNODE *pNetEnum;

    if ( dwScope == RESOURCE_CONNECTED )
    {
        /*
         * we are looking for current uses
         */
        if ( lpNetResource != NULL )
        {
            return WN_BAD_VALUE;
        }

        err = GetLMProviderName();
        if (err)
            return(err);

        pNetEnum = new USE_ENUMNODE( dwScope, dwType, dwUsage, lpNetResource );
    }
    else if ( dwScope == RESOURCE_CONTEXT )
    {
        /*
         * we are looking for servers in the domain
         * Note that lpNetResource is ignored
         * dwType is decoded in the CONTEXT_ENUMNODE constructor
         */
        pNetEnum = new CONTEXT_ENUMNODE( dwScope, dwType, dwUsage, NULL );
    }
    else if ( dwScope == RESOURCE_SHAREABLE )
    {
        /*
         * We are looking for shareable resources
         * Use SHARE_ENUMNODE, which decodes dwScope when it enumerates
         * If we're not given a server, return an EMPTY_ENUMNODE
         */
         if (lpNetResource != NULL
              &&
             lpNetResource->lpRemoteName != NULL
              &&
             lpNetResource->lpRemoteName[0] == TCH('\\')
              &&
             lpNetResource->lpRemoteName[1] == TCH('\\'))
         {
             pNetEnum = new SHARE_ENUMNODE( dwScope, dwType, dwUsage, lpNetResource );
         }
         else
         {
             pNetEnum = new EMPTY_ENUMNODE( dwScope, dwType, dwUsage, lpNetResource );
         }
    }
    else if ( dwScope == RESOURCE_GLOBALNET )
    {
        /* Look for the combination of all bits and substitute "All" for
         * them.  Ignore bits we don't know about.
         * Note: RESOURCEUSAGE_ATTACHED is a no-op for us, since LanMan
         * always tries to authenticate when doing an enumeration.
         */
        dwUsage &= (RESOURCEUSAGE_CONNECTABLE | RESOURCEUSAGE_CONTAINER);

        if ( dwUsage == (RESOURCEUSAGE_CONNECTABLE | RESOURCEUSAGE_CONTAINER) )
        {
            dwUsage = 0 ;
        }

        /*
         * we are looking for global resources out on the net
         */
        if ( lpNetResource == NULL || lpNetResource->lpRemoteName == NULL)
        {
            /*
             * at top level, therefore enumerating domains. if user
             * asked for connectable, well, there aint none.
             */
            if ( dwUsage == RESOURCEUSAGE_CONNECTABLE )
            {
                pNetEnum = new EMPTY_ENUMNODE( dwScope,
                                               dwType,
                                               dwUsage,
                                               lpNetResource );
            }
            else
            {
                pNetEnum = new DOMAIN_ENUMNODE( dwScope,
                                                dwType,
                                                dwUsage,
                                                lpNetResource );
            }
        }
        else
        {
            /*
             * we are assured of lpRemoteName != NULL.
             * things get interesting here. the cases are as follows:
             *
             * if (dwUsage == 0)
             *     if have \\ in front
             *         return shares
             *     else
             *         return servers
             * else if (dwUsage == CONNECTABLE)
             *     if have \\ in front
             *         return shares
             *     else
             *         empty enum
             * else if (dwUsage == CONTAINER)
             *     if have \\ in front
             *         empty enum
             *     else
             *         return server
             *
             * In interest of code size, i've reorganized the above
             * cases to minimized the bodies of the ifs.
             *
             * chuckc.
             */

            if ( ((dwUsage == RESOURCEUSAGE_CONNECTABLE) ||
                  (dwUsage == 0)
                 )
                 &&
                 ((lpNetResource->lpRemoteName[0] == TCH('\\')) &&
                  (lpNetResource->lpRemoteName[1] == TCH('\\'))
                 )
               )
            {
                /* Confirm that this really is a computer name (i.e., a
                 * container we can enumerate).
                 */
                if ( ::I_MNetNameValidate( NULL,
                                           &(lpNetResource->lpRemoteName[2]),
                                           NAMETYPE_COMPUTER,
                                           0L))
                {
                    return WN_BAD_VALUE ;
                }

                pNetEnum = new SHARE_ENUMNODE( dwScope, dwType, dwUsage,
                    lpNetResource );
            }
            else if ( ((dwUsage == RESOURCEUSAGE_CONTAINER) ||
                       (dwUsage == 0)
                      )
                      &&
                      (lpNetResource->lpRemoteName[0] != TCH('\\'))
                    )
            {
                pNetEnum = new SERVER_ENUMNODE( dwScope, dwType, dwUsage,
                                                lpNetResource );
            }
            else if (
                      // ask for share but aint starting from server
                      (
                       (dwUsage == RESOURCEUSAGE_CONNECTABLE)
                       &&
                       (lpNetResource->lpRemoteName[0] != TCH('\\'))
                      )
                      ||
                      // ask for server but is starting from server
                      (
                       (dwUsage == RESOURCEUSAGE_CONTAINER)
                       &&
                       ((lpNetResource->lpRemoteName[0] == TCH('\\')) &&
                        (lpNetResource->lpRemoteName[1] == TCH('\\'))
                       )
                      )
                    )
            {
                pNetEnum = new EMPTY_ENUMNODE( dwScope,
                                               dwType,
                                               dwUsage,
                                               lpNetResource );
            }
            else
            {
                // incorrect dwUsage
                return WN_BAD_VALUE;
            }
        }
    }
    else
    {
        // invalid dwScope
        return WN_BAD_VALUE;
    }

    if ( pNetEnum == NULL )
    {
        return WN_OUT_OF_MEMORY;
    }
    else if ( err = pNetEnum->QueryError() )
    {
        delete pNetEnum;
        return MapError(err);
    }

    if ( pNetEnum->IsFirstGetInfo() )
    {
        if (( err = pNetEnum->GetInfo()) != WN_SUCCESS )
        {
            delete pNetEnum;
            return MapError(err);
        }
    }

    ////////////////////////////////////////// Enter critical section

    if ( err = WNetEnterCriticalSection() )
    {
        delete pNetEnum;
        return err ;
    }

    ASSERT( vpNetEnumArray != NULL );
    INT iPos = vpNetEnumArray->QueryNextAvail();
    if ( iPos < 0 )
    {
        WNetLeaveCriticalSection() ;
        delete pNetEnum;
        return WN_OUT_OF_MEMORY;
    }

    vpNetEnumArray->SetNode( (UINT)iPos, pNetEnum );
    *lphEnum = UintToPtr((UINT)iPos);

    WNetLeaveCriticalSection() ;

    ////////////////////////////////////////// Leave critical section

    return err ;
}

/*******************************************************************

    NAME:       NPEnumResource

    SYNOPSIS:   Perform an enumeration based on handle returned by
                NPOpenEnum.

    ENTRY:      HANDLE hEnum - This must be a handle obtained from
                    NPOpenEnum call
                UINT *lpcRequested - Specifies the number of entries
                    requested. It may be 0xFFFFFFFF to request as many as
                    possible. On successful call, this location will receive
                    the number of entries actually read.
                VOID *lpBuffer - A pointer to the buffer to receive the
                    enumeration result, which are returned as an array
                    of NETRESOURCE entries. The buffer is valid until
                    the next call using hEnum.
                UINT * lpBufferSize - This specifies the size of the
                    buffer passed to the function call.  If WN_MORE_DATA
                    is returned and no entries were enumerated, then this
                    will be set to the minimum buffer size required.

    EXIT:       UINT *lpcRequested - will receive the number of entries
                    actually read.

    RETURNS:    WN_SUCCESS if the call is successful, the caller should
                    continue to call NPEnumResource to continue the
                    enumeration.
                WN_NO_MORE_ENTRIES - no more entries found, the
                enumeration completed successfully ( the contents of the
                return buffer is undefined). Otherwise, GetLastError
                should be called for extended error information.
                Extended error codes include:
                    WN_MORE_DATA - the buffer is too small even for one
                    entry
                    WN_BAD_HANDLE - hEnum is not a valid handle
                    WN_NOT_NETWORK - network is not present. This
                    condition is checked for before hEnum is tested for
                    validity.
                    WN_NET_ERROR - a network specific error occured.
                    WNetGetLastError should be called to obtain further
                    information.

    HISTORY:
                terryk  24-Oct-91       Created
                KeithMo 15-Sep-92       Align *lpcBufferSize as needed.

********************************************************************/

DWORD APIENTRY
NPEnumResource(
    HANDLE  hEnum,
    UINT *  lpcRequested,
    LPVOID  lpBuffer,
    UINT *  lpcBufferSize )
{
    APIERR err ;

    if (( lpBuffer == NULL      ) ||
        ( lpcRequested == NULL  ) ||
        ( lpcBufferSize == NULL ))
    {
        return WN_BAD_VALUE;
    }

    if ( err = WNetEnterCriticalSection() )
    {
        return err ;
    }

    ASSERT( vpNetEnumArray != NULL );
    NET_ENUMNODE *pNode = vpNetEnumArray->QueryNode(PtrToUint(hEnum));
    WNetLeaveCriticalSection() ;

    if ( pNode == NULL )
    {
        return WN_BAD_HANDLE;
    }
    else if ( pNode->IsFirstGetInfo() )
    {
        if ( err = CheckLMService() )
        {
            return err ;
        }
        if (( err = pNode->GetInfo()) != WN_SUCCESS )
        {
            return ( MapError(err) );
        }
    }

    LPNETRESOURCE pNetResource = ( LPNETRESOURCE ) lpBuffer;
    UINT cbRemainSize = ROUND_DOWN(*lpcBufferSize);

    UINT cRequested = (*lpcRequested);
    *lpcRequested = 0;
    while ( *lpcRequested < cRequested )
    {
        err = pNode->GetNetResource((BYTE *)pNetResource, &cbRemainSize );

        if ( err == WN_MORE_DATA )
        {
            /* If we can't even fit one into the buffer, then set the required
             * buffer size and return WN_MORE_DATA.
             */
            if ( *lpcRequested == 0 )
            {
                *lpcBufferSize = ROUND_UP(cbRemainSize);
            }
            else
            {
                err = NERR_Success ;
            }

            break;
        }

        if ( err == WN_NO_MORE_ENTRIES )
        {
            if ( *lpcRequested != 0 )
            {
                err = NERR_Success ;
            }

            break;
        }

        if ( err != WN_SUCCESS )
        {
            break ;
        }

        /* err == WN_SUCCESS
         */

        (*lpcRequested) ++;

        if ( sizeof( NETRESOURCE ) > cbRemainSize )
        {
            break ;
        }

        pNetResource ++;
        cbRemainSize -= (UINT)sizeof( NETRESOURCE );
    }

    return err ;
}

/*******************************************************************

    NAME:       NPCloseEnum

    SYNOPSIS:   Closes an enumeration.

    ENTRY:      HANDLE hEnum - this must be a handle obtained from
                NPOpenEnum call.

    RETURNS:    WN_SUCCESS if the call is successful. Otherwise,
                GetLastError should be called for extended error information.
                Extended error codes include:
                WN_NO_NETWORK - network is not present. this condition is
                checked for before hEnum is tested for validity.
                WN_BAD_HANDLE - hEnum is not a valid handle.
                WN_NET_ERROR - a network specific error occured.
                WNetGetLastError should be called to obtain further
                information.

    HISTORY:
                terryk  24-Oct-91       Created

********************************************************************/

DWORD APIENTRY
NPCloseEnum(
    HANDLE  hEnum )
{
    APIERR err ;
    if ( err = WNetEnterCriticalSection() )
    {
        return err ;
    }

    ASSERT( vpNetEnumArray != NULL );
    NET_ENUMNODE *pNode = vpNetEnumArray->QueryNode(PtrToUint(hEnum));
    if ( pNode == NULL )
    {
        // cannot find the node

        err = WN_BAD_HANDLE;
    }
    else
    {
        vpNetEnumArray->ClearNode(PtrToUint(hEnum));
    }

    WNetLeaveCriticalSection() ;
    return err ;
}


/*******************************************************************

    NAME:       WNetEnterCriticalSection

    SYNOPSIS:   Locks the LM network provider enumeration code

    EXIT:       vhSemaphore will be locked

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:      We wait for 7 seconds for the semaphonre to be freed

    HISTORY:
        Johnl   27-Apr-1992     Created

********************************************************************/

APIERR WNetEnterCriticalSection( void )
{
    APIERR err = NERR_Success ;
    switch( WaitForSingleObject( vhSemaphore, 7000L ))
    {
    case 0:
        break ;

    case WAIT_TIMEOUT:
        err = WN_FUNCTION_BUSY ;
        break ;

    case 0xFFFFFFFF:
        err = ::GetLastError() ;
        break ;

    default:
        UIASSERT(FALSE) ;
        err = WN_WINDOWS_ERROR ;
        break ;
    }

    return err ;
}

/*******************************************************************

    NAME:       WNetLeaveCriticalSection

    SYNOPSIS:   Unlocks the enumeration methods

    RETURNS:

    NOTES:

    HISTORY:
        Johnl   27-Apr-1992     Created

********************************************************************/

void WNetLeaveCriticalSection( void )
{
    REQUIRE( ReleaseSemaphore( vhSemaphore, 1, NULL ) ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\shell\h\wnetenum.h ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    wnetenum.h
	WNETEnum initialize and terminate functions

    FILE HISTORY:
	terryk	01-Nov-91	Created
	terryk	08-Nov-91	InitWNetEnum return APIERR

*/
#ifdef __cplusplus
extern "C" {
#endif

extern APIERR InitWNetEnum();
extern VOID TermWNetEnum();

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\shell\h\wnetshar.h ===
/**********************************************************************/
/**			  Microsoft Windows/NT			                           **/
/**		   Copyright(c) Microsoft Corp., 1992                       **/
/**********************************************************************/

/*
    wnetshare.h
	 WNetShare initialize and terminate functions

    FILE HISTORY:
	 CongpaY	12-Aug-92	Created
*/

#ifdef __cplusplus
extern "C" {
#endif

extern APIERR InitWNetShare();
extern VOID TermWNetShare();

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\shell\h\wndebug.h ===
/*****************************************************************/ 
/**		     Microsoft LAN Manager			**/ 
/**	       Copyright(c) Microsoft Corp., 1989-1990		**/ 
/*****************************************************************/ 

/*
 *	Windows/Network Interface  --  LAN Manager Version
 *
 *      History:
 *	    Yi-HsinS	31-Dec-1991 	Unicode work - char to TCHAR 
 */


/*
 *	DEBUGGING TOYS
 */

#ifdef TRACE		/* Trace implies debug */
#ifndef DEBUG
#define DEBUG
#endif
#endif

#ifdef DEBUG
static TCHAR		dbbuf[100];
static TCHAR		dbb1[10];
static TCHAR		dbb2[10];
static TCHAR		dbb3[10];
static TCHAR		dbb4[10];
static TCHAR		dbb5[10];
#endif

#ifdef DEBUG
#ifdef NEVER
#define MESSAGEBOX(s1,s2)  printf(SZ("%s %s\n"),s2,s1)
#else
#define MESSAGEBOX(s1,s2)  MessageBox ( NULL, s1, s2, MB_OK )
#endif
#else
#define MESSAGEBOX(s1,s2)  {}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\shell\shell\dfsutil.cxx ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:       common.cxx
//
//  Contents:   This has the common routines for the DFS provider
//
//  Functions:  DfsOpenp
//              DfsOpenDriverHandle
//              DfsFsctl
//
//  History:    14-June-1994    SudK    Created.
//
//-----------------------------------------------------------------------------
extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
}

#include <dfsfsctl.h>
#include <windows.h>
#include <string.h>
#include <wchar.h>
#include <npapi.h>
#include <lm.h>
#include <dfsutil.hxx>

#define appDebugOut(x)
#define appAssert(x)

#define ARRAYLEN(x) (sizeof(x) / sizeof((x)[0]))

#include <dfsfsctl.h>

static HANDLE g_hDfsFile = NULL;

static UNICODE_STRING DfsDriverObjectName =
{
    sizeof(DFS_DRIVER_NAME) - sizeof(UNICODE_NULL),
    sizeof(DFS_DRIVER_NAME) - sizeof(UNICODE_NULL),
    DFS_DRIVER_NAME
};

//+-------------------------------------------------------------------------
//
//  Function:   DfsOpenp, public
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//--------------------------------------------------------------------------
NTSTATUS
DfsOpenp(
    IN  OUT PHANDLE DfsHandle,
    IN      PUNICODE_STRING DfsName OPTIONAL
)
{
    PFILE_FULL_EA_INFORMATION eaBuffer = NULL;
    ULONG eaLength = 0;
    NTSTATUS status;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatus;
    PUNICODE_STRING name;

    if (ARGUMENT_PRESENT(DfsName))
    {
        name = DfsName;
    }
    else
    {
        name = &DfsDriverObjectName;
    }

    InitializeObjectAttributes(
        &objectAttributes,
        name,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
    );

    status = NtCreateFile(
        DfsHandle,
        SYNCHRONIZE,
        &objectAttributes,
        &ioStatus,
        NULL,
        FILE_ATTRIBUTE_NORMAL,
        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
        FILE_OPEN_IF,
        FILE_CREATE_TREE_CONNECTION | FILE_SYNCHRONOUS_IO_NONALERT,
        eaBuffer,
        eaLength
    );

// BUGBUG: does this do anything? free was unresolved
//     if(eaBuffer)
//         free(eaBuffer);

    if (NT_SUCCESS(status))
    {
        status = ioStatus.Status;
    }

    return status;
}


//+----------------------------------------------------------------------------
//
//  Function:   DfsOpenDriverHandle
//
//  Synopsis:   Opens a handle (for fsctl) to the local dfs driver.
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------
VOID DfsOpenDriverHandle()
{
    if (g_hDfsFile == NULL)
    {
        NTSTATUS status = DfsOpenp(&g_hDfsFile, NULL);
        if (!NT_SUCCESS(status))
        {
            g_hDfsFile = NULL;
        }
    }
}

// call this before unloading
VOID TermDfs()
{
    if (g_hDfsFile != NULL)
    {
        NtClose(g_hDfsFile);
        g_hDfsFile = NULL;
    }
}


//+----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsFsctl(
    IN ULONG FsControlCode,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    OUT PULONG pRequiredLength
)
{
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatus;

    if (!g_hDfsFile)
    {
        //
        // This retry is here mainly to get setup
        // utilities to work. These utilities have "bound" to this dll,
        // and *then* started the Dfs driver. When this dll was loaded,
        // there was no dfs driver to open a handle to. But now, there
        // might be.
        //

        DfsOpenDriverHandle();
        if (!g_hDfsFile)
        {
            return STATUS_OBJECT_NAME_NOT_FOUND;
        }
    }

    status = NtFsControlFile(
        g_hDfsFile,
        NULL,           // Event,
        NULL,           // ApcRoutine,
        NULL,           // ApcContext,
        &ioStatus,
        FsControlCode,
        InputBuffer,
        InputBufferLength,
        OutputBuffer,
        OutputBufferLength );

   if (NT_SUCCESS(status))
   {
       status = ioStatus.Status;
       if (pRequiredLength)
       {
           *pRequiredLength = (ULONG)ioStatus.Information;
       }
   }
   else if (status == STATUS_BUFFER_OVERFLOW)
   {
       if (pRequiredLength)
       {
           *pRequiredLength = *((PULONG) OutputBuffer);
       }
   }

   return status;
}


//+---------------------------------------------------------------------------
//
//  Function:   NewDup
//
//  Synopsis:   Duplicate a string using '::new'
//
//  Arguments:
//
//  Returns:
//
//  History:    28-Dec-94   BruceFo   Created
//
//----------------------------------------------------------------------------

PWSTR
NewDup(
    IN const WCHAR* psz
    )
{
    if (NULL == psz)
    {
        appDebugOut((DEB_IERROR,"Illegal string to duplicate: NULL\n"));
        return NULL;
    }

    PWSTR pszRet = new WCHAR[wcslen(psz) + 1];
    if (NULL == pszRet)
    {
        appDebugOut((DEB_ERROR,"OUT OF MEMORY\n"));
        return NULL;
    }

    wcscpy(pszRet, psz);
    return pszRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   wcsistr
//
//  Synopsis:   Same as wcsstr (find string in string), but case-insensitive
//
//  Arguments:
//
//  Returns:
//
//  History:    2-Feb-95   BruceFo   Created
//
//----------------------------------------------------------------------------

wchar_t*
wcsistr(
    const wchar_t* string1,
    const wchar_t* string2
    )
{
    if ((NULL == string2) || (NULL == string1))
    {
        // do whatever wcsstr would do
        return wcsstr(string1, string2);
    }

    const wchar_t* p1;
    const wchar_t* p2;

    while (*string1)
    {
        for (p1 = string1, p2 = string2;
             *p1 && *p2 && towlower(*p1) == towlower(*p2);
             ++p1, ++p2)
        {
            // nothing
        }

        if (!*p2)
        {
            // we found a match!
            return (wchar_t*)string1;   // cast away const!
        }

        ++string1;
    }

    return NULL;
}

//+---------------------------------------------------------------------
//
//  Function:   IsDfsPath
//
//  Synopsis:   Determine if the path has the form of a DFS path. That is,
//              does it look like "\\foo\DFS", optionally with a "\path\..."
//              appended?
//
//  Arguments:  [lpRemoteName] -- name to check
//
//              [dwUseFlags]   -- the flags supplied by the user
//
//              [lplpSystemPart] -- if return value is TRUE, and this is
//                  non-NULL, then *lplpSystemPart points to the "\path"
//                  part of the Dfs path within lpRemoteName.
//
//
//----------------------------------------------------------------------
BOOL
IsDfsPathEx(
    IN LPWSTR lpRemoteName,
    IN DWORD  dwUseFlags,
    OUT LPWSTR* lplpSystemPart,
    BOOL    fBypassCSC
    )
{
    LPWSTR pT;

    if (!lpRemoteName
        || lpRemoteName[0] != L'\\'
        || lpRemoteName[1] != L'\\'
        || lpRemoteName[2] == L'\0' || lpRemoteName[2] == L'\\'
        )
    {
        return FALSE;
    }
    else if ((pT = wcschr(&lpRemoteName[2], L'\\')) == NULL)
    {
        return FALSE;
    }
    else
    {
        NTSTATUS                 status;
        BOOL                     exists = FALSE;
        PDFS_IS_VALID_PREFIX_ARG pValidPrefixArg;
        USHORT                   RemoteNameLength;

        RemoteNameLength = wcslen(lpRemoteName + 1) * sizeof(WCHAR);

        pValidPrefixArg = (PDFS_IS_VALID_PREFIX_ARG)
                          new BYTE[RemoteNameLength + sizeof(DFS_IS_VALID_PREFIX_ARG)];

        if (pValidPrefixArg != NULL) {
            pValidPrefixArg->RemoteNameLen = RemoteNameLength;
            pValidPrefixArg->CSCAgentCreate = (BOOLEAN)fBypassCSC;

            memcpy(
                &pValidPrefixArg->RemoteName,
                (PBYTE)(lpRemoteName + 1),
                RemoteNameLength);

            status = DfsFsctl(
                        FSCTL_DFS_IS_VALID_PREFIX,
                        pValidPrefixArg,
                        (RemoteNameLength + sizeof(DFS_IS_VALID_PREFIX_ARG)),
                        NULL,
                        0,
                        NULL);

            delete pValidPrefixArg;
        } else {
            status = STATUS_INSUFFICIENT_RESOURCES;
        }

        if (!NT_SUCCESS(status))
        {
            return FALSE;
        }

        pT++;

        while (*pT != UNICODE_NULL && *pT != L'\\')
        {
            pT++;
        }

        if (lplpSystemPart != NULL)
        {
            *lplpSystemPart = pT;
        }
        return TRUE;
    }

}

//+---------------------------------------------------------------------
//
//  Function:   IsDfsPath
//
//  Synopsis:   Determine if the path has the form of a DFS path. That is,
//              does it look like "\\foo\DFS", optionally with a "\path\..."
//              appended?
//
//  Arguments:  [lpRemoteName] -- name to check
//
//              [dwUseFlags]   -- the flags supplied by the user
//
//              [lplpSystemPart] -- if return value is TRUE, and this is
//                  non-NULL, then *lplpSystemPart points to the "\path"
//                  part of the Dfs path within lpRemoteName.
//
//
//----------------------------------------------------------------------
BOOL
IsDfsPath(
    IN LPWSTR lpRemoteName,
    IN DWORD  dwUseFlags,
    OUT LPWSTR* lplpSystemPart
    )
{
    return IsDfsPathEx(lpRemoteName, dwUseFlags, lplpSystemPart, FALSE);
}

//+----------------------------------------------------------------------------
//
//  Function:   IsPureServerShare
//
//  Synopsis:   Determine if the path has the form of \\server\share
//
//  Arguments:  [lpRemoteName] -- name to check
//
//  Returns:    TRUE if lpRemoteName conforms to \\server\share, FALSE
//              otherwise.
//
//-----------------------------------------------------------------------------

BOOL
IsPureServerShare(
    IN LPWSTR lpRemoteName)
{
    LPWSTR lpShareName, lpRemainingPath;

    if (!lpRemoteName
        || lpRemoteName[0] != L'\\'
        || lpRemoteName[1] != L'\\'
        || lpRemoteName[2] == L'\0' || lpRemoteName[2] == L'\\'
        )
    {
        return FALSE;
    }
    else if ((lpShareName = wcschr(&lpRemoteName[2], L'\\')) == NULL)
    {
        return FALSE;
    }
    else if ((lpRemainingPath = wcschr(&lpShareName[1], L'\\')) != NULL)
    {
        return FALSE;
    }

    return TRUE;

}

VOID
StrNCopy(
    OUT LPWSTR pszTarget,
    IN LPCWSTR pszSource,
    IN DWORD cchTarget
    )
{
    DWORD cch = lstrlen(pszSource) + 1;
    cch = min(cch, cchTarget);
    wcsncpy(pszTarget, pszSource, cch - 1);
    pszTarget[cch - 1] = TEXT('\0');

    appDebugOut((DEB_TRACE,"StrNCopy: from %ws to %ws, length %d\n",
        pszSource, pszTarget, cchTarget));
}

/*******************************************************************

    NAME:       PackString

    SYNOPSIS:   pack the string to the end of the buffer

    ENTRY:      LPBYTE pBuf - beginning of the buffer
                LPDWORD pcbBufSize - orginial buffer size in BYTE
                LPTSTR pszString - the string to be copied

    EXIT:       pcbBufSize = the new bufsize - the string size

    RETURNS:    the location of the new string inside the buffer

    HISTORY:
                terryk  31-Oct-91       Created

********************************************************************/

LPTSTR
PackString(LPVOID pBuf, LPDWORD pcbBufSize, LPCTSTR pszString)
{
    DWORD cStrSize = (lstrlen(pszString) + 1) * sizeof(TCHAR);
    appAssert( cStrSize <= *pcbBufSize );
    LPTSTR pszLoc = (LPTSTR)((LPBYTE)pBuf + ((*pcbBufSize) - cStrSize));
    lstrcpy(pszLoc, pszString);
    *pcbBufSize -= cStrSize;
    return pszLoc;
}

/*******************************************************************

    NAME:       PackString3

    SYNOPSIS:   pack 3 strings to the end of the buffer. The strings are
                concatenated.

    ENTRY:      LPBYTE pBuf - beginning of the buffer
                LPDWORD pcbBufSize - orginial buffer size in BYTE
                LPTSTR pszString1 - first string
                LPTSTR pszString2 - second string
                LPTSTR pszString3 - third string

    EXIT:       pcbBufSize = the new bufsize - the string size

    RETURNS:    the location of the new string inside the buffer

    HISTORY:
                terryk  31-Oct-91       Created

********************************************************************/

LPTSTR
PackString3(LPVOID pBuf, LPDWORD pcbBufSize, LPCTSTR pszString1, LPCTSTR pszString2, LPCTSTR pszString3)
{
    DWORD cStrSize = (lstrlen(pszString1) + 1 + lstrlen(pszString2) + 1 + lstrlen(pszString3) + 1) * sizeof(TCHAR);
    appAssert( cStrSize <= *pcbBufSize );
    LPTSTR pszLoc = (LPTSTR)((LPBYTE)pBuf + ((*pcbBufSize) - cStrSize));
    lstrcpy(pszLoc, pszString1);
    lstrcat(pszLoc, pszString2);
    lstrcat(pszLoc, pszString3);
    *pcbBufSize -= cStrSize;
    return pszLoc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\shell\shell\dfsconn.cxx ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:       dfsconn.cxx
//
//  Contents:   This has the connection routines for the DFS provider
//
//  Functions:  NPAddConnection
//              NPCancelConnection
//              NPGetConnection
//              NPGetUser
//
//  History:    14-June-1994    SudK    Created.
//
//-----------------------------------------------------------------------------

extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
}

#include <dfsfsctl.h>
#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <wchar.h>
#include <mpr.h>
#include <npapi.h>
#include <lm.h>

#include <netlibnt.h>

#define appDebugOut(x)

#define ARRAYLEN(x) (sizeof(x) / sizeof((x)[0]))

#define DFS_DEVICE_ORG  L"\\Device\\WinDfs\\Root"

#include <dfsutil.hxx>
#include "dfsconn.hxx"

//+---------------------------------------------------------------------
//
//  Function:   GetDriveLetter
//
//  Synopsis:   From a local name parameter, determine the index of the drive
//              letter. The name should be of the form "x:\path...".
//              Returns -1 if the name is not a drive letter.
//
//  Arguments:
//
//----------------------------------------------------------------------
int
GetDriveLetter(
    LPCWSTR lpName
    )
{
    //
    // some sanity checks
    //
    if (!lpName || !*lpName || *(lpName+1) != L':')
    {
        appDebugOut((DEB_TRACE, "Bad local name %ws\n", lpName));
        return -1;
    }

    //
    // Validate Drive letter.
    //
    int index = towupper(*lpName) - L'A';
    if (index < 0 || index > (L'Z' - L'A'))
    {
        return -1;
    }

    return index;
}

//+---------------------------------------------------------------------
//
//  Function:   NPDfsAddConnection
//
//  Synopsis:   Creates a connection of a drive to a part of the DFS namespace.
//
//  Arguments:  Standard Provider API
//
//  Returns:    [WN_BAD_NETNAME] -- Deferred connection not originally to a
//                      Dfs Share or a non-deferred connection to a non-Dfs
//                      share.
//
//              [WN_BAD_VALUE] -- lpNetResource not understood.
//
//              [WN_BAD_LOCALNAME] -- Specified local drive not valid.
//
//              [WN_ALREADY_CONNECTED] -- Specified local drive already in use
//
//              [WN_BAD_USER] -- Either the person making this call is a
//                      lousy person, or the lpUserName is invalid.
//
//              [WN_WINDOWS_ERROR] -- DefineDosDevice failed.
//
//              [WN_NET_ERROR] -- Unable to connect to remote name
//
//              [WN_ACCESS_DENIED] -- While connecting to remote name
//
//              [WN_BAD_PASSWORD] -- The supplied (or default, if none was
//                      supplied) didn't work.
//
//              [WN_OUT_OF_MEMORY] -- Unable to allocate memory for operation
//
//----------------------------------------------------------------------
DWORD APIENTRY
NPDfsAddConnection(
    LPNETRESOURCE   lpNetResource,
    LPWSTR          lpPassword,
    LPWSTR          lpUserName,
    DWORD           dwFlags,
    BOOL            fBypassCSC
    )
{
    NTSTATUS    status;
    DWORD       err = WN_SUCCESS;
    LPWSTR      lpLocalName = NULL;
    DWORD       cchUserName = 0;
    INT         indexOfDomainBackslash;
    UINT        index, indexOfServerBackslash;
    DWORD       drivesMask;
    BYTE        chRestoreFlags;
    BOOL        fDeferred = FALSE, fIsDfsPath=FALSE;

    appDebugOut((DEB_TRACE, "NPAddConnection called\n"));

    if ((dwFlags & CONNECT_DEFERRED) != 0) {

        //
        // We are restoring a persistent connection. See if this was a
        // Dfs connection...
        //

        chRestoreFlags = CONNECT_PROVIDER_FLAGS(dwFlags);

        if ((chRestoreFlags & WNET_ADD_CONNECTION_DFS) == 0) {

            //
            // This is NOT a Dfs connection.
            //

            return( WN_BAD_NETNAME );

        } else {

            fDeferred = TRUE;

        }

    }

    if (!lpNetResource)
    {
        err = WN_BAD_VALUE;
    }
    else if (lpNetResource->dwType & RESOURCETYPE_PRINT)
    {
        //
        // We dont support printers
        //
        err = WN_BAD_VALUE;
    }
    else if (!fDeferred && !(fIsDfsPath = IsDfsPathEx(lpNetResource->lpRemoteName, dwFlags, NULL, fBypassCSC)))
    {
        err = WN_BAD_NETNAME;
    }

    if (err == WN_SUCCESS && lpNetResource->lpLocalName)
    {
        lpLocalName = lpNetResource->lpLocalName;
        index = GetDriveLetter(lpNetResource->lpLocalName);
        if (-1 == index)
        {
            err = WN_BAD_LOCALNAME;
        }
        else
        {
            //
            // Make sure that this drive letter is not in use now.
            //
            drivesMask = GetLogicalDrives();
            if (drivesMask & (1 << index))
            {
                err = WN_ALREADY_CONNECTED;
            }
        }
    }

    indexOfDomainBackslash = -1;

    if (err == WN_SUCCESS && (lpUserName != NULL))
    {
        //
        // Veryify that the user name is of a valid form. Only one backslash
        // allowed, and it can't be the last character.
        //

        cchUserName = wcslen(lpUserName);

        for (DWORD i = 0; i < cchUserName && err == WN_SUCCESS; i++)
        {
            if (lpUserName[i] == L'\\')
            {
                if (indexOfDomainBackslash == -1)
                {
                    indexOfDomainBackslash = i;
                }
                else
                {
                    err = WN_BAD_USER;
                }
            }
        }

        if (indexOfDomainBackslash == (int) (cchUserName-1))
            err = WN_BAD_USER;

    }


    if (err != WN_SUCCESS)
    {
        return err;
    }

    if (err == WN_SUCCESS)
    {
        LPWSTR lpRemoteName = lpNetResource->lpRemoteName;
        PFILE_DFS_DEF_ROOT_CREDENTIALS  buffer = NULL;
        ULONG  i, cbSize, cbPassword, cbRemote;

        cbRemote = (wcslen(lpRemoteName) + 1) * sizeof(WCHAR);

        if (lpPassword != NULL)
            cbPassword = (wcslen(lpPassword) + 1) * sizeof(WCHAR);
        else
            cbPassword = 0;

        //
        // We have to stick in the server name and share name separately,
        // so we double allocate the cbRemote
        //

        cbSize = sizeof(FILE_DFS_DEF_ROOT_CREDENTIALS) +
                    cchUserName * sizeof(WCHAR) +
                        cbPassword +
                            2 * cbRemote;

        buffer = (PFILE_DFS_DEF_ROOT_CREDENTIALS) new BYTE[cbSize];

        if (buffer != NULL)
        {
            buffer->Flags = 0;

            if (fDeferred)
                buffer->Flags |= DFS_DEFERRED_CONNECTION;

            if (lpLocalName != NULL) {
                buffer->LogicalRoot[0] = towupper(lpLocalName[0]);
                buffer->LogicalRoot[1] = UNICODE_NULL;
            } else {
                buffer->LogicalRoot[0] = UNICODE_NULL;
            }

            buffer->Buffer[0] = UNICODE_NULL;

            //
            // Copy the domain name if necessary
            //

            if (indexOfDomainBackslash > 0)
            {
                buffer->DomainNameLen =
                    (USHORT)((indexOfDomainBackslash) * sizeof(WCHAR));
                wcscat(buffer->Buffer, lpUserName);
                buffer->Buffer[ indexOfDomainBackslash ] = UNICODE_NULL;
            }
            else
                buffer->DomainNameLen = 0;

            //
            // Copy the user name if necessary
            //

            if (lpUserName != NULL)
            {
                buffer->UserNameLen = (USHORT)
                    (cchUserName - (indexOfDomainBackslash + 1)) *
                        sizeof(WCHAR);
                wcscat(buffer->Buffer, &lpUserName[indexOfDomainBackslash+1]);
            }
            else
                buffer->UserNameLen = 0;

            //
            // Copy the password if necessary
            //

            if (lpPassword)
            {
                buffer->PasswordLen =
                    (USHORT) (cbPassword - sizeof(UNICODE_NULL));

                wcscat(buffer->Buffer, lpPassword);

                if (buffer->PasswordLen == 0)
                    buffer->Flags |= DFS_USE_NULL_PASSWORD;
            }
            else
                buffer->PasswordLen = 0;

            //
            // Copy the server and share name
            //

            ULONG k = (buffer->DomainNameLen +
                            buffer->UserNameLen +
                                buffer->PasswordLen) / sizeof(WCHAR);

            for (i = 2, buffer->ServerNameLen = 0;
                    lpRemoteName[i] != L'\\';
                        i++, k++) {
                buffer->Buffer[k] = lpRemoteName[i];
                buffer->ServerNameLen += sizeof(WCHAR);
            }

            for (i++, buffer->ShareNameLen = 0;
                    lpRemoteName[i] != UNICODE_NULL &&
                        lpRemoteName[i] != L'\\';
                            i++, k++) {
                 buffer->Buffer[k] = lpRemoteName[i];
                 buffer->ShareNameLen += sizeof(WCHAR);
            }
            buffer->Buffer[k] = UNICODE_NULL;

            //
            // Finally, copy the remote prefix
            //
            buffer->RootPrefixLen = (USHORT) (cbRemote - (2 * sizeof(WCHAR)));
            wcscat(buffer->Buffer, &lpRemoteName[1]);

            appDebugOut((DEB_TRACE, "Setting up root for %ws\n", lpNetResource->lpRemoteName));

            buffer->CSCAgentCreate = (BOOLEAN)fBypassCSC;

            if (err == WN_SUCCESS) {

                status = DfsFsctl(
                            FSCTL_DFS_DEFINE_ROOT_CREDENTIALS,
                            buffer,
                            cbSize,
                            NULL,
                            0,
                            NULL);

                if (!NT_SUCCESS(status))
                {
                    appDebugOut((DEB_TRACE,
                        "unable to create root %08lx\n", status));

                    switch( status ) {

                        //
                        // The following errors can happen under normal
                        // situations.
                        //

                    case STATUS_NETWORK_CREDENTIAL_CONFLICT:
                        err = ERROR_SESSION_CREDENTIAL_CONFLICT;
                        break;

                    case STATUS_ACCESS_DENIED:
                        err = WN_ACCESS_DENIED;
                        break;

                    case STATUS_LOGON_FAILURE:
                    case STATUS_WRONG_PASSWORD:
                    case STATUS_WRONG_PASSWORD_CORE:
                        err = WN_BAD_PASSWORD;
                        break;

                    case STATUS_INSUFFICIENT_RESOURCES:
                        err = WN_OUT_OF_MEMORY;
                        break;

                    case STATUS_OBJECT_NAME_COLLISION:
                        err = WN_ALREADY_CONNECTED;
                        break;

                        //
                        // If someone mounted a non-existing share and then
                        // tries to do a deep net use to it, we'll get
                        // STATUS_BAD_NETNAME from DfsVerifyCredentials in
                        // mup.sys
                        //

                    case STATUS_BAD_NETWORK_PATH:
                        err = WN_BAD_NETNAME;
                        break;

                    default:
                        err = WN_NET_ERROR;
                        break;
                    }

                }
                else
                {
                    appDebugOut((DEB_TRACE,
                        "Successfully created logical root %ws\n",
                        lpNetResource->lpRemoteName));
                }
            }

            delete[] (BYTE*)buffer;
        }
        else
        {
            appDebugOut((DEB_TRACE, "Unable to allocate %d bytes\n", ulSize));
            err = WN_OUT_OF_MEMORY;
        }
    }

    //
    // Lastly we verify that the appropriate object exists (we can get to it).
    // Else we dont allow the connection to be added.
    //
    if (err == ERROR_SUCCESS && !fDeferred) {
	DWORD dwAttr;

	if (lpLocalName != NULL) {
	    WCHAR wszFileName[4];

	    ASSERT(lpLocalName != NULL);

	    wszFileName[0] = lpLocalName[0];
	    wszFileName[1] = L':';
	    wszFileName[2] = L'\\';
	    wszFileName[2] = UNICODE_NULL;

	    dwAttr = GetFileAttributes( wszFileName );
	    if ( (dwAttr == (DWORD)-1) ) {
		err = GetLastError();
	    }
	    else if ( (dwAttr & FILE_ATTRIBUTE_DIRECTORY) == 0) {
	        err = WN_BAD_NETNAME;
	    }
	    if (err != ERROR_SUCCESS) {
		(VOID) NPDfsCancelConnection(lpLocalName, TRUE);
	    }
	}
	else {
	    PWCHAR lpRemoteName = lpNetResource->lpRemoteName;
	    dwAttr = GetFileAttributes( lpRemoteName );

	    if ( (dwAttr == (DWORD)-1) ) {
		err = GetLastError();
	    } 
	    else if ( (dwAttr & FILE_ATTRIBUTE_DIRECTORY) == 0) {
	        err = WN_BAD_NETNAME;
	    }
	    if (err != ERROR_SUCCESS) {
		(VOID) NPDfsCancelConnection(lpRemoteName, TRUE);
	    }
	}
    }


    return err;
}


//+---------------------------------------------------------------------
//
//  Function:   NPDfsCancelConnection
//
//  Synopsis:   Cancels a connection of a drive to a part of the DFS namespace.
//
//  Arguments:  Standard Provider API
//
//----------------------------------------------------------------------
DWORD APIENTRY
NPDfsCancelConnection(
    LPCWSTR lpName,
    BOOL    fForce
    )
{
    NET_API_STATUS              err = WN_SUCCESS;
    NTSTATUS                    status;
    int                         index;
    ULONG                       len, bufsize;
    PFILE_DFS_DEF_ROOT_BUFFER   buffer;

    appDebugOut((DEB_TRACE, "NPCancelConnection called %ws\n", lpName));

    if (lpName == NULL)
    {
        return(WN_BAD_NETNAME);
    }

    len = wcslen(lpName);

    index = GetDriveLetter(lpName);

    if (-1 != index)
    {
        //
        // Drive based path. Make sure its only two characters wide!
        //

        if (len > 2)
        {
            err = WN_BAD_NETNAME;
        }
        else
        {
            bufsize = sizeof(FILE_DFS_DEF_ROOT_BUFFER);
        }
    }
    else
    {
        //
        // Not a drive based path. See if its a UNC path
        //

        if (len >= 2 && lpName[0] == L'\\' && lpName[1] == L'\\')
        {
            bufsize = sizeof(FILE_DFS_DEF_ROOT_BUFFER) +
                        (len + 1) * sizeof(WCHAR);
        }
        else
        {
            err = WN_BAD_NETNAME;
        }
    }

    if (err != WN_SUCCESS)
    {
        return( err );
    }

    buffer = (PFILE_DFS_DEF_ROOT_BUFFER) new BYTE[ bufsize ];

    if (buffer == NULL)
    {
        return( WN_OUT_OF_MEMORY );

    }

    //
    // cancel the connection
    //

    if (-1 != index)
    {
        buffer->LogicalRoot[0] = lpName[0];
        buffer->LogicalRoot[1] = UNICODE_NULL;
//        buffer->RootPrefix[0] = UNICODE_NULL;
    }
    else
    {
        buffer->LogicalRoot[0] = UNICODE_NULL;
        wcscpy(buffer->RootPrefix, &lpName[1]);
    }

    buffer->fForce = (fForce != FALSE);

    appDebugOut((DEB_TRACE, "Deleting root for %wc\n", lpName[0]));

    status = DfsFsctl(
                FSCTL_DFS_DELETE_LOGICAL_ROOT,
                buffer,
                bufsize,
                NULL,
                0,
                NULL);

    delete [] ((BYTE *) buffer);

    if (NT_SUCCESS(status))
    {
        appDebugOut((DEB_TRACE, "Successfully deleted logical root\n"));

    }
    else if (status == STATUS_DEVICE_BUSY)
    {
        appDebugOut((DEB_TRACE, "Failed to delete logical root: 0x%08lx\n", status));
        err = WN_OPEN_FILES;
    }
    else if (status == STATUS_OBJECT_NAME_NOT_FOUND)
    {
        appDebugOut((DEB_TRACE, "Object not found: 0x%08lx\n", status));
        err = WN_NOT_CONNECTED;
    }
    else if (status == STATUS_NO_SUCH_DEVICE)
    {
        appDebugOut((DEB_TRACE, "No such device: 0x%08lx\n", status));
        err = WN_NOT_CONNECTED;
    }
    else
    {
        appDebugOut((DEB_TRACE, "Other error: 0x%08lx\n", status));
        err = WN_NO_NETWORK;
    }

    return err;
}


//+---------------------------------------------------------------------
//
//  Function:   NPGetConnection
//
//  Synopsis:   Gets the Connection info for a specific connection into DFS.
//
//  Arguments:  Standard Provider API
//
//----------------------------------------------------------------------
DWORD APIENTRY
NPDfsGetConnection(
    LPWSTR   lpLocalName,
    LPWSTR   lpRemoteName,
    LPUINT   lpnBufferLen
    )
{
    int index;
    NTSTATUS status;
    ULONG ulSize = 0;
    FILE_DFS_DEF_ROOT_BUFFER buffer;
    DWORD err = WN_SUCCESS;
    PULONG OutputBuffer = NULL;

    appDebugOut((DEB_TRACE, "NPGetConnection called %ws\n", lpLocalName));

    index = GetDriveLetter(lpLocalName);
    if (-1 == index)
    {
        return WN_NOT_CONNECTED;
    }

    // The Dfs driver returns us a name of the form "\dfsroot\dfs", but we
    // need to return to the caller "\\dfsroot\dfs". So, we have some code to
    // stuff in the extra backslash.

    if (*lpnBufferLen > 2)
    {
        ulSize = ((*lpnBufferLen) - 1) * sizeof(WCHAR);
    }
    else
    {
        ulSize = sizeof(ULONG);
    }


    //
    // DfsFsctl expects an ulong aligned buffer, since we get the 
    // size in the first ulong of the buffer when the fsctl gets
    // back an overflow from the driver.
    // So allocate a new buffer here, that is aligned on an ULONG
    // and then copyout the contents of this buffer to the buffer
    // that was passed in to us.
    //
    OutputBuffer = (PULONG) new ULONG [ (ulSize / sizeof(ULONG)) + 1];
    if (OutputBuffer == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    buffer.LogicalRoot[0] = *lpLocalName;
    buffer.LogicalRoot[1] = UNICODE_NULL;

    status = DfsFsctl(
                FSCTL_DFS_GET_LOGICAL_ROOT_PREFIX,
                &buffer,
                sizeof(FILE_DFS_DEF_ROOT_BUFFER),
                (PVOID) (OutputBuffer),
                ulSize,
                &ulSize);

    ASSERT( status != STATUS_BUFFER_TOO_SMALL );

    if (status == STATUS_BUFFER_OVERFLOW)
    {
        *lpnBufferLen = (ulSize / sizeof(WCHAR)) + 1;
        err = WN_MORE_DATA;
    }
    else if (status == STATUS_NO_SUCH_DEVICE)
    {
        err = WN_NOT_CONNECTED;
    }
    else if (!NT_SUCCESS(status))
    {
        err = WN_NO_NETWORK;
    }
    else
    {
        if (*lpnBufferLen < ((ulSize / sizeof(WCHAR)) + 1))
        {
            *lpnBufferLen = (ulSize / sizeof(WCHAR)) + 1;
            err = WN_MORE_DATA;
        }
        else 
        {
            // stuff the initial backslash only if it was a success
            *lpRemoteName = L'\\';
            RtlCopyMemory(lpRemoteName + 1, 
                          OutputBuffer,
                          ulSize );
        }
    }

    if (OutputBuffer != NULL)
    {
        delete [] OutputBuffer;
    }
    return err;
}



//+---------------------------------------------------------------------
//
//  Function:   DfspGetRemoteName, private
//
//  Synopsis:   Gets the remote name for a given local name.
//              Memory is allocated for the remote name. Use delete[].
//
//  Arguments:  [lpLocalName] -- The local name for which the remote name
//                               is required.
//              [lplpRemoteName] -- The remote name is returned here.
//
//----------------------------------------------------------------------
DWORD
DfspGetRemoteName(
    LPCWSTR lpLocalName,
    LPWSTR* lplpRemoteName
    )
{
#define MAX_STRING  512

    UINT    ulSize;
    DWORD   err;
    WCHAR   wszDriveName[3];

    wszDriveName[0] = lpLocalName[0];
    wszDriveName[1] = lpLocalName[1];
    wszDriveName[2] = UNICODE_NULL;

    *lplpRemoteName = new WCHAR[MAX_STRING];
    if (*lplpRemoteName == NULL)
    {
        return WN_OUT_OF_MEMORY;
    }
    ulSize = MAX_STRING * sizeof(WCHAR);

    err = NPDfsGetConnection(wszDriveName, *lplpRemoteName, &ulSize);
    if (err == WN_SUCCESS)
    {
        return err;
    }
    else if (err == WN_MORE_DATA)
    {
        //
        // In this case we try once more with the right sized buffer
        //
        delete[] *lplpRemoteName;
        *lplpRemoteName = new WCHAR[ulSize];

        if (*lplpRemoteName == NULL) {
            err = ERROR_NOT_ENOUGH_MEMORY;
        }
        else {
            err = NPDfsGetConnection(wszDriveName, *lplpRemoteName, &ulSize);
            ASSERT(err != WN_MORE_DATA);
        }
        return err;
    }
    else
    {
        //
        // In this case it is a valid error. Just return it back.
        //
        delete[] *lplpRemoteName;
        return err;
    }
}


//+----------------------------------------------------------------------------
//
//  Function:   DfspNameResolve
//
//  Synopsis:   Forces a name resolve of a DFS_PATH by doing an NtOpenFile on
//              it. The act of opening should drive the DNR process as far
//              as possible.
//
//  Arguments:  [Src] -- NtPathName of form \Device\Windfs etc.
//
//  Returns:    STATUS_SUCCESS if name resolution succeeded.
//
//              STATUS_NO_MEMORY if could not allocate working memory
//
//              STATUS_OBJECT_PATH_INVALID if lousy input path.
//
//              STATUS_OBJECT_PATH_NOT_FOUND if name resolution could not be
//              driven to completion (for example, some intermediate DC is
//              down in an interdomain case)
//
//-----------------------------------------------------------------------------

NTSTATUS
DfspNameResolve(
    IN LPWSTR Src
    )
{
    NTSTATUS    status;
    HANDLE      hFile;

    UNICODE_STRING      ustrNtFileName;
    OBJECT_ATTRIBUTES   oa;
    IO_STATUS_BLOCK     ioStatus;

    appDebugOut((DEB_TRACE, "NameResolving: %ws\n", Src));
    RtlInitUnicodeString(&ustrNtFileName, Src);

    //
    // We ignore all errors from the NtOpenFile call except for
    // STATUS_CANT_ACCESS_DOMAIN_INFO, STATUS_BAD_NETWORK_PATH,
    // STATUS_NO_SUCH_DEVICE, STATUS_INSUFFICIENT_RESOURCES.
    // These error codes from DNR indicate that the name resolution
    // process did not proceed to completion.
    //
    // BUGBUG - is this list complete?
    //
    // We used to use RtlDoesFileExists_U, but we discarded that for
    // performance. It turns out that if you are opening a LM dir, then
    // LM doesn't really open the dir until you do something interesting
    // to it. So, RtlDoesFileExists_U was forced to do NtQueryInformation
    // on the file. Under Dfs, this short circuiting is disabled, so we
    // can get by with a simple NtOpenFile.
    //

    InitializeObjectAttributes(
            &oa,
            &ustrNtFileName,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL);

    status = NtOpenFile(
                &hFile,
                FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                &oa,
                &ioStatus,
                FILE_SHARE_READ | FILE_SHARE_DELETE,
                FILE_SYNCHRONOUS_IO_NONALERT);

    if (NT_SUCCESS(status))
    {
        NtClose(hFile);
        status = STATUS_SUCCESS;
    }

    appDebugOut((DEB_TRACE, "NameResolve Returned: 0x%08lx\n", status));

    if (!NT_SUCCESS(status))
    {
        if (status == STATUS_CANT_ACCESS_DOMAIN_INFO ||
            status == STATUS_BAD_NETWORK_PATH ||
            status == STATUS_NO_SUCH_DEVICE ||
            status == STATUS_INSUFFICIENT_RESOURCES
            )
        {
            status = STATUS_OBJECT_PATH_NOT_FOUND;
        }
        else
        {
            status = STATUS_SUCCESS;
        }
    }

    return status;
}


//+----------------------------------------------------------------------------
//
//  Function:   NPDfsGetReconnectFlags
//
//  Synopsis:   Returns flags that should be persisted. Upon reboot, when
//              the persistent connection is being restored, these flags are
//              passed back in to NPAddConnection
//
//  Arguments:  [lpLocalName] -- Name of local Device.
//              [lpPersistFlags] -- Upon successful return, flags to be
//                      persisted
//
//  Returns:    [WN_SUCCESS] -- If flags are being returned.
//
//              [WN_BAD_NETNAME] -- If lpLocalName is not a Dfs drive
//
//-----------------------------------------------------------------------------

DWORD APIENTRY
NPDfsGetReconnectFlags(
    LPWSTR lpLocalName,
    LPBYTE lpPersistFlags)
{
    DWORD err = WN_BAD_NETNAME;
    int nDriveIndex;
    WCHAR wchDrive;

    *lpPersistFlags = 0;

    nDriveIndex = GetDriveLetter(lpLocalName);

    if (nDriveIndex != -1) {

        NTSTATUS Status;

        wchDrive = L'A' + nDriveIndex;

        Status = DfsFsctl(
                    FSCTL_DFS_IS_VALID_LOGICAL_ROOT,
                    (PVOID) &wchDrive,
                    sizeof(WCHAR),
                    NULL,
                    0,
                    NULL);

        if (Status == STATUS_SUCCESS) {

            *lpPersistFlags = WNET_ADD_CONNECTION_DFS;

            err = WN_SUCCESS;

        }

    }

    return( err );

}

//+---------------------------------------------------------------------
//
//  Function:   NPDfsGetConnectionPerformance
//
//  Synopsis:   Gets the Connection info for a specific connection into DFS.
//
//  Arguments:  Standard Provider API
//
//----------------------------------------------------------------------
DWORD APIENTRY
NPDfsGetConnectionPerformance(
    LPWSTR   TreeName,
    OUT LPVOID OutputBuffer OPTIONAL,
    IN DWORD OutputBufferSize,
    IN BOOLEAN *DfsName
    )
{
    NTSTATUS status;
    DWORD err = WN_BAD_NETNAME;

    appDebugOut((DEB_TRACE, "NPGetConnection called %ws\n", TreeName));

    if ((TreeName == NULL) || (TreeName[0] == 0)) {
        *DfsName = FALSE;
        return ERROR_INVALID_PARAMETER;
    }

    *DfsName = (BOOLEAN)IsDfsPathEx(TreeName, 0, NULL, FALSE);
    if (*DfsName == FALSE) {
        return ERROR_INVALID_PARAMETER;
    }

    status = DfsFsctl(
		      FSCTL_DFS_GET_CONNECTION_PERF_INFO,
		      (TreeName + 1),
		      (wcslen(TreeName + 1) * sizeof(WCHAR)),
		      OutputBuffer,
		      OutputBufferSize,
		      NULL );

    if (status == STATUS_SUCCESS) {
        err = WN_SUCCESS;
    }
    else {
        err = NetpNtStatusToApiStatus(status);
    }

    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\shell\shell\libmain.cxx ===
/*****************************************************************/
/**                  Microsoft LAN Manager                      **/
/**            Copyright(c) Microsoft Corp., 1989-1991          **/
/*****************************************************************/

/*
 *      Windows/Network Interface  --  LAN Manager Version
 *
 *      History
 *          terryk      01-Nov-1991     Add WNetResourceEnum Init and
 *                                      term function
 *          Yi-HsinS    31-Dec-1991     Unicode work
 *          terryk      03-Jan-1992     Capitalize the manifest
 *          beng        06-Apr-1992     Unicode conversion
 *          Yi-HsinS    20-Nov-1992     Added hmodAclEditor and
 *                                      pSedDiscretionaryAclEditor
 *          DavidHov 17-Oct-1993    Made pSedDiscretionaryEditor extern "C"
 *                                  because mangling on Alpha didn't
 *                                  equate to that in SHAREACL.CXX
 */

#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_DOSERRORS
#define INCL_NETERRORS
#define INCL_NETUSE
#define INCL_NETWKSTA
#define INCL_NETLIB
#define _WINNETWK_
#include <lmui.hxx>
#undef _WINNETWK_

#include <dos.h>

#include <winnetwk.h>
#include <npapi.h>
#include <winlocal.h>
#include <wnetenum.h>
#include <wnetshar.h>

#include <sedapi.h>

#ifndef max
#define max(a,b)   ((a)>(b)?(a):(b))
#endif

#include <uitrace.hxx>

#include "chkver.hxx"
#include <string.hxx>
#include <winprof.hxx>

#include <strchlit.hxx>     // for STRING_TERMINATOR

/*      Local prototypes         */

// reorged these for Glock
extern "C"
{
    BOOL NEAR PASCAL LIBMAIN              ( HINSTANCE hInst,
                                            UINT   wDataSeg,
                                            UINT   wHeapSize,
                                            LPSTR  lpCmdLine  );

    /* Under Win32, DllMain simply calls LIBMAIN.
     */
    BOOL DllMain( HINSTANCE hDll, DWORD dwReason, LPVOID lpvReserved ) ;

    void FAR PASCAL Enable                ( void              );

    void FAR PASCAL Disable               ( void              );

    INT FAR PASCAL WEP                    ( UINT   wWord      );

    void ErrorInitWarning                 ( APIERR err        );

#ifdef DEBUG            // debug scratch area
TCHAR CJJRW[64] ;
#endif

}

VOID TermDfs();

#define FAR_HEAPS_DLL 5  /* Maximum numbe of far heaps for ::new */

HINSTANCE  hModule = NULL;

/*****
 *
 *  LIBMAIN
 *
 *  Purpose:
 *      Initialize DLL, which includes:
 *        - save away instance handle
 *        - set current capabilities
 *
 *  Parameters:
 *      hInst           Instance handle of DLL
 *
 *  Returns:
 *      TRUE            Init OK
 *      FALSE           Init failed
 */

BOOL LIBMAIN (
    HINSTANCE       hInst,
    UINT            wDataSeg,
    UINT            wHeapSize,
    LPSTR           lpCmdLine )
{
    UNREFERENCED (wDataSeg);
    UNREFERENCED (lpCmdLine);


    ::hModule = hInst;

    UNREFERENCED( wHeapSize );


    /* Initialize WNetEnum stuff
     */
    InitWNetEnum();

    /* Initialize SHARELIST  in WNetGetDirectoryType. */
    InitWNetShare();

    return TRUE;
}  /* LIBMAIN */


/*******************************************************************

    NAME:       DllMain

    SYNOPSIS:   Win32 DLL Entry point.  This function gets called when
                a process or thread attaches/detaches itself to this DLL.
                We simply call the Win3 appropriate DLL function.

    ENTRY:      hDll - DLL Module handle
                dwReason - Indicates attach/detach
                lpvReserved - Not used

    EXIT:

    RETURNS:    TRUE if successful, FALSE otherwise

    NOTES:      This is the typical Win32 DLL entry style.

                This is Win32 only.

    HISTORY:
        Johnl   01-Nov-1991     Created

********************************************************************/

BOOL DllMain( HINSTANCE hDll, DWORD dwReason, LPVOID lpvReserved )
{
    UNREFERENCED( lpvReserved ) ;

    switch ( dwReason )
    {
    case DLL_PROCESS_ATTACH:
        DisableThreadLibraryCalls(hDll);
        return LIBMAIN( hDll, 0, 0, NULL ) ;

    case DLL_PROCESS_DETACH:
        return WEP( 0 ) ;

    default:
        // Unexpected reason given to DllMain entry point
        // UIASSERT(FALSE);
        break ;
    }

    return FALSE ;
}

/*
 *  Enable  - must be exported as ordinal @21 in .DEF file
 *
 *  Lanman driver exports this function so that Windows can call
 *  it whenever Lanman driver is started and each time it is swapped
 *  back in off disk.
 *
 *  Note: the corresponding function in Windows is Disable() which
 *        Windows will call it whenever driver is about to swapped
 *        out the disk and exit Windows.  Enable() and Disable()
 *        were implemented specifically for supporting the popup
 *        mechanisms, where you need to disengage yourself before
 *        being swapped to disk so that you won't be called when
 *        you're not there.
 *
 */

void Enable ( void )
{
   /* This is only to provide a entry point whenever Windows tries
    * to call Lanman driver.
    */
   return;

}  /* Enable */

/*
 *  Disable  - must be exported as ordinal @22 in .DEF file
 *
 *  Lanman driver exports this function so that Windows can call
 *  it whenever Lanman driver is exited and each time it is swapped
 *  out the disk.
 *
 */

void Disable ( void )
{
   return;
}  /* Disable */


/*
 *  WEP   (Windows Export Proc--short and cryptic name because
 *         this function is not given an ordinal)
 *
 *  When Windows unloads a driver, it calls this function so that
 *  the driver can do any last minute clean-ups.  Then, Windows
 *  calls the WEP function.  All Windows libraries are required to
 *  contain this function.  It should be included in the .def file
 *  but should not be given an ordinal.
 *
 */

INT WEP ( UINT wWord )
{
    UNREFERENCED( wWord ) ;

    TermWNetEnum();
    TermWNetShare();
    TermDfs();

    return 1;
}  /* WEP */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\shell\shell\chkver.cxx ===
/*****************************************************************/
/**                  Microsoft LAN Manager                      **/
/**            Copyright(c) Microsoft Corp., 1989-1991          **/
/*****************************************************************/

/*
 *      Windows/Network Interface
 *
 *      History:
 *          Yi-HsinS    31-Dec-1991     Unicode work
 *          Johnl       10-Jan-1992     Removed debug info, removed API
 *                                      functionality check for Win32
 */

#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_DOSERRORS
#define INCL_NETERRORS
#define INCL_NETCONS
#define INCL_NETUSE
#define INCL_NETWKSTA
#define _WINNETWK_
#include <lmui.hxx>
#undef _WINNETWK_

#include <dos.h>

#include <winnetwk.h>
#include <npapi.h>
#include <winlocal.h>

#include <string.hxx>
#include <lmowks.hxx>           // for WKSTA_10 object
#include <lmodev.hxx>           // for DEVICE object
#include <strchlit.hxx>         // for DEVICEA_STRING

#include "chkver.hxx"

#include <dbgstr.hxx>


/*      Local prototypes         */



int W_QueryLMFunctionalityLevel  ( void );

/****
 *
 *  W_QueryLMFunctionalityLevel
 *
 *  Purpose:
 *     Find level of functionality in DOS LM.
 *
 *  Parameters:
 *     None
 *
 *  Returns:
 *
 *     FUNC_IncorrectNetwork
 *       - if network software other than LAN Manager is installed or
 *         the LAN Manager version is incompatible with the current driver.
 *
 *     FUNC_WkstaNotStarted
 *       - if workstation was not started
 *             This means the redirector was not started.
 *
 *     FUNC_BaseFunctionality       (see comment below in code)
 *       - if Base functionality is available
 *             In addition to that the network is started,
 *             this level includes:
 *                 Basic redirector functions
 *                 Named pipes
 *                 Remote API's
 *                 NetWkstaGetInfo
 *
 *     FUNC_APIFunctionality
 *       - if API support is loaded
 *             This includes all API's.
 *
 *     FUNC_InsufficientMemory
 *       - If ERROR_OUT_OF_MEMORY is returned during any one of the
 *             API calls.  If this happens, we choose to not install
 *             Lanman.drv since a memory problem with these simple API
 *             functions is going to appear in a bigger scale with
 *             other API functions.
 *
 *  Notes:
 *     Let f = functionality.  Then,
 *       f( FUNC_WkstaNotStarted ) = empty set
 *       f( FUNC_WkstaNotStarted ) = subset of f( FUNC_BaseFunctionality )
 *       f( FUNC_BaseFunctionality ) = subset of f( FUNC_APIFunctionality )
 *
 *  History:
 *      Johnl   27-Mar-1991     Added check for not enough memory
 *
 */

INT W_QueryLMFunctionalityLevel ( void )
{
      WKSTA_10       wksta10;

      /*  Now, check if NetWkstaGetInfo seems to work.  If not,
       *  we will assume that a different network is running,
       *  although we are not certain about this (see winrdme.txt).
       *
       *  Since we have allocated a big buffer, we don't expect to get
       *  ERROR_MORE_DATA, NERR_BufTooSmall and ERROR_NOT_ENOUGH_MEMORY
       *  errors back.
       */
      APIERR errNetErr = wksta10.GetInfo ();

      INT  LMFunc;

      switch (errNetErr)
      {
          case NERR_Success:
              LMFunc = FUNC_BaseFunctionality;
              break;

          case NERR_WkstaNotStarted:
          case NERR_NetNotStarted:
          case NERR_ServiceNotInstalled:    // This happens under NT
              LMFunc = FUNC_WkstaNotStarted;
              break;

          case ERROR_NOT_ENOUGH_MEMORY:
              LMFunc = FUNC_InsufficientMemory ;
              break ;

          default:
              LMFunc = FUNC_IncorrectNetwork;
              DBGOUT("W_QueryLMFunctionality - wksta10.GetInfo returned " << errNetErr);
              DBGEOL(" Assuming functionality is incorrect network");
              break;
      }

      if (LMFunc != FUNC_BaseFunctionality)
          return LMFunc;

#if 0
      DBGOUT("Network Major version is " << wksta10.QueryMajorVer() );
      DBGEOL("  Minor version is " << wksta10.QueryMinorVer() );
#endif

      // Check to see if LM version is too "ADVANCE"
      if (wksta10.QueryMajorVer() > SUPPORTED_MAJOR_VER)
          LMFunc = FUNC_HigherLMVersion;

      // Check to see if LM version is too old
      // 1. If the major version is equvalent to our supported version, but
      //    the minor version is smaller than our supported minor version;
      //    (e.g. If we support 2.1 and above, then 2.0 will be rejected.)
      // 2. If the major version is smaller then our supported major version
      //    (e.g. 1.x will be rejected)

#pragma warning(push)
#pragma warning(disable:4296) // C4296: '<' : expression is always false

      if (((wksta10.QueryMajorVer() == SUPPORTED_MAJOR_VER) &&
           (wksta10.QueryMinorVer() <  SUPPORTED_MINOR_VER)) ||
          (wksta10.QueryMajorVer() < SUPPORTED_MAJOR_VER))
      {
          LMFunc = FUNC_LowerLMVersion;
      }
#pragma warning(pop)

      if (LMFunc != FUNC_BaseFunctionality)
          return LMFunc;

      /* API Support should always be there under Win32
       */
      LMFunc = FUNC_APIFunctionality;

      return LMFunc;

}  /* W_QueryLMFunctionalityLevel */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\shell\shell\wnerr.cxx ===
/*****************************************************************/
/**                  Microsoft LAN Manager                      **/
/**            Copyright(c) Microsoft Corp., 1989-1990          **/
/*****************************************************************/

/*
 *      Windows/Network Interface  --  LAN Manager Version
 *
 *      HISTORY
 *          terryk      01-Nov-1991     WIN32 conversion
 *          Yi-HsinS    31-Dec-1991     Unicode work
 *          terryk      03-Jan-1992     Removed the GetError call
 *          terryk      10-Jan-1992     Fixed SetNetError problem
 *          beng        06-Apr-1992     Unicode visitation
 *          terryk      10-Oct-1993     Remove ErrorPopup
 */

#define INCL_WINDOWS
#define INCL_DOSERRORS
#define INCL_NETERRORS
#define INCL_NETCONS
#define INCL_NETLIB
#define _WINNETWK_
#include <lmui.hxx>
#undef _WINNETWK_

#include <stdlib.h>

#include <winnetwk.h>
#include <npapi.h>
#include <winlocal.h>
#include <errornum.h>
#include <string.hxx>
#include <strchlit.hxx>

#define INCL_BLT_MSGPOPUP
#include <blt.hxx>

#include <uitrace.hxx>

extern HMODULE hModule ;
#define NETMSG_DLL                        SZ("NETMSG.DLL")

APIERR GetLMProviderName();

/*******************************************************************

    NAME:       GetErrorText

    SYNOPSIS:   Internal get error text function. It is called by
                WNetGetGetText and SetNetError.

    ENTRY:      UINT nError - error number
                LPTSTR - return string
                LPUINT - return buffer size (in TCHARs)

    RETURNS:    UINT - WN_NO_ERROR if the error number is too big or
                        cannot find the error string.
                        Otherwise, it will return WN_SUCCESS.

    HISTORY:
                terryk  11-Jan-92       Created
                beng    06-Apr-1992     Clarify BYTEs vs TCHARs
                                        (this will probably change)
                beng    03-Aug-1992     Clarity TCHARs vs BYTEs
                                        (see, it did change)
                Yi-HsinS12-Nov-1992     Use NLS_STR::Load instead of LoadString
                chuckc  10-Dec-1992     Use FormatMessage since NLS_STR::Load
                                        has dependency on BltInit which may not
                                        happen for non GUI uses of ntlanman.dll
                anirudhs29-Mar-1996     Remove bogus call to GetUIErrorString

********************************************************************/

UINT GetErrorText( UINT           nError,
                   LPTSTR         lpBuffer,
                   LPUINT         lpnBufferSize     )
{
    // Avoid returning text for internal strings
    if (nError >= IDS_UI_SHELL_EXPORTED_LAST)
        return WN_NET_ERROR;
    ::memsetf(lpBuffer, 0, *lpnBufferSize * sizeof(TCHAR)) ;

    INT cch;

    if ( nError >= IDS_UI_SHELL_BASE )    // in our own error range
    {
        // The code here used to call GetUIErrorString in ntlanui.dll.
        // This would always fail because ntlanui.dll doesn't export
        // GetUIErrorString.  Also, there are no error strings in
        // this range in ntlanui.dll.
        ASSERT(!"Unexpected error from LanMan call");

        // Fall through to FormatMessage.
    }

    // only get here if we want to call FormatMessage for either Net
    // or system errors.

    HANDLE hmod = NULL;
    DWORD dwFlags = FORMAT_MESSAGE_IGNORE_INSERTS |
                    FORMAT_MESSAGE_MAX_WIDTH_MASK ;

    if ( nError < MIN_LANMAN_MESSAGE_ID || nError > MAX_LANMAN_MESSAGE_ID )
    {
        // System errors
        dwFlags |=  FORMAT_MESSAGE_FROM_SYSTEM;
    }
    else
    {
        // must be Net errors
        dwFlags |=  FORMAT_MESSAGE_FROM_HMODULE;
        hmod = ::LoadLibraryEx( NETMSG_DLL,
                                NULL,
                                LOAD_WITH_ALTERED_SEARCH_PATH );

        if ( hmod == 0 )
        {
            return WN_NET_ERROR;
        }
    }

    cch = (UINT) ::FormatMessage( dwFlags,
                                  hmod,
                                  nError,
                                  0,
                                  (LPTSTR) lpBuffer,
                                  *lpnBufferSize,
                                  NULL );
    if (cch == 0)
        return WN_NET_ERROR ;

    *lpnBufferSize = cch + 1;
    return WN_SUCCESS;
}

// we are UNICODE on Win32, hence below is OK,
// the proc name is deliberately ANSI since GetProcAddress
// takes ANSI only.

#define WNET_DLL                        SZ("MPR.DLL")
#define WNETSETLASTERROR_NAME           "WNetSetLastErrorW"
#define WNETGETLASTERROR_NAME           "WNetGetLastErrorW"

typedef VOID TYPE_WNetSetLastErrorW(
    DWORD   err,
    LPWSTR  lpError,
    LPWSTR  lpProviders
    );
TYPE_WNetSetLastErrorW      *vpfSetLastError = NULL ;

typedef VOID TYPE_WNetGetLastErrorW(
    LPDWORD lpError,
    LPWSTR  lpErrorBuf,
    DWORD   nErrorBufLen,
    LPWSTR  lpNameBuf,
    DWORD   nNameBufLen
    );
TYPE_WNetGetLastErrorW      *vpfGetLastError = NULL ;


/*****
 *
 *  SetNetError
 *
 *  Purpose:
 *      Set network error for later retrieval.
 *      Should only be called from within MapError() in WIN32
 *
 *  Parameters:
 *      err             Network error code.
 *
 *  Returns:
 *      Nothing.
 *
 *  Globals:
 *      Sets WLastNetErrorCode, used in WNetGetError.
 *
 *  Notes:
 *      CODEWORK - we have plans to put all message files in one
 *      dll. when that happens, the call to GetErrorText wont find
 *      the NERR errors, unless we mod GetErrorText.
 */

void SetNetError ( APIERR errNetErr )
{
    // Initialize pszNTLanMan
    APIERR err = GetLMProviderName();
    if (err != WN_SUCCESS)
        return ;

    // if need, load the MPR dll to get hold of
    // WNetSetLastError. If we cant get it, just return.
    if (vpfSetLastError == NULL)
    {
        HMODULE hDLL ;

        hDLL = ::LoadLibraryEx( WNET_DLL,
                                NULL,
                                LOAD_WITH_ALTERED_SEARCH_PATH );
        if (hDLL == NULL)
            return ;

        vpfSetLastError = (TYPE_WNetSetLastErrorW *)
            ::GetProcAddress(hDLL, WNETSETLASTERROR_NAME) ;
        if (vpfSetLastError == NULL)
            return ;
    }

    TCHAR szBuffer[ MAX_TEXT_SIZE ];
    UINT  uBufSize = sizeof(szBuffer)/sizeof(szBuffer[0]) ;
    err = GetErrorText( (UINT)errNetErr, szBuffer, &uBufSize );

    // if we cannot find the string, use empty string but return the
    // error and provider info.
    if ( err == WN_SUCCESS )
        (*vpfSetLastError)( (UINT)errNetErr, szBuffer, (TCHAR *) pszNTLanMan );
    else
        (*vpfSetLastError)( (UINT)errNetErr, SZ(""), (TCHAR *) pszNTLanMan );

}  /* SetNetError */

/*****
 *
 *  GetNetErrorCode
 *
 *  Purpose:
 *      Get network error for the current thread.
 *
 *  Parameters:
 *      None.
 *
 *  Returns:
 *      Network error code.
 */

APIERR GetNetErrorCode ()
{
    APIERR errNetErr = NERR_Success;

    // if need, load the MPR dll to get hold of
    // WNetGetLastError. If we cant get it, just return.
    if (vpfGetLastError == NULL)
    {
        HMODULE hDLL ;

        hDLL = ::LoadLibraryEx( WNET_DLL,
                                NULL,
                                LOAD_WITH_ALTERED_SEARCH_PATH );
        if (hDLL == NULL)
            return errNetErr;

        vpfGetLastError = (TYPE_WNetGetLastErrorW *)
            ::GetProcAddress(hDLL, WNETGETLASTERROR_NAME) ;
        if (vpfGetLastError == NULL)
            return errNetErr;
    }

    WCHAR szError;
    WCHAR szName;

    (*vpfGetLastError)( (PULONG)&errNetErr, &szError, 1, &szName, 1 );

    return errNetErr;
}  /* GetNetErrorCode */


/*
 *  MapError
 *
 *  This function maps a NERR error code to a WinNet error code.
 *  It also does a SetLastError/WnetSetLastError as need.
 *
 *  If no mapping exists, this function calls WNetSetLastError and
 *  returns WN_EXTENDED_ERROR.
 *
 *  Calling it with WN_SUCCESS or NERR_Success is a NO-OP.
 *
 *  Parameters:
 *      usNetErr        The standard (normally ERROR_* or NERR_*) error
 *                      code to be mapped.
 *
 *  Return value:
 *      The WinNet error code (WN_*) corresponding to the given usNetErr.
 *
 *  Notes:
 *      The caller may use MapError as follows:
 *
 *          WORD NPxxx( void )
 *          {
 *              //  etc.
 *
 *              USHORT usErr = NetXxx();
 *              switch ( usErr )
 *              {
 *                  // special-case error returns here (when applicable)
 *              default:
 *                  break;
 *              }
 *
 *              return MapError( usErr );
 *
 *          }  // NPxxx
 *
 *
 *      Also, it is harmless to remap and error that has already
 *      been mapped to the WN_* range. This will just result in
 *      the same error.
 */

UINT MapError( APIERR err )
{
    APIERR errMapped ;

    switch ( err )
    {
    case NERR_Success:
        errMapped = WN_SUCCESS;
        break ;

    case ERROR_NETWORK_ACCESS_DENIED:
    case ERROR_ACCESS_DENIED:
        errMapped = WN_ACCESS_DENIED;
        break ;

    case ERROR_BAD_NET_NAME:
        errMapped = WN_BAD_NETNAME;
        break ;

        /*
         * Fall through
         */
    case ERROR_INVALID_PASSWORD:
    case NERR_BadPasswordCore:
    case NERR_BadPassword:
        errMapped = WN_BAD_PASSWORD;
        break ;

    case NERR_BadUsername:
        errMapped = WN_BAD_USER ;
        break ;

    case NERR_WkstaNotStarted:
        errMapped = WN_NO_NETWORK ;
        break ;

    case NERR_UseNotFound:
        errMapped = WN_NOT_CONNECTED ;
        break ;

    case NERR_OpenFiles:
        errMapped = WN_OPEN_FILES ;
        break ;

    case NERR_DevInUse:
        errMapped = WN_DEVICE_IN_USE ;
        break ;

    default:
        if (err < NERR_BASE)
            // not network error. assume it is base Win32
            errMapped = err ;
        else
        {
            SetNetError( err );   // let SetNetError figure it out
            errMapped = WN_EXTENDED_ERROR;  // its an extended error
        }
    }

    // Don't need to SetLastError since MPR always does it for us

    return((UINT)errMapped) ;

}  // MapError
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\shell\shell\thunk.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**             Copyright(c) Microsoft Corp., 1991                   **/
/**********************************************************************/

/*
 *   thunk.cxx
 *     Contains dialogs called by the wfw thunk DLL.
 *     For deleting and creating shares.
 *
 *   FILE HISTORY:
 *     terryk           10/10/93                Created
 *
 */


#define INCL_WINDOWS_GDI
#define INCL_WINDOWS
#define INCL_DOSERRORS
#define INCL_NETERRORS
#define INCL_NETSHARE
#define INCL_NETUSE
#define INCL_NETSERVER
#define INCL_NETCONS
#define INCL_NETLIB
#include <lmui.hxx>

#include <mpr.h>
#include <wnet16.h>
#include <winnetwk.h>
#include <npapi.h>
#include <uiexport.h>
#include <winlocal.h>
#include <search.h>
#include <wnetshar.h>

extern "C"
{
    // export functions
    APIERR ShareCreate( HWND hwnd );
    APIERR ShareStop( HWND hwnd );
    VOID ShareManage( HWND hwnd, const TCHAR *pszServer );
}

#include <string.hxx>
#include <uitrace.hxx>
#include <array.hxx>
#include <netname.hxx>
#include <lmoshare.hxx>
#include <lmoesh.hxx>
#include <lmoeconn.hxx>
#include <lmosrv.hxx>
#include <dbgstr.hxx>
#include <uiassert.hxx>

#include <strchlit.hxx>   // for string and character constants

#define SZ_NTLANUI_DLL          SZ("ntlanui.dll")
#define SZ_SHAREASDIALOGA       "ShareAsDialogA0"
#define SZ_STOPSHAREDIALOGA     "StopShareDialogA0"
#define SZ_SHARECREATE          "ShareCreate"
#define SZ_SHARESTOP            "ShareStop"
#define SZ_SHAREMANAGE          "ShareManage"
#define SZ_I_SYSTEMFOCUSDIALOG  "I_SystemFocusDialog"
#define SZ_SERVERBROWSEDIALOGA  "ServerBrowseDialogA0"
#define SZ_GETPROPERTYTEXT      "NPGetPropertyText"
#define SZ_GETPROPERTYDIALOG    "NPPropertyDialog"

DECLARE_ARRAY_LIST_OF(NLS_STR);
DEFINE_EXT_ARRAY_LIST_OF(NLS_STR); //Create ARRAY_LIST_NLS_STR class.

/********************************************************************

  NAME:         SHARELIST

  WORKBOOK:

  SYNOPSIS:     SHARE LIST class

  INTERFACE:    Add()     -Add a share directory in the share list
                AllocateMoreMemory - Allocate more elements for the
                           array to avoid reallocating memory all the time
                Fill()    -Add share directories on the Drive to the
                                   share list.
                Delete()  -Delete share directories on the Drive from
                                   the share list.

  PARENT:       ARRAY_LIST_NLS_STR

  HISTORY:
       CongpaY  20-Jul-1992     Created
       YiHsinS   8-Feb-1992     Added Add() and AllocateMoreMemory()

*********************************************************************/

class SHARELIST : public ARRAY_LIST_NLS_STR
{
public:
    BOOL Add( const NLS_STR &nls );
    APIERR AllocateMoreMemory( INT cElemAdd );

    APIERR Fill(const NLS_STR & nlsDrive);
    APIERR Delete(const NLS_STR & nlsDrive);
};

/********************************************************************

  NAME:         SHARELIST::Add

  SYNOPSIS:     Add share directory to the share list.

  ENTRY:        nls - the share directory to be added

  RETURNS:      BOOL

  NOTES:        This is redefined because the original Add will
                downsize the array which is a hit in performance.
                Until we clean up the array list class, we have
                to have this method.

  HISTORY:
      YiHsinS  8-Feb-1993

********************************************************************/

BOOL SHARELIST::Add( const NLS_STR &nls )
{
    INT n = QueryCount();
    if ( !Resize( n+1, FALSE ) )
        return FALSE;

    (*this)[n] = nls;
    return TRUE;
}

/********************************************************************

  NAME:         SHARELIST::AllocateMoreMemory

  SYNOPSIS:     Allocate more elements for the array to avoid
                resizing the array all the time.

  ENTRY:        cElemAdd - the elements to be added

  RETURNS:

  NOTES:

  HISTORY:
      YiHsinS  8-Feb-1993       Created

********************************************************************/

APIERR SHARELIST::AllocateMoreMemory( INT cElemAdd )
{
    APIERR err = NERR_Success;

    INT cElemOld = QueryCount();
    if ( cElemAdd > 0 )
    {
        if ( !Resize( cElemAdd + cElemOld ) )
            err = ERROR_NOT_ENOUGH_MEMORY;
    }

    // This is just to set the current array size to the right number
    // so that further Add() starts adding at cElemOld+1.
    // FALSE means not to downsize memory.
    if (  ( err == NERR_Success )
       && ( !Resize( cElemOld, FALSE ))
       )
    {
        err = ERROR_NOT_ENOUGH_MEMORY;
    }

    return err;
}

/********************************************************************

  NAME:         SHARELIST::Fill

  SYNOPSIS:     Add share directories to the share list.

  ENTRY:        nlsDrive        -The drive that share directories are under.

  RETURNS:      APIERR

  NOTES:        If Fill is executed successfully, share directories under
                the nlsDrive will be added to the share list.

  HISTORY:
       CongpaY  20-Jul-1992

********************************************************************/

APIERR SHARELIST::Fill(const NLS_STR & nlsDrive)
{

    /* Check if nlsDrive is a valid drive name. */

//    UIASSERT(nlsDrive.QueryTextLength() == 2);
    ISTR istrDrive(nlsDrive);
    ++istrDrive;
//    UIASSERT(*(nlsDrive.QueryPch(istrDrive)) == TCH(':'));

    APIERR err;
    NET_NAME netnameDrive(nlsDrive.QueryPch());
    if ((err = netnameDrive.QueryError()) != NERR_Success)
        return err;

    BOOL bLocal = netnameDrive.IsLocal(&err);
    if(err == NERR_Success)
    {
        if(bLocal)
        {
            SHARE2_ENUM she2(NULL);
            if ((err = she2.GetInfo()) != NERR_Success)
                return err;

            // Resize the array to the number of shares + the original
            // count of the array so that the array is not resized over
            // and over again on a computer with thousands of shares.
            // NOTE: There are some potential problem with
            // she2.QueryCount() if SHARE2_ENUM is resumable. ( The
            // count might not be accurate. )

            if ( (err = AllocateMoreMemory( she2.QueryCount())) != NERR_Success)
                return err;

            SHARE2_ENUM_ITER shei2(she2);
            const SHARE2_ENUM_OBJ * pshei2;
            while((pshei2 = shei2()) != NULL)
            {
                NLS_STR nlsPath(pshei2->QueryPath());
                if ((err = nlsPath.QueryError()) != NERR_Success)
                    return err;
                if (nlsDrive._strnicmp(nlsPath, istrDrive) == 0)
                {
                    if (!Add( nlsPath._strupr()))
                        return ERROR_NOT_ENOUGH_MEMORY;
                }
            }

        }
        else
        {
            NLS_STR nlsComp, nlsServerShare, nlsSvrDrive;
            if (((err = nlsComp.QueryError()) != NERR_Success) ||
                ((err = nlsServerShare.QueryError()) != NERR_Success) ||
                ((err = nlsSvrDrive.QueryError()) != NERR_Success) ||
                ((err = netnameDrive.QueryComputerName(&nlsComp)) != NERR_Success) ||
                ((err = netnameDrive.QueryServerShare(&nlsServerShare)) != NERR_Success))
            {
                return err;
            }
            NET_NAME netnameSvrDrive(nlsServerShare.QueryPch());
            if (((err = netnameSvrDrive.QueryError()) != NERR_Success) ||
                ((err = netnameSvrDrive.QueryLocalPath(&nlsSvrDrive)) != NERR_Success))
            {
                return err;
            }

            nlsSvrDrive._strupr();

            SHARE2_ENUM she2(nlsComp.QueryPch());
            if((err = she2.GetInfo()) != NERR_Success)
                return err;

            // Resize the array to the number of share + the original
            // count of the array so that the array is not resized over
            // and over again on a computer with thousands of shares.
            // NOTE: There are some potential problem with
            // she2.QueryCount() if SHARE2_ENUM is resumable. ( The
            // count might not be accurate. )
            //
            if ( (err = AllocateMoreMemory( she2.QueryCount())) != NERR_Success)
                return err;

            SHARE2_ENUM_ITER shei2(she2);
            const SHARE2_ENUM_OBJ * pshei2;
            while((pshei2 = shei2()) != NULL)
            {
                NLS_STR nlsLocalPath(pshei2->QueryPath());
                if ((err = nlsLocalPath.QueryError()) != NERR_Success)
                    return err;

                nlsLocalPath._strupr();
                ISTR istrPos(nlsLocalPath);
                if (nlsLocalPath.strstr(& istrPos, nlsSvrDrive))
                {
                    ISTR istrEnd(nlsLocalPath);
                    istrEnd += nlsSvrDrive.QueryTextLength();
                    nlsLocalPath.DelSubStr(istrPos, istrEnd);
                    ISTR istrLocalPath(nlsLocalPath);
                    NLS_STR nlsPath(nlsDrive.QueryPch());
                    if ((err = nlsPath.QueryError()) != NERR_Success)
                        return err;
                    if (*(nlsLocalPath.QueryPch(istrLocalPath)) != TCH('\\'))
                        if ((err = nlsPath.Append(NLS_STR(SZ("\\")))) != NERR_Success)
                            return err;
                    if ((err = nlsPath.Append(nlsLocalPath)) != NERR_Success)
                        return err;
                    if (!Add( nlsPath._strupr()))
                        return ERROR_NOT_ENOUGH_MEMORY;
                }
            }
        }
    }
    return err;
}

/********************************************************************

  NAME:         SHARELIST::Delete

  SYNOPSIS:     Delete share directories from the share list.

  ENTRY:        nlsDrive        -The drive that share directories are under.

  RETURNS:      APIERR

  NOTES:        When Delete is executed, share directories under
                the nlsDrive will be removed from the share list.

  HISTORY:
       CongpaY  20-Jul-1992

********************************************************************/

APIERR SHARELIST::Delete(const NLS_STR & nlsDrive)
{
    /* Check if nlsDrive is a valid drive name. */
//    UIASSERT(nlsDrive.QueryTextLength() == 2);
    ISTR istrDrive(nlsDrive);
    ++istrDrive;
//    UIASSERT(*(nlsDrive.QueryPch(istrDrive)) == TCH(':'));

    INT i = 0, cItem = QueryCount();

    while (i < cItem)
    {
        ALIAS_STR nlsPath((*this)[i]);
        ISTR istrPos(nlsPath);
        if (nlsPath.strstr(& istrPos, nlsDrive))
        {
            Remove(nlsPath);
            cItem--;
        }
        else
            i++;
    }
    return NERR_Success;
}   //SHARELIST


/* The following defines two functions used by libmain.cxx.
 * pShareList is a point to the SHARELIST object which stores all the shared
 * directories. pDriveList is a point to the SHARELIST object which stores
 * all the drives that have been queried.
 */

static SHARELIST *pShareList = NULL;
static SHARELIST *pDriveList = NULL;

/*******************************************************************

    NAME:       ShareAsDialogA0

    SYNOPSIS:   dialog for creating shares

    ENTRY:      hwnd  - hwnd of the parent window
                nType - type of share (currently must be disk)
                pszPath - directory to share

    EXIT:

    RETURNS:

    NOTES:      CODEWORK: the help context here is relative to our
                          normal winfile stuff. at this late stage,
                          it is too late to add new help for something
                          that most likely is never used. as it is, any
                          app that calls this internal API will still
                          get help, just that it piggybacks on top of winfile.


    HISTORY:
        ChuckC          3/25/93         Stole from sharefmx

********************************************************************/

typedef DWORD (*FPShareAsDialogA0)( HWND    hwnd,
                       DWORD   nType,
                       CHAR    *pszPath);

DWORD ShareAsDialogA0( HWND    hwnd,
                       DWORD   nType,
                       CHAR    *pszPath)
{
    DWORD err = NERR_Success;

    do {
        HINSTANCE hDll = ::LoadLibraryEx( SZ_NTLANUI_DLL,
                                          NULL,
                                          LOAD_WITH_ALTERED_SEARCH_PATH );
        if ( hDll == NULL )
        {
            err = ::GetLastError();
            break;
        }

        FARPROC pFarProc = ::GetProcAddress( hDll, SZ_SHAREASDIALOGA );

        if ( pFarProc == NULL )
        {
            err = ::GetLastError();
        } else
        {
            err = (*(FPShareAsDialogA0)pFarProc)( hwnd, nType, pszPath);
        }

        if ( hDll )
            ::FreeLibrary( hDll );

    } while (FALSE);

    return err;
}

/*******************************************************************

    NAME:       StopShareDialogA0

    SYNOPSIS:   dialog for deleting shares

    ENTRY:      hwnd  - hwnd of the parent window
                nType - type of share (currently must be disk)
                pszPath - directory to stop share

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        ChuckC        3/25/93            Stole from sharefmx.cxx

********************************************************************/

typedef DWORD (*FPStopShareDialogA0)( HWND    hwnd,
                         DWORD   nType,
                         CHAR    *pszPath) ;

DWORD StopShareDialogA0( HWND    hwnd,
                         DWORD   nType,
                         CHAR    *pszPath)
{
    DWORD err = NERR_Success;

    do {
        HINSTANCE hDll = ::LoadLibraryEx( SZ_NTLANUI_DLL,
                                          NULL,
                                          LOAD_WITH_ALTERED_SEARCH_PATH );
        if ( hDll == NULL )
        {
            err = ::GetLastError();
            break;
        }

        FARPROC pFarProc = ::GetProcAddress( hDll, SZ_STOPSHAREDIALOGA );

        if ( pFarProc == NULL )
        {
            err = ::GetLastError();
        } else
        {
            err = (*(FPStopShareDialogA0)pFarProc)( hwnd, nType, pszPath);
        }

        if ( hDll )
            ::FreeLibrary( hDll );

    } while (FALSE);

    return err;
}

/*******************************************************************

    NAME:       ShareCreate

    SYNOPSIS:   Get the item selected in FM and call the create share dialog

    ENTRY:      hwnd  - hwnd of the parent window

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        8/25/91         Created

********************************************************************/

typedef APIERR (*FPShareCreate)( HWND hwnd );

APIERR ShareCreate( HWND hwnd )
{
    APIERR err = NERR_Success;

    do {
        HINSTANCE hDll = ::LoadLibraryEx( SZ_NTLANUI_DLL,
                                          NULL,
                                          LOAD_WITH_ALTERED_SEARCH_PATH );
        if ( hDll == NULL )
        {
            err = ::GetLastError();
            break;
        }

        FARPROC pFarProc = ::GetProcAddress( hDll, SZ_SHARECREATE );

        if ( pFarProc == NULL )
        {
            err = ::GetLastError();
        } else
        {
            err = (*(FPShareCreate)pFarProc)( hwnd );
        }

        if ( hDll )
            ::FreeLibrary( hDll );

    } while (FALSE);

    return err;
}

/*******************************************************************

    NAME:       ShareStop

    SYNOPSIS:   Get the item selected in FM and call the stop share dialog

    ENTRY:      hwnd  - hwnd of the parent window

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        8/25/91         Created

********************************************************************/

typedef APIERR (*FPShareStop)(HWND hwd);

APIERR ShareStop( HWND hwnd )
{
    APIERR err = NERR_Success;

    do {
        HINSTANCE hDll = ::LoadLibraryEx( SZ_NTLANUI_DLL,
                                          NULL,
                                          LOAD_WITH_ALTERED_SEARCH_PATH );
        if ( hDll == NULL )
        {
            err = ::GetLastError();
            break;
        }

        FARPROC pFarProc = ::GetProcAddress( hDll, SZ_SHARESTOP );

        if ( pFarProc == NULL )
        {
            err = ::GetLastError();
        } else
        {
            err = (*(FPShareStop)pFarProc)( hwnd );
        }

        if ( hDll )
            ::FreeLibrary( hDll );

    } while (FALSE);

    return err;
}

/*******************************************************************

    NAME:       ShareManage

    SYNOPSIS:   Entry point for the share management dialog to be called
                from the server manager.


    ENTRY:      hwnd      - hwnd of the parent window
                pszServer - The server to focus on

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        8/8/92          Created

********************************************************************/

typedef VOID (*FPShareManage)( HWND hwnd, const TCHAR *pszServer);

VOID ShareManage( HWND hwnd, const TCHAR *pszServer )
{
    APIERR err = NERR_Success;

    do {
        HINSTANCE hDll = ::LoadLibraryEx( SZ_NTLANUI_DLL,
                                          NULL,
                                          LOAD_WITH_ALTERED_SEARCH_PATH );
        if ( hDll == NULL )
        {
            err = ::GetLastError();
            break;
        }

        FARPROC pFarProc = ::GetProcAddress( hDll, SZ_SHAREMANAGE );

        if ( pFarProc == NULL )
        {
            err = ::GetLastError();
        } else
        {
            (*(FPShareManage)pFarProc)( hwnd,  pszServer);
        }

        if ( hDll )
            ::FreeLibrary( hDll );

    } while (FALSE);

    // return Nothing
}

/*******************************************************************

    NAME:       I_SystemFocusDialog

    SYNOPSIS:   Popup a dialog box and get the domain or server name

    ENTRY:      hwndOwner - owner window handle
                nSelectionType - Determines what items the user can select
                pszName - the string buffer which contains the
                    return value. It can be either domain name or server
                    name. ( server name will start with "\\" )
                cchBuffSize - the max buf size of pszName
                pfOK - TRUE if user hits OK button. FALSE if user
                    hits a CANCEL button.

    EXIT:       LPWSTR pszName - if user hits okay button, it will
                    return either a domain name or a server name. (
                    server name always starts with "\\" ). It will be
                    undefined if the user hits Cancel button.
                BOOL *pfOK - TRUE if user hits ok button. FALSE
                    otherwise.

    RETURNS:    UINT - (APIERR) - NERR_Success if the operation is succeed.
                         NERR_BufTooSmall, the string buffer is too
                             small. It will not set the string if the
                             buffer is too small.

    NOTES:      The reason the return type is UINT and not APIERR is because
                APIERR is not a public definition, and this API is exported
                for public use.

    HISTORY:
                terryk  18-Nov-1991     Created
                terryk  19-Nov-1991     Name changed
                JohnL   22-Apr-1992     Allowed inclusion specification

********************************************************************/

typedef UINT (*FPI_SystemFocusDialog)(   HWND   hwndOwner,
                                         UINT   nSelectionType,
                                         LPWSTR pszName,
                                         UINT   cchBuffSize,
                                         BOOL * pfOK,
                                         LPWSTR pszHelpFile,
                                         DWORD  nHelpContext );

UINT I_SystemFocusDialog(   HWND   hwndOwner,
                            UINT   nSelectionType,
                            LPWSTR pszName,
                            UINT   cchBuffSize,
                            BOOL * pfOK,
                            LPWSTR pszHelpFile,
                            DWORD  nHelpContext )
{
    UINT err = NERR_Success;

    do {
        HINSTANCE hDll = ::LoadLibraryEx( SZ_NTLANUI_DLL,
                                          NULL,
                                          LOAD_WITH_ALTERED_SEARCH_PATH );
        if ( hDll == NULL )
        {
            err = (UINT)::GetLastError();
            break;
        }

        FARPROC pFarProc = ::GetProcAddress( hDll, SZ_I_SYSTEMFOCUSDIALOG );

        if ( pFarProc == NULL )
        {
            err = (UINT)::GetLastError();
        } else
        {
            err = (*(FPI_SystemFocusDialog)pFarProc)( hwndOwner,
                                                                nSelectionType,
                                                                pszName,
                                                                cchBuffSize,
                                                                pfOK,
                                                                pszHelpFile,
                                                                nHelpContext );
        }

        if ( hDll )
            ::FreeLibrary( hDll );

    } while (FALSE);

    return err;
}    // GetSystemFocusDialog END

/*******************************************************************

    NAME:       ServerBrowseDialog

    SYNOPSIS:   dialog box to browse for servers

    ENTRY:      hwndOwner - owner window handle
                pszName - the string buffer which contains the
                    return value. It can be either domain name or server
                    name. ( server name will start with "\\" )
                cchBuffSize - the max buf size of pszName

    EXIT:       LPWSTR pszName - if user hits okay button, it will
                    return either a domain name or a server name. (
                    server name always starts with "\\" ). It will be
                    undefined if the user hits Cancel button.

    RETURNS:    UINT - (APIERR) - NERR_Success if the operation is succeed.
                         NERR_BufTooSmall, the string buffer is too
                             small. It will not set the string if the
                             buffer is too small.

    NOTES:

    HISTORY:
                ChuckC   28-Mar-1993     Created

********************************************************************/

typedef DWORD (*FPServerBrowseDialogA0)(HWND    hwnd,
                           CHAR   *pchBuffer,
                           DWORD   cchBufSize) ;

DWORD ServerBrowseDialogA0(HWND    hwnd,
                           CHAR   *pchBuffer,
                           DWORD   cchBufSize)
{
    DWORD err = NERR_Success;

    do {
        HINSTANCE hDll = ::LoadLibraryEx( SZ_NTLANUI_DLL,
                                          NULL,
                                          LOAD_WITH_ALTERED_SEARCH_PATH );
        if ( hDll == NULL )
        {
            err = ::GetLastError();
            break;
        }

        FARPROC pFarProc = ::GetProcAddress( hDll, SZ_SERVERBROWSEDIALOGA );

        if ( pFarProc == NULL )
        {
            err = ::GetLastError();
        } else
        {
            err = (*(FPServerBrowseDialogA0)pFarProc)( hwnd, pchBuffer, cchBufSize );
        }

        if ( hDll )
            ::FreeLibrary( hDll );

    } while (FALSE);

    return err;
}

/*******************************************************************

    NAME:       NPGetDirectoryType

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
                terryk  1-Nov-1993      Move to thunk.cxx

********************************************************************/

DWORD APIENTRY NPGetDirectoryType( LPTSTR lpPathName, LPINT lpType, BOOL bFlushCache)
{
    APIERR err;

/* Get the drive of the directory pointed by lpPathName. */

    NLS_STR nlsDrive, nlsPath(lpPathName);
    if (((err = nlsPath.QueryError()) != NERR_Success) ||
        ((err = nlsDrive.QueryError()) != NERR_Success))
    {
        return err;
    }
    nlsDrive = nlsPath;
    ISTR istrDrive(nlsDrive);
    istrDrive += 2;
    nlsDrive.DelSubStr(istrDrive);

/* Update sharelist if necessary. */

    if (pDriveList->Find(nlsDrive._strupr()) == -1)
    {
        if((err = pShareList->Fill(nlsDrive)) != NERR_Success)
            return err;
        if(pShareList->QueryCount() > 0)
            pShareList->Sort();
        if (!(pDriveList->Add(nlsDrive._strupr())))
            return ERROR_NOT_ENOUGH_MEMORY;
    }
    else if (bFlushCache)
    {
        pShareList->Delete(nlsDrive);
        if((err = pShareList->Fill(nlsDrive)) != NERR_Success)
            return err;
        if(pShareList->QueryCount() > 0)
            pShareList->Sort();
    }

/* Using binary search to find if the directory is a share. */
    if (pShareList->QueryCount() > 0)
        *lpType = (pShareList->BinarySearch(nlsPath._strupr()) == -1) ? WNDT_NORMAL : WNDT_NETWORK;
    else
        *lpType = WNDT_NORMAL;
    return 0;

}   // NPGetDirectoryType


/*******************************************************************

    NAME:       NPDirectoryNotify

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        rustanl     30-Apr-1991     Created
        beng        06-Apr-1992     Unicode pass
        congpay     07-Aug-1992     Modefied structure comments

********************************************************************/

DWORD APIENTRY NPDirectoryNotify( HWND hwnd, LPTSTR lpDir, UINT wOper )
{
    //ASSERT( lpDir != NULL ) ;
    UNREFERENCED( hwnd ) ;
    UNREFERENCED( lpDir ) ;
    UNREFERENCED( wOper ) ;
    return MapError( WN_NOT_SUPPORTED );

/********************************************************************
 *  Below shows the structure.
 *
 *  USHORT usMsg;
 *
 *  switch ( wOper )
 *  {
 *  case WNDN_MKDIR:
 *
 *  case WNDN_RMDIR:
 *
 *  case WNDN_MVDIR:
 *
 *  default:
 *      return WN_NOT_SUPPORTED;
 *  }
 *******************************************************************/

}   // NPDirectoryNotify

typedef UINT (*FPGetPropertyText)( UINT iButton,
                                   UINT nPropSel,
                                   LPTSTR lpszName,
                                   LPTSTR lpButtonName,
                                   UINT cchButtonName,
                                   UINT nType           );

DWORD APIENTRY NPGetPropertyText( UINT iButton,
                                           UINT nPropSel,
                                           LPTSTR lpszName,
                                           LPTSTR lpButtonName,
                                           UINT cchButtonName,
                                           UINT nType           )
{
    UINT err = NERR_Success;

    do {
        HINSTANCE hDll = ::LoadLibraryEx( SZ_NTLANUI_DLL,
                                          NULL,
                                          LOAD_WITH_ALTERED_SEARCH_PATH );
        if ( hDll == NULL )
        {
            err = (UINT)::GetLastError();
            break;
        }

        FARPROC pFarProc = ::GetProcAddress( hDll, SZ_GETPROPERTYTEXT );

        if ( pFarProc == NULL )
        {
            err = (UINT)::GetLastError();
        } else
        {
            err =MapError((*(FPGetPropertyText)pFarProc)( iButton,nPropSel,lpszName,
                                             lpButtonName,cchButtonName,nType ));
        }
        if ( hDll )
            ::FreeLibrary( hDll );

    } while (FALSE);

    return err;

}

/*******************************************************************

    NAME:       NPPropertyDialog

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        terryk          01-Nov-1993     Modefied to dll call out

********************************************************************/

typedef UINT (*FPPropertyDialog)( HWND hwndParent,
                                UINT iButton,
                                UINT nPropSel,
                                LPTSTR lpszName,
                                UINT nType        );

DWORD APIENTRY NPPropertyDialog( HWND hwndParent,
                                          UINT iButton,
                                          UINT nPropSel,
                                          LPTSTR lpszName,
                                          UINT nType        )
{
    UINT err = NERR_Success;

    do {
        HINSTANCE hDll = ::LoadLibraryEx( SZ_NTLANUI_DLL,
                                          NULL,
                                          LOAD_WITH_ALTERED_SEARCH_PATH );
        if ( hDll == NULL )
        {
            err = (UINT)::GetLastError();
            break;
        }

        FARPROC pFarProc = ::GetProcAddress( hDll, SZ_GETPROPERTYDIALOG );

        if ( pFarProc == NULL )
        {
            err = (UINT)::GetLastError();
        } else
        {
            err = MapError((*(FPPropertyDialog)pFarProc)(hwndParent,
                                                   iButton,
                                                   nPropSel,
                                                   lpszName,
                                                   nType));
        }

        if ( hDll )
            ::FreeLibrary( hDll );

    } while (FALSE);

    return err;
}

/* InitWNetShare initialize sharelists for storing shared directories and
 * corresponding drives.
 */

APIERR InitWNetShare()
{
    if (pShareList == NULL)
        pShareList = new SHARELIST;
    if (pShareList == NULL)
        return ERROR_NOT_ENOUGH_MEMORY;
    if (pDriveList == NULL)
        pDriveList = new SHARELIST;
    if (pDriveList == NULL)
        return ERROR_NOT_ENOUGH_MEMORY;
    return NO_ERROR ;
}

/* TermWNetShare cleans up the heap. */

VOID TermWNetShare()
{
    delete pShareList;
    pShareList = NULL;
    delete pDriveList;
    pShareList = NULL;
}   // InitWNetShare and TermWNetShare.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\shell\shell\wnetcaps.cxx ===
/*****************************************************************/
/**          Microsoft LAN Manager          **/
/**        Copyright(c) Microsoft Corp., 1989-1990      **/
/*****************************************************************/

/*
 *  Windows/Network Interface  --  LAN Manager Version
 *
 *  History:
 *      terryk  03-Jan-1992 Capitalize the manifest
 *      Johnl   11-Jan-1992 Cleaned up as a Win32 network provider
 */

#define INCL_WINDOWS
#define INCL_NETERRORS
#define INCL_DOSERRORS
#define INCL_NETSERVICE
#define _WINNETWK_
#include <lmui.hxx>
#undef _WINNETWK_
#include "chkver.hxx"
#include <winnetwk.h>
#include <npapi.h>
#include <winlocal.h>

#include <uibuffer.hxx>
#include <dbgstr.hxx>
#include <uiassert.hxx>
#include <svcman.hxx>
#include <lmowks.hxx>


/* Figures out the appropriate timeout for the lanman provider
 */
UINT GetTimeOutCap( void ) ;

/*****
 *
 *  NPGetCaps
 *
 *  Network Provider entry point -- see spec for parms and return values.
 *
 */

DWORD NPGetCaps ( UINT      nIndex )
{
    switch (nIndex)
    {
    case WNNC_SPEC_VERSION:
        return  WNNC_SPEC_VERSION51;

    case WNNC_NET_TYPE:
        return  WNNC_NET_LANMAN;

    case WNNC_DRIVER_VERSION:
        return  0x0400;

    case WNNC_USER:
        return  WNNC_USR_GETUSER;

    case WNNC_CONNECTION:
        return  (
                WNNC_CON_ADDCONNECTION      |
                WNNC_CON_ADDCONNECTION3     |
                WNNC_CON_CANCELCONNECTION   |
                WNNC_CON_GETCONNECTIONS     |
                WNNC_CON_GETPERFORMANCE     |
                WNNC_CON_DEFER
                );

    case WNNC_CONNECTION_FLAGS:
        return  (
                WNNC_CF_DEFAULT |
                CONNECT_DEFERRED |
                CONNECT_COMMANDLINE |
                CONNECT_CMD_SAVECRED
                );

    case WNNC_ENUMERATION:
        return  (
                WNNC_ENUM_GLOBAL  |
                WNNC_ENUM_LOCAL   |
                WNNC_ENUM_CONTEXT |
                WNNC_ENUM_SHAREABLE
                );

    case WNNC_START:
        return GetTimeOutCap() ;

    case WNNC_DIALOG:
        return  (
#ifdef DEBUG
                WNNC_DLG_SEARCHDIALOG           |
#endif
                WNNC_DLG_DEVICEMODE             |
                WNNC_DLG_PROPERTYDIALOG         |
                WNNC_DLG_FORMATNETWORKNAME      |
                WNNC_DLG_GETRESOURCEPARENT      |
                WNNC_DLG_GETRESOURCEINFORMATION
                );

    case WNNC_ADMIN:
        return  (
                WNNC_ADM_GETDIRECTORYTYPE  |
                WNNC_ADM_DIRECTORYNOTIFY
                );

    default:
        return  0;
    }
}  /* NPGetCaps */

/*******************************************************************

    NAME:   GetTimeOutCap

    SYNOPSIS:   Returns the appropriate timeout value for the Lanman Network
        provider startup time

    RETURNS:    Either the time in milliseconds till we think the provider
        will be ready to run
        or 0 - Means the workstation service isn't autostart, don't
            try us anymore
        or FFFFFFFF - We have no idea, keep trying until the system
            timeout has elapsed

    NOTES:

    HISTORY:
    Johnl   01-Sep-1992 Created

********************************************************************/

#define DEFAULT_LM_PROVIDER_WAIT    (0xffffffff)

UINT GetTimeOutCap( void )
{
    APIERR err = NERR_Success ;
    UINT cMsecWait = DEFAULT_LM_PROVIDER_WAIT ;

    //
    // we almost always hit the wksta soon after this call & the wksta
    // is usually started. so this check will avoid paging in the service
    // controller. it just ends up paging in the wksta a bit earlier.
    // only if the call fails do we hit the service controller for the
    // actual status.
    //
    WKSTA_10 wksta_10 ;

    if ( (wksta_10.QueryError() == NERR_Success) &&
         (wksta_10.GetInfo() == NERR_Success) )
    {
        return 0x1 ; // already started, so say we're going to start real soon
    }

    do { // error breakout

    SC_MANAGER scman( NULL, (UINT) (GENERIC_READ | GENERIC_EXECUTE) ) ;
    if ( err = scman.QueryError() )
    {
        DBGEOL("NETUI: GetTimeOutCap - Failed to open Service Manager, "
            << " error = " << err ) ;
        break ;
    }

    LPQUERY_SERVICE_CONFIG psvcConfig ;
    SC_SERVICE svcWksta( scman, (const TCHAR *) SERVICE_WORKSTATION ) ;
    if ( (err = svcWksta.QueryError()) ||
         (err = svcWksta.QueryConfig( &psvcConfig )) )
    {
        DBGEOL("NETUI: GetTimeOutCap - Failed to open Service/get config info "
            << ", error = " << err ) ;
        break ;
    }

    switch ( psvcConfig->dwStartType )
    {
    case SERVICE_DISABLED:
        TRACEEOL("NETUI: GetTimeOutCap: Workstation service is disabled" ) ;
        cMsecWait = 0 ;
        break ;

    case SERVICE_AUTO_START:
    case SERVICE_DEMAND_START:
        {
        /* Try and get the wait hint from the service
         */
        SERVICE_STATUS svcStatus ;
        if ( err = svcWksta.QueryStatus( &svcStatus ))
        {
            DBGEOL("NETUI: GetTimeOutCap - Failed to get "
                << "Service status, error = " << err ) ;
            break ;
        }

        /* If the workstation is going to stop, there's no point
         * in telling the router to restore connections
         */
        if ( svcStatus.dwCurrentState == SERVICE_STOP_PENDING )
        {
            cMsecWait = 0 ;
            break ;
        }

        /* If wksta service is stopped, then check to see if we
         * might start or have already ran (exit code will be set
         * if we've started and exited due to an error).
         */
        if ( svcStatus.dwCurrentState == SERVICE_STOPPED )
        {
            if ( psvcConfig->dwStartType == SERVICE_AUTO_START )
            {
                        if ( svcStatus.dwWin32ExitCode !=
                                                 ERROR_SERVICE_NEVER_STARTED )
            {
                cMsecWait = 0 ;
            }
            else
            {
                cMsecWait = 0xffffffff ;
            }
            }
            else
            {
            /* If we're demand start (i.e., the user starts us), then
             * we most likely aren't going to start here.
             */
            UIASSERT(psvcConfig->dwStartType==SERVICE_DEMAND_START) ;
            cMsecWait = 0 ;
            }
            break ;
        }

        TRACEEOL("NETUI: GetTimeOutCap - Wait hint for the workstation "
             << "service is " << (ULONG) svcStatus.dwWaitHint << "msec") ;

        /* If zero is returned, then the service has probably already
         * started.  Return the "I don't know but keep trying" status so
         * the router will do the connect next time around.
         */
        cMsecWait =  (UINT)  (svcStatus.dwWaitHint != 0 ?
                    svcStatus.dwWaitHint : 0xffffffff ) ;
        }
        break ;

    /* The workstation service should not be boot started or system started
     */
    case SERVICE_BOOT_START:
    case SERVICE_SYSTEM_START:
    default:
        cMsecWait = 0xffffffff ;
        break ;
    }

    } while (FALSE) ;

    return cMsecWait ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\shell\shell\wnuser.cxx ===
/*****************************************************************/
/**                  Microsoft LAN Manager                      **/
/**            Copyright(c) Microsoft Corp., 1989-1991          **/
/*****************************************************************/

/*
 *      Windows/Network Interface  --  LAN Manager Version
 *
 *
 *  History:
 *      rustanl     23-Apr-1991     Revised to use WKSTA_10 class.
 *      beng        17-May-1991     Corrected lmui.hxx usage
 *      terryk      01-Nov-1991     Add WIN32 WNetGetUser interface
 *      terryk      04-Nov-1991     Code review change. Attend: johnl
 *                                  chuckc davidhov
 *      terryk      06-Jan-1992     Use NET_NAME class
 *      beng        06-Apr-1992     Unicode fixes
 *      anirudhs    01-Oct-1995     Unicode cleanup, return domain\user
 *
 */


#define INCL_WINDOWS
#define INCL_NETERRORS
#define INCL_NETCONS
#define INCL_NETWKSTA
#define INCL_NETLIB
#define INCL_NETUSE
#define INCL_NETSHARE
#define INCL_NETSERVICE
#define INCL_ICANON
#define _WINNETWK_
#include <lmui.hxx>
#undef _WINNETWK_
#include <blt.hxx>
#include <dbgstr.hxx>

#include <lmapibuf.h>
#include <winnetwk.h>
#include <npapi.h>
#include <winlocal.h>

#include <string.h>
#include <uiassert.hxx>
#include <lmowks.hxx>
#include <lmodev.hxx>
#include <lmsvc.hxx>
#include <netname.hxx>

#define IS_EMPTY_STRING(pch) (!(pch) || !*(pch))


DWORD APIENTRY
NPGetUser (
    LPWSTR  pszName,
    LPWSTR  pszUser,
    LPDWORD lpnBufferLen )
{
    APIERR err = NERR_Success ;

    LM_SERVICE service( NULL, (const WCHAR *)SERVICE_WORKSTATION );
    if ( !service.IsStarted() && !service.IsPaused())
    {
        // if not started nor paused return error. paused is actually
	// OK for LM workstation
        return WN_NO_NETWORK;
    }

    // MPR should take care of the NULL username case
    UIASSERT (! IS_EMPTY_STRING(pszName));

    BYTE * pBuf = NULL ;
    switch (err = NetUseGetInfo( NULL, pszName, 3, &pBuf ))
    {
    case NERR_Success:
        break ;

    case NERR_UseNotFound:
        err = WN_NOT_CONNECTED ;
        break ;

    default:
        DBGEOL("NPGetUser - Error " << (ULONG) err << " returned from DEVICE2.GetInfo") ;
        break ;
    }

    if ( err )
    {
        NetApiBufferFree( pBuf ) ;
        pBuf = NULL;
        return MapError( err ) ;
    }

    USE_INFO_3 * pui3 = (USE_INFO_3 *) pBuf ;
    USE_INFO_2 * pui2 = &pui3->ui3_ui2;

    if (IS_EMPTY_STRING(pui2->ui2_username))
    {
        /* Unexpectedly the user name field is NULL, nothing we can do
         * except bag out.
         */
        err = WN_NET_ERROR ;
    }
    else
    {
        DWORD nUserNameLen = wcslen(pui2->ui2_username) + 1;
        if (! IS_EMPTY_STRING(pui2->ui2_domainname))
        {
            nUserNameLen += wcslen(pui2->ui2_domainname) + 1;
        }

        if ( nUserNameLen > *lpnBufferLen )
        {
            err = WN_MORE_DATA;        // user name cannot fit in given buffer
            *lpnBufferLen = nUserNameLen ;
        }
        else
        {
            if (IS_EMPTY_STRING(pui2->ui2_domainname))
            {
                wcscpy( pszUser, pui2->ui2_username );
            }
            else
            {
                wcscpy( pszUser, pui2->ui2_domainname );
                wcscat( pszUser, L"\\" );
                wcscat( pszUser, pui2->ui2_username );
            }
        }
    }

    /* If default credentials were used, return that info to the MPR
     */

    if ((err == WN_SUCCESS) && (pui3->ui3_flags & USE_DEFAULT_CREDENTIALS))
    {
        err = WN_CONNECTED_OTHER_PASSWORD_DEFAULT;
    }

    NetApiBufferFree( pBuf ) ;
    pBuf = NULL;

    return err ;

}  /* NPGetUser */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\shell\test\apphacks.cxx ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1987-1990          **/
/********************************************************************/

/*
 *  FILE STATUS:
 *  12/28/90  created
 *  1/12/91  Split from Logon App, reduced to just Shell Test APP
 */

#ifdef CODESPEC
/*START CODESPEC*/

/***********
APPHACKS.CXX
***********/

/****************************************************************************

    MODULE: AppHacks.cxx

    PURPOSE: Hack nonsense added to correct linkage problems etc.

    FUNCTIONS:

    COMMENTS:

****************************************************************************/


/***************
end APPHACKS.CXX
***************/

/*END CODESPEC*/
#endif // CODESPEC

#include "apptest.hxx"

#undef brkpt

extern "C" {
void brkpt(void);
void SetNetError(WORD);
}

/* internal procedure declarations */


/* Junk added for linkage problems */
extern "C" {
extern DWORD FAR PASCAL GlobalDosAlloc (DWORD);
DWORD (FAR PASCAL *lpfnGlbDosAlloc)(DWORD) = GlobalDosAlloc;
}

void SetNetError(WORD w)
{
    (void) w;
}


/* procedures */


/*
 * The following dummy ininlsf replaces the real one in the Windows
 * C-runtime.  This prevents the real one from trying to call
 * DOSGETCOLLATE and crashing the system.
 */
// void ininlsf()
// {
//     return;
// }

/*
 * The following brkpt() hack makes it unnecessary to link DOSNET.
 */
void brkpt(void)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\shell\shell\wnetconn.cxx ===
/*****************************************************************/
/**                  Microsoft LAN Manager                      **/
/**            Copyright(c) Microsoft Corp., 1989-1991          **/
/*****************************************************************/

/*
 *      Windows/Network Interface  --  LAN Manager Version
 *  FILE HISTORY:
 *      RustanL     ??-??-??        Created
 *      ChuckC      27-Mar-1991     Added extra calls to SetNetError()
 *      beng        17-May-1991     Corrected lmui.hxx usage
 *      terryk      16-Sep-1991     Change NetUseXXX to DEVICE object
 *      terryk      07-Oct-1991     types change for NT
 *      terryk      17-Oct-1991     Fix Device problem
 *                                  Add WNetAddConnect2 interface
 *      terryk      08-Nov-1991     Code review changes
 *      terryk      10-Dec-1991     Added BUGBUG to validate path name
 *                                  need to use NET_NAME class to break
 *                                  the path into 2 parts
 *      Yi-HsinS    31-Dec-1991     Unicode work
 *      terryk      03-Jan-1992     Add AddConnection and AddConnection2
 *                                  functions
 *      terryk      10-Jan-1992     Use NETNAME to check path name
 *      JohnL       14-Jan-1992     Added check for ERROR_BAD_NET_PATH and
 *                                  NERR_DevInUse to WNet functions.
 *      AnirudhS    01-Oct-1995     Fixed function names.
 *      MilanS      15-Mar-1996     Added Dfs functionality
 *
 */

#include <ntincl.hxx>
extern "C"
{
    #include <ntseapi.h>
    #include <ntddnfs.h>
}

#include <netlibnt.h>

#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_DOSERRORS
#define INCL_NETERRORS
#define INCL_NETUSE
#define INCL_NETWKSTA
#define INCL_NETLIB
#define INCL_NETSERVICE
#define INCL_ICANON
#define _WINNETWK_
#include <lmui.hxx>
#undef _WINNETWK_

#include <stdlib.h>
#include <stdio.h>
#include <mnet.h>

#include <winnetwk.h>
#include <winnetp.h>    // GetConnection3 structures
#include <mpr.h>        // IS_USERNAME_PASSWORD_ERROR()

#include <npapi.h>
#include <lmapibuf.h>
#include <winlocal.h>
#include <wndebug.h>

#include <wnintrn.h>
#include <uiprof.h>

// Include the profile functions
#include <string.hxx>
#include <winprof.hxx>

#include <strchlit.hxx>  // for EMPTY_STRING
#include <miscapis.hxx>
#include <uibuffer.hxx>
#include <uiassert.hxx>
#include <uitrace.hxx>
#include <lmodev.hxx>
#include <lmowks.hxx>
#include <lmsvc.hxx>
#include <netname.hxx>

#include <security.hxx>
#include <ntacutil.hxx>     // For NT_ACCOUNTS_UTILTIY::CrackQualifiedAccountName

#include "dfsconn.hxx"
#include <dfsutil.hxx>

#include <wincred.h>

#include <errornum.h>
#include <apperr.h>


#define IPC_SUFFIX  L"\\IPC$"
#define ARRAYLEN(x) (sizeof(x) / sizeof((x)[0]))

extern "C" DWORD
I_NetDfsIsThisADomainName(
    IN  LPCWSTR                      wszName
    );
    
#define UNICODE_PATH_SEP L'\\'
//
// Errors returned from DFS (NPDfsAddConnection)
// indicating that a non-DFS share was passed in.
//
// For WN_BAD_LOCALNAME, lpt1: is a bad local name for DFS but valid for NTLM
// For WN_BAD_USER, "" is a bad user for DFS but valid for NTLM
//

#define IS_NON_DFS_SHARE_ERROR(x)       \
            ((x) == WN_BAD_NETNAME   || \
             (x) == WN_BAD_VALUE     || \
             (x) == WN_BAD_LOCALNAME || \
             (x) == WN_BAD_USER)

//
// Non-recoverable errors returned from DFS
// (NPDfsAddConnection) for DFS shares.
//

#define IS_RETURNABLE_DFS_ERROR(x) \
            (!IS_NON_DFS_SHARE_ERROR(x) && !IS_USERNAME_PASSWORD_ERROR(x))


/*  Local prototypes  */

APIERR DisconnectUNC( const TCHAR * pszUNCName, LMO_DEVICE lmodev, BOOL fForce ) ;

DWORD
AddConnection3Help(
    LPTSTR         pszNetPath,
    LPTSTR         pszPassword,
    LPTSTR         pszLocalName,
    LPTSTR         pszUserName,
    ULONG          ulNetUseFlags
    );

DWORD
AddConnectionWorker(
    HWND           hwndOwner,
    LPNETRESOURCE  lpNetResource,
    LPTSTR         pszPassword,
    LPTSTR         pszUserName,
    DWORD          dwFlags,
    BOOL           *lpfIsDfsConnect,
    BOOL CalledFromCsc
    );

#ifdef __cplusplus
extern "C" {
#endif

DWORD APIENTRY
NPAddConnection3ForCSCAgent(
    HWND            hwndOwner,
    LPNETRESOURCE   lpNetResource,
    LPTSTR          pszPassword,
    LPTSTR          pszUserName,
    DWORD           dwFlags,
    BOOL            *lpfIsDfsConnect
    );

DWORD APIENTRY
NPCancelConnectionForCSCAgent (
    LPCTSTR         szName,
    BOOL            fForce );

#ifdef __cplusplus
}
#endif

extern HMODULE hModule;

typedef
int
(WINAPI
*PFN_LOADSTRING)(
    HINSTANCE hInstance,
    UINT uID,
    LPWSTR lpBuffer,
    int nBufferMax
    );

typedef
DWORD
(WINAPI
*PFN_CREDUI_PROMPTFORCREDENTIALS)(
    PCREDUI_INFOW pUiInfo,
    PCWSTR pszTargetName,
    PCtxtHandle pContext,
    DWORD dwAuthError,
    PWSTR pszUserName,
    ULONG ulUserNameMaxChars,
    PWSTR pszPassword,
    ULONG ulPasswordMaxChars,
    PBOOL pfSave,
    DWORD dwFlags
    );

typedef
DWORD
(WINAPI
*PFN_CREDUI_CMDLINE_PROMPTFORCREDENTIALS)(
    PCWSTR pszTargetName,
    PCtxtHandle pContext,
    DWORD dwAuthError,
    PWSTR UserName,
    ULONG ulUserMaxChars,
    PWSTR pszPassword,
    ULONG ulPasswordMaxChars,
    PBOOL pfSave,
    DWORD dwFlags
    );

typedef
void
(WINAPI
*PFN_CREDUI_CONFIRMCREDENTIALS)(
    PCWSTR pszTargetName,
    BOOL  bConfirm
    );

HMODULE
InitCredUI(
    IN BOOL  fDFSShare,
    IN PWSTR pszRemoteName,
    OUT PWSTR pszServer,
    IN ULONG ulServerLength,
    OUT PFN_CREDUI_PROMPTFORCREDENTIALS *pfnCredUIPromptForCredentials,
    OUT PFN_CREDUI_CMDLINE_PROMPTFORCREDENTIALS *pfnCredUICmdlinePromptForCredentials,
    OUT PFN_CREDUI_CONFIRMCREDENTIALS *pfnCredUIConfirmCredentials
    )
{

    // Make sure the first 2 characters are path separators:

    if ((pszRemoteName == NULL) ||
        (pszRemoteName[0] != L'\\') ||
        (pszRemoteName[1] != L'\\'))
    {
        return NULL;
    }


    PWSTR pszStart = pszRemoteName + 2;
    PWSTR pszEnd = NULL;

    if ( fDFSShare )
    {
        // send the whole thing (minus the initial double backslash
        pszEnd = pszStart + wcslen(pszStart);

    }
    else
    {
        // send only the server name, the string up to the first slash
        pszEnd = wcschr(pszStart, PATH_SEPARATOR);

        if (pszEnd == NULL)
        {
            pszEnd = pszStart + wcslen(pszStart);
        }
    }

    DWORD_PTR dwLength = (DWORD_PTR)(pszEnd - pszStart);

    if ((dwLength == 0) || (dwLength >= ulServerLength))
    {
        // The server is either an empty string or more than the maximum
        // number of characters we support:

        SetLastError(WN_BAD_NETNAME);
        return NULL;
    }

    wcsncpy(pszServer, pszStart, dwLength);
    pszServer[dwLength] = L'\0';

    // Load the DLL here and find the function we need:

    HMODULE hCredUI = LoadLibrary(L"credui.dll");

    if (hCredUI != NULL)
    {

        *pfnCredUIPromptForCredentials = (PFN_CREDUI_PROMPTFORCREDENTIALS)
            GetProcAddress(hCredUI, "CredUIPromptForCredentialsW");
        if (*pfnCredUIPromptForCredentials == NULL)
        {
            FreeLibrary(hCredUI);
            hCredUI = NULL;
            goto Cleanup;
        }

        *pfnCredUICmdlinePromptForCredentials = (PFN_CREDUI_CMDLINE_PROMPTFORCREDENTIALS)
            GetProcAddress(hCredUI, "CredUICmdLinePromptForCredentialsW");
        if (*pfnCredUICmdlinePromptForCredentials == NULL)
        {
            FreeLibrary(hCredUI);
            hCredUI = NULL;
            goto Cleanup;
        }

        *pfnCredUIConfirmCredentials = (PFN_CREDUI_CONFIRMCREDENTIALS)
            GetProcAddress(hCredUI, "CredUIConfirmCredentialsW");

        if (*pfnCredUIConfirmCredentials == NULL)
        {
            FreeLibrary(hCredUI);
            hCredUI = NULL;
            goto Cleanup;
        }

    }

Cleanup:
    return hCredUI;
}

VOID
InitCredUIStrings(
    PCWSTR pszRemoteName,
    PWSTR pszCaption,
    ULONG ulCaptionLength,
    PWSTR pszMessage,
    ULONG ulMessageLength
    )
{
    pszCaption[0] = L'\0';
    pszMessage[0] = L'\0';

    // Since we're doing UI, user32.dll must be loaded, so just call
    // GetModuleHandle here. We don't need to ref count the DLL since
    // it will stay loaded as long as the credential UI is loaded:

    HMODULE hUser32 = GetModuleHandle(L"user32.dll");

    if (hUser32 != NULL)
    {
        PFN_LOADSTRING pfnLoadString =
            (PFN_LOADSTRING) GetProcAddress(hUser32, "LoadStringW");

        if (pfnLoadString != NULL)
        {
            // We're not really interested in failure cases. In that
            // case, the remote name will be the only thing displayed.

            pfnLoadString(hModule,
                          IDS_CREDENTIALS_CAPTION,
                          pszCaption,
                          ulCaptionLength);

            pfnLoadString(hModule,
                          IDS_CREDENTIALS_MESSAGE,
                          pszMessage,
                          ulMessageLength);
        }
    }

    if (pszCaption[0] == L'\0')
    {
        // The caption string is empty, so just copy the remote name;
        // at least this is better than nothing:

        wcsncpy(pszCaption,
                pszRemoteName,
                ulCaptionLength);
    }

    // !!! For localization, the server name may not always come at
    //     the end of the string, so rather can a concatenation, a
    //     _snwprintf may be more appropriate.
    //
    // Concatenate the remote name to the text message:

    DWORD length = wcslen(pszMessage);

    wcsncpy(pszMessage + length,
            pszRemoteName,
            ulMessageLength - length);
}

/*******************************************************************
 *
 *  NPGetConnection()
 *
 *  This function returns the name of the network resource associated with
 *  a redirected local device.
 *
 *  pszLocalName specifies the name of the redirected local device, and
 *  nBufferSize should point to the maximum length of the pszRemoteName
 *  buffer.
 *
 *  Input:     pszLocalName   -- specifies the name of the redirected
 *                              local device
 *             pszRemoteName  -- pointer to empty buffer
 *             nBufferSize   -- pointer to size of pszRemoteName buffer
 *
 *  Output:    *pszLocalName  -- unchanged
 *             *pszRemoteName -- contains the remote name of the local
 *                              device upon WN_SUCCESS.  Do not use
 *                              contents of this buffer if this function
 *                              is unsuccessful.
 *             *nBufferSize  -- size of pszRemoteName buffer needed.  This
 *                              is returned upon WN_SUCCESS and
 *                              WN_MORE_DATA.  Incase of the former,
 *                              it contains how much is actually used,
 *                              whereas incase of the latter, it contains
 *                              how big a buffer would be required to
 *                              return from this function with success.
 *
 *  Return Status Codes:
 *
 *     WN_SUCCESS           success
 *     WN_NOT_CONNECTED     pszLocalName is not a redired local device
 *     WN_BAD_VALUE         pszLocalName is not a valid local device
 *     WN_MORE_DATA         buffer was too small
 *     WN_OUT_OF_MEMORY     cannot allocate buffer due memory shortage
 *     WN_NET_ERROR         other network error
 *
 * History:
 *      Johnl   18-Feb-1992     Fixed problems with not checking the buffer
 *                              size.  Removed LMO_DEV_UNAVAIL case under
 *                              win32.
 *      beng    06-Apr-1992     Unicode conversion
 *      JohnL   24-Apr-1992     Converted to Character counts
 *
 *******************************************************************/

UINT
NPGetConnection(
    LPTSTR    pszLocalName,
    LPTSTR    pszRemoteName,
    LPUINT    nBufferSize )
{
    APIERR  err ;

    if ( err = CheckLMService() )
        return err ;

    err = NPDfsGetConnection(pszLocalName, pszRemoteName, nBufferSize);
    if (err == WN_SUCCESS || err == WN_MORE_DATA) {
        return err;
    }

    /*  pass the job along to the NetUseGetInfo() API  */

    DEVICE device( pszLocalName );

    err = device.GetInfo();

    /* Error notes:
     *   - The API documentation lists both NERR_BufTooSmall and
     *     ERROR_MORE_DATA as possible error return codes.  It seems that
     *     ERROR_MORE_DATA is the one that is going to be returned if
     *     given buffer is not large enough when using information
     *     level 1, but just to make sure, both of the codes are included
     *     above.  This way, either of these codes will produce a
     *     WN_MORE_DATA error.  The required size is passed back as
     *     promised.
     *   - Any other error not explicitly outlined above is treated as
     *     a misc. net error.
     */
    switch (err)
    {
    case NERR_Success:
        switch ( device.QueryState() )
        {

        /* This is the case where a connection is remembered
         */
        case LMO_DEV_UNAVAIL:
            /* Under Win32, MPR handles all of the remembered connections, thus
             * we should never get this case.
             */
            UIASSERT( FALSE ) ;
            err = WN_NET_ERROR ;
            break;

        case LMO_DEV_NOSUCH:
            err = WN_NOT_CONNECTED;
            break;

        default:
            if ( device.QueryStatus() == USE_NETERR)
            {
               err = WN_DEVICE_ERROR;
            }
            else
            {
                /* A NULL from QueryRemoteName indicates the device is not
                 * connected.
                 */
                ALIAS_STR nlsRemoteName( device.QueryRemoteName() == NULL ?
                                                EMPTY_STRING :
                                                device.QueryRemoteName() ) ;
                /* +1 for Null *character*
                 */
                UINT nBuffRequired = nlsRemoteName.QueryTextLength() + 1 ;
                if ( nBuffRequired > *nBufferSize )
                {
                    *nBufferSize = nBuffRequired ;
                    return WN_MORE_DATA ;
                }

                /* If there is no remote name then this isn't a connected
                 * device.
                 */
                if ( nlsRemoteName.strlen() == 0  )
                {
                    err = WN_NOT_CONNECTED;
                }
                else
                {
                    ::strcpy( pszRemoteName, nlsRemoteName ) ;
                    err = WN_SUCCESS;
                }
            }
            break;
        }
        break;

    case ERROR_INVALID_PARAMETER:
        err = WN_BAD_LOCALNAME ;
        break;

    case NERR_BufTooSmall:
    case ERROR_MORE_DATA:
        *nBufferSize = sizeof(use_info_1);
        err = WN_MORE_DATA;
        break;

    default:
        break ;
    }

    return (MapError(err)) ;

}  /*  NPGetConnection()  */


/*******************************************************************
 *
 *  NPGetConnection3()
 *
 *  This function returns miscellaneous information about a network
 *  connection, depending on the info level parameter.
 *
 *  Input:  pszLocalName   -- specifies the name of a redirected
 *                          local device
 *          dwLevel -- level of info required
 *          lpBuffer -- output buffer
 *          lpBufferSize -- output buffer size in bytes
 *
 *  Output: *pszLocalName  -- unchanged
 *          *lpBuffer      -- for level 1, set to a DWORD which tells
 *                          whether the connection is disconnected,
 *                          either WNGETCON_CONNECTED or
 *                          WNGETCON_DISCONNECTED.
 *          *pszRemoteName -- contains the remote name of the local
 *                          device upon WN_SUCCESS.  Do not use
 *                          contents of this buffer if this function
 *                          is unsuccessful.
 *          *lpBufferSize  -- size of pszRemoteName buffer needed.  This
 *                          is returned upon WN_MORE_DATA.
 *
 *  Return Status Codes:
 *
 *     WN_SUCCESS           success
 *     WN_NOT_CONNECTED     pszLocalName is not a redirected local device
 *     WN_BAD_VALUE         pszLocalName is not a valid local device
 *     WN_BAD_LEVEL         dwLevel is not a supported level
 *     WN_MORE_DATA         buffer was too small
 *     WN_OUT_OF_MEMORY     cannot allocate buffer due memory shortage
 *     WN_NET_ERROR         other network error
 *
 * History:
 *
 *      AnirudhS 20-Mar-1996    Created
 *
 *******************************************************************/

//
// Size of buffer for calling NPDfsGetConnection.
//
#define REMOTE_DFS_SIZE 32

DWORD APIENTRY
NPGetConnection3 (
    LPCWSTR   lpLocalName,
    DWORD     dwLevel,
    LPVOID    lpBuffer,
    LPDWORD   lpBufferSize
    )
{
    WCHAR  RemoteDfsName[REMOTE_DFS_SIZE];
    UINT   RemoteDfsNameSize = REMOTE_DFS_SIZE;
    DWORD err;

    if (dwLevel != WNGC_INFOLEVEL_DISCONNECTED)
    {
        return WN_BAD_LEVEL;
    }

    //
    // We call the existing get connection, and if that succeeds or
    // indicates more data exists, we know this is connected.
    //
    err = NPDfsGetConnection((LPWSTR)lpLocalName, RemoteDfsName, &RemoteDfsNameSize );
    if (err == WN_SUCCESS || err == WN_MORE_DATA) {

        ((WNGC_CONNECTION_STATE *)lpBuffer)->dwState = WNGC_CONNECTED;

        return WN_SUCCESS;
    }


    USE_INFO_1 * UseInfo;
    err = NetUseGetInfo(NULL, (LPWSTR) lpLocalName, 1, (LPBYTE *) &UseInfo);

    if (err != NERR_Success)
    {
        return (MapError(err));
    }

    DWORD dwState = (UseInfo->ui1_status == USE_DISCONN)
                            ? WNGC_DISCONNECTED
                            : WNGC_CONNECTED;

    NetApiBufferFree(UseInfo);

    if (*lpBufferSize < sizeof(WNGC_CONNECTION_STATE))
    {
        *lpBufferSize = sizeof(WNGC_CONNECTION_STATE);
        return WN_MORE_DATA;
    }

    ((WNGC_CONNECTION_STATE *)lpBuffer)->dwState = dwState;

    return WN_SUCCESS;
}  /*  NPGetConnection3()  */


/*******************************************************************

    NAME:       NPAddConnection

    SYNOPSIS:   The function allows the caller to redirect (connect) a
                local device to a network resource.

    ENTRY:      LPTSTR lpRemoteName - Specifies the network resource to
                    connect to
                LPTSTR lpPassword - specifies the password to be used in
                    making the connection, normally the password
                    associated with lpUserName. The NULL value may be
                    passed in to indicate to the function to use the
                    default password. An empty string may be used to
                    indicated no password.
                LPTSTR lpLocalName - this specifies the name of a local
                    device to be redirected, such as "F:" or "LPT1". The
                    string is treated in a case insensitive may be the empty
                    string in which case a connection to the netowrk
                    resource is made without making a redirection.
                LPSTR lpUserName - this specifies the username used to
                    make the connection. If NULL, the default username
                    (currently logged on user) will be applied. This is used
                    when the user wishes to connect to a resourec, but has a
                    different user name or account assigned to him for that
                    resource.

    RETURNS:    WN_SUCCESS if the call is successful. Otherwise,
                GetLastError should be called for extended error information.
                Extended error codes includes:

                WN_BAD_NETNAME - lpRemoteName is not acceptable to any
                    provider.
                WN_BAD_LOCALNAME - lpLocalName is invalid.
                WN_BAD_PASSWORD - invalid password
                WN_ALREADY_CONNECTED - lpLocalName already connected
                WN_ACCESS_DENIED - access denied
                WN_NO_NETWORK - network is not present
                WN_NONET_OR_BADNAME - the operation could not be handled
                    either because a network component is not started or
                    the specified name could not be handled.
                WN_NET_ERROR - a network specific error occured.
                WNetGetLastError should be called to obtain further
                    information.

    HISTORY:
                terryk  31-Oct-91       Created

********************************************************************/

DWORD APIENTRY
NPAddConnection (
    LPNETRESOURCE   lpNetResource,
    LPTSTR          pszPassword,
    LPTSTR          pszUserName )
{
    UIASSERT( lpNetResource != NULL );

    return NPAddConnection3(
                NULL,
                lpNetResource,
                pszPassword,
                pszUserName,
                0);
}


VOID
DisplayFailureReason(
    DWORD Status,
    LPCWSTR Path
    )

/*++

Routine Description:

    This routine displays the reason for the authentication failure.
    The complete path name is displayed.

    We could modify credui to display this, but credui doesn't have the full path name.

Arguments:

    Status - Status of the failure

    Path - Full path name of the failed authentication.

Return Value:

    None.

--*/
{
    DWORD MessageId;
    LPWSTR InsertionStrings[2];

    HMODULE lpSource = NULL;
    DWORD MessageLength = 0;
    LPWSTR Buffer = NULL;
    BOOL MessageFormatted = FALSE;

    //
    // Pick the message based in the failure status
    //

    MessageId = ( Status == ERROR_LOGON_FAILURE) ? APE_UseBadPassOrUser : APE_UseBadPass;
    InsertionStrings[0] = (LPWSTR) Path;


    //
    // Load the message library and format the message from it
    //

    lpSource = LoadLibrary( MESSAGE_FILENAME );

    if ( lpSource ) {

        //
        // Format the message
        //

        MessageLength = FormatMessageW( FORMAT_MESSAGE_ARGUMENT_ARRAY |
                                            FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                            FORMAT_MESSAGE_FROM_HMODULE,
                                        lpSource,
                                        MessageId,
                                        0,       // LanguageId defaulted
                                        (LPWSTR) &Buffer,
                                        1024,   // Limit the buffer size
                                        (va_list *) InsertionStrings);

        if ( MessageLength ) {
            MessageFormatted = TRUE;
        }
    }


    //
    // If it failed, print a generic message
    //

    if ( !MessageFormatted ) {
        WCHAR NumberString[18];

        //
        // get the message number in Unicode
        //
        _ultow(MessageId, NumberString, 16);

        //
        // setup insert strings
        //
        InsertionStrings[0] = NumberString;
        InsertionStrings[1] = MESSAGE_FILENAME;

        //
        // Use the system messge file.
        //

        MessageLength = FormatMessageW( FORMAT_MESSAGE_ARGUMENT_ARRAY |
                                            FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                            FORMAT_MESSAGE_FROM_SYSTEM,
                                        NULL,
                                        ERROR_MR_MID_NOT_FOUND,
                                        0,       // LanguageId defaulted
                                        (LPWSTR) &Buffer,
                                        1024,
                                        (va_list *) InsertionStrings);

    }


    //
    // Avoid double newlines
    //

    if ( MessageLength >= 2) {

        if ( Buffer[MessageLength - 1] == L'\n' &&
             Buffer[MessageLength - 2] == L'\r') {

            //
            // "\r\n" shows up as two newlines when using the CRT and piping
            // output to a file.  Make it just one newline.
            //

            Buffer[MessageLength - 1] = L'\0';
            Buffer[MessageLength - 2] = L'\n';
            MessageLength --;
        }
    }


    //
    // Output the message to stdout
    //

    if ( MessageLength > 0 ) {

        fputws( Buffer, stdout );
        fputws( L"\n", stdout );
    }


    //
    // Clean up before exitting
    //

    if ( lpSource != NULL ) {
        FreeLibrary( lpSource );
    }

    if ( Buffer != NULL ) {
        LocalFree( Buffer );
    }

}


/*******************************************************************

    NAME:       NPAddConnection3

    SYNOPSIS:   This function creates a network connection.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Johnl   20-Feb-1992     Commented, fixed for deviceless connections
        JohnL   27-Mar-1992     Add support for "domain\username"
        beng    06-Apr-1992     Unicode conversion
        BruceFo  14-Jun-1995    Created NPAddConnection3
        anirudhs 15-Jan-1996    Add CONNECT_DEFERRED support
        anirudhs 12-Feb-1996    Merged NPAddConnection3 and AddConnection3
        anirudhs 19-Jun-1996    Allow setting up a null session, by
            specifying a null local name, empty user name, empty password

********************************************************************/

DWORD APIENTRY
NPAddConnection3(
    HWND           hwndOwner,
    LPNETRESOURCE  lpNetResource,
    LPTSTR         pszPassword,
    LPTSTR         pszUserName,
    DWORD          dwFlags
    )
{
    BOOL IsDfs;

    //
    // Simply call the worker routine to create the connection
    //

    return AddConnectionWorker( hwndOwner,
                                lpNetResource,
                                pszPassword,
                                pszUserName,
                                dwFlags,
                                &IsDfs,
                                FALSE );    // Not called from CSC

}


/*******************************************************************

    NAME:       AddConnectionWorker

    SYNOPSIS:   This function creates a network connection.
        It is shared code between NPAddConnection3 and NPAddConnection3ForCSCAgent

    ENTRY:

        Same as for NPAddConnection3 except for the following:

        lpfIsDfsConnect: Returns true if this is a DFS connection

        CalledFromCsc: True if the routine is being called from CSC.
            This flag is used to prevent this code from calling CSC

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        CliffV  06-Dec-2000     Created so we don't have two implementations of similar code

********************************************************************/

DWORD
AddConnectionWorker(
    HWND           hwndOwner,
    LPNETRESOURCE  lpNetResource,
    LPTSTR         pszPassword,
    LPTSTR         pszUserName,
    DWORD          dwFlags,
    BOOL *lpfIsDfsConnect,
    BOOL CalledFromCsc
    )
{
    WCHAR szPassword[CREDUI_MAX_PASSWORD_LENGTH + 1];    // if the user needs to enter one
    WCHAR szUserName[CREDUI_MAX_USERNAME_LENGTH + 1];    //    "                       "
    DWORD dwErr = NO_ERROR;
    ULONG ulNetUseFlags = 0;
    DWORD dwNetErr = NERR_Success;

    //
    // Try DFS first (Unless we need to prompt first)
    //
    // Bypass CSC if we're being called from CSC
    //

    *lpfIsDfsConnect = FALSE;

    if (!(dwFlags & CONNECT_PROMPT))
    {
        dwErr = NPDfsAddConnection(lpNetResource, pszPassword, pszUserName, dwFlags, CalledFromCsc);

        dwNetErr = (dwErr == ERROR_EXTENDED_ERROR) ? GetNetErrorCode() : NERR_Success;


        if (IS_RETURNABLE_DFS_ERROR(dwErr) && (dwNetErr != NERR_PasswordExpired))
        {
            *lpfIsDfsConnect = TRUE;

            //
            // If default credentials were used, return WN_CONNECTED_OTHER_PASSWORD_DEFAULT
            // to let the MPR know we used the default credentials to connect.
            //

            if (dwErr == NO_ERROR && pszUserName == NULL && pszPassword == NULL)
            {
                return WN_CONNECTED_OTHER_PASSWORD_DEFAULT;
            }

            return dwErr;
        }

        //
        // If we get logon failure from DFS,
        //  this is a dfs share.
        //
        if (IS_USERNAME_PASSWORD_ERROR(dwErr) || (dwNetErr == NERR_PasswordExpired))
        {
            *lpfIsDfsConnect = TRUE;

            if (!( dwFlags & CONNECT_INTERACTIVE ))  // Cannot popup dialog
            {
                return dwErr;
            }
        }

    //
    // Even if we don't try DFS first
    //  we need to determine if it is a DFS share.
    //

    }
    else
    {
        *lpfIsDfsConnect = IsDfsPathEx(lpNetResource->lpRemoteName, dwFlags, NULL, CalledFromCsc );
    }

    if (dwFlags & CONNECT_DEFERRED)
    {
        ulNetUseFlags |= CREATE_NO_CONNECT;
    }

    //
    // If we're being called from CSC,
    // bypass CSC on future connections.
    //

    if ( CalledFromCsc )
    {
        ulNetUseFlags |= CREATE_BYPASS_CSC;
    }

    //
    // Try other providers if this is not a DFS share.
    //

    if (!(*lpfIsDfsConnect))
    {
        if (!(dwFlags & CONNECT_PROMPT))
        {
            dwErr = AddConnection3Help(lpNetResource->lpRemoteName,
                                       pszPassword,
                                       lpNetResource->lpLocalName,
                                       pszUserName,
                                       ulNetUseFlags ) ;

            if ((dwErr == NO_ERROR) || !(dwFlags & CONNECT_INTERACTIVE))  // Cannot popup dialog
            {
                //
                // If default credentials were used, return WN_CONNECTED_OTHER_PASSWORD_DEFAULT
                // to let the MPR know we used the default credentials to connect.
                //

                if (dwErr == NO_ERROR && pszUserName == NULL && pszPassword == NULL)
                {
                    return WN_CONNECTED_OTHER_PASSWORD_DEFAULT;
                }

                return dwErr;
            }

            dwNetErr = (dwErr == ERROR_EXTENDED_ERROR) ? GetNetErrorCode() : NERR_Success;

            if (!IS_USERNAME_PASSWORD_ERROR(dwErr) && (dwNetErr != NERR_PasswordExpired))
            {
                // Errors not related to access problems
                return dwErr;
            }
        }
        else
        {
            // Got CONNECT_PROMPT. Make sure the path at least *looks* good
            // before putting up a dialog. If it doesn't look good, let MPR
            // keep routing.

            WCHAR wszCanonName[MAX_PATH];   // buffer for canonicalized name
            ULONG iBackslash;               // index into wszCanonName

            REMOTENAMETYPE rnt = ParseRemoteName(lpNetResource->lpRemoteName,
                                                 wszCanonName,
                                                 sizeof(wszCanonName),
                                                 &iBackslash);

            if ( rnt != REMOTENAMETYPE_SHARE &&
                 rnt != REMOTENAMETYPE_SERVER &&
                 rnt != REMOTENAMETYPE_PATH )
            {
                // then you can't connect to it!
                return WN_BAD_NETNAME;
            }
        }
    }

    UIASSERT(dwFlags & CONNECT_INTERACTIVE);

    szPassword[0] = L'\0';
    szUserName[0] = L'\0';
    if (NULL != pszUserName)
    {
        if (wcslen(pszUserName) > CREDUI_MAX_USERNAME_LENGTH)
        {
            return WN_BAD_USER;
        }

        wcscpy(szUserName, pszUserName);
    }

    // Prepare to use the credential manager user interface:

    WCHAR szServer[CRED_MAX_STRING_LENGTH + NNLEN + 1];
    PFN_CREDUI_PROMPTFORCREDENTIALS pfnCredUIPromptForCredentials;
    PFN_CREDUI_CMDLINE_PROMPTFORCREDENTIALS pfnCredUICmdlinePromptForCredentials;
    PFN_CREDUI_CONFIRMCREDENTIALS pfnCredUIConfirmCredentials;
    BOOL DfsShare = FALSE;

    if (*lpfIsDfsConnect == TRUE)
    {
        ULONG NameLen = wcslen(lpNetResource->lpRemoteName);
        LPWSTR UseName = new WCHAR[NameLen + 1];
        LPWSTR DomainName;
        ULONG i;

        if (UseName == NULL)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        wcscpy(UseName, lpNetResource->lpRemoteName);
        for(i = 0; i < NameLen && UseName[i] == UNICODE_PATH_SEP; i++)
        {
            NOTHING;
        }
        DomainName = &UseName[i];

        for(i = 0; i < NameLen && DomainName[i] != UNICODE_PATH_SEP; i++)
        {
            NOTHING;
        }
        if (i < NameLen)
        {
            DomainName[i] = UNICODE_NULL;
        }
        
        if (I_NetDfsIsThisADomainName(DomainName) == ERROR_SUCCESS)
        {
            DfsShare = TRUE;
        }
        delete [] UseName;
    }

    HMODULE hCredUI = InitCredUI(DfsShare,
                                 lpNetResource->lpRemoteName,
                                 szServer,
                                 ARRAYLEN(szServer),
                                 &pfnCredUIPromptForCredentials,
                                 &pfnCredUICmdlinePromptForCredentials,
                                 &pfnCredUIConfirmCredentials);

    if (hCredUI == NULL)
    {
        return GetLastError();
    }

    CREDUI_INFO uiInfo = { sizeof(uiInfo), hwndOwner, NULL, NULL, NULL };
    DWORD dwCredUIFlags = 0;

    // Require confirmation of the stored credential
    dwCredUIFlags |= CREDUI_FLAGS_EXPECT_CONFIRMATION;

    // allow CredUI to prompt just for a password and no username if necessary.
    dwCredUIFlags |= CREDUI_FLAGS_PASSWORD_ONLY_OK;

    WCHAR szCaption[128];
    WCHAR szMessage[128];

    BOOL fGetCredsFailed = FALSE;
    BOOL fStringsLoaded = FALSE;

    for (;;)    // forever
    {
        BOOL fCredWritten = FALSE;
        DWORD dwCredErr;
        DWORD dwAuthErr;
        LPWSTR pszNewPassword;

        //
        // Remember the original failure reason
        //

        dwAuthErr = (dwErr == ERROR_EXTENDED_ERROR ? GetNetErrorCode() : dwErr);

        if ( fGetCredsFailed )
        {
            dwCredErr = ERROR_NO_SUCH_LOGON_SESSION;
        }
        else if ( dwFlags & CONNECT_COMMANDLINE )
        {
            //
            // Display the reason for the failure with the full path name
            //

            DisplayFailureReason( dwAuthErr, lpNetResource->lpRemoteName );


            //
            // Set the appropriate flag to set the behavior of the common UI.
            //

            // We don't (yet) know how to handle certificates
            dwCredUIFlags |= CREDUI_FLAGS_EXCLUDE_CERTIFICATES;

            // Ensure that the username syntax is correct
            dwCredUIFlags |= CREDUI_FLAGS_VALIDATE_USERNAME;

            //
            // If the caller wants to save both username and password,
            //  create an enterprise peristed cred.
            //
            if ( dwFlags & CONNECT_CMD_SAVECRED ) {

                dwCredUIFlags |= CREDUI_FLAGS_PERSIST;

            //
            // If the caller doesn't want to save,
            //  that's OK too
            //
            } else {

                dwCredUIFlags |= CREDUI_FLAGS_DO_NOT_PERSIST;

            }

            dwCredErr = pfnCredUICmdlinePromptForCredentials (
                                            szServer,
                                            NULL,
                                            dwAuthErr,
                                            szUserName,
                                            ARRAYLEN(szUserName) - 1,
                                            szPassword,
                                            ARRAYLEN(szPassword) - 1,
                                            &fCredWritten,
                                            dwCredUIFlags);

        }
        else
        {
            dwCredErr = pfnCredUIPromptForCredentials (
                                            &uiInfo,
                                            szServer,
                                            NULL,
                                            dwAuthErr,
                                            szUserName,
                                            ARRAYLEN(szUserName) - 1,
                                            szPassword,
                                            ARRAYLEN(szPassword) - 1,
                                            &fCredWritten,
                                            dwCredUIFlags);
        }

        //
        // If we can't save the credential,
        //  try again asking credui to not support saving.
        //

        if (dwCredErr == ERROR_NO_SUCH_LOGON_SESSION)
        {
            szPassword[0] = L'\0';

            fGetCredsFailed = TRUE;
            fCredWritten = FALSE;

            //
            // Since there is no logon session,
            //  simply turn off the ability to save the cred and try again.
            //

            dwCredUIFlags |= CREDUI_FLAGS_DO_NOT_PERSIST;
            dwCredUIFlags &= ~CREDUI_FLAGS_PERSIST;

            if ( dwFlags & CONNECT_COMMANDLINE ) {

                dwCredErr = pfnCredUICmdlinePromptForCredentials (
                                                szServer,
                                                NULL,
                                                dwAuthErr,
                                                szUserName,
                                                ARRAYLEN(szUserName) - 1,
                                                szPassword,
                                                ARRAYLEN(szPassword) - 1,
                                                NULL,
                                                dwCredUIFlags);

            } else {

                if (!fStringsLoaded)
                {
                    InitCredUIStrings(lpNetResource->lpRemoteName,
                                      szCaption,
                                      ARRAYLEN(szCaption),
                                      szMessage,
                                      ARRAYLEN(szMessage));

                    uiInfo.pszMessageText = szMessage;
                    uiInfo.pszCaptionText = szCaption;

                    fStringsLoaded = TRUE;
                }

                dwCredErr = pfnCredUIPromptForCredentials (
                                                &uiInfo,
                                                szServer,
                                                NULL,
                                                dwAuthErr,
                                                szUserName,
                                                ARRAYLEN(szUserName) - 1,
                                                szPassword,
                                                ARRAYLEN(szPassword) - 1,
                                                NULL,
                                                dwCredUIFlags);
            }
        }

        // This comment is copied from the original version of this
        // function which used I_GetCredentials:
        //
        // Use the new password and user name! Note: we convert an empty
        // user name to a NULL user name. However, we leave an empty
        // password as a null string. Why? If you are connecting to a
        // Win95 machine with no password for read-only access but a
        // password for full access, the first time you try to make the
        // connection, with a null password, it fails. The password dialog
        // pops up. If you hit "ok" without typing anything, we read a
        // null string for the password, and use that. This time, the
        // connection attempt succeeds because we *are* passing a password
        // over the wire, and it is equal to the Win95 read-only password,
        // namely the null string.

        if (dwCredErr == ERROR_SUCCESS)
        {
            pszUserName = (L'\0' == szUserName[0]) ? NULL : szUserName;
            pszNewPassword = szPassword;
        }
        else
        {
            if (dwCredErr == ERROR_CANCELLED)
            {
                dwErr = WN_CANCEL;
            }
            else
            {
                dwErr = dwCredErr;
            }

            break;
        }

        //
        // Try again with new credentials.
        //

        dwErr = NPDfsAddConnection(lpNetResource, pszNewPassword, pszUserName, dwFlags, CalledFromCsc);

        dwNetErr = (dwErr == ERROR_EXTENDED_ERROR) ?
                   GetNetErrorCode() : NERR_Success;

        if ( dwErr == NO_ERROR )
        {
            *lpfIsDfsConnect = TRUE;
        }
        else if (IS_RETURNABLE_DFS_ERROR(dwErr) && (dwNetErr != NERR_PasswordExpired))
        {
            *lpfIsDfsConnect = TRUE;

            // report cred as not working
            pfnCredUIConfirmCredentials( szServer, FALSE );
            break;
        }

        //
        // If we get logon failure from DFS,
        //  this is a dfs share.
        //
        if (IS_USERNAME_PASSWORD_ERROR(dwErr) || (dwNetErr == NERR_PasswordExpired))
        {
            *lpfIsDfsConnect = TRUE;
        }

        //
        // Try other providers if this is not a DFS share.
        //

        if (!(*lpfIsDfsConnect))
        {
            dwErr = AddConnection3Help(lpNetResource->lpRemoteName,
                                       pszNewPassword,
                                       lpNetResource->lpLocalName,
                                       pszUserName,
                                       ulNetUseFlags);

            dwNetErr = (dwErr == ERROR_EXTENDED_ERROR) ? GetNetErrorCode() : NERR_Success;
        }

        if (dwErr == NO_ERROR)
        {
            // confirm the cred
            pfnCredUIConfirmCredentials( szServer, TRUE );

            //
            // If the credential was not stored in credman,
            //  tell MPR so it can prompt the user when restoring peristent connections.
            //
            //
            // If the credential was stored in credman,
            //  tell MPR that the default credential was used.
            //
            //

            if (fCredWritten)
            {
                dwErr = WN_CONNECTED_OTHER_PASSWORD_DEFAULT;
            }
            else if ((pszPassword == NULL) || (wcscmp(pszPassword, szPassword) != 0))
            {
                dwErr = WN_CONNECTED_OTHER_PASSWORD;
            }

            break;
        }

        // report cred as not working
        pfnCredUIConfirmCredentials( szServer, FALSE );

        if (!IS_USERNAME_PASSWORD_ERROR(dwErr) && (dwNetErr != NERR_PasswordExpired))
        {
            // Errors not related to access problems
            break;
        }
        else
        {
            // The connection failed, but we will be displaying the UI again
            // so this time report the connection error to the user:
            dwCredUIFlags |= CREDUI_FLAGS_INCORRECT_PASSWORD;
        }

        //
        // For command line prompting,
        //  only prompt once.
        //

        if ( dwFlags & CONNECT_COMMANDLINE ) {
            break;
        }
    }

    //
    // clear any password from memory
    //
    ZeroMemory(szPassword, sizeof(szPassword)) ;
    FreeLibrary(hCredUI);
    return dwErr;
}


/*******************************************************************

    NAME:       AddConnection3Help

    SYNOPSIS:   Helper function for AddConnection3

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Johnl   20-Feb-1992     Commented, fixed for deviceless connections
        JohnL   27-Mar-1992     Add support for "domain\username"
        beng    06-Apr-1992     Unicode conversion
        anirudhs 15-Jan-1996    Add ulNetUseFlags parameter

********************************************************************/

DWORD
AddConnection3Help(
    LPTSTR         pszNetPath,
    LPTSTR         pszPassword,
    LPTSTR         pszLocalName,
    LPTSTR         pszUserName,
    ULONG          ulNetUseFlags
    )
{
    APIERR                   err;
    BOOL                     fValue;
    UINT                     uiLocalNameLen;
    UINT                     uiPasswordLen;

    if ( err = CheckLMService() )
        return err ;

    //
    // Win95-ism: an AddConnection to a path of the form \\server
    // actually does an AddConnection to \\server\IPC$
    //
    WCHAR wszPath[MAX_PATH];
    if (pszNetPath[0] == PATH_SEPARATOR &&
        pszNetPath[1] == PATH_SEPARATOR &&
        wcschr(&pszNetPath[2], PATH_SEPARATOR) == NULL)
    {
        if (pszLocalName && *pszLocalName)
        {
            // Can't connect a local device to the IPC$ share
            return WN_BAD_NETNAME;
        }

        if (wcslen(pszNetPath) + wcslen(IPC_SUFFIX) >= MAX_PATH)
        {
            return WN_BAD_NETNAME;
        }

        wcscpy(wszPath, pszNetPath);
        wcscat(wszPath, IPC_SUFFIX);
        pszNetPath = wszPath;
    }

    NET_NAME netname( pszNetPath );
    if ( netname.QueryError() != NERR_Success )
    {
        return WN_BAD_NETNAME;
    }

    //  if pszLocalName is NULL or '\0', then we will assume this is
    //  a deviceless connection, otherwise
    //  pszLocalName must be less then DEVLEN characters long.

    if ( (pszLocalName != NULL) && (pszLocalName[0] != TCH('\0')) )
    {
        if ( (uiLocalNameLen = ::strlenf (pszLocalName)) > DEVLEN )
        {
            return WN_BAD_LOCALNAME;
        }
    }
    else
    {
        /* If the local name was NULL, then just map it to the empty
         * string.
         */
        pszLocalName = EMPTY_STRING ;
    }

    //  Find the length of pszPassword. Note that a NULL pointer
    //  here will count as 0 length.  See comment below about
    //  passwords.  If the password exceeds PWLEN characters,
    //  we return an error.

    if (( pszPassword != NULL ) && ( ::strlenf( pszPassword ) != 0 ))
    {
        if (( err = I_NetNameValidate( NULL, pszPassword,
            NAMETYPE_PASSWORD, 0L )) != NERR_Success )
        {
            return WN_BAD_PASSWORD;
        }
    }

    uiPasswordLen = ( pszPassword ? ::strlenf (pszPassword) : 0 );

    if (uiPasswordLen > PWLEN)
    {
        return WN_BAD_PASSWORD;
    }

    //  Add the password to the buffer that we will pass to
    //  NetUseAdd.  The NetUseAdd API treats the NULL pointer
    //  and the nul string as different.  If the NULL pointer
    //  is specified, the default password stored in the redirector
    //  is used.  If the nul string (or any other string) is
    //  specified, that string is used for the password.  Currently
    //  (2/9/90), Windows never calls WNetAddConnection with
    //  a NULL pointer.  Rather, if no password is specified in
    //  the edit field for password, Windows transmits the nul
    //  string to us.  We will assume that the nul string here
    //  means that the user wants to use the default password.
    //  The WinNet spec does not mention whether or not a NULL
    //  pointer may ever be used, or what to do with it if it is.
    //  Hence, we will convert a nul string into a NULL pointer.
    //  If the nul string is ever used as the password in the
    //  future, a user could never specify it from Windows.  This
    //  is not too bad, because (0) we don't know of any other
    //  way from a user interface point of view to let a user
    //  distinguish between a NULL pointer and a nul string, (1)
    //  NET command always passes a NULL pointer for the password
    //  if no password is entered from the command line (there
    //  is, of course, no way here either for the user to distinguish
    //  between entering a NULL pointer or a nul string), (2) the
    //  current implementation (according to PaulC) of matching
    //  an entered password with a password that is set to be the
    //  empty string lets any entered password match the nul string.
    //                                              RustanL 2/9/90

    TCHAR *pszCanonPasswd  = NULL;
    TCHAR szCanonPasswd[PWLEN + 1];

    if ( pszPassword != NULL )
    {
        ::strcpyf (szCanonPasswd, pszPassword);
        pszCanonPasswd = szCanonPasswd;
    }

    DEVICE2 dev( pszLocalName );

    switch (err = dev.GetInfo())
    {
    case NERR_Success:
        break ;

    case ERROR_INVALID_PARAMETER:
        err = WN_BAD_LOCALNAME ; // and drop thru

    default:
        memsetf(szCanonPasswd, 0, sizeof(szCanonPasswd)) ;
        return(MapError(err));
    }

    /* Note that the user name may be in the form of "Domain\UserName", check
     * and crack as appropriate.
     */
    if ( pszUserName != NULL &&
         *pszUserName != L'\0' )
    {
        NLS_STR nlsUserName( 47 ) ;
        NLS_STR nlsDomainName( 47 ) ;
        ALIAS_STR nlsQualifiedUserName( pszUserName ) ;

        if ( (err = nlsUserName.QueryError())   ||
             (err = nlsDomainName.QueryError()) ||
             (err = NT_ACCOUNTS_UTILITY::CrackQualifiedAccountName(
                                                          nlsQualifiedUserName,
                                                          &nlsUserName,
                                                          &nlsDomainName)))
        {
            memsetf(szCanonPasswd, 0, sizeof(szCanonPasswd)) ;
            return err ;
        }

        err = ::I_NetNameValidate( NULL, (TCHAR *)nlsUserName.QueryPch(), NAMETYPE_USER, 0L );
        if ( err != NERR_Success )
        {
            memsetf(szCanonPasswd, 0, sizeof(szCanonPasswd)) ;
            return WN_BAD_USER;
        }

        ISTR istr( nlsUserName );


        if ( nlsDomainName.strlen() == 0 && nlsUserName.strchr( &istr, L'@' ) )
        {
            //
            // This might be a UPN.  Try an empty domain name.  On the offchance
            // this is not a UPN (e.g., domain\usernamewith@), this should succeed
            // anyhow, though it'll take more net traffic to do so.
            //

            err = dev.Connect ( pszNetPath,
                                pszCanonPasswd,
                                nlsUserName,
                                TEXT(""),
                                ulNetUseFlags );
        }
        else
        {
            err = dev.Connect ( pszNetPath,
                                pszCanonPasswd,
                                nlsUserName,
                                nlsDomainName.strlen() > 0 ?
                                    nlsDomainName.QueryPch() :
                                    NULL,
                                ulNetUseFlags );
        }
    }
    else
    {
        /* Else the user name is NULL or empty so pass it on to connect
         */
        err = dev.Connect ( pszNetPath,
                            pszCanonPasswd,
                            pszUserName,    // user name
                            pszUserName,    // domain name
                            ulNetUseFlags ) ;
    }

    switch (err)
    {
    case NERR_Success:
        break;

    case ERROR_INVALID_PARAMETER:       /* Fixes lm21 bug 1909, JohnL */
        err = WN_BAD_NETNAME ;
        break ;

    default:
        break;
    }

    memsetf(szCanonPasswd, 0, sizeof(szCanonPasswd)) ;
    return MapError( err ) ;
}


/*****
 *
 *  NPCancelConnection
 *
 *  NP API Function -- see spec for parms and return values.
 *
 */

DWORD APIENTRY
NPCancelConnection (
    LPCTSTR         szName,
    BOOL            fForce )
{
    APIERR err;

    if ( err = CheckLMService() )
        return err ;

    err = NPDfsCancelConnection(szName, fForce);
    if (err == WN_SUCCESS || err == WN_OPEN_FILES) {
        return( err );
    }

    /* If it's  not a UNC name, then we can just use the DEVICE class,
     * otherwise we need to iterate through all active connections and
     * delete each one that corresponds the UNC name.
     */
    if ( szName[0] != TCH('\\') || szName[1] != TCH('\\') )
    {
        DEVICE dev(szName);

        if ((err = dev.GetInfo()) == NERR_Success)
        {
            err = dev.Disconnect ( fForce ? USE_LOTS_OF_FORCE : USE_FORCE );
        }
        else if (err == ERROR_INVALID_PARAMETER)
        {
            return WN_BAD_NETNAME;
        }
    }
    else
    {
        /* It's a UNC connection.  We don't know whether it's a disk or print
         * until we successfully disconnect one of the devices.
         */

        /*
         * Win95-ism: a CancelConnection of a path of the form \\server
         * actually does a CancelConnection of \\server\IPC$
         */
        WCHAR wszPath[MAX_PATH];
        if (wcschr(&szName[2], PATH_SEPARATOR) == NULL)
        {
            if (wcslen(szName) + wcslen(IPC_SUFFIX) >= MAX_PATH)
            {
                return WN_BAD_NETNAME;
            }

            wcscpy(wszPath, szName);
            wcscat(wszPath, IPC_SUFFIX);
            szName = wszPath;
        }

        switch ( err = DisconnectUNC( szName, LMO_DEV_DISK, fForce ))
        {
        case NERR_UseNotFound:
            err = DisconnectUNC( szName, LMO_DEV_PRINT, fForce ) ;
            break ;

        case NERR_Success:
        default:
            break ;
        }
    }

    switch (err)
    {
    case NERR_Success:
        err = WN_SUCCESS;
        break;

    /* All other errors go thru MapError() */
    default:
        break;
    }

    return (MapError(err)) ;

}  /* NPCancelConnection */


/*******************************************************************

    NAME:       DisconnectUNC

    SYNOPSIS:   This procedure deletes the UNC connection passed in.

    ENTRY:      pszUNCName - UNC Name to remove all connections for
                lmodev - Either LMO_DEV_DISK or LMO_DEV_PRINT
                fForce - FALSE if use no force, TRUE if use lots of force

    EXIT:       THe connection connected to the pszUNCName resource will
                be disconnected.

    RETURNS:    NERR_Success if successful, error code otherwise.

    NOTES:      If nothing was disconnected, then NERR_UseNotFound will be
                returned.

    HISTORY:
        Johnl   20-Feb-1992     Created

********************************************************************/

APIERR DisconnectUNC( const TCHAR * pszUNCName, LMO_DEVICE lmodev, BOOL fForce )
{
    APIERR err = NERR_Success ;
    const TCHAR * pszDevName ;

    {
        /*
         * check for validity
         */
        NET_NAME netname( pszUNCName, TYPE_PATH_UNC );
        if ( netname.QueryError() != NERR_Success )
        {
            return WN_BAD_VALUE;
        }
    }

    /*
     *  NUKE the straight UNC connection
     */
    DEVICE devUNC( pszUNCName ) ;
    if ((err = devUNC.GetInfo()) == NERR_Success)
    {
        err = devUNC.Disconnect ( fForce ? USE_LOTS_OF_FORCE :
                                           USE_FORCE ) ;
    }

    return err ;
}


/*****
 *
 *  NPGetUniversalName()
 *
 *  This function returns the UNC name of the network resource associated with
 *  a redirected local device.
 *
 *  Input:     pszLocalPath   -- specifies the name of the redirected
 *                              local path, like X:\foo\bar
 *             dwInfoLevel   -- universal name or remote name. see specs
 *             lpBuffer      -- pointer to empty buffer
 *             nBufferSize   -- pointer to size of pszRemoteName buffer
 *
 *  Output:    *pszLocalPath  -- unchanged
 *             dwInfoLevel    -- unchanged
 *             lpBuffer       -- contains either UNIVERSAL_NAME_INFO
 *                               or REMOTE_NAME_INFO. value is undefined
 *                               if call is unsuccessful.
 *             *lpBufferSize  -- size of buffer needed.
 *
 *  Return Status Codes:
 *
 *     WN_SUCCESS           success
 *     WN_NOT_CONNECTED     pszLocalName is not a redired local device
 *     WN_BAD_VALUE         pszLocalName is not a valid local device
 *     WN_MORE_DATA         buffer was too small
 *     WN_OUT_OF_MEMORY     cannot allocate buffer due memory shortage
 *     WN_NET_ERROR         other network error
 *
 * History:
 *     ChuckC   28-Apr-1994     Created
 */

UINT
NPGetUniversalName(
    LPCTSTR lpLocalPath,
    UINT   dwInfoLevel,
    LPVOID lpBuffer,
    LPUINT lpBufferSize
    )
{

    DWORD status = WN_SUCCESS ;
    DWORD dwCharsRequired = MAX_PATH + 1 ;
    DWORD dwBytesNeeded ;
    DWORD dwLocalLength ;
    LPTSTR lpRemoteBuffer ;
    TCHAR  szDrive[3] ;

    //
    // check for bad info level
    //
    if ((dwInfoLevel != UNIVERSAL_NAME_INFO_LEVEL) &&
        (dwInfoLevel != REMOTE_NAME_INFO_LEVEL))
    {
        return WN_BAD_VALUE ;
    }

    //
    // check for bad pointers
    //
    if (!lpLocalPath || !lpBuffer || !lpBufferSize)
    {
        return WN_BAD_POINTER ;
    }

    //
    // local path must at least have "X:"
    //
    if (((dwLocalLength = wcslen(lpLocalPath)) < 2) ||
        (lpLocalPath[1] != TCH(':')) ||
        ((dwLocalLength > 2) && (lpLocalPath[2] != TCH('\\'))))
    {
        return WN_BAD_VALUE ;
    }

    //
    // preallocate some memory
    //
    if (!(lpRemoteBuffer = (LPTSTR) LocalAlloc(
                                        LPTR,
                                        dwCharsRequired * sizeof(TCHAR))))
    {
        status = GetLastError() ;
        goto ErrorExit ;
    }

    szDrive[2] = 0 ;
    wcsncpy(szDrive, lpLocalPath, 2) ;

    //
    // get the remote path by calling the existing API
    //
    // Note: If some other method, other than the call to NPGetConnection,
    //       is used to determine the remote name, you need to make sure that
    //       the new method will handle Dfs redirections, otherwise you will
    //       break WNetGetUniversalName for Dfs redirected drives.
    //

    status = NPGetConnection(
                 szDrive,
                 lpRemoteBuffer,
                 (LPUINT) &dwCharsRequired) ;

    if (status == WN_MORE_DATA)
    {
        //
        // reallocate the correct size
        //

        LPTSTR    lpTempBuffer = (LPTSTR) LocalReAlloc(
                                            (HLOCAL) lpRemoteBuffer,
                                            dwCharsRequired * sizeof(TCHAR),
                                            LMEM_MOVEABLE);

        if (lpTempBuffer == NULL)
        {
            status = GetLastError() ;
            goto ErrorExit ;
        }

        lpRemoteBuffer = lpTempBuffer;

        status = NPGetConnection(
                     szDrive,
                     lpRemoteBuffer,
                     (LPUINT) &dwCharsRequired) ;
    }

    if (status != WN_SUCCESS)
    {
        goto ErrorExit ;
    }

    //
    // at minimum we will need this size of the UNC name
    // the -2 is because we loose the drive letter & colon.
    //
    dwBytesNeeded = (wcslen(lpRemoteBuffer) +
                     dwLocalLength - 2 + 1) * sizeof(TCHAR) ;

    switch (dwInfoLevel)
    {
        case UNIVERSAL_NAME_INFO_LEVEL:
        {
            LPUNIVERSAL_NAME_INFO lpUniversalNameInfo ;

            //
            // calculate how many bytes we really need
            //
            dwBytesNeeded += sizeof(UNIVERSAL_NAME_INFO) ;

            if (*lpBufferSize < dwBytesNeeded)
            {
                *lpBufferSize = dwBytesNeeded ;
                status = WN_MORE_DATA ;
                break ;
            }

            //
            // now we are all set. just stick the data in the buffer
            //
            lpUniversalNameInfo = (LPUNIVERSAL_NAME_INFO) lpBuffer ;

            lpUniversalNameInfo->lpUniversalName = (LPTSTR)
                (((LPBYTE)lpBuffer) + sizeof(UNIVERSAL_NAME_INFO)) ;
            wcscpy(lpUniversalNameInfo->lpUniversalName,
                   lpRemoteBuffer) ;
            wcscat(lpUniversalNameInfo->lpUniversalName,
                   lpLocalPath+2) ;

            break ;
        }

        case REMOTE_NAME_INFO_LEVEL :
        {
            LPREMOTE_NAME_INFO lpRemoteNameInfo ;

            //
            // calculate how many bytes we really need
            //
            dwBytesNeeded *= 2 ;  // essentially twice the info + terminator
            dwBytesNeeded += (sizeof(REMOTE_NAME_INFO) + sizeof(TCHAR)) ;

            if (*lpBufferSize < dwBytesNeeded)
            {
                *lpBufferSize = dwBytesNeeded ;
                status = WN_MORE_DATA ;
                break ;
            }

            //
            // now we are all set. just stick the data in the buffer
            //
            lpRemoteNameInfo = (LPREMOTE_NAME_INFO) lpBuffer ;

            lpRemoteNameInfo->lpUniversalName = (LPTSTR)
                (((LPBYTE)lpBuffer) + sizeof(REMOTE_NAME_INFO)) ;
            wcscpy(lpRemoteNameInfo->lpUniversalName,
                   lpRemoteBuffer) ;
            wcscat(lpRemoteNameInfo->lpUniversalName,
                   lpLocalPath+2) ;

            lpRemoteNameInfo->lpConnectionName =
                lpRemoteNameInfo->lpUniversalName +
                wcslen(lpRemoteNameInfo->lpUniversalName) + 1 ;
            wcscpy(lpRemoteNameInfo->lpConnectionName,
                   lpRemoteBuffer) ;

            lpRemoteNameInfo->lpRemainingPath =
                lpRemoteNameInfo->lpConnectionName +
                wcslen(lpRemoteNameInfo->lpConnectionName) + 1 ;
            wcscpy(lpRemoteNameInfo->lpRemainingPath,
                   lpLocalPath+2) ;

            break ;
        }

        default:
            //
            // yikes!
            //
            status = WN_BAD_VALUE ;
            UIASSERT(FALSE);
    }

ErrorExit:

    if (lpRemoteBuffer)
    {
        (void) LocalFree((HLOCAL)lpRemoteBuffer) ;
    }
    return status;
}


/*******************************************************************
 *
 *  NPGetConnectionPerformance()
 *
 *  This function returns quality-of-service information about a
 *  network connection.
 *
 *  Input:
 *
 *  Output:
 *
 *  Return Status Codes:
 *
 *     WN_SUCCESS           success
 *
 * History:
 *     AnirudhS 05-Feb-1996     Created
 *
 *******************************************************************/

DWORD APIENTRY
NPGetConnectionPerformance(
    LPCWSTR         lpRemoteName,
    LPNETCONNECTINFOSTRUCT lpNetConnectInfo
    )
{
    NTSTATUS ntStatus;
    HANDLE hToken;
    TOKEN_STATISTICS stats;
    ULONG length;
    LMR_REQUEST_PACKET request;
    struct {
        LMR_CONNECTION_INFO_3 ConnectInfo;
        WCHAR StringArea[MAX_PATH * 4];
    } Buf;
    NET_API_STATUS apiStatus;
    BOOLEAN DfsName;

    apiStatus = NPDfsGetConnectionPerformance((LPWSTR)lpRemoteName,
                                              (LPVOID)&Buf,
                                              sizeof(Buf),
                                              &DfsName);

    if (DfsName == FALSE) {
        ntStatus = NtOpenProcessToken(NtCurrentProcess(), GENERIC_READ, &hToken);
        if (NT_SUCCESS(ntStatus)) {

            //
            // Get the logon id of the current thread
            //

            ntStatus = NtQueryInformationToken(hToken,
                                            TokenStatistics,
                                            (PVOID)&stats,
                                            sizeof(stats),
                                            &length
                                            );

            if (NT_SUCCESS(ntStatus)) {
                RtlCopyLuid(&request.LogonId, &stats.AuthenticationId);
                request.Type = GetConnectionInfo;
                request.Version = REQUEST_PACKET_VERSION;
                request.Level = 3;


                apiStatus = NetpRdrFsControlTree((LPWSTR)lpRemoteName,
                                             NULL,
                                             USE_WILDCARD,
                                             FSCTL_LMR_GET_CONNECTION_INFO,
                                             NULL,
                                             (LPVOID)&request,
                                             sizeof(request),
                                             (LPVOID)&Buf,
                                             sizeof(Buf),
                                             FALSE
                                             );
            }

            NtClose(hToken);
        }
        else  {
            apiStatus = NetpNtStatusToApiStatus(ntStatus);
        }
    }

    if (apiStatus == NERR_Success) {

        //
        // Translate the LMR_CONNECTION_INFO_3 to a NETCONNECTINFOSTRUCT
        //

        // dwFlags bits are set as follows:
        // WNCON_FORNETCARD - false
        // WNCON_NOTROUTED - unknown
        // WNCON_SLOWLINK - doesn't matter since we set dwSpeed
        // WNCON_DYNAMIC - true
        //
        // The units for the relevant fields of LMR_CONNECTION_INFO_3
        // are:
        // Throughput - bytes per second
        // Delay - one-way delay in 100 ns units (NT time units)
        //

        lpNetConnectInfo->dwFlags = WNCON_DYNAMIC;
        lpNetConnectInfo->dwSpeed = Buf.ConnectInfo.Throughput * 8 / 100;
        lpNetConnectInfo->dwDelay = Buf.ConnectInfo.Delay / 10000;
        // lpNetConnectInfo->dwOptDataSize is unknown
    }
    else if (apiStatus == ERROR_INVALID_PARAMETER)
    {
        apiStatus = WN_BAD_NETNAME;
    }

    return MapError(apiStatus);
}

/*******************************************************************
 *
 *  NPGetReconnectFlags()
 *
 *  This function returns flags that should be persisted; when the
 *  persisted connection is restored on a reboot, these flags are passed
 *  in to WNetAddConnection
 *
 *  Input:      lpLocalName -- The local name of this connection
 *
 *              lpPersistFlags -- A byte of flags to be persisted
 *
 *  Output:
 *
 *  Return Status Codes:
 *
 *     WN_SUCCESS           success
 *
 * History:
 *     AnirudhS 05-Feb-1996     Created
 *
 *******************************************************************/

DWORD APIENTRY
NPGetReconnectFlags(
    LPWSTR lpLocalName,
    LPBYTE lpPersistFlags)
{

    if (NPDfsGetReconnectFlags( lpLocalName, lpPersistFlags ) != WN_SUCCESS)
        *lpPersistFlags = 0;

    return( WN_SUCCESS );

}


/*******************************************************************

    NAME:       NPAddConnection3ForCSCAgent

    SYNOPSIS:   This function creates a network connection.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

********************************************************************/

DWORD APIENTRY
NPAddConnection3ForCSCAgent(
    HWND            hwndOwner,
    LPNETRESOURCE   lpNetResource,
    LPTSTR          pszPassword,
    LPTSTR          pszUserName,
    DWORD           dwFlags,
    BOOL            *lpfIsDfsConnect
    )
{

    //
    // Simply call the worker routine to create the connection
    //

    return AddConnectionWorker( hwndOwner,
                                lpNetResource,
                                pszPassword,
                                pszUserName,
                                dwFlags,
                                lpfIsDfsConnect,
                                TRUE );    // Called from CSC

}

/*****
 *
 *  NPCancelConnection
 *
 *  NP API Function -- see spec for parms and return values.
 *
 */

DWORD APIENTRY
NPCancelConnectionForCSCAgent (
    LPCTSTR         szName,
    BOOL            fForce )
{
    return NPCancelConnection(szName, fForce);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\shell\shell\wnres.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    wnres.cxx

Abstract:

    Contains:
        NPGetResourceInformation
        NPGetResourceParent

Environment:

    User Mode -Win32

Notes:

    CODEWORK: Exorcize NLS_STR from this file!

Revision History:

    21-Apr-1995     anirudhs
        Ported from Windows 95 sources (msparent.c, msconn.c)

--*/

#define INCL_WINDOWS
#define INCL_NETERRORS
#define INCL_DOSERRORS
#define INCL_NETWKSTA
#define INCL_NETSERVER
#define INCL_NETSHARE
#define INCL_NETUSE
#define INCL_ICANON
#define _WINNETWK_
#include <lmui.hxx>
#undef _WINNETWK_

#include <winnetwk.h>
#include <npapi.h>
#include <tstr.h>
#include <netlib.h>
#include <lmapibuf.h>
#include <winlocal.h>
#include <errornum.h>   // IDS_UnknownWorkgroup
#include <uiassert.hxx>
#include <uitrace.hxx>
#include <lmowks.hxx>
#include <miscapis.hxx>

#include <dfsutil.hxx>

extern "C" DWORD
I_NetDfsIsThisADomainName(
    IN  LPCWSTR                      wszName
    );

APIERR GetLMProviderName();

VOID
ShareExistsFillInInfo(
    SHARE_INFO_1    *psi,
    DWORD           *pdwType,
    NLS_STR         **ppnlsComment
    );


extern HMODULE hModule ;

DWORD DisplayTypeToUsage(DWORD dwDisplayType)
{
    switch (dwDisplayType) {
    case RESOURCEDISPLAYTYPE_NETWORK:
    case RESOURCEDISPLAYTYPE_DOMAIN:
    case RESOURCEDISPLAYTYPE_SERVER:
        return RESOURCEUSAGE_CONTAINER;

    case RESOURCEDISPLAYTYPE_SHARE:
        return RESOURCEUSAGE_CONNECTABLE | RESOURCEUSAGE_NOLOCALDEVICE;

    case RESOURCEDISPLAYTYPE_SHAREADMIN:
        return RESOURCEUSAGE_NOLOCALDEVICE;

    default:
        break;
    }
    return 0L;
}

BOOLEAN IsThisADfsDomain(
    IN LPCWSTR pwszDomainName)
{
    DWORD dwErr;

    if (pwszDomainName == NULL) {
        return( FALSE );
    }

    if (wcslen(pwszDomainName) > 2 &&
            pwszDomainName[0] == L'\\' &&
                pwszDomainName[1] == L'\\') {
        pwszDomainName += 2;
    }

    dwErr = I_NetDfsIsThisADomainName( pwszDomainName );

    return( (dwErr == ERROR_SUCCESS) ? TRUE : FALSE );
}

/*******************************************************************

    NAME:       CopyResourceToBuffer

    SYNOPSIS:   Copies the specified NETRESOURCE fields into the
                specified buffer.  If the buffer is not big enough,
                returns WN_MORE_DATA and sets cbBuffer to the required
                size; otherwise leaves cbBuffer untouched.
                The strings are copied at the end of the buffer, to
                match convention (though in order for this to be
                useful, we ought to return a space remaining counter).

    RETURNS:    WN_SUCCESS or WN_MORE_DATA

    NOTES:      This function does the work of the ParentInfoEnumerator
                class in the Win 95 MSNP sources.

    HISTORY:
      AnirudhS  24-Apr-1995 Created

********************************************************************/

DWORD CopyResourceToBuffer(
    OUT LPBYTE      lpBuffer,
    IN OUT LPDWORD  pcbBuffer,
    IN  DWORD       dwScope,
    IN  DWORD       dwType,
    IN  DWORD       dwDisplayType,
    IN  DWORD       dwUsage,
    IN  LPCWSTR     lpLocalName,
    IN  LPCWSTR     lpRemoteName,
    IN  LPCWSTR     lpComment,
    IN  LPCWSTR     lpProvider
    )
{
    // Calculate minimum required buffer size
    DWORD cbTotalStringSize =
                  (lpLocalName  ? WCSSIZE(lpLocalName)  : 0)
                + (lpRemoteName ? WCSSIZE(lpRemoteName) : 0)
                + (lpComment    ? WCSSIZE(lpComment)    : 0)
                + (lpProvider   ? WCSSIZE(lpProvider)   : 0);

    if (*pcbBuffer < sizeof(NETRESOURCE) + cbTotalStringSize)
    {
        *pcbBuffer = sizeof(NETRESOURCE) + cbTotalStringSize;
        return WN_MORE_DATA;
    }

    // Calculate start of string area
    LPWSTR pNextString = (LPWSTR) (lpBuffer + *pcbBuffer - cbTotalStringSize);

    // Copy the data
    LPNETRESOURCE pNetResource = (LPNETRESOURCE) lpBuffer;
    pNetResource->dwScope       = dwScope;
    pNetResource->dwType        = dwType;
    pNetResource->dwDisplayType = dwDisplayType;
    pNetResource->dwUsage       = dwUsage;

#define COPYSTRINGFIELD(field)                  \
    if (field)                                  \
    {                                           \
        pNetResource->field = pNextString;      \
        wcscpy(pNextString, field);             \
        pNextString += wcslen(pNextString) + 1; \
    }                                           \
    else                                        \
    {                                           \
        pNetResource->field = NULL;             \
    }

    COPYSTRINGFIELD(lpLocalName)
    COPYSTRINGFIELD(lpRemoteName)
    COPYSTRINGFIELD(lpComment)
    COPYSTRINGFIELD(lpProvider)
#undef COPYSTRINGFIELD

    return WN_SUCCESS;
}


DWORD GetDomainParent(NLS_STR& nlsServer)
{
    LPCWSTR DomainName = nlsServer.QueryPch();
    LPWSTR NewName;
    LPWSTR UseName;

    if (DomainName == NULL) 
    {
        return WN_BAD_NETNAME;
    }

    NewName = new WCHAR[wcslen(DomainName) + 1]; 
    if (NewName == NULL) 
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    wcscpy(NewName, DomainName);

    UseName = NewName;

    while ((*UseName == L'\\') && (*UseName != 0))
    {
        UseName++;
    }

    nlsServer = UseName;

    delete[] NewName;

    return WN_SUCCESS;
}

DWORD GetServerParent(NLS_STR& nlsServer)
{
    PWKSTA_INFO_100 pWkstaInfo = NULL;
    NET_API_STATUS err = NetWkstaGetInfo(
                                (LPWSTR) nlsServer.QueryPch(),
                                100,
                                (PBYTE *)&pWkstaInfo
                                );

    switch (err) {
    case NERR_Success:
        nlsServer = pWkstaInfo->wki100_langroup;
        NetApiBufferFree(pWkstaInfo);
        break;
    case ERROR_NOT_SUPPORTED:
    case ERROR_NETWORK_ACCESS_DENIED:
    case ERROR_ACCESS_DENIED:
    case ERROR_INVALID_LEVEL:
        nlsServer.Load(IDS_UnknownWorkgroup, hModule);
        break;
    default:
        return MapError( err ) ;
    }
    return WN_SUCCESS;
}


/*******************************************************************

    NAME:       NPGetResourceParent

    SYNOPSIS:

    RETURNS:

    NOTES:

    HISTORY:
      AnirudhS  21-Apr-1995 Ported from Win95 sources

********************************************************************/

DWORD NPGetResourceParent(
    LPNETRESOURCE lpNetResource,
    LPVOID lpBuffer,
    LPDWORD cbBuffer
    )
{
    //
    // Canonicalize the remote name, find its type, and find the
    // beginning of the path portion of it
    //
    WCHAR wszCanonName[MAX_PATH];   // buffer for canonicalized name
    ULONG iBackslash;               // index into wszCanonName
    REMOTENAMETYPE rnt = ParseRemoteName(
                            lpNetResource->lpRemoteName,
                            wszCanonName,
                            sizeof(wszCanonName),
                            &iBackslash);

    //
    // Convert to NLS string classes, for Win95 source compatibility
    //
    ALLOC_STR nlsRemote(wszCanonName, sizeof(wszCanonName), wszCanonName);

    DWORD dwDisplayType;
    LPCWSTR lpProvider = NULL;
    NET_API_STATUS err;

    switch (rnt) {

    case REMOTENAMETYPE_INVALID:
        return WN_BAD_NETNAME;

    case REMOTENAMETYPE_WORKGROUP:
        dwDisplayType = RESOURCEDISPLAYTYPE_NETWORK;
        break;

    case REMOTENAMETYPE_SERVER:
        if (!IsThisADfsDomain(lpNetResource->lpRemoteName))
        {
            err = GetServerParent(nlsRemote);
            if (err != WN_SUCCESS)
                return err;
        }
        else
        {
            err = GetDomainParent(nlsRemote);
            if (err != WN_SUCCESS)
                return err;
        }
        dwDisplayType = RESOURCEDISPLAYTYPE_DOMAIN;
        break;

    case REMOTENAMETYPE_SHARE:
        {
            ISTR istrBackslash(nlsRemote);
            istrBackslash += iBackslash;

            nlsRemote.DelSubStr(istrBackslash);            /* lop off sharename */
            dwDisplayType = RESOURCEDISPLAYTYPE_SERVER;
        }
        break;

    case REMOTENAMETYPE_PATH:
        {
            ISTR istrLastBackslash(nlsRemote);
            ISTR istrBackslash(nlsRemote);
            istrBackslash += iBackslash;

            nlsRemote.strrchr(&istrLastBackslash, PATH_SEPARATOR);
            if (istrLastBackslash == istrBackslash)
                dwDisplayType = RESOURCEDISPLAYTYPE_SHARE;
            else
                dwDisplayType = RESOURCEDISPLAYTYPE_DIRECTORY;
            nlsRemote.DelSubStr(istrLastBackslash);
        }
        break;

#ifdef DEBUG
    default:
        ASSERTSZ(FALSE,"ParseRemoteName reported unexpected type!");
#endif
    }

    LPCWSTR lpNewName;
    if (dwDisplayType == RESOURCEDISPLAYTYPE_NETWORK)
        lpNewName = NULL;
    else
        lpNewName = nlsRemote.QueryPch();

    err = GetLMProviderName();
    if (err != WN_SUCCESS)
        return err;
    lpProvider = pszNTLanMan;

    return CopyResourceToBuffer(
                (LPBYTE) lpBuffer,  // lpBuffer
                cbBuffer,           // pcbBuffer
                0,                  // dwScope
                RESOURCETYPE_ANY,   // dwType (we can't tell)
                dwDisplayType,      // dwDisplayType
                DisplayTypeToUsage(dwDisplayType), // dwUsage
                NULL,               // lpLocalName
                lpNewName,          // lpRemoteName
                NULL,               // lpComment
                lpProvider          // lpProvider
                );
}


BOOL WorkgroupExists(NLS_STR& nlsWorkgroup)
{
    DWORD cEntriesRead, cTotalAvail = 0;
    LPBYTE bufptr = NULL; // not used

    NET_API_STATUS err = NetServerEnum(
                                NULL,
                                100,
                                &bufptr,
                                0,
                                &cEntriesRead,
                                &cTotalAvail,
                                SV_TYPE_ALL,
                                (LPWSTR) nlsWorkgroup.QueryPch(),
                                NULL
                                );

    DBGEOL("NPGetResourceInformation - Error " << (ULONG) err <<
               " returned from NetServerEnum") ;

    // NetServerEnum allocates a 0-byte buffer that must be freed
    if (bufptr != NULL)
    {
        NetApiBufferFree(bufptr);
    }

    return (cTotalAvail > 0 || err == NERR_Success);
}


BOOL ServerExists(NLS_STR& nlsServer, NLS_STR **ppnlsComment)
{
    PWKSTA_INFO_100 pWkstaInfo = NULL;
    NET_API_STATUS err = NetWkstaGetInfo(
                                (LPWSTR) nlsServer.QueryPch(),
                                100,
                                (PBYTE *)&pWkstaInfo
                                );

    switch (err) {
    case NERR_Success:
    {
        NetApiBufferFree(pWkstaInfo);

        /* Now try NetServerGetInfo, to get the comment.  May not be able
         * to do this.  Not the end of the world if we can't.
         */
        PSERVER_INFO_101 pServerInfo;
        if (NetServerGetInfo((LPWSTR) nlsServer.QueryPch(), 101, (PBYTE *)&pServerInfo)
                    == NERR_Success)
        {
            if (pServerInfo->sv101_comment != NULL)
            {
                *ppnlsComment = new NLS_STR(pServerInfo->sv101_comment);
                if (*ppnlsComment && (*ppnlsComment)->QueryError())
                {
                    delete *ppnlsComment;
                    *ppnlsComment = NULL;
                }
            }
            NetApiBufferFree(pServerInfo);
        }
    }
    // fall through
    case ERROR_NOT_SUPPORTED:
    case ERROR_NETWORK_ACCESS_DENIED:
    case ERROR_ACCESS_DENIED:
    case ERROR_INVALID_LEVEL:
    case ERROR_BAD_NET_RESP:
        return TRUE;
    default:
        break;
    }
    return FALSE;
}


BOOL AttemptUse(NLS_STR& nlsRemote)
{
    USE_INFO_1 ui1;

    ui1.ui1_local = NULL;
    ui1.ui1_remote = (LPWSTR)nlsRemote.QueryPch();
    ui1.ui1_password = NULL;
    ui1.ui1_asg_type = USE_WILDCARD;

    NET_API_STATUS err = NetUseAdd(NULL, 1, (LPBYTE)&ui1, NULL);

    switch (err) {
    case NERR_Success:
        NetUseDel(NULL, (LPWSTR) nlsRemote.QueryPch(), USE_NOFORCE);
        // fall through
    case ERROR_INVALID_PASSWORD:
    case NERR_BadPasswordCore:
        return TRUE;
    }

    return FALSE;
}


BOOL ShareExists(NLS_STR& nlsShare, ISTR& istrBackslash, BOOL *pfServerOK,
                 DWORD *pdwType, NLS_STR **ppnlsComment)
{
    *pfServerOK = FALSE;
    *pdwType = RESOURCETYPE_ANY;

    WCHAR szServer[MAX_PATH+1];
    BOOL  fDownLevel = FALSE;
    DWORD cEntriesRead;
    DWORD cTotalAvail;
    BOOL  fRet = FALSE;

    wcsncpy(szServer, nlsShare, MAX_PATH);
    szServer[MAX_PATH] = L'\0';
    szServer[istrBackslash] = L'\0';
    ++istrBackslash;

    PBYTE          pBuf;
    NET_API_STATUS err;

    //
    // This could be a domain based dfs share, so check to see if this is a
    // Dfs name.
    //

    LPWSTR pwszPath;
    if (IsDfsPath((LPWSTR)nlsShare.QueryPch(), 0, &pwszPath))
    {
        DWORD dwAttr;
        BOOL retValue;

        *pfServerOK = TRUE;
        *pdwType = RESOURCETYPE_DISK;

        dwAttr = GetFileAttributes( (LPWSTR)nlsShare.QueryPch());
        if (dwAttr == (DWORD)-1)
        {
            retValue = FALSE;
        }
        else
        {
            retValue = TRUE;
        }
        return( retValue );
    }
    else {
        err = NetShareGetInfo(
                        szServer,
                        szServer + istrBackslash,
                        1,
                        &pBuf
                        );
    }

    if (err != NERR_Success) {

        //
        // Win98, Win95, and Win3.11 don't implement NetShareGetInfo
        // and all 3 return different errors in this case (Win95 actually
        // returns ERROR_NETWORK_ACCESS_DENIED)
        //
        fDownLevel = TRUE;

        err = NetShareEnum(
                        szServer,
                        1,
                        &pBuf,
                        0xffffffff,
                        &cEntriesRead,
                        &cTotalAvail,
                        NULL
                        );
    }

    switch (err) {
    case NERR_Success:
        break;

    case NERR_BadTransactConfig:
        *pfServerOK = TRUE;
        return AttemptUse(nlsShare);

    case ERROR_ACCESS_DENIED:
    case ERROR_NETWORK_ACCESS_DENIED:
        *pfServerOK = TRUE;
        // fall through

    default:
        return FALSE;
    }

    *pfServerOK = TRUE;

    SHARE_INFO_1 *psi = (SHARE_INFO_1 *)pBuf;

    if (!fDownLevel) {
        ShareExistsFillInInfo(psi, pdwType, ppnlsComment);
        fRet = TRUE;
    }
    else {

        //
        // We had to enumerate since this was a downlevel client -- check
        // to see if the share in which we're interested is on the server
        //

        LPCWSTR pszShare = nlsShare.QueryPch(istrBackslash);

        for (DWORD i = 0; i < cEntriesRead; i++, psi++) {

            if (!_wcsicmp(pszShare, psi->shi1_netname)) {

                //
                // Found it
                //
                ShareExistsFillInInfo(psi, pdwType, ppnlsComment);
                fRet = TRUE;
                break;
            }
        }
    }

    NetApiBufferFree(pBuf);
    return fRet;
}


VOID
ShareExistsFillInInfo(
    SHARE_INFO_1    *psi,
    DWORD           *pdwType,
    NLS_STR         **ppnlsComment
    )
{
    switch (psi->shi1_type) {

        case STYPE_DISKTREE:
            *pdwType = RESOURCETYPE_DISK;
            break;

        case STYPE_PRINTQ:
            *pdwType = RESOURCETYPE_PRINT;
            break;
    }    /* default was set above */

    if (psi->shi1_remark != NULL) {

        *ppnlsComment = new NLS_STR(psi->shi1_remark);

        if (*ppnlsComment && (*ppnlsComment)->QueryError()) {
            delete *ppnlsComment;
            *ppnlsComment = NULL;
        }
    }
}


/*******************************************************************

    NAME:       NPGetResourceInformation

    SYNOPSIS:

    RETURNS:

    NOTES:

    HISTORY:
      AnirudhS  21-Apr-1995 Ported from Win95 sources
      AnirudhS  22-May-1996 Fixed buffer size calculations

********************************************************************/

DWORD NPGetResourceInformation(
    LPNETRESOURCE lpNetResource,
    LPVOID lpBuffer,
    LPDWORD cbBuffer,
    LPWSTR *lplpSystem
    )
{
    //
    // Canonicalize the remote name, find its type, and find the
    // beginning of the path portion of it
    //
    WCHAR wszCanonName[MAX_PATH];   // buffer for canonicalized name
    ULONG iBackslash;               // index into wszCanonName
    REMOTENAMETYPE rnt = ParseRemoteName(
                            lpNetResource->lpRemoteName,
                            wszCanonName,
                            sizeof(wszCanonName),
                            &iBackslash
                            );

    //
    // Convert to NLS string classes, for Win95 source compatibility
    //
    ALLOC_STR nlsRemote(wszCanonName);

    BOOL fExists = FALSE;
    BOOL fServerOK = FALSE;
    LPNETRESOURCE lpNROut = (LPNETRESOURCE)lpBuffer;
    LPWSTR lpszNext = (LPWSTR)(lpNROut+1);
    DWORD cbNeeded = sizeof(NETRESOURCE);
    NLS_STR *pnlsComment = NULL;
    DWORD dwType = RESOURCETYPE_ANY;
    DWORD dwDisplayType = 0;

    // set a few defaults
    if (*cbBuffer >= cbNeeded)
    {
        lpNROut->dwScope = 0;
        lpNROut->lpLocalName = NULL;
        lpNROut->lpComment = NULL;
    }
    *lplpSystem = NULL;

    switch (rnt) {

    case REMOTENAMETYPE_INVALID:
        return WN_BAD_NETNAME;

    case REMOTENAMETYPE_WORKGROUP:
        fExists = WorkgroupExists(nlsRemote);
        dwDisplayType = RESOURCEDISPLAYTYPE_DOMAIN;
        break;

    case REMOTENAMETYPE_SERVER:
        if (IsThisADfsDomain(lpNetResource->lpRemoteName))
        {
            fExists = TRUE;
            dwDisplayType = RESOURCEDISPLAYTYPE_SERVER;
        }
        else
        {
            fExists = ServerExists(nlsRemote, &pnlsComment);
            dwDisplayType = RESOURCEDISPLAYTYPE_SERVER;
        }
        break;

    case REMOTENAMETYPE_PATH:
        {
            ISTR istrBackslash(nlsRemote);
            istrBackslash += iBackslash;

            UINT cbPath = WCSSIZE(nlsRemote.QueryPch(istrBackslash));
            cbNeeded += cbPath;
            if (*cbBuffer >= cbNeeded) {
                *lplpSystem = lpszNext;
                wcscpy(lpszNext, nlsRemote.QueryPch(istrBackslash));
                lpszNext += cbPath/sizeof(WCHAR);
            }
            nlsRemote.DelSubStr(istrBackslash);
            nlsRemote.strrchr(&istrBackslash, PATH_SEPARATOR);

            fExists = ShareExists(nlsRemote,
                                  istrBackslash,
                                  &fServerOK,
                                  &dwType,
                                  &pnlsComment);

            dwDisplayType = RESOURCEDISPLAYTYPE_SHARE;
        }
        break;

    case REMOTENAMETYPE_SHARE:
        {
            ISTR istrBackslash(nlsRemote);
            istrBackslash += iBackslash;

            fExists = ShareExists(nlsRemote,
                                  istrBackslash,
                                  &fServerOK,
                                  &dwType,
                                  &pnlsComment);

            dwDisplayType = RESOURCEDISPLAYTYPE_SHARE;
        }

        break;

#ifdef DEBUG
    default:
        ASSERTSZ(FALSE,"ParseRemoteName reported unexpected type!");
#endif
    }

    if (!fExists)
    {
        /* If we've been fed a UNC name, and the server exists but the share
         * doesn't, Win95's MSNP customizes the error text thus, but we just
         * return the standard text since our MPR doesn't support customization
         * of text for standard errors:
         *    if (fServerOK)
         *        return MapNetError(ERROR_BAD_NET_NAME);
         */

        return WN_BAD_NETNAME;
    }

    APIERR err = GetLMProviderName();
    if (err != WN_SUCCESS)
        return err;
    UINT cbProvider = WCSSIZE(pszNTLanMan);
    cbNeeded += cbProvider;
    if (*cbBuffer >= cbNeeded) {
        lpNROut->lpProvider = lpszNext;
        wcscpy(lpszNext, pszNTLanMan);
        lpszNext += cbProvider/sizeof(WCHAR);
    }

    cbNeeded += nlsRemote.QueryTextSize();
    if (*cbBuffer >= cbNeeded) {
        lpNROut->lpRemoteName = lpszNext;
        wcscpy(lpszNext, nlsRemote);
        lpszNext += nlsRemote.QueryTextSize()/sizeof(WCHAR);
    }

    if (pnlsComment != NULL) {
        cbNeeded += pnlsComment->QueryTextSize();
        if (*cbBuffer >= cbNeeded) {
            lpNROut->lpComment = lpszNext;
            wcscpy(lpszNext, pnlsComment->QueryPch());
            lpszNext += pnlsComment->QueryTextSize()/sizeof(WCHAR);
        }
        delete pnlsComment;
    }

    if (*cbBuffer >= cbNeeded) {
        lpNROut->dwType = dwType;
        lpNROut->dwDisplayType = dwDisplayType;
        lpNROut->dwUsage = DisplayTypeToUsage(lpNROut->dwDisplayType);
        return WN_SUCCESS;
    }
    else {
        *cbBuffer = cbNeeded;
        return WN_MORE_DATA;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\shell\shell\wnetfmt.cxx ===
/*****************************************************************/
/**                   Microsoft Windows NT                      **/
/**        Copyright(c) Microsoft Corp., 1989-1990              **/
/*****************************************************************/

/*
 *  wnetfmt.cxx
 *
 *  History:
 *      Yi-HsinS    12/21/92    Created
 */

#define INCL_WINDOWS
#define INCL_NETERRORS
#define INCL_DOSERRORS
#define INCL_NETSERVICE
#include <lmui.hxx>

#include "chkver.hxx"

#include <winnetp.h>    // WNFMT_* definitions
#include <npapi.h>
#include <winlocal.h>

#include <dbgstr.hxx>
#include <uiassert.hxx>
#include <string.hxx>

/*****
 *
 *  NPFormatNetworkName
 *
 *  WinNet Provider API Function -- see spec for parms and return values.
 *
 */

DWORD
NPFormatNetworkName(
    LPWSTR lpRemoteName,
    LPWSTR lpDisplayName,
    LPDWORD lpnLength,
    DWORD  dwFlags,
    DWORD  dwAveCharPerLine )
{
    if (  ( dwFlags & WNFMT_MULTILINE )
       && ( dwFlags & WNFMT_ABBREVIATED )
       )
    {
        return WN_BAD_VALUE;
    }

    LPWSTR pszCopyFrom = lpRemoteName;    // by default, the whole string

    if (  ( dwFlags & WNFMT_ABBREVIATED )
       && ( dwFlags & WNFMT_INENUM )
       )
    {
        if (lpRemoteName[0] == L'\\' && lpRemoteName[1] == L'\\')
        {
            LPWSTR pszThird = wcschr(lpRemoteName + 2, L'\\');
            if (NULL != pszThird)
            {
                // in the form "\\server\share" => get the share name
                pszCopyFrom = pszThird + 1;
            }
            else
            {
                // in the form "\\server" => get rid of "\\"
                pszCopyFrom = lpRemoteName + 2;
            }
        }
    }

    DWORD nLength = wcslen(pszCopyFrom) + 1;
    if (nLength > *lpnLength)
    {
        *lpnLength = nLength;
        return WN_MORE_DATA;
    }

    wcsncpy(lpDisplayName, pszCopyFrom, nLength);
    return WN_SUCCESS;

} /* NPFormatNetworkName */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\shell\test\apptest.cxx ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1987-1990          **/
/********************************************************************/

/*
 *  FILE STATUS:
 *  9/18/90  Copied from generic template
 *  1/12/91  Split from Logon App, reduced to just Shell Test APP
 */

/****************************************************************************

    PROGRAM: apptest.cxx

    PURPOSE: Generic Shell test program

    FUNCTIONS:

	Provides access to test modules which call shell APIs.

    COMMENTS:

        Windows can have several copies of your application running at the
        same time.  The variable hInstance keeps track of which instance this
        application is so that processing will be to the correct window.

****************************************************************************/


#define INCL_GDI
#include "apptest.hxx"


HINSTANCE hInstance = 0;   // Required by wnerr.cxx

/****************************************************************************

    FUNCTION: WinMain(HANDLE, HANDLE, LPSTR, int)

    PURPOSE: calls initialization function, processes message loop

    COMMENTS:

        Windows recognizes this function by name as the initial entry point
        for the program.  This function calls the application initialization
        routine, if no other instance of the program is running, and always
        calls the instance initialization routine.  It then executes a message
        retrieval and dispatch loop that is the top-level control structure
        for the remainder of execution.  The loop is terminated when a WM_QUIT
        message is received, at which time this function exits the application
        instance by returning the value passed by PostQuitMessage().

        If this function must abort before entering the message loop, it
        returns the conventional value NULL.

****************************************************************************/

WinMain(
    HINSTANCE hInstance,                /* current instance             */
    HINSTANCE hPrevInstance,            /* previous instance            */
    LPSTR lpCmdLine,                 /* command line                 */
    int nCmdShow                     /* show-window type (open/icon) */
    )
{
    MSG msg;				     /* message			     */

    UNUSED(lpCmdLine);

    if (!hPrevInstance)			 /* Other instances of app running? */
	if (!InitApplication(hInstance)) /* Initialize shared things */
	    return (FALSE);		 /* Exits if unable to initialize     */

    /* Perform initializations that apply to a specific instance */

    if (!InitInstance(hInstance, nCmdShow))
        return (FALSE);

    /* Acquire and dispatch messages until a WM_QUIT message is received. */

    while (GetMessage(&msg,	   /* message structure			     */
	    NULL,		   /* handle of window receiving the message */
	    NULL,		   /* lowest message to examine		     */
	    NULL))		   /* highest message to examine	     */
    {
	TranslateMessage(&msg);	   /* Translates virtual key codes	     */
	DispatchMessage(&msg);	   /* Dispatches message to window	     */
    }
    return (msg.wParam);	   /* Returns the value from PostQuitMessage */
}


/****************************************************************************

    FUNCTION: InitApplication(HANDLE)

    PURPOSE: Initializes window data and registers window class

    COMMENTS:

        This function is called at initialization time only if no other
        instances of the application are running.  This function performs
        initialization tasks that can be done once for any number of running
        instances.

        In this case, we initialize a window class by filling out a data
        structure of type WNDCLASS and calling the Windows RegisterClass()
        function.  Since all instances of this application use the same window
        class, we only need to do this when the first instance is initialized.


****************************************************************************/

BOOL InitApplication(
    HINSTANCE hInstance                           /* current instance           */
    )
{
    WNDCLASS  wc;

    /* Fill in window class structure with parameters that describe the       */
    /* main window.                                                           */

    wc.style = NULL;                    /* Class style(s).                    */
#ifdef WIN32
    wc.lpfnWndProc = (WNDPROC) MainWndProc;
#else
    wc.lpfnWndProc = (LONGFARPROC) MainWndProc;
#endif
					/* Function to retrieve messages for  */
                                        /* windows of this class.             */
    wc.cbClsExtra = 0;                  /* No per-class extra data.           */
    wc.cbWndExtra = 0;                  /* No per-window extra data.          */
    wc.hInstance = hInstance;           /* Application that owns the class.   */
    wc.hIcon = LoadIcon(hInstance, SZ("AppIcon")); /* load icon */
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH) GetStockObject(WHITE_BRUSH);
    wc.lpszMenuName = SZ("AppMenu");
					/* Name of menu resource in .RC file. */
    wc.lpszClassName = WC_MAINWINDOW;   /* Name used in call to CreateWindow. */

    /* Register the window class and return success/failure code. */

    return (RegisterClass(&wc));

}


/****************************************************************************

    FUNCTION:  InitInstance(HANDLE, int)

    PURPOSE:  Saves instance handle and creates main window

    COMMENTS:

        This function is called at initialization time for every instance of
        this application.  This function performs initialization tasks that
        cannot be shared by multiple instances.

        In this case, we save the instance handle in a static variable and
        create and display the main program window.

****************************************************************************/

BOOL InitInstance(
    HINSTANCE           hInstance,          /* Current instance identifier.       */
    int             nCmdShow            /* Param for first ShowWindow() call. */
    )
{
    HWND            hWnd;               /* Main window handle.                */
    TCHAR	     pszWindowTitle[MAXLEN_WINDOWTITLE_STRING+1];
					/* window title */

    /* Save the instance handle in static variable, which will be used in  */
    /* many subsequence calls from this application to Windows.            */

    ::hInstance = hInstance;

    /* Create a main window for this application instance.  */

    hWnd = CreateWindow(
        WC_MAINWINDOW,                  /* See RegisterClass() call.          */
        pszWindowTitle,                 /* Text for window title bar.         */
        WS_OVERLAPPEDWINDOW,            /* Window style.                      */
/* Width?  Height?  Initial position? */
        CW_USEDEFAULT,                  /* Default horizontal position.       */
        CW_USEDEFAULT,                  /* Default vertical position.         */
        CW_USEDEFAULT,                  /* Default width.                     */
        CW_USEDEFAULT,                  /* Default height.                    */
        NULL,                           /* Overlapped windows have no parent. */
	LoadMenu( ::hInstance, SZ("AppMenu")), /* Use the window class menu.	     */
        hInstance,                      /* This instance owns this window.    */
        NULL                            /* Pointer not needed.                */
    );

    /* If window could not be created, return "failure" */

    if (!hWnd)
        return (FALSE);

    /* Make the window visible; update its client area; and return "success" */

    ShowWindow(hWnd, nCmdShow);  /* Show the window                        */
    UpdateWindow(hWnd);          /* Sends WM_PAINT message                 */
    return (TRUE);               /* Returns the value from PostQuitMessage */

}

/****************************************************************************

    FUNCTION: MainWndProc(HWND, unsigned, WORD, LONG)

    PURPOSE:  Processes messages

    MESSAGES:

	WM_COMMAND    - application menu (About dialog box)
	WM_DESTROY    - destroy window

    COMMENTS:

	To process the IDM_ABOUT message, call MakeProcInstance() to get the
	current instance address of the About() function.  Then call Dialog
	box which will create the box according to the information in your
	generic.rc file and turn control over to the About() function.	When
	it returns, free the intance address.

****************************************************************************/

long /* FAR PASCAL */ MainWndProc(
    HWND hWnd,				  /* window handle		     */
    unsigned message,			  /* type of message		     */
    WORD wParam,			  /* additional information	     */
    LONG lParam				  /* additional information	     */
    )
{
    FARPROC lpProcAbout;		  /* pointer to the "About" function */

    switch (message) {
	case WM_COMMAND:	   /* message: command from application menu */
	    switch (wParam)
	    {
	    case IDM_HELP_ABOUT:
		lpProcAbout = MakeProcInstance((FARPROC)About, ::hInstance);

                DialogBox(::hInstance,           /* current instance         */
		    SZ("AboutBox"),			 /* resource to use	     */
		    hWnd,			 /* parent handle	     */
		    (DLGPROC) lpProcAbout);		   /* About() instance address */

		FreeProcInstance(lpProcAbout);
		break;

#ifndef WIN32
	    // Autologon and change password tests
            case IDM_TEST_1:
		// test1(hWnd);
		break;

            case IDM_TEST_2:
		// test2(hWnd);
		break;
#endif //!WIN32

            case IDM_TEST_3:
		test3(hWnd);
		break;

            case IDM_TEST_4:
		// test4(hWnd);
		break;

            case IDM_TEST_5:
		//test5(hWnd);
		break;

            case IDM_TEST_6:
		// test6(hWnd);
		break;

            case IDM_TEST_7:
		// test7(hWnd);
		break;

            case IDM_TEST_8:
		// test8(hWnd);
		break;

            case IDM_TEST_9:
                // test9(hWnd);
                break;
#ifdef WIN32
	    case IDM_TEST_10:
	        // test10(hInstance,hWnd);
	        break;
#endif

	    case IDM_TEST_11:
    		// test11(hWnd );
		break;

	    default:    /* Lets Windows process it	     */
		return (DefWindowProc(hWnd, message, wParam, lParam));
	    }

	case WM_PAINT:                    /* message: update window */
	    {
	        PAINTSTRUCT ps;

	        BeginPaint (hWnd, &ps);
		//DrawStrings(&ps);
	        EndPaint   (hWnd, &ps);
	    }
	    break;

	case WM_ACTIVATE:                 /* message: (de)activate window */
	    return (DefWindowProc(hWnd, message, wParam, lParam));

	case WM_DESTROY:		  /* message: window being destroyed */
	    PostQuitMessage(0);
	    break;

	default:			  /* Passes it on if unproccessed    */
	    return (DefWindowProc(hWnd, message, wParam, lParam));
    }
    return (NULL);
}



/****************************************************************************

    FUNCTION: About(HWND, unsigned, WORD, LONG)

    PURPOSE:  Processes messages for "About" dialog box

    MESSAGES:

	WM_INITDIALOG - initialize dialog box
	WM_COMMAND    - Input received

    COMMENTS:

	No initialization is needed for this particular dialog box, but TRUE
	must be returned to Windows.

	Wait for user to click on "Ok" button, then close the dialog box.

****************************************************************************/

BOOL /* FAR PASCAL */ About(
    HWND hDlg,                            /* window handle of the dialog box */
    unsigned message,                     /* type of message                 */
    WORD wParam,                          /* message-specific information    */
    LONG lParam
    )
{
    UNUSED(lParam);

    switch (message) {
	case WM_INITDIALOG:		   /* message: initialize dialog box */
	    return (TRUE);

	case WM_COMMAND:		      /* message: received a command */
	    if (wParam == IDOK                /* "OK" box selected?	     */
                || wParam == IDCANCEL) {      /* System menu close command? */
		EndDialog(hDlg, TRUE);	      /* Exits the dialog box	     */
		return (TRUE);
	    }
	    break;
    }
    return (FALSE);			      /* Didn't process a message    */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\shell\test\appresrc.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1987-1990          **/
/********************************************************************/

/*
 *  FILE STATUS:
 *  9/18/90  Copied from generic template
 *  11/30/90 Split from logon.h to resource.h
 */

#ifndef _RESOURCE_H
#define _RESOURCE_H

/* menu items */
#define IDM_LOGON_LOGON     100
#define IDM_LOGON_LOGOFF    101
#define IDM_PASSWORD_CHANGE 110
#define IDM_PROFILE_LOAD    120
#define IDM_PROFILE_SAVE    121
#define IDM_HELP_ABOUT      130
#define IDM_TEST_1          140
#define IDM_TEST_2          141
#define IDM_TEST_3          142
#define IDM_TEST_4          143
#define IDM_TEST_5          144
#define IDM_TEST_6          145
#define IDM_TEST_7          146
#define IDM_TEST_8          147
#define IDM_TEST_9          148
#define IDM_TEST_10         149
#define IDM_TEST_11	    150

/* constant strings loaded on startup */
#define NUM_STATIC_LINES    4
#define NUM_STATIC_STRINGS  8
#define LINE_WkstaName      0
#define LINE_UserName       1
#define LINE_DomainName     2
#define LINE_Status         3
#define STATUS_NoWksta      4
#define STATUS_NotLoggedOn  5
#define STATUS_LoggedOn     6
#define STATUS_Error        7

/* base index of stringtable strings */
#define IDS_BASE        100

/* indices to static strings in .RC file */
#define MAXLEN_STATIC_STRING 40
#define IDS_STATIC_BASE      IDS_BASE
#define IDS_STATIC_WkstaName   IDS_STATIC_BASE+LINE_WkstaName
#define IDS_STATIC_UserName    IDS_STATIC_BASE+LINE_UserName
#define IDS_STATIC_DomainName  IDS_STATIC_BASE+LINE_DomainName
#define IDS_STATIC_Status      IDS_STATIC_BASE+LINE_Status
#define IDS_STATUS_NoWksta     IDS_STATIC_BASE+STATUS_NoWksta
#define IDS_STATUS_NotLoggedOn IDS_STATIC_BASE+STATUS_NotLoggedOn
#define IDS_STATUS_LoggedOn    IDS_STATIC_BASE+STATUS_LoggedOn
#define IDS_STATUS_Error       IDS_STATIC_BASE+STATUS_Error

/* window title strings */
#define MAXLEN_WINDOWTITLE_STRING 100
#define IDS_WINDOWTITLE_BASE      IDS_STATIC_BASE+100
#define IDS_WINDOWTITLE_MainWindow   IDS_WINDOWTITLE_BASE

#endif // _RESOURCE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\shell\test\apptest1.cxx ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1987-1990          **/
/********************************************************************/

/*
 *  FILE STATUS:
 *  12/06/90  Created
 *  01/02/91  renamed to just test1
 *  1/12/91  Split from Logon App, reduced to just Shell Test APP
 */

/****************************************************************************

    PROGRAM: test1.cxx

    PURPOSE: Test module to test I_ChangePassword

    FUNCTIONS:

	test1()

    COMMENTS:

****************************************************************************/


#ifdef CODESPEC
/*START CODESPEC*/

/********
TEST1.CXX
********/

/************
end TEST1.CXX
************/
/*END CODESPEC*/
#endif // CODESPEC



#include "apptest.hxx"


/****************************************************************************

    FUNCTION: test1()

    PURPOSE: test WNetRestoreConnection

    COMMENTS:

****************************************************************************/

void test1(HWND hwndParent)
{
    MessageBox(hwndParent,SZ("Welcome to sunny test1"),SZ("Test"),MB_OK);
    I_ChangePassword(hwndParent);
    MessageBox(hwndParent,SZ("Thanks for visiting test1 -- please come again!"),SZ("Test"),MB_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\shell\test\apptest6.cxx ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1987-1990          **/
/********************************************************************/

/*
 *  FILE STATUS:
 *  12/06/90  Created
 *  01/02/91  renamed to just test6
 *  1/15/91  Split from Logon App, reduced to just Shell Test APP
 */

/****************************************************************************

    PROGRAM: test6.cxx

    PURPOSE: Test module to test WNetConnectionDialog

    FUNCTIONS:

	test6()

    COMMENTS:

****************************************************************************/


#ifdef CODESPEC
/*START CODESPEC*/

/********
TEST6.CXX
********/

/************
end TEST6.CXX
************/
/*END CODESPEC*/
#endif // CODESPEC



#include "apptest.hxx"



/****************************************************************************

    FUNCTION: test6()

    PURPOSE: test WNetConnectionDialog

    COMMENTS:

****************************************************************************/

void test6(HWND hwndParent)
{
    UINT type ;
    switch( MessageBox(hwndParent,SZ("Browse Printer (Yes) or Drive (No) connections"),SZ("Test"),MB_YESNOCANCEL))
    {
    case IDYES:
	type =
		   #ifdef WIN32
		       RESOURCETYPE_PRINT ;
		   #else
		       WNTYPE_PRINTER ;
		   #endif
	break ;

    case IDNO:
	type =
		   #ifdef WIN32
		       RESOURCETYPE_DISK ;
		   #else
		       WNTYPE_DISK ;
		   #endif

	break ;

    case IDCANCEL:
    default:
	return ;
    }

    UINT rc;

    rc = WNetConnectionDialog ( hwndParent, type ) ;

    MessageBox(hwndParent,SZ("Thanks for visiting test6 -- please come again!"),SZ("Test"),MB_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\shell\test\apptest9.cxx ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1987-1990          **/
/********************************************************************/

/*
 *  FILE STATUS:
 *  12/06/90  Created
 *  01/02/91  renamed to just test9
 *  1/15/91  Split from Logon App, reduced to just Shell Test APP
 */

/****************************************************************************

    PROGRAM: test9.cxx

    PURPOSE: Test module to test WNetDisconnectDialog

    FUNCTIONS:

	test9()

    COMMENTS:

****************************************************************************/


#ifdef CODESPEC
/*START CODESPEC*/

/********
test9.CXX
********/

/************
end test9.CXX
************/
/*END CODESPEC*/
#endif // CODESPEC



#include "apptest.hxx"

/****************************************************************************

    FUNCTION: test9()

    PURPOSE: test WNetConnectionDialog

    COMMENTS:

****************************************************************************/

void test9(HWND hwndParent)
{
    MessageBox(hwndParent,SZ("Welcome to sunny test9"),SZ("Test"),MB_OK);


#ifdef WIN32
    DWORD rc = WNetDisconnectDialog( hwndParent, RESOURCETYPE_DISK ) ;
#else
    WORD rc;
    rc = WNetDisconnectDialog ( hwndParent, WNTYPE_DRIVE );
#endif
    MessageBox(hwndParent,SZ("Thanks for visiting test9 -- please come again!"),SZ("Test"),MB_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\shell\test\apptest8.cxx ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1987-1990          **/
/********************************************************************/

/*
 *  FILE STATUS:
 *  12/06/90  Created
 *  1/12/91  Split from Logon App, reduced to just Shell Test APP
 *  2/21/91  Disabled
 */

/****************************************************************************

    PROGRAM: test8.cxx

    PURPOSE: Test module as yet undefined

    FUNCTIONS:

	test8()

    COMMENTS:

****************************************************************************/


#ifdef CODESPEC
/*START CODESPEC*/

/********
TEST8.CXX
********/

/************
end TEST8.CXX
************/
/*END CODESPEC*/
#endif // CODESPEC



#include "apptest.hxx"

/****************************************************************************

    FUNCTION: test8()

    PURPOSE: as yet undefined

    COMMENTS:

****************************************************************************/

void test8(HWND hwndParent)
{
    MessageBox(hwndParent,SZ("Welcome to sunny test8"),SZ("test disabled"),MB_OK);
#ifdef WIN32
    DWORD rc = WNetConnectDialog( hwndParent, RESOURCETYPE_DISK ) ;
#endif // WIN32


    MessageBox(hwndParent,SZ("Thanks for visiting test8 -- please come again!"),SZ("Test"),MB_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\shell\test\apptest2.cxx ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1987-1990          **/
/********************************************************************/

/*
 *  FILE STATUS:
 *  12/06/90  Created
 *  01/12/91  Split from Logon App, reduced to just Shell Test APP
 *  02/21/91  Changed to I_AutoLogon test
 */

/****************************************************************************

    PROGRAM: test2.cxx

    PURPOSE: I_AutoLogon test

    FUNCTIONS:

	test2()

    COMMENTS:

****************************************************************************/


#ifdef CODESPEC
/*START CODESPEC*/

/********
TEST2.CXX
********/

/************
end TEST2.CXX
************/
/*END CODESPEC*/
#endif // CODESPEC



#include "apptest.hxx"



/****************************************************************************

    FUNCTION: test2()

    PURPOSE: tests I_AutoLogon

    COMMENTS:

****************************************************************************/

void test2(HWND hwndParent)
{
    char msgbuf[100];
    BOOL fLoggedOn;
    MessageBox(hwndParent,SZ("Welcome to sunny test2"),SZ("test I_AutoLogon(TRUE)"),MB_OK);

    BOOL fReturn = I_AutoLogon(hwndParent, SZ("AppName"), NULL, &fLoggedOn);
    wsprintf(msgbuf,SZ("Returned %s, fLoggedOn = %s"),
		(fReturn)?SZ("TRUE"):SZ("FALSE"),
    		(fLoggedOn)?SZ("TRUE"):SZ("FALSE"));

    MessageBox(hwndParent,msgbuf,SZ("Test"),MB_OK);
    MessageBox(hwndParent,SZ("Thanks for visiting test2 -- please come again!"),SZ("Test"),MB_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\shell\test\apptest4.cxx ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1987-1990          **/
/********************************************************************/

/*
 *  FILE STATUS:
 *  1/02/91  Created
 *  1/12/91  Split from Logon App, reduced to just Shell Test APP
 *  2/21/91  Disabled
 *  Johnl   12/28/91	    Created DACL Editor test
 */

/****************************************************************************

    PROGRAM: test4.cxx

    PURPOSE: Test the SedDiscretionaryAclEditor API

    FUNCTIONS:

	test4()

    COMMENTS:

****************************************************************************/


#ifdef CODESPEC
/*START CODESPEC*/

/********
TEST4.CXX
********/

/************
end TEST4.CXX
************/
/*END CODESPEC*/
#endif // CODESPEC

#include <ntstuff.hxx>

#define INCL_NETLIB
#define INCL_WINDOWS
#define INCL_NETERRORS
#define INCL_DOSERRORS
#include <lmui.hxx>

#include <string.hxx>
#include <security.hxx>
#include <uibuffer.hxx>
extern "C"
{
    #include <sedapi.h>
}

#include <uiassert.hxx>

#include "apptest.hxx"

#define CALLBACK_CONTEXT  0x12345678
DWORD SedCallback( ULONG_PTR		  ulCallbackContext,
		   PSECURITY_DESCRIPTOR   psecdesc,
		   BOOLEAN		  fApplyToSubContainers,
		   BOOLEAN		  fApplyToSubObjects,
		   LPDWORD		  StatusReturn
		 ) ;

/* Individual permission bits, these show up in the Special permission dialog
 */
#define TEST_SPECIAL_PERM1     0x00000001
#define TEST_SPECIAL_PERM2     0x00000002
#define TEST_SPECIAL_PERM3     0x00000004
#define TEST_SPECIAL_PERM4     0x00000008
#define TEST_SPECIAL_PERM5     0x00000010

/* Sets of permission bits (these are shown in the main dialog)
 */
#define TEST_RESOURCE_NO_ACCESS (0)
#define TEST_RESOURCE_PERM12  (TEST_SPECIAL_PERM1|TEST_SPECIAL_PERM2)
#define TEST_RESOURCE_PERM34  (TEST_SPECIAL_PERM3|TEST_SPECIAL_PERM4)
#define TEST_RESOURCE_PERM135 (TEST_SPECIAL_PERM1|TEST_SPECIAL_PERM3|TEST_SPECIAL_PERM5)
#define TEST_RESOURCE_PERM4   (TEST_SPECIAL_PERM4)


/* Individual permission bits, these show up in the Special permission dialog
 */
#define TEST_NEW_OBJ_SPECIAL_PERM1     0x00000020
#define TEST_NEW_OBJ_SPECIAL_PERM2     0x00000040
#define TEST_NEW_OBJ_SPECIAL_PERM3     0x00000080
#define TEST_NEW_OBJ_SPECIAL_PERM4     0x00000100
#define TEST_NEW_OBJ_SPECIAL_PERM5     0x00000200

#define TEST_NEW_OBJ_SPECIAL_NO_ACCESS (0)
#define TEST_NEW_OBJ_SPECIAL_PERM12    (TEST_NEW_OBJ_SPECIAL_PERM1|TEST_NEW_OBJ_SPECIAL_PERM2)
#define TEST_NEW_OBJ_SPECIAL_PERM34    (TEST_NEW_OBJ_SPECIAL_PERM3|TEST_NEW_OBJ_SPECIAL_PERM4)

SED_APPLICATION_ACCESS sedappaccessNoNewObj[] =
    { { SED_DESC_TYPE_RESOURCE, TEST_RESOURCE_NO_ACCESS,0, SZ("No Access")},
      { SED_DESC_TYPE_RESOURCE, TEST_RESOURCE_PERM12,	0, SZ("Resource perms with 1, 2")},
      { SED_DESC_TYPE_RESOURCE, TEST_RESOURCE_PERM34,	0, SZ("Resource perms with 3, 4")},
      { SED_DESC_TYPE_RESOURCE, TEST_RESOURCE_PERM135,	0, SZ("Resource perms with 1, 3, 5")},
      { SED_DESC_TYPE_RESOURCE, TEST_RESOURCE_PERM4,	0, SZ("Resource perms with 4")},
      { SED_DESC_TYPE_RESOURCE_SPECIAL, TEST_SPECIAL_PERM1, 0, SZ("Perm bit 1")},
      { SED_DESC_TYPE_RESOURCE_SPECIAL, TEST_SPECIAL_PERM2, 0, SZ("Perm bit 2")},
      { SED_DESC_TYPE_RESOURCE_SPECIAL, TEST_SPECIAL_PERM3, 0, SZ("Perm bit 3")},
      { SED_DESC_TYPE_RESOURCE_SPECIAL, TEST_SPECIAL_PERM4, 0, SZ("Perm bit 4")},
      { SED_DESC_TYPE_RESOURCE_SPECIAL, TEST_SPECIAL_PERM5, 0, SZ("Perm bit 5")}
    } ;

SED_APPLICATION_ACCESS sedappaccessNewObj[] =
    { { SED_DESC_TYPE_CONT_AND_NEW_OBJECT, TEST_RESOURCE_NO_ACCESS,TEST_NEW_OBJ_SPECIAL_NO_ACCESS, SZ("No Access")},
      { SED_DESC_TYPE_CONT_AND_NEW_OBJECT, TEST_RESOURCE_PERM12,   TEST_NEW_OBJ_SPECIAL_PERM12, SZ("Resource perms with 1, 2, New Obj 1, 2")},
      { SED_DESC_TYPE_CONT_AND_NEW_OBJECT, TEST_RESOURCE_PERM34,   TEST_NEW_OBJ_SPECIAL_PERM34, SZ("Resource perms with 3, 4, New Obj 3, 4")},
      { SED_DESC_TYPE_CONT_AND_NEW_OBJECT, TEST_RESOURCE_PERM135,  TEST_NEW_OBJ_SPECIAL_PERM12, SZ("Resource perms with 1, 3, 5, New Obj 1, 2")},
      { SED_DESC_TYPE_CONT_AND_NEW_OBJECT, TEST_RESOURCE_PERM4,    TEST_NEW_OBJ_SPECIAL_PERM34, SZ("Resource perms with 4, New Obj 3, 4")},
      { SED_DESC_TYPE_RESOURCE_SPECIAL, TEST_SPECIAL_PERM1, 0, SZ("Perm bit 1")},
      { SED_DESC_TYPE_RESOURCE_SPECIAL, TEST_SPECIAL_PERM2, 0, SZ("Perm bit 2")},
      { SED_DESC_TYPE_RESOURCE_SPECIAL, TEST_SPECIAL_PERM3, 0, SZ("Perm bit 3")},
      { SED_DESC_TYPE_RESOURCE_SPECIAL, TEST_SPECIAL_PERM4, 0, SZ("Perm bit 4")},
      { SED_DESC_TYPE_RESOURCE_SPECIAL, TEST_SPECIAL_PERM5, 0, SZ("Perm bit 5")},

      { SED_DESC_TYPE_NEW_OBJECT_SPECIAL, TEST_NEW_OBJ_SPECIAL_PERM1, 0, SZ("New Obj Perm bit 1")},
      { SED_DESC_TYPE_NEW_OBJECT_SPECIAL, TEST_NEW_OBJ_SPECIAL_PERM2, 0, SZ("New Obj Perm bit 2")},
      { SED_DESC_TYPE_NEW_OBJECT_SPECIAL, TEST_NEW_OBJ_SPECIAL_PERM3, 0, SZ("New Obj Perm bit 3")},
      { SED_DESC_TYPE_NEW_OBJECT_SPECIAL, TEST_NEW_OBJ_SPECIAL_PERM4, 0, SZ("New Obj Perm bit 4")},
      { SED_DESC_TYPE_NEW_OBJECT_SPECIAL, TEST_NEW_OBJ_SPECIAL_PERM5, 0, SZ("New Obj Perm bit 5")}
    } ;

SED_APPLICATION_ACCESS sedappaccessAuditting[] =
    { { SED_DESC_TYPE_AUDIT, TEST_RESOURCE_PERM12,   0, SZ("Resource Audits with 1, 2")},
      { SED_DESC_TYPE_AUDIT, TEST_RESOURCE_PERM34,   0, SZ("Resource Audits with 3, 4")},
      { SED_DESC_TYPE_AUDIT, TEST_RESOURCE_PERM135,  0, SZ("Resource Audits with 1, 3, 5")},
    } ;


#define SIZEOF_NEWOBJ_ARRAY	(sizeof(sedappaccessNewObj))
#define SIZEOF_NO_NEWOBJ_ARRAY	(sizeof(sedappaccessNoNewObj))
#define SIZEOF_AUDIT_ARRAY	(sizeof(sedappaccessAuditting))

#define COUNT_NEWOBJ_ARRAY	(sizeof(sedappaccessNewObj)/sizeof(SED_APPLICATION_ACCESS))
#define COUNT_NO_NEWOBJ_ARRAY	(sizeof(sedappaccessNoNewObj)/sizeof(SED_APPLICATION_ACCESS))
#define COUNT_AUDIT_ARRAY	(sizeof(sedappaccessAuditting)/sizeof(SED_APPLICATION_ACCESS))

/* We need to build a dummy security descriptor that we can pass to the
 * API.  The following was borrowed from Danl's radmin test stuff.
 */
//
// DataStructures
//

typedef struct _TEST_SID {
    UCHAR   Revision;
    UCHAR   SubAuthorityCount;
    UCHAR   IdentifierAuthority[6];
    ULONG   SubAuthority[10];
} TEST_SID, *PTEST_SID, *LPTEST_SID;

typedef struct _TEST_ACE {
    UCHAR  AceType ;
    UCHAR  AceSize ;
    UCHAR  InheritFlags ;
    UCHAR  AceFlags ;
    ACCESS_MASK Mask ;
    TEST_SID sid ;
} TEST_ACE, *PTEST_ACE ;


typedef struct _TEST_ACL {
    UCHAR   AclRevision;
    UCHAR   Sbz1;
    USHORT  AclSize;
    USHORT  AceCount;
    USHORT  sbz2 ;
    TEST_ACE Ace1[3] ;
    //TEST_ACE Ace2 ;
    //TEST_ACE Ace3 ;
} TEST_ACL, *PTEST_ACL;

typedef struct _TEST_SECURITY_DESCRIPTOR {
   UCHAR                        Revision;
   UCHAR                        Sbz1;
   SECURITY_DESCRIPTOR_CONTROL  Control;
   PTEST_SID                    Owner;
   PTEST_SID                    Group;
   PTEST_ACL                    Sacl;
   PTEST_ACL                    Dacl;
} TEST_SECURITY_DESCRIPTOR, *PTEST_SECURITY_DESCRIPTOR;

//
// GLOBALS
//

    TEST_SID     OwnerSid = { 
                        1, 5,
                        1,2,3,4,5,6,
                        0x999, 0x888, 0x777, 0x666, 0x12345678};

    TEST_SID     GroupSid = {
                        1, 5,
                        1,2,3,4,5,6,
                        0x999, 0x888, 0x777, 0x666, 0x12345678};

    TEST_ACL	 SaclAcl  = { 2, 0, sizeof(TEST_ACL)+1024, 1, 0,
				{ SYSTEM_AUDIT_ACE_TYPE, sizeof(TEST_ACE),
				  CONTAINER_INHERIT_ACE|OBJECT_INHERIT_ACE, SUCCESSFUL_ACCESS_ACE_FLAG|FAILED_ACCESS_ACE_FLAG,
				  TEST_RESOURCE_PERM12,
				  {  1, 5,
				     1,2,3,4,5,6,
				     0x999, 0x888, 0x777, 0x666, 0x12345678
				  }
				} } ;
    TCHAR _SaclAclBufferSpace[1024] ;

    TEST_ACL	 DaclAcl  = { 2, 0, sizeof(TEST_ACL)+1024, 1, 0,
				{ ACCESS_DENIED_ACE_TYPE, sizeof(TEST_ACE),
				  CONTAINER_INHERIT_ACE, 0,
				  GENERIC_ALL,
				  {  1, 5,
				     1,2,3,4,5,6,
				     0x999, 0x888, 0x777, 0x666, 0x12345678
				  }
				} } ;
    TCHAR _DaclAclBufferSpace[1024] ;

    TEST_ACL	 DaclAclNewObj = { 2, 0, sizeof(TEST_ACL)+1024, 1, 0,
				{ ACCESS_DENIED_ACE_TYPE, sizeof(TEST_ACE),
				  CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE, 0,
				  GENERIC_ALL,
				  {  1, 5,
				     1,2,3,4,5,6,
				     0x999, 0x888, 0x777, 0x666, 0x12345678
				  }
				} } ;
    TCHAR _DaclAclNewObjBufferSpace[1024] ;


TEST_ACE AuditAce1 =
				{ SYSTEM_AUDIT_ACE_TYPE, sizeof(TEST_ACE),
				  CONTAINER_INHERIT_ACE|OBJECT_INHERIT_ACE, SUCCESSFUL_ACCESS_ACE_FLAG|FAILED_ACCESS_ACE_FLAG,
				  TEST_RESOURCE_PERM135,
				  {  1, 5,
				     1,1,3,4,5,6,
				     0x999, 0x888, 0x777, 0x666, 0x12345678
				  }
				} ;
TEST_ACE AccessAce1 =
				{ ACCESS_DENIED_ACE_TYPE, sizeof(TEST_ACE),
				  CONTAINER_INHERIT_ACE, 0,
				  GENERIC_ALL,
				  {  1, 5,
				     1,1,3,4,5,6,
				     0x999, 0x888, 0x777, 0x666, 0x12345678
				  }
				} ;

TEST_ACE AccessNewObjAce1 =
				{ ACCESS_DENIED_ACE_TYPE, sizeof(TEST_ACE),
				  CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE, 0,
				  GENERIC_ALL,
				  {  1, 5,
				     1,1,3,4,5,6,
				     0x999, 0x888, 0x777, 0x666, 0x12345678
				  }
				} ;




    TEST_SECURITY_DESCRIPTOR TestSd = {
				    1, 2, SE_DACL_PRESENT|SE_SACL_PRESENT,
                                    &OwnerSid,
                                    &GroupSid,
				    &SaclAcl,
				    &DaclAcl };

    TEST_SECURITY_DESCRIPTOR TestSdNewObj = {
				    1, 2, SE_DACL_PRESENT|SE_SACL_PRESENT,
                                    &OwnerSid,
                                    &GroupSid,
				    &SaclAcl,
				    &DaclAclNewObj };



/****************************************************************************

    FUNCTION: test4()

    PURPOSE: Test the generic ACL Editor, specifically the
	     SedDiscretionaryAclEditor and the SedSystemAclEditor

    COMMENTS:

****************************************************************************/

void test4(HWND hwndParent)
{
    BOOL fIsContainer = FALSE,
	 fSupportsNewObjects = FALSE,
	 fDACLEditor = TRUE ;


    switch (MessageBox(hwndParent,SZ("Test the DACL editor (Yes) or the SACL editor (No)?"),
    SZ("Welcome to way cool test4 (AclEditor)"),MB_YESNOCANCEL))
    {
    case IDYES:
	break ;

    case IDNO:
	{
	    fDACLEditor = FALSE ;
	    BOOL	 fPresent ;
	    OS_ACL *	 posSACL ;
	    OS_ACE	 osAceSACL( (void *) &AuditAce1 ) ;
	    UIASSERT(	!osAceSACL.QueryError() ) ;
	    OS_SECURITY_DESCRIPTOR ossecdescSACL( (PSECURITY_DESCRIPTOR)&TestSd ) ;
	    UIASSERT(	!ossecdescSACL.QueryError() ) ;
	    REQUIRE(	!ossecdescSACL.QuerySACL( &fPresent, &posSACL )) ;
	    UIASSERT(	 fPresent ) ;
	    REQUIRE(	!posSACL->AddACE( 0, osAceSACL )) ;
	}
	break ;

    case IDCANCEL:
    default:
	return ;
    }


    if ( fDACLEditor )
    {
	switch (MessageBox(hwndParent,SZ("Test the container object code? "),
	SZ("Welcome to way cool test4 (SedDiscretionaryAclEditor)"),MB_YESNOCANCEL))
	{
	case IDYES:
	    fIsContainer = TRUE ;
	    break ;

	    switch (MessageBox(hwndParent,SZ("Does the container support New Object creation? "),
	    SZ("Welcome to way cool test4 (SedDiscretionaryAclEditor)"),MB_YESNOCANCEL))
	    {
	    case IDYES:
		{
		    fSupportsNewObjects = TRUE ;
		    BOOL	 fPresent ;
		    OS_ACL *	 posDACL ;
		    OS_ACE	 osAceDACL( (void *) &AccessNewObjAce1 ) ;
		    UIASSERT(	!osAceDACL.QueryError() ) ;
		    OS_SECURITY_DESCRIPTOR ossecdescDACL( (PSECURITY_DESCRIPTOR)&TestSdNewObj ) ;
		    UIASSERT(	!ossecdescDACL.QueryError() ) ;
		    REQUIRE(	!ossecdescDACL.QueryDACL( &fPresent, &posDACL )) ;
		    UIASSERT(	 fPresent ) ;
		    REQUIRE(	!posDACL->AddACE( 0, osAceDACL )) ;
		}

		break ;

	    case IDNO:
		{
		    BOOL	 fPresent ;
		    OS_ACL *	 posDACL ;
		    OS_ACE	 osAceDACL( (void *) &AccessAce1 ) ;
		    UIASSERT(	!osAceDACL.QueryError() ) ;
		    OS_SECURITY_DESCRIPTOR ossecdescDACL( (PSECURITY_DESCRIPTOR)&TestSd ) ;
		    UIASSERT(	!ossecdescDACL.QueryError() ) ;
		    REQUIRE(	!ossecdescDACL.QueryDACL( &fPresent, &posDACL )) ;
		    UIASSERT(	 fPresent ) ;
		    REQUIRE(	!posDACL->AddACE( 0, osAceDACL )) ;
		}
		break ;

	    case IDCANCEL:
	    default:
		return ;
	    }
	    break ;

	case IDNO:
	    break ;

	case IDCANCEL:
	default:
	    return ;
	}
    }

    SED_OBJECT_TYPE_DESCRIPTOR sedobjdesc ;
    GENERIC_MAPPING GenericMapping ;

    sedobjdesc.Revision 		   = SED_REVISION1 ;
    sedobjdesc.IsContainer		   = fIsContainer ;
    sedobjdesc.AllowNewObjectPerms	   = fSupportsNewObjects ;
    sedobjdesc.ObjectTypeName		   = SZ("Test object type name") ;
    sedobjdesc.MapSpecificPermsToGeneric   = FALSE ;
    sedobjdesc.GenericMapping		   = &GenericMapping ;
    sedobjdesc.HelpInfo 		   = NULL ;
    sedobjdesc.ApplyToSubContainerTitle    = SZ("Apply To Sub Container Title") ;
    sedobjdesc.SpecialObjectAccessTitle    = SZ("Special Object Access Title...") ;
    sedobjdesc.SpecialNewObjectAccessTitle = SZ("Special NEW Object Access Title...") ;

    BUFFER buff( sizeof(SED_APPLICATION_ACCESSES) +
		 fSupportsNewObjects ? SIZEOF_NEWOBJ_ARRAY : SIZEOF_NO_NEWOBJ_ARRAY) ;
    if ( buff.QueryError() )
    {
	MessageBox( hwndParent, SZ("Error occurred allocating buffer"),SZ("Exitting test"), MB_OK) ;
	return ;
    }

    PSED_APPLICATION_ACCESSES psedappaccesses = (PSED_APPLICATION_ACCESSES) buff.QueryPtr() ;
    psedappaccesses->Count =  !fDACLEditor ? COUNT_AUDIT_ARRAY :
				  fSupportsNewObjects ? COUNT_NEWOBJ_ARRAY : COUNT_NO_NEWOBJ_ARRAY ;

    //::memcpyf( psedappaccesses->AccessGroup,
    //		 !fDACLEditor ? sedappaccessAuditting :
    //		     fSupportsNewObjects ? sedappaccessNewObj : sedappaccessNoNewObj,
    //		 !fDACLEditor ? SIZEOF_AUDIT_ARRAY :
    //		     fSupportsNewObjects ? SIZEOF_NEWOBJ_ARRAY : SIZEOF_NO_NEWOBJ_ARRAY ) ;

    DWORD rc ;
    DWORD dwSEDReturnStatus ;

    if ( fDACLEditor )
	rc = SedDiscretionaryAclEditor( hwndParent,
					NULL,		// Instance handle
					SZ("\\\\JOHNL0"),
					&sedobjdesc,
					psedappaccesses,
					SZ("Resource Name (i.e., C:\MyFile)"),
					(PSED_FUNC_APPLY_SEC_CALLBACK) SedCallback,
					(ULONG_PTR)CALLBACK_CONTEXT,
					(PSECURITY_DESCRIPTOR) fSupportsNewObjects ?
						    &TestSdNewObj : &TestSd,
					FALSE,
					&dwSEDReturnStatus ) ;

    else
	rc = SedSystemAclEditor( hwndParent,
				 NULL,	// Instance handle
				 SZ("\\\\JOHNL0"),
				 &sedobjdesc,
				 psedappaccesses,
				 SZ("Resource Name (i.e., C:\MyFile)"),
				 (PSED_FUNC_APPLY_SEC_CALLBACK) SedCallback,
				 (ULONG_PTR)CALLBACK_CONTEXT,
				 (PSECURITY_DESCRIPTOR) fSupportsNewObjects ?
					     &TestSdNewObj : &TestSd,
				 FALSE,
				 &dwSEDReturnStatus ) ;

    if ( rc )
    {
	TCHAR achBuff[100] ;
	wsprintf( achBuff, "Error code %ld returned from ACL Editor", rc ) ;
	MessageBox( hwndParent, achBuff, SZ("Apptest4"), MB_OK ) ;
    }
}


DWORD SedCallback( ULONG_PTR		  ulCallbackContext,
		   PSECURITY_DESCRIPTOR   psecdesc,
		   BOOLEAN		  fApplyToSubContainers,
		   BOOLEAN		  fApplyToSubObjects,
		   LPDWORD		  StatusReturn
		 )
{
    UIASSERT( ulCallbackContext == CALLBACK_CONTEXT ) ;

    OS_SECURITY_DESCRIPTOR ossecdesc( psecdesc ) ;
    APIERR err = ossecdesc.QueryError() ;
    BOOL   fValid = ossecdesc.IsValid() ;

    TCHAR achBuff[200] ;
    wsprintf( achBuff, "ossecdesc.QueryError() = %d, fApplyToSubContainers = %d, fApplyToSubObjects = %d, security desc will be output to the debugger (if debug build)",
	      err, fApplyToSubContainers, fApplyToSubObjects ) ;
    MessageBox( NULL, achBuff, SZ("SedCallback"), MB_OK ) ;

#ifdef DEBUG
    ossecdesc.DbgPrint() ;
#endif
    *StatusReturn = SED_STATUS_FAILED_TO_MODIFY ;
    return NERR_Success ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\shell\test\apptest5.cxx ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1987-1990          **/
/********************************************************************/

/*
 *  FILE STATUS:
 *  1/02/91  Created
 *  1/12/91  Split from Logon App, reduced to just Shell Test APP
 *  2/21/91  Disabled
 */

/****************************************************************************

    PROGRAM: test5.cxx

    PURPOSE: Test module as yet undefined

    FUNCTIONS:

	test5()

    COMMENTS:

****************************************************************************/


#ifdef CODESPEC
/*START CODESPEC*/

/********
TEST5.CXX
********/

/************
end TEST5.CXX
************/
/*END CODESPEC*/
#endif // CODESPEC



#include "apptest.hxx"

/****************************************************************************

    FUNCTION: test5()

    PURPOSE: as yet undefined

    COMMENTS:

****************************************************************************/

void test5(HWND hwndParent)
{
    MessageBox(hwndParent,SZ("WNetNukeConnections/WNetRestoreConnections stress Test"),SZ("MPR Tests"),MB_OK);
    APIERR err = NERR_Success;
    for (INT i = 0; i < 3; i++)
    {
        err = WNetNukeConnections( hwndParent ) ;
        err = WNetRestoreConnection( hwndParent, NULL ) ;
    }
    MessageBox(hwndParent,SZ("Thanks for visiting test5 -- please come again!"),SZ("Test"),MB_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\shell\test\apptest7.cxx ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1987-1990          **/
/********************************************************************/

/*
 *  FILE STATUS:
 *  01/23/90  Created
 */

/****************************************************************************

    PROGRAM: test7.cxx

    PURPOSE: Test module to test WNetRestoreConnection(1)

    FUNCTIONS:

	test7()

    COMMENTS:

****************************************************************************/


#ifdef CODESPEC
/*START CODESPEC*/

/********
TEST7.CXX
********/

/************
end TEST7.CXX
************/
/*END CODESPEC*/
#endif // CODESPEC



#include "apptest.hxx"


/****************************************************************************

    FUNCTION: test7()

    PURPOSE: test WNetRestoreConnection(NULL)

    COMMENTS:

****************************************************************************/

void test7(HWND hwndParent)
{
    MessageBox(hwndParent,SZ("Welcome to sunny test7"),SZ("Test"),MB_OK);
    WNetRestoreConnection(hwndParent,NULL) ;
    MessageBox(hwndParent,SZ("Thanks for visiting test7 -- please come again!"),SZ("Test"),MB_OK);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\shell\test\apptest3.cxx ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1987-1990          **/
/********************************************************************/

/*
 *  FILE STATUS:
 *  1/02/91  Created
 *  1/12/91  Split from Logon App, reduced to just Shell Test APP
 *  2/21/91  Disabled
 */

/****************************************************************************

    PROGRAM: test3.cxx

    PURPOSE: Test module as yet undefined

    FUNCTIONS:

	test3()

    COMMENTS:

****************************************************************************/


#ifdef CODESPEC
/*START CODESPEC*/

/********
TEST3.CXX
********/

/************
end TEST3.CXX
************/
/*END CODESPEC*/
#endif // CODESPEC



#include "apptest.hxx"


/****************************************************************************

    FUNCTION: test3()

    PURPOSE: as yet undefined

    COMMENTS:

****************************************************************************/

void test3(HWND hwndParent)
{
    MessageBox(hwndParent,SZ("Welcome to sunny test3"),SZ("test disabled"),MB_OK);
    UINT rc;
    rc = WNetConnectionDialog ( hwndParent, 1 );
    MessageBox(hwndParent,SZ("Thanks for visiting test3 -- please come again!"),SZ("Test"),MB_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\shellui\bin\dummy.cxx ===
extern i ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\shell\test\testa.h ===
#define ID_END          123
#define ID_LISTBOX      125
#define ID_GO		132
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\shell\test\apptesta.cxx ===
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1987-1990          **/
/********************************************************************/

/*
 *  FILE STATUS:
 *  10/07/91  Created
 *  12/28/91  Changed WNetEnum type
 *  01/03/92  Capitalize the Resource_XXX manifest
 */

/****************************************************************************

    PROGRAM: test10.cxx

    PURPOSE: Test module to test WNetOpenEnum, WNetResourceEnum,
	WNetCloseEnum

    FUNCTIONS:

	test10()

    COMMENTS:

****************************************************************************/


#ifdef CODESPEC
/*START CODESPEC*/

/********
TEST10.CXX
********/

/************
end TEST10.CXX
************/
/*END CODESPEC*/
#endif // CODESPEC



#define INCL_NETSHARE
#define INCL_NETSERVER
#define INCL_NETUSE

#include "apptest.hxx"
#include "testa.h"
#include <lmobj.hxx>
#include <lmoshare.hxx>
#include <lmoesh.hxx>
#include <lmodev.hxx>
#include <lmosrv.hxx>
#include <lmoesrv.hxx>

#define L3_NETRESOURCE_NUM 15

extern "C"
{
#include <string.h>

BOOL FAR PASCAL EnumWndProc(HWND,WORD,WORD,LONG);
#ifdef WIN32
VOID DoIt(HANDLE , HWND );
VOID SetListbox( HWND );
#endif
}

/* Provided for error returns
 */
TCHAR achError[256], achProvider[256] ;

#ifdef WIN32

HWND hwndEnum;
BOOL fShare = FALSE;

VOID SetListbox( HWND hDlg )
{
    HCURSOR hCursor = SetCursor( LoadCursor( NULL, IDC_WAIT));
    ShowCursor( TRUE );
    HWND hwndListbox = GetDlgItem( hDlg, ID_LISTBOX);
    HWND hwndGo = GetDlgItem( hDlg, ID_GO );
    SendMessage( hwndListbox, LB_RESETCONTENT, 0, 0 );
    if (fShare )
    {
	SetWindowText( hwndGo, SZ("CONNECTED"));
    }
    else
    {
	SetWindowText( hwndGo, SZ("GLOBALNET"));
    }
    HANDLE hEnum;
    DWORD err;
    if (fShare )
	err = WNetOpenEnum( RESOURCE_GLOBALNET, 0, 0, NULL, &hEnum );
    else
	err = WNetOpenEnum( RESOURCE_CONNECTED, 0, 0,NULL,&hEnum);
    if ( err != WN_SUCCESS)
    {
	TCHAR pszStr[100];
	wsprintf( pszStr, "Cannot open enum: error %d", err );
	if ( err != 2 )
	{
	    wsprintf( pszStr, "Cannot open enum : error %d", err );
	}
	else
	{
	    UINT uErr;
	    WNetGetLastError( (DWORD*)&uErr, achError, sizeof(achError)/sizeof(TCHAR), achProvider, sizeof(achProvider)/sizeof(TCHAR) );
	    wsprintf( pszStr, "Cannot open enum: error %d, Text: %s   Provider: %s", uErr, achError, achProvider );
	}
	MessageBox( hDlg, pszStr, SZ("test"), MB_OK );
	return;
    }

    NETRESOURCE *pBuffer =(NETRESOURCE *) malloc(sizeof(NETRESOURCE) + 50 );
    DWORD Count = 1;
    DWORD dwBuffSize = sizeof( NETRESOURCE)+50 ;
    err = WNetEnumResource( hEnum, &Count, pBuffer, &dwBuffSize );
    if ( err != WN_NO_MORE_ENTRIES )
    {
	if ( err != WN_SUCCESS)
	{
	    TCHAR pszStr[100];
	    wsprintf( pszStr, "Cannot Enum resource: error %d", err );
	    UIDEBUG(pszStr);
	    UIDEBUG(SZ("\n\r"));
	    SendMessage( hwndListbox, LB_ADDSTRING,0,(LONG)pszStr);
	}
	else
	{
	    TCHAR pszStr[100];
	    wsprintf( pszStr,"%s connect:%s Scope:%s Type:%s Usage:%s",
		pBuffer->lpRemoteName ,
		( pBuffer->dwScope != RESOURCE_CONNECTED ) ? SZ("no"):
		    (( pBuffer->lpLocalName == NULL )?SZ("<empty localname>"):
		    pBuffer->lpLocalName),
		( pBuffer->dwScope == RESOURCE_CONNECTED )?SZ("connected"):SZ("globalnet"),
		( pBuffer->dwType == 0 )?SZ("disk and print"):
		    ( pBuffer->dwType == RESOURCETYPE_DISK )?SZ("disk"):SZ("print"),
		( pBuffer->dwUsage == 0 )?SZ("unknow"):
		    (pBuffer->dwUsage == RESOURCEUSAGE_CONTAINER )?SZ("container"):
		    SZ("connectable")
		);
	    SendMessage( hwndListbox, LB_ADDSTRING, 0, (LONG)pszStr);
	    if (fShare)
	    {
		HANDLE hEnum2;
		DWORD err;
		err = WNetOpenEnum( RESOURCE_GLOBALNET, 0, RESOURCEUSAGE_CONTAINER, pBuffer,&hEnum2);
		if ( err != WN_SUCCESS)
		{
		    TCHAR pszStr[100];
		    wsprintf( pszStr, "Cannot open enum 2: error %d", err );
		    MessageBox( hDlg, pszStr, SZ("test"), MB_OK );
		    return;
		}

		NETRESOURCE *pBuffer2=(NETRESOURCE *)malloc(sizeof(NETRESOURCE)+50);
		for(INT cCount =0; cCount < 60; cCount ++)
		{
		    DWORD Count = 1;
		    DWORD dwBuffSize = sizeof(NETRESOURCE)+50 ;
		    err=WNetEnumResource(hEnum2,&Count,pBuffer2,&dwBuffSize );
		    if (( err == WN_NO_MORE_ENTRIES ) || (Count!=1))
		    {
			break;
		    }
		    if ( err != WN_SUCCESS)
		    {
			TCHAR pszStr[100];
			if ( err != 2 )
			{
			    wsprintf( pszStr, "Cannot Enum resource 2: error %d", err );
			}
			else
			{
			    UINT uErr;
			    WNetGetLastError( (DWORD*)&uErr, achError, sizeof(achError)/sizeof(TCHAR), achProvider, sizeof(achProvider)/sizeof(TCHAR) );
			    wsprintf( pszStr, "Cannot Enum resource 2: error %d, Text: %s   Provider: %s", uErr, achError, achProvider );
			}
			UIDEBUG(pszStr);
			UIDEBUG(SZ("\n\r"));
			SendMessage(hwndListbox,LB_ADDSTRING,0,(LONG)pszStr);
			break;
		    }
		    TCHAR pszStr[100];
		    wsprintf( pszStr,"   %s:%s connect:%s Scope:%s Type:%s Usage:%s",
			pBuffer->lpRemoteName,
			pBuffer2->lpRemoteName ,
			( pBuffer2->dwScope != RESOURCE_CONNECTED ) ? SZ("no"):
			    (( pBuffer2->lpLocalName == NULL )?SZ("<empty localname>"):
			    pBuffer2->lpLocalName),
			( pBuffer2->dwScope == RESOURCE_CONNECTED )?SZ("connected"):
			    SZ("globalnet"),
			( pBuffer2->dwType == 0 )?SZ("disk and print"):
			    ( pBuffer2->dwType == RESOURCETYPE_DISK )?SZ("disk"):SZ("print"),
			( pBuffer2->dwUsage == 0 )?SZ("unknow"):
			    (pBuffer2->dwUsage == RESOURCEUSAGE_CONTAINER )?SZ("container"):
			    SZ("connectable")
			);
		    SendMessage( hwndListbox,LB_ADDSTRING, 0,
			(LONG)pszStr);
		    if ( TRUE )
		    /*
		    if ((strcmp( pBuffer2->lpRemoteName, "\\\\ANDREWCO2") != 0 ) &&
			(strcmp( pBuffer2->lpRemoteName, "\\\\DAVEGOE") != 0 ) &&
			(strcmp( pBuffer2->lpRemoteName, "\\\\JOHNOW") != 0 ) &&
			(strcmp( pBuffer2->lpRemoteName, "\\\\TOMM3") != 0 ) &&
			(strcmp( pBuffer2->lpRemoteName, "\\\\DAVIDRO2") != 0 ) &&
			(strcmp( pBuffer2->lpRemoteName, "\\\\JUICYFRUIT") != 0 ) &&
			(strcmp( pBuffer2->lpRemoteName, "\\\\ROBERTRE4") != 0 ) &&
			(strcmp( pBuffer2->lpRemoteName, "\\\\STEVEWO_OS2") != 0 ))
		    */
		    {
			UIDEBUG(pBuffer2->lpRemoteName );
			UIDEBUG(SZ("\n\r"));
			HANDLE hEnum3;
			err = WNetOpenEnum( RESOURCE_GLOBALNET, 0, 0,pBuffer2,&hEnum3);
			if ( err != WN_SUCCESS)
			{
			    TCHAR pszStr[100];
			    wsprintf( pszStr, "Cannot open enum 3: error %d", err );
			    MessageBox( hDlg, pszStr, SZ("test"), MB_OK );
			    return;
			}

			NETRESOURCE *pBegin=(NETRESOURCE *)malloc(L3_NETRESOURCE_NUM*sizeof(NETRESOURCE)+50);
			NETRESOURCE *pBuffer3 = pBegin;
			for(;;)
			{
			    DWORD Count = 1;
			    DWORD dwBuffSize = L3_NETRESOURCE_NUM*sizeof(NETRESOURCE)+50 ;
			    err=WNetEnumResource(hEnum3,&Count,pBuffer3, &dwBuffSize );
			    if (( err == WN_NO_MORE_ENTRIES ) || (Count!=1))
			    {
				break;
			    }
			    if ( err != WN_SUCCESS)
			    {
				TCHAR pszStr[100];
				if ( err != 2 )
				{
				    wsprintf( pszStr, "Cannot Enum resource 3: error %d", err );
				}
				else
				{
				    UINT uErr;
				    WNetGetLastError( (DWORD*)&uErr, achError, sizeof(achError)/sizeof(TCHAR), achProvider, sizeof(achProvider)/sizeof(TCHAR) );
				    wsprintf( pszStr, "Cannot Enum resource 3: error %d, Text: %s   Provider: %s", uErr, achError, achProvider );
				}
				UIDEBUG(pszStr);
				UIDEBUG(SZ("\n\r"));
				SendMessage(hwndListbox,LB_ADDSTRING,0,(LONG)pszStr);
				break;
			    }
			    for (DWORD i=0; i < Count; i++, pBuffer3++)
			    {
				TCHAR pszStr[100];
				wsprintf( pszStr,
				    "      %s:%s:%s connect:%s Scope:%s Type:%s Usage:%s",
				    pBuffer->lpRemoteName, pBuffer2->lpRemoteName ,
				    pBuffer3->lpRemoteName,
				    ( pBuffer3->dwScope != RESOURCE_CONNECTED ) ? SZ("no"):
					(( pBuffer3->lpLocalName == NULL )?SZ("<empty localname>"):
					pBuffer3->lpLocalName),
				    ( pBuffer3->dwScope == RESOURCE_CONNECTED )?SZ("connected"):
					SZ("globalnet"),
				    ( pBuffer3->dwType == 0 )?SZ("disk and print"):
					( pBuffer3->dwType == RESOURCETYPE_DISK )?SZ("disk"):SZ("print"),
				    ( pBuffer3->dwUsage == 0 )?SZ("unknow"):
					(pBuffer3->dwUsage == RESOURCEUSAGE_CONTAINER )?SZ("container"):
					SZ("connectable")
				    );
				SendMessage( hwndListbox,LB_ADDSTRING, 0,
				    (LONG)pszStr);
			    }
			    if ( err == WN_NO_MORE_ENTRIES )
			    {
				break;
			    }
			}
			err = WNetCloseEnum( hEnum3 );
			if ( err != WN_SUCCESS)
			{
			    TCHAR pszStr[100];
			    wsprintf( pszStr, "Cannot close enum 3: error %d", err );
			    MessageBox( hDlg, pszStr, SZ("test"), MB_OK );
			}
			if (pBegin != NULL )
			    free(pBegin);
		    }
		}
		err = WNetCloseEnum( hEnum2 );
		if ( err != WN_SUCCESS)
		{
		    TCHAR pszStr[100];
		    wsprintf( pszStr, "Cannot close enum 2: error %d", err );
		    MessageBox( hDlg, pszStr, SZ("test"), MB_OK );
		}
		free(pBuffer2);
	    }
	}
    }
    err = WNetCloseEnum( hEnum );
    if ( err != WN_SUCCESS)
    {
	TCHAR pszStr[100];
	wsprintf( pszStr, "Cannot close enum: error %d", err );
	MessageBox( hDlg, pszStr, SZ("test"), MB_OK );
	return;
    }
    free(pBuffer);
    ShowCursor( FALSE );
    SetCursor( hCursor);
    return;
}

#endif

BOOL EnumWndProc( HWND hDlg, WORD message, WORD wParam, LONG lParam )
{
#ifdef WIN32
    switch(message)
    {
    case WM_INITDIALOG:
	fShare = FALSE;
	SetListbox(hDlg );
	return TRUE;
    case WM_COMMAND:
    {
	switch(wParam)
	{
	case ID_GO:
	    if ( fShare )
	    {
		fShare = FALSE;
		SetListbox(hDlg );
	    }
	    else
	    {
		fShare = TRUE;
		SetListbox(hDlg );
	    }
	    return TRUE;
	case ID_END:
	    DestroyWindow(hDlg );
	    return TRUE;
	}
    }
    }
#endif
    return FALSE;
}

#ifdef WIN32

VOID DoIt(HANDLE hInstance, HWND hwndParent )
{
    hwndEnum = CreateDialog( hInstance, SZ("TEST_A"), hwndParent,
	(DLGPROC) MakeProcInstance((WNDPROC) EnumWndProc, hInstance));
}

/****************************************************************************

    FUNCTION: test10()

    PURPOSE: test WNetOpenEnum

    COMMENTS:

****************************************************************************/

void test10(HANDLE hInstance, HWND hwndParent)
{
    MessageBox(hwndParent,SZ("Welcome to sunny test10"),SZ("Test"),MB_OK);
    DoIt( hInstance, hwndParent );
    //MessageBox(hwndParent,"Thanks for visiting test10 -- please come again!","Test",MB_OK);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\shellui\file\wnprop.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**             Copyright(c) Microsoft Corp., 1991                   **/
/**********************************************************************/

/*
    wnprop.cxx
    This file contains the following symbols:
        WNetGetPropertyText
        WNetPropertyDialog


    FILE HISTORY:
        rustanl     29-Apr-1991     Created
        rustanl     24-May-1991     Added calls to permission test program
        terryk      22-May-1991     add parent class name to constructor
        Yi-HsinS    15-Aug-1991     Added calls to share dialogs
        Yi-HsinS    31-Dec-1991     Unicode Work

*/
#include <ntstuff.hxx>

#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_DOSERRORS
#define INCL_NETERRORS
#define INCL_NETFILE
#define _WINNETWK_
#include <lmui.hxx>
#undef _WINNETWK_

extern "C"
{
    #include <wnet1632.h>
    #include <winlocal.h>
}

#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MSGPOPUP
#define INCL_BLT_MISC
#include <blt.hxx>

#include <string.hxx>
#include <opens.hxx>
#include <sharedlg.h>

#include <uitrace.hxx>

#include <wnprop.hxx>
#include <wnetdev.hxx>

/* This array contains the button indices and the associated string IDs
 * for that button.
 */

MSGID aidsButtonNames[] =
                    {
                      IDS_PROP_BUTTON_FILEOPENS,
                      0
                    } ;

RESOURCE_STR * PROPERTY_DIALOG::pnlsButtonName[] = { NULL, NULL } ;

/*******************************************************************

    NAME:       PROPERTY_DIALOG::Construct

    SYNOPSIS:   Property Dialog pseudo constructor

    EXIT:       Initializes the array of button names, should be called
                before the static QueryButtonName is called.

    NOTES:

    HISTORY:
        Johnl   04-Aug-1991     Created

********************************************************************/

APIERR PROPERTY_DIALOG::Construct( void )
{
    INT i = 0 ;
    while ( aidsButtonNames[i] != 0 )
    {
        pnlsButtonName[i] = new RESOURCE_STR( aidsButtonNames[i] ) ;
        if ( pnlsButtonName[i]->QueryError() != NERR_Success )
        {
            UIDEBUG( SZ("PROPERTY_DIALOG::Construct - Error loading button names")) ;
            return pnlsButtonName[i]->QueryError() ;
        }
        i++ ;
    }

    return NERR_Success ;
}

/*******************************************************************

    NAME:       PROPERTY_DIALOG::Destruct

    SYNOPSIS:   Pseudo Destructor.

    NOTES:

    HISTORY:
        Johnl   04-Aug-1991     Created

********************************************************************/

void PROPERTY_DIALOG::Destruct()
{
    INT i = 0 ;
    while ( aidsButtonNames[i] != 0 )
    {
        delete pnlsButtonName[i] ;
        pnlsButtonName[i] = NULL ;
        i++ ;
    }
}

/*******************************************************************

    NAME:       PROPERTY_DIALOG::QueryButtonName

    SYNOPSIS:   Returns the button name for a particular button

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

        The following notes described what *really* is to take place.
        The following table describes which buttons are used for
        which types of objects.  F stands for File, and D for Directory.
        Note, no buttons are used for multiple selections.

            Permissions         FD
            Auditing            FD
            //Volume              D
            Share               D
            In use by           F

        To check whether or not to display the Permission and Auditing
        buttons, the following is done.  Call NetAccessGetInfo.
        If it returns success, more data, buf too small, or
        resource not found, display the button; otherwise, don't.

        //For Volume, call I_DfsCheckExitPoint.  Display button iff
        //the directory is an exit point.

        For Share, use a DEVICE object on the drive letter.  Then,
        call dev.IsRemote.  If remote, then use dev.QueryRemoteName()
        and call NetShareGetInfo on that server and share.  If return
        is success, more data, or buf too small, display the button;
        otherwise, don't.

        For In use by, call NetFileEnum2.


        To check whether a name is valid (maybe not in this function),
        use the following FSA:

                        0   1   2   3   4   5   6
            ^           4   2   1   4   3   6   6
            "           1   5   1   6   3   6   6
            other       3   1   1   3   3   6   6

        where 0 is the initial state, and 3 and 5 are accepting
        states.


    HISTORY:
        rustanl     29-Apr-1991     Created
        rustanl     03-May-1991     Added notes
        Johnl       21-Jan-1992     Removed Permission/Auditting buttons

********************************************************************/

APIERR PROPERTY_DIALOG::QueryButtonName( UINT iButton,
                                         UINT nPropSel,
                                         const NLS_STR * * ppnlsName )
{
    INT i = -1;
    switch ( nPropSel )
    {
    case WNPS_FILE:
        {
            switch ( iButton )
            {
            /* Note: These numbers are the actual indices past to us by
             * the file manager (and not magic numbers).
             */
            case 0:
                i = PROP_ID_FILEOPENS ;
                break ;

            default:
                break;
            }
        }
        break;

    case WNPS_DIR:
        break;

    case WNPS_MULT:
        break;
    }

    /* We are being asked for a button that we don't support
     */
    if ( i == -1 )
    {
        return WN_NOT_SUPPORTED ;
    }

    *ppnlsName = pnlsButtonName[ i ] ;

    return NERR_Success;

}  // PROPERTY_DIALOG::QueryButtonName

/*******************************************************************

    NAME:       WNetGetPropertyText

    SYNOPSIS:   This function is used to determine the names of
                buttons added to a property dialog for some particular
                resources.  It is called everytime such a dialog is
                brought up, and prior to displaying the dialog.

                If the user clicks a button added through this API
                by the Winnet driver, WNetPropertyDialog will be called
                with the appropriate parameters.

                In Windows 3.1, only File Manager calls this API.  File
                Manager then calls it on files and directories.

    ENTRY:
                iButton         Indicates the index (starting at 0) of the
                                button.

                                The Windows 3.1 File Manager will support
                                at most 6 buttons.

                nPropSel        Specifies what items the property dialog
                                focuses on.

                                In Windows 3.1, it can be one of the
                                following values:
                                    WNPS_FILE   single file
                                    WNPS_DIR    single directory
                                    WNPS_MULT   multiple selection of
                                                files and/or directories

                lpszName        Specifies the names of the item or items
                                to be viewed or edited by the dialog.

                                In Windows 3.1, the items are files (and
                                directories), so the item names are file
                                names.  These will
                                be unambiguous, contain no wildcard
                                characters and will be fully qualified (e.g.,
                                C:\LOCAL\FOO.BAR).  Multiple filenames
                                will be separated with spaces.  Any filename
                                may be quoted (e.g., "C:\My File") in which
                                case it will be treated as a single name.  The
                                caret character '^' may also be used as the
                                quotation mechanism for single characters
                                (e.g., C:\My^"File, "C:\My^"File" both refer
                                to the file C:\My"File).

                lpButtonName    Points to a buffer where the Winnet driver
                                should copy the name of the property button.

                cchButtonName   Specifies the size of the lpButtonName
                                buffer in count of characters for NT and
                                is a byte count for Win 3.1.

                nType           Specifies the item type.

                                In Windows 3.1, only WNTYPE_FILE will be used.


    EXIT:       On success, the buffer pointed to by lpButtonName will
                contain the name of the property button.  If this buffer,
                on exit, contains the empty string, then the corresponding
                button and all succeeding buttons will be removed from the
                dialog box.  The network driver cannot "skip" a button.

    RETURNS:    A Winnet return code, including:

                    WN_SUCCESS          lpButtonName can be used.  If it
                                        points to the empty string, no
                                        button corresponds to an index as
                                        high as iButton.
                    WN_OUT_OF_MEMORY    Couldn't load string from resources
                    WN_MORE_DATA        The given buffer is too small
                                        to fit the text of the button.
                    WN_BAD_VALUE        The lpszName parameter takes an
                                        unexpected form.
                    WN_NOT_SUPPORTED    Property dialogs are not supported
                                        for the given object type (nType).

    NOTES:      The behavior, parameters, and return values of this
                function are specified in the Winnet 3.1 spec.

    HISTORY:
            rustanl     29-Apr-1991     Created
            Johnl       02-Sep-1991     Updated for real world.
            beng        06-Apr-1992     Unicode fixes

********************************************************************/

UINT /* FAR PASCAL */ WNetGetPropertyText( UINT iButton,
                                           UINT nPropSel,
                                           LPTSTR lpszName,
                                           LPTSTR lpButtonName,
                                           UINT cchButtonName,
                                           UINT nType           )
{
    APIERR err ;
    if ( err = InitShellUI() )
    {
        return err ;
    }

    UNREFERENCED( lpszName );

    if ( nType != WNTYPE_FILE )
    {
        //  Note.  Only WNTYPE_FILE is used in Windows 3.1.
        UIDEBUG( SZ("WNetGetPropertyText received unexpected nType value\r\n"));
        return ERROR_NOT_SUPPORTED;
    }

    const NLS_STR * pnlsButtonName;
    err = PROPERTY_DIALOG::QueryButtonName( iButton,
                                            nPropSel,
                                            &pnlsButtonName );
    if ( err != NERR_Success )
    {
        return err;
    }
    UINT nButtonNameLen = pnlsButtonName->QueryTextLength()+1 ;

    if ( cchButtonName < nButtonNameLen )  // dialog name
    {
        UIDEBUG( SZ("WNetGetPropertyText given too small a buffer\r\n") );
        return ERROR_MORE_DATA;
    }

    /* Note: This is an NLS_STR strcpy.
     */
    ::strcpy( (TCHAR *) lpButtonName, *pnlsButtonName );
    return NERR_Success;

}  // WNetGetPropertyText


/*******************************************************************

    NAME:       WNetPropertyDialog

    SYNOPSIS:   This function is called out to when the user clicks
                a button added through the WNetGetPropertyText API.

                In Windows 3.1, this will only be called for file and
                directory network properties.

    ENTRY:
                hwndParent  Specifies the parent window which should own
                            the file property dialog.

                iButton     Indicates the index (starting at 0) of the
                            button that was pressed.

                nPropSel    Specifies what items the property dialog should
                            act on.

                            In Windows 3.1, it can be one of the
                            following values:
                                WNPS_FILE   single file
                                WNPS_DIR    single directory
                                WNPS_MULT   multiple selection of
                                            files and/or directories

                lpszName    Points to the names of the items that the
                            property dialog should act on.

                            See the WNetGetPropertyText API for a description
                            of the format of what lpszName points to.

                nType       Specifies the item type.

                            For Windows 3.1, only WNTYPE_FILE will be used.

    RETURNS:    A Winnet return code, including:

                    WN_SUCCESS          Success
                    WN_BAD_VALUE        Some parameter takes an unexpected
                                        form or value
                    WN_OUT_OF_MEMORY    Not enough memory to display the
                                        dialog
                    WN_NET_ERROR        Some other network error occurred

    NOTES:      Note, this function is only called on sets of properties
                for which WNetGetPropertyText has assigned a button name.

                The behavior, parameters, and return values of this
                function are specified in the Winnet 3.1 spec.

    HISTORY:
        rustanl     29-Apr-1991     Created

********************************************************************/

UINT /* FAR PASCAL */ WNetPropertyDialog( HWND hwndParent,
                                          UINT iButton,
                                          UINT nPropSel,
                                          LPTSTR lpszName,
                                          UINT nType        )
{
    APIERR err ;
    if ( err = InitShellUI() )
    {
        return err ;
    }

    if ( nType != WNTYPE_FILE )
    {
        //  Note.  Only WNTYPE_FILE is used in Windows 3.1.
        UIDEBUG( SZ("WNetPropertyDialog received unexpected nType value\r\n"));
        return ERROR_NOT_SUPPORTED;
    }

    const NLS_STR * pnlsButtonName;
    err = PROPERTY_DIALOG::QueryButtonName( iButton,
                                            nPropSel,
                                            &pnlsButtonName );
    if ( err != NERR_Success )
    {
        return err;
    }

    if ( *pnlsButtonName == *PROPERTY_DIALOG::QueryString( PROP_ID_FILEOPENS ) )
    {
        err = DisplayOpenFiles( hwndParent,
                         (WORD)nPropSel,
                         lpszName ) ;
    }

    return err;

}  // WNetPropertyDialog




/* Standard Init and Uninit calls.
 */

APIERR I_PropDialogInit( void )
{
    APIERR err ;
    //if ( err = MapError( PROPERTY_DIALOG::Construct()))
    if ( err = PROPERTY_DIALOG::Construct())
    {
        return err ;
    }

    return NERR_Success ;
}

void   I_PropDialogUnInit( void )
{
    PROPERTY_DIALOG::Destruct() ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\shell\test\testpars.c ===
/**********************************************************************/
/**                       Microsoft LAN Manager                      **/
/**                Copyright(c) Microsoft Corp., 1990                **/
/**********************************************************************/

/*
    testpars.c
    Tests the FLNParse routine in the winnet driver

    FILE HISTORY:
    Johnl    6-12-90    Created

*/



//  This is annoying
#define  NOGDICAPMASKS
#define  NOVIRTUALKEYCODES
#define  NOWINMESSAGES
#define  NOWINSTYLES
#define  NOSYSMETRICS
#define  NOMENUS
#define  NOICONS
#define  NOKEYSTATES
#define  NOSYSCOMMANDS
#define  NORASTEROPS
#define  NOSHOWWINDOW
#define  OEMRESOURCE
#define  NOATOM
#define  NOCLIPBOARD
#define  NOCOLOR
#define  NOCTLMGR
#define  NODRAWTEXT
#define  NOGDI
//#define  NOMB
#define  NOMETAFILE
#define  NOMINMAX
#define  NOMSG
#define  NOSCROLL
#define  NOSOUND
#define  NOTEXTMETRIC
#define  NOWH
#define  NOWINOFFSETS
#define  NOCOMM
#define  NOKANJI
#define  NOHELP
#define  NOPROFILER
#include <windows.h>

#define INCL_ERRORS
#include <uierr.h>

#define LFN
#include <winnet.h>

#define OS2_INCLUDED
#include <lmcons.h>
#undef OS2_INCLUDED
#include <uinetlib.h>
#include <netlib.h>

#include <assert.h>
#include <stdio.h>
#include <dos.h>

typedef PASCAL FAR LFNPARSEPROC(LPSTR, LPSTR, LPSTR) ;
typedef PASCAL FAR LFNVOLUMETYPEPROC( WORD, LPWORD ) ;

#ifdef LFNFIND_TEST
typedef PASCAL FAR LFNFINDFIRST( LPSTR, WORD, LPWORD, LPWORD, WORD, FILEFINDBUF2 FAR *) ;
typedef PASCAL FAR LFNFINDNEXT( WORD, LPWORD, WORD, FILEFINDBUF2 FAR * ) ;
typedef PASCAL FAR LFNFINDCLOSE( WORD ) ;
#endif

typedef PASCAL FAR LFNGETVOLLABEL(WORD, LPSTR ) ;
typedef PASCAL FAR LFNSETVOLLABEL(WORD, LPSTR ) ;
typedef PASCAL FAR LFNMKDIR( LPSTR ) ;
typedef PASCAL FAR LFNRMDIR( LPSTR );
typedef PASCAL FAR LFNGETATTRIBUTES(LPSTR, LPWORD ) ;
typedef PASCAL FAR LFNSETATTRIBUTES(LPSTR, WORD ) ;

#define DRIVE_F 6
#define DRIVE_H 8

int PASCAL WinMain( HANDLE, HANDLE, LPSTR, int ) ;

int PASCAL WinMain( HANDLE hInstance,
                    HANDLE hPrevInstance,
                    LPSTR  lpCmdLine,
                    int    nCmdShow  )
{

    LFNPARSEPROC      far *lpLFNParse ;
    LFNVOLUMETYPEPROC far *lpLFNVolumeType ;
#ifdef LFNFIND_TEST
    LFNFINDFIRST      far *lpLFNFindFirst ;
    LFNFINDNEXT       far *lpLFNFindNext ;
    LFNFINDCLOSE      far *lpLFNFindClose ;
#endif
    LFNGETVOLLABEL    far *lpLFNGetVolLabel ;
    LFNSETVOLLABEL    far *lpLFNSetVolLabel ;
    LFNMKDIR          far *lpLFNMkDir ;
    LFNRMDIR          far *lpLFNRmDir ;
    LFNGETATTRIBUTES  far *lpLFNGetAttributes ;
    LFNSETATTRIBUTES  far *lpLFNSetAttributes ;

    HANDLE hWinnet = LoadLibrary("Lanman.drv" ) ;

    MessageBox( NULL, "This test requires drive H: to be an HPFS redirected drive and drive F: to be FAT redirected drive", "LFN Test Suite", MB_OK ) ;

    MessageBox( NULL, "Begin", "LFN Test Suite", MB_OK ) ;

    assert( hWinnet > 32 ) ;

    assert( (lpLFNParse =       (LFNPARSEPROC far*)      GetProcAddress( hWinnet, "LFNParse"          )) != NULL ) ;
    assert( (lpLFNVolumeType =  (LFNVOLUMETYPEPROC far*) GetProcAddress( hWinnet, "LFNVolumeType"     )) != NULL ) ;
#ifdef LFNFIND_TEST
    assert( (lpLFNFindFirst =   (LFNFINDFIRST far*)      GetProcAddress( hWinnet, "LFNFindFirst"      )) != NULL ) ;
    assert( (lpLFNFindNext =    (LFNFINDNEXT far*)       GetProcAddress( hWinnet, "LFNFindNext"       )) != NULL ) ;
    assert( (lpLFNFindClose =   (LFNFINDCLOSE far*)      GetProcAddress( hWinnet, "LFNFindClose"      )) != NULL ) ;
#endif
    assert( (lpLFNGetVolLabel = (LFNGETVOLLABEL far *)   GetProcAddress( hWinnet, "LFNGetVolumeLabel" )) != NULL ) ;
    assert( (lpLFNSetVolLabel = (LFNSETVOLLABEL far *)   GetProcAddress( hWinnet, "LFNSetVolumeLabel" )) != NULL ) ;
    assert( (lpLFNMkDir       = (LFNMKDIR far *)         GetProcAddress( hWinnet, "LFNMkDir"          )) != NULL ) ;
    assert( (lpLFNRmDir       = (LFNRMDIR far *)         GetProcAddress( hWinnet, "LFNRmDir"          )) != NULL ) ;
    assert( (lpLFNGetAttributes=(LFNGETATTRIBUTES far *) GetProcAddress( hWinnet, "LFNGetAttributes"  )) != NULL ) ;
    assert( (lpLFNSetAttributes=(LFNSETATTRIBUTES far *) GetProcAddress( hWinnet, "LFNSetAttributes"  )) != NULL ) ;

    //*******************************************************************
    // Test VolumeType
    {
        WORD  wVolType, wErr ;
        char buff[150] ;
        // Drive H: is redirected to a drive that supports long filenames
        wErr = lpLFNVolumeType( DRIVE_H, &wVolType ) ;
        if ( wErr )
        {
            sprintf( buff, "LFNVolumeType returned error %d on drive H (wVolType = %d)", wErr, wVolType ) ;
            MessageBox( NULL, buff, "LFN Test Suite", MB_OK ) ;
        }

        assert( wVolType == VOLUME_LONGNAMES ) ;

        // Drive F: is redirected to a drive that does not support long filenames
        wErr = lpLFNVolumeType( DRIVE_F, &wVolType ) ;
        if ( wErr )
        {
            sprintf( buff, "LFNVolumeType returned error %d on drive F (wVolType = %d)", wErr, wVolType ) ;
            MessageBox( NULL, buff, "LFN Test Suite", MB_OK ) ;
        }
        assert( wVolType == VOLUME_STANDARD ) ;
    }

    //*******************************************************************
    // Test LFNSetVolumeLabel & LFNGetVolumeLabel
    {
        char *pchLabel = "VolLabel" ;
        WORD wErrF, wErrH ;
        static char LabelF[15], LabelH[15], Buff[128] ;

        wErrF = lpLFNGetVolLabel( DRIVE_F, LabelF ) ;
        if ( wErrF )
            *LabelF = '\0' ;

        wErrH = lpLFNGetVolLabel( DRIVE_H, LabelH ) ;
        if ( wErrH )
            *LabelH = '\0' ;

        wsprintf(Buff, "Drive F is \"%s\", wErr = %d, Drive H is \"%s\", wErr = %d",
                      LabelF, wErrF, LabelH, wErrH ) ;
        OutputDebugString("LFNParse:" ) ;
        OutputDebugString( Buff ) ;
        MessageBox( NULL, Buff, "LFN Test Suite", MB_OK ) ;

        assert( lpLFNSetVolLabel( DRIVE_F, pchLabel ) == ERROR_ACCESS_DENIED ) ;
        assert( lpLFNSetVolLabel( DRIVE_H, pchLabel ) == ERROR_ACCESS_DENIED ) ;
    }

    //*******************************************************************
    // Test LFNParse combining file and mask
    {
        struct
        {
            char * pszFile ;
            char * pszMask ;
            char * pszCompString ;
            int    RetVal ;
        } ParseCombTest[] =
            {
               "\\STUFF\\FOO", "\\BAR\\?1?23",  "\\STUFF\\BAR\\F1O23",  FILE_83_CI,
               "\\A\\B\\C\\FILE", "1\\2\\*.*", "\\A\\B\\C\\1\\2\\FILE", FILE_83_CI,
               "A:\\FOOT.BALL",   "*",         "A:\\FOOT.BALL",         FILE_LONG,
               "A:\\FOOT.BALL",   "*.*",       "A:\\FOOT.BALL",         FILE_LONG,
               "A:\\1234.567",    "*.*.*",     "A:\\1234.567",          FILE_83_CI,
               "A:\\1234.567",    "*3.5*7",    "A:\\123.567",           FILE_83_CI,
               "A:\\1234.567",    "*a.5*7",    "A:\\1234.567a.57",      FILE_LONG,
               "A:\\FOOT.BALL",   "?",         "A:\\F",                 FILE_83_CI,
               "A:\\FOOT.BALL",   "????????.???", "A:\\FOOT.BAL",       FILE_83_CI,
               "\\TEST\\FOO",     "\\MOO\\?1?2?3","\\TEST\\MOO\\F1O23", FILE_83_CI,
               "A:\\FOOT.BALL",   "A",         "A:\\A",                 FILE_83_CI,
               "A:\\FOOT.BALL",   "TST.???",   "A:\\TST.BAL",           FILE_83_CI,
               "A:\\FOOT.BALL",   "B.*",       "A:\\B.BALL",            FILE_LONG,
               "A:\\FOOT.BALL",   "B",         "A:\\B",                 FILE_83_CI,
               "A:\\E.F.G.Hey.IJK", "*.*..H.I??", "A:\\E.F..H.IJK",     FILE_LONG,
               NULL, NULL, NULL, 0
            } ;
        int i = 0 ;

        while ( ParseCombTest[i].pszFile != NULL )
        {
            static char Result[512] ;

            int iRet = lpLFNParse( ParseCombTest[i].pszFile,
                                   ParseCombTest[i].pszMask,
                                   Result                   ) ;
            assert( iRet == ParseCombTest[i].RetVal ) ;
            assert( !strcmpf( Result, ParseCombTest[i].pszCompString ) ) ;

            i++ ;
        }
    }

    //*******************************************************************
    // Test LFNGet/SetAttributes
    {
        // Bogus value at the moment...
        WORD wAttr = 0x00 ;

        // GP Fault here?
        assert( !lpLFNSetAttributes("H:\\foo.bar\\foo.bar", _A_NORMAL ) ) ;
        assert( !lpLFNGetAttributes("H:\\foo.bar\\foo.bar", &wAttr ) ) ;
        assert( wAttr == _A_NORMAL ) ;

        assert( !lpLFNSetAttributes("F:\\foo.bar\\foo.bar", _A_NORMAL ) ) ;
        assert( !lpLFNGetAttributes("F:\\foo.bar\\foo.bar", &wAttr ) ) ;
        assert( wAttr == _A_NORMAL ) ;


        // Test the HPFS drive
        assert( !lpLFNSetAttributes("H:\\test.att", _A_NORMAL ) ) ;
        assert( !lpLFNGetAttributes("H:\\test.att", &wAttr ) ) ;
        assert( wAttr == _A_NORMAL ) ;

        assert( !lpLFNSetAttributes("H:\\test.att", _A_RDONLY | _A_ARCH ) ) ;
        assert( !lpLFNGetAttributes("H:\\test.att", &wAttr ) ) ;
        assert( wAttr == _A_RDONLY | _A_ARCH ) ;

        assert( !lpLFNSetAttributes("H:\\test.att", _A_HIDDEN | _A_SYSTEM ) ) ;
        assert( !lpLFNGetAttributes("H:\\test.att", &wAttr ) ) ;
        assert( wAttr == _A_HIDDEN | _A_SYSTEM ) ;

        assert( !lpLFNSetAttributes("H:\\test.att", _A_NORMAL ) ) ;
        assert( !lpLFNGetAttributes("H:\\test.att", &wAttr ) ) ;
        assert( wAttr == _A_NORMAL ) ;

        // Test the FAT drive
        assert( !lpLFNSetAttributes("F:\\test.att", _A_NORMAL ) ) ;
        assert( !lpLFNGetAttributes("F:\\test.att", &wAttr ) ) ;
        assert( wAttr == _A_NORMAL ) ;

        assert( !lpLFNSetAttributes("F:\\test.att", _A_RDONLY | _A_ARCH ) ) ;
        assert( !lpLFNGetAttributes("F:\\test.att", &wAttr ) ) ;
        assert( wAttr == _A_RDONLY | _A_ARCH ) ;

        assert( !lpLFNSetAttributes("F:\\test.att", _A_HIDDEN | _A_SYSTEM ) ) ;
        assert( !lpLFNGetAttributes("F:\\test.att", &wAttr ) ) ;
        assert( wAttr == _A_HIDDEN | _A_SYSTEM ) ;

        assert( !lpLFNSetAttributes("F:\\test.att", _A_NORMAL ) ) ;
        assert( !lpLFNGetAttributes("F:\\test.att", &wAttr ) ) ;
        assert( wAttr == _A_NORMAL ) ;
    }

    //*******************************************************************
    // Test LFNParse 8.3 tests
    {
        char * psz83I1 = "C:\\ABC",
             * psz83I2 = "C:ABC",
             * psz83I3 = "\\ABC",
             * psz83I4 = ".\\ABC",
             * psz83I5 = "..\\ABC",

             * psz83I6 = "C:\\ABC\\DEF",
             * psz83I7 = "C:ABC\\DEF",
             * psz83I8 = "\\ABC\\DEF",
             * psz83I9 = ".\\ABC\\DEF",
             * psz83IA = "..\\ABC\\DEF",

             * psz83IB = "C:\\ABC\\DEF\\GHIJKLMN.OPQ",
             * psz83IC = "C:ABC\\DEF\\GHI.JKL",
             * psz83ID = "\\ABC\\DEF\\..",
             * psz83IE = ".\\ABC\\DEF\\..\\GHIJKLMN.OPQ",
             * psz83IF = "..\\ABC\\D.EF\\..\\.\\..\\GH.IJ",

             * psz83IG = "ABC",
             * psz83IH = "ABC\\DEFGHIJK",
             * psz83II = "ABC\D",
             * psz83IJ = "A\C",

             * psz83IK = "A.",
             * psz83IL = "A.EXE",
             * psz83IM = "X:\\.\\A.EXE",
             * psz83IN = "X:\\.\\A.",

             * psz83C1 = "C:\\ABC\\DEF\\GHIjKLMN.OPQ",
             * psz83C2 = "C:ABC\\DEF\\GHI.JKl",
             * psz83C3 = "\\ABC\\DEf\\..",
             * psz83C4 = ".\\ABC\\dEF\\..\\GhIJKLMN.OPQ",
             * psz83C5 = "..\\aBC\\DEF\\..\\.\\..\\GH",

             * pszLong1 = "C:\\ABCDEFGHI.JKL",
             * pszLong2 = "C:\\ABCD.HI.JKL",
             * pszLong3 = "C:\\ABCDE..JKL",
             * pszLong4 = "C:\\ABCDEF\\GHI\\ JKL",
             * pszLong5 = "\\ABCDE.123\\ABCDE.1234",
             * pszLong6 = ".AB\\CDE",

             *pszReg1   =  ".\\.\\.\\.\\.\\.\\.\\.\\.\\.\\.\\.\\.\\.\\.\\.\\ABC",
             *pszReg2   =  ".\\ABCjjHHHiiiasdfasdfJJZZZZZZ",
             *pszReg3   =  ".\\aBC",
             *pszReg4   =  ".\\ABC" ;

        assert( (*lpLFNParse)( pszReg1, NULL, NULL ) == FILE_83_CI ) ;
        //assert( (*lpLFNParse)( pszReg2  NULL, NULL ) == FILE_LONG  ) ;
        assert( (*lpLFNParse)( pszReg3, NULL, NULL ) == FILE_83_CS ) ;
        assert( (*lpLFNParse)( pszReg4, NULL, NULL ) == FILE_83_CI ) ;

        assert( (*lpLFNParse)( psz83I1, NULL, NULL ) == FILE_83_CI ) ;
        assert( (*lpLFNParse)( psz83I2, NULL, NULL ) == FILE_83_CI ) ;
        assert( (*lpLFNParse)( psz83I3, NULL, NULL ) == FILE_83_CI ) ;
        assert( (*lpLFNParse)( psz83I4, NULL, NULL ) == FILE_83_CI ) ;
        assert( (*lpLFNParse)( psz83I5, NULL, NULL ) == FILE_83_CI ) ;
        assert( (*lpLFNParse)( psz83I6, NULL, NULL ) == FILE_83_CI ) ;
        assert( (*lpLFNParse)( psz83I7, NULL, NULL ) == FILE_83_CI ) ;
        assert( (*lpLFNParse)( psz83I8, NULL, NULL ) == FILE_83_CI ) ;
        assert( (*lpLFNParse)( psz83I9, NULL, NULL ) == FILE_83_CI ) ;
        assert( (*lpLFNParse)( psz83IA, NULL, NULL ) == FILE_83_CI ) ;
        assert( (*lpLFNParse)( psz83IB, NULL, NULL ) == FILE_83_CI ) ;
        assert( (*lpLFNParse)( psz83IC, NULL, NULL ) == FILE_83_CI ) ;
        assert( (*lpLFNParse)( psz83ID, NULL, NULL ) == FILE_83_CI ) ;
        assert( (*lpLFNParse)( psz83IE, NULL, NULL ) == FILE_83_CI ) ;
        assert( (*lpLFNParse)( psz83IF, NULL, NULL ) == FILE_83_CI ) ;
        assert( (*lpLFNParse)( psz83IG, NULL, NULL ) == FILE_83_CI ) ;
        assert( (*lpLFNParse)( psz83IH, NULL, NULL ) == FILE_83_CI ) ;
        assert( (*lpLFNParse)( psz83II, NULL, NULL ) == FILE_83_CI ) ;
        assert( (*lpLFNParse)( psz83IJ, NULL, NULL ) == FILE_83_CI ) ;
        assert( (*lpLFNParse)( psz83IK, NULL, NULL ) == FILE_83_CI ) ;
        assert( (*lpLFNParse)( psz83IL, NULL, NULL ) == FILE_83_CI ) ;
        assert( (*lpLFNParse)( psz83IM, NULL, NULL ) == FILE_83_CI ) ;
        assert( (*lpLFNParse)( psz83IN, NULL, NULL ) == FILE_83_CI ) ;

        assert( (*lpLFNParse)( psz83C1, NULL, NULL ) == FILE_83_CS ) ;
        assert( (*lpLFNParse)( psz83C2, NULL, NULL ) == FILE_83_CS ) ;
        assert( (*lpLFNParse)( psz83C3, NULL, NULL ) == FILE_83_CS ) ;
        assert( (*lpLFNParse)( psz83C4, NULL, NULL ) == FILE_83_CS ) ;
        assert( (*lpLFNParse)( psz83C5, NULL, NULL ) == FILE_83_CS ) ;

        assert( (*lpLFNParse)( pszLong1, NULL, NULL ) == FILE_LONG ) ;
        assert( (*lpLFNParse)( pszLong2, NULL, NULL ) == FILE_LONG ) ;
        assert( (*lpLFNParse)( pszLong3, NULL, NULL ) == FILE_LONG ) ;
        assert( (*lpLFNParse)( pszLong4, NULL, NULL ) == FILE_LONG ) ;
        assert( (*lpLFNParse)( pszLong5, NULL, NULL ) == FILE_LONG ) ;
        assert( (*lpLFNParse)( pszLong6, NULL, NULL ) == FILE_LONG ) ;
    }



#ifdef NEVER
    //*******************************************************************
    // Test LFNFindFirst, LFNFindNext & LFNFindClose
    {
        FILEFINDBUF2 *    pFind;
        FILEFINDBUF2      buf ;
        static char       outst[256];
        unsigned          err, hdir, entries ;

        entries = 1 ;

        pFind = &buf ;
        err = lpLFNFindFirst("H:\\*.*", 0, &entries, &hdir, sizeof(buf), &buf);
        if ( err )
        {
            sprintf(outst, "Error %d from FindFirst (Ret buff = \"%s\")", err, &buf ) ;
            MessageBox( NULL, outst, "LFN Test Suite", MB_OK ) ;
        }
        else
        {
            sprintf(outst, "Attr = 0x%x, Size = %lu, Name = %s",
                                             pFind->attrFile, pFind->cbFile,
                                             pFind->achName ) ;
            MessageBox( NULL, outst, "LFN Test Suite", MB_OK ) ;
        }

        if ( IDOK == MessageBox( NULL, "LFNFindNext...", "LFN Test Suite", MB_OKCANCEL ) )
        {
            while ( !err )
            {
                err = lpLFNFindNext(hdir, &entries, sizeof(buf), &buf);
                if ( err )
                {
                    sprintf(outst, "Error %d from FindNext (Ret buff = \"%s\")", err, &buf ) ;
                    MessageBox( NULL, outst, "LFN Test Suite", MB_OK ) ;
                }
                else
                {
                    sprintf(outst, "Attr = 0x%x, Size = %lu, Name = %s",
                                                     pFind->attrFile, pFind->cbFile,
                                                     pFind->achName) ;
                    if ( IDOK != MessageBox( NULL, outst, "LFN Test Suite", MB_OKCANCEL ) )
                        break ;
                }
            }
        }
        lpLFNFindClose( hdir ) ;
    }
#endif //NEVER

    //*******************************************************************
    // Test Mkdir/Rmdir
    {
        // Make valid dirs on HPFS partition
        assert( !lpLFNMkDir("H:\\LFNTESTDIR.LONG.NAME" ) ) ;
        assert( !lpLFNMkDir("H:\\LFNTESTDIR.LONG.NAME\\LEVEL2" ) ) ;
        assert( !lpLFNMkDir("H:\\LFNTESTDIR.LONG.NAME\\LEVEL2\\LONGLEVEL3.....A" ) ) ;
        MessageBox(NULL, "Directories made on H:", "LFN Test Suite", MB_OK ) ;
        assert( !lpLFNRmDir("H:\\LFNTESTDIR.LONG.NAME\\LEVEL2\\LONGLEVEL3.....A" ) ) ;
        assert( !lpLFNRmDir("H:\\LFNTESTDIR.LONG.NAME\\LEVEL2" ) ) ;
        assert( !lpLFNRmDir("H:\\LFNTESTDIR.LONG.NAME" ) ) ;

        // Make invalid dirs on fat partition
        assert( lpLFNMkDir("F:\\LFNTESTDIR.LONG.NAME" ) ) ;
        MessageBox(NULL, "Attempted to make long Directories on F:", "LFN Test Suite", MB_OK ) ;
        assert( lpLFNRmDir("F:\\LFNTESTDIR.LONG.NAME" ) ) ;

        // Make valid dirs on FAT partition
        assert( !lpLFNMkDir("F:\\LFNTEST.NAM" ) ) ;
        assert( !lpLFNMkDir("F:\\LFNTEST.NAM\\LEVEL2" ) ) ;
        MessageBox(NULL, "Directories made on F:", "LFN Test Suite", MB_OK ) ;
        assert( !lpLFNRmDir("F:\\LFNTEST.NAM\\LEVEL2" ) ) ;
        assert( !lpLFNRmDir("F:\\LFNTEST.NAM" ) ) ;

    }

    MessageBox( NULL, "Done", "LFN Test Suite", MB_OK ) ;

    return 0 ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\shellui\h\errornum.h ===
/*****************************************************************/
/**                  Microsoft Windows NT                       **/
/**            Copyright(c) Microsoft Corp., 1989-1990          **/
/*****************************************************************/

/*
 *      Windows/Network Interface
 */

/*
 *	History:
 *	    chuckc	12-Dec-1991	split off from winlocal, uses uimsg.h
 */

#ifndef _ERRORNUM_H_
#define _ERRORNUM_H_

#include <uimsg.h>

/*
 *  READ THIS!!!
 *
 *  NOTE: Due to limitations in the resource compiler, the message numbers
 *  are hard coded in the file msg2help.tbl.  Any changes to the message
 *  numbers should also be changed in the msg2help.tbl file.
 */

/*
 *  Error messages in this range may be returned to Windows, via
 *  WNetGetErrorText.
 */
#define IDS_UI_SHELL_EXPORTED_BASE	(IDS_UI_SHELL_BASE+0)
#define IDS_UI_SHELL_EXPORTED_LAST	(IDS_UI_SHELL_BASE+99)


/*
 *  Error messages in this range are general Winnet messages
 */
#define IDS_UI_SHELL_GEN_BASE		(IDS_UI_SHELL_BASE+100)
#define IDS_UI_SHELL_GEN_LAST		(IDS_UI_SHELL_BASE+299)

/*
 *  Error messages in this range are BROWSING related messages
 */
#define IDS_UI_SHELL_BROW_BASE		(IDS_UI_SHELL_BASE+300)
#define IDS_UI_SHELL_BROW_LAST		(IDS_UI_SHELL_BASE+399)

/*
 *  Error messages in this range are password related messages
 */
#define IDS_UI_SHELL_PASS_BASE		(IDS_UI_SHELL_BASE+400)
#define IDS_UI_SHELL_PASS_LAST		(IDS_UI_SHELL_BASE+499)

/*
 *  Error messages in this range are share related messages
 */
#define IDS_UI_SHELL_SHR_BASE		(IDS_UI_SHELL_BASE+500)
#define IDS_UI_SHELL_SHR_LAST		(IDS_UI_SHELL_BASE+599)

/*
 *  Error messages in this range are openfile related messages
 */
#define IDS_UI_SHELL_OPEN_BASE		(IDS_UI_SHELL_BASE+600)
#define IDS_UI_SHELL_OPEN_LAST		(IDS_UI_SHELL_BASE+619)

/*
 *  Error messages in this range are PERM related messages
 */
#define IDS_UI_SHELL_PERM_BASE		(IDS_UI_SHELL_BASE+620)
#define IDS_UI_SHELL_PERM_LAST		(IDS_UI_SHELL_BASE+799)


/********************* Messages Proper ************************/

/*
 * exported messages
 */
#define IERR_MustBeLoggedOnToConnect    (IDS_UI_SHELL_EXPORTED_BASE+0)
#define IERR_MustBeLoggedOnToDisconnect (IDS_UI_SHELL_EXPORTED_BASE+1)
#define IERR_CannotOpenPrtJobFile	(IDS_UI_SHELL_EXPORTED_BASE+2)
#define IERR_ConnectDlgNoDevices	(IDS_UI_SHELL_EXPORTED_BASE+3)

/*
 * general messages
 */
#define IDS_SHELLHELPFILENAME           (IDS_UI_SHELL_GEN_BASE+1)
#define IDS_SMHELPFILENAME              (IDS_UI_SHELL_GEN_BASE+2)
#define IDS_CREDHELPFILENAME            (IDS_UI_SHELL_GEN_BASE+3)

#ifndef WIN32
#define IERR_PWNoUser                   (IDS_UI_SHELL_GEN_BASE+9)
#define IERR_PWNoDomainOrServer         (IDS_UI_SHELL_GEN_BASE+10)
#endif

#define IERR_FullAPISupportNotLoaded    (IDS_UI_SHELL_GEN_BASE+19)
#define IERR_IncorrectNetwork           (IDS_UI_SHELL_GEN_BASE+20)
#define IERR_InvalidDomainName          (IDS_UI_SHELL_GEN_BASE+22)

#define IDS_LMMsgBoxTitle		(IDS_UI_SHELL_GEN_BASE+23)

#define IERR_UnrecognizedNetworkError   (IDS_UI_SHELL_GEN_BASE+30)
#define IERR_NotLoggedOn                (IDS_UI_SHELL_GEN_BASE+32)
#define IERR_USER_CLICKED_CANCEL        (IDS_UI_SHELL_GEN_BASE+34)

#define IERR_CannotConnect              (IDS_UI_SHELL_GEN_BASE+40)

/*      The following 2 errors are defined for LM 2.1 */
#define IERR_HigherLMVersion            (IDS_UI_SHELL_GEN_BASE+50)
#define IERR_LowerLMVersion             (IDS_UI_SHELL_GEN_BASE+51)

/* The following errors are for LOGON */
#define IERR_LogonBadUsername           (IDS_UI_SHELL_GEN_BASE+53)
#define IERR_LogonBadDomainName         (IDS_UI_SHELL_GEN_BASE+54)
#define IERR_LogonBadPassword           (IDS_UI_SHELL_GEN_BASE+55)
#define IERR_LogonSuccess		(IDS_UI_SHELL_GEN_BASE+56)
#define IERR_LogonStandalone		(IDS_UI_SHELL_GEN_BASE+57)
#define IERR_LogonFailure		(IDS_UI_SHELL_GEN_BASE+58)

/* CODEWORK - these should be IDS_ */

#define PRIV_STRING_GUEST		(IDS_UI_SHELL_GEN_BASE+75)

#define IDS_UnknownWorkgroup            (IDS_UI_SHELL_GEN_BASE+76)

#ifndef WIN32
#define IERR_PasswordNoMatch		(IDS_UI_SHELL_GEN_BASE+80)
#define IERR_PasswordOldInvalid		(IDS_UI_SHELL_GEN_BASE+81)
#define IERR_PasswordTooRecent_Domain	(IDS_UI_SHELL_GEN_BASE+82)
#define IERR_PasswordTooRecent_Server	(IDS_UI_SHELL_GEN_BASE+83)
#define IERR_PasswordHistConflict	(IDS_UI_SHELL_GEN_BASE+84)
#define IERR_PasswordNewInvalid		(IDS_UI_SHELL_GEN_BASE+85)
#define IERR_PasswordTooShort		(IDS_UI_SHELL_GEN_BASE+86)
#endif
#define IERR_CannotConnectAlias         (IDS_UI_SHELL_GEN_BASE+92)
#define IERR_ReplaceUnavailQuery	(IDS_UI_SHELL_GEN_BASE+93)

#define IERR_DisconnectNoRemoteDrives	(IDS_UI_SHELL_GEN_BASE+94)

#define IDS_LogonDialogCaptionFromApp	(IDS_UI_SHELL_GEN_BASE+96)

#define IERR_BadTransactConfig		(IDS_UI_SHELL_GEN_BASE+97)
#define IERR_BAD_NET_NAME		(IDS_UI_SHELL_GEN_BASE+98)
#define IERR_NOT_SUPPORTED		(IDS_UI_SHELL_GEN_BASE+99)


/*	The following manifests are for the Browse, Connect, and Connection
 *	dialogs.  They are used in file\browdlg.cxx.
 *	The IDSOFFSET_BROW_COUNT value indicates how many offset values
 *	there are.
 *	The BASE values in combination with the OFFSET values form a matrix
 *	of strings.
 */
#define IDSOFFSET_BROW_CAPTION_CONNECT	0
#define IDSOFFSET_BROW_CAPTION_CONNS	1
#define IDSOFFSET_BROW_CAPTION_BROW	2
#define IDSOFFSET_BROW_SHOW_TEXT	3
#define IDSOFFSET_BROW_IN_DOMAIN	4
#define IDSOFFSET_BROW_ON_SERVER	5
#define IDSOFFSET_BROW_DEVICE_TEXT	6
#define IDSOFFSET_BROW_CURRENT_CONNS	7
#define IDSOFFSET_BROW_COUNT		8
#define IDSBASE_BROW_RES_TEXT_FILE	IDS_UI_SHELL_BROW_BASE
#define IDSBASE_BROW_RES_TEXT_PRINT	(IDSBASE_BROW_RES_TEXT_FILE + IDSOFFSET_BROW_COUNT)
#define IDSBASE_BROW_RES_TEXT_COMM	(IDSBASE_BROW_RES_TEXT_PRINT + IDSOFFSET_BROW_COUNT)


/*	The following manifests are for the Password Change and Password
 *	Expiry dialogs.  Each pair of strings contains the messages for
 *	the first and second static text strings under these situations:
 *	EXPIRED:  Password has already expired
 *	EXPIRES_SOON:  Password will expire in one or more days
 *	EXPIRES_TODAY:  Password will expire in less than 24 hours
 *
 *	They should all be processed with the following
 *	insertion strings:
 *	Insertion String 0:  Name of server/domain
 *	Insertion String 1:  Number of days until expiry (as text)
 */

#define IDS_PASSWORD_EXPIRED		IDS_UI_SHELL_PASS_BASE
#define IDS_PASSWORD_EXPIRED_0		(IDS_PASSWORD_EXPIRED + 0)
#define IDS_PASSWORD_EXPIRED_1		(IDS_PASSWORD_EXPIRED + 1)

#define IDS_PASSWORD_EXPIRES_SOON	(IDS_PASSWORD_EXPIRED + 2)
#define IDS_PASSWORD_EXPIRES_SOON_0	(IDS_PASSWORD_EXPIRES_SOON + 0)
#define IDS_PASSWORD_EXPIRES_SOON_1	(IDS_PASSWORD_EXPIRES_SOON + 1)

#define IDS_PASSWORD_EXPIRES_TODAY	(IDS_PASSWORD_EXPIRES_SOON + 2)
#define IDS_PASSWORD_EXPIRES_TODAY_0	(IDS_PASSWORD_EXPIRES_TODAY + 0)
#define IDS_PASSWORD_EXPIRES_TODAY_1	(IDS_PASSWORD_EXPIRES_TODAY + 1)

// #define IDSBASE_PRINTMAN		IDS_UI_SHELL_PASS_BASE+20

#define IDS_CREDENTIALS_CAPTION         (IDS_UI_SHELL_PASS_BASE+40)
#define IDS_CREDENTIALS_MESSAGE         (IDS_UI_SHELL_PASS_BASE+41)

/*	Note.  The following string ID is the first one not used.  If
 *	you add any more strings, use this number as your first number, and
 *	then update IDS_FirstValueThatIsNotUsed.
 */
// #define IDS_FirstValueThatIsNotUsed	(IDSBASE_PRINTMAN + 20)


#endif

/* Not used any more.
#define IERR_MessageNoText              (IDS_UI_SHELL_GEN_BASE+3)
#define IERR_MessageRetry               (IDS_UI_SHELL_GEN_BASE+4)
#define IERR_MessageNoUser              (IDS_UI_SHELL_GEN_BASE+5)
#define IERR_LogoffQuery                (IDS_UI_SHELL_GEN_BASE+6)
#define IERR_LogoffQueryOpenFiles       (IDS_UI_SHELL_GEN_BASE+7)
#define IERR_NoServers                  (IDS_UI_SHELL_GEN_BASE+8)
#define IDS_DMNoUser                    (IDS_UI_SHELL_GEN_BASE+11)
#define IDS_DomainText                  (IDS_UI_SHELL_GEN_BASE+12)
#define IDS_BrowseCaptionAll            (IDS_UI_SHELL_GEN_BASE+13)
#define IDS_BrowseCaptionDisk           (IDS_UI_SHELL_GEN_BASE+14)
#define IDS_BrowseCaptionPrint          (IDS_UI_SHELL_GEN_BASE+15)
#define IDS_BrowseShareText             (IDS_UI_SHELL_GEN_BASE+16)
#define IDS_VersionText                 (IDS_UI_SHELL_GEN_BASE+17)
#define IERR_NetworkNotStarted          (IDS_UI_SHELL_GEN_BASE+18)
#define IERR_NoSupportForRealMode       (IDS_UI_SHELL_GEN_BASE+21)
#define IERR_CannotDisplayUserInfo      (IDS_UI_SHELL_GEN_BASE+31)
#define IERR_BadSharePassword		(IDS_UI_SHELL_GEN_BASE+33)
#define IERR_CannotInitMsgPopup         (IDS_UI_SHELL_GEN_BASE+52)
#define IERR_ProfileChangeError         (IDS_UI_SHELL_GEN_BASE+60)
#define IERR_ProfileLoadError		(IDS_UI_SHELL_GEN_BASE+61)
#define IERR_ProfileLoadErrorWithCancel (IDS_UI_SHELL_GEN_BASE+62)
#define IERR_ProfileAlreadyAssigned     (IDS_UI_SHELL_GEN_BASE+65)
#define IERR_ProfileFileRead		(IDS_UI_SHELL_GEN_BASE+66)
#define	FMT_NET_error			(IDS_UI_SHELL_GEN_BASE+72)
#define	FMT_SYS_error			(IDS_UI_SHELL_GEN_BASE+73)
#define	FMT_other_error			(IDS_UI_SHELL_GEN_BASE+74)
#define PRIV_STRING_USER		(IDS_UI_SHELL_GEN_BASE+76)
#define PRIV_STRING_ADMIN		(IDS_UI_SHELL_GEN_BASE+77)
#define IERR_DelUnavailQuery		(IDS_UI_SHELL_GEN_BASE+87)
#define IERR_DelUseOpenFilesQuery	(IDS_UI_SHELL_GEN_BASE+88)
#define IDS_DevicePromptDrive		(IDS_UI_SHELL_GEN_BASE+90)
#define IDS_DevicePromptDevice		(IDS_UI_SHELL_GEN_BASE+91)
#define IERR_OutOfStructures		(IDS_UI_SHELL_GEN_BASE+95)
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\shell\test\apptestb.cxx ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1987-1990          **/
/********************************************************************/

/*
 *  FILE STATUS:
 *  12/06/90  Created
 *  01/02/91  renamed to just test1
 *  1/12/91  Split from Logon App, reduced to just Shell Test APP
 */

/****************************************************************************

    PROGRAM: test11.cxx

    PURPOSE: Test module to test I_ChangePassword

    FUNCTIONS:

	test11()

    COMMENTS:

****************************************************************************/


#ifdef CODESPEC
/*START CODESPEC*/

/********
TESTb.CXX
********/

/************
end TESTb.CXX
************/
/*END CODESPEC*/
#endif // CODESPEC



#include "apptest.hxx"


/****************************************************************************

    FUNCTION: test11()

    PURPOSE: test WNetRestoreConnection

    COMMENTS:

****************************************************************************/

void test11(HWND hwndParent)
{
    BOOL fOK;
    TCHAR pszName[100];
    TCHAR pszMessage[200];
    MessageBox(hwndParent,SZ("Welcome to sunny test11"),SZ("Test"),MB_OK);
    if ( I_SystemFocusDialog(hwndParent, FOCUSDLG_SERVERS_ONLY,
			     pszName,
			     sizeof(pszName),
			     &fOK) )
    {
	MessageBox( hwndParent, SZ("An error was returned from the dialog"),
		    SZ("Test"), MB_OK) ;
	return ;
    }

    if (!fOK)
    {
	MessageBox(hwndParent,SZ("User Hit cancel!"),SZ("Test"),MB_OK);
    }
    else
    {
	wsprintf(pszMessage,"The name is: %s", pszName );
	MessageBox(hwndParent,pszMessage,SZ("Test"),MB_OK);
    }
    MessageBox(hwndParent,SZ("Thanks for visiting test11 -- please come again!"),SZ("Test"),MB_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\shell\util\miscapis.cxx ===
/*****************************************************************/
/**                  Microsoft LAN Manager                      **/
/**            Copyright(c) Microsoft Corp., 1990               **/
/*****************************************************************/


/*
    MiscAPIs.cxx
    Miscallaneous APIs


    FILE HISTORY:

    jonn        14-Jan-1991     Split from winprof.cxx
    jonn        17-Jan-1991     Split off lm21util.cxx, lm30spfc.cxx
    jonn        02-Feb-1991     Removed unused routines
    rustanl     12-Apr-1991     Added UI_UNCPathCompare and
                                UI_UNCPathValidate
    beng        17-May-1991     Correct lmui.hxx usage
    jonn        22-May-1991     Added MyNetUseAdd (was in winprof.cxx)
    rustanl     24-May-1991     Added AUTO_CURSOR to MyNetUseAdd
    terryk      31-Oct-1991     add mnet.h and change I_NetXXX to
                                I_MNetXXX
    Yi-HsinS    31-Dec-1991     Unicode work
    terryk  10-Oct-1993 deleted MyNetUseAdd

*/



#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_DOSERRORS
#define INCL_NETERRORS
#define INCL_NETCONS
#define INCL_NETACCESS
#define INCL_NETSERVER
#define INCL_NETWKSTA
#define INCL_NETSERVICE
#define INCL_NETLIB
#define INCL_ICANON
#define INCL_NETUSE // for NetUseAdd
#define _WINNETWK_
#include <lmui.hxx>
#undef _WINNETWK_

extern "C"
{
    #include <mnet.h>
    #include <winnetwk.h>
    #include <npapi.h>
    #include <lmsname.h>
}

#include <uiassert.hxx>
#include <uitrace.hxx>
#include <string.hxx>
#include <lmowks.hxx>
#include <lmodom.hxx>
#include <lmodev.hxx> // for DEVICE object
#include <uibuffer.hxx>
#include <strchlit.hxx>  // for string and character literals
#include <lmsvc.hxx>
#include <miscapis.hxx>



/* Local prototypes */


/* functions */

/*******************************************************************

    NAME:       CheckLMService

    SYNOPSIS:   Checks to make sure the LM Wksta service is willing to
                accept requests.

    RETURNS:    NERR_Success if the service is happy happy
                WN_NO_NETWORK if the service is stopped or stopping
                WN_FUNCTION_BUSY if the service is starting
                Other error if an error occurred getting the status

    NOTES:

    HISTORY:
        Johnl   09-Sep-1992     Created

********************************************************************/

APIERR CheckLMService( void )
{

    APIERR err = NERR_Success ;

    //
    // we almost always hit the wksta soon after this call & the wksta
    // is usually started. so this check will avoid paging in the service
    // controller. it just ends up paging in the wksta a bit earlier.
    // only if the call fails do we hit the service controller for the
    // actual status.
    //
    WKSTA_10 wksta_10 ;

    if ( (wksta_10.QueryError() == NERR_Success) &&
         (wksta_10.GetInfo() == NERR_Success) )
    {
        return NERR_Success ;
    }

    LM_SERVICE service( NULL, (const TCHAR *)SERVICE_WORKSTATION );
    if ( err = service.QueryError() )
    {
        return err ;
    }

    switch ( service.QueryStatus( &err ) )
    {
    case LM_SVC_STOPPED:
    case LM_SVC_STOPPING:
        if ( !err )
            err = WN_NO_NETWORK ;
        TRACEEOL("::CheckLMService - Returning WN_NO_NETWORK") ;
        break ;

    case LM_SVC_STARTING:
        if ( !err )
            err = WN_FUNCTION_BUSY ;
        TRACEEOL("::CheckLMService - Returning WN_FUNCTION_BUSY") ;
        break ;

    case LM_SVC_STATUS_UNKNOWN:
    case LM_SVC_STARTED:
    case LM_SVC_PAUSED:
    case LM_SVC_PAUSING:
    case LM_SVC_CONTINUING:
    default:
        /* Return unadultered error code
         */
        break ;
    }

    return err ;
}


/*******************************************************************

    NAME:       ParseRemoteName

    SYNOPSIS:   Canonicalizes a remote resource name and determines
        its type

    ARGUMENTS:
        RemoteName - Remote resource name to be parsed
        CanonName - Buffer for canonicalized name, assumed to be
            MAX_PATH characters long
        CanonNameSize - Size, in bytes, of output buffer
        PathStart - Set to the offset, in characters, of the start
            of the "\share" portion (in the REMOTENAMETYPE_SHARE case)
            or the "\path" portion (in the REMOTENAMETYPE_PATH case)
            of the name within CanonName.  Not set in other cases.

    RETURNS:
        If nlsRemote is like    Then returns
        --------------------    ------------
        workgroup               REMOTENAMETYPE_WORKGROUP
        \\server                REMOTENAMETYPE_SERVER
        \\server\share          REMOTENAMETYPE_SHARE
        \\server\share\path     REMOTENAMETYPE_PATH
        (other)                 REMOTENAMETYPE_INVALID

    NOTES:

    HISTORY:
      AnirudhS  21-Apr-1995 Ported from Win95 sources - used netlib
        functions rather than ad hoc parsing, introduced comments

********************************************************************/

REMOTENAMETYPE ParseRemoteName(
    IN  LPWSTR  RemoteName,
    OUT LPWSTR  CanonName,
    IN  DWORD   CanonNameSize,
    OUT PULONG  PathStart
    )
{
    //
    // Determine the path type
    //
    DWORD PathType = 0;
    NET_API_STATUS Status = I_NetPathType(NULL, RemoteName, &PathType, 0);

    if (Status != NERR_Success)
    {
        return REMOTENAMETYPE_INVALID;
    }

    //
    // I_NetPathType doesn't give us quite as fine a classification of
    // path types as we need, so we still need to do a little more parsing
    //
    switch (PathType)
    {
    case ITYPE_PATH_RELND:
        //
        // A driveless relative path
        // A valid workgroup or domain name would be classified as
        // such, but it still needs to be validated as a workgroup name
        //
        Status = I_NetNameCanonicalize(
                            NULL,               // ServerName
                            RemoteName,         // Name
                            CanonName,          // Outbuf
                            CanonNameSize,      // OutbufLen
                            NAMETYPE_WORKGROUP, // NameType
                            0                   // Flags
                            );

        if (Status == NERR_Success)
        {
            return REMOTENAMETYPE_WORKGROUP;
        }
        else
        {
            return REMOTENAMETYPE_INVALID;
        }

    case ITYPE_UNC_COMPNAME:
        //
        // A UNC computername, "\\server"
        //
        {
            //
            // HACK: I_NetPathCanonicalize likes "\\server\share" but not
            // "\\server", so append a dummy share name to canonicalize.
            // We assume that the CanonName buffer will still be big
            // enough (which it will, in the calls made from this file).
            //
            if (wcslen(RemoteName) + 3 > NNLEN)
            {
                return REMOTENAMETYPE_INVALID;
            }
            WCHAR wszDummy[NNLEN];
            wcscpy(wszDummy, RemoteName);
            wcscat(wszDummy, L"\\a");

            UIASSERT(CanonNameSize >= sizeof(wszDummy));
            PathType = ITYPE_UNC;
            Status = I_NetPathCanonicalize(
                                    NULL,           // ServerName
                                    wszDummy,       // PathName
                                    CanonName,      // Outbuf
                                    CanonNameSize,  // OutbufLen
                                    NULL,           // Prefix
                                    &PathType,      // PathType
                                    0               // Flags
                                    );
        }

        if (Status != NERR_Success)
        {
            return REMOTENAMETYPE_INVALID;
        }

        CanonName[ wcslen(CanonName) - 2 ] = 0;

        return REMOTENAMETYPE_SERVER;

    case ITYPE_UNC:
        //
        // A UNC path, either "\\server\share" or "\\server\share\path" -
        // canonicalize and determine which one
        //
        Status = I_NetPathCanonicalize(
                                    NULL,           // ServerName
                                    RemoteName,     // PathName
                                    CanonName,      // Outbuf
                                    CanonNameSize,  // OutbufLen
                                    NULL,           // Prefix
                                    &PathType,      // PathType
                                    0               // Flags
                                    );
        if (Status != NERR_Success)
        {
            return REMOTENAMETYPE_INVALID;
        }

        {
            WCHAR * pSlash = wcschr(CanonName+2, PATH_SEPARATOR);
            UIASSERT(pSlash);
            *PathStart = (ULONG)(pSlash - CanonName);

            // Look for a fourth slash
            pSlash = wcschr(pSlash+1, PATH_SEPARATOR);
            if (pSlash)
            {
                *PathStart = (ULONG)(pSlash - CanonName);
                return REMOTENAMETYPE_PATH;
            }
            else
            {
                return REMOTENAMETYPE_SHARE;
            }
        }

    default:
        return REMOTENAMETYPE_INVALID;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\shellui\file\opens.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**             Copyright(c) Microsoft Corp., 1991                   **/
/**********************************************************************/

/*
    openfiles.cxx
        Open Files Dialog

    FILE HISTORY:
        chuckc     30-Sep-1991     Created
        Yi-HsinS   31-Dec-1991     Unicode Work

*/

#define INCL_WINDOWS_GDI
#define INCL_WINDOWS
#define INCL_DOSERRORS
#define INCL_NETERRORS
#define INCL_NETCONS
#define INCL_NETLIB
#define INCL_NETFILE
#define INCL_NETSERVER
#define _WINNETWK_
#include <lmui.hxx>
#undef _WINNETWK_

extern "C"
{
    #include <helpnums.h>
    #include <opens.h>
    #include <winlocal.h>
}

#define INCL_BLT_WINDOW
#define INCL_BLT_CONTROL
#define INCL_BLT_DIALOG
#define INCL_BLT_MSGPOPUP
#define INCL_BLT_MISC
#include <blt.hxx>
#include <string.hxx>
#include <uibuffer.hxx>
#include <uitrace.hxx>

#include <strnumer.hxx>

#include <netname.hxx>
#include <aprompt.hxx>
#include <opens.hxx>


/*******************************************************************

    NAME:       DisplayOpenFiles

    SYNOPSIS:   This internal function is called when the user hits
                the Open Files button from the properties dialog.

    ENTRY:      hwndParent - Handle to parent window
                wSelectType - What type of selection the user has in the
                        File manager.
                pszResourceName - Name of the resource we are trying to edit
                        (should be fully qualified).
    EXIT:

    RETURNS:    NERR_Success if successful, appropriate error code otherwise
                (we will display any errors that occur).

    NOTES:

    HISTORY:
        Chuckc  30-Sep-1991     Created

********************************************************************/

APIERR DisplayOpenFiles( HWND hwndParent,
                         WORD wSelectType,
                         const TCHAR * pszResourceName )
{
    APIERR err ;

    BOOL fNT = TRUE ;
    NLS_STR nlsServer ;
    NLS_STR nlsLocalPath ;
    SERVER_WITH_PASSWORD_PROMPT *pServerWithPrompt = NULL ;

    // wSelectType is currently not used.
    UNREFERENCED(wSelectType) ;

    DBGEOL( "#" << pszResourceName << "#" );

    TCHAR *p = ::strrchrf(pszResourceName,TCH(' ')) ;
    if (p)
        *p = TCH('\0') ;

    // create a NET_NAME object to analize the name
    NET_NAME netName(pszResourceName) ;
    err = netName.QueryError() ;

    // is it local?
    BOOL fIsLocal ;
    if (err == NERR_Success)
        fIsLocal = netName.IsLocal(&err) ;

    // better error mapping if device is something we cannot deal with
    if (err==NERR_InvalidDevice)
        err = ERROR_NOT_SUPPORTED ;   

    // get server name
    if (err == NERR_Success)
        err = netName.QueryComputerName(&nlsServer) ;
    if (err == NERR_Success)
        err = nlsServer.QueryError() ;

    // check if is NT server. at same time, prompt for passwd if need
    if (err == NERR_Success)
    {
        pServerWithPrompt =
            new SERVER_WITH_PASSWORD_PROMPT (nlsServer.QueryPch(),
                                             hwndParent,
					     HC_UI_SHELL_BASE );
        err = (pServerWithPrompt == NULL) ?
            ERROR_NOT_ENOUGH_MEMORY :
            pServerWithPrompt->QueryError() ;
        if (err == NERR_Success)
        {
            if ( !(err = pServerWithPrompt->GetInfo()) )
                fNT = pServerWithPrompt->IsNT() ;
            else
            {
                if (err == ERROR_INVALID_LEVEL)
	            err = ERROR_NOT_SUPPORTED ;
                else if (err == IERR_USER_CLICKED_CANCEL) 
                    // if user cancelled, we carry on as far as we can
	            err = NERR_Success ;
            }
        }
    }

    // get local name
    if (err == NERR_Success)
        err = netName.QueryLocalPath(&nlsLocalPath) ;
    if (err == NERR_Success)
        err = nlsLocalPath.QueryError() ;

    // if we fail at any point above, bag out here
    if (err != NERR_Success)
    {
        delete pServerWithPrompt ;
        MsgPopup(hwndParent, err);
        return(err) ;
    }

    // if local drive and not on NT, barf!
    if (fIsLocal && !fNT)
    {
        delete pServerWithPrompt ;
        MsgPopup(hwndParent, IDS_NOT_SHAREABLE);
        return(NERR_Success) ;
    }

    // we know path passed in must be x:\foo, so lets just make sure
    UIASSERT (nlsServer.strlen() > 0) ;
    UIASSERT (nlsLocalPath.strlen() > 0) ;


    // create dialog
    OPENFILES_DIALOG *pOpenFiles = new OPENFILES_DIALOG (hwndParent,
                                                pszResourceName,
                                                nlsServer.QueryPch(),
                                                nlsLocalPath.QueryPch()) ;

    if (pOpenFiles == NULL)
        err = ERROR_NOT_ENOUGH_MEMORY ;

    if (err == NERR_Success)
            err = pOpenFiles->QueryError() ;

    if (err == NERR_Success)
            err = pOpenFiles->Process() ;

    if (err != NERR_Success)
        MsgPopup(hwndParent, err) ;

    delete pServerWithPrompt ;
    delete pOpenFiles ;
    return(err) ;
}

/*******************************************************************

    NAME:       OPENFILES_DIALOG::OPENFILES_DIALOG

    SYNOPSIS:   constructor for open files dialog

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
        chuckc  30-Sep-1991     created

********************************************************************/
OPENFILES_DIALOG::OPENFILES_DIALOG ( HWND hDlg,
                                     const TCHAR *pszFile,
                                     const TCHAR *pszServer,
                                     const TCHAR *pszBasePath)
    : OPEN_DIALOG_BASE( hDlg,
                       OPENFILES_DLG,
                       IDD_OF_OPENCOUNT,
                       IDD_OF_LOCKCOUNT,
                       IDD_OF_CLOSE,
                       IDD_OF_CLOSEALL,
                       pszServer,
                       pszBasePath,
                       &_lbFiles),
    _slePath(this,IDD_OF_PATH),
    _lbFiles( this, IDD_OF_LBOX, pszServer, pszBasePath )
{
    // usual check for OK-ness
    if (QueryError() != NERR_Success)
        return ;

    // set the path in the read only SLE.
    _slePath.SetText(pszFile) ;

    // set the rest of the info
    Refresh() ;

    // put focus in listbox if anything there, else on OK button
    if (_lbFiles.QueryCount() > 0)
        _lbFiles.ClaimFocus() ;
    else
        SetFocus(IDOK) ;
}

/*******************************************************************

    NAME:       QueryHelpContext

    SYNOPSIS:   The usual query method for finding out the help context.

    RETURNS:    Help Context

    NOTES:

    HISTORY:
        Chuckc  30-Sep-1991     Created

********************************************************************/

ULONG OPENFILES_DIALOG::QueryHelpContext ( void )
{
    return HC_OPENFILES;
}

/*******************************************************************

    NAME:       OPENFILES_LBI::Paint

    SYNOPSIS:   standard paint method for the OpenFiles LBI

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
        chuckc  30-Sep-1991     stolen from server manager, hierarchicalized
                                and converted to use QueryColumnWidths
        beng    22-Apr-1992     Change to LBI::Paint

********************************************************************/

VOID OPENFILES_LBI :: Paint( LISTBOX *plb,
                             HDC          hdc,
                             const RECT  *prect,
                             GUILTT_INFO *pGUILTT ) const
{
    STR_DTE dteUserName( _nlsUserName.QueryPch() );
    STR_DTE dteAccess( _nlsAccess.QueryPch() );
    STR_DTE dteLocks( _nlsLocks.QueryPch() );
    STR_DTE dteFileID( _nlsID.QueryPch() ) ;

    DISPLAY_TABLE dtab( 4, ((OPENFILES_LBOX *)plb)->QueryColumnWidths() );

    dtab[0] = &dteUserName;
    dtab[1] = &dteAccess;
    dtab[2] = &dteLocks;
    dtab[3] = &dteFileID;

    dtab.Paint( plb, hdc, prect, pGUILTT );

}   // OPENFILES_LBI :: Paint


/*******************************************************************

    NAME:       OPENFILES_LBI::Compare

    SYNOPSIS:   standard compare method for the OpenFiles LBI

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
        chuckc  30-Sep-1991     stolen from server manager

********************************************************************/
INT OPENFILES_LBI::Compare( const LBI * plbi ) const
{
    const NLS_STR * pnls    = &(((const OPENFILES_LBI *)plbi)->_nlsUserName);

    // no need check above, since error will be returned here as well
    return (_nlsUserName._stricmp( *pnls ) ) ;
}

/*******************************************************************

    NAME:       OPENFILES_LBI::OPENFILES_LBI

    SYNOPSIS:   constructor for the OpenFiles LBI

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
        chuckc  30-Sep-1991     stolen from server manager, hierarchicalized,
                                and converted to use QueryColumnWidths
        beng    06-Apr-1992     Removed wsprintf

********************************************************************/
OPENFILES_LBI::OPENFILES_LBI( const TCHAR *pszUserName,
                              const TCHAR *pszPath,
                              UINT        uPermissions,
                              ULONG       cLocks,
                              ULONG       ulFileID)
                 :OPEN_LBI_BASE( pszUserName,
                                 pszPath,
                                 uPermissions,
                                 cLocks,
                                 ulFileID),
                 _nlsID(ulFileID)
{
    // usual check
    if( QueryError() != NERR_Success )
        return;

    APIERR err ;
    if ((err = _nlsID.QueryError()) != NERR_Success)
    {
        ReportError(err) ;
        return ;
    }
}

/*******************************************************************

    NAME:       OPENFILES_LBI::~OPENFILES_LBI

    SYNOPSIS:   destructor for the OpenFiles LBI

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
        chuckc  30-Sep-1991     stolen from server manager, hierarchicalized,
                                and converted to use QueryColumnWidths

********************************************************************/
OPENFILES_LBI::~OPENFILES_LBI()
{
    ; // nothing more to do
}

/*******************************************************************

    NAME:       OPENFILES_LBOX::OPENFILES_LBOX

    SYNOPSIS:   constructor for the OpenFiles LBOX

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
        chuckc  30-Sep-1991     stolen from server manager, hierarchicalized,
                                and converted to use QueryColumnWidths

********************************************************************/
OPENFILES_LBOX::OPENFILES_LBOX( OWNER_WINDOW *powOwner,
                              CID cid,
                              const NLS_STR &nlsServer,
                              const NLS_STR &nlsBasePath )
                    : OPEN_LBOX_BASE( powOwner,
                                      cid,
                                      nlsServer,
                                      nlsBasePath )
{
    if (QueryError() != NERR_Success)
        return ;

    //
    //  Build the column width table to be used by
    //  OPEN_LBI_BASE :: Paint().
    //
    DISPLAY_TABLE::CalcColumnWidths( _adx, 4, powOwner, cid, FALSE );
}

/*******************************************************************

    NAME:       OPENFILES_LBOX::~OPENFILES_LBOX

    SYNOPSIS:   destructor for the OpenFiles LBOX

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
        chuckc  30-Sep-1991     stolen from server manager, hierarchicalized,
                                and converted to use QueryColumnWidths

********************************************************************/
OPENFILES_LBOX::~OPENFILES_LBOX()
{
    ; // nothing more to do
}

/*******************************************************************

    NAME:       OPENFILES_LBOX::CreateFileEntry

    SYNOPSIS:   creates a file lbi entry suitable for this
                particular subclass.

    ENTRY:

    EXIT:

    NOTES:      virtual method used by parent class.


    HISTORY:
        chuckc  30-Sep-1991     created

********************************************************************/
OPEN_LBI_BASE *OPENFILES_LBOX::CreateFileEntry(const FILE3_ENUM_OBJ *pfi3)
{
    return
        new OPENFILES_LBI(pfi3->QueryUserName(),
                          pfi3->QueryPathName(),
                          pfi3->QueryPermissions(),
                          pfi3->QueryNumLocks(),
                          pfi3->QueryFileId()) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\shellui\h\helpnums.h ===
/**********************************************************************/
/**			  Microsoft LAN Manager 		     **/
/**		Copyright(c) Microsoft Corp., 1990, 1991	     **/
/**********************************************************************/

/*
    HelpNums.h
    Help context context codes


    FILE HISTORY:
    Johnl   	1/5/91	Created
    Yi-HsinS	10/5/91 Added share dialogs help contexts 

*/

#ifndef _HELPNUMS_H_
#define _HELPNUMS_H_

#include <uihelp.h>

/*
 * Dialog Help Contexts
 */
#define HC_OPENFILES             (HC_UI_SHELL_BASE+10) // open file dialog 

/*
 *  The actual reserved help contexts for share dialogs.            
 *  IMPORTANT: Do not change these numbers unless you also change the          
 *             help contexts in server manager.                                
 * #define HC_FILEMGRSTOPSHARE      (HC_UI_SHELL_BASE+1) 
 * #define HC_FILEMGRSHAREPROP      (HC_UI_SHELL_BASE+2) 
 * #define HC_FILEMGRNEWSHARE       (HC_UI_SHELL_BASE+3) 
 * #define HC_CURRENTUSERSWARNING   (HC_UI_SHELL_BASE+4) 
 * #define HC_LMSHARELEVELPERMS     (HC_UI_SHELL_BASE+5) 
 * #define HC_SHAREPASSWORDPROMPT   (HC_UI_SHELL_BASE+9) 
 * #define HC_NTSHAREPERMS	    (HC_UI_SHELL_BASE+11)
 * #define HC_SHAREADDUSER 	    (HC_UI_SHELL_BASE+12)
 * #define HC_SHAREADDUSER_LOCALGROUP 	(HC_UI_SHELL_BASE+13)
 * #define HC_SHAREADDUSER_GLOBALGROUP 	(HC_UI_SHELL_BASE+14)
 * #define HC_SHAREADDUSER_FINDUSER 	(HC_UI_SHELL_BASE+15)
 * #define HC_PASSWORD_DIALOG 	        (HC_UI_SHELL_BASE+16)
 */

// BUGBUG
#define HC_PASSWORD_DIALOG 	        (HC_UI_SHELL_BASE+16)

#define HC_SVRMGRSHAREPROP       1 // share properties in srvmgr 
#define HC_SVRMGRNEWSHARE        2 // create a new share dialog in srvmgr
#define HC_SVRMGRSHAREMANAGEMENT 3 // share management dialog in srvmgr

/*
 *  Dialog Help Contexts for share dialogs
 *  These are shared between the File manager and the Server manager.
 *  A base help context will be added to each of these to form the
 *  actual help context. 
 */

#define HC_FILEMGRSHAREPROP      1 // share properties in filemgr 
#define HC_FILEMGRNEWSHARE       2 // create a new share dialog in filemgr
#define HC_FILEMGRSTOPSHARE      3 // stop sharing dialog in filemgr

#define HC_CURRENTUSERSWARNING   4 // current users warning dialog
#define HC_LMSHARELEVELPERMS     5 // share level permissions dialog
#define HC_SHAREPASSWORDPROMPT   9 // prompt password dialog when on a share-level server
#define HC_NTSHAREPERMS		 11 // Main share perm dialog

// The following four have to be consecutive
#define HC_SHAREADDUSER 	     12 // Share perm add dlg
#define HC_SHAREADDUSER_LOCALGROUP   13 // Share perm add->Members
#define HC_SHAREADDUSER_GLOBALGROUP  14 // Share perm add->Members
#define HC_SHAREADDUSER_FINDUSER     15 // Share perm add->FindUser

/*
 *  Help for message popups in the share dialogs.
 *  These are shared between the File manager and the Server manager.
 *  A base help context will be added to each of these to form the
 *  actual help context. 
 *
 *  For example, the help context of HC_CHANGEPATHWARNING actually 
 *  depends on whether it's called from the file manager or server manager.
 *  If it's called from the server manager, then the help context is
 *  HC_UI_SRVMGR_BASE+111. If it's called from the file manager, the help
 *  context is HC_UI_SHELL+111.
 *
 *  IMPORTANT: Do not change these numbers unless you also change the
 *             help contexts in server manager.
 */

#define HC_SHAREREMOTEADMINNOTSUPPORTED 50 // IERR_SHARE_REMOTE_ADMIN_NOT_SUPPORTED
#define HC_SHAREINVALIDPERMISSIONS      51 // IERR_SHARE_INVALID_PERMISSIONS
#define HC_SHAREINVALIDCOMMENT          52 // IERR_SHARE_INVALID_COMMENT
#define HC_SHAREINVALIDSHAREPATH        53 // IERR_SHARE_INVALID_SHAREPATH
#define HC_SHAREINVALIDLOCALPATH        54 // IERR_SHARE_INVALID_LOCAL_PATH
#define HC_SHAREINVALIDSHARE            55 // IERR_SHARE_INVALID_SHARE
#define HC_SHAREINVALIDUSERLIMIT        56 // IERR_SHARE_INVALID_USERLIMIT
#define HC_SPECIALSHAREINVALIDPATH      57 // IERR_SPECIAL_SHARE_INVALID_PATH
#define HC_SPECIALSHAREINVALIDCOMMENT   58 // IERR_SPECIAL_SHARE_INVALID_COMMENT
#define HC_SPECIALSHARECANNOTCHANGEPATH 59 // IDS_SPECIAL_SHARE_CANNOT_CHANGE_PATH
#define HC_SHAREPROPCHANGEPASSWDWARN    60 // IDS_SHARE_PROP_CHANGE_PASSWD_WARN_TEXT
#define HC_CHANGEPATHWARNING            61 // IDS_CHANGE_PATH_WARNING
#define HC_SHARENOTACCESSIBLEFROMDOS    62 // IDS_SHARE_NOT_ACCESSIBLE_FROM_DOS
#define HC_CANNOTSETPERMONLMUSERSERVER  63 // IDS_CANNOT_SET_PERM_ON_LMUSER_SERVER

/*                                                                             
 *  The actual reserved help contexts for message popups in the share dialogs.  
 *  IMPORTANT: Do not change these numbers unless you also change the          
 *             help contexts in server manager.                                
 *                                                                             
 *  #define HC_SHAREREMOTEADMINNOTSUPPORTED (HC_UI_SHELL_BASE + 50)           
 *  #define HC_SHAREINVALIDPERMISSIONS      (HC_UI_SHELL_BASE + 51)           
 *  #define HC_SHAREINVALIDCOMMENT          (HC_UI_SHELL_BASE + 52)           
 *  #define HC_SHAREINVALIDSHAREPATH        (HC_UI_SHELL_BASE + 53)           
 *  #define HC_SHAREINVALIDLOCALPATH        (HC_UI_SHELL_BASE + 54)           
 *  #define HC_SHAREINVALIDSHARE            (HC_UI_SHELL_BASE + 55)           
 *  #define HC_SHAREINVALIDUSERLIMIT        (HC_UI_SHELL_BASE + 56)           
 *  #define HC_SPECIALSHAREINVALIDPATH      (HC_UI_SHELL_BASE + 57)           
 *  #define HC_SPECIALSHAREINVALIDCOMMENT   (HC_UI_SHELL_BASE + 58)           
 *  #define HC_SPECIALSHARECANNOTCHANGEPATH (HC_UI_SHELL_BASE + 59)           
 *  #define HC_SHAREPROPCHANGEPASSWDWARN    (HC_UI_SHELL_BASE + 60)           
 *  #define HC_CHANGEPATHWARNING            (HC_UI_SHELL_BASE + 61)           
 *  #define HC_SHARENOTACCESSIBLEFROMDOS    (HC_UI_SHELL_BASE + 62)           
 *  #define HC_CANNOTSETPERMONLMUSERSERVER  (HC_UI_SHELL_BASE + 63)           
 */                                                                             
                                                                               

#ifndef WIN32
/*
 * Dialog Help Contexts
 */
#define HC_WKSTANOTSTARTED		(HC_UI_SHELL_BASE+150)
#define HC_BADLOGONPASSWD		(HC_UI_SHELL_BASE+151)
#define HC_BADLOGONNAME		        (HC_UI_SHELL_BASE+152)	
#define HC_BADDOMAINNAME		(HC_UI_SHELL_BASE+153)
#define HC_LOSESAVEDCONNECTION		(HC_UI_SHELL_BASE+154)
#define HC_REPLACESAVEDCONNECTION	(HC_UI_SHELL_BASE+155)
#define HC_PROFILEREADWRITEERROR	(HC_UI_SHELL_BASE+156)
#define HC_OUTOFSTRUCTURES		(HC_UI_SHELL_BASE+157)

/*
 *  Help for message popups
 */
#define HC_LOGON		(HC_UI_SHELL_BASE+200) // logon dialog 
#define HC_CHANGEPASSWD		(HC_UI_SHELL_BASE+201) // change passwd
#define HC_PASSWDEXPIRY		(HC_UI_SHELL_BASE+202) // change expired passwd
#define HC_CONNECTDRIVE		(HC_UI_SHELL_BASE+203) // connect net drive (win31)
#define HC_BROWSEDRIVE		(HC_UI_SHELL_BASE+204) // browse net drive (win30)
#define HC_BROWSEPRINT		(HC_UI_SHELL_BASE+205) // browse lpt (win30)
#define HC_SENDMSG		(HC_UI_SHELL_BASE+206) // send message
#define HC_DISCONNECTDRIVE	(HC_UI_SHELL_BASE+207) // disconnect net drive (win31)
#define HC_CONNECTPRINT		(HC_UI_SHELL_BASE+208) // connect lpt (win31)
#define HC_PASSWDPROMPT		(HC_UI_SHELL_BASE+209) // prompt for passwd
#endif // !WIN32

//
// Context-sensitive help constants
//
#define IDH_PASSWORD                 1000
#define IDH_CONNECTAS                1005

#endif // _HELPNUMS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\shellui\h\pswddlog.h ===
/*****************************************************************/ 
/**		     Microsoft LAN Manager			**/ 
/**	       Copyright(c) Microsoft Corp., 1989-1990		**/ 
/*****************************************************************/ 

/*
 *	Windows/Network Interface  --  LAN Manager Version
 *
 *	These manifests are generated by the Dialog Editor in combination
 *	with xlate\pswddlog.dlg.
 */

#define IDD_PSWDDLOG_CANCEL     114
#define IDD_PSWDDLOG_HELP       115
#define IDD_PSWDDLOG_OK         112
#define IDD_PSWDDLOG_PASSWORD   110
#define IDD_PSWDDLOG_RESOURCE   107

#define IDD_PSWDDLOG_DEVICE         113
#define IDD_PSWDDLOG_DEVICEPROMPT   118
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\shellui\h\passwd.h ===
/*****************************************************************/ 
/**		     Microsoft LAN Manager			**/ 
/**	       Copyright(c) Microsoft Corp., 1989-1990		**/ 
/*****************************************************************/ 

/*
 *	Windows/Network Interface  --  LAN Manager Version
 *
 *	These manifests are generated by the Dialog Editor in combination
 *	with xlate\passwd.dlg.
 */

#define IDD_PW_CANCEL       120
#define IDD_PW_CONFIRM      117
#define IDD_PW_DOM_SERVER   116
#define IDD_PW_FIRST        122
#define IDD_PW_HELP         121
#define IDD_PW_NEW          123
#define IDD_PW_OK           119
#define IDD_PW_OLD          115
#define IDD_PW_SECOND       113
#define IDD_PW_USERNAME     114
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\shellui\h\logndlog.h ===
/*****************************************************************/ 
/**		     Microsoft LAN Manager			**/ 
/**	       Copyright(c) Microsoft Corp., 1989-1990		**/ 
/*****************************************************************/ 

/*
 *	Windows/Network Interface  --  LAN Manager Version
 *
 *	These manifests are generated by the Dialog Editor in combination
 *	with xlate\logndlog.dlg.
 */

#define IDD_LOG_CANCEL     110
#define IDD_LOG_DOMAIN     423
#define IDD_LOG_HELP       422
#define IDD_LOG_OK         109
#define IDD_LOG_PASSWORD   421
#define IDD_LOG_USERNAME   420
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\shellui\h\pmandlg.h ===
/*****************************************************************/ 
/**		     Microsoft LAN Manager			**/ 
/**	       Copyright(c) Microsoft Corp., 1989-1990		**/ 
/*****************************************************************/ 

/*
 *	Windows/Network Interface  --  LAN Manager Version
 *
 *	These manifests are generated by the Dialog Editor in combination
 *	with xlate\pmandlg.dlg.
 */

#define PMAN_FIND_NAME		420
#define PMAN_FIND_COMMENT	421
#define PMAN_FIND_LOCATION	422
#define PMAN_FIND_KEYWORDS	423
#define PMAN_FIND_DRIVER	424
#define PMAN_SETFOCUS_FOCUS     425
#define PMAN_SETFOCUS_LB        426
#define PMAN_HELP               80
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\shellui\h\opens.h ===
/*****************************************************************/ 
/**		     Microsoft LAN Manager			**/ 
/**	       Copyright(c) Microsoft Corp., 1989-1990		**/ 
/*****************************************************************/ 

#include <errornum.h>

#define IDD_OF_PATH		101
#define IDD_OF_OPENCOUNT	102
#define IDD_OF_LOCKCOUNT	103
#define IDD_OF_CLOSE		104
#define IDD_OF_CLOSEALL		105
#define IDD_OF_LBOX		106
#define IDD_OF_OPENBY		107
#define IDD_OF_OPENFOR		108
#define IDD_OF_LOCKS		109
#define IDD_OF_FILEID		110

#define IDS_NOT_SHAREABLE	(IDS_UI_SHELL_OPEN_BASE+0)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\shellui\h\printman.h ===
/*****************************************************************/ 
/**		     Microsoft LAN Manager			**/ 
/**	       Copyright(c) Microsoft Corp., 1989-1990		**/ 
/*****************************************************************/ 

 /*
 *	Windows/Network Interface  --  LAN Manager Version
 *
 *	This is used for resources associated with the Print Manager.
 */

#define IDM_NEW_PRINTER		200
#define IDM_NEW_SHARE		201
// #define IDM_PROPERTIES		202 still defined in spl_wnt.h
#define IDM_DELETE		203
#define IDM_DELETE_ALL		204
#define IDM_SET_FOCUS		205
#define IDM_FIND		206
#define IDM_CONFIRMATION	207
#define IDM_REFRESH_INTERVAL	208
#define IDM_REFRESH		209
#define IDM_ADMIN_MENUS    	210
#define IDM_STANDARD_MENUS    	211
// #define IDM_CHANGE_MENUS    	212  still defined in spl_wnt.h

// Test Driver only
#define DEBUG_ADMINISTRATOR	213

#define SEP_COMMAND    		220  // Admin Menu Seperator ID

#define IDS_A_PRINTCOMPL	(IDS_A_BASE+1)
#define IDS_A_INTERV		(IDS_A_BASE+2)
#define IDS_A_ERROR		(IDS_A_BASE+3)
#define IDS_A_DESTOFFLINE	(IDS_A_BASE+4)
#define IDS_A_DESTPAUSED	(IDS_A_BASE+5)
#define IDS_A_NOTIFY		(IDS_A_BASE+6)
#define IDS_A_NOPAPER		(IDS_A_BASE+7)
#define IDS_A_FORMCHG		(IDS_A_BASE+8)
#define IDS_A_CRTCHG		(IDS_A_BASE+9)
#define IDS_A_PENCHG		(IDS_A_BASE+10)

#define IDS_A_NOQUEUES		(IDS_A_BASE+11)
#define IDS_A_JOBQUEUED		(IDS_A_BASE+12)
#define IDS_A_JOBPAUSED		(IDS_A_BASE+13)
#define IDS_A_JOBSPOOLING	(IDS_A_BASE+14)
#define IDS_A_JOBPRINTING	(IDS_A_BASE+15)

#define IDS_CAPTION_DOMAIN	(IDS_A_BASE+20)
#define IDS_CAPTION_SERVER	(IDS_A_BASE+21)



// Test Driver only
#define IDS_PMAN_ISADMIN	(IDSBASE_PRINTMAN + 0)
#define IDS_PMAN_AdminMenuItem	(IDSBASE_PRINTMAN + 1)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\shellui\h\sharedlg.h ===
/*****************************************************************/
/**		     Microsoft Windows NT			**/
/**	       Copyright(c) Microsoft Corp., 1991 		**/
/*****************************************************************/

/*
 *  sharedlg.h
 *  This manifests are used by the share properties dialogs
 *
 *  History:
 *  	Yi-HsinS	8/15/91		Created
 *  	Yi-HsinS	12/5/91		Added IERR_SHARE_DRIVE_NOT_READY
 *      beng            04-Aug-1992     Move resource IDs into reange
 *
 */

#ifndef _SHAREDLG_H_
#define _SHAREDLG_H_

#include <errornum.h>

#define IERR_SHARE_REMOTE_ADMIN_NOT_SUPPORTED 	(IDS_UI_SHELL_SHR_BASE + 1)
#define IERR_SHARE_DRIVE_NOT_READY		(IDS_UI_SHELL_SHR_BASE + 2)
#define IERR_SHARE_INVALID_PERMISSIONS	 	(IDS_UI_SHELL_SHR_BASE + 3)
#define IERR_SHARE_INVALID_COMMENT		(IDS_UI_SHELL_SHR_BASE + 4)
#define IERR_SHARE_INVALID_SHAREPATH	 	(IDS_UI_SHELL_SHR_BASE + 5)
#define IERR_SHARE_INVALID_LOCAL_PATH           (IDS_UI_SHELL_SHR_BASE + 6)
#define IERR_SHARE_INVALID_SHARE		(IDS_UI_SHELL_SHR_BASE + 7)
#define IERR_SHARE_INVALID_USERLIMIT            (IDS_UI_SHELL_SHR_BASE + 8)
#define IERR_SPECIAL_SHARE_INVALID_PATH         (IDS_UI_SHELL_SHR_BASE + 9)
#define IERR_SPECIAL_SHARE_INVALID_COMMENT      (IDS_UI_SHELL_SHR_BASE + 10)
#define IERR_SHARE_DIR_NOT_SHARED               (IDS_UI_SHELL_SHR_BASE + 11)
#define IERR_NO_SHARES_ON_SERVER                (IDS_UI_SHELL_SHR_BASE + 12)
#define IERR_SHARE_NOT_ACCESSIBLE_FROM_DOS      (IDS_UI_SHELL_SHR_BASE + 13)
#define IERR_CANNOT_SET_PERM_ON_LMUSER_SERVER   (IDS_UI_SHELL_SHR_BASE + 14)
#define IERR_SPECIAL_SHARE_CANNOT_CHANGE_PATH   (IDS_UI_SHELL_SHR_BASE + 16)
#define IERR_SHARE_NOT_FOUND                    (IDS_UI_SHELL_SHR_BASE + 17)
#define IERR_SPECIAL_SHARE_CANNOT_SET_PERMISSIONS (IDS_UI_SHELL_SHR_BASE + 18)
#define IERR_NOT_SUPPORTED_ON_NON_LM_DRIVE      (IDS_UI_SHELL_SHR_BASE + 19)

#define IDS_SHARE_LB_TITLE_TEXT	                (IDS_UI_SHELL_SHR_BASE + 50)
#define IDS_SHARE_CURRENT_USERS_TEXT            (IDS_UI_SHELL_SHR_BASE + 51)
#define IDS_SHARE_PROP_CHANGE_PASSWD_WARN_TEXT	(IDS_UI_SHELL_SHR_BASE + 52)
#define IDS_ADMIN_INFO_TEXT	                (IDS_UI_SHELL_SHR_BASE + 53)
#define IDS_CHANGE_PATH_WARNING	                (IDS_UI_SHELL_SHR_BASE + 54)

#define IDS_SHARE                               (IDS_UI_SHELL_SHR_BASE + 55)
#define IDS_SHARE_PERM_GEN_READ                 (IDS_UI_SHELL_SHR_BASE + 56)
#define IDS_SHARE_PERM_GEN_MODIFY               (IDS_UI_SHELL_SHR_BASE + 57)
#define IDS_SHARE_PERM_GEN_ALL                  (IDS_UI_SHELL_SHR_BASE + 58)
#define IDS_SHARE_PERM_GEN_NO_ACCESS            (IDS_UI_SHELL_SHR_BASE + 59)

/* The following are the buttons that appear in the Properties dialog.
 */
#define IDS_NETWORK_NAME  			(IDS_UI_SHELL_SHR_BASE + 60)
#define IDS_PROP_BUTTON_SHARE			(IDS_UI_SHELL_SHR_BASE + 61)
#define IDS_PROP_BUTTON_FILEOPENS		(IDS_UI_SHELL_SHR_BASE + 62)

/*
 * Menu IDs for share menus. Used for identifying buttons acyions as well.
 */
#define IDM_CREATE_SHARE        1   // have to be between  1-99
#define IDM_STOP_SHARE          2
#define IDM_SHARE_MANAGEMENT    3

#define IDD_SHARECREATEDLG          8101
#define IDD_FILEMGRSHAREPROPDLG	    8102
#define IDD_SVRMGRSHAREPROPDLG	    8103
#define IDD_SHAREMANAGEMENTDLG      8104
#define IDD_SHAREPERMDLG            8105
#define IDD_SHAREUSERSWARNINGDLG    8106
#define IDD_SHARESTOPDLG            8107

#define SLE_PATH		    160
#define SLE_COMMENT                 161
#define SLE_PASSWORD                162
#define SLE_SHARE                   163
#define CB_SHARE                    164
#define SLT_ADMININFO               165
#define SLT_SHARETITLE              166
#define BUTTON_PERMISSIONS          167
#define BUTTON_NEWSHARE             168

//  Stop sharing dialog

#define LB_SHARE                    170     // NOTE: LB_SHARENAME, LBHEADER_NAME
#define LBHEADER_NAME          	    171     //       and LBHEADER_PATH must be
#define LBHEADER_PATH               172     //       consecutive numbers

//
//  Share management dialog
//
#define BUTTON_STOPSHARING          175
#define BUTTON_SHAREINFO            176
#define BUTTON_ADDSHARE             177


//
//  User Limit Magic Group
//
#define RB_UNLIMITED                180
#define RB_USERS                    181
#define SLE_USERS                   182
#define SB_USERS_GROUP              183
#define SB_USERS_UP                 184
#define SB_USERS_DOWN               185
#define FRAME_USERS                 186

//
//  Permission Group
//
#define RB_READONLY		    190
#define RB_MODIFY		    191
#define RB_OTHER		    192
#define SLE_OTHER		    193

//
//  Current users warning dialog
//
#define SLT_SHARE_TEXT              200

#define LB_USERS                    201    // The following four must be
#define LBHEADER_USERS              202    // continuous numbers.
#define LBHEADER_FILEOPENS          203
#define LBHEADER_TIME		    204

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\shellui\h\wnpasswd.h ===
/*****************************************************************/ 
/**		     Microsoft LAN Manager			**/ 
/**	       Copyright(c) Microsoft Corp., 1989-1990		**/ 
/*****************************************************************/ 

/*
 *	Windows/Network Interface  --  LAN Manager Version
 *
 *	These manifests are used in the Password Expiry dialog,
 *	the ChangePassword dialog, and in the Password Prompt dialog.
 */

// Password Expiry and Change Password dialogs

#include "passwd.h"

#undef  IDD_PW_OK
#define IDD_PW_OK     IDOK
#undef  IDD_PW_CANCEL
#define IDD_PW_CANCEL IDCANCEL
#undef  IDD_PW_HELP
#define IDD_PW_HELP   IDHELPBLT



// Password Prompt dialog

#include "pswddlog.h"

#undef  IDD_PSWDDLOG_CANCEL
#define IDD_PSWDDLOG_CANCEL IDCANCEL
#undef  IDD_PSWDDLOG_OK
#define IDD_PSWDDLOG_OK IDOK
#undef  IDD_PSWDDLOG_HELP
#define IDD_PSWDDLOG_HELP IDHELPBLT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\shellui\h\wnlogon.h ===
/*****************************************************************/ 
/**		     Microsoft LAN Manager			**/ 
/**	       Copyright(c) Microsoft Corp., 1989-1990		**/ 
/*****************************************************************/ 

/*
 *	Windows/Network Interface  --  LAN Manager Version
 *
 *	These manifests are used in the Log On to Workstation dialog.
 */

#include "logndlog.h"

#undef  IDD_LOG_OK
#define IDD_LOG_OK     IDOK
#undef  IDD_LOG_CANCEL
#define IDD_LOG_CANCEL IDCANCEL
#undef  IDD_LOG_HELP
#define IDD_LOG_HELP   IDHELPBLT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\shellui\h\wninit.h ===
/*****************************************************************/ 
/**		     Microsoft LAN Manager			**/ 
/**	       Copyright(c) Microsoft Corp., 1989-1990		**/ 
/*****************************************************************/ 

 /*
 *	Windows/Network Interface  --  LAN Manager Version
 *
 *	These manifests are used in the Init Warning dialog.
 */

#define IDD_IW_REASON		520
#define IDCB_IW_SUPP_WARNINGS	521
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\shellui\h\wnbrows.h ===
/*****************************************************************/ 
/**		     Microsoft LAN Manager			**/ 
/**	       Copyright(c) Microsoft Corp., 1989-1990		**/ 
/*****************************************************************/ 

/*
 *	Windows/Network Interface  --  LAN Manager Version
 *
 *	These manifests are used in the Browser dialog.
 */

#define IDD_TEXT	    100
#define IDD_DIR 	    101
#define IDD_FROM	    102
#define IDD_TO		    103

#define IDD_NETBROWSE	    500
#define IDD_DOMAIN_CB	    501
#define IDD_SERVERS	    502
#define IDD_SERVERTEXT	    503
#define IDD_SHARES	    504
#define IDD_SHARETEXT	    505
#define IDM_BRWS_HELPINDEX  506
#define IDM_BRWS_ABOUT	    507
#define IDD_DOMAINTEXT	    508


/*  The following manifests are for the new (LAN Man 2.1 and 3.0) browser */

#define IDD_BROW_BASE			(100)
#define IDD_BROW_NETWORK_PATH_TEXT	(IDD_BROW_BASE+0)
#define IDD_BROW_NETWORK_PATH		(IDD_BROW_BASE+1)
#define IDD_BROW_DEVICE_TEXT		(IDD_BROW_BASE+2)
#define IDD_BROW_DEVICE 		(IDD_BROW_BASE+3)
#define IDD_BROW_RECONNECT		(IDD_BROW_BASE+4)
#define IDD_BROW_SHOW_TEXT		(IDD_BROW_BASE+5)
#define IDD_BROW_SHOW			(IDD_BROW_BASE+6)
#define IDD_BROW_RESOURCES_TEXT 	(IDD_BROW_BASE+7)
#define IDD_BROW_RESOURCES		(IDD_BROW_BASE+8)
#define IDD_BROW_COMMON_ERRORS		(IDD_BROW_BASE+9)

#define IDD_PRINTER_CONN_TEXT           (IDD_BROW_BASE+11)
#define IDD_PRINTER_CONN                (IDD_BROW_BASE+12)
#define IDD_DOTLINE                     (IDD_BROW_BASE+13)
#define IDD_DISCONNECT                  (IDD_BROW_BASE+14)
#define IDD_RECONNECT                   (IDD_BROW_BASE+15)
#define IDD_CONNECT                     (IDD_BROW_BASE+16)

#define IDD_DISCONN_DRIVES_TEXT         (IDD_BROW_BASE+17)
#define IDD_DISCONN_DRIVES              (IDD_BROW_BASE+18)
#define IDD_DISCONN_LOGON               (IDD_BROW_BASE+19)
#define IDD_DISCONN_HELP                (IDD_BROW_BASE+20)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\shellui\h\wnpmdlg.h ===
/*****************************************************************/ 
/**		     Microsoft LAN Manager			**/ 
/**	       Copyright(c) Microsoft Corp., 1989-1990		**/ 
/*****************************************************************/ 

/*
 *	Windows/Network Interface  --  LAN Manager Version
 *
 *	These manifests are used in the Find Printer and Set Focus dialogs.
 */

#include "pmandlg.h"

#undef  PMAN_HELP
#define PMAN_HELP   IDHELPBLT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\shellui\h\wndev.h ===
/*****************************************************************/ 
/**		     Microsoft LAN Manager			**/ 
/**	       Copyright(c) Microsoft Corp., 1989-1990		**/ 
/*****************************************************************/ 

 /*
 *	Windows/Network Interface  --  LAN Manager Version
 *
 *	This is used for subdialogs of the Device Mode dialog.
 */

#define IDM_LOGON		   400
#define IDM_LOGOFF		   401
#define IDM_PASSWD		   402
#define IDM_EXIT		   403
#define IDM_SEND		   410
#define IDM_TOGGLE_AUTOLOGON	   420
#define IDM_TOGGLE_AUTORESTORE     421
#define IDM_TOGGLE_SAVECONNECTIONS 422
#define IDM_TOGGLE_WARNINGS	   423
#define IDM_HELPINDEX		   430
#define IDM_ABOUT		   431

#define IDD_MS_USERNAME 441
#define IDD_MS_MSGTEXT	442
#define IDD_MS_HELP	443

#define IDD_ABT_VERSION  450
#define IDD_LMAN_VERSION 451

#define IDD_CPW_PW	460

#define IDD_UserName	    470
#define IDD_ComputerName    471
#define IDD_DomainName	    472

#define IDD_PRO_SHARE	    480
#define IDD_PRO_PW	    481


BOOL FAR PASCAL NetDevMsgDlgProc      ( HWND		hDlg,
					WORD		wMsg,
					WORD		wParam,
					LONG		lParam		);

BOOL FAR PASCAL NetDevLogDlgProc      ( HWND		hDlg,
					WORD		wMsg,
					WORD		wParam,
					LONG		lParam		);

BOOL FAR PASCAL NetDevPasswdProc      ( HWND		hDlg,
					WORD		wMsg,
					WORD		wParam,
					LONG		lParam		);

BOOL FAR PASCAL NetDevConfPWProc      ( HWND		hDlg,
					WORD		wMsg,
					WORD		wParam,
					LONG		lParam		);

extern "C"
{
BOOL FAR PASCAL LoadProfiles	      ( HWND		hwndParent	);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\shellui\h\winlocal.h ===
/*****************************************************************/
/**                      Microsoft Windows NT                   **/
/**            Copyright(c) Microsoft Corp., 1989-1992          **/
/*****************************************************************/

/*
 *      Windows/Network Interface  --  LAN Manager Version
 *
 *      Insert typedef which is excluded from netlib.h when the
 *      OS2_INCLUDED switch is included.  OS2_INCLUDED is necessary
 *      to avoid a redefinition of BYTE.  For this reason, to include
 *      the str[...]f functions, include the following lines:
 *           #include "winlocal.h"
 *           #define OS2_INCLUDED
 *           #include <netlib.h>
 *           #undef OS2_INCLUDED
 *      Note, that winlocal.h must be included before netlib.h.
 *
 *      History:
 *          terryk      08-Nov-1991 change ErrorPopup's WORD to UINT
 *          chuckc      12-Dec-1991 move error message defines elsewhere,
 *                                  misc cleanup.
 *          Yi-HsinS    31-Dec-1991 Unicode work - move string literals
 *                                  defines to strchlit.hxx
 *          beng        21-Feb-1992 Relocate some BMIDs to focusdlg.h
 *          beng        04-Aug-1992 Move resource IDs into official range;
 *                                  dialog IDs return to here
 */

#ifndef _WINLOCAL_H_
#define _WINLOCAL_H_

/*
 * The following manifests define the BITMAP names used by the browse
 * dialogs.
 * They are meant to be used with the DISPLAY_MAP class (they have a green
 * border for that represents the transparent color).
 */
#define BMID_NETDIR          8001
#define BMID_NETDIREX        8002
#define BMID_PRINTER         8003
#define BMID_PRINTER_UNAVAIL 8004
#define BMID_SHARE_UNAVAIL   8006
#define BMID_USER            8007
#define BMID_GROUP           8008

/* Bitmaps for share dialogs */
#define BMID_SHARE           8010
#define BMID_STICKYSHARE     8011
#define BMID_IPCSHARE        8012

/* Menu IDs (menus, not menuitems) */

#define FMX_MENU             8001


/* Dialog IDs */

#define PASSWORD_DLG         8001
#define OPENFILES_DLG        8002

#define DLG_NETDEVLOGON      8003
#define DLG_NETDEVMSGSEND    8004
#define DLG_NETDEVDLG        8005
#define DLG_INITWARN         8006

#define DLG_NETDEVPASSWD     8007
#define DLG_EXPIRY           8008

#define DLG_FIND_PRINTER     8009
#define DLG_SET_FOCUS        8010


/*
 * include the error message ranges
 */
#include <errornum.h>

UINT MapError( APIERR usNetError );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\shellui\misc\getfocus.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    GETFOCUS.CXX
        Popup a dialog box and ask for the domain or server name

    FILE HISTORY:
        terryk  18-Nov-1991     Created
        terryk  26-Nov-1991     Code review changes. reviewed by jonn
                                johnl
        Yi-HsinS31-Dec-1991     Unicode work - change strlen() to
                                               QueryTextSize()

*/

#define INCL_WINDOWS_GDI
#define INCL_WINDOWS
#define INCL_DOSERRORS
#define INCL_NETCONS
#define INCL_NETERRORS
#define INCL_NETLIB
#define INCL_ICANON
#define INCL_NETSERVER
#include <lmui.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif
#include <uiassert.hxx>

#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MSGPOPUP
#define INCL_BLT_CLIENT
#define INCL_BLT_APP
#define INCL_BLT_TIMER
#include <blt.hxx>
#include <string.hxx>
#include <uitrace.hxx>
#include <focusdlg.hxx>
#include <wnetdev.hxx>

extern "C"
{
    #include <uiexport.h>
    #include <wnet16.h>
    #include <uigenhlp.h>
}

#define  THIS_DLL_NAME	             SZ("ntlanman.dll")
#define  DEFAULT_NETWORK_HELP_FILE   SZ("network.hlp")


/*******************************************************************

    NAME:       I_SystemFocusDialog

    SYNOPSIS:   Popup a dialog box and get the domain or server name

    ENTRY:      hwndOwner - owner window handle
                nSelectionType - Determines what items the user can select
                pszName - the string buffer which contains the
                    return value. It can be either domain name or server
                    name. ( server name will start with "\\" )
                cchBuffSize - the max buf size of pszName
                pfOK - TRUE if user hits OK button. FALSE if user
                    hits a CANCEL button.

    EXIT:       LPWSTR pszName - if user hits okay button, it will
                    return either a domain name or a server name. (
                    server name always starts with "\\" ). It will be
                    undefined if the user hits Cancel button.
                BOOL *pfOK - TRUE if user hits ok button. FALSE
                    otherwise.

    RETURNS:    UINT - (APIERR) - NERR_Success if the operation is succeed.
                         NERR_BufTooSmall, the string buffer is too
                             small. It will not set the string if the
                             buffer is too small.

    NOTES:      The reason the return type is UINT and not APIERR is because
                APIERR is not a public definition, and this API is exported
                for public use.

    HISTORY:
                terryk  18-Nov-1991     Created
                terryk  19-Nov-1991     Name changed
                JohnL   22-Apr-1992     Allowed inclusion specification

********************************************************************/

UINT I_SystemFocusDialog(   HWND   hwndOwner,
                            UINT   nSelectionType,
                            LPWSTR pszName,
                            UINT   cchBuffSize,
                            BOOL * pfOK,
                            LPWSTR pszHelpFile,
                            DWORD  nHelpContext )
{
    static BOOL fLoadedCurrentDll = FALSE;

    APIERR err ;
    if ( err = InitShellUI() )
    {
	return err ;
    }

    // 
    // Because select computer dialog has a second thread,
    // we need to do a loadlibrary again to prevent
    // the dll from unloading itself while the second thread
    // is still active.
    //

    // JonN 01/28/00 PREFIX bug 444915
    // Because STANDALONE_SET_FOCUS_DLG is liable to launch a second thread
    // which will survive DIALOG::Process(), we increment the library
    // refcount.  We can't decrement it because we don't know when
    // this thread will complete, so the library remains loaded
    // for the life of the process.
    //
    // This is not an ideal solution.  The thread should take care of
    // its own refcounting needs.  However, this is downlevel code
    // used only by the oldest clients, and I don't feel comfortable
    // making this kind of change which could cause unpredictable problems.
    // I think the wisest course is to leave this alone, and continue to
    // migrate clients towards Object Picker.

    if ( !fLoadedCurrentDll )
    {
        HANDLE handle = ::LoadLibraryEx( THIS_DLL_NAME,
                                         NULL,
                                         LOAD_WITH_ALTERED_SEARCH_PATH );
        if ( handle == NULL )
            return ::GetLastError();
        fLoadedCurrentDll = TRUE;
    }

    UINT nSel = nSelectionType & 0x0000FFFF;
    ULONG maskDomainSources = nSelectionType >> 16;
    if ( maskDomainSources == 0 )
        maskDomainSources = BROWSE_LM2X_DOMAINS;

    enum SELECTION_TYPE seltype ;
    switch ( nSel  )
    {
    case FOCUSDLG_DOMAINS_ONLY:
        seltype = SEL_DOM_ONLY ;
        break ;

    case FOCUSDLG_SERVERS_ONLY:
        seltype = SEL_SRV_ONLY ;
        break ;

    case FOCUSDLG_SERVERS_AND_DOMAINS:
        seltype = SEL_SRV_AND_DOM ;
        break ;

    default:
        return ERROR_INVALID_PARAMETER ;
    }

    // Create a standalone set focus dialog box and get the input
    // form the user
    NLS_STR nlsName;
    STANDALONE_SET_FOCUS_DLG ssfdlg( hwndOwner, 
                                     &nlsName, 
                                     nHelpContext, 
                                     seltype,
                                     maskDomainSources,
                                     NULL,
                                     pszHelpFile );

    err = ssfdlg.Process( pfOK );
    if ( err != NERR_Success )
    {
        ::MsgPopup( hwndOwner, err );
        *pfOK = FALSE;
        return err;
    }
    if ( *pfOK == TRUE )
    {
        if (( nlsName.QueryTextLength() + 1 ) > cchBuffSize )
        {
            *pfOK = FALSE;
            return NERR_BufTooSmall;
        }
        ::strcpyf( pszName, nlsName.QueryPch() );
    }

    return NERR_Success;
}    // GetSystemFocusDialog END

/*******************************************************************

    NAME:       ServerBrowseDialogA0

    SYNOPSIS:   dialog box to browse for servers

    ENTRY:      hwndOwner - owner window handle
                pszName - the string buffer which contains the
                    return value. It can be either domain name or server
                    name. ( server name will start with "\\" )
                cchBuffSize - the max buf size of pszName

    EXIT:       LPWSTR pszName - if user hits okay button, it will
                    return either a domain name or a server name. (
                    server name always starts with "\\" ). It will be
                    undefined if the user hits Cancel button.

    RETURNS:    UINT - (APIERR) - NERR_Success if the operation is succeed.
                         WN_CANCEL - The user cancelled the dialog box.
                         NERR_BufTooSmall, the string buffer is too
                             small. It will not set the string if the
                             buffer is too small.

    NOTES:      

    HISTORY:
                ChuckC   28-Mar-1993     Created
                AnirudhS 03-Oct-1995     Handle WN_CANCEL case

********************************************************************/

DWORD ServerBrowseDialogA0(HWND    hwnd,
                           CHAR   *pchBuffer,
                           DWORD   cchBufSize) 
{
    NLS_STR nlsServer ;
    TCHAR szServer[MAX_PATH] ;
    BOOL  fOK ;
    UINT  err ;

    ::memsetf(pchBuffer,0,cchBufSize) ;

    if (err = (UINT) nlsServer.QueryError())
        return err ;

    err = I_SystemFocusDialog ( hwnd,
                                FOCUSDLG_SERVERS_ONLY,
                                szServer,
                                MAX_PATH,
                                &fOK,
                                DEFAULT_NETWORK_HELP_FILE,
                                HC_GENHELP_BROWSESERVERS ) ;

    if (err == NERR_Success && !fOK)
    {
        err = WN_CANCEL;
    }

    if (err != NERR_Success)
        return err ;

    err = (UINT) nlsServer.CopyFrom(szServer) ;
    if (err == NERR_Success)
    {
        err = (UINT) nlsServer.MapCopyTo(pchBuffer, cchBufSize) ;
    }
    
    return err ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\shellui\share\sharefmx.cxx ===
/**********************************************************************/
/**			  Microsoft Windows NT	 		     **/
/**		Copyright(c) Microsoft Corp., 1991  		     **/
/**********************************************************************/

/*
 *   sharefmx.cxx
 *     Contains dialogs called by FMExtensionProc/WinFile/Svrmgr for creating,
 *     deleting and managing shares.
 *
 *   FILE HISTORY:
 *     Yi-HsinS		8/25/91		Created
 *     Yi-HsinS		11/25/91	Made sleShareDir in Create Share dialog
 *					accepts local full path name.
 *     Yi-HsinS		12/5/91		Uses NET_NAME
 *     Yi-HsinS		12/15/91	Uses SHARE_NET_NAME
 *     Yi-HsinS		12/31/91	Unicode work
 *     Yi-HsinS         1/8/92		Move dialogs to sharestp.cxx,
 *	  				sharecrt.cxx
 *     Yi-HsinS         8/10/92         Added ShareManage and got rid of
 *                                      WNetShareManagementW...
 *
 */

#define INCL_WINDOWS_GDI
#define INCL_WINDOWS
#define INCL_DOSERRORS
#define INCL_NETERRORS
#define INCL_NETSHARE
#define INCL_NETUSE
#define INCL_NETSERVER
#define INCL_NETCONS
#define INCL_NETLIB
#include <lmui.hxx>

extern "C"
{
    #include <mpr.h>
    #include <helpnums.h>
    #include <sharedlg.h>
}
#include <wfext.h>

#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MSGPOPUP
#define INCL_BLT_SPIN_GROUP
#include <blt.hxx>

#include <string.hxx>
#include <uitrace.hxx>

#include <lmoshare.hxx>
#include <lmoesh.hxx>
#include <lmoeconn.hxx>
#include <lmosrv.hxx>
#include <wnetdev.hxx>

#include <fmx.hxx>

#include <strchlit.hxx>   // for string and character constants
#include "sharestp.hxx"
#include "sharecrt.hxx"
#include "sharemgt.hxx"
#include "sharefmx.hxx"

/*******************************************************************

    NAME:	ShareCreate	

    SYNOPSIS:   Get the item selected in FM and call the create share dialog

    ENTRY:      hwnd  - hwnd of the parent window

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
  	Yi-HsinS	8/25/91		Created	

********************************************************************/

APIERR ShareCreate( HWND hwnd )
{
    APIERR err = NERR_Success;
    if ( err = ::InitShellUI() )
        return err;

    ULONG ulOldHelpContextBase = POPUP::SetHelpContextBase( HC_UI_SHELL_BASE );
    //
    // Get the first selected item in the file manager
    //
    NLS_STR nlsSelItem;
    FMX fmx( hwnd );
    SERVER_WITH_PASSWORD_PROMPT *psvr = NULL;

    if (  ((err = nlsSelItem.QueryError()) == NERR_Success )
       && ((err = ::GetSelItem( hwnd, &nlsSelItem ) ) == NERR_Success )
       )
    {

        BOOL fShared = FALSE;

        //
        // If a file/directory is selected, check to see if the directory
        // (the directory the file is in if a file is selected)
        // is shared or not. If we select a file/directory on a LM2.1
        // share level server, a dialog will prompt for password to the
        // ADMIN$ share if we don't already have a connection to it.
        //
        if ( nlsSelItem.QueryTextLength() != 0 )
        {
            AUTO_CURSOR autocur;
            NET_NAME netname( nlsSelItem, TYPE_PATH_ABS );
            NLS_STR nlsLocalPath;
            NLS_STR nlsServer;

            if (  ((err = netname.QueryError()) == NERR_Success )
               && ((err = nlsLocalPath.QueryError()) == NERR_Success )
               && ((err = nlsServer.QueryError()) == NERR_Success )
               )
            {
                BOOL fLocal = netname.IsLocal( &err );

                //
                // Use better error code for non-LM device
                //
                if ( err == NERR_InvalidDevice ) 
                    err = IERR_NOT_SUPPORTED_ON_NON_LM_DRIVE;

                if (  ( err == NERR_Success )
                   && ( fLocal
                      || ((err = netname.QueryComputerName(&nlsServer))
                          == NERR_Success)
                      )
                   )

                {
                    psvr = new SERVER_WITH_PASSWORD_PROMPT( nlsServer,
  						            hwnd,
					                    HC_UI_SHELL_BASE );
                    if (  ( psvr != NULL )
                       && ((err = psvr->QueryError()) == NERR_Success )
                       && ((err = psvr->GetInfo()) == NERR_Success )
                       && ((err = netname.QueryLocalPath(&nlsLocalPath))
                          ==NERR_Success)
                       )
                    {
                        //
                        // Check to see if the directory is shared
                        //
                        SHARE2_ENUM sh2Enum( nlsServer );
                        if (  ((err = sh2Enum.QueryError()) == NERR_Success )
                           && ((err = sh2Enum.GetInfo()) == NERR_Success )
                           )
                        {
                            SHARE_NAME_WITH_PATH_ENUM_ITER shPathEnum(sh2Enum,
                                                                  nlsLocalPath);

                            if ((err = shPathEnum.QueryError()) == NERR_Success)
                            {
                                const TCHAR *pszShare;
                                while ((pszShare = shPathEnum()) != NULL )
                                {
                                    fShared = TRUE;
                                    break;
                                }
                            }
                        }
                    }
                    else
                    {
                        if ( psvr == NULL )
                            err = ERROR_NOT_ENOUGH_MEMORY;
                    }
                }
             }
        }

        if ( err == NERR_Success )
        {
            //
            //  If the directory is shared, popup the share properties
            //  dialog. If not, popup the new share dialog.
            //

            SHARE_DIALOG_BASE *pdlg;
            if ( !fShared )
                pdlg = new FILEMGR_NEW_SHARE_DIALOG( hwnd,
 						     nlsSelItem,
						     HC_UI_SHELL_BASE );
            else
                pdlg = new FILEMGR_SHARE_PROP_DIALOG( hwnd,
     						      nlsSelItem,
						      HC_UI_SHELL_BASE );

            err = (APIERR) ( pdlg == NULL? ERROR_NOT_ENOUGH_MEMORY
				         : pdlg->QueryError());

            if ( err == NERR_Success)
            {
                BOOL fSucceeded;
                err = pdlg->Process( &fSucceeded );

                //
                // Refresh the file manager if successfully created a share
                //
                if (( err == NERR_Success ) && fSucceeded )
                {
                    delete psvr;
                    psvr = NULL;
                    fmx.Refresh();
                }
            }

            delete pdlg;
        }

    }

    delete psvr;
    psvr = NULL;

    if ( err != NERR_Success )
    {
        if ( err == ERROR_INVALID_LEVEL )
            err = ERROR_NOT_SUPPORTED;
        else if (err == IERR_USER_CLICKED_CANCEL)
            err = NERR_Success;

        if ( err != NERR_Success )
            ::MsgPopup( hwnd, err );
    }

    POPUP::SetHelpContextBase( ulOldHelpContextBase );
    return NERR_Success;
}

/*******************************************************************

    NAME:	ShareStop	

    SYNOPSIS:   Get the item selected in FM and call the stop share dialog

    ENTRY:      hwnd  - hwnd of the parent window

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
  	Yi-HsinS	8/25/91		Created	

********************************************************************/

APIERR ShareStop( HWND hwnd )
{
    APIERR err = NERR_Success;

    if ( err = ::InitShellUI() )
        return err;

    ULONG ulOldHelpContextBase = POPUP::SetHelpContextBase( HC_UI_SHELL_BASE );

    //
    // Get the first selected item in the file manager
    //
    NLS_STR nlsSelItem;
    FMX fmx( hwnd );
    if (  ((err = nlsSelItem.QueryError()) == NERR_Success )
       && ((err = ::GetSelItem( hwnd, &nlsSelItem ) ) == NERR_Success )
       )
    {
        //
        // Check to see if the selected item is on a LM drive,
        // if not, pop an error.
        //
        NET_NAME netname( nlsSelItem, TYPE_PATH_ABS );

        if ((err = netname.QueryError()) == NERR_Success )
        {
            BOOL fLocal = netname.IsLocal( &err );

            //
            // Use better error code for non-LM device
            //
            if ( err == NERR_InvalidDevice ) 
                err = IERR_NOT_SUPPORTED_ON_NON_LM_DRIVE;
        }
       
        if ( err == NERR_Success )
        {
            //
            // Show the stop sharing dialog
            //
            STOP_SHARING_DIALOG *pdlg = new STOP_SHARING_DIALOG( hwnd,
    		        		  			                    nlsSelItem,
				        			                        HC_UI_SHELL_BASE );

            err = (APIERR) ( pdlg == NULL? ERROR_NOT_ENOUGH_MEMORY
	                    	    		 : pdlg->QueryError() );
            BOOL fSucceeded;
            if ( err == NERR_Success )
                err = pdlg->Process( &fSucceeded );

            delete pdlg;

            //
            // Refresh the file manager if successfully stopped sharing a share
            //
            if (( err == NERR_Success ) && fSucceeded )
                fmx.Refresh();
        }
    }

    if ( err != NERR_Success )
    {
        if (err == IERR_USER_CLICKED_CANCEL)
            err = NERR_Success;
        else 
            ::MsgPopup( hwnd, err );
    }

    POPUP::SetHelpContextBase( ulOldHelpContextBase );
    return NERR_Success;
}

/*******************************************************************

    NAME:	ShareManage

    SYNOPSIS:	Entry point for the share management dialog to be called
                from the server manager.


    ENTRY:	hwnd      - hwnd of the parent window
		pszServer - The server to focus on

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	Yi-HsinS	8/8/92		Created

********************************************************************/

VOID ShareManage( HWND hwnd, const TCHAR *pszServer )
{
    APIERR err = NERR_Success;

    ULONG ulOldHelpContextBase = POPUP::SetHelpContextBase( HC_UI_SRVMGR_BASE);

    if (  ( err = ::InitShellUI() )
       || ( pszServer == NULL )
       )
    {
        err = err? err : ERROR_INVALID_PARAMETER ;
    }
    else
    {
        SHARE_MANAGEMENT_DIALOG *pdlg =
            new SHARE_MANAGEMENT_DIALOG( hwnd, pszServer, HC_UI_SRVMGR_BASE );

        err = (APIERR) ( pdlg == NULL? ERROR_NOT_ENOUGH_MEMORY
	   			     : pdlg->QueryError() );
        if ( err == NERR_Success )
        {
	    err = pdlg->Process();
        }

        delete pdlg;
    }

    if ( err != NERR_Success )
    {
        if ( err == ERROR_INVALID_LEVEL )
            err = ERROR_NOT_SUPPORTED;
        else if (err == IERR_USER_CLICKED_CANCEL)
            err = NERR_Success;
         
        if ( err != NERR_Success )
            ::MsgPopup( hwnd, err );
    }

    POPUP::SetHelpContextBase( ulOldHelpContextBase );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\shellui\share\shareacl.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*

    ShareAcl.cxx

    This file contains the implementation for the Shares Acl
    Editor.  It is just a front end for the Generic ACL Editor that is
    specific to Shares,.

    FILE HISTORY:
	ChuckC	 06-Aug-1992	Culled from NTFSACL.CXX
        Yi-HsinS 09-Oct-1992    Added ulHelpContext to EditShareAcl
        Yi-HsinS 20-Nov-1992    Make ntlanman.dll link dynamically to
				acledit.dll ( not statically ).
        DavidHov 17-Oct-1993    Made pSedDiscretionaryEditor extern "C"
                                because mangling on Alpha didn't
                                equate to that in LIBMAIN.CXX
*/

#include <ntincl.hxx>

extern "C"
{
    #include <ntioapi.h>
    #include <ntseapi.h>
    #include <helpnums.h>
}


#define INCL_NETCONS
#define INCL_WINDOWS
#define INCL_NETERRORS
#define INCL_DOSERRORS
#define INCL_NETSHARE
#define _WINNETWK_
#include <lmui.hxx>
#undef _WINNETWK_

#define INCL_BLT_MSGPOPUP
#include <blt.hxx>
#include <dbgstr.hxx>

#include <string.hxx>
#include <strnumer.hxx>
#include <security.hxx>
#include <ntacutil.hxx>
#include <uibuffer.hxx>
#include <strlst.hxx>
#include <errmap.hxx>


extern "C"
{
    #include <sedapi.h>
    #include <sharedlg.h>
    #include <lmapibuf.h>
}


#include <uiassert.hxx>
#include <shareacl.hxx>

typedef DWORD (*PSEDDISCRETIONARYACLEDITOR)( HWND, HANDLE, LPWSTR,
              PSED_OBJECT_TYPE_DESCRIPTOR, PSED_APPLICATION_ACCESSES,
              LPWSTR, PSED_FUNC_APPLY_SEC_CALLBACK, ULONG_PTR, PSECURITY_DESCRIPTOR,
              BOOLEAN, BOOLEAN, LPDWORD, DWORD );

extern HMODULE hmodAclEditor;

extern "C"
{
    // BUGBUG:  This needs to be in a header file so mangling will
    //          work properly
    extern PSEDDISCRETIONARYACLEDITOR pSedDiscretionaryAclEditor;
}

#define ACLEDIT_DLL_STRING                 SZ("acledit.dll")
#define SEDDISCRETIONARYACLEDITOR_STRING   ("SedDiscretionaryAclEditor")
/*
 * declare the callback routine based on typedef in sedapi.h.
 * CODEWORK - that file should declare for us!
 */
DWORD SedCallback( HWND 		  hwndParent,
		   HANDLE		  hInstance,
		   ULONG_PTR		  ulCallbackContext,
		   PSECURITY_DESCRIPTOR   psecdesc,
		   PSECURITY_DESCRIPTOR   psecdescNewObjects,
		   BOOLEAN		  fApplyToSubContainers,
		   BOOLEAN		  fApplyToSubObjects,
		   LPDWORD		  StatusReturn
		 ) ;

/*
 * structure for callback function's usage.
 * all we do today during callback is set the
 * Dacl to be passed back to the Shared dialog,
 * and set a flag to tell us if the user actually
 * did anything. The flag is FALSE as long as the
 * user hits cancel.
 */
typedef struct _SHARE_CALLBACK_INFO
{
    OS_SECURITY_DESCRIPTOR * pOsSecDesc ;
    BOOL                     fSecDescModified ;
} SHARE_CALLBACK_INFO ;

/*
 * routine that sets up the right generic mappings
 */
void InitializeShareGenericMapping( PGENERIC_MAPPING pSHAREGenericMapping ) ;

/* The following two arrays define the permission names for NT Files.  Note
 * that each index in one array corresponds to the index in the other array.
 * The second array will be modifed to contain a string pointer pointing to
 * the corresponding IDS_* in the first array.
 */
MSGID msgidSharePermNames[] =
{
    IDS_SHARE_PERM_GEN_NO_ACCESS,
    IDS_SHARE_PERM_GEN_READ,
    IDS_SHARE_PERM_GEN_MODIFY,
    IDS_SHARE_PERM_GEN_ALL
} ;

SED_APPLICATION_ACCESS sedappaccessSharePerms[] =
    {
      { SED_DESC_TYPE_RESOURCE, 	FILE_PERM_GEN_NO_ACCESS,    0, NULL },
      { SED_DESC_TYPE_RESOURCE, 	FILE_PERM_GEN_READ,	    0, NULL },
      { SED_DESC_TYPE_RESOURCE, 	FILE_PERM_GEN_MODIFY,	    0, NULL },
      { SED_DESC_TYPE_RESOURCE, 	FILE_PERM_GEN_ALL,	    0, NULL }
    } ;

#define COUNT_FILEPERMS_ARRAY	(sizeof(sedappaccessSharePerms)/sizeof(SED_APPLICATION_ACCESS))


/*******************************************************************

    NAME:	EditShareAcl

    SYNOPSIS:	This Procedure prepares the structures necessary for the
		generic ACL editor, specifically for NT Shares.

    ENTRY:	hwndParent - Parent window handle
		
		pszServer - Name of server the resource resides on
		    (in the form "\\server")
		pszResource - Fully qualified name of resource we will
		    edit, basically a share name.
		pfSecDescModified - used to return to share dialog if
		    the User cancelled or hit OK.
		ppOsSEcDesc - pointer to pointer to OS_SECURITY_DESCRIPTOR.
		    *ppOsSecDesc is NULL if this is a new share or a share
		    without any security descriptor, in which case we create
		    one.

    EXIT:

    RETURNS:

    NOTES:	We assume we are dealing with a SHARE by the time
		this function is called.

    HISTORY:
	ChuckC	 10-Aug-1992	Created. Culled from NTFS ACL code.
        Yi-HsinS 09-Oct-1992     Added ulHelpContextBase

********************************************************************/

APIERR EditShareAcl( HWND		       hwndParent,
		     const TCHAR *	       pszServer,
		     const TCHAR *	       pszResource,
		     BOOL        *             pfSecDescModified,
                     OS_SECURITY_DESCRIPTOR ** ppOsSecDesc,
                     ULONG                     ulHelpContextBase )

{
    UIASSERT(pszServer) ;
    UIASSERT(pszResource) ;
    UIASSERT(ppOsSecDesc) ;
    UIASSERT(pfSecDescModified) ;

    APIERR err = NERR_Success; // JonN 01/27/00: PREFIX bug 444914

    do { // error breakout
	
	/*
         * if we *ppsecdesc is NULL, this is new share or a share with no
         * security descriptor.
	 * we go and create a new (default) security descriptor.
         */
        if (!*ppOsSecDesc)
	{
	    APIERR err = ::CreateDefaultAcl(ppOsSecDesc) ;
	    if (err != NERR_Success)
		break ;
	}

	/* Retrieve the resource strings appropriate for the type of object we
	 * are looking at
	 */
	RESOURCE_STR nlsTypeName( IDS_SHARE ) ;
	RESOURCE_STR nlsDefaultPermName( IDS_SHARE_PERM_GEN_READ ) ;

	if ( ( err = nlsTypeName.QueryError() ) ||
	     ( err = nlsDefaultPermName.QueryError()) )
	{
	    break ;
	}

	/*
         * other misc stuff we need pass to security editor
	 */
	SED_OBJECT_TYPE_DESCRIPTOR sedobjdesc ;
	SED_HELP_INFO sedhelpinfo ;
	GENERIC_MAPPING SHAREGenericMapping ;

	// setup mappings
	InitializeShareGenericMapping( &SHAREGenericMapping ) ;

	// setup help
	RESOURCE_STR nlsHelpFileName( ulHelpContextBase == HC_UI_SHELL_BASE
                                      ? IDS_SHELLHELPFILENAME
                                      : IDS_SMHELPFILENAME ) ;
	if ( err = nlsHelpFileName.QueryError() )
	{
	    DBGEOL("::EditShareAcl - Failed to retrieve help file name") ;
	    break ;
	}

	sedhelpinfo.pszHelpFileName = (LPWSTR) nlsHelpFileName.QueryPch() ;
	sedhelpinfo.aulHelpContext[HC_MAIN_DLG] = ulHelpContextBase +
                                                  HC_NTSHAREPERMS ;
	sedhelpinfo.aulHelpContext[HC_ADD_USER_DLG] = ulHelpContextBase +
                                                      HC_SHAREADDUSER ;
        sedhelpinfo.aulHelpContext[HC_ADD_USER_MEMBERS_LG_DLG] =
                                                      ulHelpContextBase +
                                                      HC_SHAREADDUSER_LOCALGROUP ;
        sedhelpinfo.aulHelpContext[HC_ADD_USER_MEMBERS_GG_DLG] =
                                                      ulHelpContextBase +
                                                      HC_SHAREADDUSER_GLOBALGROUP ;
        sedhelpinfo.aulHelpContext[HC_ADD_USER_SEARCH_DLG] =
                                                      ulHelpContextBase +
                                                      HC_SHAREADDUSER_FINDUSER ;

	// These are not used, set to zero
	sedhelpinfo.aulHelpContext[HC_SPECIAL_ACCESS_DLG] = 0 ;
	sedhelpinfo.aulHelpContext[HC_NEW_ITEM_SPECIAL_ACCESS_DLG] = 0 ;

	// setup the object description
	sedobjdesc.Revision		       = SED_REVISION1 ;
	sedobjdesc.IsContainer		       = FALSE ;
	sedobjdesc.AllowNewObjectPerms	       = FALSE ;
	sedobjdesc.MapSpecificPermsToGeneric   = TRUE ;
	sedobjdesc.GenericMapping	       = &SHAREGenericMapping ;
	sedobjdesc.GenericMappingNewObjects    = &SHAREGenericMapping ;
	sedobjdesc.HelpInfo		       = &sedhelpinfo ;
	sedobjdesc.ObjectTypeName	       = (LPTSTR)nlsTypeName.QueryPch();
	sedobjdesc.SpecialObjectAccessTitle    = NULL ;

	/* Now we need to load the global arrays with the permission names
	 * from the resource file.
	 */
	UINT cArrayItems  = COUNT_FILEPERMS_ARRAY ;
	MSGID * msgidPermNames  = msgidSharePermNames ;
	PSED_APPLICATION_ACCESS pappaccess = sedappaccessSharePerms ;

	/* Loop through each permission title retrieving the text from the
	 * resource file and setting the pointer in the array.	The memory
	 * will be deleted when strlistPermNames is destructed.
	 */
	STRLIST strlistPermNames ;
	for ( UINT i = 0 ; i < cArrayItems ; i++ )
	{
	    RESOURCE_STR * pnlsPermName = new RESOURCE_STR( msgidPermNames[i]) ;
	    err = (pnlsPermName==NULL) ? ERROR_NOT_ENOUGH_MEMORY :
					 pnlsPermName->QueryError() ;
	    if (  err ||
		 (err = strlistPermNames.Add( pnlsPermName )) )
	    {
		delete pnlsPermName ;
		break ;
	    }
	    pappaccess[i].PermissionTitle = (LPTSTR) pnlsPermName->QueryPch() ;
	}
	if ( err )
	    break ;

	SED_APPLICATION_ACCESSES SedAppAccesses ;
	SedAppAccesses.Count	       = cArrayItems ;
	SedAppAccesses.AccessGroup     = pappaccess ;
	SedAppAccesses.DefaultPermName = (LPTSTR)nlsDefaultPermName.QueryPch() ;

	DWORD dwSedReturnStatus ;

	/*
 	 * pass this along so when the call back function is called,
	 * we can set it.
	 */
	SHARE_CALLBACK_INFO callbackinfo ;
	callbackinfo.pOsSecDesc = *ppOsSecDesc ;
	callbackinfo.fSecDescModified = FALSE ;

        if ( ::hmodAclEditor == NULL )
        {
            ::hmodAclEditor = ::LoadLibraryEx( ACLEDIT_DLL_STRING,
                                               NULL,
                                               LOAD_WITH_ALTERED_SEARCH_PATH );
            if ( ::hmodAclEditor == NULL )
            {
                err = ::GetLastError();
                break;
            }

            ::pSedDiscretionaryAclEditor = (PSEDDISCRETIONARYACLEDITOR)
                ::GetProcAddress( ::hmodAclEditor,
                                  SEDDISCRETIONARYACLEDITOR_STRING );
            if ( ::pSedDiscretionaryAclEditor == NULL )
            {
                err = ::GetLastError();
                break;
            }
        }

        UIASSERT( ::pSedDiscretionaryAclEditor != NULL );

	err = (*pSedDiscretionaryAclEditor)( hwndParent,
				NULL,  // dont need instance
				(LPWSTR) pszServer,
			        &sedobjdesc,
				&SedAppAccesses,
				(LPWSTR) pszResource,
			        (PSED_FUNC_APPLY_SEC_CALLBACK) SedCallback,
				(ULONG_PTR) &callbackinfo,
				(*ppOsSecDesc)->QueryDescriptor(),
                                FALSE,  // always can read
                                FALSE,  // If we can read, we can write
                                &dwSedReturnStatus,
                                0 ) ;

	if (err)
	    break ;

	*pfSecDescModified = callbackinfo.fSecDescModified ;

    } while (FALSE) ;

    return err ;
}

/*******************************************************************

    NAME:	SedCallback

    SYNOPSIS:	Security Editor callback for the SHARE ACL Editor

    ENTRY:	See sedapi.hxx

    EXIT:

    RETURNS:

    NOTES:	Normally, the callback is expected to perform the 'apply'.
		In this case, since the object may not exist yet, we defer
		the 'apply' till the user hits OK in the Shares dialog.
		All the CallBack does is simply save away that precious
		modified ACL in the OS_SECURITY_DESCRIPTOR object we were
		given in the first place.

    HISTORY:
	ChuckC	10-Aug-1992	Created

********************************************************************/


DWORD SedCallback( HWND 		  hwndParent,
		   HANDLE		  hInstance,
		   ULONG_PTR		  ulCallbackContext,
		   PSECURITY_DESCRIPTOR   psecdesc,
		   PSECURITY_DESCRIPTOR   psecdescNewObjects,
		   BOOLEAN		  fApplyToSubContainers,
		   BOOLEAN		  fApplyToSubObjects,
		   LPDWORD		  StatusReturn
		 )
{
    UNREFERENCED( hInstance ) ;
    UNREFERENCED( psecdescNewObjects ) ;
    UNREFERENCED( fApplyToSubObjects ) ;
    UNREFERENCED( fApplyToSubContainers ) ;
    UNREFERENCED( StatusReturn ) ;

    APIERR err = NO_ERROR ;
    OS_SECURITY_DESCRIPTOR * pOsSecDesc =
	((SHARE_CALLBACK_INFO *)ulCallbackContext)->pOsSecDesc ;

    do {  // error breakout loop

        OS_SECURITY_DESCRIPTOR osNewSecDesc (psecdesc) ;
        if (err = osNewSecDesc.QueryError())
	    break ;

	BOOL fDaclPresent ;
	OS_ACL * pOsDacl ;
        if (err = osNewSecDesc.QueryDACL(&fDaclPresent, &pOsDacl))
	    break ;

	// set the new DACL
	err = pOsSecDesc->SetDACL(TRUE, pOsDacl) ;

    } while (FALSE) ;

    if ( err )
	::MsgPopup( hwndParent, (MSGID) err ) ;
    else
	((SHARE_CALLBACK_INFO *)ulCallbackContext)->fSecDescModified = TRUE ;

    return err ;
}


/*******************************************************************

    NAME:	InitializeShareGenericMapping

    SYNOPSIS:	Initializes the passed generic mapping structure
		for shares

    ENTRY:	pSHAREGenericMapping - Pointer to GENERIC_MAPPING to be init.

    EXIT:

    RETURNS:

    NOTES:	There currently is no public definition, replace if one
		ever becomes available.

    HISTORY:
	ChuckC	10-Aug-1992	Created

********************************************************************/

void InitializeShareGenericMapping( PGENERIC_MAPPING pSHAREGenericMapping )
{
    pSHAREGenericMapping->GenericRead	 = FILE_GENERIC_READ ;
    pSHAREGenericMapping->GenericWrite 	 = FILE_GENERIC_WRITE ;
    pSHAREGenericMapping->GenericExecute = FILE_GENERIC_EXECUTE ;
    pSHAREGenericMapping->GenericAll	 = FILE_ALL_ACCESS ;
}


/*******************************************************************

    NAME:	CreateDefaultAcl

    SYNOPSIS:	Create a default ACL for either a new share or for
		a share that dont exist.

    ENTRY:	

    EXIT:

    RETURNS:    NERR_Success if OK, api error otherwise.

    NOTES:	

    HISTORY:
	ChuckC	10-Aug-1992	Created

********************************************************************/

APIERR CreateDefaultAcl( OS_SECURITY_DESCRIPTOR ** ppOsSecDesc )
{
    UIASSERT(ppOsSecDesc) ;

    APIERR                   err ;
    OS_ACL                   aclDacl ;
    OS_ACE                   osace ;
    OS_SECURITY_DESCRIPTOR * pOsSecDesc ;

    *ppOsSecDesc = NULL ;   // empty it.

    do
    {        // error breakout

	/*
         * make sure we constructed OK
         */
        if ( (err = aclDacl.QueryError())  ||
             (err = osace.QueryError()) )
        {
            break ;
        }

	/*
         * create it! use NULL to mean we build it ourselves.
 	 */
	pOsSecDesc = new OS_SECURITY_DESCRIPTOR(NULL) ;
	if (pOsSecDesc == NULL)
	{
	    err = ERROR_NOT_ENOUGH_MEMORY ;
            break ;
        }
        if (err = pOsSecDesc->QueryError())
        {
            break ;
        }

        /*
         * This sets up an ACE with Generic all access
         */
        osace.SetAccessMask( GENERIC_ALL ) ;
        osace.SetInheritFlags( 0 ) ;
        osace.SetType( ACCESS_ALLOWED_ACE_TYPE ) ;

#if 0
        //
        // The server should set the owner/group before we get the security
        // descriptor so we don't need to do this anymore
        //

	/*
         * now set the group and owner to be the Administrators.
 	 * need create Adminstrators SID.
       	 */
        OS_SID ossidBuiltin ;
        if (err = NT_ACCOUNTS_UTILITY::QuerySystemSid( UI_SID_BuiltIn,
                                                       &ossidBuiltin ))
	{
	    break ;
	}
        OS_SID ossidAdmin (ossidBuiltin.QueryPSID(),
			   (ULONG)DOMAIN_ALIAS_RID_ADMINS) ;
        if (err = ossidAdmin.QueryError())
	    break ;

        if ( (err = pOsSecDesc->SetGroup( ossidAdmin, TRUE )) ||
             (err = pOsSecDesc->SetOwner( ossidAdmin, TRUE ))   )
        {
            break ;
        }
#endif
	/*
         * create a world SID, and add this to the full access ACE.
	 * then put the ACE in the ACL, and the ACL in the Security
      	 * descriptor.
	 */
        OS_SID ossidWorld ;
        if ( (err = ossidWorld.QueryError()) ||
             (err = NT_ACCOUNTS_UTILITY::QuerySystemSid(
                                                   UI_SID_World,
                                                   &ossidWorld )) ||
             (err = osace.SetSID( ossidWorld )) ||
             (err = aclDacl.AddACE( 0, osace )) ||
             (err = pOsSecDesc->SetDACL( TRUE, &aclDacl )) )
        {
            break ;
        }

	/*
         * all set, set the security descriptor
         */
        *ppOsSecDesc = pOsSecDesc ;

    } while (FALSE) ;

    return err ;
}

/*******************************************************************

    NAME:	GetSharePerm

    SYNOPSIS:	CAll the NETAPI to retrieve existing Security Descriptor
		from the Share.

    ENTRY:	

    EXIT:

    RETURNS:    NERR_Success if OK, api error otherwise.

    NOTES:	CODEWORK. This should be a LMOBJ thing when we have time.
		Currently just direct call to NETAPI.

    HISTORY:
	ChuckC	10-Aug-1992	Created

********************************************************************/
APIERR GetSharePerm (const TCHAR *	       pszServer,
		     const TCHAR *	       pszShare,
                     OS_SECURITY_DESCRIPTOR ** ppOsSecDesc )
{
#ifndef WIN32
#error This is currently NOT 16 bit compatible.
#endif
    APIERR err ;
    LPBYTE pBuffer ;
    PSECURITY_DESCRIPTOR psecdesc ;
    OS_SECURITY_DESCRIPTOR * pOsSecDesc ;

    /*
     * call API to get the security descriptor
     */
    err = NetShareGetInfo((LPTSTR) pszServer,
			  (LPTSTR) pszShare,
			  502,
			  &pBuffer) ;
    if (err != NERR_Success)
	return err ;

    if (*ppOsSecDesc)
	delete *ppOsSecDesc ;
    *ppOsSecDesc = NULL ;

    /*
     * if no such thang, just say none. we'll create later as need.
     */
    psecdesc = ((SHARE_INFO_502 *)pBuffer)->shi502_security_descriptor ;
    if (!psecdesc)
    {
        NetApiBufferFree(pBuffer) ;
 	return NERR_Success ;
    }

    do {  // error break out loop

	// create a new security descriptor
        pOsSecDesc = new OS_SECURITY_DESCRIPTOR(NULL) ;
        if (pOsSecDesc == NULL)
        {
	    err = ERROR_NOT_ENOUGH_MEMORY ;
            break ;
        }
        if (err = pOsSecDesc->QueryError())
        {
            break ;
        }

	/*
         * create alias to the security descriptor we go from the API
	 */
        OS_SECURITY_DESCRIPTOR osShareSecDesc (psecdesc) ;
        if (err = osShareSecDesc.QueryError())
	    break ;

	/*
         * make copy of it for use by security editor
	 */
	if ( (err = pOsSecDesc->Copy( osShareSecDesc )) )
	{
	    break ;
	}

    } while (FALSE) ;

    if (err == NERR_Success)
        *ppOsSecDesc = pOsSecDesc ;

    NetApiBufferFree(pBuffer) ;
    return err ;
}

/*******************************************************************

    NAME:	SetSharePerm

    SYNOPSIS:	CAll the NETAPI to set the Security Descriptor
		for the Share.

    ENTRY:	

    EXIT:

    RETURNS:    NERR_Success if OK, api error otherwise.

    NOTES:	CODEWORK. This should be a LMOBJ thing when we have time.
		Currently just direct call to NETAPI.

    HISTORY:
	ChuckC	10-Aug-1992	Created

********************************************************************/
APIERR SetSharePerm (const TCHAR *	            pszServer,
		     const TCHAR *	            pszShare,
                     const OS_SECURITY_DESCRIPTOR * pOsSecDesc )
{
#ifndef WIN32
#error This is currently NOT 16 bit compatible.
#endif
    APIERR err ;
    SHARE_INFO_1501  shareinfo1501 ;
    ::ZeroMemory(&shareinfo1501,
                 sizeof(shareinfo1501)); // JonN 01/27/00: PREFIX bug 444913

    shareinfo1501.shi1501_security_descriptor =
	pOsSecDesc->QueryDescriptor() ;

    /*
     * call API to get the security descriptor
     */
    err = NetShareSetInfo((LPTSTR) pszServer,
			  (LPTSTR) pszShare,
			  1501,
			  (LPBYTE)&shareinfo1501,
			  NULL) ;

    return err ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\shellui\share\sharestp.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**             Copyright(c) Microsoft Corp., 1991                   **/
/**********************************************************************/

/*
 *   sharestp.cxx
 *     Contain the dialog for deleting shares.
 *
 *   FILE HISTORY:
 *     Yi-HsinS         8/25/91         Created
 *     Yi-HsinS         12/15/91        Uses SHARE_NET_NAME
 *     Yi-HsinS         12/31/91        Unicode work
 *     Yi-HsinS         1/6/92          Renamed to sharestp.cxx and separated
 *                                      the create share dialogs to sharecrt.cxx
 *     Yi-HsinS         3/12/92         Added STOP_SHARING_GROUP
 *     Yi-HsinS         4/2/92          Added MayRun
 *     Yi-HsinS         8/6/92          Reorganize to match Winball
 *     Yi-HsinS         11/20/92        Added support for sticky shares
 */

#define INCL_WINDOWS_GDI
#define INCL_WINDOWS
#define INCL_DOSERRORS
#define INCL_NETERRORS
#define INCL_NETSHARE
#define INCL_NETSERVER
#define INCL_NETCONS
#define INCL_NETLIB
#include <lmui.hxx>

extern "C"
{
    #include <sharedlg.h>
    #include <helpnums.h>
    #include <winlocal.h>
    #include <mnet.h>
}

#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MSGPOPUP
#define INCL_BLT_SPIN_GROUP
#include <blt.hxx>

#include <string.hxx>
#include <uitrace.hxx>

#include <strnumer.hxx>

#include <lmoshare.hxx>
#include <lmoesh.hxx>
#include <lmoeconn.hxx>
#include <lmosrv.hxx>

#include <ctime.hxx>
#include <intlprof.hxx>

#include <strchlit.hxx>   // for string and character constants
#include "sharestp.hxx"

/*******************************************************************

    NAME:       SHARE_LBI::SHARE_LBI

    SYNOPSIS:   Listbox items used in the SHARE_LISTBOX

    ENTRY:      s2 - object returned by SHARE2_ENUM_ITER

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        1/8/92          Created

********************************************************************/

SHARE_LBI::SHARE_LBI( const SHARE2_ENUM_OBJ &s2, UINT nType )
     : _nlsShareName( s2.QueryName()),
       _nlsSharePath( s2.QueryPath()),
       _nType       ( nType )
{
    if ( QueryError() != NERR_Success )
        return;

    APIERR err;
    if (  (( err = _nlsShareName.QueryError()) != NERR_Success )
       || (( err = _nlsSharePath.QueryError()) != NERR_Success )
       )
    {
        ReportError( err );
        return;
    }
}

/*******************************************************************

    NAME:       SHARE_LBI::~SHARE_LBI

    SYNOPSIS:   Destructor

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        1/6/92          Created

********************************************************************/

SHARE_LBI::~SHARE_LBI()
{
}

/*******************************************************************

    NAME:       SHARE_LBI::QueryLeadingChar

    SYNOPSIS:   Returns the leading character of the listbox item.
                The enables shortcut keys in the listbox

    ENTRY:

    EXIT:

    RETURNS:    Returns the first char of the share name

    NOTES:

    HISTORY:
        Yi-HsinS        1/6/92          Created

********************************************************************/

WCHAR SHARE_LBI::QueryLeadingChar( VOID ) const
{
    ISTR istr( _nlsShareName );
    return _nlsShareName.QueryChar( istr );
}

/*******************************************************************

    NAME:       SHARE_LBI::Paint

    SYNOPSIS:   Redefine Paint() method of LBI class

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        1/8/92          Created
        beng            22-Apr-1992     Change to LBI::Paint

********************************************************************/

VOID SHARE_LBI::Paint( LISTBOX *plb,
                       HDC hdc,
                       const RECT *prect,
                       GUILTT_INFO *pGUILTT ) const
{

    STR_DTE strdteShareName( _nlsShareName );
    STR_DTE strdteSharePath( _nlsSharePath );

    DISPLAY_TABLE dt(3, ((SHARE_LISTBOX *) plb)->QueryColumnWidths() );
    dt[0] = _nType == DISKSHARE_TYPE
            ? ((SHARE_LISTBOX *) plb)->QueryShareBitmap()
            : ( _nType == STICKYSHARE_TYPE
                ? ((SHARE_LISTBOX *) plb)->QueryStickyShareBitmap()
                : ((SHARE_LISTBOX *) plb)->QueryIPCShareBitmap());
    dt[1] = &strdteShareName;
    dt[2] = &strdteSharePath;

    dt.Paint( plb, hdc, prect, pGUILTT );

}

/*******************************************************************

    NAME:       SHARE_LBI::Compare

    SYNOPSIS:   Redefine Compare() method of LBI class
                We compare the share names of two LBIs.

    ENTRY:      plbi - pointer to the LBI to compare with

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        1/8/92          Created

********************************************************************/
INT SHARE_LBI::Compare( const LBI *plbi ) const
{
    return( _nlsShareName._stricmp( ((const SHARE_LBI *) plbi)->_nlsShareName ));
}

/*******************************************************************

    NAME:       SHARE_LISTBOX::SHARE_LISTBOX

    SYNOPSIS:   Constructor

    ENTRY:      powin      - owner window
                cid        - resource id of the share listbox
                nShareType - The type of shares to be displayed in the listbox

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        1/20/92         Created

********************************************************************/

SHARE_LISTBOX::SHARE_LISTBOX( OWNER_WINDOW *powin, CID cid, UINT nShareType )
    : BLT_LISTBOX  ( powin, cid ),
      _pdmdte      ( NULL ),
      _pdmdteSticky( NULL ),
      _pdmdteIPC   ( NULL ),
      _nShareType  ( nShareType )
{
    if ( QueryError() != NERR_Success )
        return;

    APIERR err = ERROR_NOT_ENOUGH_MEMORY;
    if (  ((_pdmdte = new DMID_DTE( BMID_SHARE )) == NULL )
       || ((_pdmdteSticky = new DMID_DTE( BMID_STICKYSHARE )) == NULL )
       || ((_pdmdteIPC = new DMID_DTE( BMID_IPCSHARE )) == NULL )
       || ((err = _pdmdte->QueryError()) != NERR_Success )
       || ((err = _pdmdteSticky->QueryError()) != NERR_Success )
       || ((err = DISPLAY_TABLE::CalcColumnWidths( _adx, 3, powin, cid, TRUE))
           != NERR_Success )
       )
    {
        ReportError( err );
        return;
    }

}

/*******************************************************************

    NAME:       SHARE_LISTBOX::~SHARE_LISTBOX

    SYNOPSIS:   Destructor

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        1/20/92         Created

********************************************************************/

SHARE_LISTBOX::~SHARE_LISTBOX()
{
    // Delete the share bitmap
    delete _pdmdte;
    _pdmdte = NULL;

    delete _pdmdteSticky;
    _pdmdteSticky = NULL;

    delete _pdmdteIPC;
    _pdmdteIPC = NULL;
}

/*******************************************************************

    NAME:       SHARE_LISTBOX::Update

    SYNOPSIS:   Update (refresh) the shares in the listbox

    ENTRY:      pszComputer -  The computer to set focus to, will be an
                               empty string if the computer is local.


    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        1/7/92          Created

*******************************************************************/

APIERR SHARE_LISTBOX::Update( SERVER_WITH_PASSWORD_PROMPT *psvr )
{

    APIERR err = NERR_Success;
    ALIAS_STR nlsServer( psvr->QueryName() );

    DeleteAllItems();
    SetRedraw( FALSE );

    do  // Not a loop, just a way to break out in case error occurred
    {

        SHARE2_ENUM sh2Enum( nlsServer );
        if (  ((err = sh2Enum.QueryError()) != NERR_Success )
           || ((err = sh2Enum.GetInfo()) != NERR_Success )
           )
        {
            break;
        }

        //
        // First, add the shares that are created
        //
        SHARE2_ENUM_ITER shi2( sh2Enum );
        const SHARE2_ENUM_OBJ *pshi2 = NULL;

        while ( (pshi2 = shi2() ) != NULL )
        {

            UINT nCurrentShareType = pshi2->QueryType() & ~STYPE_SPECIAL;

            //
            // Filter out unwanted shares
            //
            if ( _nShareType != STYPE_ALL_SHARE )
            {
                if (!(  (  ( _nShareType & STYPE_DISK_SHARE )
                       && ( nCurrentShareType == STYPE_DISKTREE ))
                    || (  ( _nShareType & STYPE_PRINT_SHARE )
                       && ( nCurrentShareType == STYPE_PRINTQ ))
                    || (  ( _nShareType & STYPE_IPC_SHARE )
                       && ( nCurrentShareType == STYPE_IPC ))))
                {
                    continue;
                }
            }

            //
            // Add the share to the listbox
            //
            SHARE_LBI *psharelbi = new SHARE_LBI( *pshi2,
                                   nCurrentShareType == STYPE_IPC?
                                   IPCSHARE_TYPE : DISKSHARE_TYPE );
            if (  ( psharelbi == NULL )
               || ( ( err = psharelbi->QueryError() ) != NERR_Success )
               || ( AddItem( psharelbi ) < 0 )
               )
            {
                err = err? err : (APIERR) ERROR_NOT_ENOUGH_MEMORY;
                delete psharelbi;
                psharelbi = NULL;
                break;
            }
        }

        if ( !psvr->IsNT() )
            break;

        //
        // If we are focusing on NT, add the sticky shares.
        // AddItemIdemp will delete the item if it already exist in the listbox.
        //
        SHARE2_ENUM sh2EnumSticky( nlsServer, STICKYSHARE_TYPE );
        if (  ((err = sh2EnumSticky.QueryError()) != NERR_Success )
           || ((err = sh2EnumSticky.GetInfo()) != NERR_Success )
           )
        {
            break;
        }

        SHARE2_ENUM_ITER shi2Sticky( sh2EnumSticky );

        while ( (pshi2 = shi2Sticky()) != NULL )
        {
            //
            // Filter out unwanted shares
            //
            if ( _nShareType != STYPE_ALL_SHARE )
            {
                UINT nCurrentShareType = pshi2->QueryType() & ~STYPE_SPECIAL;

                if (!(  (  ( _nShareType & STYPE_DISK_SHARE )
                       && ( nCurrentShareType == STYPE_DISKTREE ))
                    || (  ( _nShareType & STYPE_PRINT_SHARE )
                       && ( nCurrentShareType == STYPE_PRINTQ ))
                    || (  ( _nShareType & STYPE_IPC_SHARE )
                       && ( nCurrentShareType == STYPE_IPC ))))
                {
                    continue;
                }
            }

            //
            // Add the sticky share to the listbox
            //
            SHARE_LBI *psharelbi = new SHARE_LBI( *pshi2, TRUE );
            if (  ( psharelbi == NULL )
               || ( ( err = psharelbi->QueryError() ) != NERR_Success )
               || ( AddItemIdemp( psharelbi ) < 0 )
               )
            {
                err = err? err : (APIERR) ERROR_NOT_ENOUGH_MEMORY;
                delete psharelbi;
                psharelbi = NULL;
                break;
            }
        }

    }
    while ( FALSE );

    Invalidate( TRUE );
    SetRedraw( TRUE );

    return err;
}

/*******************************************************************

    NAME:       VIEW_SHARE_DIALOG_BASE::VIEW_SHARE_DIALOG_BASE

    SYNOPSIS:   Constructor

    ENTRY:      pszDlgResource    - name of the dialog
                hwndParent        - handle of the parent
                nShareType        - the type of share to display
                ulHelpContextBase - the base help context

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        8/25/91         Created

********************************************************************/

VIEW_SHARE_DIALOG_BASE::VIEW_SHARE_DIALOG_BASE( const TCHAR *pszDlgResource,
                                                HWND  hwndParent,
                                                ULONG ulHelpContextBase,
                                                UINT  nShareType )
    : DIALOG_WINDOW ( pszDlgResource, hwndParent ),
      _sltShareTitle( this, SLT_SHARETITLE ),
      _lbShare      ( this, LB_SHARE, nShareType ),
      _psvr         ( NULL ),
      _ulHelpContextBase( ulHelpContextBase )
{

    if ( QueryError() != NERR_Success )
        return;
}

/*******************************************************************

    NAME:       VIEW_SHARE_DIALOG_BASE::~VIEW_SHARE_DIALOG_BASE

    SYNOPSIS:   Destructor

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        8/8/92         Created

********************************************************************/

VIEW_SHARE_DIALOG_BASE::~VIEW_SHARE_DIALOG_BASE()
{
    delete _psvr;
    _psvr = NULL;
}

/*******************************************************************

    NAME:       VIEW_SHARE_DIALOG_BASE::InitComputer

    SYNOPSIS:   Initialize the dialog and internal variables
                to focus on the selected computer

    ENTRY:      pszComputer - name of the computer to set focus on

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        8/8/92         Created

********************************************************************/

APIERR VIEW_SHARE_DIALOG_BASE::InitComputer( const TCHAR *pszComputer )
{

    APIERR err;

    do {  // not a loop

        //
        // Display the title of the listbox
        //

        LOCATION loc( pszComputer, FALSE );
        NLS_STR nlsComputer;

        if (  ((err = nlsComputer.QueryError()) != NERR_Success )
           || ((err = loc.QueryDisplayName( &nlsComputer)) != NERR_Success )
           )
        {
            break;
        }

        const NLS_STR *apnlsParams[2];
        apnlsParams[0] = (NLS_STR *) &nlsComputer;
        apnlsParams[1] = NULL;

        RESOURCE_STR nlsTitle( IDS_SHARE_LB_TITLE_TEXT );

        if (  ((err = nlsTitle.QueryError()) != NERR_Success )
           || ((err = nlsTitle.InsertParams( apnlsParams )) != NERR_Success )
           )
        {
            break;
        }

        _sltShareTitle.SetText( nlsTitle );

        //
        // Initialize the SERVER_WITH_PASSWORD_PROMPT object
        //

        LOCATION locLocal;  // local computer
        NLS_STR nlsLocalComputer;

        if ( (err = locLocal.QueryDisplayName( &nlsLocalComputer))
             != NERR_Success )
            break;

        if( !::I_MNetComputerNameCompare( nlsLocalComputer, nlsComputer ) )
            nlsComputer = EMPTY_STRING;

        _psvr = new SERVER_WITH_PASSWORD_PROMPT( nlsComputer,
                                                 QueryRobustHwnd(),
                                                 QueryHelpContextBase());

        if (  ( _psvr == NULL )
           || ((err = _psvr->QueryError() ) != NERR_Success )
           || ((err = _psvr->GetInfo() ) != NERR_Success )
           )
        {
            err = err? err: (APIERR) ERROR_NOT_ENOUGH_MEMORY;
            delete _psvr;
            _psvr = NULL;
            break;
        }

        //
        // Update the listbox and disable it if the number of items is zero
        //
        err = err? err : _lbShare.Update( _psvr );
        _lbShare.Enable( _lbShare.QueryCount() > 0 );
        _sltShareTitle.Enable( _lbShare.QueryCount() > 0 );
        if ( _lbShare.QueryCount() > 0 )
            _lbShare.ClaimFocus();

   } while ( FALSE );

   return err;

}

/*******************************************************************

    NAME:       VIEW_SHARE_DIALOG_BASE::Refresh

    SYNOPSIS:   Refresh the share listbox

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        8/8/92         Created

********************************************************************/

APIERR VIEW_SHARE_DIALOG_BASE::Refresh( VOID )
{
    AUTO_CURSOR autocur;
    UIASSERT( _psvr != NULL );

    APIERR err = _lbShare.Update( _psvr );
    _lbShare.Enable( _lbShare.QueryCount() > 0 );
    _sltShareTitle.Enable( _lbShare.QueryCount() > 0 );
    return err;
}

/*******************************************************************

    NAME:       VIEW_SHARE_DIALOG_BASE::OnCommand

    SYNOPSIS:   Check if the user double clicks on a share

    ENTRY:      event - the event that occurred

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        1/8/92          Created

********************************************************************/

BOOL VIEW_SHARE_DIALOG_BASE::OnCommand( const CONTROL_EVENT &event )
{
    APIERR err = NERR_Success;

    switch ( event.QueryCid() )
    {

        case LB_SHARE:
            if (  ( event.QueryCode() == LBN_DBLCLK )
               && ( _lbShare.QuerySelCount() > 0 )
               )
            {
                return OnShareLbDblClk();
            }
            break;

        default:
            return DIALOG_WINDOW::OnCommand( event );

    }

    return TRUE;
}

/*******************************************************************

    NAME:       VIEW_SHARE_DIALOG_BASE::StopShare

    SYNOPSIS:   Helper method to delete a share and popup any
                warning if some users are connected to the share

    ENTRY:      pszShare - the share to be deleted

    EXIT:       pfCancel - pointer to a BOOLEAN indicating whether
                           the user decided to cancel deleting the share

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        8/8/92         Created

********************************************************************/

APIERR VIEW_SHARE_DIALOG_BASE::StopShare( const TCHAR *pszShare, BOOL *pfCancel)
{

    UIASSERT( pfCancel != NULL );
    *pfCancel = FALSE;

    ALIAS_STR nlsShare( pszShare );
    ALIAS_STR nlsComputer( _psvr->QueryName() );

    APIERR err = NERR_Success;

    SHARE_2 sh2( nlsShare, nlsComputer, FALSE );


    //
    // Check if there are any users connected to the share
    //
    if (  (( err = sh2.QueryError()) == NERR_Success )
       && (( err = sh2.GetInfo()) == NERR_Success )
       && ( sh2.QueryCurrentUses() > 0 )
       )
    {

        //
        // There are users currently connected to the share to be deleted,
        // hence, popup a dialog displaying all uses to the share.
        //

        BOOL fOK = TRUE;
        CURRENT_USERS_WARNING_DIALOG *pdlg =
            new CURRENT_USERS_WARNING_DIALOG( QueryRobustHwnd(),
                                              nlsComputer,
                                              nlsShare,
                                              QueryHelpContextBase() );


        if (  ( pdlg == NULL )
           || ((err = pdlg->QueryError()) != NERR_Success )
           || ((err = pdlg->Process( &fOK )) != NERR_Success )
           )
        {
            err = err? err : (APIERR) ERROR_NOT_ENOUGH_MEMORY;
        }

        // User clicked CANCEL for the pdlg
        if ( !err && !fOK )
        {
            *pfCancel = TRUE;
        }

        delete pdlg;
    }

    if ( !err && !*pfCancel )
        err = sh2.Delete();

    return err;
}


/*******************************************************************


    NAME:       STOP_SHARING_DIALOG::STOP_SHARING_DIALOG

    SYNOPSIS:   Constructor

    ENTRY:      hwndParent        - handle of parent window
                pszSelectedDir    - the directory selected in the
                                    file manager. This will be used
                                    to determine which computer the
                                    user is currently focusing on.
                ulHelpContextBase - the base help context

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        8/25/91         Created

********************************************************************/

STOP_SHARING_DIALOG::STOP_SHARING_DIALOG( HWND hwndParent,
                                          const TCHAR *pszSelectedDir,
                                          ULONG ulHelpContextBase )
    : VIEW_SHARE_DIALOG_BASE( MAKEINTRESOURCE(IDD_SHARESTOPDLG),
                              hwndParent,
                              ulHelpContextBase,
                              STYPE_DISK_SHARE ),
      _buttonOK    ( this, IDOK ),
      _buttonCancel( this, IDCANCEL ),
      _stpShareGrp ( QueryLBShare(), &_buttonOK, &_buttonCancel )
{
    if ( QueryError() != NERR_Success )
        return;

    APIERR err;
    if (  ((err = _stpShareGrp.QueryError() ) != NERR_Success )
       || ((err = Init( pszSelectedDir ) ) != NERR_Success )
       )
    {
        if ( err == ERROR_INVALID_LEVEL )  // winball machine
            err = ERROR_NOT_SUPPORTED;
        ReportError( err );
        return;
    }

}

/*******************************************************************

    NAME:       STOP_SHARING_DIALOG::Init

    SYNOPSIS:   2nd stage constructor

    ENTRY:      pszSelectedDir - the directory selected in the
                                 file manager. This will be used
                                 to determine which computer the
                                 user is currently focusing on.

    EXIT:

    RETURNS:

    NOTES:      If no directory is selected, then the focus is
                set to the local computer.

    HISTORY:
        Yi-HsinS        4/2/92          Created

********************************************************************/

APIERR STOP_SHARING_DIALOG::Init( const TCHAR *pszSelectedDir )
{
    AUTO_CURSOR autocur;

    APIERR err;

    do {  // Not a loop

        ALIAS_STR nlsSelectedDir( pszSelectedDir );

        NLS_STR nlsServerString;
        if ((err = nlsServerString.QueryError()) != NERR_Success )
            break;

        //
        // If no file is selected, set the focus to the local computer.
        //

        if ( nlsSelectedDir.QueryTextLength() == 0 )
        {
            err = InitComputer( nlsServerString );
            break;
        }

        //
        // Get the computer the selected file/dir is on
        //

        SHARE_NET_NAME netName( pszSelectedDir, TYPE_PATH_ABS );

        if (  ((err = netName.QueryError()) != NERR_Success )
           || ((err = netName.QueryComputerName( &nlsServerString ))
               != NERR_Success )
           || ((err = InitComputer( nlsServerString )) != NERR_Success )
           )
        {
                break;
        }

        //
        // Search for share names that have paths that are the same
        // as the selected directory and then select them in the share listbox.
        //

        NLS_STR nlsPath;
        if (  (( err = nlsPath.QueryError()) != NERR_Success )
           || (( err = netName.QueryLocalPath( &nlsPath )) != NERR_Success )
           )
        {
            break;
        }

        SHARE_LISTBOX *plbShare = QueryLBShare();
        INT ilbCount = plbShare->QueryCount();
        INT iFirstSelected = -1;

        for ( INT i = 0; i < ilbCount; i++ )
        {
             SHARE_LBI *pshlbi = plbShare->QueryItem(i);

             if ( nlsPath._stricmp( *(pshlbi->QuerySharePath())) == 0 )
             {
                 if ( iFirstSelected < 0 )
                     iFirstSelected = i;
                 plbShare->SelectItem(i);
             }
        }

        if ( iFirstSelected >= 0 )
            plbShare->SetTopIndex( iFirstSelected );

        // Falls through if error occurs

    } while ( FALSE );

    if ( err == NERR_Success )
    {
        //
        // Make OK the default button if shares are selected in the listbox
        // and Cancel the default button otherwise.
        //
        SHARE_LISTBOX *plbShare = QueryLBShare();
        if ( plbShare->QuerySelCount() > 0 )
            _buttonOK.MakeDefault();
        else
            _buttonCancel.MakeDefault();

        if ( plbShare->QueryCount() == 0 )
        {
            err = IERR_NO_SHARES_ON_SERVER;
        }
    }

    return err;
}

/*******************************************************************

    NAME:       STOP_SHARING_DIALOG::OnShareLbDblClk

    SYNOPSIS:   When the user double clicks on the share,
                it's as if the user is clicking the OK button.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        8/25/91         Created

********************************************************************/

BOOL STOP_SHARING_DIALOG::OnShareLbDblClk( VOID )
{
    return OnOK();
}

/*******************************************************************

    NAME:       STOP_SHARING_DIALOG::OnOK

    SYNOPSIS:   Gather information and delete the shares selected
                in the listbox.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        8/25/91         Created

********************************************************************/

BOOL STOP_SHARING_DIALOG::OnOK( VOID )
{
    AUTO_CURSOR autocur;

    APIERR err = NERR_Success;

    SHARE_LISTBOX *plbShare = QueryLBShare();
    INT ciMax = plbShare->QuerySelCount();

    //
    //  If there are no items selected in the listbox,
    //  just dismiss the dialog.
    //
    if ( ciMax == 0 )
    {
        Dismiss( FALSE );
        return TRUE;
    }

    //
    //  Get all the items selected in the listbox
    //
    INT *paSelItems = (INT *) new BYTE[ sizeof(INT) * ciMax ];

    if ( paSelItems == NULL )
    {
        ::MsgPopup( this, ERROR_NOT_ENOUGH_MEMORY);
        return TRUE;
    }

    // JonN 01/27/00: PREFIX bug 444909
    ::ZeroMemory( paSelItems, sizeof(INT)*ciMax );

    err = plbShare->QuerySelItems( paSelItems,  ciMax );
    UIASSERT( err == NERR_Success );

    //
    //  Loop through each share that the user selects in the listbox
    //  and stop sharing the share. We will break out of the loop
    //  if any error occurred in stopping a share or if the user
    //  decides not stop sharing any share that some user is connected to.
    //
    BOOL fCancel = FALSE;
    BOOL fDeleted = FALSE;
    SHARE_LBI *pshlbi = NULL;
    for ( INT i = 0; i < ciMax; i++ )
    {
         pshlbi = plbShare->QueryItem( paSelItems[i] );
         if (NULL == pshlbi) continue; // JonN 01/27/00: PREFIX bug 444910
         if ( pshlbi->IsSticky() )
         {
             err = ::MNetShareDelSticky( QueryComputerName(),
                                         pshlbi->QueryShareName()->QueryPch(),
                                         0 );  // Reserved
         }
         else
         {
             err = StopShare( pshlbi->QueryShareName()->QueryPch(), &fCancel );
         }

         if (( err != NERR_Success ) || fCancel )
             break;
         fDeleted = TRUE;
    }

    delete paSelItems;
    paSelItems = NULL;

    //
    //  Dismiss the dialog only if everything went on smoothly or if
    //  we get an NERR_BadTransactConfig error.
    //
    if ( err != NERR_Success )
    {
        if ( err == NERR_NetNameNotFound )
        {
            ::MsgPopup( this, IERR_SHARE_NOT_FOUND, MPSEV_ERROR, MP_OK,
                        pshlbi->QueryShareName()->QueryPch());
        }
        else if ( err == NERR_BadTransactConfig )
        {
            DismissMsg( err );
        }
        else
        {
            ::MsgPopup( this, err );
        }

    }
    else if ( !fCancel )
    {
        Dismiss( TRUE );
    }

    //
    //  Refresh the listbox if some shares have already been deleted or if
    //  the error NERR_NetNameNotFound occurred.
    //
    if (( fDeleted) || ( err == NERR_NetNameNotFound) )
    {
         err = Refresh();
         if ( err != NERR_Success )
         {
             ::MsgPopup( this, err );
         }
         else
         {
             _buttonOK.Enable( plbShare->QueryCount() > 0 );
             if ( plbShare->QueryCount() > 0 )
                 plbShare->ClaimFocus();
             else
                 _buttonCancel.ClaimFocus();
         }
    }

    return TRUE;
}

/*******************************************************************

    NAME:       STOP_SHARING_DIALOG::QueryHelpContext

    SYNOPSIS:   Get the help context of the dialog

    ENTRY:

    EXIT:

    RETURNS:    Returns the help context

    NOTES:

    HISTORY:
        Yi-HsinS        8/25/91         Created

********************************************************************/

ULONG STOP_SHARING_DIALOG::QueryHelpContext( VOID )
{
    return QueryHelpContextBase() + HC_FILEMGRSTOPSHARE;
}

/*******************************************************************

    NAME:       STOP_SHARING_GROUP::STOP_SHARING_GROUP

    SYNOPSIS:   Constructor

    ENTRY:      plbShareName - pointer to share name combo box
                pbuttonOK    - pointer to the OK push button
                pbuttonCancel- pointer to the CANCEL push button

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        3/12/92         Created

********************************************************************/

STOP_SHARING_GROUP::STOP_SHARING_GROUP( SHARE_LISTBOX *plbShare,
                                        PUSH_BUTTON *pbuttonOK,
                                        PUSH_BUTTON *pbuttonCancel )
    : _plbShare     ( plbShare ),
      _pbuttonOK    ( pbuttonOK ),
      _pbuttonCancel( pbuttonCancel )
{
    UIASSERT( _plbShare );
    UIASSERT( _pbuttonOK );
    UIASSERT( _pbuttonCancel );

    _plbShare->SetGroup( this );
}

/*******************************************************************

    NAME:       STOP_SHARING_GROUP::~STOP_SHARING_GROUP

    SYNOPSIS:   Destructor

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        3/12/92         Created

********************************************************************/

STOP_SHARING_GROUP::~STOP_SHARING_GROUP()
{
    _plbShare      = NULL;
    _pbuttonOK     = NULL;
    _pbuttonCancel = NULL;
}

/*******************************************************************

    NAME:       STOP_SHARING_GROUP::OnUserAction

    SYNOPSIS:   If share name listbox box is empty,  set the default button
                to CANCEL, else set the default button to OK.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        3/12/92         Created

********************************************************************/

APIERR STOP_SHARING_GROUP::OnUserAction( CONTROL_WINDOW *pcw,
                                         const CONTROL_EVENT &e )
{
    if ( pcw == QueryLBShare() )
    {
        if ( e.QueryCode() == LBN_SELCHANGE )
        {
            if ( QueryLBShare()->QuerySelCount() > 0 )
                _pbuttonOK->MakeDefault();
            else
                _pbuttonCancel->MakeDefault();
        }
    }

    return GROUP_NO_CHANGE;
}

/*******************************************************************

    NAME:       CURRENT_USERS_WARNING_DIALOG::CURRENT_USERS_WARNING_DIALOG

    SYNOPSIS:   Constructor

    ENTRY:      hwndParent        - hwnd of Parent Window
                pszServer         - Server Name
                pszShare          - Share Name
                ulHelpContextBase - the base help context

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        8/25/91         Created

********************************************************************/

CURRENT_USERS_WARNING_DIALOG::CURRENT_USERS_WARNING_DIALOG( HWND hwndParent,
                                                    const TCHAR *pszServer,
                                                    const TCHAR *pszShare,
                                                    ULONG ulHelpContextBase )
    : DIALOG_WINDOW( IDD_SHAREUSERSWARNINGDLG, hwndParent ),
      _sltShareText( this, SLT_SHARE_TEXT ),
      _lbUsers( this, LB_USERS ),
      _ulHelpContextBase( ulHelpContextBase )
{
    if ( QueryError() != NERR_Success )
        return;

    UIASSERT( pszShare );

    APIERR err;

    ALIAS_STR nlsShare( pszShare );
    RESOURCE_STR nlsShareText( IDS_SHARE_CURRENT_USERS_TEXT );
    if (( err = nlsShareText.InsertParams( nlsShare )) != NERR_Success )
    {
        ReportError( err );
        return;
    }

    _sltShareText.SetText( nlsShareText );

    //
    // Gather all connections to the share that the user wants to delete.
    //
    CONN1_ENUM c1( (TCHAR *) pszServer, (TCHAR *) pszShare );
    if (  ((err = c1.QueryError()) != NERR_Success )
       || ((err = c1.GetInfo()) != NERR_Success )
       )
    {
        ReportError( err );
        return;
    }

    CONN1_ENUM_ITER ci1( c1 );
    const CONN1_ENUM_OBJ *pci1;

    _lbUsers.SetRedraw( FALSE );

    while ( ( pci1 = ci1() ) != NULL)
    {
        USERS_LBI *puserslbi = new USERS_LBI( *pci1 );
        if (  ( puserslbi == NULL )
           || ( (err = puserslbi->QueryError()) != NERR_Success )
           || ( _lbUsers.AddItem( puserslbi ) < 0 )
           )
        {
            //
            // If err is still NERR_Success, set it to ERROR_NOT_ENOUGH_MEMORY
            // ( either allocation failed or failed to add it in list box )
            //
            err = err? err: (APIERR) ERROR_NOT_ENOUGH_MEMORY;
            delete puserslbi;
            puserslbi = NULL;
            ReportError( err );
            return;
        }
    }

    _lbUsers.Invalidate( TRUE );
    _lbUsers.SetRedraw( TRUE );
}

/*******************************************************************

    NAME:       CURRENT_USERS_WARNING_DIALOG::QueryHelpContext

    SYNOPSIS:   Get the help context of the dialog

    ENTRY:

    EXIT:

    RETURNS:    Returns the help context

    NOTES:

    HISTORY:
        Yi-HsinS        8/25/91         Created

********************************************************************/

ULONG CURRENT_USERS_WARNING_DIALOG::QueryHelpContext( VOID )
{
    return _ulHelpContextBase + HC_CURRENTUSERSWARNING;
}

/*******************************************************************

    NAME:       USERS_LISTBOX::USERS_LISTBOX

    SYNOPSIS:   Constructor - list box used in CURRENT_USERS_WARNING_DIALOG

    ENTRY:      powin - owner window
                cid   - resource id of the listbox

    EXIT:

    RETURNS:

    NOTES:      This is a read-only listbox.

    HISTORY:
        Yi-HsinS        1/21/92         Created

********************************************************************/

USERS_LISTBOX::USERS_LISTBOX( OWNER_WINDOW *powin, CID cid )
    : BLT_LISTBOX( powin, cid, TRUE )   // ReadOnly Listbox
{
    if ( QueryError() != NERR_Success )
        return;

    APIERR err;
    if ( (err = DISPLAY_TABLE::CalcColumnWidths( _adx, 3, powin, cid, FALSE))
         != NERR_Success )
    {
        ReportError( err );
        return;
    }
}

/*******************************************************************

    NAME:       USERS_LBI::USERS_LBI

    SYNOPSIS:   List box items used in CURRENT_USERS_WARNING_DIALOG

    ENTRY:      c1 - connection_info_1 returned by NetConnectionEnum

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        8/25/91         Created

********************************************************************/

USERS_LBI::USERS_LBI( const CONN1_ENUM_OBJ &c1 )
    : _nlsUserName( c1.QueryUserName() ),
      _usNumOpens( c1.QueryNumOpens() ),
      _ulTime( c1.QueryTime() )
{
    if ( QueryError() != NERR_Success )
        return;

    APIERR err;
    if ( ( err = _nlsUserName.QueryError())  != NERR_Success )
    {
        ReportError( err );
        return;
    }
}

/*******************************************************************

    NAME:       USERS_LBI::~USERS_LBI

    SYNOPSIS:   Destructor

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        8/25/91         Created

********************************************************************/

USERS_LBI::~USERS_LBI()
{
}

/*******************************************************************

    NAME:       USERS_LBI::Paint

    SYNOPSIS:   Redefine Paint() method of LBI class

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        8/25/91         Created
        beng            6-Apr-1992      Removed wsprintf
        beng            22-Apr-1992     Change to LBI::Paint

********************************************************************/

VOID USERS_LBI::Paint( LISTBOX *plb,
                       HDC hdc,
                       const RECT *prect,
                       GUILTT_INFO *pGUILTT ) const
{

    APIERR err;
    DEC_STR nlsNumOpens( _usNumOpens );
    NLS_STR nlsTime;

    if (  ((err = nlsNumOpens.QueryError()) != NERR_Success )
       || ((err = nlsTime.QueryError()) != NERR_Success )
       || ((err = ConvertTime( _ulTime, &nlsTime )) != NERR_Success )
       )
    {
        ::MsgPopup( plb->QueryOwnerHwnd(), err);
        return;
    }


    STR_DTE strdteUserName( _nlsUserName );
    STR_DTE strdteNumOpens( nlsNumOpens );
    STR_DTE strdteTime( nlsTime );

    DISPLAY_TABLE dt(3, ((USERS_LISTBOX *) plb)->QueryColumnWidths() );
    dt[0] = &strdteUserName;
    dt[1] = &strdteNumOpens;
    dt[2] = &strdteTime;

    dt.Paint( plb, hdc, prect, pGUILTT );

}

/*******************************************************************

    NAME:       USERS_LBI::ConvertTime

    SYNOPSIS:   Convert the time given from ULONG (seconds) to a string
                to be shown. It complies with the internationalization
                of time using INTL_PROFILE.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        8/25/91         Created

********************************************************************/

#define SECONDS_PER_DAY    86400
#define SECONDS_PER_HOUR    3600
#define SECONDS_PER_MINUTE    60

APIERR USERS_LBI::ConvertTime( ULONG ulTime, NLS_STR *pnlsTime)  const
{
    INTL_PROFILE intlProf;

    INT nDay = (INT) ulTime / SECONDS_PER_DAY;
    ulTime %= SECONDS_PER_DAY;
    INT nHour = (INT) ulTime / SECONDS_PER_HOUR;
    ulTime %= SECONDS_PER_HOUR;
    INT nMinute = (INT) ulTime / SECONDS_PER_MINUTE;
    INT nSecond = (INT) ulTime % SECONDS_PER_MINUTE;


    return intlProf.QueryDurationStr( nDay, nHour, nMinute,
                                      nSecond, pnlsTime);
}

/*******************************************************************

    NAME:       USERS_LBI::Compare

    SYNOPSIS:   Redefine Compare() method of LBI class

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        8/25/91         Created

********************************************************************/

INT USERS_LBI::Compare( const LBI *plbi ) const
{
    return( _nlsUserName._stricmp( ((const USERS_LBI *) plbi)->_nlsUserName ));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\shellui\share\sharethk.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**             Copyright(c) Microsoft Corp., 1991                   **/
/**********************************************************************/

/*
 *   thunk.cxx
 *     Contains dialogs called by the wfw thunk DLL.
 *     For deleting and creating shares.
 *
 *   FILE HISTORY:
 *     ChuckC           3/25/93         Created
 *
 */


#define INCL_WINDOWS
#define INCL_NETERRORS
#define INCL_NETSHARE
#define INCL_NETSERVER
#include <lmui.hxx>

extern "C"
{
    #include <helpnums.h>
    #include <sharedlg.h>
}

#define INCL_BLT_MSGPOPUP
#define INCL_BLT_SPIN_GROUP
#include <blt.hxx>

#include <lmoshare.hxx>
#include <lmoesh.hxx>
#include <lmoeconn.hxx>
#include <wnetdev.hxx>

#include "sharestp.hxx"
#include "sharecrt.hxx"

/*******************************************************************

    NAME:       ShareAsDialogA0

    SYNOPSIS:   dialog for creating shares

    ENTRY:      hwnd  - hwnd of the parent window
                nType - type of share (currently must be disk)
                pszPath - directory to share

    EXIT:

    RETURNS:

    NOTES:      CODEWORK: the help context here is relative to our
                          normal winfile stuff. at this late stage,
                          it is too late to add new help for something
                          that most likely is never used. as it is, any
                          app that calls this internal API will still
                          get help, just that it piggybacks on top of winfile.


    HISTORY:
        ChuckC          3/25/93         Stole from sharefmx

********************************************************************/

DWORD ShareAsDialogA0( HWND    hwnd,
                       DWORD   nType,
                       CHAR    *pszPath)
{
    APIERR err = NERR_Success;

    if (nType != RESOURCETYPE_DISK)
        return ERROR_NOT_SUPPORTED ;

    if ( err = ::InitShellUI() )
        return err;

    ULONG ulOldHelpContextBase = POPUP::SetHelpContextBase( HC_UI_SHELL_BASE );

    //
    // Get the selected item passed in
    //
    NLS_STR nlsSelItem;
    SERVER_WITH_PASSWORD_PROMPT *psvr = NULL;

    if ((err = nlsSelItem.MapCopyFrom(pszPath)) == NERR_Success )
    {

        BOOL fShared = FALSE;

        //
        // If a file/directory is selected, check to see if the directory
        // (the directory the file is in if a file is selected)
        // is shared or not. If we select a file/directory on a LM2.1
        // share level server, a dialog will prompt for password to the
        // ADMIN$ share if we don't already have a connection to it.
        //
        if ( nlsSelItem.QueryTextLength() != 0 )
        {
            AUTO_CURSOR autocur;
            NET_NAME netname( nlsSelItem, TYPE_PATH_ABS );
            NLS_STR nlsLocalPath;
            NLS_STR nlsServer;

            if (  ((err = netname.QueryError()) == NERR_Success )
               && ((err = nlsLocalPath.QueryError()) == NERR_Success )
               && ((err = nlsServer.QueryError()) == NERR_Success )
               )
            {
                BOOL fLocal = netname.IsLocal( &err );
                if (  ( err == NERR_Success )
                   && ( fLocal
                      || ((err = netname.QueryComputerName(&nlsServer))
                          == NERR_Success)
                      )
                   )

                {
                    psvr = new SERVER_WITH_PASSWORD_PROMPT( nlsServer,
                                                            hwnd,
                                                            HC_UI_SHELL_BASE );
                    if (  ( psvr != NULL )
                       && ((err = psvr->QueryError()) == NERR_Success )
                       && ((err = psvr->GetInfo()) == NERR_Success )
                       && ((err = netname.QueryLocalPath(&nlsLocalPath))
                          ==NERR_Success)
                       )
                    {
                        //
                        // Check to see if the directory is shared
                        //
                        SHARE2_ENUM sh2Enum( nlsServer );
                        if (  ((err = sh2Enum.QueryError()) == NERR_Success )
                           && ((err = sh2Enum.GetInfo()) == NERR_Success )
                           )
                        {
                            SHARE_NAME_WITH_PATH_ENUM_ITER shPathEnum(sh2Enum,
                                                                  nlsLocalPath);

                            if ((err = shPathEnum.QueryError()) == NERR_Success)
                            {
                                const TCHAR *pszShare;
                                while ((pszShare = shPathEnum()) != NULL )
                                {
                                    fShared = TRUE;
                                    break;
                                }
                            }
                        }
                    }
                    else
                    {
                        if ( psvr == NULL )
                            err = ERROR_NOT_ENOUGH_MEMORY;
                    }
                }
             }
        }

        if ( err == NERR_Success )
        {
            //
            //  If the directory is shared, popup the share properties
            //  dialog. If not, popup the new share dialog.
            //

            SHARE_DIALOG_BASE *pdlg;
            if ( !fShared )
                pdlg = new FILEMGR_NEW_SHARE_DIALOG( hwnd,
                                                     nlsSelItem,
                                                     HC_UI_SHELL_BASE );
            else
                pdlg = new FILEMGR_SHARE_PROP_DIALOG( hwnd,
                                                      nlsSelItem,
                                                      HC_UI_SHELL_BASE );

            err = (APIERR) ( pdlg == NULL? ERROR_NOT_ENOUGH_MEMORY
                                         : pdlg->QueryError());

            if ( err == NERR_Success)
            {
                BOOL fSucceeded;
                err = pdlg->Process( &fSucceeded );

                //
                // Refresh the file manager if successfully created a share
                //
                if (( err == NERR_Success ) && fSucceeded )
                {
                    delete psvr;
                    psvr = NULL;
                }
            }

            delete pdlg;
        }

    }

    delete psvr;
    psvr = NULL;

    if ( err != NERR_Success )
    {
        if ( err == ERROR_INVALID_LEVEL )
            err = ERROR_NOT_SUPPORTED;
        else if ( err == IERR_USER_CLICKED_CANCEL )
            err = NERR_Success;

        if ( err != NERR_Success )
            ::MsgPopup( hwnd, err );
    }

    POPUP::SetHelpContextBase( ulOldHelpContextBase );
    return NERR_Success;
}

/*******************************************************************

    NAME:       StopShareDialogA0

    SYNOPSIS:   dialog for deleting shares

    ENTRY:      hwnd  - hwnd of the parent window
                nType - type of share (currently must be disk)
                pszPath - directory to stop share

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        ChuckC        3/25/93            Stole from sharefmx.cxx

********************************************************************/

DWORD StopShareDialogA0( HWND    hwnd,
                         DWORD   nType,
                         CHAR    *pszPath)
{
    APIERR err = NERR_Success;

    if (nType != RESOURCETYPE_DISK)
        return ERROR_NOT_SUPPORTED ;

    if ( err = ::InitShellUI() )
        return err;

    ULONG ulOldHelpContextBase = POPUP::SetHelpContextBase( HC_UI_SHELL_BASE );

    //
    // use the item passed in
    //
    NLS_STR nlsSelItem;
    if ( (err = nlsSelItem.MapCopyFrom(pszPath)) == NERR_Success )
    {
        //
        // Show the stop sharing dialog
        //
        STOP_SHARING_DIALOG *pdlg = new STOP_SHARING_DIALOG( hwnd,
                                                             nlsSelItem,
                                                             HC_UI_SHELL_BASE );
        err = (APIERR) ( pdlg == NULL? ERROR_NOT_ENOUGH_MEMORY
                                     : pdlg->QueryError() );
        BOOL fSucceeded;
        if ( err == NERR_Success )
            err = pdlg->Process( &fSucceeded );

        delete pdlg;
    }

    if ( err != NERR_Success )
    {
        if (err == IERR_USER_CLICKED_CANCEL)
            err = NERR_Success;
        else
            ::MsgPopup( hwnd, err );
    }

    POPUP::SetHelpContextBase( ulOldHelpContextBase );
    return NERR_Success;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\shellui\share\sharemgt.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**             Copyright(c) Microsoft Corp., 1992                   **/
/**********************************************************************/

/*
 *   sharemgt.cxx
 *     Contains the dialog for managing shares in the server manager
 *       SHARE_MANAGEMENT_DIALOG
 *
 *   FILE HISTORY:
 *     Yi-HsinS         1/6/92          Created
 *     Yi-HsinS         3/12/92         Fixed behaviour of default buttons
 *                                      and added SEL_SRV_ONLY flag to
 *                                      STANDALONE_SET_FOCUS_DIALOG.
 *     Yi-HsinS         4/2/92          Added MayRun
 *     Yi-HsinS         5/20/92         Added call to IsValid on when Add
 *                                      Share button is pressed.
 *     Yi-HsinS         8/6/92          Reorganize to match Winball
 *     Yi-HsinS         11/20/92        Added support for sticky shares
 *
 */

#define INCL_WINDOWS_GDI
#define INCL_WINDOWS
#define INCL_DOSERRORS
#define INCL_NETERRORS
#define INCL_NETSERVER
#define INCL_NETWKSTA
#define INCL_NETSHARE
#define INCL_NETCONS
#define INCL_NETLIB
#define INCL_ICANON
#include <lmui.hxx>

extern "C"
{
    #include <sharedlg.h>
    #include <helpnums.h>
    #include <mnet.h>
}

#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MSGPOPUP
#define INCL_BLT_SPIN_GROUP
#include <blt.hxx>

#include <string.hxx>
#include <uitrace.hxx>

#include <lmoshare.hxx>
#include <lmoesh.hxx>
#include <lmoeconn.hxx>
#include <lmosrv.hxx>
#include <lmowks.hxx>

#include <strchlit.hxx>   // for string and character constants
#include "sharemgt.hxx"

/*******************************************************************

    NAME:       SHARE_MANAGEMENT_DIALOG::SHARE_MANAGEMENT_DIALOG

    SYNOPSIS:   Constructor

    ENTRY:      hwndParent        - hwnd of the parent window
                pszComputer       - name of the selected computer
                ulHelpContextBase - the base help context

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        1/6/92          Created

********************************************************************/

SHARE_MANAGEMENT_DIALOG::SHARE_MANAGEMENT_DIALOG( HWND hwndParent,
                                                  const TCHAR *pszComputer,
                                                  ULONG ulHelpContextBase )
    : VIEW_SHARE_DIALOG_BASE( MAKEINTRESOURCE(IDD_SHAREMANAGEMENTDLG),
                              hwndParent,
                              ulHelpContextBase,
                              STYPE_DISK_SHARE | STYPE_IPC_SHARE ),
      _buttonStopSharing( this, BUTTON_STOPSHARING ),
      _buttonShareInfo  ( this, BUTTON_SHAREINFO ),
      _buttonClose      ( this, IDOK )
{
    if ( QueryError() != NERR_Success )
        return;

    UIASSERT( pszComputer != NULL );

    APIERR err;
    if ((err = Init( pszComputer )) != NERR_Success )
    {
        ReportError( err );
        return;
    }

}

/*******************************************************************

    NAME:       SHARING_MANAGEMENT_DIALOG::Init

    SYNOPSIS:   Initialize all information displayed in the dialog

    ENTRY:      pszComputer - the name of the computer we are focusing on

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        4/2/92          Created

********************************************************************/

APIERR SHARE_MANAGEMENT_DIALOG::Init( const TCHAR *pszComputer )
{
    AUTO_CURSOR autocur;

    //
    // Update the listbox and the title of the listbox
    //
    APIERR err = InitComputer( pszComputer );
    ResetControls();
    return err;
}

/*******************************************************************

    NAME:       SHARE_MANAGEMENT_DIALOG::Refresh

    SYNOPSIS:   Refresh the share listbox

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        1/7/92          Created

********************************************************************/

APIERR SHARE_MANAGEMENT_DIALOG::Refresh( VOID )
{
    APIERR err = VIEW_SHARE_DIALOG_BASE::Refresh();
    ResetControls();
    return err;
}

/*******************************************************************

    NAME:       SHARE_MANAGEMENT_DIALOG::ResetControls

    SYNOPSIS:   Enable/Disable/MakeDefault the push buttons according
                to whether there are items in the listbox

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        1/8/92          Created

********************************************************************/

VOID SHARE_MANAGEMENT_DIALOG::ResetControls( VOID )
{
    INT nCount = QueryLBShare()->QueryCount();

    //
    // If there are items in the listbox, select the first one
    // and set focus to the listbox.
    //
    if ( nCount > 0 )
    {
        QueryLBShare()->SelectItem( 0 );
        QueryLBShare()->ClaimFocus();
        // JonN 01/27/99: PREFIX bug 444908
        _buttonShareInfo.Enable(   NULL != QueryLBShare()->QueryItem()
                                && !QueryLBShare()->QueryItem()->IsSticky());
    }
    //
    // Else set focus to the Close button
    //
    else
    {
        _buttonClose.MakeDefault();
        _buttonClose.ClaimFocus();
        _buttonShareInfo.Enable( FALSE );
    }

    //
    // Disable the stop sharing buttons if there are no
    // items in the listbox
    //
    _buttonStopSharing.Enable( nCount > 0 );
}

/*******************************************************************

    NAME:       SHARE_MANAGEMENT_DIALOG::OnCommand

    SYNOPSIS:   Handle all push buttons commands

    ENTRY:      event - the CONTROL_EVENT that occurred

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        1/8/92          Created

********************************************************************/
BOOL SHARE_MANAGEMENT_DIALOG::OnCommand( const CONTROL_EVENT &event )
{
    APIERR err = NERR_Success;

    switch ( event.QueryCid() )
    {
        case LB_SHARE:
            if ( event.QueryCode() == LBN_SELCHANGE )
            {
                if ( QueryLBShare()->QueryCount() > 0 )
                    _buttonShareInfo.Enable( !QueryLBShare()->QueryItem()->IsSticky());
            }
            else
            {
                return VIEW_SHARE_DIALOG_BASE::OnCommand( event );
            }
            break;

        case BUTTON_STOPSHARING:
            err = OnStopSharing();
            break;

        case BUTTON_SHAREINFO:
            err = OnShareInfo();
            break;

        case BUTTON_ADDSHARE:
            err = OnAddShare();
            break;

        default:
            return VIEW_SHARE_DIALOG_BASE::OnCommand( event );

    }

    if ( err != NERR_Success )
        ::MsgPopup( this, err );

    return TRUE;

}

/*******************************************************************

    NAME:       SHARE_MANAGEMENT_DIALOG::OnStopSharing

    SYNOPSIS:   Called when the "Stop Sharing" button is pressed.
                Delete the selected share and pop up any warning
                message if there are users connected to the share.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        1/8/92          Created

********************************************************************/
APIERR SHARE_MANAGEMENT_DIALOG::OnStopSharing( VOID )
{
    AUTO_CURSOR autocur;

    SHARE_LISTBOX *plbShare = QueryLBShare();
    SHARE_LBI *pshlbi = plbShare->QueryItem();

    //
    // Stop sharing the selected item in the listbox
    //
    BOOL fCancel = FALSE;
    APIERR err;
    if ( pshlbi && pshlbi->IsSticky() ) // JonN 01/27/99 PREFIX bug 444912
    {
        err = ::MNetShareDelSticky( QueryComputerName(),
                                    pshlbi->QueryShareName()->QueryPch(),
                                    0 );  // Reserved
    }
    else
    {
        err = StopShare( *(pshlbi->QueryShareName()), &fCancel );
    }

    if ( err != NERR_Success )
    {
        ::MsgPopup( this, err );
    }

    //
    // If the user successfully deleted the share or if the error
    // from deleting the share is NERR_NetNameNotFound, refresh the
    // listbox to reflect the latest information.
    //
    APIERR err1 = NERR_Success;
    if (  (!fCancel && (err == NERR_Success )) // successfully deleted a share
       || ( err == NERR_NetNameNotFound )
       )
    {
        err1 = Refresh();
    }

    return err1;
}

/*******************************************************************

    NAME:       SHARING_MANAGEMENT_DIALOG::OnAddShare

    SYNOPSIS:   Called when the "New Share" button is pressed.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        4/2/92          Created

********************************************************************/

APIERR SHARE_MANAGEMENT_DIALOG::OnAddShare( VOID )
{
    APIERR err = NERR_Success; // JonN 01/27/00 PREFIX bug 444911

    SVRMGR_NEW_SHARE_DIALOG *pdlg =
        new SVRMGR_NEW_SHARE_DIALOG( QueryRobustHwnd(),
				     QueryServer2(),
				     QueryHelpContextBase() );

    BOOL fSucceeded;
    if (  ( pdlg == NULL )
       || ((err = pdlg->QueryError()) != NERR_Success )
       || ((err = pdlg->Process( &fSucceeded )) != NERR_Success )
       )
    {
        err = err ? err : (APIERR) ERROR_NOT_ENOUGH_MEMORY;
        ::MsgPopup( this, err );
    }

    delete pdlg;
    pdlg = NULL;

    //
    // If the user succeeded in creating a new share,
    // refresh the share listbox.
    //
    return ( fSucceeded? Refresh() : NERR_Success );
}

/*******************************************************************

    NAME:       SHARE_MANAGEMENT_DIALOG::OnShareInfo

    SYNOPSIS:   Called when the "Properties" button is pressed.
                Will pop up a dialog showing the properties of the
                selected share.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        1/8/92          Created

********************************************************************/

APIERR SHARE_MANAGEMENT_DIALOG::OnShareInfo( VOID )
{

    APIERR err = NERR_Success;

    SHARE_LISTBOX *plbShare = QueryLBShare();
    SHARE_LBI *pshlbi = plbShare->QueryItem();

    SVRMGR_SHARE_PROP_DIALOG *pdlg =
        new SVRMGR_SHARE_PROP_DIALOG( QueryRobustHwnd(),
                                      QueryServer2(),
                                      *(pshlbi->QueryShareName()),
				      QueryHelpContextBase() );
    BOOL fChanged;
    if (  ( pdlg == NULL )
       || ((err = pdlg->QueryError()) != NERR_Success )
       || ((err = pdlg->Process( &fChanged )) != NERR_Success )
       )
    {
        err = err ? err : (APIERR) ERROR_NOT_ENOUGH_MEMORY;
    }

    delete pdlg;
    pdlg = NULL;

    //
    // If the user successfully change the path of the share or if
    // the error from getting the share properties is NERR_NetNameNotFound,
    // refresh the listbox to reflect the latest information.
    //
    if (  (( err == NERR_Success) && fChanged )
       || ( err == NERR_NetNameNotFound )
       )
    {
        APIERR err1 = Refresh();
        err = err? err : err1;
    }

    plbShare->ClaimFocus();
    return err;
}

/*******************************************************************

    NAME:       SHARE_MANAGEMENT_DIALOG::OnShareLbDblClk

    SYNOPSIS:   This is called when the user double clicks on a share
                in the listbox. Will pop up a dialog showing the
                properties of the selected share.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        1/8/92          Created

********************************************************************/

BOOL SHARE_MANAGEMENT_DIALOG::OnShareLbDblClk( VOID )
{
    APIERR err = OnShareInfo();
    if ( err != NERR_Success )
        ::MsgPopup( this, err );

    return TRUE;
}

/*******************************************************************

    NAME:       SHARE_MANAGEMENT_DIALOG::QueryHelpContext

    SYNOPSIS:   Query the help context of the dialog

    ENTRY:

    EXIT:

    RETURNS:    Return the help context of the dialog

    NOTES:

    HISTORY:
        Yi-HsinS        1/6/92          Created

********************************************************************/

ULONG SHARE_MANAGEMENT_DIALOG::QueryHelpContext( VOID )
{
    return QueryHelpContextBase() + HC_SVRMGRSHAREMANAGEMENT;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\shellui\share\sharebas.cxx ===
/**********************************************************************/
/**			  Microsoft Windows NT	 		     **/
/**		Copyright(c) Microsoft Corp., 1991  		     **/
/**********************************************************************/

/*
 *  sharebas.cxx
 *    This file contains the definitions of base share dialog class,
 *    and some common classes used by the share dialogs,
 *    including SHARE_DIALOG_BASE, SHARE_LEVEL_PERMISSIONS_DIALOG,
 *    PERMISSION_GROUP, SHARE_NAME_WITH_PATH_ENUM_ITER,
 *    SERVER_WITH_PASSWORD_PROMPT and SHARE_NET_NAME.
 *
 *  History:
 *    Yi-HsinS	8/15/91		Created
 *    Yi-HsinS	11/15/91	Changed all USHORT to UINT
 *    Yi-HsinS	12/5/91	        Test more thoroughly for invalid
 *				path name
 *    Yi-HsinS	12/6/91	        Uses NET_NAME
 *    Yi-HsinS	12/31/91	Unicode work
 *    Yi-HsinS	1/8/92		Moved SHARE_PROPERTIES_BASE to
 *				sharewnp.cxx
 *    Yi-HsinS	3/12/92		Added ACCESS_PERM to PERMISSIONS_GROUP
 *    Terryk	4/12/92		Change USER limit from UINT to ULONG
 *    Yi-HsinS	4/21/92		Remove unnecessay code, and remove
 *			        _uiSpecialUserLimit
 *    Yi-HsinS	5/15/92		Make password dialog show up only if
 *                              focus on share-level servers
 *    Yi-HsinS  8/6/92          Reorganize to match Winball dialogs.
 *    ChuckC    8/12/92         Added support for ACLs on Shares.
 *    Yi-HsinS	11/16/92	Removed SLT_ADMININFO
 *    YiHsinS	4/2/93          Disable viewing/changing permission on special
 *                              shares ( [A-Z]$, IPC$, ADMIN$ )
 */

#define INCL_WINDOWS_GDI
#define INCL_WINDOWS
#define INCL_DOSERRORS
#define INCL_NETERRORS
#define INCL_NETSHARE
#define INCL_NETSERVER
#define INCL_NETWKSTA
#define INCL_NETLIB
#include <lmui.hxx>

extern "C"
{
    #include <sharedlg.h>
    #include <helpnums.h>
}

#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MSGPOPUP
#define INCL_BLT_SPIN_GROUP
#define INCL_BLT_GROUP
#include <blt.hxx>

#include <string.hxx>
#include <uitrace.hxx>
#include <dbgstr.hxx>

#include <lmoesh.hxx>
#include <lmoeusr.hxx>
#include <lmosrv.hxx>
#include <lmoshare.hxx>
#include <lmowks.hxx>

#include <strchlit.hxx>   // for string and character constants
#include "sharebas.hxx"
#include <shareacl.hxx>   // for the function prototypes

#define	USERS_DEFAULT	  10
#define USERS_MIN  	  1
#define PERM_DEFAULT_LEN  7        // length of "RWCXDAP"

/*******************************************************************

    NAME:	SHARE_DIALOG_BASE::SHARE_DIALOG_BASE

    SYNOPSIS:   Constructor for SHARE_DIALOG_BASE class

    ENTRY:      pszDlgResource - resource name for DIALOG_WINDOW
                hwndParent     - handle of parent window
		ulMaxUserLimit - the maximum user limit to be set
				 in the user limit spin button
                ulHelpContextBase - the base help context

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	Yi-HsinS	8/15/91		Created
	Yi-HsinS        1/17/91         Added  _uiSpecialUserLimit
	Yi-HsinS        4/25/91         Remove _uiSpecialUserLimit
        Yi-HsinS        10/9/92         Added  _ulHelpContextBase

********************************************************************/

SHARE_DIALOG_BASE::SHARE_DIALOG_BASE( const TCHAR *pszDlgResource,
                                      HWND hwndParent,
                                      ULONG ulHelpContextBase,
				      ULONG ulMaxUserLimit )
    : DIALOG_WINDOW ( pszDlgResource, hwndParent ),
      _slePath( this, SLE_PATH ),
      _sleComment( this, SLE_COMMENT, SHARE_COMMENT_LENGTH ),
      _mgrpUserLimit( this, RB_UNLIMITED, 2, RB_UNLIMITED), // 2 buttons
          _spsleUsers( this, SLE_USERS, USERS_DEFAULT,
                       USERS_MIN, ulMaxUserLimit - USERS_MIN + 1, TRUE,
                       FRAME_USERS ),
          _spgrpUsers( this, SB_USERS_GROUP, SB_USERS_UP, SB_USERS_DOWN),
      _buttonOK( this, IDOK ),
      _buttonCancel( this, IDCANCEL ),
      _buttonPermissions( this, BUTTON_PERMISSIONS ),
      _pStoredSecDesc( NULL ),         // default : NULL
      _fSecDescModified( FALSE ),      // initially unchanged
      _nlsStoredPassword(),            // default : empty string
      _uiStoredPermissions( ACCESS_READ | ACCESS_EXEC ),  // default permission
      _fStoredAdminOnly( FALSE ),
      _ulHelpContextBase( ulHelpContextBase )
{

    if ( QueryError() != NERR_Success )
        return;

    APIERR err;
    if (  ((err = _mgrpUserLimit.QueryError()) != NERR_Success )
       || ((err = _spgrpUsers.AddAssociation( &_spsleUsers )) != NERR_Success )
       || ((err = _mgrpUserLimit.AddAssociation( RB_USERS, &_spgrpUsers ))
	          != NERR_Success )
       || ((err = _nlsStoredPassword.QueryError()) != NERR_Success )
       )
    {
        ReportError( err );
        return;
    }

}

/*******************************************************************

    NAME:	SHARE_DIALOG_BASE::~SHARE_DIALOG_BASE

    SYNOPSIS:   Destructor for SHARE_DIALOG_BASE class

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	Yi-HsinS	8/15/91		Created

********************************************************************/

SHARE_DIALOG_BASE::~SHARE_DIALOG_BASE()
{
    delete _pStoredSecDesc;
    memsetf((LPVOID)_nlsStoredPassword.QueryPch(),
            0,
            _nlsStoredPassword.QueryTextSize()) ;
    _pStoredSecDesc = NULL;
}

/*******************************************************************

    NAME:	SHARE_DIALOG_BASE::ClearStoredInfo

    SYNOPSIS:   Clear the permission or security description stored
                internally.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	Yi-HsinS	8/6/92		Created

********************************************************************/

APIERR SHARE_DIALOG_BASE::ClearStoredInfo( VOID )
{
    delete _pStoredSecDesc;
    _pStoredSecDesc = NULL;

    _nlsStoredPassword = EMPTY_STRING;
    _uiStoredPermissions = ACCESS_READ | ACCESS_EXEC;

    return _nlsStoredPassword.QueryError();
}

/*******************************************************************

    NAME:	SHARE_DIALOG_BASE::UpdateInfo

    SYNOPSIS:   Set the information about the share in the dialog

    ENTRY:      psvr     - pointer to the server object that the share is on
                pszShare - the share to display

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	Yi-HsinS	8/15/91		Created

********************************************************************/

APIERR SHARE_DIALOG_BASE::UpdateInfo( SERVER_WITH_PASSWORD_PROMPT *psvr,
                                      const TCHAR *pszShare )
{
    AUTO_CURSOR autocur;

    UIASSERT( psvr != NULL );
    UIASSERT( pszShare != NULL );

    APIERR err;
    SHARE_2 sh2( pszShare, psvr->QueryName(), FALSE );

    if (  ((err = sh2.QueryError() ) == NERR_Success )
       && ((err = sh2.GetInfo()) == NERR_Success )
       )
    {
        if (   _slePath.QueryTextLength() == 0
            && NULL != sh2.QueryPath() ) // JonN 01/27/00: PREFIX bug 444916
            SetPath( sh2.QueryPath() );
        SetComment( sh2.QueryComment() );
        SetUserLimit( sh2.QueryMaxUses() );

        err = UpdatePermissionsInfo( psvr, &sh2, pszShare );
    }

    return err;
}

/*******************************************************************

    NAME:	SHARE_DIALOG_BASE::UpdatePermissionsInfo

    SYNOPSIS:   Set the permissions information about the share

    ENTRY:      psvr     - pointer to the server object that the share is on
                psh2     - pointer to an existing SHARE_2 object
                pszShare - the share to display

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        JonN            11/22/93        Created

********************************************************************/

APIERR SHARE_DIALOG_BASE::UpdatePermissionsInfo(
                                      SERVER_WITH_PASSWORD_PROMPT *psvr,
                                      SHARE_2 * psh2,
                                      const TCHAR *pszShare )
{
    AUTO_CURSOR autocur;

    UIASSERT( psvr != NULL );
    UIASSERT( psh2 != NULL );
    UIASSERT( pszShare != NULL );

    APIERR err = NERR_Success;
    if ( psvr->IsNT() )
    {
        _fSecDescModified = FALSE ;

        if ( psh2->IsAdminOnly() )  // There are no security descriptors in
                                    // special shares.
        {
            delete _pStoredSecDesc;
            _pStoredSecDesc = NULL;
            _fStoredAdminOnly = TRUE;
        }
        else
        {
            _fStoredAdminOnly = FALSE;
            err = QuerySharePermissions( psvr->QueryName(),
     	    	                         pszShare,
                                         &_pStoredSecDesc );
        }
    }
    else if ( psvr->IsShareLevel() )  //  LM 2.x share-level server
    {
       _nlsStoredPassword = psh2->QueryPassword();
       _uiStoredPermissions = psh2->QueryPermissions();
       err = _nlsStoredPassword.QueryError();
    }
    //
    // Do not need to get permissions on LM2.x user-level server
    // because it has no permissions for shares.
    //

    return err;
}

/*******************************************************************

    NAME:	SHARE_DIALOG_BASE::OnChangeShareProperty

    SYNOPSIS:   Helper method to change the properties of the share

    ENTRY:      psvr     - pointer the server object that the share is on
                pszShare - the share that we want to change properties on

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	Yi-HsinS	8/15/91		Created

********************************************************************/

APIERR SHARE_DIALOG_BASE::OnChangeShareProperty(
                            SERVER_WITH_PASSWORD_PROMPT *psvr,
                            const TCHAR *pszShare )
{
    APIERR err;

    UIASSERT( psvr != NULL );
    UIASSERT( pszShare != NULL );

    //
    // Get all information about the share
    //
    SHARE_2 sh2( pszShare, psvr->QueryName(), FALSE);
    NLS_STR nlsComment;

    do { // Not a loop

        if (  ((err = sh2.QueryError() ) != NERR_Success )
           || ((err = sh2.GetInfo()) != NERR_Success )
           || ((err = nlsComment.QueryError()) != NERR_Success )
           )
        {
            break;
        }

        //
        //  Set validation flag to TRUE to enable checking for invalid
        //  information set to the share object.
        //
        sh2.SetValidation( TRUE );

        //
        //  Query, validate and set the comment on the share
        //
        if (  ((err = QueryComment( &nlsComment )) != NERR_Success )
           || ((err = sh2.SetComment( nlsComment )) != NERR_Success )
           )
        {
            err = ( err == ERROR_INVALID_PARAMETER ) ?
                      (APIERR) IERR_SHARE_INVALID_COMMENT : err;
            SetFocusOnComment();
            break;
        }

        //
        //  Set the max uses on the share
        //
        if ((err = sh2.SetMaxUses( (UINT) QueryUserLimit())) != NERR_Success )
        {
            SetFocusOnUserLimit();
            break;
        }

        //
        //  Set the permissions on the share if it's on LM share level servers
        //
        if ( !psvr->IsNT()  && psvr->IsShareLevel() )
        {
            //
            // Upper case the password => same as netcmd
            // since Share-level servers are down level servers only
            //
            _nlsStoredPassword._strupr();

            //
            // Give a warning if the user wants to change the password
            //
            if ( ::stricmpf( _nlsStoredPassword, sh2.QueryPassword() ) != 0 )
            {

                NLS_STR nlsComputer;
                if (  ((err = nlsComputer.QueryError()) != NERR_Success )
                   || ((err = psvr->QueryDisplayName( &nlsComputer ))
                       != NERR_Success )
                   )
                {
                    break;
                }

                if ( ::MsgPopup( this,
 	  	  	        (MSGID) IDS_SHARE_PROP_CHANGE_PASSWD_WARN_TEXT,
 	 	                MPSEV_WARNING, MP_OKCANCEL,
                                nlsComputer.QueryPch(),
 			        sh2.QueryName(), MP_CANCEL ) == IDCANCEL )
                {
                    //
   		    // User click CANCEL =>
                    // Reset password to the original value!
                    //
 		    _nlsStoredPassword = sh2.QueryPassword();
                    err = IERR_USER_CLICKED_CANCEL;
                    break;
                }

                //
                // Set the password on the share
                //
                if (( err = sh2.SetPassword( _nlsStoredPassword ))
                    != NERR_Success )
                     break;
            }

            //
	    // We are successful up to this point, so set the permissions
            //
      	    if ( (err = sh2.SetPermissions( _uiStoredPermissions ))
                 != NERR_Success )
                break;
        }

        //
        //  Write the information out
        //
	if ( (err = sh2.WriteInfo()) != NERR_Success )
            break;

        //
        //  If the share is on an NT server and it is not
        //  a special share, set the permission to it.
        //
        if ( psvr->IsNT() &&  !sh2.IsAdminOnly() )
        {
            err = ApplySharePermissions( sh2.QueryServer(),
					 sh2.QueryName(),
            				 QueryStoredSecDesc() );
	    if (err)
		break ;
        }

        // Falls through if error occurs
    }
    while (FALSE);

    return err;

}

/*******************************************************************

    NAME:       SHARE_DIALOG_BASE::OnCommand

    SYNOPSIS:   Handle the case where the user clicked the permission button

    ENTRY:      event - the CONTROL_EVENT that occurred

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        8/6/92          Created

********************************************************************/

BOOL SHARE_DIALOG_BASE::OnCommand( const CONTROL_EVENT &event )
{
    APIERR err = NERR_Success;

    if ( event.QueryCid() == BUTTON_PERMISSIONS )
    {
        OnPermissions();
        return TRUE;
    }

    return DIALOG_WINDOW::OnCommand( event );
}

/*******************************************************************

    NAME:	SHARE_DIALOG_BASE::OnPermissions

    SYNOPSIS:   Helper method to popup the permission dialog
                when the permission button is clicked

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	Yi-HsinS	8/6/92		Created

********************************************************************/

VOID SHARE_DIALOG_BASE::OnPermissions( VOID )
{
    AUTO_CURSOR autocur;

    //
    // Get the server that the share is on
    //
    SERVER_WITH_PASSWORD_PROMPT *psvr = NULL;
    APIERR err = QueryServer2( &psvr );

    if ( err == NERR_Success )
    {
        if ( psvr->IsNT() )  // On NT servers
        {
            //
            // If we are viewing a admin only share,
            // we cannot change permission on it.
            //

            if ( _fStoredAdminOnly )
            {
                err = IERR_SPECIAL_SHARE_CANNOT_SET_PERMISSIONS;
            }
            else
            {
                NLS_STR nlsShare;
                if (  ((err = nlsShare.QueryError()) == NERR_Success )
                   && ((err = QueryShare( &nlsShare )) == NERR_Success )
                   )
	        {
                    err = EditShareAcl( QueryHwnd(),
			                psvr->QueryName(),
                                        nlsShare.QueryPch(),
				        &_fSecDescModified,
			                &_pStoredSecDesc,
                                        QueryHelpContextBase() ) ;

                }
            }
        }
        else if ( psvr->IsShareLevel() )   // On LM share-level server
        {
            SHARE_LEVEL_PERMISSIONS_DIALOG *pdlg =
                  new SHARE_LEVEL_PERMISSIONS_DIALOG( QueryHwnd(),
                                                      &_nlsStoredPassword,
                                                      &_uiStoredPermissions,
                                                      QueryHelpContextBase() );

            if (  ( pdlg == NULL )
               || (( pdlg->QueryError()) != NERR_Success )
               || (( pdlg->Process()) != NERR_Success )
               )
            {
                err = err? err: ERROR_NOT_ENOUGH_MEMORY;
            }

            delete pdlg;
        }
        else  // On LM user-level server
        {
            err = IERR_CANNOT_SET_PERM_ON_LMUSER_SERVER;
        }
    }

    if ( err != NERR_Success )
    {
        if (  (err == IERR_CANNOT_SET_PERM_ON_LMUSER_SERVER )
           || (err == IERR_SPECIAL_SHARE_CANNOT_SET_PERMISSIONS )
           )
        {
            ::MsgPopup( this, err, MPSEV_WARNING );
        }
        else
        {
            ::MsgPopup( this, err );
        }
    }

}

/*******************************************************************

    NAME:	SHARE_DIALOG_BASE::SetMaxUserLimit

    SYNOPSIS:   Set the maximum number of users in the spin button

    ENTRY:      ulMaxUserLimit - the maximum user limit to be set
				 in the spin button

    EXIT:

    RETURNS:

    NOTES:      We need this because the maximum number of users on
                LM servers and on NT servers are different.

    HISTORY:
	Yi-HsinS	1/17/92		Created

********************************************************************/

APIERR SHARE_DIALOG_BASE::SetMaxUserLimit( ULONG ulMaxUserLimit )
{
    APIERR err = NERR_Success;

    if (ulMaxUserLimit < _spsleUsers.QueryValue())
    {
	// the maximum is less than the default, so adjust the default
	err = _spsleUsers.SetSaveValue(ulMaxUserLimit);
    }

    _spsleUsers.SetRange( ulMaxUserLimit - USERS_MIN + 1);

    return err;
}

/*******************************************************************

    NAME:	SHARE_DIALOG_BASE::QueryUserLimit

    SYNOPSIS:   Get the user limit from the magic group

    ENTRY:

    EXIT:

    RETURNS:    The user limit stored in the user limit magic group

    NOTES:

    HISTORY:
	Yi-HsinS	8/15/91		Created

********************************************************************/

ULONG SHARE_DIALOG_BASE::QueryUserLimit( VOID ) const
{

    ULONG ulUserLimit;

    switch ( _mgrpUserLimit.QuerySelection() )
    {
        case RB_UNLIMITED:
             ulUserLimit = (ULONG) SHI_USES_UNLIMITED;
             break;

        case RB_USERS:
             // We don't need to check whether the value is valid or not
             // because SPIN_BUTTON checks it.

             ulUserLimit = _spsleUsers.QueryValue();
             UIASSERT(   ( ulUserLimit <= _spsleUsers.QueryMax() )
	             &&  ( ulUserLimit >= USERS_MIN )
		     );
             break;

        default:
             UIASSERT(!SZ("User Limit: This shouldn't have happened!\n\r"));
             ulUserLimit = (ULONG) SHI_USES_UNLIMITED;
             break;
    }

    return ulUserLimit;

}

/*******************************************************************

    NAME:	SHARE_DIALOG_BASE::SetUserLimit	

    SYNOPSIS:   Sets the user limit on the magic group

    ENTRY:      ulUserLimit - maximum number of users allowed

    EXIT:

    RETURNS:    NERR_Success

    NOTES:      If the limit is invalid, sets it to "Maximum allowed".

    HISTORY:
	Yi-HsinS	8/15/91		Created

********************************************************************/

APIERR SHARE_DIALOG_BASE::SetUserLimit( ULONG ulUserLimit )
{

     APIERR err = NERR_Success;

     if ( ulUserLimit == (ULONG) SHI_USES_UNLIMITED )
     {
         // Set selection to the  Unlimited button
         _mgrpUserLimit.SetSelection( RB_UNLIMITED );

         ULONG ulMaxUserLimit = _spsleUsers.QueryMax();
    	 ULONG ulNewUserLimit = (ulMaxUserLimit < USERS_DEFAULT) ? ulMaxUserLimit : USERS_DEFAULT;
         _spsleUsers.SetSaveValue( ulNewUserLimit );
     }
     else if (  ( ulUserLimit >= USERS_MIN)
	     && ( ulUserLimit <= _spsleUsers.QueryMax())
	     )
     {
         // Set the Users button
         _mgrpUserLimit.SetSelection( RB_USERS );
         _spsleUsers.SetValue( ulUserLimit );
         _spsleUsers.Update();
     }
     else
     {
	 // The user limit wasn't in range. Go back and set the share to
	 // "maximum allowed".
         return SetUserLimit((ULONG)SHI_USES_UNLIMITED);
     }

     return err;
}

/*******************************************************************

    NAME:	SHARE_DIALOG_BASE::ApplySharePermissions

    SYNOPSIS:   Sets the NT permissions of a share (security descriptor)

    ENTRY:      pszServer  - the server that the share is on
                pszShare   - the share that we want to set permissions on
                posSecDesc - the security descriptor to be set to the share

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	ChuckC  	8/10/92		Created

********************************************************************/

APIERR SHARE_DIALOG_BASE::ApplySharePermissions( const TCHAR *pszServer,
			                         const TCHAR *pszShare,
			                         const OS_SECURITY_DESCRIPTOR *
							posSecDesc)
{
    UIASSERT(pszShare) ;

    // if nothing changed, no need to set.
    if (!_fSecDescModified)
	return NERR_Success ;

    return ( ::SetSharePerm(pszServer,
			    pszShare,
			    posSecDesc) ) ;
}

/*******************************************************************

    NAME:	SHARE_DIALOG_BASE::QuerySharePermissions

    SYNOPSIS:   Gets the NT permissions of a share (security descriptor)

    ENTRY:      pszServer  - the server that the share is on
                pszShare   - the share that we want to set permissions on

    EXIT:       posSecDesc - pointer to the security descriptor
                             of the share

    RETURNS:

    NOTES:

    HISTORY:
	ChuckC  	8/10/92		Created

********************************************************************/

APIERR SHARE_DIALOG_BASE::QuerySharePermissions( const TCHAR *pszServer,
			             const TCHAR             *pszShare,
			             OS_SECURITY_DESCRIPTOR **pposSecDesc)
{
    UIASSERT(pszShare) ;
    UIASSERT(pposSecDesc) ;

    return ( ::GetSharePerm(pszServer,
			    pszShare,
			    pposSecDesc) ) ;
}

/*******************************************************************

    NAME:	SHARE_LEVEL_PERMISSIONS_DIALOG

    SYNOPSIS:   The permission dialog for LM share-level servers

    ENTRY:    	hwndParent     - parent window
                pnlsPassword   - the initial password to be displayed and
                                 place to return the password typed by the
                                 user
                puiPermissions - the initial permission to be displayed and
                                 place to return the permission entered by
                                 the user
                ulHelpContextBase - the base help context

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	Yi-HsinS	8/15/91		Created

********************************************************************/

SHARE_LEVEL_PERMISSIONS_DIALOG::SHARE_LEVEL_PERMISSIONS_DIALOG( HWND hwndParent,
                                                NLS_STR *pnlsPassword,
                                                UINT    *puiPermissions,
                                                ULONG    ulHelpContextBase )
    : DIALOG_WINDOW  ( IDD_SHAREPERMDLG, hwndParent ),
      _pnlsPassword  ( pnlsPassword ),
      _puiPermissions( puiPermissions ),
      _permgrp       ( this, RB_READONLY, SLE_OTHER ),
      _slePassword   ( this, SLE_PASSWORD, SHPWLEN ),
      _ulHelpContextBase( ulHelpContextBase )
{
    UIASSERT( pnlsPassword != NULL );
    UIASSERT( puiPermissions != NULL );

    if ( QueryError() != NERR_Success )
        return;

    APIERR err;
    if (  ((err = _permgrp.QueryError()) != NERR_Success )
       || ((err =  _permgrp.SetPermission( *_puiPermissions )) != NERR_Success)
       )
    {
        ReportError( err );
        return;
    }

    _slePassword.SetText( *_pnlsPassword );
    _permgrp.ClaimFocus();
}

/*******************************************************************

    NAME:	SHARE_LEVEL_PERMISSION_DIALOG::OnOK	

    SYNOPSIS:   Validate and return the password/permission that
                the user entered.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
      	Yi-HsinS	8/25/91		Created

********************************************************************/

BOOL SHARE_LEVEL_PERMISSIONS_DIALOG::OnOK( VOID )
{
    APIERR err = NERR_Success;

    UINT uiPerm;
    if ( ( err = _permgrp.QueryPermission( &uiPerm ) ) != NERR_Success)
    {
        err = IERR_SHARE_INVALID_PERMISSIONS;
	_permgrp.SetFocusOnOther();
    }
    else
    {
        *_puiPermissions = uiPerm;
        err = _slePassword.QueryText( _pnlsPassword );
    }
	
    if ( err == NERR_Success )
    {
        Dismiss( TRUE );
    }
    else
    {
        ::MsgPopup( this, err );
    }

    return TRUE;
}

/*******************************************************************

    NAME:	SHARE_LEVEL_PERMISSIONS_DIALOG::QueryHelpContext	

    SYNOPSIS:   Query the help context of the dialog

    ENTRY:

    EXIT:

    RETURNS:    Return the help context of the dialog

    NOTES:

    HISTORY:
      	Yi-HsinS	8/25/91		Created

********************************************************************/

ULONG SHARE_LEVEL_PERMISSIONS_DIALOG::QueryHelpContext( VOID )
{
    return _ulHelpContextBase + HC_LMSHARELEVELPERMS;
}

/*******************************************************************

    NAME:	PERMISSION_GROUP::PERMISSION_GROUP

    SYNOPSIS:   Constructor for PERMISSION_GROUP

    ENTRY:    	powin - pointer to the parent window
                cidBase - CID of first button of the permission group
                cidOtherEditField - CID of the  Other Edit field
                cidInitialSelection - CID of the initial selection
                pGroupOwner - pointer to owner group

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	Yi-HsinS	8/15/91		Created

********************************************************************/

//
// Table for converting permissions from string to UINT and vice versa.
//
static struct {
WCHAR chPerm;
UINT  uiPerm;
} permTable[] = {
                   { READ_CHAR, ACCESS_READ},
         	   { WRITE_CHAR, ACCESS_WRITE},
     		   { CREATE_CHAR, ACCESS_CREATE},
                   { EXEC_CHAR, ACCESS_EXEC},
                   { DEL_CHAR, ACCESS_DELETE},
                   { ACCESS_CHAR, ACCESS_ATRIB},
                   { PERM_CHAR, ACCESS_PERM}
                };

PERMISSION_GROUP::PERMISSION_GROUP( OWNER_WINDOW *powin,
                                    CID cidBase,
           			    CID cidOtherEditField,
				    CID cidInitialSelection,
				    CONTROL_GROUP *pGroupOwner)
    : _mgrpPermission( powin, cidBase, 3, cidInitialSelection, pGroupOwner),
      // 3 is the number of buttons in the magic group
      _sleOther(powin, cidOtherEditField, PERM_DEFAULT_LEN )
{
    if ( QueryError() != NERR_Success )
        return;

    APIERR err;
    if (  ((err = _mgrpPermission.QueryError()) != NERR_Success )
       || ((err = _mgrpPermission.AddAssociation( RB_OTHER, &_sleOther ))
							!= NERR_Success )
       )
    {
        ReportError( err );
        return;
    }

}


/*******************************************************************

    NAME:	PERMISSION_GROUP::GetAndCheckOtherField	

    SYNOPSIS:   Validate the contents in "Other" Edit field

    ENTRY:

    EXIT:       puiPermission - the permission

    RETURNS:    returns ERROR_INVALID_PARAMETER if the string in
                other edit field is not valid

    NOTES:

    HISTORY:
	Yi-HsinS	8/15/91		Created

********************************************************************/

APIERR PERMISSION_GROUP::GetAndCheckOtherField( UINT *puiPermission ) const
{
    APIERR err = NERR_Success;

    NLS_STR nlsOther( PERM_DEFAULT_LEN );
    if (  (( err = nlsOther.QueryError()) != NERR_Success )
       || (( err = _sleOther.QueryText( &nlsOther )) != NERR_Success )
       )
    {
        return err;
    }
    nlsOther._strupr();

    *puiPermission = 0;
    ISTR istrOther( nlsOther );
    BOOL fFound = FALSE;  // A flag indicating whether a valid char is found
                          // in the permission string.

    while ( nlsOther.QueryChar( istrOther) != STRING_TERMINATOR )
    {
        for ( UINT i = 0; i < PERM_DEFAULT_LEN; i++ )
        {
            if ( nlsOther.QueryChar( istrOther ) == permTable[i].chPerm )
            {
                fFound = TRUE;
                if ( !(*puiPermission & permTable[i].uiPerm ))
                {
                    *puiPermission |= permTable[i].uiPerm;
                    break;    // break the for loop but continue the while loop
                }
                else
                    return ERROR_INVALID_PARAMETER;
            }
            else if ( nlsOther.QueryChar( istrOther) == SPACE )
                fFound = TRUE;

        }

        //
        // If the current character does not belong to "RWCXDAP" or is not
        // a space, then error
        //
        if ( fFound )
            fFound = FALSE;
        else
            return ERROR_INVALID_PARAMETER;
        ++istrOther;
    }


    //
    // If the assigned permission is still zero, then the user
    // did not type anything in _sleOther.
    //
    if ( *puiPermission == 0 )
        return ERROR_INVALID_PARAMETER;
    else
        return NERR_Success;

}

/*******************************************************************

    NAME:	PERMISSION_GROUP::SetPermission

    SYNOPSIS:   Check the permission to see if it's READ_ONLY or MODIFY.
                If yes, set the corresponding radio button. Else convert
                the permission to a string of "RWCXDAP" and displayed
                it on the Other Edit field

    ENTRY:      uiPermission - the permission

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	Yi-HsinS	8/15/91		Created

********************************************************************/
APIERR PERMISSION_GROUP::SetPermission( UINT uiPermission )
{

    if ( (uiPermission & ACCESS_ALL ) == (ACCESS_READ | ACCESS_EXEC) )
    {
        _sleOther.SetText( EMPTY_STRING );
        _mgrpPermission.SetSelection( RB_READONLY );
    }
    else if ( (uiPermission & ACCESS_ALL ) == (ACCESS_ALL & ~ACCESS_PERM))
    {
        _sleOther.SetText( EMPTY_STRING );
        _mgrpPermission.SetSelection( RB_MODIFY );
    }
    else
    {
        NLS_STR nlsPermission( PERM_DEFAULT_LEN );
	APIERR err = NERR_Success;

	if ( ( err = nlsPermission.QueryError()) != NERR_Success )
	    return err;

        for ( UINT i = 0; i < PERM_DEFAULT_LEN; i++ )
        {
             if ( uiPermission & permTable[i].uiPerm )
             {
                 if ( (err = nlsPermission.AppendChar( permTable[i].chPerm ))
		      != NERR_Success )
                     return err;
             }

        }
        _mgrpPermission.SetSelection( RB_OTHER );
        _sleOther.SetText( nlsPermission );
     }

     return NERR_Success;
}

/*******************************************************************

    NAME:	PERMISSION_GROUP::QueryPermission	

    SYNOPSIS:   Get the permission from the permission group

    ENTRY:

    EXIT:       puiPermission - will contain the permission

    RETURNS:

    NOTES:

    HISTORY:
	Yi-HsinS	8/15/91		Created

********************************************************************/

APIERR PERMISSION_GROUP::QueryPermission( UINT *puiPermission ) const
{
    APIERR err = NERR_Success;

    switch ( _mgrpPermission.QuerySelection() )
    {
        case RB_READONLY:
             *puiPermission = ACCESS_READ | ACCESS_EXEC;
             break;

        case RB_MODIFY:
             *puiPermission = ACCESS_ALL & ~ACCESS_PERM;
             break;

        case RB_OTHER:
             err = GetAndCheckOtherField( puiPermission );
             break;
    }

    return err;
}

/*******************************************************************

    NAME:	SHARE_NAME_WITH_PATH_ENUM_ITER::SHARE_NAME_WITH_PATH_ENUM_ITER

    SYNOPSIS:   Constructor

    ENTRY:	sh2Enum    - The thing to iterate on
                nlsActPath - The path we are interested in finding

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	Yi-HsinS	8/15/91		Created

********************************************************************/

SHARE_NAME_WITH_PATH_ENUM_ITER::SHARE_NAME_WITH_PATH_ENUM_ITER(
						 SHARE2_ENUM &sh2Enum,
						 const NLS_STR &nlsActPath)
    : _sh2EnumIter( sh2Enum ),
      _nlsActPath( nlsActPath )
{
     if ( QueryError() != NERR_Success )
         return;

     APIERR err;
     if ( ( err = _nlsActPath.QueryError() ) != NERR_Success )
     {
         ReportError( err );
         return;
     }
}

/*******************************************************************

    NAME:	SHARE_NAME_WITH_PATH_ENUM_ITER::operator()

    SYNOPSIS:   iterator

    ENTRY:	

    EXIT:

    RETURNS:    returns the share name if its path matches the  _nlsActPath

    NOTES:

    HISTORY:
	Yi-HsinS	8/15/91		Created

********************************************************************/

const TCHAR *SHARE_NAME_WITH_PATH_ENUM_ITER::operator()( VOID )
{
      const SHARE2_ENUM_OBJ *pshi2;
      while ( (pshi2 = _sh2EnumIter()) != NULL )
      {
	  if ( ::stricmpf( pshi2->QueryPath(), _nlsActPath) == 0)
	      return( pshi2->QueryName());
      }

      return NULL;
}

/*******************************************************************

    NAME:	SERVER_WITH_PASSWORD_PROMPT::SERVER_WITH_PASSWORD_PROMPT

    SYNOPSIS:   Constructor

    ENTRY:

    EXIT:       pszServer         - Server name
		hwndParent        - Handle of the parent window
                ulHelpContextBase - The base help context

    RETURNS:

    NOTES:

    HISTORY:
	Yi-HsinS	8/15/91		Created

********************************************************************/

SERVER_WITH_PASSWORD_PROMPT::SERVER_WITH_PASSWORD_PROMPT(const TCHAR *pszServer,
                                                  HWND hwndParent,
                                                  ULONG ulHelpContextBase )
    :  SERVER_2( pszServer ),
       _hwndParent( hwndParent ),
       _pprompt( NULL ),
       _ulHelpContextBase( ulHelpContextBase )
{

    if ( QueryError() != NERR_Success )
	return;
}

/*******************************************************************

    NAME:	SERVER_WITH_PASSWORD_PROMPT::~SERVER_WITH_PASSWORD_PROMPT

    SYNOPSIS:   Destructor

    ENTRY:

    EXIT:
	
    RETURNS:

    NOTES:

    HISTORY:
	Yi-HsinS	8/15/91		Created

********************************************************************/

SERVER_WITH_PASSWORD_PROMPT::~SERVER_WITH_PASSWORD_PROMPT()
{
    delete _pprompt;
    _pprompt = NULL;
}

/*******************************************************************

    NAME:	SERVER_WITH_PASSWORD_PROMPT::I_GetInfo

    SYNOPSIS:   Get the SERVER_2 Info and if the user does not have admin
		privilege and the server is a LM share-level server,
                it will pop up a dialog asking for password,
		make a connection to the server's ADMIN$ with the
		password and attempts to get SERVER_2 info again.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	Yi-HsinS	8/15/91		Created

********************************************************************/

APIERR SERVER_WITH_PASSWORD_PROMPT::I_GetInfo( VOID )
{
    APIERR errOriginal = SERVER_2::I_GetInfo();

    if ( errOriginal == NERR_Success )
        return errOriginal;

    APIERR err;
    switch ( errOriginal )
    {
        case ERROR_ACCESS_DENIED:
        case ERROR_INVALID_PASSWORD:
        {
            //
            // Check if the machine is user level or share level
            // Return the original error if it's user level
            //

            LOCATION loc( QueryName() );
            BOOL fNT;
            if (  ((err = loc.QueryError()) == NERR_Success )
               && ((err = loc.CheckIfNT( &fNT )) == NERR_Success )
               )
            {
                if ( fNT )  // Always user level
                {
                    err = errOriginal;
                    break;
                }
                else
                {
                    USER0_ENUM usr0( QueryName() );
                    if ((err = usr0.QueryError()) != NERR_Success )
                        break;

                    //
                    // ERROR_NOT_SUPPORTED is returned by share level servers
                    //
                    if ((err = usr0.GetInfo()) != ERROR_NOT_SUPPORTED )
                    {
                        // user level
                        err = errOriginal;
                        break;
                    }
                }
            }
            else
            {
                 break;
            }

            //
            //  Prompt password and connect to the ADMIN$ share of
            //  share-level servers.
            //
	    NLS_STR nlsServer( QueryName() );
            if (  ((err = nlsServer.QueryError()) != NERR_Success )
               || ((err = QueryDisplayName( &nlsServer )) != NERR_Success)
               )
            {
                break;
            }

            NLS_STR nlsAdmin( nlsServer );
	    ALIAS_STR nlsAdminShare( ADMIN_SHARE );

            if (  ((err = nlsAdmin.QueryError()) == NERR_Success )
	       && ((err = nlsAdmin.AppendChar( PATH_SEPARATOR)) == NERR_Success)
	       && ((err = nlsAdmin.Append( nlsAdminShare )) == NERR_Success )
	       )
            {
                _pprompt = new PROMPT_AND_CONNECT( _hwndParent,
						   nlsAdmin,
                                                   _ulHelpContextBase
						   + HC_SHAREPASSWORDPROMPT,
						   SHPWLEN);

                if (  ( _pprompt != NULL )
                   && ( (err = _pprompt->QueryError()) == NERR_Success )
                   && ( (err = _pprompt->Connect()) == NERR_Success )
		   )
                {
                    if ( _pprompt->IsConnected() )
	 	    {
                        err = SERVER_2::I_GetInfo();
                    }
	            else  // user clicks CANCEL in the password dialog
		    {
		        err = IERR_USER_CLICKED_CANCEL;
                    }
                }

            }

            break;
        }

        case NERR_BadTransactConfig:
	    err = (APIERR) IERR_SHARE_REMOTE_ADMIN_NOT_SUPPORTED;
            break;

        default:
	    err = errOriginal;
            break;
    }

    return err;
}


/*******************************************************************

    NAME:	SERVER_WITH_PASSWORD_PROMPT::QueryName

    SYNOPSIS:   Query the name of the server

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:      Redefine SERVER_2::QueryName because we want to return
		EMPTY_STRING instead of NULL when the server is local.

    HISTORY:
	Yi-HsinS	8/15/91		Created

********************************************************************/

const TCHAR *SERVER_WITH_PASSWORD_PROMPT::QueryName( VOID ) const
{

    if ( SERVER_2::QueryName() == NULL )
	return EMPTY_STRING;
    else
	return SERVER_2::QueryName();
}

/*******************************************************************

    NAME:	SERVER_WITH_PASSWORD_PROMPT::IsNT

    SYNOPSIS:   Check if the server is an NT server or not.

    ENTRY:

    EXIT:

    RETURNS:    TRUE if the server is a NT server, FALSE otherwise.

    NOTES:

    HISTORY:
	Yi-HsinS	8/6/92		Created

********************************************************************/

#define NT_NOS_MAJOR_VER  3

BOOL SERVER_WITH_PASSWORD_PROMPT::IsNT( VOID ) const
{
    return ( QueryMajorVer() >= NT_NOS_MAJOR_VER );
}

/*******************************************************************

    NAME:	SHARE_NET_NAME::SHARE_NET_NAME

    SYNOPSIS:   Constructor

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:      Report why the local server cannot share directories,
                whether it's because NT server service is not started
	        or if the local computer is a WIN16 computer

    HISTORY:
	Yi-HsinS	8/15/91		Created

********************************************************************/

SHARE_NET_NAME::SHARE_NET_NAME( const TCHAR *pszSharePath,
				NETNAME_TYPE netNameType )
    : NET_NAME( pszSharePath, netNameType )
{

    if ( QueryError() != NERR_Success )
	return;

    APIERR err;
    BOOL fLocal = IsLocal( &err );
    if ( err != NERR_Success )
    {
	ReportError( err );
	return;
    }

    if ( !fLocal )
	return;

    //
    // Check whether the local computer can share directories
    //
    if ( IsSharable( &err ) && ( err == NERR_Success ))
    {
       return;
    }
    else if ( err == NERR_Success )   // Not sharable!
    {
        //
	// Determine the reason why the local computer cannot share directories
        //

        LOCATION loc; // Local Computer
        BOOL fNT;
        if (  ((err = loc.QueryError()) == NERR_Success )
	   && ((err = loc.CheckIfNT( &fNT )) == NERR_Success )
	   )
        {
	    // NOTE: What should we do here if we admin NT from
            //       WinBall machine?
	    if ( !fNT )
	        err = NERR_RemoteOnly;
	    else
	        err = NERR_ServerNotStarted;
        }
    }
	
    if ( err != NERR_Success )
    {
	ReportError( err );
	return;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\shellui\share\sharecrt.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**             Copyright(c) Microsoft Corp., 1991                   **/
/**********************************************************************/

/*
 *   sharecrt.cxx
 *     Contains dialogs for creating shares
 *
 *   FILE HISTORY:
 *     Yi-HsinS         1/6/92    Created, separated from sharefmx.cxx
 *                                and added SHARE_CREATE_BASE
 *     Yi-HsinS         3/12/92   Added CREATE_SHARE_GROUP
 *     Yi-HsinS         4/2/92    Added MayRun
 *     Yi-HsinS         8/6/92    Reorganized to match Winball
 *     YiHsinS          4/2/93    Disable viewing/changing permission on special
 *                                shares ( [A-Z]$, IPC$, ADMIN$ )
 *
 */

#include <ntincl.hxx>

#define INCL_WINDOWS_GDI
#define INCL_WINDOWS
#define INCL_DOSERRORS
#define INCL_NETERRORS
#define INCL_NETSERVER
#define INCL_NETUSE
#define INCL_NETSHARE
#define INCL_NETCONS
#define INCL_NETLIB
#define INCL_ICANON
#include <lmui.hxx>

extern "C"
{
    #include <sharedlg.h>
    #include <helpnums.h>
    #include <mnet.h>
}

#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MSGPOPUP
#define INCL_BLT_SPIN_GROUP
#include <blt.hxx>

#include <string.hxx>
#include <uitrace.hxx>
#include <dbgstr.hxx>

#include <lmoshare.hxx>
#include <lmoesh.hxx>
#include <lmoeconn.hxx>
#include <lmosrv.hxx>

#include <strchlit.hxx>   // for string and character constants
#include "sharecrt.hxx"
#include "sharestp.hxx"
#include <errmap.hxx>

/*******************************************************************

    NAME:       DetermineUserLimit

    SYNOPSIS:   A utility function to determine the maximum number of
                users allowed on a share.

    ENTRY:      psvr - the server object where the share will be placed

    RETURNS:    The maximum number of users for shares on that server

    NOTES:      The maximum number of users is determined as follows:

                if (not an NT machine) then
                    LANMAN_USERS_MAX
                else
                    whatever the server returned to us. If they return
                    unlimited, 0xffffffff, then use NT_USERS_MAX to avoid
                    maxing out the spin control

    HISTORY:
        BruceFo        9/12/95         Created

********************************************************************/

ULONG DetermineUserLimit(SERVER_WITH_PASSWORD_PROMPT* psvr)
{
    if (NULL == psvr)
    {
        return NT_USERS_MAX;
    }

    if (psvr->IsNT())
    {
        ULONG users = psvr->QueryMaxUsers();
        return (users > NT_USERS_MAX) ? NT_USERS_MAX : users;
    }
    else
    {
        return LANMAN_USERS_MAX;
    }
}

/*******************************************************************

    NAME:       ADD_SHARE_DIALOG_BASE::ADD_SHARE_DIALOG_BASE

    SYNOPSIS:   Constructor

    ENTRY:      pszDlgResource    - resource name of the dialog
                hwndParent        - hwnd of the parent window
                ulHelpContextBase - the base help context

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        8/3/92         Created

********************************************************************/

ADD_SHARE_DIALOG_BASE::ADD_SHARE_DIALOG_BASE( const TCHAR *pszDlgResource,
                                              HWND  hwndParent,
                                              ULONG ulHelpContextBase )
    : SHARE_DIALOG_BASE( pszDlgResource, hwndParent, ulHelpContextBase ),
      _sleShare( this, SLE_SHARE, SHARE_NAME_LENGTH )

{
    if ( QueryError() != NERR_Success )
        return;
}

/*******************************************************************

    NAME:       ADD_SHARE_DIALOG_BASE::~ADD_SHARE_DIALOG_BASE

    SYNOPSIS:   Destructor

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        8/3/92         Created

********************************************************************/

ADD_SHARE_DIALOG_BASE::~ADD_SHARE_DIALOG_BASE()
{
}

/*******************************************************************

    NAME:       ADD_SHARE_DIALOG_BASE::QueryPathErrorMsg

    SYNOPSIS:   Default error message when the path entered
                by the user is invalid. Depending on whether
                the dialog is used in the server manager or
                file manager, different error message for the
                invalid path will be displayed.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:      This error message is the message used when the
                dialog exist in the server manager.

    HISTORY:
        Yi-HsinS        8/3/92         Created

********************************************************************/

APIERR ADD_SHARE_DIALOG_BASE::QueryPathErrorMsg( VOID )
{
    return IERR_SHARE_INVALID_LOCAL_PATH;
}

/*******************************************************************

    NAME:       ADD_SHARE_DIALOG_BASE::OnAddShare

    SYNOPSIS:   Gather information and create a new share

    ENTRY:      psvr - the server on which to create the share

                pnlsNewShareName - optional parameter to store
                       the name of the newly created share if all went well
    EXIT:

    RETURNS:    TRUE if the share has been created successfully,
                and FALSE otherwise.

    NOTES:

    HISTORY:
        Yi-HsinS        8/25/91         Created
        Yi-HsinS        11/25/91        Made slestrpSharePath accepts local
                                        full path name
        Yi-HsinS        1/22/92         Check for sharing ADMIN$ or IPC$

********************************************************************/

BOOL ADD_SHARE_DIALOG_BASE::OnAddShare( SERVER_WITH_PASSWORD_PROMPT *psvr,
                                        NLS_STR *pnlsNewShareName )
{
    APIERR err = NERR_Success;
    BOOL fAddedShare = FALSE;
    SLE *psle = QuerySLEPath(); // Store the control window
                                // to set focus on if error

    UIASSERT( psvr != NULL );

    do {  //  Not a loop, just for breaking out to the end if error occurs

        //
        // Get the path and computer
        //
        NLS_STR nlsPath;
        NLS_STR nlsServer;
        if (  ((err = nlsPath.QueryError() ) != NERR_Success )
           || ((err = nlsServer.QueryError()) != NERR_Success )
           || ((err = GetAndValidateComputerPath( psvr, &nlsServer, &nlsPath ))
               != NERR_Success )
           )
        {
            break;
        }

        //
        // Get the share name
        //
        NLS_STR nlsShare;
        if (  ((err = nlsShare.QueryError()) != NERR_Success )
           || ((err = QueryShare( &nlsShare )) != NERR_Success)
           || ( nlsShare.QueryTextLength() == 0 )
           )
        {
            psle = QuerySLEShare();
            err = err ? err : (APIERR) IERR_SHARE_INVALID_SHARE;
            break;
        }

        //
        // Validate the share name
        //
        if ( ::I_MNetNameValidate( NULL, nlsShare,
                                   NAMETYPE_SHARE, 0L) != NERR_Success )
        {
            err = (APIERR) IERR_SHARE_INVALID_SHARE;
            psle = QuerySLEShare();
            break;
        }

        //
        // Check if the name of the share is accessible from DOS machine
        //
        ULONG nType;
        if ( ::I_MNetPathType(NULL, nlsShare, &nType, INPT_FLAGS_OLDPATHS )
             != NERR_Success )
        {
            if ( ::MsgPopup( this, IERR_SHARE_NOT_ACCESSIBLE_FROM_DOS,
                             MPSEV_INFO, MP_YESNO, nlsShare, MP_NO ) == IDNO )
            {
                psle = QuerySLEShare();
                break;
            }
        }

        //
        // Get the comment
        //
        NLS_STR nlsComment;
        if (  ((err = nlsComment.QueryError() ) != NERR_Success )
           || ((err = QueryComment( &nlsComment )) != NERR_Success )
           )
        {
            psle = QuerySLEComment();
            break;
        }

        //
        // Check whether it is a special share name -- ADMIN$ or IPC$
        // If creating the special share, the path and comment
        // has to be empty.
        //

        BOOL fAdminShare = (::stricmpf( nlsShare, ADMIN_SHARE) == 0);
        BOOL fIPCShare = (::stricmpf( nlsShare, IPC_SHARE) == 0);
        BOOL fPathEmpty = nlsPath.QueryTextLength() == 0;

        if ( fAdminShare || fIPCShare )
        {
            if ( !fPathEmpty )
            {
                err = (APIERR) IERR_SPECIAL_SHARE_INVALID_PATH;
            }
            else if ( nlsComment.QueryTextLength() != 0)
            {
                err = (APIERR) IERR_SPECIAL_SHARE_INVALID_COMMENT;
                psle = QuerySLEComment();
            }

            if ( err != NERR_Success )
                break;
        }

        //
        //  Get the right error message when the path is invalid
        //
        if ( fPathEmpty && !fAdminShare && !fIPCShare )
        {
            err = QueryPathErrorMsg();
            break;
        }

        UINT uiResourceType = ( fIPCShare? STYPE_IPC : STYPE_DISKTREE);
        SHARE_2 sh2( nlsShare, nlsServer);
        if (  ((err = sh2.QueryError()) != NERR_Success )
           || ((err = sh2.CreateNew()) != NERR_Success )
           || ((err = sh2.SetResourceType( uiResourceType )) != NERR_Success)
           || ((err = sh2.SetPath( nlsPath )) != NERR_Success)
           )
        {
            break;
        }

        //
        // Set the comment
        //
        if ( (err = sh2.SetComment( nlsComment )) != NERR_Success )
        {
            if ( err == ERROR_INVALID_PARAMETER )
                err = IERR_SHARE_INVALID_COMMENT;
            psle = QuerySLEComment();
            break;
        }

        //
        // Get and set user limit
        //
        UINT uiUserLimit = (UINT) QueryUserLimit();
        BOOL fNT = psvr->IsNT();
        if (  (( !fNT ) && ( uiUserLimit != SHI_USES_UNLIMITED )
                        && ( uiUserLimit > LANMAN_USERS_MAX ))
           || (( err = sh2.SetMaxUses( uiUserLimit ) ) != NERR_Success)
           )
        {
            err =  err ? err : IERR_SHARE_INVALID_USERLIMIT;
            psle = QuerySpinSLEUsers();
            break;
        }

        //
        // Set the permissions/password if the server is a LM share-level server
        //
        if ( !fNT && psvr->IsShareLevel() )
        {
            // Error already checked when dismissing
            // SHARE_LEVEL_PERMISSIONS _DIALOG. So, we don't need
            // to set focus when error!

            // We upper case the password => same as netcmd
            // since password are used in Share level servers which are
            // always down-level servers.
            ALIAS_STR nlsPassword( QueryStoredPassword() );
            nlsPassword._strupr();

            if (  ((err = sh2.SetPermissions( QueryStoredPermissions() ))
                   != NERR_Success)
               || ((err = sh2.SetPassword( nlsPassword ))
                   != NERR_Success)
               )
            {
                break;
            }
        }

        //
        // Write out the share
        //
        if (( err = sh2.WriteNew()) == NERR_Success )
        {
            fAddedShare = TRUE;
            if ( pnlsNewShareName )
                err = pnlsNewShareName->CopyFrom( sh2.QueryName() );

            // If the server is an NT server, set the permissions.
            if (   ( fNT )
                && ( err == NERR_Success )
                && ( QueryStoredSecDesc() != NULL)
               )
            {
                err = ApplySharePermissions( sh2.QueryServer(),
                                             sh2.QueryName(),
                                             QueryStoredSecDesc() );

                // The permissions on special shares [A-Z]$, IPC$, ADMIN$
                // cannot be set.
                if ( err == ERROR_INVALID_PARAMETER )
                    err = IERR_SPECIAL_SHARE_CANNOT_SET_PERMISSIONS;
            }
        }

    } while (FALSE);

    if ( err != NERR_Success )
    {
        // Map some errors
        switch ( err )
        {
            case ERROR_NOT_READY:
                err = IERR_SHARE_DRIVE_NOT_READY;
                break;

            case NERR_DuplicateShare:
                psle = QuerySLEShare();
                break;

            case NERR_BadTransactConfig:
                Dismiss( FALSE );
                break;

            default:
                break;
        }

        if ( err != NERR_Success )
        {
            ::MsgPopup( this,
                        err,
                        err == IERR_SPECIAL_SHARE_CANNOT_SET_PERMISSIONS
                               ? MPSEV_WARNING
                               : MPSEV_ERROR );
        }
    }

    //
    // Set focus to the appropriate control that contains invalid information
    //
    if ( !fAddedShare )
    {
        psle->SelectString();
        psle->ClaimFocus();
    }

    return fAddedShare;

}

/*******************************************************************

    NAME:       ADD_SHARE_DIALOG_BASE::GetAndValidateComputerPath

    SYNOPSIS:   Helper method to get the path of the share
                and the computer on which to create the share


    ENTRY:      psvr - the server on which to create the share

    EXIT:       pnlsComputer - pointer to the computer name
                pnlsPath     - pointer to the path

    RETURNS:

    NOTES:      This is a default virtual method used only when
                the dialogs derived from this class are used in the
                server manager.

    HISTORY:
        Yi-HsinS        8/3/92         Created

********************************************************************/

APIERR ADD_SHARE_DIALOG_BASE::GetAndValidateComputerPath(
                                 SERVER_WITH_PASSWORD_PROMPT *psvr,
                                 NLS_STR *pnlsComputer,
                                 NLS_STR *pnlsPath )
{

    UIASSERT( psvr != NULL );

    APIERR err;

    do {  // NOT a loop

        *pnlsComputer = psvr->QueryName();
        if (  ((err = pnlsComputer->QueryError()) != NERR_Success )
           || ((err = QueryPath( pnlsPath )) != NERR_Success )
           )
        {
            break;
        }

        if ( pnlsPath->QueryTextLength() == 0 )
        {
            break;
        }

        //
        //  Path should only be absolute path
        //
        NET_NAME netName( *pnlsPath, TYPE_PATH_ABS );

        if (( err = netName.QueryError()) != NERR_Success )
        {
            if ( err == ERROR_INVALID_NAME )
                err = (APIERR) IERR_SHARE_INVALID_LOCAL_PATH;
            break;
        }

        //
        // Validated successfully, so check to see if it's in the
        // form "x:". If so, append a "\" into the path.
        //
        if ( pnlsPath->QueryTextLength() == 2)
            pnlsPath->AppendChar( PATH_SEPARATOR );

    } while ( FALSE );

    return err;
}

/*******************************************************************

    NAME:       FILEMGR_NEW_SHARE_DIALOG::FILEMGR_NEW_SHARE_DIALOG

    SYNOPSIS:   Constructor

    ENTRY:      hwndParent        - hwnd of the parent window
                pszSelectedDir    - the selected directory in the file manager
                ulHelpContextBase - the base help context
                fShowDefault      - TRUE if we want to display the default share
                                    name, FALSE otherwise.

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        8/25/91         Created

********************************************************************/

FILEMGR_NEW_SHARE_DIALOG::FILEMGR_NEW_SHARE_DIALOG(  HWND hwndParent,
                                            const TCHAR *pszSelectedDir,
                                            ULONG ulHelpContextBase,
                                            BOOL  fShowDefault,
                                            NLS_STR *pnlsNewShareName )
    : ADD_SHARE_DIALOG_BASE( MAKEINTRESOURCE(IDD_SHARECREATEDLG),
                             hwndParent,
                             ulHelpContextBase ),
      _newShareGrp( this, QuerySLEShare(), QuerySLEPath()),
      _pnlsNewShareName( pnlsNewShareName ),
      _psvr( NULL )
{
    if ( QueryError() != NERR_Success )
        return;

    APIERR err;
    if (  ((err = _newShareGrp.QueryError()) != NERR_Success )
       || ((err = SetDefaults( pszSelectedDir, fShowDefault)) != NERR_Success )
       )
    {
        ReportError( err );
        return;
    }

    QuerySLEShare()->SelectString();
    QuerySLEShare()->ClaimFocus();
}

/*******************************************************************

    NAME:       FILEMGR_NEW_SHARE_DIALOG::~FILEMGR_NEW_SHARE_DIALOG

    SYNOPSIS:   Destructor

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        8/25/91         Created

********************************************************************/

FILEMGR_NEW_SHARE_DIALOG::~FILEMGR_NEW_SHARE_DIALOG()
{
    delete _psvr;
    _psvr = NULL;
}

/*******************************************************************

    NAME:       FILEMGR_NEW_SHARE_DIALOG::QueryPathErrorMsg

    SYNOPSIS:   Query the error message when the user
                entered an invalid path in the new share dialog
                used in the file manager.

    ENTRY:

    EXIT:

    RETURNS:    Returns the error message for invalid path

    NOTES:

    HISTORY:
        Yi-HsinS        8/25/91         Created

********************************************************************/

APIERR FILEMGR_NEW_SHARE_DIALOG::QueryPathErrorMsg( VOID )
{
    return IERR_SHARE_INVALID_SHAREPATH;
}

/*******************************************************************

    NAME:       FILEMGR_NEW_SHARE_DIALOG::QueryServer2

    SYNOPSIS:   Get the SERVER_2 object by determining which server
                the path is on.

    ENTRY:

    EXIT:       *ppsvr - pointer to the server object

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        8/25/91         Created

********************************************************************/

APIERR FILEMGR_NEW_SHARE_DIALOG::QueryServer2(
                                 SERVER_WITH_PASSWORD_PROMPT **ppsvr )
{
    APIERR err;
    NLS_STR nlsPath;
    NLS_STR nlsComputer;

    do {  // Not a loop

        if (  ((err = nlsPath.QueryError()) != NERR_Success )
           || ((err = nlsComputer.QueryError()) != NERR_Success )
           || ((err = QueryPath( &nlsPath )) != NERR_Success )
           )
        {
            break;
        }

        //
        // When the path is empty, ( probably because of ADMIN$/IPC$ )
        // assume the server is the local computer.
        //
        if ( nlsPath.QueryTextLength() == 0 )
        {
            nlsComputer = EMPTY_STRING;
            err = nlsComputer.QueryError();
            break;
        }

        //
        // Let the type be unknown so that SHARE_NET_NAME will set the
        // type accordingly. This is only valid when the path is not empty.
        //
        SHARE_NET_NAME netName( nlsPath, TYPE_UNKNOWN );

        if ( ( err = netName.QueryError()) != NERR_Success )
        {
            if ( err == ERROR_INVALID_NAME )
                err = (APIERR) IERR_SHARE_INVALID_SHAREPATH;
            SetFocusOnPath();
            break;
        }

        //
        // Get the Computer Name
        //
        if ((err = netName.QueryComputerName( &nlsComputer )) != NERR_Success )
        {
            break;
        }

        if ( netName.IsLocal( &err ) && ( err == NERR_Success ))
        {
            nlsComputer = EMPTY_STRING;
            err = nlsComputer.QueryError();
        }

    } while ( FALSE );

    //
    // Check to see the computer is the same the one stored before
    // If so, we don't need a new server object.
    // Else, delete the old server object and get a new one.
    //
    if (  ( err == NERR_Success )
       && (  ( _psvr == NULL )
          || ::I_MNetComputerNameCompare( nlsComputer, _psvr->QueryName() )
          )
       )
    {
        if ( _psvr != NULL )
            delete _psvr;

        //
        // We need to clear the security desc when the user switched to
        // a different computer.
        //
        if ( (err = ClearStoredInfo()) == NERR_Success )
        {
            _psvr = new SERVER_WITH_PASSWORD_PROMPT( nlsComputer,
                                                     QueryHwnd(),
                                                     QueryHelpContextBase() );
            if (  ( _psvr == NULL )
               || ((err = _psvr->QueryError()) != NERR_Success )
               || ((err = _psvr->GetInfo()) != NERR_Success )
               )
            {
                err = err? err : ERROR_NOT_ENOUGH_MEMORY;
                delete _psvr;
                _psvr = NULL;
            }
        }
    }

    *ppsvr = _psvr;
    return err;
}

/*******************************************************************

    NAME:       FILEMGR_NEW_SHARE_DIALOG::SetDefaults

    SYNOPSIS:   Set the default share and path in the SLEs

    ENTRY:      pszSelectedDir - name of the selected directory

    EXIT:

    RETURNS:

    NOTES:      We'll only set the default share name if the name has
                not been used before, i.e. when fShowDefault is TRUE

    HISTORY:
        Yi-HsinS        8/3/92         Created

********************************************************************/

APIERR FILEMGR_NEW_SHARE_DIALOG::SetDefaults( const TCHAR *pszSelectedDir,
                                              BOOL fShowDefault )
{
    APIERR err = NERR_Success;

    ALIAS_STR nlsSelectedDir( pszSelectedDir );
    if ( nlsSelectedDir.QueryTextLength() == 0 )
    {
        QueryPBCancel()->MakeDefault();
        return err;
    }

    //
    // Get Information on the selected directory
    //
    SHARE_NET_NAME netName( pszSelectedDir, TYPE_UNKNOWN );

    if ((err = netName.QueryError()) == NERR_Success )
    {

        BOOL fLocal = netName.IsLocal( &err );

        if ( err == NERR_Success )
        {

            NLS_STR nlsSharePath;  // of the form "\\server\share\path"
                                   // or "x:\path"
            NLS_STR nlsShareName;  // EMPTY_STRING is default
            NLS_STR nlsComputer;

            if (  (( err = nlsSharePath.QueryError()) == NERR_Success )
               && (( err = nlsShareName.QueryError()) == NERR_Success )
               && (( err = nlsComputer.QueryError()) == NERR_Success )
               )
            {

                //
                // Set the default value of SLEs
                // If the path is on a local computer, display the
                // absolute path. If it's not on a local computer,
                // display the UNC path
                //
                if ( fLocal )
                    err = netName.QueryLocalPath( &nlsSharePath );
                else
                    err = netName.QueryUNCPath( &nlsSharePath );

                err = err? err : netName.QueryComputerName( &nlsComputer );

                if ( fShowDefault )
                    err = err? err : netName.QueryLastComponent( &nlsShareName);

                if ( err == NERR_Success )
                {
                    UINT nShareLen = nlsShareName.QueryTextLength();
                    if ( nShareLen == 0 )
                    {
                        QueryPBCancel()->MakeDefault();
                        QueryPBPermissions()->Enable( FALSE );
                    }
                    else
                    {
                        QueryPBOK()->MakeDefault();
                        QueryPBPermissions()->Enable( TRUE );

                        if ( nShareLen > SHARE_NAME_LENGTH )
                        {
                            ISTR istr( nlsShareName );
                            istr += SHARE_NAME_LENGTH;
                            nlsShareName.DelSubStr( istr );
                        }
                    }

                    SetPath ( nlsSharePath );
                    SetShare( nlsShareName );
                }
            }
        }
    }

    return err;
}

/*******************************************************************

    NAME:       FILEMGR_NEW_SHARE_DIALOG::GetAndValidateComputerPath

    SYNOPSIS:   Helper method to get the path of the share
                and the computer on which to create the share


    ENTRY:      psvr - the server on which to create the share

    EXIT:       pnlsComputer - pointer to the computer name
                pnlsPath     - pointer to the path

    RETURNS:

    NOTES:      This is the virtual method used when the dialog belongs
                to the file manager.

    HISTORY:
        Yi-HsinS        8/3/92         Created

********************************************************************/

APIERR FILEMGR_NEW_SHARE_DIALOG::GetAndValidateComputerPath(
                                 SERVER_WITH_PASSWORD_PROMPT *psvr,
                                 NLS_STR *pnlsComputer,
                                 NLS_STR *pnlsPath )
{

    APIERR err;

    do {  // NOT a loop

        *pnlsComputer = psvr->QueryName();

        if (  ((err = pnlsComputer->QueryError()) != NERR_Success )
           || ((err = QueryPath( pnlsPath )) != NERR_Success )
           )
        {
            break;
        }

        if ( pnlsPath->QueryTextLength() == 0 )
        {
            break;
        }

        //
        // Let the type be unknown so that SHARE_NET_NAME will set the
        // type accordingly. This is only valid when the path is not empty.
        //
        SHARE_NET_NAME netName( *pnlsPath, TYPE_UNKNOWN );

        if ( ( err = netName.QueryError()) != NERR_Success )
        {
            if ( err == ERROR_INVALID_NAME )
                err = (APIERR) IERR_SHARE_INVALID_SHAREPATH;
            break;
        }

        //
        // Get the path that is local to the computer.
        //
        if ((err = netName.QueryLocalPath( pnlsPath )) != NERR_Success )
        {
            break;
        }

    } while ( FALSE );

    return err;
}

/*******************************************************************

    NAME:       FILEMGR_NEW_SHARE_DIALOG::OnOK

    SYNOPSIS:   Create the share if the user clicks on the OK button

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        1/8/92          Created

********************************************************************/
BOOL FILEMGR_NEW_SHARE_DIALOG::OnOK( VOID )
{
    AUTO_CURSOR autocur;

    SERVER_WITH_PASSWORD_PROMPT *psvr = NULL;
    APIERR err = QueryServer2( &psvr );
    if ( err == NERR_Success )
    {
        if ( OnAddShare( psvr, _pnlsNewShareName ) )
            Dismiss( TRUE );
    }
    else
    {
        // Don't popup the error if the user clicks cancel button in the
        // password dialog.
        if ( err != IERR_USER_CLICKED_CANCEL )
            ::MsgPopup( this, err );
    }

    return TRUE;
}

/*******************************************************************

    NAME:       FILEMGR_NEW_SHARE_DIALOG::QueryHelpContext

    SYNOPSIS:   Get the help context of the dialog

    ENTRY:

    EXIT:

    RETURNS:    Return the help context

    NOTES:

    HISTORY:
        Yi-HsinS        1/8/92          Created

********************************************************************/
ULONG FILEMGR_NEW_SHARE_DIALOG::QueryHelpContext( VOID )
{
    return QueryHelpContextBase() + HC_FILEMGRNEWSHARE;
}

/*******************************************************************

    NAME:       FILEMGR_NEW_SHARE_GROUP::FILEMGR_NEW_SHARE_GROUP

    SYNOPSIS:   Constructor

    ENTRY:      pdlg - pointer to the dialog
                psleShare - pointer to the Share SLE
                pslePath  - pointer to teh Path SLE

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        3/12/92         Created

********************************************************************/

FILEMGR_NEW_SHARE_GROUP::FILEMGR_NEW_SHARE_GROUP(
                         ADD_SHARE_DIALOG_BASE *pdlg,
                         SLE *psleShare, SLE *pslePath )
    : _psleShare( psleShare ),
      _pslePath( pslePath ),
      _pdlg( pdlg )
{
    UIASSERT( psleShare );
    UIASSERT( pslePath );
    UIASSERT( pdlg );

    _psleShare->SetGroup( this );
    _pslePath->SetGroup( this );
}

/*******************************************************************

    NAME:       FILEMGR_NEW_SHARE_GROUP::~FILEMGR_NEW_SHARE_GROUP

    SYNOPSIS:   Destructor

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        3/12/92         Created

********************************************************************/

FILEMGR_NEW_SHARE_GROUP::~FILEMGR_NEW_SHARE_GROUP()
{
    _psleShare   = NULL;
    _pslePath    = NULL;
    _pdlg = NULL;
}

/*******************************************************************

    NAME:       FILEMGR_NEW_SHARE_GROUP::OnUserAction

    SYNOPSIS:   If the share name is not empty, make OK the default button.
                Else, make CANCEL the default button.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        3/12/92         Created

********************************************************************/

APIERR FILEMGR_NEW_SHARE_GROUP::OnUserAction( CONTROL_WINDOW *pcw,
                                              const CONTROL_EVENT &e )
{
    if (  ( pcw == _pslePath )
       || ( pcw == _psleShare )
       )
    {
        if ( e.QueryCode() == EN_CHANGE )
        {
            BOOL fShareEmpty = ( _psleShare->QueryTextLength() == 0 );
            BOOL fPathEmpty  = ( _pslePath->QueryTextLength() == 0 );

            BOOL fEnable = FALSE;

            // If both share and path are not empty
            if ( !fShareEmpty && !fPathEmpty )
            {
                fEnable = TRUE;

            }
            // If share is not empty and path is empty,
            // check if the share name is ADMIN$ or IPC$
            else if ( !fShareEmpty && fPathEmpty )
            {
                APIERR err;
                NLS_STR nlsShare;
                if (  ((err = nlsShare.QueryError()) != NERR_Success )
                   || ((err = _psleShare->QueryText( &nlsShare ))
                       != NERR_Success )
                   )
                {
                    ::MsgPopup( pcw->QueryOwnerHwnd(), err );
                    return GROUP_NO_CHANGE;
                }

                ALIAS_STR nlsAdmin( ADMIN_SHARE );
                ALIAS_STR nlsIPC( IPC_SHARE );

                if (  ( nlsShare._stricmp( nlsAdmin ) == 0 )
                   || ( nlsShare._stricmp( nlsIPC ) == 0 )
                   )
                {
                    fEnable = TRUE;
                }
            }

            _pdlg->QueryPBPermissions()->Enable( fEnable );

            if ( !fShareEmpty )
                _pdlg->QueryPBOK()->MakeDefault();
            else
                _pdlg->QueryPBCancel()->MakeDefault();

        }

    }
    else
    {
        UIASSERT( FALSE );
    }

    return GROUP_NO_CHANGE;
}

/*******************************************************************

    NAME:       SVRMGR_NEW_SHARE_DIALOG::SVRMGR_NEW_SHARE_DIALOG

    SYNOPSIS:   Constructor

    ENTRY:      hwndParent        - hwnd of the parent window
                pszComputer       - the selected directory in the file manager
                ulHelpContextBase - the base help context

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        8/25/91         Created

********************************************************************/

SVRMGR_NEW_SHARE_DIALOG::SVRMGR_NEW_SHARE_DIALOG( HWND hwndParent,
                         SERVER_WITH_PASSWORD_PROMPT  *psvr,
                         ULONG ulHelpContextBase )
    : ADD_SHARE_DIALOG_BASE( MAKEINTRESOURCE(IDD_SHARECREATEDLG),
                             hwndParent,
                             ulHelpContextBase ),
      _shareGrp( this, QuerySLEShare() ),
      _psvr( psvr )
{
    UIASSERT( psvr != NULL );

    if ( QueryError() != NERR_Success )
        return;

    APIERR err;
    if (   ((err = _shareGrp.QueryError()) != NERR_Success)
	|| ((err = SetMaxUserLimit(DetermineUserLimit(_psvr))) != NERR_Success)
	)
    {
        ReportError( err );
        return;
    }

    QueryPBCancel()->MakeDefault();
    QueryPBPermissions()->Enable( FALSE );
}

/*******************************************************************

    NAME:       SVRMGR_NEW_SHARE_DIALOG::~SVRMGR_NEW_SHARE_DIALOG

    SYNOPSIS:   Destructor

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        8/25/91         Created

********************************************************************/
SVRMGR_NEW_SHARE_DIALOG::~SVRMGR_NEW_SHARE_DIALOG()
{
    _psvr = NULL;
}

/*******************************************************************

    NAME:       SVRMGR_NEW_SHARE_DIALOG::QueryServer2

    SYNOPSIS:   Get the server object

    ENTRY:

    EXIT:       *ppsvr - pointer to the server object

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        8/25/91         Created

********************************************************************/

APIERR SVRMGR_NEW_SHARE_DIALOG::QueryServer2(
                                SERVER_WITH_PASSWORD_PROMPT **ppsvr )
{
    UIASSERT( _psvr != NULL );
    *ppsvr = _psvr;
    return NERR_Success;
}

/*******************************************************************

    NAME:       SVRMGR_NEW_SHARE_DIALOG::OnOK

    SYNOPSIS:   Create the share when the user clicks on the OK button

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        1/8/92          Created

********************************************************************/
BOOL SVRMGR_NEW_SHARE_DIALOG::OnOK( VOID )
{
    AUTO_CURSOR autocur;

    if ( OnAddShare( _psvr ) )
        Dismiss( TRUE );

    return TRUE;
}

/*******************************************************************

    NAME:       SVRMGR_NEW_SHARE_DIALOG::QueryHelpContext

    SYNOPSIS:   Get the help context of the dialog

    ENTRY:

    EXIT:

    RETURNS:    Return the help context

    NOTES:

    HISTORY:
        Yi-HsinS        1/8/92          Created

********************************************************************/
ULONG SVRMGR_NEW_SHARE_DIALOG::QueryHelpContext( VOID )
{
    return QueryHelpContextBase() + HC_SVRMGRNEWSHARE;
}

/*******************************************************************

    NAME:       SVRMGR_NEW_SHARE_GROUP::SVRMGR_NEW_SHARE_GROUP

    SYNOPSIS:   Constructor

    ENTRY:      pdlg      - pointer to the server manager new share dialog
                psleShare - pointer to the Share SLE

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        3/12/92         Created

********************************************************************/

SVRMGR_NEW_SHARE_GROUP::SVRMGR_NEW_SHARE_GROUP( SVRMGR_NEW_SHARE_DIALOG *pdlg,
                                                SLE *psleShare )
    : _psleShare( psleShare ),
      _pdlg( pdlg )
{
    UIASSERT( psleShare );
    UIASSERT( pdlg );

    _psleShare->SetGroup( this );
}

/*******************************************************************

    NAME:       SVRMGR_NEW_SHARE_GROUP::~SVRMGR_NEW_SHARE_GROUP

    SYNOPSIS:   Destructor

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        3/12/92         Created

********************************************************************/

SVRMGR_NEW_SHARE_GROUP::~SVRMGR_NEW_SHARE_GROUP()
{
    _psleShare = NULL;
    _pdlg = NULL;
}

/*******************************************************************

    NAME:       SVRMGR_NEW_SHARE_GROUP::OnUserAction

    SYNOPSIS:   If share name SLE is empty,  set the default button
                to CANCEL, else set the default button to OK.
                We will also disable the permissions button if
                necessary.

    ENTRY:      pcw - the control window that the event was sent to
                e   - the event that occurred

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        3/12/92         Created

********************************************************************/

APIERR SVRMGR_NEW_SHARE_GROUP::OnUserAction( CONTROL_WINDOW *pcw,
                                             const CONTROL_EVENT &e )
{
    if ( pcw == _psleShare )
    {
        if ( e.QueryCode() == EN_CHANGE )
        {
            SERVER_WITH_PASSWORD_PROMPT *psvr;
            APIERR err = _pdlg->QueryServer2( &psvr );

            if ( err != NERR_Success )
            {
                ::MsgPopup( pcw->QueryOwnerHwnd(), err );
            }
            else
            {

                BOOL fShareEmpty = ( _psleShare->QueryTextLength() == 0 );

                if ( !fShareEmpty )
                {
                    _pdlg->QueryPBOK()->MakeDefault();

                    // Enable the permissions button if the server
                    // is an NT server or an LM share-level server.
                    // LM user-level servers should already have
                    // the permissions button grayed.
                    if ( psvr->IsNT() || psvr->IsShareLevel() )
                        _pdlg->QueryPBPermissions()->Enable( TRUE );
                }
                else
                {
                    _pdlg->QueryPBCancel()->MakeDefault();

                    // Disable the permissions button if the server
                    // is an NT server or an LM share-level server
                    // LM user-level servers should already have
                    // the permissions button grayed.
                    if ( psvr->IsNT() || psvr->IsShareLevel() )
                        _pdlg->QueryPBPermissions()->Enable( FALSE );
                }
            }
        }

    }

    return GROUP_NO_CHANGE;
}

/*******************************************************************

    NAME:       SVRMGR_SHARE_PROP_DIALOG::SVRMGR_SHARE_PROP_DIALOG

    SYNOPSIS:   Constructor

    ENTRY:      hwndParent        - hwnd of the parent window
                pszComputer       - the computer that the share is on
                pszShare          - the name of the share
                ulHelpContextBase - the base help context

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        8/3/92         Created

********************************************************************/

SVRMGR_SHARE_PROP_DIALOG::SVRMGR_SHARE_PROP_DIALOG( HWND hwndParent,
                                  SERVER_WITH_PASSWORD_PROMPT *psvr,
                                  const TCHAR *pszShare,
                                  ULONG ulHelpContextBase )
    : ADD_SHARE_DIALOG_BASE( MAKEINTRESOURCE(IDD_SVRMGRSHAREPROPDLG),
                             hwndParent,
                             ulHelpContextBase ),
      _nlsStoredPath(),  // the original path of the share
      _psvr( psvr ),
      _fDeleted( FALSE )
{
    UIASSERT( psvr != NULL );

    if ( QueryError() != NERR_Success )
        return;

    APIERR err;
    if (  ((err = _nlsStoredPath.QueryError()) != NERR_Success )
       || ((err = SetMaxUserLimit( DetermineUserLimit(_psvr) )) != NERR_Success)
       || ((err = UpdateInfo( _psvr, pszShare )) != NERR_Success )
       || ((err = QueryPath( &_nlsStoredPath )) != NERR_Success )
       )
    {
        ReportError( err );
        return;
    }

    if ( !_psvr->IsNT() && _psvr->IsUserLevel() )
        QueryPBPermissions()->Enable( FALSE );

    SetShare( pszShare );
    SetFocusOnComment();
}

/*******************************************************************

    NAME:       SVRMGR_SHARE_PROP_DIALOG::~SVRMGR_SHARE_PROP_DIALOG

    SYNOPSIS:   Destructor

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:      We don't need to delete _psvr. We'll leave it to whoever
                that creates it.

    HISTORY:
        Yi-HsinS        8/3/92         Created

********************************************************************/

SVRMGR_SHARE_PROP_DIALOG::~SVRMGR_SHARE_PROP_DIALOG()
{
    _psvr = NULL;
}

/*******************************************************************

    NAME:       SVRMGR_SHARE_PROP_DIALOG::QueryServer2

    SYNOPSIS:   Get the server object

    ENTRY:

    EXIT:       *ppsvr - pointer to the server object

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        8/3/92         Created

********************************************************************/

APIERR SVRMGR_SHARE_PROP_DIALOG::QueryServer2(
                                 SERVER_WITH_PASSWORD_PROMPT **ppsvr )
{
    UIASSERT( _psvr != NULL );
    *ppsvr = _psvr;
    return NERR_Success;
}



/*******************************************************************

    NAME:       SVRMGR_SHARE_PROP_DIALOG::StopShareIfNecessary

    SYNOPSIS:   Check if the user has changed the path of the directory
                If so, stop sharing the old share.

    ENTRY:      pszShare       - the name of the share
                pfDeleteShare  - pointer to a flag indicating whether
                                 the share has been deleted or not
                pfCancel       - pointer to a flag indicating whether
                                 the user has cancelled changing the
                                 properties of the share

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        8/3/92         Created

********************************************************************/

APIERR SVRMGR_SHARE_PROP_DIALOG::StopShareIfNecessary( const TCHAR *pszShare,
                                                       BOOL *pfDeleteShare,
                                                       BOOL *pfCancel )
{

    UIASSERT( pfCancel != NULL );
    *pfCancel = FALSE;
    UIASSERT( pfDeleteShare != NULL );
    *pfDeleteShare = FALSE;

    //
    // If the share has already been deleted,
    // just return
    //
    if ( _fDeleted )
    {
        *pfDeleteShare = TRUE;
        return NERR_Success;
    }

    APIERR err;
    ALIAS_STR nlsShare( pszShare );
    do {  // Not a loop

        //
        // Get and validate the path
        //
        NLS_STR nlsPath;
        if (  ((err = nlsPath.QueryError()) != NERR_Success )
           || ((err = QueryPath( &nlsPath )) != NERR_Success )
           )
        {
            break;
        }

        ALIAS_STR nlsAdmin( ADMIN_SHARE );
        ALIAS_STR nlsIPC( IPC_SHARE );

        if (  ( nlsPath.QueryTextLength() != 0 )
           || ( nlsShare._stricmp( nlsIPC ) != 0 )
           )
        {
            NET_NAME netName( nlsPath, TYPE_PATH_ABS );
            if ((err = netName.QueryError()) != NERR_Success )
            {
                if ( err == ERROR_INVALID_NAME )
                    err = IERR_SHARE_INVALID_LOCAL_PATH;
                SetFocusOnPath();
                break;
            }
        }

        //
        // If the path is of the form "x:", append a "\"
        //
        if ( nlsPath.QueryTextLength() == 2 )
        {
            if ((err = nlsPath.AppendChar( PATH_SEPARATOR)) != NERR_Success)
                break;
        }

        BOOL fPathSame;
        if ( nlsPath._stricmp( _nlsStoredPath ) == 0 )
        {
            fPathSame = TRUE;
        }
        else
        {
            fPathSame = FALSE;
        }

        MSGID msgid;
        NLS_STR *apnlsParams[ 5 ];
        apnlsParams[0] = &_nlsStoredPath;
        apnlsParams[1] = &nlsShare;
        INT i = 2;

        //
        // If the share is ADMIN$ or IPC$, and the path has changed
        // popup an error.
        //
        if (  ( nlsShare._stricmp( nlsAdmin ) == 0 )
           || ( nlsShare._stricmp( nlsIPC) == 0 )
           )
        {
            if ( !fPathSame )
            {
                if ( IDNO == ::MsgPopup( this,
                               IERR_SPECIAL_SHARE_CANNOT_CHANGE_PATH,
                               MPSEV_WARNING, MP_YESNO, MP_YES ) )
                {
                    *pfCancel = TRUE;
                    SetPath( _nlsStoredPath );
                    break;
                }
                else
                {
                    break;
                }
            }
            else
            {
                break;
            }
        }

        //
        // If the path has changed, popup an warning asking the
        // user if he really wants to change the path.
        //
        if ( !fPathSame )
        {
             msgid = IDS_CHANGE_PATH_WARNING;
             apnlsParams[ i++ ] = &nlsPath;
             apnlsParams[ i++ ] = &nlsShare;
             apnlsParams[ i ] = NULL;

             if ( IDNO == ::MsgPopup( this, msgid, MPSEV_WARNING,
                                       HC_DEFAULT_HELP, MP_YESNO,
                                       apnlsParams, MP_NO ))
             {
                 *pfCancel = TRUE;
                 SetPath( _nlsStoredPath );
                 break;
             }
        }
        else
        {
             break;
        }

        //
        // If there are users connected to the share, popup the
        // warning dialog listing all users currently connected to the share.
        //

        SHARE_2 sh2( nlsShare, _psvr->QueryName(), FALSE );

        if (  (( err = sh2.QueryError()) == NERR_Success )
           && (( err = sh2.GetInfo()) == NERR_Success )
           && ( sh2.QueryCurrentUses() > 0 )
           )
        {

            BOOL fOK = TRUE;
            // There are users currently connected to the share to be deleted,
            // hence, popup a warning.
            CURRENT_USERS_WARNING_DIALOG *pdlg =
                new CURRENT_USERS_WARNING_DIALOG( QueryRobustHwnd(),
                                                  _psvr->QueryName(),
                                                  nlsShare,
                                                  QueryHelpContextBase() );


            if (  ( pdlg == NULL )
               || ((err = pdlg->QueryError()) != NERR_Success )
               || ((err = pdlg->Process( &fOK )) != NERR_Success )
               )
            {
                err = err? err : (APIERR) ERROR_NOT_ENOUGH_MEMORY;
            }

            delete pdlg;

            // User clicked CANCEL for the pdlg
            if ( !err && !fOK )
            {
                *pfCancel = TRUE;
                break;
            }

        }

        if ( err != NERR_Success )
            break;

        //
        // If all is well so far, read the share permissions.  When the
        // share is deleted and recreated, the permissions will be
        // reinstantiated as if the user had pressed "Permissions" in
        // the New Share dialog.  Otherwise the permissions will be lost
        // when the share is "renamed".
        //

        if ( (err = UpdatePermissionsInfo( _psvr,
                                           &sh2,
                                           pszShare )) != NERR_Success )
        {
            DBGEOL( "SRVMGR_SHARE_PROP_DIALOG::StopShareIfNecessary: error loading permissions" );
            break;
        }

        //
        // We also must set this flag to ensure that permissions will be
        // written on the new share
        //
        SetSecDescModified();

        //
        // Delete the share if everything went fine.
        //
        if ( (err = sh2.Delete()) == NERR_Success )
            *pfDeleteShare = TRUE;

        // falls through if error occurs
    } while ( FALSE );

    return err;
}

/*******************************************************************

    NAME:       SVRMGR_SHARE_PROP_DIALOG::OnOK

    SYNOPSIS:   Change the properties of the share when the user
                clicks OK button

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        1/8/92          Created

********************************************************************/

BOOL SVRMGR_SHARE_PROP_DIALOG::OnOK( VOID )
{
    AUTO_CURSOR autocur;

    BOOL fDeleteShare;
    BOOL fCancel;
    APIERR err;
    NLS_STR nlsShare;

    if (  ((err = nlsShare.QueryError()) == NERR_Success )
       && ((err = QueryShare( &nlsShare )) == NERR_Success )
       && ((err = StopShareIfNecessary( nlsShare, &fDeleteShare, &fCancel ))
           == NERR_Success )
       )
    {
        if ( !fCancel )
        {
            //
            // If the share is deleted because the user change the path,
            // create a new share with the same name.
            //
            if ( fDeleteShare )
            {
                _fDeleted = TRUE;
                if ( OnAddShare( _psvr ) )
                {
                    Dismiss( TRUE );
                }
            }

            //
            // Else change the properties of the existing share
            //
            else
            {
                err = OnChangeShareProperty( _psvr, nlsShare );

                switch ( err )
                {
                    case NERR_Success:
                        Dismiss( FALSE );
                        break;

                    case NERR_NetNameNotFound:
                        Dismiss( TRUE );
                        break;

                    case NERR_BadTransactConfig:
                        Dismiss( FALSE );
                        break;

                    case IERR_USER_CLICKED_CANCEL:
                        err = NERR_Success;
                        break;
                }
            }
        }
        else
        {
            if ( err == NERR_BadTransactConfig )
                Dismiss( FALSE );
            QuerySLEPath()->SelectString();
            QuerySLEPath()->ClaimFocus();
        }
    }

    if ( err != NERR_Success )
        ::MsgPopup( this, err );

    return TRUE;

}

/*******************************************************************

    NAME:       SVRMGR_SHARE_PROP_DIALOG::OnCancel

    SYNOPSIS:   Dismiss the dialog when the user clicks the CANCEL
                button.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        1/8/92          Created

********************************************************************/

BOOL SVRMGR_SHARE_PROP_DIALOG::OnCancel( VOID )
{
    Dismiss( _fDeleted );
    return TRUE;
}

/*******************************************************************

    NAME:       SVRMGR_SHARE_PROP_DIALOG::QueryHelpContext

    SYNOPSIS:   Get the help context of the dialog

    ENTRY:

    EXIT:

    RETURNS:    Return the help context

    NOTES:

    HISTORY:
        Yi-HsinS        1/8/92          Created

********************************************************************/
ULONG SVRMGR_SHARE_PROP_DIALOG::QueryHelpContext( VOID )
{
    return QueryHelpContextBase() + HC_SVRMGRSHAREPROP;
}

/*******************************************************************

    NAME:       FILEMGR_SHARE_PROP_DIALOG::FILEMGR_SHARE_PROP_DIALOG

    SYNOPSIS:   Constructor

    ENTRY:      hwndParent        - hwnd of the parent window
                pszSelectedDir    - name of the selected directory.
                ulHelpContextBase - the base help context

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        8/25/91         Created

********************************************************************/

FILEMGR_SHARE_PROP_DIALOG::FILEMGR_SHARE_PROP_DIALOG( HWND hwndParent,
                                              const TCHAR *pszSelectedDir,
                                              ULONG ulHelpContextBase )
    : SHARE_DIALOG_BASE( MAKEINTRESOURCE(IDD_FILEMGRSHAREPROPDLG),
                         hwndParent,
                         ulHelpContextBase ),
      _cbShare( this, CB_SHARE ),
      _nlsLocalPath(),
      _fShowDefault( TRUE ),
      _fCreatedShare( FALSE ),
      _psvr( NULL )
{
    if ( QueryError() != NERR_Success )
        return;

    UIASSERT( pszSelectedDir != NULL );

    APIERR err;
    if (  ((err = _nlsLocalPath.QueryError()) != NERR_Success )
       || ((err = Init( pszSelectedDir )) != NERR_Success )
       )
    {
        ReportError( err );
        return;
    }

    if ( !_psvr->IsNT() && _psvr->IsUserLevel() )
        QueryPBPermissions()->Enable( FALSE );
}

/*******************************************************************

    NAME:       FILEMGR_SHARE_PROP_DIALOG::~FILEMGR_SHARE_PROP_DIALOG

    SYNOPSIS:   Destructor

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        8/25/91         Created

********************************************************************/

FILEMGR_SHARE_PROP_DIALOG::~FILEMGR_SHARE_PROP_DIALOG()
{
    delete _psvr;
    _psvr = NULL;
}

/*******************************************************************

    NAME:       FILEMGR_SHARE_PROP_DIALOG::QueryServer2

    SYNOPSIS:   Get the server object

    ENTRY:

    EXIT:       *ppsvr - pointer to server object

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        8/25/91         Created

********************************************************************/

APIERR FILEMGR_SHARE_PROP_DIALOG::QueryServer2(
                                  SERVER_WITH_PASSWORD_PROMPT **ppsvr )
{
    UIASSERT( _psvr != NULL );
    *ppsvr = _psvr;
    return NERR_Success;
}

/*******************************************************************

    NAME:       FILEMGR_SHARE_PROP_DIALOG::Init

    SYNOPSIS:   2nd stage constructor

    ENTRY:      pszSelectedDir - name of the selected directory

    EXIT:

    RETURNS:

    NOTES:      Set up all internal variables and display the
                correct information in the dialog

    HISTORY:
        Yi-HsinS        4/2/92          Created

********************************************************************/

APIERR FILEMGR_SHARE_PROP_DIALOG::Init( const TCHAR *pszSelectedDir )
{

    APIERR err;

    NLS_STR nlsComputer;
    NLS_STR nlsUNCPath;
    SHARE_NET_NAME netName( pszSelectedDir, TYPE_PATH_ABS );

    if (  ((err = nlsComputer.QueryError()) == NERR_Success )
       && ((err = nlsUNCPath.QueryError()) == NERR_Success )
       && ((err = netName.QueryError()) == NERR_Success )
       && ((err = netName.QueryComputerName( &nlsComputer)) == NERR_Success)
       && ((err = netName.QueryLocalPath( &_nlsLocalPath)) == NERR_Success)
       )
    {
        if ( netName.IsLocal( &err ) && ( err == NERR_Success ))
        {
            nlsComputer = EMPTY_STRING;
            if ( nlsComputer.QueryError() != NERR_Success )
                return nlsComputer.QueryError();
        }

        _psvr = new SERVER_WITH_PASSWORD_PROMPT( nlsComputer,
                                                 QueryHwnd(),
                                                 QueryHelpContextBase() );
        if (  ( _psvr != NULL )
           && ((err = _psvr->QueryError()) == NERR_Success )
           && ((err = _psvr->GetInfo()) == NERR_Success )
           && ((err = SetMaxUserLimit( DetermineUserLimit(_psvr) )) == NERR_Success)
           && ((err = Refresh()) == NERR_Success )
           )
        {
            BOOL fLocal = netName.IsLocal( &err );
            if (( err == NERR_Success )  && !fLocal )
            {
                if ((err = netName.QueryUNCPath( &nlsUNCPath )) == NERR_Success)
                    SetPath( nlsUNCPath );
            }
            else
            {
                SetPath( _nlsLocalPath );
            }

            _cbShare.ClaimFocus();
        }
        else
        {
            err = err? err : ERROR_NOT_ENOUGH_MEMORY;
            delete _psvr;
            _psvr = NULL;
        }
    }

    return err;
}

/*******************************************************************

    NAME:       FILEMGR_SHARE_PROP_DIALOG::Refresh

    SYNOPSIS:   Refresh the combo box after the user created a new
                share

    ENTRY:      pszNewShareName - Optional parameter indicating
                                  what share to select after the refresh

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        4/2/92          Created

********************************************************************/

APIERR FILEMGR_SHARE_PROP_DIALOG::Refresh( const TCHAR *pszNewShareName )
{
    AUTO_CURSOR autocur;

    APIERR err;
    SHARE2_ENUM sh2Enum( _psvr->QueryName() );
    NET_NAME netName( _nlsLocalPath, TYPE_PATH_ABS );
    NLS_STR nlsDefaultShare;

    do {

        if (  ((err = sh2Enum.QueryError()) != NERR_Success )
           || ((err = netName.QueryError()) != NERR_Success )
           || ((err = nlsDefaultShare.QueryError()) != NERR_Success )
           || ((err = sh2Enum.GetInfo()) != NERR_Success )
           || ((err = netName.QueryLastComponent( &nlsDefaultShare))
               != NERR_Success)
           )
        {
            break;
        }

        _cbShare.DeleteAllItems();

        SHARE2_ENUM_ITER sh2EnumIter( sh2Enum );
        const SHARE2_ENUM_OBJ *pshi2;
        while ( (pshi2 = sh2EnumIter()) != NULL )
        {
            if ( ::stricmpf( pshi2->QueryPath(), _nlsLocalPath ) == 0 )
            {
                ALIAS_STR nlsTemp( pshi2->QueryName() );
                if ( _cbShare.AddItem( nlsTemp )  < 0 )
                {
                    err = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }
            }

            if ( ::stricmpf( pshi2->QueryName(), nlsDefaultShare ) == 0 )
                _fShowDefault = FALSE;

        }

        if ( err != NERR_Success )
            break;

        if ( _cbShare.QueryCount() == 0 )
        {
            err = IERR_SHARE_DIR_NOT_SHARED;
            break;
        }

        INT nSel = 0;
        if ( pszNewShareName )
            nSel = _cbShare.FindItemExact( pszNewShareName );

        _cbShare.SelectItem( nSel >= 0 ? nSel : 0 );

        NLS_STR nlsShare;
        if (  ((err = nlsShare.QueryError()) != NERR_Success )
           || ((err = QueryShare( &nlsShare )) != NERR_Success )
           || ((err = UpdateInfo( _psvr, nlsShare )) != NERR_Success )
           )
        {
            break;
        }

    } while ( FALSE );

    return err;

}

/*******************************************************************

    NAME:       FILEMGR_SHARE_PROP_DIALOG::OnCommand

    SYNOPSIS:   Check when the user changes the selection in the combobox
                or when the user clicks on the new share button

    ENTRY:      event - the event that occurred

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        1/8/92          Created

********************************************************************/

BOOL FILEMGR_SHARE_PROP_DIALOG::OnCommand( const CONTROL_EVENT &event )
{
    APIERR err = NERR_Success;

    if (  ( event.QueryCid() == CB_SHARE )
       && ( event.QueryCode() == CBN_SELCHANGE )
       )
    {
        //
        // When the user changes the selection in the listbox,
        // get the share the user has selected and display its
        // information in the dialog
        //
        NLS_STR nlsShare;
        if (  ((err = nlsShare.QueryError()) != NERR_Success )
           || ((err = QueryShare( &nlsShare )) != NERR_Success )
           || ((err = UpdateInfo( _psvr, nlsShare )) != NERR_Success )
           )
        {
            // Nothing to do
        }

    }
    else if ( event.QueryCid() == BUTTON_NEWSHARE )
    {
        //
        // The user clicked on the new share button, hence, show
        // the new share dialog.
        //
        NLS_STR nlsPath;
        NLS_STR nlsNewShareName;

        if (  ((err = nlsPath.QueryError()) == NERR_Success )
           && ((err = nlsNewShareName.QueryError()) == NERR_Success )
           && ((err = QueryPath( &nlsPath)) == NERR_Success )
           )
        {
            FILEMGR_NEW_SHARE_DIALOG *pdlg =
                new FILEMGR_NEW_SHARE_DIALOG( QueryHwnd(),
                                              nlsPath,
                                              QueryHelpContextBase(),
                                              _fShowDefault,
                                              &nlsNewShareName );

            BOOL fCreated;
            if (  ( pdlg != NULL )
               && ((err = pdlg->QueryError()) == NERR_Success )
               && ((err = pdlg->Process( &fCreated )) == NERR_Success )
               )
            {
                if ( fCreated )
                {
                    err = Refresh( nlsNewShareName );
                    _fCreatedShare = TRUE;
                }
            }
            else
            {
                err = err? err : ERROR_NOT_ENOUGH_MEMORY;
            }

            delete pdlg;
            pdlg = NULL;
        }
    }
    else
    {
        return SHARE_DIALOG_BASE::OnCommand( event );
    }

    if ( err != NERR_Success )
    {
        ::MsgPopup( this, err );
        if ( err == IERR_SHARE_DIR_NOT_SHARED )
            Dismiss( TRUE );
    }

    return TRUE;

}

/*******************************************************************

    NAME:       FILEMGR_SHARE_PROP_DIALOG::OnOK

    SYNOPSIS:   Change the property of the selected share

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        1/8/92          Created

********************************************************************/

BOOL FILEMGR_SHARE_PROP_DIALOG::OnOK( VOID )
{
    AUTO_CURSOR autocur;
    NLS_STR nlsShare;
    APIERR err;

    if (  ((err = nlsShare.QueryError()) == NERR_Success )
       && ((err = QueryShare( &nlsShare )) == NERR_Success )
       )
    {

        err = OnChangeShareProperty( _psvr, nlsShare );

        switch ( err )
        {
            case NERR_Success:
                Dismiss( _fCreatedShare );
                break;

            case NERR_NetNameNotFound:
                Dismiss( TRUE );
                break;

            case NERR_BadTransactConfig:
                Dismiss( FALSE );
                break;

            case IERR_USER_CLICKED_CANCEL:
                err = NERR_Success;
                break;
        }

    }

    if ( err != NERR_Success )
        ::MsgPopup( this, err );

    return TRUE;
}

/*******************************************************************

    NAME:       FILEMGR_SHARE_PROP_DIALOG::OnCancel

    SYNOPSIS:   Dismiss the dialog when the user clicks the Cancel
                button

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        1/8/92          Created

********************************************************************/

BOOL FILEMGR_SHARE_PROP_DIALOG::OnCancel( VOID )
{
    Dismiss( _fCreatedShare );
    return TRUE;
}

/*******************************************************************

    NAME:       FILEMGR_SHARE_PROP_DIALOG::QueryHelpContext

    SYNOPSIS:   Get the help context of the dialog

    ENTRY:

    EXIT:

    RETURNS:    Return the help context

    NOTES:

    HISTORY:
        Yi-HsinS        8/25/91         Created

********************************************************************/

ULONG FILEMGR_SHARE_PROP_DIALOG::QueryHelpContext( VOID )
{
    return QueryHelpContextBase() + HC_FILEMGRSHAREPROP;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\shellui\share\libmain.cxx ===
/*****************************************************************/
/**                  Microsoft LAN Manager                      **/
/**            Copyright(c) Microsoft Corp., 1989-1991          **/
/*****************************************************************/

/*
 *      Windows/Network Interface  --  LAN Manager Version
 *
 *      History
 *          terryk      01-Nov-1991     Add WNetResourceEnum Init and
 *                                      term function
 *          Yi-HsinS    31-Dec-1991     Unicode work
 *          terryk      03-Jan-1992     Capitalize the manifest
 *          beng        06-Apr-1992     Unicode conversion
 *          Yi-HsinS    20-Nov-1992     Added hmodAclEditor and
 *                                      pSedDiscretionaryAclEditor
 */

#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_DOSERRORS
#define INCL_NETERRORS
#define INCL_NETUSE
#define INCL_NETWKSTA
#define INCL_NETLIB
#define _WINNETWK_
#include <lmui.hxx>
#undef _WINNETWK_

extern "C"
{
    #include <dos.h>

    //#include <stdlib.h>

    #include <wnet1632.h>
    #include <winlocal.h>
    #include <wninit.h>

    #include <uimsg.h>        // For range of string IDs used
    #include <uirsrc.h>
    #include <helpnums.h>

    #include <sedapi.h>
}


#ifndef max
#define max(a,b)   ((a)>(b)?(a):(b))
#endif

#define INCL_BLT_CONTROL
#define INCL_BLT_DIALOG
#define INCL_BLT_MSGPOPUP
#include <blt.hxx>

#include <uitrace.hxx>

#include <wnetdev.hxx>
#include <string.hxx>

#include <strchlit.hxx>     // for STRING_TERMINATOR
#include <wnprop.hxx>

/*      Local prototypes         */

// reorged these for Glock
extern "C"
{
    BOOL NEAR PASCAL LIBMAIN              ( HINSTANCE hInst,
                                            UINT   wDataSeg,
                                            UINT   wHeapSize,
                                            LPSTR  lpCmdLine  );

    /* Under Win32, DllMain simply calls LIBMAIN.
     */
    BOOL DllMain( HINSTANCE hDll, DWORD dwReason, LPVOID lpvReserved ) ;

    void FAR PASCAL Enable                ( void              );

    void FAR PASCAL Disable               ( void              );

    INT FAR PASCAL WEP                    ( UINT   wWord      );

    void ErrorInitWarning                 ( APIERR err        );

#ifdef DEBUG            // debug scratch area
TCHAR CJJRW[64] ;
#endif

}

#define FAR_HEAPS_DLL 5  /* Maximum numbe of far heaps for ::new */

BOOL    fRealMode = FALSE;
HINSTANCE  hModule = NULL;

typedef DWORD (*PSEDDISCRETIONARYACLEDITOR)( HWND, HANDLE, LPWSTR,
              PSED_OBJECT_TYPE_DESCRIPTOR, PSED_APPLICATION_ACCESSES,
              LPWSTR, PSED_FUNC_APPLY_SEC_CALLBACK, ULONG_PTR, PSECURITY_DESCRIPTOR,
              BOOLEAN, LPDWORD );


HMODULE hmodAclEditor = NULL;

extern "C"
{
     PSEDDISCRETIONARYACLEDITOR pSedDiscretionaryAclEditor = NULL;
}

/*****
 *
 *  LIBMAIN
 *
 *  Purpose:
 *      Initialize DLL, which includes:
 *        - save away instance handle
 *        - set current capabilities
 *
 *  Parameters:
 *      hInst           Instance handle of DLL
 *
 *  Returns:
 *      TRUE            Init OK
 *      FALSE           Init failed
 */

BOOL /* NEAR PASCAL */ LIBMAIN    ( HINSTANCE          hInst,
                                    UINT            wDataSeg,
                                    UINT            wHeapSize,
                                    LPSTR           lpCmdLine       )
{
    UNREFERENCED (wDataSeg);
    UNREFERENCED (lpCmdLine);


    ::hModule = hInst;

    UNREFERENCED( wHeapSize );

    /* GetWinFlags goes away under Win32.
     */
    ::fRealMode = FALSE;

    return TRUE;
}  /* LIBMAIN */


/*******************************************************************

    NAME:       DllMain

    SYNOPSIS:   Win32 DLL Entry point.  This function gets called when
                a process or thread attaches/detaches itself to this DLL.
                We simply call the Win3 appropriate DLL function.

    ENTRY:      hDll - DLL Module handle
                dwReason - Indicates attach/detach
                lpvReserved - Not used

    EXIT:

    RETURNS:    TRUE if successful, FALSE otherwise

    NOTES:      This is the typical Win32 DLL entry style.

                This is Win32 only.

    HISTORY:
        Johnl   01-Nov-1991     Created

********************************************************************/

BOOL DllMain( HINSTANCE hDll, DWORD dwReason, LPVOID lpvReserved )
{
    UNREFERENCED( lpvReserved ) ;

    switch ( dwReason )
    {
    case DLL_PROCESS_ATTACH:
        DisableThreadLibraryCalls(hDll);
        return LIBMAIN( hDll, 0, 0, NULL ) ;

    case DLL_PROCESS_DETACH:
        return WEP( 0 ) ;

    default:
        // Unexpected reason given to Win32LibMain entry point
        UIASSERT(FALSE);
        break ;
    }

    return FALSE ;
}

/*******************************************************************

    NAME:       InitShellUI

    SYNOPSIS:   The function initializes the UI side of this DLL.  This
                helps the load time when the dll is used as a network
                provider for NT.

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:      Every UI entrypoint in this DLL should call this function.
                It will do the right thing if we've already been initialized.

    HISTORY:
        Johnl   07-Aug-1992     Created

********************************************************************/

BOOL fInitialized = FALSE ;

APIERR InitShellUI( void )
{
    APIERR err = NERR_Success ;


    if ( !fInitialized )
    {
        ::hmodAclEditor = NULL;
        ::pSedDiscretionaryAclEditor = NULL;

        if ( (err = BLT::Init(::hModule,
                              IDRSRC_SHELL_BASE, IDRSRC_SHELL_LAST,
                              IDS_UI_SHELL_BASE, IDS_UI_SHELL_LAST)) ||
              (err = I_PropDialogInit()) ||
              (err = BLT::RegisterHelpFile( ::hModule,
                                            IDS_SHELLHELPFILENAME,
                                            HC_UI_SHELL_BASE,
                                            HC_UI_SHELL_LAST)))
        {
            /* Fall through and don't set the initialized flag
             */
        }
        else
        {
            fInitialized = TRUE ;
        }
    }

    return err ;
}

/*******************************************************************

    NAME:       TermShellUI

    SYNOPSIS:   Frees the memory used to initialize this DLL

    NOTES:      Should only be called when the DLL is terminated and the
                DLL has been initialized (i.e., fInitialized=TRUE).

    HISTORY:
        Johnl   07-Aug-1992     Created

********************************************************************/

void TermShellUI( void )
{
    if ( fInitialized )
    {
        I_PropDialogUnInit() ;
        BLT::DeregisterHelpFile( ::hModule, 0 );
        BLT::Term( ::hModule );

        if ( ::hmodAclEditor != NULL )
            ::FreeLibrary( ::hmodAclEditor );
    }
}

/*
 *  Enable  - must be exported as ordinal @21 in .DEF file
 *
 *  Lanman driver exports this function so that Windows can call
 *  it whenever Lanman driver is started and each time it is swapped
 *  back in off disk.
 *
 *  Note: the corresponding function in Windows is Disable() which
 *        Windows will call it whenever driver is about to swapped
 *        out the disk and exit Windows.  Enable() and Disable()
 *        were implemented specifically for supporting the popup
 *        mechanisms, where you need to disengage yourself before
 *        being swapped to disk so that you won't be called when
 *        you're not there.
 *
 */

void Enable ( void )
{
   /* This is only to provide a entry point whenever Windows tries
    * to call Lanman driver.
    */
   return;

}  /* Enable */

/*
 *  Disable  - must be exported as ordinal @22 in .DEF file
 *
 *  Lanman driver exports this function so that Windows can call
 *  it whenever Lanman driver is exited and each time it is swapped
 *  out the disk.
 *
 */

void Disable ( void )
{
   return;
}  /* Disable */


/*
 *  WEP   (Windows Export Proc--short and cryptic name because
 *         this function is not given an ordinal)
 *
 *  When Windows unloads a driver, it calls this function so that
 *  the driver can do any last minute clean-ups.  Then, Windows
 *  calls the WEP function.  All Windows libraries are required to
 *  contain this function.  It should be included in the .def file
 *  but should not be given an ordinal.
 *
 */

INT WEP ( UINT wWord )
{
    UNREFERENCED( wWord ) ;
    TermShellUI() ;
    return 1;
}  /* WEP */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\shellui\xlate\ntprmdlg.h ===
#define SLT_RESOURCE_TYPE           101
#define SLTPLUS_RESOURCE_NAME       102
#define LB_SUBJECT_PERMISSIONS      103
#define CB_PERM_NAME                107
#define BUTTON_ADD                  110
#define BUTTON_REMOVE               111
#define IDHELP                      113
#define SEDNTPermContDlg            300
#define CHECK_APPLY_TO_CONT         301
#define CHECK_APPLY_TO_OBJECT       302
#define SEDContPermissions          400
#define SEDNTContPerm               100
#define SEDObjectPerm               200
#define SEDContPerm                 500
#define SEDNTContAudit              600
#define SLT_CHECK_TEXT_1            602
#define CHECK_AUDIT_S_1             603
#define CHECK_AUDIT_F_1             604
#define CHECK_AUDIT_S_2             608
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\common\fhclicfg\fhclicfg.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    fhclicfg.cpp

Abstract:
    Client configuration class

Revision History:
    created     derekm      03/31/00

******************************************************************************/

#include "stdafx.h"
#include "pfrcfg.h"

// allow the configuration to be settable
#define ENABLE_SRV_CONFIG_SETTING 1


/////////////////////////////////////////////////////////////////////////////
// defaults

const EEnDis    c_eedDefShowUI      = eedEnabled;
const EEnDis    c_eedDefReport      = eedEnabled;
const EIncEx    c_eieDefShutdown    = eieExclude;
const EEnDis    c_eedDefShowUISrv   = eedDisabled;
const EEnDis    c_eedDefReportSrv   = eedDisabled;
const EIncEx    c_eieDefShutdownSrv = eieInclude;

const EEnDis    c_eedDefTextLog     = eedDisabled;
const EIncEx    c_eieDefApps        = eieInclude;
const EIncEx    c_eieDefKernel      = eieInclude;
const EIncEx    c_eieDefMSApps      = eieInclude;
const EIncEx    c_eieDefWinComp     = eieInclude;

const BOOL      c_fForceQueue       = FALSE;
const BOOL      c_fForceQueueSrv    = TRUE;

const DWORD     c_cDefHangPipes     = c_cMinPipes;
const DWORD     c_cDefFaultPipes    = c_cMinPipes;
const DWORD     c_cDefMaxUserQueue  = 10;
#if defined(DEBUG) || defined(_DEBUG)
const DWORD     c_dwDefInternal     = 1;
#else
const DWORD     c_dwDefInternal     = 0;
#endif
const WCHAR     c_wszDefSrvI[]      = L"officewatson";
const WCHAR     c_wszDefSrvE[]      = L"watson.microsoft.com";

/////////////////////////////////////////////////////////////////////////////
// utility

// **************************************************************************
HRESULT AddToArray(SAppList &sal, SAppItem *psai)
{
	USE_TRACING("AddToArray");

    HRESULT hr = NOERROR;
    DWORD   i = sal.cSlotsUsed;
    BOOL    fUseFreedSlot = FALSE;

    // first, skim thru the array & see if there are any empty slots 
    if (sal.cSlotsEmpty > 0 && sal.rgsai != NULL)
    {
        for (i = 0; i < sal.cSlotsUsed; i++)
        {
            if (sal.rgsai[i].wszApp == NULL)
            {
                sal.cSlotsEmpty--;
                fUseFreedSlot = TRUE;
                break;
            }
        }
    }

    // nope, see if we need to grow the array
    if (sal.cSlotsUsed >= sal.cSlots && fUseFreedSlot == FALSE)
    {
        SAppItem    *rgsai = NULL;
        DWORD       cSlots;

        if (sal.cSlots == 0)
            cSlots = 16;
        else
            cSlots = 2 * sal.cSlots;
        rgsai = (SAppItem *)MyAlloc(cSlots * sizeof(SAppItem));
        VALIDATEEXPR(hr, (rgsai == NULL), E_OUTOFMEMORY);
        if (FAILED(hr))
            goto done;

        if (sal.rgsai != NULL)
        {
            CopyMemory(rgsai, sal.rgsai, sal.cSlots * sizeof(SAppItem));
            MyFree(sal.rgsai);
        }

        sal.rgsai   = rgsai;
        sal.cSlots  = cSlots;
    }

    // if we are appending, then gotta increase cSlotsUsed
    if (sal.cSlotsUsed == i)
        sal.cSlotsUsed++;

    sal.rgsai[i].dwState = psai->dwState;
    sal.rgsai[i].wszApp  = psai->wszApp;

done:
    return hr;
}

// **************************************************************************
BOOL ClearCPLDW(HKEY hkeyCPL)
{
    DWORD   dw;
    WCHAR   wch = L'\0';
    BOOL    fCleared = FALSE;
    HKEY    hkeyDW = NULL;

    if (hkeyCPL == NULL)
        return TRUE;

    // first, try deleting the key.  If that succeeded or it doesn't exist,
    //  then we're done.
    dw = RegDeleteKeyW(hkeyCPL, c_wszRKDW);
    if (dw == ERROR_SUCCESS || dw == ERROR_PATH_NOT_FOUND || 
        dw == ERROR_FILE_NOT_FOUND)
    {
        fCleared = TRUE;
        goto done;
    }

    // Otherwise, need to open the key
    dw = RegOpenKeyExW(hkeyCPL, c_wszRKDW, 0, KEY_READ | KEY_WRITE, &hkeyDW);
    if (dw != ERROR_SUCCESS)
        goto done;

    // try to delete the file path value from it.
    dw = RegDeleteValueW(hkeyDW, c_wszRVDumpPath);
    if (dw == ERROR_SUCCESS || dw == ERROR_PATH_NOT_FOUND || 
        dw == ERROR_FILE_NOT_FOUND)
    {
        fCleared = TRUE;
        goto done;
    }

    // ok, last try.  Try to write an empty string to the value
    dw = RegSetValueExW(hkeyDW, c_wszRVDumpPath, 0, REG_SZ, (LPBYTE)wch, 
                        sizeof(wch));
    if (dw == ERROR_SUCCESS)
    {
        fCleared = TRUE;
        goto done;
    }

done:
    if (hkeyDW != NULL)
        RegCloseKey(hkeyDW);

    return fCleared;
}


/////////////////////////////////////////////////////////////////////////////
// CPFFaultClientCfg- init & term

// **************************************************************************
CPFFaultClientCfg::CPFFaultClientCfg()
{
    OSVERSIONINFOEXW    osvi;

    INIT_TRACING
    USE_TRACING("CPFFaultClientCfg::CPFFaultClientCfg");

    InitializeCriticalSection(&m_cs);

    ZeroMemory(m_wszDump, sizeof(m_wszDump));
    ZeroMemory(m_wszSrv, sizeof(m_wszSrv));
    ZeroMemory(m_rgLists, sizeof(m_rgLists));

    ZeroMemory(&osvi, sizeof(osvi));
    osvi.dwOSVersionInfoSize = sizeof(osvi);
    GetVersionExW((OSVERSIONINFOW *)&osvi);

    if (osvi.wProductType == VER_NT_SERVER)
    {
        m_eieShutdown   = c_eieDefShutdownSrv;
        m_fForceQueue   = c_fForceQueueSrv;
        m_fSrv          = TRUE;
    }
    else
    {
        m_eieShutdown   = c_eieDefShutdown;
        m_fForceQueue   = c_fForceQueue;
        m_fSrv          = FALSE;
    }

    m_eedUI          = c_eedDefShowUI;
    m_eedReport      = c_eedDefReport;
    m_eieApps        = c_eieDefApps;
    m_eedTextLog     = c_eedDefTextLog;
    m_eieMS          = c_eieDefMSApps;
    m_eieWin         = c_eieDefWinComp;
    m_eieKernel      = c_eieDefKernel;
    m_cFaultPipes    = c_cDefFaultPipes;
    m_cHangPipes     = c_cDefHangPipes;
    m_cMaxQueueItems = c_cDefMaxUserQueue;

    m_dwStatus       = 0;
    m_dwDirty        = 0;
    m_pbWinApps      = NULL;
    m_fRead          = FALSE;
    m_fRO            = FALSE;
}

// **************************************************************************
CPFFaultClientCfg::~CPFFaultClientCfg(void)
{
    this->Clear();
    DeleteCriticalSection(&m_cs);
}

// **************************************************************************
void CPFFaultClientCfg::Clear(void)
{
    USE_TRACING("CPFFaultClientCfg::Clear");

    DWORD               i;

    for(i = 0; i < epfltListCount; i++)
    {
        if (m_rgLists[i].hkey != NULL)
            RegCloseKey(m_rgLists[i].hkey);
        if (m_rgLists[i].rgsai != NULL)
        {
            DWORD iSlot;
            for (iSlot = 0; iSlot < m_rgLists[i].cSlotsUsed; iSlot++)
            {
                if (m_rgLists[i].rgsai[iSlot].wszApp != NULL)
                    MyFree(m_rgLists[i].rgsai[iSlot].wszApp);
            }
         
            MyFree(m_rgLists[i].rgsai);
        }
    }
    
    ZeroMemory(m_wszDump, sizeof(m_wszDump));
    ZeroMemory(m_wszSrv, sizeof(m_wszSrv));
    ZeroMemory(m_rgLists, sizeof(m_rgLists));
    
    if (m_fSrv)
    {
        m_eieShutdown   = c_eieDefShutdownSrv;
        m_fForceQueue   = c_fForceQueueSrv;
    }
    else
    {
        m_eieShutdown   = c_eieDefShutdown;
        m_fForceQueue   = c_fForceQueue;
    }

    m_eedUI          = c_eedDefShowUI;
    m_eedReport      = c_eedDefReport;
    m_eieApps        = c_eieDefApps;
    m_eedTextLog     = c_eedDefTextLog;
    m_eieMS          = c_eieDefMSApps;
    m_eieWin         = c_eieDefWinComp;
    m_eieKernel      = c_eieDefKernel;
    m_cFaultPipes    = c_cDefFaultPipes;
    m_cHangPipes     = c_cDefHangPipes;
    m_cMaxQueueItems = c_cDefMaxUserQueue;

    m_dwStatus       = 0;
    m_dwDirty        = 0;
    m_pbWinApps      = NULL;
    m_fRead          = FALSE;
    m_fRO            = FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CPFFaultClientCfg- exposed

// **************************************************************************
HRESULT CPFFaultClientCfg::Read(EReadOptions ero)
{
    USE_TRACING("CPFFaultClientCfg::Read");

    CAutoUnlockCS aucs(&m_cs);

    HRESULT hr = NOERROR;
    WCHAR   wch = L'\0', *wszDefSrv;
    DWORD   cb, dw, i, cKeys = 0, iReport = 0, iShowUI = 0;
    DWORD   dwOpt;
    HKEY    rghkeyCfg[2], hkeyCfgDW = NULL, hkeyCPL = NULL;
    BOOL    fHavePolicy = FALSE;

    // this will automatically unlock when the fn exits
    aucs.Lock();

    dwOpt = (ero == eroCPRW) ? orkWantWrite : 0;

    this->Clear();

    rghkeyCfg[0] = NULL;
    rghkeyCfg[1] = NULL;

    // if we open read-only, then we will also try to read from the policy 
    //  settings cuz they override the control panel settings.  If the user
    //  wants write access, then we don't bother cuz we don't support writing
    //  to the policy keys via this object.
    // We use the RegOpenKeyEx function directly here cuz I don't want to 
    //  create the key if it doesn't exist (and that's what OpenRegKey will do)
    if (ero == eroPolicyRO)
    {
        TESTERR(hr, RegOpenKeyExW(HKEY_LOCAL_MACHINE, c_wszRPCfgPolicy, 0, 
                                  KEY_READ | KEY_WOW64_64KEY, &rghkeyCfg[0]));
        if (SUCCEEDED(hr))
        {
            cKeys       = 1;
            fHavePolicy = TRUE;
            DBG_MSG("policy found");
        }
    }

    // open the control panel reg key
    TESTHR(hr, OpenRegKey(HKEY_LOCAL_MACHINE, c_wszRPCfg, 0, 
                          &rghkeyCfg[cKeys]));
    if (SUCCEEDED(hr))
    {
        // need to check if a filepath exists in the DW control panel key.  If
        //  so, disable reporting & enable the UI (if reporting was enabled)
        if (ClearCPLDW(rghkeyCfg[cKeys]) == FALSE)
            m_dwStatus |= CPL_CORPPATH_SET;

        hkeyCPL = rghkeyCfg[cKeys];
        cKeys++;
    }

    // if we couldn't open either key successfully, then we don't need to do
    //  anything else.  The call to 'this->Clear()' above has already set
    //  all the values to their defaults.
    VALIDATEPARM(hr, (cKeys == 0));
    if (FAILED(hr))
    {
        hr = NOERROR;
        goto doneValidate;
    }

    // read in the report value
    cb = sizeof(m_eedReport);
    dw = c_eedDefReport;
    TESTHR(hr, ReadRegEntry(rghkeyCfg, cKeys, c_wszRVDoReport, NULL, 
                            (PBYTE)&m_eedReport, &cb, (PBYTE)&dw, sizeof(dw),
                            &iReport));
    if (FAILED(hr))
        goto done;

    // read in the ui value
    cb = sizeof(m_eedUI);
    dw = c_eedDefShowUI;
    TESTHR(hr, ReadRegEntry(rghkeyCfg, cKeys, c_wszRVShowUI, NULL, 
                            (PBYTE)&m_eedUI, &cb, (PBYTE)&dw, sizeof(dw),
                            &iShowUI));
    if (FAILED(hr))
        goto done;

    // set the policy info (note that the policy key is always set into 
    //  slot 0 of the array)
    if (fHavePolicy)
    {
        if (iReport == 0)
            m_dwStatus |= REPORT_POLICY;
        if (iShowUI == 0)
            m_dwStatus |= SHOWUI_POLICY;

        ErrorTrace(0, " iReport = %d, iShowUI = %d", iReport, iShowUI);

        // if we used the default value for reporting (we didn't find the 
        //  'report' value anywhere) then try to use the control panel settings
        //  for the rest of the stuff.
        if (iReport == 2 && cKeys == 2)
            iReport = 1;

        // if THAT doesn't exist, just bail cuz all of the other values have
        //  already been set to their defaults
        else if (iReport == 1 && cKeys == 1)
            goto doneValidate;

        // only use the key where we read the 'DoReport' value from.  Don't care
        //  what the other key has to say...
        if (iReport == 1)
        {
            HKEY    hkeySwap = rghkeyCfg[0];

            rghkeyCfg[0] = rghkeyCfg[1];
            rghkeyCfg[1] = hkeySwap;
            DBG_MSG("POLICY and CPL controls INVERTED!!!");
        }

        cKeys = 1;
    }

    // read in the inclusion list value
    cb = sizeof(m_eieApps);
    dw = c_eieDefApps;
    TESTHR(hr, ReadRegEntry(rghkeyCfg, cKeys, c_wszRVAllNone, NULL, 
                            (PBYTE)&m_eieApps, &cb, (PBYTE)&dw, sizeof(dw)));
    if (FAILED(hr))
        goto done;

    // read in the inc MS value
    cb = sizeof(m_eieMS);
    dw = c_eieDefMSApps;
    TESTHR(hr, ReadRegEntry(rghkeyCfg, cKeys, c_wszRVIncMS, NULL, 
                            (PBYTE)&m_eieMS, &cb, (PBYTE)&dw, sizeof(dw)));
    if (FAILED(hr))
        goto done;

    // read in the inc Windows components
    cb = sizeof(m_eieWin);
    dw = c_eieDefWinComp;
    TESTHR(hr, ReadRegEntry(rghkeyCfg, cKeys, c_wszRVIncWinComp, NULL, 
                            (PBYTE)&m_eieWin, &cb, (PBYTE)&dw, sizeof(dw))); 
    if (FAILED(hr))
        goto done;

    // read in the text log value
    cb = sizeof(m_eedTextLog);
    dw = c_eedDefTextLog;
    TESTHR(hr, ReadRegEntry(rghkeyCfg, cKeys, c_wszRVDoTextLog, NULL, 
                            (PBYTE)&m_eedTextLog, &cb, (PBYTE)&dw, sizeof(dw)));
    if (FAILED(hr))
        goto done;

    // read in the include kernel faults value
    cb = sizeof(m_eieKernel);
    dw = c_eieDefKernel;
    TESTHR(hr, ReadRegEntry(rghkeyCfg, cKeys, c_wszRVIncKernel, NULL, 
                            (PBYTE)&m_eieKernel, &cb, (PBYTE)&dw, 
                            sizeof(dw)));
    if (FAILED(hr))
        goto done;
    
    // read in the include shutdown errs value
    cb = sizeof(m_eieShutdown);
    dw = (m_fSrv) ? c_eieDefShutdownSrv : c_eieDefShutdown;
    TESTHR(hr, ReadRegEntry(rghkeyCfg, cKeys, c_wszRVIncShutdown, NULL, 
                            (PBYTE)&m_eieShutdown, &cb, (PBYTE)&dw, 
                            sizeof(dw)));
    if (FAILED(hr))
        goto done;
    // read in the # of fault pipes value
    cb = sizeof(m_cFaultPipes);
    dw = c_cDefFaultPipes;
    TESTHR(hr, ReadRegEntry(rghkeyCfg, cKeys, c_wszRVNumFaultPipe, NULL, 
                            (PBYTE)&m_cFaultPipes, &cb, (PBYTE)&dw, 
                            sizeof(dw)));
    if (FAILED(hr))
        goto done;

    // read in the # of hang pipes value
    cb = sizeof(m_cHangPipes);
    dw = c_cDefHangPipes;
    TESTHR(hr, ReadRegEntry(rghkeyCfg, cKeys, c_wszRVNumHangPipe, NULL, 
                            (PBYTE)&m_cHangPipes, &cb, (PBYTE)&dw, 
                            sizeof(dw)));
    if (FAILED(hr))
        goto done;

    // read in the max queue size value
    cb = sizeof(m_cMaxQueueItems);
    dw = c_cDefMaxUserQueue;
    TESTHR(hr, ReadRegEntry(rghkeyCfg, cKeys, c_wszRVMaxQueueSize, NULL, 
                            (PBYTE)&m_cMaxQueueItems, &cb, (PBYTE)&dw, 
                            sizeof(dw)));
    if (FAILED(hr))
        goto done;

    // read in the force queue mode value
    cb = sizeof(m_fForceQueue);
    dw = (m_fSrv) ? c_fForceQueueSrv : c_fForceQueue;
    TESTHR(hr, ReadRegEntry(rghkeyCfg, cKeys, c_wszRVForceQueue, NULL, 
                            (PBYTE)&m_fForceQueue, &cb, (PBYTE)&dw, 
                            sizeof(dw)));
    if (FAILED(hr))
        goto done;

    m_dwUseInternal=0;
    wcscpy(m_wszSrv, c_wszDefSrvE);

    // the dump path is stored in the DW reg key, so we need to try to
    //  open it up.  However, we only need this value if we're going
    //  to go into headless mode
    if (m_eedReport == eedEnabled && m_eedUI == eedDisabled)
    {
        // if the cpl corp path is set, we can't let DW do any reporting...
        if ((m_dwStatus & REPORT_POLICY) == 0 &&
            (m_dwStatus & CPL_CORPPATH_SET) != 0 &&
            m_eedReport == eedEnabled)
            m_eedReport = eedDisabled;

        if (m_eedReport == eedEnabled)
        {
            TESTERR(hr, RegOpenKeyExW(rghkeyCfg[0], c_wszRKDW, 0, KEY_READ, 
                                      &hkeyCfgDW));
            if (SUCCEEDED(hr))
            {
                // read in the dump path value
                cb = sizeof(m_wszDump);
                TESTHR(hr, ReadRegEntry(&hkeyCfgDW, 1, c_wszRVDumpPath, NULL, 
                                        (PBYTE)m_wszDump, &cb, (PBYTE)&wch, 
                                        sizeof(wch)));
                if (FAILED(hr))
                    goto done;
            }
        }
    }

    // it's ok if these fail.  The code below will correctly deal with the 
    //  situation...
    TESTHR(hr, OpenRegKey(rghkeyCfg[0], c_wszRKExList, dwOpt, 
                          &m_rgLists[epfltExclude].hkey));
    if (FAILED(hr))
        m_rgLists[epfltExclude].hkey = NULL;

    TESTHR(hr, OpenRegKey(rghkeyCfg[0], c_wszRKIncList, dwOpt,
                          &m_rgLists[epfltInclude].hkey));
    if (FAILED(hr))
        m_rgLists[epfltInclude].hkey = NULL;

    hr = NOERROR;

doneValidate:
    // validate the data we've read and reset the values to defaults if they
    //  are outside of the allowable range of values
    if (m_eedUI != eedEnabled && m_eedUI != eedDisabled && 
        m_eedUI != eedEnabledNoCheck)
        m_eedUI = c_eedDefShowUI;

    if (m_eedReport != eedEnabled && m_eedReport != eedDisabled)
        m_eedReport = c_eedDefReport;
    
    if (m_eedTextLog != eedEnabled && m_eedTextLog != eedDisabled)
        m_eedTextLog = c_eedDefTextLog;
    
    if (m_eieApps != eieIncDisabled && m_eieApps != eieExDisabled &&
        m_eieApps != eieInclude && m_eieApps != eieExclude)
        m_eieApps = c_eieDefApps;
    
    if (m_eieMS != eieInclude && m_eieMS != eieExclude)
        m_eieMS = c_eieDefMSApps;
    
    if (m_eieKernel != eieInclude && m_eieKernel != eieExclude)
        m_eieKernel = c_eieDefKernel;

    if (m_eieShutdown != eieInclude && m_eieShutdown != eieExclude)
        m_eieShutdown = (m_fSrv) ? c_eieDefShutdownSrv : c_eieDefShutdown;
    
    if (m_eieWin != eieInclude && m_eieWin != eieExclude)
        m_eieWin = c_eieDefWinComp;
    
    if (m_dwUseInternal != 1 && m_dwUseInternal != 0)
        m_dwUseInternal = c_dwDefInternal;

    if (m_cFaultPipes < c_cMinPipes)
        m_cFaultPipes = c_cMinPipes;
    else if (m_cFaultPipes > c_cMaxPipes)
        m_cFaultPipes = c_cMaxPipes;

    if (m_cHangPipes == c_cMinPipes)
        m_cHangPipes = c_cMinPipes;
    else if (m_cHangPipes > c_cMaxPipes)
        m_cHangPipes = c_cMaxPipes;

    if (m_cMaxQueueItems > c_cMaxQueue)
        m_cMaxQueueItems = c_cMaxQueue;

    if (m_fForceQueue != c_fForceQueue && m_fForceQueue != c_fForceQueueSrv)
        m_fForceQueue = (m_fSrv) ? c_fForceQueueSrv : c_fForceQueue;

    m_fRead = TRUE;
    m_fRO = (ero != eroCPRW);

    aucs.Unlock();

done:
    if (rghkeyCfg[0] != NULL)
        RegCloseKey(rghkeyCfg[0]);
    if (rghkeyCfg[1] != NULL)
        RegCloseKey(rghkeyCfg[1]);
    if (hkeyCfgDW != NULL)
        RegCloseKey(hkeyCfgDW);
    if (FAILED(hr))
        this->Clear();

    return hr;
}

#ifndef PFCLICFG_LITE

// **************************************************************************
BOOL CPFFaultClientCfg::HasWriteAccess(void)
{
    USE_TRACING("CPFFaultClientCfg::HasWriteAccess");
    
    HRESULT hr = NOERROR;
    DWORD   dwOpt = orkWantWrite;
    HKEY    hkeyMain = NULL, hkey = NULL;

    // attempt to open all the keys we use for the control panal to see if we
    //  have write access to them.  We only do this for the control panal cuz
    //  this class does not support writing out policy values, just reading
    //  them...

    TESTHR(hr, OpenRegKey(HKEY_LOCAL_MACHINE, c_wszRPCfg, dwOpt, &hkeyMain));
    if (FAILED(hr))
        goto done;

    RegCloseKey(hkey);
    hkey = NULL;

    TESTHR(hr, OpenRegKey(hkeyMain, c_wszRKExList, dwOpt, &hkey));
    if (FAILED(hr))
        goto done;

    RegCloseKey(hkey);
    hkey = NULL;

    TESTHR(hr, OpenRegKey(hkeyMain, c_wszRKIncList, dwOpt, &hkey));
    if (FAILED(hr))
        goto done;

done:
    if (hkeyMain != NULL)
        RegCloseKey(hkeyMain);
    if (hkey != NULL)
        RegCloseKey(hkey);

    return (SUCCEEDED(hr));
}



// **************************************************************************
HRESULT CPFFaultClientCfg::Write(void)
{
    USE_TRACING("CPFFaultClientCfg::Write");

    CAutoUnlockCS aucs(&m_cs);

    HRESULT hr = NOERROR;
    DWORD   dwOpt = orkWantWrite;
    HKEY    hkeyCfg = NULL;

    // this will automatically unlock when the fn exits
    aucs.Lock();
    
    if (m_fRO)
    {
        hr = E_ACCESSDENIED;
        goto done;
    }

    TESTHR(hr, OpenRegKey(HKEY_LOCAL_MACHINE, c_wszRPCfg, dwOpt, &hkeyCfg));
    if (FAILED(hr))
        goto done;


    // inclusion / exclusion list value
    if ((m_dwDirty & FHCC_ALLNONE) != 0)
    {
        TESTERR(hr, RegSetValueExW(hkeyCfg, c_wszRVAllNone, 0, REG_DWORD, 
                                   (PBYTE)&m_eieApps, sizeof(m_eieApps)));
        if (FAILED(hr))
            goto done;

        m_dwDirty &= ~FHCC_ALLNONE;
    }

    // ms apps in except list value
    if ((m_dwDirty & FHCC_INCMS) != 0)
    {
        TESTERR(hr, RegSetValueExW(hkeyCfg, c_wszRVIncMS, 0, REG_DWORD, 
                                   (PBYTE)&m_eieMS, sizeof(m_eieMS)));
        if (FAILED(hr))
            goto done;

        m_dwDirty &= ~FHCC_INCMS;
    }

    // ms apps in except list value
    if ((m_dwDirty & FHCC_WINCOMP) != 0)
    {
        TESTERR(hr, RegSetValueExW(hkeyCfg, c_wszRVIncWinComp, 0, REG_DWORD, 
                                   (PBYTE)&m_eieWin, sizeof(m_eieWin)));
        if (FAILED(hr))
            goto done;

        m_dwDirty &= ~FHCC_WINCOMP;
    }

    // show UI value
    if ((m_dwDirty & FHCC_SHOWUI) != 0)
    {
        TESTERR(hr, RegSetValueExW(hkeyCfg, c_wszRVShowUI, 0, REG_DWORD, 
                                   (PBYTE)&m_eedUI, sizeof(m_eedUI)));
        if (FAILED(hr))
            goto done;

        m_dwDirty &= ~FHCC_SHOWUI;
    }

    // do reporting value
    if ((m_dwDirty & FHCC_DOREPORT) != 0)
    {
        TESTERR(hr, RegSetValueExW(hkeyCfg, c_wszRVDoReport, 0, REG_DWORD, 
                                   (PBYTE)&m_eedReport, sizeof(m_eedReport)));
        if (FAILED(hr))
            goto done;

        m_dwDirty &= ~FHCC_DOREPORT;
    }

    // include kernel faults value
    if ((m_dwDirty & FHCC_R0INCLUDE) != 0)
    {
        TESTERR(hr, RegSetValueExW(hkeyCfg, c_wszRVIncKernel, 0, REG_DWORD, 
                                   (PBYTE)&m_eieKernel, sizeof(m_eieKernel)));
        if (FAILED(hr))
            goto done;

        m_dwDirty &= ~FHCC_R0INCLUDE;
    }

    // include shutdown value
    if ((m_dwDirty & FHCC_INCSHUTDOWN) != 0)
    {
        TESTERR(hr, RegSetValueExW(hkeyCfg, c_wszRVIncShutdown, 0, REG_DWORD, 
                                   (PBYTE)&m_eieShutdown, 
                                   sizeof(m_eieShutdown)));
        if (FAILED(hr))
            goto done;

        m_dwDirty &= ~FHCC_INCSHUTDOWN;
    }
    
    // # fault pipes value
    if ((m_dwDirty & FHCC_NUMFAULTPIPE) != 0)
    {
        TESTERR(hr, RegSetValueExW(hkeyCfg, c_wszRVNumFaultPipe, 0, REG_DWORD, 
                                   (PBYTE)&m_cFaultPipes, 
                                   sizeof(m_cFaultPipes)));
        if (FAILED(hr))
            goto done;

        m_dwDirty &= ~FHCC_NUMFAULTPIPE;
    }

    // # hang pipes value
    if ((m_dwDirty & FHCC_NUMHANGPIPE) != 0)
    {
        TESTERR(hr, RegSetValueExW(hkeyCfg, c_wszRVNumHangPipe, 0, REG_DWORD, 
                                   (PBYTE)&m_cHangPipes, 
                                   sizeof(m_cHangPipes)));
        if (FAILED(hr))
            goto done;

        m_dwDirty &= ~FHCC_NUMHANGPIPE;
    }

    // max user fault queue size value
    if ((m_dwDirty & FHCC_QUEUESIZE) != 0)
    {
        TESTERR(hr, RegSetValueExW(hkeyCfg, c_wszRVMaxQueueSize, 0, REG_DWORD, 
                                   (PBYTE)&m_cMaxQueueItems, 
                                   sizeof(m_cMaxQueueItems)));
        if (FAILED(hr))
            goto done;

        m_dwDirty &= ~FHCC_QUEUESIZE;
    }
    
    // default Server value
    if ((m_dwDirty & FHCC_DEFSRV) != 0)
    {
        DWORD cb;

        cb = wcslen(m_wszSrv) * sizeof(WCHAR);
        TESTERR(hr, RegSetValueExW(hkeyCfg, c_wszRVDefSrv, 0, REG_DWORD, 
                                   (PBYTE)m_wszSrv, cb));
        if (FAILED(hr))
            goto done;

        m_dwDirty &= ~FHCC_DEFSRV;
    }

    // dump path value
    if ((m_dwDirty & FHCC_DUMPPATH) != 0)
    {
        DWORD cb;

        cb = wcslen(m_wszDump) * sizeof(WCHAR);
        TESTERR(hr, RegSetValueExW(hkeyCfg, c_wszRVDumpPath, 0, REG_DWORD, 
                                   (PBYTE)m_wszDump, cb));
        if (FAILED(hr))
            goto done;

        m_dwDirty &= ~FHCC_DUMPPATH;
    }

    // force queue mode value
    if ((m_dwDirty & FHCC_FORCEQUEUE) != 0)
    {
        TESTERR(hr, RegSetValueExW(hkeyCfg, c_wszRVForceQueue, 0, REG_DWORD, 
                                   (PBYTE)&m_fForceQueue, 
                                   sizeof(m_fForceQueue)));
        if (FAILED(hr))
            goto done;

        m_dwDirty &= ~FHCC_FORCEQUEUE;
    }


    aucs.Unlock();

done:
    if (hkeyCfg != NULL)
        RegCloseKey(hkeyCfg);
    return hr;
}

#endif // PFCLICFG_LITE
    
// **************************************************************************
BOOL CPFFaultClientCfg::ShouldCollect(LPWSTR wszAppPath, BOOL *pfIsMSApp)
{
    USE_TRACING("CPFFaultClientCfg::ShouldCollect");

    CAutoUnlockCS   aucs(&m_cs);
    HRESULT         hr = NOERROR;
    WCHAR           *pwszApp, wszName[MAX_PATH], wszAppPathLocal[MAX_PATH];
    DWORD           i, cb, dwChecked, dw, dwMS, dwType;
    BOOL            fCollect = FALSE;

    if (wszAppPath == NULL)
    {
        GetModuleFileNameW(NULL, wszAppPathLocal, sizeofSTRW(wszAppPathLocal));
        wszAppPath = wszAppPathLocal;
    }

    if (pfIsMSApp != NULL)
        *pfIsMSApp = FALSE;

    aucs.Lock();    

    if (m_fRead == FALSE)
    {
        TESTHR(hr, this->Read());
        if (FAILED(hr))
            goto done;
    }

    // if we have reporting turned off or the 'programs' checkbox has been cleared
    //  in the control panel, then we are definitely not reporting
    if (m_eedReport == eedDisabled || m_eieApps == eieExDisabled || 
        m_eieApps == eieIncDisabled)
    {
        fCollect = FALSE;
        goto done;
    }

    // get a pointer to the app name
    for (pwszApp = wszAppPath + wcslen(wszAppPath);
         *pwszApp != L'\\' && pwszApp != wszAppPath;
         pwszApp--);
    if (*pwszApp == L'\\')
        pwszApp++;

    // are we collecting everything by default? 
    if (m_eieApps == eieInclude)
        fCollect = TRUE;

    if (fCollect == FALSE || pfIsMSApp != NULL)
    {
        // nope, check if it's another Microsoft app...
        dwMS = IsMicrosoftApp(wszAppPath, NULL, 0);

        if (dwMS != 0 && pfIsMSApp != NULL)
            *pfIsMSApp = TRUE;
    
        // is it a windows component?
        if (m_eieWin == eieInclude && (dwMS & APP_WINCOMP) != 0)
            fCollect = TRUE;

        // is it a MS app?
        if (m_eieMS == eieInclude && (dwMS & APP_MSAPP) != 0)
            fCollect = TRUE;
    }

    // see if it's on the inclusion list (only need to do this if we aren't 
    //  already collecting).  
    // Note that if the value is not a DWORD key or we get back an error
    //  saying that we don't have enuf space to hold the data, we just assume
    //  that it should be included.
    if (fCollect == FALSE && m_rgLists[epfltInclude].hkey != NULL)
    {
        cb = sizeof(dwChecked);
        dwType = REG_DWORD;
        dw = RegQueryValueExW(m_rgLists[epfltInclude].hkey, pwszApp, NULL,
                              &dwType, (PBYTE)&dwChecked, &cb);
        if ((dw == ERROR_SUCCESS && 
             (dwChecked == 1 || dwType != REG_DWORD)) ||
            dw == ERROR_MORE_DATA)
            fCollect = TRUE;
    }

    // see if it's on the exclusion list (only need to do this if we are going
    //  to collect something)
    // Note that if the value is not a DWORD key or we get back an error
    //  saying that we don't have enuf space to hold the data, we just assume
    //  that it should be excluded.
    if (fCollect && m_rgLists[epfltExclude].hkey != NULL)
    {
        cb = sizeof(dwChecked);
        dwType = REG_DWORD;
        dw = RegQueryValueExW(m_rgLists[epfltExclude].hkey, pwszApp, NULL,
                              &dwType, (PBYTE)&dwChecked, &cb);
        if ((dw == ERROR_SUCCESS && 
             (dwChecked == 1 || dwType != REG_DWORD)) ||
            dw == ERROR_MORE_DATA)
            fCollect = FALSE;
    }

done:
    return fCollect;
}


/////////////////////////////////////////////////////////////////////////////
// CPFFaultClientCfg- get properties

// **************************************************************************
static inline LPCWSTR get_string(LPWSTR wszOut, LPWSTR wszSrc, int cchOut)
{
    LPCWSTR wszRet;

    SetLastError(0);
    if (wszOut == NULL)
    {
        wszRet = wszSrc;
    }
    else
    {
        wszRet = wszOut;
        if (cchOut < lstrlenW(wszSrc))
        {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return NULL;
        }

        lstrcpyW(wszOut, wszSrc);
    }

    return wszRet;
}

// **************************************************************************
LPCWSTR CPFFaultClientCfg::get_DumpPath(LPWSTR wsz, int cch)
{
    USE_TRACING("CPFFaultClientCfg::get_DumpPath");

    CAutoUnlockCS aucs(&m_cs);
    aucs.Lock();    
    return get_string(wsz, m_wszDump, cch);
}


// **************************************************************************
LPCWSTR CPFFaultClientCfg::get_DefaultServer(LPWSTR wsz, int cch)
{
    USE_TRACING("CPFFaultClientCfg::get_DefaultServer");
    CAutoUnlockCS aucs(&m_cs);
    aucs.Lock();    
    return get_string(wsz, m_wszSrv, cch);
}

#ifndef PFCLICFG_LITE


/////////////////////////////////////////////////////////////////////////////
// CPFFaultClientCfg- set properties

// **************************************************************************
BOOL CPFFaultClientCfg::set_DumpPath(LPCWSTR wsz)
{
    USE_TRACING("CPFFaultClientCfg::set_DumpPath");

    CAutoUnlockCS aucs(&m_cs);

    if (wsz == NULL ||
        (wcslen(wsz) + 1) > sizeofSTRW(m_wszDump))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    aucs.Lock();   
    wcscpy(m_wszDump, wsz);
    m_dwDirty |= FHCC_DUMPPATH;
    return TRUE;
}

// **************************************************************************
BOOL CPFFaultClientCfg::set_DefaultServer(LPCWSTR wsz)
{
    USE_TRACING("CPFFaultClientCfg::set_DefaultServer");

    CAutoUnlockCS aucs(&m_cs);

    if (wsz == NULL ||
        (wcslen(wsz) + 1) > sizeofSTRW(m_wszSrv))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    aucs.Lock();    
    wcscpy(m_wszSrv, wsz);
    m_dwDirty |= FHCC_DEFSRV;
    return TRUE;
}


// **************************************************************************
BOOL CPFFaultClientCfg::set_ShowUI(EEnDis eed)
{
    USE_TRACING("CPFFaultClientCfg::set_ShowUI");

    CAutoUnlockCS aucs(&m_cs);

    if (eed & ~1 && (DWORD)eed != 3)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    
    aucs.Lock();    
    m_eedUI = eed;
    m_dwDirty |= FHCC_SHOWUI;
    return TRUE;
}

// **************************************************************************
BOOL CPFFaultClientCfg::set_DoReport(EEnDis eed)
{
    USE_TRACING("CPFFaultClientCfg::set_DoReport");

    CAutoUnlockCS aucs(&m_cs);

    if (eed & ~1)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    
    aucs.Lock();    
    m_eedReport = eed;
    m_dwDirty |= FHCC_DOREPORT;
    return TRUE;
}

// **************************************************************************
BOOL CPFFaultClientCfg::set_AllOrNone(EIncEx eie)
{
    USE_TRACING("CPFFaultClientCfg::set_AllOrNone");

    CAutoUnlockCS aucs(&m_cs);
    
    if (eie & ~3)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    aucs.Lock();
    m_eieApps = eie;
    m_dwDirty |= FHCC_ALLNONE;
    return TRUE;
}

// **************************************************************************
BOOL CPFFaultClientCfg::set_IncMSApps(EIncEx eie)
{
    USE_TRACING("CPFFaultClientCfg::set_IncMSApps");

    CAutoUnlockCS aucs(&m_cs);

    if (eie & ~1)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    aucs.Lock();    
    m_eieMS = eie;
    m_dwDirty |= FHCC_INCMS;
    return TRUE;
}

// **************************************************************************
BOOL CPFFaultClientCfg::set_IncWinComp(EIncEx eie)
{
    USE_TRACING("CPFFaultClientCfg::set_IncWinComp");

    CAutoUnlockCS aucs(&m_cs);

    if (eie & ~1)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    aucs.Lock();    
    m_eieWin = eie;
    m_dwDirty |= FHCC_WINCOMP;
    return TRUE;
}

// **************************************************************************
BOOL CPFFaultClientCfg::set_IncKernel(EIncEx eie)
{
    USE_TRACING("CPFFaultClientCfg::set_IncKernel");

    CAutoUnlockCS aucs(&m_cs);

    if (eie & ~1)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    aucs.Lock();    
    m_eieKernel = eie;
    m_dwDirty |= FHCC_R0INCLUDE;
    return TRUE;
}

// **************************************************************************
BOOL CPFFaultClientCfg::set_IncShutdown(EIncEx eie)
{
    USE_TRACING("CPFFaultClientCfg::set_IncShutdown");

    CAutoUnlockCS aucs(&m_cs);

    if (eie & ~1)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    aucs.Lock();    
    m_eieShutdown = eie;
    m_dwDirty |= FHCC_INCSHUTDOWN;
    return TRUE;
}

// **************************************************************************
BOOL CPFFaultClientCfg::set_ForceQueueMode(BOOL fForceQueueMode)
{
    USE_TRACING("CPFFaultClientCfg::set_IncKernel");

    CAutoUnlockCS aucs(&m_cs);

    if (fForceQueueMode & ~1)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    aucs.Lock();    
    m_fForceQueue = fForceQueueMode;
    m_dwDirty |= FHCC_FORCEQUEUE;
    return TRUE;
}


// **************************************************************************
BOOL CPFFaultClientCfg::set_NumFaultPipes(DWORD cPipes)
{
    USE_TRACING("CPFFaultClientCfg::set_NumFaultPipes");

    CAutoUnlockCS aucs(&m_cs);

    if (cPipes == 0 || cPipes > 8)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    aucs.Lock();    
    m_cFaultPipes = cPipes;
    m_dwDirty |= FHCC_NUMFAULTPIPE;
    return TRUE;
}

// **************************************************************************
BOOL CPFFaultClientCfg::set_NumHangPipes(DWORD cPipes)
{
    USE_TRACING("CPFFaultClientCfg::set_NumHangPipes");

    CAutoUnlockCS aucs(&m_cs);

    if (cPipes == 0 || cPipes > 8)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    aucs.Lock();    
    m_cHangPipes = cPipes;
    m_dwDirty |= FHCC_NUMHANGPIPE;
    return TRUE;
}

// **************************************************************************
BOOL CPFFaultClientCfg::set_MaxUserQueueSize(DWORD cItems)
{
    USE_TRACING("CPFFaultClientCfg::set_MaxUserQueueSize");

    CAutoUnlockCS aucs(&m_cs);

    if (cItems == 0 || cItems > 256)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    aucs.Lock();    
    m_cMaxQueueItems = cItems;
    m_dwDirty |= FHCC_QUEUESIZE;
    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// App lists

// **************************************************************************
HRESULT CPFFaultClientCfg::InitList(EPFListType epflt)
{
    USE_TRACING("CPFFaultClientCfg::get_IncListCount");

    CAutoUnlockCS   aucs(&m_cs);
    HRESULT         hr = NOERROR;
    DWORD           cItems = 0;
    
    VALIDATEPARM(hr, (epflt >= epfltListCount));
    if (FAILED(hr))
        goto done;

    aucs.Lock();    

    if (m_fRead == FALSE)
    {
        hr = E_FAIL;
        goto done;;
    }

    // if we've already initialized, then just clear the list out & return
    if ((m_rgLists[epflt].dwState & epfaaInitialized) != 0)
    {
        this->ClearChanges(epflt);
        m_rgLists[epflt].dwState &= ~epfaaInitialized;
    }

    if (m_rgLists[epflt].hkey != NULL)
    {
        TESTERR(hr, RegQueryInfoKeyW(m_rgLists[epflt].hkey, NULL, NULL, NULL, 
                                     NULL, NULL, NULL, 
                                     &m_rgLists[epflt].cItemsInReg, 
								     &m_rgLists[epflt].cchMaxVal, NULL, NULL, 
                                     NULL));
        if (FAILED(hr))
            goto done;
    }
    else
    {
        m_rgLists[epflt].cItemsInReg = 0;
        m_rgLists[epflt].cchMaxVal   = 0;
    }

    m_rgLists[epflt].dwState |= epfaaInitialized;
    
done:
    return hr;
}

// **************************************************************************
HRESULT CPFFaultClientCfg::get_ListRegInfo(EPFListType epflt, DWORD *pcbMaxName, 
                                           DWORD *pcApps)
{
    USE_TRACING("CPFFaultClientCfg::get_ListRegInfo");

    CAutoUnlockCS   aucs(&m_cs);
    HRESULT         hr = NOERROR;
    
    VALIDATEPARM(hr, (pcbMaxName == NULL || pcApps == NULL ||
                      epflt >= epfltListCount));
    if (FAILED(hr))
        goto done;

    aucs.Lock();    

    *pcbMaxName = 0;
    *pcApps     = 0;

    if (m_fRead == FALSE || (m_rgLists[epflt].dwState & epfaaInitialized) == 0)
    {
        hr = E_FAIL;
        goto done;
    }

    *pcbMaxName = m_rgLists[epflt].cchMaxVal;
    *pcApps     = m_rgLists[epflt].cItemsInReg;

done:
    return hr;
}

// **************************************************************************
HRESULT CPFFaultClientCfg::get_ListRegApp(EPFListType epflt, DWORD iApp, 
                                          LPWSTR wszApp, DWORD cchApp, 
                                          DWORD *pdwChecked)
{
    USE_TRACING("CPFFaultClientCfg::get_ListApp");

    CAutoUnlockCS   aucs(&m_cs);
    HRESULT         hr = NOERROR;
    WCHAR           wsz[MAX_PATH];
    DWORD           cchName, cbData, dw, dwType = 0;

    VALIDATEPARM(hr, (wszApp == NULL || pdwChecked == NULL ||
                      epflt >= epfltListCount));
    if (FAILED(hr))
        goto done;

    *wszApp     = L'\0';
    *pdwChecked = 0;

    aucs.Lock();
    
    if (m_fRead == FALSE || (m_rgLists[epflt].dwState & epfaaInitialized) == 0)
    {
        hr = E_FAIL;
        goto done;
    }

    cchName = cchApp;
    cbData  = sizeof(DWORD);
    dw = RegEnumValueW(m_rgLists[epflt].hkey, iApp, wszApp, &cchName, NULL, 
                       &dwType, (LPBYTE)pdwChecked, &cbData);
    if (dw != ERROR_SUCCESS && dw != ERROR_NO_MORE_ITEMS)
    {
        if (dw == ERROR_MORE_DATA)
        {
            dw = RegEnumValueW(m_rgLists[epflt].hkey, iApp, wszApp, &cchName, 
                               NULL, NULL, NULL, NULL);
            *pdwChecked = 1;
        }

        TESTERR(hr, dw);
        goto done;
    }

    if (dwType != REG_DWORD || (*pdwChecked != 1 && *pdwChecked != 0))
        *pdwChecked = 1;

    if (dw == ERROR_NO_MORE_ITEMS)
    {
        hr = S_FALSE;
        goto done;
    }

done:
    return hr;
}

// **************************************************************************
HRESULT CPFFaultClientCfg::add_ListApp(EPFListType epflt, LPCWSTR wszApp)
{
    USE_TRACING("CPFFaultClientCfg::add_ListApp");

    CAutoUnlockCS   aucs(&m_cs);
    SAppItem        sai;
    HRESULT         hr = NOERROR;
    LPWSTR          wszExe = NULL;
    DWORD           dw = 0, i;

    VALIDATEPARM(hr, (wszApp == NULL || epflt >= epfltListCount));
    if (FAILED(hr))
        goto done;

    aucs.Lock();

    if (m_fRO == TRUE)
    {
        hr = E_ACCESSDENIED;
        goto done;
    }

    if (m_fRead == FALSE || (m_rgLists[epflt].dwState & epfaaInitialized) == 0)
    {
        hr = E_FAIL;
        goto done;
    }

    // first, check if it's already on the mod list
    for (i = 0; i < m_rgLists[epflt].cSlotsUsed; i++)
    {
        if (m_rgLists[epflt].rgsai[i].wszApp != NULL &&
            _wcsicmp(m_rgLists[epflt].rgsai[i].wszApp, wszApp) == 0)
        {
            SETADD(m_rgLists[epflt].rgsai[i].dwState);
            SETCHECK(m_rgLists[epflt].rgsai[i].dwState);
            goto done;
        }
    }

    // add it to the list then...
    wszExe = (LPWSTR)MyAlloc((wcslen(wszApp) + 1) * sizeof(WCHAR));
    VALIDATEEXPR(hr, (wszExe == NULL), E_OUTOFMEMORY);
    if (FAILED(hr))
        goto done;

    wcscpy(wszExe, wszApp);
    sai.wszApp = wszExe;
    SETADD(sai.dwState);
    SETCHECK(sai.dwState);

    TESTHR(hr, AddToArray(m_rgLists[epflt], &sai));
    if (FAILED(hr))
        goto done;
    
    wszExe = NULL;

done:
    if (wszExe != NULL)
        MyFree(wszExe);

    return hr;
}


// **************************************************************************
HRESULT CPFFaultClientCfg::del_ListApp(EPFListType epflt, LPWSTR wszApp)
{
    USE_TRACING("CPFFaultClientCfg::del_ListApp");

    CAutoUnlockCS   aucs(&m_cs);
    SAppItem        sai;
    HRESULT         hr = NOERROR;
    LPWSTR          wszExe = NULL;
    DWORD           i;

    VALIDATEPARM(hr, (wszApp == NULL || epflt >= epfltListCount));
    if (FAILED(hr))
        goto done;

    aucs.Lock();

    if (m_fRO == TRUE)
    {
        hr = E_ACCESSDENIED;
        goto done;
    }

    // first, check if it's already on the mod list for add
    for (i = 0; i < m_rgLists[epflt].cSlotsUsed; i++)
    {
        if (m_rgLists[epflt].rgsai[i].wszApp != NULL &&
            _wcsicmp(m_rgLists[epflt].rgsai[i].wszApp, wszApp) == 0)
        {
            if (m_rgLists[epflt].rgsai[i].dwState & epfaaAdd)
            {
                // just set the wszApp field to NULL.  we'll reuse it
                //  on the next add to the array (if any)
                MyFree(m_rgLists[epflt].rgsai[i].wszApp);
                m_rgLists[epflt].rgsai[i].wszApp = NULL;
                m_rgLists[epflt].rgsai[i].dwState = 0;
                m_rgLists[epflt].cSlotsEmpty++;
            }
            else
            {
                SETDEL(m_rgLists[epflt].rgsai[i].dwState);
            }

            goto done;
        }
    }

    // add it to the list then...
    wszExe = (LPWSTR)MyAlloc((wcslen(wszApp) + 1) * sizeof(WCHAR));
    VALIDATEEXPR(hr, (wszExe == NULL), E_OUTOFMEMORY);
    if (FAILED(hr))
        goto done;

    wcscpy(wszExe, wszApp);
    sai.wszApp = wszExe;
    SETDEL(sai.dwState);

    TESTHR(hr, AddToArray(m_rgLists[epflt], &sai));
    if (FAILED(hr))
        goto done;

    wszExe = NULL;

done:
    if (wszExe != NULL)
        MyFree(wszExe);

    return hr;
}

// **************************************************************************
HRESULT CPFFaultClientCfg::mod_ListApp(EPFListType epflt, LPWSTR wszApp, 
                                       DWORD dwChecked)
{
    USE_TRACING("CPFFaultClientCfg::del_ListApp");

    CAutoUnlockCS   aucs(&m_cs);
    SAppItem        sai;
    HRESULT         hr = NOERROR;
    LPWSTR          wszExe = NULL;
    DWORD           i;

    VALIDATEPARM(hr, (wszApp == NULL || epflt >= epfltListCount));
    if (FAILED(hr))
        goto done;

    aucs.Lock();

    if (m_fRO == TRUE)
    {
        hr = E_ACCESSDENIED;
        goto done;
    }

    // first, check if it's already on the mod list
    for (i = 0; i < m_rgLists[epflt].cSlotsUsed; i++)
    {
        if (m_rgLists[epflt].rgsai[i].wszApp != NULL &&
            _wcsicmp(m_rgLists[epflt].rgsai[i].wszApp, wszApp) == 0)
        {
            if (dwChecked == 0)
            {
                REMCHECK(m_rgLists[epflt].rgsai[i].dwState);
            }
            else
            {
                SETCHECK(m_rgLists[epflt].rgsai[i].dwState);
            }

            goto done;
        }
    }

    // add it to the list then...
    wszExe = (LPWSTR)MyAlloc((wcslen(wszApp) + 1) * sizeof(WCHAR));
    VALIDATEEXPR(hr, (wszExe == NULL), E_OUTOFMEMORY);
    if (FAILED(hr))
        goto done;

    wcscpy(wszExe, wszApp);
    sai.wszApp  = wszExe;
    sai.dwState = ((dwChecked == 0) ? epfaaRemCheck : epfaaSetCheck);

    TESTHR(hr, AddToArray(m_rgLists[epflt], &sai));
    if (FAILED(hr))
        goto done;
    
    wszExe = NULL;

done:
    if (wszExe != NULL)
        MyFree(wszExe);

    return hr;
}

// **************************************************************************
HRESULT CPFFaultClientCfg::ClearChanges(EPFListType epflt)
{
    USE_TRACING("CPFFaultClientCfg::ClearChanges");

    CAutoUnlockCS   aucs(&m_cs);
    HRESULT         hr = NOERROR;
    DWORD           i;

    VALIDATEPARM(hr, (epflt >= epfltListCount));
    if (FAILED(hr))
        goto done;

    aucs.Lock();

    if (m_fRead == FALSE || (m_rgLists[epflt].dwState & epfaaInitialized) == 0)
    {
        hr = E_FAIL;
        goto done;
    }

    if (m_rgLists[epflt].rgsai == NULL)
        goto done;

    for(i = 0; i < m_rgLists[epflt].cSlotsUsed; i++)
    {
        m_rgLists[epflt].rgsai[i].dwState = 0;
        if (m_rgLists[epflt].rgsai[i].wszApp != NULL)
        {
            MyFree(m_rgLists[epflt].rgsai[i].wszApp);
            m_rgLists[epflt].rgsai[i].wszApp = NULL;
        }
    }

    m_rgLists[epflt].cSlotsUsed = 0;

done:
    return hr;
}

// **************************************************************************
HRESULT CPFFaultClientCfg::CommitChanges(EPFListType epflt)
{
    USE_TRACING("CPFFaultClientCfg::CommitChanges");

    CAutoUnlockCS   aucs(&m_cs);
    HRESULT         hr = NOERROR;
    DWORD           i, dw;

    VALIDATEPARM(hr, (epflt >= epfltListCount));
    if (FAILED(hr))
        goto done;

    aucs.Lock();

    if (m_fRO == TRUE)
    {
        hr = E_ACCESSDENIED;
        goto done;
    }

    if (m_fRead == FALSE || (m_rgLists[epflt].dwState & epfaaInitialized) == 0)
    {
        hr = E_FAIL;
        goto done;
    }

    if (m_rgLists[epflt].hkey == NULL)
    {
        hr = E_ACCESSDENIED;
        goto done;
    }

    if (m_rgLists[epflt].rgsai == NULL)
        goto done;

    // don't need to compress the array.  Since we always append & never 
    //  delete out of the array until a commit, once I hit an 'Add', anything 
    //  after that in the array MUST also be an 'Add'.
    for (i = 0; i < m_rgLists[epflt].cSlotsUsed; i++)
    {
        if (m_rgLists[epflt].rgsai[i].wszApp == NULL)
        {
            m_rgLists[epflt].rgsai[i].dwState = 0;
            continue;
        }

        if ((m_rgLists[epflt].rgsai[i].dwState & epfaaDelete) != 0)
        {
            dw = RegDeleteValueW(m_rgLists[epflt].hkey, 
                                 m_rgLists[epflt].rgsai[i].wszApp);
            if (dw != ERROR_SUCCESS && dw != ERROR_FILE_NOT_FOUND)
            {
                TESTERR(hr, dw);
                goto done;
            }
        }

        else
        {
            DWORD dwChecked;

            dwChecked = (ISCHECKED(m_rgLists[epflt].rgsai[i].dwState)) ? 1 : 0;
            TESTERR(hr, RegSetValueExW(m_rgLists[epflt].hkey, 
                                       m_rgLists[epflt].rgsai[i].wszApp, 0, 
                                       REG_DWORD, (LPBYTE)&dwChecked, 
                                       sizeof(DWORD)));
            if (FAILED(hr))
                goto done;
        }

        MyFree(m_rgLists[epflt].rgsai[i].wszApp);
        m_rgLists[epflt].rgsai[i].wszApp  = NULL;
        m_rgLists[epflt].rgsai[i].dwState = 0;
    }

    m_rgLists[epflt].cSlotsUsed = 0;

done: 
    return hr;
}

// **************************************************************************
BOOL CPFFaultClientCfg::IsOnList(EPFListType epflt, LPCWSTR wszApp)
{
    USE_TRACING("CPFFaultClientCfg::IsOnList");

    SAppList    *psap;
    HRESULT     hr = NOERROR;
    DWORD       i;
    HKEY        hkey = NULL;

    VALIDATEPARM(hr, (epflt >= epfltListCount || wszApp == NULL));
    if (FAILED(hr))
        goto done;

    if ((m_rgLists[epflt].dwState & epfaaInitialized) == 0)
    {
        hr = E_FAIL;
        goto done;
    }

    // first, check the mod list.  This is because if we check the registry
    //  first, we miss the case where the user just deleted it and it's 
    //  therefore sitting in the mod list
    hr = S_FALSE;
    for (i = 0; i < m_rgLists[epflt].cSlotsUsed; i++)
    {
        if (m_rgLists[epflt].rgsai[i].wszApp != NULL &&
            _wcsicmp(m_rgLists[epflt].rgsai[i].wszApp, wszApp) == 0)
        {
            if ((m_rgLists[epflt].rgsai[i].dwState & epfaaDelete) == 0)
                hr = NOERROR;
            goto done;
        }
    }

    // next, check the registry.
    TESTERR(hr, RegQueryValueExW(m_rgLists[epflt].hkey, wszApp, NULL, NULL, 
                                 NULL, NULL));
    if (SUCCEEDED(hr))
        goto done;
    
done:
    return (hr == NOERROR);
}


#endif PFCLICFG_LITE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\common\pfcommon\ntevents.cpp ===
/********************************************************************

Copyright (c) 1995-2000 Microsoft Corporation

Module Name:
    ntevents.cpp

Abstract:
    Defines a generic class that can register an NT
    event source and log NT events on that evens source.

Revision History:
    rsraghav  created   03/10/95
    DerekM    modified  04/06/99

********************************************************************/


#include "stdafx.h"
#include "ntevents.h"


/////////////////////////////////////////////////////////////////////////////
// tracing

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile


/////////////////////////////////////////////////////////////////////////////
// CWebLog- initialization stuff

// **************************************************************************
CNTEvent::CNTEvent(void)
{
    m_hEventSource = INVALID_HANDLE_VALUE; 
}

// **************************************************************************
CNTEvent::~CNTEvent()
{
    if (m_hEventSource != INVALID_HANDLE_VALUE)
    {
        DeregisterEventSource(m_hEventSource);
        m_hEventSource = NULL;
    }
}


/////////////////////////////////////////////////////////////////////////////
// CWebLog- exposed methods

// **************************************************************************
HRESULT CNTEvent::InitEventLog(LPCWSTR wszEventSourceName)
{
    USE_TRACING("CNTEvent::InitEventLog");
    
    if (wszEventSourceName == NULL)
        return E_INVALIDARG;

    m_hEventSource = RegisterEventSourceW(NULL, wszEventSourceName);
    if (m_hEventSource == INVALID_HANDLE_VALUE)
        return Err2HR(GetLastError());

    return NOERROR;
}

// **************************************************************************
HRESULT CNTEvent::TerminateEventLog(void)
{
    USE_TRACING("CNTEvent::TerminateEventLog");

    HRESULT hr = NOERROR;

    if (m_hEventSource != INVALID_HANDLE_VALUE)
    {
        TESTBOOL(hr, DeregisterEventSource(m_hEventSource))
    }

    m_hEventSource = INVALID_HANDLE_VALUE;
    return hr;
}


// **************************************************************************
HRESULT CNTEvent::LogEvent(WORD wEventType, DWORD dwEventID, LPCWSTR wszParam1, 
                           LPCWSTR wszParam2, LPCWSTR wszParam3, LPCWSTR wszParam4,
                           LPCWSTR wszParam5, LPCWSTR wszParam6, LPCWSTR wszParam7,                        
                           LPCWSTR wszParam8, LPCWSTR wszParam9)
{
    USE_TRACING("CNTEvent::LogEvent");

    HRESULT hr = NOERROR;

    if (m_hEventSource == INVALID_HANDLE_VALUE)
        return E_FAIL;

    LPCWSTR wszInsertString[10];
    WORD cInsertStrings = 0;
    if (wszParam1 != NULL)
    {
        cInsertStrings++;
        wszInsertString[0] = wszParam1;

        if (wszParam2 != NULL)
        {
            cInsertStrings++;
            wszInsertString[1] = wszParam2;
            
            if (wszParam3 != NULL)
            {
                cInsertStrings++;
                wszInsertString[2] = wszParam3;

                if (wszParam4 != NULL)
                {
                    cInsertStrings++;
                    wszInsertString[3] = wszParam4;

                    if (wszParam5 != NULL)
                    {
                        cInsertStrings++;
                        wszInsertString[4] = wszParam5;

                        if (wszParam6 != NULL)
                        {
                            cInsertStrings++;
                            wszInsertString[5] = wszParam6;

                            if (wszParam7 != NULL)
                            {
                                cInsertStrings++;
                                wszInsertString[6] = wszParam7;
                                
                                if (wszParam8 != NULL)
                                {
                                    cInsertStrings++;
                                    wszInsertString[7] = wszParam8;

                                    if (wszParam9 != NULL)
                                    {
                                        cInsertStrings++;
                                        wszInsertString[8] = wszParam9;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    TESTBOOL(hr, ReportEventW(m_hEventSource, wEventType, 0, dwEventID, NULL, 
                              cInsertStrings, 0, (LPCWSTR *)wszInsertString, 
                              NULL))
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\common\pfcommon\pfarray.cpp ===
/********************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    PFArray.cpp

Abstract:
    dynamic array implementation.  This dynamic array is NOT thread 
    safe.

Revision History:
    DerekM  modified 03/14/00

********************************************************************/

#include "stdafx.h"
#include "pfarray.h"


/////////////////////////////////////////////////////////////////////////////
// tracing

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile


/////////////////////////////////////////////////////////////////////////////
// CPFArrayBase initialization & deinitialization

// **************************************************************************
CPFArrayBase::CPFArrayBase(void)
{
    m_pfnAlloc  = NULL;
    m_pfnDelete = NULL;
    m_rgpv      = NULL;
    m_cSlots    = 0;
    m_iHighest  = (DWORD)-1;
}

// **************************************************************************
CPFArrayBase::~CPFArrayBase(void)
{
    this->CompressArray(0, (DWORD)-1);
    if (m_rgpv != NULL)
        MyFree(m_rgpv, g_hPFPrivateHeap);
}


/////////////////////////////////////////////////////////////////////////////
// CAUOPropDB internal methods

// ***************************************************************************
inline HRESULT CPFArrayBase::Grow(DWORD iMinLast)
{
	USE_TRACING("CPFArrayBase::SetItem");

    HRESULT hr = NOERROR;

    if (iMinLast >= m_cSlots || m_rgpv == NULL)
    {
        LPVOID  *rgpv  = NULL;
        DWORD   cSlots;

        cSlots = MyMax(iMinLast + 1, 8);
        cSlots = MyMax(m_cSlots * 2, cSlots);
        rgpv = (LPVOID *)MyAlloc(cSlots * sizeof(LPVOID), g_hPFPrivateHeap);
        VALIDATEEXPR(hr, (rgpv == NULL), E_OUTOFMEMORY);
        if (FAILED(hr))
            goto done;

        if (m_rgpv != NULL)
        {
            CopyMemory(rgpv, m_rgpv, m_cSlots * sizeof(LPVOID));
            MyFree(m_rgpv);
        }

        m_rgpv   = rgpv;
        m_cSlots = cSlots;
    }

done:
    return hr;
}

// ***************************************************************************
inline HRESULT CPFArrayBase::CompressArray(DWORD iStart, DWORD iEnd)
{
	USE_TRACING("CPFArrayBase::CompressArray");

    _ASSERT(iStart < iEnd);

    // don't need to do anything cuz we're already empty
    if (m_iHighest == (DWORD)-1)
        return NOERROR;

    if (iStart <= m_iHighest)
    {
        DWORD   i;

        // note that this will also catch passing -1 for iEnd cuz (DWORD)-1 
        //  is greater than any other DWORD value...  Of course, this 
        //  assumes that we don't have 2^32 - 1 elements.  While it is 
        //  theoretically possible to have an array that big on ia64, this
        //  class can't be used for it.
        if (iEnd > m_iHighest + 1)
            iEnd = m_iHighest + 1;

        for(i = iStart; i < iEnd; i++)
        {
            if (m_rgpv[i] != NULL)
                this->DeleteItem(m_rgpv[i]);
        }

        // no point in doing a move if we're not going to be moving anything
        if (iEnd <= m_iHighest)
        {
            MoveMemory(&m_rgpv[iStart], &m_rgpv[iEnd], 
                       (m_iHighest - iEnd + 1) * sizeof(LPVOID));
        }
    }

    m_iHighest -= (iEnd - iStart);

    return NOERROR;
}

// ***************************************************************************
HRESULT CPFArrayBase::internalCopyFrom(CPFArrayBase *prg)
{
	USE_TRACING("CPFArrayBase::CopyFrom");

    HRESULT hr = NOERROR;
    DWORD   i;

    // if it's at -1, then we've deleted everything already...
    if (prg->m_iHighest == (DWORD)-1)
        goto done;

    TESTHR(hr, this->Grow(prg->m_iHighest + 1));
    if (FAILED(hr))
        goto done;

    for(i = 0; i < prg->m_iHighest + 1; i++)
    {
        m_rgpv[i] = prg->AllocItemCopy(prg->m_rgpv[i]);
        VALIDATEEXPR(hr, (m_rgpv[i] == NULL), E_OUTOFMEMORY);
        if (FAILED(hr))
        {
            this->RemoveAll();
            goto done;
        }
    }

done:
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CPFArrayBase exposed methods / properties

// ***************************************************************************
HRESULT CPFArrayBase::Init(DWORD cSlots)
{
	USE_TRACING("CPFArrayBase::Init");

    HRESULT hr = NOERROR;

    VALIDATEEXPR(hr, (m_rgpv != NULL), E_FAIL);
    if (FAILED(hr))
        goto done;

    TESTHR(hr, this->Grow(cSlots - 1));
    if (FAILED(hr))
        goto done;

done:
    return hr;
}

// ***************************************************************************
LPVOID &CPFArrayBase::operator [](DWORD iItem)
{
	USE_TRACING("CPFArrayBase::operator []");

    if (iItem >= m_cSlots || m_rgpv == NULL)
    {
        HRESULT hr;
        TESTHR(hr, this->Grow(iItem));
        _ASSERT(SUCCEEDED(hr));
    }

    // since we have to return a reference, we can't do much about Grow failing
    //  which means of course that we could fault...
    return m_rgpv[iItem];
}

// ***************************************************************************
HRESULT CPFArrayBase::get_Item(DWORD iItem, LPVOID *ppv)
{
	USE_TRACING("CPFArrayBase::get_Item");

    HRESULT hr = NOERROR;

    VALIDATEPARM(hr, (ppv == NULL))
    if (FAILED(hr))
        goto done;

    if (iItem >= m_cSlots || m_rgpv == NULL)
    {
        TESTHR(hr, this->Grow(iItem));
        if (FAILED(hr))
            goto done;
    }

    if (ppv != NULL)
        *ppv = m_rgpv[iItem];
        
done:
    return hr;
}

// ***************************************************************************
HRESULT CPFArrayBase::put_Item(DWORD iItem, LPVOID pv, LPVOID *ppvOld)
{
    USE_TRACING("CPFArrayBase::put_Item");

    HRESULT hr = NOERROR;

    if (iItem >= m_cSlots || m_rgpv == NULL)
    {
        TESTHR(hr, this->Grow(m_iHighest + 1));
        if (FAILED(hr))
            goto done;
    }

    if (ppvOld != NULL)
        *ppvOld = m_rgpv[iItem];
    else if (m_rgpv[iItem] != NULL)
        this->DeleteItem(m_rgpv[iItem]);
    m_rgpv[iItem] = pv;

    if (iItem > m_iHighest)
        m_iHighest = iItem;

done:
	return hr;
}

// ***************************************************************************
HRESULT CPFArrayBase::Append(LPVOID pv)
{
	USE_TRACING("CPFArrayBase::Append");

    HRESULT hr = NOERROR;

    if (pv == NULL)
        pv = NULL;

    if (m_iHighest + 1 >= m_cSlots || m_rgpv == NULL)
    {
        TESTHR(hr, this->Grow(m_iHighest + 1));
        if (FAILED(hr))
            goto done;
    }

    m_iHighest++;
    m_rgpv[m_iHighest] = pv;

done:
    return hr;
}

// ***************************************************************************
HRESULT CPFArrayBase::Remove(DWORD iItem, LPVOID *ppvOld)
{
	USE_TRACING("CPFArrayBase::Remove");

    HRESULT hr = NOERROR;

    if (iItem > m_iHighest)
        goto done;

    if (ppvOld != NULL)
        *ppvOld = m_rgpv[iItem];
        
	TESTHR(hr, this->CompressArray(iItem, iItem + 1));
    if (FAILED(hr))
        return hr;

done:
    return hr;
}

// ***************************************************************************
HRESULT CPFArrayBase::RemoveAll(void)
{
	USE_TRACING("CPFArrayBase::RemoveAll");

    HRESULT hr = NOERROR;

    // if it's at -1, then we've deleted everything already...
    if (m_iHighest == (DWORD)-1)
        goto done;

	TESTHR(hr, this->CompressArray(0, (DWORD)-1));
    if (FAILED(hr))
        return hr;

done:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\common\fhclicfg\full\stdafx.h ===
/********************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    stdafx.h

Abstract:
    PCH

Revision History:
    DerekM  created  04/04/00

********************************************************************/

// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__F6D93C3Q_DF3F_11D2_80AF_00C04F688C0B__INCLUDED_)
#define AFX_STDAFX_H__F6D93C3Q_DF3F_11D2_80AF_00C04F688C0B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <windows.h>
#include <malloc.h>

#define NOTRACE 1

#include "util.h"


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__F6D93C3Q_DF3F_11D2_80AF_00C04F688C0B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\common\fhclicfg\lite\stdafx.h ===
/********************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    stdafx.h

Abstract:
    PCH

Revision History:
    DerekM  created  04/04/00

********************************************************************/

// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__F6D93C3Q_DF3F_11D2_80AF_00C04F688C0B__INCLUDED_)
#define AFX_STDAFX_H__F6D93C3Q_DF3F_11D2_80AF_00C04F688C0B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "windows.h"
#include "malloc.h"

#define PFCLICFG_LITE 1
#ifndef DEBUG
#define NOTRACE 1
#endif

#include "util.h"



//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__F6D93C3Q_DF3F_11D2_80AF_00C04F688C0B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\common\fhclicfg\util.cpp ===
/********************************************************************

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:
    util.cpp

Abstract:
    utility functions implementation

Revision History:
    DerekM  created  05/01/99

********************************************************************/

#include "stdafx.h"
#include "util.h"
#ifdef MANIFEST_HEAP
#include <ercommon.h>
#endif  // MANIFEST_HEAP

/////////////////////////////////////////////////////////////////////////////
// tracing

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile

HANDLE  g_hPFPrivateHeap = NULL;

struct SLangCodepage
{
  WORD wLanguage;
  WORD wCodePage;
};




//////////////////////////////////////////////////////////////////////////////
// string stuff

// ***************************************************************************
WCHAR *MyStrStrIW(const WCHAR *wcs1, const WCHAR *wcs2)
{
    WCHAR *cp = (WCHAR *)wcs1;
    WCHAR *s1, *s2;

    while (*cp != '\0')
    {
        s1 = cp;
        s2 = (WCHAR *) wcs2;

        while (*s1 != '\0' && *s2 !='\0' && (towlower(*s1) - towlower(*s2)) == 0)
            s1++, s2++;

        if (*s2 == '\0')
             return(cp);

        cp++;
    }

    return(NULL);
}

// ***************************************************************************
CHAR *MyStrStrIA(const CHAR *cs1, const CHAR *cs2)
{
    CHAR *cp = (CHAR *)cs1;
    CHAR *s1, *s2;

    while (*cp != '\0')
    {
        s1 = cp;
        s2 = (CHAR *) cs2;

        while (*s1 != '\0' && *s2 !='\0' && (tolower(*s1) - tolower(*s2)) == 0)
            s1++, s2++;

        if (*s2 == '\0')
             return(cp);

        cp++;
    }

    return(NULL);
}


////////////////////////////////////////////////////////////////////////////
// temp file stuff

// ***************************************************************************
BOOL DeleteTempDirAndFile(LPCWSTR wszPath, BOOL fFilePresent)
{
    LPWSTR  wszPathToDel = NULL, pwsz;
    DWORD   cchPath;
    BOOL    fRet = FALSE;

    if (wszPath == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto done;
    }

    cchPath = wcslen(wszPath);
    __try { wszPathToDel = (LPWSTR)_alloca(cchPath * sizeof(WCHAR)); }
    __except(EXCEPTION_EXECUTE_HANDLER) { wszPathToDel = NULL; }
    if (wszPathToDel == NULL)
    {
        SetLastError(ERROR_OUTOFMEMORY);
        goto done;
    }

    wcscpy(wszPathToDel, wszPath);

    // delete the actual file
    if (fFilePresent)
    {
        DeleteFileW(wszPathToDel);

        // next, delete the directory that we put it in
        for(pwsz = wszPathToDel + cchPath - 1;
            *pwsz != L'\\' && pwsz > wszPathToDel;
            pwsz--);
        if (*pwsz != L'\\' || pwsz <= wszPathToDel)
            goto done;
    }
    else
    {
        pwsz = wszPathToDel + cchPath;
    }

    *pwsz = L'\0';
    RemoveDirectoryW(wszPathToDel);

    for(pwsz = pwsz - 1;
        *pwsz != L'.' && pwsz > wszPathToDel;
        pwsz--);
    if (*pwsz == L'.' && pwsz > wszPathToDel)
    {
        *pwsz = L'\0';
        DeleteFileW(wszPathToDel);
    }

    fRet = TRUE;

done:
    return fRet;
}

// ***************************************************************************
DWORD CreateTempDirAndFile(LPCWSTR wszTempDir, LPCWSTR wszName,
                             LPWSTR *pwszPath)
{
    LPWSTR  wszFilePath = NULL;
    WCHAR   *wszTemp = NULL;
    DWORD   cch = 0, cchDir = 0, iSuffix = 0, cSuffix = 0;
    WCHAR   wsz[1024];
    BOOL    fRet = FALSE;

    if (pwszPath == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto done;
    }

    *pwszPath = NULL;

    if (wszTempDir != NULL)
        cch = wcslen(wszTempDir);
    if (cch == 0)
    {
        cch = GetTempPathW(0, NULL);
        if (cch == 0)
            goto done;
    }

    // compute the size of the buffer for the string we're going
    //  to generate.  The 20 includes the following:
    //   max size of the temp filename
    //   extra space for the NULL terminator.
    cch += (16 + sizeofSTRW(c_wszDirSuffix));
    if (wszName != NULL)
        cch += wcslen(wszName);

    // ok, so GetTempFileName likes to write MAX_PATH characters to the buffer,
    //  so make sure it's at least MAX_PATH in size...
    cch = MyMax(cch, MAX_PATH + 1);

    wszFilePath = (LPWSTR)MyAlloc(cch * sizeof(WCHAR));
    if (wszFilePath == NULL)
    {
        SetLastError(ERROR_OUTOFMEMORY);
        goto done;
    }

    if (wszTempDir != NULL && wszTempDir[0] != L'\0')
    {
        cch = wcslen(wszTempDir);
        wszTemp = (LPWSTR)wszTempDir;
    }
    else
    {
        cch = GetTempPathW(cch, wszFilePath);
        if (cch == 0)
            goto done;

        cch++;
        __try { wszTemp = (WCHAR *)_alloca(cch * sizeof(WCHAR)); }
        __except(EXCEPTION_EXECUTE_HANDLER) { wszTemp = NULL; }
        if (wszTemp == NULL)
        {
            SetLastError(ERROR_OUTOFMEMORY);
            goto done;
        }

        wcscpy(wszTemp, wszFilePath);
    }
    cch = GetTempFileNameW(wszTemp, L"WER", 0, wszFilePath);
    if (cch == 0)
        goto done;

    cch = wcslen(wszFilePath);
    wcscpy(&wszFilePath[cch], c_wszDirSuffix);

    // iSuffix points to the first digit of the '00' at the end of
    //  c_wszDirSuffix
    iSuffix = cch + sizeofSTRW(c_wszDirSuffix) - 3;
    cSuffix = 1;
    do
    {
        fRet = CreateDirectoryW(wszFilePath, NULL);
        if (fRet)
            break;

        wszFilePath[iSuffix]     = L'0' + (WCHAR)(cSuffix / 10);
        wszFilePath[iSuffix + 1] = L'0' + (WCHAR)(cSuffix % 10);
        cSuffix++;
    }
    while (cSuffix <= 100);

    // hmm, couldn't create the directory...
    if (cSuffix > 100)
    {
        cchDir = cch;
        cch    = 0;
        goto done;
    }


    cch += (sizeofSTRW(c_wszDirSuffix) - 1);
    if (wszName != NULL)
    {
        wszFilePath[cch++] = L'\\';
        wcscpy(&wszFilePath[cch], wszName);
        cch += wcslen(wszName);
    }

    *pwszPath   = wszFilePath;
    wszFilePath = NULL;

    fRet = TRUE;

done:
    if (wszFilePath != NULL)
    {
        if (cchDir > 0)
        {
            wszFilePath[cchDir] = L'\0';
            DeleteFileW(wszFilePath);
        }
        MyFree(wszFilePath);
    }

    return cch;
}

#ifdef MANIFEST_HEAP
BOOL
DeleteFullAndTriageMiniDumps(
    LPCWSTR wszPath
    )
//
// We create a FullMinidump file along with triage minidump in the same dir
// This routine cleans up both those files
//
{
    LPWSTR  wszFullMinidump = NULL;
    DWORD   cch;
    BOOL    fRet;

    fRet = DeleteFileW(wszPath);
    cch = wcslen(wszPath) + sizeofSTRW(c_wszHeapDumpSuffix);
    __try { wszFullMinidump = (WCHAR *)_alloca(cch * sizeof(WCHAR)); }
    __except(EXCEPTION_STACK_OVERFLOW) { wszFullMinidump = NULL; }
    if (wszFullMinidump)
    {
        LPWSTR wszFileExt = NULL;

        // Build Dump-with-heap path
        wcsncpy(wszFullMinidump, wszPath, cch);
        wszFileExt = wszFullMinidump + wcslen(wszFullMinidump) - sizeofSTRW(c_wszDumpSuffix) + 1;
        if (!wcscmp(wszFileExt, c_wszDumpSuffix))
        {
            *wszFileExt = L'\0';
        }
        wcsncat(wszFullMinidump, c_wszHeapDumpSuffix, cch);


        fRet = DeleteFileW(wszFullMinidump);

    } else
    {
        fRet = FALSE;
    }
    return fRet;
}
#endif  // MANIFEST_HEAP

////////////////////////////////////////////////////////////////////////////
// File mapping

// **************************************************************************
HRESULT OpenFileMapped(LPWSTR wszFile, LPVOID *ppvFile, DWORD *pcbFile)
{
    USE_TRACING("OpenFileMapped");

    HRESULT hr = NOERROR;
    HANDLE  hMMF = NULL;
    HANDLE  hFile = INVALID_HANDLE_VALUE;
    LPVOID  pvFile = NULL;
    DWORD   cbFile = 0;

    VALIDATEPARM(hr, (wszFile == NULL || ppvFile == NULL));
    if (FAILED(hr))
        goto done;

    *ppvFile = NULL;
    if (pcbFile != NULL)
        *pcbFile = 0;

    hFile = CreateFileW(wszFile, GENERIC_READ, FILE_SHARE_READ, NULL,
                        OPEN_EXISTING, 0, NULL);
    TESTBOOL(hr, (hFile != INVALID_HANDLE_VALUE));
    if (FAILED(hr))
        goto done;

    cbFile = GetFileSize(hFile, NULL);
    TESTBOOL(hr, (cbFile != (DWORD)-1));
    if (FAILED(hr))
        goto done;

    hMMF = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, cbFile, NULL);
    TESTBOOL(hr, (hMMF != NULL));
    if (FAILED(hr))
        goto done;

    pvFile = MapViewOfFile(hMMF, FILE_MAP_READ, 0, 0, 0);
    TESTBOOL(hr, (pvFile != NULL));
    if (FAILED(hr))
        goto done;

    *ppvFile = pvFile;
    if (pcbFile != NULL)
        *pcbFile = cbFile;

done:
    if (hMMF != NULL)
        CloseHandle(hMMF);
    if (hFile != NULL)
        CloseHandle(hFile);

    return hr;
}

// **************************************************************************
HRESULT DeleteTempFile(LPWSTR wszFile)
{
    USE_TRACING("DeleteTempFile");

    HRESULT hr = NOERROR;
    WCHAR   *pwsz;

    if (wszFile == NULL)
        return NOERROR;

    // strip off the extension at the end (if it's not a .tmp)
    for(pwsz = wszFile + wcslen(wszFile); *pwsz != L'.' && pwsz > wszFile; pwsz--);
    if (pwsz > wszFile && _wcsicmp(pwsz, L".tmp") != 0)
        *pwsz = L'\0';

    if (DeleteFileW(wszFile) == FALSE)
        hr = Err2HR(GetLastError());

    // can do this even if the extension was a tmp since the value pointed to
    //  by pwsz is '.' if it's greater than wszFile...
    if (pwsz > wszFile)
        *pwsz = L'.';

    return hr;
}

// **************************************************************************
HRESULT MyCallNamedPipe(LPCWSTR wszPipe, LPVOID pvIn, DWORD cbIn,
                        LPVOID pvOut, DWORD cbOut, DWORD *pcbRead,
                        DWORD dwWaitPipe, DWORD dwWaitRead)
{
    HRESULT hr = NOERROR;
    HANDLE  hPipe = INVALID_HANDLE_VALUE;
    HANDLE  hev = NULL;
    DWORD   dwStart = GetTickCount(), dwNow, dw;
    BOOL    fRet;

    USE_TRACING("MyCallNamedPipe");

    VALIDATEPARM(hr, (wszPipe == NULL || pvIn == NULL || pvOut == NULL || pcbRead == NULL));
    if (FAILED(hr))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        hr = E_INVALIDARG;
        goto done;
    }

    *pcbRead = 0;

    for(;;)
    {
        hPipe = CreateFileW(wszPipe, GENERIC_READ | GENERIC_WRITE,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL, OPEN_EXISTING,
                            FILE_FLAG_OVERLAPPED | SECURITY_IDENTIFICATION |
                            SECURITY_SQOS_PRESENT | SECURITY_CONTEXT_TRACKING,
                            NULL);
        if (hPipe != INVALID_HANDLE_VALUE)
            break;

        // if we get ACCESS_DENIED to the above, then WaitNamedPipe will
        //  return SUCCESS, so we get stuck until the timeout expires.  Better
        //  to just bail now.
        if (GetLastError() == ERROR_ACCESS_DENIED)
            goto done;

        TESTBOOL(hr, WaitNamedPipeW(wszPipe, dwWaitPipe));
        if (FAILED(hr))
            goto done;

        dwNow = GetTickCount();
        if (dwNow < dwStart)
            dw = ((DWORD)-1 - dwStart) + dwNow;
        else
            dw = dwNow - dwStart;
        if (dw >= dwWaitPipe)
            dwWaitPipe = 0;
        else
            dwWaitPipe -= dw;

        if (dwWaitPipe == 0)
        {
            SetLastError(ERROR_TIMEOUT);
            goto done;
        }
    }


    __try
    {
        OVERLAPPED  ol;
        DWORD       dwMode = PIPE_READMODE_MESSAGE | PIPE_WAIT;
        DWORD       cbRead = 0;

        //  Default open is readmode byte stream- change to message mode.
        TESTBOOL(hr, SetNamedPipeHandleState(hPipe, &dwMode, NULL, NULL))
        if (FAILED(hr))
            __leave;

        // we need an event for the overlapped structure
        hev = CreateEventW(NULL, TRUE, FALSE, NULL);
        TESTBOOL(hr, (hev != NULL));
        if (FAILED(hr))
            __leave;

        // populate the overlapped stuff
        ZeroMemory(&ol, sizeof(ol));
        ol.hEvent = hev;

        fRet = TransactNamedPipe(hPipe, pvIn, cbIn, pvOut, cbOut, &cbRead,
                                 &ol);
        if (GetLastError() != ERROR_IO_PENDING)
        {
            if (fRet)
            {
                SetEvent(hev);
            }
            else
            {
                hr = Err2HR(GetLastError());
                __leave;
            }
        }

        dw = WaitForSingleObject(hev, dwWaitRead);
        if (dw != WAIT_OBJECT_0)
        {
            hr = (dw == WAIT_TIMEOUT) ? Err2HR(WAIT_TIMEOUT) :
                                        Err2HR(GetLastError());
            __leave;
        }

        TESTBOOL(hr, GetOverlappedResult(hPipe, &ol, &cbRead, FALSE));
        if (FAILED(hr))
            __leave;

        *pcbRead = cbRead;

        hr = NOERROR;
    }

    __finally
    {
    }

done:
    dw = GetLastError();

    if (hPipe != INVALID_HANDLE_VALUE)
        CloseHandle(hPipe);
    if (hev != NULL)
        CloseHandle(hev);

    SetLastError(dw);

    return hr;
    }

//////////////////////////////////////////////////////////////////////////////
// Security stuff

// ***************************************************************************
#define MEMBER_ACCESS 1
BOOL IsUserAnAdmin(HANDLE hToken)
{
    SID_IDENTIFIER_AUTHORITY    sia = SECURITY_NT_AUTHORITY;
    SECURITY_DESCRIPTOR         *psdAdm = NULL;
    GENERIC_MAPPING             gm;
    PRIVILEGE_SET               *pPS;
    HANDLE                      hTokenImp = NULL;
    DWORD                       cbSD, cbPS, dwGranted = 0;
    BYTE                        rgBuf[sizeof(PRIVILEGE_SET) + 3 * sizeof(LUID_AND_ATTRIBUTES)];
    BOOL                        fRet = FALSE, fStatus;
    PSID                        psidAdm = NULL;
    PACL                        pACL = NULL;
    HRESULT                     hr;

    USE_TRACING("IsUserAnAdmin");

    gm.GenericRead    = GENERIC_READ;
    gm.GenericWrite   = GENERIC_WRITE;
    gm.GenericExecute = GENERIC_EXECUTE;
    gm.GenericAll     = GENERIC_ALL;
    pPS = (PRIVILEGE_SET *)rgBuf;
    cbPS = sizeof(rgBuf);

    // AccessCheck() reqires an impersonation token...
    TESTBOOL(hr, DuplicateToken(hToken, SecurityImpersonation, &hTokenImp));
    if (FAILED(hr))
        goto done;

    fRet = FALSE;

    // construct a SID that contains the administrator's group.
    TESTBOOL(hr, AllocateAndInitializeSid(&sia, 2, SECURITY_BUILTIN_DOMAIN_RID,
                                    DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0,
                                    0, &psidAdm));
    if (FAILED(hr))
        goto done;

    cbSD = sizeof(SECURITY_DESCRIPTOR) + sizeof(ACCESS_ALLOWED_ACE) +
           sizeof(ACL) + 3 * GetLengthSid(psidAdm);

    __try { psdAdm = (SECURITY_DESCRIPTOR *)_alloca(cbSD); }
    __except(EXCEPTION_STACK_OVERFLOW) { psdAdm = NULL; }
    if (psdAdm == NULL)
        goto done;

    ZeroMemory(psdAdm, cbSD);
    pACL = (PACL)(psdAdm + 1);

    TESTBOOL(hr, InitializeSecurityDescriptor(psdAdm, SECURITY_DESCRIPTOR_REVISION));
    if (FAILED(hr))
        goto done;

    TESTBOOL(hr, SetSecurityDescriptorOwner(psdAdm, psidAdm, FALSE));
    if (FAILED(hr))
        goto done;

    TESTBOOL(hr, SetSecurityDescriptorGroup(psdAdm, psidAdm, FALSE));
    if (FAILED(hr))
        goto done;

    TESTBOOL(hr, InitializeAcl(pACL, cbSD - sizeof(SECURITY_DESCRIPTOR), ACL_REVISION));
    if (FAILED(hr))
        goto done;

    TESTBOOL(hr, AddAccessAllowedAce(pACL, ACL_REVISION, MEMBER_ACCESS, psidAdm));
    if (FAILED(hr))
        goto done;

    TESTBOOL(hr, SetSecurityDescriptorDacl(psdAdm, TRUE, pACL, FALSE));
    if (FAILED(hr))
        goto done;

    TESTBOOL(hr, AccessCheck(psdAdm, hTokenImp, MEMBER_ACCESS, &gm, pPS, &cbPS,
                       &dwGranted, &fStatus));
    if (FAILED(hr))
        goto done;

    fRet = (fStatus && dwGranted == MEMBER_ACCESS);

done:
    if (psidAdm != NULL)
        FreeSid(psidAdm);
    if (hTokenImp != NULL)
        CloseHandle(hTokenImp);

    return fRet;
}


// ***************************************************************************
BOOL AllocSD(SECURITY_DESCRIPTOR *psd, DWORD dwOLs, DWORD dwAd, DWORD dwWA)
{
    SID_IDENTIFIER_AUTHORITY    siaCreate = SECURITY_CREATOR_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY    siaWorld = SECURITY_WORLD_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY    siaNT = SECURITY_NT_AUTHORITY;
    DWORD                       cb, dw;
    PACL                        pacl = NULL;
    PSID                        psidOwner = NULL;
    PSID                        psidLS = NULL;
    PSID                        psidWorld = NULL;
    PSID                        psidAnon = NULL;
    PSID                        psidAdm = NULL;
    BOOL                        fRet = FALSE;

    if (psd == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto done;
    }

    fRet = InitializeSecurityDescriptor(psd, SECURITY_DESCRIPTOR_REVISION);
    if (fRet == FALSE)
        goto done;


    // get the SID for local system acct
    fRet = AllocateAndInitializeSid(&siaNT, 1, SECURITY_LOCAL_SYSTEM_RID, 0, 0,
                                    0, 0, 0, 0, 0, &psidLS);
    if (fRet == FALSE)
        goto done;

    // get the SID for the creator
    fRet = AllocateAndInitializeSid(&siaCreate, 1, SECURITY_CREATOR_OWNER_RID,
                                    0, 0, 0, 0, 0, 0, 0, &psidOwner);
    if (fRet == FALSE)
        goto done;

    cb = sizeof(ACL) + GetLengthSid(psidLS) + GetLengthSid(psidOwner) +
         2 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD));

    // if we have an access mask to apply for the administrators group, then
    //  we need it's SID.
    if (dwAd != 0)
    {
        // get the SID for the local administrators group
        fRet = AllocateAndInitializeSid(&siaNT, 2, SECURITY_BUILTIN_DOMAIN_RID,
                                        DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0,
                                        0, &psidAdm);
        if (fRet == FALSE)
            goto done;

        cb += (GetLengthSid(psidAdm) + sizeof(ACCESS_ALLOWED_ACE) -
               sizeof(DWORD));
    }

    // if we have an access mask to apply for world / anonymous, then we need
    //  their SIDs
    if (dwWA != 0)
    {
        // get the SID for the world (everyone)
        fRet = AllocateAndInitializeSid(&siaNT, 1, SECURITY_ANONYMOUS_LOGON_RID,
                                        0, 0, 0, 0, 0, 0, 0, &psidWorld);


        // get the SID for the anonymous users acct
        fRet = AllocateAndInitializeSid(&siaWorld, 1, SECURITY_WORLD_RID,
                                        0, 0, 0, 0, 0, 0, 0, &psidAnon);
        if (fRet == FALSE)
            goto done;

        cb += GetLengthSid(psidWorld) + GetLengthSid(psidAnon) +
              2 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD));
    }

    // make the DACL
    pacl = (PACL)MyAlloc(cb);
    if (pacl == NULL)
    {
        SetLastError(ERROR_OUTOFMEMORY);
        fRet = FALSE;
        goto done;
    }

    fRet = InitializeAcl(pacl, cb, ACL_REVISION);
    if (fRet == FALSE)
        goto done;

    fRet = AddAccessAllowedAce(pacl, ACL_REVISION, dwOLs, psidOwner);
    if (fRet == FALSE)
        goto done;

    fRet = AddAccessAllowedAce(pacl, ACL_REVISION, dwOLs, psidLS);
    if (fRet == FALSE)
        goto done;

    // if we have an administrator access mask, then apply it
    if (dwAd != 0)
    {
        fRet = AddAccessAllowedAce(pacl, ACL_REVISION, dwAd, psidAdm);
        if (fRet == FALSE)
            goto done;
    }

    // if we have a world / anonymous access mask, then apply it
    if (dwWA != 0)
    {
        fRet = AddAccessAllowedAce(pacl, ACL_REVISION, dwWA, psidWorld);
        if (fRet == FALSE)
            goto done;

        fRet = AddAccessAllowedAce(pacl, ACL_REVISION, dwWA, psidAnon);
        if (fRet == FALSE)
            goto done;
    }

    // set the SD dacl
    fRet = SetSecurityDescriptorDacl(psd, TRUE, pacl, FALSE);
    if (fRet == FALSE)
        goto done;

    pacl = NULL;

done:
    dw = GetLastError();

    if (psidLS != NULL)
        FreeSid(psidLS);
    if (psidWorld != NULL)
        FreeSid(psidWorld);
    if (psidAnon != NULL)
        FreeSid(psidAnon);
    if (psidAdm != NULL)
        FreeSid(psidAdm);
    if (psidOwner != NULL)
        FreeSid(psidOwner);
    if (pacl != NULL)
        MyFree(pacl);

    SetLastError(dw);

    return fRet;
}

// ***************************************************************************
void FreeSD(SECURITY_DESCRIPTOR *psd)
{
    PSID    psid = NULL;
    PACL    pacl = NULL;
    BOOL    f, f2;

    if (psd == NULL)
        return;

    if (GetSecurityDescriptorDacl(psd, &f, &pacl, &f2) && pacl != NULL)
        MyFree(pacl);
}


//////////////////////////////////////////////////////////////////////////////
// Registry stuff

// **************************************************************************
HRESULT OpenRegKey(HKEY hkeyMain, LPCWSTR wszSubKey, DWORD dwOpt,
                   HKEY *phkey)
{
    USE_TRACING("OpenRegKey");

    HRESULT hr = NOERROR;
    REGSAM  samDesired;
    DWORD   dwErr;

    VALIDATEPARM(hr, (hkeyMain == NULL || wszSubKey == NULL || phkey == NULL));
    if (FAILED(hr))
        goto done;

    *phkey   = NULL;

    samDesired = ((dwOpt & orkWantWrite) != 0) ? KEY_ALL_ACCESS : KEY_READ;
    samDesired |= ((dwOpt & orkUseWOW64) != 0) ? KEY_WOW64_32KEY : KEY_WOW64_64KEY;

    // first try calling RegCreateKeyEx to make sure we create the key if
    //  it doesn't exist
    TESTERR(hr, RegCreateKeyExW(hkeyMain, wszSubKey, 0, NULL, 0, samDesired,
                                NULL, phkey, NULL));
    if (FAILED(hr))
    {
        // ok, that didn't work, so try opening the key instead
        TESTERR(hr, RegOpenKeyExW(hkeyMain, wszSubKey, 0, samDesired, phkey));
    }

done:
    return hr;
}

// **************************************************************************
HRESULT ReadRegEntry(HKEY hkey, LPCWSTR wszValName, DWORD *pdwType,
                     PBYTE pbBuffer, DWORD *pcbBuffer, PBYTE pbDefault,
                     DWORD cbDefault)
{
    USE_TRACING("ReadRegEntry");

    HRESULT hr = NOERROR;
    DWORD   dwErr;

    VALIDATEPARM(hr, (hkey == NULL || wszValName == NULL));
    if (FAILED(hr))
        goto done;

    dwErr = RegQueryValueExW(hkey, wszValName, 0, pdwType, pbBuffer,
                             pcbBuffer);
    VALIDATEEXPR(hr, (dwErr != ERROR_PATH_NOT_FOUND &&
                      dwErr != ERROR_FILE_NOT_FOUND &&
                      dwErr != ERROR_SUCCESS), Err2HR(dwErr));
    if (FAILED(hr))
        goto done;

    if (dwErr != ERROR_SUCCESS && pbDefault != NULL)
    {
        VALIDATEPARM(hr, (pcbBuffer == NULL && pbBuffer != NULL));
        if (FAILED(hr))
            goto done;

        // if the receiving buffer is NULL, just return the error that
        //  RegQueryValueEx gave us cuz the user doesn't really want the
        //  value anyway
        VALIDATEEXPR(hr, (pcbBuffer == NULL), Err2HR(dwErr));
        if (FAILED(hr))
            goto done;

        if (pbBuffer == NULL)
        {
            *pcbBuffer = cbDefault;
            hr = NOERROR;
            goto done;
        }
        else if (cbDefault > *pcbBuffer)
        {
            *pcbBuffer = cbDefault;
            hr = Err2HR(ERROR_MORE_DATA);
            goto done;
        }

        CopyMemory(pbBuffer, pbDefault, cbDefault);
        *pcbBuffer = cbDefault;
        if (pdwType != NULL)
            *pdwType = REG_BINARY;

        hr = NOERROR;
        goto done;
    }
done:
    return hr;
}

// **************************************************************************
HRESULT ReadRegEntry(HKEY *rghkey, DWORD cKeys, LPCWSTR wszValName,
                     DWORD *pdwType, PBYTE pbBuffer, DWORD *pcbBuffer,
                     PBYTE pbDefault, DWORD cbDefault, DWORD *piKey)
{
    USE_TRACING("ReadRegEntryPolicy");

    HRESULT hr = NOERROR;
    DWORD   dwErr=0, i;

    VALIDATEPARM(hr, (rghkey == NULL || wszValName == NULL));
    if (FAILED(hr))
        goto done;

    for(i = 0; i < cKeys; i++)
    {
        dwErr = RegQueryValueExW(rghkey[i], wszValName, 0, pdwType, pbBuffer,
                                 pcbBuffer);
        VALIDATEEXPR(hr, (dwErr != ERROR_PATH_NOT_FOUND &&
                          dwErr != ERROR_FILE_NOT_FOUND &&
                          dwErr != ERROR_SUCCESS), Err2HR(dwErr));
        if (FAILED(hr))
            goto done;

        if (dwErr == ERROR_SUCCESS)
        {
            if (piKey != NULL)
                *piKey = i;
            break;
        }
    }

    if (dwErr != ERROR_SUCCESS && pbDefault != NULL)
    {
        VALIDATEPARM(hr, (pcbBuffer == NULL && pbBuffer != NULL));
        if (FAILED(hr))
            goto done;

        // if the receiving buffer is NULL, just return the error that
        //  RegQueryValueEx gave us cuz the user doesn't really want the
        //  value anyway
        VALIDATEEXPR(hr, (pcbBuffer == NULL), Err2HR(dwErr));
        if (FAILED(hr))
            goto done;

        if (pbBuffer == NULL)
        {
            *pcbBuffer = cbDefault;
            hr = NOERROR;
            goto done;
        }
        else if (cbDefault > *pcbBuffer)
        {
            *pcbBuffer = cbDefault;
            hr = Err2HR(ERROR_MORE_DATA);
            goto done;
        }

        CopyMemory(pbBuffer, pbDefault, cbDefault);
        *pcbBuffer = cbDefault;
        if (pdwType != NULL)
            *pdwType = REG_BINARY;

        if (piKey != NULL)
            *piKey = cKeys;

        hr = NOERROR;
        goto done;
    }
done:
    return hr;
}


//////////////////////////////////////////////////////////////////////////////
// version info stuff

// **************************************************************************
DWORD IsMicrosoftApp(LPWSTR wszAppPath, PBYTE pbAppInfo, DWORD cbAppInfo)
{
    USE_TRACING("IsMicrosoftApp");

    SLangCodepage   *plc;
    HRESULT         hr = NOERROR;
    LPWSTR          pwszName, pwszNameK32, wszModK32;
    WCHAR           wszQueryString[128];
    DWORD           cbFVI, cbFVIK32, dwJunk, dwRet = 0;
    PBYTE           pbFVI = NULL, pbFVIK32 = NULL;
    UINT            cb, cbVerInfo, i, cchNeed, cch;

    VALIDATEPARM(hr, (wszAppPath == NULL &&
                      (pbAppInfo == NULL || cbAppInfo == 0)));
    if (FAILED(hr))
        goto done;

    if (pbAppInfo == NULL)
    {
        // dwJunk is a useful parameter. Gotta pass it in so the function call
        //  set it to 0.  Gee this would make a great (tho non-efficient)
        //  way to set DWORDs to 0.  Much better than saying dwJunk = 0 by itself.
        cbFVI = GetFileVersionInfoSizeW(wszAppPath, &dwJunk);
        TESTBOOL(hr, (cbFVI != 0));
        if (FAILED(hr))
        {
            // if it fails, assume the file doesn't have any version info &
            //  return S_FALSE
            hr = S_FALSE;
            goto done;
        }

        // alloca only throws exceptions so gotta catch 'em here....
        __try { pbFVI = (PBYTE)_alloca(cbFVI); }
        __except(EXCEPTION_STACK_OVERFLOW) { pbFVI = NULL; }
        VALIDATEEXPR(hr, (pbFVI == NULL), E_OUTOFMEMORY);
        if (FAILED(hr))
            goto done;

        cb = cbFVI;
        TESTBOOL(hr, GetFileVersionInfoW(wszAppPath, 0, cbFVI, (LPVOID *)pbFVI));
        if (FAILED(hr))
        {
            // if it fails, assume the file doesn't have any version info &
            //  return S_FALSE
            hr = S_FALSE;
            goto done;
        }
    }
    else
    {
        pbFVI = pbAppInfo;
        cbFVI = cbAppInfo;
    }

    // get the info for kernel32.dll
    cchNeed = GetSystemDirectoryW(NULL, 0);
    if (cchNeed == 0)
        goto done;

    cchNeed += (sizeofSTRW(L"\\kernel32.dll") + 1);
    __try { wszModK32 = (LPWSTR)_alloca(cchNeed * sizeof(WCHAR)); }
    __except(EXCEPTION_STACK_OVERFLOW) { wszModK32 = NULL; }
    VALIDATEEXPR(hr, (wszModK32 == NULL), E_OUTOFMEMORY);
    if (FAILED(hr))
        goto done;

    // get the info for kernel32.dll
    cch = GetSystemDirectoryW(wszModK32, cchNeed);
    if (cch == 0)
        goto done;
    if (*(wszModK32 + cch - 1) == L'\\')
        *(wszModK32 + cch - 1) = L'\0';
    wcscat(wszModK32, L"\\kernel32.dll");


    // dwJunk is a useful parameter. Gotta pass it in so the function call
    //  set it to 0.  Gee this would make a great (tho non-efficient)
    //  way to set DWORDs to 0.  Much better than saying dwJunk = 0 by itself.
    cbFVIK32 = GetFileVersionInfoSizeW(wszModK32, &dwJunk);
    TESTBOOL(hr, (cbFVIK32 != 0));
    if (FAILED(hr))
    {
        // if it fails, assume the file doesn't have any version info &
        //  return S_FALSE
        hr = S_FALSE;
        goto done;
    }

    // alloca only throws exceptions so gotta catch 'em here....
    __try { pbFVIK32 = (PBYTE)_alloca(cbFVIK32); }
    __except(EXCEPTION_STACK_OVERFLOW) { pbFVIK32 = NULL; }
    VALIDATEEXPR(hr, (pbFVIK32 == NULL), E_OUTOFMEMORY);
    if (FAILED(hr))
        goto done;

    cb = cbFVI;
    TESTBOOL(hr, GetFileVersionInfoW(wszModK32, 0, cbFVIK32, (LPVOID *)pbFVIK32));
    if (FAILED(hr))
    {
        // if it fails, assume the file doesn't have any version info &
        //  return S_FALSE
        hr = S_FALSE;
        goto done;
    }

    // Ok, since we can have any number of languages in the module, gotta
    //  grep thru all of them & see if the company name field includes
    //  'Microsoft'.
    TESTBOOL(hr, VerQueryValueW(pbFVI, L"\\VarFileInfo\\Translation",
                                (LPVOID *)&plc, &cbVerInfo));
    if (FAILED(hr))
    {
        // if it fails, assume the file doesn't have any version info &
        //  return S_FALSE
        hr = S_FALSE;
        goto done;
    }

    // Read the file description for each language and code page.
    for(i = 0; i < (cbVerInfo / sizeof(SLangCodepage)); i++)
    {
        wsprintfW(wszQueryString, L"\\StringFileInfo\\%04x%04x\\CompanyName",
                  plc[i].wLanguage, plc[i].wCodePage);

        // Retrieve file description for language and code page "i".
        TESTBOOL(hr, VerQueryValueW(pbFVI, wszQueryString,
                                    (LPVOID *)&pwszName, &cb));
        if (FAILED(hr))
            continue;

            // see if the string contains the word 'Microsoft'
        if (MyStrStrIW(pwszName, L"Microsoft") != NULL)
        {
            dwRet |= APP_MSAPP;
            goto doneCompany;
        }

        // ok, didn't match the word 'Microsoft', so instead, see if it matches
        //  the string in kernel32.dll
        TESTBOOL(hr, VerQueryValueW(pbFVIK32, wszQueryString,
                                    (LPVOID *)&pwszNameK32, &cb));
        if (FAILED(hr))
            continue;

        if (CompareStringW(MAKELCID(plc[i].wLanguage, SORT_DEFAULT),
                           NORM_IGNORECASE | NORM_IGNOREKANATYPE |
                           NORM_IGNOREWIDTH | SORT_STRINGSORT,
                           pwszName, -1, pwszNameK32, -1) == CSTR_EQUAL)
            dwRet |= APP_MSAPP;
        else
            continue;

doneCompany:
        wsprintfW(wszQueryString, L"\\StringFileInfo\\%04x%04x\\ProductName",
                  plc[i].wLanguage, plc[i].wCodePage);

        // Retrieve file description for language and code page "i".
        TESTBOOL(hr, VerQueryValueW(pbFVI, wszQueryString,
                                    (LPVOID *)&pwszName, &cb));
        if (FAILED(hr))
            continue;

        // see if the string contains the words 'Microsoft Windows'
        if (MyStrStrIW(pwszName, L"Microsoft Windows") != NULL)
        {
            dwRet |= APP_WINCOMP;
            break;
        }

        // ok, didn't match the words 'Microsoft Windows', so instead, see if
        //  it matches the string in kernel32.dll
        TESTBOOL(hr, VerQueryValueW(pbFVIK32, wszQueryString,
                                    (LPVOID *)&pwszNameK32, &cb));
        if (FAILED(hr))
            continue;

        if (CompareStringW(MAKELCID(plc[i].wLanguage, SORT_DEFAULT),
                           NORM_IGNORECASE | NORM_IGNOREKANATYPE |
                           NORM_IGNOREWIDTH | SORT_STRINGSORT,
                           pwszName, -1, pwszNameK32, -1) == CSTR_EQUAL)
        {
            dwRet |= APP_WINCOMP;
            break;
        }

    }

    hr = S_FALSE;

done:
    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\common\pfcommon\pfcab.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    cabbing.cpp

Abstract:
    FDU main 

Revision History:
    created     derekm      02/23/00

******************************************************************************/

#include <stdafx.h>

#include <stdio.h>
#include <io.h>
#include <fcntl.h>
#include <sys/stat.h>

#include <fci.h>
#include <fdi.h>

#include "pfarray.h"
#include "pfcab.h"


/////////////////////////////////////////////////////////////////////////////
// tracing

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile


/////////////////////////////////////////////////////////////////////////////
// structs

struct SPFFileInfo
{
    LPSTR szCab;
    LPSTR szDestFile;
    LPSTR szFileName; 
    BOOL  fFound;
};


/////////////////////////////////////////////////////////////////////////////
// utility

// **************************************************************************
static MyCabGetLastError()
{
    DWORD dwErr;
    
    // this function assumes that it is called in an error state, so it will
    //  never return ERROR_SUCCESS
    dwErr = GetLastError();
    if (dwErr == ERROR_SUCCESS)
    {
        dwErr = _doserrno;
		if (dwErr == ERROR_SUCCESS)
			dwErr = ERROR_TOO_MANY_OPEN_FILES;
    }

    return dwErr;
}

// **************************************************************************
static void DeleteFromFileList(LPVOID pv)
{
    SysFreeString((BSTR)pv);
}

// **************************************************************************
static void SplitPath(LPCSTR szFullPath, LPSTR szPath, LPSTR szName)
{
    LPSTR szEnd;
    
    szEnd = strrchr(szFullPath, '\\');
    if (szEnd == NULL)
    {
        strcpy(szPath, "");
        strcpy(szName, szFullPath);
    }

    else
    {
        DWORD cb;
        
        cb = (DWORD)(LONG_PTR)(szEnd - szFullPath) + 1;
        strcpy(szName, szEnd + 1);
        strncpy(szPath, szFullPath, cb); 
        szPath[cb] = 0;
    }
}


/////////////////////////////////////////////////////////////////////////////
// 

// **************************************************************************
static LPVOID DIAMONDAPI mem_alloc(ULONG cb)
{
    return MyAlloc(cb);
}

// **************************************************************************
static void DIAMONDAPI mem_free(LPVOID pv)
{
    MyFree(pv);
}


/////////////////////////////////////////////////////////////////////////////
// 

// **************************************************************************
static INT_PTR DIAMONDAPI fci_open(LPSTR pszFile, int oflag, int pmode, 
                                   int *err, LPVOID pv)
{
    int result;
    
    result = _open(pszFile, oflag, pmode);
    if (result == -1) 
        *err = errno;

    return result;
}

// **************************************************************************
static UINT DIAMONDAPI fci_read(INT_PTR hf, LPVOID memory, UINT cb, int *err, 
                                LPVOID pv)
{
    UINT result;
        
    result = (UINT)_read((int)hf, memory, cb);

    if (result != cb) 
        *err = errno;

    return result;
}

// **************************************************************************
static  UINT DIAMONDAPI fci_write(INT_PTR hf, LPVOID memory, UINT cb, int *err, 
                                  LPVOID pv)
{
    UINT result;

    result = (UINT)_write((int)hf, memory, cb);

    if (result != cb) 
        *err = errno;

    return result;
}

// **************************************************************************
static  int DIAMONDAPI fci_close(INT_PTR hf, int *err, LPVOID pv)
{
    int result;
    
    result = _close((int)hf);

    if (result != 0) 
        *err = errno;

    return result;
}

// **************************************************************************
static long DIAMONDAPI fci_seek(INT_PTR hf, long dist, int seektype, int *err, 
                                LPVOID pv)
{
    long result;
    
    result = _lseek((int)hf, dist, seektype);

    if (result == -1) 
        *err = errno;

    return result;
}

// **************************************************************************
static int DIAMONDAPI fci_delete(LPSTR pszFile, int *err, LPVOID pv)
{
    int result;
    
    result = remove(pszFile);

    if (result != 0) 
        *err = errno;

    return result;
}


/////////////////////////////////////////////////////////////////////////////
// 

// **************************************************************************
static int DIAMONDAPI fci_file_placed(PCCAB pccab, LPSTR pszFile, long cbFile, 
                                      BOOL fContinuation, LPVOID pv)
{
    return 0;
}

// **************************************************************************
static BOOL DIAMONDAPI fci_get_temp_file(LPSTR pszTempName, int cbTempName, 
                                         LPVOID pv)
{
    char *psz = _tempnam("", "PCHPF"); // Get a name
    BOOL  res = FALSE;

    if (psz != NULL)
    {
        if(strlen(psz) < (size_t)cbTempName)
        {
            strcpy(pszTempName, psz); // Copy to caller's buffer
            res = TRUE;
        }

        free(psz);
    }

    return res;
}

// **************************************************************************
static long DIAMONDAPI fci_progress(UINT typeStatus, ULONG cb1, ULONG cb2, 
                                    LPVOID pv)
{
    return 0;
}

// **************************************************************************
static BOOL DIAMONDAPI fci_get_next_cabinet(PCCAB pccab, ULONG cbPrevCab, 
                                            LPVOID pv)
{
    SPFFileInfo *ppffi = (SPFFileInfo *)pv;

    SplitPath(ppffi->szDestFile, pccab->szCabPath, pccab->szCab);
    return TRUE;
}

// **************************************************************************
static INT_PTR DIAMONDAPI fci_get_open_info(LPSTR pszName, USHORT *pdate, 
                                            USHORT *ptime, USHORT *pattribs, 
                                            int *err, LPVOID pv)
{
    BY_HANDLE_FILE_INFORMATION finfo;
    FILETIME                   filetime;
    HANDLE                     handle;
    DWORD                      attrs;
    int                        hf = -1;

    // Need a Win32 type handle to get file date/time using the Win32 APIs, 
    //  even though the handle we will be returning is of the type compatible 
    //  with _open
    handle = CreateFile(pszName, GENERIC_READ, FILE_SHARE_READ, NULL, 
                        OPEN_EXISTING, 
                        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                        NULL);
    if (handle != INVALID_HANDLE_VALUE)
    {
        if (GetFileInformationByHandle(handle, &finfo))
        {
            FileTimeToLocalFileTime(&finfo.ftLastWriteTime, &filetime);
            FileTimeToDosDateTime(&filetime, pdate, ptime);

            attrs = GetFileAttributes(pszName);
            if (attrs == (DWORD)-1)
            {
                // failure
                *pattribs = 0;
            }
            else
            {
                 // Mask out all other bits except these four, since other
                 //  bits are used by the cabinet format to indicate a
                 //  special meaning.
                *pattribs = (int)(attrs & (_A_RDONLY | _A_SYSTEM | _A_HIDDEN | _A_ARCH));
            }
        }

        CloseHandle(handle);
    }


    // Return handle using _open
    hf = _open( pszName, _O_RDONLY | _O_BINARY );
    if(hf == -1)
    {
        return -1; // abort on error
    }

    return hf;
}


/////////////////////////////////////////////////////////////////////////////
//

// **************************************************************************
static INT_PTR DIAMONDAPI fdi_open(LPSTR pszFile, int oflag, int pmode)
{
    return _open(pszFile, oflag, pmode);
}

// **************************************************************************
static UINT DIAMONDAPI fdi_read(INT_PTR hf, LPVOID pv, UINT cb)
{
    return _read((int)hf, pv, cb);
}

// **************************************************************************
static UINT DIAMONDAPI fdi_write(INT_PTR hf, LPVOID pv, UINT cb)
{
    return _write((int)hf, pv, cb);
}

// **************************************************************************
static int DIAMONDAPI fdi_close(INT_PTR hf)
{
    return _close((int)hf);
}

// **************************************************************************
static long DIAMONDAPI fdi_seek(INT_PTR hf, long dist, int seektype)
{
    return _lseek((int)hf, dist, seektype);
}

// **************************************************************************
static INT_PTR DIAMONDAPI fdi_notify_copy(FDINOTIFICATIONTYPE fdint, 
                                          PFDINOTIFICATION pfdin)
{
    SPFFileInfo *ppffi = (SPFFileInfo *)pfdin->pv;
    
    switch(fdint)
    {
        // file to be copied
        case fdintCOPY_FILE:
            // is it an exact match?
            if (_stricmp(pfdin->psz1, ppffi->szFileName) == 0)
            {
                ppffi->fFound = TRUE;
                return fdi_open(ppffi->szDestFile, 
                                 _O_BINARY | _O_CREAT | _O_WRONLY | _O_SEQUENTIAL, 
                                _S_IREAD | _S_IWRITE);
            }

            // are we looking for a wildcard?
            else if (ppffi->szFileName[0] == '*'  && 
                     ppffi->szFileName[1] == '.'  &&
                     ppffi->szFileName[2] != '\0' &&
                     ppffi->szFileName[3] != '\0' &&
                     ppffi->szFileName[4] != '\0' &&
                     ppffi->szFileName[5] == '\0')
            {
                // compare the suffix's
                char *p;
                
                p = strrchr(pfdin->psz1, '.');

                if (p != NULL && _stricmp(p, &(ppffi->szFileName[1])) == 0)
                {
                    ppffi->fFound = TRUE;
                    return fdi_open(ppffi->szDestFile, 
                                    _O_BINARY | _O_CREAT | _O_WRONLY | _O_SEQUENTIAL, 
                                    _S_IREAD | _S_IWRITE);
                }
            }
            
            break;

        // close the file, set relevant info
        case fdintCLOSE_FILE_INFO:  
            fdi_close(pfdin->hf);
            return TRUE;
    }

    return 0;
}

// **************************************************************************
static INT_PTR DIAMONDAPI fdi_notify_enum(FDINOTIFICATIONTYPE fdint, 
                                          PFDINOTIFICATION pfdin)
{
    if (fdint == fdintCOPY_FILE)
    {
        CPFArrayBSTR    *rgFiles = (CPFArrayBSTR *)pfdin->pv;
        CComBSTR        bstr;

        bstr = pfdin->psz1;
        if (bstr.m_str != NULL && rgFiles != NULL)
        {
            if (SUCCEEDED(rgFiles->Append(bstr.m_str)))
                bstr.Detach();
        }

    }

    return 0;
}

/////////////////////////////////////////////////////////////////////////////
// our exposed functions


// **************************************************************************
HRESULT PFExtractFromCab(LPWSTR wszCab, LPWSTR wszDestFile, 
                         LPWSTR wszFileToFind)
{
    USES_CONVERSION;
    USE_TRACING("PFExtractFromCabinet");

    SPFFileInfo pffi;
    HRESULT     hr = NOERROR;
    BOOL        fRes = FALSE;
    HFDI        hfdi = NULL;
    char        szCabName[MAX_PATH];
    char        szCabPath[MAX_PATH];
    BOOL        fOk;
    ERF         erf;

    VALIDATEPARM(hr, (wszCab == NULL || wszDestFile == NULL ||
                      wszFileToFind == NULL));
    if (FAILED(hr))
        goto done;

    // create the cab handle
    hfdi = FDICreate(mem_alloc, mem_free, fdi_open, fdi_read, fdi_write,
                     fdi_close, fdi_seek, cpuUNKNOWN, &erf);
    VALIDATEEXPR(hr, (hfdi == NULL), Err2HR(MyCabGetLastError()));
    if (FAILED(hr))
        goto done;

    __try
    {
        pffi.szCab      = W2A(wszCab);
        pffi.szDestFile = W2A(wszDestFile);
        pffi.szFileName = W2A(wszFileToFind);
        pffi.fFound     = FALSE;
    }
    __except(1)
    {
        hr = E_OUTOFMEMORY;
    }
    if (FAILED(hr))
        goto done;

    SplitPath(pffi.szCab, szCabPath, szCabName);
    fOk = FDICopy(hfdi, szCabName, szCabPath, 0, fdi_notify_copy, NULL, &pffi);
    VALIDATEEXPR(hr, (fOk == FALSE), Err2HR(MyCabGetLastError()));
    if (FAILED(hr))
        goto done;

    hr = (pffi.fFound) ? NOERROR : S_FALSE;

done:
    if (hfdi != NULL)
        FDIDestroy(hfdi);

    return hr;
}

// **************************************************************************
HRESULT PFGetCabFileList(LPWSTR wszCabName, CPFArrayBSTR &rgFiles)
{
    USES_CONVERSION;
    USE_TRACING("PFGetCabFiles");

    CComBSTR    bstr;
    HRESULT     hr = NOERROR;
    HFDI        hfdi = NULL;
    char        szCabName[MAX_PATH], szCabPath[MAX_PATH], *pszCab = NULL;
    BOOL        fOk;
    ERF         erf;

    rgFiles.RemoveAll();

    VALIDATEPARM(hr, (wszCabName == NULL)); 
    if (FAILED(hr))
        goto done;

    __try
    {
        pszCab = W2A(wszCabName);
        _ASSERT(pszCab != NULL);
    }
    __except(1)
    {
        hr = E_OUTOFMEMORY;
    }
    if (FAILED(hr))
        goto done;
    
    hfdi = FDICreate(mem_alloc, mem_free, fdi_open, fdi_read, fdi_write,
                     fdi_close, fdi_seek, cpuUNKNOWN, &erf);
    VALIDATEEXPR(hr, (hfdi == NULL), Err2HR(MyCabGetLastError()));
    if (FAILED(hr))
        goto done;

    SplitPath(pszCab, szCabPath, szCabName);
    fOk = FDICopy(hfdi, szCabName, szCabPath, 0, fdi_notify_enum, NULL, 
                  &rgFiles);
    VALIDATEEXPR(hr, (fOk == FALSE), Err2HR(MyCabGetLastError()));
    if (FAILED(hr))
        goto done;

done:
    if (hfdi != NULL)
        FDIDestroy(hfdi);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\common\pfcommon\pfstm.cpp ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    pchstm.h

Abstract:
    This file contains the implementations of various stream objects

Revision History:
    created     derekm      01/19/00

******************************************************************************/

#include "stdafx.h"
#include "pfstm.h"


/////////////////////////////////////////////////////////////////////////////
//  CPFStreamFile- construct / destruct

// **************************************************************************
CPFStreamFile::CPFStreamFile(void)
{
    m_hFile     = INVALID_HANDLE_VALUE;
    m_dwAccess  = 0;
}

// **************************************************************************
CPFStreamFile::~CPFStreamFile(void)
{
    this->Close();
}

/////////////////////////////////////////////////////////////////////////////
//  CPFStreamFile- non interface

// **************************************************************************
HRESULT CPFStreamFile::Open(LPCWSTR szFile, DWORD dwAccess, 
                            DWORD dwDisposition, DWORD dwSharing)
{
    USE_TRACING("CPFStreamFile::Open(szFile)");

    HRESULT hr = NOERROR;
    HANDLE  hFile = INVALID_HANDLE_VALUE;

    VALIDATEPARM(hr, (szFile == NULL));
    if (FAILED(hr))
        goto done;

    hFile = ::CreateFileW(szFile, dwAccess, dwSharing, NULL, dwDisposition, 
                          FILE_ATTRIBUTE_NORMAL, NULL);
    TESTBOOL(hr, (hFile != INVALID_HANDLE_VALUE))
    if (FAILED(hr))
        goto done;

    this->Close();

    m_hFile    = hFile;
    m_dwAccess = dwAccess;
    hFile      = INVALID_HANDLE_VALUE;

done:
    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);
    
    return hr;
}

// **************************************************************************
HRESULT CPFStreamFile::Open(HANDLE hFile, DWORD dwAccess)
{
    USE_TRACING("CPFStreamFile::Open(hFile)");

    HRESULT hr = NOERROR;
    HANDLE  hFileNew = INVALID_HANDLE_VALUE;

    VALIDATEPARM(hr, (hFile == INVALID_HANDLE_VALUE || hFile == NULL));
    if (FAILED(hr))
        goto done;

    TESTBOOL(hr, DuplicateHandle(GetCurrentProcess(), hFile, 
                                 GetCurrentProcess(), &hFileNew, dwAccess, 
                                 FALSE, 0));
    if (FAILED(hr))
        goto done;

    this->Close();

    m_hFile    = hFileNew;
    m_dwAccess = dwAccess;
    hFileNew   = INVALID_HANDLE_VALUE;

done:
    if (hFileNew != INVALID_HANDLE_VALUE)
        CloseHandle(hFileNew);

    return hr;

}

// **************************************************************************
HRESULT CPFStreamFile::Close(void)
{
    USE_TRACING("CPFStreamFile::Close");
    
    if (m_hFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(m_hFile);
        m_hFile = INVALID_HANDLE_VALUE;
    }
    
    return NOERROR;
}


/////////////////////////////////////////////////////////////////////////////
//  CPFStreamFile- ISequentialStream

// **************************************************************************
STDMETHODIMP CPFStreamFile::Read(void *pv, ULONG cb, ULONG *pcbRead)
{
    USE_TRACING("CPFStreamFile::Read");

    HRESULT hr = NOERROR;
    DWORD   cbRead;

    if (pv == NULL || m_hFile == INVALID_HANDLE_VALUE || m_hFile == NULL)
    {
        hr = STG_E_INVALIDPOINTER;
        goto done;
    }

    if (pcbRead != NULL)
        *pcbRead = 0;

    if (ReadFile(m_hFile, pv, cb, &cbRead, NULL) == FALSE)
    {
        if (GetLastError() == ERROR_ACCESS_DENIED)
            hr = STG_E_ACCESSDENIED;
        else
            hr = S_FALSE;
        goto done;
    }

    if (cbRead == 0 && cb != 0)
    {
        hr = S_FALSE;
        goto done;
    }

    if (pcbRead != NULL)
        *pcbRead = cbRead;

done:
    return hr;
}

// **************************************************************************
STDMETHODIMP CPFStreamFile::Write(const void *pv, ULONG cb, ULONG *pcbWritten)
{
    USE_TRACING("CPFStreamFile::Write");

    HRESULT hr = NOERROR;
    DWORD   cbWritten;

    if (pv == NULL || m_hFile == INVALID_HANDLE_VALUE || m_hFile == NULL)
    {
        hr = STG_E_INVALIDPOINTER;
        goto done;
    }

    if ((m_dwAccess & GENERIC_WRITE) == 0)
    {
        hr = STG_E_WRITEFAULT;
        goto done;
    }

    if (pcbWritten != NULL)
        *pcbWritten = 0;

    if (WriteFile(m_hFile, pv, cb, &cbWritten, NULL) == FALSE)
    {
        switch(GetLastError())
        {
            case ERROR_DISK_FULL:
                hr = STG_E_MEDIUMFULL;
                break;

            case ERROR_ACCESS_DENIED:
                hr = STG_E_ACCESSDENIED;
                break;

            default:
                hr = STG_E_CANTSAVE;
        }
        
        goto done;
    }

    if (pcbWritten != NULL)
        *pcbWritten = cbWritten;

done:
    return hr;
} 


/////////////////////////////////////////////////////////////////////////////
//  CPFStreamFile- IStream

// **************************************************************************
STDMETHODIMP CPFStreamFile::Seek(LARGE_INTEGER libMove, DWORD dwOrigin, 
                                 ULARGE_INTEGER *plibNewPosition)
{
    USE_TRACING("CPFStreamFile::Seek");

    HRESULT hr = NOERROR;
    LONG    dwHigh, dwLow;

    if (m_hFile == INVALID_HANDLE_VALUE || m_hFile == NULL) 
    {
        hr = STG_E_INVALIDPOINTER;
        goto done;
    }

    if (plibNewPosition != NULL)
    {
        plibNewPosition->HighPart = 0;
        plibNewPosition->LowPart  = 0;
    }

    switch(dwOrigin)
    {
        default:
        case STREAM_SEEK_CUR: 
            dwOrigin = FILE_CURRENT; 
            break;

        case STREAM_SEEK_SET: 
            dwOrigin = FILE_BEGIN; 
            break;

        case STREAM_SEEK_END: 
            dwOrigin = FILE_END; 
            break;
    }

    TESTBOOL(hr, SetFilePointerEx(m_hFile, libMove, 
                                  (LARGE_INTEGER *)plibNewPosition, dwOrigin));
    if (FAILED(hr))
    {
        hr = STG_E_INVALIDFUNCTION;
        goto done;
    }

done:
    return hr;
}

// **************************************************************************
STDMETHODIMP CPFStreamFile::Stat(STATSTG *pstatstg, DWORD grfStatFlag)
{
    USE_TRACING("CPFStreamFile::Seek");

    BY_HANDLE_FILE_INFORMATION fi;
    HRESULT                    hr = NOERROR;

    if (pstatstg == NULL || m_hFile == INVALID_HANDLE_VALUE || 
        m_hFile == NULL)
    {
        hr = STG_E_INVALIDPOINTER;
        goto done;
    }

    if (GetFileInformationByHandle(m_hFile, &fi) == FALSE)
    {
        hr = STG_E_ACCESSDENIED;
        goto done;
    }

    pstatstg->pwcsName          = NULL;
    pstatstg->type              = STGTY_STREAM;
    pstatstg->cbSize.HighPart   = fi.nFileSizeHigh;
    pstatstg->cbSize.LowPart    = fi.nFileSizeLow;
    pstatstg->mtime             = fi.ftCreationTime;
    pstatstg->ctime             = fi.ftLastAccessTime;
    pstatstg->atime             = fi.ftLastWriteTime;
    pstatstg->clsid             = CLSID_NULL;
    pstatstg->grfMode           = 0;
    pstatstg->grfLocksSupported = 0;
    pstatstg->grfStateBits      = 0;
    pstatstg->reserved          = 0;

done:
    return hr;
}

// **************************************************************************
STDMETHODIMP CPFStreamFile::Clone(IStream **ppstm)
{
    USE_TRACING("CPFStreamFile::Clone");

    CPFStreamFile   *pstm = NULL;
    HRESULT         hr = NOERROR;

    if (ppstm == NULL)
    {
        hr = STG_E_INVALIDPOINTER;
        goto done;
    }

    // Create a new stream object.
    pstm = CPFStreamFile::CreateInstance();
    if (pstm == NULL)
    {
        hr = STG_E_INSUFFICIENTMEMORY;
        goto done;
    }
    pstm->AddRef();

    // intialize it
    hr = pstm->Open(m_hFile, m_dwAccess);
    if (FAILED(hr))
    {
        hr = STG_E_INVALIDPOINTER;
        goto done;
    }

    // need to hand back the IStream interface, so...
    hr = pstm->QueryInterface(IID_IStream, (LPVOID *)ppstm);
    _ASSERT(SUCCEEDED(hr));

    pstm = NULL;

done:
    if (pstm != NULL)
        pstm->Release();

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
//  CPFStreamMem- construct / destruct

// **************************************************************************
CPFStreamMem::CPFStreamMem(void)
{
    m_pvData    = NULL;
    m_pvPtr     = NULL;
    m_cb        = 0;
    m_cbRead    = 0;
    m_cbGrow    = 0;
}

// **************************************************************************
CPFStreamMem::~CPFStreamMem(void)
{
    this->Clean();
}


/////////////////////////////////////////////////////////////////////////////
//  CPFStreamMem- non interface

// **************************************************************************
HRESULT CPFStreamMem::Init(DWORD cbStart, DWORD cbGrowBy)
{
    USE_TRACING("CPFStreamMem::Init");

    HRESULT hr = NOERROR;
    LPVOID  pvNew = NULL;

    // if the user passes us -1 for either of these, he means 'use default',
    //  which is the system page size...
    if (cbStart == (DWORD)-1 || cbGrowBy == (DWORD)-1)
    {
        SYSTEM_INFO si;

        ZeroMemory(&si, sizeof(si));
        GetSystemInfo(&si);
        if (cbStart == (DWORD)-1)
            cbStart = si.dwPageSize;
        if (cbGrowBy == (DWORD)-1)
            cbGrowBy = si.dwPageSize;
    }

    if (cbStart > 0)
    {
        pvNew = MyAlloc(cbStart);
        VALIDATEEXPR(hr, (pvNew == NULL), E_OUTOFMEMORY);
        if (FAILED(hr))
            goto done;
    }

    this->Clean();

    m_pvData  = pvNew;
    m_pvPtr   = pvNew;
    m_cb      = cbStart;
    m_cbWrite = 0;
    m_cbGrow  = cbGrowBy;

    pvNew     = NULL;

done:
    if (pvNew != NULL)
        MyFree(pvNew);
    
    return hr;
}


// **************************************************************************
HRESULT CPFStreamMem::InitBinBlob(LPVOID pv, DWORD cb, DWORD cbGrow)
{
    USE_TRACING("CPFStreamMem::InitBinBlob");

    HRESULT hr = NOERROR;
    LPVOID  pvNew = NULL;

    VALIDATEPARM(hr, (pv == NULL));
    if (FAILED(hr))
        goto done;

    if (cb == 0)
        goto done;        

    pvNew = MyAlloc(cb);
    VALIDATEEXPR(hr, (pvNew == NULL), E_OUTOFMEMORY);
    if (FAILED(hr))
        goto done;

    CopyMemory(pvNew, pv, cb);

    this->Clean();

    m_pvData  = pvNew;
    m_pvPtr   = pvNew;
    m_cb      = cb;
    m_cbWrite = cb;
    m_cbGrow  = cbGrow;

    pvNew     = NULL;

done:
    if (pvNew != NULL)
        MyFree(pvNew);
    
    return hr;
}

// **************************************************************************
HRESULT CPFStreamMem::InitTextBlob(LPCWSTR wsz, DWORD cch, BOOL fConvertToANSI)
{
    USE_TRACING("CPFStreamMem::InitTextBlob(LPCWSTR)");

    HRESULT hr = NOERROR;
    LPVOID  pvNew = NULL;
    DWORD   cb;

    VALIDATEPARM(hr, (wsz == NULL));
    if (FAILED(hr))
        goto done;

    if (cch == 0)
        goto done;        

    if (fConvertToANSI)
    {
        cb = WideCharToMultiByte(CP_ACP, 0, wsz, -1, NULL, 0, NULL, NULL);
        TESTBOOL(hr, (cb != 0));
        if (FAILED(hr))
            goto done;

        pvNew = MyAlloc(cb);
        VALIDATEEXPR(hr, (pvNew == NULL), E_OUTOFMEMORY);
        if (FAILED(hr))
            goto done;

        if (WideCharToMultiByte(CP_ACP, 0, wsz, -1, (LPSTR)pvNew, cb, NULL, 
                                NULL) == 0)
        TESTBOOL(hr, (cb != 0));
        if (FAILED(hr))
            goto done;
    }

    else
    {
        // assume cch does NOT include the NULL terminator, so gotta add 1
        cb = (cch + 1) * sizeof(WCHAR);
        pvNew = MyAlloc(cb);
        VALIDATEEXPR(hr, (pvNew == NULL), E_OUTOFMEMORY);
        if (FAILED(hr))
            goto done;

        CopyMemory(pvNew, wsz, cb);
    }

    this->Clean();

    m_pvData  = pvNew;
    m_pvPtr   = pvNew;
    m_cb      = cb;
    m_cbWrite = cb;
    m_cbGrow  = 0;

    pvNew     = NULL;

done:
    if (pvNew != NULL)
        MyFree(pvNew);

    return hr;
}

// **************************************************************************
HRESULT CPFStreamMem::InitTextBlob(LPCSTR sz, DWORD cch, BOOL fConvertToWCHAR)
{
    USE_TRACING("CPFStreamMem::InitTextBlob(LPCSTR)");

    HRESULT hr = NOERROR;
    LPVOID  pvNew = NULL;
    DWORD   cb;

    VALIDATEPARM(hr, (sz == NULL));
    if (FAILED(hr))
        goto done;

    if (cch == 0)
        goto done;        

    if (fConvertToWCHAR)
    {
        cb = MultiByteToWideChar(CP_ACP, 0, sz, -1, NULL, 0);
        TESTBOOL(hr, (cb != 0));
        if (FAILED(hr))
            goto done;

        pvNew = MyAlloc(cb);
        VALIDATEEXPR(hr, (pvNew == NULL), E_OUTOFMEMORY);
        if (FAILED(hr))
            goto done;

        cb = MultiByteToWideChar(CP_ACP, 0, sz, -1, (LPWSTR)pvNew, cb);
        TESTBOOL(hr, (cb != 0));
        if (FAILED(hr))
            goto done;
    }

    else
    {
        // assume cch does NOT include the NULL terminator, so gotta add 1
        cb = cch + 1;
        pvNew = MyAlloc(cb);
        VALIDATEEXPR(hr, (pvNew == NULL), E_OUTOFMEMORY);
        if (FAILED(hr))
            goto done;

        CopyMemory(pvNew, sz, cb);
    }

    this->Clean();

    m_pvData  = pvNew;
    m_pvPtr   = pvNew;
    m_cb      = cb;
    m_cbWrite = cb;
    m_cbGrow  = 0;

    pvNew     = NULL;

done:
    if (pvNew != NULL)
        MyFree(pvNew);
    
    return hr;
}

// **************************************************************************
HRESULT CPFStreamMem::Clean(void)
{
    USE_TRACING("CPFStreamMem::Clean");

    if (m_pvData != NULL)
    {
        MyFree(m_pvData);
        m_pvData  = NULL;
        m_pvPtr   = NULL;
        m_cb      = 0;
        m_cbRead  = 0;
        m_cbWrite = 0;
        m_cbGrow  = 0;
    }
    
    return NOERROR;
}


/////////////////////////////////////////////////////////////////////////////
//  CPFStreamMem- ISequentialStream

// **************************************************************************
STDMETHODIMP CPFStreamMem::Read(void *pv, ULONG cb, ULONG *pcbRead)
{
    USE_TRACING("CPFStreamMem::Read");

    HRESULT hr = NOERROR;
    DWORD   cbRead;

    if (pv == NULL || m_pvPtr == NULL)
    {
        hr = STG_E_INVALIDPOINTER;
        goto done;
    }

    if (pcbRead != NULL)
        *pcbRead = 0;

    if (m_cbRead >= m_cbWrite)
    {
        hr = S_FALSE;
        goto done;
    }

    if (m_cbRead + cb > m_cbWrite)
        cbRead = m_cbWrite - m_cbRead;
    else
        cbRead = cb;

    CopyMemory(pv, m_pvPtr, cbRead);

    m_pvPtr  = (LPVOID)((BYTE *)m_pvPtr + cbRead);
    m_cbRead += cbRead;

    if (pcbRead != NULL)
        *pcbRead = cbRead;

done:
    return hr;
}

// **************************************************************************
STDMETHODIMP CPFStreamMem::Write(const void *pv, ULONG cb, ULONG *pcbWritten)
{
    USE_TRACING("CPFStreamMem::Write");

    HRESULT hr = NOERROR;

    if (pv == NULL)
    {
        hr = STG_E_INVALIDPOINTER;
        goto done;
    }

    if (pcbWritten != NULL)
        *pcbWritten = 0;

    if (m_cbRead + cb > m_cb)
    {
        if (m_cbGrow > 0)
        {
            LPVOID  pvNew = NULL, pvPtr;
            DWORD   cbNew;

            cbNew = MyMax(m_cb + m_cbGrow, m_cbRead + cb);
            if (m_pvData == NULL)
            {
                pvNew = MyAlloc(cbNew);
                pvPtr = pvNew;
            }
            else
            {
                pvNew = MyReAlloc(m_pvData, cbNew);
                pvPtr = (LPVOID)((BYTE *)m_pvPtr + m_cbRead);
            }
            VALIDATEEXPR(hr, (pvNew == NULL), STG_E_MEDIUMFULL);
            if (FAILED(hr))
                goto done;

            m_pvData = pvNew;
            m_pvPtr  = pvPtr;
        }

        else
        {
            hr = STG_E_MEDIUMFULL;
            goto done;
        }
    }

    CopyMemory(m_pvPtr, pv, cb);
    
    m_pvPtr   = (LPVOID)((BYTE *)m_pvPtr + cb);
    m_cbRead  += cb;
    if (m_cbRead > m_cbWrite)
        m_cbWrite = m_cbRead;

    if (pcbWritten != NULL)
        *pcbWritten = cb;

done:
    return hr;
} 


/////////////////////////////////////////////////////////////////////////////
//  CPFStreamFile- IStream

// **************************************************************************
STDMETHODIMP CPFStreamMem::Seek(LARGE_INTEGER libMove, DWORD dwOrigin, 
                                ULARGE_INTEGER *plibNewPosition)
{
    USE_TRACING("CPFStreamMem::Seek");

    HRESULT hr = NOERROR;
    LPVOID  pvNew;
    DWORD   cbNew;

    if (m_pvPtr == NULL) 
    {
        hr = STG_E_INVALIDPOINTER;
        goto done;
    }

    if (plibNewPosition != NULL)
    {
        plibNewPosition->HighPart = 0;
        plibNewPosition->LowPart  = 0;
    }

    if (libMove.HighPart != 0 && libMove.HighPart != (DWORD)-1)
    {
        hr = STG_E_INVALIDFUNCTION;
        goto done;
    }

    switch(dwOrigin)
    {
        default:
        case STREAM_SEEK_CUR: 
            pvNew = (LPVOID)((BYTE *)m_pvPtr + libMove.LowPart);
            cbNew = m_cbRead + libMove.LowPart;
            break;

        case STREAM_SEEK_SET:
            pvNew = (LPVOID)((BYTE *)m_pvData + libMove.LowPart);
            cbNew = libMove.LowPart;
            break;

        case STREAM_SEEK_END: 
            pvNew = (LPVOID)(((BYTE *)m_pvData + m_cbWrite) - libMove.LowPart);
            cbNew = m_cbWrite - libMove.LowPart;
            break;
    }

    if (pvNew < m_pvData || cbNew > m_cbWrite)
    {
        hr = STG_E_INVALIDFUNCTION;
        goto done;
    }

    m_pvPtr  = pvNew;
    m_cbRead = cbNew;

    if (plibNewPosition != NULL)
        plibNewPosition->LowPart = cbNew;

done:
    return hr;
}

// **************************************************************************
STDMETHODIMP CPFStreamMem::Stat(STATSTG *pstatstg, DWORD grfStatFlag)
{
    USE_TRACING("CPFStreamMem::Stat");

    HRESULT hr = NOERROR;

    if (pstatstg == NULL || m_pvData == NULL)
    {
        hr = STG_E_INVALIDPOINTER;
        goto done;
    }

    ZeroMemory(pstatstg, sizeof(STATSTG));
    pstatstg->type              = STGTY_STREAM;
    pstatstg->cbSize.LowPart    = m_cbWrite;

done:
    return hr;
}

// **************************************************************************
STDMETHODIMP CPFStreamMem::Clone(IStream **ppstm)
{
    USE_TRACING("CPFStreamMem::Clone");

    CPFStreamMem    *pstm = NULL;
    HRESULT         hr;

    if (ppstm == NULL)
    {
        hr = STG_E_INVALIDPOINTER;
        goto done;
    }

    // Create a new stream object.
    pstm = CPFStreamMem::CreateInstance();
    if (pstm == NULL)
    {
        hr = STG_E_INSUFFICIENTMEMORY;
        goto done;
    }
    pstm->AddRef();

    // intialize it
    hr = pstm->InitBinBlob(m_pvData, m_cbWrite);
    if (FAILED(hr))
    {
        hr = STG_E_INVALIDPOINTER;
        goto done;
    }

    // need to hand back the IStream interface, so...
    hr = pstm->QueryInterface(IID_IStream, (LPVOID *)ppstm);
    _ASSERT(SUCCEEDED(hr));

    pstm = NULL;

done:
    if (pstm != NULL)
        pstm->Release();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\common\pfcommon\util.cpp ===
/********************************************************************

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:
    util.cpp

Abstract:
    utility functions implementation

Revision History:
    DerekM  created  05/01/99

********************************************************************/

#include "stdafx.h"
#include "util.h"

/////////////////////////////////////////////////////////////////////////////
// tracing

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile

HANDLE  g_hPFPrivateHeap = NULL;

//////////////////////////////////////////////////////////////////////////////
// string stuff

// ***************************************************************************
WCHAR *MyStrStrIW(const WCHAR *wcs1, const WCHAR *wcs2)
{
    WCHAR *cp = (WCHAR *)wcs1;
    WCHAR *s1, *s2;

    while (*cp != '\0')
    {
        s1 = cp;
        s2 = (WCHAR *) wcs2;

        while (*s1 != '\0' && *s2 !='\0' && (towlower(*s1) - towlower(*s2)) == 0)
            s1++, s2++;

        if (*s2 == '\0')
             return(cp);

        cp++;
    }

    return(NULL);
}

// ***************************************************************************
CHAR *MyStrStrIA(const CHAR *cs1, const CHAR *cs2)
{
    CHAR *cp = (CHAR *)cs1;
    CHAR *s1, *s2;

    while (*cp != '\0')
    {
        s1 = cp;
        s2 = (CHAR *) cs2;

        while (*s1 != '\0' && *s2 !='\0' && (tolower(*s1) - tolower(*s2)) == 0)
            s1++, s2++;

        if (*s2 == '\0')
             return(cp);

        cp++;
    }

    return(NULL);
}

// **************************************************************************
HRESULT MyURLEncode(LPWSTR wszDest, DWORD cchDest, LPWSTR wszSrc)
{
    USE_TRACING("URLEncode");

    HRESULT hr = NOERROR;
    DWORD   cb;
    CHAR    *pszDest = NULL, *pszSrc;
    CHAR    *szSrcBuf, *szDestBuf, ch;
    
    VALIDATEPARM(hr, (wszDest == NULL || wszSrc == NULL));
    if (FAILED(hr))
        goto done;

    // alloc enuf space to hold the src array as bytes
    cb = (wcslen(wszSrc) + 1) * sizeof(WCHAR);
    __try
    {
        szSrcBuf  = (CHAR *)_alloca(cb);
        szDestBuf = (CHAR *)_alloca(cb * 3);
        _ASSERT(szSrcBuf != NULL);
    }
    __except(1)
    {
        szSrcBuf  = NULL;
        szDestBuf = NULL;
    }
    VALIDATEEXPR(hr, (szSrcBuf == NULL || szDestBuf == NULL), E_OUTOFMEMORY);
    if (FAILED(hr))
        goto done;

    // convert to multibyte so I can properly URL encode the string
    TESTBOOL(hr, (WideCharToMultiByte(CP_ACP, 0, wszSrc, -1, szSrcBuf, cb,
                                      NULL, NULL) != 0));
    if (FAILED(hr))
        goto done;

    pszDest = szDestBuf;
    for(pszSrc = szSrcBuf; *pszSrc != L'\0'; pszSrc++)
    {
        if (isalpha(*pszSrc) || isdigit(*pszSrc))
        {
            *pszDest++ = *pszSrc;
        }

        else
        {
            *pszDest++ = L'%';
            
            // get the trailing byte
            ch = (*pszSrc >> 4) & 0x0F;
            *pszDest++ = (ch < 10) ? ch + L'0' : (ch - 10) + L'A';
            ch = *pszSrc & 0x0F;
            *pszDest++ = (ch < 10) ? ch + L'0' : (ch - 10) + L'A';
        }
    }

    *pszDest = '\0';
 
    // convert back to unicode
    TESTBOOL(hr, (MultiByteToWideChar(CP_ACP, 0, szDestBuf, -1, wszDest, 
                                      cchDest) != 0));
    if (FAILED(hr))
        goto done;

done:
    return hr;
}


////////////////////////////////////////////////////////////////////////////
// File mapping

// **************************************************************************
HRESULT OpenFileMapped(LPWSTR wszFile, LPVOID *ppvFile, DWORD *pcbFile)
{
    USE_TRACING("OpenFileMapped");

    HRESULT hr = NOERROR;
    HANDLE  hMMF = NULL;
    HANDLE  hFile = INVALID_HANDLE_VALUE;
    LPVOID  pvFile = NULL;
    DWORD   cbFile = 0;
    
    VALIDATEPARM(hr, (wszFile == NULL || ppvFile == NULL));
    if (FAILED(hr))
        goto done;

    *ppvFile = NULL;
    if (pcbFile != NULL)
        *pcbFile = 0;
    
    hFile = CreateFileW(wszFile, GENERIC_READ, FILE_SHARE_READ, NULL, 
                        OPEN_EXISTING, 0, NULL);
    TESTBOOL(hr, (hFile != INVALID_HANDLE_VALUE));
    if (FAILED(hr))
        goto done;

    cbFile = GetFileSize(hFile, NULL);
    TESTBOOL(hr, (cbFile != (DWORD)-1));
    if (FAILED(hr))
        goto done;

    hMMF = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, cbFile, NULL);
    TESTBOOL(hr, (hMMF != NULL));
    if (FAILED(hr))
        goto done;

    pvFile = MapViewOfFile(hMMF, FILE_MAP_READ, 0, 0, 0);
    TESTBOOL(hr, (pvFile != NULL));
    if (FAILED(hr))
        goto done;

    *ppvFile = pvFile;
    if (pcbFile != NULL)
        *pcbFile = cbFile;

done:
    if (hMMF != NULL)
        CloseHandle(hMMF);
    if (hFile != NULL)
        CloseHandle(hFile);

    return hr;
}

// **************************************************************************
HRESULT DeleteTempFile(LPWSTR wszFile)
{
    USE_TRACING("DeleteTempFile");

    HRESULT hr = NOERROR;
    WCHAR   *pwsz;

    if (wszFile == NULL)
        return NOERROR;

    // strip off the extension at the end (if it's not a .tmp)
    for(pwsz = wszFile + wcslen(wszFile); *pwsz != L'.' && pwsz > wszFile; pwsz--);
    if (pwsz > wszFile && _wcsicmp(pwsz, L".tmp") != 0)
        *pwsz = L'\0';

    if (DeleteFileW(wszFile) == FALSE)
        hr = Err2HR(GetLastError());

    // can do this even if the extension was a tmp since the value pointed to
    //  by pwsz is '.' if it's greater than wszFile...
    if (pwsz > wszFile)
        *pwsz = L'.';
    
    return hr;
}


//////////////////////////////////////////////////////////////////////////////
// Registry stuff

// **************************************************************************
HRESULT OpenRegKey(HKEY hkeyMain, LPCWSTR wszSubKey, BOOL fWantWrite, 
                   HKEY *phkey)
{
    USE_TRACING("OpenRegKey");

    HRESULT hr = NOERROR;
    REGSAM  samDesired;
    DWORD   dwErr;
    
    VALIDATEPARM(hr, (hkeyMain == NULL || wszSubKey == NULL || phkey == NULL));
    if (FAILED(hr))
        goto done;

    *phkey   = NULL;

    samDesired = (fWantWrite) ? KEY_ALL_ACCESS : KEY_READ;    

    // first try calling RegCreateKeyEx to make sure we create the key if 
    //  it doesn't exist
    TESTERR(hr, RegCreateKeyExW(hkeyMain, wszSubKey, 0, NULL, 0, samDesired, 
                                NULL, phkey, NULL));
    if (FAILED(hr))
    {
        // ok, that didn't work, so try opening the key instead 
        TESTERR(hr, RegOpenKeyExW(hkeyMain, wszSubKey, 0, samDesired, phkey));
    }

done:
    return hr;
}

// **************************************************************************
HRESULT ReadRegEntry(HKEY hkey, LPCWSTR wszValName, DWORD *pdwType,
                     PBYTE pbBuffer, DWORD *pcbBuffer, PBYTE pbDefault,
                     DWORD cbDefault)
{
    USE_TRACING("ReadRegEntry");

    HRESULT hr = NOERROR;
    DWORD   dwErr;

    VALIDATEPARM(hr, (hkey == NULL || wszValName == NULL));
    if (FAILED(hr))
        goto done;

    dwErr = RegQueryValueExW(hkey, wszValName, 0, pdwType, pbBuffer, 
                             pcbBuffer);
    VALIDATEEXPR(hr, (dwErr != ERROR_PATH_NOT_FOUND && 
                      dwErr != ERROR_FILE_NOT_FOUND), Err2HR(dwErr));
    if (FAILED(hr))
        goto done;

    if (dwErr != ERROR_SUCCESS && pbDefault != NULL)
    {
        VALIDATEPARM(hr, (pcbBuffer == NULL && pbBuffer != NULL));
        if (FAILED(hr))
            goto done;          
        
        // if the receiving buffer is NULL, just return the error that 
        //  RegQueryValueEx gave us cuz the user doesn't really want the
        //  value anyway
        VALIDATEEXPR(hr, (pcbBuffer == NULL), Err2HR(dwErr));
        if (FAILED(hr))
            goto done;

        if (pbBuffer == NULL)
        {
            *pcbBuffer = cbDefault;
            hr = NOERROR;
            goto done;
        }
        else if (cbDefault > *pcbBuffer)
        {
            *pcbBuffer = cbDefault;
            hr = Err2HR(ERROR_MORE_DATA);
            goto done;
        }

        CopyMemory(pbBuffer, pbDefault, cbDefault);
        *pcbBuffer = cbDefault;
        if (pdwType != NULL)
            *pdwType = REG_BINARY;

        hr = NOERROR;
        goto done;
    }
done:
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// ia64 data alignment workarounds

#ifdef _WIN64

// ***************************************************************************
ULONG64 AlignTo8Bytes(PBYTE pb)
{
    ULONG64 ul;

    switch((DWORD_PTR)pb & 0x8)
    {
        // yay!  already aligned
        case 0:
            ul = *(ULONG64 *)pb;
            break;

        case 1:
        case 5:
            ul =  *pb << 56;
            ul |= *(ULONG32 *)(pb + 1) << 24;
            ul |= *(USHORT *)(pb + 5) << 8;
            ul |= *(pb + 7);
            break;

        case 2:
        case 6:
            ul =  *(USHORT *)pb << 48;
            ul |= *(ULONG32 *)(pb + 2) << 16;
            ul |= *(USHORT *)(pb + 6);
            break;

        case 3:
        case 7:
            ul =  *pb << 56;
            ul |= *(USHORT *)(pb + 1) << 48;
            ul |= *(ULONG32 *)(pb + 3) << 16;
            ul |= *(pb + 7);
            break;

        case 4:
            ul =  *(ULONG32 *)pb << 32;
            ul |= *(ULONG32 *)(pb + 4);
            break;
    }

    return ul;
}

// ***************************************************************************
ULONG32 AlignTo4Bytes(PBYTE pb)
{
    ULONG32 ul;

    switch((DWORD_PTR)pb & 0x4)
    {
        // yay!  already aligned
        case 0:
            ul = *(ULONG32 *)pb;
            break;

        case 1:
        case 3:
            ul =  *pb << 24;
            ul |= *(short *)(pb + 1) << 8;
            ul |= *(pb + 3);
            break;

        case 2:
            ul = *(short *)pb << 16;
            ul |= *(short *)(pb + 2);
            break;
    }

    return ul;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\common\pfcommon\pfdb.cpp ===
/********************************************************************

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:
    pfdb.cpp

Abstract:
    encapsulates all database activity

Revision History:
    DerekM  created  05/01/99
    DerekM  modified 02/26/00
    DerekM  modified 03/24/00

********************************************************************/

#include "stdafx.h"
#include <adoid.h>
#include "pfdb.h"


/////////////////////////////////////////////////////////////////////////////
//  tracing stuff

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile


/////////////////////////////////////////////////////////////////////////////
// CPFDB- init & termination

// **************************************************************************
CPFDB::CPFDB()
{
    m_rgpParams  = NULL;
    m_pParams    = NULL;
    m_pCmd       = NULL;
    m_pConn      = NULL;
    m_pRS        = NULL;
    m_pFields    = NULL;

    m_fNeedReset = FALSE;
    m_cSlots     = 0;
    m_iLastSlot  = (DWORD)-1;
    m_cte        = adCmdUnspecified;
}

// **************************************************************************
CPFDB::~CPFDB()
{
    this->Cleanup();
}

/////////////////////////////////////////////////////////////////////////////
// CPFDB- IUnknown

// **************************************************************************
STDMETHODIMP_(ULONG) CPFDB::AddRef(void)
{
    USE_TRACING("CPFDB::AddRef");
    
    m_cRef++;
    return m_cRef;
}

// **************************************************************************
STDMETHODIMP_(ULONG) CPFDB::Release(void)
{
    USE_TRACING("CPFDB::Release");

    m_cRef--;
    if (m_cRef == 0)
    {
        delete this;
        return 0;
    }
    
    return m_cRef;
}


/////////////////////////////////////////////////////////////////////////////
// CPFDB- internal methods

// **************************************************************************
void CPFDB::Cleanup(void)
{
    USE_TRACING("CPFDB::Cleanup");
    
    if (m_rgpParams != NULL)
    {
        DWORD i;
        for (i = 0; i < m_cSlots; i++)
        {
            if (m_rgpParams[i] != NULL)
                m_rgpParams[i]->Release();
        }
        MyFree(m_rgpParams);
    }

    m_bstrConn.Empty();
    m_bstrCmd.Empty();

    if (m_pParams != NULL)
        m_pParams->Release();
    if (m_pCmd != NULL)
        m_pCmd->Release();
    if (m_pConn != NULL)
        m_pConn->Release();
    if (m_pFields != NULL)
        m_pFields->Release();
    if (m_pRS != NULL)
    {
        m_pRS->Close();
        m_pRS->Release();
    }

    m_rgpParams  = NULL;
    m_pParams    = NULL;
    m_pCmd       = NULL;
    m_pConn      = NULL;
    m_pRS        = NULL;
    m_pFields    = NULL;

    m_fNeedReset = FALSE;
    m_cSlots     = 0;
    m_iLastSlot  = (DWORD)-1;
    m_cte        = adCmdUnspecified;
}

// **************************************************************************
HRESULT CPFDB::AddParameterObj(DWORD iPos)
{
    USE_TRACING("CPFDB::CreateParameter");

    VARIANT varEmpty;
    HRESULT hr = NOERROR;

    if (iPos >= m_cSlots)
    {
        LPVOID pv;
        DWORD  cSlots;
        
        cSlots = MyMax(m_cSlots * 2, c_cInitialProps);
        cSlots = MyMax(cSlots , iPos + 1);

        pv = MyAlloc(cSlots * sizeof(ADOParameter *));
        VALIDATEEXPR(hr, (pv == NULL), E_OUTOFMEMORY);
        if (FAILED(hr))
            goto done;

        CopyMemory(pv, m_rgpParams, m_cSlots * sizeof(ADOParameter *));
        MyFree(m_rgpParams);
        
        m_rgpParams = (ADOParameter **)pv;
        m_cSlots    = cSlots;
    }

    // create the parameter and set up the direction
    VariantInit(&varEmpty);
    TESTHR(hr, m_pCmd->CreateParameter(NULL, adEmpty, adParamInput, 0, 
                                       varEmpty, &m_rgpParams[iPos]));
    if (FAILED(hr))
        goto done;

done:
    
    return hr;
}

// **************************************************************************
HRESULT CPFDB::TestConnAndRefresh(void)
{
    USE_TRACING("CPFDB::AttemptReset");

    ADORecordset    *pRS = NULL;
    CComBSTR        bstr;
    HRESULT         hr = NOERROR;

    // if these are missing, we are totally screwed.  So tell the caller 
    //  about and share the annoyance
    VALIDATEEXPR(hr, (m_pCmd == NULL || 
                      (m_pConn == NULL && m_bstrConn.m_str == NULL)), E_FAIL);
    if (FAILED(hr))
        goto done;

    // ok, first try to do a bogus send to see if the connection is there or
    //  not...
    TESTHR(hr, bstr.Append(L"SELECT 1"));
    if (FAILED(hr))
        goto done;

    TESTHR(hr, m_pCmd->put_CommandText(bstr.m_str));
    if (FAILED(hr))
        goto done;

    // if this succeeds, there's nothing wrong with the connection (yeah, we
    //  actually WANT this to fail...)
    TESTHR(hr, m_pCmd->Execute(NULL, NULL, adCmdText | adExecuteNoRecords, 
                               &pRS));
    if (SUCCEEDED(hr))
    {
        hr = S_FALSE;
        goto done;
    }

    // ok, so the connection is somehow screwed up so try to fix it...
    VALIDATEEXPR(hr, (m_bstrConn.m_str == NULL), E_FAIL);
    if (FAILED(hr))
        goto done;

    m_pConn->Close();
    TESTHR(hr, m_pConn->Open(m_bstrConn.m_str, NULL, NULL, 
                             adConnectUnspecified));
    if (FAILED(hr))
        goto done;

    // might have to reset all of the parameter objects at this point & 
    //  re-add them to the command object. 

done:
    if (pRS != NULL)
    {
        pRS->Close();
        pRS->Release();
    }

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CPFDB- exposed methods

// **************************************************************************
HRESULT CPFDB::Init(LPCWSTR wszConn, DWORD dwTimeout)
{
    USE_TRACING("CPFDB::Init");

    ADOConnection   *pConn = NULL;
    CComBSTR        bstrConn;
    HRESULT         hr = NOERROR;

    VALIDATEPARM(hr, (wszConn == NULL || dwTimeout == 0));
    if (FAILED(hr))
        goto done;

    TESTHR(hr, CoCreateInstance(CLSID_CADOConnection, NULL, 
                                CLSCTX_INPROC_SERVER, IID_IADOConnection, 
                                (LPVOID *)&pConn));
    if (FAILED(hr))
        goto done;

    TESTHR(hr, pConn->put_CommandTimeout(dwTimeout));
    if (FAILED(hr))
        hr = NOERROR;

    TESTHR(hr, bstrConn.Append(wszConn));
    if (FAILED(hr))
        goto done;

    TESTHR(hr, pConn->Open(bstrConn.m_str, NULL, NULL, adConnectUnspecified));
    if (FAILED(hr))
        goto done;

    TESTHR(hr, this->Init(pConn, dwTimeout, bstrConn.m_str));
    if (FAILED(hr))
        goto done;

    // if the Init method succeeded, then it took control of the bstr, so we
    //  don't want to free when we exit.
    bstrConn.Detach();

done:
    if (pConn != NULL)
        pConn->Release();

    return hr;
}

// **************************************************************************
HRESULT CPFDB::Init(ADOConnection *pConn, DWORD dwTimeout, BSTR bstrConn)
{
    USE_TRACING("CPFDB::Init");

    ADOParameters   *pParams = NULL;
    ADOCommand      *pCmd = NULL;
    CComBSTR        bstrConnNew;
    HRESULT         hr = NOERROR;

    // can't have both the connection string and connection object NULL...
    VALIDATEPARM(hr, (pConn == NULL));
    if (FAILED(hr))
        goto done;

    // get the connection string for the object
    if (bstrConn == NULL)
    {
        TESTHR(hr, pConn->get_ConnectionString(&bstrConnNew));
        if (FAILED(hr))
            goto done;
    }
    else
    {
        bstrConnNew.Attach(bstrConn);
    }

    // set up the command object
    TESTHR(hr, CoCreateInstance(CLSID_CADOCommand, NULL, CLSCTX_INPROC_SERVER,
                                IID_IADOCommand25, (LPVOID *)&pCmd));
    if (FAILED(hr))
        goto done;

    TESTHR(hr, pCmd->put_CommandTimeout(dwTimeout));
    if (FAILED(hr))
        hr = NOERROR;

    TESTHR(hr, pCmd->putref_ActiveConnection(pConn));
    if (FAILED(hr))
        goto done;

    TESTHR(hr, pCmd->get_Parameters(&pParams));
    if (FAILED(hr))
        goto done;

    // free up anything that already exists
    this->Cleanup();

    // save off what we just allocated...
    pConn->AddRef();
    m_pConn     = pConn;
    m_pCmd      = pCmd;
    m_pParams   = pParams;

    pParams     = NULL;
    pCmd        = NULL;

    if (bstrConnNew.m_str != NULL)
        m_bstrConn.Attach(bstrConnNew.Detach());

done:
    if (pParams != NULL)
        pParams->Release();
    if (pCmd != NULL)
        pCmd->Release();
    
    return hr;
}

// **************************************************************************
HRESULT CPFDB::Begin(LPCWSTR wszCmd, CommandTypeEnum cte)
{
    USE_TRACING("CPFDB::Begin");

    HRESULT     hr = NOERROR;

    // validate params
    VALIDATEPARM(hr, (wszCmd == NULL));
    if (FAILED(hr))
        goto done;

    // make sure we've been initialized
    VALIDATEEXPR(hr, (m_pCmd == NULL), E_FAIL);
    if (FAILED(hr))
        goto done;

    if (m_fNeedReset)
    {
        TESTHR(hr, this->Reset());
        if (FAILED(hr))
            goto done;
    }

    // set the command text
    TESTHR(hr, m_bstrCmd.Append(wszCmd));
    if (FAILED(hr))
        goto done;

    TESTHR(hr, m_pCmd->put_CommandText(m_bstrCmd.m_str));
    if (FAILED(hr))
        goto done;

    TESTHR(hr, m_pCmd->put_CommandType(cte));
    if (FAILED(hr))
        goto done;

    m_cte = cte;

done:
    return hr;
}


// **************************************************************************
HRESULT CPFDB::Reset(void)
{
    USE_TRACING("CPFDB::Reset");

    HRESULT hr = NOERROR;

    // check if we need to reset internal stuff
    if (m_fNeedReset && m_pParams != NULL)
    {
        VARIANT var;
        long    cParams, i;

        // got to delete everything in the parameters object cuz ADO is 
        //  stupid and won't let us reuse parameter objects.
        TESTHR(hr, m_pParams->get_Count(&cParams));
        if (FAILED(hr))
            goto done;

        VariantInit(&var);
        V_VT(&var) = VT_I4;
        V_I4(&var) = 0;
        for (i = 0; i < cParams; i++)
        {
            TESTHR(hr, m_pParams->Delete(var));
            if (FAILED(hr))
                goto done;
            if (m_rgpParams != NULL && m_rgpParams[i] != NULL)
            {
                m_rgpParams[i]->Release();
                m_rgpParams[i] = NULL;
            }
        }
    }

    m_bstrCmd.Empty();

    if (m_pFields != NULL)
        m_pFields->Release();
    if (m_pRS != NULL)
    {
        m_pRS->Close();
        m_pRS->Release();
    }
    m_pFields    = NULL;
    m_pRS        = NULL;
    m_fNeedReset = FALSE;
    m_iLastSlot  = (DWORD)-1;
    m_cte        = adCmdUnspecified;

done:
    return hr;
}

// **************************************************************************
HRESULT CPFDB::AddInParam(VARIANT &varData, DataTypeEnum dtADO, DWORD iPos)
{
    USE_TRACING("CPFDB::AddInParam");
    
    VARIANT var;
    HRESULT hr = NOERROR;
    DWORD   dwSize;

    VALIDATEEXPR(hr, (m_fNeedReset || m_pCmd == NULL), E_FAIL);
    if (FAILED(hr))
        goto done;

    VariantInit(&var);

    // if he passed in -1, it means to use 1 more than the last parameter
    //  added so far.
    if (iPos == (DWORD)-1)
        iPos = m_iLastSlot + 1;

    // check if we need to alloc a new parameter
    TESTHR(hr, this->AddParameterObj(iPos));
    if (FAILED(hr))
        goto done;

    // set the fact that it's an input parameter
    TESTHR(hr, m_rgpParams[iPos]->put_Direction(adParamInput));
    if (FAILED(hr))
        goto done;

    // if we got passed in a BSTR with a NULL string, convert it 
    //  to an empty parameter.
    if (V_VT(&varData) == VT_BSTR && V_BSTR(&varData) == NULL)
        V_VT(&varData) = VT_EMPTY;

    // ok, so we have some special case handling for adLongVarWChar types.
    //  If we have data for it (type is set to VT_BSTR) then we gotta get
    //   the size of that data & pass it to the parameter object.
    //  If we don't have data for it (type set to VT_EMPTY) then we gotta
    //   change the data type to adVarWChar cuz adLongVarWChar expects a non-
    //   zero size when u append it to the Parameters collection.  Stupid ADO.
    // more ADO stupidity.  If the size of a string isn't specified, ADO will
    //  determine the max size of the column and tack on spaces until the 
    //  string we send up is the size of the column.  So we need to specify a
    //  size or we'll end up using WAY more space that we need to.
    switch(dtADO)
    {
        case adLongVarWChar:
        case adLongVarBinary:
        case adLongVarChar:
        case adVarWChar:
        case adVarChar:
        case adVarBinary:
            if (V_VT(&varData) == VT_BSTR && *(V_BSTR(&varData)) != L'\0')
            {
                switch(dtADO)
                {
                    case adLongVarWChar:
                    case adLongVarChar:
                    case adVarWChar:
                    case adVarChar:
                        dwSize = SysStringLen(V_BSTR(&varData));
                        break;

                    case adLongVarBinary:
                    case adVarBinary:
                        dwSize = SysStringByteLen(V_BSTR(&varData));
                        break;
                }
            }

            else if (V_VT(&varData) == (VT_ARRAY | VT_UI1) && 
                     (dtADO == adVarBinary || dtADO == adLongVarBinary))
            {
                dwSize = V_ARRAY(&varData)->rgsabound[0].cElements - 
                         V_ARRAY(&varData)->rgsabound[0].lLbound;
            }

            else
            {
                dwSize = 0;
                switch(dtADO)
                {
                    case adLongVarWChar:
                    case adVarWChar:
                    case adLongVarChar:
                    case adVarChar:
                        dtADO = adBSTR;
                        break;
                }
            }

            // gotta set the size of these
            TESTHR(hr, m_rgpParams[iPos]->put_Size(dwSize));
            if (FAILED(hr))
                goto done;

            break;
    }

    // set the type
    TESTHR(hr, m_rgpParams[iPos]->put_Type(dtADO));
    if (FAILED(hr))
        goto done;

    TESTHR(hr, m_rgpParams[iPos]->put_Value(varData));
    if (FAILED(hr))
        goto done;

    if (iPos > m_iLastSlot || m_iLastSlot == (DWORD)-1)
        m_iLastSlot = iPos;

done:
    return hr;
}

// **************************************************************************
HRESULT CPFDB::AddOutParam(DataTypeEnum dtADO, DWORD iPos, BOOL fSPRetVal, 
                           DWORD cchSize)
{
    USE_TRACING("CPFDB::AddOutParam");

    HRESULT hr = NOERROR;

    VALIDATEEXPR(hr, (m_fNeedReset || m_pCmd == NULL), E_FAIL);
    if (FAILED(hr))
        goto done;

    // if he passed in -1, it means to use 1 more than the last parameter
    //  added so far.
    if (iPos == (DWORD)-1)
        iPos = m_iLastSlot + 1;

    // check if we need to alloc a new parameter
    TESTHR(hr, this->AddParameterObj(iPos));
    if (FAILED(hr))
        goto done;

    // set the type
    TESTHR(hr, m_rgpParams[iPos]->put_Type(dtADO));
    if (FAILED(hr))
        goto done;

    // set the fact that it's an output parameter
    if (fSPRetVal)
    {
        TESTHR(hr, m_rgpParams[iPos]->put_Direction(adParamReturnValue));
    }
    else
    {
        TESTHR(hr, m_rgpParams[iPos]->put_Direction(adParamOutput));
    }
    if (FAILED(hr))
        goto done;

    // if we have a string output parameter, we gotta set the size 
    //  of the string we want returned to us.  Why can't ADO just 
    //  return us the string in a BSTR?  Cuz ADO is stupid.
    if (dtADO == adVarWChar || dtADO == adBSTR || dtADO == adVarChar)
    {
        TESTHR(hr, m_rgpParams[iPos]->put_Size(cchSize));
        if (FAILED(hr))
            goto done;
    }

    if (iPos > m_iLastSlot || m_iLastSlot == (DWORD)-1)
        m_iLastSlot = iPos;

done:
    return hr;
}

// **************************************************************************
HRESULT CPFDB::Execute(BOOL fNeedRS)
{
    USE_TRACING("CPFDB::Commit");

    ADORecordset    *pRS = NULL;
    IDispatch       *pdisp = NULL;
    HRESULT         hr = NOERROR;
    DWORD           i;
    LONG            lVal;
    BOOL            fConnReset = FALSE;

#if defined(DEBUG) || defined(_DEBUG)
    ParameterDirectionEnum  pdDbgADO[32];
    DataTypeEnum            dtDbgADO[32];
    VARIANT                 varDbgVal[32];
    DWORD                   iDbg;

    ZeroMemory(pdDbgADO, sizeof(pdDbgADO));
    ZeroMemory(dtDbgADO, sizeof(dtDbgADO));
    ZeroMemory(varDbgVal, sizeof(varDbgVal));
#endif

    // don't want to try this if we failed once or the command object
    //  doesn't exist
    VALIDATEEXPR(hr, (m_fNeedReset || m_pCmd == NULL), E_FAIL);
    if (FAILED(hr))
        goto done;

    m_fNeedReset = TRUE;

    // put all of the parameters into the query... 
    for (i = 0; i < m_iLastSlot + 1; i++)
    {
        // we cannot have an empty parameter cuz ADO will choke if we do.  
        //  And we can't fill it with a default empty parameter (ie of some
        //  random type) cuz ADO will complain that it doesn't know how to
        //  (essentially) convert NULL into NULL or some such stuff. 
        VALIDATEEXPR(hr, (m_rgpParams[i] == NULL), E_FAIL);
        if (FAILED(hr))
            goto done;

#if defined(DEBUG) || defined(_DEBUG)
        if (i < 32)
        {
            VariantInit(&varDbgVal[i]);
            m_rgpParams[i]->get_Direction(&pdDbgADO[i]);
            m_rgpParams[i]->get_Type(&dtDbgADO[i]);
            m_rgpParams[i]->get_Value(&varDbgVal[i]);
        }
#endif 

        TESTHR(hr, m_rgpParams[i]->QueryInterface(IID_IDispatch, 
                                                  (LPVOID *)&pdisp));
        _ASSERT(SUCCEEDED(hr));

        TESTHR(hr, m_pParams->Append(pdisp));
        if (FAILED(hr))
            goto done;

        pdisp->Release();
        pdisp = NULL;

    }

    // execute the sucker
    lVal = (fNeedRS) ? m_cte : m_cte | adExecuteNoRecords;
    TESTHR(hr, m_pCmd->Execute(NULL, NULL, lVal, &pRS));
    if (FAILED(hr))
        goto done;

    // ok, if we have the recordset.  If the caller wanted one, check & see if
    //  it has any data & fetch the first set of fields out of it...
    if (fNeedRS)
    {
        VARIANT_BOOL    vbf;

        if (pRS == NULL)
        {
            hr = S_FALSE;
            goto done;
        }

        TESTHR(hr, pRS->get_EOF(&vbf));
        if (FAILED(hr))
            goto done;

        if (vbf == VARIANT_TRUE)
        {
            hr = S_FALSE;
            goto done;
        }

        TESTHR(hr, pRS->get_Fields(&m_pFields));
        if (FAILED(hr))
            goto done;

        m_pRS = pRS;
        pRS   = NULL;
    }

done:
#if defined(DEBUG) || defined(_DEBUG)
    for (iDbg = 0; iDbg < m_iLastSlot + 1; iDbg++)
        VariantClear(&(varDbgVal[iDbg]));
#endif   
    if (pRS != NULL)
    {
        pRS->Close();
        pRS->Release();
    }
    if (pdisp != NULL)
        pdisp->Release();
    
    return hr;
}

// **************************************************************************
HRESULT CPFDB::GetOutParam(VARIANT &varParam, VARIANT *pvar, VARTYPE vt)
{
    USE_TRACING("CPFDB::GetOutParam");
    
    ADOParameter    *pParam = NULL;
    VARIANT         varParamID;
    HRESULT         hr = NOERROR;

    _ASSERT(pvar != NULL && m_pParams != NULL && m_fNeedReset);

    VariantClear(pvar);

    TESTHR(hr, m_pParams->get_Item(varParam, &pParam));
    if (FAILED(hr))
        goto done;

    TESTHR(hr, pParam->get_Value(pvar));
    if (FAILED(hr))
        goto done;

    if (vt != VT_ILLEGAL && V_VT(pvar) != vt)
    {
        TESTHR(hr, VariantChangeType(pvar, pvar, 0, vt));
        if (FAILED(hr))
        {
            VariantClear(pvar);
            goto done;
        }
    }

done:
    if (pParam != NULL)
        pParam->Release();
    
    return hr;
}

// **************************************************************************
HRESULT CPFDB::GetOutParam(BSTR bstrParam, VARIANT *pvar, VARTYPE vt)
{
    USE_TRACING("CPFDB::GetOutParam");
    
    VARIANT varParam;
    HRESULT hr = NOERROR;

    VALIDATEPARM(hr, (bstrParam == NULL || pvar == NULL));
    if (FAILED(hr))
        goto done;

    // make sure we've been initialized & that we've executed an SP...
    VALIDATEEXPR(hr, (m_pParams == NULL || m_fNeedReset == FALSE), E_FAIL);
    if (FAILED(hr))
        goto done;

    // do not free this VARIANT cuz we don't own the BSTR
    VariantInit(&varParam);
    V_VT(&varParam)   = VT_BSTR;
    V_BSTR(&varParam) = bstrParam;

    TESTHR(hr, this->GetOutParam(varParam, pvar, vt));
    if (FAILED(hr))
        goto done;

done:
    return hr;
}

// **************************************************************************
HRESULT CPFDB::GetOutParam(DWORD iParam, VARIANT *pvar, VARTYPE vt)
{
    USE_TRACING("CPFDB::GetOutParam");
    
    VARIANT varParam;
    HRESULT hr = NOERROR;

    VALIDATEPARM(hr, (pvar == NULL));
    if (FAILED(hr))
        goto done;

    // make sure we've been initialized & that we've executed an SP...
    VALIDATEEXPR(hr, (m_pParams == NULL || m_fNeedReset == FALSE), E_FAIL);
    if (FAILED(hr))
        goto done;

    if (iParam == (DWORD)-1)
        iParam = m_iLastSlot;

    // we can't get the parameter via the array we've stored so we have to 
    //  ask the parameter object for it
    if (iParam >= m_cSlots)
    { 
        VariantInit(&varParam);
        V_VT(&varParam) = VT_I4;
        V_I4(&varParam) = iParam;

        TESTHR(hr, this->GetOutParam(varParam, pvar, vt));
        if (FAILED(hr))
            goto done;
    }

    // WOOHOO!!  Life is good when u can just accessed cached stuff...
    else
    {
        VariantClear(pvar);

        TESTHR(hr, m_rgpParams[iParam]->get_Value(pvar));
        if (FAILED(hr))
            goto done;

        if (V_VT(pvar) != vt && vt != VT_ILLEGAL && V_VT(pvar) != VT_NULL &&
            V_VT(pvar) != VT_EMPTY)
        {
            TESTHR(hr, VariantChangeType(pvar, pvar, 0, vt));
            if (FAILED(hr))
            {
                VariantClear(pvar);
                goto done;
            }
        }
    }

done:
    return hr;
}

// **************************************************************************
HRESULT CPFDB::GetNextRow(void)
{
    USE_TRACING("CPFDB::GetNextRow");

    VARIANT_BOOL    vbf;
    HRESULT         hr = NOERROR;

    VALIDATEEXPR(hr, (m_pRS == NULL || m_fNeedReset == FALSE), E_FAIL);
    if (FAILED(hr))
        goto done;
    
    if (m_pFields != NULL)
    {
        m_pFields->Release();
        m_pFields = NULL;
    }

    TESTHR(hr, m_pRS->MoveNext());
    if (FAILED(hr))
        goto done;

    // see if we're at the end of th line & if so, free everything up...
    TESTHR(hr, m_pRS->get_EOF(&vbf));
    if (FAILED(hr))
        goto done;

    if (vbf == VARIANT_TRUE)
    {
        m_pRS->Close();
        m_pRS->Release();
        m_pRS = NULL;
        hr = S_FALSE;
        goto done;
    }

    TESTHR(hr, m_pRS->get_Fields(&m_pFields));
    if (FAILED(hr))
        goto done;

done:
    return hr;
}

// **************************************************************************
HRESULT CPFDB::GetData(VARIANT &varField, VARIANT *pvarData)
{
    USE_TRACING("CPFDB::GetData");

    ADOField    *pField = NULL;
    HRESULT     hr = NOERROR;
    LONG        lVal;
    ADO_LONGPTR llSize;

    _ASSERT(pvarData != NULL && m_pFields != NULL && m_fNeedReset);

    TESTHR(hr, m_pFields->get_Item(varField, &pField));
    if (FAILED(hr))
        goto done;

    TESTHR(hr, pField->get_Attributes(&lVal));
    if (FAILED(hr))
        goto done;

    // get the actual data out of the field- if it has adFldLong set, then
    //  retrieve it using the GetChunk method cuz ADO likes it this way.
    if ((lVal & adFldLong) != 0)
    {
        TESTHR(hr, pField->get_ActualSize(&llSize));
        if (FAILED(hr))
            goto done;

        // NTRAID#NTBUG9-374453-2001/4/21-reinerf
        // we only ever read 4gig of data since GetChunk still only takes a LONG
        lVal = min(MAXLONG, llSize);

        TESTHR(hr, pField->GetChunk(lVal, pvarData));
        if (FAILED(hr))
            goto done;
    }

    else
    {
        TESTHR(hr, pField->get_Value(pvarData));
        if (FAILED(hr))
            goto done;
    }

done:
    if (pField != NULL)
        pField->Release();

    return hr;
}

// **************************************************************************
HRESULT CPFDB::GetData(BSTR bstrField, VARIANT *pvarData)
{
    USE_TRACING("CPFDB::GetData");

    VARIANT     varField;
    HRESULT     hr = NOERROR;
    LONG        cFields;

    VALIDATEPARM(hr, (bstrField == NULL || pvarData == NULL));
    if (FAILED(hr))
        goto done;

    VALIDATEEXPR(hr, (m_pFields == NULL || m_fNeedReset == FALSE), E_FAIL);
    if (FAILED(hr))
        goto done;

    // don't free this VARIANT since we don't own the BSTR
    VariantInit(&varField);
    V_VT(&varField)   = VT_BSTR;
    V_BSTR(&varField) = bstrField;

    TESTHR(hr, this->GetData(varField, pvarData));
    if (FAILED(hr))
        goto done;

done:
    return hr;
}

// **************************************************************************
HRESULT CPFDB::GetData(DWORD iField, VARIANT *pvarData)
{
    USE_TRACING("CPFDB::GetData");

    ADOField    *pField = NULL;
    VARIANT     varField;
    HRESULT     hr = NOERROR;
    LONG        cFields;

    VALIDATEPARM(hr, (pvarData == NULL));
    if (FAILED(hr))
        goto done;

    VALIDATEEXPR(hr, (m_pFields == NULL || m_fNeedReset == FALSE), E_FAIL);
    if (FAILED(hr))
        goto done;

    TESTHR(hr, m_pFields->get_Count(&cFields));
    if (FAILED(hr))
        goto done;

    VALIDATEEXPR(hr, (iField >= (DWORD)cFields), 
                 Err2HR(RPC_S_INVALID_BOUND));
    if (FAILED(hr))
        goto done;

    VariantInit(&varField);
    V_VT(&varField) = VT_I4;
    V_I4(&varField) = iField;

    TESTHR(hr, this->GetData(varField, pvarData));
    if (FAILED(hr))
        goto done;

done:
    return hr;
}

// **************************************************************************
HRESULT CPFDB::GetErrors(ADOErrors **ppErrs)
{
    USE_TRACING("CPFDB::GetErrors");

    HRESULT hr = NOERROR;

    VALIDATEPARM(hr, (ppErrs == NULL));
    if (FAILED(hr))
        goto done;

    VALIDATEEXPR(hr, (m_pConn == NULL), E_FAIL);
    if (FAILED(hr))
        goto done;

    TESTHR(hr, m_pConn->get_Errors(ppErrs));
    if (FAILED(hr))
        goto done;

done:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\common\pfcommon\pfcrc.cpp ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    pfcrc.cpp

Abstract:
    This file contains the implementation of some utility functions for
    computing CRCs.  table & algo stolen from MPC_Common...

Revision History:
    derekm      created     04/25/00

******************************************************************************/

#include "stdafx.h"
#include "pfcrc.h"


// CRC 32 table for use under ZModem protocol, IEEE 802
// G(x) = x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x+1
static DWORD rgdwCRC[256] =
{
    0x00000000, 0x04C11DB7, 0x09823B6E, 0x0D4326D9, 0x130476DC, 0x17C56B6B, 0x1A864DB2, 0x1E475005,
    0x2608EDB8, 0x22C9F00F, 0x2F8AD6D6, 0x2B4BCB61, 0x350C9B64, 0x31CD86D3, 0x3C8EA00A, 0x384FBDBD,
    0x4C11DB70, 0x48D0C6C7, 0x4593E01E, 0x4152FDA9, 0x5F15ADAC, 0x5BD4B01B, 0x569796C2, 0x52568B75,
    0x6A1936C8, 0x6ED82B7F, 0x639B0DA6, 0x675A1011, 0x791D4014, 0x7DDC5DA3, 0x709F7B7A, 0x745E66CD,
    0x9823B6E0, 0x9CE2AB57, 0x91A18D8E, 0x95609039, 0x8B27C03C, 0x8FE6DD8B, 0x82A5FB52, 0x8664E6E5,
    0xBE2B5B58, 0xBAEA46EF, 0xB7A96036, 0xB3687D81, 0xAD2F2D84, 0xA9EE3033, 0xA4AD16EA, 0xA06C0B5D,
    0xD4326D90, 0xD0F37027, 0xDDB056FE, 0xD9714B49, 0xC7361B4C, 0xC3F706FB, 0xCEB42022, 0xCA753D95,
    0xF23A8028, 0xF6FB9D9F, 0xFBB8BB46, 0xFF79A6F1, 0xE13EF6F4, 0xE5FFEB43, 0xE8BCCD9A, 0xEC7DD02D,
    0x34867077, 0x30476DC0, 0x3D044B19, 0x39C556AE, 0x278206AB, 0x23431B1C, 0x2E003DC5, 0x2AC12072,
    0x128E9DCF, 0x164F8078, 0x1B0CA6A1, 0x1FCDBB16, 0x018AEB13, 0x054BF6A4, 0x0808D07D, 0x0CC9CDCA,
    0x7897AB07, 0x7C56B6B0, 0x71159069, 0x75D48DDE, 0x6B93DDDB, 0x6F52C06C, 0x6211E6B5, 0x66D0FB02,
    0x5E9F46BF, 0x5A5E5B08, 0x571D7DD1, 0x53DC6066, 0x4D9B3063, 0x495A2DD4, 0x44190B0D, 0x40D816BA,
    0xACA5C697, 0xA864DB20, 0xA527FDF9, 0xA1E6E04E, 0xBFA1B04B, 0xBB60ADFC, 0xB6238B25, 0xB2E29692,
    0x8AAD2B2F, 0x8E6C3698, 0x832F1041, 0x87EE0DF6, 0x99A95DF3, 0x9D684044, 0x902B669D, 0x94EA7B2A,
    0xE0B41DE7, 0xE4750050, 0xE9362689, 0xEDF73B3E, 0xF3B06B3B, 0xF771768C, 0xFA325055, 0xFEF34DE2,
    0xC6BCF05F, 0xC27DEDE8, 0xCF3ECB31, 0xCBFFD686, 0xD5B88683, 0xD1799B34, 0xDC3ABDED, 0xD8FBA05A,
    0x690CE0EE, 0x6DCDFD59, 0x608EDB80, 0x644FC637, 0x7A089632, 0x7EC98B85, 0x738AAD5C, 0x774BB0EB,
    0x4F040D56, 0x4BC510E1, 0x46863638, 0x42472B8F, 0x5C007B8A, 0x58C1663D, 0x558240E4, 0x51435D53,
    0x251D3B9E, 0x21DC2629, 0x2C9F00F0, 0x285E1D47, 0x36194D42, 0x32D850F5, 0x3F9B762C, 0x3B5A6B9B,
    0x0315D626, 0x07D4CB91, 0x0A97ED48, 0x0E56F0FF, 0x1011A0FA, 0x14D0BD4D, 0x19939B94, 0x1D528623,
    0xF12F560E, 0xF5EE4BB9, 0xF8AD6D60, 0xFC6C70D7, 0xE22B20D2, 0xE6EA3D65, 0xEBA91BBC, 0xEF68060B,
    0xD727BBB6, 0xD3E6A601, 0xDEA580D8, 0xDA649D6F, 0xC423CD6A, 0xC0E2D0DD, 0xCDA1F604, 0xC960EBB3,
    0xBD3E8D7E, 0xB9FF90C9, 0xB4BCB610, 0xB07DABA7, 0xAE3AFBA2, 0xAAFBE615, 0xA7B8C0CC, 0xA379DD7B,
    0x9B3660C6, 0x9FF77D71, 0x92B45BA8, 0x9675461F, 0x8832161A, 0x8CF30BAD, 0x81B02D74, 0x857130C3,
    0x5D8A9099, 0x594B8D2E, 0x5408ABF7, 0x50C9B640, 0x4E8EE645, 0x4A4FFBF2, 0x470CDD2B, 0x43CDC09C,
    0x7B827D21, 0x7F436096, 0x7200464F, 0x76C15BF8, 0x68860BFD, 0x6C47164A, 0x61043093, 0x65C52D24,
    0x119B4BE9, 0x155A565E, 0x18197087, 0x1CD86D30, 0x029F3D35, 0x065E2082, 0x0B1D065B, 0x0FDC1BEC,
    0x3793A651, 0x3352BBE6, 0x3E119D3F, 0x3AD08088, 0x2497D08D, 0x2056CD3A, 0x2D15EBE3, 0x29D4F654,
    0xC5A92679, 0xC1683BCE, 0xCC2B1D17, 0xC8EA00A0, 0xD6AD50A5, 0xD26C4D12, 0xDF2F6BCB, 0xDBEE767C,
    0xE3A1CBC1, 0xE760D676, 0xEA23F0AF, 0xEEE2ED18, 0xF0A5BD1D, 0xF464A0AA, 0xF9278673, 0xFDE69BC4,
    0x89B8FD09, 0x8D79E0BE, 0x803AC667, 0x84FBDBD0, 0x9ABC8BD5, 0x9E7D9662, 0x933EB0BB, 0x97FFAD0C,
    0xAFB010B1, 0xAB710D06, 0xA6322BDF, 0xA2F33668, 0xBCB4666D, 0xB8757BDA, 0xB5365D03, 0xB1F740B4
};


#define CRCInit_1 0x00
#define CRCInit_2 0x00

#define CRC32_1(b, oldcrc) (rgdwCRC[(oldcrc >> 24) & 0xFF] ^ (oldcrc << 8) ^ (b & 0xFF))
#define CRC32_2(b, oldcrc) (rgdwCRC[((oldcrc >> 24) ^ b) & 0xFF] ^ (oldcrc << 8))


// ***************************************************************************
DWORD ComputeCRC32(UCHAR *pb, DWORD cb)
{
    DWORD   ich;
    DWORD   dwCRC = CRCInit_2;

    if (pb == NULL)
        return CRCInit_2;

    for (ich = 0; ich < cb; ich++)
        dwCRC = CRC32_2(pb[ich], dwCRC);
        
    return dwCRC;
}

// ***************************************************************************
DWORD ComputeCRC32(HANDLE hFile)
{
    HANDLE  hmmf = NULL;
    LPVOID  pvData = NULL;
    DWORD   cbFile, dwCRC;

    if (hFile == NULL || hFile == INVALID_HANDLE_VALUE)
        return CRCInit_2;

    // assume file < 4GB
    cbFile = GetFileSize(hFile, NULL);
    if (cbFile == -1)
        return CRCInit_2;

    hmmf = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, cbFile, NULL);
    if (hmmf == NULL)
        return CRCInit_2;

    pvData = MapViewOfFile(hmmf, FILE_MAP_READ, 0, 0, 0);
    CloseHandle(hmmf);
    if (pvData == NULL)
        return CRCInit_2;

    dwCRC = ComputeCRC32((UCHAR *)pvData, cbFile);
    UnmapViewOfFile(pvData);

    return dwCRC;
}

// ***************************************************************************
DWORD ComputeCRC32File(LPWSTR wszFile)
{
    HANDLE  hFile = INVALID_HANDLE_VALUE;
    DWORD   dwCRC;

    if (wszFile == NULL)
        return CRCInit_2;

    hFile = CreateFileW(wszFile, GENERIC_READ, FILE_SHARE_READ, NULL, 
                        OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);
    if (hFile == INVALID_HANDLE_VALUE)
        return CRCInit_2;

    dwCRC = ComputeCRC32(hFile);
    CloseHandle(hFile);

    return dwCRC;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\common\pfcommon\pfhash.cpp ===
/********************************************************************

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:
    PFHash.cpp

Abstract:
    hash table implementation.  This hash table is NOT thread safe.

Revision History:
    DerekM  created  05/01/99
    DerekM  modified 03/14/00

********************************************************************/

#include "stdafx.h"
#include "PFHash.h"


/////////////////////////////////////////////////////////////////////////////
//  tracing stuff

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile


/////////////////////////////////////////////////////////////////////////////
// CPFHashBase - construction

// ***************************************************************************
CPFHashBase::CPFHashBase(void)
{
    m_pfnDelete = NULL;
    m_rgpMap    = NULL;
    m_pEnumNext = NULL;
    m_cSlots    = 0;
    m_cObjs     = 0;
    m_iEnumSlot = (DWORD)-1;
}

// ***************************************************************************
CPFHashBase::~CPFHashBase()
{
    this->Cleanup();
    if (m_rgpMap != NULL)
        MyFree(m_rgpMap);
}

/////////////////////////////////////////////////////////////////////////////
// CPFHashBase - internal methods

// ***************************************************************************
void CPFHashBase::Cleanup(void)
{
	USE_TRACING("CPFHashBase::Cleanup");

    SPFHashObj  *pObj = NULL, *pObjNext;
    DWORD       i;
    
    // if the map is NULL, our work here is done.  We can go lay on a beach
    //  somewhere...
    if (m_rgpMap == NULL)
        return;

    // delete everything from the map
    for (i = 0; i < m_cSlots; i++)
    {
        pObj = m_rgpMap[i];
        while(pObj != NULL)
        {
            pObjNext = pObj->pNext;
            if (pObj->pvTag != NULL)
                /*this->*/DeleteTag(pObj->pvTag);
            if (pObj->pvData != NULL && m_pfnDelete != NULL)
                (*this->m_pfnDelete)(pObj->pvData);
            MyFree(pObj);
            pObj = pObjNext;
        }

        m_rgpMap[i] = NULL;
    }

    m_cObjs = 0;
}

// ***************************************************************************
SPFHashObj *CPFHashBase::FindInChain(LPVOID pvTag, DWORD iSlot, 
                                 SPFHashObj ***pppObjStore)
{
	USE_TRACING("CPFHashBase::FindInChain");

    SPFHashObj  *pObj = NULL, **ppObjStore = NULL;
    INT_PTR     iResult;

    // search thru the array.  Since we insert in sorted order, we can 
    //  optimize searching and stop if we get to an array larger than we are.
    //  So that this can be used to find locations for inserting & deleting, we
    //  also keep track of the next ptr of the previous object and return it if
    //  necessary...
    pObj = m_rgpMap[iSlot];
    ppObjStore = &m_rgpMap[iSlot];
    while (pObj != NULL)
    {
        // if it's a string, do a strcmp.  Otherwise do a subtraction
        iResult = /*this->*/CompareTag(pObj->pvTag, pvTag);
        
        // if it's equal, we found it
        if (iResult == 0)
        {
            break;
        }

        // if it's greater, we can stop
        else if (iResult > 0)
        {
            pObj = NULL;
            break;
        }
               
        // incrememnt ptrs and continue walkin' the chain gang...
        ppObjStore = &(pObj->pNext);
        pObj = pObj->pNext;
    }

    // return the next ptr.
    if (pppObjStore != NULL)
        *pppObjStore = ppObjStore;

    return pObj;
}

////////////////////////////////////////////////////////////////////////////
// CPFHashBase - exposed methods

// ***************************************************************************
HRESULT CPFHashBase::Init(DWORD cSlots)
{
	USE_TRACING("CPFHashBase::Init");

    SPFHashObj  **rgpMap = NULL;
    HRESULT     hr = NOERROR;
    
    VALIDATEPARM(hr, (cSlots <= 1));
    if (FAILED(hr))
        goto done;

    // if we already have an array, clear out the old contents.  If the new
    //  size is different than the old, then nuke the array as well and 
    //  reallocate.
    if (m_rgpMap != NULL)
    {
        this->Cleanup();
        if (cSlots == m_cSlots)
            goto done;

        MyFree(m_rgpMap);
        m_rgpMap = NULL;
        m_cSlots = 0;
    }


    // alloc the array
    rgpMap = (SPFHashObj **)MyAlloc(cSlots * sizeof(SPFHashObj *));
    VALIDATEEXPR(hr, (rgpMap == NULL), E_OUTOFMEMORY);
    if (FAILED(hr))
        goto done;

    ZeroMemory(rgpMap, cSlots * sizeof(SPFHashObj *));

    // save off internal data
    m_rgpMap = rgpMap;
    m_cSlots = cSlots;

    rgpMap = NULL;

done:
    if (rgpMap != NULL)
        MyFree(rgpMap);

    return hr;
}

// ***************************************************************************
HRESULT CPFHashBase::AddToMap(LPVOID pvTag, LPVOID pvData, LPVOID *ppvOld)
{
	USE_TRACING("CPFHashBase::AddToMap");

    SPFHashObj  *pObj = NULL, **ppObjStore = NULL, *pNewObj = NULL;
    HRESULT     hr = NOERROR;
    DWORD       iSlot;

    VALIDATEPARM(hr, (pvTag == NULL));
    if (FAILED(hr))
        goto done;

    // if we don't have a map already setup fail...
    VALIDATEEXPR(hr, (m_rgpMap == NULL), E_FAIL)
    if (FAILED(hr))
        goto done;

    if (ppvOld != NULL)
        *ppvOld = NULL;

    // compute the slot & try to find the object
    iSlot = /*this->*/ComputeSlot(pvTag);
    pObj  = this->FindInChain(pvTag, iSlot, &ppObjStore);
    
    // we're just updating an existing element
    if (pObj != NULL)
    {   
        // does the user want it back?
        if (ppvOld != NULL)
            *ppvOld = pObj->pvData;
        
        // or should be just delete it?
        else if (pObj->pvData != NULL && m_pfnDelete != NULL)
            (*this->m_pfnDelete)(pObj->pvData);

        pObj->pvData = pvData;
    }

    // ok folks, we got REAL work to do now.
    else
    {
        if (ppvOld != NULL)
            *ppvOld = NULL;

        // alloc new object
        pNewObj = (SPFHashObj *)MyAlloc(sizeof(SPFHashObj));
        VALIDATEEXPR(hr, (pNewObj == NULL), E_OUTOFMEMORY);
        if (FAILED(hr))
            goto done;

        TESTHR(hr, /*this->*/AllocTag(pvTag, &(pNewObj->pvTag)));
        if (FAILED(hr))
            goto done;

        pNewObj->pvData = pvData;
        pNewObj->pNext  = *ppObjStore;
        *ppObjStore     = pNewObj;

        // increment the number of objects
        m_cObjs++;

        pNewObj = NULL;
    }


done:
    if (pNewObj != NULL)
    {
        if (pNewObj->pvTag != NULL)
            /*this->*/DeleteTag(pNewObj->pvTag);
        
        MyFree(pNewObj);
    }

    return hr;
}

// ***************************************************************************
HRESULT CPFHashBase::FindInMap(LPVOID pvTag, LPVOID *ppv)
{
	USE_TRACING("CPFHashBase::FindInMap");

    SPFHashObj  *pObj = NULL;
    HRESULT     hr = NOERROR;
    DWORD       iSlot;

    // validate params
    VALIDATEPARM(hr, (ppv == NULL || pvTag == NULL));
    if (FAILED(hr))
        goto done;

    // if we don't have a map already setup fail...
    VALIDATEEXPR(hr, (m_rgpMap == NULL), E_FAIL);
    if (FAILED(hr))
        goto done;

    // compute the slot & try to find the object
    iSlot = /*this->*/ComputeSlot(pvTag);
    pObj  = this->FindInChain(pvTag, iSlot, NULL);

    // if we didn't find it, signal S_FALSE
    if (pObj == NULL)
    {
        hr = S_FALSE;
        goto done;
    }

    // otherwise, return the data to the user
    *ppv = pObj->pvData;

done:
    return hr;
}

// ***************************************************************************
HRESULT CPFHashBase::RemoveFromMap(LPVOID pvTag, LPVOID *ppvOld)
{
	USE_TRACING("CPFHashBase::RemoveFromMap");

    SPFHashObj  *pObj = NULL, **ppObjStore = NULL;
    HRESULT     hr = NOERROR;
    DWORD       iSlot;

    // validate params
    VALIDATEPARM(hr, (ppvOld == NULL || pvTag == NULL));
    if (FAILED(hr))
        goto done;

    // if we don't have a map already setup fail...
    VALIDATEEXPR(hr, (m_rgpMap == NULL), E_FAIL);
    if (FAILED(hr))
        goto done;

    // compute the slot & try to find the object
    iSlot = /*this->*/ComputeSlot(pvTag);
    pObj  = this->FindInChain(pvTag, iSlot, &ppObjStore);
    
    // if we didn't find one, just return NOERROR cuz not having one in the 
    //  map is pretty much what the user wanted...
    if (pObj != NULL)
    {   
        // does the user want it back?
        if (ppvOld != NULL)
            *ppvOld = pObj->pvData;
        
        // or should be just delete it?
        else if (pObj->pvData != NULL && m_pfnDelete != NULL)
            (*this->m_pfnDelete)(pObj->pvData);

        *ppObjStore = pObj->pNext;
        /*this->*/DeleteTag(pObj->pvTag);
        MyFree(pObj);
    }

done:
    return hr;
}

// ***************************************************************************
HRESULT CPFHashBase::RemoveAll(void)
{
	USE_TRACING("CPFHashBase::RemoveAll");

    // if we don't have a map already just succeed cuz everything has been 
    //  deleted.  Otherwise, remove everything in life (as far as the map 
    //  is concerned anyway).
    if (m_rgpMap != NULL)
        this->Cleanup();
    
    return NOERROR;
}

// ***************************************************************************
HRESULT CPFHashBase::BeginEnum(void)
{
	USE_TRACING("CPFHashBase::BeginEnum");

    HRESULT hr = NOERROR;

    // if we don't have a map already setup fail...
    VALIDATEEXPR(hr, (m_rgpMap == NULL), E_FAIL);
    if (FAILED(hr))
        goto done;
    
    m_iEnumSlot = 0;
    m_pEnumNext = m_rgpMap[0];
    
done:
    return hr;
}
// ***************************************************************************
HRESULT CPFHashBase::EnumNext(LPVOID *ppvTag, LPVOID *ppvData)
{
	USE_TRACING("CPFHashBase::EnumNext");

    HRESULT hr = NOERROR;

    // if we don't have a map already setup fail...
    VALIDATEEXPR(hr, (m_rgpMap == NULL || m_iEnumSlot == (DWORD)-1), E_FAIL);
    if (FAILED(hr))
        goto done;

    for(;;)
    {
        if (m_pEnumNext != NULL)
        {
            *ppvTag     = m_pEnumNext->pvTag; 
            *ppvData    = m_pEnumNext->pvData;
            m_pEnumNext = m_pEnumNext->pNext;
            break;
        }

        m_iEnumSlot++;
        if (m_iEnumSlot >= m_cSlots)
        {
            m_iEnumSlot = (DWORD)-1;
            hr          = S_FALSE;
            break;
        }

        m_pEnumNext = m_rgpMap[m_iEnumSlot];
    }

done:
    return hr;
}
/*
#if defined(DEBUG) || defined(_DEBUG)

// ***************************************************************************
void CPFHashBase::DumpAll(FILE *pf)
{
    USE_TRACING("CPFHashBASE::DumpAll");

    SPFHashObj  *pmo = NULL, *pmoNext;
    DWORD       i;
    
    // if the map is NULL, our work here is done.  We can go lay on a beach
    //  somewhere...
    if (m_rgpMap == NULL)
    {
        fprintf(pf, "empty map\n\n");
        return;
    }

    // delete everything from the map
    for (i = 0; i < m_cSlots; i++)
    {
        fprintf(pf, "Slot %2d: ", i);

        pmo = m_rgpMap[i];
        while(pmo != NULL)
        {
            pmoNext = pmo->pNext;
            this->PrintTag(pf, pmo->pvTag);
            pmo = pmoNext;
        }

        fprintf(pf, "\n");
    }

    fprintf(pf, "\n");
}

// ***************************************************************************
void CPFHashBase::DumpCount(FILE *pf)
{
    USE_TRACING("CPFHashBASE::DumpCount");
    fprintf(pf, "count: %d\n", m_cObjs);
}

#endif
*/


/////////////////////////////////////////////////////////////////////////////
// CPFHashWSTR virtual method implementation

// ***************************************************************************
HRESULT CPFHashWSTR::AllocTag(LPVOID pvTag, LPVOID *ppvTagCopy)
{
    USE_TRACING("CPFHashWSTR::AllocTag");
    
    HRESULT hr = NOERROR;
    LPWSTR  pwsz = NULL;

    pwsz = (LPWSTR)MyAlloc((wcslen((LPWSTR)pvTag) + 1) * sizeof(WCHAR));
    VALIDATEEXPR(hr, (pwsz == NULL), E_OUTOFMEMORY);
    if (FAILED(hr))
        goto done;

    wcscpy(pwsz, (LPWSTR)pvTag);
    *ppvTagCopy = (LPVOID)pwsz;

done:
    return hr;
}

// ***************************************************************************
DWORD CPFHashWSTR::ComputeSlot(LPVOID pvTag)
{
    USE_TRACING("CPFHashWSTR::ComputeSlot");

    WCHAR   *pwch = NULL;
    DWORD   dwHash;

    dwHash = 0;
    for (pwch = (WCHAR *)pvTag; *pwch != '\0'; pwch++)
        dwHash = ((dwHash << 6) + towupper(*pwch)) % m_cSlots;

    return dwHash;

}

// ***************************************************************************
void CPFHashWSTR::DeleteTag(LPVOID pvTag)
{
    USE_TRACING("CPFHashWSTR::DeleteTag");
    MyFree(pvTag);
}

// ***************************************************************************
INT_PTR CPFHashWSTR::CompareTag(LPVOID pvTag1, LPVOID pvTag2)
{
    USE_TRACING("CPFHashWSTR::CompareTag");
    return (INT_PTR)_wcsicmp((LPWSTR)pvTag1, (LPWSTR)pvTag2);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\common\pfcommon\pfxml.cpp ===
/********************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    pfxml.cpp

Abstract:
    A simple XML parser & object model (for read only access to an XML
     file.  This is heavily (nearly stolen) from WSmith's SimpleXML 
     stuff that he wrote for the Neptune comments button.  
     Note that this parser / object model is NOT thread safe.

Revision History:
    DerekM    created  03/15/00

********************************************************************/

#include "stdafx.h"
#include "pfxml.h"
#include "xmlparser.h"


/////////////////////////////////////////////////////////////////////////////
// globals

WCHAR g_wszEncoding[] = L"<?xml version=\"1.0\" ?>";


/////////////////////////////////////////////////////////////////////////////
// tracing

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile


/////////////////////////////////////////////////////////////////////////////
// struct used to hold attribute info & associated class stuff

struct SPFXMLNodeAttr
{
    LPWSTR  pwszName;
    LPWSTR  pwszValue;
};

// ***************************************************************************
void CPFArrayAttr::DeleteItem(LPVOID pv)
{
    USE_TRACING("CPFArrayAttr::DeleteItem");

    SPFXMLNodeAttr  *p = (SPFXMLNodeAttr *)pv;

    if (p != NULL)
        MyFree(p, g_hPFPrivateHeap);
}

// ***************************************************************************
LPVOID CPFArrayAttr::AllocItemCopy(LPVOID pv)
{
    USE_TRACING("CPFArrayAttr::AllocItem");

    SPFXMLNodeAttr  *p = (SPFXMLNodeAttr *)pv;
    SPFXMLNodeAttr  *pNew;
    HRESULT         hr = NOERROR;
    SIZE_T          cbName = 0, cbValue = 0;

    VALIDATEPARM(hr, (pv == NULL));
    if (FAILED(hr))
        return NULL;
    
    // assume that the only way that a node was allocated was with the 
    //  add_Attribute fn below...  Thus, the pointers are always non-NULL
    //  and valid & the all the data is in one allocated blob...

    cbName  = (PBYTE)p->pwszName  - ((PBYTE)p + sizeof(SPFXMLNodeAttr));
    cbValue = (PBYTE)p->pwszValue - ((PBYTE)p + sizeof(SPFXMLNodeAttr) + cbName);

    pNew = (SPFXMLNodeAttr *)MyAlloc(sizeof(SPFXMLNodeAttr) + cbName + cbValue, g_hPFPrivateHeap);
    VALIDATEEXPR(hr, (pNew == NULL), E_OUTOFMEMORY);
    if (FAILED(hr))
        return NULL;

    CopyMemory(pNew, p, sizeof(SPFXMLNodeAttr) + cbName + cbValue);
    pNew->pwszName  = (LPWSTR)((PBYTE)pNew + sizeof(SPFXMLNodeAttr));
    pNew->pwszValue = (LPWSTR)((PBYTE)pNew->pwszName + cbName);

    return pNew;
}


/////////////////////////////////////////////////////////////////////////////
// CPFXMLNodeFactory def (defined here cuz it's only used in this file)

// ***************************************************************************
class CPFXMLNodeFactory : 
    public IXMLNodeFactory,
    public CPFPrivHeapGenericClassBase
{
private: 
    CPFXMLNode  *m_pcfxmlRoot;
    CPFXMLNode  *m_pcfxmlCurrent;
    DWORD       m_cRef;

public:
    CPFXMLNodeFactory(void);
    ~CPFXMLNodeFactory(void);

    HRESULT Init(CPFXMLNode **pppfxmlRoot);

public:
    static CPFXMLNodeFactory *CreateInstance(void) { return new CPFXMLNodeFactory; }

    // IUnknown Interface
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID *ppv)
    {
        if (ppv == NULL)
            return E_INVALIDARG;

        *ppv = NULL;

        if (riid == IID_IUnknown)
            *ppv = (IUnknown *)this;
        else if (riid == IID_IXMLNodeFactory)
            *ppv = (IStream *)this;
        else if (riid == IID_ISequentialStream)
            *ppv = (ISequentialStream *)this;
        else
            return E_NOINTERFACE;

        this->AddRef();
        return NOERROR;
    }

    STDMETHOD_(ULONG, AddRef)()
    {
        return InterlockedIncrement((LONG *)&m_cRef);
    }

    STDMETHOD_(ULONG, Release)()
    {
        if (InterlockedDecrement((LONG *)&m_cRef) == 0)
        {
            delete this;
            return 0;
        }

        return m_cRef;
    }

    // IXMLNodeFactory
    STDMETHOD(NotifyEvent)(IXMLNodeSource* pSource, XML_NODEFACTORY_EVENT iEvt);
    STDMETHOD(BeginChildren)(IXMLNodeSource* pSource, XML_NODE_INFO* pNodeInfo);
    STDMETHOD(EndChildren)(IXMLNodeSource* pSource, BOOL fEmpty,
                           XML_NODE_INFO* pNodeInfo);
    STDMETHOD(Error)(IXMLNodeSource* pSource, HRESULT hrErrorCode,
                     USHORT cNumRecs, XML_NODE_INFO** aNodeInfo);
    STDMETHOD(CreateNode)(IXMLNodeSource* pSource, PVOID pNodeParent,
                          USHORT cNumRecs, XML_NODE_INFO** aNodeInfo);
};

/////////////////////////////////////////////////////////////////////////////
// CPFXMLNodeFactory construction

// ***************************************************************************
CPFXMLNodeFactory::CPFXMLNodeFactory()
{
    m_pcfxmlRoot    = NULL;
    m_pcfxmlCurrent = NULL;
    m_cRef          = 0;
}

// ***************************************************************************
CPFXMLNodeFactory::~CPFXMLNodeFactory()
{
    if (m_pcfxmlRoot != NULL)
        m_pcfxmlRoot->Release();
    if (m_pcfxmlCurrent != NULL)
        m_pcfxmlCurrent->Release();
}


/////////////////////////////////////////////////////////////////////////////
// CPFXMLNodeFactory exposed methods

// ***************************************************************************
HRESULT CPFXMLNodeFactory::Init(CPFXMLNode **pppfxmlRoot)
{
    USE_TRACING("CPFXMLNodeFactory::Init");
    
    HRESULT hr = NOERROR;

    if (pppfxmlRoot != NULL)
        *pppfxmlRoot = NULL;
            
    m_pcfxmlRoot = CPFXMLNode::CreateInstance();
    VALIDATEEXPR(hr, (m_pcfxmlRoot == NULL), E_OUTOFMEMORY);
    if (FAILED(hr))
        goto done;

    m_pcfxmlRoot->put_NodeType(xmlntUnknown);
    if (pppfxmlRoot != NULL)
    {
        m_pcfxmlRoot->AddRef();
        *pppfxmlRoot = m_pcfxmlRoot;
    }

done:
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CPFXMLNodeFactory IXMLNodeFactory

// ***************************************************************************
STDMETHODIMP CPFXMLNodeFactory::NotifyEvent(IXMLNodeSource* pSource,
                                            XML_NODEFACTORY_EVENT iEvt)
{
    USE_TRACING("CPFXMLNodeFactory::NotifyEvent");
    
    IXMLParser  *pxp = NULL;
    HRESULT     hr = NOERROR;

    switch (iEvt) 
    {
        // at the start of the document, we need to set our node to be 
        case XMLNF_STARTDOCUMENT:
            VALIDATEEXPR(hr, (m_pcfxmlRoot == NULL), E_FAIL);
            if (FAILED(hr))
                goto done;

            hr = pSource->QueryInterface(IID_IXMLParser, (LPVOID *)&pxp);
            _ASSERT(SUCCEEDED(hr));

            TESTHR(hr, pxp->SetRoot(m_pcfxmlRoot));
            pxp->Release();
            if (FAILED(hr))
                goto done;

            break;

        default:
            break;
    }

done:
    return hr;
}

// ***************************************************************************
STDMETHODIMP CPFXMLNodeFactory::BeginChildren(IXMLNodeSource* pSource, 
                                              XML_NODE_INFO* pNodeInfo)
{
    USE_TRACING("CPFXMLNodeFactory::BeginChildren");

    if (m_pcfxmlCurrent != NULL)
    {
        m_pcfxmlCurrent->Release();
        m_pcfxmlCurrent = NULL;
    }

    return NOERROR;
}

// ***************************************************************************
STDMETHODIMP CPFXMLNodeFactory::EndChildren(IXMLNodeSource* pSource,
                                            BOOL fEmpty, 
                                            XML_NODE_INFO* pNodeInfo)
{
    USE_TRACING("CPFXMLNodeFactory::EndChildren");

    if (m_pcfxmlCurrent != NULL)
    {
        m_pcfxmlCurrent->Release();
        m_pcfxmlCurrent = NULL;
    }

    return NOERROR;
}

// ***************************************************************************
STDMETHODIMP CPFXMLNodeFactory::Error(IXMLNodeSource* pSource, 
                                      HRESULT hrErrorCode,
                                      USHORT cNumRecs, 
                                      XML_NODE_INFO** aNodeInfo)
{
    USE_TRACING("CPFXMLNodeFactory::Error");

    ErrorTrace(0, "Error occurred while parsing XML: 0x%08x", hrErrorCode);

    if (m_pcfxmlCurrent != NULL)
    {
        m_pcfxmlCurrent->Release();
        m_pcfxmlCurrent = NULL;
    }
    
    return hrErrorCode;
}

// ***************************************************************************
STDMETHODIMP CPFXMLNodeFactory::CreateNode(IXMLNodeSource* pSource, 
                                           PVOID pNodeParent, USHORT cNumRecs,
                                           XML_NODE_INFO** aNodeInfo)
{
    USE_TRACING("CPFXMLNodeFactory::CreateNode");

    XML_NODE_INFO   *pni = aNodeInfo[0];
    CPFXMLNode      *ppfxmlParent = (CPFXMLNode *)pNodeParent;
    CPFXMLNode      *ppfxmlNode = NULL;
    HRESULT         hr = NOERROR;
    WCHAR           *pwszStart, *pwszEnd;
    DWORD           cbData;
    BOOL            fGetAttribs = FALSE;

    switch (pni->dwType) 
    {
        case XML_ELEMENT:
            if (m_pcfxmlCurrent != NULL)
            {
                m_pcfxmlCurrent->Release();
                m_pcfxmlCurrent = NULL;
            }

            // Make a new node and add it to the parent node
            ppfxmlNode = CPFXMLNode::CreateInstance();
            VALIDATEEXPR(hr, (ppfxmlNode == NULL), E_OUTOFMEMORY);
            if (FAILED(hr))
                goto done;

            ppfxmlNode->put_NodeType(xmlntElement);

            TESTHR(hr, ppfxmlNode->put_Data(pni->pwcText, pni->ulLen));
            if (FAILED(hr))
                goto done;

            TESTHR(hr, ppfxmlParent->append_Child(ppfxmlNode));
            if (FAILED(hr))
                goto done;

            // set the current node so that future calls will have the correct
            //  parent node
            pni->pNode = (LPVOID)ppfxmlNode;

            // collect attributes, if any
            if (cNumRecs > 1) 
            {
                CComBSTR    bstrVal;
                DWORD       iName = 0;

                for (int i = 1; i < cNumRecs; i++) 
                {
                    XML_NODE_INFO* pniAtt = aNodeInfo[i];

                    switch (pniAtt->dwType) 
                    {
                        // the name of the attribute
                        case XML_ATTRIBUTE:
                            if (iName > 0)
                            {
                                TESTHR(hr,  
                                       ppfxmlNode->add_Attribute(aNodeInfo[iName]->pwcText,
                                                                 bstrVal.m_str,
                                                                 aNodeInfo[iName]->ulLen,
                                                                 bstrVal.Length()));
                                if (FAILED(hr))
                                    goto done;
                                
                                iName = 0;
                                bstrVal.Empty();
                            }

                            iName = i;
                            break;

                        // the value of the attribute- threre may be more 
                        //  than one of these if there is any encoding done
                        //  within the value- IXMLParser behavior
                        case XML_PCDATA:
                        case XML_CDATA:
                            TESTHR(hr, bstrVal.Append(pniAtt->pwcText, 
                                                      pniAtt->ulLen));
                            if (FAILED(hr))
                                goto done;
                            break;

                        default:
                            break;
                    }
                }

                // do we have an attribute that hasn't been added yet? 
                if (iName > 0)
                {
                    TESTHR(hr, ppfxmlNode->add_Attribute(aNodeInfo[iName]->pwcText,
                                                         bstrVal.m_str,
                                                         aNodeInfo[iName]->ulLen,
                                                         bstrVal.Length()));
                    if (FAILED(hr))
                        goto done;
                }
            }

            break;

        case XML_PCDATA:
        case XML_CDATA:
            // do we need to start up a new node?
            if (m_pcfxmlCurrent == NULL)
            {
                ppfxmlNode = CPFXMLNode::CreateInstance();
                VALIDATEEXPR(hr, (ppfxmlNode == NULL), E_OUTOFMEMORY);
                if (FAILED(hr))
                    goto done;

                ppfxmlNode->put_NodeType(xmlntText);

                TESTHR(hr, ppfxmlParent->append_Child(ppfxmlNode));
                if (FAILED(hr))
                    goto done;

                pni->pNode      = (LPVOID)ppfxmlNode;

                m_pcfxmlCurrent = ppfxmlNode;
                ppfxmlNode      = NULL;
            }

            _ASSERT(m_pcfxmlCurrent != NULL);
            
            // skip all leading whitespace
            pwszStart = (LPWSTR)pni->pwcText;
            cbData    = pni->ulLen;
            while(iswspace(*pwszStart) && cbData > 0)
            {
                pwszStart++;
                cbData--;
            }

            // skip all trailing whitespace
            pwszEnd   = ((LPWSTR)pni->pwcText) + pni->ulLen - 1;
            while(iswspace(*pwszEnd) && cbData > 0)
            {
                pwszEnd--;
                cbData--;
            }
            
            if (cbData > 0)
            {
                TESTHR(hr, m_pcfxmlCurrent->append_Data(pwszStart, cbData));
                if (FAILED(hr))
                    goto done;
            }
            
            break;

        default:
            if (m_pcfxmlCurrent != NULL)
            {
                m_pcfxmlCurrent->Release();
                m_pcfxmlCurrent = NULL;
            }

            break;
    }

done:
    if (ppfxmlNode != NULL)
        ppfxmlNode->Release();
    
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
//*************************************************************************//
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
// CPFXMLDocument construction

// ***************************************************************************
CPFXMLDocument::CPFXMLDocument(void)
{
    m_ppfxmlRoot = NULL;
}

// ***************************************************************************
CPFXMLDocument::~CPFXMLDocument(void)
{
    if (m_ppfxmlRoot != NULL)
        m_ppfxmlRoot->Release();
}


/////////////////////////////////////////////////////////////////////////////
// CPFXMLDocument methods

// ***************************************************************************
HRESULT CPFXMLDocument::get_RootNode(CPFXMLNode **pppfxmlRoot)
{
    USE_TRACING("CPFXMLDocument::get_RootNode");

    HRESULT hr = NOERROR;

    VALIDATEPARM(hr, (pppfxmlRoot == NULL));
    if (FAILED(hr))
        goto done;

    *pppfxmlRoot = NULL;

    VALIDATEEXPR(hr, (m_ppfxmlRoot == NULL), E_FAIL);
    if (FAILED(hr))
        goto done;

    m_ppfxmlRoot->AddRef();
    *pppfxmlRoot = m_ppfxmlRoot;

done:
    return hr;
}

// ***************************************************************************
HRESULT CPFXMLDocument::put_RootNode(CPFXMLNode *ppfxmlRoot)
{
    USE_TRACING("CPFXMLDocument::set_RootNode");

    HRESULT hr = NOERROR;

    VALIDATEPARM(hr, (ppfxmlRoot == NULL));
    if (FAILED(hr))
        goto done;

    if (m_ppfxmlRoot != NULL)
        m_ppfxmlRoot->Release();

    ppfxmlRoot->AddRef();
    m_ppfxmlRoot = ppfxmlRoot;

done:
    return hr;
}

// ***************************************************************************
HRESULT CPFXMLDocument::ParseStream(IStream *pStm, DWORD cbStm)
{
    USE_TRACING("CPFXMLDocument::ParseFile");

    CPFXMLNodeFactory   *ppfnf = NULL;
    IXMLNodeFactory     *pnf = NULL;
    IXMLParser          *pxp = NULL;
    CPFXMLNode          *ppfxmlRoot = NULL, *ppfxmlNode = NULL;
    HRESULT             hr = NOERROR;
    WCHAR               wch = 0xfeff;
    DWORD               cbRead, cbToRead;
    BYTE                pbBuffer[4096];
    
    VALIDATEPARM(hr, (pStm == NULL || cbStm == 0));
    if (FAILED(hr))
        goto done;

    ppfnf = CPFXMLNodeFactory::CreateInstance();
    VALIDATEEXPR(hr, (ppfnf == NULL), E_OUTOFMEMORY);
    if (FAILED(hr))
        goto done;

    ppfnf->AddRef();
    TESTHR(hr, ppfnf->Init(&ppfxmlNode));
    if (FAILED(hr))
        goto done;

    TESTHR(hr, ppfnf->QueryInterface(IID_IXMLNodeFactory, (LPVOID *)&pnf));
    if (FAILED(hr))
        goto done;
    
    TESTHR(hr, CoCreateInstance(CLSID_XMLParser, NULL, CLSCTX_INPROC_SERVER, 
                                IID_IXMLParser, (void**)&pxp));
    if (FAILED(hr))
        goto done;

    TESTHR(hr, pxp->SetFlags(XMLFLAG_CASEINSENSITIVE | XMLFLAG_NOWHITESPACE));
    if (FAILED(hr))
        goto done;

    TESTHR(hr, pxp->SetFactory(pnf));
    if (FAILED(hr))
        goto done;

    for(;;)
    {
        cbToRead = MyMin(cbStm, sizeof(pbBuffer));
        TESTHR(hr, pStm->Read(pbBuffer, cbToRead, &cbRead));
        if (FAILED(hr))
            goto done;

        // now push the actual XML in...
        TESTHR(hr, pxp->PushData((const char *)pbBuffer, cbRead, 
                                 (cbToRead != sizeof(pbBuffer))));
        if (FAILED(hr))
            goto done;

        hr = pxp->Run(-1);
        if (hr != E_PENDING)
        {
            if (FAILED(hr))
                ErrorTrace(1, "pxp->Run(-1) failed.  Err 0x%08x", hr);
            break;
        }
    }
    if (FAILED(hr))
        goto done;

    // woohoo!  we're done, so lets save everything off (remembering to free
    //  up anything we previously had, of course).  Since the root node we 
    //  passed in earlier isn't actually a real node in the tree.  It's just
    //  a placeholder used to hold onto the real root.  So we need to fetch the 
    //  real root out here...
    if (m_ppfxmlRoot != NULL)
        m_ppfxmlRoot->Release();

    // there should only be one child node of this if the XML was well formed.
    TESTHR(hr, ppfxmlNode->get_Child(0, &ppfxmlRoot));
    if (FAILED(hr))
        goto done;

    // don't need to addref cuz get_Child does that before handing it to us...
    m_ppfxmlRoot = ppfxmlRoot;
    ppfxmlRoot   = NULL;

done:
    if (ppfxmlRoot != NULL)
        ppfxmlRoot->Release();
    if (ppfxmlNode != NULL)
        ppfxmlNode->Release();
    if (pxp != NULL)
        pxp->Release();
    if (pnf != NULL)
        pnf->Release();
    if (ppfnf != NULL)
        ppfnf->Release();

    return hr;
}


// ***************************************************************************
HRESULT CPFXMLDocument::ParseFile(LPWSTR wszFile)
{
    USE_TRACING("CPFXMLDocument::ParseFile");

    HRESULT hr = NOERROR;
    LPVOID  pvFile = NULL;
    DWORD   cbFile;
    
    VALIDATEPARM(hr, (wszFile == NULL));
    if (FAILED(hr))
        goto done;

    TESTHR(hr, OpenFileMapped(wszFile, &pvFile, &cbFile));
    if (FAILED(hr))
        goto done;

    TESTHR(hr, this->ParseBlob((PBYTE)pvFile, cbFile));
    if (FAILED(hr))
        goto done;

done:
    if (pvFile != NULL)
        UnmapViewOfFile(pvFile);

    return hr;
}

// ***************************************************************************
HRESULT CPFXMLDocument::ParseBlob(BYTE *pbBlob, DWORD cbBlob)
{
    USE_TRACING("CPFXMLDocument::ParseFile");

    CPFXMLNodeFactory   *ppfnf = NULL;
    IXMLNodeFactory     *pnf = NULL;
    IXMLParser          *pxp = NULL;
    CPFXMLNode          *ppfxmlRoot = NULL, *ppfxmlNode = NULL;
    HRESULT             hr = NOERROR;
    WCHAR               wch = 0xfeff;
    
    VALIDATEPARM(hr, (pbBlob == NULL || cbBlob == 0));
    if (FAILED(hr))
        goto done;

    ppfnf = CPFXMLNodeFactory::CreateInstance();
    VALIDATEEXPR(hr, (ppfnf == NULL), E_OUTOFMEMORY);
    if (FAILED(hr))
        goto done;

    ppfnf->AddRef();
    TESTHR(hr, ppfnf->Init(&ppfxmlNode));
    if (FAILED(hr))
        goto done;

    TESTHR(hr, ppfnf->QueryInterface(IID_IXMLNodeFactory, (LPVOID *)&pnf));
    if (FAILED(hr))
        goto done;
    
    
    TESTHR(hr, CoCreateInstance(CLSID_XMLParser, NULL, CLSCTX_INPROC_SERVER, 
                                IID_IXMLParser, (void**)&pxp));
    if (FAILED(hr))
        goto done;

    TESTHR(hr, pxp->SetFlags(XMLFLAG_CASEINSENSITIVE | XMLFLAG_NOWHITESPACE));
    if (FAILED(hr))
        goto done;

    TESTHR(hr, pxp->SetFactory(pnf));
    if (FAILED(hr))
        goto done;

    // now push the actual XML in...
    TESTHR(hr, pxp->PushData((const char *)pbBlob, cbBlob, TRUE));
    if (FAILED(hr))
        goto done;

    TESTHR(hr, pxp->Run(-1));
    if (FAILED(hr))
        goto done;

    // woohoo!  we're done, so lets save everything off (remembering to free
    //  up anything we previously had, of course).  Since the root node we 
    //  passed in earlier isn't actually a real node in the tree (It's just
    //  a placeholder used to hold onto the real root), we need to fetch the 
    //  real root out here...
    if (m_ppfxmlRoot != NULL)
        m_ppfxmlRoot->Release();

    // there should only be one child node of this if the XML was well formed.
    //  And the parser would've errored if it was not well formed...
    TESTHR(hr, ppfxmlNode->get_Child(0, &ppfxmlRoot));
    if (FAILED(hr))
        goto done;

    // don't need to addref cuz get_Child does that before handing it to us...
    m_ppfxmlRoot = ppfxmlRoot;
    ppfxmlRoot   = NULL;

done:
    if (ppfxmlRoot != NULL)
        ppfxmlRoot->Release();
    if (ppfxmlNode != NULL)
        ppfxmlNode->Release();
    if (pxp != NULL)
        pxp->Release();
    if (pnf != NULL)
        pnf->Release();
    if (ppfnf != NULL)
        ppfnf->Release();

    return hr;
}

// ***************************************************************************
HRESULT CPFXMLDocument::WriteFile(LPWSTR wszFile)
{
    USE_TRACING("CPFXMLDocument::WriteFile");

    HRESULT hr = NOERROR;
    HANDLE  hFile = INVALID_HANDLE_VALUE;
    DWORD   cbWritten;
    WCHAR   wch = 0xfeff;


    VALIDATEPARM(hr, (wszFile == NULL));
    if (FAILED(hr))
        goto done;

    VALIDATEEXPR(hr, (m_ppfxmlRoot == NULL), E_FAIL);
    if (FAILED(hr))
        goto done;

    // create a file mapping that we can hand to the parser
    hFile = CreateFileW(wszFile, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
    TESTBOOL(hr, (hFile != INVALID_HANDLE_VALUE));
    if (FAILED(hr))
        goto done;

    // write out the stuff that marks it as a unicode file
    TESTBOOL(hr, ::WriteFile(hFile, &wch, sizeof(wch), &cbWritten, NULL));
    if (FAILED(hr))
        goto done;

    // write out the XML header
    TESTBOOL(hr, ::WriteFile(hFile, g_wszEncoding, 
                             sizeof(g_wszEncoding) - sizeof(WCHAR), &cbWritten, 
                             NULL));
    if (FAILED(hr))
        goto done;

    TESTHR(hr, m_ppfxmlRoot->Write(hFile));
    if (FAILED(hr))
        goto done;

done:
    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
//*************************************************************************//
/////////////////////////////////////////////////////////////////////////////

// ***************************************************************************
HRESULT WriteEncoded(HANDLE hFile, LPWSTR wszData)
{
    USE_TRACING("WriteEncoded");

    HRESULT hr = NOERROR;

    // if the order / size of this array is changed, be sure to change the 
    //  lengths & indexes below in the switch statement
    WCHAR   *rgwsz[5] = { L"&amp;", L"&lt;", L"&gt;", L"&apos;", L"&quot;" };
    WCHAR   *pwszStart, *pwsz;
    DWORD   cchToWrite, cbWritten;


    VALIDATEPARM(hr, (hFile == NULL || hFile == INVALID_HANDLE_VALUE));
    if (FAILED(hr))
        goto done;

    if (wszData == NULL)
    {
        hr = NOERROR;
        goto done;
    }

    pwszStart  = pwsz = wszData;
    cchToWrite = 0;
    for(;;)
    {
        // loop thru until we find a 'bad' character
        while(*pwsz != L'&' && *pwsz != L'<' && *pwsz != L'>' && 
              *pwsz != L'\'' && *pwsz != L'\"' && *pwsz != L'\0')
        {
            cchToWrite++;
            pwsz++;
        }

        // write out the stuff we've accumulated so far
        if (cchToWrite > 0)
        {
            TESTBOOL(hr, WriteFile(hFile, pwszStart, 
                                   cchToWrite * sizeof(WCHAR), &cbWritten,
                                   NULL));
            if (FAILED(hr))
                goto done;
        }

        // determine the escape sequence we want to write out- if we hit the
        //  NULL terminator, we're done.  
        // Note: the string lengths assigned here are hand calculated from  
        //  rgwsz (defined above). 
        switch(*pwsz)
        {
            case L'&':  pwszStart = rgwsz[0]; cchToWrite = 5; break;
            case L'<':  pwszStart = rgwsz[1]; cchToWrite = 4; break;
            case L'>':  pwszStart = rgwsz[2]; cchToWrite = 4; break;
            case L'\'': pwszStart = rgwsz[3]; cchToWrite = 6; break;
            case L'\"': pwszStart = rgwsz[4]; cchToWrite = 6; break;

            default:
            case L'\0': 
                goto done;
        }

        // write the escape sequence
        TESTBOOL(hr, WriteFile(hFile, pwszStart, 
                               cchToWrite * sizeof(WCHAR), &cbWritten,
                               NULL));
        if (FAILED(hr))
            goto done;

        // set the pointer to one after the 'bad' character
        pwsz++;
        pwszStart  = pwsz;
        cchToWrite = 0;
    }

done:
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CPFXMLNode construction

// ***************************************************************************
CPFXMLNode::CPFXMLNode(DWORD cRef)
{
    m_cRef  = cRef;
    m_xmlnt = xmlntUnknown;
}

// ***************************************************************************
CPFXMLNode::~CPFXMLNode(void)
{
    this->Cleanup();
}


/////////////////////////////////////////////////////////////////////////////
// CPFXMLNode internal methods

// ***************************************************************************
void CPFXMLNode::Cleanup(void)
{
    USE_TRACING("CPFXMLNode::Cleanup");
    
    m_xmlnt = xmlntUnknown;
    m_rgAttr.RemoveAll();
    m_rgChildren.RemoveAll();
    m_bstrTagData.Empty();
}

// ***************************************************************************
HRESULT CPFXMLNode::Write(HANDLE hFile)
{
    USE_TRACING("CPFXMLNode::Write");

    HRESULT         hr = NOERROR;
    DWORD           cbWritten, cbToWrite;
    BOOL            fWriteCR = TRUE;

    VALIDATEPARM(hr, (hFile == INVALID_HANDLE_VALUE || hFile == NULL));
    if (FAILED(hr))
        goto done;

    VALIDATEEXPR(hr, (m_bstrTagData.m_str == NULL), E_FAIL);
    if (FAILED(hr))
        goto done;

    // write out an element node
    if (m_xmlnt == xmlntElement)
    {
        SPFXMLNodeAttr  *ppfxmlna;
        CPFXMLNode      *ppfxmln;
        WCHAR           wsz[1024];
        DWORD           i;

        // write out the tag name
        wcscpy(wsz, L"\r\n<");
        wcscat(wsz, m_bstrTagData.m_str);
        TESTBOOL(hr, WriteFile(hFile, wsz, wcslen(wsz) * sizeof(WCHAR), 
                               &cbWritten, NULL));
        if (FAILED(hr))
            goto done;

        // write out attributes
        for (i = 0; i < m_rgAttr.get_Highest() + 1; i++)
        {
            // we do NOT want to free the class we get back from this cuz it's
            //  still held by the array.
            TESTHR(hr, m_rgAttr.get_Item(i, (LPVOID *)&ppfxmlna));
            if (FAILED(hr))
                continue;

            if (ppfxmlna == NULL || ppfxmlna->pwszName == NULL || 
                ppfxmlna->pwszValue == NULL)
                continue;
                
            // Ok, assume everything is going to fit into 1024 characters.  If
            //  it doesn't, skip the attribute
            cbToWrite = (wcslen(ppfxmlna->pwszName) + 3) * sizeof(WCHAR);
            if (cbToWrite >= 1024)
                continue;

            // yeah, this isn't the most efficient way of doing this, but it's
            //  supposedly better than sprintf according to the 'faster' alias
            wcscpy(wsz, L" ");
            wcscat(wsz, ppfxmlna->pwszName);
            wcscat(wsz, L"=\"");
            TESTBOOL(hr, WriteFile(hFile, wsz, cbToWrite, &cbWritten, NULL));
            if (FAILED(hr))
                goto done;

            TESTHR(hr, WriteEncoded(hFile, ppfxmlna->pwszValue));
            if (FAILED(hr))
                goto done;

            wsz[0] = L'\"';
            TESTBOOL(hr, WriteFile(hFile, wsz, sizeof(WCHAR), &cbWritten, NULL));
            if (FAILED(hr))
                goto done;
        }

        // close off the tag (and end if there are no children)
        if (m_rgChildren.get_Highest() == (DWORD)-1)
            wcscpy(wsz, L" />");
        else
            wcscpy(wsz, L">");
        TESTBOOL(hr, WriteFile(hFile, wsz, wcslen(wsz) * sizeof(WCHAR), 
                               &cbWritten, NULL));
        if (FAILED(hr))
            goto done;

        // write out the kids
        for (i = 0; i < m_rgChildren.get_Highest() + 1; i++)
        {
            // we do NOT want to free the class we get back from this cuz 
            //  it's still held by the array.
            TESTHR(hr, m_rgChildren.get_Item(i, (LPVOID *)&ppfxmln));
            if (FAILED(hr))
                goto done;

            if (ppfxmln == NULL)
                continue;

            if (ppfxmln->m_xmlnt == xmlntText &&
                m_rgChildren.get_Highest() == 0)
                fWriteCR = FALSE;

            TESTHR(hr, ppfxmln->Write(hFile));
            if (FAILED(hr))
                goto done;
        }

        // if we had kids, then we need to write out the closing tag...
        if (m_rgChildren.get_Highest() != (DWORD)-1)
        {
            if (fWriteCR)
                wcscpy(wsz, L"\r\n</");
            else
                wcscpy(wsz, L"</");
            wcscat(wsz, m_bstrTagData.m_str);
            wcscat(wsz, L">");
            TESTBOOL(hr, WriteFile(hFile, wsz, wcslen(wsz) * sizeof(WCHAR), 
                                   &cbWritten, NULL));
            if (FAILED(hr))
                goto done;
        }
    }

    // write out an text node
    else if (m_xmlnt == xmlntText)
    {
        TESTHR(hr, WriteEncoded(hFile, m_bstrTagData.m_str));
        if (FAILED(hr))
            goto done;
    }

    // um, it's neither.  Don't fail, but toss out something to the trace log
    else
    {
        _ASSERT(FALSE);
        DebugTrace(0, "Encountered a non element & non text node");
        hr = NOERROR;
    }

done:
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CPFXMLNode methods

// ***************************************************************************
DWORD CPFXMLNode::AddRef(void)
{
    USE_TRACING("CPFXMLNode::AddRef");
    
    m_cRef++;
    return m_cRef;
}

// ***************************************************************************
DWORD CPFXMLNode::Release(void)
{
    USE_TRACING("CPFXMLNode::Release");

    m_cRef--;
    if (m_cRef == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

// ***************************************************************************
CPFXMLNode *CPFXMLNode::CreateInstance(void)
{
    USE_TRACING("CPFXMLNode::CreateInstance");

    CPFXMLNode  *ppfxml = NULL;
    HRESULT     hr = NOERROR;

    ppfxml = new CPFXMLNode(1);
    if (ppfxml == NULL)
        goto done;

    TESTHR(hr, ppfxml->m_rgAttr.Init(8));
    if (FAILED(hr))
        goto done;

    TESTHR(hr, ppfxml->m_rgChildren.Init(16));
    if (FAILED(hr))
        goto done;
done:
    if (FAILED(hr))
    {
        delete ppfxml;
        ppfxml = NULL;
    }

    return ppfxml;
}

// ***************************************************************************
HRESULT CPFXMLNode::get_Data(BSTR *pbstrData)
{
    USE_TRACING("CPFXMLNode::get_Data");

    HRESULT hr = NOERROR;

    VALIDATEPARM(hr, (pbstrData == NULL));
    if (FAILED(hr))
        goto done;

    *pbstrData = m_bstrTagData.Copy();
    VALIDATEEXPR(hr, (*pbstrData == NULL && m_bstrTagData.m_str != NULL), 
                 E_OUTOFMEMORY);
    if (FAILED(hr))
        goto done;

done:
    return hr;
}

// ***************************************************************************
HRESULT CPFXMLNode::put_Data(LPCWSTR wszData, DWORD cch)
{
    USE_TRACING("CPFXMLNode::put_Data");

    HRESULT hr = NOERROR;

    // does he want us to delete the current contents? 
    if (wszData == NULL || cch == 0)
    {
        m_bstrTagData.Empty();
    }

    // do we have a null terminated string passed to us? 
    else if (cch == (DWORD)-1)
    {
        m_bstrTagData.Empty();
        TESTHR(hr, m_bstrTagData.Append(wszData));
        if (FAILED(hr))
            goto done;
    }

    // we just got a blob of WCHARs + length
    else
    {
        m_bstrTagData.Empty();
        TESTHR(hr, m_bstrTagData.Append(wszData, cch));
        if (FAILED(hr))
            goto done;
    }

done:
    return hr;
}

// ***************************************************************************
HRESULT CPFXMLNode::append_Data(LPCWSTR wszData, DWORD cch)

{
    USE_TRACING("CPFXMLNode::append_Data");

    HRESULT hr = NOERROR;

    VALIDATEPARM(hr, (wszData == NULL || cch == 0));
    if (FAILED(hr))
        goto done;

    // do we have a null terminated string passed to us? 
    if (cch == (DWORD)-1)
    {
        TESTHR(hr, m_bstrTagData.Append(wszData));
        if (FAILED(hr))
            goto done;
    }

    // we just got a blob of WCHARs + length
    else
    {
        TESTHR(hr, m_bstrTagData.Append(wszData, cch));
        if (FAILED(hr))
            goto done;
    }

done:
    return hr;
}

// ***************************************************************************
HRESULT CPFXMLNode::add_Attribute(LPCWSTR wszName, LPCWSTR wszVal,
                                  DWORD cchName, DWORD cchVal)
{
    USE_TRACING("CPFXMLNode::add_Attribute");

    SPFXMLNodeAttr  *ppfxmlna = NULL;
    HRESULT         hr = NOERROR;
    DWORD           cbNode;
    WCHAR           *pwszName;

    VALIDATEPARM(hr, (wszName == NULL || cchName == 0));
    if (FAILED(hr))
        goto done;

    if (cchName == (DWORD)-1)
        cchName = wcslen(wszName);

    if (wszVal == NULL)
        cchVal = 0;
    else if (cchVal == (DWORD)-1)
        cchVal = wcslen(wszVal);

    // be perf concious & allocate the whole shebang in one blob
    cbNode = sizeof(SPFXMLNodeAttr) + (cchVal + cchName + 3) * sizeof(WCHAR);

    // alloc a new class to hold the attr
    ppfxmlna = (SPFXMLNodeAttr *)MyAlloc(cbNode, g_hPFPrivateHeap);
    VALIDATEEXPR(hr, (ppfxmlna == NULL), E_OUTOFMEMORY);
    if (FAILED(hr))
        goto done;

    // set up the node pointers
    ppfxmlna->pwszName  = (LPWSTR)((PBYTE)ppfxmlna + sizeof(SPFXMLNodeAttr));
    ppfxmlna->pwszValue = (LPWSTR)((PBYTE)ppfxmlna->pwszName + (cchName + 1) * sizeof(WCHAR));

    wcsncpy(ppfxmlna->pwszName, wszName, cchName);
    ppfxmlna->pwszName[cchName] = L'\0';

    if (wszVal != NULL)
        wcsncpy(ppfxmlna->pwszValue, wszVal, cchVal);
    ppfxmlna->pwszValue[cchVal] = L'\0';

    // add it 
    TESTHR(hr, m_rgAttr.Append(ppfxmlna));
    if (FAILED(hr))
        goto done;

    // since we save the class in Append, we definitely don't want to free
    //  it later on...
    ppfxmlna = NULL;

done:
    if (ppfxmlna != NULL)
        MyFree(ppfxmlna, g_hPFPrivateHeap);

    return hr;
}

// ***************************************************************************
HRESULT CPFXMLNode::get_Attribute(LPCWSTR wszName, BSTR *pbstrVal)
    
{
    USE_TRACING("CPFXMLNode::get_Attribute");

    SPFXMLNodeAttr  *ppfxmlna;
    HRESULT         hr = NOERROR;
    DWORD           i;

    VALIDATEPARM(hr, (wszName == NULL || pbstrVal == 0));
    if (FAILED(hr))
        goto done;

    *pbstrVal = NULL;

    // assume we won't find it...
    hr = S_FALSE;

    // but go ahead and try to find it anyway... :-)
    for (i = 0; i < m_rgAttr.get_Highest() + 1; i++)
    {
        // we do NOT want to free the class we get back from this cuz it's
        //  still held by the array.
        TESTHR(hr, m_rgAttr.get_Item(i, (LPVOID *)&ppfxmlna));
        if (FAILED(hr))
            goto done;

        if (ppfxmlna != NULL &&
            _wcsicmp(ppfxmlna->pwszName, wszName) == 0)
        {
            *pbstrVal = SysAllocString(ppfxmlna->pwszValue);

            // this will set hr to NOERROR if it succeeds.
            VALIDATEEXPR(hr, (*pbstrVal == NULL), E_OUTOFMEMORY);
            if (FAILED(hr))
                goto done;

            break;
        }
    }

done:
    return hr;
}

// ***************************************************************************
HRESULT CPFXMLNode::get_Attribute(DWORD iAttr, BSTR *pbstrVal)
{
    USE_TRACING("CPFXMLNode::get_Attribute");

    SPFXMLNodeAttr  *ppfxmlna;
    HRESULT         hr = NOERROR;
    DWORD           i;

    VALIDATEPARM(hr, (pbstrVal == 0));
    if (FAILED(hr))
        goto done;

    VALIDATEEXPR(hr, (iAttr >= m_rgAttr.get_Highest() + 1), 
                 Err2HR(RPC_S_INVALID_BOUND));
    if (FAILED(hr))
        goto done;

    *pbstrVal = NULL;

    // we do NOT want to free the class we get back from this cuz it's
    //  still held by the array.
    TESTHR(hr, m_rgAttr.get_Item(iAttr, (LPVOID *)&ppfxmlna));
    if (FAILED(hr))
        goto done;

    *pbstrVal = SysAllocString(ppfxmlna->pwszValue);
    VALIDATEEXPR(hr, (*pbstrVal == NULL), E_OUTOFMEMORY);
    if (FAILED(hr))
        goto done;

done:
    return hr;
}

// ***************************************************************************
HRESULT CPFXMLNode::append_Child(CPFXMLNode *ppfxml)
{
    USE_TRACING("CPFXMLNode::append_Child");

    HRESULT hr = NOERROR;

    VALIDATEPARM(hr, (ppfxml == NULL));
    if (FAILED(hr))
        goto done;

    // gotta addref here cuz the dyn array is dumb and just expects us to pass
    //  it a LPVOID
    ppfxml->AddRef();
    TESTHR(hr, m_rgChildren.Append(ppfxml));
    if (FAILED(hr))
    {
        // if it failed, the map isn't holding it, so release the addref we
        //  just did
        ppfxml->Release();
        goto done;
    }

done:
    return hr;
}

// ***************************************************************************
HRESULT CPFXMLNode::append_Children(CPFArrayUnknown &rgNodes)
{
    USE_TRACING("CPFXMLNode::append_Child");

    CPFXMLNode  *ppfxml = NULL;
    HRESULT     hr = NOERROR;
    DWORD       i;

    for (i = 0; i < rgNodes.get_Highest() + 1; i++)
    {
        TESTHR(hr, rgNodes.get_Item(i, (LPVOID *)&ppfxml));
        if (FAILED(hr))
            goto done;

        if (ppfxml == NULL)
            continue;

        // gotta addref here cuz the dyn array is dumb and just expects us to
        //  pass it a LPVOID
        ppfxml->AddRef();
        TESTHR(hr, m_rgChildren.Append(ppfxml));
        if (FAILED(hr))
        {
            // if it failed, the map isn't holding it, so release the addref we
            //  just did
            ppfxml->Release();
            goto done;
        }
    }

done:
    return hr;
}


// ***************************************************************************
HRESULT CPFXMLNode::get_Child(DWORD iChild, CPFXMLNode **pppfxml)
{
    USE_TRACING("CPFXMLNode::get_Child");

    CPFXMLNode  *ppfxml = NULL;
    HRESULT     hr = NOERROR;

    VALIDATEPARM(hr, (pppfxml == NULL));
    if (FAILED(hr))
        goto done;

    *pppfxml = NULL;

    VALIDATEEXPR(hr, (iChild >= m_rgChildren.get_Highest() + 1), 
                 Err2HR(RPC_S_INVALID_BOUND));
    if (FAILED(hr))
        goto done;

    
    TESTHR(hr, m_rgChildren.get_Item(iChild, (LPVOID *)&ppfxml));
    if (FAILED(hr))
        goto done;

    if (ppfxml != NULL)
    {
        ppfxml->AddRef();
        *pppfxml = ppfxml;
        ppfxml   = NULL;
    }

    else
    {
        hr = S_FALSE;
    }

done:
    // don't want to call release on ppfxml cuz the array is still holding it
    return hr;
}

// ***************************************************************************
HRESULT CPFXMLNode::get_MatchingChildElements(LPCWSTR wszTag, 
                                              CPFArrayUnknown &rgNodes)
{
    USE_TRACING("CPFXMLNode::get_ChildList");

    CPFXMLNode  *ppfxml = NULL;
    HRESULT     hr = NOERROR;
    DWORD       i;

    VALIDATEPARM(hr, (wszTag == NULL));
    if (FAILED(hr))
        goto done;

    // reset the dyn array
    rgNodes.RemoveAll();

    for(i = 0; i < m_rgChildren.get_Highest() + 1; i++)
    {
        TESTHR(hr, m_rgChildren.get_Item(i, (LPVOID *)&ppfxml));
        if (FAILED(hr))
            goto done;

        // look for elements with tags equal to what was passed in.  Since 
        //  we're also inside a CPFXMLNode, we can peek directly into the 
        //  class (cheating is cool)...
        if (ppfxml != NULL && ppfxml->m_xmlnt == xmlntElement && 
            _wcsicmp(wszTag, ppfxml->m_bstrTagData.m_str) == 0)
        {
            // gotta addref here cuz the dyn array is dumb and just expects us
            //  to pass it a LPVOID
            ppfxml->AddRef();
            TESTHR(hr, rgNodes.Append(ppfxml));
            if (FAILED(hr))
            {
                // if it failed, the map isn't holding it, so release the 
                //  addref we just did
                ppfxml->Release();
                goto done;
            }
        }
    }

done:
    return hr;
}

// ***************************************************************************
HRESULT CPFXMLNode::get_ChildText(BSTR *pbstrText)
{
    USE_TRACING("CPFXMLNode::get_ChildText");

    CPFXMLNode  *ppfxml;
    CComBSTR    bstr;
    HRESULT     hr = NOERROR;

    VALIDATEPARM(hr, (pbstrText == NULL));
    if (FAILED(hr))
        goto done;

    *pbstrText = NULL;

	if (m_rgChildren.get_Highest() + 1 == 0)
		goto done;

    // do NOT release this object as the array still has a hold of it
    TESTHR(hr, m_rgChildren.get_Item(0, (LPVOID *)&ppfxml));
    if (FAILED(hr))
        goto done;

    if (ppfxml->m_bstrTagData.m_str == NULL)
        goto done;

    TESTHR(hr, bstr.Append(ppfxml->m_bstrTagData));
    if (FAILED(hr))
        goto done;

    *pbstrText = bstr.Detach();

done:
    return hr;
}


// ***************************************************************************
HRESULT CPFXMLNode::DeleteAllChildren(void)
{
    USE_TRACING("CPFXMLNode::DeleteAllChildren");

    return m_rgChildren.RemoveAll();
}

// ***************************************************************************
HRESULT CPFXMLNode::CloneNode(CPFXMLNode **pppfxml, BOOL fWantChildren)
{
    USE_TRACING("CPFXMLNode::CloneNode");

    CPFXMLNode  *ppfxml = NULL;
    HRESULT     hr = NOERROR;

    VALIDATEPARM(hr, (pppfxml == NULL));
    if (FAILED(hr))
        goto done;

    *pppfxml = NULL;

    ppfxml = CPFXMLNode::CreateInstance();
    VALIDATEEXPR(hr, (ppfxml == NULL), E_OUTOFMEMORY);
    if (FAILED(hr))
        goto done;

    if (m_bstrTagData.m_str != NULL)
    {
        TESTHR(hr, ppfxml->m_bstrTagData.Append(m_bstrTagData.m_str));
        if (FAILED(hr))
            goto done;
    }

    ppfxml->m_xmlnt = m_xmlnt;
    
    TESTHR(hr, ppfxml->m_rgAttr.CopyFrom(&m_rgAttr));
    if (FAILED(hr))
        goto done;

    if (fWantChildren)
    {
        TESTHR(hr, ppfxml->m_rgChildren.CopyFrom(&m_rgChildren));
        if (FAILED(hr))
            goto done;
    }

    *pppfxml = ppfxml;
    ppfxml = NULL;

done:
    if (ppfxml != NULL)
        ppfxml->Release();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\common\pfcommon\stdafx.h ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    stdafx.h

Abstract:
    DPE common PCH

Revision History:
    DerekM  created  05/01/99

********************************************************************/

// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__F6D93C3Q_DF3F_11D2_80AF_00C04F688C0B__INCLUDED_)
#define AFX_STDAFX_H__F6D93C3Q_DF3F_11D2_80AF_00C04F688C0B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


#include <atlbase.h>
#include "dbgtrace.h"


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__F6D93C3Q_DF3F_11D2_80AF_00C04F688C0B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\common\pftn\stdafx.h ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    stdafx.h

Abstract:
    DPE common PCH

Revision History:
    DerekM  created  05/01/99

********************************************************************/

// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__F6D93C3Q_DF3F_11D2_80AF_00C04F688C0B__INCLUDED_)
#define AFX_STDAFX_H__F6D93C3Q_DF3F_11D2_80AF_00C04F688C0B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


#include <atlbase.h>
#include "dbgtrace.h"


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__F6D93C3Q_DF3F_11D2_80AF_00C04F688C0B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\common\pfcommon\weblog.cpp ===
/********************************************************************

Copyright (c) 1996-2000 Microsoft Corporation

Module Name:
    weblog.cpp

Abstract:
    Defines a generic class that can be used to log
    info from ISAPIs. This class allows its user to
    create application specific logfiles and
    automatically uses an intermediate file to log info and
    creates permanent log files at predefined intervals
    or after predefined number of records have been
    written to the intermediate file. 

Revision History:
    rsraghav  created   03/25/96
    DerekM    modified  04/06/99
    DerekM    modifued  02/24/00

********************************************************************/

#include "stdafx.h"
#include "weblog.h"
#include "util.h"
#include "wchar.h"

/////////////////////////////////////////////////////////////////////////////
// CWeblog- initialization stuff

// **************************************************************************
CWeblog::CWeblog(void)
{
    InitializeCriticalSection(&m_cs);
    m_fInit              = FALSE;

    m_cMaxRecords        = c_dwMaxRecordsDefault;
    m_dwDumpInterval     = c_dwDumpIntervalDefault;
    
    m_liDumpIntervalAsFT = c_dwDumpIntervalDefault;
    m_liDumpIntervalAsFT *= c_dwMinToMS;
    m_liDumpIntervalAsFT *= c_dwFTtoMS;

    m_szAppName[0]       = L'\0';
    m_szFileName[0]      = L'\0';
    m_szFilePath[0]      = L'\0';

    ZeroMemory(&m_ftLastDump, sizeof(m_ftLastDump));
    m_cRecords           = 0;
    m_hFile              = INVALID_HANDLE_VALUE;
}

// **************************************************************************
CWeblog::~CWeblog()
{
    if (m_hFile != INVALID_HANDLE_VALUE)
        CloseHandle(m_hFile);

    DeleteCriticalSection(&m_cs);
}

/////////////////////////////////////////////////////////////////////////////
// CWeblog- internal stuff

// **************************************************************************
HRESULT CWeblog::InitFromRegistry()
{
    USE_TRACING("CWeblog::InitFromRegistry");

    SAppLogInfoExtra    alie;
    SAppLogInfo         ali;
    HRESULT             hr;

    // read the ALI & ALIE structures 
    TESTHR(hr, ReadALI(m_szAppName, &ali, &alie));
    if (FAILED(hr))
        goto done;

    CopyMemory(&m_ftLastDump, &alie.ftLastDump, sizeof(m_ftLastDump));
    lstrcpyW(m_szFileName, ali.wszLogPath);
    lstrcpyW(m_szFilePath, ali.wszLogPath);
    m_cMaxRecords        = ali.cMaxTempRecs;
    m_cRecords           = alie.cCurTempRecs;
    m_dwDumpInterval     = ali.cDumpMins;
    m_liDumpIntervalAsFT = m_dwDumpInterval;
    m_liDumpIntervalAsFT *= c_dwMinToMS;
    m_liDumpIntervalAsFT *= c_dwFTtoMS;
    
done:
    return hr;
}

// **************************************************************************
BOOL CWeblog::IsDumpRequired() 
{ 
    USE_TRACING("CWeblog::IsDumpRequired");

    SYSTEMTIME  stNow;
    FILETIME    ftNow;

    // check if we've gone over our allotted amount of records  
    if ((m_cMaxRecords > 0) && (m_cRecords >= m_cMaxRecords)) 
        return TRUE;

    // ok, so now check if we've gone over our allotted time range.
    // if we fail to convert the system time, do a dump to be on the safe side...
    GetLocalTime(&stNow);
    if (SystemTimeToFileTime(&stNow, &ftNow) == FALSE)
        return TRUE;

    if (((*(unsigned __int64 *)&ftNow) - 
         (*(unsigned __int64 *)&m_ftLastDump)) > m_liDumpIntervalAsFT)
        return TRUE;

    return FALSE;
}

// **************************************************************************
HRESULT CWeblog::DumpLog()
{
    USE_TRACING("CWeblog::DumpLog");

    SYSTEMTIME  st;
    HRESULT     hr = NOERROR;
    DWORD       dwRet; 
    WCHAR       *pszStart = NULL;
    WCHAR       szNewName[MAX_PATH + 1];
    int         nUsed;
    
    this->Lock();

        // Close handle to the intermediate file
        CloseHandle(m_hFile);
        
        // intialize new internal stuff...
        m_hFile = INVALID_HANDLE_VALUE;
        m_cRecords = 0;     
        
        // Rename the intermediate file to be permanent logfile with 
        //  appropriate name       
        nUsed = wsprintfW(szNewName, L"%ls%ls", m_szFilePath, m_szAppName);
        
        if ((nUsed + c_cMaxTimeSuffixLen) > MAX_PATH)
        {
            // the file name is too long - truncate it
            szNewName[MAX_PATH - c_cMaxTimeSuffixLen - 1] = L'\0';
            nUsed = lstrlenW(szNewName);
        }

        // update last dump time stamp 
        GetLocalTime(&st);
        SystemTimeToFileTime(&st, &m_ftLastDump);

        // create the rest of the filename...       
        pszStart = &szNewName[nUsed];
        wsprintfW(pszStart, L"%04d%02d%02d%02d%02d%02d%ls", st.wYear, st.wMonth, 
                  st.wDay, st.wHour, st.wMinute, st.wSecond, 
                  c_szPermLogfileSuffix);

        // move the file (duh.)
        MoveFileExW(m_szFileName, szNewName, 
                    MOVEFILE_COPY_ALLOWED | MOVEFILE_WRITE_THROUGH);

        // recreate the intermediate file and get a handle to it
        m_hFile = CreateFileW(m_szFileName, GENERIC_WRITE, FILE_SHARE_READ, 
                              NULL, OPEN_ALWAYS, FILE_FLAG_SEQUENTIAL_SCAN, 
                              NULL);
        if (m_hFile == INVALID_HANDLE_VALUE)
            hr = Err2HR(GetLastError());
        else
            SetFilePointer(m_hFile, 0, NULL, FILE_END);
        
    this->Unlock();
        
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CWeblog- exposed methods

// **************************************************************************
HRESULT CWeblog::InitLogging(LPCWSTR szAppName)
{
    USE_TRACING("CWeblog::InitLogging");

    HRESULT hr = NOERROR;
    int     nUsed;
    
    // only allow one init per lifetime of the object...
    VALIDATEEXPR(hr, (m_fInit), E_FAIL);
    if (FAILED(hr))
        goto done;

    // validate params
    VALIDATEPARM(hr, (szAppName == NULL));
    if (FAILED(hr))
        goto done;

    // copy in the app name, zero terminating in case app name is longer than we allow... 
    wcsncpy(m_szAppName, szAppName, c_cMaxAppNameLen);
    m_szAppName[c_cMaxAppNameLen] = L'\0';
        
    // Read in settings from Registry
    TESTHR(hr, InitFromRegistry());
    if (FAILED(hr))
        goto done;

    // m_szFileName contains the file path: append appname and suffix
    nUsed = lstrlenW(m_szFileName);
    VALIDATEEXPR(hr, ((nUsed + lstrlenW(m_szAppName) + 6) > MAX_PATH), E_FAIL);
    if (FAILED(hr))
        goto done;

    // Open the intermediate file and keep it ready for appending
    wsprintfW(m_szFileName + nUsed, L"%ls%ls", m_szAppName, c_szTempLogfileSuffix);
    m_hFile = CreateFileW(m_szFileName, GENERIC_WRITE, FILE_SHARE_READ, NULL, 
                          OPEN_ALWAYS, FILE_FLAG_SEQUENTIAL_SCAN, NULL);
    TESTBOOL(hr, (m_hFile != INVALID_HANDLE_VALUE))
    if (FAILED(hr))
        goto done;
        
    SetFilePointer(m_hFile, 0, NULL, FILE_END);

    m_fInit = TRUE;

done:
    return hr;
}

// **************************************************************************
HRESULT CWeblog::TerminateLogging(void)
{
    USE_TRACING("CWeblog::TerminateLogging");

    SAppLogInfoExtra    alie;
    HRESULT             hr = NOERROR;

    // bug out if the initialization didn't work smoothly...
    if (m_fInit == FALSE)
        goto done;

    lstrcpyW(alie.wszName, m_szAppName);
    CopyMemory(&alie.ftLastDump, &m_ftLastDump, sizeof(alie.ftLastDump));
    alie.cCurTempRecs = m_cRecords;

    TESTHR(hr, WriteALI(NULL, &alie));
    if (FAILED(hr))
        goto done;

    m_fInit              = FALSE;

    m_cMaxRecords        = c_dwMaxRecordsDefault;
    m_dwDumpInterval     = c_dwDumpIntervalDefault;
    
    m_liDumpIntervalAsFT = c_dwDumpIntervalDefault;
    m_liDumpIntervalAsFT *= c_dwMinToMS;
    m_liDumpIntervalAsFT *= c_dwFTtoMS;

    m_szAppName[0]       = L'\0';
    m_szFileName[0]      = L'\0';
    m_szFilePath[0]      = L'\0';

    ZeroMemory(&m_ftLastDump, sizeof(m_ftLastDump));
    m_cRecords           = 0;

done:
    return hr;
}


// **************************************************************************
HRESULT CWeblog::LogRecord(LPCWSTR szFormat, ... )
{
    USE_TRACING("CWeblog::LogRecord");

    SYSTEMTIME  st;
    va_list     arglist;
    HRESULT     hr = NOERROR;
    DWORD       dwUsed, nWritten, dwUsedA;
    WCHAR       szLogRecordW[c_cMaxRecLen + 1];
	CHAR		szLogRecordA[(2 * c_cMaxRecLen) + 1];
    int         nAdded;

    // only allow 'em in if they've called init...
    VALIDATEEXPR(hr, (m_fInit == FALSE), E_FAIL);
    if (FAILED(hr))
        goto done;

    // validate params
    VALIDATEPARM(hr, (szFormat == NULL));
    if (FAILED(hr))
        goto done;
    
    // prepend the app name and current time
    GetLocalTime(&st);

    dwUsed = (ULONG)wsprintfW(szLogRecordW, L"%ls,%04u/%02u/%02u %02u:%02u:%02u\n", 
                              m_szAppName, st.wYear, st.wMonth, st.wDay, 
                              st.wHour, st.wMinute, st.wSecond);

    va_start(arglist, szFormat);

    nAdded = _vsnwprintf(&szLogRecordW[dwUsed], c_cMaxRecLen - dwUsed, 
                         szFormat, arglist);

    // is the arglist too big for us?
    if (nAdded < 0)
    {
        // if so, just insert a dummy value
        lstrcpyW(&szLogRecordW[dwUsed], 
                 L"Logging Error: Record given for logging is too big!\r\n");
        dwUsed = lstrlenW(szLogRecordW);
    }
    else
    {
        // otherwise, add a CRLF to the end...
        dwUsed += (ULONG) nAdded;
        szLogRecordW[dwUsed++] = L'\r';
        szLogRecordW[dwUsed++] = L'\n';
        szLogRecordW[dwUsed] = L'\0';
    }

    va_end(arglist);

	// translate the record down into ASCII so the lab team can use grep &
	//  other such utilities on these files (which don't work with unicode
	//  text files)
	dwUsedA = WideCharToMultiByte(CP_ACP, 0, szLogRecordW, -1, szLogRecordA, 
                                  2 * c_cMaxRecLen, NULL, NULL);
    if (dwUsedA == 0)
    {
        dwUsedA = (ULONG)wsprintfA(szLogRecordA, "%ls,%04u/%02u/%02u %02u:%02u:%02u\n", 
                                   m_szAppName, st.wYear, st.wMonth, st.wDay, 
                                   st.wHour, st.wMinute, st.wSecond);
        lstrcpyA(&szLogRecordA[dwUsedA], "Logging Error: unable to translate log record to ASCII\r\n");
        dwUsedA = lstrlen(szLogRecordA);
    }
    
    else
    {
        // dwUsedA contains a character for the NULL terminator at the end of
        //  the ASCII string.  Since we don't want to write this to the log
        //  file, reduce the size of the log entry by 1 byte...
        dwUsedA--;
    }

    this->Lock();

        TESTBOOL(hr, (WriteFile(m_hFile, szLogRecordA, dwUsedA, &nWritten, 
                                NULL) == FALSE));
        if (FAILED(hr))
        {
            this->Unlock();
            goto done;
        }

        m_cRecords++;
        
        if (IsDumpRequired())
            TESTHR(hr, DumpLog());
        
    this->Unlock();

done:

    return hr;
}

//////////////////////////////////////////////////////////////////////
// CWeblogConfig initialization

// **************************************************************************
HRESULT ReadALI(LPCWSTR wszName, SAppLogInfo *pali, SAppLogInfoExtra *palie)
{
    USE_TRACING("CWeblog::ReadALI");

    HRESULT     hr = NOERROR;
    WCHAR       wszDef[MAX_PATH];
    DWORD       dw = 0, cb;
    HKEY        hKeyLog = NULL, hKeyRoot = NULL;
    BOOL        fWrite;

    VALIDATEPARM(hr, (wszName == NULL || pali == NULL));
    if (FAILED(hr))
        goto done;
        
    GetWindowsDirectoryW(wszDef, sizeof(wszDef) / sizeof(WCHAR));
    wszDef[3] = L'\0';

    TESTHR(hr, OpenRegKey(HKEY_LOCAL_MACHINE, c_szRPWeblogRootKey, FALSE,
                          &hKeyRoot));
    if (FAILED(hr))
        goto done;

    TESTHR(hr, OpenRegKey(hKeyRoot, wszName, FALSE, &hKeyLog));
    if (FAILED(hr))
        goto done;

    // max allowed temp records
    cb = sizeof(pali->cMaxTempRecs);
    TESTHR(hr, ReadRegEntry(hKeyLog, c_szRVMaxRecords, NULL,
                            (PBYTE)&pali->cMaxTempRecs, &cb,
                            (PBYTE)&c_dwMaxRecordsDefault, sizeof(DWORD))); 
    if (FAILED(hr))
        goto done;

    // dump interval
    cb = sizeof(pali->cDumpMins);
    TESTHR(hr, ReadRegEntry(hKeyLog, c_szRVDumpInterval, NULL,
                            (PBYTE)&pali->cDumpMins, &cb,
                            (PBYTE)&c_dwDumpIntervalDefault, sizeof(DWORD))); 
    if (FAILED(hr))
        goto done;

    // weblog path 
    cb = sizeof(pali->wszLogPath) * sizeof(WCHAR);
    TESTHR(hr, ReadRegEntry(hKeyLog, c_szRVLogFilePath, NULL,
                            (PBYTE)&pali->wszLogPath, &cb, (PBYTE)&wszDef,
                            (lstrlenW(wszDef) + 1) * sizeof(WCHAR)));
    if (FAILED(hr))
        goto done;

    lstrcpyW(pali->wszName, wszName);

    // make sure we have a '\' at the end of the file path...
    dw = lstrlenW(pali->wszLogPath);
    if (pali->wszLogPath[dw - 1] != L'\\')
    {
        pali->wszLogPath[dw] = L'\\';
        pali->wszLogPath[dw + 1] = L'\0';
    }

    // make sure we have valid values here... 
    if (pali->cDumpMins == 0)
        pali->cDumpMins = c_dwDumpIntervalDefault;
    if (pali->cMaxTempRecs == 0)
        pali->cMaxTempRecs = c_dwMaxRecordsDefault;


    // if this is NULL, we don't have to do anything more
    if (palie != NULL)
    {
        FILETIME    ftDef;

        // last dump time
        ZeroMemory(&ftDef, sizeof(FILETIME));
        cb = sizeof(palie->ftLastDump);
        TESTHR(hr, ReadRegEntry(hKeyLog, c_szRVLastDumpTime, NULL,
                                (PBYTE)&palie->ftLastDump, &cb, 
                                (PBYTE)&ftDef, sizeof(FILETIME)));
        if (FAILED(hr)) 
            goto done;

        // current temp records
        dw = 0;
        cb = sizeof(palie->cCurTempRecs);
        TESTHR(hr, ReadRegEntry(hKeyLog, c_szRVCurrentRecs, NULL, 
                                (PBYTE)&palie->cCurTempRecs, &cb, 
                                (PBYTE)&dw, sizeof(DWORD)));
        if (FAILED(hr)) 
            goto done;

        lstrcpyW(palie->wszName, wszName);
    }

done:
    if (hKeyLog != NULL)
        RegCloseKey(hKeyLog);
    if (hKeyRoot != NULL)
        RegCloseKey(hKeyRoot);

    return hr;
}

// **************************************************************************
HRESULT WriteALI(SAppLogInfo *pali, SAppLogInfoExtra *palie)
{
    USE_TRACING("CWeblog::WriteALI");

    HRESULT hr = NOERROR;
    LPWSTR  pwsz = NULL;
    DWORD   dwErr;
    HKEY    hKeyLog = NULL, hKeyRoot = NULL;
    BOOL    fWrite;

    if (pali != NULL)
        pwsz = pali->wszName;
    else if (palie != NULL)
        pwsz = palie->wszName;
    else
        goto done;

    TESTHR(hr, OpenRegKey(HKEY_LOCAL_MACHINE, c_szRPWeblogRootKey, TRUE,
                          &hKeyRoot));
    if (FAILED(hr))
        goto done;

    TESTHR(hr, OpenRegKey(hKeyRoot, pwsz, TRUE, &hKeyLog));
    if (FAILED(hr))
        goto done;

    if (pali != NULL)
    {
        DWORD dw;

        // make sure we have valid values here... 
        if (pali->cDumpMins == 0)
            pali->cDumpMins = c_dwDumpIntervalDefault;
        if (pali->cMaxTempRecs == 0)
            pali->cMaxTempRecs = c_dwMaxRecordsDefault;

        // make sure we have a '\' at the end of the file path...
        dw = lstrlenW(pali->wszLogPath);
        if (pali->wszLogPath[dw - 1] != L'\\')
        {
            pali->wszLogPath[dw] = L'\\';
            pali->wszLogPath[dw + 1] = L'\0';
        }

        // max temp records
        TESTERR(hr, RegSetValueExW(hKeyLog, c_szRVMaxRecords, 0, REG_DWORD, 
                                   (PBYTE)&pali->cMaxTempRecs, sizeof(DWORD)));
        if (FAILED(hr))
            goto done;

        // dump interval
        TESTERR(hr, RegSetValueExW(hKeyLog, c_szRVDumpInterval, 0, REG_DWORD, 
                                   (PBYTE)&pali->cDumpMins, sizeof(DWORD)));
        if (FAILED(hr))
            goto done;

        // weblog path 
        TESTERR(hr, RegSetValueExW(hKeyLog, c_szRVLogFilePath, 0, REG_SZ, 
                                   (PBYTE)&pali->wszLogPath, 
                                   (lstrlenW(pali->wszLogPath) + 1) * sizeof(WCHAR)));
        if (FAILED(hr))
            goto done;
    }

    // if this is NULL, we don't have to do anything more
    if (palie != NULL)
    {
        // last dump time
        TESTERR(hr, RegSetValueExW(hKeyLog, c_szRVLastDumpTime, 0, REG_BINARY, 
                                   (PBYTE)&palie->ftLastDump, sizeof(FILETIME)));
        if (FAILED(hr))
            goto done;

        // current temp records 
        TESTERR(hr, RegSetValueExW(hKeyLog, c_szRVCurrentRecs, 0, REG_DWORD, 
                                   (PBYTE)&palie->cCurTempRecs, sizeof(DWORD)));
        if (FAILED(hr))
            goto done;
    }

done:
    if (hKeyLog != NULL)
        RegCloseKey(hKeyLog);
    if (hKeyRoot != NULL)
        RegCloseKey(hKeyRoot);

    return hr;
}

// **************************************************************************
HRESULT DeleteALI(LPCWSTR wszName)
{
    USE_TRACING("CWeblog::DeleteALI");

    HRESULT hr = NOERROR;
    DWORD   dwErr;
    HKEY    hKeyRoot = NULL;
    BOOL    fWrite;
    
    TESTHR(hr, OpenRegKey(HKEY_LOCAL_MACHINE, c_szRPWeblogRootKey, TRUE,
                          &hKeyRoot));
    if (FAILED(hr))
        goto done;

    dwErr = RegDeleteKeyW(hKeyRoot, wszName);
    if (dwErr != ERROR_SUCCESS && dwErr != ERROR_PATH_NOT_FOUND &&
        dwErr != ERROR_FILE_NOT_FOUND)
    {
        hr = Err2HR(GetLastError());
        goto done;
    }

done:
    if (hKeyRoot != NULL)
        RegCloseKey(hKeyRoot);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\common\pftn\pftn.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    pftn.cpp

Abstract:
    Thread neutral COM ptrs.  This is stolen from dmassare's MPC_Common class
    pretty much intact (with tracing & some stylistic changes added in)

Revision History:
    created     derekm      04/12/00

******************************************************************************/

#include "stdafx.h"
#include "pftn.h"
#include <process.h>

/////////////////////////////////////////////////////////////////////////////
// tracing

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile

/////////////////////////////////////////////////////////////////////////////
// CPFComPtrThreadNeutral_GIT construct / term

// **************************************************************************
CPFComPtrThreadNeutral_GIT::CPFComPtrThreadNeutral_GIT(void)
{
    m_pGIT = NULL;
    ::InitializeCriticalSection(&m_cs);
}

// **************************************************************************
CPFComPtrThreadNeutral_GIT::~CPFComPtrThreadNeutral_GIT(void)
{
    this->Term();
    ::DeleteCriticalSection(&m_cs);
}


/////////////////////////////////////////////////////////////////////////////
// CPFComPtrThreadNeutral_GIT exposed

// **************************************************************************
void CPFComPtrThreadNeutral_GIT::Lock(void)
{
    ::EnterCriticalSection(&m_cs);
}

// **************************************************************************
void CPFComPtrThreadNeutral_GIT::Unlock(void)
{
    ::LeaveCriticalSection(&m_cs);
}

// **************************************************************************
HRESULT CPFComPtrThreadNeutral_GIT::GetGIT(IGlobalInterfaceTable **ppGIT)
{
    USE_TRACING("CPFComPtrThreadNeutral_GIT::GetGIT");

    // this will automatcially unlock when the fn exits
    CAutoUnlockCS   aucs(&m_cs);
    HRESULT         hr = NOERROR;

    VALIDATEPARM(hr, (ppGIT == NULL));
    if (FAILED(hr))
        goto done;

    aucs.Lock();

    VALIDATEEXPR(hr, (m_pGIT == NULL), E_FAIL);
    if (FAILED(hr))
        goto done;

    if (*ppGIT = m_pGIT)
    {
        m_pGIT->AddRef();
        hr = NOERROR;
    }
    
    aucs.Unlock();

done:
    return hr;
}

// **************************************************************************
HRESULT CPFComPtrThreadNeutral_GIT::Init(void)
{
    USE_TRACING("CPFComPtrThreadNeutral_GIT::Init");

    HRESULT         hr = NOERROR;

    this->Lock();

    if (m_pGIT == NULL)
    {
        TESTHR(hr, CoCreateInstance(CLSID_StdGlobalInterfaceTable, NULL, 
                                    CLSCTX_INPROC_SERVER, 
                                    IID_IGlobalInterfaceTable, 
                                    (LPVOID *)&m_pGIT));
    }

    this->Unlock();

    return hr;
}

// **************************************************************************
HRESULT CPFComPtrThreadNeutral_GIT::Term(void)
{
    USE_TRACING("CPFComPtrThreadNeutral_GIT::Term");

    HRESULT         hr = NOERROR;

    this->Lock();

    if (m_pGIT != NULL)
    {
        m_pGIT->Release();
        m_pGIT = NULL;
    }

    this->Unlock();

    return hr;
}

// **************************************************************************
HRESULT CPFComPtrThreadNeutral_GIT::RegisterInterface(IUnknown *pUnk,
                                                      REFIID riid,
                                                      DWORD *pdwCookie)
{
    USE_TRACING("CPFComPtrThreadNeutral_GIT::RegisterInterface");

    CComPtr<IGlobalInterfaceTable> pGIT;
    HRESULT                        hr = NOERROR;

    VALIDATEPARM(hr, (pUnk == NULL || pdwCookie == NULL));
    if (FAILED(hr))
        return hr;

    TESTHR(hr, GetGIT(&pGIT));
    if (FAILED(hr))
        return hr;

    TESTHR(hr, pGIT->RegisterInterfaceInGlobal(pUnk, riid, pdwCookie));
    return hr;
}

// **************************************************************************
HRESULT CPFComPtrThreadNeutral_GIT::RevokeInterface(DWORD dwCookie)
{
    USE_TRACING("CPFComPtrThreadNeutral_GIT::RevokeInterface");

    CComPtr<IGlobalInterfaceTable> pGIT;
    HRESULT                        hr = NOERROR;

    TESTHR(hr, GetGIT(&pGIT));
    if (FAILED(hr))
        return hr;

    TESTHR(hr, pGIT->RevokeInterfaceFromGlobal(dwCookie));
    return hr;
}

// **************************************************************************
HRESULT CPFComPtrThreadNeutral_GIT::GetInterface(DWORD dwCookie, REFIID riid,
                                                 void **ppv)
{
    USE_TRACING("CPFComPtrThreadNeutral_GIT::GetInterface");

    CComPtr<IGlobalInterfaceTable> pGIT;
    HRESULT                        hr;

    TESTHR(hr, GetGIT(&pGIT));
    if (FAILED(hr))
        return hr;

    TESTHR(hr, pGIT->GetInterfaceFromGlobal(dwCookie, riid, ppv));
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CPFCallItem

// **************************************************************************
CPFCallItem::CPFCallItem()
{
    m_vt = VT_EMPTY; // VARTYPE                         m_vt;
            	     // CComPtrThreadNeutral<IUnknown>  m_Unknown;
            	     // CComPtrThreadNeutral<IDispatch> m_Dispatch;
            	     // CComVariant                     m_Other;
}

// **************************************************************************
CPFCallItem& CPFCallItem::operator=(const CComVariant& var)
{
	switch(m_vt = var.vt)
	{
	    case VT_UNKNOWN: 
            m_Unknown = var.punkVal; 
            break;

	    case VT_DISPATCH:
            m_Dispatch = var.pdispVal; 
            break;
	    
        default: 
            m_Other = var; 
            break;
	}

	return *this;
}

// **************************************************************************
CPFCallItem::operator CComVariant() const
{
	CComVariant res;

	switch(m_vt)
	{
	    case VT_UNKNOWN: 
            res = (CComPtr<IUnknown>)m_Unknown; 
            break;

	    case VT_DISPATCH: 
            res = (CComPtr<IDispatch>)m_Dispatch; 
            break;

	    default: 
            res = m_Other; 
            break;
	}

	return res;
}


/////////////////////////////////////////////////////////////////////////////
// CPFCallDesc

// **************************************************************************
CPFCallDesc::CPFCallDesc(void)
{
    m_rgciVars     = NULL;
    m_dwVars       = 0;
}

// **************************************************************************
CPFCallDesc::~CPFCallDesc(void)
{
    if (m_rgciVars != NULL) 
        delete [] m_rgciVars;
}

// **************************************************************************
HRESULT CPFCallDesc::Init(IDispatch *dispTarget, DISPID dispidMethod,
                          const CComVariant *rgvVars, int dwVars)
{
    USE_TRACING("CPFCallDesc::Init");

    HRESULT hr = NOERROR;
    
    m_rgciVars = new CPFCallItem[dwVars];
    VALIDATEEXPR(hr, (m_rgciVars == NULL), E_OUTOFMEMORY);
    if (FAILED(hr))
        return hr;

    m_dispTarget   = dispTarget;
    m_dwVars       = dwVars;
    m_dispidMethod = dispidMethod;

	if (m_rgciVars != NULL)
	{
        int i;
		for(i = 0; i < dwVars; i++)
			m_rgciVars[i] = rgvVars[i];
	}

    return hr;
}


// **************************************************************************
HRESULT CPFCallDesc::Call(void)
{
    USE_TRACING("CPFCallDesc::Call");

    CComPtr<IDispatch>  dispTarget = m_dispTarget;
	CComVariant*        pvars;
    CComVariant         vResult;
    DISPPARAMS          disp;
    HRESULT             hr;
    DWORD               i;

    VALIDATEEXPR(hr, (dispTarget == NULL), E_POINTER);
    if (FAILED(hr))
        return hr;

    pvars = new CComVariant[m_dwVars];
    VALIDATEEXPR(hr, (pvars == NULL), E_OUTOFMEMORY);
    if (FAILED(hr))
        return hr;

	for(i = 0; i < m_dwVars; i++)
		pvars[i] = m_rgciVars[i];

    ZeroMemory(&disp, sizeof(disp));
    disp.cArgs  = m_dwVars;
    disp.rgvarg = pvars;

	TESTHR(hr, dispTarget->Invoke(m_dispidMethod, IID_NULL, LOCALE_USER_DEFAULT, 
                                  DISPATCH_METHOD, &disp, &vResult, NULL, NULL));
	delete [] pvars;
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CPFModule                                                       

// **************************************************************************
HRESULT CPFModule::Init(void)
{
    USE_TRACING("CPFModule::Init");

    HRESULT hr = NULL;
    TESTHR(hr, m_GITHolder.Init());
    return hr;
}

// **************************************************************************
HRESULT CPFModule::Term(void)
{
    USE_TRACING("CPFModule::Init");

    HRESULT hr = NULL;
    TESTHR(hr, m_GITHolder.Term());
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\atprov\maindll.cpp ===
//***************************************************************************
//
//  MAINDLL.CPP
// 
//  Module: WMI Framework Instance provider 
//
//  Purpose: Contains DLL entry points.  Also has code that controls
//           when the DLL can be unloaded by tracking the number of
//           objects and locks as well as routines that support
//           self registration.
//
//  Copyright (c)1999 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "pchealth.h"

HMODULE g_hModule;
//============

WCHAR *GUIDSTRING = L"{5d24c539-5b5b-11d3-8ddd-00c04f688c0b}";
CLSID CLSID_PRINTSYS;

// Count number of objects and number of locks.
long g_cLock = 0;


// Keep a global IWbemServices pointer, since we use it frequently and
// it's a little expensive to get.
CComPtr<IWbemServices> g_pWbemServices = NULL;


//***************************************************************************
//
//  DllGetClassObject
//
//  Purpose: Called by Ole when some client wants a class factory.  Return 
//           one only if it is the sort of class this DLL supports.
//
//***************************************************************************

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, PPVOID ppv)
{
    CWbemGlueFactory    *pObj;
    HRESULT             hr;

    CLSIDFromString(GUIDSTRING, &CLSID_PRINTSYS);
    if (rclsid != CLSID_PRINTSYS)
        return E_FAIL;

    pObj = new CWbemGlueFactory();

    if (NULL == pObj)
        return E_OUTOFMEMORY;

    hr = pObj->QueryInterface(riid, ppv);

    if (FAILED(hr))
        delete pObj;

    return hr;
}

//***************************************************************************
//
// DllCanUnloadNow
//
// Purpose: Called periodically by Ole in order to determine if the
//          DLL can be freed.
//
// Return:  S_OK if there are no objects in use and the class factory 
//          isn't locked.
//
//***************************************************************************

STDAPI DllCanUnloadNow(void)
{
    SCODE   sc;

    // It is OK to unload if there are no objects or locks on the 
    // class factory and the framework is done with you.
    
    if ((g_cLock == 0) && CWbemProviderGlue::FrameworkLogoffDLL(L"PRINTSYS"))
        sc = S_OK;
    else
        sc = S_FALSE;
    return sc;
}

//***************************************************************************
//
//  Is4OrMore
//
//  Returns true if win95 or any version of NT > 3.51
//
//***************************************************************************

BOOL Is4OrMore(void)
{
    OSVERSIONINFO os;

    os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if(!GetVersionEx(&os))
        return FALSE;           // should never happen

    return os.dwMajorVersion >= 4;
}

//***************************************************************************
//
// DllRegisterServer
//
// Purpose: Called during setup or by regsvr32.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllRegisterServer(void)
{   
    WCHAR   wcID[128];
    HKEY    hKey1, hKey2;
    char    szID[128];
    char    szCLSID[128];
    char    szModule[MAX_PATH];
    char    *pName = "";
    char    *pModel;

    if(Is4OrMore())
        pModel = "Both";
    else
        pModel = "Apartment";

    // Create the path.
    CLSIDFromString(GUIDSTRING, &CLSID_PRINTSYS);
    StringFromGUID2(CLSID_PRINTSYS, wcID, 128);
    wcstombs(szID, wcID, 128);
    lstrcpy(szCLSID, TEXT("SOFTWARE\\CLASSES\\CLSID\\"));
    lstrcat(szCLSID, szID);

    // Create entries under CLSID
    RegCreateKey(HKEY_LOCAL_MACHINE, szCLSID, &hKey1);
    RegSetValueEx(hKey1, NULL, 0, REG_SZ, (BYTE *)pName, lstrlen(pName)+1);
    RegCreateKey(hKey1,"InprocServer32",&hKey2);

    GetModuleFileName(g_hModule, szModule,  MAX_PATH);
    RegSetValueEx(hKey2, NULL, 0, REG_SZ, (BYTE *)szModule, 
                                        lstrlen(szModule)+1);
    RegSetValueEx(hKey2, "ThreadingModel", 0, REG_SZ, 
                                        (BYTE *)pModel, lstrlen(pModel)+1);
    CloseHandle(hKey1);
    CloseHandle(hKey2);

    return NOERROR;
}

//***************************************************************************
//
// DllUnregisterServer
//
// Purpose: Called when it is time to remove the registry entries.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllUnregisterServer(void)
{
    WCHAR   wcID[128];
    HKEY    hKey;
    char    szID[128];
    char    szCLSID[128];

    // Create the path using the CLSID

    CLSIDFromString(GUIDSTRING, &CLSID_PRINTSYS);
    StringFromGUID2(CLSID_PRINTSYS, wcID, 128);
    wcstombs(szID, wcID, 128);
    lstrcpy(szCLSID, TEXT("SOFTWARE\\CLASSES\\CLSID\\"));
    lstrcat(szCLSID, szID);

    // First delete the InProcServer subkey.

    DWORD dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, szCLSID, &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey, "InProcServer32");
        CloseHandle(hKey);
    }

    dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\CLASSES\\CLSID\\"), &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey,szID);
        CloseHandle(hKey);
    }

    return NOERROR;
}

//***************************************************************************
//
// DllMain
//
// Purpose: Called by the operating system when processes and threads are 
//          initialized and terminated, or upon calls to the LoadLibrary 
//          and FreeLibrary functions
//
// Return:  TRUE if load was successful, else FALSE
//***************************************************************************

BOOL APIENTRY DllMain (HINSTANCE hInstDLL, // handle to dll module
                       DWORD fdwReason,    // reason for calling function
                       LPVOID lpReserved)  // reserved
{
    BOOL bRet = TRUE;
    
    // Perform actions based on the reason for calling.
    switch( fdwReason ) 
    { 
        case DLL_PROCESS_ATTACH:
            DisableThreadLibraryCalls(hInstDLL);
            g_hModule = hInstDLL;
            bRet = CWbemProviderGlue::FrameworkLoginDLL(L"PRINTSYS");
            break;

        case DLL_THREAD_ATTACH:
         // Do thread-specific initialization.
            break;

        case DLL_THREAD_DETACH:
         // Do thread-specific cleanup.
            break;

        case DLL_PROCESS_DETACH:
         // Perform any necessary cleanup.
            break;
    }

    return bRet;  // Sstatus of DLL_PROCESS_ATTACH.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\atprov\pchealth.h ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    pchealth.H

Abstract:
    Main header file for all PCHealth WMI providers
    Contains all defines and includes used elsewhere

Revision History:

    Ghim-Sim Chua       (gschua)   04/27/99
        - Created

    Ghim-Sim Chua       (gschua)   05/02/99
        - Added GetWbemServices & CopyProperty

    Kalyani Narlanka    (kalyanin) 05/10/99
        - Added #define  INCL_WINSOCK_API_TYPEDEFS
        - Included <winsock2.>


********************************************************************/
#define INCL_WINSOCK_API_TYPEDEFS 1
#include <winsock2.h>
#include <sys/stat.h>

#ifndef _pchdef_h_
#define _pchdef_h_

#ifdef _WIN32_WINNT
#undef _WIN32_WINNT
#endif

#include <fwcommon.h>  // This must be the first include.
#include <provider.h>
#include <atlbase.h>
#include "dbgtrace.h"
#include "traceids.h"

#include "smartptr.h"


// Namespaces that we'll be working with
#define PCH_NAMESPACE   L"root\\pchealth"
#define CIM_NAMESPACE   L"root\\cimv2"


// #include <winsock2.h>


// Global Variables
extern CComPtr<IWbemServices> g_pWbemServices;

// Utility functions
HRESULT ExecWQLQuery(IEnumWbemClassObject **ppEnumInst, BSTR bstrQuery);
HRESULT GetWbemServices(IWbemServices **ppServices);
HRESULT CopyProperty(IWbemClassObject * pFrom, LPCWSTR szFrom, CInstance * pTo, LPCWSTR szTo);
HRESULT GetCIMDataFile(BSTR bstrFile, IWbemClassObject ** ppFileObject, BOOL fHasDoubleSlashes = FALSE);
HRESULT GetCIMObj(BSTR bstrPath, IWbemClassObject **ppObj, long lFlags);
BOOL    getCompletePath(CComBSTR bstrFileName, CComBSTR &bstrFileWithPathName);

// memory alloc inlines
inline LPVOID MyAlloc(DWORD cb)
{
    return HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, cb);
}

inline LPVOID MyReAlloc(LPVOID pv, DWORD cb)
{
    return HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, pv, cb);
}
    
inline BOOL MyFree(LPVOID pv)
{
    return HeapFree(GetProcessHeap(), 0, pv);
}

#endif // _pchdef_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\atprov\printjob.cpp ===
/******************************************************************
   PrintJob.CPP -- WMI provider class implementation

   Generated by Microsoft WMI Code Generation Engine
  
   TO DO: - See individual function headers
          - When linking, make sure you link to framedyd.lib & 
            msvcrtd.lib (debug) or framedyn.lib & msvcrt.lib (retail).

   Description: 
   
  
  
******************************************************************/

#include "pchealth.h"
#include "PrintJob.h"


/////////////////////////////////////////////////////////////////////////////
//  tracing stuff

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile
#define TRACE_ID    DCID_PRINTERDRIVER


/////////////////////////////////////////////////////////////////////////////
//  initialization

CPrintJob MyPrintJobSet (PROVIDER_NAME_PRINTJOB, PCH_NAMESPACE) ;


/////////////////////////////////////////////////////////////////////////////
//  Property names

// PCH 
const static WCHAR *c_wszName          = L"Name";
const static WCHAR *c_wszPagesPrinted  = L"PagesPrinted";
const static WCHAR *c_wszSize          = L"Size";
const static WCHAR *c_wszStatus        = L"Status";
const static WCHAR *c_wszTimeSubmitted = L"TimeSubmitted";
const static WCHAR *c_wszUser          = L"User";
const static WCHAR *c_wszDocument      = L"Document";

// WMI
const static WCHAR *c_wszNotify        = L"Notify";
const static WCHAR *c_wszJobStatus     = L"JobStatus";

//////////////////////////////////////////////////////////////////////////////
// construction / destruction

// ***************************************************************************
CPrintJob::CPrintJob(LPCWSTR lpwszName, LPCWSTR lpwszNameSpace) :
    Provider(lpwszName, lpwszNameSpace)
{
}

// ***************************************************************************
CPrintJob::~CPrintJob()
{
}


//////////////////////////////////////////////////////////////////////////////
// internal methods

// ****************************************************************************
HRESULT CPrintJob::GetInstanceData(IWbemClassObjectPtr pObj, 
                                   CInstance *pInstance)
{

    // ** Name
    CopyProperty(pObj, c_wszName, pInstance, c_wszName);

    // ** Pages Printed
    CopyProperty(pObj, c_wszPagesPrinted, pInstance, c_wszPagesPrinted);
    
    // ** Size     
    CopyProperty(pObj, c_wszSize, pInstance, c_wszSize);
    
    // ** JobStatus
    CopyProperty(pObj, c_wszJobStatus, pInstance, c_wszStatus);
        
    // ** TimeSubmitted
    CopyProperty(pObj, c_wszTimeSubmitted, pInstance, c_wszTimeSubmitted);

    // ** User
    CopyProperty(pObj, c_wszNotify, pInstance, c_wszUser);

    // ** Document
    CopyProperty(pObj, c_wszDocument, pInstance, c_wszDocument);

    return NOERROR;
}


//////////////////////////////////////////////////////////////////////////////
// exposed methods

// ***************************************************************************
HRESULT CPrintJob::EnumerateInstances(MethodContext *pMethodContext, long lFlags)
{
    TraceFunctEnter("CPCH_PrintJob::EnumerateInstances");

    IEnumWbemClassObject    *pEnumInst = NULL;
    IWbemClassObjectPtr     pObj = NULL;
    CComBSTR                bstrQuery;   
    HRESULT                 hr = WBEM_S_NO_ERROR;
    ULONG                   ulRetVal;
    TCHAR                   wszUser[1024];
    DWORD                   cchUser = sizeof(wszUser) / sizeof(TCHAR);

    GetUserName(wszUser, &cchUser);


    // Execute the query
    bstrQuery = L"select Name, document, Notify, Size, JobStatus, TimeSubmitted, PagesPrinted from Win32_printJob";
    hr = ExecWQLQuery(&pEnumInst, bstrQuery);
    if (FAILED(hr))
        goto done;

    // enumerate the instances from Win32_PrintJob
    while(pEnumInst->Next(WBEM_INFINITE, 1, &pObj, &ulRetVal) == WBEM_S_NO_ERROR)
    {
        // Create a new instance based on the passed-in MethodContext
        CInstancePtr pInstance(CreateNewInstance(pMethodContext), FALSE);

        // since the old code didn't care if this failed, neither do I.
        hr = GetInstanceData(pObj, pInstance);
        
        // commit instance
        hr = pInstance->Commit();
        if (FAILED(hr))
            ErrorTrace(TRACE_ID, "Error committing instance");

        // Ok, so WMI does not follow it's own docs on how GetObject
        //  works.  According to them, we should release this object here.  But
        //  if I try, winmgmt GPFs.
        // pObj->Release();
        pObj = NULL;
    }

done:
    if (pEnumInst != NULL)
        pEnumInst->Release();

    TraceFunctLeave();
    return hr;
}

// *****************************************************************************
HRESULT CPrintJob::ExecMethod(const CInstance& Instance,
                              const BSTR bstrMethodName,
                              CInstance *pInParams, CInstance *pOutParams,
                              long lFlags)
{
    return (WBEM_E_PROVIDER_NOT_CAPABLE);
}

// *****************************************************************************
HRESULT CPrintJob::GetObject(CInstance* pInstance, long lFlags) 
{ 
    TraceFunctEnter("CPrintJob::GetObject");

    IWbemClassObjectPtr pObj = NULL;
    CComBSTR            bstrPath;
    HRESULT             hr = NOERROR;
    VARIANT             var;
    TCHAR               szDefault[MAX_PATH];
    TCHAR               *pchToken, *szDefName = NULL;
    DWORD               i;

    VariantInit(&var);

    if (pInstance == NULL)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    // get the name of the printer
    if (pInstance->GetVariant(c_wszName, var) == FALSE)
    {
        ErrorTrace(TRACE_ID, "Unable to fetch printer name");
        hr = E_FAIL;
        goto done;
    }

    if (V_VT(&var) != VT_BSTR)
    {
        hr = VariantChangeType(&var, &var, 0, VT_BSTR);
        if (FAILED(hr))
        {
            ErrorTrace(TRACE_ID, "VariantChangeType failed: 0x%08x", hr);
            goto done;
        }
    }
   
    // get the default printer & path 
    if(GetProfileString(_T("Windows"), _T("Device"), "\0", szDefault, MAX_PATH) > 1)
    {
        //  The Above GetProfileString returns "printerName", "PrinterDriver" 
        //   and "PrinterPath" seperated by commas. Ignore "PrinterDriver" 
        //   and use the other two to set the properties.
        pchToken = _tcstok(szDefault, _T(","));
        if(pchToken != NULL)
        {
            // ** default name
            szDefName = pchToken;
        }
    }
    
    // build the path to the object
    bstrPath = L"\\\\.\\root\\cimv2:Win32_PrintJob.Name=\"";
    bstrPath.Append(V_BSTR(&var));
    bstrPath.Append("\"");

    // fetch it
    hr = GetCIMObj(bstrPath, &pObj, lFlags);
    if (FAILED(hr))
        goto done;

    // populate the CInstance object
    hr = GetInstanceData(pObj, pInstance);
    if (FAILED(hr))
        goto done;
    
    //  All the properties are set. Commit the instance
    hr = pInstance->Commit();
    if(FAILED(hr))
        ErrorTrace(TRACE_ID, "Could not commit instance: 0x%08x", hr);

done:
    VariantClear(&var);

    // Ok, so WMI does not follow it's own docs on how GetObject
    //  works.  According to them, we should release this object here.  But
    //  if I try, winmgmt GPFs.
    // if (pObj != NULL)
    //    pObj->Release();

    TraceFunctLeave();
    return hr; 
}

// *****************************************************************************
HRESULT CPrintJob::ExecQuery(MethodContext *pMethodContext, 
                            CFrameworkQuery& Query, long lFlags) 
{ 
    return WBEM_E_PROVIDER_NOT_CAPABLE; 
}

// *****************************************************************************
HRESULT CPrintJob::PutInstance(const CInstance& Instance, long lFlags)
{ 
    return WBEM_E_PROVIDER_NOT_CAPABLE; 
}

// *****************************************************************************
HRESULT CPrintJob::DeleteInstance(const CInstance& Instance, long lFlags)
{ 
    return WBEM_E_PROVIDER_NOT_CAPABLE; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\atprov\printjob.h ===
/******************************************************************

   PrintJob.H -- WMI provider class definition

   Generated by Microsoft WBEM Code Generation Engine
 
   Description: 
   

*******************************************************************/

// Property set identification
//============================

#ifndef _PrintJob_H_
#define _PrintJob_H_

#define PROVIDER_NAME_PRINTJOB L"PCHAT_PrintJob"

// Property name externs -- defined in PrintJob.cpp
//=================================================

extern const WCHAR *c_szName;
extern const WCHAR *c_szPagesPrinted;
extern const WCHAR *c_szSize;
extern const WCHAR *c_szStatus;
extern const WCHAR *c_szTimeSubmitted;
extern const WCHAR *c_szUser;

class CPrintJob : public Provider 
{
private:
    // member data 
    CInstance   *m_pCurrent;
    CInstance   *m_pParamIn;
    CInstance   *m_pParamOut;
    LONG        m_lFlags;

    // member methods
    HRESULT     GetInstanceData(IWbemClassObjectPtr pObj, 
                                CInstance *pInstance);


public:
    // Constructor/destructor
    //=======================

    CPrintJob(LPCWSTR lpwszClassName, LPCWSTR lpwszNameSpace);
    virtual ~CPrintJob();

protected:
    // Reading Functions
    //============================
    virtual HRESULT EnumerateInstances(MethodContext *pMethodContext, 
                                       long lFlags = 0L);
    virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L); 
    virtual HRESULT ExecQuery(MethodContext *pMethodContext, 
                              CFrameworkQuery& Query, long lFlags = 0L);

    // Writing Functions
    //============================
    virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L);
    virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L);

    // Other Functions
    virtual HRESULT ExecMethod(const CInstance& Instance, const BSTR bstrMethodName,
                               CInstance *pInParams, CInstance *pOutParams,
                               long lFlags = 0L);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\atprov\printer.h ===
/******************************************************************

   Printer.H -- WMI provider class definition

   Generated by Microsoft WBEM Code Generation Engine
 
   Description: 
   

*******************************************************************/

// Property set identification
//============================

#ifndef _Printer_H_
#define _Printer_H_

#define PROVIDER_NAME_PRINTER L"PCHAT_Printer"

// Property name externs -- defined in Printer.cpp
//=================================================

extern const WCHAR *c_szDate;
extern const WCHAR *c_szDefault;
extern const WCHAR *c_szFilename;
extern const WCHAR *c_szManufacturer;
extern const WCHAR *c_szName;
extern const WCHAR *c_szPath;
extern const WCHAR *c_szPaused;
extern const WCHAR *c_szSize;
extern const WCHAR *c_szVersion;

class CPrinter : public Provider 
{
private:
    // member data 
    CInstance   *m_pCurrent;
    CInstance   *m_pParamIn;
    CInstance   *m_pParamOut;
    LONG        m_lFlags;

    // member methods
    HRESULT     GetInstanceData(IWbemClassObjectPtr pObj, CInstance *pInst);
    HRESULT     GetStatus(void);
    HRESULT     PrinterProperties(void);
    HRESULT     RemovePause(void);
    HRESULT     SetAsDefault(TCHAR *szOldDefault = NULL, 
                             DWORD cchOldDefault = 0, 
                             BOOL fSetOldDefault = FALSE);
    HRESULT     TestPrinter(void);
    HRESULT     EnableSpooler(void);
    HRESULT     SetTimeouts(void);

public:
    // Constructor/destructor
    //=======================
    CPrinter(LPCWSTR lpwszClassName, LPCWSTR lpwszNameSpace);
    virtual ~CPrinter();

protected:
    // Reading Functions
    //============================
    virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, 
                                       long lFlags = 0L);
    virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L);
    virtual HRESULT ExecQuery(MethodContext *pMethodContext, 
                              CFrameworkQuery& Query, long lFlags = 0L);


    // Writing Functions
    //============================
    virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L);
    virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L);

    // Other Functions
    virtual HRESULT ExecMethod(const CInstance& Instance, const BSTR bstrMethodName,
                               CInstance *pInParams, CInstance *pOutParams,
                               long lFlags = 0L);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\atprov\printsys.cpp ===
/******************************************************************
   PrintSys.CPP -- WMI provider class implementation

   Generated by Microsoft WMI Code Generation Engine
  
   TO DO: - See individual function headers
          - When linking, make sure you link to framedyd.lib & 
            msvcrtd.lib (debug) or framedyn.lib & msvcrt.lib (retail).

   Description: 
   
  
  
******************************************************************/

#include "pchealth.h"
#include "PrintSys.h"


/////////////////////////////////////////////////////////////////////////////
//  tracing stuff

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile
#define TRACE_ID    DCID_PRINTERDRIVER


/////////////////////////////////////////////////////////////////////////////
//  initialization

CPrintSys MyPrintSysSet (PROVIDER_NAME_PRINTSYS, PCH_NAMESPACE) ;


/////////////////////////////////////////////////////////////////////////////
//  Property names

const static WCHAR *c_wszGenDrv              = L"GenDrv";
const static WCHAR *c_wszName                = L"Name";
const static WCHAR *c_wszPath                = L"Path";
const static WCHAR *c_wszUniDrv              = L"UniDrv";
const static WCHAR *c_wszUsePrintMgrSpooling = L"UsePrintMgrSpooling";


//////////////////////////////////////////////////////////////////////////////
// construction / destruction

// ***************************************************************************
CPrintSys::CPrintSys (LPCWSTR lpwszName, LPCWSTR lpwszNameSpace ) :
    Provider(lpwszName, lpwszNameSpace)
{
    m_pParamOut = NULL;
    m_pCurrent  = NULL;
    m_pParamIn  = NULL;
    m_lFlags    = 0;
}

// ***************************************************************************
CPrintSys::~CPrintSys()
{
}


//////////////////////////////////////////////////////////////////////////////
// exposed methods

// *****************************************************************************
HRESULT CPrintSys::EnumerateInstances(MethodContext *pMethodContext, long lFlags)
{
    TraceFunctEnter("CPrintSys::EnumerateInstances");

    HRESULT hr = WBEM_S_NO_ERROR;

    //  Create a new instance of PCH_Printer Class based on the passed-in MethodContext
    CInstancePtr pPrintSysInst(CreateNewInstance(pMethodContext), false);

    hr = this->GetObject(pPrintSysInst, 0);
    
    TraceFunctLeave();
    return hr;
}

// *****************************************************************************
HRESULT CPrintSys::ExecMethod (const CInstance& Instance,
                              const BSTR bstrMethodName,
                              CInstance *pInParams, CInstance *pOutParams,
                              long lFlags)
{
    return WBEM_E_PROVIDER_NOT_CAPABLE; 
}

// *****************************************************************************
HRESULT CPrintSys::GetObject(CInstance* pInstance, long lFlags) 
{ 
    TraceFunctEnter("CPrintSys::GetObject");

    HRESULT hr = WBEM_S_NO_ERROR;

    //  Objects
    IWbemClassObjectPtr pFileObj = NULL;
    
    //  Variants
    CComVariant         varValue;
    CComVariant         varNotAvail             = L"Not Available";

    //   Strings
    CComBSTR            bstrDriverWithPath; 
    CComBSTR            bstrDetails;
    CComBSTR            bstrVersion             = L"Version";
    CComBSTR            bstrFileSize            = L"FileSize";
    CComBSTR            bstrModifiedDate        = L"LastModified";

    LPCTSTR             lpctstrUniDriver        = _T("unidrv.dll");
    LPCTSTR             lpctstrGenDriver        = _T("gendrv.dll");
    LPCTSTR             lpctstrWindows          = _T("Windows");   
    LPCTSTR             lpctstrDevice           = _T("Device");  
    LPCTSTR             lpctstrNoUniDrv         = _T("(unidrv.dll) = NotInstalled");
    LPCTSTR             lpctstrNoGenDrv         = _T("(gendrv.dll) = NotInstalled");
    LPCTSTR             lpctstrPrintersHive     = _T("System\\CurrentControlSet\\Control\\Print\\Printers");
    LPCTSTR             lpctstrYes              = _T("yes");
    LPCTSTR             lpctstrAttributes       = _T("Attributes");
    LPCTSTR             lpctstrSpooler          = _T("Spooler");

    TCHAR               tchBuffer[MAX_PATH + 1];
    TCHAR               tchPrinterKeyName[MAX_PATH + 1];
    TCHAR               *ptchToken;

    //  Booleans
    BOOL                fDriverFound = FALSE;
    BOOL                fAttribFound = FALSE;

    //  DWORDs
    DWORD               dwSize;
    DWORD               dwIndex;
    DWORD               dwType;

    //  Return Values;
    ULONG               ulPrinterAttribs;

    LONG                lRegRetVal;

    struct tm           tm;

    WBEMTime            wbemtime;

    HKEY                hkeyPrinter = NULL;
    HKEY                hkeyPrinters = NULL;

    FILETIME            ft;

    // *** Set the properties associated with the default printer

    
    //  In "win.ini" file under "Windows" section "Device" represents the default printer
    if(GetProfileString(lpctstrWindows, lpctstrDevice, "\0", tchBuffer, MAX_PATH) > 1)
    {
        //  The Above GetProfileString returns "printerName", "PrinterDriver" 
        //   and "PrinterPath" seperated by commas. Ignore "PrinterDriver" 
        //   and use the other two to set the properties.
        ptchToken = _tcstok(tchBuffer, _T(","));
        if(ptchToken != NULL)
        {
            // ** name (token 1)
            varValue = ptchToken;
            if (pInstance->SetVariant(c_wszName, varValue) == FALSE)
                ErrorTrace(TRACE_ID, "SetVariant on Name failed.");
                        
            // ** path (token 3)          
            ptchToken = _tcstok(NULL, _T(","));
            if(ptchToken != NULL)
            {
                // gotta skip the 2nd token cuz it's the printer dirver & we 
                //  don't give a rat's patoshki about it at this moment...
                
                ptchToken = _tcstok(NULL, _T(","));
                if(ptchToken != NULL)
                {
                    varValue = ptchToken;
                    if (pInstance->SetVariant(c_wszPath, varValue) == FALSE)
                        ErrorTrace(TRACE_ID, "Set Variant on Path failed.");
                }
            }
        }
    }

    // couldn't fetch the properties of the default printer, so shove in some
    //  default values...
    else
    {
        //  set Name to "Not Available"
        if (pInstance->SetVariant(c_wszName, varNotAvail) == FALSE)
            ErrorTrace(TRACE_ID, "Se Variant on Name failed.");

        // set Path to "Not Available"
        if (pInstance->SetVariant(c_wszPath, varValue) == FALSE)
            ErrorTrace(TRACE_ID, "Set Variant on Path failed.");
    }


    // *** Set the properties associated with using print manager spooling


    //  First try to get the Spooling  information from the registry which is 
    //   available if there are any installed printers 
    //   HKLM\system\CCS\Control\Print\Printers

    lRegRetVal = RegOpenKeyEx(HKEY_LOCAL_MACHINE, lpctstrPrintersHive, 0, KEY_READ, &hkeyPrinters);
    if(lRegRetVal == ERROR_SUCCESS)
	{
        // Enumerate the keys under this hive.
        ZeroMemory(&ft, sizeof(ft));
        dwIndex = 0;
        dwSize = MAX_PATH;
        lRegRetVal = RegEnumKeyEx(hkeyPrinters, dwIndex,  tchPrinterKeyName, &dwSize, NULL, NULL, NULL, &ft);
        if(lRegRetVal == ERROR_SUCCESS)
        {
            //  There is atleast one printer installed.
            lRegRetVal = RegOpenKeyEx(hkeyPrinters,  tchPrinterKeyName, 0, KEY_READ, &hkeyPrinter);
            if(lRegRetVal == ERROR_SUCCESS)
            {
                //  Opened the first printer key
                //  Query for , regname "Attributes"
                dwSize = sizeof(DWORD);
                lRegRetVal = RegQueryValueEx(hkeyPrinter, lpctstrAttributes, NULL, &dwType, (LPBYTE)&ulPrinterAttribs, &dwSize);
                if(lRegRetVal == ERROR_SUCCESS)
                {
                    // if the PRINTER_ATTRIBUTE_DIRECT bit in ulPrinterAttribs
                    //  is set, then we have spooling...
                    if((ulPrinterAttribs & PRINTER_ATTRIBUTE_DIRECT) != 0)
                        varValue = VARIANT_FALSE;
                    else
                        varValue = VARIANT_TRUE;

                    if (ulPrinterAttribs > 0)
                        fAttribFound = TRUE;
                }
            }
        }
    }   
    
    if (hkeyPrinter != NULL)
    {
        RegCloseKey(hkeyPrinter);
        hkeyPrinter = NULL;
    }
    if (hkeyPrinters != NULL)
    {
        RegCloseKey(hkeyPrinters);
        hkeyPrinters = NULL;
    }

    if(fAttribFound == FALSE)
    {
        //  If not get the "spooler" key value from the win.ini file.  If the entry is not present default to "yes".
        if(GetProfileString(lpctstrWindows, lpctstrSpooler, _T("yes"), tchBuffer, MAX_PATH) > 1)
        {
            // if it's yes, then we have spooling...
            if(_tcsicmp(tchBuffer, lpctstrYes) == 0)
                varValue = VARIANT_TRUE;
            else
                varValue = VARIANT_FALSE;
        }
    }

    //  Set the Spooling Property.
    if (pInstance->SetVariant(c_wszUsePrintMgrSpooling, varValue) == FALSE)
        ErrorTrace(TRACE_ID, "SetVariant on usePrintManagerSpooling failed.");
    

    // *** Set the properties associated with using print manager spooling


    //  Get the complete path for unidrv.dll
    fDriverFound = getCompletePath(lpctstrUniDriver, bstrDriverWithPath);
    if(fDriverFound)
    {
        // Need to use GetCIMDataFile to get the unidriver properties
        if (SUCCEEDED(GetCIMDataFile(bstrDriverWithPath, &pFileObj)))
        {
            bstrDetails.Empty();

            //  Get the Version & append it to the value string...
            varValue.Clear();
            hr = pFileObj->Get(bstrVersion, 0, &varValue, NULL, NULL);
            if(SUCCEEDED(hr))
            {
                if(varValue.vt == VT_BSTR)
                {
                    bstrDetails.Append(varValue.bstrVal);
                    bstrDetails.Append(_T("  "));
                }
            }

            //  Get the FileSize & append it to the value string...
            varValue.Clear();
            hr = pFileObj->Get(bstrFileSize, 0, &varValue, NULL, NULL);
            if(SUCCEEDED(hr))
            {
                if(varValue.vt == VT_BSTR)
                {
                    bstrDetails.Append(varValue.bstrVal);
                    bstrDetails.Append(_T("  "));
                }
            }

            //  Get the date & time & append them to the value string...
            varValue.Clear();
            hr = pFileObj->Get(bstrModifiedDate, 0, &varValue, NULL, NULL);
            if(SUCCEEDED(hr))
            {
                if(varValue.vt == VT_BSTR)
                {
                    WCHAR *pwsz;

                    // there is a slight problem when WMI returns to us a 
                    //  time that has a '*' in it.  The WBEMTime class plain
                    //  refuses to deal with it.  So change '*'s to '0's...
                    for (pwsz = varValue.bstrVal; *pwsz != L'\0'; pwsz++)
                    {
                        if (*pwsz == L'*')
                            *pwsz = L'0';
                    }

                    wbemtime = varValue.bstrVal;
                    if(wbemtime.GetStructtm(&tm))
                    {
                        varValue = asctime(&tm);
                        bstrDetails.Append(varValue.bstrVal);
                    }
                }
                
            }

            // set the value
            varValue.vt = VT_BSTR;
            varValue.bstrVal = bstrDetails.Detach();
        }

        // Since I don't seem to have unindrv.dll installed, I can't verify 
        //  this, but going by the other WMI providers, GetObject doesn't seem
        //  to like it when u release objects fetched by it.  So, I am not 
        //  going to release it.
        if (pFileObj != NULL)
        {
            // pFileObj->Release();
            pFileObj = NULL;
        }
    }

    // the unidriver dll isn't present.  Use a default value
    else 
    {
        varValue.Clear();
        varValue = lpctstrNoUniDrv;
    }

    // set the property
    if (pInstance->SetVariant(c_wszUniDrv, varValue) == FALSE)
        ErrorTrace(TRACE_ID, "SetVariant on UniDriver failed.");


    // *** Set the properties associated with using print manager spooling

    
    //  Get the complete path for gendrv.dll
    bstrDriverWithPath.Empty();
    fDriverFound =  getCompletePath(lpctstrGenDriver, bstrDriverWithPath);
    if(fDriverFound)
    {
        bstrDetails.Empty();

        // Need to use GetCIMDataFile to get the gen driver properties
        if(SUCCEEDED(GetCIMDataFile(bstrDriverWithPath, &pFileObj)))
        {
            //  Get the Version & append it to the value string...
            varValue.Clear();
            hr = pFileObj->Get(bstrVersion, 0, &varValue, NULL, NULL);
            if(SUCCEEDED(hr))
            {
                if(varValue.vt == VT_BSTR)
                {
                    bstrDetails.Append(varValue.bstrVal);
                    bstrDetails.Append(_T("  "));
                }
            }
            
            //  Get the FileSize & append it to the value string...
            varValue.Clear();
            hr = pFileObj->Get(bstrFileSize, 0, &varValue, NULL, NULL);
            if(SUCCEEDED(hr))
            {
                if(varValue.vt == VT_BSTR)
                {
                    bstrDetails.Append(varValue.bstrVal);
                    bstrDetails.Append(_T("  "));
                }
            }

            //  Get the date & time & append them to the value string...
            varValue.Clear();
            hr = pFileObj->Get(bstrModifiedDate, 0, &varValue, NULL, NULL);
            if(SUCCEEDED(hr))
            {
                if(varValue.vt == VT_BSTR)
                {
                    WCHAR *pwsz;

                    // there is a slight problem when WMI returns to us a 
                    //  time that has a '*' in it.  The WBEMTime class plain
                    //  refuses to deal with it.  So change '*'s to '0's...
                    for (pwsz = varValue.bstrVal; *pwsz != L'\0'; pwsz++)
                    {
                        if (*pwsz == L'*')
                            *pwsz = L'0';
                    }

                    wbemtime = varValue.bstrVal;
                    if(wbemtime.GetStructtm(&tm))
                    {
                        varValue = asctime(&tm);
                        bstrDetails.Append(varValue.bstrVal);
                    }
                }
            }

            // set the value
            varValue.vt = VT_BSTR;
            varValue.bstrVal = bstrDetails.Detach();
        }

        // Since I don't seem to have gendrv.dll installed, I can't verify 
        //  this, but going by the other WMI providers, GetObject doesn't seem
        //  to like it when u release objects fetched by it.  So, I am not 
        //  going to release it.
        if (pFileObj != NULL)
        {
            // pFileObj->Release();
            pFileObj = NULL;
        }
    } 

    // the gen driver dll is not present...
    else 
    {
        varValue.Clear();
        varValue = lpctstrNoGenDrv;
    }

    if (pInstance->SetVariant(c_wszGenDrv, varValue) == FALSE)
        ErrorTrace(TRACE_ID, "SetVariant on GenDrv failed.");


    // WOOHOO!!  We can commit now
    hr = pInstance->Commit();
    if(FAILED(hr))
        ErrorTrace(TRACE_ID, "Error on commiting!");

    TraceFunctLeave();
    return hr;
}

// *****************************************************************************
HRESULT CPrintSys::ExecQuery(MethodContext *pMethodContext, 
                            CFrameworkQuery& Query, long lFlags) 
{ 
    return WBEM_E_PROVIDER_NOT_CAPABLE; 
}

// *****************************************************************************
HRESULT CPrintSys::PutInstance(const CInstance& Instance, long lFlags)
{ 
    return WBEM_E_PROVIDER_NOT_CAPABLE; 
}

// *****************************************************************************
HRESULT CPrintSys::DeleteInstance(const CInstance& Instance, long lFlags)
{ 
    return WBEM_E_PROVIDER_NOT_CAPABLE; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\atprov\printer.cpp ===
/******************************************************************
   Printer.CPP -- WMI provider class implementation

   Generated by Microsoft WMI Code Generation Engine
  
   TO DO: - See individual function headers
          - When linking, make sure you link to framedyd.lib & 
            msvcrtd.lib (debug) or framedyn.lib & msvcrt.lib (retail).

   Description: 
   
  
  
******************************************************************/

#include "pchealth.h"
#include "Printer.h"
#include "exdisp.h"


/////////////////////////////////////////////////////////////////////////////
//  tracing stuff

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile
#define TRACE_ID    DCID_PRINTERDRIVER


/////////////////////////////////////////////////////////////////////////////
//  initialization

CPrinter MyPrinterSet(PROVIDER_NAME_PRINTER, PCH_NAMESPACE);


/////////////////////////////////////////////////////////////////////////////
//  Property names

// PCH 
const static WCHAR *c_wszDate         = L"Date";
const static WCHAR *c_wszDefault      = L"Default";
const static WCHAR *c_wszFilename     = L"Filename";
const static WCHAR *c_wszManufacturer = L"Manufacturer";
const static WCHAR *c_wszName         = L"Name";
const static WCHAR *c_wszPath         = L"Path";
const static WCHAR *c_wszPaused       = L"Paused";
const static WCHAR *c_wszSize         = L"Size";
const static WCHAR *c_wszVersion      = L"Version";
const static WCHAR *c_wszSpooler      = L"SpoolEnabled";
const static WCHAR *c_wszNetwork      = L"Network";
const static WCHAR *c_wszNSTimeout    = L"NSTimeout";
const static WCHAR *c_wszRetryTimeout = L"RetryTimeout";

// Win32
const static WCHAR *c_wszPortName     = L"PortName";
const static WCHAR *c_wszFileSize     = L"FileSize";
const static WCHAR *c_wszLastModified = L"LastModified";
const static WCHAR *c_wszDeviceID     = L"DeviceID";


// method parameters
const static WCHAR *c_wszURL          = L"strURL";
const static WCHAR *c_wszRetVal       = L"ReturnValue";
const static WCHAR *c_wszEnable       = L"fEnable";
const static WCHAR *c_wszTxTimeoutP   = L"uitxTimeout";
const static WCHAR *c_wszDNSTimeoutP  = L"uidnsTimeout";

// misc
const static TCHAR *c_szRegPathPrn    = _T("SYSTEM\\CurrentControlSet\\Control\\Print\\Printers\\");
const static TCHAR *c_szTxTimeout     = _T("txTimeout");
const static TCHAR *c_szDNSTimeout    = _T("dnsTimeout");

CComBSTR           g_bstrDeviceID     = L"DeviceID";
CComBSTR           g_bstrAttrib       = L"Attributes";


//////////////////////////////////////////////////////////////////////////////
// utility functions

// ***************************************************************************
// ***** IMPORTANT NOTE *****
//  You must free the value you get returned via ppPrnInfo via MyFree()
HRESULT GetPrinterInfo(LPTSTR szPrinter, LPBYTE *ppPrnInfo, 
                       HANDLE *phPrinter, DWORD dwLevel)
{
    USES_CONVERSION;
    TraceFunctEnter("GetPrinterInfo");

    HRESULT         hr = NOERROR;
    HANDLE          hPrinter = INVALID_HANDLE_VALUE;
    LPBYTE          pbBuff = NULL;
    DWORD           cbRead, cbNeed;
    BOOL            fOk;

    if (szPrinter == NULL)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    // yay!  Now we have a printer name we can call OpenPrinter with.
    fOk = OpenPrinter(szPrinter, &hPrinter, NULL);
    if (fOk == FALSE)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ErrorTrace(TRACE_ID, "Unable to open printer %ls: 0x%08x", szPrinter,
                   hr);
        goto done;
    }

    // only need to get this if the user wants it...
    if (ppPrnInfo != NULL)
    {
        // GetPrinter expects a buffer larger than PRINTER_INFO_2 all by itself...
        //  So gotta figure out how big of a buffer it wants and allocate it...
        fOk = GetPrinter(hPrinter, dwLevel, NULL, 0, &cbNeed);
        if (fOk == FALSE && GetLastError() != ERROR_INSUFFICIENT_BUFFER)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            ErrorTrace(TRACE_ID, "Unable to get printer info for %ls: 0x%08x", 
                       szPrinter, hr);
            goto done;
        }

        pbBuff = (LPBYTE)MyAlloc(cbNeed);
        if (pbBuff == NULL)
        {
            hr = E_OUTOFMEMORY;
            ErrorTrace(TRACE_ID, "Out of memory allocating buffer for printer data"); 
            goto done;
        }

        fOk = GetPrinter(hPrinter, dwLevel, pbBuff, cbNeed, &cbRead);
        if (fOk == FALSE || cbRead > cbNeed)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            ErrorTrace(TRACE_ID, "Unable to get printer info for %ls: 0x%08x", 
                       szPrinter, hr);
            goto done;
        }

        *ppPrnInfo = pbBuff;
        pbBuff = NULL;
    }

    if (phPrinter != NULL)
    {
        *phPrinter = hPrinter;
        hPrinter = INVALID_HANDLE_VALUE;
    }

done:
    if (pbBuff != NULL)
        MyFree(pbBuff);
    if (hPrinter != INVALID_HANDLE_VALUE)
        ClosePrinter(hPrinter);

    TraceFunctLeave();
    return hr;
}

// ***************************************************************************
HRESULT FindJobError(HANDLE hPrinter, DWORD cJobs, LPTSTR szUser, 
                     DWORD *pdwStatus, DWORD *pdwID)
{
    USES_CONVERSION;
    TraceFunctEnter("FindJobError");

    JOB_INFO_2  *rgJobInfo = NULL;
    HRESULT     hr = NOERROR;
    DWORD       cbNeed, cbRead, cFetched, i;
    BOOL        fOk;

    if (szUser == NULL || pdwStatus == NULL || pdwID == NULL)
    {
        ErrorTrace(TRACE_ID, "Invalid parameters");
        hr = E_INVALIDARG;
        goto done;
    }

    // EnumJobs requires a random amount of space to fill up.  Find out 
    //  how much it wants this time.
    fOk = EnumJobs(hPrinter, 0, cJobs, 2, NULL, 0, &cbNeed, &cFetched);
    if (fOk == FALSE && GetLastError() != ERROR_INSUFFICIENT_BUFFER)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ErrorTrace(TRACE_ID, "EnumJobs failed: 0x%08x", hr);
        goto done;
    }

    rgJobInfo = (JOB_INFO_2 *)MyAlloc(cbNeed);
    if (rgJobInfo == NULL)
    {
        hr = E_OUTOFMEMORY;
        ErrorTrace(TRACE_ID, "Out of memory");
        goto done;
    }

    // actually get the data
    fOk = EnumJobs(hPrinter, 0, cJobs, 2, (LPBYTE)rgJobInfo, cbNeed, &cbRead,
                   &cFetched);
    if (fOk == FALSE)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ErrorTrace(TRACE_ID, "EnumJobs failed: 0x%08x", hr);
        goto done;
    }

    // we are looking for two things:

    //  if the current user has job that failed
    for(i = 0; i < cJobs; i++)
    {
        if (rgJobInfo[i].pUserName != NULL && 
            _tcscmp(rgJobInfo[i].pUserName, szUser) == 0)
        {
            if ((rgJobInfo[i].Status & (JOB_STATUS_PAUSED | 
                                        JOB_STATUS_DELETING |
                                        JOB_STATUS_ERROR |
                                        JOB_STATUS_OFFLINE |
                                        JOB_STATUS_PAPEROUT |
                                        JOB_STATUS_BLOCKED_DEVQ |
                                        JOB_STATUS_PAUSED |
                                        JOB_STATUS_USER_INTERVENTION)) != 0)
            {
                *pdwID     = rgJobInfo[i].JobId;
                *pdwStatus = rgJobInfo[i].Status;
                hr = NOERROR;
                goto done;
            }   
        }
    }

    //  if anyone has a job that failed
    for(i = 0; i < cJobs; i++)
    {
        if ((rgJobInfo[i].Status & JOB_STATUS_PRINTING) != 0 && 
            (rgJobInfo[i].Status & (JOB_STATUS_ERROR |
                                    JOB_STATUS_OFFLINE |
                                    JOB_STATUS_PAPEROUT |
                                    JOB_STATUS_BLOCKED_DEVQ |
                                    JOB_STATUS_USER_INTERVENTION)) != 0)
        {
            _tcscpy(szUser, rgJobInfo[i].pUserName);
            *pdwID     = rgJobInfo[i].JobId;
            *pdwStatus = rgJobInfo[i].Status;
            hr = NOERROR;
            goto done;
        }
    }

    *pdwID     = (DWORD)-1;
    *pdwStatus = 0;


done:
    if (rgJobInfo != NULL)
        MyFree(rgJobInfo);
    TraceFunctLeave();
    return hr;
}


//////////////////////////////////////////////////////////////////////////////
// construction / destruction

// ***************************************************************************
CPrinter::CPrinter (LPCWSTR lpwszName, LPCWSTR lpwszNameSpace) :
    Provider(lpwszName, lpwszNameSpace)
{
    m_pParamOut = NULL;
    m_pCurrent  = NULL;
    m_pParamIn  = NULL;
    m_lFlags    = 0;
}

// ***************************************************************************
CPrinter::~CPrinter ()
{
}


//////////////////////////////////////////////////////////////////////////////
// internal methods

// ****************************************************************************
HRESULT CPrinter::GetInstanceData(IWbemClassObjectPtr pObj, CInstance *pInst)
{
    USES_CONVERSION;
    TraceFunctEnter("CPrinter::GetInstanceData");

    IWbemClassObjectPtr     pFileObj = NULL;
    PRINTER_INFO_2          *pPrnInfo2 = NULL;
    PRINTER_INFO_5          *pPrnInfo5 = NULL;
    struct _stat            filestat;
    CComVariant             varValue;
    CComBSTR                bstrPrinterDriverWithPath;
    CComBSTR                bstrPrinterDriver;
    CComBSTR                bstrProperty;
    HRESULT                 hr = WBEM_S_NO_ERROR;
    DWORD                   dwStatus, dwErr;
    ULONG                   ulPrinterRetVal = 0;
    ULONG                   uiReturn = 0;
    TCHAR                   szDeviceID[MAX_PATH];
    TCHAR                   szBuffer[MAX_PATH];
    TCHAR                   *pchToken;
    BOOL                    fDriverFound;
    BOOL                    fLocal = TRUE;

    // ** name
    CopyProperty(pObj, c_wszDeviceID, pInst, c_wszName);

    // ** path
    CopyProperty(pObj, c_wszPortName, pInst, c_wszPath);

    // ** spoolenabled
    CopyProperty(pObj, c_wszSpooler, pInst, c_wszSpooler);

    
    // get the attribute property from the passed in printer object.  With that
    //  we can get all sorts of info (default, network / local, etc)
    hr = pObj->Get(g_bstrAttrib, 0, &varValue, NULL, NULL);
    if (FAILED(hr))
    {
        ErrorTrace(TRACE_ID, "Unable to get attribute property from WMI: 0x%08x",
                   hr);
    }

    else if (V_VT(&varValue) != VT_I4)
    {
        hr = VariantChangeType(&varValue, &varValue, 0, VT_I4);
        if (FAILED(hr))
            ErrorTrace(TRACE_ID, "Unable to convert type: 0x%08x", hr);
    }

    if (SUCCEEDED(hr))
    {
        DWORD dwAttribs;

        dwAttribs = V_I4(&varValue);


        // ** default

        varValue = VARIANT_FALSE;
        if ((dwAttribs & PRINTER_ATTRIBUTE_DEFAULT) != 0)
            varValue = VARIANT_TRUE;

        if (pInst->SetVariant(c_wszDefault, varValue) == FALSE)
            ErrorTrace(TRACE_ID, "SetVariant on Default failed");

           
        // ** network
        
        varValue = VARIANT_FALSE;
        if ((dwAttribs & PRINTER_ATTRIBUTE_NETWORK) != 0)
        {
            varValue = VARIANT_TRUE;
            fLocal   = FALSE;
        }

        if (pInst->SetVariant(c_wszNetwork, varValue) == FALSE)
            ErrorTrace(TRACE_ID, "SetVariant on Network failed");
    }

    // we need the deviceID to do a whole bunch of stuff... 
    varValue.Clear();
    hr = pObj->Get(g_bstrDeviceID, 0, &varValue, NULL, NULL);
    if (FAILED(hr))
    {
        ErrorTrace(TRACE_ID, "Unable to get attribute property from WMI: 0x%08x",
                   hr);
    }
    else if (V_VT(&varValue) != VT_BSTR)
    {
        hr = VariantChangeType(&varValue, &varValue, 0, VT_BSTR);
        if (FAILED(hr))
            ErrorTrace(TRACE_ID, "Unable to convert type: 0x%08x", hr);
    }

    if (SUCCEEDED(hr))
    {
        // since we're going to need it a lot as a TCHAR, convert the
        //  name of the printer to one... 
        _tcscpy(szDeviceID, OLE2T(V_BSTR(&varValue)));
    
        // ** paused

        hr = GetPrinterInfo(szDeviceID, (LPBYTE *)&pPrnInfo2, NULL, 2);
        if (SUCCEEDED(hr))
        {
            varValue.Clear();
            varValue = VARIANT_FALSE;
            if ((pPrnInfo2->Status & PRINTER_STATUS_PAUSED) != 0)
                varValue = VARIANT_TRUE;

            if (pInst->SetVariant(c_wszPaused, varValue) == FALSE)
                ErrorTrace(TRACE_ID, "SetVariant on Paused failed");

            MyFree(pPrnInfo2);
            pPrnInfo2 = NULL;
        }


        // ** timeout values

        hr = GetPrinterInfo(szDeviceID, (LPBYTE *)&pPrnInfo5, NULL, 5);
        if (SUCCEEDED(hr))
        {
            varValue.Clear();
            
            V_VT(&varValue) = VT_I4;

            V_I4(&varValue) = pPrnInfo5->DeviceNotSelectedTimeout;
            if (pInst->SetVariant(c_wszNSTimeout, varValue) == FALSE)
                ErrorTrace(TRACE_ID, "SetVariant on NSTimeout failed");


            V_I4(&varValue) = pPrnInfo5->TransmissionRetryTimeout;
            if (pInst->SetVariant(c_wszRetryTimeout, varValue) == FALSE)
                ErrorTrace(TRACE_ID, "SetVariant on RetryTimeout failed");

            MyFree(pPrnInfo5);
            pPrnInfo5 = NULL;
        }


        // ** filename + others

        //  Now call GetProfileString to get the Driver
        varValue.Clear();
        if (GetProfileString(_T("Devices"), szDeviceID, _T("\0"), szBuffer, 
                             MAX_PATH) > 1)
        {
            //  szBuffer contains a string of two tokens, first the driver, 
            //   second the PathName

            //  Get the driver
            pchToken = _tcstok(szBuffer, _T(","));
            if(pchToken != NULL)
            {
                // Got the Driver Name
                bstrPrinterDriver = pchToken;
                varValue = pchToken;
            

                //  ** set the filename 

                if (pInst->SetVariant(c_wszFilename, varValue) == FALSE)
                    ErrorTrace(TRACE_ID, "SetVariant on FileName failed");

                // in order to get the file properties, we have to construct
                //  the full path to the file
                bstrPrinterDriver.Append(L".drv");
                fDriverFound = getCompletePath(bstrPrinterDriver, 
                                               bstrPrinterDriverWithPath);
                if (fDriverFound)
                {
                    //  GetCIMDataFile Function fetches properties of this file.
                    hr = GetCIMDataFile(bstrPrinterDriverWithPath, &pFileObj);
                    if (SUCCEEDED(hr))
                    {
                        // ** version

                        CopyProperty(pFileObj, c_wszVersion, 
                                     pInst, c_wszVersion);


                        // ** filesize

                        CopyProperty(pFileObj, c_wszFileSize, 
                                     pInst, c_wszSize);


                        // ** date

                        CopyProperty(pFileObj, c_wszLastModified, 
                                     pInst, c_wszDate);


                        // ** manufacturer

                        CopyProperty(pFileObj, c_wszManufacturer, 
                                     pInst, c_wszManufacturer);
                    } 
                }
            } 
        }
    }

    TraceFunctLeave();
    return hr;
}


// ****************************************************************************
HRESULT CPrinter::GetStatus(void)
{
    USES_CONVERSION;
    TraceFunctEnter("CPrinter::GetStatus");
    
    PRINTER_INFO_2  *pPrnInfo = NULL;
    HRESULT         hr = NOERROR;
    VARIANT         var;
    HANDLE          hPrinter = INVALID_HANDLE_VALUE;
    DWORD           dwStatus;
    DWORD           dwLocation;
    TCHAR           szPrinter[1024];

    VariantInit(&var);

    if (m_pCurrent == NULL || m_pParamOut == NULL)
    {
        ErrorTrace(TRACE_ID, "Parameter objects not set.");
        hr = E_FAIL;
        goto done;
    }

    if (m_pCurrent->GetVariant(c_wszName, var) == FALSE)
    {
        ErrorTrace(TRACE_ID, "Unable to fetch printer name from m_pCurrent");
        hr = E_FAIL;
        goto done;
    }

    if (V_VT(&var) != VT_BSTR)
    {
        hr = VariantChangeType(&var, &var, 0, VT_BSTR);
        if (FAILED(hr))
        {
            ErrorTrace(TRACE_ID, "VariantChangeType failed: 0x%08x", hr);
            goto done;
        }
    }

    _tcscpy(szPrinter, OLE2T(V_BSTR(&var)));

    // get the printer info structure
    hr = GetPrinterInfo(szPrinter, (LPBYTE *)&pPrnInfo, &hPrinter, 2);
    if (FAILED(hr))
        goto done;

    dwStatus = pPrnInfo->Status;

    // if the status is not in the error state, then we need to look at the 
    //  list of print jobs available
    if (dwStatus == 0)
    {
        DWORD   dwJobID;
        DWORD   cbUser;
        TCHAR   szUser[512];

        cbUser = 512;
        GetUserName(szUser, &cbUser);
        hr = FindJobError(hPrinter, pPrnInfo->cJobs, szUser, &dwStatus, 
                          &dwJobID);
        if (FAILED(hr))
            goto done;
    }

    VariantClear(&var);
    V_VT(&var) = VT_I4;
    V_I4(&var) = dwStatus;

    if (m_pParamOut->SetVariant(c_wszRetVal, var) == FALSE)
    {
        ErrorTrace(TRACE_ID, "Unable to set return val object");
        hr = E_FAIL;
        goto done;
    }

done:
    VariantClear(&var);
    if (pPrnInfo != NULL)
        MyFree(pPrnInfo);
    if (hPrinter != INVALID_HANDLE_VALUE)
        ClosePrinter(hPrinter);

    TraceFunctLeave();
    return hr;
}

// ****************************************************************************
HRESULT CPrinter::RemovePause(void)
{
    USES_CONVERSION;
    TraceFunctEnter("CPrinter::RemovePause");

    PRINTER_INFO_2  *pPrnInfo = NULL;
    HRESULT         hr = NOERROR;
    VARIANT         var;
    HANDLE          hPrinter = INVALID_HANDLE_VALUE;
    BOOL            fOk;

    VariantInit(&var);

    if (m_pCurrent == NULL)
    {
        ErrorTrace(TRACE_ID, "Parameter object not set.");
        hr = E_FAIL;
        goto done;
    }

    if  (m_pCurrent->GetVariant(c_wszName, var) == FALSE)
    {
        ErrorTrace(TRACE_ID, "Unable to fetch printer name from m_pCurrent");
        hr = E_FAIL;
        goto done;
    }

    if (V_VT(&var) != VT_BSTR)
    {
        hr = VariantChangeType(&var, &var, 0, VT_BSTR);
        if (FAILED(hr))
        {
            ErrorTrace(TRACE_ID, "VariantChangeType failed: 0x%08x", hr);
            goto done;
        }
    }

    hr = GetPrinterInfo(OLE2T(V_BSTR(&var)), (LPBYTE *)&pPrnInfo, &hPrinter, 
                        2);
    if (FAILED(hr))
        goto done;

    if (pPrnInfo->Status == PRINTER_STATUS_PAUSED)
    {
        fOk = SetPrinter(hPrinter, 0, NULL, PRINTER_CONTROL_RESUME);
        if (fOk == FALSE)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            ErrorTrace(TRACE_ID, "SetPrinter failed: 0x%08x", hr);
            goto done;
        }
    }

done:
    VariantClear(&var);
    if (pPrnInfo != NULL)
        MyFree(pPrnInfo);
    if (hPrinter != INVALID_HANDLE_VALUE)
        ClosePrinter(hPrinter);

    TraceFunctLeave();
    return hr;
}

// ****************************************************************************
HRESULT CPrinter::PrinterProperties(void)
{
    USES_CONVERSION;
    TraceFunctEnter("CPrinter::PrinterProperties");

    PRINTER_INFO_2  *pPrnInfo = NULL;
    LPDEVMODE       pDevMode = NULL;
    HRESULT         hr = NOERROR;
    VARIANT         var;
    HANDLE          hPrinter = INVALID_HANDLE_VALUE;
    DWORD           cbDevMode;

    VariantInit(&var);

    if (m_pCurrent == NULL)
    {
        ErrorTrace(TRACE_ID, "Parameter object not set.");
        hr = E_FAIL;
        goto done;
    }
    
    if  (m_pCurrent->GetVariant(c_wszName, var) == FALSE)
    {
        ErrorTrace(TRACE_ID, "Unable to fetch printer name from m_pCurrent");
        hr = E_FAIL;
        goto done;
    }

    if (V_VT(&var) != VT_BSTR)
    {
        hr = VariantChangeType(&var, &var, 0, VT_BSTR);
        if (FAILED(hr))
        {
            ErrorTrace(TRACE_ID, "VariantChangeType failed: 0x%08x", hr);
            goto done;
        }
    }

    hr = GetPrinterInfo(OLE2T(V_BSTR(&var)), (LPBYTE *)pPrnInfo, &hPrinter, 2);
    if (FAILED(hr))
        goto done;


    cbDevMode = DocumentProperties(NULL, hPrinter, OLE2T(V_BSTR(&var)), 
                                   NULL, NULL, 0);
    pDevMode = (LPDEVMODE)MyAlloc(cbDevMode);
    if (pDevMode == NULL)
    {
        hr = E_OUTOFMEMORY;
        ErrorTrace(TRACE_ID, "Out of memory allocating DEVMODE structure");
        goto done;
    }

    // ok, call this for real this time...
    if (DocumentProperties(NULL, hPrinter, OLE2T(V_BSTR(&var)), 
                           pDevMode, NULL, DM_PROMPT) == IDOK)
    {
        // nothing to free here cuz pPrnInfo->pDevMode points into the memory blob
        //  that pPrnInfo points to... 
        pPrnInfo->pDevMode = pDevMode;

        if (SetPrinter(hPrinter, 2, (LPBYTE)pPrnInfo, 0) == FALSE)
        {
            hr = E_OUTOFMEMORY;
            ErrorTrace(TRACE_ID, "Unable to set new printer info.");
            goto done;
        }
    }
    
done:
    VariantClear(&var);
    if (pPrnInfo != NULL)
        MyFree(pPrnInfo);
    if (pDevMode != NULL)
        MyFree(pDevMode);
    if (hPrinter != INVALID_HANDLE_VALUE)
        ClosePrinter(hPrinter);
    TraceFunctLeave();
    return hr;
}

// ****************************************************************************
HRESULT CPrinter::SetAsDefault(TCHAR *szOldDefault, DWORD cchOldDefault, 
                               BOOL fSetOldDefault)
{
    USES_CONVERSION;
    TraceFunctEnter("CPrinter::SetAsDefault");

    HRESULT hr = NOERROR;
    VARIANT var;
    DWORD   dw;
    TCHAR   szPrinter[1024], szNewDefault[1024];
    BOOL    fOk;

    VariantInit(&var);

    if (m_pCurrent == NULL)
    {
        ErrorTrace(TRACE_ID, "Parameter object not set.");
        hr = E_FAIL;
        goto done;
    }

    // See if the caller wants to know what the old default is or wants to set
    //  the old default...
    if (szOldDefault != NULL)
    {
        // see if we want to set the default
        if (fSetOldDefault)
        {
            fOk = WriteProfileString(_T("Windows"), _T("Device"), szOldDefault);
            if (fOk == FALSE)
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                ErrorTrace(TRACE_ID, "Failed to write old default printer: 0x%08x", 
                           hr);
            }
            
            // can goto done here cuz we don't need to do anything else... 
            goto done;
        }

        // or maybe we just want to grab is and then set m_pCurrent to be the 
        //  default
        else
        {
            dw = GetProfileString(_T("Windows"), _T("Device"), _T("\0"), 
                                  szOldDefault, cchOldDefault);
            if (dw <= 1)
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                ErrorTrace(TRACE_ID, "Failed to fetch current default: 0x%08x", 
                           hr);
                goto done;
            }
        }
    }

    // if we're here, then we gotta set the printer pointed to by m_pCurrent as 
    //  the default printer, so fetch the name of the printer we want to be the
    //  default
    if (m_pCurrent->GetVariant(c_wszName, var) == FALSE)
    {
        ErrorTrace(TRACE_ID, "Unable to fetch printer name from m_pCurrent");
        hr = E_FAIL;
        goto done;
    }
    
    if (V_VT(&var) != VT_BSTR)
    {
        hr = VariantChangeType(&var, &var, 0, VT_BSTR);
        if (FAILED(hr))
        {
            ErrorTrace(TRACE_ID, "VariantChangeType failed: 0x%08x", hr);
            goto done;
        }
    }

    // get the printer info from win.ini
    dw = GetProfileString(_T("Devices"), OLE2T(V_BSTR(&var)), _T("\0"), 
                          szPrinter, sizeof(szPrinter) / sizeof(TCHAR));
    if (dw <= 1)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ErrorTrace(TRACE_ID, "Failed to fetch current default: 0x%08x", hr);
        goto done;
    }

    // build a string & slam it back into win.ini
    wsprintf(szNewDefault, "%s,%s", OLE2T(V_BSTR(&var)), szPrinter);
    fOk = WriteProfileString(_T("Windows"), _T("Device"), szNewDefault);
    if (fOk == FALSE)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ErrorTrace(TRACE_ID, "Failed to write new default printer: 0x%08x", 
                   hr);
    }

    // got to notify everyone in existance (well, all the top level windows 
    //  anyway) that we changed the default printer...
    SendMessageTimeout(HWND_BROADCAST, WM_WININICHANGE, 0L, 
                       (LPARAM)(LPCTSTR)_T("windows"), SMTO_NORMAL, 1000, 
                       NULL);

done:
    VariantClear(&var);
    TraceFunctLeave();
    return hr;
}

// ****************************************************************************
// ***  NOTE: this method doesn't work on WinNT cuz WinMgmt runs as a service 
//            which has different printer settings / permissions than the user
//            account
HRESULT CPrinter::TestPrinter(void)
{
    TraceFunctEnter("CPrinter::TestPrinter");

    IWebBrowser2    *pwb = NULL;
    READYSTATE      rs;
    VARIANT         varFlags, varOpt, varURL;
    HRESULT         hr = NOERROR;
    CLSID           clsid;
    DWORD           dwStart;
    TCHAR           szDefault[1024];

    VariantInit(&varFlags);
    VariantInit(&varURL);
    VariantInit(&varOpt);

    if (m_pParamIn == NULL)
    {
        ErrorTrace(TRACE_ID, "Parameter object not set.");
        hr = E_FAIL;
        goto done;
    }

    if (m_pParamIn->GetVariant(c_wszURL, varURL) == FALSE)
    {
        ErrorTrace(TRACE_ID, "strURL parameter not present.");
        hr = E_FAIL;
        goto done;
    }

    hr = VariantChangeType(&varURL, &varURL, 0, VT_BSTR);
    if (FAILED(hr))
    {
        ErrorTrace(TRACE_ID, "unable to convert strURL to string");
        goto done;
    }

    // the URL should be at least 4 characters long in order for it to be a
    //  valid file path.  Need 3 characters for drive path & at least 1 for
    //  the filename (as in 'd:\a')
    if (SysStringLen(V_BSTR(&varURL)) < 4)
    {
        ErrorTrace(TRACE_ID, "strURL parameter < 4 characters.");
        hr = E_INVALIDARG;
        goto done;
    }

    // we obviously need a web browser object, so make one
    hr = CoCreateInstance(CLSID_InternetExplorer, NULL, CLSCTX_LOCAL_SERVER, 
                          IID_IWebBrowser2, (LPVOID *)&pwb);
    if (FAILED(hr))
    {
        ErrorTrace(TRACE_ID, "Unable to CoCreate web browser control: 0x%08x", hr);
        goto done;
    }

    // load the URL
    V_VT(&varFlags)  = VT_I4;
    V_I4(&varFlags)  = navNoHistory;
    V_VT(&varOpt)    = VT_ERROR;
    V_ERROR(&varOpt) = DISP_E_PARAMNOTFOUND;
    hr = pwb->Navigate2(&varURL, &varOpt, &varOpt, &varOpt, &varOpt);
    if (FAILED(hr))
    {
        ErrorTrace(TRACE_ID, "Unable to Navigate to URL '%ls': 0x%08x", 
                   V_BSTR(&varURL), hr);
        goto done;
    }

    // wait for a maximum of 5 minutes for this URL to come in...
    for(dwStart = GetTickCount(); GetTickCount() - dwStart <= 300000;)
    {
        hr = pwb->get_ReadyState(&rs);
        if (FAILED(hr))
        {
            ErrorTrace(TRACE_ID, "Unable to get web browser state: 0x%08x", hr);
            goto done;
        }

        if (rs == READYSTATE_COMPLETE)
            break;
    }

    // make sure we didn't timeout...
    if (rs != READYSTATE_COMPLETE)
    {
        ErrorTrace(TRACE_ID, "Timeout waiting for browser to load URL");
        hr = E_FAIL;
        goto done;
    }

    // since we aren't prompting the user, we need to temporarily set the
    //  default printer to be the one we want to test
    hr = this->SetAsDefault(szDefault, sizeof(szDefault) / sizeof(TCHAR), FALSE);
    if (FAILED(hr))
        goto done;

    // do the print
    hr = pwb->ExecWB(OLECMDID_PRINT, OLECMDEXECOPT_DONTPROMPTUSER, &varOpt, &varOpt);
    if (FAILED(hr))
    {
        ErrorTrace(TRACE_ID, "Unable to print: 0x%08x", hr);
        goto done;
    }

    // revert back to the original printer
    hr = this->SetAsDefault(szDefault, sizeof(szDefault) / sizeof(TCHAR), TRUE);
    if (FAILED(hr))
        goto done;

done:
    VariantClear(&varURL);
    if (pwb != NULL)
        pwb->Release();

    TraceFunctLeave();
    return hr;
}

// *****************************************************************************
HRESULT CPrinter::EnableSpooler(void)
{
    USES_CONVERSION;
    TraceFunctEnter("CPrinter::EnableSpooler");

    PRINTER_INFO_2  *pPrnInfo = NULL;
    HANDLE          hPrinter = INVALID_HANDLE_VALUE;
    VARIANT         varEnable, varName;
    HRESULT         hr = NOERROR;

    VariantInit(&varEnable);
    VariantInit(&varName);

    // get the parameter
    if (m_pParamIn == NULL || m_pCurrent == NULL)
    {
        ErrorTrace(TRACE_ID, "Parameter object not set.");
        hr = E_FAIL;
        goto done;
    }

    if (m_pParamIn->GetVariant(c_wszEnable, varEnable) == FALSE)
    {
        ErrorTrace(TRACE_ID, "strURL parameter not present.");
        hr = E_FAIL;
        goto done;
    }

    if (V_VT(&varEnable) != VT_BOOL)
    {
        hr = VariantChangeType(&varEnable, &varEnable, 0, VT_BOOL);
        if (FAILED(hr))
        {
            ErrorTrace(TRACE_ID, "unable to convert fEnable to bool: 0x%08x",
                       hr);
            goto done;
        }
    }

    if  (m_pCurrent->GetVariant(c_wszName, varName) == FALSE)
    {
        ErrorTrace(TRACE_ID, "Unable to fetch printer name from m_pCurrent");
        hr = E_FAIL;
        goto done;
    }

    if (V_VT(&varName) != VT_BSTR)
    {
        hr = VariantChangeType(&varName, &varName, 0, VT_BSTR);
        if (FAILED(hr))
        {
            ErrorTrace(TRACE_ID, "VariantChangeType failed: 0x%08x", hr);
            goto done;
        }
    }
    
    hr = GetPrinterInfo(OLE2T(V_BSTR(&varName)), (LPBYTE *)&pPrnInfo, 
                        &hPrinter, 2);
    if (FAILED(hr))
        goto done;

    if (V_BOOL(&varEnable) == VARIANT_FALSE)
        pPrnInfo->Attributes &= ~PRINTER_ATTRIBUTE_DIRECT;
    else
        pPrnInfo->Attributes |= PRINTER_ATTRIBUTE_DIRECT;

    if (SetPrinter(hPrinter, 2, (LPBYTE)pPrnInfo, 0) == FALSE)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ErrorTrace(TRACE_ID, "SetPrinter failed: 0x%08x", hr);
        goto done;
    }

done:
    VariantClear(&varName);
    VariantClear(&varEnable);
    if (pPrnInfo != NULL)
        MyFree(pPrnInfo);
    if (hPrinter != INVALID_HANDLE_VALUE)
        ClosePrinter(hPrinter);
    

    TraceFunctLeave();
    return hr;
}

// *****************************************************************************
HRESULT CPrinter::SetTimeouts(void)
{
    USES_CONVERSION;
    TraceFunctEnter("CPrinter::SetTimeouts");

    PRINTER_INFO_5  *pPrnInfo5 = NULL;
    HRESULT         hr = NOERROR;
    VARIANT         varName, varDNS, varTX;
    HANDLE          hPrinter = INVALID_HANDLE_VALUE;

    VariantInit(&varName);
    VariantInit(&varDNS);
    VariantInit(&varTX);

    // get the parameter
    if (m_pParamIn == NULL || m_pCurrent == NULL)
    {
        ErrorTrace(TRACE_ID, "Parameter object not set.");
        hr = E_FAIL;
        goto done;
    }

    // get uiTxTimeout
    if (m_pParamIn->GetVariant(c_wszTxTimeoutP, varTX) == FALSE)
    {
        ErrorTrace(TRACE_ID, "uiTxTimeout parameter not present.");
        hr = E_FAIL;
        goto done;
    }

    if (V_VT(&varTX) != VT_I4)
    {
        hr = VariantChangeType(&varTX, &varTX, 0, VT_I4);
        if (FAILED(hr))
        {
            ErrorTrace(TRACE_ID, "VariantChangeType failed: 0x%08x",
                       hr);
            goto done;
        }
    }

    // get uiDNSTimeout
    if (m_pParamIn->GetVariant(c_wszDNSTimeoutP, varDNS) == FALSE)
    {
        ErrorTrace(TRACE_ID, "uiDNSTimeout parameter not present.");
        hr = E_FAIL;
        goto done;
    }

    if (V_VT(&varDNS) != VT_I4)
    {
        hr = VariantChangeType(&varDNS, &varDNS, 0, VT_I4);
        if (FAILED(hr))
        {
            ErrorTrace(TRACE_ID, "VariantChangeType failed: 0x%08x",
                       hr);
            goto done;
        }
    }

    // get Name
    if  (m_pCurrent->GetVariant(c_wszName, varName) == FALSE)
    {
        ErrorTrace(TRACE_ID, "Unable to fetch printer name from m_pCurrent");
        hr = E_FAIL;
        goto done;
    }

    if (V_VT(&varName) != VT_BSTR)
    {
        hr = VariantChangeType(&varName, &varName, 0, VT_BSTR);
        if (FAILED(hr))
        {
            ErrorTrace(TRACE_ID, "VariantChangeType failed: 0x%08x", hr);
            goto done;
        }
    }

    hr = GetPrinterInfo(OLE2T(V_BSTR(&varName)), (LPBYTE *)&pPrnInfo5, 
                        &hPrinter, 5);
    if (FAILED(hr))
        goto done;

    pPrnInfo5->TransmissionRetryTimeout = V_I4(&varTX);
    pPrnInfo5->DeviceNotSelectedTimeout = V_I4(&varDNS);

    if (SetPrinter(hPrinter, 5, (LPBYTE)pPrnInfo5, 0) == FALSE)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ErrorTrace(TRACE_ID, "Unable to set printer info: 0x%08x", hr);
        goto done;
    }

done:
    VariantClear(&varName);
    VariantClear(&varDNS);
    VariantClear(&varTX);
    if (pPrnInfo5 != NULL)
        MyFree(pPrnInfo5);
    if (hPrinter != INVALID_HANDLE_VALUE)
        ClosePrinter(hPrinter);

    TraceFunctLeave();
    return hr;
}



//////////////////////////////////////////////////////////////////////////////
// exposed methods

// *****************************************************************************
HRESULT CPrinter::EnumerateInstances(MethodContext* pMethodContext, long lFlags)
{
    USES_CONVERSION;
    TraceFunctEnter("CPrinter::EnumerateInstances");

    IEnumWbemClassObject    *pEnumInst = NULL;
    IWbemClassObjectPtr     pObj = NULL;                   
    CComBSTR                bstrPrinterQuery;
    HRESULT                 hr = WBEM_S_NO_ERROR;
    ULONG                   ulPrinterRetVal = 0;

    // Execute the query to get DeviceID, PortName from the Win32_Printer class
    bstrPrinterQuery = L"Select DeviceID, PortName, SpoolEnabled, Status, Attributes FROM win32_printer";
    hr = ExecWQLQuery(&pEnumInst, bstrPrinterQuery);
    if (FAILED(hr))
        goto done;
    
    //  Enumerate the instances from pEnumInstance
    while(pEnumInst->Next(WBEM_INFINITE, 1, &pObj, &ulPrinterRetVal) == WBEM_S_NO_ERROR)
    {
        // Create a new instance of PCH_PrinterDriver Class based on the 
        //  passed-in MethodContext
        CInstancePtr   pInst(CreateNewInstance(pMethodContext), FALSE);

        // original code didn't really care if this failed, so neither do I...
        hr = GetInstanceData(pObj, pInst);
        
        //  All the properties are set. Commit the instance
        hr = pInst->Commit();
        if(FAILED(hr))
            ErrorTrace(TRACE_ID, "Could not commit instance: 0x%08x", hr);

        // Ok, so WMI does not follow it's own docs on how GetObject
        //  works.  According to them, we should release this object here.  But
        //  if I try, winmgmt GPFs.
        // pObj->Release();
        pObj = NULL;
    } 

done:
    if (pEnumInst != NULL)
        pEnumInst->Release();
    TraceFunctLeave();
    return hr;
}


// *****************************************************************************
HRESULT CPrinter::ExecMethod (const CInstance& Instance,
                              const BSTR bstrMethodName,
                              CInstance *pInParams, CInstance *pOutParams,
                              long lFlags)
{
    TraceFunctEnter("CPrinter::ExecMethod");

    HRESULT     hr = NOERROR;

    m_pCurrent  = (CInstance *)&Instance;
    m_pParamIn  = pInParams;
    m_pParamOut = pOutParams;
    m_lFlags    = lFlags;

    if (_wcsicmp(bstrMethodName, L"SetAsDefault") == 0)
        hr = this->SetAsDefault();

    else if (_wcsicmp(bstrMethodName, L"PrinterProperties") == 0)
        hr = this->PrinterProperties();

    else if (_wcsicmp(bstrMethodName, L"RemovePause") == 0)
        hr = this->RemovePause();

    else if (_wcsicmp(bstrMethodName, L"TestPrinter") == 0)
        hr = this->TestPrinter();

    else if (_wcsicmp(bstrMethodName, L"ErrorStatus") == 0)
        hr = this->GetStatus();

    else if (_wcsicmp(bstrMethodName, L"EnableSpooler") == 0)
        hr = this->EnableSpooler();

    else if (_wcsicmp(bstrMethodName, L"SetTimeouts") == 0)
        hr = this->SetTimeouts();

    else 
        hr = WBEM_E_INVALID_METHOD;

    if (FAILED(hr))
        goto done;

done:
    m_pCurrent  = NULL;
    m_pParamIn  = NULL;
    m_pParamOut = NULL;
    m_lFlags    = 0;

    TraceFunctLeave();
    return hr;
}

// *****************************************************************************
HRESULT CPrinter::GetObject(CInstance* pInstance, long lFlags) 
{ 
    TraceFunctEnter("CPrinter::GetObject");

    IWbemClassObjectPtr pObj = NULL;
    CComBSTR            bstrPath;
    HRESULT             hr = NOERROR;
    VARIANT             var;
    WCHAR               wszBuffer[1024], *pwszPrn, *pwszBuf;
    DWORD               i;
    BSTR                bstrPrn;

    VariantInit(&var);

    if (pInstance == NULL)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    // get the name of the printer
    if (pInstance->GetVariant(c_wszName, var) == FALSE)
    {
        ErrorTrace(TRACE_ID, "Unable to fetch printer name");
        hr = E_FAIL;
        goto done;
    }

    if (V_VT(&var) != VT_BSTR)
    {
        hr = VariantChangeType(&var, &var, 0, VT_BSTR);
        if (FAILED(hr))
        {
            ErrorTrace(TRACE_ID, "VariantChangeType failed: 0x%08x", hr);
            goto done;
        }
    }
       
    // WMI!!  It expects me to turn a printer with a name \\server\share
    //  into \\\\server\\share.  (double '\'s)
    bstrPrn = V_BSTR(&var);
    if ((bstrPrn[0] != L'\\' && bstrPrn[1] != L'\\') ||
        (bstrPrn[0] == L'\\' && bstrPrn[1] == L'\\' && bstrPrn[2] == L'\\' && 
         bstrPrn[3] == L'\\'))
    {
        wcscpy(wszBuffer, bstrPrn);
    }

    else
    {
        // ok, here's the annoying part...
        wcscpy(wszBuffer, L"\\\\\\\\");
        pwszBuf = wszBuffer + 4;
        pwszPrn = bstrPrn + 2;
        
        // actually, we only need to scan to the first '\' cuz we've already
        //  taken care of the 1st two & this needs to fit into  '\\server\share'
        while (pwszPrn != L'\0')
        {
            if (*pwszPrn == L'\\')
            {
                *pwszBuf++ = L'\\';
                break;
            }

            *pwszBuf++ = *pwszPrn++;
        }

        wcscpy(pwszBuf, pwszPrn);
    }


    // build the path to the object
    bstrPath = L"\\\\.\\root\\cimv2:Win32_Printer.DeviceID=\"";
    bstrPath.Append(wszBuffer);
    bstrPath.Append("\"");

    // fetch it
    hr = GetCIMObj(bstrPath, &pObj, lFlags);
    if (FAILED(hr))
        goto done;

    // populate the CInstance object
    hr = GetInstanceData(pObj, pInstance);
    if (FAILED(hr))
        goto done;
    
    //  All the properties are set. Commit the instance
    hr = pInstance->Commit();
    if(FAILED(hr))
        ErrorTrace(TRACE_ID, "Could not commit instance: 0x%08x", hr);

done:
    VariantClear(&var);

    // Ok, so WMI does not follow it's own docs on how GetObject
    //  works.  According to them, we should release this object here.  But
    //  if I try, winmgmt GPFs.
    // if (pObj != NULL)
    //    pObj->Release();

    TraceFunctLeave();
    return hr; 
}

// *****************************************************************************
HRESULT CPrinter::ExecQuery(MethodContext *pMethodContext, 
                            CFrameworkQuery& Query, long lFlags) 
{ 
    return WBEM_E_PROVIDER_NOT_CAPABLE; 
}

// *****************************************************************************
HRESULT CPrinter::PutInstance(const CInstance& Instance, long lFlags)
{ 
    return WBEM_E_PROVIDER_NOT_CAPABLE; 
}

// *****************************************************************************
HRESULT CPrinter::DeleteInstance(const CInstance& Instance, long lFlags)
{ 
    return WBEM_E_PROVIDER_NOT_CAPABLE; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprov\drvdefs.h ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	drvdefs.h

Abstract:
	header file containing pieces of code from msinfo codebase

Revision History:

    Brijesh Krishnaswami (brijeshk) 05/25/99
        - created
********************************************************************/

#ifndef _DRV16_H
#define _DRV16_H

#ifdef __cplusplus
extern "C" {
#endif

// defines and structs for getting User Mode drivers

#define GND_FORWARD                 0
#define GND_FIRSTINSTANCEONLY       1
#define GND_REVERSE                 2

#define IOCTL_CONNECT           1
#define IOCTL_DISCONNECT        2
#define IOCTL_GETINFO           3
#define IOCTL_GETVXDLIST        4
#define IOCTL_MAPFLAT           5

#define LAR_PAGEGRAN    0x00800000  /* Is page granular */
#define LAR_32BIT       0x00400000  /* Is 32-bit */
#define LAR_PRESENT     0x00008000  /* Is present */
#define LAR_APPL        0x00004000  /* Is normal (not a task gate) ;Internal */
#define LAR_TYPEMASK    0x00000E00  /* Selector type mask */
#define LAR_CODE        0x00000800  /* Is a code selector */
#define LAR_EXPANDDOWN  0x00000400  /* Is expand-down (data) */
#define LAR_READ        0x00000200  /* Is readable (code) */
#define LAR_WRITE       0x00000200  /* Is writeable (data) */
#define LAR_INVALID     0xff0000ff  /* Invalid (bottom bit important) */


// general util macros
#define cA(a) (sizeof(a)/sizeof(a[0]))
#define OBJAT(T, pv)    (*(T *)(pv))
#define PUN(T, v)       OBJAT(T, &(v))
#define pvAddPvCb(pv, cb) ((PVOID)((PBYTE)pv + (cb)))

typedef WORD HMODULE16;

typedef struct DRIVERINFOSTRUCT16 {
    WORD    length;
    WORD    hDriver;
    WORD    hModule;
    char    szAliasName[128];
} DRIVERINFOSTRUCT16;


// defines and structs used for getting MSDos drivers

#define DIFL_PSP        0x0001  /* It's a PSP */
#define DIFL_TSR        0x0002  /* It's a TSR (or might be) */
#define DIFL_DRV        0x0004  /* It's a device driver */

#pragma pack(1)
typedef struct ARENA {          /* DOS arena header */
    BYTE    bType;
    WORD    segOwner;
    WORD    csegSize;
    BYTE    rgbPad[3];
    char    rgchOwner[8];
} ARENA, *PARENA;

typedef struct VXDOUT {
    DWORD   dwHighLinear;
    PVOID   pvVmmDdb;
} VXDOUT, *PVXDOUT;


typedef struct VXDINFO {
    HWND    hwnd;
    FARPROC lpfnGetCurrentTibFS;
    FARPROC lpfnGetCurrentProcessId;
    FARPROC lpfnGetCurrentThreadId;
    FARPROC GetCommandLineA;
    FARPROC UnhandledExceptionFilter;
} VXDINFO;


typedef struct RMIREGS {
    union {
        struct {                    /* DWORD registers */
            DWORD   edi;
            DWORD   esi;
            DWORD   ebp;
            DWORD   res1;
            DWORD   ebx;
            DWORD   edx;
            DWORD   ecx;
            DWORD   eax;
        };

        struct {                    /* WORD registers */
            WORD    di;
            WORD    res2;
            WORD    si;
            WORD    res3;
            WORD    bp;
            WORD    res4;
            DWORD   res5;
            WORD    bx;
            WORD    res6;
            WORD    dx;
            WORD    res7;
            WORD    cx;
            WORD    res8;
            WORD    ax;
            WORD    res9;
        };

        struct {                    /* BYTE registers */
            DWORD   res10[4];       /* edi, esi, ebp, esp */
            BYTE    bl;
            BYTE    bh;
            WORD    res11;
            BYTE    dl;
            BYTE    dh;
            WORD    res12;
            BYTE    cl;
            BYTE    ch;
            WORD    res13;
            BYTE    al;
            BYTE    ah;
            WORD    res14;
        };
    };

    WORD    flags;
    WORD    es;
    WORD    ds;
    WORD    fs;
    WORD    gs;
    WORD    ip;
    WORD    cs;
    WORD    sp;
    WORD    ss;
} RMIREGS, *PRMIREGS;

#pragma pack()

// 16-bit function prototypes
LPVOID WINAPI MapLS(LPVOID);
void WINAPI UnMapLS(LPVOID);
LPVOID NTAPI MapSL(LPVOID);
void NTAPI UnMapSLFix(LPVOID pv);
HMODULE16 NTAPI GetModuleHandle16(LPCSTR);
int NTAPI GetModuleFileName16(HMODULE16 hmod, LPSTR sz, int cch);
int NTAPI GetModuleName16(HMODULE16 hmod, LPSTR sz, int cch);
WORD NTAPI GetExpWinVer16(HMODULE16 hmod);
BOOL GetDriverInfo16(WORD hDriver, DRIVERINFOSTRUCT16* pdis);
WORD GetNextDriver16(WORD hDriver, DWORD fdwFlag);
UINT AllocCodeSelector16(void);
UINT SetSelectorBase16(UINT sel, DWORD dwBase);
DWORD GetSelectorLimit16(UINT sel);
UINT SetSelectorLimit16(UINT sel, DWORD dwLimit);
UINT FreeSelector16(UINT sel);
UINT NTAPI FreeLibrary16(HINSTANCE);
void _cdecl QT_Thunk(void);
HINSTANCE WINAPI LoadLibrary16(LPCSTR);
FARPROC WINAPI GetProcAddress16(HINSTANCE, LPCSTR);
void WINAPI GetpWin16Lock(LPVOID *);

void ThunkInit(void);
UINT Int86x(UINT, PRMIREGS);
LPTSTR Token_Find(LPTSTR *);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprov\dllutils.cpp ===
#include "pchealth.h"
#include <FWcommon.h>
#include <strings.h>

#include <DllUtils.h>
#include <BrodCast.h>
#include <lmerr.h>
#include <confgmgr.h>
#include <createmutexasprocess.h>

// sets a status object with one single missing privilege
void SetSinglePrivilegeStatusObject(MethodContext* pContext, const WCHAR* pPrivilege)
{
	SAFEARRAY *psaPrivilegesReqd, *psaPrivilegesNotHeld;  
	SAFEARRAYBOUND rgsabound[1];
	rgsabound[0].cElements = 1;
	rgsabound[0].lLbound = 0;
	psaPrivilegesReqd = SafeArrayCreate(VT_BSTR, 1, rgsabound);
	psaPrivilegesNotHeld = SafeArrayCreate(VT_BSTR, 1, rgsabound);
    
    if (psaPrivilegesReqd && psaPrivilegesNotHeld)
    {
        long index = 0;
        bstr_t privilege(pPrivilege);
        SafeArrayPutElement(psaPrivilegesReqd, &index, (void*)(BSTR)privilege);
        SafeArrayPutElement(psaPrivilegesNotHeld, &index, (void*)(BSTR)privilege);
        CWbemProviderGlue::SetStatusObject(pContext, IDS_CimWin32Namespace, "Required privilege not enabled", WBEM_E_FAILED, psaPrivilegesNotHeld, psaPrivilegesReqd);
    }

    if (psaPrivilegesNotHeld) 
        SafeArrayDestroy(psaPrivilegesNotHeld);
    if (psaPrivilegesReqd)
        SafeArrayDestroy(psaPrivilegesReqd);
}

// VER_PLATFORM_WIN32s Win32s on Windows 3.1 
// VER_PLATFORM_WIN32_WINDOWS  Win32 on Windows 95
// VER_PLATFORM_WIN32_NT   Windows NT 
DWORD GetPlatformID(void) 
{
	OSVERSIONINFO OsVersion;

	OsVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	GetVersionEx((LPOSVERSIONINFO)&OsVersion);

	return OsVersion.dwPlatformId;	
}

// 3 for NT 3.51
// 4 for NT 4.0, W95 & W98
DWORD GetPlatformMajorVersion(void) 
{
	OSVERSIONINFO OsVersion;

	OsVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	GetVersionEx((LPOSVERSIONINFO)&OsVersion);

	return OsVersion.dwMajorVersion;	
}

// 0 for W95, 10 for 98
DWORD GetPlatformMinorVersion(void) 
{
	OSVERSIONINFO OsVersion;

	OsVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	GetVersionEx((LPOSVERSIONINFO)&OsVersion);

	return OsVersion.dwMinorVersion;	
}

// returns TRUE iff the current OS is Win 98+ 
// false for NT or Win 95
bool  IsWin98(void)
{
	OSVERSIONINFO OsVersion;

	OsVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	GetVersionEx((LPOSVERSIONINFO)&OsVersion);

	return (OsVersion.dwPlatformId == (VER_PLATFORM_WIN32_WINDOWS) && (OsVersion.dwMinorVersion >= 10));	
}

bool IsWinNT5(void)
{
	OSVERSIONINFO OsVersion;
	OsVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	GetVersionEx((LPOSVERSIONINFO)&OsVersion);

	return(OsVersion.dwPlatformId == (VER_PLATFORM_WIN32_NT) && (OsVersion.dwMajorVersion >= 5));
}	

bool IsWinNT4(void)
{
	OSVERSIONINFO OsVersion;
	OsVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	GetVersionEx((LPOSVERSIONINFO)&OsVersion);

	return(OsVersion.dwPlatformId == (VER_PLATFORM_WIN32_NT) && (OsVersion.dwMajorVersion == 4));
}	

bool IsWinNT351(void)
{
	OSVERSIONINFO OsVersion;
	OsVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	GetVersionEx((LPOSVERSIONINFO)&OsVersion);

	return	(	OsVersion.dwPlatformId		==	VER_PLATFORM_WIN32_NT
			&&	OsVersion.dwMajorVersion	==	3
			&&	OsVersion.dwMinorVersion	==	51 );
}	

/////////////////////////////////////////////////////////////////////
void LogEnumValueError( char * szFile, DWORD dwLine, char * szKey, char * szId )
{
	if (IsErrorLoggingEnabled())
	{
		CHString gazotta;
		gazotta.Format(ERR_REGISTRY_ENUM_VALUE_FOR_KEY, szId, szKey);
		LogErrorMessageEx((const char *)gazotta, szFile, dwLine);
	}
}
/////////////////////////////////////////////////////////////////////
void LogOpenRegistryError( char * szFile, DWORD dwLine, char * szKey )
{
	if (IsErrorLoggingEnabled())
	{
		CHString gazotta;
		gazotta.Format(ERR_OPEN_REGISTRY, szKey);
		
		LogErrorMessageEx((const char *)gazotta, szFile, dwLine);
	}
}
/////////////////////////////////////////////////////////////////////
// left in for hysterical purposes 
// prefer to use LogMessage macro in BrodCast.h
void LogError( char * szFile, DWORD dwLine, char * szKey )
{
	LogErrorMessageEx(szKey, szFile, dwLine);	
}
/////////////////////////////////////////////////////////////////////
void LogLastError( char * szFile, DWORD dwLine )
{
	if (IsErrorLoggingEnabled())
	{
		DWORD duhWord = GetLastError();
		CHString gazotta;
		gazotta.Format(IDS_GETLASTERROR, duhWord, duhWord);

		LogErrorMessageEx(gazotta, szFile, dwLine);	
    }
}

///////////////////////////////////////////////////////////////////////
BOOL GetValue( CRegistry & Reg, 
               char * szKey,
               char * ValueName, 
               CHString * pchsValueBuffer )
{
    BOOL bRet = (Reg.GetCurrentKeyValue( ValueName, *pchsValueBuffer) == ERROR_SUCCESS);
	
	if( !bRet )
        LogEnumValueError(__FILE__,__LINE__, szKey, ValueName); 

    return bRet;
}
///////////////////////////////////////////////////////////////////////
BOOL GetValue( CRegistry & Reg, 
               char * szKey,
               char * ValueName, 
               DWORD * dwValueBuffer )
{
    BOOL bRet = (Reg.GetCurrentKeyValue( ValueName, *dwValueBuffer) == ERROR_SUCCESS);
		
	if( !bRet )
        LogEnumValueError(__FILE__,__LINE__, szKey, ValueName); 

    return bRet;
}
///////////////////////////////////////////////////////////////////////
BOOL OpenAndGetValue( CRegistry & Reg, 
                      char * szKey,
                      char * ValueName, 
                      CHString * pchsValueBuffer )
{
	BOOL bRet = ( Reg.OpenLocalMachineKeyAndReadValue( szKey, ValueName, *pchsValueBuffer )== ERROR_SUCCESS);
    
	if( !bRet )
        LogEnumValueError(__FILE__,__LINE__, szKey, ValueName); 

    return bRet;
}
///////////////////////////////////////////////////////////////////////
BOOL GetBinaryValue( CRegistry & Reg, char * szKey, 
                     char * ValueName, CHString * pchsValueBuffer )
{
    BOOL bRet = ( Reg.GetCurrentBinaryKeyValue( ValueName, *pchsValueBuffer) == ERROR_SUCCESS);

    if( !bRet )
        (LogEnumValueError(__FILE__,__LINE__, szKey, ValueName)); 

    return bRet;
}

/*****************************************************************************
 *
 *  FUNCTION    : GetDeviceParms
 *
 *  DESCRIPTION : Gets drive characteristics (heads, tracks, cylinders, etc)
 *
 *  INPUTS      : Pointer to a DEVICEPARMS struct to receive the data
 *                Drive number of the drive to query (0 = default drive, 
 *                   1 = A, 2 = B, and so on)
 *
 *  OUTPUTS     : 
 *
 *  RETURNS     : TRUE if successful, FALSE otherwise
 *
 *  COMMENTS    : 
 *
 *****************************************************************************/

BOOL GetDeviceParms(PDEVICEPARMS pstDeviceParms, UINT nDrive)
{
    DEVIOCTL_REGISTERS reg;
    memset(&reg, '\0', sizeof(DEVIOCTL_REGISTERS));

    reg.reg_EAX = 0x440D;       /* IOCTL for block devices */
    reg.reg_EBX = nDrive;       /* zero-based drive ID     */
    reg.reg_ECX = 0x0860;       /* Get Media ID command    */
    reg.reg_EDX = (DWORD) pstDeviceParms;

    memset(pstDeviceParms, 0, sizeof(DEVICEPARMS));

    if (!VWIN32IOCTL(&reg, VWIN32_DIOC_DOS_IOCTL))
        return FALSE;

    if (reg.reg_Flags & 0x8000) /* error if carry flag set */
        return FALSE;

    return TRUE;
}

/*****************************************************************************
 *
 *  FUNCTION    : GetDriveMapInfo
 *
 *  DESCRIPTION : Gets logical to physical mapping info
 *
 *  INPUTS      : Pointer to a DRIVE_MAP_INFO struct to receive the data
 *                Drive number of the drive to query (0 = default drive, 
 *                   1 = A, 2 = B, and so on)
 *
 *  OUTPUTS     : 
 *
 *  RETURNS     : TRUE if successful, FALSE otherwise
 *
 *  COMMENTS    : 
 *
 *****************************************************************************/

BOOL GetDriveMapInfo(PDRIVE_MAP_INFO pDriveMapInfo, UINT nDrive)
{
   DEVIOCTL_REGISTERS reg;
   memset(&reg, '\0', sizeof(DEVIOCTL_REGISTERS));

   reg.reg_EAX = 0x440d;      /* IOCTL for block devices */
   reg.reg_EBX = nDrive;      /* zero-based drive ID     */
   reg.reg_ECX = 0x086f;      /* Get Drive Map Info */
   reg.reg_EDX = (DWORD) pDriveMapInfo;

   // zero the struct
   memset(pDriveMapInfo, 0, sizeof(DRIVE_MAP_INFO));

   // Set the length byte
   pDriveMapInfo->btAllocationLength = sizeof(DRIVE_MAP_INFO);

   // Doit
   if (!VWIN32IOCTL(&reg, VWIN32_DIOC_DOS_IOCTL))
      return FALSE;

   if (reg.reg_Flags & 0x8000) {/* error if carry flag set */
      return FALSE;
   }

   return TRUE;

}

/*****************************************************************************
 *
 *  FUNCTION    : Get_ExtFreeSpace
 *
 *  DESCRIPTION : Gets detailed info about a partition
 *
 *  INPUTS      : Drive number of the drive to query (0 = default drive, 
 *                   1 = A, 2 = B, and so on)
 *                Pointer to ExtGetDskFreSpcStruct
 *
 *  OUTPUTS     : 
 *
 *  RETURNS     : TRUE if successful, FALSE otherwise
 *
 *  COMMENTS    : 
 *
 *****************************************************************************/

BOOL Get_ExtFreeSpace(BYTE btDriveName, ExtGetDskFreSpcStruc *pstExtGetDskFreSpcStruc)
{
   DEVIOCTL_REGISTERS reg;
   memset(&reg, '\0', sizeof(DEVIOCTL_REGISTERS));
   char szDrive[4];

   szDrive[0] = btDriveName;
   szDrive[1] = ':';
   szDrive[2] = '\\';
   szDrive[3] = '\0';

   reg.reg_EAX = 0x7303;							// Get_ExtFreeSpace
   reg.reg_ECX = sizeof(ExtGetDskFreSpcStruc);		// Size of the structure sent in
   reg.reg_EDI = (DWORD)pstExtGetDskFreSpcStruc;	// Structure
   reg.reg_EDX = (DWORD)szDrive;					// Drive to get info for

   // zero the struct
   memset(pstExtGetDskFreSpcStruc, 0, sizeof(ExtGetDskFreSpcStruc));

   // Doit
   if (!VWIN32IOCTL(&reg, VWIN32_DIOC_DOS_DRIVEINFO))
      return FALSE;

   if (reg.reg_Flags & 0x8000) {/* error if carry flag set */
      return FALSE;
   }

   return TRUE;

}

/*****************************************************************************
 *
 *  FUNCTION    : VWIN32IOCTL
 *
 *  DESCRIPTION : Calls IOControl against the vwin32 vxd
 *
 *  INPUTS      : Pointer to DEVIOCTL_REGISTERS structure
 *                IOControl call number.
 *
 *  OUTPUTS     : 
 *
 *  RETURNS     : TRUE if successful, FALSE otherwise
 *
 *  COMMENTS    : 
 *
 *****************************************************************************/

BOOL VWIN32IOCTL(PDEVIOCTL_REGISTERS preg, DWORD dwCall)
{
    HANDLE hDevice;

    BOOL fResult;
    DWORD cb;

    preg->reg_Flags = 0x8000; /* assume error (carry flag set) */

	hDevice = CreateFile("\\\\.\\VWIN32", 0, 0, 0, OPEN_EXISTING,
						FILE_FLAG_DELETE_ON_CLOSE, 0);

   if (hDevice == (HANDLE) INVALID_HANDLE_VALUE) {
      return FALSE;
   } else {
      fResult = DeviceIoControl(hDevice, dwCall, preg, sizeof(*preg), preg, sizeof(*preg), &cb, 0);
    }

    CloseHandle(hDevice);

    if (!fResult) {
       return FALSE;
    }

    return TRUE;
}

CHString GetFileTypeDescription(char *szExtension) 
{
   CRegistry RegInfo;
   CHString sTemp, sType(szExtension);

   if (RegInfo.Open(HKEY_CLASSES_ROOT, szExtension, KEY_READ) == ERROR_SUCCESS) {
      RegInfo.GetCurrentKeyValue("", sTemp);

      if (RegInfo.Open(HKEY_CLASSES_ROOT, sTemp, KEY_READ) == ERROR_SUCCESS) {
         RegInfo.GetCurrentKeyValue("", sType);
      }
   }

   return sType;
}
///////////////////////////////////////////////////////////////////
//
// Define the severity codes
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error

//
// Define the severity codes
//
//
// Define the severity codes
//
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3
#define SEV_MASK 0xC0000000
void TranslateNTStatus( DWORD dwStatus, CHString & chsValue)
{

	switch((dwStatus & SEV_MASK) >> 30){

		case STATUS_SEVERITY_WARNING:
			chsValue = IDS_STATUS_Degraded;
			break;

		case STATUS_SEVERITY_SUCCESS:
			chsValue = IDS_STATUS_OK;
			break;

		case STATUS_SEVERITY_ERROR:
			chsValue = IDS_STATUS_Error;
			break;

		case STATUS_SEVERITY_INFORMATIONAL:
			chsValue = IDS_STATUS_OK;
			break;
	
		default:
			chsValue = IDS_STATUS_Unknown;
	}
}

BOOL GetVarFromVersionInfo(LPCTSTR szFile, LPCTSTR szVar, CHString &strValue)
{
	BOOL    fRc = FALSE;
	DWORD   dwTemp,
	        dwBlockSize;
	LPVOID  pInfo = NULL;

	try
    {
        dwBlockSize = GetFileVersionInfoSize((LPTSTR) szFile, &dwTemp);
	    if (dwBlockSize)
        {
		    pInfo = (LPVOID) new BYTE[dwBlockSize + 4];
			memset( pInfo, NULL, dwBlockSize + 4);

		    if (pInfo)
            {
			    UINT len;
			    if (GetFileVersionInfo((LPTSTR) szFile, 0, dwBlockSize, pInfo))
                {	
				    WORD wLang = 0;
					WORD wCodePage = 0; 	
					if(!GetVersionLanguage(pInfo, &wLang, &wCodePage) )
					{
						// on failure: default to English

						// this returns a pointer to an array of WORDs
						WORD *pArray;
						if (VerQueryValue(pInfo, "\\VarFileInfo\\Translation",(void **)(&pArray), &len))
						{
							len = len / sizeof(WORD);

							// find the english one...
							for (int i = 0; i < len; i += 2)
							{
								if( pArray[i] == 0x0409 )	{
									wLang	  = pArray[i];
									wCodePage = pArray[i + 1];
									break;
								}
							}
						}
					}
					
					TCHAR   *pMfg, szTemp[256];
					wsprintf(szTemp, _T("\\StringFileInfo\\%04X%04X\\%s"), wLang, wCodePage, szVar);

					if( VerQueryValue(pInfo, szTemp, (void **)(&pMfg), &len))
                    {
                        strValue = pMfg;
						fRc = TRUE;
					}
			    }
		    }
	    }
    }
    catch(...)
    {
        // We don't need to do anything, just need to protect ourselves
        // from the flaky version.dll calls.
    }

	if (pInfo)
		delete pInfo;

	return fRc;
}


/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:		BOOL GetVersionLanguage(void *vpInfo,
									WORD *wpLang,
									WORD *wpCodePage);
 Description:	This function extracts the language and codepage out of a passed GetFileVersionInfo()
				result. Consideration is given to variation in the layout.    
 Arguments:		vpInfo, wpLang, wpCodePage
 Returns:		Boolean
 Inputs:
 Outputs:
 Caveats:
 Courtesy of:	SMS, Nick Dyer
 Raid:
 History:		a-peterc  30-Oct-1998     Created
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
BOOL GetVersionLanguage(void *vpInfo, WORD *wpLang, WORD *wpCodePage)
{
  WORD *wpTemp;
  WORD wLength;
  WCHAR *wcpTemp;
  char *cpTemp;
  BOOL bRet = FALSE;

  wpTemp = (WORD *) vpInfo;
  cpTemp = (char *) vpInfo;

  wpTemp++; // jump past buffer length.
  wLength = *wpTemp;  // capture value length.
  wpTemp++; // skip past value length to what should be type code in new format
  if (*wpTemp == 0 || *wpTemp == 1) // new format expect unicode strings.
  {
		cpTemp = cpTemp + 38 + wLength + 8;
		wcpTemp = (WCHAR *) cpTemp;
    if (wcscmp(L"StringFileInfo", wcpTemp) == 0) // OK! were aligned properly.
    {
			bRet = TRUE;

			cpTemp += 30; // skip over "StringFileInfo"
			while ((DWORD) cpTemp % 4 > 0) // 32 bit align
				cpTemp++;

			cpTemp += 6; // skip over length and type fields.

			wcpTemp = (WCHAR *) cpTemp;
			swscanf(wcpTemp, L"%4x%4x", wpLang, wpCodePage);
    }
  }
  else  // old format, expect single byte character strings.
  {
    cpTemp += 20 + wLength + 4;
    if (strcmp("StringFileInfo", cpTemp) == 0) // OK! were aligned properly.
    {
			bRet = TRUE;

			cpTemp += 20; // skip over length fields.
			sscanf(cpTemp, "%4x%4x", wpLang, wpCodePage);
    }
  }

	return (bRet);
}

///////////////////////////////////////////////////////////////////
BOOL GetManufacturerFromFileName(LPCTSTR szFile, CHString &strMfg)
{
    return GetVarFromVersionInfo(szFile, "CompanyName", strMfg);
}

BOOL GetVersionFromFileName(LPCTSTR szFile, CHString &strVersion)
{
    return GetVarFromVersionInfo(szFile, "ProductVersion", strVersion);
}

void ReplaceString(CHString &str, LPCTSTR szFind, LPCTSTR szReplace)
{
    int iWhere,
        nLen = lstrlen(szFind);

    while ((iWhere = str.Find(szFind)) != -1)
    {
        str.Format(
            "%s%s%s",
            (LPCTSTR) str.Left(iWhere),
            szReplace,
            (LPCTSTR) str.Mid(iWhere + nLen));
    }
}

BOOL GetServiceFileName(LPCTSTR szService, CHString &strFileName)
{
    SC_HANDLE   hSCManager,
                hService;
    TCHAR       szBuffer[2048];
    QUERY_SERVICE_CONFIG    
                *pConfig = (QUERY_SERVICE_CONFIG *) szBuffer; 
    DWORD       dwNeeded;
    BOOL        bRet = FALSE;

    hSCManager = 
        OpenSCManager(
            NULL,
            NULL,
            STANDARD_RIGHTS_REQUIRED);
    if (!hSCManager)
        return FALSE;

    hService = 
        OpenService(
        hSCManager,
        szService,
        SERVICE_QUERY_CONFIG);
    
    if (hService)
    {
        if (QueryServiceConfig(
            hService,
            pConfig,
            sizeof(szBuffer),
            &dwNeeded))
        {
            strFileName = pConfig->lpBinaryPathName;

            // Now fix up the path so that it has a drive letter.

            strFileName.MakeUpper();

            // If the filename is using \SYSTEMROOT\, replace it with %SystemRoot%.
            if (strFileName.Find("\\SYSTEMROOT\\") == 0)
                ReplaceString(strFileName, "\\SYSTEMROOT\\", "%SystemRoot%\\");
            // If the filename doesn't start with a replacement string, and if it
            // doesn't have a drive letter, assume it should start with
            // %SystemRoot%.
            else if (strFileName.GetLength() >= 2 && 
                strFileName[0] != '%' && strFileName[1] != ':')
            {
                CHString strTemp;

                strTemp.Format("%%SystemRoot%%\\%s", (LPCTSTR) strFileName);
                strFileName = strTemp;
            }

            TCHAR szOut[MAX_PATH * 2];

            ExpandEnvironmentStrings(strFileName, szOut, sizeof(szOut));
            strFileName = szOut;

            bRet = TRUE;
        }

        CloseServiceHandle(hService);
    }

    CloseServiceHandle(hSCManager);

    return bRet;
}

///////////////////////////////////////////////////////////////////
// Performs a case insensitive compare (such as is required for keys)
// on two variants and returns true if they are the same type and
// the same value, else false.  Note that arrays, VT_NULL, and 
// embedded objects will assert, and return false.
///////////////////////////////////////////////////////////////////
bool CompareVariantsNoCase(const VARIANT *v1, const VARIANT *v2) 
{
   
   if (v1->vt == v2->vt) {
      switch (v1->vt) {
      case VT_BOOL: return (v1->boolVal == v2->boolVal);
      case VT_UI1:  return (v1->bVal == v2->bVal);
      case VT_I2:   return (v1->iVal == v2->iVal);
      case VT_I4:   return (v1->lVal == v2->lVal);
      case VT_R4:   return (v1->fltVal == v2->fltVal);
      case VT_R8:   return (v1->dblVal == v2->dblVal);
      case VT_BSTR: return (0 == _wcsicmp(v1->bstrVal, v2->bstrVal));
      default:
         ASSERT_BREAK(0);
      }
   }
   return false;
}

// map standard API return values (defined WinError.h)
// to WBEMish hresults (defined in WbemCli.h)
HRESULT WinErrorToWBEMhResult(LONG error)
{
	HRESULT hr = WBEM_E_FAILED;
	
	switch (error)
	{
		case ERROR_SUCCESS:
			hr = WBEM_S_NO_ERROR;
			break;
		case ERROR_ACCESS_DENIED:
			hr = WBEM_E_ACCESS_DENIED;
			break;
		case ERROR_NOT_ENOUGH_MEMORY:
		case ERROR_OUTOFMEMORY:
			hr = WBEM_E_OUT_OF_MEMORY;
			break;
		case ERROR_ALREADY_EXISTS:
			hr = WBEM_E_ALREADY_EXISTS;
			break;
		case ERROR_BAD_NETPATH:
        case ERROR_INVALID_DATA:
        case ERROR_BAD_PATHNAME:
        case REGDB_E_INVALIDVALUE:
		case ERROR_PATH_NOT_FOUND:
		case ERROR_FILE_NOT_FOUND:
		case ERROR_BAD_USERNAME:
		case NERR_NetNameNotFound:
        case ERROR_NOT_READY:
        case ERROR_INVALID_NAME:
			hr = WBEM_E_NOT_FOUND;
			break;
		default:
			hr = WBEM_E_FAILED;
	}

	return hr;
}

void SetConfigMgrProperties(CConfigMgrDevice *pDevice, CInstance *pInstance)
{
	CHString	strDeviceID;
	DWORD		dwStatus,
				dwProblem;

	if (pDevice->GetDeviceID(strDeviceID))
		pInstance->SetCHString(IDS_PNPDeviceID, strDeviceID);
					
	if (pDevice->GetStatus(&dwStatus, &dwProblem))
		pInstance->SetDWORD("ConfigManagerErrorCode", dwProblem);

	pInstance->SetDWORD("ConfigManagerUserConfig", 
		pDevice->IsUsingForcedConfig());
}

BOOL EnablePrivilegeOnCurrentThread(LPCTSTR szPriv)
{
    BOOL                bRet = FALSE;
    HANDLE              hToken = NULL;
    TOKEN_PRIVILEGES    tkp;
    BOOL                bLookup = FALSE;
    DWORD               dwLastError = ERROR_SUCCESS;

    // Try to open the thread token.  If we fail, it's because no
    // impersonation is going on, so call ImpersonateSelf to get a token.
    // Then call OpenThreadToken again.
    if (OpenThreadToken(GetCurrentThread(), TOKEN_ADJUST_PRIVILEGES | 
        TOKEN_QUERY, FALSE, &hToken) ||
        (ImpersonateSelf(SecurityImpersonation) &&
        OpenThreadToken(GetCurrentThread(), TOKEN_ADJUST_PRIVILEGES | 
        TOKEN_QUERY, FALSE, &hToken)))
    {

        {
            CreateMutexAsProcess createMutexAsProcess(SECURITYAPIMUTEXNAME);
            bLookup = LookupPrivilegeValue(NULL, szPriv, &tkp.Privileges[0].Luid);
        }
        if (bLookup) 
        {
            tkp.PrivilegeCount = 1;
            tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

            // Clear the last error.
            SetLastError(0);

            // Turn it on
            bRet = AdjustTokenPrivileges(hToken, FALSE, &tkp, 0, 
                        (PTOKEN_PRIVILEGES) NULL, 0);
            dwLastError = GetLastError();
        }

        CloseHandle(hToken);
    }

    // We have to check GetLastError() because AdjustTokenPrivileges lies about
    // its success but GetLastError() doesn't.
    return bRet && dwLastError == ERROR_SUCCESS;
}

// Takes a pnp id and returns a bios unit number
// To avoid frequent load/unload of a library, the pGetWin9XBiosUnit parameter comes from:
//                     HINSTANCE hInst =  LoadLibrary("cim32net.dll");
//                     pGetWin9XBiosUnit = (fnGetWin9XBiosUnit)GetProcAddress(hInst, "GetWin9XBiosUnit");
BYTE GetBiosUnitNumberFromPNPID(fnGetWin9XBiosUnit pGetWin9XBiosUnit, CHString strDeviceID)
{
    CHString sTemp;
    DRIVE_MAP_INFO stDMI;
    CRegistry Reg1;

    BYTE btBiosUnit = -1;
    
    // Open the associated registry key
    if (Reg1.Open(HKEY_LOCAL_MACHINE, "enum\\" + strDeviceID, KEY_QUERY_VALUE) == ERROR_SUCCESS)
    {
    
        // Get a drive letter for this pnp id
        if ((Reg1.GetCurrentKeyValue("CurrentDriveLetterAssignment", sTemp) != ERROR_SUCCESS) ||
            (sTemp.GetLength() == 0)) {
            // No drive letters, let's try one more thing.  On memphis sp1, this call will also
            // get us a unit number.
            if (pGetWin9XBiosUnit != NULL)
            {
                btBiosUnit = pGetWin9XBiosUnit(strDeviceID.GetBuffer(0));
            }
        } 
        else 
        {
            if (GetDriveMapInfo(&stDMI, toupper(sTemp[0]) - 'A' + 1)) 
            {
                btBiosUnit = stDMI.btInt13Unit;
            }
        }
    }

    return btBiosUnit;
}

HRESULT GetHKUserNames(CHStringList &list)
{
	HRESULT hres;

	// Empty the list.
	list.clear();
	
	if (GetPlatformID() == VER_PLATFORM_WIN32_NT)
	{
		// Enum the profiles from the registry.
		CRegistry	regProfileList;
		CHString	strProfile;
		DWORD		dwErr;

		// Open the ProfileList key so we know which profiles to load up.
		if ((dwErr = regProfileList.OpenAndEnumerateSubKeys(
			HKEY_LOCAL_MACHINE, 
			IDS_RegNTProfileList, 
			KEY_READ)) == ERROR_SUCCESS)
		{
			for (int i = 0; regProfileList.GetCurrentSubKeyName(strProfile) == 
				ERROR_SUCCESS; i++)
			{
				list.push_back(strProfile);
				regProfileList.NextSubKey();
			}
		}

		// Add the .DEFAULT name.
		list.push_back(_T(".DEFAULT"));

		hres = WinErrorToWBEMhResult(dwErr);
	}
	else
	{
		DWORD	dwErr = ERROR_SUCCESS;
#ifdef _DEBUG
		DWORD	dwSize = 10,
#else
		DWORD	dwSize = 1024,
#endif
				dwBytesRead;
		TCHAR	*szBuff = NULL;

		// Keep looping until we read the entire section.
		// You know your buffer wasn't big enough if the returned number
		// of bytes == (size passed in - 2).
		do
		{
			if (szBuff)
			{
				free(szBuff);

				dwSize *= 2;
			}
			
			szBuff = (TCHAR *) malloc(dwSize);
				
			// Out of memory.  Get out of loop.
			if (!szBuff)
				break;
			
			dwBytesRead = 
				GetPrivateProfileString(
					"Password Lists",
					NULL, 
					"", 
					szBuff,
					dwSize, 
					"system.ini");

		} while (dwBytesRead >= dwSize - 2);

		if (szBuff)
		{
			// Loop through the list of names.  Each is null-terminated, and the
			// list is terminated with a double null.
			TCHAR *pszCurrent = szBuff;

			while (*pszCurrent)
			{
				list.push_back(pszCurrent);
				
				pszCurrent += lstrlen(pszCurrent) + 1;
			}
			
			hres = WBEM_S_NO_ERROR;

			// Free the buffer.
			free(szBuff);

			// Add the .DEFAULT name.
			list.push_back(_T(".DEFAULT"));
		}
		else
			// Failed to malloc, so set error code.
			hres = WBEM_E_OUT_OF_MEMORY;
	}

	return hres;
}


VOID EscapeBackslashes(CHString& chstrIn,
                     CHString& chstrOut)
{
    CHString chstrCpyNormPathname = chstrIn;
    LONG lNext = -1L;
    chstrOut.Empty();

    // Find the next '\'
    lNext = chstrCpyNormPathname.Find(_T('\\'));
    while(lNext != -1)
    {
        // Add on to the new string we are building:
        chstrOut += chstrCpyNormPathname.Left(lNext + 1);
        // Add on the second backslash:
        chstrOut += _T('\\');
        // Hack off from the input string the portion we just copied 
        chstrCpyNormPathname = chstrCpyNormPathname.Right(chstrCpyNormPathname.GetLength() - lNext - 1);
        lNext = chstrCpyNormPathname.Find(_T('\\'));
    }
    // If the last character wasn't a '\', there may still be leftovers, so
    // copy them here.
    if(chstrCpyNormPathname.GetLength() != 0)
    {
        chstrOut += chstrCpyNormPathname;
    }
}

VOID EscapeQuotes(CHString& chstrIn,
                  CHString& chstrOut)
{
    CHString chstrCpyNormPathname = chstrIn;
    LONG lNext = -1L;
    chstrOut.Empty();

    // Find the next '\'
    lNext = chstrCpyNormPathname.Find(_T('\"'));
    while(lNext != -1)
    {
        // Add on to the new string we are building:
        chstrOut += chstrCpyNormPathname.Left(lNext);
        // Escape the quote:
        chstrOut += _T("\\\"");
        // Hack off from the input string the portion we just copied 
        chstrCpyNormPathname = chstrCpyNormPathname.Right(chstrCpyNormPathname.GetLength() - lNext - 1);
        lNext = chstrCpyNormPathname.Find(_T('\"'));
    }
    // If the last character wasn't a '\', there may still be leftovers, so
    // copy them here.
    if(chstrCpyNormPathname.GetLength() != 0)
    {
        chstrOut += chstrCpyNormPathname;
    }
} 

VOID RemoveDoubleBackslashes(const CHString& chstrIn, CHString& chstrOut)
{
    CHString chstrBuildString;
    CHString chstrInCopy = chstrIn;
    BOOL fDone = FALSE;
    LONG lPos = -1;
    while(!fDone)
    {
        lPos = chstrInCopy.Find(_T("\\\\"));
        if(lPos != -1)
        {
            chstrBuildString += chstrInCopy.Left(lPos);
            chstrBuildString += _T("\\");
            chstrInCopy = chstrInCopy.Mid(lPos+2);
        }
        else
        {
            chstrBuildString += chstrInCopy;
            fDone = TRUE;
        }
    }
    chstrOut = chstrBuildString;
}

CHString RemoveDoubleBackslashes(const CHString& chstrIn)
{
    CHString chstrBuildString;
    CHString chstrInCopy = chstrIn;
    BOOL fDone = FALSE;
    LONG lPos = -1;
    while(!fDone)
    {
        lPos = chstrInCopy.Find(_T("\\\\"));
        if(lPos != -1)
        {
            chstrBuildString += chstrInCopy.Left(lPos);
            chstrBuildString += _T("\\");
            chstrInCopy = chstrInCopy.Mid(lPos+2);
        }
        else
        {
            chstrBuildString += chstrInCopy;
            fDone = TRUE;
        }
    }
    return chstrBuildString;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\atprov\printsys.h ===
/******************************************************************

   PrintSys.H -- WMI provider class definition

   Generated by Microsoft WBEM Code Generation Engine
 
   Description: 
   

*******************************************************************/

// Property set identification
//============================

#ifndef _PrintSys_H_
#define _PrintSys_H_

#define PROVIDER_NAME_PRINTSYS L"PCHAT_PrintSystem"

// Property name externs -- defined in PrintSys.cpp
//=================================================

extern const WCHAR *c_wszGenDrv;
extern const WCHAR *c_wszName;
extern const WCHAR *c_wszPath;
extern const WCHAR *c_wszUniDrv;
extern const WCHAR *c_wszUsePrintMgrSpooling;

class CPrintSys : public Provider 
{
private:
    // member data 
    CInstance   *m_pCurrent;
    CInstance   *m_pParamIn;
    CInstance   *m_pParamOut;
    LONG        m_lFlags;

public:
    // Constructor/destructor
    //=======================

    CPrintSys(LPCWSTR lpwszClassName, LPCWSTR lpwszNameSpace);
    virtual ~CPrintSys();

protected:
    // Reading Functions
    //============================
    virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, 
                                       long lFlags = 0L);
    
    virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L);
    virtual HRESULT ExecQuery(MethodContext *pMethodContext, 
                              CFrameworkQuery& Query, long lFlags = 0L);


    // Writing Functions
    //============================
    virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L);
    virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L);

    // Other Functions
    virtual HRESULT ExecMethod(const CInstance& Instance, const BSTR bstrMethodName,
                               CInstance *pInParams, CInstance *pOutParams,
                               long lFlags = 0L);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\atprov\util.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    util.CPP

Abstract:
    File containing utility classes

Revision History:

    Ghim-Sim Chua       (gschua)   04/27/99
        - Created

    Jim Martin          (a-jammar) 04/30/99
        - Changed to use global IWbemServices pointer, and added
          GetWbemServices, CopyProperty, and GetCIMDataFile

    Ghim-Sim Chua       (gschua)   05/01/99
        - Modified GetWbemServices, GetCIMDataFile

    Kalyani Narlanka    (kalyanin)  05/11/99
        - Added the function GetCompletePath

********************************************************************/

#include "pchealth.h"


/////////////////////////////////////////////////////////////////////////////
//  tracing stuff

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile
#define TRACE_ID    DCID_UTIL


/////////////////////////////////////////////////////////////////////////////
//  utility functions

// ****************************************************************************
HRESULT GetWbemServices(IWbemServices **ppServices)
{
    TraceFunctEnter("GetWbemServices");

    IWbemLocator    *pWbemLocator = NULL;
    HRESULT         hr = NOERROR;

    // If global variable already initialized, use it
    if (g_pWbemServices)
    {
        *ppServices = g_pWbemServices;
        (*ppServices)->AddRef();
        goto done;
    }

    // First we have the get the IWbemLocator object with a CoCreateInstance.
    hr = CoCreateInstance(CLSID_WbemAdministrativeLocator, NULL, 
                            CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER,
                            IID_IUnknown, (void **)&pWbemLocator);
    if (FAILED(hr))
    {
        ErrorTrace(TRACE_ID, "CoCreateInstance failed to create IWbemAdministrativeLocator.");
        goto done;
    }

    // Then we connect to the WMI server for the local CIMV2 namespace.
    hr = pWbemLocator->ConnectServer(CComBSTR(CIM_NAMESPACE), NULL, NULL, NULL, 0, NULL, NULL, ppServices);
    if (FAILED(hr))
    {
        ErrorTrace(TRACE_ID, "ConnectServer failed to connect to cimv2 namespace.");
        goto done;
    }

    // Store it in the global variable
    g_pWbemServices = *ppServices;

    // BUGBUG: check out why this stops fault on NET STOP WINMGMT
    (*ppServices)->AddRef(); 

done:
    if (pWbemLocator != NULL)
        pWbemLocator->Release();

    TraceFunctLeave();
    return hr;
}

// ****************************************************************************
HRESULT ExecWQLQuery(IEnumWbemClassObject **ppEnumInst, BSTR bstrQuery)
{
    TraceFunctEnter("ExecWQLQuery");

    IWbemServices   *pWbemServices = NULL;
    HRESULT         hr = NOERROR;

    // Get pointer to WbemServices
    hr = GetWbemServices(&pWbemServices);
    if (FAILED(hr))
        goto done;

    // execute the query
    hr = pWbemServices->ExecQuery(CComBSTR("WQL"), bstrQuery,
                                  WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY,
                                  NULL, ppEnumInst);
    if (FAILED(hr))
    {
        ErrorTrace(TRACE_ID, "ExecQuery failed: 0x%08x", hr);
        goto done;
    }

done:
    if (pWbemServices != NULL)
        pWbemServices->Release();

    TraceFunctLeave();
    return hr;
}

// ****************************************************************************
HRESULT CopyProperty(IWbemClassObject *pFrom, LPCWSTR szFrom, CInstance *pTo, 
                     LPCWSTR szTo)
{
    TraceFunctEnter("CopyProperty");

    _ASSERT(pFrom && szFrom && pTo && szTo);

    CComVariant varValue;
    CComBSTR    bstrFrom;
    HRESULT     hr = NOERROR;

    // First, get the property (as a variant) from the source class object.
    bstrFrom = szFrom;
    hr = pFrom->Get(bstrFrom, 0, &varValue, NULL, NULL);
    if (FAILED(hr))
    {
        ErrorTrace(TRACE_ID, "GetVariant on %s field failed.", szFrom);
    }

    else
    {
        // Then set the variant for the target CInstance object.
        if (pTo->SetVariant(szTo, varValue) == FALSE)
        {
            ErrorTrace(TRACE_ID, "SetVariant on %s field failed.", szTo);
            hr = WBEM_E_FAILED;
        }
    }

    TraceFunctLeave();
    return hr;
}

// ****************************************************************************
HRESULT GetCIMDataFile(BSTR bstrFile, IWbemClassObject **ppFileObject, 
                       BOOL fHasDoubleSlashes)
{
    TraceFunctEnter("GetCIMDataFile");

    IWbemServices   *pWbemServices = NULL;
    HRESULT         hr = NOERROR;
    CComBSTR        bstrObjectPath;
    wchar_t         *pwch;
    UINT            uLen;

    if (bstrFile == NULL || ppFileObject == NULL)
    {
        ErrorTrace(TRACE_ID, "Parameter pointer is null.");
        hr = WBEM_E_INVALID_PARAMETER;
        goto done;
    }

    hr = GetWbemServices(&pWbemServices);
    if (FAILED(hr))
        goto done;

    // Construct the path for the file we are trying to get. Note, the path needs
    // the have double backslashes for the GetObject call to work. We scan through
    // the string and do this manually here.
    bstrObjectPath = "\\\\.\\root\\cimv2:CIM_DataFile.Name=\"";
    pwch = bstrFile;
    if (fHasDoubleSlashes)
    {
        bstrObjectPath.Append(pwch, SysStringLen(bstrFile));
    }
    else
    {
        for (uLen = SysStringLen(bstrFile); uLen > 0; uLen--)
        {
            if (*pwch == L'\\')
                bstrObjectPath.Append("\\");
            bstrObjectPath.Append(pwch, 1);
            pwch++;
        }
    }

    bstrObjectPath.Append("\"");

    // Make the call to get the CIM_DataFile object.
    hr = pWbemServices->GetObject(bstrObjectPath, 0, NULL, ppFileObject, NULL);
    if (FAILED(hr))
        ErrorTrace(TRACE_ID, "GetObject on CIM_DataFile failed.");

done:
    if (pWbemServices != NULL)
        pWbemServices->Release();
    TraceFunctLeave();
    return hr;
}

// ****************************************************************************
HRESULT GetCIMObj(BSTR bstrPath, IWbemClassObject **ppObj, long lFlags)
{
    TraceFunctEnter("GetCIMObj");

    IWbemServices   *pWbemServices = NULL;
    HRESULT         hr = NOERROR;

    if (bstrPath == NULL || ppObj == NULL)
    {
        ErrorTrace(TRACE_ID, "bad parameters");
        hr = WBEM_E_INVALID_PARAMETER;
        goto done;
    }

    // make sure we have a services object
    hr = GetWbemServices(&pWbemServices);
    if (FAILED(hr))
        goto done;

    // Make the call to get the CIM_DataFile object.
    hr = pWbemServices->GetObject(bstrPath, lFlags, NULL, ppObj, NULL);
    if (FAILED(hr))
        ErrorTrace(TRACE_ID, "GetObject failed: 0x%08x", hr);

done:
    if (pWbemServices != NULL)
        pWbemServices->Release();

    TraceFunctLeave();
    return hr;
}


// ****************************************************************************
BOOL getCompletePath(CComBSTR bstrFileName, CComBSTR &bstrFileWithPathName)
{

    //  Return
    BOOL                            bFoundFile              =   FALSE;

    ULONG                           uiReturn;

    TCHAR                           szDirectory[MAX_PATH];
    TCHAR                           temp[MAX_PATH];
    TCHAR                           lpstrTemp[MAX_PATH];

    struct _stat                    filestat;

    CComVariant                     varValue                =    NULL;

    CComBSTR                        bstrDirectory;


    //  Check for the File in the System Directory
    uiReturn = GetSystemDirectory(szDirectory, MAX_PATH);
    if (uiReturn != 0 && uiReturn < MAX_PATH)
    {
        bstrDirectory = szDirectory;
        bstrDirectory.Append("\\");
        bstrDirectory.Append(bstrFileName);

        USES_CONVERSION;
        int Result = _tstat(W2T(bstrDirectory), &filestat) ;
        if (Result == 0)
        {
            bstrFileWithPathName = bstrDirectory;
            bFoundFile = TRUE;
        }
    }

    // If not there, then check in the windows directory.
    if (!bFoundFile)
    {
        uiReturn = GetWindowsDirectory(szDirectory, MAX_PATH);
        if (uiReturn != 0 && uiReturn < MAX_PATH)
        {
            bstrDirectory = szDirectory;
            bstrDirectory.Append("\\");
            bstrDirectory.Append(bstrFileName);

            USES_CONVERSION;
            int Result = _tstat(W2T(bstrDirectory), &filestat) ;
            if (Result == 0)
            {
                bstrFileWithPathName = bstrDirectory;
                bFoundFile = TRUE;
            }
        }
    } 
    return(bFoundFile);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprov\pchealth.h ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    pchealth.H

Abstract:
    Main header file for all PCHealth WMI providers
    Contains all defines and includes used elsewhere

Revision History:

    Ghim-Sim Chua       (gschua)   04/27/99
        - Created

    Ghim-Sim Chua       (gschua)   05/02/99
        - Added GetWbemServices & CopyProperty

    Kalyani Narlanka    (kalyanin) 05/10/99
        - Added #define  INCL_WINSOCK_API_TYPEDEFS
        - Included <winsock2.>


********************************************************************/
#define INCL_WINSOCK_API_TYPEDEFS 1
#include <winsock2.h>
#include <sys/stat.h>

#ifndef _pchdef_h_
#define _pchdef_h_

#ifdef _WIN32_WINNT
#undef _WIN32_WINNT
#endif

#include <fwcommon.h>  // This must be the first include.
#include <provider.h>
#include <atlbase.h>
#include "dbgtrace.h"
#include "traceids.h"

#include "smartptr.h"

//
// Namespaces that we'll be working with
//
#define PCH_NAMESPACE   L"root\\pchealth"
#define CIM_NAMESPACE   L"root\\cimv2"


// #include <winsock2.h>
//
// Global Variables
//
extern CComPtr<IWbemServices> g_pWbemServices;

//
// Utility functions
//
HRESULT ExecWQLQuery(IEnumWbemClassObject **ppEnumInst, BSTR bstrQuery);
HRESULT GetWbemServices(IWbemServices **ppServices);
HRESULT CopyProperty(IWbemClassObject * pFrom, LPCWSTR szFrom, CInstance * pTo, LPCWSTR szTo);
HRESULT GetCIMDataFile(BSTR bstrFile, IWbemClassObject ** ppFileObject, BOOL fHasDoubleSlashes = FALSE);
BOOL getCompletePath(CComBSTR bstrFileName, CComBSTR &bstrFileWithPathName);
int DelimitedStringToArray(LPWSTR strDelimitedString, LPTSTR strDelimiter, LPTSTR apstrArray[], int iMaxArraySize);
int DelimitedStringToArray(LPTSTR strDelimitedString, LPTSTR strDelimiter, LPTSTR apstrArray[], int iMaxArraySize);

//-----------------------------------------------------------------------------
// This class is useful for retrieving information about a specific file. It
// uses the version resource code from Dr. Watson. To use it, create an
// instance of the class, and use the QueryFile method to query information
// about a specific file. Then use the Get* access functions to get the 
// values describing the information.
//-----------------------------------------------------------------------------

struct FILEVERSION;
class CFileVersionInfo
{
public:
    CFileVersionInfo();
    ~CFileVersionInfo();

    HRESULT QueryFile(LPCSTR szFile, BOOL fHasDoubleBackslashes = FALSE);
    HRESULT QueryFile(LPCWSTR szFile, BOOL fHasDoubleBackslashes = FALSE);

    LPCTSTR GetVersion();
    LPCTSTR GetDescription();
    LPCTSTR GetCompany();
    LPCTSTR GetProduct();

private:
    FILEVERSION * m_pfv;
};

#endif // _pchdef_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprov\maindll.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	MAINDLL.CPP

Abstract:
	Contains DLL entry points.  Also has code that controls
	when the DLL can be unloaded by tracking the number of
	objects and locks as well as routines that support
	self registration.

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

********************************************************************/

#include "pchealth.h"
#include <objbase.h>
#include <initguid.h>
#include <WBEMGlue.h>

/////////////////////////////////////////////////////////////////////////////
//  tracing stuff

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile
#define TRACE_ID    DCID_MAINDLL

HMODULE ghModule;
//============

WCHAR *GUIDSTRING = L"{c52586f0-f805-11d2-b3a7-00c04fa35c1a}";
CLSID CLSID_PCH_WINSOCK;

//Count number of objects and number of locks.

long       g_cLock=0;

//
// Keep a global IWbemServices pointer, since we use it frequently and
// it's a little expensive to get.
//
CComPtr<IWbemServices> g_pWbemServices = NULL;


//***************************************************************************
//
//  DllGetClassObject
//
//  Purpose: Called by Ole when some client wants a class factory.  Return 
//           one only if it is the sort of class this DLL supports.
//
//***************************************************************************


STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, PPVOID ppv)
{
    HRESULT hr;
    CWbemGlueFactory *pObj;

	CLSIDFromString(GUIDSTRING, &CLSID_PCH_WINSOCK);
    if (CLSID_PCH_WINSOCK!=rclsid)
        return E_FAIL;

    pObj=new CWbemGlueFactory();

    if (NULL==pObj)
        return E_OUTOFMEMORY;

    hr=pObj->QueryInterface(riid, ppv);

    if (FAILED(hr))
        delete pObj;

    return hr;
}

//***************************************************************************
//
// DllCanUnloadNow
//
// Purpose: Called periodically by Ole in order to determine if the
//          DLL can be freed.
//
// Return:  S_OK if there are no objects in use and the class factory 
//          isn't locked.
//
//***************************************************************************

STDAPI DllCanUnloadNow(void)
{
    SCODE   sc;

    // It is OK to unload if there are no objects or locks on the 
    // class factory and the framework is done with you.
    
    if ((0L==g_cLock) && CWbemProviderGlue::FrameworkLogoffDLL(L"PCH_WINSOCK"))
	{
		sc = S_OK;
	}
	else
	{
		sc = S_FALSE;
	}
    return sc;
}

//***************************************************************************
//
//  Is4OrMore
//
//  Returns true if win95 or any version of NT > 3.51
//
//***************************************************************************

BOOL Is4OrMore(void)
{
    OSVERSIONINFO os;
    os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if(!GetVersionEx(&os))
        return FALSE;           // should never happen
    return os.dwMajorVersion >= 4;
}

//***************************************************************************
//
// DllRegisterServer
//
// Purpose: Called during setup or by regsvr32.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllRegisterServer(void)
{   
    char       szID[128];
    WCHAR      wcID[128];
    char       szCLSID[128];
    char       szModule[MAX_PATH];
    char * pName = "";
    char * pModel;
    HKEY hKey1, hKey2;

	ghModule = GetModuleHandle("pchprov");

    // TO DO: Using 'Both' is preferable.  The framework is designed and written to support
    // free threaded code.  If you will be writing free-threaded code, uncomment these 
    // three lines.

    if(Is4OrMore())
        pModel = "Both";
    else
        pModel = "Apartment";

    // Create the path.

	CLSIDFromString(GUIDSTRING, &CLSID_PCH_WINSOCK);
    StringFromGUID2(CLSID_PCH_WINSOCK, wcID, 128);
    wcstombs(szID, wcID, 128);
    lstrcpy(szCLSID, TEXT("SOFTWARE\\CLASSES\\CLSID\\"));
    lstrcat(szCLSID, szID);

    // Create entries under CLSID

    RegCreateKey(HKEY_LOCAL_MACHINE, szCLSID, &hKey1);
    RegSetValueEx(hKey1, NULL, 0, REG_SZ, (BYTE *)pName, lstrlen(pName)+1);
    RegCreateKey(hKey1,"InprocServer32",&hKey2);

    GetModuleFileName(ghModule, szModule,  MAX_PATH);
    RegSetValueEx(hKey2, NULL, 0, REG_SZ, (BYTE *)szModule, 
                                        lstrlen(szModule)+1);
    RegSetValueEx(hKey2, "ThreadingModel", 0, REG_SZ, 
                                        (BYTE *)pModel, lstrlen(pModel)+1);
    CloseHandle(hKey1);
    CloseHandle(hKey2);
    return NOERROR;
}

//***************************************************************************
//
// DllUnregisterServer
//
// Purpose: Called when it is time to remove the registry entries.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllUnregisterServer(void)
{
    char       szID[128];
    WCHAR      wcID[128];
    char  szCLSID[128];
    HKEY hKey;

    // Create the path using the CLSID

	CLSIDFromString(GUIDSTRING, &CLSID_PCH_WINSOCK);
    StringFromGUID2(CLSID_PCH_WINSOCK, wcID, 128);
    wcstombs(szID, wcID, 128);
    lstrcpy(szCLSID, TEXT("SOFTWARE\\CLASSES\\CLSID\\"));
    lstrcat(szCLSID, szID);

    // First delete the InProcServer subkey.

    DWORD dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, szCLSID, &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey, "InProcServer32");
        CloseHandle(hKey);
    }

    dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\CLASSES\\CLSID\\"), &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey,szID);
        CloseHandle(hKey);
    }

    return NOERROR;
}

BOOL APIENTRY DllMain (	HINSTANCE hInstDLL,	// handle to dll module
						DWORD fdwReason,	// reason for calling function
						LPVOID lpReserved	)	// reserved
{
    BOOL bRet = TRUE;
	
	// Perform actions based on the reason for calling.
    switch( fdwReason ) 
    { 
        case DLL_PROCESS_ATTACH:
         // Initialize once for each new process.
         // Return FALSE to fail DLL load.
			bRet = CWbemProviderGlue::FrameworkLoginDLL(L"PCH_WINSOCK");
            break;

        case DLL_THREAD_ATTACH:
         // Do thread-specific initialization.
            break;

        case DLL_THREAD_DETACH:
         // Do thread-specific cleanup.
            break;

        case DLL_PROCESS_DETACH:
         // Perform any necessary cleanup.
            break;
    }

    return bRet;  // Sstatus of DLL_PROCESS_ATTACH.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprov\pch_cdrom.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    PCH_CDROM.CPP

Abstract:
    WBEM provider class implementation for PCH_CDROM class

Revision History:

    Ghim-Sim Chua       (gschua)   04/27/99
        - Created

    Ghim-Sim Chua       (gschua)   05/02/99
        - Modified code to use CopyProperty function
        - Use CComBSTR instead of USES_CONVERSION

********************************************************************/

#include "pchealth.h"
#include "PCH_CDROM.h"

/////////////////////////////////////////////////////////////////////////////
//  tracing stuff

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile
#define TRACE_ID    DCID_CDROM

CPCH_CDROM MyPCH_CDROMSet (PROVIDER_NAME_PCH_CDROM, PCH_NAMESPACE) ;

// Property names
//===============
const static WCHAR* pTimeStamp = L"TimeStamp" ;
const static WCHAR* pChange = L"Change" ;
const static WCHAR* pDataTransferIntegrity = L"DataTransferIntegrity" ;
const static WCHAR* pDescription = L"Description" ;
const static WCHAR* pDeviceID = L"DeviceID" ;
const static WCHAR* pDriveLetter = L"DriveLetter" ;
const static WCHAR* pManufacturer = L"Manufacturer" ;
const static WCHAR* pSCSITargetID = L"SCSITargetID" ;
const static WCHAR* pTransferRateKBS = L"TransferRateKBS" ;
const static WCHAR* pVolumeName = L"VolumeName" ;

/*****************************************************************************
*
*  FUNCTION    :    CPCH_CDROM::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                       WBEM_FLAG_DEEP
*                       WBEM_FLAG_SHALLOW
*                       WBEM_FLAG_RETURN_IMMEDIATELY
*                       WBEM_FLAG_FORWARD_ONLY
*                       WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    : TO DO: All instances on the machine should be returned here.
*                       If there are no instances, return WBEM_S_NO_ERROR.
*                       It is not an error to have no instances.
*
*****************************************************************************/
HRESULT
CPCH_CDROM::EnumerateInstances(
    MethodContext* pMethodContext,
    long lFlags
    )
{
    TraceFunctEnter("CPCH_CDROM::EnumerateInstances");

    HRESULT                             hRes = WBEM_S_NO_ERROR;
    REFPTRCOLLECTION_POSITION           posList;
    CComPtr<IEnumWbemClassObject>       pEnumInst;
    IWbemClassObjectPtr                 pObj;
    ULONG                               ulRetVal;

    //
    // Get the date and time
    //
	SYSTEMTIME stUTCTime;
	GetSystemTime(&stUTCTime);

    //
    // Execute the query
    //
    hRes = ExecWQLQuery(&pEnumInst, CComBSTR("SELECT DeviceID, Drive, VolumeName, TransferRate, DriveIntegrity, Description, SCSITargetId, Manufacturer FROM Win32_CDROMDrive"));
    if (FAILED(hRes))
        goto END;

	//
	// enumerate the instances from win32_CodecFile
	//
    while (WBEM_S_NO_ERROR == pEnumInst->Next(WBEM_INFINITE, 1, &pObj, &ulRetVal))
    {
        // Create a new instance based on the passed-in MethodContext. If this fails,
        // we don't need to check for a null pointer because it throws an exception.

        CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);
        CComVariant  varValue;

        if (!pInstance->SetDateTime(pTimeStamp, WBEMTime(stUTCTime)))
            ErrorTrace(TRACE_ID, "SetDateTime on Timestamp Field failed.");

        if (!pInstance->SetCHString(pChange, L"Snapshot"))
            ErrorTrace(TRACE_ID, "SetCHString on Change Field failed.");

        (void)CopyProperty(pObj, L"DriveIntegrity", pInstance, pDataTransferIntegrity);
        (void)CopyProperty(pObj, L"Description", pInstance, pDescription);
        (void)CopyProperty(pObj, L"DeviceID", pInstance, pDeviceID);
        (void)CopyProperty(pObj, L"Drive", pInstance, pDriveLetter);
        (void)CopyProperty(pObj, L"Manufacturer", pInstance, pManufacturer);
        (void)CopyProperty(pObj, L"SCSITargetId", pInstance, pSCSITargetID);
        (void)CopyProperty(pObj, L"TransferRate", pInstance, pTransferRateKBS);
        (void)CopyProperty(pObj, L"VolumeName", pInstance, pVolumeName);

    	hRes = pInstance->Commit();
        if (FAILED(hRes))
            ErrorTrace(TRACE_ID, "Commit on Instance failed.");
  }

END :
    TraceFunctLeave();
    return hRes ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprov\pch_bios.h ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_BIOS.H

Abstract:
	WBEM provider class definition for PCH_BIOS class

Revision History:

	Ghim-Sim Chua       (gschua)   05/05/99
		- Created

********************************************************************/

// Property set identification
//============================

#ifndef _PCH_BIOS_H_
#define _PCH_BIOS_H_

#define PROVIDER_NAME_PCH_BIOS "PCH_BIOS"

// Property name externs -- defined in PCH_BIOS.cpp
//=================================================

extern const WCHAR* pBIOSDate ;
extern const WCHAR* pBIOSName ;
extern const WCHAR* pBIOSVersion ;
extern const WCHAR* pCPU ;
extern const WCHAR* pINFName ;
extern const WCHAR* pMachineType ;
extern const WCHAR* pMediaID ;
extern const WCHAR* pChange;
extern const WCHAR* pTimeStamp;

class CPCH_BIOS : public Provider 
{
	public:
		// Constructor/destructor
		//=======================

		CPCH_BIOS(const CHString& chsClassName, LPCWSTR lpszNameSpace) : Provider(chsClassName, lpszNameSpace) {};
        virtual ~CPCH_BIOS() {};

	protected:
		// Reading Functions
		//============================
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Writing Functions
		//============================
		virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Other Functions
		virtual HRESULT ExecMethod( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags = 0L ) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprov\pch_bios.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_BIOS.CPP

Abstract:
	WBEM provider class implementation for PCH_BIOS class

Revision History:

	Ghim-Sim Chua       (gschua)   05/05/99
		- Created

    Kalyani Narlanka    (kalyanin)  05/12/99
        - Added Code to get all the properties of this class

    Kalyani Narlanka    (kalyanin)  05/18/99
        

********************************************************************/

#include "pchealth.h"
#include "PCH_BIOS.h"

/////////////////////////////////////////////////////////////////////////////
//  tracing stuff

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile
#define TRACE_ID    DCID_BIOS

CPCH_BIOS MyPCH_BIOSSet (PROVIDER_NAME_PCH_BIOS, PCH_NAMESPACE) ;

// Property names
//===============
const static WCHAR* pBIOSDate    = L"BIOSDate" ;
const static WCHAR* pBIOSName    = L"BIOSName" ;
const static WCHAR* pBIOSVersion = L"BIOSVersion" ;
const static WCHAR* pCPU         = L"CPU" ;
const static WCHAR* pINFName     = L"INFName" ;
const static WCHAR* pMachineType = L"MachineType" ;
const static WCHAR* pDriver      = L"Driver" ;
const static WCHAR* pDriverDate  = L"DriverDate" ;
const static WCHAR* pChange      = L"Change";
const static WCHAR* pTimeStamp   = L"TimeStamp";

/*****************************************************************************
*
*  FUNCTION    :    CPCH_BIOS::EnumerateInstances
*
*  DESCRIPTION :    Returns the instance of this class
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                       WBEM_FLAG_DEEP
*                       WBEM_FLAG_SHALLOW
*                       WBEM_FLAG_RETURN_IMMEDIATELY
*                       WBEM_FLAG_FORWARD_ONLY
*                       WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  SYSNOPSIS    : There is only instance of this class at any time. This function gives this 
*                  instance.
*                       If there are no instances, returns WBEM_S_NO_ERROR.
*                       It is not an error to have no instances.
*
*****************************************************************************/

HRESULT CPCH_BIOS::EnumerateInstances ( MethodContext* pMethodContext, long lFlags )
{

    //  Begin Declarations
    //

    TraceFunctEnter("CPCH_BIOS::EnumerateInstances");

    HRESULT                         hRes                            = WBEM_S_NO_ERROR;
    HRESULT                         hRes1;
    HRESULT                         hRes2;

     //  Query String
    
    CComBSTR                        bstrBIOSQuery                   = L"Select Name, ReleaseDate, Version FROM win32_BIOS";
    CComBSTR                        bstrProcessorQuery              = L"Select DeviceId, Name FROM win32_processor";
    CComBSTR                        bstrComputerSystemQuery         = L"Select Name, Description FROM win32_computerSystem";
    CComBSTR                        bstrDriver;

    //  Registry Hive where BIOS Info is stored
    LPCTSTR                         lpctstrSystemHive               = _T("System\\CurrentControlSet\\Services\\Class\\System");
  
    //   Registry Names of interest
    LPCTSTR                         lpctstrDriverDesc               = _T("DriverDesc");
    LPCTSTR                         lpctstrINFName                  = _T("INFPath");
    LPCTSTR                         lpctstrDriverDate               = _T("DriverDate");
    LPCTSTR                         lpctstrSystem                   = _T("System\\");

    //  Property Names
    LPCWSTR                         lpctstrReleaseDate              = L"ReleaseDate";
    LPCWSTR                         lpctstrName                     = L"Name";
    LPCWSTR                         lpctstrVersion                  = L"Version";
    LPCWSTR                         lpctstrDescription              = L"Description";
    LPCTSTR                         lpctstrSystemBoard              = _T("System Board");

    //  Strings
    TCHAR                           tchSubSystemKeyName[MAX_PATH]; 
    TCHAR                           tchDriverDescValue[MAX_PATH];
    TCHAR                           tchDriverDateValue[MAX_PATH];
    TCHAR                           tchINFNameValue[MAX_PATH];


    // Instances
    CComPtr<IEnumWbemClassObject>   pBIOSEnumInst;
    CComPtr<IEnumWbemClassObject>   pProcessorEnumInst;
    CComPtr<IEnumWbemClassObject>   pComputerSystemEnumInst;

    //  Instances
    //  CInstancePtr                   pPCHBIOSInstance;

    //  Objects
    IWbemClassObjectPtr             pBIOSObj;                   // BUGBUG : WMI asserts if we use CComPtr
    IWbemClassObjectPtr             pProcessorObj;              // BUGBUG : WMI asserts if we use CComPtr
    IWbemClassObjectPtr             pComputerSystemObj;         // BUGBUG : WMI asserts if we use CComPtr

    //  Variants
    CComVariant                     varDriver;
    CComVariant                     varDriverDate;
    CComVariant                     varINFName;
    CComVariant                     varSnapshot                     = "SnapShot";

    //  Unsigned Longs....
    ULONG                           ulBIOSRetVal                    = 0;
    ULONG                           ulProcessorRetVal               = 0;
    ULONG                           ulComputerSystemRetVal          = 0;

    LONG                            lRegRetVal;

    //  SystemTime
    SYSTEMTIME                      stUTCTime;

    //  Registry Keys
    HKEY                            hkeySystem;
    HKEY                            hkeySubSystem;

    //  DWORDs
    DWORD                           dwIndex                         = 0;
    DWORD                           dwSize                          = MAX_PATH;
    DWORD                           dwType;

    //  Boolean
    BOOL                            fContinueEnum                   = FALSE;
    BOOL                            fCommit                         = FALSE;
    
    //  FileTime
    PFILETIME                       pFileTime                       = NULL;

    //  End Declarations                            
    

    //  Create a new instance of PCH_BIOS Class based on the passed-in MethodContext
    CInstancePtr pPCHBIOSInstance(CreateNewInstance(pMethodContext), false);

   
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //                              TIME STAMP                                                                 //
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////

    // Get the date and time to update the TimeStamp Field
    GetSystemTime(&stUTCTime);

    hRes = pPCHBIOSInstance->SetDateTime(pTimeStamp, WBEMTime(stUTCTime));
    if (FAILED(hRes))
    {
        //  Could not Set the Time Stamp
        //  Continue anyway
        ErrorTrace(TRACE_ID, "SetDateTime on Timestamp Field failed.");
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //                              CHANGE                                                                     //
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////

    hRes = pPCHBIOSInstance->SetVariant(pChange, varSnapshot);
    if (FAILED(hRes))
    {
        //  Could not Set the Change Property
        //  Continue anyway
        ErrorTrace(TRACE_ID, "Set  Variant on Change Field failed.");
    }

    //  Execute the query to get Name, ReleaseDate, Version FROM Win32_BIOS
    //  Class.

    //  pBIOSEnumInst contains a pointer to the instance returned.

    hRes = ExecWQLQuery(&pBIOSEnumInst, bstrBIOSQuery );
    if (SUCCEEDED(hRes))
    {
        //  Query Succeeded!
        
        //  Get the instance Object.
        if((pBIOSEnumInst->Next(WBEM_INFINITE, 1, &pBIOSObj, &ulBIOSRetVal)) == WBEM_S_NO_ERROR)
        {

            //  Get Name, Date and Version
       
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////
            //                              BIOSDATE                                                                   //
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////
            
            CopyProperty(pBIOSObj, lpctstrReleaseDate, pPCHBIOSInstance, pBIOSDate);

            /////////////////////////////////////////////////////////////////////////////////////////////////////////////
            //                              BIOSNAME                                                                   //
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                
            hRes = CopyProperty(pBIOSObj, lpctstrName, pPCHBIOSInstance, pBIOSName);
            if(SUCCEEDED(hRes))
            {
                fCommit = TRUE;
            }

            /////////////////////////////////////////////////////////////////////////////////////////////////////////////
            //                              BIOSVERSION                                                                //
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////

            CopyProperty(pBIOSObj, lpctstrVersion, pPCHBIOSInstance, pBIOSVersion);

        }

    }
    //  Done with Win32_BIOS Class

    //  Now query Win32_Processor Class to get  "CPU" property

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //                              CPU                                                                    //
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    
    hRes = ExecWQLQuery(&pProcessorEnumInst, bstrProcessorQuery);
    if (SUCCEEDED(hRes))
    {
        //  Query Succeeded!
        
        //  Get the instance Object.
        if((pProcessorEnumInst->Next(WBEM_INFINITE, 1, &pProcessorObj, &ulProcessorRetVal)) == WBEM_S_NO_ERROR)
        {

            //  Get Name
       
            CopyProperty(pProcessorObj, lpctstrName, pPCHBIOSInstance, pCPU);

        }
    }


    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //                              MACHINETYPE                                                                    //
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    
    hRes = ExecWQLQuery(&pComputerSystemEnumInst, bstrComputerSystemQuery);
    if (SUCCEEDED(hRes))
    {
        //  Query Succeeded!
        
        //  Get the instance Object.
        if((pComputerSystemEnumInst->Next(WBEM_INFINITE, 1, &pComputerSystemObj, &ulComputerSystemRetVal)) == WBEM_S_NO_ERROR)
        {

            //  Get "Description"
       
            CopyProperty(pComputerSystemObj, lpctstrDescription, pPCHBIOSInstance, pMachineType);

                  

        }
    }
    
    //  Get the remaining properties i.e. INFName, Driver and DriverDate  from the Registry
    //  This is present in one of the keys under the HIVE "HKLM\System\CCS\Services\Class\System"
    //  Enumerate keys under this hive until the regname "DeviceDesc" equals "System Board"

    //  Once you hit "DeviceDesc" = "System Board"  get the INFpath, Driver
    //  DriverDate from there.
    
    lRegRetVal = RegOpenKeyEx(HKEY_LOCAL_MACHINE, lpctstrSystemHive, 0, KEY_READ, &hkeySystem);
    if(lRegRetVal == ERROR_SUCCESS)
	{
		// Opened the Registry key.
        // Enumerate the keys under this hive. One of the keys has 
        // DeviceDesc = "system Board".

        lRegRetVal = RegEnumKeyEx(hkeySystem, dwIndex,  tchSubSystemKeyName, &dwSize, NULL, NULL, NULL, pFileTime);
        if(lRegRetVal == ERROR_SUCCESS)
        {
            fContinueEnum = TRUE;
        }
        while(fContinueEnum)
        {

            //  Open the SubKey.
            lRegRetVal = RegOpenKeyEx(hkeySystem,  tchSubSystemKeyName, 0, KEY_READ, &hkeySubSystem);
            if(lRegRetVal == ERROR_SUCCESS)
            {
                //  Opened the SubKey
                //  Query for , regname "DriverDesc "
                dwSize = MAX_PATH;
                lRegRetVal = RegQueryValueEx(hkeySubSystem, lpctstrDriverDesc , NULL, &dwType, (LPBYTE)tchDriverDescValue, &dwSize);
                if(lRegRetVal == ERROR_SUCCESS)
                {
                    //  Compare if  the value is equal to "System Board"
                    if(_tcsicmp(tchDriverDescValue, lpctstrSystemBoard) == 0)
                    {
                        //  The following statements could 
                        try
                        {
                            // Found the Right DriverDesc 
                            /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                            //                              DRIVER                                                                    //
                            /////////////////////////////////////////////////////////////////////////////////////////////////////////////

                            // Driver = system+lptstrSubSystemKeyName
                            bstrDriver = lpctstrSystem;
                            bstrDriver.Append(tchSubSystemKeyName);
                            varDriver = bstrDriver.Copy();
                            hRes2 = pPCHBIOSInstance->SetVariant(pDriver, varDriver);
                            if(FAILED(hRes2))
                            {
                                //  Could not Set the DRIVER Property
                                //  Continue anyway
                                ErrorTrace(TRACE_ID, "Set variant on Driver Failed.");
                            }


                            /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                            //                              DRIVERDATE                                                                 //
                            /////////////////////////////////////////////////////////////////////////////////////////////////////////////

                            // Query for DriverDate
                            dwSize = MAX_PATH;
                            lRegRetVal = RegQueryValueEx(hkeySubSystem, lpctstrDriverDate, NULL, &dwType, (LPBYTE)tchDriverDescValue, &dwSize);
                            if(lRegRetVal == ERROR_SUCCESS)
                            {
                                //  Set the DriverDate
                                varDriverDate = tchDriverDescValue;
                                hRes2 = pPCHBIOSInstance->SetVariant(pDriverDate, varDriverDate);
                                if(FAILED(hRes2))
                                {
                                    //  Could not Set the DRIVERDATE Property
                                    //  Continue anyway
                                    ErrorTrace(TRACE_ID, "Set variant on DriverDate Failed.");
                                }
                            }

                            /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                            //                              INFNAME                                                                     //
                            /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                        
                            // Query for INFName
                            dwSize = MAX_PATH;
                            lRegRetVal = RegQueryValueEx(hkeySubSystem, lpctstrINFName, NULL, &dwType, (LPBYTE)tchINFNameValue, &dwSize);
                            if(lRegRetVal == ERROR_SUCCESS)
                            {
                                //  Set the INFName
                                varINFName = tchINFNameValue;
                                hRes2 = pPCHBIOSInstance->SetVariant(pINFName, varINFName);
                                if(FAILED(hRes2))
                                {
                                    //  Could not Set the INFNAME Property
                                    //  Continue anyway
                                    ErrorTrace(TRACE_ID, "Set variant on INFNAME Property Failed.");
                                }
                            
                            }

                            // Need not enumerate the rest of the keys
                            fContinueEnum = FALSE;
                        }
                        catch(...)
                        {
                            lRegRetVal = RegCloseKey(hkeySubSystem);
                            lRegRetVal = RegCloseKey(hkeySystem);
                            throw;
                        }

                    }  // end of strcmp
                    
                }  // end of Succeeded  hRes2
                //  Close the Opened Regkey
                lRegRetVal = RegCloseKey(hkeySubSystem);
                if(lRegRetVal != ERROR_SUCCESS)
                {
                    //  Could not close the reg Key
                    ErrorTrace(TRACE_ID, "RegClose Sub Key Failed.");
                }
               
            }
            //  Check to see if further enumeration is required.
            //  continue to enumerate.
            if(fContinueEnum)
            {
                dwSize = MAX_PATH;
		        dwIndex++;
                lRegRetVal = RegEnumKeyEx(hkeySystem, dwIndex,  tchSubSystemKeyName, &dwSize, NULL, NULL, NULL, pFileTime);
                if(lRegRetVal != ERROR_SUCCESS)
                {
                    fContinueEnum = FALSE;
                }
                
            }
            
                    
        } // end of while
        lRegRetVal = RegCloseKey(hkeySystem);
        if(lRegRetVal != ERROR_SUCCESS)
        {
             //  Could not close the reg Key
             ErrorTrace(TRACE_ID, "RegClose Key Failed.");
        }
    }

    // Got all the properties for PCH_BIOS Class

    if(fCommit)
    {
        hRes = pPCHBIOSInstance->Commit();
        if(FAILED(hRes))
        {
            //  Could not Commit the instance
            ErrorTrace(TRACE_ID, "Commit on PCHBiosInstance Failed");
        }
    }

    TraceFunctLeave();
    return hRes ;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprov\pch_codec.h ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_Codec.H

Abstract:
	WBEM provider class definition for PCH_Codec class

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

********************************************************************/

// Property set identification
//============================

#ifndef _PCH_Codec_H_
#define _PCH_Codec_H_

#define PROVIDER_NAME_PCH_CODEC "PCH_Codec"

// Property name externs -- defined in PCH_Codec.cpp
//=================================================

extern const WCHAR* pCategory ;
extern const WCHAR* pTimeStamp ;
extern const WCHAR* pChange ;
extern const WCHAR* pCodecDriver ;
extern const WCHAR* pDate ;
extern const WCHAR* pDescription ;
extern const WCHAR* pGroupName ;
extern const WCHAR* pkey ;
extern const WCHAR* pSize ;
extern const WCHAR* pVersion ;

class CPCH_Codec : public Provider 
{
	public:
		// Constructor/destructor
		//=======================

		CPCH_Codec(const CHString& chsClassName, LPCWSTR lpszNameSpace) : Provider(chsClassName, lpszNameSpace) {};
		virtual ~CPCH_Codec() {};

	protected:
		// Reading Functions
		//============================
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Writing Functions
		//============================
		virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Other Functions
		virtual HRESULT ExecMethod( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags = 0L ) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprov\pch_codec.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    PCH_Codec.CPP

Abstract:
    WBEM provider class implementation for PCH_CODEC class

Revision History:

    Ghim-Sim Chua       (gschua)   04/27/99
        - created

    Ghim-Sim Chua       (gschua)   05/02/99
        - Modified code to use CopyProperty function
        - Use CComBSTR instead of USES_CONVERSION

    Jim Martin          (a-jammar) 05/13/99
        - Picked up the remaining properties (groupname and key
          from the registry.

********************************************************************/

#include "pchealth.h"
#include "PCH_Codec.h"

/////////////////////////////////////////////////////////////////////////////
//  tracing stuff

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile
#define TRACE_ID    DCID_CODEC

CPCH_Codec MyPCH_CodecSet (PROVIDER_NAME_PCH_CODEC, PCH_NAMESPACE) ;

// Property names
//===============
const static WCHAR* pCategory = L"Category" ;
const static WCHAR* pTimeStamp = L"TimeStamp" ;
const static WCHAR* pChange = L"Change" ;
const static WCHAR* pCodecDriver = L"CodecDriver" ;
const static WCHAR* pDate = L"Date" ;
const static WCHAR* pDescription = L"Description" ;
const static WCHAR* pGroupName = L"GroupName" ;
const static WCHAR* pkey = L"key" ;
const static WCHAR* pSize = L"Size" ;
const static WCHAR* pVersion = L"Version" ;

//-----------------------------------------------------------------------------
// Part of the data from the PCH_CODEC class does not come from the cimv2
// Win32_CODECFile class, but from the registry. The "GroupName" and "Key"
// properties are found at:
//
//    HKLM\System\CurrentControlSet\Control\MediaResources\<group>\<key>:driver
//
// Where the "driver" value is equal to the filename of the CODEC. Due to the 
// way this part of the registry is constructed, we can't find the <group>
// and <key> given the driver name. We'll need to build a map from driver
// to <group> and <key> - building the map requires traversing the registry.
//
// This class is used as a helper for that lookup. When it's created, it
// scans the registry, processing all of the CODEC entries. It can then
// be queried for the key and group associated with a driver.
//-----------------------------------------------------------------------------

#define MAX_DRIVER_LEN  MAX_PATH
#define MAX_KEY_LEN     MAX_PATH
#define MAX_GROUP_LEN   MAX_PATH

class CCODECInfo
{
public:
    CCODECInfo();
    ~CCODECInfo();

    BOOL QueryCODECInfo(LPCTSTR szDriver, LPCSTR * pszKey, LPCSTR * pszGroup);

private:
    struct SCODECNode
    {
        TCHAR        m_szDriver[MAX_DRIVER_LEN];
        TCHAR        m_szKey[MAX_KEY_LEN];
        TCHAR        m_szGroup[MAX_GROUP_LEN];
        SCODECNode * m_pNext;
    };

    SCODECNode * m_pCODECList;
};

//-----------------------------------------------------------------------------
// The constructor reads the CODEC info from the registry and builds a linked
// list (unsorted) of entries. The destructor deletes it.
//-----------------------------------------------------------------------------

CCODECInfo::CCODECInfo() : m_pCODECList(NULL)
{
    TraceFunctEnter("CCODECInfo::CCODECInfo");

    LPCTSTR szCODECKey = _T("System\\CurrentControlSet\\Control\\MediaResources");
    LPTSTR  szDrvValue = _T("driver");
    
    HKEY hkeyCODEC;
    if (ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE, szCODECKey, 0, KEY_READ, &hkeyCODEC))
        ErrorTrace(TRACE_ID, "RegOpenKeyEx failed on CODEC key.");
    else
    {
        // Enumerate each subkey of the CODEC key. Each subkey corresponds to a group.

        DWORD       dwGroupIndex = 0;
        DWORD       dwSize = MAX_GROUP_LEN;
        FILETIME    ft;
        TCHAR       szGroup[MAX_GROUP_LEN];
        TCHAR       szKey[MAX_KEY_LEN];
        TCHAR       szDriver[MAX_DRIVER_LEN];

        while (ERROR_SUCCESS == RegEnumKeyEx(hkeyCODEC, dwGroupIndex, szGroup, &dwSize, 0, NULL, NULL, &ft))
        {
            // Open the group subkey. Then enumerate it's subkeys. These will be the keys.

            HKEY hkeyGroup;
            if (ERROR_SUCCESS != RegOpenKeyEx(hkeyCODEC, szGroup, 0, KEY_READ, &hkeyGroup))
                ErrorTrace(TRACE_ID, "RegOpenKeyEx failed on group key = %s.", szGroup);
            else
            {
                dwSize = MAX_KEY_LEN;

                DWORD dwKeyIndex = 0;
                while (ERROR_SUCCESS == RegEnumKeyEx(hkeyGroup, dwKeyIndex, szKey, &dwSize, 0, NULL, NULL, &ft))
                {
                    // For each key, attempt to get the value named "driver". This is the
                    // filename for the driver for this CODEC.

                    HKEY hkeyKey;
                    if (ERROR_SUCCESS != RegOpenKeyEx(hkeyGroup, szKey, 0, KEY_READ, &hkeyKey))
                        ErrorTrace(TRACE_ID, "RegOpenKeyEx failed on key = %s.", szKey);
                    else
                    {
                        // Note - there's no trace here because sometimes there may not be
                        // a driver value, and this is not an error for us.

                        dwSize = MAX_DRIVER_LEN * sizeof(TCHAR); // this wants the size in bytes

                        DWORD dwType = REG_SZ;
                        if (ERROR_SUCCESS == RegQueryValueEx(hkeyKey, szDrvValue, NULL, &dwType, (LPBYTE) szDriver, &dwSize))
                        {
                            if (*szGroup && *szKey && *szDriver)
                            {
                                // Here's where we insert a value into the map, using
                                // the strings szDriver, szKey and szGroup.

                                SCODECNode * pNew = new SCODECNode;
                                if (!pNew)
                                {
                                    ErrorTrace(TRACE_ID, "Out of memory.");
                                    RegCloseKey(hkeyKey);
                                    RegCloseKey(hkeyGroup);
                                    RegCloseKey(hkeyCODEC);
                                    throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
                                }

                                _tcscpy(pNew->m_szDriver, szDriver);
                                _tcscpy(pNew->m_szKey, szKey);
                                _tcscpy(pNew->m_szGroup, szGroup);
                                pNew->m_pNext = m_pCODECList;
                                m_pCODECList = pNew;
                            }
                        }

                        if (ERROR_SUCCESS != RegCloseKey(hkeyKey))
                            ErrorTrace(TRACE_ID, "RegCloseKey failed on key.");
                    }

                    dwSize = MAX_KEY_LEN;
                    dwKeyIndex += 1;
                }

                if (ERROR_SUCCESS != RegCloseKey(hkeyGroup))
                    ErrorTrace(TRACE_ID, "RegCloseKey failed on key.");
            }

            dwSize = MAX_GROUP_LEN;
            dwGroupIndex += 1;
        }

        if (ERROR_SUCCESS != RegCloseKey(hkeyCODEC))
            ErrorTrace(TRACE_ID, "RegCloseKey failed on CODEC key.");
    }

    TraceFunctLeave();
}

CCODECInfo::~CCODECInfo()
{
    TraceFunctEnter("CCODECInfo::~CCODECInfo");

    while (m_pCODECList)
    {
        SCODECNode * pNext = m_pCODECList->m_pNext;
        delete m_pCODECList;
        m_pCODECList = pNext;
    }
    
    TraceFunctLeave();
}

//-----------------------------------------------------------------------------
// Search for the requested driver in the list of CODEC information entries.
// If it's found, set pszKey and pszGroup to point to the key and group strings
// in the entry and return TRUE, otherwise return FALSE. Note: copies of the
// strings are not made, so the caller is not responsible for deallocating
// the strings. Another note: the string pointers won't be valid after the
// CCODECInfo object is destructed.
//-----------------------------------------------------------------------------

BOOL CCODECInfo::QueryCODECInfo(LPCTSTR szDriver, LPCTSTR * pszKey, LPCTSTR * pszGroup)
{
    TraceFunctEnter("CCODECInfo::QueryCODECInfo");

    _ASSERT(szDriver && pszKey && pszGroup);

    SCODECNode * pScan = m_pCODECList;
    BOOL         fReturn = FALSE;

    while (pScan)
    {
        if (0 == _tcscmp(szDriver, pScan->m_szDriver))
        {
            *pszKey = pScan->m_szKey;
            *pszGroup = pScan->m_szGroup;
            fReturn = TRUE;
            break;
        }

        pScan = pScan->m_pNext;
    }

    TraceFunctLeave();
    return fReturn;
}

/*****************************************************************************
*
*  FUNCTION    :    CPCH_Codec::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                       WBEM_FLAG_DEEP
*                       WBEM_FLAG_SHALLOW
*                       WBEM_FLAG_RETURN_IMMEDIATELY
*                       WBEM_FLAG_FORWARD_ONLY
*                       WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    : TO DO: All instances on the machine should be returned here.
*                       If there are no instances, return WBEM_S_NO_ERROR.
*                       It is not an error to have no instances.
*
*****************************************************************************/

HRESULT CPCH_Codec::EnumerateInstances(MethodContext * pMethodContext, long lFlags)
{
    TraceFunctEnter("CPCH_Codec::EnumerateInstances");

    USES_CONVERSION;
    HRESULT                             hRes = WBEM_S_NO_ERROR;
    REFPTRCOLLECTION_POSITION           posList;
    CComPtr<IEnumWbemClassObject>       pEnumInst;
    IWbemClassObjectPtr                 pObj;
    ULONG                               ulRetVal;
    
    // This instance of CCODECInfo will provide some of the missing information
    // about each CODEC. Constructing it queries the registry for CODEC info.

    CCODECInfo codecinfo;

    // Get the date and time

    SYSTEMTIME stUTCTime;
    GetSystemTime(&stUTCTime);

    // Execute the query

    hRes = ExecWQLQuery(&pEnumInst, CComBSTR("SELECT * FROM Win32_CodecFile"));
    if (FAILED(hRes))
        goto END;

    // enumerate the instances from win32_CodecFile

    while (WBEM_S_NO_ERROR == pEnumInst->Next(WBEM_INFINITE, 1, &pObj, &ulRetVal))
    {
        // Create a new instance based on the passed-in MethodContext

        CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);
        CComVariant  varValue;

        if (!pInstance->SetDateTime(pTimeStamp, WBEMTime(stUTCTime)))
            ErrorTrace(TRACE_ID, "SetDateTime on Timestamp Field failed.");

        if (!pInstance->SetCHString(pChange, L"Snapshot"))
            ErrorTrace(TRACE_ID, "SetCHString on Change Field failed.");

        (void)CopyProperty(pObj, L"group", pInstance, pCategory);
        (void)CopyProperty(pObj, L"name", pInstance, pCodecDriver);
        (void)CopyProperty(pObj, L"description", pInstance, pDescription);
        (void)CopyProperty(pObj, L"filesize", pInstance, pSize);
        (void)CopyProperty(pObj, L"version", pInstance, pVersion);

        // BUGBUG: WMI does not seem to be populating this field correctly.
        // Even though Win32_CODECFile is derived from CIM_DataFile, it doesn't
        // seem to be inheriting CreationDate. This is what we'd like to do:
        //
        // (void)CopyProperty(pObj, "CreationDate", pInstance, pDate);

        // Get the data which is missing from the Win32_CODECClass. Use the
        // instance of CCODECInfo we declared - we need to pass in just the
        // driver name (without the complete path).

        CComBSTR bstrDriver("name");
        if (FAILED(pObj->Get(bstrDriver, 0, &varValue, NULL, NULL)))
            ErrorTrace(TRACE_ID, "GetVariant on pCodecDriver field failed.");
        else
        {
            CComBSTR    ccombstrValue(V_BSTR(&varValue));

            // Because Win32_CODECFile doesn't seem to be inheriting
            // CreationDate, we need to get the actual creation date
            // by calling API functions.

            LPTSTR szName = W2T(ccombstrValue);
            HANDLE hFile = CreateFile(szName, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);
            if (INVALID_HANDLE_VALUE == hFile)
                ErrorTrace(TRACE_ID, "Couldn't open codec file to get date.");
            else
            {
                SYSTEMTIME stFileTime;
                FILETIME ftFileTime;

                if (GetFileTime(hFile, NULL, NULL, &ftFileTime))
                    if (FileTimeToSystemTime(&ftFileTime, &stFileTime))
                        if (!pInstance->SetDateTime(pDate, WBEMTime(stFileTime)))
                            ErrorTrace(TRACE_ID, "SetDateTime on date field failed.");

                CloseHandle(hFile);
            }

            // We need to convert the string from a BSTR to a LPCTSTR,
            // and to only include the file part (without the path).

            UINT uLen = SysStringLen(ccombstrValue);

            // Scan backwards through the string until we've either reached
            // the start (shouldn't happen) or a '\'.

            UINT iChar = uLen - 1;
            while (iChar && ccombstrValue[iChar] != L'\\')
                iChar -= 1;

            // Then scan to the end of the string, copying the filename.

            if (ccombstrValue[iChar] == L'\\')
                iChar += 1;

            TCHAR szDriver[MAX_DRIVER_LEN + 1] = _T("");
            int   i = 0;

            while (iChar < uLen && i < MAX_DRIVER_LEN)
                szDriver[i++] = (TCHAR) ccombstrValue[iChar++];
            szDriver[i] = _T('\0');

            LPCSTR szKey = NULL;
            LPCSTR szGroup = NULL;
            if (codecinfo.QueryCODECInfo(szDriver, &szKey, &szGroup))
            {
                if (!pInstance->SetCHString(pkey, szKey))
                    ErrorTrace(TRACE_ID, "SetCHString on key field failed.");

                if (!pInstance->SetCHString(pGroupName, szGroup))
                    ErrorTrace(TRACE_ID, "SetCHString on group field failed.");
            }
            else if (codecinfo.QueryCODECInfo(szName, &szKey, &szGroup))
            {
                // Sometimes the CODEC is stored in the registry with a complete
                // path. If we can't find the CODEC based on just the filename,
                // we might find it with the path.

                if (!pInstance->SetCHString(pkey, szKey))
                    ErrorTrace(TRACE_ID, "SetCHString on key field failed.");

                if (!pInstance->SetCHString(pGroupName, szGroup))
                    ErrorTrace(TRACE_ID, "SetCHString on group field failed.");
            }
        }
        
    	hRes = pInstance->Commit();
        if (FAILED(hRes))
            ErrorTrace(TRACE_ID, "Commit on Instance failed.");
    }

END:
    TraceFunctLeave();
    return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprov\pch_cdrom.h ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_CDROM.H

Abstract:
	WBEM provider class definition for PCH_CDROM class

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

********************************************************************/

// Property set identification
//============================

#ifndef _PCH_CDROM_H_
#define _PCH_CDROM_H_

#define PROVIDER_NAME_PCH_CDROM "PCH_CDROM"

// Property name externs -- defined in PCH_CDROM.cpp
//=================================================

extern const WCHAR* pChange ;
extern const WCHAR* pTimeStamp ;
extern const WCHAR* pDataTransferIntegrity ;
extern const WCHAR* pDescription ;
extern const WCHAR* pDeviceID ;
extern const WCHAR* pDriveLetter ;
extern const WCHAR* pManufacturer ;
extern const WCHAR* pSCSITargetID ;
extern const WCHAR* pTransferRateKBS ;
extern const WCHAR* pVolumeName ;

class CPCH_CDROM : public Provider 
{
	public:
		// Constructor/destructor
		//=======================

		CPCH_CDROM(const CHString& chsClassName, LPCWSTR lpszNameSpace) : Provider(chsClassName, lpszNameSpace) {};
		virtual ~CPCH_CDROM() {};

	protected:
		// Reading Functions
		//============================
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Writing Functions
		//============================
		virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Other Functions
		virtual HRESULT ExecMethod( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags = 0L ) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprov\pch_device.h ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_Device.H

Abstract:
	WBEM provider class definition for PCH_Device class

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

********************************************************************/

// Property set identification
//============================

#ifndef _PCH_Device_H_
#define _PCH_Device_H_

#define PROVIDER_NAME_PCH_DEVICE "PCH_Device"

// Property name externs -- defined in PCH_Device.cpp
//=================================================

extern const WCHAR* pCategory ;
extern const WCHAR* pTimeStamp ;
extern const WCHAR* pChange ;
extern const WCHAR* pDescription ;
extern const WCHAR* pDriveLetter ;
extern const WCHAR* pHWRevision ;
extern const WCHAR* pName ;
extern const WCHAR* pRegkey ;

class CPCH_Device : public Provider 
{
	public:
		// Constructor/destructor
		//=======================

		CPCH_Device(const CHString& chsClassName, LPCWSTR lpszNameSpace) : Provider(chsClassName, lpszNameSpace) {};
		virtual ~CPCH_Device() {};

	protected:
		// Reading Functions
		//============================
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
        virtual bool IsOneOfMe(void* a_pv);

		// Writing Functions
		//============================
		virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Other Functions
		virtual HRESULT ExecMethod( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags = 0L ) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprov\pch_device.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_Device.CPP

Abstract:
	WBEM provider class implementation for PCH_Device class

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

********************************************************************/

#include "pchealth.h"
#include "PCH_Device.h"
#include "confgmgr.h"
#include <cregcls.h>

/////////////////////////////////////////////////////////////////////////////
//  tracing stuff

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile
#define TRACE_ID    DCID_DEVICE

CPCH_Device MyPCH_DeviceSet (PROVIDER_NAME_PCH_DEVICE, PCH_NAMESPACE) ;

// Property names
//===============
const static WCHAR* pCategory = L"Category" ;
const static WCHAR* pTimeStamp = L"TimeStamp" ;
const static WCHAR* pChange = L"Change" ;
const static WCHAR* pDescription = L"Description" ;
const static WCHAR* pDriveLetter = L"DriveLetter" ;
const static WCHAR* pHWRevision = L"HWRevision" ;
const static WCHAR* pName = L"Name" ;
const static WCHAR* pRegkey = L"Regkey" ;

/*****************************************************************************
*
*  FUNCTION    :    CPCH_Device::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                       WBEM_FLAG_DEEP
*                       WBEM_FLAG_SHALLOW
*                       WBEM_FLAG_RETURN_IMMEDIATELY
*                       WBEM_FLAG_FORWARD_ONLY
*                       WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    : TO DO: All instances on the machine should be returned here.
*                       If there are no instances, return WBEM_S_NO_ERROR.
*                       It is not an error to have no instances.
*
*****************************************************************************/
HRESULT CPCH_Device::EnumerateInstances(
    MethodContext* pMethodContext,
    long lFlags
    )
{
    TraceFunctEnter("CPCH_Device::EnumerateInstances");

    CConfigManager cfgManager;
    CDeviceCollection deviceList;
    HRESULT hRes = WBEM_S_NO_ERROR;
    //
    // Get the date and time
    //
	SYSTEMTIME stUTCTime;
	GetSystemTime(&stUTCTime);

    if ( cfgManager.GetDeviceList( deviceList ) ) 
    {
        REFPTR_POSITION pos;
    
        if ( deviceList.BeginEnum( pos ) ) 
        {
            try
            {
                CConfigMgrDevice* pDevice = NULL;
        
                // Walk the list
                while ( (NULL != ( pDevice = deviceList.GetNext( pos ) ) ) )
                {

                    try
                    {
                       if(IsOneOfMe(pDevice))

                       {

                            // Create a new instance based on the passed-in MethodContext
                            CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);
                            CHString chstrVar;

                            if (!pInstance->SetDateTime(pTimeStamp, WBEMTime(stUTCTime)))
                                ErrorTrace(TRACE_ID, "SetDateTime on Timestamp Field failed.");

                            if (!pInstance->SetCHString(pChange, L"Snapshot"))
                                ErrorTrace(TRACE_ID, "SetCHString on Change Field failed.");

                            // Description
                            if (pDevice->GetDeviceDesc(chstrVar))
                                if (!pInstance->SetCHString(pDescription, chstrVar))
                                    ErrorTrace(TRACE_ID, "SetCHString on Description field failed.");

                            // Name & Regkey
                            if (pDevice->GetDeviceID(chstrVar))
                            {
                                // Name
                                if (!pInstance->SetCHString(pName, chstrVar))
                                    ErrorTrace(TRACE_ID, "SetCHString on Name field failed.");

                                // Regkey
                                CHString chstrTemp("HKEY_LOCAL_MACHINE\\enum\\");
                                chstrTemp += chstrVar;
                                if (!pInstance->SetCHString(pRegkey, chstrTemp))
                                    ErrorTrace(TRACE_ID, "SetCHString on Category field failed.");

                                // try to get the HW Revision
                                {
                                    CHString chstrKey("enum\\");
                                    chstrKey += chstrVar;
                    
                                    // Open the key in the registry and get the value
                                    CRegistry RegInfo;
                                    CHString strHWRevision;
                                    if (RegInfo.Open(HKEY_LOCAL_MACHINE, chstrKey, KEY_READ) == ERROR_SUCCESS)
                                    {
                                        try
                                        {
                                            if (RegInfo.GetCurrentKeyValue(L"HWRevision", strHWRevision) == ERROR_SUCCESS)
                                            {
                                                if (!pInstance->SetCHString(pHWRevision, strHWRevision))
                                                    ErrorTrace(TRACE_ID, "SetCHString on HWRevision field failed.");
                                            }
                                        }
                                        catch(...)
                                        {
                                            RegInfo.Close();
                                            throw;
                                        }
                                        RegInfo.Close();
                                    }
                                }
                            }

                            // Category
                            if (pDevice->GetClass(chstrVar))
                                if (!pInstance->SetCHString(pCategory, chstrVar))
                                    ErrorTrace(TRACE_ID, "SetCHString on Category field failed.");
    
                            hRes = pInstance->Commit();
                            if (FAILED(hRes))
                                ErrorTrace(TRACE_ID, "Commit on Instance failed.");
                       }

                    }
                    catch(...)
                    {
                        // GetNext() AddRefs
                        pDevice->Release();
                        throw;
                    }

                    // GetNext() AddRefs
                    pDevice->Release();
                }
            }
            catch(...)
            {
                // Always call EndEnum().  For all Beginnings, there must be an End
                deviceList.EndEnum();
                throw;
            }
        
            // Always call EndEnum().  For all Beginnings, there must be an End
            deviceList.EndEnum();
        }
    }

    TraceFunctLeave();
    return hRes ;
}

bool CPCH_Device::IsOneOfMe
(
    void* pv
)
{
    DWORD dwStatus;
    CConfigMgrDevice* pDevice = (CConfigMgrDevice*)pv;

    // This logic is what the nt5 device manager uses to
    // hide what it calls 'hidden' devices.  These devices
    // can be viewed by using the View/Show Hidden Devices.

    if (pDevice->GetConfigFlags( dwStatus ) &&          // If we can read the status
        ((dwStatus & DN_NO_SHOW_IN_DM) == 0) &&         // Not marked as hidden

        ( !(pDevice->IsClass(L"Legacy")) )              // Not legacy

        )
    {
        return true;
    }
    else
    {
        // Before we disqualify this device, see if it has any resources.
        CResourceCollection resourceList;

        pDevice->GetResourceList(resourceList);

        return resourceList.GetSize() != 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprov\pch_drive.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    PCH_Drive.CPP

Abstract:
    WBEM provider class implementation for PCH_Drive class

Revision History:

    Ghim-Sim Chua       (gschua)   04/27/99
        - Created

    Ghim-Sim Chua       (gschua)   05/02/99
        - Modified code to use CopyProperty function
        - Use CComBSTR instead of USES_CONVERSION

********************************************************************/

#include "pchealth.h"
#include "PCH_Drive.h"

/////////////////////////////////////////////////////////////////////////////
//  tracing stuff

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile
#define TRACE_ID    DCID_DRIVE

#define   maxMediaTypes         (sizeof(szMediaTypeStrings)/sizeof(*szMediaTypeStrings))
#define   KILO                   1024
#define   MAXSIZE                65

const  static  LPCTSTR    szMediaTypeStrings[] = 
{
    _T("Format is Unknown "),                        
    _T("5.25\", 1.2MB,  512 bytes/sector "),         
    _T("3.5\",  1.44MB, 512 bytes/sector "),         
    _T("3.5\",  2.88MB, 512 bytes/sector "),         
    _T("3.5\",  20.8MB, 512 bytes/sector "),         
    _T("3.5\",  720KB,  512 bytes/sector "),         
    _T("5.25\", 360KB,  512 bytes/sector "),         
    _T("5.25\", 320KB,  512 bytes/sector "),         
    _T("5.25\", 320KB,  1024 bytes/sector"),         
    _T("5.25\", 180KB,  512 bytes/sector "),         
    _T("5.25\", 160KB,  512 bytes/sector "),
    _T("Removable media other than floppy "),
    _T("Fixed hard disk media            "),
    _T("3.5\", 120M Floppy                "),
    _T("3.5\" ,  640KB,  512 bytes/sector "),
    _T("5.25\",  640KB,  512 bytes/sector "),
    _T("5.25\",  720KB,  512 bytes/sector "),
    _T("3.5\" ,  1.2Mb,  512 bytes/sector "),
    _T("3.5\" ,  1.23Mb, 1024 bytes/sector"),
    _T("5.25\",  1.23MB, 1024 bytes/sector"),
    _T("3.5\" MO 128Mb   512 bytes/sector "),
    _T("3.5\" MO 230Mb   512 bytes/sector "),
    _T("8\",     256KB,  128 bytes/sector ")
};

CPCH_Drive MyPCH_DriveSet (PROVIDER_NAME_PCH_DRIVE, PCH_NAMESPACE) ;

// Property names
//===============
const static WCHAR* pAvailable = L"Available" ;
const static WCHAR* pTimeStamp = L"TimeStamp" ;
const static WCHAR* pChange = L"Change" ;
const static WCHAR* pDriveLetter = L"DriveLetter" ;
const static WCHAR* pFilesystemType = L"FilesystemType" ;
const static WCHAR* pFree = L"Free" ;
const static WCHAR* pDescription = L"Description";
const static WCHAR* pMediaType = L"MediaType";

/*****************************************************************************
*
*  FUNCTION    :    CPCH_Drive::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                       WBEM_FLAG_DEEP
*                       WBEM_FLAG_SHALLOW
*                       WBEM_FLAG_RETURN_IMMEDIATELY
*                       WBEM_FLAG_FORWARD_ONLY
*                       WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    : TO DO: All instances on the machine should be returned here.
*                       If there are no instances, return WBEM_S_NO_ERROR.
*                       It is not an error to have no instances.
*
*****************************************************************************/
HRESULT CPCH_Drive::EnumerateInstances(
    MethodContext* pMethodContext,
    long lFlags
    )
{
    TraceFunctEnter("CPCH_Drive::EnumerateInstances");

    HRESULT                             hRes = WBEM_S_NO_ERROR;
    REFPTRCOLLECTION_POSITION           posList;
    CComPtr<IEnumWbemClassObject>       pEnumInst;
    IWbemClassObjectPtr                 pObj;      
    ULONG                               ulRetVal;

    int                                 nMediaType;
    long                                lFreeSpace;
    long                                lAvailable;

    LONGLONG                            llFreeSpace;
    LONGLONG                            llAvailable;

    TCHAR                               tchSize[MAXSIZE];
    TCHAR                               tchFreeSpace[MAXSIZE];

    CComVariant                         varMediaType;
    CComVariant                         varMediaTypeStr;
    CComVariant                         varFreeSpace;
    CComVariant                         varFree;
    CComVariant                         varAvailable;
    CComVariant                         varSize;

    //
    // Get the date and time
    //
    SYSTEMTIME stUTCTime;
    GetSystemTime(&stUTCTime);

    //
    // Execute the query
    //
    hRes = ExecWQLQuery(&pEnumInst, CComBSTR("select DeviceID, FileSystem, FreeSpace, Size, Description, MediaType FROM win32_logicalDisk"));
    if (FAILED(hRes))
        goto END;

    //
    // enumerate the instances from win32_CodecFile
    //
    while(WBEM_S_NO_ERROR == pEnumInst->Next(WBEM_INFINITE, 1, &pObj, &ulRetVal))
    {

        // Create a new instance based on the passed-in MethodContext
        CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);
        
        if (!pInstance->SetDateTime(pTimeStamp, WBEMTime(stUTCTime)))
            ErrorTrace(TRACE_ID, "SetDateTime on Timestamp Field failed.");

        if (!pInstance->SetCHString(pChange, L"Snapshot"))
            ErrorTrace(TRACE_ID, "SetCHString on Change Field failed.");

        (void)CopyProperty(pObj, L"DeviceID", pInstance, pDriveLetter);
        (void)CopyProperty(pObj, L"FileSystem", pInstance, pFilesystemType);
        (void)CopyProperty(pObj, L"Description", pInstance, pDescription);

     
        //  Get the Available Space
        varSize.Clear();
        varAvailable.Clear();
        hRes = pObj->Get(CComBSTR(L"Size"),0,&varSize,NULL,NULL);
        if(FAILED(hRes))
        {
            // Cannot Get the "Size" Property.
            ErrorTrace(TRACE_ID, "GetVariant on Size Field failed.");
        }
        else
        {
            // Got the size property.
            if(varSize.vt == VT_BSTR)
            {
                varSize.ChangeType(VT_BSTR, NULL);
                {
                      USES_CONVERSION;
                      _tcscpy(tchSize,OLE2T(varSize.bstrVal));
                }
    
                // Convert this to KB.
                // lAvailable = _ttol(tchSize);
                llAvailable = _ttoi64(tchSize);
            }
            else if(varSize.vt == VT_NULL)
            {
                llAvailable = 0;
            }
            // lAvailable = lAvailable/KILO;
            llAvailable = llAvailable/KILO;
            varAvailable = (long)llAvailable;

            // Set the Size Property
            if (FAILED(pInstance->SetVariant(pAvailable, varAvailable)))
            {
                // Set Available Space Failed
                // Proceed anyway
                ErrorTrace(TRACE_ID, "SetVariant on Available Field failed.");
            }
        }
        varFreeSpace.Clear();
        varFree.Clear();
        hRes = pObj->Get(CComBSTR(L"FreeSpace"),0,&varFreeSpace,NULL,NULL);
        if(FAILED(hRes))
        {
            // Cannot Get the "FreeSpace" Property.
            ErrorTrace(TRACE_ID, "GetVariant on Size Field failed.");
        }
        else
        {
            // Got the FreeSpace property.
            if(varFreeSpace.vt == VT_BSTR)
            {
                varFreeSpace.ChangeType(VT_BSTR, NULL);
                {
                      USES_CONVERSION;
                      _tcscpy(tchFreeSpace,OLE2T(varFreeSpace.bstrVal));
                }
    
                // Convert this to KB.
                // lFreeSpace = _ttol(tchFreeSpace);
                llFreeSpace = _ttoi64(tchFreeSpace);
            }
            else if(varFreeSpace.vt == VT_NULL)
            {
                llFreeSpace = 0;
            }
            
            // lFreeSpace = lFreeSpace/KILO;
            llFreeSpace = llFreeSpace/KILO;
            // varFreeSpace = (long)llFreeSpace;


            // varFree = nFreeSpace;
            // varFree = lFreeSpace;
            varFree = (long)llFreeSpace;

            // Set the Free Property
            if (FAILED(pInstance->SetVariant(pFree, varFree)))
            {
                // Set Free Space Failed
                // Proceed anyway
                ErrorTrace(TRACE_ID, "SetVariant on Free Field failed.");
            }
        }

        varMediaType = NULL;
        hRes = pObj->Get(CComBSTR("MediaType"), 0, &varMediaType, NULL, NULL);
        if (FAILED(hRes))
        {
           //  Cannot get MediaType.
           ErrorTrace(TRACE_ID, "GetVariant on MediaType Field failed.");
        }
        else 
        {
            //  Got the MediaType
            nMediaType = varMediaType.iVal;
            if (nMediaType < 0 || nMediaType > maxMediaTypes)
            {
                //unknown Media Type
                nMediaType = 0;
            }
            varMediaTypeStr = szMediaTypeStrings[nMediaType];
            // Set the Media Type Property
            if (FAILED(pInstance->SetVariant(pMediaType, varMediaTypeStr)))
            {
                // Set MediaType Failed
                // Proceed anyway
                ErrorTrace(TRACE_ID, "SetVariant on MediaType Field failed.");
            }
        }
 
        hRes = pInstance->Commit();
        if (FAILED(hRes))
        {
            //  Could not Set the Change Property
            //  Continue anyway
            ErrorTrace(TRACE_ID, "Commit failed.");
        }
    }

END :
    TraceFunctLeave();
    return hRes ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprov\pch_devicedriver.h ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_DeviceDriver.H

Abstract:
	WBEM provider class definition for PCH_DeviceDriver class

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

********************************************************************/

// Property set identification
//============================

#ifndef _PCH_DeviceDriver_H_
#define _PCH_DeviceDriver_H_

#define PROVIDER_NAME_PCH_DEVICEDRIVER "PCH_DeviceDriver"

// Property name externs -- defined in PCH_DeviceDriver.cpp
//=================================================

extern const WCHAR* pTimeStamp ;
extern const WCHAR* pChange ;
extern const WCHAR* pDate ;
extern const WCHAR* pFilename ;
extern const WCHAR* pManufacturer ;
extern const WCHAR* pName ;
extern const WCHAR* pSize ;
extern const WCHAR* pVersion ;

class CPCH_DeviceDriver : public Provider 
{
	public:
		// Constructor/destructor
		//=======================

		CPCH_DeviceDriver(const CHString& chsClassName, LPCWSTR lpszNameSpace) : Provider(chsClassName, lpszNameSpace) {};
		virtual ~CPCH_DeviceDriver() {};

	protected:
		// Reading Functions
		//============================
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Writing Functions
		//============================
		virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Other Functions
		virtual HRESULT ExecMethod( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags = 0L ) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

    private:
        virtual HRESULT CreateDriverInstances(CHString chstrDriverName, CConfigMgrDevice *pDevice, MethodContext *pMethodContext);
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprov\pch_devicedriver.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_DeviceDriver.CPP

Abstract:
	WBEM provider class implementation for PCH_DeviceDriver class

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

********************************************************************/

#include "pchealth.h"
#include "confgmgr.h"
#include "PCH_DeviceDriver.h"
#include "cregcls.h"

#define MAX_ARRAY   100

/////////////////////////////////////////////////////////////////////////////
//  tracing stuff

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile
#define TRACE_ID    DCID_DEVICEDRIVER

CPCH_DeviceDriver MyPCH_DeviceDriverSet (PROVIDER_NAME_PCH_DEVICEDRIVER, PCH_NAMESPACE) ;

// Property names
//===============
const static WCHAR* pTimeStamp = L"TimeStamp" ;
const static WCHAR* pChange = L"Change" ;
const static WCHAR* pDate = L"Date" ;
const static WCHAR* pFilename = L"Filename" ;
const static WCHAR* pManufacturer = L"Manufacturer" ;
const static WCHAR* pName = L"Name" ;
const static WCHAR* pSize = L"Size" ;
const static WCHAR* pVersion = L"Version" ;

/*****************************************************************************
*
*  FUNCTION    :    CPCH_DeviceDriver::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                       WBEM_FLAG_DEEP
*                       WBEM_FLAG_SHALLOW
*                       WBEM_FLAG_RETURN_IMMEDIATELY
*                       WBEM_FLAG_FORWARD_ONLY
*                       WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    : TO DO: All instances on the machine should be returned here.
*                       If there are no instances, return WBEM_S_NO_ERROR.
*                       It is not an error to have no instances.
*
*****************************************************************************/
HRESULT CPCH_DeviceDriver::EnumerateInstances(
    MethodContext* pMethodContext,
    long lFlags
    )
{
    TraceFunctEnter("CPCH_DeviceDriver::EnumerateInstances");

    CConfigManager cfgManager;
    CDeviceCollection deviceList;
    HRESULT hRes = WBEM_S_NO_ERROR;

    if ( cfgManager.GetDeviceList( deviceList ) ) 
    {
        REFPTR_POSITION pos;
    
        if ( deviceList.BeginEnum( pos ) ) 
        {
            try
            {
                CConfigMgrDevice    *pDevice = NULL;
        
                // Walk the list
                while ( (NULL != ( pDevice = deviceList.GetNext( pos ) ) ) )
                {
                    try
                    {

                        CHString chstrVar;

                        // Driver
                        if (pDevice->GetDriver(chstrVar))
                        {
                            // Get device driver info
                            (void)CreateDriverInstances(chstrVar, pDevice, pMethodContext);
                        }
                    }
                    catch(...)
                    {
                        // GetNext() AddRefs
                        pDevice->Release();
                        throw;
                    }

                    // GetNext() AddRefs
                    pDevice->Release();
                }
            }
            catch(...)
            {
                // Always call EndEnum().  For all Beginnings, there must be an End
                deviceList.EndEnum();
                throw;
            }
        
            // Always call EndEnum().  For all Beginnings, there must be an End
            deviceList.EndEnum();
        }
    }
    
    TraceFunctLeave();
    return hRes ;
//			  pInstance->SetVariant(pTimeStamp, <Property Change>);
//            pInstance->SetVariant(pChange, <Property Value>);
//            pInstance->SetVariant(pDate, <Property Value>);
//            pInstance->SetVariant(pFilename, <Property Value>);
//            pInstance->SetVariant(pManufacturer, <Property Value>);
//            pInstance->SetVariant(pName, <Property Value>);
//            pInstance->SetVariant(pSize, <Property Value>);
//            pInstance->SetVariant(pVersion, <Property Value>);
}

//
// QualifyInfFile will find where the inf file is located, in specific
// sections
//
BOOL QualifyInfFile(CHString chstrInfFile, CHString &chstrInfFileQualified)
{
	USES_CONVERSION;
    TCHAR strWinDir[MAX_PATH];
    
    if (GetWindowsDirectory(strWinDir, MAX_PATH))
    {
        // check if the file exists in %windir%\inf
        CHString chstrFullPath(strWinDir);
        chstrFullPath += "\\inf\\";
        chstrFullPath += chstrInfFile;

        // test for presence of the file
        HANDLE hFile = CreateFile(W2A((LPCWSTR)chstrFullPath), GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

        // if found, then return with value
        if (hFile != INVALID_HANDLE_VALUE)
        {
            chstrInfFileQualified = chstrFullPath;
            CloseHandle(hFile);
            return TRUE;
        }

        // check if the file exists in %windir%\inf\other
        chstrFullPath = strWinDir;
        chstrFullPath += "\\inf\\other\\";
        chstrFullPath += chstrInfFile;

        // test for presence of the file
        hFile = CreateFile(W2A((LPCWSTR)chstrFullPath), GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

        // if found, then return with value
        if (hFile != INVALID_HANDLE_VALUE)
        {
            chstrInfFileQualified = chstrFullPath;
            CloseHandle(hFile);
            return TRUE;
        }
    }

    return FALSE;
}

BOOL TestFile(LPCTSTR chstrPath1, LPCTSTR chstrPath2, LPCTSTR chstrPath3, CHString &chstrFullPath)
{
	USES_CONVERSION;

    // concatenate all parts of the path
    chstrFullPath = chstrPath1;
    chstrFullPath += chstrPath2;
    chstrFullPath += chstrPath3;

    // test for presence of the file
    HANDLE hFile = CreateFile(W2A(chstrFullPath), GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    // if found, then return with value
    if (hFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hFile);
        return TRUE;
    }

    return FALSE;
}

//
// QualifyDriverFile will find where the driver file is located, in specific
// sections
//
BOOL QualifyDriverFile(CHString chstrInfFile, CHString &chstrInfFileQualified)
{
    TCHAR strWinDir[MAX_PATH];
    TCHAR strSysDir[MAX_PATH];

    USES_CONVERSION;
    char * szInfFile = W2A(chstrInfFile);
    
    // Check in Windows Directory
    if (GetWindowsDirectory(strWinDir, MAX_PATH))
    {
        // check to see if it exists in %windir%
        if (TestFile(strWinDir, "\\", szInfFile, chstrInfFileQualified))
            return TRUE;

        // check to see if it exists in %windir%\system32 
        if (TestFile(strWinDir, "\\System32\\", szInfFile, chstrInfFileQualified))
            return TRUE;

        // check if the file exists in %windir%\system32\drivers
        if (TestFile(strWinDir, "\\system32\\drivers\\", szInfFile, chstrInfFileQualified))
            return TRUE;
    }

    // check in System Directory
    if (GetSystemDirectory(strSysDir, MAX_PATH))
    {
        // check to see if it exists in %sysdir%
        if (TestFile(strSysDir, "\\", szInfFile, chstrInfFileQualified))
            return TRUE;

        // check to see if it exists in %sysdir%\iosubsys
        if (TestFile(strSysDir, "\\iosubsys\\", szInfFile, chstrInfFileQualified))
            return TRUE;

        // check to see if it exists in %sysdir%\vmm32
        if (TestFile(strSysDir, "\\vmm32\\", szInfFile, chstrInfFileQualified))
            return TRUE;
    }

    return FALSE;
}

/*****************************************************************************
*
*  FUNCTION    :    CPCH_DeviceDriver::CreateDriverInstances
*
*  DESCRIPTION :    Creates all the device driver instances given the driver name
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*
*    How drivers are obtained from the registry and inf files :
*
*    In the reg hive HKLM\System\CurrentControlSet\Services\Class, each device will have a subkey.
*    In each device subkey, there are two values InfPath and InfSection. In the specified InfPath
*    and InfSection, the drivers are stored in the following fashion :
*
*    // sample.inf
*
*    [InfSection]
*    CopyFiles = Subsection1, Subsection2.....
*
*    [Subsection1]
*    xxx.dll
*    yyy.vxd
*    zzz.sys
*
*    [Subsection2]
*    aaa.dll
*    bbb.vxd
*    zzz.sys
*
*    Plus, there are other values for each different device which may contain driver information :
*
*    ALL             : PortDriver
*    Display         : drv, minivdd (extra level deep : default)
*    Net             : DeviceVxDs
*    Ports           : PortDriver, ConfigDialog
*    Media           : Driver
*
*
*****************************************************************************/
HRESULT CPCH_DeviceDriver::CreateDriverInstances(
    CHString chstrDriverName,
    CConfigMgrDevice* pDevice,
    MethodContext* pMethodContext
    )
{
    TraceFunctEnter("CPCH_DeviceDriver::EnumerateInstances");

    HRESULT     hRes = WBEM_S_NO_ERROR;
    CComVariant varValue;
    CRegistry   Reg;
    int         iDel;
    CHString    chstrInfFileQualified;
    CHString    chstrInfSection;
    TCHAR       strCopyFiles[MAX_PATH];
    LPTSTR      apstrCopyFileArray[MAX_ARRAY];
    LPTSTR      apstrDriverArray[MAX_ARRAY];
    int         iDriverIndex;
    int         iCountDriver;
    int         iCountCopyFile;
    int         iIndex;

    // create the device key
    CHString strDeviceKey("SYSTEM\\CurrentControlSet\\SERVICES\\Class\\");
    strDeviceKey += chstrDriverName;

    // Get the date and time
	SYSTEMTIME stUTCTime;
	GetSystemTime(&stUTCTime);

    USES_CONVERSION;
    char * szInf;
    char * szInfFileQualified;

    // Get the inf filename
    CHString chstrInfFile;
    if (Reg.OpenLocalMachineKeyAndReadValue(strDeviceKey, L"InfPath", chstrInfFile) != ERROR_SUCCESS)
        goto End;

    if (!QualifyInfFile(chstrInfFile, chstrInfFileQualified))
        goto End;

    // get the inf section
    if (Reg.OpenLocalMachineKeyAndReadValue(strDeviceKey, L"InfSection", chstrInfSection) != ERROR_SUCCESS)
        goto End;

    // get the subsections to be expanded
    szInf = W2A(chstrInfSection);
    szInfFileQualified = W2A(chstrInfFileQualified);
    GetPrivateProfileString(szInf, "CopyFiles", "Error", strCopyFiles, MAX_PATH, szInfFileQualified);
    if (!_tcscmp("Error", strCopyFiles))
        goto End;

    // add the default driver to the driver array
    iCountDriver = DelimitedStringToArray((LPWSTR)(LPCWSTR)chstrDriverName, ",", apstrDriverArray, MAX_ARRAY);

    // count number of files to look at
    iCountCopyFile = DelimitedStringToArray(strCopyFiles, ",", apstrCopyFileArray, MAX_ARRAY);

    // loop through all subsections
    for (iIndex = 0; iIndex < iCountCopyFile; iIndex++)
    {
        // get all drivers in the subsection
        TCHAR strDriver[MAX_PATH * MAX_ARRAY];

        if (0 < GetPrivateProfileSection(apstrCopyFileArray[iIndex], strDriver, MAX_PATH * MAX_ARRAY, szInfFileQualified))
        {
            // the string is delimited by NULL values so in order to work with the
            // DelimitedStringToArray function, we'll replace it with something else
            int iCIndex = 0;
            while (!((strDriver[iCIndex] == '\0') && (strDriver[iCIndex + 1] == '\0')))
            {
                if (strDriver[iCIndex] == '\0')
                    strDriver[iCIndex] = '%';
                else // do some cleanup here
                    if (!(_istalnum(strDriver[iCIndex])) && !(strDriver[iCIndex] == '.'))
                        strDriver[iCIndex] = '\0';

                    iCIndex++;
            }

            iCountDriver += DelimitedStringToArray(strDriver, "%", apstrDriverArray + iCountDriver, MAX_ARRAY - iCountDriver);

            // Scout around for more drivers in special keys
            CHString chstrExtraKey = strDeviceKey;
            chstrExtraKey += "\\default";
            CHString chstrDriver;

            // special case for display and monitor
            if ((!wcsncmp(chstrDriverName, L"display", wcslen(L"display"))) ||
                (!wcsncmp(chstrDriverName, L"monitor", wcslen(L"monitor"))))
            {
                // HKLM\SYSTEM\CurrentControlSet\SERVICES\Class\XXXX\####\default for Drv values

                if (Reg.OpenLocalMachineKeyAndReadValue(chstrExtraKey, L"Drv", chstrDriver) == ERROR_SUCCESS)
                {
                    // add the list of new driver to the driver array
                    iCountDriver += DelimitedStringToArray((LPWSTR)(LPCWSTR)chstrDriver, ",", apstrDriverArray + iCountDriver, MAX_ARRAY - iCountDriver);
                }

                // HKLM\SYSTEM\CurrentControlSet\SERVICES\Class\XXXX\####\default for MiniVDD values
                if (Reg.OpenLocalMachineKeyAndReadValue(chstrExtraKey, L"MiniVDD", chstrDriver) == ERROR_SUCCESS)
                {
                    // add the list of new driver to the driver array
                    iCountDriver += DelimitedStringToArray((LPWSTR)(LPCWSTR)chstrDriver, ",", apstrDriverArray + iCountDriver, MAX_ARRAY - iCountDriver);
                }
            }

            // special case for net, nettrans, netclient, netservice
            if (!wcsncmp(chstrDriverName, L"net", wcslen(L"net")))
            {
                // HKLM\SYSTEM\CurrentControlSet\SERVICES\Class\XXXX\#### for DeviceVxDs values
                if (Reg.OpenLocalMachineKeyAndReadValue(strDeviceKey, L"DeviceVxDs", chstrDriver) == ERROR_SUCCESS)
                {
                    // add the list of new driver to the driver array
                    iCountDriver += DelimitedStringToArray((LPWSTR)(LPCWSTR)chstrDriver, ",", apstrDriverArray + iCountDriver, MAX_ARRAY - iCountDriver);
                }
            }

            // special case for ports
            if (!wcsncmp(chstrDriverName, L"ports", wcslen(L"ports")))
            {
                // HKLM\SYSTEM\CurrentControlSet\SERVICES\Class\XXXX\#### for ConfigDialog values
                if (Reg.OpenLocalMachineKeyAndReadValue(strDeviceKey, L"ConfigDialog", chstrDriver) == ERROR_SUCCESS)
                {
                    // add the list of new driver to the driver array
                    iCountDriver += DelimitedStringToArray((LPWSTR)(LPCWSTR)chstrDriver, ",", apstrDriverArray + iCountDriver, MAX_ARRAY - iCountDriver);
                }
            }

            // special case for media
            if (!wcsncmp(chstrDriverName, L"media", wcslen(L"media")))
            {
                // HKLM\SYSTEM\CurrentControlSet\SERVICES\Class\XXXX\#### for Driver values
                if (Reg.OpenLocalMachineKeyAndReadValue(strDeviceKey, L"Driver", chstrDriver) == ERROR_SUCCESS)
                {
                    // add the list of new driver to the driver array
                    iCountDriver += DelimitedStringToArray((LPWSTR)(LPCWSTR)chstrDriver, ",", apstrDriverArray + iCountDriver, MAX_ARRAY - iCountDriver);
                }
            }
            
            // HKLM\SYSTEM\CurrentControlSet\SERVICES\Class\XXXX\#### for PortDriver values
            if (Reg.OpenLocalMachineKeyAndReadValue(strDeviceKey, L"PortDriver", chstrDriver) == ERROR_SUCCESS)
            {
                // add the list of new driver to the driver array
                iCountDriver += DelimitedStringToArray((LPWSTR)(LPCWSTR)chstrDriver, ",", apstrDriverArray + iCountDriver, MAX_ARRAY - iCountDriver);
            }
        }
    }

    // Clean up
    for (iDel = 0; iDel < iCountCopyFile; iDel++)
        delete [] apstrCopyFileArray[iDel];

    // go through list of drivers and create the instances
    for (iDriverIndex = 0; iDriverIndex < iCountDriver; iDriverIndex++)
    {                            
        CHString chstrDriver(apstrDriverArray[iDriverIndex]);
        CHString chstrPath;

        // Check for duplicates
        BOOL bDup = FALSE;
        for (int iDup = 0; iDup < iDriverIndex; iDup++)
        {
            char * szDriver = W2A(chstrDriver);
            if (!_tcsicmp(szDriver, apstrDriverArray[iDup]))
            {
                bDup = TRUE;
                break;
            }
        }

        // if there exists a duplicate, skip it
        if (bDup)
            continue;

        // create instance
        CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);

        try
        {
            // Timestamp
            if (!pInstance->SetDateTime(pTimeStamp, WBEMTime(stUTCTime)))
               ErrorTrace(TRACE_ID, "SetDateTime on Timestamp Field failed.");

            // Snapshot
            if (!pInstance->SetCHString(pChange, L"Snapshot"))
                ErrorTrace(TRACE_ID, "SetCHString on Change Field failed.");

            // Name (key)
            // bug fix : should be name of device (foreign key), NOT driver name
            CHString chstrVar;
            if (pDevice->GetDeviceID(chstrVar))
                if (!pInstance->SetCHString(pName, chstrVar))
                    ErrorTrace(TRACE_ID, "SetCHString on Name field failed.");

            // Set filename (key)
            if (!pInstance->SetCHString(pFilename, chstrDriver))
                ErrorTrace(TRACE_ID, "SetVariant on filename Field failed.");

            // If there exists such a driver file, get the CIM_Datafile object on it
            if (QualifyDriverFile(chstrDriver, chstrPath))
            {
                // get the CIMDatafile object
                IWbemClassObject *pFileObj;
                CComBSTR ccombstrPath((LPCWSTR)chstrPath);

                hRes = GetCIMDataFile(ccombstrPath, &pFileObj);
            
                // if succeeded in getting the CIM_Datafile object, get all file info
                if (SUCCEEDED(hRes))
                {
                    // Get Manufacturer
                    hRes = pFileObj->Get(CComBSTR("Manufacturer"), 0, &varValue, NULL, NULL);
                    if (FAILED(hRes))
                        ErrorTrace(TRACE_ID, "Get Manufacturer failed on file object");
                    else
                        if (!pInstance->SetVariant(pManufacturer, varValue))
                            ErrorTrace(TRACE_ID, "SetVariant on Manufacturer Field failed.");                        

                    // Get size
                    hRes = pFileObj->Get(CComBSTR("Filesize"), 0, &varValue, NULL, NULL);
                    if (FAILED(hRes))
                        ErrorTrace(TRACE_ID, "Get FileSize failed on file object");
                    else
                        if (!pInstance->SetVariant(pSize, varValue))
                            ErrorTrace(TRACE_ID, "SetVariant on Size Field failed.");                        

                    // Get version
                    hRes = pFileObj->Get(CComBSTR("version"), 0, &varValue, NULL, NULL);
                    if (FAILED(hRes))
                        ErrorTrace(TRACE_ID, "Get version failed on file object");
                    else
                        if (!pInstance->SetVariant(pVersion, varValue))
                            ErrorTrace(TRACE_ID, "SetVariant on version Field failed.");                        

                    // Get date
                    hRes = pFileObj->Get(CComBSTR("LastModified"), 0, &varValue, NULL, NULL);
                    if (FAILED(hRes))
                        ErrorTrace(TRACE_ID, "Get LastModified failed on file object");
                    else
                        if (!pInstance->SetVariant(pDate, varValue))
                            ErrorTrace(TRACE_ID, "SetVariant on Date Field failed.");                        
                }
            }

            // commit it
   	        hRes = pInstance->Commit();
            if (FAILED(hRes))
                ErrorTrace(TRACE_ID, "Commit on Instance failed.");
        }
        catch(...)
        {
            // Clean up
            for (iDel = 0; iDel < iCountDriver; iDel++)
                delete [] apstrDriverArray[iDel];
            throw;
        }
    }

    // Clean up
    for (iDel = 0; iDel < iCountDriver; iDel++)
        delete [] apstrDriverArray[iDel];
        
End :
    TraceFunctLeave();
    return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprov\pch_driver.h ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_Driver.H

Abstract:
	WBEM provider class definition for PCH_Driver class

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

********************************************************************/

// Property set identification
//============================

#ifndef _PCH_Driver_H_
#define _PCH_Driver_H_

#define PROVIDER_NAME_PCH_DRIVER "PCH_Driver"

#include <list>

// Property name externs -- defined in PCH_Driver.cpp
//=================================================

extern const WCHAR* pCategory ;
extern const WCHAR* pTimeStamp ;
extern const WCHAR* pChange ;
extern const WCHAR* pDate ;
extern const WCHAR* pDescription ;
extern const WCHAR* pLoadedFrom ;
extern const WCHAR* pManufacturer ;
extern const WCHAR* pName ;
extern const WCHAR* pPartOf ;
extern const WCHAR* pPath ;
extern const WCHAR* pSize ;
extern const WCHAR* pType ;
extern const WCHAR* pVersion ;

typedef struct _DRIVER_KERNEL
{
    TCHAR   strDriver[MAX_PATH];
    TCHAR   strVersion[MAX_PATH];
    TCHAR   strManufacturer[MAX_PATH];
    TCHAR   strDescription[MAX_PATH];
    TCHAR   strLikelyPath[MAX_PATH];
    TCHAR   strLoadedFrom[MAX_PATH];
    TCHAR   strType[MAX_PATH];
    TCHAR   strPartOf[MAX_PATH];
    struct _DRIVER_KERNEL *next;
} DRIVER_KERNEL;

typedef struct _DRIVER_MS_DOS
{
    TCHAR   strName[MAX_PATH];
    TCHAR   strType[MAX_PATH];
    WORD    seg;
} DRIVER_MS_DOS;

typedef struct _DRIVER_USER_MODE
{
    TCHAR   strDriver[MAX_PATH];
    TCHAR   strVersion[MAX_PATH];
    TCHAR   strManufacturer[MAX_PATH];
    TCHAR   strDescription[MAX_PATH];
    TCHAR   strPath[MAX_PATH];
    TCHAR   strType[MAX_PATH];
    TCHAR   strPartOf[MAX_PATH];
} DRIVER_USER_MODE;

class CPCH_Driver : public Provider 
{
	public:
		// Constructor/destructor
		//=======================

        CPCH_Driver(const CHString& chsClassName, LPCWSTR lpszNameSpace) : 
                Provider(chsClassName, lpszNameSpace), m_pDriverKernel(NULL) {};
		virtual ~CPCH_Driver() {};


	protected:
		// Reading Functions
		//============================
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Writing Functions
		//============================
		virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Other Functions
		virtual HRESULT ExecMethod( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags = 0L ) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

    private:
        DRIVER_KERNEL       *m_pDriverKernel;
        std::list<DRIVER_MS_DOS* >      m_DriverMSDosList;
        std::list<DRIVER_USER_MODE* >   m_DriverUserModeList;


        HRESULT GetDriverKernel();
        HRESULT GetDriverMSDos();
        HRESULT GetDriverUserMode();

        // to parse driver list and create instances
        HRESULT ParseUserModeList(MethodContext*);
        HRESULT ParseMSDosList(MethodContext*);

        // for ms-dos drivers
        void DosMem_WalkArena(WORD, DWORD);
        void DosMem_CleanArena(DWORD);

        // for kernel drivers
        HRESULT AddDriverKernelList(LPTSTR strDriverName, LPTSTR strLoadedFrom);
        HRESULT AddRegDriverList(HKEY hKey, LPTSTR strSubKey);
        HRESULT AddRegDriverConfigList(HKEY hk);
        HRESULT GetRegDriver(LPTSTR strSubKey);
        HRESULT GetSystemINIDriver();
        HRESULT GetIOSubsysDriver();
        HRESULT GetServicesVxD();
        HRESULT GetMSISYSVxD();
        HRESULT GetKernelDriverInfo();
        void    CPCH_Driver::SetFileVersionInfo(CComBSTR, CInstance*);
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprov\pch_drive.h ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_Drive.H

Abstract:
	WBEM provider class definition for PCH_Drive class

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

********************************************************************/

// Property set identification
//============================

#ifndef _PCH_Drive_H_
#define _PCH_Drive_H_

#define PROVIDER_NAME_PCH_DRIVE "PCH_Drive"

// Property name externs -- defined in PCH_Drive.cpp
//=================================================

extern const WCHAR* pAvailable ;
extern const WCHAR* pTimeStamp ;
extern const WCHAR* pChange ;
extern const WCHAR* pDriveLetter ;
extern const WCHAR* pFilesystemType ;
extern const WCHAR* pFree ;
extern const WCHAR* pDescription;
extern const WCHAR* pMediaType;


class CPCH_Drive : public Provider 
{
	public:
		// Constructor/destructor
		//=======================

		CPCH_Drive(const CHString& chsClassName, LPCWSTR lpszNameSpace) : Provider(chsClassName, lpszNameSpace) {};
		virtual ~CPCH_Drive() {};

	protected:
		// Reading Functions
		//============================
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Writing Functions
		//============================
		virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Other Functions
		virtual HRESULT ExecMethod( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags = 0L ) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprov\pch_driver.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    PCH_Driver.CPP

Abstract:
    WBEM provider class implementation for PCH_Driver class

Revision History:

    Ghim-Sim Chua       (gschua)   04/27/99
        - Created

  Brijesh Krishnaswami  (brijeshk) 05/24/99
        - added code for enumerating usermode drivers
        - added code for enumerating msdos drivers
        - added code for getting details on kernel mode drivers
********************************************************************/

#include "pchealth.h"
#include "PCH_Driver.h"
#include "drvdefs.h"
#include "shlwapi.h"

#define Not_VxD
#include <vxdldr.h>             /* For DeviceInfo */


/////////////////////////////////////////////////////////////////////////////
//  tracing stuff

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile
#define TRACE_ID    DCID_DRIVER
#define SYSTEM_INI_MAX  32767

CPCH_Driver MyPCH_DriverSet (PROVIDER_NAME_PCH_DRIVER, PCH_NAMESPACE) ;
void MakeSrchDirs(void);

static BOOL fThunkInit = FALSE;

TCHAR       g_rgSrchDir[10][MAX_PATH];
UINT        g_nSrchDir;


// Property names
//===============
const static WCHAR* pCategory = L"Category" ;
const static WCHAR* pTimeStamp = L"TimeStamp" ;
const static WCHAR* pChange = L"Change" ;
const static WCHAR* pDate = L"Date" ;
const static WCHAR* pDescription = L"Description" ;
const static WCHAR* pLoadedFrom = L"LoadedFrom" ;
const static WCHAR* pManufacturer = L"Manufacturer" ;
const static WCHAR* pName = L"Name" ;
const static WCHAR* pPartOf = L"PartOf" ;
const static WCHAR* pPath = L"Path" ;
const static WCHAR* pSize = L"Size" ;
const static WCHAR* pType = L"Type" ;
const static WCHAR* pVersion = L"Version" ;

// Device names
//=============
LPSTR c_rgpszDevice[] = {
    "device",
    "display",
    "mouse",
    "keyboard",
    "network",
    "ebios",
    "fastdisk",
    "transport",
    "netcard",
    "netcard3",
    "netmisc",
    "secondnet",
    NULL
};

// IO Subsystem extensions
//========================
LPSTR c_rgptszDrvExt[] = {
    ".DRV",
    ".MPD",
    ".PDR",
    ".VXD",
    NULL
};

// Registry key names
//===================
LPCTSTR c_rgptszConfig[] = {
    TEXT("DevLoader"),
    TEXT("Contention"),
    TEXT("Enumerator"),
    TEXT("Driver"),
    TEXT("PortDriver"),
    TEXT("DeviceVxDs"),
    TEXT("vdd"),
    TEXT("minivdd"),
    NULL
};

// Known VxDs
//===========
LPCTSTR astrKnownVxDs[] = {
    "VMM",
    "VPOWERD",
    "ENABLE",
    "VKD",
    "VFLATD",
    "BIOS",
    "VDD",
    "VMOUSE",
    "EBIOS",
    "VSHARE",
    "VWIN32",
    "VFBACKUP",
    "VCOMM",
    "COMBUFF",
    "VCD",
    "VPD",
    "IFSMGR",
    "IOS",
    "SPOOLER",
    "VFAT",
    "VCACHE",
    "VCOND",
    "VCDFSD",
    "INT13",
    "VXDLDR",
    "VDEF",
    "PAGEFILE",
    "CONFIGMG",
    "VMD",
    "DOSNET",
    "VPICD",
    "VTD",
    "REBOOT",
    "VDMAD",
    "VSD",
    "V86MMGR",
    "PAGESWAP",
    "DOSMGR",
    "VMPOLL",
    "SHELL",
    "PARITY",
    "BIOSXLAT",
    "VMCPD",
    "VTDAPI",
    "PERF",
    "NTKERN",
    "SDVXD",
    NULL
};

// Known VxD Description
//======================
LPCTSTR astrKnownVxDsDesc[] = {
    "Virtual Machine Manager",
    "Advanced Power Management driver",
    "Accessibility driver",
    "Keyboard driver",
    "Linear aperture video driver",
    "Plug and Play BIOS driver",
    "Display driver",
    "Mouse driver",
    "Extended BIOS driver",
    "File sharing driver",
    "Win32 subsystem driver",
    "Floppy backup helper driver",
    "Communications port Plug and Play driver",
    "Communications buffer driver",
    "Communications port driver",
    "Printer driver",
    "File system manager",
    "I/O Supervisor",
    "Print spooler",
    "FAT filesystem driver",
    "Cache manager",
    "Console subsystem driver",
    "CD-ROM filesystem driver",
    "BIOS hard disk emulation driver",
    "Dynamic device driver loader",
    "Default filesystem driver",
    "Swapfile driver",
    "Configuration manager",
    "Windows 3.1-compatible mouse driver",
    "Windows 3.1-compatible network helper driver",
    "Hardware interrupt manager",
    "Timer device driver",
    "Ctrl+Alt+Del manager",
    "Direct Memory Access controller driver",
    "Speaker driver",
    "MS-DOS memory manager",
    "Swapfile manager",
    "MS-DOS emulation manager",
    "System idle-time driver",
    "Shell device driver",
    "Memory parity driver",
    "BIOS emulation driver",
    "Math coprocessor driver",
    "Multimedia timer driver",
    "System Monitor data collection driver",
    "Windows Driver Model",
    "SmartDrive",
    NULL
};

/*****************************************************************************
*
*  FUNCTION    :    CPCH_Driver::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                       WBEM_FLAG_DEEP
*                       WBEM_FLAG_SHALLOW
*                       WBEM_FLAG_RETURN_IMMEDIATELY
*                       WBEM_FLAG_FORWARD_ONLY
*                       WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    : TO DO: All instances on the machine should be returned here.
*                       If there are no instances, return WBEM_S_NO_ERROR.
*                       It is not an error to have no instances.
*
*****************************************************************************/
HRESULT CPCH_Driver::EnumerateInstances(
    MethodContext* pMethodContext,
    long lFlags
    )
{
    TraceFunctEnter("CPCH_Driver::AddDriverKernelList");
    HRESULT hRes = WBEM_S_NO_ERROR;
    CComVariant     varValue;

    //
    // Get the date and time
    SYSTEMTIME stUTCTime;
    GetSystemTime(&stUTCTime);

    // if thunk init is already done, don't initialize again
    if (!fThunkInit)
    {
        ThunkInit();
        fThunkInit = TRUE;
    }


    // Enumerate Kernel Drivers
    MakeSrchDirs();
    GetDriverKernel();
    DRIVER_KERNEL *pDrvKer = m_pDriverKernel;
    DRIVER_KERNEL *pDelDrvKer;
    while(pDrvKer)
    {
        // Create a new instance
        CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);

        // Set the timestamp
        if (!pInstance->SetDateTime(pTimeStamp, WBEMTime(stUTCTime)))
            ErrorTrace(TRACE_ID, "SetDateTime on Timestamp Field failed.");

        // Set the category
        if (!pInstance->SetCHString(pCategory, "Kernel"))
            ErrorTrace(TRACE_ID, "SetVariant on Category Field failed.");

        // Set the name
        if (_tcslen(pDrvKer->strDriver))
        {
            varValue = pDrvKer->strDriver;
            if (!pInstance->SetVariant(pName, varValue))
                ErrorTrace(TRACE_ID, "SetVariant on Name Field failed.");
        }

        // Set the path
        if (_tcslen(pDrvKer->strLikelyPath))
        {
            varValue = pDrvKer->strLikelyPath;
            if (!pInstance->SetVariant(pPath, varValue))
                ErrorTrace(TRACE_ID, "SetVariant on Path Field failed.");
        }


        // set file description, version, partof
        CComBSTR filename = pDrvKer->strLikelyPath;
        SetFileVersionInfo(filename, pInstance);

        // Set the Description - overwrite with well-known description if available
        if (_tcslen(pDrvKer->strDescription))
        {
            varValue = pDrvKer->strDescription;
            if (!pInstance->SetVariant(pDescription, varValue))
                ErrorTrace(TRACE_ID, "SetVariant on Description Field failed.");
        }

        // Set the LoadedFrom
        if (_tcslen(pDrvKer->strLoadedFrom))
        {
            varValue = pDrvKer->strLoadedFrom;
            if (!pInstance->SetVariant(pLoadedFrom, varValue))
                ErrorTrace(TRACE_ID, "SetVariant on LoadedFrom Field failed.");
        }

        // Commit this
        hRes = pInstance->Commit();
        if (FAILED(hRes))
            ErrorTrace(TRACE_ID, "Commit on Instance failed.");

        // advance and delete the record
        pDelDrvKer = pDrvKer;
        pDrvKer = pDrvKer->next;
        delete (pDelDrvKer);
    }

    // get usermode drivers
    // create instances, and cleanup list
    GetDriverUserMode();
    ParseUserModeList(pMethodContext);

    // get msdos drivers
    // create instances, and cleanup list
    GetDriverMSDos();
    ParseMSDosList(pMethodContext);

    TraceFunctLeave();
    return hRes;
}


HRESULT CPCH_Driver::AddDriverKernelList(LPTSTR strDriverList, LPTSTR strLoadedFrom)
{
    TraceFunctEnter("CPCH_Driver::AddDriverKernelList");

    // Break driver list up into tokens
    LPTSTR strDriverName;
    int        nStrLen;
    int        nPos;

    while ((strDriverName = Token_Find(&strDriverList)) != 0)
    {
        // Got the first token
        // See if the first character is '*', if so remove it.
        if(strDriverName[0] == _T('*'))
        {
            strDriverName++;
        }
        // Allocate new element
        DRIVER_KERNEL *pNewKernel = new DRIVER_KERNEL;
        if (!pNewKernel)
        {
            ErrorTrace(TRACE_ID, "Out of memory while calling new DRIVER_KERNEL");
            return WBEM_E_OUT_OF_MEMORY;
        }

        // Zero out all memory
        ZeroMemory(pNewKernel, sizeof(DRIVER_KERNEL));

        // Check if we have a path by seeing if filename is same as the driver name
        LPTSTR strFilename = PathFindFileName(strDriverName);

        // copy name
        _tcscpy(pNewKernel->strDriver, strFilename);

        // terminate name at the extension
        *PathFindExtension(pNewKernel->strDriver) = 0;

        // check for duplicates
        DRIVER_KERNEL   *pDrvKerLoop = m_pDriverKernel;
        BOOL            bDup = FALSE;
        while(pDrvKerLoop)
        {
            if (!_tcsicmp(pDrvKerLoop->strDriver, pNewKernel->strDriver))
            {
                bDup = TRUE;
                break;
            }
            pDrvKerLoop = pDrvKerLoop->next;
        }

        // if duplicate, delete it, otherwise store it in linked list
        if (bDup)
        {
            delete pNewKernel;
        }
        else
        {
            // Copy Loaded From
            _tcscpy(pNewKernel->strLoadedFrom, strLoadedFrom);

            // Copy Path
            _tcscpy(pNewKernel->strLikelyPath, strDriverName);

            // check if it is a well known VxD and copy the description
            for(int iVxDIndex = 0; astrKnownVxDs[iVxDIndex]; iVxDIndex++)
                if (!_tcsicmp(astrKnownVxDs[iVxDIndex], pNewKernel->strDriver))
                    _tcscpy(pNewKernel->strDescription, astrKnownVxDsDesc[iVxDIndex]);

            // Add it to the list
            pNewKernel->next = m_pDriverKernel;
            m_pDriverKernel = pNewKernel;
        }
    }
            
    TraceFunctLeave();
    return S_OK;
}

HRESULT CPCH_Driver::GetDriverKernel()
{
    TraceFunctEnter("CPCH_Driver::GetDriverKernel");

    // Init WinDir
    TCHAR   strWinDir[MAX_PATH];
    GetWindowsDirectory(strWinDir, MAX_PATH);

    // init head of list
    m_pDriverKernel = NULL;

    // Add vmm driver
    TCHAR   strVmmPath[MAX_PATH];
    TCHAR   strVmmFilePath[MAX_PATH];
    PathCombine(strVmmPath, strWinDir, "VMM32");
    PathCombine(strVmmFilePath, strVmmPath, "vmm.vxd");
    AddDriverKernelList(strVmmFilePath, "Registry");

    // Add debugging drivers
    AddDriverKernelList("wdeb386.exe", "Debugger");
    AddDriverKernelList("debugcmd.vxd", "Debugger");

    // Add winsock drivers
    AddDriverKernelList("wsock.vxd", "Winsock");
    AddDriverKernelList("vdhcp.386", "Winsock");

    // Add WINMM drivers
    AddDriverKernelList("mmdevldr.vxd", "Plug and Play");

//    AddDriverKernelList("===HKLM_System_CurrentControlSet_Services_VxD_AFVXD===", "Registry");

    // Add HKLM\System\CurrentControlSet\Services\VxD\AFVXD
    AddRegDriverList(HKEY_LOCAL_MACHINE, "System\\CurrentControlSet\\Services\\VxD\\AFVXD");

//    AddDriverKernelList("===HKLM_System_CurrentControlSet_Services_VxD_Winsock===", "Registry");

    // Add HKLM\System\CurrentControlSet\Services\VxD\Winsock
    AddRegDriverList(HKEY_LOCAL_MACHINE, "System\\CurrentControlSet\\Services\\VxD\\Winsock");

//    AddDriverKernelList("===HKLM_System_CurrentControlSet_Services_Class===", "Registry");

    // Add HKLM\System\CurrentControlSet\Services\Class
    GetRegDriver("System\\CurrentControlSet\\Services\\Class");

//    AddDriverKernelList("===HKLM_System_CurrentControlSet_Services_Class_Display===", "Registry");

    // Add HKLM\System\CurrentControlSet\Services\Class\Display
    GetRegDriver("System\\CurrentControlSet\\Services\\Class\\Display");

//    AddDriverKernelList("===SYSTEM_INI===", "Registry");

    // Add system.ini drivers
    GetSystemINIDriver();

//    AddDriverKernelList("===IOSubSystem===", "Registry");

    // Add IO Subsystem drivers
    GetIOSubsysDriver();

//    AddDriverKernelList("===HKLM_System_CurrentControlSet_Services_VxD===", "Registry");

    // Add HKLM\System\CurrentControlSet\Services\VxD
    GetServicesVxD();

    // Collect additional driver information from MSISYS or DrWatson
    GetMSISYSVxD();

    // Now that we've collected all the drivers, collect each driver's information
    GetKernelDriverInfo();    

    TraceFunctLeave();
    return S_OK;
}


BOOL 
Drivers_PathFileExists(LPTSTR ptszBuf, LPCTSTR ptszPath, LPCTSTR ptszFile)
{
    PathCombine(ptszBuf, ptszPath, ptszFile);
    return PathFileExists(ptszBuf);
}


void 
MakeSrchDirs(void)
{
    TCHAR   tszPath[3];
    LPTSTR  pszDir;
    UINT    ctchPath;
    LPTSTR  ptsz;
    LPTSTR  pTmp;
    int     i = 0;

    // look in windows dir
    GetWindowsDirectory(g_rgSrchDir[0], MAX_PATH);

    // look in windows\vmm32
    PathCombine(g_rgSrchDir[1], g_rgSrchDir[0], TEXT("VMM32"));

    // look in system dir
    GetSystemDirectory(g_rgSrchDir[2], MAX_PATH);

    // look in boot dir
    RMIREGS reg;
    reg.ax = 0x3305;
    reg.dl = 3;             // assume C: in case of error
    Int86x(0x21, &reg);
    wsprintf(g_rgSrchDir[3], "%c:\\", reg.dl + '@');

    // look in dirs specified in path variable
    i = 4;
    pszDir = NULL;
    // get size of path string
    ctchPath = GetEnvironmentVariable(TEXT("PATH"), tszPath, 1);
    pTmp = ptsz = new TCHAR[ctchPath+1];
    if (ptsz)
    {
        GetEnvironmentVariable(TEXT("PATH"), ptsz, ctchPath);
        while ((pszDir = Token_Find(&ptsz)) != 0)
        {
            lstrcpy(g_rgSrchDir[i++],pszDir);
        }
        delete [] pTmp;
    }

    g_nSrchDir = i-1;
}


HRESULT CPCH_Driver::GetKernelDriverInfo()
{
    int i;

    TraceFunctEnter("CPCH_Driver::GetKernelDriverInfo");

    /*
    *  Search order :
    *
    *  1. If extension is ".386" look in Windows directory.
    *  2. Look in System directory.
    *  3. Look in directory Windows was launched from.
    *     (We'll assume Root directory.)
    *  4. Then look on the path.
    *
    *  If the file doesn't have an extension, use ".vxd".
    *
    *  BUGBUG -- this is a hack; need to look for .386 too
    */

    DRIVER_KERNEL       *pDKLoop;
    pDKLoop = m_pDriverKernel;
    
    while(pDKLoop)
    {
        TCHAR szFile[MAX_PATH] = TEXT("");
        LPTSTR szExtension = NULL;

        if (PathFileExists(pDKLoop->strLikelyPath)) 
        {
            goto havefile;
        }

        lstrcpy(szFile, pDKLoop->strLikelyPath);
        for (i=0; i<g_nSrchDir; i++)
        {
            if (Drivers_PathFileExists(pDKLoop->strLikelyPath, g_rgSrchDir[i], szFile))
            {
                goto havefile;
            }

            szExtension = PathFindExtension(pDKLoop->strLikelyPath);

            // no extension?
            if (!_tcslen(szExtension))
            {
                // try .VXD
                lstrcat(szFile, TEXT(".VXD"));
                if (Drivers_PathFileExists(pDKLoop->strLikelyPath, g_rgSrchDir[i], szFile))
                {
                    goto havefile;
                }

                // try .386
                lstrcpy(szFile, pDKLoop->strLikelyPath);
                lstrcat(szFile, TEXT(".386"));
                if (Drivers_PathFileExists(pDKLoop->strLikelyPath, g_rgSrchDir[i], szFile))
                {
                    goto havefile;
                }
            }
        }

        // no path
        lstrcpy(pDKLoop->strLikelyPath, TEXT(""));

havefile:
        pDKLoop = pDKLoop->next;
    }

    TraceFunctLeave();
    return S_OK;
}



HRESULT CPCH_Driver::GetSystemINIDriver()
{
    TraceFunctEnter("CPCH_Driver::GetSystemINIDriver");

    TCHAR str386Enh[SYSTEM_INI_MAX];
    LPTSTR strLine;
    int iLineLen;

    // Get the section 386Enh in system.ini
    GetPrivateProfileSection(TEXT("386Enh"), str386Enh, SYSTEM_INI_MAX, TEXT("system.ini"));

    // For each line in the 386Enh section
    for (strLine = str386Enh; (iLineLen = _tcslen(strLine)) != 0; strLine += iLineLen + 1)
    {
        // Get the value after the '=' char
        LPTSTR strValue = _tcschr(strLine, '=');

        if (strValue)
        {
            // Terminate the string at the '=' char
            *strValue = '\0';

            // Look to see if device corresponds to any of the listed devices
            for (int iDeviceNames = 0; c_rgpszDevice[iDeviceNames]; iDeviceNames++)
            {
                // if it is listed, add to the driver list
                if (_tcsicmp(c_rgpszDevice[iDeviceNames], strLine) == 0)
                {
                    AddDriverKernelList(strValue + 1, "system.ini");
                }
            }
        }
    }

    TraceFunctLeave();
    return S_OK;
}

HRESULT CPCH_Driver::GetIOSubsysDriver()
{
    TraceFunctEnter("CPCH_Driver::GetIOSubsysDriver");

    TCHAR   strSystemDir[MAX_PATH];
    TCHAR   strIOSubSys[MAX_PATH];
    TCHAR   strIOSubSysWildcard[MAX_PATH];
    TCHAR   strFullPath[MAX_PATH];
    TCHAR   strDir[MAX_PATH];

    HANDLE hfd;
    WIN32_FIND_DATA wfd;

    // get the system directory
    if (!GetSystemDirectory(strSystemDir, MAX_PATH))
    {
        ErrorTrace(TRACE_ID, "Error while calling GetSystemDirectory");
        goto EndIO;
    }

    // combine paths to IO Subsystem
    PathCombine(strIOSubSys, strSystemDir, "IOSUBSYS");
    PathCombine(strIOSubSysWildcard, strIOSubSys, "*.*");

    // enumerate all files in IO Subsystem
    hfd = FindFirstFile(strIOSubSysWildcard, &wfd);

    if (hfd != INVALID_HANDLE_VALUE)
        do
        {
            // add file it it has one of the extensions in c_rgptszDrvExt
            LPTSTR strExt = PathFindExtension(wfd.cFileName);
            for (int iExt = 0; c_rgptszDrvExt[iExt]; iExt++) {
                if (_tcsicmp(strExt, c_rgptszDrvExt[iExt]) == 0) {
                    PathCombine(strFullPath, strIOSubSys, wfd.cFileName);
                    AddDriverKernelList(strFullPath, "I/O subsystem");
                    break;
                }
            }
        } while (FindNextFile(hfd, &wfd));
    FindClose(hfd);

EndIO:
    TraceFunctLeave();
    return S_OK;
}
    
HRESULT CPCH_Driver::GetServicesVxD()
{
    TraceFunctEnter("CPCH_Driver::GetServicesVxD");

    TCHAR   strStaticVxd[MAX_PATH];
    DWORD   dwLen = MAX_PATH;
    HKEY    hkMain;

    // Open the key in registry
    if (RegOpenKey(HKEY_LOCAL_MACHINE, "System\\CurrentControlSet\\Services\\VxD", &hkMain) == ERROR_SUCCESS)
    {
        TCHAR strValue[MAX_PATH];

        // Enum all the keys in the subkey
        for (int iEnumSubKey = 0; RegEnumKey(hkMain, iEnumSubKey, strValue, MAX_PATH) == ERROR_SUCCESS; iEnumSubKey++)
        {
            HKEY hkSub;

            // Open the subkey
            if (RegOpenKey(hkMain, strValue, &hkSub) == ERROR_SUCCESS)
            {
                // examine the StaticVxD value
                dwLen = MAX_PATH;
                if (RegQueryValueEx(hkSub, "StaticVxD", 0, 0, (LPBYTE)strStaticVxd, &dwLen) == ERROR_SUCCESS)
                    AddDriverKernelList(strStaticVxd, "Registry");

                // close the key
                RegCloseKey(hkSub);
            }
        }
        // close the key
        RegCloseKey(hkMain);
    }

    TraceFunctLeave();
    return S_OK;
}

HRESULT CPCH_Driver::GetMSISYSVxD()
{
    TraceFunctEnter("CPCH_Driver::GetMSISYSVxD");

    HANDLE hVxDHandle = INVALID_HANDLE_VALUE;

    // try looking for MSISYS.VXD
    hVxDHandle = CreateFile("\\\\.\\MSISYS.VXD", 0, 0, 0, 0, FILE_ATTRIBUTE_NORMAL, 0);
    if (hVxDHandle == INVALID_HANDLE_VALUE)
    {
        // try looking for DRWATSON.VXD
        hVxDHandle = CreateFile("\\\\.\\DRWATSON.VXD", 0, 0, 0, 0, FILE_ATTRIBUTE_NORMAL, 0);
        if (hVxDHandle == INVALID_HANDLE_VALUE)
        {
            ErrorTrace(TRACE_ID, "Error in opening MSISYS.VXD or DRWATSON.VXD");
            goto EndAddVxD;
        }
    }

    // Call into VxD to get additional information
    struct DeviceInfo* pDeviceInfo;
    DWORD cbRc;
    if (DeviceIoControl(hVxDHandle, IOCTL_GETVXDLIST, 0, 0, &pDeviceInfo, sizeof(pDeviceInfo), &cbRc, 0))
    {
        while (pDeviceInfo
            && !IsBadReadPtr(pDeviceInfo, sizeof(*pDeviceInfo)) 
            && pDeviceInfo->DI_Signature == 0x444C5658)
        {
            if (pDeviceInfo->DI_DDB == (LPVOID)1)
                AddDriverKernelList(pDeviceInfo->DI_ModuleName, "UNKNOWN");
            pDeviceInfo = pDeviceInfo->DI_Next;
        }
    }

EndAddVxD:
    if (hVxDHandle != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hVxDHandle);
    }
    TraceFunctLeave();
    return S_OK;
}

HRESULT CPCH_Driver::GetRegDriver(LPTSTR strSubKey)
{
    TraceFunctEnter("CPCH_Driver::GetRegDriver");

    TCHAR   strStaticVxd[MAX_PATH];
    DWORD   dwLen = MAX_PATH;
    HKEY    hkMain;

    // Open the key in registry
    if (RegOpenKey(HKEY_LOCAL_MACHINE, strSubKey, &hkMain) == ERROR_SUCCESS)
    {
        TCHAR strValue[MAX_PATH];

         // Enum all the keys in the subkey
        for (int iEnumSubKey = 0; RegEnumKey(hkMain, iEnumSubKey, strValue, MAX_PATH) == ERROR_SUCCESS; iEnumSubKey++)
        {
            HKEY hkSub;

             // Open the subkey
            if (RegOpenKey(hkMain, strValue, &hkSub) == ERROR_SUCCESS)
            {
                TCHAR strSubValue[MAX_PATH];

                 // Enum all the subkeys in the subkey
                for (int iEnumSubSubKey = 0; RegEnumKey(hkSub, iEnumSubSubKey, strSubValue, MAX_PATH) == ERROR_SUCCESS; iEnumSubSubKey++)
                {
                    HKEY hkSubSub;

                     // Open the subsubkey
                    if (RegOpenKey(hkSub, strSubValue, &hkSubSub) == ERROR_SUCCESS)
                    {
                        // examine the values in subkey
                        AddRegDriverConfigList(hkSubSub);
                    }
                    // close the key
                    RegCloseKey(hkSubSub);
                }
                // close the key
                RegCloseKey(hkSub);
            }
        }
        // close the key
        RegCloseKey(hkMain);
    }

    TraceFunctLeave();
    return S_OK;
}

HRESULT CPCH_Driver::AddRegDriverConfigList(HKEY hk)
{
    TraceFunctEnter("CPCH_Driver::AddRegDriverConfigList");
    for (int iCount = 0; c_rgptszConfig[iCount]; iCount++)
    {
        TCHAR      strValue[MAX_PATH];
        DWORD      dwCount = MAX_PATH;
        

        if (RegQueryValueEx(hk, c_rgptszConfig[iCount], 0, 0, (LPBYTE)strValue, &dwCount) == ERROR_SUCCESS)
        {
            /*
            if(strValue[0] == '*')
            {
                nStrLen = _tcslen(strValue);
                for(nPos = 1;  nPos < nStrLen ; nPos++)
                {
                    strValue[nPos-1] = strValue[nPos];
                }
            }
            */
            AddDriverKernelList(strValue, "Plug and Play");
        }

    }

    TraceFunctLeave();
    return S_OK;
}


HRESULT CPCH_Driver::AddRegDriverList(HKEY hKeyMain, LPTSTR strSubKey)
{
    TraceFunctEnter("CPCH_Driver::AddRegDriverList");
    HKEY hKey;

    // Open key in registry
    if (RegOpenKey(hKeyMain, strSubKey, &hKey) == ERROR_SUCCESS) 
    {
        // enumerate all values
        for (int iValue = 0; ; iValue++)
        {
            TCHAR strValue[MAX_PATH];
            TCHAR strKey[MAX_PATH];
            DWORD ctchRc = MAX_PATH;
            DWORD cbRc = MAX_PATH;
            LONG lResult;

            lResult = RegEnumValue(hKey, iValue, strKey, &ctchRc, 0, 0, (LPBYTE)strValue, &cbRc);

            if (lResult == ERROR_SUCCESS)
            {
                if (strKey[0])
                    AddDriverKernelList(strValue, "Registry");
            }
            else
                if (lResult != ERROR_MORE_DATA)
                    break;
        }
        // close the key
        RegCloseKey(hKeyMain);
    }
    else
        ErrorTrace(TRACE_ID, "RegOpenKey failed");

    TraceFunctLeave();
    return S_OK;
}


// get list of MSDos drivers
HRESULT
CPCH_Driver::GetDriverMSDos()
{
    VXDINFO vi;
    VXDOUT  vo;
    HANDLE  hVxD = INVALID_HANDLE_VALUE;
    ULONG   cbRc;
    PBYTE   pbSysVars = NULL;
    WORD    wTemp = 0;
    BOOL    fRc = FALSE;

    TraceFunctEnter("CPCH_DRIVER::GetDriverMSDos");

    // open handle to vxd
    hVxD = CreateFile(TEXT("\\\\.\\MSISYS.VXD"), 0, 0, 0, 0, FILE_FLAG_DELETE_ON_CLOSE, 0);
    if (hVxD == INVALID_HANDLE_VALUE) 
    {
        ErrorTrace(TRACE_ID, "Cannot open VxD");
        goto exit;
    }

    // get high linear address of system VM
    // ask msisys.vxd for this
    vo.dwHighLinear = 0;
    fRc = DeviceIoControl(hVxD, 
                          IOCTL_CONNECT,
                          &vi,
                          sizeof(vi),
                          &vo, 
                          sizeof(vo), 
                          &cbRc,
                          0);

    if (fRc && vo.dwHighLinear) 
    {
        RMIREGS reg;

        // Get list of driver lists 
        reg.ax = 0x5200;            
        if (Int86x(0x21, &reg) == 0) 
        {
            pbSysVars = (PBYTE) pvAddPvCb(vo.dwHighLinear,
                                            reg.es * 16 + reg.bx);
          
            //  Build the list of drivers in conventional memory.
            wTemp = PUN(WORD, pbSysVars[-2]);

            DosMem_WalkArena(wTemp, vo.dwHighLinear);

            //  Build the list of drivers in UMBs.             
            wTemp = PUN(WORD, pbSysVars[0x66]);
            if (wTemp != 0xFFFF) 
            {
                DosMem_WalkArena(wTemp, vo.dwHighLinear);
            }

            //  Remove KRNL386 and its ilk to prune away non-TSR apps.
            DosMem_CleanArena(vo.dwHighLinear);
        }
    } 

exit:
    TraceFunctLeave();
    if (hVxD)
    {
        CloseHandle(hVxD);
    }
    return S_OK;
}



// get list of user mode drivers 
HRESULT
CPCH_Driver::GetDriverUserMode()
{
    BOOL fRc;
    WORD hDriver;
    DRIVERINFOSTRUCT16 dis;

    TraceFunctEnter("CPCH_Driver::GetDriverUserMode");

    dis.length = sizeof(dis);

    hDriver = 0;

    // walk through list of 16-bit drivers
    while ((hDriver = GetNextDriver16(hDriver,
                                      GND_FIRSTINSTANCEONLY)) != 0) 
    {
        if (GetDriverInfo16(hDriver, &dis))
        {
            WORD                wVer;
            DWORD               dwMajor;
            DWORD               dwMinor;
            TCHAR               szTemp[MAX_PATH];
            DRIVER_USER_MODE*   pDriver = new DRIVER_USER_MODE;
            
            if (!pDriver)
            {
                ErrorTrace(TRACE_ID,"Cannot allocate memory");
                goto exit;
            }

            if (GetModuleFileName16(dis.hModule,
                                pDriver->strPath,
                                cA(pDriver->strPath)))
            {
                lstrcpyn(pDriver->strDriver, 
                         dis.szAliasName,
                         cA(pDriver->strDriver));

                wVer = GetExpWinVer16(dis.hModule);
                dwMajor = HIBYTE(wVer);
                dwMinor = LOBYTE(wVer);
                wsprintf(pDriver->strType,
                         TEXT("%d.%d"),
                         dwMajor,
                         dwMinor % 10 ? dwMinor : dwMinor / 10);

                // append to driver list
                m_DriverUserModeList.push_back(pDriver);
            }
            else
            {
                delete pDriver;
                ErrorTrace(TRACE_ID, "GetModuleFileName16 failed");
            }
        }
    }

exit:
    TraceFunctLeave();    
    return S_OK;
}


// walk arena and create list of drivers
void 
CPCH_Driver::DosMem_WalkArena(WORD segStart, DWORD dwHighLinear)
{
    WORD segStop = 0;               
    WORD seg = segStart;
    TCHAR szTemp[MAX_PATH]="";

    TraceFunctEnter("DosMem_WalkArena");

    do
    {
        PARENA par = (PARENA) (dwHighLinear + seg * 16);

        seg++;

        //  Remember the stop point if we've found it.
        if (par->bType == 'Z')
        {
            segStop = (WORD)(seg + par->csegSize);
        }


        //  If it's owned by itself, then it's a program or driver.
        //  We know a bit more about the DOS memory subtypes.
        //  This can change in principle (since most people don't
        //  know about it, and we changed it in Win95, so obviously
        //  it isn't compatibility-constrained).
        if (par->segOwner == seg) 
        {
            DRIVER_MS_DOS* pDriver = NULL;

            if (par->bType == 'M' || par->bType == 'D' || par->bType == 'Z')
            {

                pDriver = new DRIVER_MS_DOS;

                if (!pDriver)
                {
                    ErrorTrace(TRACE_ID, "Cannot allocate memory");
                    goto exit;
                }

                lstrcpyn(pDriver->strName, par->rgchOwner, 9);
                pDriver->seg = seg;
                m_DriverMSDosList.push_back(pDriver);
            }
        }


        //  If it's owned by 8 and rgchOwner is "SD", then it's
        //  "system data" and contains subobjects.  Else, it's a
        //  normal arena that we step over.
        segStart = seg;
        if (par->segOwner == 8 && PUN(WORD, par->rgchOwner) == 0x4453) 
        {
        } 
        else 
        {
            seg = (WORD)(seg + par->csegSize);
        }

        if (seg < segStart)
        {
            break;
        }

    } while (seg != segStop);

exit:
    TraceFunctLeave();
}


// Remove the items that are apps and not TSRs.  
// Done by locating KRNL386, and then walking the parent chain until
// we find an app that is its own parent.
void
CPCH_Driver::DosMem_CleanArena(DWORD dwHighLinear)
{
    std::list<DRIVER_MS_DOS*>::iterator it = m_DriverMSDosList.begin();
    std::list<DRIVER_MS_DOS*>::iterator it2;
    WORD seg, segParent;
    PBYTE ppsp;

    TraceFunctEnter("CPCH_Driver::DosMem_CleanArena");

    while (it != m_DriverMSDosList.end())
    {
        if ((*it) && _tcsstr((*it)->strName,TEXT("KRNL386")))
        {
            break;
        }
        it++;
    }

    // cannot find KRNL386?
    if (it == m_DriverMSDosList.end() || !(*it))
    {
        goto exit;
    }

    // traverse list in reverse order
    do 
    {
        seg = (*it)->seg;
        ppsp = (PBYTE) (dwHighLinear + seg * 16);
        m_DriverMSDosList.erase(it);
        it--;

        segParent = PUN(WORD, ppsp[0x16]);
        if (seg == segParent) // Found the top. Stop
        {     
            break;
        }

        // find parent 
        for (it2 = m_DriverMSDosList.begin(); it2 != m_DriverMSDosList.end(); it2++)
        {
            if ((*it2) && (*it2)->seg == segParent)
            {
                it = it2;
                break;
            }
        }
        if (it2 == m_DriverMSDosList.end())  // parent not found
        {
            break;
        }
    } while (it != m_DriverMSDosList.begin() && (*it));

exit:
    TraceFunctLeave();
}


void CPCH_Driver::SetFileVersionInfo(CComBSTR filename, CInstance *pInstance)
{
    CFileVersionInfo fvi;

    TraceFunctEnter("CPCH_Driver::SetFileVersionInfo");

    CComPtr<IWbemClassObject>   pFileObj;
    if (SUCCEEDED(GetCIMDataFile(filename, &pFileObj)))
    {
        CopyProperty(pFileObj, L"Version", pInstance, pVersion);
        CopyProperty(pFileObj, L"FileSize", pInstance, pSize);
        CopyProperty(pFileObj, L"CreationDate", pInstance, pDate);
        CopyProperty(pFileObj, L"Manufacturer", pInstance, pManufacturer);
    }

    if (SUCCEEDED(fvi.QueryFile(filename)))
    {
        if (!pInstance->SetCHString(pDescription, fvi.GetDescription()))
            ErrorTrace(TRACE_ID, "SetCHString on description field failed.");

        if (!pInstance->SetCHString(pPartOf, fvi.GetProduct()))
            ErrorTrace(TRACE_ID, "SetCHString on partof field failed.");
    }

    TraceFunctLeave();
}


// step through user mode driver list and create instances
HRESULT
CPCH_Driver::ParseUserModeList(
        MethodContext* pMethodContext
        )
{
    HRESULT                 hRes = WBEM_S_NO_ERROR;
    std::list<DRIVER_USER_MODE* >::iterator  it = m_DriverUserModeList.begin();

    TraceFunctEnter("CPCH_Driver::ParseUserModeList");

    while (it != m_DriverUserModeList.end() && (SUCCEEDED(hRes))) 
    {
        DRIVER_USER_MODE* pUMDrv = *it;

        if (!pUMDrv)
        {
            ErrorTrace(TRACE_ID, "Null driver node in list");
            continue;
        }

        SYSTEMTIME stUTCTime;
        GetSystemTime(&stUTCTime);
       
        // Create a new instance based on the passed-in MethodContext
        CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);

        if (!pInstance->SetDateTime(pTimeStamp, WBEMTime(stUTCTime)))
        {
            ErrorTrace(TRACE_ID, "SetDateTime on Timestamp Field failed.");
        }
        if (!pInstance->SetCHString(pChange, L"Snapshot"))
        {
            ErrorTrace(TRACE_ID, "SetCHString on Change Field failed.");
        }

        // set category
        if (!pInstance->SetCHString(pCategory, L"UserMode"))
        {
            ErrorTrace(TRACE_ID, "SetCHString on Change Field failed.");
        }

        // set driver name
        if (!pInstance->SetCHString(pName, pUMDrv->strDriver))
        {
            ErrorTrace(TRACE_ID, "SetCHString on Name Field failed.");
        }

        // set path
        if (!pInstance->SetCHString(pPath, pUMDrv->strPath))
        {
            ErrorTrace(TRACE_ID, "SetCHString on Path Field failed.");
        }

        // set type 
        if (!pInstance->SetCHString(pType, pUMDrv->strType))
        {
            ErrorTrace(TRACE_ID, "SetCHString on Type Field failed.");
        }


        // get version info
        CFileVersionInfo fvi;
        CComBSTR filename = pUMDrv->strPath;
        SetFileVersionInfo(filename,pInstance);
        hRes = pInstance->Commit();
        if (FAILED(hRes))
        {
            ErrorTrace(TRACE_ID, "Commit on Instance failed.");
        }
                    
        // delete the node
        delete pUMDrv;
        pUMDrv = NULL;
        it = m_DriverUserModeList.erase(it);
    }    
    TraceFunctLeave();
    return hRes;
}


// step through ms-dos driver list and create instances
HRESULT
CPCH_Driver::ParseMSDosList(
        MethodContext* pMethodContext
        )
{
    HRESULT                 hRes = WBEM_S_NO_ERROR;
    std::list<DRIVER_MS_DOS* >::iterator  it = m_DriverMSDosList.begin();

    TraceFunctEnter("CPCH_Driver::ParseMSDosList");

    while (it != m_DriverMSDosList.end() && (SUCCEEDED(hRes))) 
    {
        DRIVER_MS_DOS* pMSDrv = *it;

        if (!pMSDrv)
        {
            ErrorTrace(TRACE_ID, "Null driver node in list");
            continue;
        }

        SYSTEMTIME stUTCTime;
        GetSystemTime(&stUTCTime);

        
        // Create a new instance based on the passed-in MethodContext
        CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);

        if (!pInstance->SetDateTime(pTimeStamp, WBEMTime(stUTCTime)))
        {
            ErrorTrace(TRACE_ID, "SetDateTime on Timestamp Field failed.");
        }

        if (!pInstance->SetCHString(pChange, L"Snapshot"))
        {
            ErrorTrace(TRACE_ID, "SetCHString on Change Field failed.");
        }

        // set category
        if (!pInstance->SetCHString(pCategory, L"MSDOS"))
        {
            ErrorTrace(TRACE_ID, "SetCHString on Change Field failed.");
        }

        // set driver name
        if (!pInstance->SetCHString(pName, pMSDrv->strName))
        {
            ErrorTrace(TRACE_ID, "SetCHString on Name Field failed.");
        }

        // set type to "Device Driver" 
        if (!pInstance->SetCHString(pType, L"Device Driver"))
        {
            ErrorTrace(TRACE_ID, "SetCHString on Type Field failed.");
        }

        hRes = pInstance->Commit();
        if (FAILED(hRes))
        {
            ErrorTrace(TRACE_ID, "Commit on Instance failed.");
        }
        
        // delete the node
        delete pMSDrv;
        pMSDrv = NULL;
        it = m_DriverMSDosList.erase(it);
    }    
    TraceFunctLeave();
    return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprov\pch_fileupload.h ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_FileUpload.H

Abstract:
	WBEM provider class definition for PCH_FileUpload class

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

********************************************************************/

// Property set identification
//============================

#ifndef _PCH_FileUpload_H_
#define _PCH_FileUpload_H_

#define PROVIDER_NAME_PCH_FILEUPLOAD "PCH_FileUpload"

// Property name externs -- defined in PCH_FileUpload.cpp
//=================================================

extern const WCHAR* pTimeStamp ;
extern const WCHAR* pChange ;
extern const WCHAR* pData ;
extern const WCHAR* pDateAccessed ;
extern const WCHAR* pDateCreated ;
extern const WCHAR* pDateModified ;
extern const WCHAR* pFileAttributes ;
extern const WCHAR* pPath ;
extern const WCHAR* pSize ;

class CPCH_FileUpload : public Provider 
{
	public:
		// Constructor/destructor
		//=======================

		CPCH_FileUpload(const CHString& chsClassName, LPCWSTR lpszNameSpace) : Provider(chsClassName, lpszNameSpace) {};
		virtual ~CPCH_FileUpload() {};

	protected:
		// Reading Functions
		//============================
        virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L){ return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L) ;

		// Writing Functions
		//============================
		virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Other Functions
		virtual HRESULT ExecMethod( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags = 0L ) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprov\pch_networkadapter.cpp ===
/*****************************************************************************

  Copyright (c) 1999 Microsoft Corporation
  
    Module Name:
    .PCH_NetworkAdapter.CPP
    
      Abstract:
      WBEM provider class implementation for PCH_NetworkAdapter class.
      1. This class gets the foll. properties from Win32_NetworkAdapter Class:
      AdapterType, DeviceID, ProductName
      2. Gets the foll. properties from Win32_NetworkAdapterConfiguration Class:
      ServiceName,IPAddress,IPSubnet,DefaultIPGateway,DHCPEnabled,MACAddress
      3. Gets the foll. properties from Win32_IRQResource Class:
      IRQ Number
      4. Gets the foll. properties from Win32_PortResource Class:
      StartingAddress, EndingAddress
      5. Sets the "Change" property to "Snapshot" always
      
        Revision History:
        
          Ghim Sim Chua       (gschua)                        04/27/99
          - Created
          Kalyani Narlanka      kalyanin
          - Added  ServiceName, IPAddress, IPSubnet, DefaultIPGateway, DHCPEnabled, 
                   MACAddress                                 05/03/99
          - Added  IRQNumber and PORT Resource                07/08 /99
          
            
*******************************************************************************/

#include "pchealth.h"
#include "PCH_NetworkAdapter.h"

///////////////////////////////////////////////////////////////////////////////
//    Begin Tracing stuff
//
#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile
#define TRACE_ID    DCID_NETWORKADAPTER
//
//    End Tracing stuff
///////////////////////////////////////////////////////////////////////////////

//    
CPCH_NetworkAdapter MyPCH_NetworkAdapterSet (PROVIDER_NAME_PCH_NETWORKADAPTER, PCH_NAMESPACE) ;

///////////////////////////////////////////////////////////////////////////////
//....Properties of PCHNetworkAdapter Class
//
const static WCHAR* pAdapterType      = L"AdapterType" ;
const static WCHAR* pTimeStamp        = L"TimeStamp" ;
const static WCHAR* pChange           = L"Change" ;
// const static WCHAR* pDefaultIPGateway = L"DefaultIPGateway" ;
const static WCHAR* pDeviceID         = L"DeviceID" ;
const static WCHAR* pDHCPEnabled      = L"DHCPEnabled" ;
const static WCHAR* pIOPort           = L"IOPort" ;
// const static WCHAR* pIPAddress        = L"IPAddress" ;
// const static WCHAR* pIPSubnet         = L"IPSubnet" ;
const static WCHAR* pIRQNumber        = L"IRQNumber" ;
// const static WCHAR* pMACAddress       = L"MACAddress" ;
const static WCHAR* pProductName      = L"ProductName" ;
// const static WCHAR* pServiceName      = L"ServiceName" ;
//
///////////////////////////////////////////////////////////////////////////////


//*****************************************************************************
//
// Function Name     : CPCH_NetworkAdapter::EnumerateInstances
//
// Input Parameters  : pMethodContext : Pointer to the MethodContext for 
//                                      communication with WinMgmt.
//                
//                     lFlags :         Long that contains the flags described 
//                                      in IWbemServices::CreateInstanceEnumAsync
//                                      Note that the following flags are handled 
//                                      by (and filtered out by) WinMgmt:
//                                      WBEM_FLAG_DEEP
//                                      WBEM_FLAG_SHALLOW
//                                      WBEM_FLAG_RETURN_IMMEDIATELY
//                                      WBEM_FLAG_FORWARD_ONLY
//                                      WBEM_FLAG_BIDIRECTIONAL
// Output Parameters  : None
//
// Returns            : WBEM_S_NO_ERROR 
//                      
//
// Synopsis           : All instances of this class on the machine are returned.
//                      If there are no instances returns WBEM_S_NO_ERROR.
//                      It is not an error to have no instances.
//                 
//
//*****************************************************************************

HRESULT CPCH_NetworkAdapter::EnumerateInstances(MethodContext* pMethodContext,
                                                long lFlags)
{
    TraceFunctEnter("CPCH_NetworkAdapter::EnumerateInstances");
    
    //  Begin Declarations...................................................
    HRESULT                             hRes = WBEM_S_NO_ERROR;
    REFPTRCOLLECTION_POSITION           posList;
    
    //  Instances
    CComPtr<IEnumWbemClassObject>       pNetworkAdapterEnumInst;
    CComPtr<IEnumWbemClassObject>       pNetworkAdapterConfigurationEnumInst;
    CComPtr<IEnumWbemClassObject>       pAllocatedResourceEnumInst;
    CComPtr<IEnumWbemClassObject>       pPortResourceEnumInst;
    
    //  PCH_NetworkAdapter Class instance 
    CInstancePtr                         pPCHNetworkAdapterInstance;
    
    //  Objects
    IWbemClassObjectPtr                  pNetworkAdapterObj;                   
    IWbemClassObjectPtr                  pNetworkAdapterConfigurationObj;      
    IWbemClassObjectPtr                  pAllocatedResourceObj;                
    IWbemClassObjectPtr                  pPortResourceObj;                     

    //  Variants
    CComVariant                         varIndex;
    CComVariant                         varDeviceID;
    CComVariant                         varAntecedent;
    CComVariant                         varPortResource;
    CComVariant                         varName;
    CComVariant                         varIRQNumber;
    
    //  Return Values;
    ULONG                               ulNetworkAdapterRetVal               = 0;
    ULONG                               ulNetworkAdapterConfigurationRetVal  = 0;
    ULONG                               ulAllocatedResourceRetVal            = 0;
    ULONG                               ulPortResourceRetVal                 = 0;
    
    //  Query Strings
    CComBSTR                            bstrNetworkAdapterQuery              = L"Select AdapterType, DeviceID, ProductName, Index FROM win32_NetworkAdapter";
    CComBSTR                            bstrNetworkAdapterConfigurationQuery = L"Select ServiceName, IPAddress, IPSubnet, DefaultIPGateway, DHCPEnabled, MACAddress, Index FROM Win32_NetworkAdapterConfiguration WHERE Index=";
    CComBSTR                            bstrAllocatedResourceQuery           = L"SELECT Antecedent, Dependent FROM Win32_AllocatedResource WHERE  Dependent=\"Win32_NetworkAdapter.DeviceID=\\\""; 
    CComBSTR                            bstrPortResourceQuery                = L"Select StartingAddress, Name FROM Win32_PortResource WHERE ";
    
    //  Other Query Strings
    CComBSTR                            bstrNetworkAdapterConfigurationQueryString;
    CComBSTR                            bstrAllocatedResourceQueryString;
    CComBSTR                            bstrPortResourceQueryString;

    //  Other  Strings
    CComBSTR                            bstrPropertyAntecedent = L"antecedent";
    CComBSTR                            bstrPropertyName = L"Name";
    CComBSTR                            bstrIndex = L"Index";
    CComBSTR                            bstrDeviceID = L"DeviceID";
    CComBSTR                            bstrResult;

    //  SystemTime
    SYSTEMTIME                          stUTCTime;

    //  Integers 
    int                                 i;
    int                                 nIRQLen;
    int                                 nIter;

    //  Pattern Strings
    LPCSTR                               strIRQPattern                 = "Win32_IRQResource.IRQNumber=";
    LPCSTR                               strPortPattern                = "Win32_PortResource.StartingAddress=";
    LPCSTR                               strPortPattern2               = "Win32_PortResource.";

    //  Chars
    LPSTR                                strSource;
    LPSTR                                pDest;

    BOOL                                 fValidInt;

    //  End  Declarations...................................................

    //  Should take care of memory allocation failure for CComBSTRs


    // Get the date and time to update the TimeStamp Field
    GetSystemTime(&stUTCTime);
    
    //
    // Execute the query to get "AdapterType", "DeviceID", "Name" and "Index"
    // from Win32_NetworkAdapter Class.
    
    // "Index" is required as it is the common property between
    // Win32_NetworkAdapter and Win32_NetworkAdapterConfiguration
    // pNetworkAdapterEnumInst contains a pointer to the list of instances returned.
    //
    hRes = ExecWQLQuery(&pNetworkAdapterEnumInst, bstrNetworkAdapterQuery);
    if (FAILED(hRes))
    {
        //  Cannot get any properties.
        goto END;
    }
    
    //  Query Succeeded!
    
    //  Enumerate the instances from pNetworkAdapterEnumInst.
    //  Get the next instance into pNetworkAdapterObj object.
    
    while(WBEM_S_NO_ERROR == pNetworkAdapterEnumInst->Next(WBEM_INFINITE, 1, &pNetworkAdapterObj, &ulNetworkAdapterRetVal))
    {

        //  Create a new instance of PCH_NetworkAdapter Class based on the passed-in MethodContext
        
        CInstancePtr pPCHNetworkAdapterInstance(CreateNewInstance(pMethodContext), false);

        //  Created a New Instance of PCH_NetworkAdapter Successfully.

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //                              TIME STAMP                                                                 //
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////

        hRes = pPCHNetworkAdapterInstance->SetDateTime(pTimeStamp, WBEMTime(stUTCTime));
        if (FAILED(hRes))
        {
            //  Could not Set the Time Stamp
            //  Continue anyway
                ErrorTrace(TRACE_ID, "SetDateTime on Timestamp Field failed.");
        }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //                              CHANGE                                                                     //
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////

        hRes = pPCHNetworkAdapterInstance->SetCHString(pChange, L"Snapshot");
        if (FAILED(hRes))
        {
            //  Could not Set the Change Property
            //  Continue anyway
            ErrorTrace(TRACE_ID, "SetCHString on Change Field failed.");
        }

        //  Copy the following properties from win32_NetworkAdapter class Instance 
        //  TO PCH_NetworkAdapter class Instance.

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //                              ADAPTERTYPE                                                                //
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////

        CopyProperty(pNetworkAdapterObj, L"AdapterType", pPCHNetworkAdapterInstance, pAdapterType);

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //                              DEVICEID                                                                   //
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////

        CopyProperty(pNetworkAdapterObj, L"DeviceID", pPCHNetworkAdapterInstance, pDeviceID);

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //                              PRODUCTNAME                                                                //
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////

        CopyProperty(pNetworkAdapterObj, L"ProductName", pPCHNetworkAdapterInstance, pProductName);

        /*

        Because of Bug : 100158 , regarding dropping all the privacy related properties, 
        the foll. properties need to be dropped :

        ServiceName, IPAddress, IPSubnet, DefaultIPGateway,  MACAddress

        */



        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //                              INDEX                                                                      //
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
            
        //  Get the "Index" property from the current instance Object
        //  Index is the common property between NetworkAdapter and NetworkAdapterConfiguration.

        hRes = pNetworkAdapterObj->Get(bstrIndex, 0, &varIndex, NULL, NULL);
        if (FAILED(hRes))
        {
            //  Cannot get index.
            //  Without Index Cannot get any properties from Win32_NetworkAdapterConfiguration Class
                ErrorTrace(TRACE_ID, "GetVariant on Index Field failed.");
        }
        else 
        {
            //  Got the index. Now we are ready to get the properties from Win32_NetworkAdapterConfiguration Class
            //  With "index" as the key get the corresponding NetworkAdapterConfiguration instance
            //   Make Sure Index is of Type VT_I4 i.e. long
            //   Convert the Index to type VT_I4 
            hRes = varIndex.ChangeType(VT_I4, NULL);
            if FAILED(hRes)
            {
                //  Not of type VT_I4 So there is no way to get the Corresponding 
                //  NetworkAdapter Configuration instance
            }
            else
            {
                //  index of expected Type. Get the corr. NetworkAdapterConfiguration instance

                //  Append the "index" to the Query String

                bstrNetworkAdapterConfigurationQueryString =  bstrNetworkAdapterConfigurationQuery;

                //  Change varIndex to BSTR type so that it can be appended
                varIndex.ChangeType(VT_BSTR, NULL);

                bstrNetworkAdapterConfigurationQueryString.Append(V_BSTR(&varIndex));

                //  Execute the query to get "ServiceName", "IPAddress", "IPSubnet", 
                //  "DefaultIPGateway", "DHCPEnabled", "MACAddress", "Index"
                //  from Win32_NetworkAdapter Configuration Class.

                //  pNetworkAdapterConfigurationEnumInst contains a pointer to the instance returned.

                hRes = ExecWQLQuery(&pNetworkAdapterConfigurationEnumInst,bstrNetworkAdapterConfigurationQueryString);
                if (FAILED(hRes))
                {
                    //  Query failed!! Cannot Copy Values.
                }
                else
                {
                    // Query Succeeded. Get the Instance Object
                    if (WBEM_S_NO_ERROR == pNetworkAdapterConfigurationEnumInst->Next(WBEM_INFINITE, 1, &pNetworkAdapterConfigurationObj, &ulNetworkAdapterConfigurationRetVal))
                    {
                        //  Copy the following properties from win32_NetworkAdapterConfiguration 
                        //  class Instance TO PCH_NetworkAdapter class Instance.

                        /*

                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                        //                              SERVICENAME                                                                //
                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////

                        CopyProperty(pNetworkAdapterConfigurationObj, L"ServiceName", pPCHNetworkAdapterInstance, pServiceName);

                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                        //                              IPADDRESS                                                                  //
                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////

                        CopyProperty(pNetworkAdapterConfigurationObj, L"IPAddress", pPCHNetworkAdapterInstance, pIPAddress);

                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                        //                              IPSUBNET                                                                   //
                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////

                        CopyProperty(pNetworkAdapterConfigurationObj, L"IPSubnet", pPCHNetworkAdapterInstance, pIPSubnet);

                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                        //                              DEFAULTIPGATEWAY                                                           //
                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////

                        CopyProperty(pNetworkAdapterConfigurationObj, L"DefaultIPGateway", pPCHNetworkAdapterInstance, pDefaultIPGateway);

                        */

                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                        //                              DHCPENABLED                                                                //
                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////

                        CopyProperty(pNetworkAdapterConfigurationObj, L"DHCPEnabled", pPCHNetworkAdapterInstance, pDHCPEnabled);

                        /*

                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                        //                              MACADDRESS                                                                //
                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////

                        CopyProperty(pNetworkAdapterConfigurationObj, L"MACAddress", pPCHNetworkAdapterInstance, pMACAddress);

                        */

                        
                    } //end of if pNetworkAdapterConfigurationEnumInst....


                } // end of else query succeeded

                
            } // end of else got the index

        } // end of else got the index

        

        //  Get the resources from Win32_AllocatedResource

        //  Update the Query String with the Device ID Property.
        bstrAllocatedResourceQueryString = bstrAllocatedResourceQuery;

        hRes = pNetworkAdapterObj->Get(bstrDeviceID, 0, &varDeviceID, NULL, NULL);

        if (FAILED(hRes))
        {
            //  Current Instance object no longer required.
            //  hRes = pNetworkAdapterObj->Release();
            if (FAILED(hRes))
            {
                //  Unable to realease the Object
                ErrorTrace(TRACE_ID, "GetVariant on DeviceID Field while calculating IRQ and PORT Resource failed!");
            }

            //                Cannot get DeviceID
            ErrorTrace(TRACE_ID, "GetVariant on DeviceID Field while calculating IRQ and PORT Resource failed!");

        } // end of cannot get the DeviceId 
        else 
        {

            //  Current Instance object no longer required.
            //  hRes = pNetworkAdapterObj->Release();
            if (FAILED(hRes))
            {
                //  Unable to realease the Object
                ErrorTrace(TRACE_ID, "GetVariant on DeviceID Field while calculating IRQ and PORT Resource failed!");
            }

            //  Got the DeviceID

            //  Convert the DeviceID to type VT_BSTR
            hRes = varDeviceID.ChangeType(VT_BSTR, NULL);
            if FAILED(hRes)
            {
                //  Cannot get the DeviceID value. So there is no way to get the Corresponding 
                //  IRQ and PORT Resources.
            } // end of FAILED hRes , Cannot get the DeviceID Value
            else
            {
                //  Got the DeviceID value.  Update the Query string with this value.
                _ASSERT(varDeviceID.vt == VT_BSTR);
                bstrAllocatedResourceQueryString.Append(V_BSTR(&varDeviceID));

                //  Append "///" to the QueryString.
                bstrAllocatedResourceQueryString.Append("\\\"\"");

                //  The Query string is formed, get the antecedent instances
                //  Added the following line because you need to clear the CComPtr before you query the second time.
                pAllocatedResourceEnumInst = NULL;
                hRes = ExecWQLQuery(&pAllocatedResourceEnumInst, bstrAllocatedResourceQueryString); 
                if (FAILED(hRes))
                {
                    //  Query failed!! Cannot get the Resources.
                    //  Continue anyway
                }
                else
                {
                    //  Get the "antecedent" value.  

                    //  Query Succeeded. Get the Instance Object
                    //  Get all the instances of Win32_AllocatedResource applicable
                    while(WBEM_S_NO_ERROR == pAllocatedResourceEnumInst->Next(WBEM_INFINITE, 1, &pAllocatedResourceObj, &ulAllocatedResourceRetVal))
                    {
                        hRes = pAllocatedResourceObj->Get(bstrPropertyAntecedent, 0, &varAntecedent, NULL, NULL);
                        if (FAILED(hRes))
                        {
                            //  Could not get the antecedent
                            ErrorTrace(TRACE_ID, "GetVariant on Win32_AllocatedResource:Antecedent Field failed.");
                        } //end of if FAILED(pAllocatedResourceObj->Get..antecedent
                        else
                        {
                            //  Got the antecedent

                            // varAntecedent set to antecedent. Copy this to bstrResult
                            varAntecedent.ChangeType(VT_BSTR, NULL);

                            {
                                USES_CONVERSION;
                                strSource = OLE2A(varAntecedent.bstrVal);
                            }

                            //  Check if it is IRQ Resource by comparing with the known pattern of IRQ Resource
                            pDest = strstr(strSource,strIRQPattern);

                            /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                            //                              IRQ Number                                                                 //
                            /////////////////////////////////////////////////////////////////////////////////////////////////////////////

                            if(pDest != NULL)
                            {

                                //  This is IRQ Resource instance
                                //  Can get the IRQ Number

                                //  Advance the pointer to the end of the pattern so the pointer is 
                                //  positioned at IRQ Number
                                pDest += lstrlen(strIRQPattern);

                                // First verify that the given string is a valid integer.
                                nIRQLen = lstrlen(pDest);
                                fValidInt = TRUE;

                                for(nIter = 0; nIter <nIRQLen; nIter++)
                                {
                                    if (_istdigit(pDest[nIter]) == 0)
                                    {
                                        fValidInt = FALSE;
                                        break;
                                    }
                                }

                                if(fValidInt)
                                {
                                    // Convert the IRQ Number that you get as string to a long

                                    varIRQNumber = atol(pDest);

                                    //  Set the IRQ Number as a variant
                                    hRes = pPCHNetworkAdapterInstance->SetVariant(pIRQNumber, varIRQNumber);
                                    if (!hRes)
                                    {
                                        ErrorTrace(TRACE_ID, "SetVariant on win32_AllocatedResource.IRQ Number Failed!");
                                        //  Proceed Anyway
                                    }
                                }
                            } // end of if pDest != NULL
                            else
                            {
                                //                                    This is not IRQ Resource
                            }  // end of else pDest != NULL

                            //  Check if it is PORT Resource
                            pDest = strstr(strSource,strPortPattern);

                            /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                            //                              PORTRESOURCE                                                               //
                            /////////////////////////////////////////////////////////////////////////////////////////////////////////////

                            if(pDest != NULL)
                            {
                                //  This is PORT Resource instance
                                //  Can get the PORT Resource Starting Address

                                //  Advance the pointer to the end of the pattern so the pointer is 
                                //  positioned at "Win32_PortResource...." Portion
                                pDest += lstrlen(strPortPattern2);

                                //  Formulate the Query String
                                bstrPortResourceQueryString =  bstrPortResourceQuery;
                                bstrPortResourceQueryString.Append(pDest);

                                // At this point the WQL Query can be used to get the win32_portResource Instance.
                                hRes = ExecWQLQuery(&pPortResourceEnumInst, bstrPortResourceQueryString);
                                if (FAILED(hRes))
                                {
                                    //  Query failed!! Cannot get the PORT Resources.
                                    //  Continue anyway!
                                }
                                else
                                {
                                    //  Query Succeeded. Get the Instance Object
                                    if(WBEM_S_NO_ERROR == pPortResourceEnumInst->Next(WBEM_INFINITE, 1, &pPortResourceObj, &ulPortResourceRetVal))
                                    {

                                        //  Get the Name 

                                        hRes = pPortResourceObj->Get(bstrPropertyName, 0, &varName, NULL, NULL);
                                        if (FAILED(hRes))
                                        {
                                            //  Could not get the Name
                                            ErrorTrace(TRACE_ID, "GetVariant on Win32_PortResource: Field failed.");
                                        } //end of if FAILED(pPortResourceObj->Get..Name
                                        else
                                        {
                                            //  Got the Name
                                            //  This is the PORT Address. Set the Value
                                            if (!pPCHNetworkAdapterInstance->SetVariant(pIOPort, varName))
                                            {
                                                ErrorTrace(TRACE_ID, "SetVariant on win32_AllocatedResource.PortAddress Failed!");
                                            }
                                            else
                                            {
                                                //  Port Address is set.
                                            }
                                        } // end of else FAILED(pPortResourceObj->Get..Name

                                        //  Got the Name. Nothing more to do.  
                                        
                                    } //end of if WBEM_S_NO_ERROR
                                    else
                                    {
                                        //  Cannot get the Instance Object
                                        //  Cannot get the PORT Adresses.
                                    } //end of else WBEM_S_NO_ERROR

                                    
                                } //end of else FAILED(hRes)

                            } //end of if pDest!= NULL
                            else
                            {
                                //  Not a PORT Resource Instance
                            } //end of else pDest!= NULL

                        } ////end of else FAILED(pAllocatedResourceObj->Get..antecedent 

                        
                    }// end of while pAllocatedResourceEnumInst....

                } // end of else FAILED(hRes) got the Antecedent Value

                
            } // end of else FAILED(hRes) , got the DeviceID Value

        } // end of else got the DeviceID

        //  Get the resources from Win32_AllocatedResource END 

        //  All the properties in pPCHNetworkAdapterInstance are set

        hRes = pPCHNetworkAdapterInstance->Commit();
        if (FAILED(hRes))
        {
            //  Cannot commit the Instance
            ErrorTrace(TRACE_ID, "Commit on Instance failed.");
        } // end of if FAILED(hRes)

    } //end of while pEnumInst....

END :
      TraceFunctLeave();
    return hRes ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprov\pch_fileupload.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_FileUpload.CPP

Abstract:
	WBEM provider class implementation for PCH_FileUpload class

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

********************************************************************/
#include "pchealth.h"
#include "PCH_FileUpload.h"
#include "mpc_utils.h"

// MAX_FILE_SIZE is the limit set on the maximum file size of text files that will be collected.
// If the Filesize is larger than 262144 then the data property is not populated. 
// This Number is arrived at by the PM.
#define     MAX_FILE_SIZE                   262144

#define     READONLY                        "READONLY  "  
#define     HIDDEN                          "HIDDEN  "
#define     SYSTEM                          "SYSTEM  "
#define     DIRECTORY                       "DIRECTORY  "
#define     ARCHIVE                         "ARCHIVE  "
#define     NORMAL                          "NORMAL  "
#define     TEMPORARY                       "TEMPORARY  "
#define     REPARSEPOINT                    "REPARSEPOINT  "
#define     SPARSEFILE                      "SPARSEFILE  "
#define     COMPRESSED                      "COMPRESSED  "
#define     OFFLINE                         "OFFLINE  "
#define     ENCRYPTED                       "ENCRYPTED  "

/////////////////////////////////////////////////////////////////////////////
//  tracing stuff

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile
#define TRACE_ID    DCID_FILEUPLOAD

CPCH_FileUpload MyPCH_FileUploadSet (PROVIDER_NAME_PCH_FILEUPLOAD, PCH_NAMESPACE) ;

// Property names
//===============
const static WCHAR* pTimeStamp = L"TimeStamp" ;
const static WCHAR* pChange = L"Change" ;
const static WCHAR* pData = L"Data" ;
const static WCHAR* pDateAccessed = L"DateAccessed" ;
const static WCHAR* pDateCreated = L"DateCreated" ;
const static WCHAR* pDateModified = L"DateModified" ;
const static WCHAR* pFileAttributes = L"FileAttributes" ;
const static WCHAR* pPath = L"Path" ;
const static WCHAR* pSize = L"Size" ;

/*****************************************************************************
*
*  FUNCTION    :    CPCH_FileUpload::ExecQuery
*
*  DESCRIPTION :    You are passed a method context to use in the creation of 
*                   instances that satisfy the query, and a CFrameworkQuery 
*                   which describes the query.  Create and populate all 
*                   instances which satisfy the query.  WinMgmt will post - 
*                   filter the query for you, so you may return more instances 
*                   or more properties than are requested and WinMgmt 
*                   will filter out any that do not apply.
*
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A query object describing the query to satisfy.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                       WBEM_FLAG_FORWARD_ONLY
*                       WBEM_FLAG_BIDIRECTIONAL
*                       WBEM_FLAG_ENSURE_LOCATABLE
*
*  RETURNS     :    WBEM_E_PROVIDER_NOT_CAPABLE if not supported for this class
*                   WBEM_E_FAILED if the query failed
*                   WBEM_S_NO_ERROR if query was successful 
*
*  COMMENTS    : TO DO: Most providers will not need to implement this method.  If you don't, WinMgmt 
*                       will call your enumerate function to get all the instances and perform the 
*                       filtering for you.  Unless you expect SIGNIFICANT savings from implementing 
*                       queries, you should remove this method.
*
*****************************************************************************/

HRESULT CPCH_FileUpload::ExecQuery (MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags)
{

    TraceFunctEnter("CPCH_FileUpLoad::ExecQuery");

    HRESULT                             hRes;
    HANDLE                              hFile;

    CHStringArray                       chstrFiles;

    TCHAR                               tchFileName[MAX_PATH];
    TCHAR                               tchRootDir[MAX_PATH];
    TCHAR                               tchWindowsDir[MAX_PATH];

    WIN32_FIND_DATA                     FindFileData;
    // CInstance                           *pPCHFileUploadInstance;
    SYSTEMTIME                          stUTCTime;

    BOOL                                fTimeStamp;
    BOOL                                fChange;
    BOOL                                fData;
    BOOL                                fDateAccessed;
    BOOL                                fDateCreated;
    BOOL                                fDateModified;
    BOOL                                fFileAttributes;
    BOOL                                fSize;
    BOOL                                fCommit;
    BOOL                                fFileRead           = FALSE;
    BOOL                                fFileFound          = FALSE;
    BOOL                                fNoData             = TRUE;

    CComVariant                         varAttributes;
    CComVariant                         varSize;
    CComVariant                         varRequestedFileName;
    CComVariant                         varSnapshot         = "SnapShot";
    CComVariant                         varData;

    ULARGE_INTEGER                      ulnFileSize;
    WBEMINT64                           wbemulnFileSize;

    char                                *pbBuffer;
    WCHAR                               *pwcBuffer;
    
    DWORD                               dwDesiredAccess     = GENERIC_READ;
    DWORD                               dwNumBytesRead;
    DWORD                               dwAttributes;

    BSTR                                bstrData;

    CComBSTR                            bstrFileName;
    CComBSTR                            bstrFileNameWithPath;
    CComBSTR                            bstrKey             = L"Path";

    int                                 nBufferSize;
    int                                 nFilesRequested             = 0;
    int                                 nIndex;
    int                                 nFileSize;
    int                                 nRetChars;

    TCHAR                               tchAttributes[MAX_PATH];

    //  
    std::tstring                        szEnv;

    //  End Declarations
    GetSystemTime(&stUTCTime);

    hRes = WBEM_S_NO_ERROR;
    hRes = Query.GetValuesForProp(bstrKey, chstrFiles);
    if(FAILED(hRes))
    {
        goto END;
    }
    else
    {
        fTimeStamp      = Query.IsPropertyRequired(pTimeStamp);
        fChange         = Query.IsPropertyRequired(pChange);
        fData           = Query.IsPropertyRequired(pData);
        fDateAccessed   = Query.IsPropertyRequired(pDateAccessed);
        fDateCreated    = Query.IsPropertyRequired(pDateCreated);
        fDateModified   = Query.IsPropertyRequired(pDateModified);
        fFileAttributes = Query.IsPropertyRequired(pFileAttributes);
        fSize           = Query.IsPropertyRequired(pSize);

        nFilesRequested = chstrFiles.GetSize();
        for (nIndex = 0; nIndex < nFilesRequested; nIndex++)
        {
            USES_CONVERSION;
            varRequestedFileName = chstrFiles[nIndex];
            bstrFileName = chstrFiles[nIndex];
            szEnv = W2T(chstrFiles[nIndex]);
            hRes = MPC::SubstituteEnvVariables(szEnv);
            if(SUCCEEDED(hRes))
            {
                //  Found the file
                _tcscpy(tchFileName, szEnv.c_str());
                hFile = FindFirstFile(tchFileName, &FindFileData); 
                if(hFile != INVALID_HANDLE_VALUE)
                {
                    //  Close the File Handle
                    FindClose(hFile);
                
                    //  Create the Fileupload Instance
                    //  Create an instance of PCH_Startup 
                    CInstancePtr pPCHFileUploadInstance(CreateNewInstance(pMethodContext), false);
                                        

                    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                    //                              PATH                                                                       //
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////////

                    hRes = pPCHFileUploadInstance->SetVariant(pPath, varRequestedFileName);
                    if(SUCCEEDED(hRes))
                    {
                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                        //                              SIZE                                                                       //
                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    
                        ulnFileSize.LowPart = FindFileData.nFileSizeLow;
                        ulnFileSize.HighPart = FindFileData.nFileSizeHigh;
                        if(ulnFileSize.HighPart > 0)
                        {
                            //  File Size too large don't populate the Data field.
                            fNoData = TRUE;
                        }
                        else if(ulnFileSize.LowPart > MAX_FILE_SIZE)
                        {
                            //   File Size Exceeds the set limit
                            fNoData = TRUE;
                        }
                        else
                        {
                            fNoData = FALSE;
                            nFileSize = ulnFileSize.LowPart;
                        }
                        if(fSize)
                        {
                            hRes = pPCHFileUploadInstance->SetWBEMINT64(pSize,ulnFileSize.QuadPart);
                            if (FAILED(hRes))
                            {
                                //  Could not Set the Time Stamp
                                //  Continue anyway
                                ErrorTrace(TRACE_ID, "SetVariant on Size Field failed.");
                            }
                        }

                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                        //                              DATA                                                                       //
                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                        if(fData)
                        {
                            if(!fNoData)
                            {
                                hFile = CreateFile(tchFileName, GENERIC_READ, 0, 0, OPEN_EXISTING,  0, NULL);
                                if(hFile != INVALID_HANDLE_VALUE)
                                {
                                    //  Allocate the memory for the buffer
                                    pbBuffer        = new char[nFileSize];
                                    if (pbBuffer != NULL)
                                    {
                                        try
                                        {
                                            fFileRead = ReadFile(hFile, pbBuffer, nFileSize,  &dwNumBytesRead, NULL);
                                            if(fFileRead)
                                            {
                                                pwcBuffer    = new WCHAR[nFileSize];
                                                if (pwcBuffer != NULL)
                                                {
                                                    try
                                                    {
                                                        nRetChars =  MultiByteToWideChar(CP_ACP, 0, (const char *)pbBuffer, nFileSize, pwcBuffer, nFileSize);
                                                        if(nRetChars != 0)
                                                        {
                                                            //  MultiByteToWideChar succeeds
                                                            //  Copy the byte buffer into BSTR
                                                            bstrData = SysAllocStringLen(pwcBuffer, nFileSize);  
                                                            varData = bstrData;
                                                            SysFreeString(bstrData);
                                                            hRes = pPCHFileUploadInstance->SetVariant(pData,varData);
                                                            if(FAILED(hRes))
                                                            {
                                                                //  Could not Set the Time Stamp
                                                                //  Continue anyway
                                                                ErrorTrace(TRACE_ID, "SetVariant on Data Field failed.");
                                                            }
                                                        }
                                                    }
                                                    catch(...)
                                                    {
                                                        delete [] pwcBuffer;
                                                        throw;
                                                    }
                                                    delete [] pwcBuffer;
                                                }
                                                else
                                                {
                                                    //  Cannot allocate pwcBuffer
                                                    throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
                                                }
                                            }
                                        }
                                        catch(...)
                                        {
                                            CloseHandle(hFile);
                                            delete [] pbBuffer;
                                            throw;
                                        }
                                    }
                                    else
                                    {
                                        //  Cannot allocate pwcBuffer
                                        throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
                                    }
                                    CloseHandle(hFile);
                                }
                            }
                        }


                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                        //                              TIMESTAMP                                                                  //
                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////

                        if(fTimeStamp)
                        {
                            hRes = pPCHFileUploadInstance->SetDateTime(pTimeStamp, WBEMTime(stUTCTime));
                            if (FAILED(hRes))
                            {
                                //  Could not Set the Time Stamp
                                //  Continue anyway
                                ErrorTrace(TRACE_ID, "SetDateTime on Timestamp Field failed.");
                            }
                        }

                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                        //                              CHANGE                                                                     //
                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////

                        if(fChange)
                        {
                            hRes = pPCHFileUploadInstance->SetVariant(pChange, varSnapshot);
                            if (FAILED(hRes))
                            {
                                //Could not Set the CHANGE property
                                //  Continue anyway
                                ErrorTrace(TRACE_ID, "Set Variant on SnapShot Field failed.");
                            }
                        }

                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                        //                              DATEACCESSED                                                               //
                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                        //   ftLastAccessTime gives the last access time for the file.
                        if(fDateAccessed)
                        {
                            hRes = pPCHFileUploadInstance->SetDateTime(pDateAccessed, WBEMTime(FindFileData.ftLastAccessTime));
                            if (FAILED(hRes))
                            {
                                //  Could not Set the Date Accessed
                                //  Continue anyway
                                ErrorTrace(TRACE_ID, "SetDateTime on DATEACCESSED Field failed.");
                            }
                        }

                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                        //                              DATECREATED                                                                //
                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////

                        if(fDateCreated)
                        {
                            hRes = pPCHFileUploadInstance->SetDateTime(pDateCreated, WBEMTime(FindFileData.ftCreationTime));
                            if (FAILED(hRes))
                            {
                                //  Could not Set the Date Created
                                //  Continue anyway
                                ErrorTrace(TRACE_ID, "SetDateTime on DATECREATED Field failed.");
                            }
                        }


                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                        //                              DATEMODIFIED                                                               //
                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                        
                        if(fDateModified)
                        {
                            hRes = pPCHFileUploadInstance->SetDateTime(pDateModified, WBEMTime(FindFileData.ftLastWriteTime));
                            if (FAILED(hRes))
                            {
                                //  Could not Set the Date Modified
                                //  Continue anyway
                                ErrorTrace(TRACE_ID, "SetDateTime on DateModified Field failed.");
                            }
                        }


                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                        //                              FILEATTRIBUTES                                                             //
                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////

                        if(fFileAttributes)
                        {
                            dwAttributes = FindFileData.dwFileAttributes;
                            tchAttributes[0] = 0;
                            //  Get the attributes as a string
                            if(dwAttributes & FILE_ATTRIBUTE_READONLY)
                            {
                                _tcscat(tchAttributes, READONLY);
                            }
                            if(dwAttributes & FILE_ATTRIBUTE_HIDDEN)
                            {
                                _tcscat(tchAttributes, HIDDEN);
                            }
                            if(dwAttributes & FILE_ATTRIBUTE_SYSTEM)
                            {
                                _tcscat(tchAttributes, SYSTEM);
                            }
                            if(dwAttributes & FILE_ATTRIBUTE_DIRECTORY)
                            {
                                _tcscat(tchAttributes, DIRECTORY);
                            }
                            if(dwAttributes & FILE_ATTRIBUTE_ARCHIVE)
                            {
                                _tcscat(tchAttributes, ARCHIVE);
                            }
                            if(dwAttributes & FILE_ATTRIBUTE_NORMAL)
                            {
                                _tcscat(tchAttributes, NORMAL);
                            }
                            if(dwAttributes & FILE_ATTRIBUTE_TEMPORARY)
                            {
                                _tcscat(tchAttributes, TEMPORARY);
                            }
                            if(dwAttributes & FILE_ATTRIBUTE_COMPRESSED)
                            {
                                _tcscat(tchAttributes, COMPRESSED);
                            }
                            if(dwAttributes & FILE_ATTRIBUTE_ENCRYPTED)
                            {
                                _tcscat(tchAttributes, ENCRYPTED);
                            }
                            if(dwAttributes & FILE_ATTRIBUTE_OFFLINE)
                            {
                                _tcscat(tchAttributes, OFFLINE);
                            }
                            if(dwAttributes & FILE_ATTRIBUTE_REPARSE_POINT)
                            {
                                _tcscat(tchAttributes, REPARSEPOINT);
                            }
                            if(dwAttributes & FILE_ATTRIBUTE_SPARSE_FILE)
                            {
                                _tcscat(tchAttributes, SPARSEFILE);
                            }
                            varAttributes = tchAttributes;

                            //  hRes = varAttributes.ChangeType(VT_BSTR, NULL);
                            //  if(SUCCEEDED(hRes))
                            //  {
                            hRes = pPCHFileUploadInstance->SetVariant(pFileAttributes, varAttributes);
                            if (FAILED(hRes))
                            {
                                //  Could not Set the File Attributes
                                //  Continue anyway
                                ErrorTrace(TRACE_ID, "SetVariant on FileAttributes Field failed.");
                            // }
                            }
                        }
                    
                        hRes = pPCHFileUploadInstance->Commit();
                        if(FAILED(hRes))
                        {
                            //  Could not Commit the instance
                            ErrorTrace(TRACE_ID, "Commit on PCHFileUploadInstance Failed");
                        }
                    }

                }
                            
            }
            
        }

    }
END:TraceFunctLeave();
    return (hRes);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprov\pch_module.h ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_Module.H

Abstract:
	WBEM provider class definition for PCH_Module class

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

********************************************************************/

// Property set identification
//============================

#ifndef _PCH_Module_H_
#define _PCH_Module_H_

#define PROVIDER_NAME_PCH_MODULE "PCH_Module"

// Property name externs -- defined in PCH_Module.cpp
//=================================================

extern const WCHAR* pAddress ;
extern const WCHAR* pTimeStamp ;
extern const WCHAR* pChange ;
extern const WCHAR* pDate ;
extern const WCHAR* pDescription ;
extern const WCHAR* pManufacturer ;
extern const WCHAR* pName ;
extern const WCHAR* pPartOf ;
extern const WCHAR* pPath ;
extern const WCHAR* pSize ;
extern const WCHAR* pType ;
extern const WCHAR* pVersion ;

class CPCH_Module : public Provider 
{
	public:
		// Constructor/destructor
		//=======================

		CPCH_Module(const CHString& chsClassName, LPCWSTR lpszNameSpace) : Provider(chsClassName, lpszNameSpace) {};
		virtual ~CPCH_Module() {};

	protected:
		// Reading Functions
		//============================
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Writing Functions
		//============================
		virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Other Functions
		virtual HRESULT ExecMethod( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags = 0L ) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprov\pch_module.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_Module.CPP

Abstract:
	WBEM provider class implementation for PCH_Module class

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

    Jim Martin          (a-jammar) 05/20/99
        - Populated data fields.

********************************************************************/

#include "pchealth.h"
#include "PCH_Module.h"
#include <tlhelp32.h>

/////////////////////////////////////////////////////////////////////////////
//  tracing stuff

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile
#define TRACE_ID    DCID_MODULE

CPCH_Module MyPCH_ModuleSet (PROVIDER_NAME_PCH_MODULE, PCH_NAMESPACE) ;

// Property names
//===============

const static WCHAR * pAddress = L"Address" ;
const static WCHAR * pTimeStamp = L"TimeStamp" ;
const static WCHAR * pChange = L"Change" ;
const static WCHAR * pDate = L"Date" ;
const static WCHAR * pDescription = L"Description" ;
const static WCHAR * pManufacturer = L"Manufacturer" ;
const static WCHAR * pName = L"Name" ;
const static WCHAR * pPartOf = L"PartOf" ;
const static WCHAR * pPath = L"Path" ;
const static WCHAR * pSize = L"Size" ;
const static WCHAR * pType = L"Type" ;
const static WCHAR * pVersion = L"Version" ;

//-----------------------------------------------------------------------------
// The CModuleCollection class is used to gather all of the running modules.
// They can be found from the CIM_ProcessExecutable class, as the Antecedent
// property, with the following caveat: this enumeration will include 
// duplicate entries of the same file (it will have a copy of a DLL for each
// time it's been loaded). This class will remove the duplicates, and save
// a list of filenames which can then be queried.
//-----------------------------------------------------------------------------

class CModuleCollection
{
public:
    CModuleCollection();
    ~CModuleCollection();

    HRESULT Create(IEnumWbemClassObject * pEnum);
    BOOL    GetInstance(DWORD dwIndex, LPWSTR * pszFile);

private:
    struct SModule
    {
        LPWSTR      m_szFilename;
        SModule *   m_pNext;

        SModule(LPWSTR szFilename, SModule * pNext) : m_pNext(pNext) { m_szFilename = szFilename; }
        ~SModule() { delete m_szFilename; }
    };

    SModule * m_pList;
    SModule * m_pLastQueriedItem;
    DWORD     m_dwLastQueriedIndex;
};

//-----------------------------------------------------------------------------
// The constructor and destructor are simple.
//-----------------------------------------------------------------------------

CModuleCollection::CModuleCollection() 
: m_pList(NULL), 
  m_pLastQueriedItem(NULL), 
  m_dwLastQueriedIndex(0)
{}

CModuleCollection::~CModuleCollection()
{
    TraceFunctEnter("CModuleCollection::~CModuleCollection");

    while (m_pList)
    {
        SModule * pNext = m_pList->m_pNext;
        delete m_pList;
        m_pList = pNext;
    }

    TraceFunctLeave();
}

//-----------------------------------------------------------------------------
// The Create method creates the list of module names based on the enumerator
// passed in (which is assumed to enumerate Antecedents in 
// CIM_ProcessExecutable).
//-----------------------------------------------------------------------------

HRESULT CModuleCollection::Create(IEnumWbemClassObject * pEnum)
{
    TraceFunctEnter("CModuleCollection::Create");
   
    HRESULT             hRes = S_OK;
    IWbemClassObjectPtr pObj;
    ULONG               ulRetVal;
    CComVariant         varValue;
    CComBSTR            bstrFile("Antecedent");

    while (WBEM_S_NO_ERROR == pEnum->Next(WBEM_INFINITE, 1, &pObj, &ulRetVal))
    {
        if (FAILED(pObj->Get(bstrFile, 0, &varValue, NULL, NULL)))
            ErrorTrace(TRACE_ID, "Get on Antecedent field failed.");
        else
        {
            // We need to convert the string from a BSTR to a LPCTSTR,
            // and to only include the file part (without the WMI part).
            // So we need to scan through the string until an '=' is
            // found, then use the rest (minus enclosing quote marks)
            // as the file path.

            CComBSTR ccombstrValue(V_BSTR(&varValue));
            UINT     i = 0, uLen = SysStringLen(ccombstrValue);

            // Scan to the '='.

            while (i < uLen && ccombstrValue[i] != L'=')
                i++;

            // Skip over the '=' and any quotes.

            while (i < uLen && (ccombstrValue[i] == L'=' || ccombstrValue[i] == L'"'))
                i++;

            // Allocate a character buffer and copy the string, converting it to
            // lower case (to make comparisons faster later on).

            LPWSTR szFilename = new WCHAR[uLen - i + 1];
            if (!szFilename)
            {
                ErrorTrace(TRACE_ID, "CModuleCollection::Create out of memory");
                throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
            }

            for (int j = 0; i < uLen; j++, i++)
                szFilename[j] = towlower(ccombstrValue[i]);

            // Terminate the string - if it ends with a quote, overwrite that with a 
            // null character.

            if (j && szFilename[j - 1] == L'"')
                j -= 1;
            szFilename[j] = L'\0';

            // Check to see if this module is already in the list of strings.

            SModule * pScan = m_pList;
            while (pScan)
            {
                if (wcscmp(szFilename, pScan->m_szFilename) == 0)
                    break;
                pScan = pScan->m_pNext;
            }

            if (pScan == NULL)
            {
                // We reached the end of the list without finding a duplicate.
                // Add the new string to the list of modules, which will be responsible for
                // deallocating the string.

                SModule * pNew = new SModule(szFilename, m_pList);
                if (!pNew)
                {
                    delete [] szFilename;
                    ErrorTrace(TRACE_ID, "CModuleCollection::Create out of memory");
                    throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
                }

                m_pList = pNew;
            }
            else
                delete [] szFilename;
        }
    }

    // Set the queried item pointer to the start of the list.

    m_pLastQueriedItem = m_pList;
    m_dwLastQueriedIndex = 0;
    
    TraceFunctLeave();
    return hRes;
}

//-----------------------------------------------------------------------------
// Get the instance of module string referenced by the index. This is stored
// internally as a linked list, but we'll cache a pointer for the last
// referenced dwIndex to improve performance if the dwIndex is iterated
// sequentially. Return TRUE and set pszFile to point to the string if
// it exists, otherwise return FALSE.
//-----------------------------------------------------------------------------

BOOL CModuleCollection::GetInstance(DWORD dwIndex, LPWSTR * pszFile)
{
    TraceFunctEnter("CModuleCollection::GetInstance");

    // If the call is for an index less than the last queried index (which
    // should be rare), we need to scan from the start of the list.

    if (dwIndex < m_dwLastQueriedIndex)
    {
        m_dwLastQueriedIndex = 0;
        m_pLastQueriedItem = m_pList;
    }

    // Scan through the list by (dwIndex - m_dwLastQueriedIndex) items.

    while (dwIndex > m_dwLastQueriedIndex && m_pLastQueriedItem)
    {
        m_pLastQueriedItem = m_pLastQueriedItem->m_pNext;
        m_dwLastQueriedIndex += 1;
    }

    BOOL fResult = FALSE;
    if (m_pLastQueriedItem)
    {
        *pszFile = m_pLastQueriedItem->m_szFilename;
        fResult = TRUE;
    }

    TraceFunctLeave();
    return fResult;
}

//-----------------------------------------------------------------------------
// This function is designed to find the process ID and base address for a
// given module. It will scan through the list of processes - if one of the
// names matches the module name, it will return that information. If it's
// not in the processes, then the modules for each process will be examined.
//-----------------------------------------------------------------------------

typedef HANDLE (*CTH32)(DWORD, DWORD);
typedef BOOL (*MODENUM)(HANDLE, LPMODULEENTRY32);
typedef BOOL (*PROCENUM)(HANDLE, LPPROCESSENTRY32);

HRESULT GetModuleProcIDAndAddr(HINSTANCE hKernel32, HANDLE hToolhelp, LPCSTR szFile, DWORD * pdwProcessID, LPVOID * ppAddr, DWORD * pdwSize)
{
    TraceFunctEnter("::GetModuleProcIDAndAddr");

    HRESULT         hRes = E_FAIL;
    PROCESSENTRY32  pe;
    MODULEENTRY32   me;
    PROCENUM        ProcFirst, ProcNext;
    MODENUM         ModFirst, ModNext;
    HANDLE          hModuleTH;
    CTH32           CrtToolhelp32;

    ProcFirst = (PROCENUM) ::GetProcAddress(hKernel32, "Process32First");
    ProcNext = (PROCENUM) ::GetProcAddress(hKernel32, "Process32Next");
    ModFirst = (MODENUM) ::GetProcAddress(hKernel32, "Module32First");
    ModNext = (MODENUM) ::GetProcAddress(hKernel32, "Module32Next");
    CrtToolhelp32 = (CTH32) ::GetProcAddress(hKernel32, "CreateToolhelp32Snapshot"); 

    pe.dwSize = sizeof(PROCESSENTRY32);
    if (CrtToolhelp32 && ProcFirst && ProcNext && ModFirst && ModNext && (ProcFirst)(hToolhelp, &pe))
        do
        {
            if (0 == _stricmp(szFile, pe.szExeFile))
            {
                hRes = S_OK;
                *pdwProcessID = pe.th32ProcessID;
                *ppAddr = (LPVOID) NULL;
                *pdwSize = 0;
            }

            // Scan through the modules - either for the process's module if the name
            // matched for the process, or for a module with a matching name.

            hModuleTH = (CrtToolhelp32)(TH32CS_SNAPMODULE, pe.th32ProcessID);
            if (hModuleTH != (HANDLE) -1)
            {
                me.dwSize = sizeof(MODULEENTRY32);
                if ((ModFirst)(hModuleTH, &me))
                {
                    do
                    {
                        if (hRes == S_OK)
                        {
                            // The file matched a process. We should look for the module
                            // which matches the process's module ID.

                            if (me.th32ModuleID == pe.th32ModuleID)
                            {
                                *ppAddr = (LPVOID) me.modBaseAddr;
                                *pdwSize = me.modBaseSize;
                                break;
                            }
                        }
                        else
                        {
                            // The file didn't match the process. We should look for a
                            // module which matches the name.

                            if (0 == _stricmp(szFile, me.szExePath))
                            {
                                *ppAddr = (LPVOID) me.modBaseAddr;
                                *pdwSize = me.modBaseSize;
                                *pdwProcessID = me.th32ProcessID;
                                hRes = S_OK;
                                break;
                            }
                        }
                    } while ((ModNext)(hModuleTH, &me));
                }

                CloseHandle(hModuleTH);
            }
        } while ((ProcNext)(hToolhelp, &pe) && FAILED(hRes));

    TraceFunctLeave();
    return hRes;
}

/*****************************************************************************
*
*  FUNCTION    :    CPCH_Module::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                       WBEM_FLAG_DEEP
*                       WBEM_FLAG_SHALLOW
*                       WBEM_FLAG_RETURN_IMMEDIATELY
*                       WBEM_FLAG_FORWARD_ONLY
*                       WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    : TO DO: All instances on the machine should be returned here.
*                       If there are no instances, return WBEM_S_NO_ERROR.
*                       It is not an error to have no instances.
*
*****************************************************************************/

typedef HANDLE (*CTH32)(DWORD, DWORD);

HRESULT CPCH_Module::EnumerateInstances(MethodContext * pMethodContext, long lFlags)
{
    TraceFunctEnter("CPCH_Module::EnumerateInstances");
    HRESULT hRes = WBEM_S_NO_ERROR;

    // Get the date and time

    SYSTEMTIME stUTCTime;
    GetSystemTime(&stUTCTime);

    // Create a toolhelp snapshot to get process information. We need to dynamically
    // link to the function, because it might not be present on all platforms.

    HANDLE hToolhelp = (HANDLE) -1;
    HINSTANCE hKernel32 = ::LoadLibrary("kernel32");
    if (hKernel32)
    {
        CTH32 CrtToolhelp32 = (CTH32) ::GetProcAddress(hKernel32, "CreateToolhelp32Snapshot"); 
        if (CrtToolhelp32)
            hToolhelp = (*CrtToolhelp32)(TH32CS_SNAPPROCESS, 0);
    }

	try
	{				
        // The CModuleCollection class gathers a list of module names (which can then
        // be used to retrieve information about each file). 

        CFileVersionInfo  fileversioninfo;
        CModuleCollection moduleinfo;
        LPWSTR            szFile;
        DWORD             dwIndex;

        CComPtr<IEnumWbemClassObject> pEnum;
        hRes = ExecWQLQuery(&pEnum, CComBSTR("SELECT Antecedent FROM CIM_ProcessExecutable"));
        if (FAILED(hRes))
            goto END;

        hRes = moduleinfo.Create(pEnum);
        if (FAILED(hRes))
            goto END;

        // Iterate through all of the module instances.

        for (dwIndex = 0; moduleinfo.GetInstance(dwIndex, &szFile); dwIndex++)
        {
            if (!szFile)
                continue;

            CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);

            // Set the change and timestamp fields to "Snapshot" and the current time.

            if (!pInstance->SetDateTime(pTimeStamp, WBEMTime(stUTCTime)))
                ErrorTrace(TRACE_ID, "SetDateTime on Timestamp field failed.");

            if (!pInstance->SetCHString(pChange, L"Snapshot"))
                ErrorTrace(TRACE_ID, "SetCHString on Change field failed.");

            // Using the filename, get the CIM_DataFile object.

            CComPtr<IWbemClassObject>   pFileObj;
            CComBSTR                    ccombstrValue(szFile);
            if (SUCCEEDED(GetCIMDataFile(ccombstrValue, &pFileObj, TRUE)))
            {
                // Using the CIM_DataFile object, copy over the appropriate properties.

                CopyProperty(pFileObj, L"Version", pInstance, pVersion);
                CopyProperty(pFileObj, L"FileSize", pInstance, pSize);
                CopyProperty(pFileObj, L"CreationDate", pInstance, pDate);
                CopyProperty(pFileObj, L"Name", pInstance, pPath);
                CopyProperty(pFileObj, L"EightDotThreeFileName", pInstance, pName);
                CopyProperty(pFileObj, L"Manufacturer", pInstance, pManufacturer);
            }

            if (SUCCEEDED(fileversioninfo.QueryFile(szFile, TRUE)))
            {
                if (!pInstance->SetCHString(pDescription, fileversioninfo.GetDescription()))
                    ErrorTrace(TRACE_ID, "SetCHString on description field failed.");

                if (!pInstance->SetCHString(pPartOf, fileversioninfo.GetProduct()))
                    ErrorTrace(TRACE_ID, "SetCHString on partof field failed.");
            }

            if (hToolhelp != (HANDLE) -1)
            {
                DWORD   dwProcessID;
                LPVOID  lpAddr;
                DWORD   dwSize;
                char    szWorking[MAX_PATH];
                int     i = 0, j = 0;

                // We need to get the file into an Ansi string, with the double backslashes removed.
                // Scan through the string, converting double backslashes to single backslashes.

                while (szFile[i])
                {
                    if (szFile[i] == L'\\' && szFile[i + 1] == L'\\')
                        i += 1;
                    szWorking[j++] = (char) szFile[i++];
                }
                szWorking[j] = '\0';

                if (SUCCEEDED(GetModuleProcIDAndAddr(hKernel32, hToolhelp, szWorking, &dwProcessID, &lpAddr, &dwSize)))
                {
                    TCHAR   szBuffer[30];
                    DWORD   dwVersion;

                    dwVersion = GetProcessVersion(dwProcessID);
                    wsprintf(szBuffer, _T("%d.%d"), HIWORD(dwVersion), LOWORD(dwVersion));
                    if (!pInstance->SetCHString(pType, szBuffer))
                        ErrorTrace(TRACE_ID, "SetCHString on type field failed.");

                    wsprintf(szBuffer, _T("%08X-%08X"), lpAddr, (DWORD)lpAddr + dwSize);
                    if (!pInstance->SetCHString(pAddress, szBuffer))
                        ErrorTrace(TRACE_ID, "SetCHString on address field failed.");
                }
            }

    	    hRes = pInstance->Commit();
            if (FAILED(hRes))
                ErrorTrace(TRACE_ID, "Commit on Instance failed.");
        }
    }
	catch (...)
	{
        if ((HANDLE)-1 != hToolhelp)
            CloseHandle(hToolhelp);

        if (hKernel32)
            FreeLibrary(hKernel32);

        throw;
	}

END:
    if ((HANDLE)-1 != hToolhelp)
        CloseHandle(hToolhelp);

    if (hKernel32)
        FreeLibrary(hKernel32);

    TraceFunctLeave();
    return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprov\pch_networkadapter.h ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_NetworkAdapter.H

Abstract:
	WBEM provider class definition for PCH_NetworkAdapter class

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

********************************************************************/

// Property set identification
//============================

#ifndef _PCH_NetworkAdapter_H_
#define _PCH_NetworkAdapter_H_

#define PROVIDER_NAME_PCH_NETWORKADAPTER "PCH_NetworkAdapter"

// Property name externs -- defined in PCH_NetworkAdapter.cpp
//=================================================

extern const WCHAR* pAdapterType ;
extern const WCHAR* pTimeStamp ;
extern const WCHAR* pChange ;
// extern const WCHAR* pDefaultIPGateway ;
extern const WCHAR* pDeviceID ;
extern const WCHAR* pDHCPEnabled ;
extern const WCHAR* pIOPort ;
// extern const WCHAR* pIPAddress ;
// extern const WCHAR* pIPSubnet ;
extern const WCHAR* pIRQNumber ;
// extern const WCHAR* pMACAddress ;
extern const WCHAR* pProductName ;
// extern const WCHAR* pServiceName ;

class CPCH_NetworkAdapter : public Provider 
{
	public:
		// Constructor/destructor
		//=======================

		CPCH_NetworkAdapter(const CHString& chsClassName, LPCWSTR lpszNameSpace) : Provider(chsClassName, lpszNameSpace) {};
		virtual ~CPCH_NetworkAdapter() {};

	protected:
		// Reading Functions
		//============================
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Writing Functions
		//============================
		virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Other Functions
		virtual HRESULT ExecMethod( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags = 0L ) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprov\pch_networkconnection.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    PCH_NetworkConnection.CPP

Abstract:
    WBEM provider class implementation for PCH_NetworkConnection class

Revision History:

    Ghim-Sim Chua       (gschua)   04/27/99
        - Created

    Ghim-Sim Chua       (gschua)   05/02/99
        - Modified code to use CopyProperty function
        - Use CComBSTR instead of USES_CONVERSION

********************************************************************/

#include "pchealth.h"
#include "PCH_NetworkConnection.h"

/////////////////////////////////////////////////////////////////////////////
//  tracing stuff

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile
#define TRACE_ID    DCID_NETWORKCONNECTION

CPCH_NetworkConnection MyPCH_NetworkConnectionSet (PROVIDER_NAME_PCH_NETWORKCONNECTION, PCH_NAMESPACE) ;

// Property names
//===============
const static WCHAR* pTimeStamp = L"TimeStamp" ;
const static WCHAR* pChange = L"Change" ;
const static WCHAR* pLocalName = L"LocalName" ;
const static WCHAR* pName = L"Name" ;
const static WCHAR* pRemoteName = L"RemoteName" ;
const static WCHAR* pStatus = L"Status" ;
const static WCHAR* pType = L"Type" ;

/*****************************************************************************
*
*  FUNCTION    :    CPCH_NetworkConnection::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                       WBEM_FLAG_DEEP
*                       WBEM_FLAG_SHALLOW
*                       WBEM_FLAG_RETURN_IMMEDIATELY
*                       WBEM_FLAG_FORWARD_ONLY
*                       WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    : TO DO: All instances on the machine should be returned here.
*                       If there are no instances, return WBEM_S_NO_ERROR.
*                       It is not an error to have no instances.
*
*****************************************************************************/
HRESULT CPCH_NetworkConnection::EnumerateInstances(
    MethodContext* pMethodContext,
    long lFlags
    )
{
    TraceFunctEnter("CPCH_NetworkConnection::EnumerateInstances");

    HRESULT                             hRes = WBEM_S_NO_ERROR;
    REFPTRCOLLECTION_POSITION           posList;
    CComPtr<IEnumWbemClassObject>       pEnumInst;
    IWbemClassObjectPtr                 pObj;      // BUGBUG : WMI asserts if we use CComPtr
    ULONG                               ulRetVal;

    // Get the date and time
    //
    SYSTEMTIME stUTCTime;
    GetSystemTime(&stUTCTime);

    //
    // Execute the query
    //
    hRes = ExecWQLQuery(&pEnumInst, CComBSTR("select Name, LocalName, RemoteName, ResourceType, Status from Win32_NetworkConnection"));
    if (FAILED(hRes))
        goto END;

    //
    // enumerate the instances from win32_CodecFile
    //
    while(WBEM_S_NO_ERROR == pEnumInst->Next(WBEM_INFINITE, 1, &pObj, &ulRetVal))
    {

        // Create a new instance based on the passed-in MethodContext
        CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);

        if (!pInstance->SetDateTime(pTimeStamp, WBEMTime(stUTCTime)))
            ErrorTrace(TRACE_ID, "SetDateTime on Timestamp Field failed.");

        if (!pInstance->SetCHString(pChange, L"Snapshot"))
            ErrorTrace(TRACE_ID, "SetCHString on Change Field failed.");

        (void)CopyProperty(pObj, L"LocalName", pInstance, pLocalName);
        (void)CopyProperty(pObj, L"Name", pInstance, pName);
        (void)CopyProperty(pObj, L"RemoteName", pInstance, pRemoteName);
        (void)CopyProperty(pObj, L"Status", pInstance, pStatus);
        (void)CopyProperty(pObj, L"ResourceType", pInstance, pType);

        hRes = pInstance->Commit();
        if (FAILED(hRes))
        {
            //  Could not Set the Change Property
            //  Continue anyway
            ErrorTrace(TRACE_ID, "Set Variant on Name Field failed.");
        }
            
    }

END :
    TraceFunctLeave();
    return hRes ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprov\pch_networkconnection.h ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_NetworkConnection.H

Abstract:
	WBEM provider class definition for PCH_NetworkConnection class

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

********************************************************************/

// Property set identification
//============================

#ifndef _PCH_NetworkConnection_H_
#define _PCH_NetworkConnection_H_

#define PROVIDER_NAME_PCH_NETWORKCONNECTION "PCH_NetworkConnection"

// Property name externs -- defined in PCH_NetworkConnection.cpp
//=================================================

extern const WCHAR* pTimeStamp ;
extern const WCHAR* pChange ;
extern const WCHAR* pLocalName ;
extern const WCHAR* pName ;
extern const WCHAR* pRemoteName ;
extern const WCHAR* pStatus ;
extern const WCHAR* pType ;

class CPCH_NetworkConnection : public Provider 
{
	public:
		// Constructor/destructor
		//=======================

		CPCH_NetworkConnection(const CHString& chsClassName, LPCWSTR lpszNameSpace) : Provider(chsClassName, lpszNameSpace) {};
		virtual ~CPCH_NetworkConnection() {};

	protected:
		// Reading Functions
		//============================
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Writing Functions
		//============================
		virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Other Functions
		virtual HRESULT ExecMethod( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags = 0L ) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprov\pch_networkprotocol.h ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_NetworkProtocol.H

Abstract:
	WBEM provider class definition for PCH_NetworkProtocol class

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

********************************************************************/

// Property set identification
//============================

#ifndef _PCH_NetworkProtocol_H_
#define _PCH_NetworkProtocol_H_

#define PROVIDER_NAME_PCH_NETWORKPROTOCOL "PCH_NetworkProtocol"

// Property name externs -- defined in PCH_NetworkProtocol.cpp
//=================================================

extern const WCHAR* pTimeStamp ;
extern const WCHAR* pChange ;
extern const WCHAR* pConnectionlessService ;
extern const WCHAR* pGuaranteesDelivery ;
extern const WCHAR* pGuaranteesSequencing ;
extern const WCHAR* pName ;

class CPCH_NetworkProtocol : public Provider 
{
	public:
		// Constructor/destructor
		//=======================

		CPCH_NetworkProtocol(const CHString& chsClassName, LPCWSTR lpszNameSpace) : Provider(chsClassName, lpszNameSpace) {};
		virtual ~CPCH_NetworkProtocol() {};

	protected:
		// Reading Functions
		//============================
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Writing Functions
		//============================
		virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Other Functions
		virtual HRESULT ExecMethod( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags = 0L ) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprov\pch_networkprotocol.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    PCH_NetworkProtocol.CPP

Abstract:
    WBEM provider class implementation for PCH_NetworkProtocol class

Revision History:

    Ghim-Sim Chua       (gschua)   04/27/99
        - Created

    Ghim-Sim Chua       (gschua)   05/02/99
        - Modified code to use CopyProperty function
        - Use CComBSTR instead of USES_CONVERSION

********************************************************************/

#include "pchealth.h"
#include "PCH_NetworkProtocol.h"

/////////////////////////////////////////////////////////////////////////////
//  tracing stuff

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile
#define TRACE_ID    DCID_NETWORKPROTOCOL

CPCH_NetworkProtocol MyPCH_NetworkProtocolSet (PROVIDER_NAME_PCH_NETWORKPROTOCOL, PCH_NAMESPACE) ;

// Property names
//===============
const static WCHAR* pTimeStamp = L"TimeStamp" ;
const static WCHAR* pChange = L"Change" ;
const static WCHAR* pConnectionlessService = L"ConnectionlessService" ;
const static WCHAR* pGuaranteesDelivery = L"GuaranteesDelivery" ;
const static WCHAR* pGuaranteesSequencing = L"GuaranteesSequencing" ;
const static WCHAR* pName = L"Name" ;

/*****************************************************************************
*
*  FUNCTION    :    CPCH_NetworkProtocol::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                       WBEM_FLAG_DEEP
*                       WBEM_FLAG_SHALLOW
*                       WBEM_FLAG_RETURN_IMMEDIATELY
*                       WBEM_FLAG_FORWARD_ONLY
*                       WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    : TO DO: All instances on the machine should be returned here.
*                       If there are no instances, return WBEM_S_NO_ERROR.
*                       It is not an error to have no instances.
*
*****************************************************************************/
HRESULT CPCH_NetworkProtocol::EnumerateInstances(
    MethodContext* pMethodContext,
    long lFlags
    )
{
    TraceFunctEnter("CPCH_NetworkProtocol::EnumerateInstances");

    HRESULT                             hRes = WBEM_S_NO_ERROR;
    REFPTRCOLLECTION_POSITION           posList;
    CComPtr<IEnumWbemClassObject>       pEnumInst;
    IWbemClassObjectPtr                 pObj;       // BUGBUG : WMI asserts if we use CComPtr
    ULONG                               ulRetVal;

    //
    // Get the date and time
    //
    SYSTEMTIME stUTCTime;
    GetSystemTime(&stUTCTime);

    //
    // Execute the query
    //
    hRes = ExecWQLQuery(&pEnumInst, CComBSTR("select Name, ConnectionlessService, GuaranteesDelivery, GuaranteesSequencing from Win32_NetworkProtocol"));
    if (FAILED(hRes))
        goto END;

    //
    // enumerate the instances from win32_CodecFile
    //
    while(WBEM_S_NO_ERROR == pEnumInst->Next(WBEM_INFINITE, 1, &pObj, &ulRetVal))
    {

        // Create a new instance based on the passed-in MethodContext
        CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);
        
        if (!pInstance->SetDateTime(pTimeStamp, WBEMTime(stUTCTime)))
            ErrorTrace(TRACE_ID, "SetDateTime on Timestamp Field failed.");
        if (!pInstance->SetCHString(pChange, L"Snapshot"))
            ErrorTrace(TRACE_ID, "SetCHString on Change Field failed.");

        (void)CopyProperty(pObj, L"ConnectionlessService", pInstance, pConnectionlessService);
        (void)CopyProperty(pObj, L"GuaranteesDelivery", pInstance, pGuaranteesDelivery);
        (void)CopyProperty(pObj, L"GuaranteesSequencing", pInstance, pGuaranteesSequencing);
        (void)CopyProperty(pObj, L"Name", pInstance, pName);

        hRes = pInstance->Commit();
        if (FAILED(hRes))
        {
            //  Could not Commit
            //  Continue anyway
            ErrorTrace(TRACE_ID, "Commit failed.");
        }
    }

END :
    TraceFunctLeave();
    return hRes ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprov\pch_oleregistration.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    PCH_OLERegistration.CPP

Abstract:
    WBEM provider class implementation for PCH_OLERegistration class

Revision History:

    Ghim-Sim Chua       (gschua)   04/27/99
        - Created

    Jim Martin          (a-jammar) 05/14/99
        - Gathering data.

********************************************************************/

#include "pchealth.h"
#include "PCH_OLERegistration.h"

/////////////////////////////////////////////////////////////////////////////
//  tracing stuff

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile
#define TRACE_ID    DCID_OLEREGISTRATION

CPCH_OLERegistration MyPCH_OLERegistrationSet (PROVIDER_NAME_PCH_OLEREGISTRATION, PCH_NAMESPACE) ;

// Property names
//===============
const static WCHAR * pCategory = L"Category" ;
const static WCHAR * pTimeStamp = L"TimeStamp" ;
const static WCHAR * pChange = L"Change" ;
const static WCHAR * pDate = L"Date" ;
const static WCHAR * pDescription = L"Description" ;
const static WCHAR * pObject = L"Object" ;
const static WCHAR * pProgramFile = L"ProgramFile" ;
const static WCHAR * pSize = L"Size" ;
const static WCHAR * pVersion = L"Version" ;

//-----------------------------------------------------------------------------
// The COLERegItem class encapsulates a single OLE Registration item, and is
// used to build a linked list of items. Note that the constructor is private,
// since the only way one of these is created is by the friend class
// COLEItemCollection.
//-----------------------------------------------------------------------------

#define CATEGORY_LEN        9
#define DESCRIPTION_LEN     128
#define OBJECT_LEN          128
#define PROGRAM_LEN         MAX_PATH

class COLEItemCollection;
class COLERegItem
{
    friend class COLEItemCollection;
private:
    TCHAR   m_szCategory[CATEGORY_LEN];
    TCHAR   m_szDescription[DESCRIPTION_LEN];
    TCHAR   m_szObject[OBJECT_LEN];
    TCHAR   m_szProgramFile[PROGRAM_LEN];

public:
    LPCTSTR GetCategory()       { return m_szCategory; };
    LPCTSTR GetDescription()    { return m_szDescription; };
    LPCTSTR GetObject()         { return m_szObject; };
    LPCTSTR GetProgramFile()    { return m_szProgramFile; };

private:
    COLERegItem();

    COLERegItem * m_pNext;
};

COLERegItem::COLERegItem()
{
    m_szCategory[0]     = _T('\0');
    m_szDescription[0]  = _T('\0');
    m_szObject[0]       = _T('\0');
    m_szProgramFile[0]  = _T('\0');
    m_pNext             = NULL;
}

//-----------------------------------------------------------------------------
// The COLEItemCollection class is used to gather all of the OLE Registration
// items (from the registry and INI file) when the object is constructed. The
// object is then used to iterate all of the items, returning COLERegItem
// pointers for each item found.
//-----------------------------------------------------------------------------

class COLEItemCollection
{
public:
    COLEItemCollection();
    ~COLEItemCollection();

    BOOL GetInstance(DWORD dwIndex, COLERegItem ** ppoleitem);

private:
    BOOL UpdateFromRegistry();
    BOOL UpdateFromINIFile();
    BOOL AddOLERegItem(LPCSTR szCategory, LPCSTR szDescription, LPCSTR szObject, LPCSTR szProgramFile);

    COLERegItem * m_pItemList;
    COLERegItem * m_pLastQueriedItem;
    DWORD         m_dwLastQueriedIndex;
};

//-----------------------------------------------------------------------------
// Build the internal list of OLE registration items. This is done by looking
// in the registry and in the INI file. Also set the m_pLastQueriedItem pointer
// to the first item in the list (this cached pointer is used to improve
// indexed lookup speed for iterated indices).
//
// The destructor just deletes the list.
//-----------------------------------------------------------------------------

COLEItemCollection::COLEItemCollection() : m_pItemList(NULL), m_dwLastQueriedIndex(0)
{
    TraceFunctEnter("COLEItemCollection::COLEItemCollection");

    // If UpdateFromRegistry fails, it would be because there isn't enough memory
    // to create more list items, so don't bother calling UpdateFromINIFile.

    if (UpdateFromRegistry())
        UpdateFromINIFile();

    m_pLastQueriedItem = m_pItemList;

    TraceFunctLeave();
}

COLEItemCollection::~COLEItemCollection()
{
    TraceFunctEnter("COLEItemCollection::~COLEItemCollection");

    while (m_pItemList)
    {
        COLERegItem * pNext = m_pItemList->m_pNext;
        delete m_pItemList;
        m_pItemList = pNext;
    }
    
    TraceFunctLeave();
}

//-----------------------------------------------------------------------------
// Get the instance of COLERegItem referenced by the index. This is stored
// internally as a linked list, but we'll cache a pointer for the last
// referenced dwIndex to improve performance if the dwIndex is iterated
// sequentially. Return TRUE and set ppoleitem to point to the instance if
// it exists, otherwise return FALSE.
//-----------------------------------------------------------------------------

BOOL COLEItemCollection::GetInstance(DWORD dwIndex, COLERegItem ** ppoleitem)
{
    TraceFunctEnter("COLEItemCollection::GetInstance");

    // If the call is for an index less than the last queried index (which
    // should be rare), we need to scan from the start of the list.

    if (dwIndex < m_dwLastQueriedIndex)
    {
        m_dwLastQueriedIndex = 0;
        m_pLastQueriedItem = m_pItemList;
    }

    // Scan through the list by (dwIndex - m_dwLastQueriedIndex) items.

    while (dwIndex > m_dwLastQueriedIndex && m_pLastQueriedItem)
    {
        m_pLastQueriedItem = m_pLastQueriedItem->m_pNext;
        m_dwLastQueriedIndex += 1;
    }

    BOOL fResult = FALSE;
    if (m_pLastQueriedItem)
    {
        *ppoleitem = m_pLastQueriedItem;
        fResult = TRUE;
    }

    TraceFunctLeave();
    return fResult;
}

//-----------------------------------------------------------------------------
// Insert a new item in the COLERegItem linked list.
//-----------------------------------------------------------------------------

BOOL COLEItemCollection::AddOLERegItem(LPCSTR szCategory, LPCSTR szDescription, LPCSTR szObject, LPCSTR szProgramFile)
{
    TraceFunctEnter("COLEItemCollection::AddOLERegItem");

    BOOL            fReturn = FALSE;
    COLERegItem *   pNewNode = new COLERegItem;

    if (pNewNode)
    {
        _tcsncpy(pNewNode->m_szCategory, szCategory, CATEGORY_LEN);
        _tcsncpy(pNewNode->m_szDescription, szDescription, DESCRIPTION_LEN);
        _tcsncpy(pNewNode->m_szObject, szObject, OBJECT_LEN);
        _tcsncpy(pNewNode->m_szProgramFile, szProgramFile, PROGRAM_LEN);

        pNewNode->m_pNext = m_pItemList;
        m_pItemList = pNewNode;
        fReturn = TRUE;
    }
    else
    {
        ErrorTrace(TRACE_ID, "COLEItemCollection::AddOLERegItem out of memory.");
        throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
    }

    TraceFunctLeave();
    return fReturn;
}

//-----------------------------------------------------------------------------
// This method retrieves OLE object information from the registry and adds
// it to the list of objects. Note - this code is essentially lifted from the
// source code for the OLE Registration OCX in MSInfo 4.10.
//
// Changes were made to remove MFC dependencies.
//-----------------------------------------------------------------------------

BOOL COLEItemCollection::UpdateFromRegistry()
{
    TraceFunctEnter("COLEItemCollection::UpdateFromRegistry");
    BOOL fReturn = TRUE;

    // Fill in the information for the array of items. We do this by
    // looking in the registry under the HKEY_CLASSES_ROOT key and
    // enumerating all of the subkeys there.

    TCHAR     szCLSID[MAX_PATH];
    TCHAR     szObjectKey[OBJECT_LEN];
    TCHAR     szServer[PROGRAM_LEN];
    TCHAR     szTemp[MAX_PATH];
    TCHAR     szDescription[DESCRIPTION_LEN];
    DWORD     dwSize, dwType;
    FILETIME  filetime;
    HKEY      hkeyObject, hkeyServer, hkeyTest, hkeyCLSID, hkeySearch;
    BOOL      bInsertInList;

    for (DWORD dwIndex = 0; TRUE; dwIndex++)
    {
        dwSize = OBJECT_LEN;
        if (RegEnumKeyEx(HKEY_CLASSES_ROOT, dwIndex, szObjectKey, &dwSize, NULL, NULL, NULL, &filetime) != ERROR_SUCCESS)
            break;

        // Open the key for this object (we'll be using it a lot).

        if (ERROR_SUCCESS != RegOpenKeyEx(HKEY_CLASSES_ROOT, szObjectKey, 0, KEY_READ, &hkeyObject))
            continue;

        // Now we need to figure out if this subkey refers to an OLE object which
        // we want to put into the list. Our first test is to see if there is
        // a "NotInsertable" key under it. If there is, we skip this object.

        if (ERROR_SUCCESS == RegOpenKeyEx(hkeyObject, _T("NotInsertable"), 0, KEY_READ, &hkeyTest))
        {
            RegCloseKey(hkeyTest);
            continue;
        }

        // The next test is to look for a CLSID. If there isn't one, then we
        // will skip this object.

        if (ERROR_SUCCESS != RegOpenKeyEx(hkeyObject, _T("CLSID"), 0, KEY_READ, &hkeyCLSID))
        {
            RegCloseKey(hkeyObject);
            continue;
        }

        dwSize = MAX_PATH * sizeof(TCHAR);
        if (ERROR_SUCCESS != RegQueryValueEx(hkeyCLSID, _T(""), NULL, &dwType, (LPBYTE) szCLSID, &dwSize))
        {
            RegCloseKey(hkeyObject);
            RegCloseKey(hkeyCLSID);
            continue;
        }
        RegCloseKey(hkeyCLSID);

        // The next check is for a subkey called "protocol\StdFileEditing\server".
        // If it is present, then this object should be inserted into the list.

        bInsertInList = FALSE;
        strcpy(szTemp, szObjectKey);
        strcat(szTemp, "\\protocol\\StdFileEditing\\server");
        if (RegOpenKeyEx(HKEY_CLASSES_ROOT, szTemp, 0, KEY_READ, &hkeyServer) == ERROR_SUCCESS)
        {
            // Get the name of the server.

            dwSize = MAX_PATH * sizeof(TCHAR);
            if (RegQueryValueEx(hkeyServer, "", NULL, &dwType, (LPBYTE) szServer, &dwSize) != ERROR_SUCCESS || szServer[0] == '\0')
            {
                RegCloseKey(hkeyObject);
                RegCloseKey(hkeyServer);
                continue;
            }

            bInsertInList = TRUE;
            RegCloseKey(hkeyServer);
        }

        // There's still another chance for this little fella to make it into the
        // list. If the object is insertable (i.e. it has an "Insertable" key) and
        // it a server can be found under HKEY_CLASSES_ROOT\CLSID\<clsid> key, then
        // it makes it into the list.

        if (!bInsertInList)
        {
            // First, make sure the object is insertable.

            if (RegOpenKeyEx(hkeyObject, "Insertable", 0, KEY_READ, &hkeyTest) == ERROR_SUCCESS)
            {
                // There are four places to look for a server. We'll check for 32-bit
                // servers first. When we've found one, use that server name and
                // stop the search.

                TCHAR * aszServerKeys[] = { _T("LocalServer32"), _T("InProcServer32"), _T("LocalServer"), _T("InProcServer"), _T("")};
                for (int iServer = 0; *aszServerKeys[iServer] && !bInsertInList; iServer++)
                {
                    _tcscpy(szTemp, _T("CLSID\\"));
                    _tcscat(szTemp, szCLSID);
                    _tcscat(szTemp, _T("\\"));
                    _tcscat(szTemp, aszServerKeys[iServer]);

                    if (RegOpenKeyEx(HKEY_CLASSES_ROOT, szTemp, 0, KEY_READ, &hkeySearch) == ERROR_SUCCESS)
                    {
                        dwSize = PROGRAM_LEN * sizeof(TCHAR);
                        if (RegQueryValueEx(hkeySearch, _T(""), NULL, &dwType, (LPBYTE) szServer, &dwSize) == ERROR_SUCCESS && szServer[0] != '\0')
                            bInsertInList = TRUE;
                        RegCloseKey(hkeySearch);
                    }
                }
            }
            RegCloseKey(hkeyTest);
        }

        if (bInsertInList)
        {
            // Get the description of the object. This can be found under the
            // objects key as the default value.

            dwSize = DESCRIPTION_LEN * sizeof(TCHAR);
            if (ERROR_SUCCESS != RegQueryValueEx(hkeyObject, "", NULL, &dwType, (LPBYTE) szDescription, &dwSize))
                szDescription[0] = _T('\0');

            // Create a new OLE registration item entry. This might throw a memory exception,
            // so close the hkeyObject handle first.

            RegCloseKey(hkeyObject);
            if (!AddOLERegItem(_T("REGISTRY"), szDescription, szObjectKey, szServer))
            {
                fReturn = FALSE;
                goto END;
            }
        }
        else
            RegCloseKey(hkeyObject);
    }

END:
    TraceFunctLeave();
    return fReturn;
}

//-----------------------------------------------------------------------------
// This method retrieves OLE object information from the INI file(s) and adds
// it to the list of objects. Note - this code is essentially lifted from the
// source code for the OLE Registration OCX in MSInfo 4.10.
//
// Changes were made to remove MFC dependencies.
//-----------------------------------------------------------------------------

BOOL COLEItemCollection::UpdateFromINIFile()
{
    TraceFunctEnter("COLEItemCollection::UpdateFromINIFile");

    TCHAR   szProgram[PROGRAM_LEN];
    TCHAR   szDescription[DESCRIPTION_LEN];
    LPTSTR  szBuffer;
    LPTSTR  szEntry;
    LPTSTR  szScan;
    TCHAR   szData[MAX_PATH * 2];
    BOOL    fReturn = TRUE;
    int     i;

    szBuffer = new TCHAR[2048];
    if (szBuffer == NULL)
        throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);

    if (GetProfileString(_T("embedding"), NULL, _T("\0\0"), szBuffer, 2048) <= 2)
    {
        fReturn = FALSE;
        goto END;
    }

    szEntry = szBuffer;
    while (*szEntry != 0)
    {
        if (GetProfileString(_T("embedding"), szEntry, _T("\0\0"), szData, MAX_PATH * 2) > 1)
        {
            // Parse out the components of the string we retrieved. The string
            // should be formed as "primary desc, registry desc, program, format".

            szScan = szData;

            i = _tcscspn(szScan, _T(","));
            _tcsncpy(szDescription, szScan, (i < DESCRIPTION_LEN - 1) ? i : DESCRIPTION_LEN - 1);
            szDescription[(i < DESCRIPTION_LEN - 1) ? i : DESCRIPTION_LEN - 1] = _T('\0');
            szScan += i + 1;

            szScan += _tcscspn(szScan, _T(",")) + 1;     // skip registry

            i = _tcscspn(szScan, _T(","));
            _tcsncpy(szProgram, szScan, (i < PROGRAM_LEN - 1) ? i : PROGRAM_LEN - 1);
            szProgram[(i < PROGRAM_LEN - 1) ? i : PROGRAM_LEN - 1] = _T('\0');
            szScan += i + 1;

            // Create a new OLE registration item entry. This might throw an exception.

			try
			{				
                if (!AddOLERegItem(_T("INIFILE"), szDescription, szEntry, szProgram))
                {
                    fReturn = FALSE;
                    goto END;
                }
			}
			catch (...)
			{
                if (szBuffer)
                    delete [] szBuffer;
                throw;
			}
        }
        szEntry += lstrlen(szEntry) + 1;
    }

END:
    if (szBuffer)
        delete [] szBuffer;
    TraceFunctLeave();
    return fReturn;
}

/*****************************************************************************
*
*  FUNCTION    :    CPCH_OLERegistration::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                       WBEM_FLAG_DEEP
*                       WBEM_FLAG_SHALLOW
*                       WBEM_FLAG_RETURN_IMMEDIATELY
*                       WBEM_FLAG_FORWARD_ONLY
*                       WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    : TO DO: All instances on the machine should be returned here.
*                       If there are no instances, return WBEM_S_NO_ERROR.
*                       It is not an error to have no instances.
*
*****************************************************************************/

HRESULT CPCH_OLERegistration::EnumerateInstances(MethodContext * pMethodContext, long lFlags)
{
    TraceFunctEnter("CPCH_OLERegistration::EnumerateInstances");

    HRESULT hRes = WBEM_S_NO_ERROR;
   
    // Get the date and time

    SYSTEMTIME stUTCTime;
    GetSystemTime(&stUTCTime);

    // The COLEItemCollection class gathers data about the OLE registration objects when it's
    // constructed. We can get info for each individual object using it's GetInstance
    // pointer, which gives us a pointer to a COLERegItem object.

    COLEItemCollection olereginfo;
    COLERegItem * poleitem;

    for (DWORD dwIndex = 0;  olereginfo.GetInstance(dwIndex, &poleitem); dwIndex++)
    {
        CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);

        // Set the change and timestamp fields to "Snapshot" and the current time.

        if (!pInstance->SetDateTime(pTimeStamp, WBEMTime(stUTCTime)))
            ErrorTrace(TRACE_ID, "SetDateTime on Timestamp field failed.");

        if (!pInstance->SetCHString(pChange, L"Snapshot"))
            ErrorTrace(TRACE_ID, "SetCHString on Change field failed.");

        // Set each of the other fields to the values we found when we retrieved
        // the OLE objects from the registry and INI files.

        if (!pInstance->SetCHString(pCategory, poleitem->GetCategory()))
            ErrorTrace(TRACE_ID, "SetCHString on Category field failed.");

        if (!pInstance->SetCHString(pDescription, poleitem->GetDescription()))
            ErrorTrace(TRACE_ID, "SetCHString on Description field failed.");

        if (!pInstance->SetCHString(pProgramFile, poleitem->GetProgramFile()))
            ErrorTrace(TRACE_ID, "SetCHString on ProgramFile field failed.");

        if (!pInstance->SetCHString(pObject, poleitem->GetObject()))
            ErrorTrace(TRACE_ID, "SetCHString on Object field failed.");

        LPCSTR szFile = poleitem->GetProgramFile();
        if (szFile && szFile[0])
        {
            CComPtr<IWbemClassObject>   pFileObj;
            CComBSTR                    ccombstrValue(szFile);
            if (SUCCEEDED(GetCIMDataFile(ccombstrValue, &pFileObj)))
            {
                // Using the CIM_DataFile object, copy over the appropriate properties.

                CopyProperty(pFileObj, L"Version", pInstance, pVersion);
                CopyProperty(pFileObj, L"FileSize", pInstance, pSize);
                CopyProperty(pFileObj, L"CreationDate", pInstance, pDate);
            }
        }

    	hRes = pInstance->Commit();
        if (FAILED(hRes))
            ErrorTrace(TRACE_ID, "Commit on Instance failed.");
    }

    TraceFunctLeave();
    return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprov\pch_oleregistration.h ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_OLERegistration.H

Abstract:
	WBEM provider class definition for PCH_OLERegistration class

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

********************************************************************/

// Property set identification
//============================

#ifndef _PCH_OLERegistration_H_
#define _PCH_OLERegistration_H_

#define PROVIDER_NAME_PCH_OLEREGISTRATION "PCH_OLERegistration"

// Property name externs -- defined in PCH_OLERegistration.cpp
//=================================================

extern const WCHAR* pCategory ;
extern const WCHAR* pTimeStamp ;
extern const WCHAR* pChange ;
extern const WCHAR* pDate ;
extern const WCHAR* pDescription ;
extern const WCHAR* pObject ;
extern const WCHAR* pProgramFile ;
extern const WCHAR* pSize ;
extern const WCHAR* pVersion ;

class CPCH_OLERegistration : public Provider 
{
	public:
		// Constructor/destructor
		//=======================

		CPCH_OLERegistration(const CHString& chsClassName, LPCWSTR lpszNameSpace) : Provider(chsClassName, lpszNameSpace) {};
		virtual ~CPCH_OLERegistration() {};

	protected:
		// Reading Functions
		//============================
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Writing Functions
		//============================
		virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Other Functions
		virtual HRESULT ExecMethod( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags = 0L ) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprov\pch_printerdriver.h ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_PrinterDriver.H

Abstract:
	WBEM provider class definition for PCH_PrinterDriver class

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

********************************************************************/

// Property set identification
//============================

#ifndef _PCH_PrinterDriver_H_
#define _PCH_PrinterDriver_H_

#define PROVIDER_NAME_PCH_PRINTERDRIVER "PCH_PrinterDriver"

// Property name externs -- defined in PCH_PrinterDriver.cpp
//=================================================

extern const WCHAR* pTimeStamp ;
extern const WCHAR* pChange ;
extern const WCHAR* pDate ;
extern const WCHAR* pFilename ;
extern const WCHAR* pManufacturer ;
extern const WCHAR* pName ;
extern const WCHAR* pSize ;
extern const WCHAR* pVersion ;
extern const WCHAR* pPath;

class CPCH_PrinterDriver : public Provider 
{
	public:
		// Constructor/destructor
		//=======================

		CPCH_PrinterDriver(const CHString& chsClassName, LPCWSTR lpszNameSpace) : Provider(chsClassName, lpszNameSpace) {};
		virtual ~CPCH_PrinterDriver() {};

	protected:
		// Reading Functions
		//============================
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Writing Functions
		//============================
		virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Other Functions
		virtual HRESULT ExecMethod( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags = 0L ) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprov\pch_printerdriver.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    PCH_PrinterDriver.CPP

Abstract:
    WBEM provider class implementation for PCH_PrinterDriver class

Revision History:

    Ghim-Sim Chua       (gschua)   04/27/99
        - Created

    Kalyani Narlanka    (kalyanin) 05/11/99
        - Added Code to get all the properties for this class

********************************************************************/

#include "pchealth.h"
#include "PCH_PrinterDriver.h"


/////////////////////////////////////////////////////////////////////////////
//  tracing stuff

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile
#define TRACE_ID    DCID_PRINTERDRIVER

CPCH_PrinterDriver MyPCH_PrinterDriverSet (PROVIDER_NAME_PCH_PRINTERDRIVER, PCH_NAMESPACE) ;

// Property names
//===============
const static WCHAR* pTimeStamp       = L"TimeStamp" ;
const static WCHAR* pChange          = L"Change" ;
const static WCHAR* pDate            = L"Date" ;
const static WCHAR* pFilename        = L"Filename" ;
const static WCHAR* pManufacturer    = L"Manufacturer" ;
const static WCHAR* pName            = L"Name" ;
const static WCHAR* pSize            = L"Size" ;
const static WCHAR* pVersion         = L"Version" ;
const static WCHAR* pPath            = L"Path" ;

/*****************************************************************************
*
*  FUNCTION    :    CPCH_PrinterDriver::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                       WBEM_FLAG_DEEP
*                       WBEM_FLAG_SHALLOW
*                       WBEM_FLAG_RETURN_IMMEDIATELY
*                       WBEM_FLAG_FORWARD_ONLY
*                       WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    : TO DO: All instances on the machine should be returned here.
*                       If there are no instances, return WBEM_S_NO_ERROR.
*                       It is not an error to have no instances.
*
*****************************************************************************/
HRESULT CPCH_PrinterDriver::EnumerateInstances(
    MethodContext* pMethodContext,
    long lFlags
    )
{

    TraceFunctEnter("CPCH_PrinterDriver::EnumerateInstances");

    //  Begin Declarations

    HRESULT                         hRes                = WBEM_S_NO_ERROR;

    //  Query String
    CComBSTR                        bstrPrinterQuery    = L"Select DeviceID, PortName FROM win32_printer";

    // Instances
    CComPtr<IEnumWbemClassObject>   pPrinterEnumInst;
    CInstance                       *pPCHPrinterDriverInstance;

    //  SystemTime
    SYSTEMTIME                      stUTCTime;

     //  Objects
    IWbemClassObjectPtr            pPrinterObj;                   
    IWbemClassObjectPtr            pFileObj;

    //  Unsigned Longs....
    ULONG                           ulPrinterRetVal     = 0;
    ULONG                           uiReturn            = 0;

    //  File Status structure
    struct _stat                    filestat;

    //  Strings
    CComBSTR                        bstrPrinterDriverWithPath;
    CComBSTR                        bstrPrinterDriver;
    CComBSTR                        bstrProperty;
    CComBSTR                        bstrDeviceID                = L"DeviceID";

    LPCWSTR                         lpctstrPortName             = L"PortName";
    LPCWSTR                         lpctstrFileSize             = L"FileSize";
    LPCWSTR                         lpctstrLastModified         = L"LastModified";
    LPCWSTR                         lpctstrManufacturer         = L"Manufacturer";
    LPCWSTR                         lpctstrVersion              = L"Version";
    LPCTSTR                         lpctstrComma                = _T(",");
    LPCTSTR                         lpctstrDrvExtension         = _T(".drv");
    LPCTSTR                         lpctstrDevices              = _T("Devices");
    LPCWSTR                         lpctstrDeviceID             = L"DeviceID";

    TCHAR                           tchDeviceID[MAX_PATH];

    TCHAR                           tchBuffer[MAX_PATH];
    TCHAR                           *ptchToken;

    CComVariant                     varValue;
    CComVariant                     varSnapshot                 = "Snapshot";
    
    BOOL                            fDriverFound;

    BOOL                            fCommit                     = FALSE;

    // Get the date and time to update the TimeStamp Field
    GetSystemTime(&stUTCTime);

    //  Execute the query to get DeviceID, PORTName FROM Win32_Printer
    //  Class.
    //  pPrinterEnumInst contains a pointer to the list of instances returned.

    tchDeviceID[0] = 0;

    hRes = ExecWQLQuery(&pPrinterEnumInst, bstrPrinterQuery);
    if (FAILED(hRes))
    {
        //  Cannot get any properties.
        goto END;
    }
    //  Query Succeeded!
    //  Enumerate the instances from pPrinterEnumInstance
    //  Get the next instance into pPrinterObj object.
    while(WBEM_S_NO_ERROR == pPrinterEnumInst->Next(WBEM_INFINITE, 1, &pPrinterObj, &ulPrinterRetVal))
    {
        //  Create a new instance of PCH_PrinterDriver Class based on the passed-in MethodContext
        CInstancePtr   pPCHPrinterDriverInstance(CreateNewInstance(pMethodContext),false);

        //  Created a New Instance of PCH_PrinterDriver Successfully.
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //                              TIME STAMP                                                                 //
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////

        hRes = pPCHPrinterDriverInstance->SetDateTime(pTimeStamp, WBEMTime(stUTCTime));
        if (FAILED(hRes))
        {
            //  Could not Set the Time Stamp
            //  Continue anyway
                ErrorTrace(TRACE_ID, "SetDateTime on Timestamp Field failed.");
        }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //                              CHANGE                                                                     //
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////

        hRes = pPCHPrinterDriverInstance->SetVariant(pChange, varSnapshot);
        if (FAILED(hRes))
        {
            //  Could not Set the Change Property
            //  Continue anyway
            ErrorTrace(TRACE_ID, "SetCHString on Change Field failed.");
        }


        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //                              NAME                                                                     //
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////

        hRes = CopyProperty(pPrinterObj, lpctstrDeviceID, pPCHPrinterDriverInstance, pName);
        if(SUCCEEDED(hRes))
        {
            fCommit = TRUE;
        }

       
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //                              PATH                                                                        //
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////

        CopyProperty(pPrinterObj, lpctstrPortName, pPCHPrinterDriverInstance, pPath);
        
      
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //                              FILENAME                                                                     //
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////

        // Get the File Name i.e.driver from the INI file.
        // Use the DeviceID of win32_printer class to get the PCH_Printer.FileName

        // Get the device ID  and use it to pick up the driver from win.ini File
        hRes = pPrinterObj->Get(bstrDeviceID, 0, &varValue, NULL, NULL);
        if(SUCCEEDED(hRes))
        {
            //  Got the DeviceID
            //  Now call GetProfileString to get the Driver
            USES_CONVERSION;
            _tcscpy(tchDeviceID,W2T(varValue.bstrVal));
            if (GetProfileString(lpctstrDevices, tchDeviceID, "\0", tchBuffer, MAX_PATH) > 1)
            {
                //  tchBuffer contains a string of two tokens, first the driver, second the PathName
                //  Get the driver
                ptchToken = _tcstok(tchBuffer,lpctstrComma);
                if(ptchToken != NULL)
                {
                    // Got the Driver Name
                    bstrPrinterDriver = ptchToken;
                    varValue = ptchToken;
                
                    //  Use this to set the FileName
                    hRes = pPCHPrinterDriverInstance->SetVariant(pFilename, varValue);
                    if (FAILED(hRes))
                    {
                        //  Could not Set the FileName Property
                        //  Continue anyway
                        ErrorTrace(TRACE_ID, "Set Variant on Change Field failed.");
                    }

                    // Now get the properties of the File
                    // Concatenate ".drv" to get the driver's actual Name
                    bstrPrinterDriver.Append(lpctstrDrvExtension);

                    //  Get the Complete Path of the File 
                    fDriverFound =  getCompletePath(bstrPrinterDriver, bstrPrinterDriverWithPath);
                    if (fDriverFound)
                    {
                        //  Got the complete Path  Call GetCIMDataFile Function to get 
                        //  properties  of this file.

                        if (SUCCEEDED(GetCIMDataFile(bstrPrinterDriverWithPath, &pFileObj)))
                        {

                            /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                            //                              VERSION                                                                    //
                            /////////////////////////////////////////////////////////////////////////////////////////////////////////////

                            CopyProperty(pFileObj, lpctstrVersion, pPCHPrinterDriverInstance, pVersion);

                            /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                            //                              FILESIZE                                                                   //
                            /////////////////////////////////////////////////////////////////////////////////////////////////////////////

                            CopyProperty(pFileObj, lpctstrFileSize, pPCHPrinterDriverInstance, pSize);

                            /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                            //                              DATE                                                                     //
                            /////////////////////////////////////////////////////////////////////////////////////////////////////////////

                            CopyProperty(pFileObj, lpctstrLastModified, pPCHPrinterDriverInstance, pDate);

                            /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                            //                              MANUFACTURER                                                                     //
                            /////////////////////////////////////////////////////////////////////////////////////////////////////////////

                            CopyProperty(pFileObj, lpctstrManufacturer, pPCHPrinterDriverInstance, pManufacturer);

                            
                        } //end of SUCCEEDED...
                    } // end of if fDriverFound
                
                }  // end of if (ptchToken != NULL)

            } // end of GetProfileString...
                        
        }// end of got the DeviceID

        //  All the properties are set. Commit the instance
        hRes = pPCHPrinterDriverInstance->Commit();
        if(FAILED(hRes))
        {
            //  Could not Commit the instance
            ErrorTrace(TRACE_ID, "Could not commit the instance");
        }

    } // end of While

END:    TraceFunctLeave();
        return hRes;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprov\pch_printer.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
PCH_Printer.CPP

Abstract:
WBEM provider class implementation for PCH_Printer class

Revision History:

Ghim-Sim Chua       (gschua)   04/27/99
- Created

********************************************************************/

#include "pchealth.h"
#include "PCH_Printer.h"

/////////////////////////////////////////////////////////////////////////////
//  tracing stuff

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile
#define TRACE_ID    DCID_PRINTER


#define                 MAX_STRING_LEN      1024

CPCH_Printer MyPCH_PrinterSet (PROVIDER_NAME_PCH_PRINTER, PCH_NAMESPACE) ;



///////////////////////////////////////////////////////////////////////////////
//....Properties of PCHPrinter Class
//

const static WCHAR* pTimeStamp           = L"TimeStamp" ;
const static WCHAR* pChange              = L"Change" ;
const static WCHAR* pDefaultPrinter      = L"DefaultPrinter" ;
const static WCHAR* pGenDrv              = L"GenDrv" ;
const static WCHAR* pName                = L"Name" ;
const static WCHAR* pPath                = L"Path" ;
const static WCHAR* pUniDrv              = L"UniDrv" ;
const static WCHAR* pUsePrintMgrSpooling = L"UsePrintMgrSpooling" ;

//*****************************************************************************
//
// Function Name     : CPCH_Printer::EnumerateInstances
//
// Input Parameters  : pMethodContext : Pointer to the MethodContext for 
//                                      communication with WinMgmt.
//                
//                     lFlags :         Long that contains the flags described 
//                                      in IWbemServices::CreateInstanceEnumAsync
//                                      Note that the following flags are handled 
//                                      by (and filtered out by) WinMgmt:
//                                      WBEM_FLAG_DEEP
//                                      WBEM_FLAG_SHALLOW
//                                      WBEM_FLAG_RETURN_IMMEDIATELY
//                                      WBEM_FLAG_FORWARD_ONLY
//                                      WBEM_FLAG_BIDIRECTIONAL
// Output Parameters  : None
//
// Returns            : WBEM_S_NO_ERROR 
//                      
//
// Synopsis           : There is a single instance of this class on the machine 
//                      and this is returned..
//                      If there is no instances returns WBEM_S_NO_ERROR.
//                      It is not an error to have no instances.
//
//*****************************************************************************

HRESULT CPCH_Printer::EnumerateInstances(MethodContext* pMethodContext,
                                                long lFlags)
{
    TraceFunctEnter("CPCH_Printer::EnumerateInstances");

    //  Begin Declarations...................................................

    HRESULT                                 hRes = WBEM_S_NO_ERROR;

    //  Instances
    CComPtr<IEnumWbemClassObject>           pPrinterEnumInst;

    //  Objects
    IWbemClassObjectPtr                     pFileObj;
    IWbemClassObjectPtr                     pPrinterObj;                   // BUGBUG : WMI asserts if we use CComPtr
    
    //  SystemTime
    SYSTEMTIME                              stUTCTime;

    //  Variants
    CComVariant                             varValue;
    CComVariant                             varAttributes;
    CComVariant                             varSnapshot             = "Snapshot";
    CComVariant                             varNotAvail             = "Not Available";

    //   Strings
    CComBSTR                                bstrUniDriverWithPath; 
    CComBSTR                                bstrGenDriverWithPath;
    CComBSTR                                bstrUnidriverDetails;
    CComBSTR                                bstrGenDriverDetails;
    CComBSTR                                bstrAttributes          =   "attributes";
    CComBSTR                                bstrPrinterQueryString;
    CComBSTR                                bstrVersion             = "Version";
    CComBSTR                                bstrFileSize            = "FileSize";
    CComBSTR                                bstrModifiedDate        = "LastModified";

    LPCTSTR                                 lpctstrUniDriver        = _T("unidrv.dll");
    LPCTSTR                                 lpctstrGenDriver        = _T("gendrv.dll");
    LPCTSTR                                 lpctstrSpace            = _T("  "); 
    LPCTSTR                                 lpctstrPrinterQuery     = _T("Select DeviceID, DriverName, Attributes FROM win32_printer WHERE DriverName =\"");
    LPCTSTR                                 lpctstrWindows          = _T("Windows");   
    LPCTSTR                                 lpctstrDevice           = _T("Device");  
    LPCTSTR                                 lpctstrComma            = _T(",");
    LPCTSTR                                 lpctstrSlash            = _T("\"");
    LPCTSTR                                 lpctstrNoUniDrv         = _T("(unidrv.dll) = NotInstalled");
    LPCTSTR                                 lpctstrNoGenDrv         = _T("(gendrv.dll) = NotInstalled");
    LPCTSTR                                 lpctstrPrintersHive     = _T("System\\CurrentControlSet\\Control\\Print\\Printers");
    LPCTSTR                                 lpctstrYes              = _T("yes");
    LPCTSTR                                 lpctstrAttributes       = _T("Attributes");
    LPCTSTR                                 lpctstrSpooler          = _T("Spooler");

    TCHAR                                   tchBuffer[MAX_STRING_LEN];
    TCHAR                                   tchPrinterKeyName[MAX_STRING_LEN];
    TCHAR                                   tchAttributesValue[MAX_PATH];
    TCHAR                                   *ptchToken;

    //  Booleans
    BOOL                                    fDriverFound;
    BOOL                                    fCommit                 = FALSE;
    BOOL                                    fAttribFound            = FALSE;

    //  DWORDs
    DWORD                                   dwSize;
    DWORD                                   dwIndex;
    DWORD                                   dwType;
    DWORD                                   dwAttributes;
     
    //  Return Values;
    ULONG                                   ulPrinterRetVal         = 0;
    ULONG                                   ulPrinterAttribs;

    LONG                                    lRegRetVal;

    struct tm                               tm;

    WBEMTime                                wbemtimeUnidriver;
    WBEMTime                                wbemtimeGendriver;

    HKEY                                    hkeyPrinter;
    HKEY                                    hkeyPrinters;

    PFILETIME                               pFileTime               = NULL;
  

    //  End Declarations...................................................

    //  Create a new instance of PCH_Printer Class based on the passed-in MethodContext
    CInstancePtr pPCHPrinterInstance(CreateNewInstance(pMethodContext), false);

    //  Created a New Instance of PCH_PrinterInstance Successfully.

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //                              TIME STAMP                                                                 //
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////

    // Get the date and time to update the TimeStamp Field
    GetSystemTime(&stUTCTime);

    hRes = pPCHPrinterInstance->SetDateTime(pTimeStamp, WBEMTime(stUTCTime));
    if (FAILED(hRes))
    {
        //  Could not Set the Time Stamp
        //  Continue anyway
        ErrorTrace(TRACE_ID, "SetDateTime on Timestamp Field failed.");
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //                              CHANGE                                                                     //
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////

    hRes = pPCHPrinterInstance->SetVariant(pChange, varSnapshot);
    if(FAILED(hRes))
    {
        //  Could not Set the Change Property
        //  Continue anyway
        ErrorTrace(TRACE_ID, "Set Variant on Change Field failed.");
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //                              DEFAULTPRINTER                                                             //
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    
    //  In "win.ini" file under "Windows" section "Device" represents the default printer
    if(GetProfileString(lpctstrWindows, lpctstrDevice, "\0", tchBuffer, MAX_PATH) > 1)
    {
        // If Found the Default Printer set the value to TRUE
        varValue = VARIANT_TRUE;
        hRes = pPCHPrinterInstance->SetVariant(pDefaultPrinter, varValue);
        if(FAILED(hRes))
        {
            //  Could not Set the Default Printer to TRUE
            //  Continue anyway
            ErrorTrace(TRACE_ID, "Set Variant on DefaultPrinter Field failed.");
        }

        //  The Above GetProfileString returns "printerName", "PrinterDriver" and "PrinterPath" 
        //  seperated by commas. Ignore "PrinterDriver" and use the other two to set the properties.
        ptchToken = _tcstok(tchBuffer,lpctstrComma);
        if(ptchToken != NULL)
        {
            // Got the first Token i.e. name. Set this.
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////
            //                              NAME                                                                       //
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////
            varValue = ptchToken;
            hRes = pPCHPrinterInstance->SetVariant(pName, varValue);
            if(FAILED(hRes))
            {
                //  Could not Set the Name
                //  Continue anyway
                ErrorTrace(TRACE_ID, "Set Variant on Name Field failed.");
            }
                        
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////
            //                              PATH                                                                       //
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////

            // continue to get the next token and ignore
          
            ptchToken = _tcstok(NULL,lpctstrComma);
            if(ptchToken != NULL)
            {
                //  If ptchToken is not equal to NULL, then continue to get the third token and set it to PATH Name Field
                ptchToken = _tcstok(NULL,lpctstrComma);
                if(ptchToken != NULL)
                {
                    // Got the third token i.e. PATH Set this.
                    varValue = ptchToken;
                    hRes = pPCHPrinterInstance->SetVariant(pPath, varValue);
                    if (FAILED(hRes))
                    {
                        //  Could not Set the Path property
                        //  Continue anyway
                        ErrorTrace(TRACE_ID, "Set Variant on PathName Field failed.");
                    }
                }
            }
        }
    }
    else
    {
        //  Could not get the default printer details.

        //  Set the Name to "Not Available"
        hRes = pPCHPrinterInstance->SetVariant(pName, varNotAvail);
        if(FAILED(hRes))
        {
            //  Could not Set the Name
            //  Continue anyway
            ErrorTrace(TRACE_ID, "Set Variant on Name Field failed.");
        }
        //  Set the default printer to false
        varValue = VARIANT_FALSE;
        hRes = pPCHPrinterInstance->SetVariant(pDefaultPrinter, varValue);
        if(FAILED(hRes))
        {
            //  Could not Set the Default Printer to FALSE
            //  Continue anyway
            ErrorTrace(TRACE_ID, "Set Variant on DefaultPrinter Field failed.");
        }
        //  Proceed anyway!
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //                              USEPRINTMANAGERSPOOLING                                                    //
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////

    //  First try to get the Spooling  information from the registry. This is available in registry if there are 
    //  any installed printers.
    // This info. is present under HKLM\system\CCS\Control\Print\Printers

    lRegRetVal = RegOpenKeyEx(HKEY_LOCAL_MACHINE, lpctstrPrintersHive, 0, KEY_READ, &hkeyPrinters);
    if(lRegRetVal == ERROR_SUCCESS)
	{
		// Opened the Registry key.
        // Enumerate the keys under this hive.
        dwIndex = 0;
        dwSize = MAX_PATH;
        lRegRetVal = RegEnumKeyEx(hkeyPrinters, dwIndex,  tchPrinterKeyName, &dwSize, NULL, NULL, NULL, pFileTime);
        if(lRegRetVal == ERROR_SUCCESS)
        {
            //  There is atleast one printer installed.
            lRegRetVal = RegOpenKeyEx(hkeyPrinters,  tchPrinterKeyName, 0, KEY_READ, &hkeyPrinter);
            if(lRegRetVal == ERROR_SUCCESS)
            {
                //  Opened the first printer key
                //  Query for , regname "Attributes"
                dwSize = MAX_PATH;
                lRegRetVal = RegQueryValueEx(hkeyPrinter, lpctstrAttributes , NULL, &dwType, (LPBYTE)&dwAttributes, &dwSize);
                if(lRegRetVal == ERROR_SUCCESS)
                {
                    //  Got the attributes

                    //  Check the type of the reg Value
                    if(dwType == REG_DWORD)
                    {
                    /*
                    //  tchAttributesValue set to Attributes. Copy this to ulPrinterAttribs
                    ulPrinterAttribs = atol(tchAttributesValue);
                    if (ulPrinterAttribs > 0)
                    {
                        // From ulPrinterAttribs determine if spooling is present or not.
                        // AND it with PRINTER_ATTRIBUTE_DIRECT
                        if((ulPrinterAttribs & PRINTER_ATTRIBUTE_DIRECT) != 0)
                        {
                            // No spooling
                            varValue = VARIANT_FALSE;
                        }
                        else
                        {
                            // Spooling : YES
                            varValue = VARIANT_TRUE;
                        }

                        //  Attribute Found
                        fAttribFound = TRUE;
                    }
                    */
                        if((dwAttributes & PRINTER_ATTRIBUTE_DIRECT) != 0)
                        {
                            // No spooling
                            varValue = VARIANT_FALSE;
                        }
                        else
                        {
                            // Spooling : YES
                            varValue = VARIANT_TRUE;
                        }

                        //  Attribute Found
                        fAttribFound = TRUE;
                    }
                }
            }
                     
        }
    }              
    if(!fAttribFound)
    {
        //  If not get the "spooler" key value from the win.ini file.  If the entry is not present default to "yes".
        if(GetProfileString(lpctstrWindows, lpctstrSpooler, "yes", tchBuffer, MAX_PATH) > 1)
        {
            //  Got the spooler Details
            if(_tcsicmp(tchBuffer, lpctstrYes) == 0)
            {
                // Spooling : YES
                varValue = VARIANT_TRUE;
            }
            else
            {
                // No spooling
                varValue = VARIANT_FALSE;
            }
        }

    }

    //  Set the Spooling Property.
    hRes =  pPCHPrinterInstance->SetVariant(pUsePrintMgrSpooling, varValue);
    if(FAILED(hRes))
    {
        //  Could not Set the USEPRINTMANAGERSPOOLING
        //  Continue anyway
        ErrorTrace(TRACE_ID, "Set Variant on usePrintManagerSpooling Field failed.");
    }
    
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //                              UNIDRV                                                                     //
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    pFileObj = NULL;
    //  Get the complete path for unidrv.dll
    fDriverFound =  getCompletePath(lpctstrUniDriver, bstrUniDriverWithPath);
    if(fDriverFound)
    {
        //  Unidrv.dll present. Pass the File with PathName to
        //  GetCIMDataFile function to get the file properties.
        if (SUCCEEDED(GetCIMDataFile(bstrUniDriverWithPath, &pFileObj)))
        {
            // From the CIM_DataFile Object get the properties and append them 
            //  Get the Version 
            varValue.Clear();
            hRes = pFileObj->Get(bstrVersion, 0, &varValue, NULL, NULL);
            if(SUCCEEDED(hRes))
            {
                //  Got the Version. Append it to the bstrUnidriverDetails String
                if(varValue.vt == VT_BSTR)
                {
                    bstrUnidriverDetails.Append(varValue.bstrVal);
                    //  Append Space 
                    bstrUnidriverDetails.Append(lpctstrSpace);
                }
            }

            //  Get the FileSize
            varValue.Clear();
            hRes = pFileObj->Get(bstrFileSize, 0, &varValue, NULL, NULL);
            if(SUCCEEDED(hRes))
            {
                //  Got the FileSize. Append it to the bstrUnidriverDetails String
                if(varValue.vt == VT_BSTR)
                {
                    bstrUnidriverDetails.Append(varValue.bstrVal);
                    //  Append Space 
                    bstrUnidriverDetails.Append(lpctstrSpace);
                }
            }

            //  Get the Date&Time
            varValue.Clear();
            hRes = pFileObj->Get(bstrModifiedDate, 0, &varValue, NULL, NULL);
            if(SUCCEEDED(hRes))
            {
                if(varValue.vt == VT_BSTR)
                {
                    wbemtimeUnidriver = varValue.bstrVal;
                    if(wbemtimeUnidriver.GetStructtm(&tm))
                    {
                        //  Got the time in tm Struct format
                        //  Convert it into a string
                        varValue = asctime(&tm);
                        //Append it to the bstrUnidriverDetails String
                        bstrUnidriverDetails.Append(varValue.bstrVal);
                    }
                }
                
            }
            // Copy the string into the varValue
            varValue.vt = VT_BSTR;
            varValue.bstrVal = bstrUnidriverDetails.Detach();
        }// end of if succeeded CIM_DataFile
    } // end of if driver Found
    else 
    {
        //  unidrv.dll not present
        varValue.Clear();
        varValue = lpctstrNoUniDrv;
    }
    hRes = pPCHPrinterInstance->SetVariant(pUniDrv, varValue);
    if(FAILED(hRes))
    {
        //  Could not Set the Unidriver property
        //  Continue anyway
        ErrorTrace(TRACE_ID, "Set Variant on Uni Driver Field failed.");
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //                              GENDRV                                                                     //
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////

    pFileObj = NULL;
    
    //  Get the complete path for gendrv.dll
    fDriverFound =  getCompletePath(lpctstrGenDriver, bstrGenDriverWithPath);
    if(fDriverFound)
    {
        //  Gendrv.dll present. Pass the File with PathName to
        //  GetCIMDataFile function to get the file properties.
        if(SUCCEEDED(GetCIMDataFile(bstrGenDriverWithPath, &pFileObj)))
        {
            // From the CIM_DataFile Object get the properties and append them 
            // Get the Version 
            varValue.Clear();
            hRes = pFileObj->Get(bstrVersion, 0, &varValue, NULL, NULL);
            if(SUCCEEDED(hRes))
            {
                //  Got the Version. Append it to the bstrUnidriverDetails String
                if(varValue.vt == VT_BSTR)
                {
                    bstrGenDriverDetails.Append(varValue.bstrVal);
                    //  Append Space 
                    bstrGenDriverDetails.Append(lpctstrSpace);
                }
            }
            //  Get the FileSize
            varValue.Clear();
            hRes = pFileObj->Get(bstrFileSize, 0, &varValue, NULL, NULL);
            if(SUCCEEDED(hRes))
            {
                if(varValue.vt == VT_BSTR)
                {
                    //  Got the FileSize. Append it to the bstrUnidriverDetails String
                    bstrGenDriverDetails.Append(varValue.bstrVal);
                    //  Append Space 
                    bstrGenDriverDetails.Append(lpctstrSpace);
                }
            }
            //  Get the Date&Time
            varValue.Clear();
            hRes = pFileObj->Get(bstrModifiedDate, 0, &varValue, NULL, NULL);
            if(SUCCEEDED(hRes))
            {
                if(varValue.vt == VT_BSTR)
                {
                    wbemtimeGendriver = varValue.bstrVal;
                    if(wbemtimeGendriver.GetStructtm(&tm))
                    {
                        //  Got the time in tm Struct format
                        //  Convert it into a string
                        varValue = asctime(&tm);
                        bstrGenDriverDetails.Append(varValue.bstrVal);
                    }
                }
                
            }
            // Copy the string into the varValue
            varValue.vt = VT_BSTR;
            varValue.bstrVal = bstrGenDriverDetails.Detach();
        }// end of if succeeded CIM_DataFile
    } // end of if driver Found
    else 
    {
        //  gendrv.dll not present
        varValue.Clear();
        varValue = lpctstrNoGenDrv;
    }
    hRes =   pPCHPrinterInstance->SetVariant(pGenDrv, varValue);
    if(FAILED(hRes))
    {
        //  Could not Set the GenDrv Field
        //  Continue anyway
        ErrorTrace(TRACE_ID, "Set Variant on GenDrv Field failed.");
    }

    //  All the properties are set.
    hRes = pPCHPrinterInstance->Commit();
    if(FAILED(hRes))
    {
        //  Could not Set the GenDrv Field
        //  Continue anyway
        ErrorTrace(TRACE_ID, "Error on commiting!");
    }
    
    TraceFunctLeave();
    return hRes ;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprov\pch_printjob.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    PCH_PrintJob.CPP

Abstract:
    WBEM provider class implementation for PCH_PrintJob class

Revision History:

    Ghim-Sim Chua       (gschua)   04/27/99
        - Created

    Ghim-Sim Chua       (gschua)   05/02/99
        - Modified code to use CopyProperty function
        - Use CComBSTR instead of USES_CONVERSION

********************************************************************/

#include "pchealth.h"
#include "PCH_PrintJob.h"

/////////////////////////////////////////////////////////////////////////////
//  tracing stuff

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile
#define TRACE_ID    DCID_PRINTJOB

CPCH_PrintJob MyPCH_PrintJobSet (PROVIDER_NAME_PCH_PRINTJOB, PCH_NAMESPACE) ;

// Property names
//===============
const static WCHAR* pTimeStamp = L"TimeStamp" ;
const static WCHAR* pChange = L"Change" ;
const static WCHAR* pName = L"Name" ;
const static WCHAR* pPagesPrinted = L"PagesPrinted" ;
const static WCHAR* pSize = L"Size" ;
const static WCHAR* pStatus = L"Status" ;
const static WCHAR* pTimeSubmitted = L"TimeSubmitted" ;

/*****************************************************************************
*
*  FUNCTION    :    CPCH_PrintJob::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                       WBEM_FLAG_DEEP
*                       WBEM_FLAG_SHALLOW
*                       WBEM_FLAG_RETURN_IMMEDIATELY
*                       WBEM_FLAG_FORWARD_ONLY
*                       WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    : TO DO: All instances on the machine should be returned here.
*                       If there are no instances, return WBEM_S_NO_ERROR.
*                       It is not an error to have no instances.
*
*****************************************************************************/
HRESULT CPCH_PrintJob::EnumerateInstances(
    MethodContext* pMethodContext,
    long lFlags
    )
{
    TraceFunctEnter("CPCH_PrintJob::EnumerateInstances");

    HRESULT                             hRes = WBEM_S_NO_ERROR;
    REFPTRCOLLECTION_POSITION           posList;
    CComPtr<IEnumWbemClassObject>       pEnumInst;
    IWbemClassObjectPtr                 pObj;      // BUGBUG : WMI asserts if we use CComPtr
    ULONG                               ulRetVal;

    //
    // Get the date and time
    //
    SYSTEMTIME stUTCTime;
    GetSystemTime(&stUTCTime);

    //
    // Execute the query
    //
    // To fix Bug : 100551 , we need to read "jobstatus" instead of "status".
    hRes = ExecWQLQuery(&pEnumInst, CComBSTR("select Name, Size, JobStatus, TimeSubmitted, PagesPrinted from Win32_printJob"));
    if (FAILED(hRes))
        goto END;

    //
    // enumerate the instances from win32_CodecFile
    //
    while(WBEM_S_NO_ERROR == pEnumInst->Next(WBEM_INFINITE, 1, &pObj, &ulRetVal))
    {

        // Create a new instance based on the passed-in MethodContext
        CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);
        CComVariant varValue;

        if (!pInstance->SetDateTime(pTimeStamp, WBEMTime(stUTCTime)))
            ErrorTrace(TRACE_ID, "SetDateTime on Timestamp Field failed.");

        if (!pInstance->SetCHString(pChange, L"Snapshot"))
            ErrorTrace(TRACE_ID, "SetCHString on Change Field failed.");

        (void)CopyProperty(pObj, L"Name", pInstance, pName);
        (void)CopyProperty(pObj, L"PagesPrinted", pInstance, pPagesPrinted);
        (void)CopyProperty(pObj, L"Size", pInstance, pSize);
        (void)CopyProperty(pObj, L"JobStatus", pInstance, pStatus);
        (void)CopyProperty(pObj, L"TimeSubmitted", pInstance, pTimeSubmitted);

        hRes = pInstance->Commit();
        if (FAILED(hRes))
        {
            //  Could not Set the Change Property
            //  Continue anyway
            ErrorTrace(TRACE_ID, "Set Variant on Name Field failed.");
        }
           
    }

END :
    TraceFunctLeave();
    return hRes ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprov\pch_printer.h ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_Printer.H

Abstract:
	WBEM provider class definition for PCH_Printer class

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

********************************************************************/

// Property set identification
//============================

#ifndef _PCH_Printer_H_
#define _PCH_Printer_H_

#define PROVIDER_NAME_PCH_PRINTER "PCH_Printer"

// Property name externs -- defined in PCH_Printer.cpp
//=================================================

extern const WCHAR* pTimeStamp ;
extern const WCHAR* pChange ;
extern const WCHAR* pDefaultPrinter ;
extern const WCHAR* pGenDrv ;
extern const WCHAR* pName ;
extern const WCHAR* pPath ;
extern const WCHAR* pUniDrv ;
extern const WCHAR* pUsePrintMgrSpooling ;

class CPCH_Printer : public Provider 
{
	public:
		// Constructor/destructor
		//=======================

		CPCH_Printer(const CHString& chsClassName, LPCWSTR lpszNameSpace) : Provider(chsClassName, lpszNameSpace) {};
		virtual ~CPCH_Printer() {};

	protected:
		// Reading Functions
		//============================
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Writing Functions
		//============================
		virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Other Functions
		virtual HRESULT ExecMethod( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags = 0L ) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprov\pch_programgroup.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    PCH_ProgramGroup.CPP

Abstract:
    WBEM provider class implementation for PCH_ProgramGroup class

Revision History:

    Ghim-Sim Chua       (gschua)   04/27/99
        - Created

    Ghim-Sim Chua       (gschua)   05/02/99
        - Modified code to use CopyProperty function
        - Use CComBSTR instead of USES_CONVERSION

********************************************************************/

#include "pchealth.h"
#include "PCH_ProgramGroup.h"

/////////////////////////////////////////////////////////////////////////////
//  tracing stuff

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile
#define TRACE_ID    DCID_PROGRAMGROUP

CPCH_ProgramGroup MyPCH_ProgramGroupSet (PROVIDER_NAME_PCH_PROGRAMGROUP, PCH_NAMESPACE) ;

// Property names
//===============
const static WCHAR* pTimeStamp = L"TimeStamp" ;
const static WCHAR* pChange = L"Change" ;
const static WCHAR* pGroupName = L"GroupName" ;
const static WCHAR* pName = L"Name" ;
const static WCHAR* pUsername = L"Username" ;

/*****************************************************************************
*
*  FUNCTION    :    CPCH_ProgramGroup::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                       WBEM_FLAG_DEEP
*                       WBEM_FLAG_SHALLOW
*                       WBEM_FLAG_RETURN_IMMEDIATELY
*                       WBEM_FLAG_FORWARD_ONLY
*                       WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    :    All instances on the machine are returned here.
*                       If there are no instances,  WBEM_S_NO_ERROR is returned.
*                       It is not an error to have no instances.
*
*****************************************************************************/
HRESULT CPCH_ProgramGroup::EnumerateInstances(
    MethodContext* pMethodContext,
    long lFlags
    )
{
    TraceFunctEnter("CPCH_ProgramGroup::EnumerateInstances");

    HRESULT                             hRes = WBEM_S_NO_ERROR;
    REFPTRCOLLECTION_POSITION           posList;
    CComPtr<IEnumWbemClassObject>       pEnumInst;
    IWbemClassObjectPtr                 pObj;
    ULONG                               ulRetVal;

    // Get the date and time

    SYSTEMTIME stUTCTime;
    GetSystemTime(&stUTCTime);

    // Execute the query

    hRes = ExecWQLQuery(&pEnumInst, CComBSTR("select GroupName, Name, UserName from Win32_ProgramGroup"));
    if (FAILED(hRes))
        goto END;

    // enumerate the instances from win32_CodecFile

    while (WBEM_S_NO_ERROR == pEnumInst->Next(WBEM_INFINITE, 1, &pObj, &ulRetVal))
    {
        // Create a new instance based on the passed-in MethodContext. If this fails,
        // we don't need to check for a null pointer because it throws an exception.

        CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);
        CComVariant  varValue;

        if (!pInstance->SetDateTime(pTimeStamp, WBEMTime(stUTCTime)))
            ErrorTrace(TRACE_ID, "SetDateTime on Timestamp Field failed.");

        if (!pInstance->SetCHString(pChange, L"Snapshot"))
            ErrorTrace(TRACE_ID, "SetCHString on Change Field failed.");

        (void)CopyProperty(pObj, L"GroupName", pInstance, pGroupName);
        (void)CopyProperty(pObj, L"Name", pInstance, pName);
        (void)CopyProperty(pObj, L"UserName", pInstance, pUsername);

    	hRes = pInstance->Commit();
        if (FAILED(hRes))
            ErrorTrace(TRACE_ID, "Commit on Instance failed.");
    }

END:
    TraceFunctLeave();
    return hRes ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprov\pch_printjob.h ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_PrintJob.H

Abstract:
	WBEM provider class definition for PCH_PrintJob class

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

********************************************************************/

// Property set identification
//============================

#ifndef _PCH_PrintJob_H_
#define _PCH_PrintJob_H_

#define PROVIDER_NAME_PCH_PRINTJOB "PCH_PrintJob"

// Property name externs -- defined in PCH_PrintJob.cpp
//=================================================

extern const WCHAR* pTimeStamp ;
extern const WCHAR* pChange ;
extern const WCHAR* pName ;
extern const WCHAR* pPagesPrinted ;
extern const WCHAR* pSize ;
extern const WCHAR* pStatus ;
extern const WCHAR* pTimeSubmitted ;

class CPCH_PrintJob : public Provider 
{
	public:
		// Constructor/destructor
		//=======================

		CPCH_PrintJob(const CHString& chsClassName, LPCWSTR lpszNameSpace) : Provider(chsClassName, lpszNameSpace) {};
		virtual ~CPCH_PrintJob() {};

	protected:
		// Reading Functions
		//============================
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Writing Functions
		//============================
		virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Other Functions
		virtual HRESULT ExecMethod( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags = 0L ) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprov\pch_programgroup.h ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_ProgramGroup.H

Abstract:
	WBEM provider class definition for PCH_ProgramGroup class

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

********************************************************************/

// Property set identification
//============================

#ifndef _PCH_ProgramGroup_H_
#define _PCH_ProgramGroup_H_

#define PROVIDER_NAME_PCH_PROGRAMGROUP "PCH_ProgramGroup"

// Property name externs -- defined in PCH_ProgramGroup.cpp
//=================================================

extern const WCHAR* pTimeStamp ;
extern const WCHAR* pChange ;
extern const WCHAR* pGroupName ;
extern const WCHAR* pName ;
extern const WCHAR* pUsername ;

class CPCH_ProgramGroup : public Provider 
{
	public:
		// Constructor/destructor
		//=======================

		CPCH_ProgramGroup(const CHString& chsClassName, LPCWSTR lpszNameSpace) : Provider(chsClassName, lpszNameSpace) {};
		virtual ~CPCH_ProgramGroup() {};

	protected:
		// Reading Functions
		//============================
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Writing Functions
		//============================
		virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Other Functions
		virtual HRESULT ExecMethod( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags = 0L ) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprov\pch_resourcedma.h ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_ResourceDMA.H

Abstract:
	WBEM provider class definition for PCH_ResourceDMA class

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

********************************************************************/

// Property set identification
//============================

#ifndef _PCH_ResourceDMA_H_
#define _PCH_ResourceDMA_H_

#define PROVIDER_NAME_PCH_RESOURCEDMA "PCH_ResourceDMA"

// Property name externs -- defined in PCH_ResourceDMA.cpp
//=================================================

extern const WCHAR* pCategory ;
extern const WCHAR* pTimeStamp ;
extern const WCHAR* pChange ;
extern const WCHAR* pChannel ;
extern const WCHAR* pMask ;
extern const WCHAR* pName ;

class CPCH_ResourceDMA : public Provider 
{
	public:
		// Constructor/destructor
		//=======================

		CPCH_ResourceDMA(const CHString& chsClassName, LPCWSTR lpszNameSpace) : Provider(chsClassName, lpszNameSpace) {};
		virtual ~CPCH_ResourceDMA() {};

	protected:
		// Reading Functions
		//============================
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Writing Functions
		//============================
		virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Other Functions
		virtual HRESULT ExecMethod( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags = 0L ) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprov\pch_resourceiorange.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_ResourceIORange.CPP

Abstract:
	WBEM provider class implementation for PCH_ResourceIORange class

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

********************************************************************/

#include "pchealth.h"
#include "PCH_ResourceIORange.h"
#include "confgmgr.h"

/////////////////////////////////////////////////////////////////////////////
//  tracing stuff

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile
#define TRACE_ID    DCID_RESOURCEIORANGE

CPCH_ResourceIORange MyPCH_ResourceIORangeSet (PROVIDER_NAME_PCH_RESOURCEIORANGE, PCH_NAMESPACE) ;

// Property names
//===============
const static WCHAR* pAlias = L"Alias" ;
const static WCHAR* pBase = L"Base" ;
const static WCHAR* pCategory = L"Category" ;
const static WCHAR* pTimeStamp = L"TimeStamp" ;
const static WCHAR* pChange = L"Change" ;
const static WCHAR* pDecode = L"Decode" ;
const static WCHAR* pEnd = L"End" ;
const static WCHAR* pMax = L"Max" ;
const static WCHAR* pMin = L"Min" ;
const static WCHAR* pName = L"Name" ;

/*****************************************************************************
*
*  FUNCTION    :    CPCH_ResourceIORange::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                       WBEM_FLAG_DEEP
*                       WBEM_FLAG_SHALLOW
*                       WBEM_FLAG_RETURN_IMMEDIATELY
*                       WBEM_FLAG_FORWARD_ONLY
*                       WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    : TO DO: All instances on the machine should be returned here.
*                       If there are no instances, return WBEM_S_NO_ERROR.
*                       It is not an error to have no instances.
*
*****************************************************************************/
HRESULT CPCH_ResourceIORange::EnumerateInstances(
    MethodContext* pMethodContext,
    long lFlags
    )
{
    TraceFunctEnter("CPCH_ResourceIRQ::EnumerateInstances");

    CConfigManager cfgManager;
    CDeviceCollection deviceList;
    HRESULT hRes = WBEM_S_NO_ERROR;
    //
    // Get the date and time
    //
	SYSTEMTIME stUTCTime;
	GetSystemTime(&stUTCTime);

    // get the device list
    if (cfgManager.GetDeviceList(deviceList)) 
    {
        REFPTR_POSITION pos;
    
        // Initialize device enumerator
        if (deviceList.BeginEnum(pos)) 
        {
            CConfigMgrDevice* pDevice = NULL;

            try
            {
                // Walk the list of devices
                while ((NULL != (pDevice = deviceList.GetNext(pos))))
                {
                    CIOCollection ioList;
                    try
                    {
                        // Get DMAChannel list for this device
                        if (pDevice->GetIOResources(ioList))
                        {
                            REFPTR_POSITION pos2;

                            // Initialize DMA enumerator
                            if (ioList.BeginEnum(pos2))
                            {
                                CIODescriptor *pIO = NULL;

                                // Walk the list of DMA
                                while (( NULL != (pIO = ioList.GetNext(pos2))))
                                {
                                    try
                                    {
                                        // Create a new instance based on the passed-in MethodContext
                                        CInstancePtr    pInstance(CreateNewInstance(pMethodContext), false);
                                        CHString        chstrVar;
                                        CComVariant     varValue;
                                        TCHAR           strTemp[64];

                                        // Timestamp
                                        if (!pInstance->SetDateTime(pTimeStamp, WBEMTime(stUTCTime)))
                                            ErrorTrace(TRACE_ID, "SetDateTime on Timestamp Field failed.");

                                        // Snapshot
                                        if (!pInstance->SetCHString(pChange, L"Snapshot"))
                                            ErrorTrace(TRACE_ID, "SetCHString on Change Field failed.");

                                        // Name
                                        if (pDevice->GetDeviceID(chstrVar))
                                            if (!pInstance->SetCHString(pName, chstrVar))
                                                ErrorTrace(TRACE_ID, "SetCHString on Name field failed.");

                                        // Category
                                        if (pDevice->GetClass(chstrVar))
                                            if (!pInstance->SetCHString(pCategory, chstrVar))
                                                ErrorTrace(TRACE_ID, "SetCHString on Category field failed.");

                                        // Base
                                        _stprintf(strTemp, "x%I64X", pIO->GetBaseAddress());
                                        varValue = strTemp;
                                        if (!pInstance->SetVariant(pBase, varValue))
                                            ErrorTrace(TRACE_ID, "SetVariant on Base field failed.");

                                        // End
                                        _stprintf(strTemp, "x%I64X", pIO->GetEndAddress());
                                        varValue = strTemp;
                                        if (!pInstance->SetVariant(pEnd, varValue))
                                            ErrorTrace(TRACE_ID, "SetVariant on End field failed.");

                                        // Alias
                                        varValue = (long)pIO->GetAlias();
                                        if (!pInstance->SetVariant(pAlias, varValue))
                                            ErrorTrace(TRACE_ID, "SetVariant on Alias field failed.");

                                        // Decode
                                        varValue = (long)pIO->GetDecode();
                                        if (!pInstance->SetVariant(pDecode, varValue))
                                            ErrorTrace(TRACE_ID, "SetVariant on Decode field failed.");

                                        // Commit this
                   	                    hRes = pInstance->Commit();
                                        if (FAILED(hRes))
                                            ErrorTrace(TRACE_ID, "Commit on Instance failed.");
                                    }
                                    catch (...)
                                    {
                                        pIO->Release();
                                        throw;
                                    }

                                    // release the DMA object
                                    pIO->Release();
                                }
                            }
                        }
                    }
                    catch (...)
                    {
                        pDevice->Release();
                        ioList.EndEnum();
                        throw;
                    }

                    // GetNext() AddRefs
                    pDevice->Release();

                    // Always call EndEnum().  For all Beginnings, there must be an End
                    ioList.EndEnum();
                }
            }
            catch (...)
            {
                deviceList.EndEnum();
                throw;
            }

            // Always call EndEnum().  For all Beginnings, there must be an End
            deviceList.EndEnum();
        }
    }
    
    TraceFunctLeave();
    return hRes ;

//            Missing data 
//            WMI does not give us min and max so we are not populating these in our class.
//
//            pInstance->SetVariant(pMax, <Property Value>);
//            pInstance->SetVariant(pMin, <Property Value>);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprov\pch_resourceirq.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    PCH_ResourceIRQ.CPP

Abstract:
    WBEM provider class implementation for PCH_ResourceIRQ class

Revision History:

    Ghim-Sim Chua       (gschua)   04/27/99
        - Created

********************************************************************/

#include "pchealth.h"
#include "PCH_ResourceIRQ.h"
#include "confgmgr.h"

/////////////////////////////////////////////////////////////////////////////
//  tracing stuff

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile
#define TRACE_ID    DCID_RESOURCEIRQ

CPCH_ResourceIRQ MyPCH_ResourceIRQSet (PROVIDER_NAME_PCH_RESOURCEIRQ, PCH_NAMESPACE) ;

// Property names
//===============
const static WCHAR* pCategory = L"Category" ;
const static WCHAR* pTimeStamp = L"TimeStamp" ;
const static WCHAR* pChange = L"Change" ;
const static WCHAR* pMask = L"Mask" ;
const static WCHAR* pName = L"Name" ;
const static WCHAR* pValue = L"Value" ;

/*****************************************************************************
*
*  FUNCTION    :    CPCH_ResourceIRQ::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                       WBEM_FLAG_DEEP
*                       WBEM_FLAG_SHALLOW
*                       WBEM_FLAG_RETURN_IMMEDIATELY
*                       WBEM_FLAG_FORWARD_ONLY
*                       WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    : TO DO: All instances on the machine should be returned here.
*                       If there are no instances, return WBEM_S_NO_ERROR.
*                       It is not an error to have no instances.
*
*****************************************************************************/
HRESULT CPCH_ResourceIRQ::EnumerateInstances(
    MethodContext* pMethodContext,
    long lFlags
    )
{
    TraceFunctEnter("CPCH_ResourceIRQ::EnumerateInstances");

    CConfigManager cfgManager;
    CDeviceCollection deviceList;
    HRESULT hRes = WBEM_S_NO_ERROR;
    //
    // Get the date and time
    //
    SYSTEMTIME stUTCTime;
    GetSystemTime(&stUTCTime);

    // get the device list
    if (cfgManager.GetDeviceList(deviceList)) 
    {
        REFPTR_POSITION pos;
    
        // Initialize device enumerator
        if (deviceList.BeginEnum(pos)) 
        {
            CConfigMgrDevice* pDevice = NULL;

            try
            {
                // Walk the list of devices
                while ((NULL != (pDevice = deviceList.GetNext(pos))))
                {
                    CIRQCollection irqList;

                    try
                    {
                        // Get DMAChannel list for this device
                        if (pDevice->GetIRQResources(irqList))
                        {
                            REFPTR_POSITION pos2;

                            // Initialize DMA enumerator
                            if (irqList.BeginEnum(pos2))
                            {
                                CIRQDescriptor *pIRQ = NULL;

                                // Walk the list of DMA
                                while (( NULL != (pIRQ = irqList.GetNext(pos2))))
                                {
                                    try
                                    {
                                        // Create a new instance based on the passed-in MethodContext
                                        CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);
                                        CHString     chstrVar;
                                        CComVariant  varValue;

                                        // Timestamp
                                        if (!pInstance->SetDateTime(pTimeStamp, WBEMTime(stUTCTime)))
                                            ErrorTrace(TRACE_ID, "SetDateTime on Timestamp Field failed.");

                                        // Snapshot
                                        if (!pInstance->SetCHString(pChange, L"Snapshot"))
                                            ErrorTrace(TRACE_ID, "SetCHString on Change Field failed.");

                                        // Name
                                        if (pDevice->GetDeviceID(chstrVar))
                                            if (!pInstance->SetCHString(pName, chstrVar))
                                                ErrorTrace(TRACE_ID, "SetCHString on Name field failed.");

                                        // Category
                                        if (pDevice->GetClass(chstrVar))
                                            if (!pInstance->SetCHString(pCategory, chstrVar))
                                                ErrorTrace(TRACE_ID, "SetCHString on Category field failed.");

                                        // Value
                                        varValue = (long)pIRQ->GetInterrupt();
                                        if (!pInstance->SetVariant(pValue, varValue))
                                            ErrorTrace(TRACE_ID, "SetVariant on Value field failed.");

                                        // Mask
                                        varValue = (long)pIRQ->GetFlags();
                                        if (!pInstance->SetVariant(pMask, varValue))
                                            ErrorTrace(TRACE_ID, "SetVariant on Mask field failed.");

                                        // Commit this
                                        hRes = pInstance->Commit();
                                        if (FAILED(hRes))
                                            ErrorTrace(TRACE_ID, "Commit on Instance failed.");
                                    }
                                    catch (...)
                                    {
                                        pIRQ->Release();
                                        throw;
                                    }

                                    // release the DMA object
                                    pIRQ->Release();
                                }
                            }
                        }
                    }
                    catch (...)
                    {
                        pDevice->Release();
                        irqList.EndEnum();
                        throw;
                    }

                    // GetNext() AddRefs
                    pDevice->Release();

                    // Always call EndEnum().  For all Beginnings, there must be an End
                    irqList.EndEnum();
                }
            }
            catch (...)
            {
                deviceList.EndEnum();
                throw;
            }

            // Always call EndEnum().  For all Beginnings, there must be an End
            deviceList.EndEnum();
        }
    }
    
    TraceFunctLeave();
    return hRes ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprov\pch_resourcedma.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_ResourceDMA.CPP

Abstract:
	WBEM provider class implementation for PCH_ResourceDMA class

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

********************************************************************/

#include "pchealth.h"
#include "PCH_ResourceDMA.h"
#include "confgmgr.h"

/////////////////////////////////////////////////////////////////////////////
//  tracing stuff

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile
#define TRACE_ID    DCID_RESOURCEDMA

CPCH_ResourceDMA MyPCH_ResourceDMASet (PROVIDER_NAME_PCH_RESOURCEDMA, PCH_NAMESPACE) ;

// Property names
//===============
const static WCHAR* pCategory = L"Category" ;
const static WCHAR* pTimeStamp = L"TimeStamp" ;
const static WCHAR* pChange = L"Change" ;
const static WCHAR* pChannel = L"Channel" ;
const static WCHAR* pMask = L"Mask" ;
const static WCHAR* pName = L"Name" ;

/*****************************************************************************
*
*  FUNCTION    :    CPCH_ResourceDMA::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                       WBEM_FLAG_DEEP
*                       WBEM_FLAG_SHALLOW
*                       WBEM_FLAG_RETURN_IMMEDIATELY
*                       WBEM_FLAG_FORWARD_ONLY
*                       WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    : TO DO: All instances on the machine should be returned here.
*                       If there are no instances, return WBEM_S_NO_ERROR.
*                       It is not an error to have no instances.
*
*****************************************************************************/
HRESULT CPCH_ResourceDMA::EnumerateInstances(
    MethodContext* pMethodContext,
    long lFlags
    )
{
    TraceFunctEnter("CPCH_ResourceDMA::EnumerateInstances");

    CConfigManager cfgManager;
    CDeviceCollection deviceList;
    HRESULT hRes = WBEM_S_NO_ERROR;
    //
    // Get the date and time
    //
	SYSTEMTIME stUTCTime;
	GetSystemTime(&stUTCTime);

    // get the device list
    if (cfgManager.GetDeviceList(deviceList)) 
    {
        REFPTR_POSITION pos;
    
        // Initialize device enumerator
        if (deviceList.BeginEnum(pos)) 
        {
            CConfigMgrDevice* pDevice = NULL;
        
            try
            {
                // Walk the list of devices
                while ((NULL != (pDevice = deviceList.GetNext(pos))))
                {
                    CDMACollection dmaList;

                    try
                    {
                       // Get DMAChannel list for this device
                        if (pDevice->GetDMAResources(dmaList))
                        {
                            REFPTR_POSITION pos2;

                            // Initialize DMA enumerator
                            if (dmaList.BeginEnum(pos2))
                            {
                                CDMADescriptor *pDMA = NULL;

                                // Walk the list of DMA
                                while (( NULL != (pDMA = dmaList.GetNext(pos2))))
                                {
                                    try
                                    {
                                        // Create a new instance based on the passed-in MethodContext
                                        CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);
                                        CHString     chstrVar;
                                        CComVariant  varValue;

                                        // Timestamp
                                        if (!pInstance->SetDateTime(pTimeStamp, WBEMTime(stUTCTime)))
                                            ErrorTrace(TRACE_ID, "SetDateTime on Timestamp Field failed.");

                                        // Snapshot
                                        if (!pInstance->SetCHString(pChange, L"Snapshot"))
                                            ErrorTrace(TRACE_ID, "SetCHString on Change Field failed.");

                                        // Name
                                        if (pDevice->GetDeviceID(chstrVar))
                                            if (!pInstance->SetCHString(pName, chstrVar))
                                                ErrorTrace(TRACE_ID, "SetCHString on Name field failed.");

                                        // Category
                                        if (pDevice->GetClass(chstrVar))
                                            if (!pInstance->SetCHString(pCategory, chstrVar))
                                                ErrorTrace(TRACE_ID, "SetCHString on Category field failed.");

                                        // Channel
                                        varValue = (long)pDMA->GetChannel();
                                        if (!pInstance->SetVariant(pChannel, varValue))
                                            ErrorTrace(TRACE_ID, "SetVariant on Channel field failed.");

                                        // Mask
                                        varValue = (long)pDMA->GetFlags();
                                        if (!pInstance->SetVariant(pMask, varValue))
                                            ErrorTrace(TRACE_ID, "SetVariant on Mask field failed.");

                                        // Commit this
                       	                hRes = pInstance->Commit();
                                        if (FAILED(hRes))
                                            ErrorTrace(TRACE_ID, "Commit on Instance failed.");
                                    }
                                    catch (...)
                                    {
                                        pDMA->Release();
                                        throw;
                                    }

                                    // release the DMA object
                                    pDMA->Release();
                                }
                            }
                        }
                    }
                    catch (...)
                    {
                        pDevice->Release();
                        dmaList.EndEnum();
                        throw;
                    }

                    // GetNext() AddRefs
                    pDevice->Release();

                    // Always call EndEnum().  For all Beginnings, there must be an End
                    dmaList.EndEnum();
                }
            }
            catch (...)
            {
                deviceList.EndEnum();
                throw;
            }

            // Always call EndEnum().  For all Beginnings, there must be an End
            deviceList.EndEnum();
        }
    }
    
    TraceFunctLeave();
    return hRes ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprov\pch_resourceiorange.h ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_ResourceIORange.H

Abstract:
	WBEM provider class definition for PCH_ResourceIORange class

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

********************************************************************/

// Property set identification
//============================

#ifndef _PCH_ResourceIORange_H_
#define _PCH_ResourceIORange_H_

#define PROVIDER_NAME_PCH_RESOURCEIORANGE "PCH_ResourceIORange"

// Property name externs -- defined in PCH_ResourceIORange.cpp
//=================================================

extern const WCHAR* pAlias ;
extern const WCHAR* pBase ;
extern const WCHAR* pCategory ;
extern const WCHAR* pTimeStamp ;
extern const WCHAR* pChange ;
extern const WCHAR* pDecode ;
extern const WCHAR* pEnd ;
extern const WCHAR* pMax ;
extern const WCHAR* pMin ;
extern const WCHAR* pName ;

class CPCH_ResourceIORange : public Provider 
{
	public:
		// Constructor/destructor
		//=======================

		CPCH_ResourceIORange(const CHString& chsClassName, LPCWSTR lpszNameSpace) : Provider(chsClassName, lpszNameSpace) {};
		virtual ~CPCH_ResourceIORange() {};

	protected:
		// Reading Functions
		//============================
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Writing Functions
		//============================
		virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Other Functions
		virtual HRESULT ExecMethod( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags = 0L ) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprov\pch_resourcememrange.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_ResourceMemRange.CPP

Abstract:
	WBEM provider class implementation for PCH_ResourceMemRange class

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

********************************************************************/

#include "pchealth.h"
#include "PCH_ResourceMemRange.h"
#include "confgmgr.h"

/////////////////////////////////////////////////////////////////////////////
//  tracing stuff

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile
#define TRACE_ID    DCID_RESOURCEMEMRANGE

CPCH_ResourceMemRange MyPCH_ResourceMemRangeSet (PROVIDER_NAME_PCH_RESOURCEMEMRANGE, PCH_NAMESPACE) ;

// Property names
//===============
const static WCHAR* pBase = L"Base" ;
const static WCHAR* pCategory = L"Category" ;
const static WCHAR* pTimeStamp = L"TimeStamp" ;
const static WCHAR* pChange = L"Change" ;
const static WCHAR* pEnd = L"End" ;
const static WCHAR* pMax = L"Max" ;
const static WCHAR* pMin = L"Min" ;
const static WCHAR* pName = L"Name" ;

/*****************************************************************************
*
*  FUNCTION    :    CPCH_ResourceMemRange::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                       WBEM_FLAG_DEEP
*                       WBEM_FLAG_SHALLOW
*                       WBEM_FLAG_RETURN_IMMEDIATELY
*                       WBEM_FLAG_FORWARD_ONLY
*                       WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    : TO DO: All instances on the machine should be returned here.
*                       If there are no instances, return WBEM_S_NO_ERROR.
*                       It is not an error to have no instances.
*
*****************************************************************************/
HRESULT CPCH_ResourceMemRange::EnumerateInstances(
    MethodContext* pMethodContext,
    long lFlags
    )
{
    TraceFunctEnter("CPCH_ResourceIRQ::EnumerateInstances");

    CConfigManager cfgManager;
    CDeviceCollection deviceList;
    HRESULT hRes = WBEM_S_NO_ERROR;
    //
    // Get the date and time
    //
	SYSTEMTIME stUTCTime;
	GetSystemTime(&stUTCTime);

    // get the device list
    if (cfgManager.GetDeviceList(deviceList)) 
    {
        REFPTR_POSITION pos;
    
        // Initialize device enumerator
        if (deviceList.BeginEnum(pos)) 
        {
            CConfigMgrDevice* pDevice = NULL;

            try
            {
                // Walk the list of devices
                while ((NULL != (pDevice = deviceList.GetNext(pos))))
                {
                    CDeviceMemoryCollection memList;

                    try
                    {
                        // Get DMAChannel list for this device
                        if (pDevice->GetDeviceMemoryResources(memList))
                        {
                            REFPTR_POSITION pos2;

                            // Initialize DMA enumerator
                            if (memList.BeginEnum(pos2))
                            {
                                CDeviceMemoryDescriptor *pMem = NULL;

                                // Walk the list of DMA
                                while (( NULL != (pMem = memList.GetNext(pos2))))
                                {
                                    try
                                    {
                                        // Create a new instance based on the passed-in MethodContext
                                        CInstancePtr    pInstance(CreateNewInstance(pMethodContext), false);
                                        CHString        chstrVar;
                                        CComVariant     varValue;
                                        TCHAR           strTemp[64];

                                        // Timestamp
                                        if (!pInstance->SetDateTime(pTimeStamp, WBEMTime(stUTCTime)))
                                            ErrorTrace(TRACE_ID, "SetDateTime on Timestamp Field failed.");

                                        // Snapshot
                                        if (!pInstance->SetCHString(pChange, L"Snapshot"))
                                            ErrorTrace(TRACE_ID, "SetCHString on Change Field failed.");

                                        // Name
                                        if (pDevice->GetDeviceID(chstrVar))
                                            if (!pInstance->SetCHString(pName, chstrVar))
                                                ErrorTrace(TRACE_ID, "SetCHString on Name field failed.");

                                        // Category
                                        if (pDevice->GetClass(chstrVar))
                                            if (!pInstance->SetCHString(pCategory, chstrVar))
                                                ErrorTrace(TRACE_ID, "SetCHString on Category field failed.");

                                        // Base
                                        _stprintf(strTemp, "x%I64X", pMem->GetBaseAddress());
                                        varValue = strTemp;
                                        if (!pInstance->SetVariant(pBase, varValue))
                                            ErrorTrace(TRACE_ID, "SetVariant on Base field failed.");

                                        // End
                                        _stprintf(strTemp, "x%I64X", pMem->GetEndAddress());
                                        varValue = strTemp;
                                        if (!pInstance->SetVariant(pEnd, varValue))
                                            ErrorTrace(TRACE_ID, "SetVariant on End field failed.");
            /*
                                        // Alias
                                        varValue = (long)pMem->GetAlias();
                                        if (!pInstance->SetVariant(pAlias, varValue))
                                            ErrorTrace(TRACE_ID, "SetVariant on Alias field failed.");

                                        // Decode
                                        varValue = (long)pMem->GetDecode();
                                        if (!pInstance->SetVariant(pDecode, varValue))
                                            ErrorTrace(TRACE_ID, "SetVariant on Decode field failed.");
            */
                                        // Commit this
                   	                    hRes = pInstance->Commit();
                                        if (FAILED(hRes))
                                            ErrorTrace(TRACE_ID, "Commit on Instance failed.");
                                    }
                                    catch (...)
                                    {
                                        pMem->Release();
                                        throw;
                                    }

                                    // release the DMA object
                                    pMem->Release();
                                }
                            }
                        }
                    }
                    catch (...)
                    {
                        pDevice->Release();
                        memList.EndEnum();
                        throw;
                    }

                    // GetNext() AddRefs
                    pDevice->Release();

                    // Always call EndEnum().  For all Beginnings, there must be an End
                    memList.EndEnum();
                }
            }
            catch (...)
            {
                deviceList.EndEnum();
                throw;
            }

            // Always call EndEnum().  For all Beginnings, there must be an End
            deviceList.EndEnum();
        }
    }
    
    TraceFunctLeave();
    return hRes ;

//            pInstance->SetVariant(pBase, <Property Value>);
//            pInstance->SetVariant(pCategory, <Property Value>);
//			  pInstance->SetVariant(pTimeStamp, <Property Value>);
//            pInstance->SetVariant(pChange, <Property Value>);
//            pInstance->SetVariant(pEnd, <Property Value>);
//            pInstance->SetVariant(pMax, <Property Value>);
//            pInstance->SetVariant(pMin, <Property Value>);
//            pInstance->SetVariant(pName, <Property Value>);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprov\pch_resourceirq.h ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_ResourceIRQ.H

Abstract:
	WBEM provider class definition for PCH_ResourceIRQ class

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

********************************************************************/

// Property set identification
//============================

#ifndef _PCH_ResourceIRQ_H_
#define _PCH_ResourceIRQ_H_

#define PROVIDER_NAME_PCH_RESOURCEIRQ "PCH_ResourceIRQ"

// Property name externs -- defined in PCH_ResourceIRQ.cpp
//=================================================

extern const WCHAR* pCategory ;
extern const WCHAR* pTimeStamp ;
extern const WCHAR* pChange ;
extern const WCHAR* pMask ;
extern const WCHAR* pName ;
extern const WCHAR* pValue ;

class CPCH_ResourceIRQ : public Provider 
{
	public:
		// Constructor/destructor
		//=======================

		CPCH_ResourceIRQ(const CHString& chsClassName, LPCWSTR lpszNameSpace) : Provider(chsClassName, lpszNameSpace) {};
		virtual ~CPCH_ResourceIRQ() {};

	protected:
		// Reading Functions
		//============================
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Writing Functions
		//============================
		virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Other Functions
		virtual HRESULT ExecMethod( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags = 0L ) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprov\pch_resourcememrange.h ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_ResourceMemRange.H

Abstract:
	WBEM provider class definition for PCH_ResourceMemRange class

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

********************************************************************/

// Property set identification
//============================

#ifndef _PCH_ResourceMemRange_H_
#define _PCH_ResourceMemRange_H_

#define PROVIDER_NAME_PCH_RESOURCEMEMRANGE "PCH_ResourceMemRange"

// Property name externs -- defined in PCH_ResourceMemRange.cpp
//=================================================

extern const WCHAR* pBase ;
extern const WCHAR* pCategory ;
extern const WCHAR* pTimeStamp ;
extern const WCHAR* pChange ;
extern const WCHAR* pEnd ;
extern const WCHAR* pMax ;
extern const WCHAR* pMin ;
extern const WCHAR* pName ;

class CPCH_ResourceMemRange : public Provider 
{
	public:
		// Constructor/destructor
		//=======================

		CPCH_ResourceMemRange(const CHString& chsClassName, LPCWSTR lpszNameSpace) : Provider(chsClassName, lpszNameSpace) {};
		virtual ~CPCH_ResourceMemRange() {};

	protected:
		// Reading Functions
		//============================
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Writing Functions
		//============================
		virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Other Functions
		virtual HRESULT ExecMethod( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags = 0L ) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprov\pch_runningtask.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    PCH_RunningTask.CPP

Abstract:
    WBEM provider class implementation for PCH_RunningTask class

Revision History:

    Ghim-Sim Chua       (gschua)   04/27/99
        - Created

    Jim Martin          (a-jammar) 04/30/99
        - Updated to retrieve file info from CIM_DataFile

********************************************************************/

#include "pchealth.h"
#include "PCH_RunningTask.h"
#include <tlhelp32.h>

/////////////////////////////////////////////////////////////////////////////
//  tracing stuff

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile
#define TRACE_ID    DCID_RUNNINGTASK

CPCH_RunningTask MyPCH_RunningTaskSet (PROVIDER_NAME_PCH_RUNNINGTASK, PCH_NAMESPACE) ;

// Property names
//===============

const static WCHAR * pAddress = L"Address" ;
const static WCHAR * pTimeStamp = L"TimeStamp" ;
const static WCHAR * pChange = L"Change" ;
const static WCHAR * pDate = L"Date" ;
const static WCHAR * pDescription = L"Description" ;
const static WCHAR * pManufacturer = L"Manufacturer" ;
const static WCHAR * pName = L"Name" ;
const static WCHAR * pPartOf = L"PartOf" ;
const static WCHAR * pPath = L"Path" ;
const static WCHAR * pSize = L"Size" ;
const static WCHAR * pType = L"Type" ;
const static WCHAR * pVersion = L"Version" ;

//-----------------------------------------------------------------------------
// Gets the process ID (for use with Win32 APIs) for the specified executable.
// The hToolhelp parameter is the handle returned by a call to 
// CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0).
//
// Note: if the same executable is loaded more than once, the process ID for
// the first one encountered is returned. 
//-----------------------------------------------------------------------------

typedef BOOL (*PROCENUM)(HANDLE, LPPROCESSENTRY32);

HRESULT GetProcessID(HINSTANCE hKernel32, HANDLE hToolhelp, LPCSTR szFile, DWORD * pdwProcessID)
{
    TraceFunctEnter("::GetProcessID");

    HRESULT         hRes = E_FAIL;
    PROCESSENTRY32  pe;
    PROCENUM        ProcFirst, ProcNext;

    ProcFirst = (PROCENUM) ::GetProcAddress(hKernel32, "Process32First");
    ProcNext = (PROCENUM) ::GetProcAddress(hKernel32, "Process32Next");

    pe.dwSize = sizeof(PROCESSENTRY32);
    if (ProcFirst && ProcNext && (ProcFirst)(hToolhelp, &pe))
        do
        {
            if (0 == _stricmp(szFile, pe.szExeFile))
            {
                hRes = S_OK;
                *pdwProcessID = pe.th32ProcessID;
                break;
            }
        } while ((ProcNext)(hToolhelp, &pe));

    TraceFunctLeave();
    return hRes;
}

//-----------------------------------------------------------------------------
// The EnumerateInstances member function is responsible for reporting each
// instance of the PCH_RunningTask class. This is done by performing a query
// against CIMV2 for all of the Win32_Process instances. Each process instance
// corresponds to a running task, and is used to find a CIM_DataFile instance
// to report file information for each running task.
//-----------------------------------------------------------------------------

typedef HANDLE (*CTH32)(DWORD, DWORD);

HRESULT CPCH_RunningTask::EnumerateInstances(MethodContext* pMethodContext, long lFlags)
{
    TraceFunctEnter("CPCH_RunningTask::EnumerateInstances");

    HRESULT hRes = WBEM_S_NO_ERROR;
    LPSTR szFile;
    USES_CONVERSION;

    // Get the date and time for the time stamp.

    SYSTEMTIME stUTCTime;
    GetSystemTime(&stUTCTime);

    // Create a toolhelp snapshot to get process information. We need to dynamically
    // link to the function, because it might not be present on all platforms.

    HANDLE hToolhelp = (HANDLE) -1;
    HINSTANCE hKernel32 = ::LoadLibrary("kernel32");
    if (hKernel32)
    {
        CTH32 CrtToolhelp32 = (CTH32) ::GetProcAddress(hKernel32, "CreateToolhelp32Snapshot"); 
        if (CrtToolhelp32)
            hToolhelp = (*CrtToolhelp32)(TH32CS_SNAPPROCESS, 0);
    }

    // Execute the query against the Win32_Process class. This will give us the
    // list of processes running - then we'll get file information for each of
    // the processes.

    try
    {
        CFileVersionInfo fileversioninfo;
        CComPtr<IEnumWbemClassObject> pEnumInst;
        CComBSTR bstrQuery("SELECT Caption, ExecutablePath FROM Win32_Process");

        hRes = ExecWQLQuery(&pEnumInst, bstrQuery);
        if (FAILED(hRes))
            goto END;

        // Enumerate each instance of the Win32_Process query.

        IWbemClassObjectPtr pObj;
        ULONG               ulRetVal;

        // CODEWORK: this shouldn't really use WBEM_INFINITE

        while (WBEM_S_NO_ERROR == pEnumInst->Next(WBEM_INFINITE, 1, &pObj, &ulRetVal))
        {
            CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);

            // Use the system time to set the timestamp property, and set
            // the "Change" field to "Snapshot".

		    if (!pInstance->SetDateTime(pTimeStamp, WBEMTime(stUTCTime)))
                ErrorTrace(TRACE_ID, "SetDateTime on Timestamp Field failed.");

            if (!pInstance->SetCHString(pChange, L"Snapshot"))
                ErrorTrace(TRACE_ID, "SetCHString on Change Field failed.");

            // Copy each property which transfers directly from the source
            // class object to the destination CInstance object.

            CopyProperty(pObj, L"Caption", pInstance, pName);
            CopyProperty(pObj, L"ExecutablePath", pInstance, pPath);

            // Get the "ExecutablePath" property, which we'll use to find the
            // appropriate CIM_DataFile object.

            CComVariant varValue;
            CComBSTR    bstrExecutablePath("ExecutablePath");

		    if (FAILED(pObj->Get(bstrExecutablePath, 0, &varValue, NULL, NULL)))
                ErrorTrace(TRACE_ID, "GetVariant on ExecutablePath field failed.");
            else
            {
                CComPtr<IWbemClassObject>	pFileObj;
			    CComBSTR					ccombstrValue(V_BSTR(&varValue));
                if (SUCCEEDED(GetCIMDataFile(ccombstrValue, &pFileObj)))
                {
                    // Using the CIM_DataFile object, copy over the appropriate properties.

                    CopyProperty(pFileObj, L"Version", pInstance, pVersion);
                    CopyProperty(pFileObj, L"FileSize", pInstance, pSize);
                    CopyProperty(pFileObj, L"CreationDate", pInstance, pDate);
                    CopyProperty(pFileObj, L"Manufacturer", pInstance, pManufacturer);
                }

                // Use the CFileVersionInfo object to get version attributes.

                if (SUCCEEDED(fileversioninfo.QueryFile(ccombstrValue)))
                {
                    if (!pInstance->SetCHString(pDescription, fileversioninfo.GetDescription()))
                        ErrorTrace(TRACE_ID, "SetCHString on description field failed.");

                    if (!pInstance->SetCHString(pPartOf, fileversioninfo.GetProduct()))
                        ErrorTrace(TRACE_ID, "SetCHString on partof field failed.");
                }

                // Use the toolhelp handle to get the type.

                if (hToolhelp != (HANDLE) -1)
                {
                    szFile = W2A(ccombstrValue);
                    if (szFile)
                    {
                        DWORD dwProcessID;
                        if (SUCCEEDED(GetProcessID(hKernel32, hToolhelp, szFile, &dwProcessID)))
                        {
                            TCHAR   szBuffer[20];
                            DWORD   dwVersion;

                            dwVersion = GetProcessVersion(dwProcessID);
                            wsprintf(szBuffer, _T("%d.%d"), HIWORD(dwVersion), LOWORD(dwVersion));
                            if (!pInstance->SetCHString(pType, szBuffer))
                                ErrorTrace(TRACE_ID, "SetCHString on type field failed.");
                        }
                    }
                }
            }

            // After all the properties are set, release the instance of the
            // class we're getting data from, and commit the new instance.

   	        hRes = pInstance->Commit();
            if (FAILED(hRes))
                ErrorTrace(TRACE_ID, "Commit on Instance failed.");
        }
    }
	catch (...)
	{
        if ((HANDLE)-1 != hToolhelp)
            CloseHandle(hToolhelp);

        if (hKernel32)
            FreeLibrary(hKernel32);

        throw;
	}

END:
    if ((HANDLE)-1 != hToolhelp)
        CloseHandle(hToolhelp);

    if (hKernel32)
        FreeLibrary(hKernel32);

    TraceFunctLeave();
    return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprov\pch_runningtask.h ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_RunningTask.H

Abstract:
	WBEM provider class definition for PCH_RunningTask class

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

********************************************************************/

// Property set identification
//============================

#ifndef _PCH_RunningTask_H_
#define _PCH_RunningTask_H_

#define PROVIDER_NAME_PCH_RUNNINGTASK "PCH_RunningTask"

// Property name externs -- defined in PCH_RunningTask.cpp
//=================================================

extern const WCHAR* pAddress ;
extern const WCHAR* pTimeStamp ;
extern const WCHAR* pChange ;
extern const WCHAR* pDate ;
extern const WCHAR* pDescription ;
extern const WCHAR* pManufacturer ;
extern const WCHAR* pName ;
extern const WCHAR* pPartOf ;
extern const WCHAR* pPath ;
extern const WCHAR* pSize ;
extern const WCHAR* pType ;
extern const WCHAR* pVersion ;

class CPCH_RunningTask : public Provider 
{
	public:
		// Constructor/destructor
		//=======================

		CPCH_RunningTask(const CHString& chsClassName, LPCWSTR lpszNameSpace) : Provider(chsClassName, lpszNameSpace) {};
		virtual ~CPCH_RunningTask() {};

	protected:
		// Reading Functions
		//============================
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Writing Functions
		//============================
		virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Other Functions
		virtual HRESULT ExecMethod( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags = 0L ) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprov\pch_startup.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_StartUp.CPP

Abstract:
	WBEM provider class implementation for PCH_StartUp class

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

********************************************************************/

#include "pchealth.h"
#include "PCH_StartUp.h"
#include "shlobj.h"

/////////////////////////////////////////////////////////////////////////////
//  tracing stuff

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile
#define TRACE_ID    DCID_STARTUP

CPCH_StartUp MyPCH_StartUpSet (PROVIDER_NAME_PCH_STARTUP, PCH_NAMESPACE) ;

// Property names
//===============
const static WCHAR* pTimeStamp   = L"TimeStamp" ;
const static WCHAR* pChange      = L"Change" ;
const static WCHAR* pCommand     = L"Command" ;
const static WCHAR* pLoadedFrom  = L"LoadedFrom" ;
const static WCHAR* pName        = L"Name" ;


//**************************************************************************************
//
//  ResolveLink  :  Given the link file with complete Path, this function  resolves it 
//                  to  get its command line.
//**************************************************************************************

HRESULT ResolveLink(CComBSTR bstrLinkFile,   // [in] link filename
                CComBSTR &bstrCommand        // [out] cmd line of program
                                             // needs to be MAX_PATH*2 bytes long
               )
{ 
    //  Begin Declarations

    HRESULT                             hRes; 
    IShellLink                          *pShellLink                   = NULL;
    IPersistFile                        *pPersistFile;
    TCHAR                               tchGotPath[MAX_PATH]; 
    TCHAR                               tchArgs[MAX_PATH];
    WIN32_FIND_DATA                     wfdFileData;  

    //   End Declarations

    // Get a pointer to the IShellLink interface. 
    hRes = CoCreateInstance(CLSID_ShellLink, NULL, 
                            CLSCTX_INPROC_SERVER,
                            IID_IShellLink, 
                            (LPVOID *) &pShellLink); 

    if(SUCCEEDED(hRes)) 
    { 
        // Get a pointer to the IPersistFile interface. 
        hRes = pShellLink->QueryInterface(IID_IPersistFile, (void **)&pPersistFile);
        if (SUCCEEDED(hRes))
        {
            // Load the shortcut. 
            hRes = pPersistFile->Load(bstrLinkFile, STGM_READ);
            if(SUCCEEDED(hRes)) 
            { 
                try
                {
                    // Resolve the link. 
                    hRes = pShellLink->Resolve(NULL, 
                                    SLR_NOTRACK|SLR_NOSEARCH|SLR_NO_UI|SLR_NOUPDATE); 
                    if (SUCCEEDED(hRes))
                    {  
                        // Get the path to the link target. 
                        hRes = pShellLink->GetPath(tchGotPath, 
                                        MAX_PATH,
                                        (WIN32_FIND_DATA *)&wfdFileData, 
                                        SLGP_UNCPRIORITY );                     
                        if(SUCCEEDED(hRes))
                        {
                            // bstrPath = tchGotPath;
                            bstrCommand = tchGotPath;
                            // Get cmd line arguments
                            hRes = pShellLink->GetArguments(tchArgs, MAX_PATH);
                            if(SUCCEEDED(hRes))
                            {   
                                bstrCommand.Append(tchArgs);
                            }
                        }
                    }
                }
                catch(...)
                {
                    pPersistFile->Release();
                    pShellLink->Release();
                    throw;
                }
            }        

            // Release the pointer to the IPersistFile interface. 
            pPersistFile->Release(); 
        }
         
        // Release the pointer to the IShellLink interface.     
        pShellLink->Release(); 
    } 
    return hRes;
}

//**************************************************************************************
//
//  UpdateInstance  :  Given all the properties for the instance this function copies 
//                     them to the instance.
//
//**************************************************************************************

HRESULT         UpdateInstance(
                               CComVariant      varName,                // [in]  Name of the Startup Instance
                               CComVariant      varLoadedFrom,          // [in]  Registry/StartupGroup
                               CComVariant      varCommand,             // [in]  Command of the startup Instance
                               SYSTEMTIME       stUTCTime,              // [in]  
                               CInstancePtr     pPCHStartupInstance,     // [in/out] Instance is created by the caller.
                               BOOL*            fCommit
                               )
{
    TraceFunctEnter("::updateInstance");

    HRESULT                     hRes;
    CComVariant                 varSnapshot             = "SnapShot";
    
    hRes = pPCHStartupInstance->SetDateTime(pTimeStamp, WBEMTime(stUTCTime));
    if (FAILED(hRes))
    {
         //  Could not Set the Time Stamp
         //  Continue anyway
         ErrorTrace(TRACE_ID, "SetDateTime on Timestamp Field failed.");
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //                              CHANGE                                                                     //
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////

    hRes = pPCHStartupInstance->SetVariant(pChange, varSnapshot);
    if (FAILED(hRes))
    {
        //  Could not Set the CHANGE property
        //  Continue anyway
        ErrorTrace(TRACE_ID, "Set Variant on SnapShot Field failed.");
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //                              NAME                                                                       //
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////


    hRes = pPCHStartupInstance->SetVariant(pName, varName);
    if (FAILED(hRes))
    {
        //  Could not Set the NAME property
        //  Continue anyway
        ErrorTrace(TRACE_ID, "SetVariant on Name Field failed.");
    }
    else
    {
        *fCommit = TRUE;
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //                              LOADEDFROM                                                                 //
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////


    hRes = pPCHStartupInstance->SetVariant(pLoadedFrom, varLoadedFrom);
    if (FAILED(hRes))
    {
        //  Could not Set the LOADEDFROM property
        //  Continue anyway
        ErrorTrace(TRACE_ID, "Set variant on LOADEDFROM Field failed.");
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //                              COMMAND                                                                    //
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////

    hRes = pPCHStartupInstance->SetVariant(pCommand, varCommand);
    if (FAILED(hRes))
    {
        //  Could not Set the COMMAND property
        //  Continue anyway
        ErrorTrace(TRACE_ID, "Set Variant on COMMAND Field failed.");
    }
                
    
    TraceFunctLeave();
    return(hRes);

}

//**************************************************************************************
//
//  UpdateRegistryInstance  :  Given the Registry Root and the Hive this function creates 
//                             as many instances of PCH_StartUp Class as there are 
//                             entries in the particular hive.
//
//**************************************************************************************

HRESULT         CPCH_StartUp::UpdateRegistryInstance(
                               HKEY             hkeyRoot,                   // [in]  For now this is either HKLM or HKCU
                               LPCTSTR          lpctstrRegistryHive,        // [in]  Registry hive to look for startup entries
                               CComVariant      varLoadedFrom,              // [in]  Constant string to fill the property "Loaded From"
                               SYSTEMTIME       stUTCTime,                  // [in]  To fill up the "Timestamp" Field
                               MethodContext*   pMethodContext              // [in]  Required to create Instances.
                               )
{
    TraceFunctEnter("::UpdateRegistryInstance");

    //  Begin Declarations

    HRESULT                             hRes;

    HKEY                                hkeyRun;

    DWORD                               dwIndex;
    DWORD                               dwType;
    DWORD                               dwNameSize;
    DWORD                               dwValueSize;

    TCHAR                               tchRunKeyName[MAX_PATH];
    TCHAR                               tchRunKeyValue[MAX_PATH];
  

    CComVariant                         varSnapshot                         = "SnapShot";
    CComVariant                         varCommand;
    CComVariant                         varName;

    LONG                                lregRetValue;

    BOOL                                fCommit                             = FALSE;

    

    //  End Declarations
    //  Initializations
    varCommand.Clear();
    varName.Clear();

    //  Get the startup progrmas from  the given registry Hive
   
    lregRetValue = RegOpenKeyEx(hkeyRoot, lpctstrRegistryHive, 0, KEY_QUERY_VALUE, &hkeyRun);
    if(lregRetValue == ERROR_SUCCESS)
	{
		//  Opened the Registry key.
        //  Enumerate the Name, Value pairs under this hive. 
        //  Initialize dwIndex, dwNameSize, dwValueSize

        dwIndex = 0;
        dwNameSize = MAX_PATH;
        dwValueSize = MAX_PATH;
        lregRetValue = RegEnumValue(hkeyRun, dwIndex, tchRunKeyName, &dwNameSize, NULL, NULL,(LPBYTE)tchRunKeyValue, &dwValueSize);
        while(lregRetValue == ERROR_SUCCESS)
        {
            //  Got the Name and Value i.e "NAME" and "COMMAND"
            varName = tchRunKeyName;
            varCommand = tchRunKeyValue;
            
            //  Create an instance of PCH_Startup 
            //  Create a new instance of PCH_StartupInstance Class based on the passed-in MethodContext
            CInstancePtr pPCHStartupInstance(CreateNewInstance(pMethodContext), false);

            //  Call updateInstance now.
            try
            {
                hRes = UpdateInstance(varName, varLoadedFrom, varCommand,  stUTCTime, pPCHStartupInstance, &fCommit);
            }
            catch(...)
            {
                lregRetValue = RegCloseKey(hkeyRun);
                if(lregRetValue != ERROR_SUCCESS)
                {
                    //  Could not Close the Key
                    ErrorTrace(TRACE_ID, "Reg Close Key failed.");
                }
                throw;
            }
            if(fCommit)
            {
                hRes = pPCHStartupInstance->Commit();
                if(FAILED(hRes))
                {
                    //  Could not Commit the instance
                    ErrorTrace(TRACE_ID, "Commit on PCHStartupInstance Failed");
                }
            }

            //  Reinitialize dwNameSize and dwValueSize

            dwIndex++;
            dwNameSize = MAX_PATH;
            dwValueSize = MAX_PATH;
            lregRetValue = RegEnumValue(hkeyRun, dwIndex, tchRunKeyName, &dwNameSize, NULL, NULL,(LPBYTE)tchRunKeyValue, &dwValueSize);

        } // while Enum
        lregRetValue = RegCloseKey(hkeyRun);
        if(lregRetValue != ERROR_SUCCESS)
        {
            //  Could not Close the Key
            ErrorTrace(TRACE_ID, "Reg Close Key failed.");
        }
    }  // if SUCCEEDED 

    TraceFunctLeave();
    return(hRes);

}
//**************************************************************************************
//
//  UpdateStartupGroupInstance  :  Given the Startup Folder this function gets all the 
//                                 link files in the folder and Calls the Function 
//                                 ResolveLink to get the command Line of the Link File.
//                                 This also creates a PCH_Startup Class Instance  for
//                                 each link file.
//
//**************************************************************************************

HRESULT         CPCH_StartUp::UpdateStartupGroupInstance(
                               int              nFolder,                 // [in]  Special Folder to look for startup entries
                               SYSTEMTIME       stUTCTime,               // [in]  
                               MethodContext*   pMethodContext           // [in]  Instance is created by the caller.
                               )
{
    TraceFunctEnter("::UpdateStartupGroup Instance");

    //  Begin Declarations

    HRESULT                             hRes;

    LPCTSTR                             lpctstrLinkExtension        = _T("\\*.lnk");

    CComBSTR                            bstrPath;
    CComBSTR                            bstrSlash                   = "\\";
    CComBSTR                            bstrCommand;
    CComBSTR                            bstrPath1;
    
    TCHAR                               tchLinkFile[MAX_PATH];
    TCHAR                               tchProgramName[2*MAX_PATH];
    TCHAR                               tchPath[MAX_PATH];
    TCHAR                               tchFileName[MAX_PATH];
    LPCTSTR                             lpctstrCouldNot             = "Could Not Resolve the File";

    CComVariant                         varCommand;
    CComVariant                         varName;
    CComVariant                         varLoadedFrom               = "Startup Group";

    HANDLE                              hLinkFile;

    WIN32_FIND_DATA                     FindFileData;

    HWND                                hwndOwner                   = NULL;

    BOOL                                fCreate                     = FALSE;
    BOOL                                fShouldClose                = FALSE;
    BOOL                                fContinue                   = FALSE;
    BOOL                                fCommit                     = FALSE;

    int                                 nFileNameLen;
    int                                 nExtLen                     = 4;

    //  End Declarations



    //  Get the Path to the passed in Special Folder nFolder
    if (SHGetSpecialFolderPath(hwndOwner,tchPath,nFolder,fCreate))
    {
        //  Got the Startup Folder
        bstrPath1 = tchPath;
        bstrPath1.Append(bstrSlash);

        _tcscat(tchPath, lpctstrLinkExtension);
        
        hLinkFile = FindFirstFile(tchPath, &FindFileData);  // data returned  
        if(hLinkFile != INVALID_HANDLE_VALUE)
        {
            fContinue = TRUE;
            fShouldClose = TRUE;
        }
        else
        {
            fContinue = FALSE;
            fShouldClose = FALSE;
        }
        while(fContinue)
        {
            //  Got the Link 
            bstrPath = bstrPath1;
            bstrPath.Append(FindFileData.cFileName);

            // Take out the ".lnk" extension
            nFileNameLen = _tcslen(FindFileData.cFileName);
            nFileNameLen -= nExtLen;
            _tcsncpy(tchFileName, FindFileData.cFileName, nFileNameLen);
            tchFileName[nFileNameLen]='\0';
            varName = tchFileName;
            hRes = ResolveLink(bstrPath, bstrCommand);
            if(SUCCEEDED(hRes))
            {
                // Resolved the File Name
                varCommand = bstrCommand;
            }
            else
            {
                //  Could not resolve the File
                varCommand = lpctstrCouldNot;
            }
            
            //  Create an instance of PCH_Startup 
            CInstancePtr pPCHStartupInstance(CreateNewInstance(pMethodContext), false);

            //  Call updateInstance now.
            try
            {
                hRes = UpdateInstance(varName, varLoadedFrom, varCommand, stUTCTime, pPCHStartupInstance, &fCommit);
            }
            catch(...)
            {
                if (!FindClose(hLinkFile))
                {
                    //  Could not close the handle
                    ErrorTrace(TRACE_ID, "Could not close the File Handle");
                }
                throw;
            }
            if(fCommit)
            {
                hRes = Commit(pPCHStartupInstance);
                if(FAILED(hRes))
                {
                    //  Could not Commit the instance
                    ErrorTrace(TRACE_ID, "Commit on PCHStartupInstance Failed");
                }
            }
            if(!FindNextFile(hLinkFile, &FindFileData))
            {
                fContinue = FALSE;
            }
        }
        
        //  Close the Find File Handle.

        if(fShouldClose)
        {
            if (!FindClose(hLinkFile))
            {
                //  Could not close the handle
                ErrorTrace(TRACE_ID, "Could not close the File Handle");
            }
        }
                                 
    }
    return(hRes);
    TraceFunctLeave();
}
                

/*****************************************************************************
*
*  FUNCTION    :    CPCH_StartUp::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                       WBEM_FLAG_DEEP
*                       WBEM_FLAG_SHALLOW
*                       WBEM_FLAG_RETURN_IMMEDIATELY
*                       WBEM_FLAG_FORWARD_ONLY
*                       WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    : TO DO: All instances on the machine should be returned here.
*                       If there are no instances, return WBEM_S_NO_ERROR.
*                       It is not an error to have no instances.
*
*****************************************************************************/
HRESULT CPCH_StartUp::EnumerateInstances(
                                        MethodContext*              pMethodContext,
                                        long                        lFlags
                                        )
{
    TraceFunctEnter("CPCH_StartUp::EnumerateInstances");
    
    //  Begin Declarations...................................................

    HRESULT                             hRes                        = WBEM_S_NO_ERROR;

    SYSTEMTIME                          stUTCTime;

    //  Registry Hives of interest
    LPCTSTR                             lpctstrRunHive              = _T("software\\microsoft\\windows\\currentversion\\run");
    LPCTSTR                             lpctstrRunServicesHive      = _T("software\\microsoft\\windows\\currentversion\\runservices");

    int                                 nFolder;
    int                                 nIndex;

    CComVariant                         varMachineRun               = "Registry (Machine Run)";
    CComVariant                         varMachineService           = "Registry (Machine Service)";
    CComVariant                         varPerUserRun               = "Registry (Per User Run)";
    CComVariant                         varPerUserService           = "Registry (Per User Service)";


    //  End Declarations...................................................

    GetSystemTime(&stUTCTime);

    //  Get the StartUp Programs From HKLM\software\microsoft\windows\currentversion\run
    hRes = UpdateRegistryInstance(HKEY_LOCAL_MACHINE, lpctstrRunHive, varMachineRun, stUTCTime, pMethodContext);
    if(hRes == WBEM_E_OUT_OF_MEMORY)
    {
        goto END;
    }

    //  Get the StartUp Programs From HKLM\software\microsoft\windows\currentversion\runservices
    hRes = UpdateRegistryInstance(HKEY_LOCAL_MACHINE, lpctstrRunServicesHive, varMachineService, stUTCTime, pMethodContext);
    if(hRes == WBEM_E_OUT_OF_MEMORY)
    {
        goto END;
    }


    //  Get the StartUp Programs From HKCU\software\microsoft\windows\currentversion\run
    hRes = UpdateRegistryInstance(HKEY_CURRENT_USER, lpctstrRunHive, varPerUserRun, stUTCTime, pMethodContext);
    if(hRes == WBEM_E_OUT_OF_MEMORY)
    {
        goto END;
    }


    //  Get the StartUp Programs From HKCU\software\microsoft\windows\currentversion\runservices
    hRes = UpdateRegistryInstance(HKEY_CURRENT_USER, lpctstrRunServicesHive, varPerUserService, stUTCTime, pMethodContext);
    if(hRes == WBEM_E_OUT_OF_MEMORY)
    {
        goto END;
    }


    //  Get the rest of the instances of startup programs from the Startup Group.
    //  The two directories to look for are : Startup and common\startup

	//  CSIDL_STARTUP (current user)
    hRes = UpdateStartupGroupInstance(CSIDL_STARTUP, stUTCTime, pMethodContext);
    if(hRes == WBEM_E_OUT_OF_MEMORY)
    {
        goto END;
    }

    //  CSIDL_COMMON_STARTUP (all users)
    hRes = UpdateStartupGroupInstance(CSIDL_COMMON_STARTUP, stUTCTime, pMethodContext);

END:    TraceFunctLeave();
     return WBEM_S_NO_ERROR;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprov\pch_startup.h ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_StartUp.H

Abstract:
	WBEM provider class definition for PCH_StartUp class

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

********************************************************************/

// Property set identification
//============================

#ifndef _PCH_StartUp_H_
#define _PCH_StartUp_H_

#define PROVIDER_NAME_PCH_STARTUP "PCH_StartUp"

// Property name externs -- defined in PCH_StartUp.cpp
//=================================================

extern const WCHAR* pTimeStamp ;
extern const WCHAR* pChange ;
extern const WCHAR* pCommand ;
extern const WCHAR* pLoadedFrom ;
extern const WCHAR* pName ;

class CPCH_StartUp : public Provider 
{
	public:
		// Constructor/destructor
		//=======================

		CPCH_StartUp(const CHString& chsClassName, LPCWSTR lpszNameSpace) : Provider(chsClassName, lpszNameSpace) {};
		virtual ~CPCH_StartUp() {};

	protected:
		// Reading Functions
		//============================
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Writing Functions
		//============================
		virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Other Functions
		virtual HRESULT ExecMethod( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags = 0L ) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
    private:
        virtual HRESULT UpdateRegistryInstance(
                        HKEY             hkeyRoot,                // [in]  Name of the Startup Instance
                        LPCTSTR          lpctstrRegistryHive,         // [in]  Registry/StartupGroup
                        CComVariant      varLoadedFrom,          // [in]  Command of the startup Instance
                        SYSTEMTIME       stUTCTime,              // [in]  
                        MethodContext*   pMethodContext          // [in] 
                        );

        virtual HRESULT UpdateStartupGroupInstance(
                        int              nFolder,                 // [in]  Registry hive to look for startup entries
                        SYSTEMTIME       stUTCTime,               // [in]  
                        MethodContext*   pMethodContext           // [in]  Instance is created by the caller.
                        );
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprov\pch_systemhook.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_SystemHook.CPP

Abstract:
	WBEM provider class implementation for PCH_SystemHook class

Revision History:

	Ghim-Sim Chua       (gschua)   05/05/99
		- Created

    Jim Martin          (a-jammar) 06/01/99
        - Populated data, added Dr. Watson code.

********************************************************************/

#include "pchealth.h"
#include "PCH_SystemHook.h"

/////////////////////////////////////////////////////////////////////////////
//  tracing stuff

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile
#define TRACE_ID    DCID_SYSTEMHOOK

CPCH_SystemHook MyPCH_SystemHookSet (PROVIDER_NAME_PCH_SYSTEMHOOK, PCH_NAMESPACE);

// Property names

const static WCHAR * pTimeStamp = L"TimeStamp";
const static WCHAR * pChange = L"Change";
const static WCHAR * pApplication = L"Application";
const static WCHAR * pApplicationPath = L"ApplicationPath";
const static WCHAR * pDLLPath = L"DLLPath";
const static WCHAR * pFullPath = L"FullPath";
const static WCHAR * pHookedBy = L"HookedBy";
const static WCHAR * pHookType = L"HookType";

//-----------------------------------------------------------------------------
// Here's a simple collection class to hold the hook information.
//-----------------------------------------------------------------------------

class CHookInfo
{
public:
    CHookInfo() : m_pList(NULL) {};
    ~CHookInfo();

    BOOL QueryHooks();
    BOOL GetHook(DWORD dwIndex, int * iHook, char ** pszDll, char ** pszExe);

private:
    // Functions pulled from the Dr. Watson code.

    BOOL NTAPI Hook_PreInit();
    void NTAPI Hook_RecordHook(PHOOK16 phk, PHOOKWALKINFO phwi);

    // A struct to hold each parsed hook.

    struct SHookItem
    {
        int         m_iHook;
        char        m_szHookDll[MAX_PATH];
        char        m_szHookExe[MAX_PATH];
        SHookItem * m_pNext;

        SHookItem(int iHook, const char * szDll, const char * szExe, SHookItem * pNext)
            : m_iHook(iHook), m_pNext(pNext)
        {
            strcpy(m_szHookDll, szDll);
            strcpy(m_szHookExe, szExe);
        }
    };

    SHookItem * m_pList;
};

//-----------------------------------------------------------------------------
// The destructor gets rid of the list of hooks.
//-----------------------------------------------------------------------------

CHookInfo::~CHookInfo()
{
    TraceFunctEnter("CHookInfo::~CHookInfo");
    SHookItem * pNext;
    while (m_pList)
    {
        pNext = m_pList->m_pNext;
        delete m_pList;
        m_pList = pNext;
    }
    TraceFunctLeave();
}

//-----------------------------------------------------------------------------
// QueryHooks creates the list of system hooks (by calling the Dr. Watson code).
//-----------------------------------------------------------------------------

extern "C" void ThunkInit(void);
BOOL CHookInfo::QueryHooks()
{
    ThunkInit();
    return Hook_PreInit();
}

//-----------------------------------------------------------------------------
// GetHook returns information for the hook specified by dwIndex. If there is
// no hook at that index, FALSE is returned. The string pointers are changed
// to point at the appropriate strings in the CHookInfo list. This pointers
// will be invalid when the CHookInfo object is destroyed.
//-----------------------------------------------------------------------------

BOOL CHookInfo::GetHook(DWORD dwIndex, int * iHook, char ** pszDll, char ** pszExe)
{
    TraceFunctEnter("CHookInfo::GetHook");

    SHookItem * pItem = m_pList;
    BOOL        fReturn = FALSE;

    for (DWORD i = 0; i < dwIndex && pItem; i++)
        pItem = pItem->m_pNext;

    if (pItem)
    {
        *iHook  = pItem->m_iHook;
        *pszDll = pItem->m_szHookDll;
        *pszExe = pItem->m_szHookExe;
        fReturn = TRUE;
    }

    TraceFunctLeave();
    return fReturn;
}

//-----------------------------------------------------------------------------
// The following table is used for indicating the hook type. It's referenced
// by the iHook value returned from CHookInfo::GetHook. One has to be added
// to the iHook value to reference this table, since it starts from -1.
//-----------------------------------------------------------------------------

LPCTSTR aszHookType[] = 
{
    _T("Message Filter"),
    _T("Journal Record"),
    _T("Journal Playback"),
    _T("Keyboard"),
    _T("GetMessage"),
    _T("Window Procedure"),
    _T("CBT"),
    _T("System MsgFilter"),
    _T("Mouse"),
    _T("Hardware"),
    _T("Debug"),
    _T("Shell"),
    _T("Foreground Idle"),
    _T("Window Procedure Result")
};

//-----------------------------------------------------------------------------
// The EnumeratInstances function is called by WMI to enurate the instances
// of the class. Here we use the CHookInfo class to create a list of system
// hooks which we enumerate, creating a WMI object for each one.
//-----------------------------------------------------------------------------

HRESULT CPCH_SystemHook::EnumerateInstances(MethodContext * pMethodContext, long lFlags)
{
    TraceFunctEnter("CPCH_SystemHook::EnumerateInstances");
    HRESULT hRes = WBEM_S_NO_ERROR;

    // Get the date and time

    SYSTEMTIME stUTCTime;
    GetSystemTime(&stUTCTime);

    CHookInfo hookinfo;
    if (hookinfo.QueryHooks())
    {
        int     iHook;
        char *  szDll;
        char *  szExe;

        for (DWORD dwIndex = 0; hookinfo.GetHook(dwIndex, &iHook, &szDll, &szExe); dwIndex++)
        {
            CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);

            // Set the change and timestamp fields to "Snapshot" and the current time.

            if (!pInstance->SetDateTime(pTimeStamp, WBEMTime(stUTCTime)))
                ErrorTrace(TRACE_ID, "SetDateTime on Timestamp field failed.");

            if (!pInstance->SetCHString(pChange, L"Snapshot"))
                ErrorTrace(TRACE_ID, "SetCHString on Change field failed.");

            // Set the properties we found for the hook.

            if (!pInstance->SetCHString(pDLLPath, szDll))
                ErrorTrace(TRACE_ID, "SetCHString on DLL field failed.");

            if (!pInstance->SetCHString(pApplicationPath, szExe))
                ErrorTrace(TRACE_ID, "SetCHString on application path field failed.");

            if (!pInstance->SetCHString(pApplication, PathFindFileName(szExe)))
                ErrorTrace(TRACE_ID, "SetCHString on application field failed.");

            if (!pInstance->SetCHString(pFullPath, szDll))
                ErrorTrace(TRACE_ID, "SetCHString on pFullPath field failed.");

            if (!pInstance->SetCHString(pHookedBy, PathFindFileName(szDll)))
                ErrorTrace(TRACE_ID, "SetCHString on pHookedBy field failed.");

            if (iHook >= -1 && iHook <= 12)
            {
                if (!pInstance->SetCHString(pHookType, aszHookType[iHook + 1]))
                    ErrorTrace(TRACE_ID, "SetCHString on pHookType field failed.");
            }
            else
                ErrorTrace(TRACE_ID, "Bad hook type.");

   	        hRes = pInstance->Commit();
            if (FAILED(hRes))
                ErrorTrace(TRACE_ID, "Commit on Instance failed.");
        }
    }

    TraceFunctLeave();
    return hRes;
}

//-----------------------------------------------------------------------------
// Gather the system hook information.
//-----------------------------------------------------------------------------

TCHAR g_tszShell[MAX_PATH];
BOOL NTAPI CHookInfo::Hook_PreInit()
{
    TraceFunctEnter("CHookInfo::Hook_PreInit");

    BOOL fRc = FALSE;

    // Initialize the g_tszShell variable if necessary.

    if (!g_tszShell[0])
    {
        TCHAR tszPath[MAX_PATH];
        GetPrivateProfileString(TEXT("boot"), TEXT("shell"), TEXT("explorer.exe"), tszPath, cA(tszPath), TEXT("system.ini"));
        lstrcpy(g_tszShell, PathFindFileName(tszPath));
    }

    if (g_pvWin16Lock) 
    {
        PV pvUser = MapSL((PV)MAKELONG(0, (DWORD)g_hinstUser));
        LPWORD pwRghhk;
        DWORD dwHhk;

        dwHhk = GetUserHookTable();

        switch (HIWORD(dwHhk)) 
        {
        case 1:
            //  We "know" the structure of the USER hook chain
            //  of type 1.

            pwRghhk = (LPWORD)pvAddPvCb(pvUser, LOWORD(dwHhk) + 2);
            break;

        default:
            // Unknown hook style.  Oh well.

            pwRghhk = 0;
            break;
        }

        if (pwRghhk) 
        {
            //  Walk the hook list (under the Win16 lock)
            //  and parse out each installed hook.

            int ihk;
            HOOKWALKINFO hwi;

            EnterSysLevel(g_pvWin16Lock);

            for (ihk = WH_MIN; ihk <= WH_MAX; ihk++) 
            {
                WORD hhk = pwRghhk[ihk];
                while (hhk) 
                {
                    PHOOK16 phk = (PHOOK16)pvAddPvCb(pvUser, hhk);
                    if (phk->hkMagic != HK_MAGIC || phk->idHook  != ihk) 
                        break; // Weird.  Stop before we GPF
                    Hook_RecordHook(phk, &hwi);
                    hhk = phk->phkNext;
                    fRc = TRUE;
                }
            }

            LeaveSysLevel(g_pvWin16Lock);
        }
    } 

    TraceFunctLeave();
    return fRc;
}

//-----------------------------------------------------------------------------
// Record information about a single hook during the hookwalk process.
//-----------------------------------------------------------------------------

void NTAPI CHookInfo::Hook_RecordHook(PHOOK16 phk, PHOOKWALKINFO phwi)
{
    TraceFunctEnter("CHookInfo::Hook_RecordHook");

    HOOKINFO hi;
    PQ16 pq;

    ZeroX(hi);

    hi.iHook = phk->idHook;

    // Get the name of the app that installed the hook.
    // We wished we could pass the queue handle to GetModuleFileName,
    // but that will just return USER.
    //
    // It is possible that the queue is null; this means that the
    // hook was installed by a device driver (like XMOUSE).

    pq = (PQ16)MapSL((PV)MAKELONG(0, phk->hqCreator));
    if (pq) 
        GetModuleFileName16(pq->htask, hi.szHookExe, cA(hi.szHookExe));
    else 
        hi.szHookExe[0] = TEXT('\0');

    //  Now get the DLL name.  This varies depending on whether the
    //  DLL is 16-bit or 32-bit.

    if (phk->uiFlags & HOOK_32BIT) 
    {
        // If a 32-bit hook, then the DLL name is saved in an atom.

        GetUserAtomName(phk->atomModule, hi.szHookDll);
        PathAdjustCase(hi.szHookDll, 0);
    } 
    else 
    {
        // If a 16-bit hook, then the DLL name is saved as hmodule16.

        GetModuleFileName16((HMODULE16)phk->hmodOwner, hi.szHookDll, cA(hi.szHookDll));
        PathAdjustCase(hi.szHookDll, 1);
    }

    // Add the hook to the collection of hooks. Don't add the explorer shell to the
    // list.

    if (hi.iHook != WH_SHELL || lstrcmpi(PathFindFileName(hi.szHookExe), g_tszShell) != 0) 
    {
        SHookItem * pNew = new SHookItem(hi.iHook, hi.szHookDll, hi.szHookExe, m_pList);
        if (pNew)
            m_pList = pNew;
        else
            throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
    }

    TraceFunctLeave();
}

//-----------------------------------------------------------------------------
// Function pulled in from Dr. Watson.
//
// If f16, then it is a 16-bit thing, and we uppercase it all.
// If !f16, then it is a 32-bit thing, and we uppercase the
// first and downcase the rest.
// 
// If the first letter is a DBCS thing, then we don't touch it.
//-----------------------------------------------------------------------------

void NTAPI PathAdjustCase(LPSTR psz, BOOL f16)
{
    TraceFunctEnter("PathAdjustCase");

    psz = PathFindFileName(psz);

    if (f16) 
        CharUpper(psz);
    else if (!IsDBCSLeadByte(*psz)) 
    {
        CharUpperBuff(psz, 1);
        CharLower(psz+1);
    }

    TraceFunctLeave();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprov\pch_systemhook.h ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_SystemHook.H

Abstract:
	WBEM provider class definition for PCH_SystemHook class

Revision History:

	Ghim-Sim Chua       (gschua)   05/05/99
		- Created

********************************************************************/

// Property set identification
//============================

#ifndef _PCH_SystemHook_H_
#define _PCH_SystemHook_H_

#define PROVIDER_NAME_PCH_SYSTEMHOOK "PCH_SystemHook"

// Property name externs -- defined in PCH_SystemHook.cpp
//=================================================

extern const WCHAR* pApplication ;
extern const WCHAR* pApplicationPath ;
extern const WCHAR* pDLLPath ;
extern const WCHAR* pFullPath ;
extern const WCHAR* pHookedBy ;
extern const WCHAR* pHookType ;

class CPCH_SystemHook : public Provider 
{
	public:
		// Constructor/destructor
		//=======================

        CPCH_SystemHook(const CHString& chsClassName, LPCWSTR lpszNameSpace) : Provider(chsClassName, lpszNameSpace) {};
        virtual ~CPCH_SystemHook() {};

	protected:
		// Reading Functions
		//============================
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Writing Functions
		//============================
		virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Other Functions
		virtual HRESULT ExecMethod( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags = 0L ) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
} ;

//-----------------------------------------------------------------------------
// There are a bunch of macros and type definitions used by the Dr. Watson
// code, which are included here. There's also a lot we use from hook.c.
//-----------------------------------------------------------------------------

// Various macros used by the Dr. Watson source code.

#define cbX(X) sizeof(X)
#define cA(a) (cbX(a)/cbX(a[0]))
#define ZeroBuf(pv, cb) memset(pv, 0, cb)
#define ZeroX(x) ZeroBuf(&(x), cbX(x))
#define PV LPVOID
#define pvAddPvCb(pv, cb) ((PV)((PBYTE)pv + (cb)))

// A few constants used in this code.

#define HK_MAGIC    0x4B48      /* "HK" */
#define HOOK_32BIT  0x0002      /* 32-bit hook */

// Type definitons used in the hook code from Dr. Watson.

typedef WORD HMODULE16;

typedef struct Q16 
{
    WORD    hqNext;             /* Pointer to next */
    WORD    htask;              /* Owner task */
} Q16, *PQ16;

typedef struct HOOKWALKINFO 
{
    int  ihkShellShell;         /* Last shell hook installed by shell */
} HOOKWALKINFO, *PHOOKWALKINFO;

typedef struct HOOKINFO 
{
    int     iHook;              /* Hook number */
    char    szHookDll[MAX_PATH];/* Who hooked it? (must be >= 256 bytes) */
    char    szHookExe[MAX_PATH];/* Whose idea was it? */
} HOOKINFO, *PHOOKINFO;

typedef struct HOOK16 
{
    WORD    hkMagic;            /* Must be HK_MAGIC */
    WORD    phkNext;            /* Near pointer to next (or 0) */
    short   idHook;             /* Hook type */
    WORD    ppiCreator;         /* App which created the hook */
    WORD    hq;                 /* Queue for which hook applies */
    WORD    hqCreator;          /* Queue which created the hook */
    WORD    uiFlags;            /* Flags */
    WORD    atomModule;         /* If 32-bit module, atom for DLL name */
    DWORD   hmodOwner;          /* Module handle of owner */
    FARPROC lpfn;               /* The hook procedure itself */
    short   cCalled;            /* Number of active calls */
} HOOK16, *PHOOK16;

extern "C" 
{
    // External functions.

    int NTAPI                   GetModuleFileName16(HMODULE16 hmod, LPSTR sz, int cch);
    DWORD NTAPI                 GetUserHookTable(void);
    WINBASEAPI void WINAPI      EnterSysLevel(PV pvCrst);
    WINBASEAPI void WINAPI      LeaveSysLevel(PV pvCrst);
    WINBASEAPI LPVOID WINAPI    MapSL(LPVOID);
    UINT                        GetUserAtomName(UINT atom, LPSTR psz);

    // Global variables defined in thunk.c

    extern LPVOID      g_pvWin16Lock;
    HINSTANCE   g_hinstUser;
}

void NTAPI PathAdjustCase(LPSTR psz, BOOL f16);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprov\pch_sysinfo.cpp ===
/*****************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
   .PCH_SysInfo.CPP

Abstract:
    WBEM provider class implementation for PCH_SysInfo class.
    1. This class gets the foll. properties from Win32_OperatingSystem Class:
       "OSName", "Version" 
       and sets "PCH_SysInfo.OsName" property.
    2. Gets the foll. properties from Win32_Processor Class:
       "Manufacturer", "Description"
       and sets "PCH_SysInfo.Processor" property.
    3. Gets the foll. properties from Win32_LogicalMemoryConfiguration Class:
       "TotalPhysicalMemory"
       and sets "PCH_SysInfo.RAM" property.
    4. Gets the foll. properties from Win32_PageFile Class:
       "Name", "FreeSpace", "FSName"
        and sets PCH_SysInfo.SwapFile Property.
    5. Sets the "Change" property to "Snapshot" always
 
Revision History:

    Ghim Sim Chua          (gschua )    04/27/99
     - Created
    Kalyani Narlanka       (kalyanin)   05/03/99
     - Added  properties

*******************************************************************************/

#include "pchealth.h"
#include "PCH_Sysinfo.h"

///////////////////////////////////////////////////////////////////////////////
//    Begin Tracing stuff
//

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile
#define TRACE_ID    DCID_SYSINFO
//
//    End Tracing stuff
///////////////////////////////////////////////////////////////////////////////

CPCH_Sysinfo MyPCH_SysinfoSet (PROVIDER_NAME_PCH_SYSINFO, PCH_NAMESPACE) ;

///////////////////////////////////////////////////////////////////////////////

//     Different types of Installation

#define         IDS_SKU_NET                     "network"
#define         IDS_SKU_CD_UPGRADE              "CD"
#define         IDS_SKU_FLOPPY_UPGRADE          "Floppy"
#define         IDS_SKU_FLOPPY_FULL             "Full Floppy"
#define         IDS_SKU_SELECT_FLOPPY           "floppy"
#define         IDS_SKU_SELECT_CD               "Select CD"
#define         IDS_SKU_OEM_DISKMAKER           "OEM"
#define         IDS_SKU_OEM_FLOPPY              "OEM floppy"
#define         IDS_SKU_OEM_CD                  "OEM CD"
#define         IDS_SKU_MS_INTERNAL             "Microsoft Internal"
#define         IDS_SKU_CD_FULL                 "Full CD"
#define         IDS_SKU_WEB                     "Web"
#define         IDS_SKU_MSDN_CD                 "MSDN CD"
#define         IDS_SKU_OEM_CD_FULL             "Full OEM CD"
#define         IDS_SKU_OEM_PREINST_KIT         "OEM Preinstall Kit"
#define         MAX_LEN                         20
#define         ONEK                            1024
#define         HALFK                           512


//....Properties of PCHSysInfo Class
//
const static WCHAR* pOSLanguage          = L"OSLanguage";
const static WCHAR* pManufacturer        = L"Manufacturer";
const static WCHAR* pModel               = L"Model";
const static WCHAR* pTimeStamp           = L"TimeStamp" ;  
const static WCHAR* pChange              = L"Change" ;     
const static WCHAR* pIEVersion           = L"IEVersion" ;  
const static WCHAR* pInstall             = L"Install" ;
const static WCHAR* pMode                = L"Mode" ;
const static WCHAR* pOSName              = L"OSName" ;
const static WCHAR* pOSVersion           = L"OSVersion";
const static WCHAR* pProcessor           = L"Processor" ;
const static WCHAR* pClockSpeed          = L"ClockSpeed" ;
const static WCHAR* pRAM                 = L"RAM" ;
const static WCHAR* pSwapFile            = L"SwapFile" ;
const static WCHAR* pSystemID            = L"SystemID" ;
const static WCHAR* pUptime              = L"Uptime" ;
const static WCHAR* pOSBuildNumber       = L"OSBuildNumber";


//*****************************************************************************
//
// Function Name     : CPCH_SysInfo::EnumerateInstances
//
// Input Parameters  : pMethodContext : Pointer to the MethodContext for 
//                                      communication with WinMgmt.
//                
//                     lFlags :         Long that contains the flags described 
//                                      in IWbemServices::CreateInstanceEnumAsync
//                                      Note that the following flags are handled 
//                                      by (and filtered out by) WinMgmt:
//                                      WBEM_FLAG_DEEP
//                                      WBEM_FLAG_SHALLOW
//                                      WBEM_FLAG_RETURN_IMMEDIATELY
//                                      WBEM_FLAG_FORWARD_ONLY
//                                      WBEM_FLAG_BIDIRECTIONAL
// Output Parameters  : None
//
// Returns            : WBEM_S_NO_ERROR 
//                      
//
// Synopsis           : All instances of this class on the machine are returned.
//                      If there are no instances returns WBEM_S_NO_ERROR.
//                      It is not an error to have no instances.
//                 
//
//*****************************************************************************

HRESULT CPCH_Sysinfo::EnumerateInstances(MethodContext* pMethodContext,
                                                long lFlags)
{
    TraceFunctEnter("CPCH_Sysinfo::EnumerateInstances");

//  Begin Declarations...................................................
//                                                                 
    HRESULT                             hRes = WBEM_S_NO_ERROR;

    //  Instances
    CComPtr<IEnumWbemClassObject>       pOperatingSystemEnumInst;
    CComPtr<IEnumWbemClassObject>       pProcessorEnumInst;
    CComPtr<IEnumWbemClassObject>       pLogicalMemConfigEnumInst;
    CComPtr<IEnumWbemClassObject>       pPageFileEnumInst;
    CComPtr<IEnumWbemClassObject>       pComputerSystemEnumInst;

    //  CInstance                           *pPCHSysInfoInstance;

    //  WBEM Objects
    IWbemClassObjectPtr                 pOperatingSystemObj;           // BUGBUG : WMI asserts if we use CComPtr
    IWbemClassObjectPtr                 pProcessorObj;                 // BUGBUG : WMI asserts if we use CComPtr
    IWbemClassObjectPtr                 pLogicalMemConfigObj;          // BUGBUG : WMI asserts if we use CComPtr
    IWbemClassObjectPtr                 pPageFileObj;                  // BUGBUG : WMI asserts if we use CComPtr
    IWbemClassObjectPtr                 pComputerSystemObj;            // BUGBUG : WMI asserts if we use CComPtr

   
    //  Variants
    CComVariant                         varValue;
    CComVariant                         varCaption;
    CComVariant                         varVersion;
    CComVariant                         varSnapshot                     = "Snapshot";
    CComVariant                         varRam;
    CComVariant                         varPhysicalMem;

    //  Return Values
    ULONG                               ulOperatingSystemRetVal;
    ULONG                               ulProcessorRetVal;
    ULONG                               ulLogicalMemConfigRetVal;
    ULONG                               ulPageFileRetVal;
    ULONG                               ulComputerSystemRetVal;

    LONG                                lRegKeyRet;
    LONG                                lSystemID;

    //  Query Strings
    CComBSTR                            bstrOperatingSystemQuery        = L"Select Caption, Version, Name, OSLanguage, BuildNumber FROM Win32_OperatingSystem";
    CComBSTR                            bstrProcessorQuery              = L"Select DeviceID, Name, Manufacturer, CurrentClockSpeed FROM Win32_Processor";
    CComBSTR                            bstrLogicalMemConfigQuery       = L"Select Name, TotalPhysicalMemory FROM Win32_LogicalMemoryConfiguration";
    CComBSTR                            bstrPageFileQuery               = L"Select Name, FreeSpace, FSName FROM Win32_PageFile";
    CComBSTR                            bstrComputerSystemQuery         = L"Select Name, BootupState, Manufacturer, Model FROM Win32_ComputerSystem";
    CComBSTR                            bstrQueryString;

    CComBSTR                            bstrProperty;
    CComBSTR                            bstrVersion                     = L"Version";
    CComBSTR                            bstrCaption                     = L"Caption";
    CComBSTR                            bstrManufacturer                = L"Manufacturer";
    CComBSTR                            bstrModel                       = L"Model";
    CComBSTR                            bstrOSLanguage                  = L"OSLanguage";
    CComBSTR                            bstrName                        = L"Name";
    CComBSTR                            bstrFreeSpace                   = L"FreeSpace";
    CComBSTR                            bstrFSName                      = L"FSName";
    CComBSTR                            bstrBuildNumber                 = L"BuildNumber";
    CComBSTR                            bstrSemiColon                   = L" ; ";
        
    LPCTSTR                             lpctstrSpaces                   = "  ";
    LPCTSTR                             lpctstrCleanInstall             = _T("Clean Install Using");
    LPCTSTR                             lpctstrUpgradeInstall           = _T("Upgrade Using");

    CComBSTR                            bstrProcessor;
    CComBSTR                            bstrOSName;
    CComBSTR                            bstrSwapFile;

     //  Registry Hive where IE info is stored
    LPCTSTR                             lpctstrIEHive                   = _T("Software\\Microsoft\\windows\\currentversion");
    LPCTSTR                             lpctstrSystemIDHive             = _T("Software\\Microsoft\\PCHealth\\MachineInfo");

    LPCTSTR                             lpctstrUpgrade                  = _T("Upgrade");
    LPCTSTR                             lpctstrProductType              = _T("ProductType");
    LPCTSTR                             lpctstrCommandLine              = _T("CommandLine");
    LPCTSTR                             lpctstrIEVersion                = _T("Plus! VersionNumber");
    LPCWSTR                             lpctstrVersion                  = L"Version";
    LPCWSTR                             lpctstrBootupState              = L"BootupState";
    LPCWSTR                             lpctstrTotalPhysicalMemory      = L"TotalPhysicalMemory";
    LPCTSTR                             lpctstrComputerName             = _T("ComputerName");
    LPCTSTR                             lpctstrCurrentUser              = _T("Current User");
    LPCTSTR                             lpctstrMBFree                   = _T(" MB Free ");
    LPCWSTR                             lpctstrClockSpeed               = L"CurrentClockSpeed";
    LPCWSTR                             lpctstrCaption                  = L"Name";
    
    //  Format Strings
    LPCTSTR                             lpctstrSystemIDFormat           = _T("On \"%s\" as \"%s\"");
    LPCTSTR                             lpctstrOSNameFormat             = _T("%s  %s");
    LPCTSTR                             lpctstrInstallFormat            = _T("%s %s %s");
    LPCTSTR                             lpctstrUptimeFormat             = _T("%d:%02d:%02d:%02d");

    LPCSTR                              lpctstrInstallHive              = "Software\\Microsoft\\Windows\\CurrentVersion\\Setup";
    LPCSTR                              lpctstrCurrentVersionHive       = "Software\\Microsoft\\Windows\\CurrentVersion";
    LPCSTR                              lpctstrControlHive              = "System\\CurrentControlSet\\Control";
    LPCTSTR                             lpctstrPID                      = _T("PID");
    LPCTSTR                             lpctstrNoSystemID               = _T("NoSystemID");

    //  Other Strings
    TCHAR                               tchIEVersionValue[MAX_LEN];

    TCHAR                               tchCommandLineValue[MAX_PATH];
    TCHAR                               tchProductTypeValue[MAX_LEN];
    TCHAR                               tchCurrentUserValue[MAX_PATH];
    TCHAR                               tchComputerNameValue[MAX_PATH];
    TCHAR                               tchSystemID[MAX_PATH];
    TCHAR                               tchOSName[MAX_PATH];
    TCHAR                               tchInstallStr[3*MAX_PATH];
    TCHAR                               tchUptimeStr[MAX_PATH];
    TCHAR                               tchInstall[MAX_PATH];

    TCHAR                               tchProductType[MAX_PATH];

    //  Time
    SYSTEMTIME                          stUTCTime;

    // DWORD
    DWORD                               dwSize                          = MAX_PATH;
    DWORD                               dwType;
    
    //  Key
    HKEY                                hkeyIEKey;
    HKEY                                hkeyInstallKey;
    HKEY                                hkeyCurrentVersionKey;
    HKEY                                hkeyComputerKey;
    HKEY                                hkeyComputerSubKey;
    HKEY                                hkeyControlKey;
    HKEY                                hkeySystemIDKey;

    BYTE                                bUpgradeValue;
    
    int                                 nProductTypeValue;
    int                                 nStrLen;
    int                                 nDays, nHours, nMins, nSecs;
    int                                 nRam, nRem;

    float                               dRam;

    BOOL                                fCommit                         = FALSE;
                                                                      
//  End  Declarations...................................................

    //  Initializations
    tchIEVersionValue[0]    = 0;
    tchCommandLineValue[0]  = 0;
    tchProductTypeValue[0]  = 0;
    tchProductType[0]       = 0;
    tchCurrentUserValue[0]  = 0;
    tchComputerNameValue[0] = 0;
    tchSystemID[0]          = 0;
    tchInstallStr[0]        = 0;

    varValue.Clear();
    varCaption.Clear();
    varVersion.Clear();
    
    //
    // Get the date and time  This is required for the TimeStamp field
    GetSystemTime(&stUTCTime);

    // Create a new instance of PCH_SysInfo Class based on the 
    // passed-in MethodContext

    CInstancePtr pPCHSysInfoInstance(CreateNewInstance(pMethodContext), false);

    //  Created a New Instance of PCH_SysInfo Successfully.

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //                              TIME STAMP                                                                 //
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////

    hRes = pPCHSysInfoInstance->SetDateTime(pTimeStamp, WBEMTime(stUTCTime));
    if (FAILED(hRes))
    {
      //  Could not Set the Time Stamp
      //  Continue anyway
      ErrorTrace(TRACE_ID, "SetDateTime on Timestamp Field failed.");
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //                              CHANGE                                                                     //
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////

    hRes = pPCHSysInfoInstance->SetVariant(pChange, varSnapshot);
    if (FAILED(hRes))
    {
        //  Could not Set the Change Property
        //  Continue anyway
        ErrorTrace(TRACE_ID, "Set Variant on Change Field failed.");
    }


    //  To fix the Bug : 100158 : the system ID property should not contain any privacy info. 
    //  In its place we generate some random number;

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //                              SYSTEMID                                                                   //
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        
    //  The SystemID can be obtained from HKLM\SYSTEM\CURRENTCONTROLSET\CONTROL\COMPUTERNAME\COMPUTERNAME
    //  The username can be obtained from HKLM\SYSTEM\CURRENTCONTROLSET\CONTROL\CURRENTUSER
    // 

    /*
    
    lRegKeyRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, lpctstrControlHive, 0, KEY_READ, &hkeyControlKey);
	if(lRegKeyRet == ERROR_SUCCESS)
	{
        //  Opened the Control Key
        //  Open the Computer System sub key under hkeyControlKey
        lRegKeyRet = RegOpenKeyEx(hkeyControlKey, lpctstrComputerName, 0, KEY_READ, &hkeyComputerKey);
        if(lRegKeyRet == ERROR_SUCCESS)
	    {
            //  Opened the ComputerNameSub Key
            //  Open the 
            //  Open the CompterNameSubSubKey key under ComputerNameSub Key
            lRegKeyRet = RegOpenKeyEx(hkeyComputerKey, lpctstrComputerName, 0, KEY_READ, &hkeyComputerSubKey);
            if(lRegKeyRet == ERROR_SUCCESS)
	        {
                //  Read the ComputerName Value
                dwSize = MAX_PATH;
		        lRegKeyRet = RegQueryValueEx(hkeyComputerSubKey, lpctstrComputerName, NULL, &dwType, (LPBYTE)tchComputerNameValue, &dwSize);
		        if (lRegKeyRet != ERROR_SUCCESS)
                {
                    // Could not get the ComputerName
                    ErrorTrace(TRACE_ID, "Cannot get the ComputerName");
                }
                
                //  Close the ComputerName Sub Sub Key 
                lRegKeyRet = RegCloseKey(hkeyComputerSubKey);
                if(lRegKeyRet != ERROR_SUCCESS)
	            {
                    //  Could not close the key.
                    ErrorTrace(TRACE_ID, "Cannot Close the Key");
                }
            }
            //  Close the ComputerName Sub Key 
            lRegKeyRet = RegCloseKey(hkeyComputerKey);
            if(lRegKeyRet != ERROR_SUCCESS)
	        {
                //  Could not close the key.
                ErrorTrace(TRACE_ID, "Cannot Close the Key");
            }
        }

        //  Read the CurrentUser Value
        dwSize = MAX_PATH;
		lRegKeyRet = RegQueryValueEx(hkeyControlKey, lpctstrCurrentUser, NULL, &dwType, (LPBYTE)tchCurrentUserValue, &dwSize);
		if (lRegKeyRet != ERROR_SUCCESS)
        {
            // Could not get the UserName
            ErrorTrace(TRACE_ID, "Cannot get the UserName");
        }
        
        //  Close the  Control Key
        lRegKeyRet = RegCloseKey(hkeyControlKey);
        if(lRegKeyRet != ERROR_SUCCESS)
	    {
            //  Could not close the key.
            ErrorTrace(TRACE_ID, "Cannot Close the Key");
        }

        // Got the ComputerName and CurrentUser, Format the string for systemID.

        nStrLen = wsprintf(tchSystemID,lpctstrSystemIDFormat, tchComputerNameValue, tchCurrentUserValue);

        lSystemID = long(GetTickCount());
        _ltot(lSystemID, tchSystemID, 10);
           
        //  Set the SystemID Property
        varValue = tchSystemID;
        if (FAILED(pPCHSysInfoInstance->SetVariant(pSystemID, varValue)))
        {
            // Set SystemID  Field Failed.
            // Proceed anyway
            ErrorTrace(TRACE_ID, "SetVariant on OSName Field failed.");
        }
        else
        {
            fCommit = TRUE;
        }
    }

    */


    /*
    lSystemID = long(GetTickCount());
    _ltot(lSystemID, tchSystemID, 10);
    */

    //  To fix Bug 100268 , get the system ID from the Registry.
    //  The Registry key to read is :
    //  HKLM\SW\MS\PCHealth\MachineInfo\PID

    lRegKeyRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, lpctstrSystemIDHive, 0, KEY_READ, &hkeySystemIDKey);
	if(lRegKeyRet == ERROR_SUCCESS)
	{
        //  Opened the SystemID Hive
        //  Read the PID Value
        dwSize = MAX_PATH;
		lRegKeyRet = RegQueryValueEx(hkeySystemIDKey, lpctstrPID, NULL, &dwType, (LPBYTE)tchSystemID, &dwSize);
		if (lRegKeyRet != ERROR_SUCCESS)
        {
            _tcscpy(tchSystemID,lpctstrNoSystemID);
            // Could not get the PID
            ErrorTrace(TRACE_ID, "Cannot get the PID");
        }
        //  Close the SystemID Key 
        lRegKeyRet = RegCloseKey(hkeySystemIDKey);
        if(lRegKeyRet != ERROR_SUCCESS)
        {
            //  Could not close the key.
            ErrorTrace(TRACE_ID, "Cannot Close the Key");
        }
    
    }   
    //  Set the SystemID Property
    varValue = tchSystemID;
    if (FAILED(pPCHSysInfoInstance->SetVariant(pSystemID, varValue)))
    {
        // Set SystemID  Field Failed.
        // Proceed anyway
        ErrorTrace(TRACE_ID, "SetVariant on OSName Field failed.");
    }
    else
    {
        fCommit = TRUE;
    }
  
        
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //                              OSNAME                                                                     //
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////

    // Execute the query to get "Caption", "Version", "Name" from Win32_OperatingSystem Class.
    // Although "Name" is not required to set PCH_SysInfo.OSName property
    // we need to query for it as its the "Key" property of the class.

    // pOperatingSystemEnumInst contains a pointer to the list of instances returned.
    //
    hRes = ExecWQLQuery(&pOperatingSystemEnumInst, bstrOperatingSystemQuery);
    if (SUCCEEDED(hRes))
    {
        // Query on Win32_OperatingSystem Class Succeeded
        // Enumerate the instances of Win32_OperatingSystem Class
        // from pOperatingSystemEnumInst.

        // Get the next instance into pOperatingSystemObj object.
        hRes = pOperatingSystemEnumInst->Next(WBEM_INFINITE, 1, &pOperatingSystemObj, &ulOperatingSystemRetVal);
        if(hRes == WBEM_S_NO_ERROR)
        {
            //  Copy property "caption" to "OSName"
            CopyProperty(pOperatingSystemObj, lpctstrCaption, pPCHSysInfoInstance, pOSName);

            //  Copy property "Version" to "Version"
            CopyProperty(pOperatingSystemObj, lpctstrVersion, pPCHSysInfoInstance, pOSVersion);

            //  Copy property "OSLangauge" to "OSLangauge"
            CopyProperty(pOperatingSystemObj, bstrOSLanguage, pPCHSysInfoInstance, pOSLanguage);

            //  Copy property "BuildNumber" to "BuildNumber"
            CopyProperty(pOperatingSystemObj, bstrBuildNumber, pPCHSysInfoInstance, pOSBuildNumber);

            
        } //end of if WBEM_S_NO_ERROR

    } // end of if SUCCEEDED(hRes)
    else
    {
        //  Operating system Query did not succeed.
        ErrorTrace(TRACE_ID, "Query on win32_OperatingSystem Field failed.");
    }


    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //                              UPTIME                                                                     //
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////

    //  Get uptime using GetTickCount()
    dwSize = GetTickCount();

    /* There is a bug in the server side because of the fix and so this needs to be reverted again.

    //  GetTickCount returns uptime in milliseconds. Divide this by 1000 to get seconds.

    dwSize = dwSize/1000.0;

    // To fix the bug of inconsistent time formats, change the seconds to days::hours::mins::secs.

    // Get the number of days.
    nDays = dwSize/(60*60*24);
    dwSize = dwSize%(60*60*24);

    // Get the Number of hours.
    nHours = dwSize/(60*60);
    dwSize = dwSize%(60*60);

    //Get the Number of Mins.
    nMins = dwSize/(60);

    //Get the Number of Secs.
    nSecs = dwSize%60;

    nStrLen = wsprintf(tchUptimeStr,lpctstrUptimeFormat, nDays, nHours, nMins, nSecs);
    varValue = tchUptimeStr;

    */

    
    // varValue = (long)dwSize;
    varValue.vt = VT_I4;
    varValue.lVal = (long)dwSize;
    

    //  Set the UpTime Property
    if (FAILED(pPCHSysInfoInstance->SetVariant(pUptime, varValue)))
    {
        // Set UpTime Failed.
        // Proceed anyway
        ErrorTrace(TRACE_ID, "SetVariant on UpTime Field failed.");
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //                              INSTALL                                                                    //
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////

    //  The Install info is obtained from the Registry

    // Get "Upgrade" regvalue from HKLM\Software\Microsoft\Windows\CurrentVersion\Setup
    // if Upgrade == 0, then it is "Clean Install" otherwise its a "Upgrade"

    dwSize = MAX_PATH;
    lRegKeyRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, lpctstrInstallHive, 0, KEY_READ, &hkeyInstallKey);
	if(lRegKeyRet == ERROR_SUCCESS)
	{
        //  Opened the Install Key
        //  Read the upgrade Value
         dwSize = 1;
		lRegKeyRet = RegQueryValueEx(hkeyInstallKey, lpctstrUpgrade, NULL, &dwType, &bUpgradeValue, &dwSize);
		if (lRegKeyRet == ERROR_SUCCESS)
		{
            //  Compare Install Value with "00"
            if (bUpgradeValue == 0)
            {
                // Clean Install
                _tcscpy(tchInstall, lpctstrCleanInstall);
            }
            else
            {
                _tcscpy(tchInstall, lpctstrUpgradeInstall);
            }
           
        }
        
        // Read the CommandLine Value
        dwSize = MAX_PATH;
		lRegKeyRet = RegQueryValueEx(hkeyInstallKey, lpctstrCommandLine, NULL, &dwType, (LPBYTE)tchCommandLineValue, &dwSize);
		lRegKeyRet = RegCloseKey(hkeyInstallKey);
        if(lRegKeyRet != ERROR_SUCCESS)
	    {
            //  Could not close the key.
            ErrorTrace(TRACE_ID, "Cannot Close the Key");
        }
    }

    // Get "ProductType" regvalue from HKLM\Software\Microsoft\Windows\CurrentVersion   

    dwSize = MAX_PATH;
    lRegKeyRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, lpctstrCurrentVersionHive, 0, KEY_READ, &hkeyCurrentVersionKey);
	if(lRegKeyRet == ERROR_SUCCESS)
	{
        // Opened the CurrentVersion Key
        // Read the ProductType Value
		lRegKeyRet = RegQueryValueEx(hkeyCurrentVersionKey, lpctstrProductType, NULL, &dwType, (LPBYTE)tchProductTypeValue, &dwSize);
		if (lRegKeyRet == ERROR_SUCCESS)
		{
            //  Compare ProductType Value with known codes
            //  Convert the productType value to an int

            nProductTypeValue = atoi(tchProductTypeValue);

            switch(nProductTypeValue)
            {
            case 100:
                {
                    _tcscpy(tchProductType, IDS_SKU_MS_INTERNAL);
                    break;
                }
            case 101:
                {
                     _tcscpy(tchProductType, IDS_SKU_CD_FULL);
                    break;
                }
            case 102:
                {
                     _tcscpy(tchProductType, IDS_SKU_CD_UPGRADE);
                    break;
                }
            case 103:
                {
                     _tcscpy(tchProductType,IDS_SKU_FLOPPY_FULL);
                    break;
                }
            case 104:
                {
                      _tcscpy(tchProductType,IDS_SKU_FLOPPY_UPGRADE);
                    break;
                }
            case 105:
                {
                     _tcscpy(tchProductType,IDS_SKU_WEB);
                    break;
                }
            case 110:
                {
                     _tcscpy(tchProductType, IDS_SKU_SELECT_CD);
                    break;
                }
            case 111:
                {
                     _tcscpy(tchProductType, IDS_SKU_MSDN_CD);
                    break;
                }
            case 115:
                {
                      _tcscpy(tchProductType, IDS_SKU_OEM_CD_FULL);
                    break;
                }
            case 116:
                {
                    _tcscpy(tchProductType,IDS_SKU_OEM_CD);
                    break;
                }
            case 120:
                {
                    _tcscpy(tchProductType, IDS_SKU_OEM_PREINST_KIT);
                    break;
                }
            case 1:
                {
                    _tcscpy(tchProductType, IDS_SKU_NET);
                    break;
                }
            case 5:
                {
                    _tcscpy(tchProductType, IDS_SKU_SELECT_FLOPPY);
                    break;
                }
            case 7:
                {
                    _tcscpy(tchProductType, IDS_SKU_OEM_DISKMAKER);
                    break;
                }
            case 8:
                {
                    _tcscpy(tchProductType, IDS_SKU_OEM_FLOPPY);
                    break;
                }
            default:
                {
                    //  Cannot figure out the type of installation
                }
            }

        }
    
        //  RegCloseKey(hkeyCurrentVersionKey);
        lRegKeyRet = RegCloseKey(hkeyCurrentVersionKey);
        if(lRegKeyRet != ERROR_SUCCESS)
	    {
            //  Could not close the key.
            ErrorTrace(TRACE_ID, "Cannot Close the Key");
        }
    }

    nStrLen = wsprintf(tchInstallStr,lpctstrInstallFormat, tchInstall, tchProductType, tchCommandLineValue);
    varValue = tchInstallStr;
    
    // Set the Install Property
    if (FAILED(pPCHSysInfoInstance->SetVariant(pInstall, varValue)))
    {
        // Set Install Failed.
        // Proceed anyway
        ErrorTrace(TRACE_ID, "SetVariant on OSName Field failed.");
    }

   
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //                              IEVERSION                                                                  //
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////

	// IE Version can be obtained from the Registry under the following hive.
	// HKLM\Software\Microsoft\Windows\Current Version
	// Version is available in the field "Plus!VersionNumber"
	// "Internet Explorer" Key is  in  "hkeyIEKey"

    lRegKeyRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, lpctstrIEHive, 0, KEY_READ, &hkeyIEKey);
	if(lRegKeyRet == ERROR_SUCCESS)
	{
        // Opened the Internet Explorer key.
        // Read the Version Value
        dwSize = MAX_PATH;
		lRegKeyRet = RegQueryValueEx(hkeyIEKey, lpctstrIEVersion, NULL, &dwType, (LPBYTE) tchIEVersionValue, &dwSize);
		if (lRegKeyRet == ERROR_SUCCESS)
		{
		    try
            {
                // Got the version as a string.
			    // Update the IE Version Property
                varValue = tchIEVersionValue;
           
                // Set the IEVersion Property
		        hRes = pPCHSysInfoInstance->SetVariant(pIEVersion, varValue);
                if (hRes == ERROR_SUCCESS)
                {
                    // Set IEVersion Failed.
                    // Proceed anyway
                    ErrorTrace(TRACE_ID, "SetVariant on IEVersion Field failed.");
                }
            }
            catch(...)
            {
                lRegKeyRet = RegCloseKey(hkeyIEKey);
                if(lRegKeyRet != ERROR_SUCCESS)
	            {
                    //  Could not close the key.
                    ErrorTrace(TRACE_ID, "Cannot Close the Key");
                }
                throw;
            }
	    } // end of if RegQueryValueEx == ERROR_SUCCESS

        lRegKeyRet = RegCloseKey(hkeyIEKey);
        if(lRegKeyRet != ERROR_SUCCESS)
	    {
            //  Could not close the key.
            ErrorTrace(TRACE_ID, "Cannot Close the Key");
        }
        
    } // end of if RegOpenKeyEx == ERROR_SUCCESS
        
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //                              MODE                                                                       //
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////

    //  Execute the query to get Name, BootUpstate FROM Win32_ComputerSystem
    //  Class.

    //  pComputerSystemEnumInst contains a pointer to the instance returned.

    hRes = ExecWQLQuery(&pComputerSystemEnumInst, bstrComputerSystemQuery);
    if (SUCCEEDED(hRes))
    {
        //  Query Succeeded!
        
        //  Get the instance Object.
        if((pComputerSystemEnumInst->Next(WBEM_INFINITE, 1, &pComputerSystemObj, &ulComputerSystemRetVal)) == WBEM_S_NO_ERROR)
        {

            //  Get the BootupState
            CopyProperty(pComputerSystemObj, lpctstrBootupState, pPCHSysInfoInstance, pMode);

            //  Get the Manufacturer
            CopyProperty(pComputerSystemObj, bstrManufacturer, pPCHSysInfoInstance, pManufacturer);

            //  Get the Model
            CopyProperty(pComputerSystemObj, bstrModel, pPCHSysInfoInstance, pModel);
           
        }
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //                              PROCESSOR                                                                  //
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////

    // Execute the query to get "DeviceID", "Manufacturer", "Name", "CurrentClockSpeed"
    // from Win32_Processor Class.
    // Although "DeviceID" is not required to set PCH_SysInfo.Processor property
    // we need to query for it as its the "Key" property of the class.
    // pProcessorEnumInst contains a pointer to the list of instances returned.
  
    //
    hRes = ExecWQLQuery(&pProcessorEnumInst, bstrProcessorQuery);
    if (SUCCEEDED(hRes))
    {
        
        // Query on Win32_Processor Class Succeeded
        // Enumerate the instances of Win32_Processor Class
        // from pProcessorEnumInst.

        // Get the instance into pProcessorObj object.
   
        if(WBEM_S_NO_ERROR == pProcessorEnumInst->Next(WBEM_INFINITE, 1, &pProcessorObj, &ulProcessorRetVal))
        {
            //Get the Manufacturer
            if (FAILED(pProcessorObj->Get(bstrManufacturer, 0, &varValue, NULL, NULL)))
            {
                // Could not get the Manufacturer
                ErrorTrace(TRACE_ID, "GetVariant on Win32_Processor:Manufacturer Field failed.");
            }
            else
            {
                // Got the Manufacturer
                // varValue set to Manufacturer. Copy this to bstrResult
                hRes = varValue.ChangeType(VT_BSTR, NULL);
                if(SUCCEEDED(hRes))
                {
                    bstrProcessor.Append(V_BSTR(&varValue));

                    // Put some spaces before appending the string.
                    bstrProcessor.Append(lpctstrSpaces);
                }

            }

            // Get the Name
            if (FAILED(pProcessorObj->Get(bstrName, 0, &varValue, NULL, NULL)))
            {
                    // Could not get the Name
                    ErrorTrace(TRACE_ID, "GetVariant on Win32_Processor:Name Field failed.");
            } 
            else
            {
                // Got the Name
                // varValue set to Name. Append this to bstrResult
                hRes = varValue.ChangeType(VT_BSTR, NULL);
                if(SUCCEEDED(hRes))
                {
                    bstrProcessor.Append(V_BSTR(&varValue));

                    // Put some spaces before appending the string.
                    bstrProcessor.Append(lpctstrSpaces);
                }
            }

            // Set the Processor Property
            varValue.vt = VT_BSTR;
            varValue.bstrVal = bstrProcessor.Detach();
            hRes = pPCHSysInfoInstance->SetVariant(pProcessor, varValue);
            if (FAILED(hRes))
            {
                // Set Processor Failed.
                // Proceed anyway
                ErrorTrace(TRACE_ID, "SetVariant on Processor Field failed.");
            }

            //  Copy Property Clock speed
            CopyProperty(pProcessorObj, lpctstrClockSpeed, pPCHSysInfoInstance, pClockSpeed);

        } //end of if WBEM_S_NO_ERROR
        

    } // end of if SUCCEEDED(hRes))        

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //                              RAM                                                                        //
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////

    // Execute the query to get "Name", "TotalPhysicalMemory"
    // from Win32_LogicalMemoryConfiguration Class.
    // Although "Name" is not required to set PCH_SysInfo.RAM property
    // we need to query for it as its the "Key" property of the class.
    // pLogicalMemConfigEnumInst contains a pointer to the list of instances returned.
    //
    hRes = ExecWQLQuery(&pLogicalMemConfigEnumInst, bstrLogicalMemConfigQuery);
    if (SUCCEEDED(hRes))
    {
        // Query on Win32_LogicalMemoryConfiguration Class Succeeded
        // Enumerate the instances of Win32_LogicalMemoryConfiguration Class
        // from pEnumInst.
        // Get the next instance into pLogicalMemConfigObj object.
        //
        if(WBEM_S_NO_ERROR == pLogicalMemConfigEnumInst->Next(WBEM_INFINITE, 1, &pLogicalMemConfigObj, &ulLogicalMemConfigRetVal))
        {
            //Get the TotalPhysicalMemory
            if (FAILED(pLogicalMemConfigObj->Get(lpctstrTotalPhysicalMemory, 0, &varPhysicalMem, NULL, NULL)))
            {
                 // Could not get the RAM
                 ErrorTrace(TRACE_ID, "GetVariant on Win32_LogicalMemoryConfiguration:TotalPhysicalMemory Field failed.");
            } 
            else
            {
                // Got the TotalPhysicalMemory
                // varRAM set to TotalPhysicalMemory. Copy this to bstrResult
                nRam = varPhysicalMem.lVal;
                nRem = nRam % ONEK;
                nRam = nRam/ONEK;
                if (nRem > HALFK)
                {
                    nRam++;
                }
                varRam = nRam;
                hRes = pPCHSysInfoInstance->SetVariant(pRAM, varRam);
                {
                    // Set RAM Failed.
                    // Proceed anyway
                    ErrorTrace(TRACE_ID, "SetVariant on RAM Field failed.");
                }
            }

        }
    } // end of else FAILED(hRes)

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //                              SWAPFILE                                                                   //
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        
    // Execute the query to get "Name", "FreeSpace", "FSName"
    // from Win32_PageFile.
    // pPageFileEnumInst contains a pointer to the list of instances returned.
    //
    hRes = ExecWQLQuery(&pPageFileEnumInst, bstrPageFileQuery);
    if (SUCCEEDED(hRes))
    {
        // Query on Win32_PageFile Class Succeeded
        // Enumerate the instances of Win32_PageFile Class
        // from pEnumInst.
        // Get the next instance into pObj object.
        //
        // Initialize bstrResult to NULL;
        
        if(WBEM_S_NO_ERROR == pPageFileEnumInst->Next(WBEM_INFINITE, 1, &pPageFileObj, &ulPageFileRetVal))
        {
            //Get the Name
            if (FAILED(pPageFileObj->Get(bstrName, 0, &varValue, NULL, NULL)))
            {
                 // Could not get the Name
                 ErrorTrace(TRACE_ID, "GetVariant on Win32_PageFile:Name Field failed.");
            } 
            else
            {
                // Got the Name.
                // varValue set to Name. Copy this to bstrResult
                hRes = varValue.ChangeType(VT_BSTR, NULL);
                if(SUCCEEDED(hRes))
                {
                    bstrSwapFile.Append(V_BSTR(&varValue));

                    // Put some spaces in between the two strings.
                    bstrSwapFile.Append(lpctstrSpaces);
                }
            }

            // Get the FreeSpace
            if (FAILED(pPageFileObj->Get(bstrFreeSpace, 0, &varValue, NULL, NULL)))
            {
                // Could not get the FreeSpace
                ErrorTrace(TRACE_ID, "GetVariant on Win32_PageFile:FreeSpace Field failed.");
            } 
            else
            {
                // Got the FreeSpace
                // varValue set to FreeSpace. Append this to bstrResult
                hRes = varValue.ChangeType(VT_BSTR, NULL);
                if(SUCCEEDED(hRes))
                {
                    bstrSwapFile.Append(V_BSTR(&varValue));

                    // Put some spaces in between the two strings.
                    bstrSwapFile.Append(lpctstrSpaces);

                    bstrSwapFile.Append(lpctstrMBFree);

                }
            }

            
            // Get the FSName
            if (FAILED(pPageFileObj->Get(bstrFSName, 0, &varValue, NULL, NULL)))
            {
                // Could not get the FSName
                ErrorTrace(TRACE_ID, "GetVariant on Win32_PageFile:FSName Field failed.");
            } 
            else
            {
                // Got the FSName
                // varValue set to FSName. Append this to bstrResult
                hRes = varValue.ChangeType(VT_BSTR, NULL);
                if(SUCCEEDED(hRes))
                {
                    bstrSwapFile.Append(V_BSTR(&varValue));
                }
            }

            // Set the SwapFile Property
            // varValue = bstrSwapFile;

            varValue.vt = VT_BSTR;
            varValue.bstrVal = bstrSwapFile.Detach();

            hRes = pPCHSysInfoInstance->SetVariant(pSwapFile, varValue);
            {
                // Set SwapFile Failed.
                // Proceed anyway
                ErrorTrace(TRACE_ID, "SetVariant on SwapFile Field failed.");
            }
            
            
        } //end of if WBEM_S_NO_ERROR

    } // end of else FAILED(hRes)        

    // All the properties are set.

    if(fCommit)
    {
        hRes = pPCHSysInfoInstance->Commit();
        if (FAILED(hRes))
        {
            ErrorTrace(TRACE_ID, "Commit on Instance failed.");
        } 
    }
        
    TraceFunctLeave();
    return hRes ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprov\pch_sysinfo.h ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_Sysinfo.H

Abstract:
	WBEM provider class definition for PCH_Sysinfo class

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

********************************************************************/

// Property set identification
//============================

#ifndef _PCH_Sysinfo_H_
#define _PCH_Sysinfo_H_

#define PROVIDER_NAME_PCH_SYSINFO "PCH_Sysinfo"

// Property name externs -- defined in PCH_Sysinfo.cpp
//=================================================

extern const WCHAR* pTimeStamp ;
extern const WCHAR* pChange ;
extern const WCHAR* pIEVersion ;
extern const WCHAR* pInstall ;
extern const WCHAR* pMode ;
extern const WCHAR* pOSName ;
extern const WCHAR* pOSVersion ;
extern const WCHAR* pProcessor ;
extern const WCHAR* pClockSpeed ;
extern const WCHAR* pRAM ;
extern const WCHAR* pSwapFile ;
extern const WCHAR* pSystemID ;
extern const WCHAR* pUptime ;
extern const WCHAR* pOSLanguage;
extern const WCHAR* pManufacturer;
extern const WCHAR* pModel;
extern const WCHAR* pOSBuildNumber;

class CPCH_Sysinfo : public Provider 
{
	public:
		// Constructor/destructor
		//=======================

		CPCH_Sysinfo(const CHString& chsClassName, LPCWSTR lpszNameSpace) : Provider(chsClassName, lpszNameSpace) {};
		virtual ~CPCH_Sysinfo() {};

	protected:
		// Reading Functions
		//============================
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Writing Functions
		//============================
		virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Other Functions
		virtual HRESULT ExecMethod( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags = 0L ) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprov\pch_winsock.cpp ===
/*****************************************************************************

  Copyright (c) 1999 Microsoft Corporation
  
    Module Name:
        PCH_Winsock.CPP

    Abstract:
        WBEM provider class implementation for PCH_Winsock class.
        This class does not use any existing Win32 Class 

    Revision History:
        Kalyani Narlanka        (kalyanin)                  04/27/99
            - Created

        Kalyani Narlanka        (kalyanin)                  05/10/99
            - Added   Name, Size, Version, Description, SystemStatus, MaxUDP, MAXSockets,
              Change, Timestamp                             


*******************************************************************************/

//  #includes
#include "pchealth.h"
#include "PCH_WINSOCK.h"

//  #defines
//  nMajorVersion represents the Major Version as seen in OSVERSIONINFO
#define             nMajorVersion               4  
//  nMinorVersion represents the Minor Version as seen in OSVERSIONINFO
#define             nMinorVersion               10

///////////////////////////////////////////////////////////////////////////////
//    Begin Tracing stuff
//
#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile
#define TRACE_ID    DCID_WINSOCK
//
//    End Tracing stuff
///////////////////////////////////////////////////////////////////////////////


CPCH_WINSOCK MyPCH_WINSOCKSet (PROVIDER_NAME_PCH_WINSOCK, PCH_NAMESPACE) ;

///////////////////////////////////////////////////////////////////////////////
//....Properties of PCHWinsock Class
//

const static WCHAR* pTimeStamp           = L"TimeStamp" ;
const static WCHAR* pChange              = L"Change" ;
const static WCHAR* pDescription         = L"Description" ;
const static WCHAR* pMaxSockets          = L"MaxSockets" ;
const static WCHAR* pMaxUDP              = L"MaxUDP" ;
const static WCHAR* pName                = L"Name" ;
const static WCHAR* pSize                = L"Size" ;
const static WCHAR* pSystemStatus        = L"SystemStatus" ;
const static WCHAR* pVersion             = L"Version" ;


//*****************************************************************************
//
// Function Name     : CPCH_WINSOCK::EnumerateInstances
//
// Input Parameters  : pMethodContext : Pointer to the MethodContext for 
//                                      communication with WinMgmt.
//                
//                     lFlags :         Long that contains the flags described 
//                                      in IWbemServices::CreateInstanceEnumAsync
//                                      Note that the following flags are handled 
//                                      by (and filtered out by) WinMgmt:
//                                      WBEM_FLAG_DEEP
//                                      WBEM_FLAG_SHALLOW
//                                      WBEM_FLAG_RETURN_IMMEDIATELY
//                                      WBEM_FLAG_FORWARD_ONLY
//                                      WBEM_FLAG_BIDIRECTIONAL
// Output Parameters  : None
//
// Returns            : WBEM_S_NO_ERROR 
//                      
//
// Synopsis           : There is a single instance of this class on the machine 
//                      and this is returned..
//                      If there is no instances returns WBEM_S_NO_ERROR.
//                      It is not an error to have no instances.
//
//*****************************************************************************

HRESULT CPCH_WINSOCK::EnumerateInstances(MethodContext* pMethodContext,
                                                long lFlags)
{
    TraceFunctEnter("CPCH_Winsock::EnumerateInstances");

    //  Begin Declarations...................................................

    HRESULT                                 hRes = WBEM_S_NO_ERROR;

    //  PCH_WinSock Class instance 
    //  CInstance                               *pPCHWinsockInstance;

    //  Strings
    TCHAR                                   tchBuf[MAX_PATH];
    TCHAR                                   tchTemp[MAX_PATH];
    TCHAR                                   szDirectory[MAX_PATH];
    TCHAR                                   tchWinsockDll[MAX_PATH];

    LPCTSTR                                 lpctstrWS2_32Dll                    = _T("ws2_32.dll");
    LPCTSTR                                 lpctstrWSock32Dll                   = _T("wsock32.dll");
    LPCWSTR                                 lpctstrFileSize                     = L"FileSize";
    LPCTSTR                                 lpctstrWSAStartup                   = _T("WSAStartup");
    LPCTSTR                                 lpctstrWSACleanup                   = _T("WSACleanup");

    //  WORDs
    WORD                                    wVersionRequested;

    //  WSAData
    WSADATA                                 wsaData;

    // CComVariants
    CComVariant                             varValue;
    CComVariant                             varSnapshot                         = "Snapshot";

    //  ints
    int                                     nError;

    //  HINSTANCE 
    HINSTANCE                               hModule; 

    //  OSVersion
    OSVERSIONINFO                           osVersionInfo;

    //  SystemTime
    SYSTEMTIME                              stUTCTime;

    //  Strings
    CComBSTR                                bstrWinsockDllWithPath;

    BOOL                                    fWinsockDllFound                  = FALSE;

    struct _stat                            filestat;

    ULONG                                   uiReturn;

    IWbemClassObjectPtr                     pWinsockDllObj;

    LPFN_WSASTARTUP                         WSAStartup;
    LPFN_WSACLEANUP                         WSACleanup;

    BOOL                                    fCommit                         = FALSE;

//  END  Declarations


    //  There is only one instance of PCH_Winsock class

    //  Create a new instance of PCH_Winsock Class based on the passed-in MethodContext
    CInstancePtr pPCHWinsockInstance(CreateNewInstance(pMethodContext), false);

    // Get the date and time to update the TimeStamp Field
    GetSystemTime(&stUTCTime);


    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //                              TIME STAMP                                                                 //
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////

    hRes = pPCHWinsockInstance->SetDateTime(pTimeStamp, WBEMTime(stUTCTime));
    if (FAILED(hRes))
    {
        //  Could not Set the Time Stamp
        //  Continue anyway
        ErrorTrace(TRACE_ID, "SetDateTime on Timestamp Field failed.");
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //                              CHANGE                                                                     //
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////

    hRes = pPCHWinsockInstance->SetVariant(pChange, varSnapshot);
    if (FAILED(hRes))
    {
        //  Could not Set the Change Property
        //  Continue anyway
        ErrorTrace(TRACE_ID, "Set Variant on Change Field failed.");
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //                              NAME                                                                       //
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////

    //  Before callling GetVersionEx set dwOSVersionInfoSize to the foll.
    osVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
   
    if (GetVersionEx(&osVersionInfo) != 0)
    {
        if (osVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
        {
            if ((osVersionInfo.dwMajorVersion == nMajorVersion) && (osVersionInfo.dwMinorVersion >= nMinorVersion))
            {
                _tcscpy(tchWinsockDll, lpctstrWS2_32Dll);
            }
            else if (osVersionInfo.dwMajorVersion > nMajorVersion) 
            {
                _tcscpy(tchWinsockDll, lpctstrWS2_32Dll);
            }
            else 
            {
                _tcscpy(tchWinsockDll, lpctstrWSock32Dll);
            }
        } //end of osVersionInfo.... if
        else if (osVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
        {
            _tcscpy(tchWinsockDll, lpctstrWS2_32Dll);
        }
        else 
        {
            _tcscpy(tchWinsockDll, lpctstrWS2_32Dll);
        }
    } //end of if GetVersionEx
    else
    {
        _tcscpy(tchWinsockDll, lpctstrWS2_32Dll);
    }

    //  Got the right winsock DLL Name
    //  Load the Library
    varValue = tchWinsockDll;
    hModule = LoadLibrary(tchWinsockDll);
    if (hModule == NULL)
    {
        goto END;
    }
    else
    {
        fCommit = TRUE;
    }
    try
    {
        hRes = pPCHWinsockInstance->SetVariant(pName, varValue);
        if (FAILED(hRes))
        {
            //  Could not Set the Change Property
            //  Continue anyway
            ErrorTrace(TRACE_ID, "Set Variant on Name Field failed.");
        }
    }
    catch(...)
    {
        FreeLibrary(hModule);
        throw;
    }
    
    if ((WSAStartup = (LPFN_WSASTARTUP) GetProcAddress(hModule, lpctstrWSAStartup)) == NULL)
    {
        FreeLibrary(hModule);
        goto END;
    }
    if ((WSACleanup = (LPFN_WSACLEANUP) GetProcAddress(hModule, lpctstrWSACleanup)) == NULL)
    {
        FreeLibrary(hModule);
        goto END;       
    }

    try
    {
        wVersionRequested = MAKEWORD( 2, 0 );
        nError = (*WSAStartup)( wVersionRequested, &wsaData );
        if (nError != 0)
        {
            // Cannot get any winsock values
            goto END;
        }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //                              SIZE                                                                //
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////

        fWinsockDllFound =  getCompletePath(tchWinsockDll, bstrWinsockDllWithPath);
        if(fWinsockDllFound)
        {
            // Got the complete Path , use this to get the filesize.
            if(SUCCEEDED(GetCIMDataFile(bstrWinsockDllWithPath, &pWinsockDllObj)))
            {
                // From the CIM_DataFile Object get the size property

                CopyProperty(pWinsockDllObj, lpctstrFileSize, pPCHWinsockInstance, pSize);
        
            }
        }
    
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //                              VERSION                                                                    //
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////

        _stprintf(tchBuf, "%d.%d", LOBYTE(wsaData.wHighVersion), HIBYTE(wsaData.wHighVersion));
        varValue = tchBuf;
        hRes = pPCHWinsockInstance->SetVariant(pVersion, varValue);
        if (FAILED(hRes))
        {
            //  Could not Set the Change Property
            //  Continue anyway
            ErrorTrace(TRACE_ID, "Set Variant on Version Field failed.");
        }
        
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //                              DESCRIPTION                                                                //                                                                              KAYANI                                                                                                                                                                  -9++***************************---------------------------------------------------------+++
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        
        if (_tcslen(wsaData.szDescription) < sizeof(tchBuf))
        {
            _tcscpy(tchBuf, wsaData.szDescription);
        }
        else
        {
            _tcsncpy(tchBuf, wsaData.szDescription, sizeof(tchBuf)-1);
            tchBuf[sizeof(tchBuf)] = 0;
        }

        varValue = tchBuf;
        hRes =  pPCHWinsockInstance->SetVariant(pDescription,  varValue);
        if(FAILED(hRes))
        {
            //  Could not Set the Change Property
            //  Continue anyway
            ErrorTrace(TRACE_ID, "Set Variant on Description Field failed.");
        }
   

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //                              SYSTEMSTATUS                                                               //
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    
        if (_tcslen(wsaData.szSystemStatus) < sizeof(tchBuf))
        _tcscpy(tchBuf, wsaData.szSystemStatus);
        else
        {
            _tcsncpy(tchBuf, wsaData.szSystemStatus, sizeof(tchBuf)-1);
            tchBuf[sizeof(tchBuf)] = 0;
        }
       
        varValue = tchBuf;
        hRes =  pPCHWinsockInstance->SetVariant(pSystemStatus, varValue);
        if (FAILED(hRes))
        {
            //  Could not Set the Change Property
            //  Continue anyway
            ErrorTrace(TRACE_ID, "Set Variant on SystemStatus Field failed.");
        }
   

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //                              MAXUDP                                                               //
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////

        if (LOBYTE(wsaData.wHighVersion) >= 2)
        {
           varValue = 0;
        }
        else
        {
            varValue = wsaData.iMaxUdpDg;
        }
        hRes = pPCHWinsockInstance->SetVariant(pMaxUDP, varValue);
        if (FAILED(hRes))
        {
            //  Could not Set the Change Property
            //  Continue anyway
            ErrorTrace(TRACE_ID, "Set Variant on MAXUDP Field failed.");
        }
    

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //                              MAXSOCKETS                                                                 //
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        
        if (LOBYTE(wsaData.wHighVersion) >= 2)
        {
            varValue = 0;
        }
        else
        {
            varValue = wsaData.iMaxSockets;
        }
        hRes =  pPCHWinsockInstance->SetVariant(pMaxSockets, varValue);
        if (FAILED(hRes))
        {
            //  Could not Set the Change Property
            //  Continue anyway
            ErrorTrace(TRACE_ID, "Set Variant on MaxSockets Field failed.");
        }
        if(fCommit)
        {
            hRes = pPCHWinsockInstance->Commit();
            if (FAILED(hRes))
            {   
                //  Could not Commit
                //  Continue anyway
                ErrorTrace(TRACE_ID, "Commit failed.");
            }
        }

        if(0 != (*WSACleanup)())
        {
             //  Could not Cleanup
            //  Continue anyway
            ErrorTrace(TRACE_ID, "WSACleanup failed.");
        }
        
        FreeLibrary(hModule);
    }
    catch(...)
    {
        if(0 != (*WSACleanup)())
        {
             //  Could not Cleanup
            //  Continue anyway
            ErrorTrace(TRACE_ID, "WSACleanup failed.");
        }
        
        FreeLibrary(hModule);
        throw;
    }

END:    TraceFunctLeave();
        return hRes ;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprov\thunk.c ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	thunk.c

Abstract:
	Thunk procedures for calling 16-bit functions

Revision History:

    Brijesh Krishnaswami (brijeshk) 05/24/99
            - created (imported from msinfo codebase)
********************************************************************/

#include <windows.h>
#include "drvdefs.h"


/***************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   DWORD | TemplateThunk |
 *
 *          Call down, passing all sorts of random parameters.
 *
 *          Parameter signature is as follows:
 *
 *          p = 0:32 pointer to convert to 16:16 pointer
 *          l = a 32-bit integer
 *          s = a 16-bit integer
 *
 *          P = returns a pointer
 *          L = returns a 32-bit integer
 *          S = returns a 16-bit signed integer
 *          U = returns a 16-bit unsigned integer
 *
 ***************************************************************************/
#pragma warning(disable:4035)           // no return value 

__declspec(naked) int
TemplateThunk(FARPROC fp, PCSTR pszSig, ...)
{
    BYTE rgbThunk[60];          // For private use of QT_Thunk 
    LPVOID *ppvArg;
    int i;
    LPVOID pv;
    int iRc;

    __asm {

        // Function prologue 
        push    ebp;
        mov     ebp, esp;
        sub     esp, __LOCAL_SIZE;
        push    ebx;
        push    edi;
        push    esi;

    }

    // Thunk all the parameters according to the signature 
    ppvArg = (LPVOID)(&pszSig+1);
    for (i = 0; ; i++) {
        pv = ppvArg[i];
        switch (pszSig[i]) {
        case 'p':
            pv = ppvArg[i] = MapLS(pv);
            __asm push pv;
            break;

        case 'l':
            __asm push pv;
            break;

        case 's':
            __asm mov eax, pv;
            __asm push ax;
            break;

        default: goto doneThunk;
        }
    }

doneThunk:;

    // Call the 16:16 procedure 
    __asm {
        mov     edx, fp;
        mov     ebx, ebp;
        lea     ebp, rgbThunk+64;               // Required by QT_Thunk 
    }
        QT_Thunk();
    __asm {
        mov     ebp, ebx;
        shl     eax, 16;                        // Convert DX:AX to EAX 
        shrd    eax, edx, 16;
        mov     iRc, eax;
    }

    // Now unthunk the parameters 
    ppvArg = (LPVOID)(&pszSig+1);
    for (i = 0; ; i++) {
        switch (pszSig[i]) {
        case 'p':
            UnMapLS(ppvArg[i]);
            break;

        case 'l':
        case 's':
            break;

        default: goto doneUnthunk;
        }
    }

doneUnthunk:;

    // Thunk the return value 
    switch (pszSig[i]) {
    case 'L':
        break;

    case 'U':
        iRc = LOWORD(iRc);
        break;

    case 'S':
        iRc = (short)iRc;
        break;

    case 'P':
        iRc = (int)MapSL((LPVOID)iRc);
        break;
    }

    __asm {
        mov     eax, iRc;
        pop     esi;
        pop     edi;
        pop     ebx;
        mov     esp, ebp;
        pop     ebp;
        ret;
    }
}



#pragma warning(default:4035)


/***************************************************************************
 *
 *          Functions we call down in Win16.
 *
 ***************************************************************************/

FARPROC g_rgfpKernel[] = {
    (FARPROC)132,           /* GetWinFlags */
    (FARPROC)355,           /* GetWinDebugInfo */
    (FARPROC)169,           /* GetFreeSpace */
    (FARPROC) 47,           /* GetModuleHandle */
    (FARPROC) 93,           /* GetCodeHandle */
    (FARPROC)104,           /* GetCodeInfo */
    (FARPROC) 49,           /* GetModuleFileName */
    (FARPROC)175,           /* AllocSelector */
    (FARPROC)186,           /* GetSelectorBase */
    (FARPROC)187,           /* SetSelectorBase */
    (FARPROC)188,           /* GetSelectorLimit */
    (FARPROC)189,           /* SetSelectorLimit */
    (FARPROC)176,           /* FreeSelector */
    (FARPROC) 27,           /* GetModuleName */
    (FARPROC)167,           /* GetExpWinVer */
    (FARPROC)184,           /* GlobalDosAlloc */
    (FARPROC)185,           /* GlobalDosFree */
    (FARPROC) 16,           /* GlobalReAlloc */
};


#define g_fpGetWinFlags         g_rgfpKernel[0]
#define g_fpGetWinDebugInfo     g_rgfpKernel[1]
#define g_fpGetFreeSpace        g_rgfpKernel[2]
#define g_fpGetModuleHandle     g_rgfpKernel[3]
#define g_fpGetCodeHandle       g_rgfpKernel[4]
#define g_fpGetCodeInfo         g_rgfpKernel[5]
#define g_fpGetModuleFileName   g_rgfpKernel[6]
#define g_fpAllocSelector       g_rgfpKernel[7]
#define g_fpGetSelectorBase     g_rgfpKernel[8]
#define g_fpSetSelectorBase     g_rgfpKernel[9]
#define g_fpGetSelectorLimit    g_rgfpKernel[10]
#define g_fpSetSelectorLimit    g_rgfpKernel[11]
#define g_fpFreeSelector        g_rgfpKernel[12]
#define g_fpGetModuleName       g_rgfpKernel[13]
#define g_fpGetExpWinVer        g_rgfpKernel[14]
#define g_fpGlobalDosAlloc      g_rgfpKernel[15]
#define g_fpGlobalDosFree       g_rgfpKernel[16]
#define g_fpGlobalReAlloc       g_rgfpKernel[17]


FARPROC g_rgfpUser[] = {
    (FARPROC)216,           /* UserSeeUserDo */
    (FARPROC)284,           /* GetFreeSystemResources */
    (FARPROC)256,           /* GetDriverInfo */
    (FARPROC)257,           /* GetNextDriver */
};

#define g_fpUserSeeUserDo           g_rgfpUser[0]
#define g_fpGetFreeSystemResources  g_rgfpUser[1]
#define g_fpGetDriverInfo           g_rgfpUser[2]
#define g_fpGetNextDriver           g_rgfpUser[3]


/***************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | ThunkGetProcAddresses |
 *
 *          Get all the necessary proc addresses.
 *
 ***************************************************************************/

HINSTANCE 
ThunkGetProcAddresses(FARPROC *rgfp, UINT cfp, LPCTSTR ptszLibrary,
                      BOOL fFree)
{
    HINSTANCE hinst;

    hinst = LoadLibrary16(ptszLibrary);
    if (hinst >= (HINSTANCE)32) {
        UINT ifp;
        for (ifp = 0; ifp < cfp; ifp++) {
            rgfp[ifp] = GetProcAddress16(hinst, (PVOID)rgfp[ifp]);
        }

        if (fFree) {
            FreeLibrary16(hinst);
        }

    } else {
        hinst = 0;
    }

    return hinst;

}

/***************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | ThunkInit |
 *
 *          GetProcAddress16 our brains out.
 *
 ***************************************************************************/

LPVOID g_pvWin16Lock = NULL;
HINSTANCE g_hinstUser;

void  
ThunkInit(void)
{
    if (g_pvWin16Lock == NULL)
    {
        ThunkGetProcAddresses(g_rgfpKernel, cA(g_rgfpKernel), TEXT("KERNEL"), 1);
        g_hinstUser = ThunkGetProcAddresses(g_rgfpUser, cA(g_rgfpUser), TEXT("USER"), 1);
        GetpWin16Lock(&g_pvWin16Lock);
    }
}


HMODULE16  
GetModuleHandle16(LPCSTR pszModule)
{
    return (HMODULE16)TemplateThunk(g_fpGetModuleHandle, "pU", pszModule);
}

int  
GetModuleFileName16(HMODULE16 hmod, LPSTR sz, int cch)
{
    return TemplateThunk(g_fpGetModuleFileName, "spsS", hmod, sz, cch);
}

int  
GetModuleName16(HMODULE16 hmod, LPSTR sz, int cch)
{
    return TemplateThunk(g_fpGetModuleName, "spsS", hmod, sz, cch);
}

UINT  
AllocCodeSelector16(void)
{
    return TemplateThunk(g_fpAllocSelector, "sU", HIWORD(g_fpAllocSelector));
}


DWORD  
GetSelectorBase16(UINT sel)
{
    return TemplateThunk(g_fpGetSelectorBase, "sL", sel);
}


UINT  
SetSelectorBase16(UINT sel, DWORD dwBase)
{
    return TemplateThunk(g_fpSetSelectorBase, "slU", sel, dwBase);
}


DWORD  
GetSelectorLimit16(UINT sel)
{
    return TemplateThunk(g_fpGetSelectorLimit, "sL", sel);
}


UINT  
SetSelectorLimit16(UINT sel, DWORD dwLimit)
{
    return TemplateThunk(g_fpSetSelectorLimit, "slU", sel, dwLimit);
}

UINT  
FreeSelector16(UINT sel)
{
    return TemplateThunk(g_fpFreeSelector, "sU", sel);
}

WORD  
GetExpWinVer16(HMODULE16 hmod)
{
    return (WORD)TemplateThunk(g_fpGetExpWinVer, "sS", hmod);
}

DWORD  
GlobalDosAlloc16(DWORD cb)
{
    return (DWORD)TemplateThunk(g_fpGlobalDosAlloc, "lL", cb);
}

UINT  
GlobalDosFree16(UINT uiSel)
{
    return (UINT)TemplateThunk(g_fpGlobalDosFree, "sS", uiSel);
}

/*
 *  Kernel has thunks for GlobalAlloc, GlobalFree, but not GlobalRealloc.
 */
WORD  
GlobalReAlloc16(WORD hglob, DWORD cb, UINT fl)
{
    return (WORD)TemplateThunk(g_fpGlobalReAlloc, "slsS", hglob, cb, fl);
}

#define SD_ATOMNAME     0x000E

UINT
GetUserAtomName(UINT atom, LPSTR psz)
{
    return (UINT)TemplateThunk(g_fpUserSeeUserDo, "sspS",
                               SD_ATOMNAME, atom, psz);
}

#define SD_GETRGPHKSYSHOOKS 0x0010

DWORD 
GetUserHookTable(void)
{
    return (UINT)TemplateThunk(g_fpUserSeeUserDo, "sslL",
                               SD_GETRGPHKSYSHOOKS, 0, 0);
}


BOOL  
GetDriverInfo16(WORD hDriver, DRIVERINFOSTRUCT16* pdis)
{
    return (BOOL)TemplateThunk(g_fpGetDriverInfo, "spS", hDriver, pdis);
}

WORD  
GetNextDriver16(WORD hDriver, DWORD fdwFlag)
{
    return (WORD)TemplateThunk(g_fpGetNextDriver, "slS", hDriver, fdwFlag);

}


/***************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | Int86x |
 *
 *          Issue a real-mode software interrupt.
 *
 *          We do this by allocating a temporary code selector and
 *          thunking to it.
 *
 *
 ***************************************************************************/

BYTE rgbInt31[] = {
    0x55,                       /* push bp          */
    0x8B, 0xEC,                 /* mov  bp, sp      */
    0x57,                       /* push di          */
    0xC4, 0x7E, 0x06,           /* les  di, [bp+6]  */
    0x8B, 0x5E, 0x0A,           /* mov  bx, [bp+10] */
    0x33, 0xC9,                 /* xor  cx, cx      */
    0xB8, 0x00, 0x03,           /* mov  ax, 0300h   */
    0xCD, 0x31,                 /* int  31h         */
    0x72, 0x02,                 /* jc   $+4         */
    0x33, 0xC0,                 /* xor  ax, ax      */
    0x5F,                       /* pop  di          */
    0x5D,                       /* pop  bp          */
    0xCA, 0x06, 0x00,           /* retf 6           */
};

UINT  
Int86x(UINT intno, PRMIREGS preg)
{
    UINT selCode = AllocCodeSelector16();
    UINT uiRc;
    if (selCode) {
        SetSelectorBase16(selCode, (DWORD)rgbInt31);
        SetSelectorLimit16(selCode, sizeof(rgbInt31));
        preg->ss = preg->sp = 0;
        uiRc = (UINT)TemplateThunk((FARPROC)MAKELONG(0, selCode),
                                   "spU", intno, preg);
        FreeSelector16(selCode);
    } else {
        uiRc = 0x8011;          /* Descriptor unavailable */
    }
    return uiRc;
}


/***************************************************************************
 *
 *  @doc    INTERNAL : ported from msinfo 4.10 code
 *
 *  @func   Token_Find |
 *
 *          Returns the first token in the string.
 *
 *          Tokens are space or comma separated strings.  Quotation marks
 *          have no effect.  We also treat semicolons as separators.
 *          (This lets us use this routine for walking the PATH too.)
 *
 *          *pptsz is modified in place to contain a pointer that can
 *          be passed subsequently to Token_Find to pull the next token.
 *
 ***************************************************************************/
LPTSTR Token_Find(LPTSTR *pptsz)
{
    LPTSTR ptsz = *pptsz;
    while (*ptsz) {

        /*
         *  Skip leading separators.
         */
        while (*ptsz == TEXT(' ') ||
               *ptsz == TEXT(',') ||
               *ptsz == TEXT(';')) {
            ptsz++;
        }

        if (*ptsz) {
            LPTSTR ptszStart = ptsz;

            /*
             *  Skip until we see a separator.
             */
            while (*ptsz != TEXT('\0') &&
                   *ptsz != TEXT(' ') &&
                   *ptsz != TEXT(',') &&
                   *ptsz != TEXT(';')) {
                ptsz++;
            }

            /*
             *  Wipe out the separator, and advance ptsz past it
             *  if there is something after it.  (Don't advance
             *  it beyond the end of the string!)
             */
            if (*ptsz) {
                *ptsz++ = 0;
            }
            *pptsz = ptsz;

            return ptszStart;

        } else {
            break;
        }
    }
    return 0;
}



#pragma warning(default:4035)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprov\pch_winsock.h ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_WINSOCK.H

Abstract:
	WBEM provider class definition for PCH_WINSOCK class

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

********************************************************************/

// Property set identification
//============================

#ifndef _PCH_WINSOCK_H_
#define _PCH_WINSOCK_H_

#define PROVIDER_NAME_PCH_WINSOCK "PCH_WINSOCK"

// Property name externs -- defined in PCH_WINSOCK.cpp
//=================================================

extern const WCHAR* pTimeStamp ;
extern const WCHAR* pChange ;
extern const WCHAR* pDescription ;
extern const WCHAR* pMaxSockets ;
extern const WCHAR* pMaxUDP ;
extern const WCHAR* pName ;
extern const WCHAR* pSize ;
extern const WCHAR* pSystemStatus ;
extern const WCHAR* pVersion ;

class CPCH_WINSOCK : public Provider 
{
	public:
		// Constructor/destructor
		//=======================

		CPCH_WINSOCK(const CHString& chsClassName, LPCWSTR lpszNameSpace) : Provider(chsClassName, lpszNameSpace) {};
		virtual ~CPCH_WINSOCK() {};

	protected:
		// Reading Functions
		//============================
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Writing Functions
		//============================
		virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Other Functions
		virtual HRESULT ExecMethod( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags = 0L ) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprovn\maindll.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	MAINDLL.CPP

Abstract:
	Contains DLL entry points.  Also has code that controls
	when the DLL can be unloaded by tracking the number of
	objects and locks as well as routines that support
	self registration.

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

********************************************************************/

#include "pchealth.h"
#include <objbase.h>
#include <initguid.h>
#include <WBEMGlue.h>

/////////////////////////////////////////////////////////////////////////////
//  tracing stuff

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile
#define TRACE_ID    DCID_MAINDLL

HMODULE ghModule;
//============

WCHAR *GUIDSTRING = L"{c52586f0-f805-11d2-b3a7-00c04fa35c1a}";
CLSID CLSID_PCH_WINSOCK;

//Count number of objects and number of locks.

long       g_cLock=0;

//
// Keep a global IWbemServices pointer, since we use it frequently and
// it's a little expensive to get.
//
CComPtr<IWbemServices> g_pWbemServices = NULL;


//***************************************************************************
//
//  DllGetClassObject
//
//  Purpose: Called by Ole when some client wants a class factory.  Return 
//           one only if it is the sort of class this DLL supports.
//
//***************************************************************************


STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, PPVOID ppv)
{
    HRESULT hr;
    CWbemGlueFactory *pObj;

	CLSIDFromString(GUIDSTRING, &CLSID_PCH_WINSOCK);
    if (CLSID_PCH_WINSOCK!=rclsid)
        return E_FAIL;

    pObj=new CWbemGlueFactory();

    if (NULL==pObj)
        return E_OUTOFMEMORY;

    hr=pObj->QueryInterface(riid, ppv);

    if (FAILED(hr))
        delete pObj;

    return hr;
}

//***************************************************************************
//
// DllCanUnloadNow
//
// Purpose: Called periodically by Ole in order to determine if the
//          DLL can be freed.
//
// Return:  S_OK if there are no objects in use and the class factory 
//          isn't locked.
//
//***************************************************************************

STDAPI DllCanUnloadNow(void)
{
    SCODE   sc;

    // It is OK to unload if there are no objects or locks on the 
    // class factory and the framework is done with you.
    
    if ((0L==g_cLock) && CWbemProviderGlue::FrameworkLogoffDLL(L"PCH_WINSOCK"))
	{
		sc = S_OK;
	}
	else
	{
		sc = S_FALSE;
	}
    return sc;
}

//***************************************************************************
//
//  Is4OrMore
//
//  Returns true if win95 or any version of NT > 3.51
//
//***************************************************************************

BOOL Is4OrMore(void)
{
    OSVERSIONINFO os;
    os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if(!GetVersionEx(&os))
        return FALSE;           // should never happen
    return os.dwMajorVersion >= 4;
}

//***************************************************************************
//
// DllRegisterServer
//
// Purpose: Called during setup or by regsvr32.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllRegisterServer(void)
{   
    char       szID[128];
    WCHAR      wcID[128];
    char       szCLSID[128];
    char       szModule[MAX_PATH];
    char * pName = "";
    char * pModel;
    HKEY hKey1, hKey2;

	ghModule = GetModuleHandle("pchprov");

    // TO DO: Using 'Both' is preferable.  The framework is designed and written to support
    // free threaded code.  If you will be writing free-threaded code, uncomment these 
    // three lines.

    if(Is4OrMore())
        pModel = "Both";
    else
        pModel = "Apartment";

    // Create the path.

	CLSIDFromString(GUIDSTRING, &CLSID_PCH_WINSOCK);
    StringFromGUID2(CLSID_PCH_WINSOCK, wcID, 128);
    wcstombs(szID, wcID, 128);
    lstrcpy(szCLSID, TEXT("SOFTWARE\\CLASSES\\CLSID\\"));
    lstrcat(szCLSID, szID);

    // Create entries under CLSID

    RegCreateKey(HKEY_LOCAL_MACHINE, szCLSID, &hKey1);
    RegSetValueEx(hKey1, NULL, 0, REG_SZ, (BYTE *)pName, lstrlen(pName)+1);
    RegCreateKey(hKey1,"InprocServer32",&hKey2);

    GetModuleFileName(ghModule, szModule,  MAX_PATH);
    RegSetValueEx(hKey2, NULL, 0, REG_SZ, (BYTE *)szModule, 
                                        lstrlen(szModule)+1);
    RegSetValueEx(hKey2, "ThreadingModel", 0, REG_SZ, 
                                        (BYTE *)pModel, lstrlen(pModel)+1);
    CloseHandle(hKey1);
    CloseHandle(hKey2);
    return NOERROR;
}

//***************************************************************************
//
// DllUnregisterServer
//
// Purpose: Called when it is time to remove the registry entries.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllUnregisterServer(void)
{
    char       szID[128];
    WCHAR      wcID[128];
    char  szCLSID[128];
    HKEY hKey;

    // Create the path using the CLSID

	CLSIDFromString(GUIDSTRING, &CLSID_PCH_WINSOCK);
    StringFromGUID2(CLSID_PCH_WINSOCK, wcID, 128);
    wcstombs(szID, wcID, 128);
    lstrcpy(szCLSID, TEXT("SOFTWARE\\CLASSES\\CLSID\\"));
    lstrcat(szCLSID, szID);

    // First delete the InProcServer subkey.

    DWORD dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, szCLSID, &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey, "InProcServer32");
        CloseHandle(hKey);
    }

    dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\CLASSES\\CLSID\\"), &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey,szID);
        CloseHandle(hKey);
    }

    return NOERROR;
}

BOOL APIENTRY DllMain (	HINSTANCE hInstDLL,	// handle to dll module
						DWORD fdwReason,	// reason for calling function
						LPVOID lpReserved	)	// reserved
{
    BOOL bRet = TRUE;
	
	// Perform actions based on the reason for calling.
    switch( fdwReason ) 
    { 
        case DLL_PROCESS_ATTACH:
         // Initialize once for each new process.
         // Return FALSE to fail DLL load.
			bRet = CWbemProviderGlue::FrameworkLoginDLL(L"PCH_WINSOCK");
            break;

        case DLL_THREAD_ATTACH:
         // Do thread-specific initialization.
            break;

        case DLL_THREAD_DETACH:
         // Do thread-specific cleanup.
            break;

        case DLL_PROCESS_DETACH:
         // Perform any necessary cleanup.
            break;
    }

    return bRet;  // Sstatus of DLL_PROCESS_ATTACH.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprovn\drvdefs.h ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	drvdefs.h

Abstract:
	header file containing pieces of code from msinfo codebase

Revision History:

    Brijesh Krishnaswami (brijeshk) 05/25/99
        - created
********************************************************************/

#ifndef _DRV16_H
#define _DRV16_H

#ifdef __cplusplus
extern "C" {
#endif

// defines and structs for getting User Mode drivers

#define GND_FORWARD                 0
#define GND_FIRSTINSTANCEONLY       1
#define GND_REVERSE                 2

#define IOCTL_CONNECT           1
#define IOCTL_DISCONNECT        2
#define IOCTL_GETINFO           3
#define IOCTL_GETVXDLIST        4
#define IOCTL_MAPFLAT           5

#define LAR_PAGEGRAN    0x00800000  /* Is page granular */
#define LAR_32BIT       0x00400000  /* Is 32-bit */
#define LAR_PRESENT     0x00008000  /* Is present */
#define LAR_APPL        0x00004000  /* Is normal (not a task gate) ;Internal */
#define LAR_TYPEMASK    0x00000E00  /* Selector type mask */
#define LAR_CODE        0x00000800  /* Is a code selector */
#define LAR_EXPANDDOWN  0x00000400  /* Is expand-down (data) */
#define LAR_READ        0x00000200  /* Is readable (code) */
#define LAR_WRITE       0x00000200  /* Is writeable (data) */
#define LAR_INVALID     0xff0000ff  /* Invalid (bottom bit important) */


// general util macros
#define cA(a) (sizeof(a)/sizeof(a[0]))
#define OBJAT(T, pv)    (*(T *)(pv))
#define PUN(T, v)       OBJAT(T, &(v))
#define pvAddPvCb(pv, cb) ((PVOID)((PBYTE)pv + (cb)))

typedef WORD HMODULE16;

typedef struct DRIVERINFOSTRUCT16 {
    WORD    length;
    WORD    hDriver;
    WORD    hModule;
    char    szAliasName[128];
} DRIVERINFOSTRUCT16;


// defines and structs used for getting MSDos drivers

#define DIFL_PSP        0x0001  /* It's a PSP */
#define DIFL_TSR        0x0002  /* It's a TSR (or might be) */
#define DIFL_DRV        0x0004  /* It's a device driver */

#pragma pack(1)
typedef struct ARENA {          /* DOS arena header */
    BYTE    bType;
    WORD    segOwner;
    WORD    csegSize;
    BYTE    rgbPad[3];
    char    rgchOwner[8];
} ARENA, *PARENA;

typedef struct VXDOUT {
    DWORD   dwHighLinear;
    PVOID   pvVmmDdb;
} VXDOUT, *PVXDOUT;


typedef struct VXDINFO {
    HWND    hwnd;
    FARPROC lpfnGetCurrentTibFS;
    FARPROC lpfnGetCurrentProcessId;
    FARPROC lpfnGetCurrentThreadId;
    FARPROC GetCommandLineA;
    FARPROC UnhandledExceptionFilter;
} VXDINFO;


typedef struct RMIREGS {
    union {
        struct {                    /* DWORD registers */
            DWORD   edi;
            DWORD   esi;
            DWORD   ebp;
            DWORD   res1;
            DWORD   ebx;
            DWORD   edx;
            DWORD   ecx;
            DWORD   eax;
        };

        struct {                    /* WORD registers */
            WORD    di;
            WORD    res2;
            WORD    si;
            WORD    res3;
            WORD    bp;
            WORD    res4;
            DWORD   res5;
            WORD    bx;
            WORD    res6;
            WORD    dx;
            WORD    res7;
            WORD    cx;
            WORD    res8;
            WORD    ax;
            WORD    res9;
        };

        struct {                    /* BYTE registers */
            DWORD   res10[4];       /* edi, esi, ebp, esp */
            BYTE    bl;
            BYTE    bh;
            WORD    res11;
            BYTE    dl;
            BYTE    dh;
            WORD    res12;
            BYTE    cl;
            BYTE    ch;
            WORD    res13;
            BYTE    al;
            BYTE    ah;
            WORD    res14;
        };
    };

    WORD    flags;
    WORD    es;
    WORD    ds;
    WORD    fs;
    WORD    gs;
    WORD    ip;
    WORD    cs;
    WORD    sp;
    WORD    ss;
} RMIREGS, *PRMIREGS;

#pragma pack()

// 16-bit function prototypes
LPVOID WINAPI MapLS(LPVOID);
void WINAPI UnMapLS(LPVOID);
LPVOID NTAPI MapSL(LPVOID);
void NTAPI UnMapSLFix(LPVOID pv);
HMODULE16 NTAPI GetModuleHandle16(LPCSTR);
int NTAPI GetModuleFileName16(HMODULE16 hmod, LPSTR sz, int cch);
int NTAPI GetModuleName16(HMODULE16 hmod, LPSTR sz, int cch);
WORD NTAPI GetExpWinVer16(HMODULE16 hmod);
BOOL GetDriverInfo16(WORD hDriver, DRIVERINFOSTRUCT16* pdis);
WORD GetNextDriver16(WORD hDriver, DWORD fdwFlag);
UINT AllocCodeSelector16(void);
UINT SetSelectorBase16(UINT sel, DWORD dwBase);
DWORD GetSelectorLimit16(UINT sel);
UINT SetSelectorLimit16(UINT sel, DWORD dwLimit);
UINT FreeSelector16(UINT sel);
UINT NTAPI FreeLibrary16(HINSTANCE);
void _cdecl QT_Thunk(void);
HINSTANCE WINAPI LoadLibrary16(LPCSTR);
FARPROC WINAPI GetProcAddress16(HINSTANCE, LPCSTR);
void WINAPI GetpWin16Lock(LPVOID *);

void ThunkInit(void);
UINT Int86x(UINT, PRMIREGS);
LPTSTR Token_Find(LPTSTR *);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprov\version.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	version.CPP

Abstract:
	Implementation of class to provide version information about
    a file using functions pulled from the Dr. Watson source.

Revision History:

    Jim Martin          (a-jammar) 05/22/99
        - Created.

********************************************************************/

#include "pchealth.h"
#include <winver.h>

#define TRACE_ID DCID_VERSION

//-----------------------------------------------------------------------------
// Local structures and macros used to retrieve the file version information.
// These are necessary to use to the Dr. Watson codebase without too much
// modification.
//-----------------------------------------------------------------------------

struct VERSIONSTATE 
{
    PVOID  pvData;
    TCHAR  tszLang[9];
    TCHAR  tszLang2[9];
};

struct FILEVERSION 
{
    TCHAR   tszFileVersion[32];         /* File version */
    TCHAR   tszDesc[MAX_PATH];          /* File description */
    TCHAR   tszCompany[MAX_PATH];       /* Manufacturer */
    TCHAR   tszProduct[MAX_PATH];       /* Enclosing product */
};

typedef VERSIONSTATE * PVERSIONSTATE;
typedef FILEVERSION * PFILEVERSION;

BOOL _GetVersionString(PVERSIONSTATE pvs, LPCTSTR ptszKey, LPTSTR ptszBuf);
BOOL __GetVersionString(PVOID pvData, LPCTSTR ptszLang, LPCTSTR ptszKey, LPTSTR ptszBuf);
void GetFileVersion(LPTSTR ptszFile, FILEVERSION * pfv);

#define pvSubPvCb(pv, cb) ((PVOID)((PBYTE)pv - (cb)))
#define pvAddPvCb(pv, cb) ((PVOID)((PBYTE)pv + (cb)))
#define cbSubPvPv(p1, p2) ((PBYTE)(p1) - (PBYTE)(p2))
#define cbX(X) sizeof(X)
#define cA(a) (cbX(a)/cbX(a[0]))

char c_szStringFileInfo[] = "StringFileInfo";

//-----------------------------------------------------------------------------
// The constructor and destructor don't have too much to do.
//-----------------------------------------------------------------------------

CFileVersionInfo::CFileVersionInfo() : m_pfv(NULL)
{
}

CFileVersionInfo::~CFileVersionInfo()
{
    delete m_pfv;
}

//-----------------------------------------------------------------------------
// The Get functions are also really simple.
//-----------------------------------------------------------------------------

LPCTSTR CFileVersionInfo::GetVersion()
{
    return (m_pfv) ? (m_pfv->tszFileVersion) : NULL;
}

LPCTSTR CFileVersionInfo::GetDescription()
{
    return (m_pfv) ? (m_pfv->tszDesc) : NULL;
}

LPCTSTR CFileVersionInfo::GetCompany()
{
    return (m_pfv) ? (m_pfv->tszCompany) : NULL;
}

LPCTSTR CFileVersionInfo::GetProduct()
{
    return (m_pfv) ? (m_pfv->tszProduct) : NULL;
}

//-----------------------------------------------------------------------------
// QueryFile get information about the requested file. If necessary, it will
// convert a path with double backslashes to single backslashes before calling
// the helper function GetFileVersion from Dr. Watson code.
//-----------------------------------------------------------------------------

HRESULT CFileVersionInfo::QueryFile(LPCSTR szFile, BOOL fHasDoubleBackslashes)
{
    TraceFunctEnter("CFileVersionInfo::QueryFile");

    HRESULT hRes = S_OK;
    LPSTR   szWorking;
    
    if (!m_pfv)
        m_pfv = new FILEVERSION;

    if (!m_pfv)
    {
        hRes = E_OUTOFMEMORY;
        goto END;
    }

    szWorking = (LPSTR) szFile;
    if (fHasDoubleBackslashes)
    {
        szWorking = new char[strlen(szFile)];
        if (!szWorking)
        {
            hRes = E_OUTOFMEMORY;
            goto END;
        }

        // Scan through the passed string, converting double backslashes to single
        // backslashes.

        int i = 0, j = 0;
        while (szFile[i])
        {
            if (szFile[i] == '\\' && szFile[i + 1] == '\\')
                i += 1;
            szWorking[j++] = szFile[i++];
        }
        szWorking[j] = '\0';
    }

    GetFileVersion(szWorking, m_pfv);

    if (fHasDoubleBackslashes)
        delete [] szWorking;

END:
    TraceFunctLeave();
    return hRes;
}

//-----------------------------------------------------------------------------
// An alternate version of the previous function which takes a UNICODE string.
//-----------------------------------------------------------------------------

HRESULT CFileVersionInfo::QueryFile(LPCWSTR szFile, BOOL fHasDoubleBackslashes)
{
    TraceFunctEnter("CFileVersionInfo::QueryFile");

    // Convert the string from UNICODE to ANSI.

    USES_CONVERSION;
    LPSTR szConvertedFile = W2A(szFile); 

    HRESULT hRes = this->QueryFile(szConvertedFile, fHasDoubleBackslashes);

    TraceFunctLeave();
    return hRes;
}


//-----------------------------------------------------------------------------
// Gets the version information for the file ptszFile, and fillsin the pfv
// FILEVERSION structure.
//-----------------------------------------------------------------------------

void GetFileVersion(LPTSTR ptszFile, FILEVERSION * pfv)
{
    TraceFunctEnter("GetFileVersion");

    // Open the file and take out the description.

    DWORD cbScratch, cbRc;

    memset(pfv, 0, sizeof(FILEVERSION));

    cbRc = GetFileVersionInfoSize(ptszFile, &cbScratch);
    if (cbRc) 
    {
        VERSIONSTATE vs;
        memset(&vs, 0, sizeof(VERSIONSTATE));

        vs.pvData = new unsigned char[cbRc]; // BUGBUG
        if (vs.pvData) 
        {
            if (GetFileVersionInfo(ptszFile, cbScratch, cbRc, vs.pvData)) 
            {
                UINT    uiRc;
                LPDWORD pdwLang;

                if (VerQueryValue(vs.pvData, TEXT("VarFileInfo\\Translation"), (PVOID *) &pdwLang, &uiRc) && uiRc >= 4)
                {
                    wsprintf(vs.tszLang, TEXT("%04x%04x"), LOWORD(*pdwLang), HIWORD(*pdwLang));

                    if (cbRc > 0x70 && ((LPBYTE)pvAddPvCb(vs.pvData, 0x4C))[14] == 0 &&
                        lstrcmpi(c_szStringFileInfo, (LPCTSTR) pvAddPvCb(vs.pvData, 0x4C)) == 0)
                    {
                        lstrcpyn(vs.tszLang2, (LPCTSTR) pvAddPvCb(vs.pvData, 0x60), cA(vs.tszLang2));
                    } 
                    else 
                    {
                        vs.tszLang2[0] = 0;
                    }
                }

                if (vs.tszLang[0] == 0)
                {
#ifdef UNICODE
                    // Try English Unicode

                    lstrcpy(vs.tszLang, TEXT("040904B0"));
                    if (!_GetVersionString(&vs, TEXT("FileVersion"), pfv->tszFileVersion))
                    {
#endif
                    // Try English

                    lstrcpy(vs.tszLang, TEXT("040904E4"));
                    if (!_GetVersionString(&vs, TEXT("FileVersion"), pfv->tszFileVersion))
                    {
                        // Try English null codepage

                        lstrcpy(vs.tszLang, TEXT("04090000"));
                        if (!_GetVersionString(&vs, TEXT("FileVersion"), pfv->tszFileVersion))
                            goto LNoVersion;
                    }
#ifdef UNICODE
                    }
#endif
                }
                else
                    _GetVersionString(&vs, TEXT("FileVersion"), pfv->tszFileVersion);

                _GetVersionString(&vs, TEXT("FileDescription"), pfv->tszDesc);
                _GetVersionString(&vs, TEXT("CompanyName"), pfv->tszCompany);
                _GetVersionString(&vs, TEXT("ProductName"), pfv->tszProduct);
            }

LNoVersion:
            delete [] vs.pvData;
        }
    }
    TraceFunctLeave();
}

//-----------------------------------------------------------------------------
// Using the version state, retrieve the version string specified by ptszKey
// and put it in the ptszBuf. This just calls another internal function, trying
// both possible languages.
//-----------------------------------------------------------------------------

BOOL _GetVersionString(PVERSIONSTATE pvs, LPCTSTR ptszKey, LPTSTR ptszBuf)
{
    TraceFunctEnter("_GetVersionString");

    BOOL fRc;

    fRc = __GetVersionString(pvs->pvData, pvs->tszLang, ptszKey, ptszBuf);

    if (!fRc)
        fRc = __GetVersionString(pvs->pvData, pvs->tszLang2, ptszKey, ptszBuf);

    TraceFunctLeave();
    return fRc;
}

//-----------------------------------------------------------------------------
// An internal function to try to get the data specified by the ptszKey, using
// the ptszLang language and codepage.
//-----------------------------------------------------------------------------

BOOL __GetVersionString(PVOID pvData, LPCTSTR ptszLang, LPCTSTR ptszKey, LPTSTR ptszBuf)
{
    TraceFunctEnter("__GetVersionString");

    TCHAR   tszBuf[128];
    LPCTSTR ptszResult;
    UINT    uiRc;
    BOOL    fRc;

    wsprintf(tszBuf, TEXT("\\%s\\%s\\%s"), c_szStringFileInfo, ptszLang, ptszKey);

    if (VerQueryValue(pvData, tszBuf, (PVOID *)&ptszResult, &uiRc))
        fRc = (BOOL)lstrcpyn(ptszBuf, ptszResult, MAX_PATH);
    else
        fRc = FALSE;

    TraceFunctLeave();
    return fRc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprov\util.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    util.CPP

Abstract:
    File containing utility classes

Revision History:

    Ghim-Sim Chua       (gschua)   04/27/99
        - Created

    Jim Martin          (a-jammar) 04/30/99
        - Changed to use global IWbemServices pointer, and added
          GetWbemServices, CopyProperty, and GetCIMDataFile

    Ghim-Sim Chua       (gschua)   05/01/99
        - Modified GetWbemServices, GetCIMDataFile

    Kalyani Narlanka    (kalyanin)  05/11/99
        - Added the function GetCompletePath

********************************************************************/

#include "pchealth.h"

#define TRACE_ID    DCID_UTIL

//-----------------------------------------------------------------------------
// Returns an IWbemServices pointer. The caller is responsible for releasing
// the object.
//-----------------------------------------------------------------------------
HRESULT GetWbemServices(IWbemServices **ppServices)
{
    TraceFunctEnter("::GetWbemServices");

    HRESULT hRes = S_OK;
    CComPtr<IWbemLocator> pWbemLocator;

    // If global variable already initialized, use it
    if (g_pWbemServices)
    {
        *ppServices = g_pWbemServices;
        (*ppServices)->AddRef();
        goto End;
    }

    // First we have the get the IWbemLocator object with a CoCreateInstance.
    hRes = CoCreateInstance(CLSID_WbemAdministrativeLocator, NULL, 
                            CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER,
                            IID_IUnknown, (void **)&pWbemLocator);
    if (FAILED(hRes))
    {
        ErrorTrace(TRACE_ID, "CoCreateInstance failed to create IWbemAdministrativeLocator.");
        goto End;
    }

    // Then we connect to the WMI server for the local CIMV2 namespace.
    hRes = pWbemLocator->ConnectServer(CComBSTR(CIM_NAMESPACE), NULL, NULL, NULL, 0, NULL, NULL, ppServices);
    if (FAILED(hRes))
    {
        ErrorTrace(TRACE_ID, "ConnectServer failed to connect to cimv2 namespace.");
        goto End;
    }

    // Store it in the global variable

    g_pWbemServices = *ppServices;
    (*ppServices)->AddRef(); // CODEWORK: check out why this stops fault on NET STOP WINMGMT

End :
    TraceFunctLeave();
    return hRes;
}

//-----------------------------------------------------------------------------
// Executes the WQL query and returns the enumerated list
//-----------------------------------------------------------------------------

HRESULT ExecWQLQuery(IEnumWbemClassObject **ppEnumInst, BSTR bstrQuery)
{
    TraceFunctEnter("::ExecWQLQuery");

    HRESULT                     hRes;
    CComPtr<IWbemServices>      pWbemServices;

    // Get pointer to WbemServices
    hRes = GetWbemServices(&pWbemServices);
    if (FAILED(hRes))
        goto End;

    // execute the query
    hRes = pWbemServices->ExecQuery(
        CComBSTR("WQL"),
        bstrQuery,
        WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY,
        NULL,
        ppEnumInst);

    if (FAILED(hRes))
    {
        ErrorTrace(TRACE_ID, "ExecQuery failed.");
        goto End;
    }

End:
    TraceFunctLeave();
    return hRes;
}

//-----------------------------------------------------------------------------
// Copies the property named szFrom from pFrom to the property named szTo in
// to CInstance object pTo.
//-----------------------------------------------------------------------------

HRESULT CopyProperty(IWbemClassObject *pFrom, LPCWSTR szFrom, CInstance *pTo, LPCWSTR szTo)
{
    TraceFunctEnter("::CopyProperty");

    _ASSERT(pFrom && szFrom && pTo && szTo);

    HRESULT     hRes = S_OK;
    CComVariant varValue;
    CComBSTR    bstrFrom(szFrom);

    // First, get the property (as a variant) from the source class object.

    hRes = pFrom->Get(bstrFrom, 0, &varValue, NULL, NULL);
    if (FAILED(hRes))
        ErrorTrace(TRACE_ID, "GetVariant on %s field failed.", szFrom);
    else
    {
        // Then set the variant for the target CInstance object.

        if (!pTo->SetVariant(szTo, varValue))
        {
            ErrorTrace(TRACE_ID, "SetVariant on %s field failed.", szTo);
            hRes = WBEM_E_FAILED;
        }
    }

    TraceFunctLeave();
    return hRes;
}

//-----------------------------------------------------------------------------
// Returns an IWbemClassObject pointer for the CIM_DataFile object represented
// by the bstrFile parameter. The bstrFile parameter should contain the full
// path to the file. If the pServices parameter is non-null, it is used to
// retrieve the file info, otherwise a new (and temporary) services pointer is
// created.
//-----------------------------------------------------------------------------

HRESULT GetCIMDataFile(BSTR bstrFile, IWbemClassObject ** ppFileObject, BOOL fHasDoubleSlashes)
{
    TraceFunctEnter("::GetCIMDataFile");

    HRESULT     hRes = S_OK;
    CComBSTR    bstrObjectPath("\\\\.\\root\\cimv2:CIM_DataFile.Name=\"");
    wchar_t *   pwch;
    UINT        uLen;

    CComPtr<IWbemServices> pWbemServices;
    hRes = GetWbemServices(&pWbemServices);
    if (FAILED(hRes))
        goto END;

    if (bstrFile == NULL || ppFileObject == NULL)
    {
        ErrorTrace(TRACE_ID, "Parameter pointer is null.");
        hRes = WBEM_E_INVALID_PARAMETER;
        goto END;
    }

    // Construct the path for the file we are trying to get. Note, the path needs
    // the have double backslashes for the GetObject call to work. We scan through
    // the string and do this manually here.
    //
    // CODEWORK: there has to be a faster way to do this, although the Append is
    // probably not too expensive, since the BSTR length can be found without
    // scanning the string. Unless it's reallocating more memory as it goes.

    pwch = bstrFile;
    if (fHasDoubleSlashes)
        bstrObjectPath.Append(pwch, SysStringLen(bstrFile));
    else
        for (uLen = SysStringLen(bstrFile); uLen > 0; uLen--)
        {
            if (*pwch == L'\\')
                bstrObjectPath.Append("\\");
            bstrObjectPath.Append(pwch, 1);
            pwch++;
        }
    bstrObjectPath.Append("\"");

    // Make the call to get the CIM_DataFile object.

    hRes = pWbemServices->GetObject(bstrObjectPath, 0, NULL, ppFileObject, NULL);
    if (FAILED(hRes))
        ErrorTrace(TRACE_ID, "GetObject on CIM_DataFile failed.");

END:
    TraceFunctLeave();
    return hRes;
}


//*****************************************************************************
//
// Function Name        :   getCompletePath
//
// Input Parameters     :   bstrFileName
//                              CComBSTR  which represents the file
//                              whose complete path is required. 
// Output Parameters    :   bstrFileWithPathName
//                              CComBSTR  which represents the file
//                              with the Path    
//  Returns             :   BOOL 
//                              TRUE      if bstrFileWithPathName can be set.
//                              FALSE     if bstrFileWithPathName cannot be set.
//                      
//
//  Synopsis            :   Given a file name (bstrFileName) this function
//                          searches the "System" directory for the existence
//                          of the file. 
//
//                          If it finds the file it pre appends the directory 
//                          path to the input file and  copies into the output
//                          file (bstrFileWithPathName).
//                          
//                          If it doesnot find the file in "System" directory
//                          searches for the file in "Windows" Directoy and does
//                          the same as above.
//
//*****************************************************************************



BOOL getCompletePath(CComBSTR bstrFileName, CComBSTR &bstrFileWithPathName)
{

    //  Return
    BOOL                            bFoundFile              =   FALSE;

    ULONG                           uiReturn;

    TCHAR                           szDirectory[MAX_PATH];
    TCHAR                           temp[MAX_PATH];
    TCHAR                           lpstrTemp[MAX_PATH];

    struct _stat                    filestat;

    CComVariant                     varValue                =    NULL;

    CComBSTR                        bstrDirectory;


    //  Check for the File in the System Directory
    uiReturn = GetSystemDirectory(szDirectory, MAX_PATH);
    if (uiReturn != 0 && uiReturn < MAX_PATH)
    {
        bstrDirectory = szDirectory;
        bstrDirectory.Append("\\");
        bstrDirectory.Append(bstrFileName);

        USES_CONVERSION;
        int Result = _tstat(W2T(bstrDirectory), &filestat) ;
        if (Result == 0)
        {
            bstrFileWithPathName = bstrDirectory;
            bFoundFile = TRUE;
        }
    }

    // If not there, then check in the windows directory.
    if (!bFoundFile)
    {
        uiReturn = GetWindowsDirectory(szDirectory, MAX_PATH);
        if (uiReturn != 0 && uiReturn < MAX_PATH)
        {
            bstrDirectory = szDirectory;
            bstrDirectory.Append("\\");
            bstrDirectory.Append(bstrFileName);

            USES_CONVERSION;
            int Result = _tstat(W2T(bstrDirectory), &filestat) ;
            if (Result == 0)
            {
                bstrFileWithPathName = bstrDirectory;
                bFoundFile = TRUE;
            }
        }
    } 
    return(bFoundFile);
}

// Used by GetCim32NetDll and FreeCim32NetDll.
CCritSec g_csCim32Net;
HINSTANCE s_Handle = NULL;

// There is a problem with loading Cim32Net.dll over and over, so this code
// makes sure we only load it once, then unloads it at exit.
// these are used with GetCim32NetHandle

void FreeCim32NetHandle()
{
    if (s_Handle)
    {
        FreeLibrary(s_Handle);
        s_Handle = NULL;
    }
}

HINSTANCE GetCim32NetHandle()
{
    // Have we ever loaded it before?
    if (s_Handle == NULL)
    {
        // Avoid contention on static
        g_csCim32Net.Enter();

        // Check for race condition
        if (s_Handle == NULL)
        {
            s_Handle = LoadLibrary(_T("Cim32Net.dll"));

            // Register to free the handle at exit
            // NO! bad....badddd juju... call from FlushAll instead (o.w., when
            // cimwin32.dll unloads this pointer is invalid, but atexit gets
            // called when framedyn.dll unloads)
            // atexit(FreeCim32NetHandle);
        }
        g_csCim32Net.Leave();
    }

    // By re-opening the handle, we ensure proper refcounting on the handle,
    // and facilitate leak checking.
    HINSTANCE hHandle = LoadLibrary(_T("Cim32Net.dll"));

    return hHandle;
}

//
// Given a delimited string, convert tokens into strings and store them into an array
// returns the number of tokens parsed. Caller is responsible for freeing up the memory
// allocated using delete
//
#ifndef UNICODE
int DelimitedStringToArray(LPWSTR strString, LPTSTR strDelimiter, LPTSTR apstrArray[], int iMaxArraySize)
{
    USES_CONVERSION;
    LPTSTR szString = W2A(strString);
    return DelimitedStringToArray(szString, strDelimiter, apstrArray, iMaxArraySize);
}
#endif

int DelimitedStringToArray(LPTSTR strString, LPTSTR strDelimiter, LPTSTR apstrArray[], int iMaxArraySize)
{
    // make a copy of the string to begin parsing
    LPTSTR strDelimitedString = (TCHAR *) new TCHAR [_tcslen(strString) + 1];

    // if out of memory, just return error value -1
    if (!strDelimitedString)
        return -1;
        
    // copy the token into the new allocated string
    _tcscpy(strDelimitedString, strString);
    
    // initialize _tcstok
    LPTSTR strTok = _tcstok(strDelimitedString, strDelimiter);
    int iCount = 0;

    // loop through all tokens parsed
    while ((strTok) && (iCount < iMaxArraySize))
    {
        LPTSTR strNewTok = (TCHAR *) new TCHAR[_tcslen(strTok) + 1];

        // if out of memory, just return error value -1
        if (!strNewTok)
            return -1;
        
        // copy the token into the new allocated string
        _tcscpy(strNewTok, strTok);

        // save it in the array
        apstrArray[iCount] = strNewTok;

        // increment the index
        iCount++;

        // get the next token
        strTok = _tcstok(NULL, strDelimiter);
    }

    // free up the memory used
    delete [] strDelimitedString;

    return iCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprovn\pch_bios.h ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_BIOS.H

Abstract:
	WBEM provider class definition for PCH_BIOS class

Revision History:

	Ghim-Sim Chua       (gschua)   05/05/99
		- Created

********************************************************************/

// Property set identification
//============================

#ifndef _PCH_BIOS_H_
#define _PCH_BIOS_H_

#define PROVIDER_NAME_PCH_BIOS "PCH_BIOS"

// Property name externs -- defined in PCH_BIOS.cpp
//=================================================

extern const WCHAR* pBIOSDate ;
extern const WCHAR* pBIOSName ;
extern const WCHAR* pBIOSVersion ;
extern const WCHAR* pCPU ;
extern const WCHAR* pINFName ;
extern const WCHAR* pMachineType ;
extern const WCHAR* pMediaID ;
extern const WCHAR* pChange;
extern const WCHAR* pTimeStamp;

class CPCH_BIOS : public Provider 
{
	public:
		// Constructor/destructor
		//=======================

		CPCH_BIOS(const CHString& chsClassName, LPCWSTR lpszNameSpace) : Provider(chsClassName, lpszNameSpace) {};
        virtual ~CPCH_BIOS() {};

	protected:
		// Reading Functions
		//============================
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Writing Functions
		//============================
		virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Other Functions
		virtual HRESULT ExecMethod( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags = 0L ) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprovn\pch_cdrom.h ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_CDROM.H

Abstract:
	WBEM provider class definition for PCH_CDROM class

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

********************************************************************/

// Property set identification
//============================

#ifndef _PCH_CDROM_H_
#define _PCH_CDROM_H_

#define PROVIDER_NAME_PCH_CDROM "PCH_CDROM"

// Property name externs -- defined in PCH_CDROM.cpp
//=================================================

extern const WCHAR* pChange ;
extern const WCHAR* pTimeStamp ;
extern const WCHAR* pDataTransferIntegrity ;
extern const WCHAR* pDescription ;
extern const WCHAR* pDeviceID ;
extern const WCHAR* pDriveLetter ;
extern const WCHAR* pManufacturer ;
extern const WCHAR* pSCSITargetID ;
extern const WCHAR* pTransferRateKBS ;
extern const WCHAR* pVolumeName ;

class CPCH_CDROM : public Provider 
{
	public:
		// Constructor/destructor
		//=======================

		CPCH_CDROM(const CHString& chsClassName, LPCWSTR lpszNameSpace) : Provider(chsClassName, lpszNameSpace) {};
		virtual ~CPCH_CDROM() {};

	protected:
		// Reading Functions
		//============================
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Writing Functions
		//============================
		virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Other Functions
		virtual HRESULT ExecMethod( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags = 0L ) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprovn\pch_cdrom.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    PCH_CDROM.CPP

Abstract:
    WBEM provider class implementation for PCH_CDROM class

Revision History:

    Ghim-Sim Chua       (gschua)   04/27/99
        - Created

    Ghim-Sim Chua       (gschua)   05/02/99
        - Modified code to use CopyProperty function
        - Use CComBSTR instead of USES_CONVERSION

********************************************************************/

#include "pchealth.h"
#include "PCH_CDROM.h"

/////////////////////////////////////////////////////////////////////////////
//  tracing stuff

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile
#define TRACE_ID    DCID_CDROM

CPCH_CDROM MyPCH_CDROMSet (PROVIDER_NAME_PCH_CDROM, PCH_NAMESPACE) ;

// Property names
//===============
const static WCHAR* pTimeStamp = L"TimeStamp" ;
const static WCHAR* pChange = L"Change" ;
const static WCHAR* pDataTransferIntegrity = L"DataTransferIntegrity" ;
const static WCHAR* pDescription = L"Description" ;
const static WCHAR* pDeviceID = L"DeviceID" ;
const static WCHAR* pDriveLetter = L"DriveLetter" ;
const static WCHAR* pManufacturer = L"Manufacturer" ;
const static WCHAR* pSCSITargetID = L"SCSITargetID" ;
const static WCHAR* pTransferRateKBS = L"TransferRateKBS" ;
const static WCHAR* pVolumeName = L"VolumeName" ;

/*****************************************************************************
*
*  FUNCTION    :    CPCH_CDROM::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                       WBEM_FLAG_DEEP
*                       WBEM_FLAG_SHALLOW
*                       WBEM_FLAG_RETURN_IMMEDIATELY
*                       WBEM_FLAG_FORWARD_ONLY
*                       WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    : TO DO: All instances on the machine should be returned here.
*                       If there are no instances, return WBEM_S_NO_ERROR.
*                       It is not an error to have no instances.
*
*****************************************************************************/
HRESULT
CPCH_CDROM::EnumerateInstances(
    MethodContext* pMethodContext,
    long lFlags
    )
{
    TraceFunctEnter("CPCH_CDROM::EnumerateInstances");

    HRESULT                             hRes = WBEM_S_NO_ERROR;
    REFPTRCOLLECTION_POSITION           posList;
    CComPtr<IEnumWbemClassObject>       pEnumInst;
    IWbemClassObjectPtr                 pObj;
    ULONG                               ulRetVal;

    //
    // Get the date and time
    //
	SYSTEMTIME stUTCTime;
	GetSystemTime(&stUTCTime);

    //
    // Execute the query
    //
    hRes = ExecWQLQuery(&pEnumInst, CComBSTR("SELECT DeviceID, Drive, VolumeName, TransferRate, DriveIntegrity, Description, SCSITargetId, Manufacturer FROM Win32_CDROMDrive"));
    if (FAILED(hRes))
        goto END;

	//
	// enumerate the instances from win32_CodecFile
	//
    while (WBEM_S_NO_ERROR == pEnumInst->Next(WBEM_INFINITE, 1, &pObj, &ulRetVal))
    {
        // Create a new instance based on the passed-in MethodContext. If this fails,
        // we don't need to check for a null pointer because it throws an exception.

        CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);
        CComVariant  varValue;

        if (!pInstance->SetDateTime(pTimeStamp, WBEMTime(stUTCTime)))
            ErrorTrace(TRACE_ID, "SetDateTime on Timestamp Field failed.");

        if (!pInstance->SetCHString(pChange, L"Snapshot"))
            ErrorTrace(TRACE_ID, "SetCHString on Change Field failed.");

        (void)CopyProperty(pObj, L"DriveIntegrity", pInstance, pDataTransferIntegrity);
        (void)CopyProperty(pObj, L"Description", pInstance, pDescription);
        (void)CopyProperty(pObj, L"DeviceID", pInstance, pDeviceID);
        (void)CopyProperty(pObj, L"Drive", pInstance, pDriveLetter);
        (void)CopyProperty(pObj, L"Manufacturer", pInstance, pManufacturer);
        (void)CopyProperty(pObj, L"SCSITargetId", pInstance, pSCSITargetID);
        (void)CopyProperty(pObj, L"TransferRate", pInstance, pTransferRateKBS);
        (void)CopyProperty(pObj, L"VolumeName", pInstance, pVolumeName);

    	hRes = pInstance->Commit();
        if (FAILED(hRes))
            ErrorTrace(TRACE_ID, "Commit on Instance failed.");
  }

END :
    TraceFunctLeave();
    return hRes ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprovn\pch_codec.h ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_Codec.H

Abstract:
	WBEM provider class definition for PCH_Codec class

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

********************************************************************/

// Property set identification
//============================

#ifndef _PCH_Codec_H_
#define _PCH_Codec_H_

#define PROVIDER_NAME_PCH_CODEC "PCH_Codec"

// Property name externs -- defined in PCH_Codec.cpp
//=================================================

extern const WCHAR* pCategory ;
extern const WCHAR* pTimeStamp ;
extern const WCHAR* pChange ;
extern const WCHAR* pCodecDriver ;
extern const WCHAR* pDate ;
extern const WCHAR* pDescription ;
extern const WCHAR* pGroupName ;
extern const WCHAR* pkey ;
extern const WCHAR* pSize ;
extern const WCHAR* pVersion ;

class CPCH_Codec : public Provider 
{
	public:
		// Constructor/destructor
		//=======================

		CPCH_Codec(const CHString& chsClassName, LPCWSTR lpszNameSpace) : Provider(chsClassName, lpszNameSpace) {};
		virtual ~CPCH_Codec() {};

	protected:
		// Reading Functions
		//============================
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Writing Functions
		//============================
		virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Other Functions
		virtual HRESULT ExecMethod( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags = 0L ) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprovn\dllutils.cpp ===
#include "pchealth.h"
#include <FWcommon.h>
#include <strings.h>

#include <DllUtils.h>
#include <BrodCast.h>
#include <lmerr.h>
#include <confgmgr.h>
#include <createmutexasprocess.h>

// sets a status object with one single missing privilege
void SetSinglePrivilegeStatusObject(MethodContext* pContext, const WCHAR* pPrivilege)
{
	SAFEARRAY *psaPrivilegesReqd, *psaPrivilegesNotHeld;  
	SAFEARRAYBOUND rgsabound[1];
	rgsabound[0].cElements = 1;
	rgsabound[0].lLbound = 0;
	psaPrivilegesReqd = SafeArrayCreate(VT_BSTR, 1, rgsabound);
	psaPrivilegesNotHeld = SafeArrayCreate(VT_BSTR, 1, rgsabound);
    
    if (psaPrivilegesReqd && psaPrivilegesNotHeld)
    {
        long index = 0;
        bstr_t privilege(pPrivilege);
        SafeArrayPutElement(psaPrivilegesReqd, &index, (void*)(BSTR)privilege);
        SafeArrayPutElement(psaPrivilegesNotHeld, &index, (void*)(BSTR)privilege);
        CWbemProviderGlue::SetStatusObject(pContext, IDS_CimWin32Namespace, "Required privilege not enabled", WBEM_E_FAILED, psaPrivilegesNotHeld, psaPrivilegesReqd);
    }

    if (psaPrivilegesNotHeld) 
        SafeArrayDestroy(psaPrivilegesNotHeld);
    if (psaPrivilegesReqd)
        SafeArrayDestroy(psaPrivilegesReqd);
}

// VER_PLATFORM_WIN32s Win32s on Windows 3.1 
// VER_PLATFORM_WIN32_WINDOWS  Win32 on Windows 95
// VER_PLATFORM_WIN32_NT   Windows NT 
DWORD GetPlatformID(void) 
{
	OSVERSIONINFO OsVersion;

	OsVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	GetVersionEx((LPOSVERSIONINFO)&OsVersion);

	return OsVersion.dwPlatformId;	
}

// 3 for NT 3.51
// 4 for NT 4.0, W95 & W98
DWORD GetPlatformMajorVersion(void) 
{
	OSVERSIONINFO OsVersion;

	OsVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	GetVersionEx((LPOSVERSIONINFO)&OsVersion);

	return OsVersion.dwMajorVersion;	
}

// 0 for W95, 10 for 98
DWORD GetPlatformMinorVersion(void) 
{
	OSVERSIONINFO OsVersion;

	OsVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	GetVersionEx((LPOSVERSIONINFO)&OsVersion);

	return OsVersion.dwMinorVersion;	
}

// returns TRUE iff the current OS is Win 98+ 
// false for NT or Win 95
bool  IsWin98(void)
{
	OSVERSIONINFO OsVersion;

	OsVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	GetVersionEx((LPOSVERSIONINFO)&OsVersion);

	return (OsVersion.dwPlatformId == (VER_PLATFORM_WIN32_WINDOWS) && (OsVersion.dwMinorVersion >= 10));	
}

bool IsWinNT5(void)
{
	OSVERSIONINFO OsVersion;
	OsVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	GetVersionEx((LPOSVERSIONINFO)&OsVersion);

	return(OsVersion.dwPlatformId == (VER_PLATFORM_WIN32_NT) && (OsVersion.dwMajorVersion >= 5));
}	

bool IsWinNT4(void)
{
	OSVERSIONINFO OsVersion;
	OsVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	GetVersionEx((LPOSVERSIONINFO)&OsVersion);

	return(OsVersion.dwPlatformId == (VER_PLATFORM_WIN32_NT) && (OsVersion.dwMajorVersion == 4));
}	

bool IsWinNT351(void)
{
	OSVERSIONINFO OsVersion;
	OsVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	GetVersionEx((LPOSVERSIONINFO)&OsVersion);

	return	(	OsVersion.dwPlatformId		==	VER_PLATFORM_WIN32_NT
			&&	OsVersion.dwMajorVersion	==	3
			&&	OsVersion.dwMinorVersion	==	51 );
}	

/////////////////////////////////////////////////////////////////////
void LogEnumValueError( char * szFile, DWORD dwLine, char * szKey, char * szId )
{
	if (IsErrorLoggingEnabled())
	{
		CHString gazotta;
		gazotta.Format(ERR_REGISTRY_ENUM_VALUE_FOR_KEY, szId, szKey);
		LogErrorMessageEx((const char *)gazotta, szFile, dwLine);
	}
}
/////////////////////////////////////////////////////////////////////
void LogOpenRegistryError( char * szFile, DWORD dwLine, char * szKey )
{
	if (IsErrorLoggingEnabled())
	{
		CHString gazotta;
		gazotta.Format(ERR_OPEN_REGISTRY, szKey);
		
		LogErrorMessageEx((const char *)gazotta, szFile, dwLine);
	}
}
/////////////////////////////////////////////////////////////////////
// left in for hysterical purposes 
// prefer to use LogMessage macro in BrodCast.h
void LogError( char * szFile, DWORD dwLine, char * szKey )
{
	LogErrorMessageEx(szKey, szFile, dwLine);	
}
/////////////////////////////////////////////////////////////////////
void LogLastError( char * szFile, DWORD dwLine )
{
	if (IsErrorLoggingEnabled())
	{
		DWORD duhWord = GetLastError();
		CHString gazotta;
		gazotta.Format(IDS_GETLASTERROR, duhWord, duhWord);

		LogErrorMessageEx(gazotta, szFile, dwLine);	
    }
}

///////////////////////////////////////////////////////////////////////
BOOL GetValue( CRegistry & Reg, 
               char * szKey,
               char * ValueName, 
               CHString * pchsValueBuffer )
{
    BOOL bRet = (Reg.GetCurrentKeyValue( ValueName, *pchsValueBuffer) == ERROR_SUCCESS);
	
	if( !bRet )
        LogEnumValueError(__FILE__,__LINE__, szKey, ValueName); 

    return bRet;
}
///////////////////////////////////////////////////////////////////////
BOOL GetValue( CRegistry & Reg, 
               char * szKey,
               char * ValueName, 
               DWORD * dwValueBuffer )
{
    BOOL bRet = (Reg.GetCurrentKeyValue( ValueName, *dwValueBuffer) == ERROR_SUCCESS);
		
	if( !bRet )
        LogEnumValueError(__FILE__,__LINE__, szKey, ValueName); 

    return bRet;
}
///////////////////////////////////////////////////////////////////////
BOOL OpenAndGetValue( CRegistry & Reg, 
                      char * szKey,
                      char * ValueName, 
                      CHString * pchsValueBuffer )
{
	BOOL bRet = ( Reg.OpenLocalMachineKeyAndReadValue( szKey, ValueName, *pchsValueBuffer )== ERROR_SUCCESS);
    
	if( !bRet )
        LogEnumValueError(__FILE__,__LINE__, szKey, ValueName); 

    return bRet;
}
///////////////////////////////////////////////////////////////////////
BOOL GetBinaryValue( CRegistry & Reg, char * szKey, 
                     char * ValueName, CHString * pchsValueBuffer )
{
    BOOL bRet = ( Reg.GetCurrentBinaryKeyValue( ValueName, *pchsValueBuffer) == ERROR_SUCCESS);

    if( !bRet )
        (LogEnumValueError(__FILE__,__LINE__, szKey, ValueName)); 

    return bRet;
}

/*****************************************************************************
 *
 *  FUNCTION    : GetDeviceParms
 *
 *  DESCRIPTION : Gets drive characteristics (heads, tracks, cylinders, etc)
 *
 *  INPUTS      : Pointer to a DEVICEPARMS struct to receive the data
 *                Drive number of the drive to query (0 = default drive, 
 *                   1 = A, 2 = B, and so on)
 *
 *  OUTPUTS     : 
 *
 *  RETURNS     : TRUE if successful, FALSE otherwise
 *
 *  COMMENTS    : 
 *
 *****************************************************************************/

BOOL GetDeviceParms(PDEVICEPARMS pstDeviceParms, UINT nDrive)
{
    DEVIOCTL_REGISTERS reg;
    memset(&reg, '\0', sizeof(DEVIOCTL_REGISTERS));

    reg.reg_EAX = 0x440D;       /* IOCTL for block devices */
    reg.reg_EBX = nDrive;       /* zero-based drive ID     */
    reg.reg_ECX = 0x0860;       /* Get Media ID command    */
    reg.reg_EDX = (DWORD) pstDeviceParms;

    memset(pstDeviceParms, 0, sizeof(DEVICEPARMS));

    if (!VWIN32IOCTL(&reg, VWIN32_DIOC_DOS_IOCTL))
        return FALSE;

    if (reg.reg_Flags & 0x8000) /* error if carry flag set */
        return FALSE;

    return TRUE;
}

/*****************************************************************************
 *
 *  FUNCTION    : GetDriveMapInfo
 *
 *  DESCRIPTION : Gets logical to physical mapping info
 *
 *  INPUTS      : Pointer to a DRIVE_MAP_INFO struct to receive the data
 *                Drive number of the drive to query (0 = default drive, 
 *                   1 = A, 2 = B, and so on)
 *
 *  OUTPUTS     : 
 *
 *  RETURNS     : TRUE if successful, FALSE otherwise
 *
 *  COMMENTS    : 
 *
 *****************************************************************************/

BOOL GetDriveMapInfo(PDRIVE_MAP_INFO pDriveMapInfo, UINT nDrive)
{
   DEVIOCTL_REGISTERS reg;
   memset(&reg, '\0', sizeof(DEVIOCTL_REGISTERS));

   reg.reg_EAX = 0x440d;      /* IOCTL for block devices */
   reg.reg_EBX = nDrive;      /* zero-based drive ID     */
   reg.reg_ECX = 0x086f;      /* Get Drive Map Info */
   reg.reg_EDX = (DWORD) pDriveMapInfo;

   // zero the struct
   memset(pDriveMapInfo, 0, sizeof(DRIVE_MAP_INFO));

   // Set the length byte
   pDriveMapInfo->btAllocationLength = sizeof(DRIVE_MAP_INFO);

   // Doit
   if (!VWIN32IOCTL(&reg, VWIN32_DIOC_DOS_IOCTL))
      return FALSE;

   if (reg.reg_Flags & 0x8000) {/* error if carry flag set */
      return FALSE;
   }

   return TRUE;

}

/*****************************************************************************
 *
 *  FUNCTION    : Get_ExtFreeSpace
 *
 *  DESCRIPTION : Gets detailed info about a partition
 *
 *  INPUTS      : Drive number of the drive to query (0 = default drive, 
 *                   1 = A, 2 = B, and so on)
 *                Pointer to ExtGetDskFreSpcStruct
 *
 *  OUTPUTS     : 
 *
 *  RETURNS     : TRUE if successful, FALSE otherwise
 *
 *  COMMENTS    : 
 *
 *****************************************************************************/

BOOL Get_ExtFreeSpace(BYTE btDriveName, ExtGetDskFreSpcStruc *pstExtGetDskFreSpcStruc)
{
   DEVIOCTL_REGISTERS reg;
   memset(&reg, '\0', sizeof(DEVIOCTL_REGISTERS));
   char szDrive[4];

   szDrive[0] = btDriveName;
   szDrive[1] = ':';
   szDrive[2] = '\\';
   szDrive[3] = '\0';

   reg.reg_EAX = 0x7303;							// Get_ExtFreeSpace
   reg.reg_ECX = sizeof(ExtGetDskFreSpcStruc);		// Size of the structure sent in
   reg.reg_EDI = (DWORD)pstExtGetDskFreSpcStruc;	// Structure
   reg.reg_EDX = (DWORD)szDrive;					// Drive to get info for

   // zero the struct
   memset(pstExtGetDskFreSpcStruc, 0, sizeof(ExtGetDskFreSpcStruc));

   // Doit
   if (!VWIN32IOCTL(&reg, VWIN32_DIOC_DOS_DRIVEINFO))
      return FALSE;

   if (reg.reg_Flags & 0x8000) {/* error if carry flag set */
      return FALSE;
   }

   return TRUE;

}

/*****************************************************************************
 *
 *  FUNCTION    : VWIN32IOCTL
 *
 *  DESCRIPTION : Calls IOControl against the vwin32 vxd
 *
 *  INPUTS      : Pointer to DEVIOCTL_REGISTERS structure
 *                IOControl call number.
 *
 *  OUTPUTS     : 
 *
 *  RETURNS     : TRUE if successful, FALSE otherwise
 *
 *  COMMENTS    : 
 *
 *****************************************************************************/

BOOL VWIN32IOCTL(PDEVIOCTL_REGISTERS preg, DWORD dwCall)
{
    HANDLE hDevice;

    BOOL fResult;
    DWORD cb;

    preg->reg_Flags = 0x8000; /* assume error (carry flag set) */

	hDevice = CreateFile("\\\\.\\VWIN32", 0, 0, 0, OPEN_EXISTING,
						FILE_FLAG_DELETE_ON_CLOSE, 0);

   if (hDevice == (HANDLE) INVALID_HANDLE_VALUE) {
      return FALSE;
   } else {
      fResult = DeviceIoControl(hDevice, dwCall, preg, sizeof(*preg), preg, sizeof(*preg), &cb, 0);
    }

    CloseHandle(hDevice);

    if (!fResult) {
       return FALSE;
    }

    return TRUE;
}

CHString GetFileTypeDescription(char *szExtension) 
{
   CRegistry RegInfo;
   CHString sTemp, sType(szExtension);

   if (RegInfo.Open(HKEY_CLASSES_ROOT, szExtension, KEY_READ) == ERROR_SUCCESS) {
      RegInfo.GetCurrentKeyValue("", sTemp);

      if (RegInfo.Open(HKEY_CLASSES_ROOT, sTemp, KEY_READ) == ERROR_SUCCESS) {
         RegInfo.GetCurrentKeyValue("", sType);
      }
   }

   return sType;
}
///////////////////////////////////////////////////////////////////
//
// Define the severity codes
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error

//
// Define the severity codes
//
//
// Define the severity codes
//
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3
#define SEV_MASK 0xC0000000
void TranslateNTStatus( DWORD dwStatus, CHString & chsValue)
{

	switch((dwStatus & SEV_MASK) >> 30){

		case STATUS_SEVERITY_WARNING:
			chsValue = IDS_STATUS_Degraded;
			break;

		case STATUS_SEVERITY_SUCCESS:
			chsValue = IDS_STATUS_OK;
			break;

		case STATUS_SEVERITY_ERROR:
			chsValue = IDS_STATUS_Error;
			break;

		case STATUS_SEVERITY_INFORMATIONAL:
			chsValue = IDS_STATUS_OK;
			break;
	
		default:
			chsValue = IDS_STATUS_Unknown;
	}
}

BOOL GetVarFromVersionInfo(LPCTSTR szFile, LPCTSTR szVar, CHString &strValue)
{
	BOOL    fRc = FALSE;
	DWORD   dwTemp,